{"commit_id": "3eb6764acd2d708f6873c177a77f9bef3b266fa9", "project": "libuv", "func": "static int uv__rwlock_fallback_init(uv_rwlock_t* rwlock) {\n  /* Initialize the semaphore that acts as the write lock. */\n  HANDLE handle = CreateSemaphoreW(NULL, 1, 1, NULL);\n  if (handle == NULL)\n    return uv_translate_sys_error(GetLastError());\n  rwlock->fallback_.write_lock_.sem = handle;\n\n  /* Initialize the critical section protecting the reader count. */\n  InitializeCriticalSection(&rwlock->fallback_.read_lock_.cs);\n\n  /* Initialize the reader count. */\n  rwlock->fallback_.num_readers_ = 0;\n\n  return 0;\n}", "target": 2, "idx": 9656}
{"commit_id": "0ab290774f91a23bebe30a358fde4e53ab4876a0", "project": "tensorflow", "func": "void Compute(OpKernelContext* ctx) override {\n    const Tensor& in0 = ctx->input(0);\n    const Tensor& in1 = ctx->input(1);\n\n    ValidateInputTensors(ctx, in0, in1);\n    if (!ctx->status().ok()) return;\n\n    MatMulBCast bcast(in0.shape().dim_sizes(), in1.shape().dim_sizes());\n    OP_REQUIRES(\n        ctx, bcast.IsValid(),\n        errors::InvalidArgument(\n            \"In[0] and In[1] must have compatible batch dimensions: \",\n            in0.shape().DebugString(), \" vs. \", in1.shape().DebugString()));\n\n    TensorShape out_shape = bcast.output_batch_shape();\n    auto batch_size = bcast.output_batch_size();\n    auto d0 = in0.dim_size(in0.dims() - 2);  // Band size.\n    auto d1 = in0.dim_size(in0.dims() - 1);\n    Tensor in0_reshaped;\n    OP_REQUIRES(\n        ctx,\n        in0_reshaped.CopyFrom(in0, TensorShape({bcast.x_batch_size(), d0, d1})),\n        errors::Internal(\"Failed to reshape In[0] from \",\n                         in0.shape().DebugString()));\n    auto d2 = in1.dim_size(in1.dims() - 2);\n    auto d3 = in1.dim_size(in1.dims() - 1);\n    Tensor in1_reshaped;\n    OP_REQUIRES(\n        ctx,\n        in1_reshaped.CopyFrom(in1, TensorShape({bcast.y_batch_size(), d2, d3})),\n        errors::Internal(\"Failed to reshape In[1] from \",\n                         in1.shape().DebugString()));\n    OP_REQUIRES(ctx, d1 == d2,\n                errors::InvalidArgument(\n                    \"In[0] mismatch In[1] shape: \", d1, \" vs. \", d2, \": \",\n                    in0.shape().DebugString(), \" \", in1.shape().DebugString(),\n                    \" \", lower_, \" \", adjoint_));\n    out_shape.AddDim(d1);\n    out_shape.AddDim(d3);\n    Tensor* out = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, out_shape, &out));\n    if (out->NumElements() == 0) {\n      return;\n    }\n    Tensor out_reshaped;\n    OP_REQUIRES(ctx,\n                out_reshaped.CopyFrom(*out, TensorShape({batch_size, d1, d3})),\n                errors::Internal(\"Failed to reshape output from \",\n                                 out->shape().DebugString()));\n    LaunchBatchBandedTriangularSolve<Scalar>::Launch(\n        ctx, in0_reshaped, in1_reshaped, adjoint_, lower_, bcast,\n        &out_reshaped);\n  }", "target": 0, "idx": 9657}
{"commit_id": "3cbb6fbcc7077d94161ec95b7bc1421671317c65", "project": "pdfium", "func": "static OPJ_BOOL opj_j2k_read_SPCod_SPCoc(  opj_j2k_t *p_j2k,\n                                                                OPJ_UINT32 compno,\n                                                                OPJ_BYTE * p_header_data,\n                                                                OPJ_UINT32 * p_header_size,\n                                                                opj_event_mgr_t * p_manager)\n{\n        OPJ_UINT32 i, l_tmp;\n        opj_cp_t *l_cp = NULL;\n        opj_tcp_t *l_tcp = NULL;\n        opj_tccp_t *l_tccp = NULL;\n        OPJ_BYTE * l_current_ptr = NULL;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_header_data != 00);\n\n        l_cp = &(p_j2k->m_cp);\n        l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH) ?\n                                &l_cp->tcps[p_j2k->m_current_tile_number] :\n                                p_j2k->m_specific_param.m_decoder.m_default_tcp;\n\n        /* precondition again */\n        if (compno >= p_j2k->m_private_image->numcomps) {\n                return OPJ_FALSE;\n        }\n\n        l_tccp = &l_tcp->tccps[compno];\n        l_current_ptr = p_header_data;\n\n        /* make sure room is sufficient */\n        if (*p_header_size < 5) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading SPCod SPCoc element\\n\");\n                return OPJ_FALSE;\n        }\n\n        opj_read_bytes(l_current_ptr, &l_tccp->numresolutions ,1);              /* SPcox (D) */\n        ++l_tccp->numresolutions;                                                                               /* tccp->numresolutions = read() + 1 */\n        if (l_tccp->numresolutions > OPJ_J2K_MAXRLVLS) {\n                opj_event_msg(p_manager, EVT_ERROR,\n                              \"Invalid value for numresolutions : %d, max value is set in openjpeg.h at %d\\n\",\n                              l_tccp->numresolutions, OPJ_J2K_MAXRLVLS);\n                return OPJ_FALSE;\n        }\n        ++l_current_ptr;\n\n        /* If user wants to remove more resolutions than the codestream contains, return error */\n        if (l_cp->m_specific_param.m_dec.m_reduce >= l_tccp->numresolutions) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error decoding component %d.\\nThe number of resolutions to remove is higher than the number \"\n                                        \"of resolutions of this component\\nModify the cp_reduce parameter.\\n\\n\", compno);\n                p_j2k->m_specific_param.m_decoder.m_state |= 0x8000;/* FIXME J2K_DEC_STATE_ERR;*/\n                return OPJ_FALSE;\n        }\n\n        opj_read_bytes(l_current_ptr,&l_tccp->cblkw ,1);                /* SPcoc (E) */\n        ++l_current_ptr;\n        l_tccp->cblkw += 2;\n\n        opj_read_bytes(l_current_ptr,&l_tccp->cblkh ,1);                /* SPcoc (F) */\n        ++l_current_ptr;\n        l_tccp->cblkh += 2;\n\n        if ((l_tccp->cblkw > 10) || (l_tccp->cblkh > 10) || ((l_tccp->cblkw + l_tccp->cblkh) > 12)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading SPCod SPCoc element, Invalid cblkw/cblkh combination\\n\");\n                return OPJ_FALSE;\n        }\n\t\n\n        opj_read_bytes(l_current_ptr,&l_tccp->cblksty ,1);              /* SPcoc (G) */\n        ++l_current_ptr;\n\n        opj_read_bytes(l_current_ptr,&l_tccp->qmfbid ,1);               /* SPcoc (H) */\n        ++l_current_ptr;\n\n        *p_header_size = *p_header_size - 5;\n\n        /* use custom precinct size ? */\n        if (l_tccp->csty & J2K_CCP_CSTY_PRT) {\n                if (*p_header_size < l_tccp->numresolutions) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Error reading SPCod SPCoc element\\n\");\n                        return OPJ_FALSE;\n                }\n\n                for     (i = 0; i < l_tccp->numresolutions; ++i) {\n                        opj_read_bytes(l_current_ptr,&l_tmp ,1);                /* SPcoc (I_i) */\n                        ++l_current_ptr;\n                        /* Precinct exponent 0 is only allowed for lowest resolution level (Table A.21) */\n                        if ((i != 0) && (((l_tmp & 0xf) == 0) || ((l_tmp >> 4) == 0))) {\n                                opj_event_msg(p_manager, EVT_ERROR, \"Invalid precinct size\\n\");\n                                return OPJ_FALSE;\n                        }\n                        l_tccp->prcw[i] = l_tmp & 0xf;\n                        l_tccp->prch[i] = l_tmp >> 4;\n                }\n\n                *p_header_size = *p_header_size - l_tccp->numresolutions;\n        }\n        else {\n                /* set default size for the precinct width and height */\n                for     (i = 0; i < l_tccp->numresolutions; ++i) {\n                        l_tccp->prcw[i] = 15;\n                        l_tccp->prch[i] = 15;\n                }\n        }\n\n#ifdef WIP_REMOVE_MSD\n        /* INDEX >> */\n        if (p_j2k->cstr_info && compno == 0) {\n                OPJ_UINT32 l_data_size = l_tccp->numresolutions * sizeof(OPJ_UINT32);\n\n                p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].tccp_info[compno].cblkh = l_tccp->cblkh;\n                p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].tccp_info[compno].cblkw = l_tccp->cblkw;\n                p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].tccp_info[compno].numresolutions = l_tccp->numresolutions;\n                p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].tccp_info[compno].cblksty = l_tccp->cblksty;\n                p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].tccp_info[compno].qmfbid = l_tccp->qmfbid;\n\n                memcpy(p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].pdx,l_tccp->prcw, l_data_size);\n                memcpy(p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].pdy,l_tccp->prch, l_data_size);\n        }\n        /* << INDEX */\n#endif\n\n        return OPJ_TRUE;\n}", "target": 2, "idx": 9658}
{"commit_id": "de5494af4815a4c9328536c72741229b7de88e7f", "project": "torvalds/linux", "func": "static ssize_t available_instances_show(struct mdev_type *mtype,\n\t\t\t\t\tstruct mdev_type_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tconst struct mbochs_type *type =\n\t\t&mbochs_types[mtype_get_type_group_id(mtype)];\n\tint count = atomic_read(&mbochs_avail_mbytes) / type->mbytes;\n\n\treturn sprintf(buf, \"%d\\n\", count);\n}", "target": 1, "idx": 9659}
{"commit_id": "2fb81b8ed6a4a6b2385f3efbb0412f24f80163c4", "project": "libvips", "func": "static float\nvips_eye_point( VipsPoint *point, int x, int y ) \n{\n\tVipsEye *eye = (VipsEye *) point;\n\n\t/* VIPS_MAX to prevent /0.\n\t */\n\tint max_x = VIPS_MAX( point->width - 1, 1 );\n\tint max_y = VIPS_MAX( point->height - 1, 1 );\n\n\tdouble c = eye->factor * VIPS_PI / (2 * max_x);\n\tdouble h = max_y * max_y;\n\n\treturn( y * y * cos( c * x * x ) / h );\n}", "target": 1, "idx": 9660}
{"commit_id": "cfb182b8d5cdc104ba1e9c09125c918b00e850bb", "project": "chromium", "func": "void forEachForBinding(ScriptState* scriptState, const ScriptValue& thisValue, const ScriptValue& callback, const ScriptValue& thisArg, ExceptionState& exceptionState)\n    {\n        IterationSource* source = this->startIteration(scriptState, exceptionState);\n\n        v8::Isolate* isolate = scriptState->isolate();\n        v8::TryCatch tryCatch(isolate);\n\n        v8::Local<v8::Object> creationContext(thisValue.v8Value().As<v8::Object>());\n        v8::Local<v8::Function> v8Callback(callback.v8Value().As<v8::Function>());\n        v8::Local<v8::Value> v8ThisArg(thisArg.v8Value());\n        v8::Local<v8::Value> args[3];\n\n        args[2] = thisValue.v8Value();\n\n        while (true) {\n            KeyType key;\n            ValueType value;\n\n            if (!source->next(scriptState, key, value, exceptionState))\n                return;\n\n            ASSERT(!exceptionState.hadException());\n\n            args[0] = toV8(value, creationContext, isolate);\n            args[1] = toV8(key, creationContext, isolate);\n            if (args[0].IsEmpty() || args[1].IsEmpty()) {\n                if (tryCatch.HasCaught())\n                    exceptionState.rethrowV8Exception(tryCatch.Exception());\n                return;\n            }\n\n            v8::Local<v8::Value> result;\n            if (!V8ScriptRunner::callFunction(v8Callback, scriptState->executionContext(), v8ThisArg, 3, args, isolate).ToLocal(&result)) {\n                exceptionState.rethrowV8Exception(tryCatch.Exception());\n                return;\n            }\n        }\n    }", "target": 2, "idx": 9661}
{"commit_id": "8342139c09178823dba3f3bbd8b53d0ea0c72de9", "project": "adplug", "func": "bool CmtkLoader::load(const std::string &filename, const CFileProvider &fp)\n{\n  binistream *f = fp.open(filename); if(!f) return false;\n  struct {\n    char id[18];\n    unsigned short crc,size;\n  } header;\n  struct mtkdata {\n    char songname[34],composername[34],instname[0x80][34];\n    unsigned char insts[0x80][12],order[0x80],dummy,patterns[0x32][0x40][9];\n    // HSC pattern has different type and size from patterns, but that\n    // doesn't matter much since we memcpy() the data. Still confusing.\n  } *data;\n  unsigned char *cmp,*org;\n  unsigned int i;\n  unsigned long cmpsize,cmpptr=0,orgptr=0;\n  unsigned short ctrlbits=0,ctrlmask=0,cmd,cnt,offs;\n\n  // read header\n  f->readString(header.id, 18);\n  header.crc = f->readInt(2);\n  header.size = f->readInt(2);\n\n  // file validation section\n  if (memcmp(header.id, \"mpu401tr\\x92kk\\xeer@data\", 18) ||\n      header.size < sizeof(*data) - sizeof(data->patterns)) {\n    fp.close(f); return false;\n  }\n\n  // load section\n  cmpsize = fp.filesize(f) - 22;\n  cmp = new unsigned char[cmpsize];\n  org = new unsigned char[header.size];\n  for(i = 0; i < cmpsize; i++) cmp[i] = f->readInt(1);\n  fp.close(f);\n\n  while(cmpptr < cmpsize) {\t// decompress\n    ctrlmask >>= 1;\n    if(!ctrlmask) {\n      if (cmpptr + 2 > cmpsize) goto err;\n      ctrlbits = cmp[cmpptr] + (cmp[cmpptr + 1] << 8);\n      cmpptr += 2;\n      ctrlmask = 0x8000;\n    }\n    if(!(ctrlbits & ctrlmask)) {\t// uncompressed data\n      if(orgptr >= header.size)\n\tgoto err;\n\n      org[orgptr] = cmp[cmpptr];\n      orgptr++; cmpptr++;\n      continue;\n    }\n\n    // compressed data\n    cmd = (cmp[cmpptr] >> 4) & 0x0f;\n    cnt = cmp[cmpptr] & 0x0f;\n    cmpptr++;\n    if (cmpptr >= cmpsize) goto err;\n    switch(cmd) {\n    case 0:\n      cnt += 3;\n      if (orgptr + cnt > header.size) goto err;\n      memset(&org[orgptr],cmp[cmpptr],cnt);\n      cmpptr++; orgptr += cnt;\n      break;\n\n    case 1:\n      cnt += (cmp[cmpptr] << 4) + 19;\n      if (orgptr + cnt > header.size || cmpptr >= cmpsize) goto err;\n      memset(&org[orgptr],cmp[++cmpptr],cnt);\n      cmpptr++; orgptr += cnt;\n      break;\n\n    case 2:\n      if (cmpptr + 2 > cmpsize) goto err;\n      offs = (cnt+3) + (cmp[cmpptr] << 4);\n      cnt = cmp[++cmpptr] + 16; cmpptr++;\n      if (orgptr + cnt > header.size || offs > orgptr) goto err;\n      memcpy(&org[orgptr],&org[orgptr - offs],cnt);\n      orgptr += cnt;\n      break;\n\n    default:\n      offs = (cnt+3) + (cmp[cmpptr++] << 4);\n      if (orgptr + cmd > header.size || offs > orgptr) goto err;\n      memcpy(&org[orgptr],&org[orgptr-offs],cmd);\n      orgptr += cmd;\n      break;\n    }\n  }\n  // orgptr should match header.size; add a check?\n  delete [] cmp;\n  data = (struct mtkdata *) org;\n\n  // convert to HSC replay data\n  memset(title,0,34); strncpy(title,data->songname+1,33);\n  memset(composer,0,34); strncpy(composer,data->composername+1,33);\n  memset(instname,0,0x80*34);\n  for(i=0;i<0x80;i++)\n    strncpy(instname[i],data->instname[i]+1,33);\n  memcpy(instr,data->insts,0x80 * 12);\n  memcpy(song,data->order,0x80);\n  for (i=0;i<128;i++) {\t\t\t\t// correct instruments\n    instr[i][2] ^= (instr[i][2] & 0x40) << 1;\n    instr[i][3] ^= (instr[i][3] & 0x40) << 1;\n    instr[i][11] >>= 4;\t\t// make unsigned\n  }\n  cnt = header.size - (sizeof(*data) - sizeof(data->patterns)); // was off by 1\n  if (cnt > sizeof(patterns)) cnt = sizeof(patterns); // fail?\n  memcpy(patterns, data->patterns, cnt);\n\n  delete [] org;\n  rewind(0);\n  return true;\n\n err:\n  delete [] cmp;\n  delete [] org;\n  return false;\n}", "target": 2, "idx": 9662}
{"commit_id": "aa5c6b710dfd8020d2c908d6b3bd41f1da719b3b", "project": "the-tcpdump-group/tcpdump", "func": "static int\nldp_tlv_print(netdissect_options *ndo,\n              register const u_char *tptr,\n              u_short msg_tlen)\n{\n    struct ldp_tlv_header {\n        uint8_t type[2];\n        uint8_t length[2];\n    };\n\n    const struct ldp_tlv_header *ldp_tlv_header;\n    u_short tlv_type,tlv_len,tlv_tlen,af,ft_flags;\n    u_char fec_type;\n    u_int ui,vc_info_len, vc_info_tlv_type, vc_info_tlv_len,idx;\n    char buf[100];\n    int i;\n\n    ldp_tlv_header = (const struct ldp_tlv_header *)tptr;\n    ND_TCHECK(*ldp_tlv_header);\n    tlv_len=EXTRACT_16BITS(ldp_tlv_header->length);\n    if (tlv_len + 4 > msg_tlen) {\n        ND_PRINT((ndo, \"\\n\\t\\t TLV contents go past end of message\"));\n        return 0;\n    }\n    tlv_tlen=tlv_len;\n    tlv_type=LDP_MASK_TLV_TYPE(EXTRACT_16BITS(ldp_tlv_header->type));\n\n    /* FIXME vendor private / experimental check */\n    ND_PRINT((ndo, \"\\n\\t    %s TLV (0x%04x), length: %u, Flags: [%s and %s forward if unknown]\",\n           tok2str(ldp_tlv_values,\n                   \"Unknown\",\n                   tlv_type),\n           tlv_type,\n           tlv_len,\n           LDP_MASK_U_BIT(EXTRACT_16BITS(&ldp_tlv_header->type)) ? \"continue processing\" : \"ignore\",\n           LDP_MASK_F_BIT(EXTRACT_16BITS(&ldp_tlv_header->type)) ? \"do\" : \"don't\"));\n\n    tptr+=sizeof(struct ldp_tlv_header);\n\n    switch(tlv_type) {\n\n    case LDP_TLV_COMMON_HELLO:\n        TLV_TCHECK(4);\n        ND_PRINT((ndo, \"\\n\\t      Hold Time: %us, Flags: [%s Hello%s]\",\n               EXTRACT_16BITS(tptr),\n               (EXTRACT_16BITS(tptr+2)&0x8000) ? \"Targeted\" : \"Link\",\n               (EXTRACT_16BITS(tptr+2)&0x4000) ? \", Request for targeted Hellos\" : \"\"));\n        break;\n\n    case LDP_TLV_IPV4_TRANSPORT_ADDR:\n        TLV_TCHECK(4);\n        ND_PRINT((ndo, \"\\n\\t      IPv4 Transport Address: %s\", ipaddr_string(ndo, tptr)));\n        break;\n    case LDP_TLV_IPV6_TRANSPORT_ADDR:\n        TLV_TCHECK(16);\n        ND_PRINT((ndo, \"\\n\\t      IPv6 Transport Address: %s\", ip6addr_string(ndo, tptr)));\n        break;\n    case LDP_TLV_CONFIG_SEQ_NUMBER:\n        TLV_TCHECK(4);\n        ND_PRINT((ndo, \"\\n\\t      Sequence Number: %u\", EXTRACT_32BITS(tptr)));\n        break;\n\n    case LDP_TLV_ADDRESS_LIST:\n        TLV_TCHECK(LDP_TLV_ADDRESS_LIST_AFNUM_LEN);\n\taf = EXTRACT_16BITS(tptr);\n\ttptr+=LDP_TLV_ADDRESS_LIST_AFNUM_LEN;\n        tlv_tlen -= LDP_TLV_ADDRESS_LIST_AFNUM_LEN;\n\tND_PRINT((ndo, \"\\n\\t      Address Family: %s, addresses\",\n               tok2str(af_values, \"Unknown (%u)\", af)));\n        switch (af) {\n        case AFNUM_INET:\n\t    while(tlv_tlen >= sizeof(struct in_addr)) {\n\t\tND_TCHECK2(*tptr, sizeof(struct in_addr));\n\t\tND_PRINT((ndo, \" %s\", ipaddr_string(ndo, tptr)));\n\t\ttlv_tlen-=sizeof(struct in_addr);\n\t\ttptr+=sizeof(struct in_addr);\n\t    }\n            break;\n        case AFNUM_INET6:\n\t    while(tlv_tlen >= sizeof(struct in6_addr)) {\n\t\tND_TCHECK2(*tptr, sizeof(struct in6_addr));\n\t\tND_PRINT((ndo, \" %s\", ip6addr_string(ndo, tptr)));\n\t\ttlv_tlen-=sizeof(struct in6_addr);\n\t\ttptr+=sizeof(struct in6_addr);\n\t    }\n            break;\n        default:\n            /* unknown AF */\n            break;\n        }\n\tbreak;\n\n    case LDP_TLV_COMMON_SESSION:\n\tTLV_TCHECK(8);\n\tND_PRINT((ndo, \"\\n\\t      Version: %u, Keepalive: %us, Flags: [Downstream %s, Loop Detection %s]\",\n\t       EXTRACT_16BITS(tptr), EXTRACT_16BITS(tptr+2),\n\t       (EXTRACT_16BITS(tptr+6)&0x8000) ? \"On Demand\" : \"Unsolicited\",\n\t       (EXTRACT_16BITS(tptr+6)&0x4000) ? \"Enabled\" : \"Disabled\"\n\t       ));\n\tbreak;\n\n    case LDP_TLV_FEC:\n        TLV_TCHECK(1);\n        fec_type = *tptr;\n\tND_PRINT((ndo, \"\\n\\t      %s FEC (0x%02x)\",\n\t       tok2str(ldp_fec_values, \"Unknown\", fec_type),\n\t       fec_type));\n\n\ttptr+=1;\n\ttlv_tlen-=1;\n\tswitch(fec_type) {\n\n\tcase LDP_FEC_WILDCARD:\n\t    break;\n\tcase LDP_FEC_PREFIX:\n\t    TLV_TCHECK(2);\n\t    af = EXTRACT_16BITS(tptr);\n\t    tptr+=LDP_TLV_ADDRESS_LIST_AFNUM_LEN;\n\t    tlv_tlen-=LDP_TLV_ADDRESS_LIST_AFNUM_LEN;\n\t    if (af == AFNUM_INET) {\n\t\ti=decode_prefix4(ndo, tptr, tlv_tlen, buf, sizeof(buf));\n\t\tif (i == -2)\n\t\t    goto trunc;\n\t\tif (i == -3)\n\t\t    ND_PRINT((ndo, \": IPv4 prefix (goes past end of TLV)\"));\n\t\telse if (i == -1)\n\t\t    ND_PRINT((ndo, \": IPv4 prefix (invalid length)\"));\n\t\telse\n\t\t    ND_PRINT((ndo, \": IPv4 prefix %s\", buf));\n\t    }\n\t    else if (af == AFNUM_INET6) {\n\t\ti=decode_prefix6(ndo, tptr, tlv_tlen, buf, sizeof(buf));\n\t\tif (i == -2)\n\t\t    goto trunc;\n\t\tif (i == -3)\n\t\t    ND_PRINT((ndo, \": IPv4 prefix (goes past end of TLV)\"));\n\t\telse if (i == -1)\n\t\t    ND_PRINT((ndo, \": IPv6 prefix (invalid length)\"));\n\t\telse\n\t\t    ND_PRINT((ndo, \": IPv6 prefix %s\", buf));\n\t    }\n\t    else\n\t\tND_PRINT((ndo, \": Address family %u prefix\", af));\n\t    break;\n\tcase LDP_FEC_HOSTADDRESS:\n\t    break;\n\tcase LDP_FEC_MARTINI_VC:\n            /*\n             * We assume the type was supposed to be one of the MPLS\n             * Pseudowire Types.\n             */\n            TLV_TCHECK(7);\n            vc_info_len = *(tptr+2);\n\n            /*\n\t     * According to RFC 4908, the VC info Length field can be zero,\n\t     * in which case not only are there no interface parameters,\n\t     * there's no VC ID.\n\t     */\n            if (vc_info_len == 0) {\n                ND_PRINT((ndo, \": %s, %scontrol word, group-ID %u, VC-info-length: %u\",\n                       tok2str(mpls_pw_types_values, \"Unknown\", EXTRACT_16BITS(tptr)&0x7fff),\n                       EXTRACT_16BITS(tptr)&0x8000 ? \"\" : \"no \",\n                       EXTRACT_32BITS(tptr+3),\n                       vc_info_len));\n                break;\n            }\n\n            /* Make sure we have the VC ID as well */\n            TLV_TCHECK(11);\n\t    ND_PRINT((ndo, \": %s, %scontrol word, group-ID %u, VC-ID %u, VC-info-length: %u\",\n\t\t   tok2str(mpls_pw_types_values, \"Unknown\", EXTRACT_16BITS(tptr)&0x7fff),\n\t\t   EXTRACT_16BITS(tptr)&0x8000 ? \"\" : \"no \",\n                   EXTRACT_32BITS(tptr+3),\n\t\t   EXTRACT_32BITS(tptr+7),\n                   vc_info_len));\n            if (vc_info_len < 4) {\n                /* minimum 4, for the VC ID */\n                ND_PRINT((ndo, \" (invalid, < 4\"));\n                return(tlv_len+4); /* Type & Length fields not included */\n\t    }\n            vc_info_len -= 4; /* subtract out the VC ID, giving the length of the interface parameters */\n\n            /* Skip past the fixed information and the VC ID */\n            tptr+=11;\n            tlv_tlen-=11;\n            TLV_TCHECK(vc_info_len);\n\n            while (vc_info_len > 2) {\n                vc_info_tlv_type = *tptr;\n                vc_info_tlv_len = *(tptr+1);\n                if (vc_info_tlv_len < 2)\n                    break;\n                if (vc_info_len < vc_info_tlv_len)\n                    break;\n\n                ND_PRINT((ndo, \"\\n\\t\\tInterface Parameter: %s (0x%02x), len %u\",\n                       tok2str(ldp_fec_martini_ifparm_values,\"Unknown\",vc_info_tlv_type),\n                       vc_info_tlv_type,\n                       vc_info_tlv_len));\n\n                switch(vc_info_tlv_type) {\n                case LDP_FEC_MARTINI_IFPARM_MTU:\n                    ND_PRINT((ndo, \": %u\", EXTRACT_16BITS(tptr+2)));\n                    break;\n\n                case LDP_FEC_MARTINI_IFPARM_DESC:\n                    ND_PRINT((ndo, \": \"));\n                    for (idx = 2; idx < vc_info_tlv_len; idx++)\n                        safeputchar(ndo, *(tptr + idx));\n                    break;\n\n                case LDP_FEC_MARTINI_IFPARM_VCCV:\n                    ND_PRINT((ndo, \"\\n\\t\\t  Control Channels (0x%02x) = [%s]\",\n                           *(tptr+2),\n                           bittok2str(ldp_fec_martini_ifparm_vccv_cc_values, \"none\", *(tptr+2))));\n                    ND_PRINT((ndo, \"\\n\\t\\t  CV Types (0x%02x) = [%s]\",\n                           *(tptr+3),\n                           bittok2str(ldp_fec_martini_ifparm_vccv_cv_values, \"none\", *(tptr+3))));\n                    break;\n\n                default:\n                    print_unknown_data(ndo, tptr+2, \"\\n\\t\\t  \", vc_info_tlv_len-2);\n                    break;\n                }\n\n                vc_info_len -= vc_info_tlv_len;\n                tptr += vc_info_tlv_len;\n            }\n\t    break;\n\t}\n\n\tbreak;\n\n    case LDP_TLV_GENERIC_LABEL:\n\tTLV_TCHECK(4);\n\tND_PRINT((ndo, \"\\n\\t      Label: %u\", EXTRACT_32BITS(tptr) & 0xfffff));\n\tbreak;\n\n    case LDP_TLV_STATUS:\n\tTLV_TCHECK(8);\n\tui = EXTRACT_32BITS(tptr);\n\ttptr+=4;\n\tND_PRINT((ndo, \"\\n\\t      Status: 0x%02x, Flags: [%s and %s forward]\",\n\t       ui&0x3fffffff,\n\t       ui&0x80000000 ? \"Fatal error\" : \"Advisory Notification\",\n\t       ui&0x40000000 ? \"do\" : \"don't\"));\n\tui = EXTRACT_32BITS(tptr);\n\ttptr+=4;\n\tif (ui)\n\t    ND_PRINT((ndo, \", causing Message ID: 0x%08x\", ui));\n\tbreak;\n\n    case LDP_TLV_FT_SESSION:\n\tTLV_TCHECK(12);\n\tft_flags = EXTRACT_16BITS(tptr);\n\tND_PRINT((ndo, \"\\n\\t      Flags: [%sReconnect, %sSave State, %sAll-Label Protection, %s Checkpoint, %sRe-Learn State]\",\n\t       ft_flags&0x8000 ? \"\" : \"No \",\n\t       ft_flags&0x8 ? \"\" : \"Don't \",\n\t       ft_flags&0x4 ? \"\" : \"No \",\n\t       ft_flags&0x2 ? \"Sequence Numbered Label\" : \"All Labels\",\n\t       ft_flags&0x1 ? \"\" : \"Don't \"));\n\t/* 16 bits (FT Flags) + 16 bits (Reserved) */\n\ttptr+=4;\n\tui = EXTRACT_32BITS(tptr);\n\tif (ui)\n\t    ND_PRINT((ndo, \", Reconnect Timeout: %ums\", ui));\n\ttptr+=4;\n\tui = EXTRACT_32BITS(tptr);\n\tif (ui)\n\t    ND_PRINT((ndo, \", Recovery Time: %ums\", ui));\n\tbreak;\n\n    case LDP_TLV_MTU:\n\tTLV_TCHECK(2);\n\tND_PRINT((ndo, \"\\n\\t      MTU: %u\", EXTRACT_16BITS(tptr)));\n\tbreak;\n\n\n    /*\n     *  FIXME those are the defined TLVs that lack a decoder\n     *  you are welcome to contribute code ;-)\n     */\n\n    case LDP_TLV_HOP_COUNT:\n    case LDP_TLV_PATH_VECTOR:\n    case LDP_TLV_ATM_LABEL:\n    case LDP_TLV_FR_LABEL:\n    case LDP_TLV_EXTD_STATUS:\n    case LDP_TLV_RETURNED_PDU:\n    case LDP_TLV_RETURNED_MSG:\n    case LDP_TLV_ATM_SESSION_PARM:\n    case LDP_TLV_FR_SESSION_PARM:\n    case LDP_TLV_LABEL_REQUEST_MSG_ID:\n\n    default:\n        if (ndo->ndo_vflag <= 1)\n            print_unknown_data(ndo, tptr, \"\\n\\t      \", tlv_tlen);\n        break;\n    }\n    return(tlv_len+4); /* Type & Length fields not included */\n\ntrunc:\n    ND_PRINT((ndo, \"%s\", tstr));\n    return 0;\n\nbadtlv:\n    ND_PRINT((ndo, \"\\n\\t\\t TLV contents go past end of TLV\"));\n    return(tlv_len+4); /* Type & Length fields not included */\n}", "target": 2, "idx": 9663}
{"commit_id": "737925113363b6130879729cdff9ccc46c33eaea", "project": "neocturne/fastd", "func": "static inline void handle_socket_receive_unknown(\n\tfastd_socket_t *sock, const fastd_peer_address_t *local_addr, const fastd_peer_address_t *remote_addr,\n\tfastd_buffer_t *buffer) {\n\tconst uint8_t *packet_type = buffer->data;\n\n\tswitch (*packet_type) {\n\tcase PACKET_DATA:\n\t\tfastd_buffer_free(buffer);\n\n\t\tif (!backoff_unknown(remote_addr)) {\n\t\t\tpr_debug(\"unexpectedly received payload data from unknown address %I\", remote_addr);\n\t\t\tconf.protocol->handshake_init(sock, local_addr, remote_addr, NULL);\n\t\t}\n\t\tbreak;\n\n\tcase PACKET_HANDSHAKE:\n\t\tfastd_handshake_handle(sock, local_addr, remote_addr, NULL, buffer);\n\t\tbreak;\n\n\tdefault:\n\t\tfastd_buffer_free(buffer);\n\t\tpr_debug(\"received packet with invalid type from unknown address %I\", remote_addr);\n\t}\n}", "target": 2, "idx": 9664}
{"commit_id": "abfaf0eee97925905e742aa3b0b72e04a918fa9e", "project": "torvalds/linux", "func": "static int kfd_parse_subtype_iolink(struct crat_subtype_iolink *iolink,\n\t\t\t\t\tstruct list_head *device_list)\n{\n\tstruct kfd_iolink_properties *props = NULL, *props2;\n\tstruct kfd_topology_device *dev, *to_dev;\n\tuint32_t id_from;\n\tuint32_t id_to;\n\n\tid_from = iolink->proximity_domain_from;\n\tid_to = iolink->proximity_domain_to;\n\n\tpr_debug(\"Found IO link entry in CRAT table with id_from=%d, id_to %d\\n\",\n\t\t\tid_from, id_to);\n\tlist_for_each_entry(dev, device_list, list) {\n\t\tif (id_from == dev->proximity_domain) {\n\t\t\tprops = kfd_alloc_struct(props);\n\t\t\tif (!props)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tprops->node_from = id_from;\n\t\t\tprops->node_to = id_to;\n\t\t\tprops->ver_maj = iolink->version_major;\n\t\t\tprops->ver_min = iolink->version_minor;\n\t\t\tprops->iolink_type = iolink->io_interface_type;\n\n\t\t\tif (props->iolink_type == CRAT_IOLINK_TYPE_PCIEXPRESS)\n\t\t\t\tprops->weight = 20;\n\t\t\telse if (props->iolink_type == CRAT_IOLINK_TYPE_XGMI)\n\t\t\t\tprops->weight = 15 * iolink->num_hops_xgmi;\n\t\t\telse\n\t\t\t\tprops->weight = node_distance(id_from, id_to);\n\n\t\t\tprops->min_latency = iolink->minimum_latency;\n\t\t\tprops->max_latency = iolink->maximum_latency;\n\t\t\tprops->min_bandwidth = iolink->minimum_bandwidth_mbs;\n\t\t\tprops->max_bandwidth = iolink->maximum_bandwidth_mbs;\n\t\t\tprops->rec_transfer_size =\n\t\t\t\t\tiolink->recommended_transfer_size;\n\n\t\t\tdev->io_link_count++;\n\t\t\tdev->node_props.io_links_count++;\n\t\t\tlist_add_tail(&props->list, &dev->io_link_props);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* CPU topology is created before GPUs are detected, so CPU->GPU\n\t * links are not built at that time. If a PCIe type is discovered, it\n\t * means a GPU is detected and we are adding GPU->CPU to the topology.\n\t * At this time, also add the corresponded CPU->GPU link if GPU\n\t * is large bar.\n\t * For xGMI, we only added the link with one direction in the crat\n\t * table, add corresponded reversed direction link now.\n\t */\n\tif (props && (iolink->flags & CRAT_IOLINK_FLAGS_BI_DIRECTIONAL)) {\n\t\tto_dev = kfd_topology_device_by_proximity_domain(id_to);\n\t\tif (!to_dev)\n\t\t\treturn -ENODEV;\n\t\t/* same everything but the other direction */\n\t\tprops2 = kmemdup(props, sizeof(*props2), GFP_KERNEL);\n\t\tif (!props2)\n\t\t\treturn -ENOMEM;\n\n\t\tprops2->node_from = id_to;\n\t\tprops2->node_to = id_from;\n\t\tprops2->kobj = NULL;\n\t\tto_dev->io_link_count++;\n\t\tto_dev->node_props.io_links_count++;\n\t\tlist_add_tail(&props2->list, &to_dev->io_link_props);\n\t}\n\n\treturn 0;\n}", "target": 1, "idx": 9665}
{"commit_id": "cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8", "project": "vim", "func": "VTermState *vterm_obtain_state(VTerm *vt)\n{\n  VTermState *state;\n  if(vt->state)\n    return vt->state;\n\n  state = vterm_state_new(vt);\n  if (state == NULL)\n    return NULL;\n  vt->state = state;\n\n  state->combine_chars_size = 16;\n  state->combine_chars = vterm_allocator_malloc(state->vt, state->combine_chars_size * sizeof(state->combine_chars[0]));\n\n  state->tabstops = vterm_allocator_malloc(state->vt, (state->cols + 7) / 8);\n\n  state->lineinfo = vterm_allocator_malloc(state->vt, state->rows * sizeof(VTermLineInfo));\n\n  state->encoding_utf8.enc = vterm_lookup_encoding(ENC_UTF8, 'u');\n  if(*state->encoding_utf8.enc->init != NULL)\n    (*state->encoding_utf8.enc->init)(state->encoding_utf8.enc, state->encoding_utf8.data);\n\n  vterm_parser_set_callbacks(vt, &parser_callbacks, state);\n\n  return state;\n}", "target": 2, "idx": 9666}
{"commit_id": "830548acd030467e857f4cf0b79af8ebf1e04dde", "project": "gpac", "func": "static void lsr_read_paint(GF_LASeRCodec *lsr, SVG_Paint *paint, const char *name)\n{\n\tu32 val;\n\tGF_LSR_READ_INT(lsr, val, 1, \"hasIndex\");\n\tif (val) {\n\t\tGF_LSR_READ_INT(lsr, val, lsr->colorIndexBits, name);\n\t\tlsr_get_color(lsr, val, &paint->color);\n\t\tpaint->type = SVG_PAINT_COLOR;\n\t\tpaint->color.type = 0;\n\t} else {\n\t\tGF_LSR_READ_INT(lsr, val, 2, \"enum\");\n\t\tswitch (val) {\n\t\tcase 0:\n\t\t\tGF_LSR_READ_INT(lsr, val, 2, \"choice\");\n\t\t\tswitch (val) {\n\t\t\tcase 0:\n\t\t\t\tpaint->type = SVG_PAINT_INHERIT;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tpaint->type = SVG_PAINT_COLOR;\n\t\t\t\tpaint->color.type = SVG_COLOR_CURRENTCOLOR;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpaint->type = SVG_PAINT_NONE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t{\n\t\t\tXMLRI iri;\n\t\t\tmemset(&iri, 0, sizeof(XMLRI));\n\t\t\tiri.type = 0xFF;\n\t\t\tlsr_read_any_uri(lsr, &iri, name);\n\t\t\tgf_node_unregister_iri(lsr->sg, &iri);\n\t\t\tgf_list_del_item(lsr->deferred_hrefs, &iri);\n\n\t\t\tpaint->type = SVG_PAINT_URI;\n\t\t\tif (iri.string) {\n\t\t\t\tpaint->type = SVG_PAINT_URI;\n\t\t\t\tpaint->iri.type = XMLRI_STRING;\n\t\t\t\tpaint->iri.string = iri.string;\n\t\t\t} else if (iri.target) {\n\t\t\t\tpaint->iri.type = XMLRI_ELEMENTID;\n\t\t\t\tpaint->iri.target = iri.target;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase 2:\n\t\t{\n\t\t\tchar *sysPaint=NULL;\n\t\t\tlsr_read_byte_align_string(lsr, &sysPaint, \"systemsPaint\");\n\t\t\tif (sysPaint) {\n\t\t\t\tpaint->type = SVG_PAINT_COLOR;\n\t\t\t\tpaint->color.type = gf_svg_get_system_paint_server_type(sysPaint);\n\t\t\t\tgf_free(sysPaint);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase 3:\n\t\t\tlsr_read_extension(lsr, name);\n\t\t\tbreak;\n\t\t}\n\t}\n}", "target": 1, "idx": 9667}
{"commit_id": "fbfa4d1083ea84c5429992ca3e996d7d4fbc8238", "project": "YanVugenfirer/kvm-guest-drivers-windows", "func": "tChecksumCheckResult ParaNdis_CheckRxChecksum(\n                                            PARANDIS_ADAPTER *pContext,\n                                            ULONG virtioFlags,\n                                            tCompletePhysicalAddress *pPacketPages,\n                                            ULONG ulPacketLength,\n                                            ULONG ulDataOffset)\n{\n    tOffloadSettingsFlags f = pContext->Offload.flags;\n    tChecksumCheckResult res;\n    tTcpIpPacketParsingResult ppr;\n    ULONG flagsToCalculate = 0;\n    res.value = 0;\n\n    //VIRTIO_NET_HDR_F_NEEDS_CSUM - we need to calculate TCP/UDP CS\n    //VIRTIO_NET_HDR_F_DATA_VALID - host tells us TCP/UDP CS is OK\n\n    if (f.fRxIPChecksum) flagsToCalculate |= pcrIpChecksum; // check only\n\n    if (!(virtioFlags & VIRTIO_NET_HDR_F_DATA_VALID))\n    {\n        if (virtioFlags & VIRTIO_NET_HDR_F_NEEDS_CSUM)\n        {\n            flagsToCalculate |= pcrFixXxpChecksum | pcrTcpChecksum | pcrUdpChecksum;\n        }\n        else\n        {\n            if (f.fRxTCPChecksum) flagsToCalculate |= pcrTcpV4Checksum;\n            if (f.fRxUDPChecksum) flagsToCalculate |= pcrUdpV4Checksum;\n            if (f.fRxTCPv6Checksum) flagsToCalculate |= pcrTcpV6Checksum;\n            if (f.fRxUDPv6Checksum) flagsToCalculate |= pcrUdpV6Checksum;\n        }\n    }\n\n    ppr = ParaNdis_CheckSumVerify(pPacketPages, ulPacketLength - ETH_HEADER_SIZE, ulDataOffset + ETH_HEADER_SIZE, flagsToCalculate, __FUNCTION__);\n\n    if (ppr.ipCheckSum == ppresIPTooShort || ppr.xxpStatus == ppresXxpIncomplete)\n    {\n        res.flags.IpOK = FALSE;\n        res.flags.IpFailed = TRUE;\n        return res;\n    }\n\n    if (virtioFlags & VIRTIO_NET_HDR_F_DATA_VALID)\n    {\n        pContext->extraStatistics.framesRxCSHwOK++;\n        ppr.xxpCheckSum = ppresCSOK;\n    }\n\n    if (ppr.ipStatus == ppresIPV4 && !ppr.IsFragment)\n    {\n        if (f.fRxIPChecksum)\n        {\n            res.flags.IpOK =  ppr.ipCheckSum == ppresCSOK;\n            res.flags.IpFailed = ppr.ipCheckSum == ppresCSBad;\n        }\n        if(ppr.xxpStatus == ppresXxpKnown)\n        {\n            if(ppr.TcpUdp == ppresIsTCP) /* TCP */\n            {\n                if (f.fRxTCPChecksum)\n                {\n                    res.flags.TcpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS;\n                    res.flags.TcpFailed = !res.flags.TcpOK;\n                }\n            }\n            else /* UDP */\n            {\n                if (f.fRxUDPChecksum)\n                {\n                    res.flags.UdpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS;\n                    res.flags.UdpFailed = !res.flags.UdpOK;\n                }\n            }\n        }\n    }\n    else if (ppr.ipStatus == ppresIPV6)\n    {\n        if(ppr.xxpStatus == ppresXxpKnown)\n        {\n            if(ppr.TcpUdp == ppresIsTCP) /* TCP */\n            {\n                if (f.fRxTCPv6Checksum)\n                {\n                    res.flags.TcpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS;\n                    res.flags.TcpFailed = !res.flags.TcpOK;\n                }\n            }\n            else /* UDP */\n            {\n                if (f.fRxUDPv6Checksum)\n                {\n                    res.flags.UdpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS;\n                    res.flags.UdpFailed = !res.flags.UdpOK;\n                }\n            }\n        }\n    }\n\n    return res;\n}", "target": 2, "idx": 9668}
{"commit_id": "88e7b873da5d3e85d31b601c1560d2e24a1d7b25", "project": "gpac", "func": "static s32 gf_vvc_read_vps_bs_internal(GF_BitStream *bs, VVCState *vvc, Bool stop_at_vps_ext)\n{\n\tu32 i, j;\n\ts32 vps_id;\n\tVVC_VPS *vps;\n\tBool vps_default_ptl_dpb_hrd_max_tid_flag=0;\n\n\t//nalu header already parsed\n\tvps_id = gf_bs_read_int_log(bs, 4, \"vps_id\");\n\tif ((vps_id<0) || (vps_id >= 16)) return -1;\n\tif (!vps_id) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VVC] VPS ID 0 is forbidden\\n\"));\n\t\treturn -1;\n\t}\n\tvps = &vvc->vps[vps_id];\n\tif (!vps->state) {\n\t\tvps->id = vps_id;\n\t\tvps->state = 1;\n\t}\n\tvps->max_layers = 1 + gf_bs_read_int_log(bs, 6, \"max_layers\");\n\tif (vps->max_layers > VVC_MAX_LAYERS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VVC] %d layers in VPS but only %d supported in GPAC\\n\", vps->max_layers, VVC_MAX_LAYERS));\n\t\tvps->max_layers = VVC_MAX_LAYERS;\n\t\treturn -1;\n\t}\n\tvps->max_sub_layers = gf_bs_read_int_log(bs, 3, \"max_sub_layers_minus1\") + 1;\n\n\tif ((vps->max_layers>1) && (vps->max_sub_layers>1))\n\t\tvps_default_ptl_dpb_hrd_max_tid_flag = gf_bs_read_int_log(bs, 1, \"vps_default_ptl_dpb_hrd_max_tid_flag\");\n\n\tif (vps->max_layers>1)\n\t\tvps->all_layers_independent = gf_bs_read_int_log(bs, 1, \"all_layers_independent\");\n\n\tfor (i=0; i<vps->max_layers; i++) {\n\t\tu32 layer_id = gf_bs_read_int_log_idx(bs, 6, \"layer_id\", i);\n\t\tif (layer_id>vps->max_layer_id) vps->max_layer_id = layer_id;\n\t\tif (i && !vps->all_layers_independent) {\n\t\t\tBool layer_indep = gf_bs_read_int_log_idx(bs, 1, \"layer_independent\", i);\n\t\t\tif (!layer_indep) {\n\t\t\t\tBool vps_max_tid_ref_present_flag = gf_bs_read_int_log_idx(bs, 1, \"vps_max_tid_ref_present_flag\", i);\n\t\t\t\tfor (j=0; j<i; j++) {\n\t\t\t\t\tBool vps_direct_ref_layer_flag = gf_bs_read_int_log_idx2(bs, 1, \"vps_direct_ref_layer_flag\", i, j);\n\t\t\t\t\tif (vps_max_tid_ref_present_flag && vps_direct_ref_layer_flag) {\n\t\t\t\t\t\tgf_bs_read_int_log_idx2(bs, 3, \"vps_max_tid_il_ref_pics_plus1\", i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvps->num_ptl = 1;\n\tif (vps->max_layers > 1) {\n\t\tif (vps->all_layers_independent) {\n\t\t\tvps->each_layer_is_ols = gf_bs_read_int_log(bs, 1, \"each_layer_is_ols\");\n\t\t}\n\t\tif (!vps->each_layer_is_ols) {\n\t\t\tu32 vps_ols_mode_idc = 2;\n\t\t\tif (!vps->all_layers_independent) {\n\t\t\t\tvps_ols_mode_idc = gf_bs_read_int_log(bs, 2, \"vps_ols_mode_idc\");\n\t\t\t}\n\t\t\tif (vps_ols_mode_idc==2) {\n\t\t\t\tu8 vps_num_output_layer_sets = 2 + gf_bs_read_int_log(bs, 8, \"vps_num_output_layer_sets_minus2\");\n\t\t\t\tfor (i=0; i<vps_num_output_layer_sets; i++) {\n\t\t\t\t\tfor (j=0; j<vps->max_layers; j++) {\n\t\t\t\t\t\tgf_bs_read_int_log_idx2(bs, 1, \"vps_ols_output_layer_flag\", i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvps->num_ptl = 1 + gf_bs_read_int_log(bs, 8, \"num_ptl_minus1\");\n\t}\n\tvps->ptl[0].pt_present = 1;\n\tfor (i=0; i<vps->num_ptl; i++) {\n\t\tif (i)\n\t\t\tvps->ptl[i].pt_present = gf_bs_read_int_log_idx(bs, 1, \"pt_present\", i);\n\t\tif (!vps_default_ptl_dpb_hrd_max_tid_flag)\n\t\t\tvps->ptl[i].ptl_max_tid = gf_bs_read_int_log_idx(bs, 3, \"ptl_max_tid\", i);\n\t\telse\n\t\t\tvps->ptl[i].ptl_max_tid = vps->max_sub_layers - 1;\n\t}\n\t//align\n\tgf_bs_align(bs);\n\n\tfor (i=0; i<vps->num_ptl; i++) {\n\t\tvvc_profile_tier_level(bs, &vps->ptl[i], i);\n\t}\n\n\t//TODO, parse multilayer stuff\n\n\n\tif (gf_bs_is_overflow(bs))\n\t\treturn -1;\n\treturn vps_id;\n}", "target": 2, "idx": 9669}
{"commit_id": "1a623d361ffe5cecd4244a02f449528416360038", "project": "torvalds/linux", "func": "static void __io_free_req(struct io_kiocb *req)\n{\n\tio_req_put_fs(req);\n\tif (req->file && !(req->flags & REQ_F_FIXED_FILE))\n\t\tfput(req->file);\n\tpercpu_ref_put(&req->ctx->refs);\n\tkmem_cache_free(req_cachep, req);\n}", "target": 2, "idx": 9670}
{"commit_id": "08193b7f0cd3910256e00d599f0f3eb2519c44ca", "project": "facebook/hhvm", "func": "int64_t length() const {\n    return m_str ? m_str->size() : 0;\n  }", "target": 3, "idx": 9671}
{"commit_id": "66191f780863ea8c66ace4040d0d04a8842e8432", "project": "radareorg/radare2", "func": "static x86newTokenType getToken(const char *str, size_t *begin, size_t *end) {\n\tif (*begin > strlen (str)) {\n\t\treturn TT_EOF;\n\t}\n\t// Skip whitespace\n\twhile (begin && str[*begin] && isspace ((ut8)str[*begin])) {\n\t\t++(*begin);\n\t}\n\n\tif (!str[*begin]) {                // null byte\n\t\t*end = *begin;\n\t\treturn TT_EOF;\n\t}\n\tif (isalpha ((ut8)str[*begin])) {   // word token\n\t\t*end = *begin;\n\t\twhile (end && str[*end] && isalnum ((ut8)str[*end])) {\n\t\t\t++(*end);\n\t\t}\n\t\treturn TT_WORD;\n\t}\n\tif (isdigit ((ut8)str[*begin])) {   // number token\n\t\t*end = *begin;\n\t\twhile (end && isalnum ((ut8)str[*end])) {     // accept alphanumeric characters, because hex.\n\t\t\t++(*end);\n\t\t}\n\t\treturn TT_NUMBER;\n\t} else {                             // special character: [, ], +, *, ...\n\t\t*end = *begin + 1;\n\t\treturn TT_SPECIAL;\n\t}\n}", "target": 1, "idx": 9672}
{"commit_id": "b08afc81c60607a4f736f418f2e3eb06087f1a35", "project": "FRRouting/frr", "func": "enum bgp_attr_parse_ret bgp_attr_parse(struct peer *peer, struct attr *attr,\n\t\t\t\t       bgp_size_t size,\n\t\t\t\t       struct bgp_nlri *mp_update,\n\t\t\t\t       struct bgp_nlri *mp_withdraw)\n{\n\tenum bgp_attr_parse_ret ret;\n\tuint8_t flag = 0;\n\tuint8_t type = 0;\n\tbgp_size_t length;\n\tuint8_t *startp, *endp;\n\tuint8_t *attr_endp;\n\tuint8_t seen[BGP_ATTR_BITMAP_SIZE];\n\t/* we need the as4_path only until we have synthesized the as_path with\n\t * it */\n\t/* same goes for as4_aggregator */\n\tstruct aspath *as4_path = NULL;\n\tas_t as4_aggregator = 0;\n\tstruct in_addr as4_aggregator_addr = {.s_addr = 0};\n\tstruct transit *transit;\n\n\t/* Initialize bitmap. */\n\tmemset(seen, 0, BGP_ATTR_BITMAP_SIZE);\n\n\t/* End pointer of BGP attribute. */\n\tendp = BGP_INPUT_PNT(peer) + size;\n\n\t/* Get attributes to the end of attribute length. */\n\twhile (BGP_INPUT_PNT(peer) < endp) {\n\t\tstartp = BGP_INPUT_PNT(peer);\n\n\t\t/* Fewer than three octets remain (or fewer than four\n\t\t * octets, if the Attribute Flags field has the Extended\n\t\t * Length bit set) when beginning to parse the attribute.\n\t\t * That is, this case exists if there remains unconsumed\n\t\t * data in the path attributes but yet insufficient data\n\t\t * to encode a single minimum-sized path attribute.\n\t\t *\n\t\t * An error condition exists and the \"treat-as-withdraw\"\n\t\t * approach MUST be used (unless some other, more severe\n\t\t * error is encountered dictating a stronger approach),\n\t\t * and the Total Attribute Length MUST be relied upon to\n\t\t * enable the beginning of the NLRI field to be located.\n\t\t */\n\n\t\t/* Check remaining length check.*/\n\t\tif ((endp - startp) < BGP_ATTR_MIN_LEN) {\n\t\t\t/* XXX warning: long int format, int arg (arg 5) */\n\t\t\tflog_warn(\n\t\t\t\tEC_BGP_ATTRIBUTE_TOO_SMALL,\n\t\t\t\t\"%s: error BGP attribute length %lu is smaller than min len\",\n\t\t\t\tpeer->host,\n\t\t\t\t(unsigned long)(endp\n\t\t\t\t\t\t- stream_pnt(BGP_INPUT(peer))));\n\n\t\t\tif (peer->sort != BGP_PEER_EBGP) {\n\t\t\t\tbgp_notify_send(peer->connection,\n\t\t\t\t\t\tBGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\t\tBGP_NOTIFY_UPDATE_ATTR_LENG_ERR);\n\t\t\t\tret = BGP_ATTR_PARSE_ERROR;\n\t\t\t} else {\n\t\t\t\tret = BGP_ATTR_PARSE_WITHDRAW;\n\t\t\t}\n\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* Fetch attribute flag and type.\n\t\t * The lower-order four bits of the Attribute Flags octet are\n\t\t * unused. They MUST be zero when sent and MUST be ignored when\n\t\t * received.\n\t\t */\n\t\tflag = 0xF0 & stream_getc(BGP_INPUT(peer));\n\t\ttype = stream_getc(BGP_INPUT(peer));\n\n\t\t/* Check whether Extended-Length applies and is in bounds */\n\t\tif (CHECK_FLAG(flag, BGP_ATTR_FLAG_EXTLEN)\n\t\t    && ((endp - startp) < (BGP_ATTR_MIN_LEN + 1))) {\n\t\t\tflog_warn(\n\t\t\t\tEC_BGP_EXT_ATTRIBUTE_TOO_SMALL,\n\t\t\t\t\"%s: Extended length set, but just %lu bytes of attr header\",\n\t\t\t\tpeer->host,\n\t\t\t\t(unsigned long)(endp\n\t\t\t\t\t\t- stream_pnt(BGP_INPUT(peer))));\n\n\t\t\tif (peer->sort != BGP_PEER_EBGP) {\n\t\t\t\tbgp_notify_send(peer->connection,\n\t\t\t\t\t\tBGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\t\tBGP_NOTIFY_UPDATE_ATTR_LENG_ERR);\n\t\t\t\tret = BGP_ATTR_PARSE_ERROR;\n\t\t\t} else {\n\t\t\t\tret = BGP_ATTR_PARSE_WITHDRAW;\n\t\t\t}\n\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* Check extended attribue length bit. */\n\t\tif (CHECK_FLAG(flag, BGP_ATTR_FLAG_EXTLEN))\n\t\t\tlength = stream_getw(BGP_INPUT(peer));\n\t\telse\n\t\t\tlength = stream_getc(BGP_INPUT(peer));\n\n\t\t/* Overflow check. */\n\t\tattr_endp = BGP_INPUT_PNT(peer) + length;\n\n\t\tif (attr_endp > endp) {\n\t\t\tflog_warn(\n\t\t\t\tEC_BGP_ATTRIBUTE_TOO_LARGE,\n\t\t\t\t\"%s: BGP type %d length %d is too large, attribute total length is %d.  attr_endp is %p.  endp is %p\",\n\t\t\t\tpeer->host, type, length, size, attr_endp,\n\t\t\t\tendp);\n\n\t\t\t/* Only relax error handling for eBGP peers */\n\t\t\tif (peer->sort != BGP_PEER_EBGP) {\n\t\t\t\t/*\n\t\t\t\t * RFC 4271 6.3\n\t\t\t\t * If any recognized attribute has an Attribute\n\t\t\t\t * Length that conflicts with the expected length\n\t\t\t\t * (based on the attribute type code), then the\n\t\t\t\t * Error Subcode MUST be set to Attribute Length\n\t\t\t\t * Error.  The Data field MUST contain the erroneous\n\t\t\t\t * attribute (type, length, and value).\n\t\t\t\t * ----------\n\t\t\t\t * We do not currently have a good way to determine the\n\t\t\t\t * length of the attribute independent of the length\n\t\t\t\t * received in the message. Instead we send the\n\t\t\t\t * minimum between the amount of data we have and the\n\t\t\t\t * amount specified by the attribute length field.\n\t\t\t\t *\n\t\t\t\t * Instead of directly passing in the packet buffer and\n\t\t\t\t * offset we use the stream_get* functions to read into\n\t\t\t\t * a stack buffer, since they perform bounds checking\n\t\t\t\t * and we are working with untrusted data.\n\t\t\t\t */\n\t\t\t\tunsigned char ndata[peer->max_packet_size];\n\n\t\t\t\tmemset(ndata, 0x00, sizeof(ndata));\n\t\t\t\tsize_t lfl =\n\t\t\t\t\tCHECK_FLAG(flag, BGP_ATTR_FLAG_EXTLEN) ? 2 : 1;\n\t\t\t\t/* Rewind to end of flag field */\n\t\t\t\tstream_rewind_getp(BGP_INPUT(peer), (1 + lfl));\n\t\t\t\t/* Type */\n\t\t\t\tstream_get(&ndata[0], BGP_INPUT(peer), 1);\n\t\t\t\t/* Length */\n\t\t\t\tstream_get(&ndata[1], BGP_INPUT(peer), lfl);\n\t\t\t\t/* Value */\n\t\t\t\tsize_t atl = attr_endp - startp;\n\t\t\t\tsize_t ndl = MIN(atl, STREAM_READABLE(BGP_INPUT(peer)));\n\n\t\t\t\tstream_get(&ndata[lfl + 1], BGP_INPUT(peer), ndl);\n\n\t\t\t\tbgp_notify_send_with_data(peer->connection,\n\t\t\t\t\t\t\t  BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\t\t\t  BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n\t\t\t\t\t\t\t  ndata, ndl + lfl + 1);\n\n\t\t\t\tret = BGP_ATTR_PARSE_ERROR;\n\t\t\t\tgoto done;\n\t\t\t} else {\n\t\t\t\t/* Handling as per RFC7606 section 4, treat-as-withdraw approach\n\t\t\t\t * must be followed when the total attribute length is in conflict\n\t\t\t\t * with the enclosed path attribute length.\n\t\t\t\t */\n\t\t\t\tflog_warn(\n\t\t\t\t\tEC_BGP_ATTRIBUTE_PARSE_WITHDRAW,\n\t\t\t\t\t\"%s: Attribute %s, parse error - treating as withdrawal\",\n\t\t\t\t\tpeer->host, lookup_msg(attr_str, type, NULL));\n\t\t\t\tret = BGP_ATTR_PARSE_WITHDRAW;\n\t\t\t\tstream_forward_getp(BGP_INPUT(peer), endp - BGP_INPUT_PNT(peer));\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\n\t\t/* If attribute appears more than once in the UPDATE message,\n\t\t * for MP_REACH_NLRI & MP_UNREACH_NLRI attributes\n\t\t * the Error Subcode is set to Malformed Attribute List.\n\t\t * For all other attributes, all the occurances of the attribute\n\t\t * other than the first occurence is discarded. (RFC7606 3g)\n\t\t */\n\n\t\tif (CHECK_BITMAP(seen, type)) {\n\t\t\t/* Only relax error handling for eBGP peers */\n\t\t\tif (peer->sort != BGP_PEER_EBGP ||\n\t\t\t\t\ttype == BGP_ATTR_MP_REACH_NLRI || type == BGP_ATTR_MP_UNREACH_NLRI) {\n\t\t\t\tflog_warn(\n\t\t\t\t\tEC_BGP_ATTRIBUTE_REPEATED,\n\t\t\t\t\t\"%s: error BGP attribute type %d appears twice in a message\",\n\t\t\t\t\tpeer->host, type);\n\n\t\t\t\tbgp_notify_send(peer->connection,\n\t\t\t\t\t\tBGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\t\t\tret = BGP_ATTR_PARSE_ERROR;\n\t\t\t\tgoto done;\n\t\t\t} else {\n\t\t\t\tflog_warn(\n\t\t\t\t\tEC_BGP_ATTRIBUTE_REPEATED,\n\t\t\t\t\t\"%s: error BGP attribute type %d appears twice in a message - discard attribute\",\n\t\t\t\t\tpeer->host, type);\n\t\t\t\t/* Adjust the stream getp to the end of the attribute, in case we\n\t\t\t\t * haven't read all the attributes.\n\t\t\t\t */\n\t\t\t\tstream_set_getp(BGP_INPUT(peer),\n\t\t\t\t\t(startp - STREAM_DATA(BGP_INPUT(peer))) + (attr_endp - startp));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* Set type to bitmap to check duplicate attribute.  `type' is\n\t\t   unsigned char so it never overflow bitmap range. */\n\n\t\tSET_BITMAP(seen, type);\n\n\t\tstruct bgp_attr_parser_args attr_args = {\n\t\t\t.peer = peer,\n\t\t\t.length = length,\n\t\t\t.attr = attr,\n\t\t\t.type = type,\n\t\t\t.flags = flag,\n\t\t\t.startp = startp,\n\t\t\t.total = attr_endp - startp,\n\t\t};\n\n\n\t\t/* If any recognized attribute has Attribute Flags that conflict\n\t\t   with the Attribute Type Code, then the Error Subcode is set\n\t\t   to\n\t\t   Attribute Flags Error.  The Data field contains the erroneous\n\t\t   attribute (type, length and value). */\n\t\tif (bgp_attr_flag_invalid(&attr_args)) {\n\t\t\tret = bgp_attr_malformed(\n\t\t\t\t&attr_args, BGP_NOTIFY_UPDATE_ATTR_FLAG_ERR,\n\t\t\t\tattr_args.total);\n\t\t\tif (ret == BGP_ATTR_PARSE_PROCEED)\n\t\t\t\tcontinue;\n\t\t\tstream_forward_getp(BGP_INPUT(peer), endp - BGP_INPUT_PNT(peer));\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* OK check attribute and store it's value. */\n\t\tswitch (type) {\n\t\tcase BGP_ATTR_ORIGIN:\n\t\t\tret = bgp_attr_origin(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_AS_PATH:\n\t\t\tret = bgp_attr_aspath(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_AS4_PATH:\n\t\t\tret = bgp_attr_as4_path(&attr_args, &as4_path);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_NEXT_HOP:\n\t\t\tret = bgp_attr_nexthop(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_MULTI_EXIT_DISC:\n\t\t\tret = bgp_attr_med(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_LOCAL_PREF:\n\t\t\tret = bgp_attr_local_pref(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_ATOMIC_AGGREGATE:\n\t\t\tret = bgp_attr_atomic(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_AGGREGATOR:\n\t\t\tret = bgp_attr_aggregator(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_AS4_AGGREGATOR:\n\t\t\tret = bgp_attr_as4_aggregator(&attr_args,\n\t\t\t\t\t\t      &as4_aggregator,\n\t\t\t\t\t\t      &as4_aggregator_addr);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_COMMUNITIES:\n\t\t\tret = bgp_attr_community(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_LARGE_COMMUNITIES:\n\t\t\tret = bgp_attr_large_community(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_ORIGINATOR_ID:\n\t\t\tret = bgp_attr_originator_id(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_CLUSTER_LIST:\n\t\t\tret = bgp_attr_cluster_list(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_MP_REACH_NLRI:\n\t\t\tret = bgp_mp_reach_parse(&attr_args, mp_update);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_MP_UNREACH_NLRI:\n\t\t\tret = bgp_mp_unreach_parse(&attr_args, mp_withdraw);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_EXT_COMMUNITIES:\n\t\t\tret = bgp_attr_ext_communities(&attr_args);\n\t\t\tbreak;\n#ifdef ENABLE_BGP_VNC_ATTR\n\t\tcase BGP_ATTR_VNC:\n#endif\n\t\tcase BGP_ATTR_ENCAP:\n\t\t\tret = bgp_attr_encap(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_PREFIX_SID:\n\t\t\tret = bgp_attr_prefix_sid(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_PMSI_TUNNEL:\n\t\t\tret = bgp_attr_pmsi_tunnel(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_IPV6_EXT_COMMUNITIES:\n\t\t\tret = bgp_attr_ipv6_ext_communities(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_OTC:\n\t\t\tret = bgp_attr_otc(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_AIGP:\n\t\t\tret = bgp_attr_aigp(&attr_args);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = bgp_attr_unknown(&attr_args);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ret == BGP_ATTR_PARSE_ERROR_NOTIFYPLS) {\n\t\t\tbgp_notify_send(peer->connection, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\t\tret = BGP_ATTR_PARSE_ERROR;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (ret == BGP_ATTR_PARSE_ERROR) {\n\t\t\tflog_warn(EC_BGP_ATTRIBUTE_PARSE_ERROR,\n\t\t\t\t  \"%s: Attribute %s, parse error\", peer->host,\n\t\t\t\t  lookup_msg(attr_str, type, NULL));\n\t\t\tgoto done;\n\t\t}\n\t\tif (ret == BGP_ATTR_PARSE_WITHDRAW) {\n\t\t\tflog_warn(\n\t\t\t\tEC_BGP_ATTRIBUTE_PARSE_WITHDRAW,\n\t\t\t\t\"%s: Attribute %s, parse error - treating as withdrawal\",\n\t\t\t\tpeer->host, lookup_msg(attr_str, type, NULL));\n\t\t\tstream_forward_getp(BGP_INPUT(peer), endp - BGP_INPUT_PNT(peer));\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* Check the fetched length. */\n\t\tif (BGP_INPUT_PNT(peer) != attr_endp) {\n\t\t\tflog_warn(EC_BGP_ATTRIBUTE_FETCH_ERROR,\n\t\t\t\t  \"%s: BGP attribute %s, fetch error\",\n\t\t\t\t  peer->host, lookup_msg(attr_str, type, NULL));\n\t\t\tbgp_notify_send(peer->connection, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\tBGP_NOTIFY_UPDATE_ATTR_LENG_ERR);\n\t\t\tret = BGP_ATTR_PARSE_ERROR;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/*\n\t * draft-ietf-idr-bgp-prefix-sid-27#section-3:\n\t * About Prefix-SID path attribute,\n\t * Label-Index TLV(type1) and The Originator SRGB TLV(type-3)\n\t * may only appear in a BGP Prefix-SID attribute attached to\n\t * IPv4/IPv6 Labeled Unicast prefixes ([RFC8277]).\n\t * It MUST be ignored when received for other BGP AFI/SAFI combinations.\n\t */\n\tif (!attr->mp_nexthop_len || mp_update->safi != SAFI_LABELED_UNICAST)\n\t\tattr->label_index = BGP_INVALID_LABEL_INDEX;\n\n\t/* Check final read pointer is same as end pointer. */\n\tif (BGP_INPUT_PNT(peer) != endp) {\n\t\tflog_warn(EC_BGP_ATTRIBUTES_MISMATCH,\n\t\t\t  \"%s: BGP attribute %s, length mismatch\", peer->host,\n\t\t\t  lookup_msg(attr_str, type, NULL));\n\t\tbgp_notify_send(peer->connection, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_ATTR_LENG_ERR);\n\n\t\tret = BGP_ATTR_PARSE_ERROR;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * RFC4271: If the NEXT_HOP attribute field is syntactically incorrect,\n\t * then the Error Subcode MUST be set to Invalid NEXT_HOP Attribute.\n\t * This is implemented below and will result in a NOTIFICATION. If the\n\t * NEXT_HOP attribute is semantically incorrect, the error SHOULD be\n\t * logged, and the route SHOULD be ignored. In this case, a NOTIFICATION\n\t * message SHOULD NOT be sent. This is implemented elsewhere.\n\t *\n\t * RFC4760: An UPDATE message that carries no NLRI, other than the one\n\t * encoded in the MP_REACH_NLRI attribute, SHOULD NOT carry the NEXT_HOP\n\t * attribute. If such a message contains the NEXT_HOP attribute, the BGP\n\t * speaker that receives the message SHOULD ignore this attribute.\n\t */\n\tif (CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_NEXT_HOP))\n\t    && !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI))) {\n\t\tif (bgp_attr_nexthop_valid(peer, attr) < 0) {\n\t\t\tret = BGP_ATTR_PARSE_ERROR;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* Check all mandatory well-known attributes are present */\n\tret = bgp_attr_check(peer, attr);\n\tif (ret < 0)\n\t\tgoto done;\n\n\t/*\n\t * At this place we can see whether we got AS4_PATH and/or\n\t * AS4_AGGREGATOR from a 16Bit peer and act accordingly.\n\t * We can not do this before we've read all attributes because\n\t * the as4 handling does not say whether AS4_PATH has to be sent\n\t * after AS_PATH or not - and when AS4_AGGREGATOR will be send\n\t * in relationship to AGGREGATOR.\n\t * So, to be defensive, we are not relying on any order and read\n\t * all attributes first, including these 32bit ones, and now,\n\t * afterwards, we look what and if something is to be done for as4.\n\t *\n\t * It is possible to not have AS_PATH, e.g. GR EoR and sole\n\t * MP_UNREACH_NLRI.\n\t */\n\t/* actually... this doesn't ever return failure currently, but\n\t * better safe than sorry */\n\tif (CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_AS_PATH))\n\t    && bgp_attr_munge_as4_attrs(peer, attr, as4_path, as4_aggregator,\n\t\t\t\t\t&as4_aggregator_addr)) {\n\t\tbgp_notify_send(peer->connection, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\tret = BGP_ATTR_PARSE_ERROR;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Finally do the checks on the aspath we did not do yet\n\t * because we waited for a potentially synthesized aspath.\n\t */\n\tif (attr->flag & (ATTR_FLAG_BIT(BGP_ATTR_AS_PATH))) {\n\t\tret = bgp_attr_aspath_check(peer, attr);\n\t\tif (ret != BGP_ATTR_PARSE_PROCEED)\n\t\t\tgoto done;\n\t}\n\n\tret = BGP_ATTR_PARSE_PROCEED;\ndone:\n\n\t/*\n\t * At this stage, we have done all fiddling with as4, and the\n\t * resulting info is in attr->aggregator resp. attr->aspath so\n\t * we can chuck as4_aggregator and as4_path alltogether in order\n\t * to save memory\n\t */\n\t/*\n\t * unintern - it is in the hash\n\t * The flag that we got this is still there, but that\n\t * does not do any trouble\n\t */\n\taspath_unintern(&as4_path);\n\n\ttransit = bgp_attr_get_transit(attr);\n\tif (ret != BGP_ATTR_PARSE_ERROR) {\n\t\t/* Finally intern unknown attribute. */\n\t\tif (transit)\n\t\t\tbgp_attr_set_transit(attr, transit_intern(transit));\n\t\tif (attr->encap_subtlvs)\n\t\t\tattr->encap_subtlvs = encap_intern(attr->encap_subtlvs,\n\t\t\t\t\t\t\t   ENCAP_SUBTLV_TYPE);\n#ifdef ENABLE_BGP_VNC\n\t\tstruct bgp_attr_encap_subtlv *vnc_subtlvs =\n\t\t\tbgp_attr_get_vnc_subtlvs(attr);\n\n\t\tif (vnc_subtlvs)\n\t\t\tbgp_attr_set_vnc_subtlvs(\n\t\t\t\tattr,\n\t\t\t\tencap_intern(vnc_subtlvs, VNC_SUBTLV_TYPE));\n#endif\n\t} else {\n\t\tif (transit) {\n\t\t\ttransit_free(transit);\n\t\t\tbgp_attr_set_transit(attr, NULL);\n\t\t}\n\n\t\tbgp_attr_flush_encap(attr);\n\t};\n\n\t/* Sanity checks */\n\ttransit = bgp_attr_get_transit(attr);\n\tif (transit)\n\t\tassert(transit->refcnt > 0);\n\tif (attr->encap_subtlvs)\n\t\tassert(attr->encap_subtlvs->refcnt > 0);\n#ifdef ENABLE_BGP_VNC\n\tstruct bgp_attr_encap_subtlv *vnc_subtlvs =\n\t\tbgp_attr_get_vnc_subtlvs(attr);\n\n\tif (vnc_subtlvs)\n\t\tassert(vnc_subtlvs->refcnt > 0);\n#endif\n\n\treturn ret;\n}", "target": 2, "idx": 9673}
{"commit_id": "ee778252faebb721afba5a081dd6ad7eaf20eef3", "project": "michaelrsweet/htmldoc", "func": "static int\t\t\t/* O - Current column */\nwrite_node(FILE   *out,\t\t/* I - Output file */\n           tree_t *t,\t\t/* I - Document tree node */\n           int    col)\t\t/* I - Current column */\n{\n  int\t\ti;\t\t/* Looping var */\n  uchar\t\t*ptr,\t\t/* Pointer to output string */\n\t\t*entity,\t/* Entity string */\n\t\t*src,\t\t/* Source image */\n\t\t*realsrc,\t/* Real source image */\n\t\tnewsrc[1024];\t/* New source image filename */\n\n\n  if (out == NULL)\n    return (0);\n\n  switch (t->markup)\n  {\n    case MARKUP_NONE :\n        if (t->data == NULL)\n\t  break;\n\n\tif (t->preformatted)\n\t{\n          for (ptr = t->data; *ptr; ptr ++)\n            fputs((char *)iso8859(*ptr), out);\n\n\t  if (t->data[0] && t->data[strlen((char *)t->data) - 1] == '\\n')\n            col = 0;\n\t  else\n            col += strlen((char *)t->data);\n\t}\n\telse\n\t{\n\t  if ((col + (int)strlen((char *)t->data)) > 72 && col > 0)\n\t  {\n            putc('\\n', out);\n            col = 0;\n\t  }\n\n          for (ptr = t->data; *ptr; ptr ++)\n            fputs((char *)iso8859(*ptr), out);\n\n\t  col += strlen((char *)t->data);\n\n\t  if (col > 72)\n\t  {\n            putc('\\n', out);\n            col = 0;\n\t  }\n\t}\n\tbreak;\n\n    case MARKUP_COMMENT :\n    case MARKUP_UNKNOWN :\n        fputs(\"\\n<!--\", out);\n\tfor (ptr = t->data; *ptr; ptr ++)\n\t  fputs((char *)iso8859(*ptr), out);\n\tfputs(\"-->\\n\", out);\n\tcol = 0;\n\tbreak;\n\n    case MARKUP_AREA :\n    case MARKUP_BODY :\n    case MARKUP_DOCTYPE :\n    case MARKUP_ERROR :\n    case MARKUP_FILE :\n    case MARKUP_HEAD :\n    case MARKUP_HTML :\n    case MARKUP_MAP :\n    case MARKUP_META :\n    case MARKUP_TITLE :\n        break;\n\n    case MARKUP_BR :\n    case MARKUP_CENTER :\n    case MARKUP_DD :\n    case MARKUP_DL :\n    case MARKUP_DT :\n    case MARKUP_H1 :\n    case MARKUP_H2 :\n    case MARKUP_H3 :\n    case MARKUP_H4 :\n    case MARKUP_H5 :\n    case MARKUP_H6 :\n    case MARKUP_H7 :\n    case MARKUP_H8 :\n    case MARKUP_H9 :\n    case MARKUP_H10 :\n    case MARKUP_H11 :\n    case MARKUP_H12 :\n    case MARKUP_H13 :\n    case MARKUP_H14 :\n    case MARKUP_H15 :\n    case MARKUP_HR :\n    case MARKUP_LI :\n    case MARKUP_OL :\n    case MARKUP_P :\n    case MARKUP_PRE :\n    case MARKUP_TABLE :\n    case MARKUP_TR :\n    case MARKUP_UL :\n        if (col > 0)\n        {\n          putc('\\n', out);\n          col = 0;\n        }\n\n    default :\n\tif (t->markup == MARKUP_IMG && OutputFiles &&\n            (src = htmlGetVariable(t, (uchar *)\"SRC\")) != NULL &&\n            (realsrc = htmlGetVariable(t, (uchar *)\"REALSRC\")) != NULL)\n\t{\n\t /*\n          * Update and copy local images...\n          */\n\n          if (file_method((char *)src) == NULL &&\n              src[0] != '/' && src[0] != '\\\\' &&\n\t      (!isalpha(src[0]) || src[1] != ':'))\n          {\n            image_copy((char *)src, (char *)realsrc, OutputPath);\n            strlcpy((char *)newsrc, file_basename((char *)src), sizeof(newsrc));\n            htmlSetVariable(t, (uchar *)\"SRC\", newsrc);\n          }\n\t}\n\n        if (t->markup != MARKUP_EMBED)\n\t{\n\t  col += fprintf(out, \"<%s\", _htmlMarkups[t->markup]);\n\t  for (i = 0; i < t->nvars; i ++)\n\t  {\n\t    if (strcasecmp((char *)t->vars[i].name, \"BREAK\") == 0 &&\n\t        t->markup == MARKUP_HR)\n\t      continue;\n\n\t    if (strcasecmp((char *)t->vars[i].name, \"REALSRC\") == 0 &&\n\t        t->markup == MARKUP_IMG)\n\t      continue;\n\n            if (strncasecmp((char *)t->vars[i].name, \"_HD_\", 4) == 0)\n\t      continue;\n\n\t    if (col > 72 && !t->preformatted)\n\t    {\n              putc('\\n', out);\n              col = 0;\n\t    }\n\n            if (col > 0)\n            {\n              putc(' ', out);\n              col ++;\n            }\n\n\t    if (t->vars[i].value == NULL)\n              col += fprintf(out, \"%s\", t->vars[i].name);\n\t    else\n\t    {\n\t      col += fprintf(out, \"%s=\\\"\", t->vars[i].name);\n\t      for (ptr = t->vars[i].value; *ptr; ptr ++)\n\t      {\n\t\tentity = iso8859(*ptr);\n\t\tfputs((char *)entity, out);\n\t\tcol += strlen((char *)entity);\n\t      }\n\n\t      putc('\\\"', out);\n\t      col ++;\n\t    }\n\t  }\n\n\t  putc('>', out);\n\t  col ++;\n\n\t  if (col > 72 && !t->preformatted)\n\t  {\n\t    putc('\\n', out);\n\t    col = 0;\n\t  }\n\t}\n\tbreak;\n  }\n\n  return (col);\n}", "target": 2, "idx": 9674}
{"commit_id": "1de49725a5fc4e48f1a3b902ec3599ee99283043", "project": "tensorflow", "func": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteEmbeddingLookupSparseParams*>(node->builtin_data);\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  const TfLiteTensor* ids;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &ids));\n  const TfLiteTensor* indices;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &indices));\n  const TfLiteTensor* dense_shape;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 2, &dense_shape));\n  const TfLiteTensor* weights;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 3, &weights));\n  const TfLiteTensor* value;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 4, &value));\n\n  const int lookup_rank = SizeOfDimension(indices, 1);\n  const int embedding_rank = NumDimensions(value);\n  const int num_lookups = SizeOfDimension(ids, 0);\n  const int num_rows = SizeOfDimension(value, 0);\n\n  // The last dimension gets replaced by the embedding.\n  const int output_rank = (lookup_rank - 1) + (embedding_rank - 1);\n\n  // Make sure that the actual dense shape of the sparse tensor represented by\n  // (loopkup, indices, dense_shape) is consistent.\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(dense_shape, 0), lookup_rank);\n\n  // Resize output tensor.\n  TfLiteIntArray* output_shape = TfLiteIntArrayCreate(output_rank);\n  TF_LITE_ENSURE(context, output_shape != nullptr);\n  int k = 0;\n  size_t embedding_size = 1;\n  size_t lookup_size = 1;\n  for (int i = 0; i < lookup_rank - 1; i++, k++) {\n    const size_t dim = dense_shape->data.i32[i];\n    TF_LITE_ENSURE_MSG(\n        context,\n        MultiplyAndCheckOverflow(lookup_size, dim, &lookup_size) == kTfLiteOk,\n        \"Lookup size overflowed.\");\n    output_shape->data[k] = dim;\n  }\n  for (int i = 1; i < embedding_rank; i++, k++) {\n    const size_t dim = SizeOfDimension(value, i);\n    TF_LITE_ENSURE_MSG(context,\n                       MultiplyAndCheckOverflow(embedding_size, dim,\n                                                &embedding_size) == kTfLiteOk,\n                       \"Embedding size overflowed.\");\n    output_shape->data[k] = dim;\n  }\n  TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, output, output_shape));\n  const size_t output_size = lookup_size * embedding_size;\n  TfLiteTensorRealloc(output_size * sizeof(float), output);\n\n  float* output_ptr = GetTensorData<float>(output);\n  const float* weights_ptr = GetTensorData<float>(weights);\n  const float* value_ptr = GetTensorData<float>(value);\n  // Makes sure reallocation was successful.\n  TF_LITE_ENSURE(context, output_ptr != nullptr);\n\n  std::fill_n(output_ptr, output_size, 0.0f);\n\n  // Keep track of the current bucket for aggregation/combination.\n  int current_output_offset = 0;\n  float current_total_weight = 0.0;\n  float current_squares_weight = 0.0;\n  int num_elements = 0;\n\n  for (int i = 0; i < num_lookups; i++) {\n    int idx = ids->data.i32[i];\n    if (idx >= num_rows || idx < 0) {\n      context->ReportError(context,\n                           \"Embedding Lookup Sparse: index out of bounds. \"\n                           \"Got %d, and bounds are [0, %d]\",\n                           idx, num_rows - 1);\n      return kTfLiteError;\n    }\n\n    // Check where we need to aggregate.\n    const int example_indices_offset = i * lookup_rank;\n    int output_bucket = 0;\n    int stride = 1;\n    for (int k = (lookup_rank - 1) - 1; k >= 0; k--) {\n      output_bucket += indices->data.i32[example_indices_offset + k] * stride;\n      stride *= dense_shape->data.i32[k];\n    }\n    const int output_offset = output_bucket * embedding_size;\n\n    // If we are in a new aggregation bucket and the combiner is not the sum,\n    // go back and finalize the result of the previous bucket.\n    if (output_offset != current_output_offset) {\n      FinalizeAggregation(params->combiner, num_elements, current_total_weight,\n                          current_squares_weight, embedding_size,\n                          &output_ptr[current_output_offset]);\n\n      // Track next bucket.\n      num_elements = 0;\n      current_total_weight = 0.0;\n      current_squares_weight = 0.0;\n      current_output_offset = output_offset;\n    }\n\n    // Add element to aggregation.\n    ++num_elements;\n    const int example_embedding_offset = idx * embedding_size;\n    const float w = weights_ptr[i];\n    current_squares_weight += w * w;\n    current_total_weight += w;\n    for (int k = 0; k < embedding_size; k++) {\n      output_ptr[current_output_offset + k] +=\n          value_ptr[example_embedding_offset + k] * w;\n    }\n  }\n\n  // Finalize last bucket.\n  FinalizeAggregation(params->combiner, num_elements, current_total_weight,\n                      current_squares_weight, embedding_size,\n                      &GetTensorData<float>(output)[current_output_offset]);\n\n  return kTfLiteOk;\n}", "target": 2, "idx": 9675}
{"commit_id": "d919b2744cd05abae043490f0a3dd1946c1ccb8c", "project": "open5gs", "func": "static int on_part_data_end(multipart_parser *parser)\n{\n    multipart_parser_data_t *data = NULL;\n\n    ogs_assert(parser);\n    data = multipart_parser_get_data(parser);\n    ogs_assert(data);\n\n    if (data->num_of_part < OGS_SBI_MAX_NUM_OF_PART) {\n        data->num_of_part++;\n    }\n\n    return 0;\n}", "target": 2, "idx": 9676}
{"commit_id": "840f3af31a5b8d2d395d9367c826ed756e380fb9", "project": "eclipse-openj9/openj9", "func": "J9Method *   \nresolveSpecialSplitMethodRef(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA splitTableIndex, UDATA resolveFlags)\n{\n\tU_16 cpIndex = *(U_16 *)(J9ROMCLASS_SPECIALSPLITMETHODREFINDEXES(ramCP->ramClass->romClass) + splitTableIndex);\n\tJ9Method *method = ramCP->ramClass->specialSplitMethodTable[splitTableIndex];\n\t\n\tif (method == (J9Method*)vmStruct->javaVM->initialMethods.initialSpecialMethod) {\n\t\tmethod = resolveSpecialMethodRefInto(vmStruct, ramCP, cpIndex, resolveFlags, NULL);\n\n\t\tif ((NULL != method) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n\t\t\tramCP->ramClass->specialSplitMethodTable[splitTableIndex] = method;\n\t\t}\n\t}\n\treturn method;\n}", "target": 1, "idx": 9677}
{"commit_id": "d7d362995aa0cb8905c8d5c2a2a4c305d2ffff80", "project": "GNOME/gvfs", "func": "static void\ndo_query_info_on_write (GVfsBackend *backend,\n                        GVfsJobQueryInfoWrite *query_info_job,\n                        GVfsBackendHandle handle,\n                        GFileInfo *info,\n                        GFileAttributeMatcher *matcher)\n{\n  GVfsJob *job = G_VFS_JOB (query_info_job);\n  GFileOutputStream *stream = handle;\n  GError *error = NULL;\n  GFileInfo *real_info;\n\n  real_info = g_file_output_stream_query_info (stream, query_info_job->attributes,\n                                               job->cancellable, &error);\n  if (error != NULL)\n    goto out;\n\n  g_file_info_copy_into (real_info, info);\n  g_object_unref (real_info);\n\n out:\n  complete_job (job, error);\n}", "target": 2, "idx": 9678}
{"commit_id": "21998a351512eba4ed5969006f0c55882d995ada", "project": "torvalds/linux", "func": "static int ib_prctl_set(struct task_struct *task, unsigned long ctrl)\n{\n\tswitch (ctrl) {\n\tcase PR_SPEC_ENABLE:\n\t\tif (spectre_v2_user_ibpb == SPECTRE_V2_USER_NONE &&\n\t\t    spectre_v2_user_stibp == SPECTRE_V2_USER_NONE)\n\t\t\treturn 0;\n\t\t/*\n\t\t * Indirect branch speculation is always disabled in strict\n\t\t * mode.\n\t\t */\n\t\tif (spectre_v2_user_ibpb == SPECTRE_V2_USER_STRICT ||\n\t\t    spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT ||\n\t\t    spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT_PREFERRED)\n\t\t\treturn -EPERM;\n\t\ttask_clear_spec_ib_disable(task);\n\t\ttask_update_spec_tif(task);\n\t\tbreak;\n\tcase PR_SPEC_DISABLE:\n\tcase PR_SPEC_FORCE_DISABLE:\n\t\t/*\n\t\t * Indirect branch speculation is always allowed when\n\t\t * mitigation is force disabled.\n\t\t */\n\t\tif (spectre_v2_user_ibpb == SPECTRE_V2_USER_NONE &&\n\t\t    spectre_v2_user_stibp == SPECTRE_V2_USER_NONE)\n\t\t\treturn -EPERM;\n\t\tif (spectre_v2_user_ibpb == SPECTRE_V2_USER_STRICT ||\n\t\t    spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT ||\n\t\t    spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT_PREFERRED)\n\t\t\treturn 0;\n\t\ttask_set_spec_ib_disable(task);\n\t\tif (ctrl == PR_SPEC_FORCE_DISABLE)\n\t\t\ttask_set_spec_ib_force_disable(task);\n\t\ttask_update_spec_tif(task);\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\treturn 0;\n}", "target": 1, "idx": 9679}
{"commit_id": "453b351ac5bd2b6619925dc966da60adf6b3126c", "project": "android", "func": "sp<VBRISeeker> VBRISeeker::CreateFromSource(\n        const sp<DataSource> &source, off64_t post_id3_pos) {\n    off64_t pos = post_id3_pos;\n\n    uint8_t header[4];\n    ssize_t n = source->readAt(pos, header, sizeof(header));\n    if (n < (ssize_t)sizeof(header)) {\n        return NULL;\n    }\n\n    uint32_t tmp = U32_AT(&header[0]);\n    size_t frameSize;\n    int sampleRate;\n    if (!GetMPEGAudioFrameSize(tmp, &frameSize, &sampleRate)) {\n        return NULL;\n    }\n\n    // VBRI header follows 32 bytes after the header _ends_.\n    pos += sizeof(header) + 32;\n\n    uint8_t vbriHeader[26];\n    n = source->readAt(pos, vbriHeader, sizeof(vbriHeader));\n    if (n < (ssize_t)sizeof(vbriHeader)) {\n        return NULL;\n    }\n\n    if (memcmp(vbriHeader, \"VBRI\", 4)) {\n        return NULL;\n    }\n\n    size_t numFrames = U32_AT(&vbriHeader[14]);\n\n    int64_t durationUs =\n        numFrames * 1000000ll * (sampleRate >= 32000 ? 1152 : 576) / sampleRate;\n\n    ALOGV(\"duration = %.2f secs\", durationUs / 1E6);\n\n    size_t numEntries = U16_AT(&vbriHeader[18]);\n    size_t entrySize = U16_AT(&vbriHeader[22]);\n    size_t scale = U16_AT(&vbriHeader[20]);\n\n    ALOGV(\"%zu entries, scale=%zu, size_per_entry=%zu\",\n         numEntries,\n         scale,\n         entrySize);\n\n    if (entrySize > 4) {\n        ALOGE(\"invalid VBRI entry size: %zu\", entrySize);\n        return NULL;\n    }\n\n    sp<VBRISeeker> seeker = new (std::nothrow) VBRISeeker;\n    if (seeker == NULL) {\n        ALOGW(\"Couldn't allocate VBRISeeker\");\n        return NULL;\n    }\n\n    size_t totalEntrySize = numEntries * entrySize;\n    uint8_t *buffer = new (std::nothrow) uint8_t[totalEntrySize];\n    if (!buffer) {\n        ALOGW(\"Couldn't allocate %zu bytes\", totalEntrySize);\n        return NULL;\n    }\n\n    n = source->readAt(pos + sizeof(vbriHeader), buffer, totalEntrySize);\n    if (n < (ssize_t)totalEntrySize) {\n        delete[] buffer;\n        buffer = NULL;\n\n        return NULL;\n    }\n\n    seeker->mBasePos = post_id3_pos + frameSize;\n    // only update mDurationUs if the calculated duration is valid (non zero)\n    // otherwise, leave duration at -1 so that getDuration() and getOffsetForTime()\n    // return false when called, to indicate that this vbri tag does not have the\n    // requested information\n    if (durationUs) {\n        seeker->mDurationUs = durationUs;\n    }\n\n    off64_t offset = post_id3_pos;\n    for (size_t i = 0; i < numEntries; ++i) {\n        uint32_t numBytes;\n        switch (entrySize) {\n            case 1: numBytes = buffer[i]; break;\n            case 2: numBytes = U16_AT(buffer + 2 * i); break;\n            case 3: numBytes = U24_AT(buffer + 3 * i); break;\n            default:\n            {\n                CHECK_EQ(entrySize, 4u);\n                numBytes = U32_AT(buffer + 4 * i); break;\n            }\n        }\n\n        numBytes *= scale;\n\n        seeker->mSegments.push(numBytes);\n\n        ALOGV(\"entry #%zu: %u offset %#016llx\", i, numBytes, (long long)offset);\n        offset += numBytes;\n    }\n\n    delete[] buffer;\n    buffer = NULL;\n\n    ALOGI(\"Found VBRI header.\");\n\n    return seeker;\n}", "target": 1, "idx": 9680}
{"commit_id": "0061f393de54cf0326621c079dc2988336d1ebb3", "project": "yhirose/cpp-peglib", "func": "LiteralString(std::string &&s, bool ignore_case)\n      : lit_(s), ignore_case_(ignore_case), is_word_(false) {}", "target": 1, "idx": 9681}
{"commit_id": "97c62c6167299028d80765080e74d91dfc99efbd", "project": "gssapi/gss-ntlmssp", "func": "static int ntlm_decode_oem_str(struct wire_field_hdr *str_hdr,\n                               struct ntlm_buffer *buffer,\n                               size_t payload_offs, char **_str)\n{\n    uint16_t str_len;\n    uint32_t str_offs;\n    char *str = NULL;\n\n    str_len = le16toh(str_hdr->len);\n    if (str_len == 0) goto done;\n\n    str_offs = le32toh(str_hdr->offset);\n    if ((str_offs < payload_offs) ||\n        (str_offs > buffer->length) ||\n        (UINT32_MAX - str_offs < str_len) ||\n        (str_offs + str_len > buffer->length)) {\n        return ERR_DECODE;\n    }\n\n    str = strndup((const char *)&buffer->data[str_offs], str_len);\n    if (!str) return ENOMEM;\n\ndone:\n    *_str = str;\n    return 0;\n}", "target": 1, "idx": 9682}
{"commit_id": "a30f895ad3239f45012e860d4f94c1a388b36d14", "project": "torvalds/linux", "func": "static int io_register_personality(struct io_ring_ctx *ctx)\n{\n\tconst struct cred *creds;\n\tu32 id;\n\tint ret;\n\n\tcreds = get_current_cred();\n\n\tret = xa_alloc_cyclic(&ctx->personalities, &id, (void *)creds,\n\t\t\tXA_LIMIT(0, USHRT_MAX), &ctx->pers_next, GFP_KERNEL);\n\tif (ret < 0) {\n\t\tput_cred(creds);\n\t\treturn ret;\n\t}\n\treturn id;\n}", "target": 2, "idx": 9683}
{"commit_id": "ff82911cd3f69f028f2537825c9720ff78bc3f19", "project": "qemu", "func": "void nbd_client_attach_aio_context(BlockDriverState *bs,\n                                   AioContext *new_context)\n{\n    NBDClientSession *client = nbd_get_client_session(bs);\n    qio_channel_attach_aio_context(QIO_CHANNEL(client->sioc), new_context);\n    aio_co_schedule(new_context, client->read_reply_co);\n}", "target": 1, "idx": 9684}
{"commit_id": "8e9d6b38c036a97020c462ad48e1132e0ddc57ce", "project": "gpac", "func": "GF_Err chnl_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ChannelLayoutBox *ptr = (GF_ChannelLayoutBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u8(bs, ptr->layout.stream_structure);\n\tif (ptr->version==0) {\n\t\tgf_bs_write_u8(bs, ptr->layout.stream_structure);\n\t} else {\n\t\tgf_bs_write_int(bs, ptr->layout.stream_structure, 4);\n\t\tgf_bs_write_int(bs, ptr->layout.format_ordering, 4);\n\t\tgf_bs_write_u8(bs, ptr->layout.base_channel_count);\n\t}\n\tif (ptr->layout.stream_structure & 1) {\n\t\tgf_bs_write_u8(bs, ptr->layout.definedLayout);\n\t\tif (ptr->layout.definedLayout==0) {\n\t\t\tu32 i;\n\t\t\tif (ptr->version==1) {\n\t\t\t\tgf_bs_write_u8(bs, ptr->layout.channels_count);\n\t\t\t}\n\t\t\tfor (i=0; i<ptr->layout.channels_count; i++) {\n\t\t\t\tgf_bs_write_u8(bs, ptr->layout.layouts[i].position);\n\t\t\t\tif (ptr->layout.layouts[i].position==126) {\n\t\t\t\t\tgf_bs_write_int(bs, ptr->layout.layouts[i].azimuth, 16);\n\t\t\t\t\tgf_bs_write_int(bs, ptr->layout.layouts[i].elevation, 8);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (ptr->version==1) {\n\t\t\t\tgf_bs_write_int(bs, 0, 4);\n\t\t\t\tgf_bs_write_int(bs, ptr->layout.channel_order_definition, 3);\n\t\t\t\tgf_bs_write_int(bs, ptr->layout.omitted_channels_present, 1);\n\t\t\t\tif (ptr->layout.omitted_channels_present)\n\t\t\t\t\tgf_bs_write_u64(bs, ptr->layout.omittedChannelsMap);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u64(bs, ptr->layout.omittedChannelsMap);\n\t\t\t}\n\t\t}\n\t}\n\tif ((ptr->version==0) && (ptr->layout.stream_structure & 2)) {\n\t\tgf_bs_write_u8(bs, ptr->layout.object_count);\n\t}\n\treturn GF_OK;\n}", "target": 2, "idx": 9685}
{"commit_id": "e996e322ffd42aaa051602da182d03178d0f13e1", "project": "wget", "func": "static uerr_t\nftp_loop_internal (struct url *u, struct url *original_url, struct fileinfo *f,\n                   ccon *con, char **local_file, bool force_full_retrieve)\n{\n  int count, orig_lp;\n  wgint restval, len = 0, qtyread = 0;\n  char *tms, *locf;\n  const char *tmrate = NULL;\n  uerr_t err;\n  struct_stat st;\n\n  /* Declare WARC variables. */\n  bool warc_enabled = (opt.warc_filename != NULL);\n  FILE *warc_tmp = NULL;\n  ip_address *warc_ip = NULL;\n  wgint last_expected_bytes = 0;\n\n  /* Get the target, and set the name for the message accordingly. */\n  if ((f == NULL) && (con->target))\n    {\n      /* Explicit file (like \".listing\"). */\n      locf = con->target;\n    }\n  else\n    {\n      /* URL-derived file.  Consider \"-O file\" name. */\n      xfree (con->target);\n      con->target = url_file_name (opt.trustservernames || !original_url ? u : original_url, NULL);\n      if (!opt.output_document)\n        locf = con->target;\n      else\n        locf = opt.output_document;\n    }\n\n  /* If the output_document was given, then this check was already done and\n     the file didn't exist. Hence the !opt.output_document */\n\n  /* If we receive .listing file it is necessary to determine system type of the ftp\n     server even if opn.noclobber is given. Thus we must ignore opt.noclobber in\n     order to establish connection with the server and get system type. */\n  if (opt.noclobber && !opt.output_document && file_exists_p (con->target)\n      && !((con->cmd & DO_LIST) && !(con->cmd & DO_RETR)))\n    {\n      logprintf (LOG_VERBOSE,\n                 _(\"File %s already there; not retrieving.\\n\"), quote (con->target));\n      /* If the file is there, we suppose it's retrieved OK.  */\n      return RETROK;\n    }\n\n  /* Remove it if it's a link.  */\n  remove_link (con->target);\n\n  count = 0;\n\n  if (con->st & ON_YOUR_OWN)\n    con->st = ON_YOUR_OWN;\n\n  orig_lp = con->cmd & LEAVE_PENDING ? 1 : 0;\n\n  /* THE loop.  */\n  do\n    {\n      /* Increment the pass counter.  */\n      ++count;\n      sleep_between_retrievals (count);\n      if (con->st & ON_YOUR_OWN)\n        {\n          con->cmd = 0;\n          con->cmd |= (DO_RETR | LEAVE_PENDING);\n          if (con->csock != -1)\n            con->cmd &= ~ (DO_LOGIN | DO_CWD);\n          else\n            con->cmd |= (DO_LOGIN | DO_CWD);\n        }\n      else /* not on your own */\n        {\n          if (con->csock != -1)\n            con->cmd &= ~DO_LOGIN;\n          else\n            con->cmd |= DO_LOGIN;\n          if (con->st & DONE_CWD)\n            con->cmd &= ~DO_CWD;\n          else\n            con->cmd |= DO_CWD;\n        }\n\n      /* For file RETR requests, we can write a WARC record.\n         We record the file contents to a temporary file. */\n      if (warc_enabled && (con->cmd & DO_RETR) && warc_tmp == NULL)\n        {\n          warc_tmp = warc_tempfile ();\n          if (warc_tmp == NULL)\n            return WARC_TMP_FOPENERR;\n\n          if (!con->proxy && con->csock != -1)\n            {\n              warc_ip = (ip_address *) alloca (sizeof (ip_address));\n              socket_ip_address (con->csock, warc_ip, ENDPOINT_PEER);\n            }\n        }\n\n      /* Decide whether or not to restart.  */\n      if (con->cmd & DO_LIST)\n        restval = 0;\n      else if (force_full_retrieve)\n        restval = 0;\n      else if (opt.start_pos >= 0)\n        restval = opt.start_pos;\n      else if (opt.always_rest\n          && stat (locf, &st) == 0\n          && S_ISREG (st.st_mode))\n        /* When -c is used, continue from on-disk size.  (Can't use\n           hstat.len even if count>1 because we don't want a failed\n           first attempt to clobber existing data.)  */\n        restval = st.st_size;\n      else if (count > 1)\n        restval = qtyread;          /* start where the previous run left off */\n      else\n        restval = 0;\n\n      /* Get the current time string.  */\n      tms = datetime_str (time (NULL));\n      /* Print fetch message, if opt.verbose.  */\n      if (opt.verbose)\n        {\n          char *hurl = url_string (u, URL_AUTH_HIDE_PASSWD);\n          char tmp[256];\n          strcpy (tmp, \"        \");\n          if (count > 1)\n            sprintf (tmp, _(\"(try:%2d)\"), count);\n          logprintf (LOG_VERBOSE, \"--%s--  %s\\n  %s => %s\\n\",\n                     tms, hurl, tmp, quote (locf));\n#ifdef WINDOWS\n          ws_changetitle (hurl);\n#endif\n          xfree (hurl);\n        }\n      /* Send getftp the proper length, if fileinfo was provided.  */\n      if (f && f->type != FT_SYMLINK)\n        len = f->size;\n      else\n        len = 0;\n\n      /* If we are working on a WARC record, getftp should also write\n         to the warc_tmp file. */\n      err = getftp (u, original_url, len, &qtyread, restval, con, count,\n                    &last_expected_bytes, warc_tmp);\n\n      if (con->csock == -1)\n        con->st &= ~DONE_CWD;\n      else\n        con->st |= DONE_CWD;\n\n      switch (err)\n        {\n        case HOSTERR: case CONIMPOSSIBLE: case FWRITEERR: case FOPENERR:\n        case FTPNSFOD: case FTPLOGINC: case FTPNOPASV: case FTPNOAUTH: case FTPNOPBSZ: case FTPNOPROT:\n        case UNLINKERR: case WARC_TMP_FWRITEERR: case CONSSLERR: case CONTNOTSUPPORTED:\n#ifdef HAVE_SSL\n          if (err == FTPNOAUTH)\n            logputs (LOG_NOTQUIET, \"Server does not support AUTH TLS.\\n\");\n          if (opt.ftps_implicit)\n            logputs (LOG_NOTQUIET, \"Server does not like implicit FTPS connections.\\n\");\n#endif\n          /* Fatal errors, give up.  */\n          if (warc_tmp != NULL)\n              fclose (warc_tmp);\n          return err;\n        case CONSOCKERR: case CONERROR: case FTPSRVERR: case FTPRERR:\n        case WRITEFAILED: case FTPUNKNOWNTYPE: case FTPSYSERR:\n        case FTPPORTERR: case FTPLOGREFUSED: case FTPINVPASV:\n        case FOPEN_EXCL_ERR:\n          printwhat (count, opt.ntry);\n          /* non-fatal errors */\n          if (err == FOPEN_EXCL_ERR)\n            {\n              /* Re-determine the file name. */\n              xfree (con->target);\n              con->target = url_file_name (u, NULL);\n              locf = con->target;\n            }\n          continue;\n        case FTPRETRINT:\n          /* If the control connection was closed, the retrieval\n             will be considered OK if f->size == len.  */\n          if (!f || qtyread != f->size)\n            {\n              printwhat (count, opt.ntry);\n              continue;\n            }\n          break;\n        case RETRFINISHED:\n          /* Great!  */\n          break;\n        default:\n          /* Not as great.  */\n          abort ();\n        }\n      tms = datetime_str (time (NULL));\n      if (!opt.spider)\n        tmrate = retr_rate (qtyread - restval, con->dltime);\n\n      /* If we get out of the switch above without continue'ing, we've\n         successfully downloaded a file.  Remember this fact. */\n      downloaded_file (FILE_DOWNLOADED_NORMALLY, locf);\n\n      if (con->st & ON_YOUR_OWN)\n        {\n          fd_close (con->csock);\n          con->csock = -1;\n        }\n      if (!opt.spider)\n        {\n          bool write_to_stdout = (opt.output_document && HYPHENP (opt.output_document));\n\n          logprintf (LOG_VERBOSE,\n                     write_to_stdout\n                     ? _(\"%s (%s) - written to stdout %s[%s]\\n\\n\")\n                     : _(\"%s (%s) - %s saved [%s]\\n\\n\"),\n                     tms, tmrate,\n                     write_to_stdout ? \"\" : quote (locf),\n                     number_to_static_string (qtyread));\n        }\n      if (!opt.verbose && !opt.quiet)\n        {\n          /* Need to hide the password from the URL.  The `if' is here\n             so that we don't do the needless allocation every\n             time. */\n          char *hurl = url_string (u, URL_AUTH_HIDE_PASSWD);\n          logprintf (LOG_NONVERBOSE, \"%s URL: %s [%s] -> \\\"%s\\\" [%d]\\n\",\n                     tms, hurl, number_to_static_string (qtyread), locf, count);\n          xfree (hurl);\n        }\n\n      if (warc_enabled && (con->cmd & DO_RETR))\n        {\n          /* Create and store a WARC resource record for the retrieved file. */\n          bool warc_res;\n\n          warc_res = warc_write_resource_record (NULL, u->url, NULL, NULL,\n                                                  warc_ip, NULL, warc_tmp, -1);\n\n          if (! warc_res)\n            return WARC_ERR;\n\n          /* warc_write_resource_record has also closed warc_tmp. */\n          warc_tmp = NULL;\n        }\n\n      if (con->cmd & DO_LIST)\n        /* This is a directory listing file. */\n        {\n          if (!opt.remove_listing)\n            /* --dont-remove-listing was specified, so do count this towards the\n               number of bytes and files downloaded. */\n            {\n              total_downloaded_bytes += qtyread;\n              numurls++;\n            }\n\n          /* Deletion of listing files is not controlled by --delete-after, but\n             by the more specific option --dont-remove-listing, and the code\n             to do this deletion is in another function. */\n        }\n      else if (!opt.spider)\n        /* This is not a directory listing file. */\n        {\n          /* Unlike directory listing files, don't pretend normal files weren't\n             downloaded if they're going to be deleted.  People seeding proxies,\n             for instance, may want to know how many bytes and files they've\n             downloaded through it. */\n          total_downloaded_bytes += qtyread;\n          numurls++;\n\n          if (opt.delete_after && !input_file_url (opt.input_filename))\n            {\n              DEBUGP ((\"\\\nRemoving file due to --delete-after in ftp_loop_internal():\\n\"));\n              logprintf (LOG_VERBOSE, _(\"Removing %s.\\n\"), locf);\n              if (unlink (locf))\n                logprintf (LOG_NOTQUIET, \"unlink: %s\\n\", strerror (errno));\n            }\n        }\n\n      /* Restore the original leave-pendingness.  */\n      if (orig_lp)\n        con->cmd |= LEAVE_PENDING;\n      else\n        con->cmd &= ~LEAVE_PENDING;\n\n      if (local_file)\n        *local_file = xstrdup (locf);\n\n      if (warc_tmp != NULL)\n        fclose (warc_tmp);\n\n      return RETROK;\n    } while (!opt.ntry || (count < opt.ntry));\n\n  if (con->csock != -1 && (con->st & ON_YOUR_OWN))\n    {\n      fd_close (con->csock);\n      con->csock = -1;\n    }\n\n  if (warc_tmp != NULL)\n    fclose (warc_tmp);\n\n  return TRYLIMEXC;\n}", "target": 2, "idx": 9686}
{"commit_id": "d0d62baa7f505bd4c59cd169692ff07ec49dde37", "project": "torvalds/linux", "func": "static int xemaclite_of_probe(struct platform_device *ofdev)\n{\n\tstruct resource *res;\n\tstruct net_device *ndev = NULL;\n\tstruct net_local *lp = NULL;\n\tstruct device *dev = &ofdev->dev;\n\n\tint rc = 0;\n\n\tdev_info(dev, \"Device Tree Probing\\n\");\n\n\t/* Create an ethernet device instance */\n\tndev = alloc_etherdev(sizeof(struct net_local));\n\tif (!ndev)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, ndev);\n\tSET_NETDEV_DEV(ndev, &ofdev->dev);\n\n\tlp = netdev_priv(ndev);\n\tlp->ndev = ndev;\n\n\t/* Get IRQ for the device */\n\tres = platform_get_resource(ofdev, IORESOURCE_IRQ, 0);\n\tif (!res) {\n\t\tdev_err(dev, \"no IRQ found\\n\");\n\t\trc = -ENXIO;\n\t\tgoto error;\n\t}\n\n\tndev->irq = res->start;\n\n\tres = platform_get_resource(ofdev, IORESOURCE_MEM, 0);\n\tlp->base_addr = devm_ioremap_resource(&ofdev->dev, res);\n\tif (IS_ERR(lp->base_addr)) {\n\t\trc = PTR_ERR(lp->base_addr);\n\t\tgoto error;\n\t}\n\n\tndev->mem_start = res->start;\n\tndev->mem_end = res->end;\n\n\tspin_lock_init(&lp->reset_lock);\n\tlp->next_tx_buf_to_use = 0x0;\n\tlp->next_rx_buf_to_use = 0x0;\n\tlp->tx_ping_pong = get_bool(ofdev, \"xlnx,tx-ping-pong\");\n\tlp->rx_ping_pong = get_bool(ofdev, \"xlnx,rx-ping-pong\");\n\n\trc = of_get_mac_address(ofdev->dev.of_node, ndev->dev_addr);\n\tif (rc) {\n\t\tdev_warn(dev, \"No MAC address found, using random\\n\");\n\t\teth_hw_addr_random(ndev);\n\t}\n\n\t/* Clear the Tx CSR's in case this is a restart */\n\txemaclite_writel(0, lp->base_addr + XEL_TSR_OFFSET);\n\txemaclite_writel(0, lp->base_addr + XEL_BUFFER_OFFSET + XEL_TSR_OFFSET);\n\n\t/* Set the MAC address in the EmacLite device */\n\txemaclite_update_address(lp, ndev->dev_addr);\n\n\tlp->phy_node = of_parse_phandle(ofdev->dev.of_node, \"phy-handle\", 0);\n\txemaclite_mdio_setup(lp, &ofdev->dev);\n\n\tdev_info(dev, \"MAC address is now %pM\\n\", ndev->dev_addr);\n\n\tndev->netdev_ops = &xemaclite_netdev_ops;\n\tndev->ethtool_ops = &xemaclite_ethtool_ops;\n\tndev->flags &= ~IFF_MULTICAST;\n\tndev->watchdog_timeo = TX_TIMEOUT;\n\n\t/* Finally, register the device */\n\trc = register_netdev(ndev);\n\tif (rc) {\n\t\tdev_err(dev,\n\t\t\t\"Cannot register network device, aborting\\n\");\n\t\tgoto error;\n\t}\n\n\tdev_info(dev,\n\t\t \"Xilinx EmacLite at 0x%08lX mapped to 0x%p, irq=%d\\n\",\n\t\t (unsigned long __force)ndev->mem_start, lp->base_addr, ndev->irq);\n\treturn 0;\n\nerror:\n\tfree_netdev(ndev);\n\treturn rc;\n}", "target": 0, "idx": 9687}
{"commit_id": "05caadc7eedbef471ac9610809ba683f0c698700", "project": "libarchive", "func": "static int\nparse_codes(struct archive_read *a)\n{\n  int i, j, val, n, r;\n  unsigned char bitlengths[MAX_SYMBOLS], zerocount, ppmd_flags;\n  unsigned int maxorder;\n  struct huffman_code precode;\n  struct rar *rar = (struct rar *)(a->format->data);\n  struct rar_br *br = &(rar->br);\n\n  free_codes(a);\n\n  /* Skip to the next byte */\n  rar_br_consume_unalined_bits(br);\n\n  /* PPMd block flag */\n  if (!rar_br_read_ahead(a, br, 1))\n    goto truncated_data;\n  if ((rar->is_ppmd_block = rar_br_bits(br, 1)) != 0)\n  {\n    rar_br_consume(br, 1);\n    if (!rar_br_read_ahead(a, br, 7))\n      goto truncated_data;\n    ppmd_flags = rar_br_bits(br, 7);\n    rar_br_consume(br, 7);\n\n    /* Memory is allocated in MB */\n    if (ppmd_flags & 0x20)\n    {\n      if (!rar_br_read_ahead(a, br, 8))\n        goto truncated_data;\n      rar->dictionary_size = (rar_br_bits(br, 8) + 1) << 20;\n      rar_br_consume(br, 8);\n    }\n\n    if (ppmd_flags & 0x40)\n    {\n      if (!rar_br_read_ahead(a, br, 8))\n        goto truncated_data;\n      rar->ppmd_escape = rar->ppmd7_context.InitEsc = rar_br_bits(br, 8);\n      rar_br_consume(br, 8);\n    }\n    else\n      rar->ppmd_escape = 2;\n\n    if (ppmd_flags & 0x20)\n    {\n      maxorder = (ppmd_flags & 0x1F) + 1;\n      if(maxorder > 16)\n        maxorder = 16 + (maxorder - 16) * 3;\n\n      if (maxorder == 1)\n      {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"Truncated RAR file data\");\n        return (ARCHIVE_FATAL);\n      }\n\n      /* Make sure ppmd7_contest is freed before Ppmd7_Construct\n       * because reading a broken file cause this abnormal sequence. */\n      __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context, &g_szalloc);\n\n      rar->bytein.a = a;\n      rar->bytein.Read = &ppmd_read;\n      __archive_ppmd7_functions.PpmdRAR_RangeDec_CreateVTable(&rar->range_dec);\n      rar->range_dec.Stream = &rar->bytein;\n      __archive_ppmd7_functions.Ppmd7_Construct(&rar->ppmd7_context);\n\n      if (rar->dictionary_size == 0) {\n\t      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"Invalid zero dictionary size\");\n\t      return (ARCHIVE_FATAL);\n      }\n\n      if (!__archive_ppmd7_functions.Ppmd7_Alloc(&rar->ppmd7_context,\n        rar->dictionary_size, &g_szalloc))\n      {\n        archive_set_error(&a->archive, ENOMEM,\n                          \"Out of memory\");\n        return (ARCHIVE_FATAL);\n      }\n      if (!__archive_ppmd7_functions.PpmdRAR_RangeDec_Init(&rar->range_dec))\n      {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"Unable to initialize PPMd range decoder\");\n        return (ARCHIVE_FATAL);\n      }\n      __archive_ppmd7_functions.Ppmd7_Init(&rar->ppmd7_context, maxorder);\n      rar->ppmd_valid = 1;\n    }\n    else\n    {\n      if (!rar->ppmd_valid) {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"Invalid PPMd sequence\");\n        return (ARCHIVE_FATAL);\n      }\n      if (!__archive_ppmd7_functions.PpmdRAR_RangeDec_Init(&rar->range_dec))\n      {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"Unable to initialize PPMd range decoder\");\n        return (ARCHIVE_FATAL);\n      }\n    }\n  }\n  else\n  {\n    rar_br_consume(br, 1);\n\n    /* Keep existing table flag */\n    if (!rar_br_read_ahead(a, br, 1))\n      goto truncated_data;\n    if (!rar_br_bits(br, 1))\n      memset(rar->lengthtable, 0, sizeof(rar->lengthtable));\n    rar_br_consume(br, 1);\n\n    memset(&bitlengths, 0, sizeof(bitlengths));\n    for (i = 0; i < MAX_SYMBOLS;)\n    {\n      if (!rar_br_read_ahead(a, br, 4))\n        goto truncated_data;\n      bitlengths[i++] = rar_br_bits(br, 4);\n      rar_br_consume(br, 4);\n      if (bitlengths[i-1] == 0xF)\n      {\n        if (!rar_br_read_ahead(a, br, 4))\n          goto truncated_data;\n        zerocount = rar_br_bits(br, 4);\n        rar_br_consume(br, 4);\n        if (zerocount)\n        {\n          i--;\n          for (j = 0; j < zerocount + 2 && i < MAX_SYMBOLS; j++)\n            bitlengths[i++] = 0;\n        }\n      }\n    }\n\n    memset(&precode, 0, sizeof(precode));\n    r = create_code(a, &precode, bitlengths, MAX_SYMBOLS, MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK) {\n      free(precode.tree);\n      free(precode.table);\n      return (r);\n    }\n\n    for (i = 0; i < HUFFMAN_TABLE_SIZE;)\n    {\n      if ((val = read_next_symbol(a, &precode)) < 0) {\n        free(precode.tree);\n        free(precode.table);\n        return (ARCHIVE_FATAL);\n      }\n      if (val < 16)\n      {\n        rar->lengthtable[i] = (rar->lengthtable[i] + val) & 0xF;\n        i++;\n      }\n      else if (val < 18)\n      {\n        if (i == 0)\n        {\n          free(precode.tree);\n          free(precode.table);\n          archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                            \"Internal error extracting RAR file.\");\n          return (ARCHIVE_FATAL);\n        }\n\n        if(val == 16) {\n          if (!rar_br_read_ahead(a, br, 3)) {\n            free(precode.tree);\n            free(precode.table);\n            goto truncated_data;\n          }\n          n = rar_br_bits(br, 3) + 3;\n          rar_br_consume(br, 3);\n        } else {\n          if (!rar_br_read_ahead(a, br, 7)) {\n            free(precode.tree);\n            free(precode.table);\n            goto truncated_data;\n          }\n          n = rar_br_bits(br, 7) + 11;\n          rar_br_consume(br, 7);\n        }\n\n        for (j = 0; j < n && i < HUFFMAN_TABLE_SIZE; j++)\n        {\n          rar->lengthtable[i] = rar->lengthtable[i-1];\n          i++;\n        }\n      }\n      else\n      {\n        if(val == 18) {\n          if (!rar_br_read_ahead(a, br, 3)) {\n            free(precode.tree);\n            free(precode.table);\n            goto truncated_data;\n          }\n          n = rar_br_bits(br, 3) + 3;\n          rar_br_consume(br, 3);\n        } else {\n          if (!rar_br_read_ahead(a, br, 7)) {\n            free(precode.tree);\n            free(precode.table);\n            goto truncated_data;\n          }\n          n = rar_br_bits(br, 7) + 11;\n          rar_br_consume(br, 7);\n        }\n\n        for(j = 0; j < n && i < HUFFMAN_TABLE_SIZE; j++)\n          rar->lengthtable[i++] = 0;\n      }\n    }\n    free(precode.tree);\n    free(precode.table);\n\n    r = create_code(a, &rar->maincode, &rar->lengthtable[0], MAINCODE_SIZE,\n                MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK)\n      return (r);\n    r = create_code(a, &rar->offsetcode, &rar->lengthtable[MAINCODE_SIZE],\n                OFFSETCODE_SIZE, MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK)\n      return (r);\n    r = create_code(a, &rar->lowoffsetcode,\n                &rar->lengthtable[MAINCODE_SIZE + OFFSETCODE_SIZE],\n                LOWOFFSETCODE_SIZE, MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK)\n      return (r);\n    r = create_code(a, &rar->lengthcode,\n                &rar->lengthtable[MAINCODE_SIZE + OFFSETCODE_SIZE +\n                LOWOFFSETCODE_SIZE], LENGTHCODE_SIZE, MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK)\n      return (r);\n  }\n\n  if (!rar->dictionary_size || !rar->lzss.window)\n  {\n    /* Seems as though dictionary sizes are not used. Even so, minimize\n     * memory usage as much as possible.\n     */\n    void *new_window;\n    unsigned int new_size;\n\n    if (rar->unp_size >= DICTIONARY_MAX_SIZE)\n      new_size = DICTIONARY_MAX_SIZE;\n    else\n      new_size = rar_fls((unsigned int)rar->unp_size) << 1;\n    new_window = realloc(rar->lzss.window, new_size);\n    if (new_window == NULL) {\n      archive_set_error(&a->archive, ENOMEM,\n                        \"Unable to allocate memory for uncompressed data.\");\n      return (ARCHIVE_FATAL);\n    }\n    rar->lzss.window = (unsigned char *)new_window;\n    rar->dictionary_size = new_size;\n    memset(rar->lzss.window, 0, rar->dictionary_size);\n    rar->lzss.mask = rar->dictionary_size - 1;\n  }\n\n  rar->start_new_table = 0;\n  return (ARCHIVE_OK);\ntruncated_data:\n  archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                    \"Truncated RAR file data\");\n  rar->valid = 0;\n  return (ARCHIVE_FATAL);\n}", "target": 2, "idx": 9688}
{"commit_id": "8e76aef72820435e766c7f339ed36da33da90c40", "project": "xen-project/xen", "func": "void pt_restore_timer(struct vcpu *v)\n{\n    struct list_head *head = &v->arch.hvm.tm_list;\n    struct periodic_time *pt;\n\n    pt_vcpu_lock(v);\n\n    list_for_each_entry ( pt, head, list )\n    {\n        if ( pt->pending_intr_nr == 0 )\n        {\n            pt_process_missed_ticks(pt);\n            set_timer(&pt->timer, pt->scheduled);\n        }\n    }\n\n    pt_thaw_time(v);\n\n    pt_vcpu_unlock(v);\n}", "target": 1, "idx": 9689}
{"commit_id": "8dc9551e1d56290e6f7f02cc38b77e1d211fd4a5", "project": "wireshark", "func": "static proto_item *\nproto_tree_add_node(proto_tree *tree, field_info *fi)\n{\n\tproto_node *pnode, *tnode, *sibling;\n\tfield_info *tfi;\n\tint depth = 1;\n\n\t/*\n\t * Restrict our depth. proto_tree_traverse_pre_order and\n\t * proto_tree_traverse_post_order (and possibly others) are recursive\n\t * so we need to be mindful of our stack size.\n\t */\n\tif (tree->first_child == NULL) {\n\t\tfor (tnode = tree; tnode != NULL; tnode = tnode->parent) {\n\t\t\tdepth++;\n\t\t\tif (G_UNLIKELY(depth > MAX_TREE_LEVELS)) {\n\t\t\t\tTHROW_MESSAGE(DissectorError, wmem_strdup_printf(wmem_packet_scope(),\n\t\t\t\t\t\t     \"Maximum tree depth %d exceeded for \\\"%s\\\" - \\\"%s\\\" (%s:%u)\",\n\t\t\t\t\t\t     MAX_TREE_LEVELS,\n\t\t\t\t\t\t     fi->hfinfo->name, fi->hfinfo->abbrev, G_STRFUNC, __LINE__));\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Make sure \"tree\" is ready to have subtrees under it, by\n\t * checking whether it's been given an ett_ value.\n\t *\n\t * \"PNODE_FINFO(tnode)\" may be null; that's the case for the root\n\t * node of the protocol tree.  That node is not displayed,\n\t * so it doesn't need an ett_ value to remember whether it\n\t * was expanded.\n\t */\n\ttnode = tree;\n\ttfi = PNODE_FINFO(tnode);\n\tif (tfi != NULL && (tfi->tree_type < 0 || tfi->tree_type >= num_tree_types)) {\n\t\tREPORT_DISSECTOR_BUG(wmem_strdup_printf(wmem_packet_scope(),\n\t\t\t\t     \"\\\"%s\\\" - \\\"%s\\\" tfi->tree_type: %u invalid (%s:%u)\",\n\t\t\t\t     fi->hfinfo->name, fi->hfinfo->abbrev, tfi->tree_type, __FILE__, __LINE__));\n\t\t/* XXX - is it safe to continue here? */\n\t}\n\n\tpnode = wmem_new(PNODE_POOL(tree), proto_node);\n\tPROTO_NODE_INIT(pnode);\n\tpnode->parent = tnode;\n\tPNODE_FINFO(pnode) = fi;\n\tpnode->tree_data = PTREE_DATA(tree);\n\n\tif (tnode->last_child != NULL) {\n\t\tsibling = tnode->last_child;\n\t\tDISSECTOR_ASSERT(sibling->next == NULL);\n\t\tsibling->next = pnode;\n\t} else\n\t\ttnode->first_child = pnode;\n\ttnode->last_child = pnode;\n\n\ttree_data_add_maybe_interesting_field(pnode->tree_data, fi);\n\n\treturn (proto_item *)pnode;\n}", "target": 1, "idx": 9690}
{"commit_id": "afc39bea36fd436e54262f150c009e8d72db5014", "project": "envoyproxy/envoy", "func": "void HeaderMapImpl::remove(const LowerCaseString& key) {\n  EntryCb cb = ConstSingleton<StaticLookupTable>::get().find(key.get());\n  if (cb) {\n    StaticLookupResponse ref_lookup_response = cb(*this);\n    removeInline(ref_lookup_response.entry_);\n  } else {\n    for (auto i = headers_.begin(); i != headers_.end();) {\n      if (i->key() == key.get().c_str()) {\n        subtractSize(i->key().size() + i->value().size());\n        i = headers_.erase(i);\n      } else {\n        ++i;\n      }\n    }\n  }\n}", "target": 2, "idx": 9691}
{"commit_id": "dafc397fdc3655aeb5c7b9963a43f1604c6a2062", "project": "RIOT-OS/RIOT", "func": "static gnrc_pktsnip_t *_iphc_encode(gnrc_pktsnip_t *pkt,\n                                    const gnrc_netif_hdr_t *netif_hdr,\n                                    gnrc_netif_t *iface)\n{\n    assert(pkt != NULL);\n    uint8_t *iphc_hdr;\n    gnrc_pktsnip_t *dispatch, *ptr = pkt->next;\n    size_t dispatch_size = 0;\n    uint16_t inline_pos = 0;\n    uint8_t nh;\n\n    dispatch = NULL;    /* use dispatch as temporary pointer for prev */\n    /* determine maximum dispatch size and write protect all headers until\n     * then because they will be removed */\n    while ((ptr != NULL) && _compressible(ptr)) {\n        gnrc_pktsnip_t *tmp = gnrc_pktbuf_start_write(ptr);\n\n        if (tmp == NULL) {\n            DEBUG(\"6lo iphc: unable to write protect compressible header\\n\");\n            return NULL;\n        }\n        ptr = tmp;\n        if (dispatch == NULL) {\n            /* pkt was already write protected in gnrc_sixlowpan.c:_send so\n             * we shouldn't do it again */\n            pkt->next = ptr;    /* reset original packet */\n        }\n        else {\n            dispatch->next = ptr;\n        }\n        dispatch_size += ptr->size;\n        dispatch = ptr; /* use dispatch as temporary point for prev */\n        ptr = ptr->next;\n    }\n    /* there should be at least one compressible header in `pkt`, otherwise this\n     * function should not be called */\n    assert(dispatch_size > 0);\n    dispatch = gnrc_pktbuf_add(NULL, NULL, dispatch_size + 1,\n                               GNRC_NETTYPE_SIXLOWPAN);\n\n    if (dispatch == NULL) {\n        DEBUG(\"6lo iphc: error allocating dispatch space\\n\");\n        return NULL;\n    }\n\n    iphc_hdr = dispatch->data;\n    inline_pos = _iphc_ipv6_encode(pkt, netif_hdr, iface, iphc_hdr);\n\n    if (inline_pos == 0) {\n        DEBUG(\"6lo iphc: error encoding IPv6 header\\n\");\n        gnrc_pktbuf_release(dispatch);\n        return NULL;\n    }\n\n    nh = ((ipv6_hdr_t *)pkt->next->data)->nh;\n#ifdef MODULE_GNRC_SIXLOWPAN_IPHC_NHC\n    while (_compressible_nh(nh)) {\n        ssize_t local_pos = 0;\n        if (pkt->next->next == NULL) {\n            DEBUG(\"6lo iphc: packet next header missing data\");\n            gnrc_pktbuf_release(dispatch);\n            return NULL;\n        }\n        switch (nh) {\n            case PROTNUM_UDP:\n                local_pos = _nhc_udp_encode_snip(pkt, &iphc_hdr[inline_pos]);\n                /* abort loop on next iteration */\n                nh = PROTNUM_RESERVED;\n                break;\n            case PROTNUM_IPV6: {    /* encapsulated IPv6 header */\n                local_pos = _nhc_ipv6_encode_snip(pkt, netif_hdr, iface,\n                                                  &iphc_hdr[inline_pos], &nh);\n                break;\n            }\n            case PROTNUM_IPV6_EXT_HOPOPT:\n            case PROTNUM_IPV6_EXT_RH:\n            case PROTNUM_IPV6_EXT_FRAG:\n            case PROTNUM_IPV6_EXT_DST:\n            case PROTNUM_IPV6_EXT_MOB:\n                local_pos = _nhc_ipv6_ext_encode_snip(pkt,\n                                                      &iphc_hdr[inline_pos],\n                                                      &nh);\n                if (local_pos == 0) {\n                    /* abort loop, extension header is not compressible as\n                     * length field is too large value */\n                    nh = PROTNUM_RESERVED;\n                }\n                break;\n            default:\n                /* abort loop on next iteration */\n                nh = PROTNUM_RESERVED;\n                break;\n        }\n        if (local_pos < 0) {\n            DEBUG(\"6lo iphc: error on compressing next header\\n\");\n            gnrc_pktbuf_release(dispatch);\n            return NULL;\n        }\n        inline_pos += local_pos;\n    }\n#endif\n\n    /* shrink dispatch allocation to final size */\n    /* NOTE: Since this only shrinks the data nothing bad SHOULD happen ;-) */\n    gnrc_pktbuf_realloc_data(dispatch, (size_t)inline_pos);\n\n    /* remove IPv6 header */\n    pkt = gnrc_pktbuf_remove_snip(pkt, pkt->next);\n\n    /* insert dispatch into packet */\n    dispatch->next = pkt->next;\n    pkt->next = dispatch;\n    return pkt;\n}", "target": 3, "idx": 9692}
{"commit_id": "4e245d758e1c826a01080d40c22ca8706f0339e5", "project": "GNOME/balsa", "func": "static ImapResult\nimap_mbox_connect(ImapMboxHandle* handle)\n{\n  ImapResponse resp;\n  GError *error = NULL;\n\n  /* reset some handle status */\n  handle->op_cancelled = FALSE;\n  handle->has_capabilities = FALSE;\n  handle->can_fetch_body = TRUE;\n  handle->idle_state = IDLE_INACTIVE;\n  if(handle->sio) {\n    g_object_unref(handle->sio); handle->sio = NULL;\n  }\n\n  handle->sio = net_client_siobuf_new(handle->host,\n\t  handle->tls_mode == NET_CLIENT_CRYPT_ENCRYPTED ? 993 : 143);\n  g_signal_connect(handle->sio, \"auth\", handle->auth_cb, handle->auth_arg);\n  g_signal_connect(handle->sio, \"cert-check\", handle->cert_cb, handle->sio);\n  /* FIXME - client certificate? */\n  if (!net_client_connect(NET_CLIENT(handle->sio), &error)) {\n\timap_mbox_handle_set_msg(handle, _(\"Connecting %s failed: %s\"), handle->host, error_safe(error));\n\tg_clear_error(&error);\n\treturn IMAP_CONNECT_FAILED;\n  }\n  \n#if 0\n  if(handle->timeout>0) {\n    sio_set_timeout(handle->sio, handle->timeout);\n    sio_set_timeoutcb(handle->sio, imap_timeout_cb, handle);\n  }\n#endif\n  if (handle->tls_mode == NET_CLIENT_CRYPT_ENCRYPTED) {\n    if (!net_client_start_tls(NET_CLIENT(handle->sio), &error)) {\n      imap_mbox_handle_set_msg(handle, _(\"TLS negotiation failed: %s\"), error_safe(error));\n\t  g_clear_error(&error);\n      return IMAP_UNSECURE;\n    }\n  }\n\n  handle->state = IMHS_CONNECTED;\n  if ( (resp=imap_cmd_step(handle, 0)) != IMR_UNTAGGED) {\n    g_message(\"imap_mbox_connect:unexpected initial response(%d): %s\",\n\t      resp, handle->last_msg);\n    imap_handle_disconnect(handle);\n    return IMAP_PROTOCOL_ERROR;\n  }\n  handle->can_fetch_body = (handle->last_msg != NULL) &&\n    (strncmp(handle->last_msg, \"Microsoft Exchange\", 18) != 0);\n  if((handle->tls_mode == NET_CLIENT_CRYPT_ENCRYPTED) ||\n\t (handle->tls_mode == NET_CLIENT_CRYPT_NONE)) {\n    resp = IMAP_SUCCESS; /* secured already with SSL, or no encryption requested */\n  } else if(imap_mbox_handle_can_do(handle, IMCAP_STARTTLS)) {\n    if( imap_handle_starttls(handle, &error) != IMR_OK) {\n      imap_mbox_handle_set_msg(handle, _(\"TLS negotiation failed: %s\"), error_safe(error));\n      resp = IMAP_UNSECURE; /* TLS negotiation error */\n    } else {\n      resp = IMAP_SUCCESS; /* secured with TLS */\n    }\n  } else {\n\timap_mbox_handle_set_msg(handle, _(\"TLS required but not available\"));\n    resp = IMR_NO; /* TLS unavailable */\n  }\n\n  return resp;\n}", "target": 2, "idx": 9693}
{"commit_id": "50f54462076648ac2e36c3f58f4dadd4babbf1c9", "project": "ImageMagick", "func": "static Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    colorspace[MagickPathExtent],\n    text[MagickPathExtent];\n\n  Image\n    *image;\n\n  long\n    x_offset,\n    y_offset;\n\n  PixelInfo\n    pixel;\n\n  MagickBooleanType\n    status;\n\n  QuantumAny\n    range;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  ssize_t\n    count,\n    type,\n    y;\n\n  unsigned long\n    depth,\n    height,\n    max_value,\n    width;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) ResetMagickMemory(text,0,sizeof(text));\n  (void) ReadBlobString(image,text);\n  if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) != 0)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  do\n  {\n    width=0;\n    height=0;\n    max_value=0;\n    *colorspace='\\0';\n    count=(ssize_t) sscanf(text+32,\"%lu,%lu,%lu,%s\",&width,&height,&max_value,\n      colorspace);\n    if ((count != 4) || (width == 0) || (height == 0) || (max_value == 0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    image->columns=width;\n    image->rows=height;\n    for (depth=1; (GetQuantumRange(depth)+1) < max_value; depth++)\n      if (depth >= 64)\n        break;\n    image->depth=depth;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    LocaleLower(colorspace);\n    i=(ssize_t) strlen(colorspace)-1;\n    image->alpha_trait=UndefinedPixelTrait;\n    if ((i > 0) && (colorspace[i] == 'a'))\n      {\n        colorspace[i]='\\0';\n        image->alpha_trait=BlendPixelTrait;\n      }\n    type=ParseCommandOption(MagickColorspaceOptions,MagickFalse,colorspace);\n    if (type < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    (void) SetImageBackgroundColor(image,exception);\n    (void) SetImageColorspace(image,(ColorspaceType) type,exception);\n    GetPixelInfo(image,&pixel);\n    range=GetQuantumRange(image->depth);\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      double\n        alpha,\n        black,\n        blue,\n        green,\n        red;\n\n      red=0.0;\n      green=0.0;\n      blue=0.0;\n      black=0.0;\n      alpha=0.0;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        if (ReadBlobString(image,text) == (char *) NULL)\n          break;\n        switch (image->colorspace)\n        {\n          case GRAYColorspace:\n          {\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                count=(ssize_t) sscanf(text,\"%ld,%ld: (%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&alpha);\n                green=red;\n                blue=red;\n                break;\n              }\n            count=(ssize_t) sscanf(text,\"%ld,%ld: (%lf%*[%,]\",&x_offset,\n              &y_offset,&red);\n            green=red;\n            blue=red;\n            break;       \n          }\n          case CMYKColorspace:\n          {\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                count=(ssize_t) sscanf(text,\n                  \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&green,&blue,&black,&alpha);\n                break;\n              }\n            count=(ssize_t) sscanf(text,\n              \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",&x_offset,\n              &y_offset,&red,&green,&blue,&black);\n            break;\n          }\n          default:\n          {\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                count=(ssize_t) sscanf(text,\n                  \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&green,&blue,&alpha);\n                break;\n              }\n            count=(ssize_t) sscanf(text,\n              \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]\",&x_offset,\n              &y_offset,&red,&green,&blue);\n            break;       \n          }\n        }\n        if (strchr(text,'%') != (char *) NULL)\n          {\n            red*=0.01*range;\n            green*=0.01*range;\n            blue*=0.01*range;\n            black*=0.01*range;\n            alpha*=0.01*range;\n          }\n        if (image->colorspace == LabColorspace)\n          {\n            green+=(range+1)/2.0;\n            blue+=(range+1)/2.0;\n          }\n        pixel.red=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (red+0.5),\n          range);\n        pixel.green=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (green+0.5),\n          range);\n        pixel.blue=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (blue+0.5),\n          range);\n        pixel.black=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (black+0.5),\n          range);\n        pixel.alpha=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (alpha+0.5),\n          range);\n        q=GetAuthenticPixels(image,(ssize_t) x_offset,(ssize_t) y_offset,1,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          continue;\n        SetPixelViaPixelInfo(image,&pixel,q);\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n      }\n    }\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    (void) ReadBlobString(image,text);\n    if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}", "target": 1, "idx": 9694}
{"commit_id": "3bf4b7c9a4c923e66d5e836b598d17501865dc18", "project": "jerryscript-project/jerryscript", "func": "static void\nparser_reparse_as_common_identifier (parser_context_t *context_p, /**< context */\n                                     parser_line_counter_t start_line, /**< start line */\n                                     parser_line_counter_t start_column) /**< start column */\n{\n  /* context_p->token.lit_location.char_p is showing the character after the string start,\n     so it is not suitable for reparsing as identifier.\n     e.g.: { 'foo' } */\n  if (context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n  {\n    parser_raise_error (context_p, PARSER_ERR_IDENTIFIER_EXPECTED);\n  }\n\n  context_p->source_p = context_p->token.lit_location.char_p;\n  context_p->line = start_line;\n  context_p->column = start_column;\n\n  lexer_next_token (context_p);\n\n  if (context_p->token.type != LEXER_LITERAL)\n  {\n    parser_raise_error (context_p, PARSER_ERR_IDENTIFIER_EXPECTED);\n  }\n\n  JERRY_ASSERT (context_p->token.lit_location.type == LEXER_IDENT_LITERAL);\n\n  lexer_construct_literal_object (context_p,\n                                  &context_p->token.lit_location,\n                                  LEXER_IDENT_LITERAL);\n\n}", "target": 2, "idx": 9695}
{"commit_id": "17405b975948abc216f6a085d2d027ec1cfd5766", "project": "hongliuliao/ehttp", "func": "int Request::parse_request(const char *read_buffer, int read_size) {\n    _total_req_size += read_size;\n    if (_total_req_size > MAX_REQ_SIZE) {\n        LOG_INFO(\"TOO BIG REQUEST WE WILL REFUSE IT! MAX_REQ_SIZE:%d\", MAX_REQ_SIZE);\n        return -1;\n    }\n    LOG_DEBUG(\"read from client: size:%d, content:%.4096s\", read_size, read_buffer);\n    ssize_t nparsed = http_parser_execute(&_parser, &_settings, read_buffer, read_size);\n    if (nparsed != read_size) {\n        std::string err_msg = \"unkonw\";\n        if (_parser.http_errno) {\n            err_msg = http_errno_description(HTTP_PARSER_ERRNO(&_parser));\n        }\n        LOG_ERROR(\"parse request error, nparsed:%jd, input size:%d! msg:%s\", \n                nparsed, read_size, err_msg.c_str());\n        return -1;\n    }\n\n    if (_parse_err) {\n        return _parse_err;\n    }\n    if (_parse_part != PARSE_REQ_OVER) {\n        return NEED_MORE_STATUS;\n    }\n    return 0;\n}", "target": 2, "idx": 9696}
{"commit_id": "1ac2c130b210539ee1e5d67a7bac93f9d8007c0e", "project": "reddit/snudown", "func": "struct sd_markdown *\nsd_markdown_new(\n\tunsigned int extensions,\n\tsize_t max_nesting,\n\tsize_t max_table_cols,\n\tconst struct sd_callbacks *callbacks,\n\tvoid *opaque)\n{\n\tstruct sd_markdown *md = NULL;\n\n\tassert(max_nesting > 0 && max_table_cols > 0 && callbacks);\n\n\tmd = malloc(sizeof(struct sd_markdown));\n\tif (!md)\n\t\treturn NULL;\n\n\tif (!sip_hash_key_init) {\n\t\tif (getrandom(sip_hash_key, SIP_HASH_KEY_LEN, 0) < SIP_HASH_KEY_LEN)\n\t\t\treturn NULL;\n\t\tsip_hash_key_init = 1;\n\t}\n\n\tmemcpy(&md->cb, callbacks, sizeof(struct sd_callbacks));\n\n\tstack_init(&md->work_bufs[BUFFER_BLOCK], 4);\n\tstack_init(&md->work_bufs[BUFFER_SPAN], 8);\n\n\tmemset(md->active_char, 0x0, 256);\n\n\tif (md->cb.emphasis || md->cb.double_emphasis || md->cb.triple_emphasis) {\n\t\tmd->active_char['*'] = MD_CHAR_EMPHASIS;\n\t\tmd->active_char['_'] = MD_CHAR_EMPHASIS;\n\t\tmd->active_char['>'] = MD_CHAR_EMPHASIS;\n\t\tif (extensions & MKDEXT_STRIKETHROUGH)\n\t\t\tmd->active_char['~'] = MD_CHAR_EMPHASIS;\n\t}\n\n\tif (md->cb.codespan)\n\t\tmd->active_char['`'] = MD_CHAR_CODESPAN;\n\n\tif (md->cb.linebreak)\n\t\tmd->active_char['\\n'] = MD_CHAR_LINEBREAK;\n\n\tif (md->cb.image || md->cb.link)\n\t\tmd->active_char['['] = MD_CHAR_LINK;\n\n\tmd->active_char['<'] = MD_CHAR_LANGLE;\n\tmd->active_char['\\\\'] = MD_CHAR_ESCAPE;\n\tmd->active_char['&'] = MD_CHAR_ENTITITY;\n\n\tif (extensions & MKDEXT_AUTOLINK) {\n\t\tif (!(extensions & MKDEXT_NO_EMAIL_AUTOLINK))\n\t\t\tmd->active_char['@'] = MD_CHAR_AUTOLINK_EMAIL;\n\t\tmd->active_char[':'] = MD_CHAR_AUTOLINK_URL;\n\t\tmd->active_char['w'] = MD_CHAR_AUTOLINK_WWW;\n\t\tmd->active_char['/'] = MD_CHAR_AUTOLINK_SUBREDDIT_OR_USERNAME;\n\t}\n\n\tif (extensions & MKDEXT_SUPERSCRIPT)\n\t\tmd->active_char['^'] = MD_CHAR_SUPERSCRIPT;\n\n\t/* Extension data */\n\tmd->ext_flags = extensions;\n\tmd->opaque = opaque;\n\tmd->max_nesting = max_nesting;\n\tmd->max_table_cols = max_table_cols;\n\tmd->in_link_body = 0;\n\n\treturn md;\n}", "target": 1, "idx": 9697}
{"commit_id": "1cbd25ca15383394ffa9ee8601c5de4c0f2f90e1", "project": "php/php-src", "func": "static void spl_ptr_heap_insert(spl_ptr_heap *heap, spl_ptr_heap_element elem, void *cmp_userdata TSRMLS_DC) { /* {{{ */\n\tint i;\n\n\tif (heap->count+1 > heap->max_size) {\n\t\t/* we need to allocate more memory */\n\t\theap->elements  = (void **) safe_erealloc(heap->elements, sizeof(spl_ptr_heap_element), (heap->max_size), (sizeof(spl_ptr_heap_element) * (heap->max_size)));\n\t\theap->max_size *= 2;\n\t}\n\n\theap->ctor(elem TSRMLS_CC);\n\n\t/* sifting up */\n\tfor(i = heap->count; i > 0 && heap->cmp(heap->elements[(i-1)/2], elem, cmp_userdata TSRMLS_CC) < 0; i = (i-1)/2) {\n\t\theap->elements[i] = heap->elements[(i-1)/2];\n\t}\n\theap->count++;\n\n\tif (EG(exception)) {\n\t\t/* exception thrown during comparison */\n\t\theap->flags |= SPL_HEAP_CORRUPTED;\n\t}\n\n\theap->elements[i] = elem;\n\n}", "target": 3, "idx": 9698}
{"commit_id": "4324f0ac59f8225aa44bc5034df60dbeccd1d334", "project": "owasp-modsecurity/ModSecurity", "func": "static int var_files_tmp_contents_generate(modsec_rec *msr, msre_var *var,\n    msre_rule *rule, apr_table_t *vartab, apr_pool_t *mptmp)\n{\n    multipart_part **parts = NULL;\n    int i, count = 0;\n\n    if (msr->mpd == NULL) return 0;\n\n    parts = (multipart_part **)msr->mpd->parts->elts;\n    for (i = 0; i < msr->mpd->parts->nelts; i++)\n    {\n        if ((parts[i]->type == MULTIPART_FILE) &&\n                (parts[i]->tmp_file_name != NULL))\n        {\n            int match = 0;\n\n            /* Figure out if we want to include this variable. */\n            if (var->param == NULL)\n            {\n                match = 1;\n            }\n            else\n            {\n                if (var->param_data != NULL)\n                {\n                    /* Regex. */\n                    char *my_error_msg = NULL;\n                    if (!(msc_regexec((msc_regex_t *)var->param_data,\n                        parts[i]->name, strlen(parts[i]->name),\n                        &my_error_msg) == PCRE_ERROR_NOMATCH)) \n                    {\n                        match = 1;\n                    }\n                }\n                else\n                {\n                    /* Simple comparison. */\n                    if (strcasecmp(parts[i]->name, var->param) == 0)\n                    {\n                        match = 1;\n                    }\n                }\n            }\n            /* If we had a match add this argument to the collection. */\n            if (match) {\n                char buf[1024];\n                FILE *file;\n                size_t nread;\n                char *full_content = NULL;\n                char *full_content_tmp_ptr = NULL;\n                size_t total_lenght = 0;\n                msre_var *rvar = NULL;\n\n                file = fopen(parts[i]->tmp_file_name, \"r\");\n                if (file == NULL)\n                {\n                    continue;\n                }\n\n                full_content = (char *)apr_pcalloc(mptmp, (sizeof(char)*parts[i]->length) + 1);\n                if (full_content == NULL) {\n                    if (msr->txcfg->debuglog_level >= 3) {\n                        msr_log(msr, 3, \"Variable FILES_TMP_CONTENT will not be created, not \" \\\n                            \"enough memory available.\");\n                    }\n                    goto files_tmp_content_not_enough_mem;\n                }\n                full_content_tmp_ptr = full_content;\n\n                while ((nread = fread(buf, 1, 1023, file)) > 0)\n                {   \n                    full_content_tmp_ptr = memcpy(full_content_tmp_ptr, buf, nread);\n                    full_content_tmp_ptr += nread;\n                    total_lenght         += nread;\n                }\n                full_content_tmp_ptr[total_lenght] = '\\0';\n                fclose(file);\n\n                rvar = apr_pmemdup(mptmp, var, sizeof(msre_var));\n                rvar->value = full_content;\n                rvar->value_len = total_lenght;\n                rvar->name = apr_psprintf(mptmp, \"FILES_TMP_CONTENT:%s\",\n                    log_escape_nq(mptmp, parts[i]->name));\n                apr_table_addn(vartab, rvar->name, (void *)rvar);\n\n                count++;\n            }\n        }\n    }\n\nfiles_tmp_content_not_enough_mem:\n    return count;\n}", "target": 2, "idx": 9699}
{"commit_id": "702dbcc274e2ca43be20ba64c758c0ca57dab91d", "project": "qemu", "func": "int v9fs_device_realize_common(V9fsState *s, Error **errp)\n{\n    V9fsVirtioState *v = container_of(s, V9fsVirtioState, state);\n    int i, len;\n    struct stat stat;\n    FsDriverEntry *fse;\n    V9fsPath path;\n    int rc = 1;\n\n    /* initialize pdu allocator */\n    QLIST_INIT(&s->free_list);\n    QLIST_INIT(&s->active_list);\n    for (i = 0; i < (MAX_REQ - 1); i++) {\n        QLIST_INSERT_HEAD(&s->free_list, &v->pdus[i], next);\n        v->pdus[i].s = s;\n        v->pdus[i].idx = i;\n    }\n\n    v9fs_path_init(&path);\n\n    fse = get_fsdev_fsentry(s->fsconf.fsdev_id);\n\n    if (!fse) {\n        /* We don't have a fsdev identified by fsdev_id */\n        error_setg(errp, \"9pfs device couldn't find fsdev with the \"\n                   \"id = %s\",\n                   s->fsconf.fsdev_id ? s->fsconf.fsdev_id : \"NULL\");\n        goto out;\n    }\n\n    if (!s->fsconf.tag) {\n        /* we haven't specified a mount_tag */\n        error_setg(errp, \"fsdev with id %s needs mount_tag arguments\",\n                   s->fsconf.fsdev_id);\n        goto out;\n    }\n\n    s->ctx.export_flags = fse->export_flags;\n    s->ctx.fs_root = g_strdup(fse->path);\n    s->ctx.exops.get_st_gen = NULL;\n    len = strlen(s->fsconf.tag);\n    if (len > MAX_TAG_LEN - 1) {\n        error_setg(errp, \"mount tag '%s' (%d bytes) is longer than \"\n                   \"maximum (%d bytes)\", s->fsconf.tag, len, MAX_TAG_LEN - 1);\n        goto out;\n    }\n\n    s->tag = g_strdup(s->fsconf.tag);\n    s->ctx.uid = -1;\n\n    s->ops = fse->ops;\n\n    s->fid_list = NULL;\n    qemu_co_rwlock_init(&s->rename_lock);\n\n    if (s->ops->init(&s->ctx) < 0) {\n        error_setg(errp, \"9pfs Failed to initialize fs-driver with id:%s\"\n                   \" and export path:%s\", s->fsconf.fsdev_id, s->ctx.fs_root);\n        goto out;\n    }\n\n    /*\n     * Check details of export path, We need to use fs driver\n     * call back to do that. Since we are in the init path, we don't\n     * use co-routines here.\n     */\n    if (s->ops->name_to_path(&s->ctx, NULL, \"/\", &path) < 0) {\n        error_setg(errp,\n                   \"error in converting name to path %s\", strerror(errno));\n        goto out;\n    }\n    if (s->ops->lstat(&s->ctx, &path, &stat)) {\n        error_setg(errp, \"share path %s does not exist\", fse->path);\n        goto out;\n    } else if (!S_ISDIR(stat.st_mode)) {\n        error_setg(errp, \"share path %s is not a directory\", fse->path);\n        goto out;\n    }\n    v9fs_path_free(&path);\n\n    rc = 0;\nout:\n    if (rc) {\n        if (s->ops->cleanup && s->ctx.private) {\n            s->ops->cleanup(&s->ctx);\n        }\n        g_free(s->tag);\n        g_free(s->ctx.fs_root);\n        v9fs_path_free(&path);\n    }\n    return rc;\n}", "target": 1, "idx": 9700}
{"commit_id": "6e4dd9ec3f14b48170fc45dc9d13a3261765f994", "project": "facebook/hhvm", "func": "int64_t BZ2File::readImpl(char * buf, int64_t length) {\n  if (length == 0) {\n    return 0;\n  }\n  assertx(m_bzFile);\n  int len = BZ2_bzread(m_bzFile, buf, length);\n  /* Sometimes libbz2 will return fewer bytes than requested, and set bzerror\n   * to BZ_STREAM_END, but it's not actually EOF, and you can keep reading from\n   * the file - so, only set EOF after a failed read. This matches PHP5.\n   */\n  if (len <= 0) {\n    setEof(true);\n    if (len < 0) {\n      return 0;\n    }\n  }\n  return len;\n}", "target": 3, "idx": 9701}
{"commit_id": "ee301cb2029db8a6289c5295daa42bba7715e99a", "project": "DanBloomberg/leptonica", "func": "GPLOT *\ngplotRead(const char  *filename)\n{\nchar     buf[L_BUFSIZE];\nchar    *rootname, *title, *xlabel, *ylabel, *ignores;\nl_int32  outformat, ret, version, ignore;\nFILE    *fp;\nGPLOT   *gplot;\n\n    PROCNAME(\"gplotRead\");\n\n    if (!filename)\n        return (GPLOT *)ERROR_PTR(\"filename not defined\", procName, NULL);\n\n    if ((fp = fopenReadStream(filename)) == NULL)\n        return (GPLOT *)ERROR_PTR(\"stream not opened\", procName, NULL);\n\n    ret = fscanf(fp, \"Gplot Version %d\\n\", &version);\n    if (ret != 1) {\n        fclose(fp);\n        return (GPLOT *)ERROR_PTR(\"not a gplot file\", procName, NULL);\n    }\n    if (version != GPLOT_VERSION_NUMBER) {\n        fclose(fp);\n        return (GPLOT *)ERROR_PTR(\"invalid gplot version\", procName, NULL);\n    }\n\n    ignore = fscanf(fp, \"Rootname: %511s\\n\", buf);  /* L_BUFSIZE - 1 */\n    rootname = stringNew(buf);\n    ignore = fscanf(fp, \"Output format: %d\\n\", &outformat);\n    ignores = fgets(buf, L_BUFSIZE, fp);   /* Title: ... */\n    title = stringNew(buf + 7);\n    title[strlen(title) - 1] = '\\0';\n    ignores = fgets(buf, L_BUFSIZE, fp);   /* X axis label: ... */\n    xlabel = stringNew(buf + 14);\n    xlabel[strlen(xlabel) - 1] = '\\0';\n    ignores = fgets(buf, L_BUFSIZE, fp);   /* Y axis label: ... */\n    ylabel = stringNew(buf + 14);\n    ylabel[strlen(ylabel) - 1] = '\\0';\n\n    gplot = gplotCreate(rootname, outformat, title, xlabel, ylabel);\n    LEPT_FREE(rootname);\n    LEPT_FREE(title);\n    LEPT_FREE(xlabel);\n    LEPT_FREE(ylabel);\n    if (!gplot) {\n        fclose(fp);\n        return (GPLOT *)ERROR_PTR(\"gplot not made\", procName, NULL);\n    }\n    sarrayDestroy(&gplot->cmddata);\n    sarrayDestroy(&gplot->datanames);\n    sarrayDestroy(&gplot->plotdata);\n    sarrayDestroy(&gplot->plottitles);\n    numaDestroy(&gplot->plotstyles);\n\n    ignore = fscanf(fp, \"Commandfile name: %511s\\n\", buf);  /* L_BUFSIZE - 1 */\n    stringReplace(&gplot->cmdname, buf);\n    ignore = fscanf(fp, \"\\nCommandfile data:\");\n    gplot->cmddata = sarrayReadStream(fp);\n    ignore = fscanf(fp, \"\\nDatafile names:\");\n    gplot->datanames = sarrayReadStream(fp);\n    ignore = fscanf(fp, \"\\nPlot data:\");\n    gplot->plotdata = sarrayReadStream(fp);\n    ignore = fscanf(fp, \"\\nPlot titles:\");\n    gplot->plottitles = sarrayReadStream(fp);\n    ignore = fscanf(fp, \"\\nPlot styles:\");\n    gplot->plotstyles = numaReadStream(fp);\n\n    ignore = fscanf(fp, \"Number of plots: %d\\n\", &gplot->nplots);\n    ignore = fscanf(fp, \"Output file name: %511s\\n\", buf);\n    stringReplace(&gplot->outname, buf);\n    ignore = fscanf(fp, \"Axis scaling: %d\\n\", &gplot->scaling);\n\n    fclose(fp);\n    return gplot;\n}", "target": 3, "idx": 9702}
{"commit_id": "55ffdb08bb5c12cfd5e2fee05f8c01d23ceaf9a3", "project": "wireshark", "func": "void\nconversation_set_addr2(conversation_t *conv, const address *addr)\n{\n    char* addr_str;\n    DISSECTOR_ASSERT_HINT(!(conv->options & CONVERSATION_TEMPLATE),\n            \"Use the conversation_create_from_template function when the CONVERSATION_TEMPLATE bit is set in the options mask\");\n\n    addr_str = address_to_str(NULL, addr);\n    DPRINT((\"called for addr=%s\", addr_str));\n    wmem_free(NULL, addr_str);\n\n    /*\n     * If the address 2 value is not wildcarded, don't set it.\n     */\n    if (!(conv->options & NO_ADDR2))\n        return;\n\n    DINDENT();\n    if (conv->options & NO_PORT2) {\n        conversation_remove_from_hashtable(conversation_hashtable_no_addr2_or_port2, conv);\n    } else {\n        conversation_remove_from_hashtable(conversation_hashtable_no_addr2, conv);\n    }\n\n    // Shift our endpoint and, if needed, our port element over and set our address.\n    // We assume that conv->key_ptr was created with conversation_new and that we have\n    // enough element slots.\n    conv->options &= ~NO_ADDR2;\n    wmem_map_t *hashtable;\n    if (conv->options & NO_PORT2) {\n        // addr1,port1,endp -> addr1,port1,addr2,endp\n        conv->key_ptr[ENDP_NO_PORT2_IDX] = conv->key_ptr[ENDP_NO_ADDR2_PORT2_IDX];\n        hashtable = conversation_hashtable_no_port2;\n    } else {\n        // addr1,port1,port2,endp -> addr1,port1,addr2,port2,endp\n        conv->key_ptr[ENDP_EXACT_IDX] = conv->key_ptr[ENDP_NO_ADDR2_IDX];\n        conv->key_ptr[PORT2_IDX] = conv->key_ptr[PORT2_NO_ADDR2_IDX];\n        hashtable = conversation_hashtable_exact_addr_port;\n    }\n    conv->key_ptr[ADDR2_IDX].type = CE_ADDRESS;\n    copy_address_wmem(wmem_file_scope(), &conv->key_ptr[ADDR2_IDX].addr_val, addr);\n    conversation_insert_into_hashtable(hashtable, conv);\n    DENDENT();\n}", "target": 1, "idx": 9703}
{"commit_id": "1ec82e6e97e1db06a72ca505f9fbf6b981f31ef7", "project": "redis", "func": "void appendCommand(client *c) {\n    size_t totlen;\n    robj *o, *append;\n\n    o = lookupKeyWrite(c->db,c->argv[1]);\n    if (o == NULL) {\n        /* Create the key */\n        c->argv[2] = tryObjectEncoding(c->argv[2]);\n        dbAdd(c->db,c->argv[1],c->argv[2]);\n        incrRefCount(c->argv[2]);\n        totlen = stringObjectLen(c->argv[2]);\n    } else {\n        /* Key exists, check type */\n        if (checkType(c,o,OBJ_STRING))\n            return;\n\n        /* \"append\" is an argument, so always an sds */\n        append = c->argv[2];\n        if (checkStringLength(c,stringObjectLen(o),sdslen(append->ptr)) != C_OK)\n            return;\n\n        /* Append the value */\n        o = dbUnshareStringValue(c->db,c->argv[1],o);\n        o->ptr = sdscatlen(o->ptr,append->ptr,sdslen(append->ptr));\n        totlen = sdslen(o->ptr);\n    }\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_STRING,\"append\",c->argv[1],c->db->id);\n    server.dirty++;\n    addReplyLongLong(c,totlen);\n}", "target": 1, "idx": 9704}
{"commit_id": "97eff7eb57fc2320c267a949cffd622c38712484", "project": "php/php-src", "func": "static int append_key_value(smart_str* loc_name, HashTable* hash_arr, char* key_name)\n{\n\tzval**\tele_value\t= NULL;\n\n\tif(zend_hash_find(hash_arr , key_name , strlen(key_name) + 1 ,(void **)&ele_value ) == SUCCESS ) {\n\t\tif(Z_TYPE_PP(ele_value)!= IS_STRING ){\n\t\t\t/* element value is not a string */\n\t\t\treturn FAILURE;\n\t\t}\n\t\tif(strcmp(key_name, LOC_LANG_TAG) != 0 &&\n\t\t   strcmp(key_name, LOC_GRANDFATHERED_LANG_TAG)!=0 ) {\n\t\t\t/* not lang or grandfathered tag */\n\t\t\tsmart_str_appendl(loc_name, SEPARATOR , sizeof(SEPARATOR)-1);\n\t\t}\n\t\tsmart_str_appendl(loc_name, Z_STRVAL_PP(ele_value) , Z_STRLEN_PP(ele_value));\n\t\treturn SUCCESS;\n\t}\n\n\treturn LOC_NOT_FOUND;\n}", "target": 2, "idx": 9705}
{"commit_id": "b17d5e860f30e8be2caeb0022b63be4c76660178", "project": "ONLYOFFICE/core", "func": "unsigned int GetU32LE (const unsigned int& nPos, bool *pbSuccess)\n        {\n            //*pbSuccess = true;\n\n            if ( m_nLen < 4 || nPos > (m_nLen - 4) )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            unsigned int nRes = m_sFile[nPos + 3];\n            nRes = (nRes << 8) + m_sFile[nPos + 2];\n            nRes = (nRes << 8) + m_sFile[nPos + 1];\n            nRes = (nRes << 8) + m_sFile[nPos + 0];\n            return nRes;\n        }", "target": 3, "idx": 9706}
{"commit_id": "126c7c98ea788241922c30df4a5633ea692cf8df", "project": "ImageMagick", "func": "static Image *ReadWEBPImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  int\n    webp_status;\n\n  MagickBooleanType\n    status;\n\n  register unsigned char\n    *p;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    header[12],\n    *stream;\n\n  WebPDecoderConfig\n    configure;\n\n  WebPDecBuffer\n    *magick_restrict webp_image = &configure.output;\n\n  WebPBitstreamFeatures\n    *magick_restrict features = &configure.input;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (WebPInitDecoderConfig(&configure) == 0)\n    ThrowReaderException(ResourceLimitError,\"UnableToDecodeImageFile\");\n  webp_image->colorspace=MODE_RGBA;\n  count=ReadBlob(image,12,header);\n  if (count != 12)\n    ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n  status=IsWEBP(header,count);\n  if (status == MagickFalse)\n    ThrowReaderException(CorruptImageError,\"CorruptImage\");\n  length=(size_t) (ReadWebPLSBWord(header+4)+8);\n  if (length < 12)\n    ThrowReaderException(CorruptImageError,\"CorruptImage\");\n  stream=(unsigned char *) AcquireQuantumMemory(length,sizeof(*stream));\n  if (stream == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) memcpy(stream,header,12);\n  count=ReadBlob(image,length-12,stream+12);\n  if (count != (ssize_t) (length-12))\n    ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n  webp_status=WebPGetFeatures(stream,length,features);\n  if (webp_status == VP8_STATUS_OK)\n    {\n      image->columns=(size_t) features->width;\n      image->rows=(size_t) features->height;\n      image->depth=8;\n      image->matte=features->has_alpha != 0 ? MagickTrue : MagickFalse;\n      if (IsWEBPImageLossless(stream,length) != MagickFalse)\n        image->quality=100;\n      if (image_info->ping != MagickFalse)\n        {\n          stream=(unsigned char*) RelinquishMagickMemory(stream);\n          (void) CloseBlob(image);\n          return(GetFirstImageInList(image));\n        }\n      status=SetImageExtent(image,image->columns,image->rows);\n      if (status == MagickFalse)\n        {\n          InheritException(exception,&image->exception);\n          return(DestroyImageList(image));\n        }\n      webp_status=WebPDecode(stream,length,&configure);\n    }\n  if (webp_status != VP8_STATUS_OK)\n    {\n      stream=(unsigned char*) RelinquishMagickMemory(stream);\n      switch (webp_status)\n      {\n        case VP8_STATUS_OUT_OF_MEMORY:\n        {\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          break;\n        }\n        case VP8_STATUS_INVALID_PARAM:\n        {\n          ThrowReaderException(CorruptImageError,\"invalid parameter\");\n          break;\n        }\n        case VP8_STATUS_BITSTREAM_ERROR:\n        {\n          ThrowReaderException(CorruptImageError,\"CorruptImage\");\n          break;\n        }\n        case VP8_STATUS_UNSUPPORTED_FEATURE:\n        {\n          ThrowReaderException(CoderError,\"DataEncodingSchemeIsNotSupported\");\n          break;\n        }\n        case VP8_STATUS_SUSPENDED:\n        {\n          ThrowReaderException(CorruptImageError,\"decoder suspended\");\n          break;\n        }\n        case VP8_STATUS_USER_ABORT:\n        {\n          ThrowReaderException(CorruptImageError,\"user abort\");\n          break;\n        }\n        case VP8_STATUS_NOT_ENOUGH_DATA:\n        {\n          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n          break;\n        }\n        default:\n          ThrowReaderException(CorruptImageError,\"CorruptImage\");\n      }\n    }\n  p=(unsigned char *) webp_image->u.RGBA.rgba;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register PixelPacket\n      *q;\n\n    register ssize_t\n      x;\n\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      SetPixelRed(q,ScaleCharToQuantum(*p++));\n      SetPixelGreen(q,ScaleCharToQuantum(*p++));\n      SetPixelBlue(q,ScaleCharToQuantum(*p++));\n      SetPixelAlpha(q,ScaleCharToQuantum(*p++));\n      q++;\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  WebPFreeDecBuffer(webp_image);\n  stream=(unsigned char*) RelinquishMagickMemory(stream);\n  (void) CloseBlob(image);\n  return(image);\n}", "target": 1, "idx": 9707}
{"commit_id": "4a8b02d5f1afb38b00c77ab1321d5f56720f4e30", "project": "MisterTea/EternalTerminal", "func": "int main(int argc, char** argv) {\n  // Setup easylogging configurations\n  el::Configurations defaultConf = LogHandler::setupLogHandler(&argc, &argv);\n  LogHandler::setupStdoutLogger();\n\n  et::HandleTerminate();\n\n  // Override easylogging handler for sigint\n  ::signal(SIGINT, et::InterruptSignalHandler);\n\n  // Parse command line arguments\n  cxxopts::Options options(\"etterminal\", \"User terminal for Eternal Terminal.\");\n\n  try {\n    options.allow_unrecognised_options();\n\n    options.add_options()         //\n        (\"h,help\", \"Print help\")  //\n        (\"idpasskey\",\n         \"If set, uses IPC to send a client id/key to the server daemon. \"\n         \"Alternatively, pass in via stdin.\",\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"idpasskeyfile\",\n         \"If set, uses IPC to send a client id/key to the server daemon from a \"\n         \"file. Alternatively, pass in via stdin.\",\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"jump\",\n         \"If set, forward all packets between client and dst terminal\")  //\n        (\"dsthost\", \"Must be set if jump is set to true\",\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"dstport\", \"Must be set if jump is set to true\",\n         cxxopts::value<int>()->default_value(\"2022\"))  //\n        // Not used by etterminal but easylogging uses this flag under the hood\n        (\"v,verbose\", \"Enable verbose logging\",\n         cxxopts::value<int>()->default_value(\"0\"))  //\n        (\"logtostdout\", \"Write log to stdout\")       //\n        (\"serverfifo\",\n         \"If set, connects to the etserver instance listening on the matching \"\n         \"fifo name\",                                       //\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        ;\n\n    auto result = options.parse(argc, argv);\n    if (result.count(\"help\")) {\n      CLOG(INFO, \"stdout\") << options.help({}) << endl;\n      exit(0);\n    }\n\n    el::Loggers::setVerboseLevel(result[\"verbose\"].as<int>());\n\n    GOOGLE_PROTOBUF_VERIFY_VERSION;\n    srand(1);\n\n    ServerFifoPath serverFifo;\n    if (!result[\"serverfifo\"].as<string>().empty()) {\n      serverFifo.setPathOverride(result[\"serverfifo\"].as<string>());\n    }\n\n    shared_ptr<SocketHandler> ipcSocketHandler(new PipeSocketHandler());\n    shared_ptr<PsuedoUserTerminal> term(new PsuedoUserTerminal());\n\n    string idpasskey;\n    if (result.count(\"idpasskey\") == 0 && result.count(\"idpasskeyfile\") == 0) {\n      // Try to read from stdin\n      struct timeval timeout;\n      timeout.tv_sec = 1;\n      timeout.tv_usec = 0;\n      fd_set readfds;\n      FD_ZERO(&readfds);\n\n      FD_SET(STDIN_FILENO, &readfds);\n\n      int selectResult = 0;\n      do {\n        // Repeatedly calls when interrupted, up to the timeout.\n        selectResult = select(1, &readfds, NULL, NULL, &timeout);\n      } while (selectResult < 0 && errno == EINTR);\n\n      FATAL_FAIL(selectResult);\n      if (selectResult == 0) {\n        CLOG(INFO, \"stdout\")\n            << \"Call etterminal with --idpasskey or --idpasskeyfile, or feed \"\n               \"this information on stdin\\n\";\n        exit(1);\n      }\n\n      string stdinData;\n      if (!getline(cin, stdinData)) {\n        CLOG(INFO, \"stdout\")\n            << \"Call etterminal with --idpasskey or --idpasskeyfile, or feed \"\n               \"this information on stdin\\n\";\n        exit(1);\n      }\n      auto tokens = split(stdinData, '_');\n      if (tokens.size() == 2) {\n        idpasskey = tokens[0];\n        if (idpasskey.substr(0, 3) == std::string(\"XXX\")) {\n          // New client connecting to new server, throw away passkey and\n          // regenerate\n          string passkey = genRandomAlphaNum(32);\n          string id = genRandomAlphaNum(16);\n          idpasskey = id + string(\"/\") + passkey;\n        }\n\n        FATAL_FAIL(setenv(\"TERM\", tokens[1].c_str(), 1));\n      } else {\n        STFATAL << \"Invalid number of tokens: \" << tokens.size();\n      }\n    } else {\n      string idpasskey = result[\"idpasskey\"].as<string>();\n      if (result.count(\"idpasskeyfile\")) {\n        // Check for passkey file\n        std::ifstream t(result[\"idpasskeyfile\"].as<string>().c_str());\n        std::stringstream buffer;\n        buffer << t.rdbuf();\n        idpasskey = buffer.str();\n        // Trim whitespace\n        idpasskey.erase(idpasskey.find_last_not_of(\" \\n\\r\\t\") + 1);\n      }\n    }\n\n    string id = split(idpasskey, '/')[0];\n    string username = string(ssh_get_local_username());\n    if (result.count(\"jump\")) {\n      // etserver with --jump cannot write to the default log file(root)\n      LogHandler::setupLogFiles(&defaultConf, GetTempDirectory(),\n                                (\"etjump-\" + username + \"-\" + id),\n                                result.count(\"logtostdout\"), false);\n      // Reconfigure default logger to apply settings above\n      el::Loggers::reconfigureLogger(\"default\", defaultConf);\n      // set thread name\n      el::Helpers::setThreadName(\"jump-main\");\n      // Install log rotation callback\n      el::Helpers::installPreRollOutCallback(LogHandler::rolloutHandler);\n\n      CLOG(INFO, \"stdout\") << \"IDPASSKEY:\" << idpasskey << endl;\n      if (DaemonCreator::createSessionLeader() == -1) {\n        STFATAL << \"Error creating daemon: \" << strerror(GetErrno());\n      }\n      SocketEndpoint destinationEndpoint;\n      destinationEndpoint.set_name(result[\"dsthost\"].as<string>());\n      destinationEndpoint.set_port(result[\"dstport\"].as<int>());\n      shared_ptr<SocketHandler> jumpClientSocketHandler(new TcpSocketHandler());\n      UserJumphostHandler ujh(jumpClientSocketHandler, idpasskey,\n                              destinationEndpoint, ipcSocketHandler,\n                              serverFifo.getEndpointForConnect());\n      ujh.run();\n\n      // Uninstall log rotation callback\n      el::Helpers::uninstallPreRollOutCallback();\n      return 0;\n    }\n\n    // etserver with --idpasskey cannot write to the default log file(root)\n    LogHandler::setupLogFiles(&defaultConf, GetTempDirectory(),\n                              (\"etterminal-\" + username + \"-\" + id),\n                              result.count(\"logtostdout\"), false);\n\n    // Reconfigure default logger to apply settings above\n    el::Loggers::reconfigureLogger(\"default\", defaultConf);\n    // set thread name\n    el::Helpers::setThreadName(\"terminal-main\");\n    // Install log rotation callback\n    el::Helpers::installPreRollOutCallback(LogHandler::rolloutHandler);\n\n    UserTerminalHandler uth(ipcSocketHandler, term, true,\n                            serverFifo.getEndpointForConnect(), idpasskey);\n    CLOG(INFO, \"stdout\") << \"IDPASSKEY:\" << idpasskey << endl;\n    if (DaemonCreator::createSessionLeader() == -1) {\n      STFATAL << \"Error creating daemon: \" << strerror(GetErrno());\n    }\n    uth.run();\n\n  } catch (cxxopts::OptionException& oe) {\n    CLOG(INFO, \"stdout\") << \"Exception: \" << oe.what() << \"\\n\" << endl;\n    CLOG(INFO, \"stdout\") << options.help({}) << endl;\n    exit(1);\n  }\n\n  // Uninstall log rotation callback\n  el::Helpers::uninstallPreRollOutCallback();\n  return 0;\n}", "target": 1, "idx": 9708}
{"commit_id": "4cb1bcf1422bbcd79c0f683edb7ee85e3f7a31fe", "project": "gstreamer/gst-plugins-bad", "func": "static int\nvmnc_handle_packet (GstVMncDec * dec, const guint8 * data, int len,\n    gboolean decode)\n{\n  int type;\n  int offset = 0;\n\n  if (len < 4) {\n    GST_LOG_OBJECT (dec, \"Packet too short\");\n    return ERROR_INSUFFICIENT_DATA;\n  }\n\n  type = data[0];\n\n  switch (type) {\n    case 0:\n    {\n      int numrect = RFB_GET_UINT16 (data + 2);\n      int i;\n      int read;\n\n      offset = 4;\n\n      for (i = 0; i < numrect; i++) {\n        struct RfbRectangle r;\n        rectangle_handler handler;\n\n        if (len < offset + 12) {\n          GST_LOG_OBJECT (dec,\n              \"Packet too short for rectangle header: %d < %d\",\n              len, offset + 12);\n          return ERROR_INSUFFICIENT_DATA;\n        }\n        GST_LOG_OBJECT (dec, \"Reading rectangle %d\", i);\n        r.x = RFB_GET_UINT16 (data + offset);\n        r.y = RFB_GET_UINT16 (data + offset + 2);\n        r.width = RFB_GET_UINT16 (data + offset + 4);\n        r.height = RFB_GET_UINT16 (data + offset + 6);\n        r.type = RFB_GET_UINT32 (data + offset + 8);\n\n        if (r.type != TYPE_WMVi) {\n          /* We must have a WMVi packet to initialise things before we can \n           * continue */\n          if (!dec->have_format) {\n            GST_WARNING_OBJECT (dec, \"Received packet without WMVi: %d\",\n                r.type);\n            return ERROR_INVALID;\n          }\n          if (r.x + r.width > dec->format.width ||\n              r.y + r.height > dec->format.height) {\n            GST_WARNING_OBJECT (dec, \"Rectangle out of range, type %d\", r.type);\n            return ERROR_INVALID;\n          }\n        } else if (r.width > 16384 || r.height > 16384) {\n          GST_WARNING_OBJECT (dec, \"Width or height too high: %ux%u\", r.width,\n              r.height);\n          return ERROR_INVALID;\n        }\n\n        switch (r.type) {\n          case TYPE_WMVd:\n            handler = vmnc_handle_wmvd_rectangle;\n            break;\n          case TYPE_WMVe:\n            handler = vmnc_handle_wmve_rectangle;\n            break;\n          case TYPE_WMVf:\n            handler = vmnc_handle_wmvf_rectangle;\n            break;\n          case TYPE_WMVg:\n            handler = vmnc_handle_wmvg_rectangle;\n            break;\n          case TYPE_WMVh:\n            handler = vmnc_handle_wmvh_rectangle;\n            break;\n          case TYPE_WMVi:\n            handler = vmnc_handle_wmvi_rectangle;\n            break;\n          case TYPE_WMVj:\n            handler = vmnc_handle_wmvj_rectangle;\n            break;\n          case TYPE_RAW:\n            handler = vmnc_handle_raw_rectangle;\n            break;\n          case TYPE_COPY:\n            handler = vmnc_handle_copy_rectangle;\n            break;\n          case TYPE_HEXTILE:\n            handler = vmnc_handle_hextile_rectangle;\n            break;\n          default:\n            GST_WARNING_OBJECT (dec, \"Unknown rectangle type\");\n            return ERROR_INVALID;\n        }\n\n        read = handler (dec, &r, data + offset + 12, len - offset - 12, decode);\n        if (read < 0) {\n          GST_DEBUG_OBJECT (dec, \"Error calling rectangle handler\\n\");\n          return read;\n        }\n        offset += 12 + read;\n      }\n      break;\n    }\n    default:\n      GST_WARNING_OBJECT (dec, \"Packet type unknown: %d\", type);\n      return ERROR_INVALID;\n  }\n\n  return offset;\n}", "target": 2, "idx": 9709}
{"commit_id": "e7719a0dfac7a20cb7da5529e09773d8271bb78b", "project": "xen-project/xen", "func": "static void dump_irqs(unsigned char key)\n{\n    int i, irq, pirq;\n    struct irq_desc *desc;\n    irq_guest_action_t *action;\n    struct domain *d;\n    const struct pirq *info;\n    unsigned long flags;\n    char *ssid;\n\n    printk(\"IRQ information:\\n\");\n\n    for ( irq = 0; irq < nr_irqs; irq++ )\n    {\n        if ( !(irq & 0x1f) )\n            process_pending_softirqs();\n\n        desc = irq_to_desc(irq);\n\n        if ( !irq_desc_initialized(desc) || desc->handler == &no_irq_type )\n            continue;\n\n        ssid = in_irq() ? NULL : xsm_show_irq_sid(irq);\n\n        spin_lock_irqsave(&desc->lock, flags);\n\n        cpumask_scnprintf(keyhandler_scratch, sizeof(keyhandler_scratch),\n                          desc->affinity);\n        printk(\"   IRQ:%4d affinity:%s vec:%02x type=%-15s\"\n               \" status=%08x \",\n               irq, keyhandler_scratch, desc->arch.vector,\n               desc->handler->typename, desc->status);\n\n        if ( ssid )\n            printk(\"Z=%-25s \", ssid);\n\n        if ( desc->status & IRQ_GUEST )\n        {\n            action = (irq_guest_action_t *)desc->action;\n\n            printk(\"in-flight=%d domain-list=\", action->in_flight);\n\n            for ( i = 0; i < action->nr_guests; i++ )\n            {\n                d = action->guest[i];\n                pirq = domain_irq_to_pirq(d, irq);\n                info = pirq_info(d, pirq);\n                printk(\"%u:%3d(%c%c%c)\",\n                       d->domain_id, pirq,\n                       evtchn_port_is_pending(d, info->evtchn) ? 'P' : '-',\n                       evtchn_port_is_masked(d, info->evtchn) ? 'M' : '-',\n                       (info->masked ? 'M' : '-'));\n                if ( i != action->nr_guests )\n                    printk(\",\");\n            }\n\n            printk(\"\\n\");\n        }\n        else if ( desc->action )\n            printk(\"%ps()\\n\", desc->action->handler);\n        else\n            printk(\"mapped, unbound\\n\");\n\n        spin_unlock_irqrestore(&desc->lock, flags);\n\n        xfree(ssid);\n    }\n\n    process_pending_softirqs();\n    printk(\"Direct vector information:\\n\");\n    for ( i = FIRST_DYNAMIC_VECTOR; i < NR_VECTORS; ++i )\n        if ( direct_apic_vector[i] )\n            printk(\"   %#02x -> %ps()\\n\", i, direct_apic_vector[i]);\n\n    dump_ioapic_irq_info();\n}", "target": 3, "idx": 9710}
{"commit_id": "b19488c7154b902354cb26a27f11415d7799b0b2", "project": "wayland", "func": "int\nwl_map_insert_at(struct wl_map *map, uint32_t flags, uint32_t i, void *data)\n{\n\tunion map_entry *start;\n\tuint32_t count;\n\tstruct wl_array *entries;\n\n\tif (i < WL_SERVER_ID_START) {\n\t\tentries = &map->client_entries;\n\t} else {\n\t\tentries = &map->server_entries;\n\t\ti -= WL_SERVER_ID_START;\n\t}\n\n\tif (i > WL_MAP_MAX_OBJECTS)\n\t\treturn -1;\n\n\tcount = entries->size / sizeof *start;\n\tif (count < i) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tif (count == i) {\n\t\tif (!wl_array_add(entries, sizeof *start))\n\t\t\treturn -1;\n\t}\n\n\tstart = entries->data;\n\tstart[i].data = data;\n\tstart[i].next |= (flags & 0x1) << 1;\n\n\treturn 0;\n}", "target": 1, "idx": 9711}
{"commit_id": "605785b65dd356d46d4487faa41dbf90943b8bc1", "project": "radareorg/radare2", "func": "static bool set_reg_profile(RAnal *anal) {\n\tconst char *p =\n\t\t\"=PC\tpc\\n\"\n\t\t\"=SP\tr14\\n\" // XXX\n\t\t\"=BP\tsrp\\n\" // XXX\n\t\t\"=SN\tr0\\n\"\n\t\t\"=A0\tr0\\n\"\n\t\t\"=A1\tr1\\n\"\n\t\t\"=A2\tr2\\n\"\n\t\t\"=A3\tr3\\n\"\n\t\t\"gpr\tsp\t.32\t56\t0\\n\" // r14\n\t\t\"gpr\tacr\t.32\t60\t0\\n\" // r15\n\t\t\"gpr\tpc\t.32\t64\t0\\n\" // r16 // out of context\n\t\t\"gpr\tsrp\t.32\t68\t0\\n\" // like rbp on x86 // out of context\n\t\t// GPR\n\t\t\"gpr\tr0\t.32\t0\t0\\n\"\n\t\t\"gpr\tr1\t.32\t4\t0\\n\"\n\t\t\"gpr\tr2\t.32\t8\t0\\n\"\n\t\t\"gpr\tr3\t.32\t12\t0\\n\"\n\t\t\"gpr\tr4\t.32\t16\t0\\n\"\n\t\t\"gpr\tr5\t.32\t20\t0\\n\"\n\t\t\"gpr\tr6\t.32\t24\t0\\n\"\n\t\t\"gpr\tr7\t.32\t28\t0\\n\"\n\t\t\"gpr\tr8\t.32\t32\t0\\n\"\n\t\t\"gpr\tr9\t.32\t36\t0\\n\"\n\t\t\"gpr\tr10\t.32\t40\t0\\n\"\n\t\t\"gpr\tr11\t.32\t44\t0\\n\"\n\t\t\"gpr\tr12\t.32\t48\t0\\n\"\n\t\t\"gpr\tr13\t.32\t52\t0\\n\"\n\n\t\t// STACK POINTER\n\t\t\"gpr\tr14\t.32\t56\t0\\n\"\n\t\t\"gpr\tr15\t.32\t60\t0\\n\"\n\t\t// ADD P REGISTERS\n\t\t;\n\treturn r_reg_set_profile_string (anal->reg, p);\n}", "target": 1, "idx": 9712}
{"commit_id": "26f5a4350f3ab5507bb8727051c87bb04660f333", "project": "akrennmair/newsbeuter", "func": "std::string queueloader::get_filename(const std::string& str) {\n\tstd::string fn = ctrl->get_dlpath();\n\n\tif (fn[fn.length()-1] != NEWSBEUTER_PATH_SEP[0])\n\t\tfn.append(NEWSBEUTER_PATH_SEP);\n\tchar buf[1024];\n\tsnprintf(buf, sizeof(buf), \"%s\", str.c_str());\n\tchar * base = basename(buf);\n\tif (!base || strlen(base) == 0) {\n\t\tchar lbuf[128];\n\t\ttime_t t = time(NULL);\n\t\tstrftime(lbuf, sizeof(lbuf), \"%Y-%b-%d-%H%M%S.unknown\", localtime(&t));\n\t\tfn.append(lbuf);\n\t} else {\n\t\tfn.append(utils::replace_all(base, \"'\", \"%27\"));\n\t}\n\treturn fn;\n}", "target": 2, "idx": 9713}
{"commit_id": "7ac5067146613997bb38442cb022d7f41321a706", "project": "ffmpeg", "func": "static int decompress_i(AVCodecContext *avctx, uint32_t *dst, int linesize)\n{\n    SCPRContext *s = avctx->priv_data;\n    GetByteContext *gb = &s->gb;\n    int cx = 0, cx1 = 0, k = 0, clr = 0;\n    int run, r, g, b, off, y = 0, x = 0, z, ret;\n    unsigned backstep = linesize - avctx->width;\n    const int cxshift = s->cxshift;\n    unsigned lx, ly, ptype;\n\n    reinit_tables(s);\n    bytestream2_skip(gb, 2);\n    init_rangecoder(&s->rc, gb);\n\n    while (k < avctx->width + 1) {\n        ret = decode_unit(s, &s->pixel_model[0][cx + cx1], 400, &r);\n        if (ret < 0)\n            return ret;\n\n        cx1 = (cx << 6) & 0xFC0;\n        cx = r >> cxshift;\n        ret = decode_unit(s, &s->pixel_model[1][cx + cx1], 400, &g);\n        if (ret < 0)\n            return ret;\n\n        cx1 = (cx << 6) & 0xFC0;\n        cx = g >> cxshift;\n        ret = decode_unit(s, &s->pixel_model[2][cx + cx1], 400, &b);\n        if (ret < 0)\n            return ret;\n\n        cx1 = (cx << 6) & 0xFC0;\n        cx = b >> cxshift;\n\n        ret = decode_value(s, s->run_model[0], 256, 400, &run);\n        if (ret < 0)\n            return ret;\n\n        clr = (b << 16) + (g << 8) + r;\n        k += run;\n        while (run-- > 0) {\n            if (y >= avctx->height)\n                return AVERROR_INVALIDDATA;\n\n            dst[y * linesize + x] = clr;\n            lx = x;\n            ly = y;\n            x++;\n            if (x >= avctx->width) {\n                x = 0;\n                y++;\n            }\n        }\n    }\n    off = -linesize - 1;\n    ptype = 0;\n\n    while (x < avctx->width && y < avctx->height) {\n        ret = decode_value(s, s->op_model[ptype], 6, 1000, &ptype);\n        if (ret < 0)\n            return ret;\n        if (ptype == 0) {\n            ret = decode_unit(s, &s->pixel_model[0][cx + cx1], 400, &r);\n            if (ret < 0)\n                return ret;\n\n            cx1 = (cx << 6) & 0xFC0;\n            cx = r >> cxshift;\n            ret = decode_unit(s, &s->pixel_model[1][cx + cx1], 400, &g);\n            if (ret < 0)\n                return ret;\n\n            cx1 = (cx << 6) & 0xFC0;\n            cx = g >> cxshift;\n            ret = decode_unit(s, &s->pixel_model[2][cx + cx1], 400, &b);\n            if (ret < 0)\n                return ret;\n\n            clr = (b << 16) + (g << 8) + r;\n        }\n        if (ptype > 5)\n            return AVERROR_INVALIDDATA;\n        ret = decode_value(s, s->run_model[ptype], 256, 400, &run);\n        if (ret < 0)\n            return ret;\n\n        switch (ptype) {\n        case 0:\n            while (run-- > 0) {\n                if (y >= avctx->height)\n                    return AVERROR_INVALIDDATA;\n\n                dst[y * linesize + x] = clr;\n                lx = x;\n                ly = y;\n                x++;\n                if (x >= avctx->width) {\n                    x = 0;\n                    y++;\n                }\n            }\n            break;\n        case 1:\n            while (run-- > 0) {\n                if (y >= avctx->height)\n                    return AVERROR_INVALIDDATA;\n\n                dst[y * linesize + x] = dst[ly * linesize + lx];\n                lx = x;\n                ly = y;\n                x++;\n                if (x >= avctx->width) {\n                    x = 0;\n                    y++;\n                }\n            }\n            clr = dst[ly * linesize + lx];\n            break;\n        case 2:\n            while (run-- > 0) {\n                if (y < 1 || y >= avctx->height)\n                    return AVERROR_INVALIDDATA;\n\n                clr = dst[y * linesize + x + off + 1];\n                dst[y * linesize + x] = clr;\n                lx = x;\n                ly = y;\n                x++;\n                if (x >= avctx->width) {\n                    x = 0;\n                    y++;\n                }\n            }\n            break;\n        case 4:\n            while (run-- > 0) {\n                uint8_t *odst = (uint8_t *)dst;\n\n                if (y < 1 || y >= avctx->height ||\n                    (y == 1 && x == 0))\n                    return AVERROR_INVALIDDATA;\n\n                if (x == 0) {\n                    z = backstep;\n                } else {\n                    z = 0;\n                }\n\n                r = odst[(ly * linesize + lx) * 4] +\n                    odst[((y * linesize + x) + off - z) * 4 + 4] -\n                    odst[((y * linesize + x) + off - z) * 4];\n                g = odst[(ly * linesize + lx) * 4 + 1] +\n                    odst[((y * linesize + x) + off - z) * 4 + 5] -\n                    odst[((y * linesize + x) + off - z) * 4 + 1];\n                b = odst[(ly * linesize + lx) * 4 + 2] +\n                    odst[((y * linesize + x) + off - z) * 4 + 6] -\n                    odst[((y * linesize + x) + off - z) * 4 + 2];\n                clr = ((b & 0xFF) << 16) + ((g & 0xFF) << 8) + (r & 0xFF);\n                dst[y * linesize + x] = clr;\n                lx = x;\n                ly = y;\n                x++;\n                if (x >= avctx->width) {\n                    x = 0;\n                    y++;\n                }\n            }\n            break;\n        case 5:\n            while (run-- > 0) {\n                if (y < 1 || y >= avctx->height ||\n                    (y == 1 && x == 0))\n                    return AVERROR_INVALIDDATA;\n\n                if (x == 0) {\n                    z = backstep;\n                } else {\n                    z = 0;\n                }\n\n                clr = dst[y * linesize + x + off - z];\n                dst[y * linesize + x] = clr;\n                lx = x;\n                ly = y;\n                x++;\n                if (x >= avctx->width) {\n                    x = 0;\n                    y++;\n                }\n            }\n            break;\n        }\n\n        if (avctx->bits_per_coded_sample == 16) {\n            cx1 = (clr & 0x3F00) >> 2;\n            cx = (clr & 0xFFFFFF) >> 16;\n        } else {\n            cx1 = (clr & 0xFC00) >> 4;\n            cx = (clr & 0xFFFFFF) >> 18;\n        }\n    }\n\n    return 0;\n}", "target": 2, "idx": 9714}
{"commit_id": "7e112c1563632f57cfa1c4fa964987f823da17fa", "project": "chromium", "func": "void PasswordGenerationAgent::FindPossibleGenerationForm() {\n  if (!enabled_ || !render_frame())\n    return;\n\n  // We don't want to generate passwords if the browser won't store or sync\n  // them.\n  if (!ShouldAnalyzeDocument())\n    return;\n\n  // If we have already found a signup form for this page, no need to continue.\n  if (generation_form_data_)\n    return;\n\n  blink::WebVector<blink::WebFormElement> forms;\n  render_frame()->GetWebFrame()->document().forms(forms);\n  for (size_t i = 0; i < forms.size(); ++i) {\n    if (forms[i].isNull())\n      continue;\n\n    // If we can't get a valid PasswordForm, we skip this form because the\n    // the password won't get saved even if we generate it.\n    std::unique_ptr<PasswordForm> password_form(\n        CreatePasswordFormFromWebForm(forms[i], nullptr, nullptr));\n    if (!password_form.get()) {\n      VLOG(2) << \"Skipping form as it would not be saved\";\n      continue;\n    }\n\n    // Do not generate password for GAIA since it is used to retrieve the\n    // generated paswords.\n    GURL realm(password_form->signon_realm);\n    if (realm == GaiaUrls::GetInstance()->gaia_login_form_realm())\n      continue;\n\n    std::vector<blink::WebInputElement> passwords;\n    if (GetAccountCreationPasswordFields(\n            form_util::ExtractAutofillableElementsInForm(forms[i]),\n            &passwords)) {\n      AccountCreationFormData ac_form_data(\n          make_linked_ptr(password_form.release()), passwords);\n      possible_account_creation_forms_.push_back(ac_form_data);\n    }\n  }\n\n  if (!possible_account_creation_forms_.empty()) {\n    VLOG(2) << possible_account_creation_forms_.size()\n            << \" possible account creation forms deteceted\";\n    DetermineGenerationElement();\n  }\n}", "target": 2, "idx": 9715}
{"commit_id": "d5e6098dc2e984befc836f482845137245fa04e2", "project": "chromium", "func": "DevToolsWindow* DevToolsWindow::Create(\n    Profile* profile,\n    const GURL& frontend_url,\n    content::WebContents* inspected_web_contents,\n    bool shared_worker_frontend,\n    const std::string& remote_frontend,\n    bool can_dock,\n    const std::string& settings) {\n  if (profile->GetPrefs()->GetBoolean(prefs::kDevToolsDisabled) ||\n      base::CommandLine::ForCurrentProcess()->HasSwitch(switches::kKioskMode))\n    return nullptr;\n\n  if (inspected_web_contents) {\n    // Check for a place to dock.\n    Browser* browser = NULL;\n    int tab;\n    if (!FindInspectedBrowserAndTabIndex(inspected_web_contents,\n                                         &browser, &tab) ||\n        browser->is_type_popup()) {\n      can_dock = false;\n    }\n  }\n\n  // Create WebContents with devtools.\n  GURL url(GetDevToolsURL(profile, frontend_url,\n                          shared_worker_frontend,\n                          remote_frontend,\n                          can_dock));\n  std::unique_ptr<WebContents> main_web_contents(\n      WebContents::Create(WebContents::CreateParams(profile)));\n  main_web_contents->GetController().LoadURL(\n      DecorateFrontendURL(url), content::Referrer(),\n      ui::PAGE_TRANSITION_AUTO_TOPLEVEL, std::string());\n  DevToolsUIBindings* bindings =\n      DevToolsUIBindings::ForWebContents(main_web_contents.get());\n  if (!bindings)\n    return nullptr;\n  if (!settings.empty())\n    SetPreferencesFromJson(profile, settings);\n  return new DevToolsWindow(profile, main_web_contents.release(), bindings,\n                            inspected_web_contents, can_dock);\n}", "target": 1, "idx": 9716}
{"commit_id": "d790e336fd68029d802aa7da6d262eb5ef36488c", "project": "chromium", "func": "void SerializedScriptValueWriter::writeImageBitmap(uint32_t width, uint32_t height, uint32_t isOriginClean, const uint8_t* pixelData, uint32_t pixelDataLength)\n{\n    append(ImageBitmapTag);\n    append(isOriginClean);\n    doWriteImageData(width, height, pixelData, pixelDataLength);\n}", "target": 2, "idx": 9717}
{"commit_id": "e45e48b881038487d0bc94d92a16c1537616cc0a", "project": "ImageMagick", "func": "static Image *ReadLABELImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    geometry[MagickPathExtent],\n    *property;\n\n  const char\n    *label;\n\n  DrawInfo\n    *draw_info;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  TypeMetric\n    metrics;\n\n  size_t\n    height,\n    width;\n\n  /*\n    Initialize Image structure.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  (void) ResetImagePage(image,\"0x0+0+0\");\n  property=InterpretImageProperties((ImageInfo *) image_info,image,\n    image_info->filename,exception);\n  (void) SetImageProperty(image,\"label\",property,exception);\n  property=DestroyString(property);\n  label=GetImageProperty(image,\"label\",exception);\n  draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);\n  draw_info->text=ConstantString(label);\n  metrics.width=0;\n  metrics.ascent=0.0;\n  status=GetMultilineTypeMetrics(image,draw_info,&metrics,exception);\n  if ((image->columns == 0) && (image->rows == 0))\n    {\n      image->columns=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);\n      image->rows=(size_t) floor(metrics.height+draw_info->stroke_width+0.5);\n    }\n  else\n    if (((image->columns == 0) || (image->rows == 0)) ||\n        (fabs(image_info->pointsize) < MagickEpsilon))\n      {\n        double\n          high,\n          low;\n\n        /*\n          Auto fit text into bounding box.\n        */\n        for ( ; ; draw_info->pointsize*=2.0)\n        {\n          (void) FormatLocaleString(geometry,MagickPathExtent,\"%+g%+g\",\n            -metrics.bounds.x1,metrics.ascent);\n          if (draw_info->gravity == UndefinedGravity)\n            (void) CloneString(&draw_info->geometry,geometry);\n          status=GetMultilineTypeMetrics(image,draw_info,&metrics,exception);\n          width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);\n          height=(size_t) floor(metrics.height+draw_info->stroke_width+0.5);\n          if ((image->columns != 0) && (image->rows != 0))\n            {\n              if ((width >= image->columns) && (height >= image->rows))\n                break;\n            }\n          else\n            if (((image->columns != 0) && (width >= image->columns)) ||\n                ((image->rows != 0) && (height >= image->rows)))\n              break;\n        }\n        high=draw_info->pointsize;\n        for (low=1.0; (high-low) > 0.5; )\n        {\n          draw_info->pointsize=(low+high)/2.0;\n          (void) FormatLocaleString(geometry,MagickPathExtent,\"%+g%+g\",\n            -metrics.bounds.x1,metrics.ascent);\n          if (draw_info->gravity == UndefinedGravity)\n            (void) CloneString(&draw_info->geometry,geometry);\n          status=GetMultilineTypeMetrics(image,draw_info,&metrics,exception);\n          width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);\n          height=(size_t) floor(metrics.height+draw_info->stroke_width+0.5);\n          if ((image->columns != 0) && (image->rows != 0))\n            {\n              if ((width < image->columns) && (height < image->rows))\n                low=draw_info->pointsize+0.5;\n              else\n                high=draw_info->pointsize-0.5;\n            }\n          else\n            if (((image->columns != 0) && (width < image->columns)) ||\n                ((image->rows != 0) && (height < image->rows)))\n              low=draw_info->pointsize+0.5;\n            else\n              high=draw_info->pointsize-0.5;\n        }\n        draw_info->pointsize=(low+high)/2.0-0.5;\n      }\n   status=GetMultilineTypeMetrics(image,draw_info,&metrics,exception);\n   if (status == MagickFalse)\n     {\n      draw_info=DestroyDrawInfo(draw_info);\n       image=DestroyImageList(image);\n       return((Image *) NULL);\n     }\n  if (image->columns == 0)\n    image->columns=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);\n  if (image->columns == 0)\n    image->columns=(size_t) floor(draw_info->pointsize+draw_info->stroke_width+\n      0.5);\n  if (image->rows == 0)\n    image->rows=(size_t) floor(metrics.ascent-metrics.descent+\n      draw_info->stroke_width+0.5);\n  if (image->rows == 0)\n    image->rows=(size_t) floor(draw_info->pointsize+draw_info->stroke_width+\n      0.5);\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    {\n      draw_info=DestroyDrawInfo(draw_info);\n      return(DestroyImageList(image));\n    }\n  if (SetImageBackgroundColor(image,exception) == MagickFalse)\n    {\n      draw_info=DestroyDrawInfo(draw_info);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Draw label.\n  */\n  (void) FormatLocaleString(geometry,MagickPathExtent,\"%+g%+g\",\n    draw_info->direction == RightToLeftDirection ? image->columns-\n    metrics.bounds.x2 : 0.0,draw_info->gravity == UndefinedGravity ?\n    metrics.ascent : 0.0);\n  draw_info->geometry=AcquireString(geometry);\n  status=AnnotateImage(image,draw_info,exception);\n  if (image_info->pointsize == 0.0)\n    {\n      char\n        pointsize[MagickPathExtent];\n\n      (void) FormatLocaleString(pointsize,MagickPathExtent,\"%.20g\",\n        draw_info->pointsize);\n      (void) SetImageProperty(image,\"label:pointsize\",pointsize,exception);\n    }\n  draw_info=DestroyDrawInfo(draw_info);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  return(GetFirstImageInList(image));\n}", "target": 1, "idx": 9718}
{"commit_id": "04f5866e41fb70690e28397487d8bd8eea7d712a", "project": "torvalds/linux", "func": "struct vm_area_struct *\nfind_extend_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma, *prev;\n\n\taddr &= PAGE_MASK;\n\tvma = find_vma_prev(mm, addr, &prev);\n\tif (vma && (vma->vm_start <= addr))\n\t\treturn vma;\n\t/* don't alter vm_end if the coredump is running */\n\tif (!prev || !mmget_still_valid(mm) || expand_stack(prev, addr))\n\t\treturn NULL;\n\tif (prev->vm_flags & VM_LOCKED)\n\t\tpopulate_vma_page_range(prev, addr, prev->vm_end, NULL);\n\treturn prev;\n}", "target": 2, "idx": 9719}
{"commit_id": "c32949b0779106ed5710ae3bffc5053e49083ab4", "project": "vim", "func": "char_u *\nvim_strchr(char_u *string, int c)\n{\n    char_u\t*p;\n    int\t\tb;\n\n    p = string;\n    if (enc_utf8 && c >= 0x80)\n    {\n\twhile (*p != NUL)\n\t{\n\t    int l = utfc_ptr2len(p);\n\n\t    // Avoid matching an illegal byte here.\n\t    if (utf_ptr2char(p) == c && l > 1)\n\t\treturn p;\n\t    p += l;\n\t}\n\treturn NULL;\n    }\n    if (enc_dbcs != 0 && c > 255)\n    {\n\tint\tn2 = c & 0xff;\n\n\tc = ((unsigned)c >> 8) & 0xff;\n\twhile ((b = *p) != NUL)\n\t{\n\t    if (b == c && p[1] == n2)\n\t\treturn p;\n\t    p += (*mb_ptr2len)(p);\n\t}\n\treturn NULL;\n    }\n    if (has_mbyte)\n    {\n\twhile ((b = *p) != NUL)\n\t{\n\t    if (b == c)\n\t\treturn p;\n\t    p += (*mb_ptr2len)(p);\n\t}\n\treturn NULL;\n    }\n    while ((b = *p) != NUL)\n    {\n\tif (b == c)\n\t    return p;\n\t++p;\n    }\n    return NULL;\n}", "target": 2, "idx": 9720}
{"commit_id": "de53fd7aedb100f03e5d2231cfce0e4993282425", "project": "torvalds/linux", "func": "static int assign_cfs_rq_runtime(struct cfs_rq *cfs_rq)\n{\n\tstruct task_group *tg = cfs_rq->tg;\n\tstruct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(tg);\n\tu64 amount = 0, min_amount;\n\n\t/* note: this is a positive sum as runtime_remaining <= 0 */\n\tmin_amount = sched_cfs_bandwidth_slice() - cfs_rq->runtime_remaining;\n\n\traw_spin_lock(&cfs_b->lock);\n\tif (cfs_b->quota == RUNTIME_INF)\n\t\tamount = min_amount;\n\telse {\n\t\tstart_cfs_bandwidth(cfs_b);\n\n\t\tif (cfs_b->runtime > 0) {\n\t\t\tamount = min(cfs_b->runtime, min_amount);\n\t\t\tcfs_b->runtime -= amount;\n\t\t\tcfs_b->idle = 0;\n\t\t}\n\t}\n\traw_spin_unlock(&cfs_b->lock);\n\n\tcfs_rq->runtime_remaining += amount;\n\n\treturn cfs_rq->runtime_remaining > 0;\n}", "target": 1, "idx": 9721}
{"commit_id": "73e1589afa0900e22134fd78523aa64307189f48", "project": "mackron/miniaudio", "func": "DRWAV_API drwav_uint32 drwav_bytes_to_u32(const drwav_uint8* data)\n{\n    return ((drwav_uint32)data[0] << 0) | ((drwav_uint32)data[1] << 8) | ((drwav_uint32)data[2] << 16) | ((drwav_uint32)data[3] << 24);\n}", "target": 2, "idx": 9722}
{"commit_id": "bea84e2844b647532a9b7fbc3a6a8989d66e49e3", "project": "ValveSoftware/GameNetworkingSockets", "func": "bool AES_GCM_EncryptContext::Encrypt(\n\tconst void *pPlaintextData, size_t cbPlaintextData,\n\tconst void *pIV,\n\tvoid *pEncryptedDataAndTag, uint32 *pcbEncryptedDataAndTag,\n\tconst void *pAdditionalAuthenticationData, size_t cbAuthenticationData\n) {\n\n\t// Make sure caller's buffer is big enough to hold the result.\n\tif ( cbPlaintextData + crypto_aead_aes256gcm_ABYTES > *pcbEncryptedDataAndTag )\n\t{\n\t\t*pcbEncryptedDataAndTag = 0;\n\t\treturn false;\n\t}\n\n    unsigned long long cbEncryptedDataAndTag_longlong;\n    crypto_aead_aes256gcm_encrypt_afternm(\n\t\tstatic_cast<unsigned char*>( pEncryptedDataAndTag ), &cbEncryptedDataAndTag_longlong,\n\t\tstatic_cast<const unsigned char*>( pPlaintextData ), cbPlaintextData,\n\t\tstatic_cast<const unsigned char*>(pAdditionalAuthenticationData), cbAuthenticationData,\n\t\tnullptr,\n\t\tstatic_cast<const unsigned char*>( pIV ),\n\t\tstatic_cast<const crypto_aead_aes256gcm_state*>( m_ctx )\n\t);\n\n    *pcbEncryptedDataAndTag = cbEncryptedDataAndTag_longlong;\n\n    return true;\n}", "target": 3, "idx": 9723}
{"commit_id": "f062b42c0ea8dddebdc6a152fd16152de215d614", "project": "DanBloomberg/leptonica", "func": "PIX *\npixBlockconvGrayUnnormalized(PIX     *pixs,\n                             l_int32  wc,\n                             l_int32  hc)\n{\nl_int32    i, j, w, h, d, wpla, wpld, jmax;\nl_uint32  *linemina, *linemaxa, *lined, *dataa, *datad;\nPIX       *pixsb, *pixacc, *pixd;\n\n    PROCNAME(\"pixBlockconvGrayUnnormalized\");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    pixGetDimensions(pixs, &w, &h, &d);\n    if (d != 8)\n        return (PIX *)ERROR_PTR(\"pixs not 8 bpp\", procName, NULL);\n    if (wc <= 0 || hc <= 0)  /* no-op */\n        return pixCopy(NULL, pixs);\n    if (w < 2 * wc + 1 || h < 2 * hc + 1) {\n        L_ERROR(\"kernel is too large: w = %d, wc = %d, h = %d, hc = %d\\n\",\n                procName, w, wc, h, hc);\n        return pixCopy(NULL, pixs);\n    }\n\n    if ((pixsb = pixAddMirroredBorder(pixs, wc + 1, wc, hc + 1, hc)) == NULL)\n        return (PIX *)ERROR_PTR(\"pixsb not made\", procName, NULL);\n    pixacc = pixBlockconvAccum(pixsb);\n    pixDestroy(&pixsb);\n    if (!pixacc)\n        return (PIX *)ERROR_PTR(\"pixacc not made\", procName, NULL);\n    if ((pixd = pixCreate(w, h, 32)) == NULL) {\n        pixDestroy(&pixacc);\n        return (PIX *)ERROR_PTR(\"pixd not made\", procName, NULL);\n    }\n\n    wpla = pixGetWpl(pixacc);\n    wpld = pixGetWpl(pixd);\n    datad = pixGetData(pixd);\n    dataa = pixGetData(pixacc);\n    for (i = 0; i < h; i++) {\n        lined = datad + i * wpld;\n        linemina = dataa + i * wpla;\n        linemaxa = dataa + (i + 2 * hc + 1) * wpla;\n        for (j = 0; j < w; j++) {\n            jmax = j + 2 * wc + 1;\n            lined[j] = linemaxa[jmax] - linemaxa[j] -\n                       linemina[jmax] + linemina[j];\n        }\n    }\n\n    pixDestroy(&pixacc);\n    return pixd;\n}", "target": 1, "idx": 9724}
{"commit_id": "04beafa8e6c66f5cd814c00e2d2b51cfbc41cb8a", "project": "xen-project/xen", "func": "static int hvm_load_segment_selector(\n    enum x86_segment seg, uint16_t sel)\n{\n    struct segment_register desctab, cs, segr;\n    struct desc_struct *pdesc, desc;\n    u8 dpl, rpl, cpl;\n    bool_t writable;\n    int fault_type = TRAP_invalid_tss;\n    struct cpu_user_regs *regs = guest_cpu_user_regs();\n    struct vcpu *v = current;\n\n    if ( regs->eflags & X86_EFLAGS_VM )\n    {\n        segr.sel = sel;\n        segr.base = (uint32_t)sel << 4;\n        segr.limit = 0xffffu;\n        segr.attr.bytes = 0xf3;\n        hvm_set_segment_register(v, seg, &segr);\n        return 0;\n    }\n\n    /* NULL selector? */\n    if ( (sel & 0xfffc) == 0 )\n    {\n        if ( (seg == x86_seg_cs) || (seg == x86_seg_ss) )\n            goto fail;\n        memset(&segr, 0, sizeof(segr));\n        segr.sel = sel;\n        hvm_set_segment_register(v, seg, &segr);\n        return 0;\n    }\n\n    /* LDT descriptor must be in the GDT. */\n    if ( (seg == x86_seg_ldtr) && (sel & 4) )\n        goto fail;\n\n    hvm_get_segment_register(v, x86_seg_cs, &cs);\n    hvm_get_segment_register(\n        v, (sel & 4) ? x86_seg_ldtr : x86_seg_gdtr, &desctab);\n\n    /* Segment not valid for use (cooked meaning of .p)? */\n    if ( !desctab.attr.fields.p )\n        goto fail;\n\n    /* Check against descriptor table limit. */\n    if ( ((sel & 0xfff8) + 7) > desctab.limit )\n        goto fail;\n\n    pdesc = hvm_map_entry(desctab.base + (sel & 0xfff8), &writable);\n    if ( pdesc == NULL )\n        goto hvm_map_fail;\n\n    do {\n        desc = *pdesc;\n\n        /* LDT descriptor is a system segment. All others are code/data. */\n        if ( (desc.b & (1u<<12)) == ((seg == x86_seg_ldtr) << 12) )\n            goto unmap_and_fail;\n\n        dpl = (desc.b >> 13) & 3;\n        rpl = sel & 3;\n        cpl = cs.sel & 3;\n\n        switch ( seg )\n        {\n        case x86_seg_cs:\n            /* Code segment? */\n            if ( !(desc.b & _SEGMENT_CODE) )\n                goto unmap_and_fail;\n            /* Non-conforming segment: check DPL against RPL. */\n            if ( !(desc.b & _SEGMENT_EC) && (dpl != rpl) )\n                goto unmap_and_fail;\n            break;\n        case x86_seg_ss:\n            /* Writable data segment? */\n            if ( (desc.b & (_SEGMENT_CODE|_SEGMENT_WR)) != _SEGMENT_WR )\n                goto unmap_and_fail;\n            if ( (dpl != cpl) || (dpl != rpl) )\n                goto unmap_and_fail;\n            break;\n        case x86_seg_ldtr:\n            /* LDT system segment? */\n            if ( (desc.b & _SEGMENT_TYPE) != (2u<<8) )\n                goto unmap_and_fail;\n            goto skip_accessed_flag;\n        default:\n            /* Readable code or data segment? */\n            if ( (desc.b & (_SEGMENT_CODE|_SEGMENT_WR)) == _SEGMENT_CODE )\n                goto unmap_and_fail;\n            /*\n             * Data or non-conforming code segment:\n             * check DPL against RPL and CPL.\n             */\n            if ( ((desc.b & (_SEGMENT_EC|_SEGMENT_CODE)) !=\n                  (_SEGMENT_EC|_SEGMENT_CODE))\n                 && ((dpl < cpl) || (dpl < rpl)) )\n                goto unmap_and_fail;\n            break;\n        }\n\n        /* Segment present in memory? */\n        if ( !(desc.b & _SEGMENT_P) )\n        {\n            fault_type = (seg != x86_seg_ss) ? TRAP_no_segment\n                                             : TRAP_stack_error;\n            goto unmap_and_fail;\n        }\n    } while ( !(desc.b & 0x100) && /* Ensure Accessed flag is set */\n              writable && /* except if we are to discard writes */\n              (cmpxchg(&pdesc->b, desc.b, desc.b | 0x100) != desc.b) );\n\n    /* Force the Accessed flag in our local copy. */\n    desc.b |= 0x100;\n\n skip_accessed_flag:\n    hvm_unmap_entry(pdesc);\n\n    segr.base = (((desc.b <<  0) & 0xff000000u) |\n                 ((desc.b << 16) & 0x00ff0000u) |\n                 ((desc.a >> 16) & 0x0000ffffu));\n    segr.attr.bytes = (((desc.b >>  8) & 0x00ffu) |\n                       ((desc.b >> 12) & 0x0f00u));\n    segr.limit = (desc.b & 0x000f0000u) | (desc.a & 0x0000ffffu);\n    if ( segr.attr.fields.g )\n        segr.limit = (segr.limit << 12) | 0xfffu;\n    segr.sel = sel;\n    hvm_set_segment_register(v, seg, &segr);\n\n    return 0;\n\n unmap_and_fail:\n    hvm_unmap_entry(pdesc);\n fail:\n    hvm_inject_hw_exception(fault_type, sel & 0xfffc);\n hvm_map_fail:\n    return 1;\n}", "target": 2, "idx": 9725}
{"commit_id": "31e0456de5be379b10fea0fa94a681057114a96e", "project": "torvalds/linux", "func": "static int smsusb_init_device(struct usb_interface *intf, int board_id)\n{\n\tstruct smsdevice_params_t params;\n\tstruct smsusb_device_t *dev;\n\tvoid *mdev;\n\tint i, rc;\n\tint in_maxp;\n\n\t/* create device object */\n\tdev = kzalloc(sizeof(struct smsusb_device_t), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tmemset(&params, 0, sizeof(params));\n\tusb_set_intfdata(intf, dev);\n\tdev->udev = interface_to_usbdev(intf);\n\tdev->state = SMSUSB_DISCONNECTED;\n\n\tfor (i = 0; i < intf->cur_altsetting->desc.bNumEndpoints; i++) {\n\t\tstruct usb_endpoint_descriptor *desc =\n\t\t\t\t&intf->cur_altsetting->endpoint[i].desc;\n\n\t\tif (desc->bEndpointAddress & USB_DIR_IN) {\n\t\t\tdev->in_ep = desc->bEndpointAddress;\n\t\t\tin_maxp = usb_endpoint_maxp(desc);\n\t\t} else {\n\t\t\tdev->out_ep = desc->bEndpointAddress;\n\t\t}\n\t}\n\n\tpr_debug(\"in_ep = %02x, out_ep = %02x\\n\", dev->in_ep, dev->out_ep);\n\tif (!dev->in_ep || !dev->out_ep) {\t/* Missing endpoints? */\n\t\tsmsusb_term_device(intf);\n\t\treturn -ENODEV;\n\t}\n\n\tparams.device_type = sms_get_board(board_id)->type;\n\n\tswitch (params.device_type) {\n\tcase SMS_STELLAR:\n\t\tdev->buffer_size = USB1_BUFFER_SIZE;\n\n\t\tparams.setmode_handler = smsusb1_setmode;\n\t\tparams.detectmode_handler = smsusb1_detectmode;\n\t\tbreak;\n\tcase SMS_UNKNOWN_TYPE:\n\t\tpr_err(\"Unspecified sms device type!\\n\");\n\t\t/* fall-thru */\n\tdefault:\n\t\tdev->buffer_size = USB2_BUFFER_SIZE;\n\t\tdev->response_alignment = in_maxp - sizeof(struct sms_msg_hdr);\n\n\t\tparams.flags |= SMS_DEVICE_FAMILY2;\n\t\tbreak;\n\t}\n\n\tparams.device = &dev->udev->dev;\n\tparams.usb_device = dev->udev;\n\tparams.buffer_size = dev->buffer_size;\n\tparams.num_buffers = MAX_BUFFERS;\n\tparams.sendrequest_handler = smsusb_sendrequest;\n\tparams.context = dev;\n\tusb_make_path(dev->udev, params.devpath, sizeof(params.devpath));\n\n\tmdev = siano_media_device_register(dev, board_id);\n\n\t/* register in smscore */\n\trc = smscore_register_device(&params, &dev->coredev, 0, mdev);\n\tif (rc < 0) {\n\t\tpr_err(\"smscore_register_device(...) failed, rc %d\\n\", rc);\n\t\tsmsusb_term_device(intf);\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\n\t\tmedia_device_unregister(mdev);\n#endif\n\t\tkfree(mdev);\n\t\treturn rc;\n\t}\n\n\tsmscore_set_board_id(dev->coredev, board_id);\n\n\tdev->coredev->is_usb_device = true;\n\n\t/* initialize urbs */\n\tfor (i = 0; i < MAX_URBS; i++) {\n\t\tdev->surbs[i].dev = dev;\n\t\tusb_init_urb(&dev->surbs[i].urb);\n\t}\n\n\tpr_debug(\"smsusb_start_streaming(...).\\n\");\n\trc = smsusb_start_streaming(dev);\n\tif (rc < 0) {\n\t\tpr_err(\"smsusb_start_streaming(...) failed\\n\");\n\t\tsmsusb_term_device(intf);\n\t\treturn rc;\n\t}\n\n\tdev->state = SMSUSB_ACTIVE;\n\n\trc = smscore_start_device(dev->coredev);\n\tif (rc < 0) {\n\t\tpr_err(\"smscore_start_device(...) failed\\n\");\n\t\tsmsusb_term_device(intf);\n\t\treturn rc;\n\t}\n\n\tpr_debug(\"device 0x%p created\\n\", dev);\n\n\treturn rc;\n}", "target": 1, "idx": 9726}
{"commit_id": "b12aa1d44352de21d1a6faaf04172d8c2508b42b", "project": "tensorflow", "func": "Status ComputeConv2DDimension(const Conv2DParameters& params,\n                              const Tensor& input, const Tensor& filter,\n                              Conv2DDimensions* dimensions) {\n  // Check that 2D convolution input and filter have exactly 4 dimensions.\n  TF_REQUIRES(input.dims() == 4,\n              errors::InvalidArgument(\"input must be 4-dimensional\",\n                                      input.shape().DebugString()));\n  TF_REQUIRES(filter.dims() == 4,\n              errors::InvalidArgument(\"filter must be 4-dimensional: \",\n                                      filter.shape().DebugString()));\n  for (int i = 0; i < 3; i++) {\n    TF_REQUIRES(\n        FastBoundsCheck(filter.dim_size(i), std::numeric_limits<int>::max()),\n        errors::InvalidArgument(\"filter too large\"));\n  }\n\n  // The last dimension for input is in_depth. Check that it is the same as the\n  // filter's in_depth or it is evenly divisible by filter's in_depth.\n  const int64 in_depth_raw = GetTensorDim(input, params.data_format, 'C');\n  const int64 patch_depth_raw = filter.dim_size(2);\n  TF_REQUIRES(FastBoundsCheck(in_depth_raw, std::numeric_limits<int>::max()),\n              errors::InvalidArgument(\"Input depth too large\"));\n  TF_REQUIRES(FastBoundsCheck(patch_depth_raw, std::numeric_limits<int>::max()),\n              errors::InvalidArgument(\"Patch depth too large\"));\n  const int in_depth = static_cast<int>(in_depth_raw);\n  const int patch_depth = static_cast<int>(patch_depth_raw);\n  TF_REQUIRES(patch_depth > 0,\n              errors::InvalidArgument(\n                  \"filter depth must be stricly positive, got \", patch_depth));\n  TF_REQUIRES(in_depth % patch_depth == 0,\n              errors::InvalidArgument(\n                  \"input depth must be evenly divisible by filter depth: \",\n                  in_depth, \" vs \", patch_depth));\n\n  // The last dimension for filter is out_depth.\n  const int out_depth = static_cast<int>(filter.dim_size(3));\n\n  // The second dimension for input is rows/height.\n  // The first dimension for filter is rows/height.\n  const int64 input_rows_raw = GetTensorDim(input, params.data_format, 'H');\n  TF_REQUIRES(FastBoundsCheck(input_rows_raw, std::numeric_limits<int>::max()),\n              errors::InvalidArgument(\"Input rows too large\"));\n  const int input_rows = static_cast<int>(input_rows_raw);\n  const int filter_rows = static_cast<int>(filter.dim_size(0));\n\n  // The third dimension for input is columns/width.\n  // The second dimension for filter is columns/width.\n  const int64 input_cols_raw = GetTensorDim(input, params.data_format, 'W');\n  TF_REQUIRES(FastBoundsCheck(input_cols_raw, std::numeric_limits<int>::max()),\n              errors::InvalidArgument(\"Input cols too large\"));\n  const int input_cols = static_cast<int>(input_cols_raw);\n  const int filter_cols = static_cast<int>(filter.dim_size(1));\n\n  // The first dimension for input is batch.\n  const int64 batch_raw = GetTensorDim(input, params.data_format, 'N');\n  TF_REQUIRES(FastBoundsCheck(batch_raw, std::numeric_limits<int>::max()),\n              errors::InvalidArgument(\"batch is too large\"));\n  const int batch = static_cast<int>(batch_raw);\n\n  // Take the stride and dilation from the second and third dimensions only (we\n  // do not support striding or dilation on the batch or depth dimension).\n  const int stride_rows = GetTensorDim(params.strides, params.data_format, 'H');\n  const int stride_cols = GetTensorDim(params.strides, params.data_format, 'W');\n  const int dilation_rows =\n      GetTensorDim(params.dilations, params.data_format, 'H');\n  const int dilation_cols =\n      GetTensorDim(params.dilations, params.data_format, 'W');\n\n  int64 pad_rows_before, pad_rows_after, pad_cols_before, pad_cols_after;\n  if (params.padding == Padding::EXPLICIT) {\n    GetExplicitPaddingForDim(params.explicit_paddings, params.data_format, 'H',\n                             &pad_rows_before, &pad_rows_after);\n    GetExplicitPaddingForDim(params.explicit_paddings, params.data_format, 'W',\n                             &pad_cols_before, &pad_cols_after);\n  }\n\n  // Compute windowed output sizes for rows and columns.\n  int64 out_rows = 0, out_cols = 0;\n  TF_RETURN_IF_ERROR(GetWindowedOutputSizeVerboseV2(\n      input_rows, filter_rows, dilation_rows, stride_rows, params.padding,\n      &out_rows, &pad_rows_before, &pad_rows_after));\n  TF_RETURN_IF_ERROR(GetWindowedOutputSizeVerboseV2(\n      input_cols, filter_cols, dilation_cols, stride_cols, params.padding,\n      &out_cols, &pad_cols_before, &pad_cols_after));\n\n  dimensions->batch = batch;\n  dimensions->input_rows = input_rows;\n  dimensions->input_cols = input_cols;\n  dimensions->in_depth = in_depth;\n  dimensions->filter_rows = filter_rows;\n  dimensions->filter_cols = filter_cols;\n  dimensions->patch_depth = patch_depth;\n  dimensions->out_depth = out_depth;\n  dimensions->stride_rows = stride_rows;\n  dimensions->stride_cols = stride_cols;\n  dimensions->dilation_rows = dilation_rows;\n  dimensions->dilation_cols = dilation_cols;\n  dimensions->out_rows = out_rows;\n  dimensions->out_cols = out_cols;\n  dimensions->pad_rows_before = pad_rows_before;\n  dimensions->pad_rows_after = pad_rows_after;\n  dimensions->pad_cols_before = pad_cols_before;\n  dimensions->pad_cols_after = pad_cols_after;\n\n  return Status::OK();\n}", "target": 0, "idx": 9727}
{"commit_id": "f490fc335772a9b14e78997486f4a572b0594c04", "project": "android", "func": "static int Downmix_Command(effect_handle_t self, uint32_t cmdCode, uint32_t cmdSize,\n        void *pCmdData, uint32_t *replySize, void *pReplyData) {\n\n    downmix_module_t *pDwmModule = (downmix_module_t *) self;\n    downmix_object_t *pDownmixer;\n\n    if (pDwmModule == NULL || pDwmModule->context.state == DOWNMIX_STATE_UNINITIALIZED) {\n        return -EINVAL;\n    }\n\n    pDownmixer = (downmix_object_t*) &pDwmModule->context;\n\n    ALOGV(\"Downmix_Command command %\" PRIu32 \" cmdSize %\" PRIu32, cmdCode, cmdSize);\n\n    switch (cmdCode) {\n    case EFFECT_CMD_INIT:\n        if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {\n            return -EINVAL;\n        }\n        *(int *) pReplyData = Downmix_Init(pDwmModule);\n        break;\n\n    case EFFECT_CMD_SET_CONFIG:\n        if (pCmdData == NULL || cmdSize != sizeof(effect_config_t)\n                || pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {\n            return -EINVAL;\n        }\n        *(int *) pReplyData = Downmix_Configure(pDwmModule,\n                (effect_config_t *)pCmdData, false);\n        break;\n\n    case EFFECT_CMD_RESET:\n        Downmix_Reset(pDownmixer, false);\n        break;\n\n    case EFFECT_CMD_GET_PARAM:\n        ALOGV(\"Downmix_Command EFFECT_CMD_GET_PARAM pCmdData %p, *replySize %\" PRIu32 \", pReplyData: %p\",\n                pCmdData, *replySize, pReplyData);\n        if (pCmdData == NULL || cmdSize < (int)(sizeof(effect_param_t) + sizeof(int32_t)) ||\n                pReplyData == NULL || replySize == NULL ||\n                *replySize < (int) sizeof(effect_param_t) + 2 * sizeof(int32_t)) {\n            return -EINVAL;\n        }\n        effect_param_t *rep = (effect_param_t *) pReplyData;\n        memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + sizeof(int32_t));\n        ALOGV(\"Downmix_Command EFFECT_CMD_GET_PARAM param %\" PRId32 \", replySize %\" PRIu32,\n                *(int32_t *)rep->data, rep->vsize);\n        rep->status = Downmix_getParameter(pDownmixer, *(int32_t *)rep->data, &rep->vsize,\n                rep->data + sizeof(int32_t));\n        *replySize = sizeof(effect_param_t) + sizeof(int32_t) + rep->vsize;\n        break;\n\n    case EFFECT_CMD_SET_PARAM:\n        ALOGV(\"Downmix_Command EFFECT_CMD_SET_PARAM cmdSize %d pCmdData %p, *replySize %\" PRIu32\n                \", pReplyData %p\", cmdSize, pCmdData, *replySize, pReplyData);\n        if (pCmdData == NULL || (cmdSize < (int)(sizeof(effect_param_t) + sizeof(int32_t)))\n                || pReplyData == NULL || replySize == NULL || *replySize != (int)sizeof(int32_t)) {\n            return -EINVAL;\n        }\n        effect_param_t *cmd = (effect_param_t *) pCmdData;\n        if (cmd->psize != sizeof(int32_t)) {\n            android_errorWriteLog(0x534e4554, \"63662938\");\n            return -EINVAL;\n        }\n        *(int *)pReplyData = Downmix_setParameter(pDownmixer, *(int32_t *)cmd->data,\n                cmd->vsize, cmd->data + sizeof(int32_t));\n        break;\n\n    case EFFECT_CMD_SET_PARAM_DEFERRED:\n        //FIXME implement\n        ALOGW(\"Downmix_Command command EFFECT_CMD_SET_PARAM_DEFERRED not supported, FIXME\");\n        break;\n\n    case EFFECT_CMD_SET_PARAM_COMMIT:\n        //FIXME implement\n        ALOGW(\"Downmix_Command command EFFECT_CMD_SET_PARAM_COMMIT not supported, FIXME\");\n        break;\n\n    case EFFECT_CMD_ENABLE:\n        if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {\n            return -EINVAL;\n        }\n        if (pDownmixer->state != DOWNMIX_STATE_INITIALIZED) {\n            return -ENOSYS;\n        }\n        pDownmixer->state = DOWNMIX_STATE_ACTIVE;\n        ALOGV(\"EFFECT_CMD_ENABLE() OK\");\n        *(int *)pReplyData = 0;\n        break;\n\n    case EFFECT_CMD_DISABLE:\n        if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {\n            return -EINVAL;\n        }\n        if (pDownmixer->state != DOWNMIX_STATE_ACTIVE) {\n            return -ENOSYS;\n        }\n        pDownmixer->state = DOWNMIX_STATE_INITIALIZED;\n        ALOGV(\"EFFECT_CMD_DISABLE() OK\");\n        *(int *)pReplyData = 0;\n        break;\n\n    case EFFECT_CMD_SET_DEVICE:\n        if (pCmdData == NULL || cmdSize != (int)sizeof(uint32_t)) {\n            return -EINVAL;\n        }\n        // FIXME change type if playing on headset vs speaker\n        ALOGV(\"Downmix_Command EFFECT_CMD_SET_DEVICE: 0x%08\" PRIx32, *(uint32_t *)pCmdData);\n        break;\n\n    case EFFECT_CMD_SET_VOLUME: {\n        // audio output is always stereo => 2 channel volumes\n        if (pCmdData == NULL || cmdSize != (int)sizeof(uint32_t) * 2) {\n            return -EINVAL;\n        }\n        // FIXME change volume\n        ALOGW(\"Downmix_Command command EFFECT_CMD_SET_VOLUME not supported, FIXME\");\n        float left = (float)(*(uint32_t *)pCmdData) / (1 << 24);\n        float right = (float)(*((uint32_t *)pCmdData + 1)) / (1 << 24);\n        ALOGV(\"Downmix_Command EFFECT_CMD_SET_VOLUME: left %f, right %f \", left, right);\n        break;\n    }\n\n    case EFFECT_CMD_SET_AUDIO_MODE:\n        if (pCmdData == NULL || cmdSize != (int)sizeof(uint32_t)) {\n            return -EINVAL;\n        }\n        ALOGV(\"Downmix_Command EFFECT_CMD_SET_AUDIO_MODE: %\" PRIu32, *(uint32_t *)pCmdData);\n        break;\n\n    case EFFECT_CMD_SET_CONFIG_REVERSE:\n    case EFFECT_CMD_SET_INPUT_DEVICE:\n        // these commands are ignored by a downmix effect\n        break;\n\n    default:\n        ALOGW(\"Downmix_Command invalid command %\" PRIu32, cmdCode);\n        return -EINVAL;\n    }\n\n    return 0;\n}", "target": 1, "idx": 9728}
{"commit_id": "1b5e2423164b3670e8bc9174e4762d297990deff", "project": "torvalds/linux", "func": "static s32\nbrcmf_wowl_nd_results(struct brcmf_if *ifp, const struct brcmf_event_msg *e,\n\t\t      void *data)\n{\n\tstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\n\tstruct wiphy *wiphy = cfg_to_wiphy(cfg);\n\tstruct brcmf_pno_scanresults_le *pfn_result;\n\tstruct brcmf_pno_net_info_le *netinfo;\n\n\tbrcmf_dbg(SCAN, \"Enter\\n\");\n\n\tif (e->datalen < (sizeof(*pfn_result) + sizeof(*netinfo))) {\n\t\tbrcmf_dbg(SCAN, \"Event data to small. Ignore\\n\");\n\t\treturn 0;\n\t}\n\n\tpfn_result = (struct brcmf_pno_scanresults_le *)data;\n\n\tif (e->event_code == BRCMF_E_PFN_NET_LOST) {\n\t\tbrcmf_dbg(SCAN, \"PFN NET LOST event. Ignore\\n\");\n\t\treturn 0;\n\t}\n\n\tif (le32_to_cpu(pfn_result->count) < 1) {\n\t\tbphy_err(wiphy, \"Invalid result count, expected 1 (%d)\\n\",\n\t\t\t le32_to_cpu(pfn_result->count));\n\t\treturn -EINVAL;\n\t}\n\n\tnetinfo = brcmf_get_netinfo_array(pfn_result);\n\tif (netinfo->SSID_len > IEEE80211_MAX_SSID_LEN)\n\t\tnetinfo->SSID_len = IEEE80211_MAX_SSID_LEN;\n\tmemcpy(cfg->wowl.nd->ssid.ssid, netinfo->SSID, netinfo->SSID_len);\n\tcfg->wowl.nd->ssid.ssid_len = netinfo->SSID_len;\n\tcfg->wowl.nd->n_channels = 1;\n\tcfg->wowl.nd->channels[0] =\n\t\tieee80211_channel_to_frequency(netinfo->channel,\n\t\t\tnetinfo->channel <= CH_MAX_2G_CHANNEL ?\n\t\t\t\t\tNL80211_BAND_2GHZ : NL80211_BAND_5GHZ);\n\tcfg->wowl.nd_info->n_matches = 1;\n\tcfg->wowl.nd_info->matches[0] = cfg->wowl.nd;\n\n\t/* Inform (the resume task) that the net detect information was recvd */\n\tcfg->wowl.nd_data_completed = true;\n\twake_up(&cfg->wowl.nd_data_wait);\n\n\treturn 0;\n}", "target": 2, "idx": 9729}
{"commit_id": "ef976323e770315b5fca544efb6b2faa25674d15", "project": "vim", "func": "static void\nspell_load_lang(char_u *lang)\n{\n    char_u\tfname_enc[85];\n    int\t\tr;\n    spelload_T\tsl;\n    int\t\tround;\n\n    // Copy the language name to pass it to spell_load_cb() as a cookie.\n    // It's truncated when an error is detected.\n    STRCPY(sl.sl_lang, lang);\n    sl.sl_slang = NULL;\n    sl.sl_nobreak = FALSE;\n\n    // Disallow deleting the current buffer.  Autocommands can do weird things\n    // and cause \"lang\" to be freed.\n    ++curbuf->b_locked;\n\n    // We may retry when no spell file is found for the language, an\n    // autocommand may load it then.\n    for (round = 1; round <= 2; ++round)\n    {\n\t/*\n\t * Find the first spell file for \"lang\" in 'runtimepath' and load it.\n\t */\n\tvim_snprintf((char *)fname_enc, sizeof(fname_enc) - 5,\n#ifdef VMS\n\t\t\t\t\t\"spell/%s_%s.spl\",\n#else\n\t\t\t\t\t\"spell/%s.%s.spl\",\n#endif\n\t\t\t\t\t\t\t   lang, spell_enc());\n\tr = do_in_runtimepath(fname_enc, 0, spell_load_cb, &sl);\n\n\tif (r == FAIL && *sl.sl_lang != NUL)\n\t{\n\t    // Try loading the ASCII version.\n\t    vim_snprintf((char *)fname_enc, sizeof(fname_enc) - 5,\n#ifdef VMS\n\t\t\t\t\t\t  \"spell/%s_ascii.spl\",\n#else\n\t\t\t\t\t\t  \"spell/%s.ascii.spl\",\n#endif\n\t\t\t\t\t\t\t\t\tlang);\n\t    r = do_in_runtimepath(fname_enc, 0, spell_load_cb, &sl);\n\n\t    if (r == FAIL && *sl.sl_lang != NUL && round == 1\n\t\t    && apply_autocmds(EVENT_SPELLFILEMISSING, lang,\n\t\t\t\t\t      curbuf->b_fname, FALSE, curbuf))\n\t\tcontinue;\n\t    break;\n\t}\n\tbreak;\n    }\n\n    if (r == FAIL)\n    {\n\tsmsg(\n#ifdef VMS\n\t_(\"Warning: Cannot find word list \\\"%s_%s.spl\\\" or \\\"%s_ascii.spl\\\"\"),\n#else\n\t_(\"Warning: Cannot find word list \\\"%s.%s.spl\\\" or \\\"%s.ascii.spl\\\"\"),\n#endif\n\t\t\t\t\t\t     lang, spell_enc(), lang);\n    }\n    else if (sl.sl_slang != NULL)\n    {\n\t// At least one file was loaded, now load ALL the additions.\n\tSTRCPY(fname_enc + STRLEN(fname_enc) - 3, \"add.spl\");\n\tdo_in_runtimepath(fname_enc, DIP_ALL, spell_load_cb, &sl);\n    }\n\n    --curbuf->b_locked;\n}", "target": 2, "idx": 9730}
{"commit_id": "6ca3e4f094da0a0017cb2d483ec1db6176bb0b16", "project": "qbittorrent/qBittorrent", "func": "void PropertiesWidget::loadTorrentInfos(BitTorrent::TorrentHandle *const torrent)\n{\n    clear();\n    m_torrent = torrent;\n    downloaded_pieces->setTorrent(m_torrent);\n    pieces_availability->setTorrent(m_torrent);\n    if (!m_torrent) return;\n\n    // Save path\n    updateSavePath(m_torrent);\n    // Hash\n    hash_lbl->setText(m_torrent->hash());\n    PropListModel->model()->clear();\n    if (m_torrent->hasMetadata()) {\n        // Creation date\n        lbl_creationDate->setText(m_torrent->creationDate().toString(Qt::DefaultLocaleShortDate));\n\n        label_total_size_val->setText(Utils::Misc::friendlyUnit(m_torrent->totalSize()));\n\n        // Comment\n        comment_text->setText(Utils::Misc::parseHtmlLinks(Utils::String::toHtmlEscaped(m_torrent->comment())));\n\n        // URL seeds\n        loadUrlSeeds();\n\n        label_created_by_val->setText(Utils::String::toHtmlEscaped(m_torrent->creator()));\n\n        // List files in torrent\n        PropListModel->model()->setupModelData(m_torrent->info());\n        filesList->setExpanded(PropListModel->index(0, 0), true);\n\n        // Load file priorities\n        PropListModel->model()->updateFilesPriorities(m_torrent->filePriorities());\n    }\n    // Load dynamic data\n    loadDynamicData();\n}", "target": 1, "idx": 9731}
{"commit_id": "ba953a9d89a00c078b85f4b190bc1dde66fe16b5", "project": "torvalds/linux", "func": "static int pfkey_register(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\tstruct sk_buff *supp_skb;\n\n\tif (hdr->sadb_msg_satype > SADB_SATYPE_MAX)\n\t\treturn -EINVAL;\n\n\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC) {\n\t\tif (pfk->registered&(1<<hdr->sadb_msg_satype))\n\t\t\treturn -EEXIST;\n\t\tpfk->registered |= (1<<hdr->sadb_msg_satype);\n\t}\n\n\tmutex_lock(&pfkey_mutex);\n\txfrm_probe_algs();\n\n\tsupp_skb = compose_sadb_supported(hdr, GFP_KERNEL | __GFP_ZERO);\n\tmutex_unlock(&pfkey_mutex);\n\n\tif (!supp_skb) {\n\t\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC)\n\t\t\tpfk->registered &= ~(1<<hdr->sadb_msg_satype);\n\n\t\treturn -ENOBUFS;\n\t}\n\n\tpfkey_broadcast(supp_skb, GFP_KERNEL, BROADCAST_REGISTERED, sk,\n\t\t\tsock_net(sk));\n\treturn 0;\n}", "target": 2, "idx": 9732}
{"commit_id": "4f65a3e4eedaffa1efcf9ee1eb08f0b504fbc31a", "project": "libgd", "func": "static inline LineContribType *_gdContributionsCalc(unsigned int line_size, unsigned int src_size, double scale_d,  const interpolation_method pFilter)\n{\n\tdouble width_d;\n\tdouble scale_f_d = 1.0;\n\tconst double filter_width_d = DEFAULT_BOX_RADIUS;\n\tint windows_size;\n\tunsigned int u;\n\tLineContribType *res;\n\n\tif (scale_d < 1.0) {\n\t\twidth_d = filter_width_d / scale_d;\n\t\tscale_f_d = scale_d;\n\t}  else {\n\t\twidth_d= filter_width_d;\n\t}\n\n\twindows_size = 2 * (int)ceil(width_d) + 1;\n\tres = _gdContributionsAlloc(line_size, windows_size);\n\n\tfor (u = 0; u < line_size; u++) {\n\t\tconst double dCenter = (double)u / scale_d;\n\t\t/* get the significant edge points affecting the pixel */\n\t\tregister int iLeft = MAX(0, (int)floor (dCenter - width_d));\n\t\tint iRight = MIN((int)ceil(dCenter + width_d), (int)src_size - 1);\n\t\tdouble dTotalWeight = 0.0;\n\t\tint iSrc;\n\n\t\t/* Cut edge points to fit in filter window in case of spill-off */\n\t\tif (iRight - iLeft + 1 > windows_size)  {\n\t\t\tif (iLeft < ((int)src_size - 1 / 2))  {\n\t\t\t\tiLeft++;\n\t\t\t} else {\n\t\t\t\tiRight--;\n\t\t\t}\n\t\t}\n\n\t\tres->ContribRow[u].Left = iLeft;\n\t\tres->ContribRow[u].Right = iRight;\n\n\t\tfor (iSrc = iLeft; iSrc <= iRight; iSrc++) {\n\t\t\tdTotalWeight += (res->ContribRow[u].Weights[iSrc-iLeft] =  scale_f_d * (*pFilter)(scale_f_d * (dCenter - (double)iSrc)));\n\t\t}\n\n\t\tif (dTotalWeight < 0.0) {\n\t\t\t_gdContributionsFree(res);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (dTotalWeight > 0.0) {\n\t\t\tfor (iSrc = iLeft; iSrc <= iRight; iSrc++) {\n\t\t\t\tres->ContribRow[u].Weights[iSrc-iLeft] /= dTotalWeight;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}", "target": 2, "idx": 9733}
{"commit_id": "591c546c536b42bef696d027f64aa22434f8c3f0", "project": "bluez", "func": "static void prep_write_cb(struct bt_att_chan *chan, uint8_t opcode,\n\t\t\t\t\tconst void *pdu, uint16_t length,\n\t\t\t\t\tvoid *user_data)\n{\n\tstruct bt_gatt_server *server = user_data;\n\tuint16_t handle = 0;\n\tuint16_t offset;\n\tstruct gatt_db_attribute *attr;\n\tstruct prep_write_complete_data *pwcd;\n\tuint8_t ecode, status;\n\n\tif (length < 4) {\n\t\tecode = BT_ATT_ERROR_INVALID_PDU;\n\t\tgoto error;\n\t}\n\n\tif (queue_length(server->prep_queue) >= server->max_prep_queue_len) {\n\t\tecode = BT_ATT_ERROR_PREPARE_QUEUE_FULL;\n\t\tgoto error;\n\t}\n\n\thandle = get_le16(pdu);\n\toffset = get_le16(pdu + 2);\n\n\tattr = gatt_db_get_attribute(server->db, handle);\n\tif (!attr) {\n\t\tecode = BT_ATT_ERROR_INVALID_HANDLE;\n\t\tgoto error;\n\t}\n\n\tutil_debug(server->debug_callback, server->debug_data,\n\t\t\t\t\"Prep Write Req - handle: 0x%04x\", handle);\n\n\tecode = check_length(length, offset);\n\tif (ecode)\n\t\tgoto error;\n\n\tecode = check_permissions(server, attr, BT_ATT_PERM_WRITE_MASK);\n\tif (ecode)\n\t\tgoto error;\n\n\tpwcd = new0(struct prep_write_complete_data, 1);\n\tpwcd->chan = chan;\n\tpwcd->pdu = malloc(length);\n\tmemcpy(pwcd->pdu, pdu, length);\n\tpwcd->length = length;\n\tpwcd->server = server;\n\n\tstatus = gatt_db_attribute_write(attr, offset, NULL, 0,\n\t\t\t\t\t\tBT_ATT_OP_PREP_WRITE_REQ,\n\t\t\t\t\t\tserver->att,\n\t\t\t\t\t\tprep_write_complete_cb, pwcd);\n\n\tif (status)\n\t\treturn;\n\n\tecode = BT_ATT_ERROR_UNLIKELY;\n\nerror:\n\tbt_att_chan_send_error_rsp(chan, opcode, handle, ecode);\n}", "target": 2, "idx": 9734}
{"commit_id": "bab0716c7f4793ec42e05a5aa7e80d82a0dd4e75", "project": "ffmpeg", "func": "static int mxf_parse_structural_metadata(MXFContext *mxf)\n{\n    MXFPackage *material_package = NULL;\n    int i, j, k, ret;\n\n    av_log(mxf->fc, AV_LOG_TRACE, \"metadata sets count %d\\n\", mxf->metadata_sets_count);\n    /* TODO: handle multiple material packages (OP3x) */\n    for (i = 0; i < mxf->packages_count; i++) {\n        material_package = mxf_resolve_strong_ref(mxf, &mxf->packages_refs[i], MaterialPackage);\n        if (material_package) break;\n    }\n    if (!material_package) {\n        av_log(mxf->fc, AV_LOG_ERROR, \"no material package found\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    mxf_add_umid_metadata(&mxf->fc->metadata, \"material_package_umid\", material_package);\n    if (material_package->name && material_package->name[0])\n        av_dict_set(&mxf->fc->metadata, \"material_package_name\", material_package->name, 0);\n    mxf_parse_package_comments(mxf, &mxf->fc->metadata, material_package);\n\n    for (i = 0; i < material_package->tracks_count; i++) {\n        MXFPackage *source_package = NULL;\n        MXFTrack *material_track = NULL;\n        MXFTrack *source_track = NULL;\n        MXFTrack *temp_track = NULL;\n        MXFDescriptor *descriptor = NULL;\n        MXFStructuralComponent *component = NULL;\n        MXFTimecodeComponent *mxf_tc = NULL;\n        UID *essence_container_ul = NULL;\n        const MXFCodecUL *codec_ul = NULL;\n        const MXFCodecUL *container_ul = NULL;\n        const MXFCodecUL *pix_fmt_ul = NULL;\n        AVStream *st;\n        AVTimecode tc;\n        int flags;\n\n        if (!(material_track = mxf_resolve_strong_ref(mxf, &material_package->tracks_refs[i], Track))) {\n            av_log(mxf->fc, AV_LOG_ERROR, \"could not resolve material track strong ref\\n\");\n            continue;\n        }\n\n        if ((component = mxf_resolve_strong_ref(mxf, &material_track->sequence_ref, TimecodeComponent))) {\n            mxf_tc = (MXFTimecodeComponent*)component;\n            flags = mxf_tc->drop_frame == 1 ? AV_TIMECODE_FLAG_DROPFRAME : 0;\n            if (av_timecode_init(&tc, mxf_tc->rate, flags, mxf_tc->start_frame, mxf->fc) == 0) {\n                mxf_add_timecode_metadata(&mxf->fc->metadata, \"timecode\", &tc);\n            }\n        }\n\n        if (!(material_track->sequence = mxf_resolve_strong_ref(mxf, &material_track->sequence_ref, Sequence))) {\n            av_log(mxf->fc, AV_LOG_ERROR, \"could not resolve material track sequence strong ref\\n\");\n            continue;\n        }\n\n        for (j = 0; j < material_track->sequence->structural_components_count; j++) {\n            component = mxf_resolve_strong_ref(mxf, &material_track->sequence->structural_components_refs[j], TimecodeComponent);\n            if (!component)\n                continue;\n\n            mxf_tc = (MXFTimecodeComponent*)component;\n            flags = mxf_tc->drop_frame == 1 ? AV_TIMECODE_FLAG_DROPFRAME : 0;\n            if (av_timecode_init(&tc, mxf_tc->rate, flags, mxf_tc->start_frame, mxf->fc) == 0) {\n                mxf_add_timecode_metadata(&mxf->fc->metadata, \"timecode\", &tc);\n                break;\n            }\n        }\n\n        /* TODO: handle multiple source clips, only finds first valid source clip */\n        if(material_track->sequence->structural_components_count > 1)\n            av_log(mxf->fc, AV_LOG_WARNING, \"material track %d: has %d components\\n\",\n                       material_track->track_id, material_track->sequence->structural_components_count);\n\n        for (j = 0; j < material_track->sequence->structural_components_count; j++) {\n            component = mxf_resolve_sourceclip(mxf, &material_track->sequence->structural_components_refs[j]);\n            if (!component)\n                continue;\n\n            source_package = mxf_resolve_source_package(mxf, component->source_package_ul, component->source_package_uid);\n            if (!source_package) {\n                av_log(mxf->fc, AV_LOG_TRACE, \"material track %d: no corresponding source package found\\n\", material_track->track_id);\n                continue;\n            }\n            for (k = 0; k < source_package->tracks_count; k++) {\n                if (!(temp_track = mxf_resolve_strong_ref(mxf, &source_package->tracks_refs[k], Track))) {\n                    av_log(mxf->fc, AV_LOG_ERROR, \"could not resolve source track strong ref\\n\");\n                    ret = AVERROR_INVALIDDATA;\n                    goto fail_and_free;\n                }\n                if (temp_track->track_id == component->source_track_id) {\n                    source_track = temp_track;\n                    break;\n                }\n            }\n            if (!source_track) {\n                av_log(mxf->fc, AV_LOG_ERROR, \"material track %d: no corresponding source track found\\n\", material_track->track_id);\n                break;\n            }\n\n            for (k = 0; k < mxf->essence_container_data_count; k++) {\n                MXFEssenceContainerData *essence_data;\n\n                if (!(essence_data = mxf_resolve_strong_ref(mxf, &mxf->essence_container_data_refs[k], EssenceContainerData))) {\n                    av_log(mxf->fc, AV_LOG_TRACE, \"could not resolve essence container data strong ref\\n\");\n                    continue;\n                }\n                if (!memcmp(component->source_package_ul, essence_data->package_ul, sizeof(UID)) && !memcmp(component->source_package_uid, essence_data->package_uid, sizeof(UID))) {\n                    source_track->body_sid = essence_data->body_sid;\n                    source_track->index_sid = essence_data->index_sid;\n                    break;\n                }\n            }\n\n            if(source_track && component)\n                break;\n        }\n        if (!source_track || !component || !source_package) {\n            if((ret = mxf_add_metadata_stream(mxf, material_track)))\n                goto fail_and_free;\n            continue;\n        }\n\n        if (!(source_track->sequence = mxf_resolve_strong_ref(mxf, &source_track->sequence_ref, Sequence))) {\n            av_log(mxf->fc, AV_LOG_ERROR, \"could not resolve source track sequence strong ref\\n\");\n            ret = AVERROR_INVALIDDATA;\n            goto fail_and_free;\n        }\n\n        /* 0001GL00.MXF.A1.mxf_opatom.mxf has the same SourcePackageID as 0001GL.MXF.V1.mxf_opatom.mxf\n         * This would result in both files appearing to have two streams. Work around this by sanity checking DataDefinition */\n        if (memcmp(material_track->sequence->data_definition_ul, source_track->sequence->data_definition_ul, 16)) {\n            av_log(mxf->fc, AV_LOG_ERROR, \"material track %d: DataDefinition mismatch\\n\", material_track->track_id);\n            continue;\n        }\n\n        st = avformat_new_stream(mxf->fc, NULL);\n        if (!st) {\n            av_log(mxf->fc, AV_LOG_ERROR, \"could not allocate stream\\n\");\n            ret = AVERROR(ENOMEM);\n            goto fail_and_free;\n        }\n        st->id = material_track->track_id;\n        st->priv_data = source_track;\n\n        source_package->descriptor = mxf_resolve_strong_ref(mxf, &source_package->descriptor_ref, AnyType);\n        descriptor = mxf_resolve_multidescriptor(mxf, source_package->descriptor, source_track->track_id);\n\n        /* A SourceClip from a EssenceGroup may only be a single frame of essence data. The clips duration is then how many\n         * frames its suppose to repeat for. Descriptor->duration, if present, contains the real duration of the essence data */\n        if (descriptor && descriptor->duration != AV_NOPTS_VALUE)\n            source_track->original_duration = st->duration = FFMIN(descriptor->duration, component->duration);\n        else\n            source_track->original_duration = st->duration = component->duration;\n\n        if (st->duration == -1)\n            st->duration = AV_NOPTS_VALUE;\n        st->start_time = component->start_position;\n        if (material_track->edit_rate.num <= 0 ||\n            material_track->edit_rate.den <= 0) {\n            av_log(mxf->fc, AV_LOG_WARNING,\n                   \"Invalid edit rate (%d/%d) found on stream #%d, \"\n                   \"defaulting to 25/1\\n\",\n                   material_track->edit_rate.num,\n                   material_track->edit_rate.den, st->index);\n            material_track->edit_rate = (AVRational){25, 1};\n        }\n        avpriv_set_pts_info(st, 64, material_track->edit_rate.den, material_track->edit_rate.num);\n\n        /* ensure SourceTrack EditRate == MaterialTrack EditRate since only\n         * the former is accessible via st->priv_data */\n        source_track->edit_rate = material_track->edit_rate;\n\n        PRINT_KEY(mxf->fc, \"data definition   ul\", source_track->sequence->data_definition_ul);\n        codec_ul = mxf_get_codec_ul(ff_mxf_data_definition_uls, &source_track->sequence->data_definition_ul);\n        st->codecpar->codec_type = codec_ul->id;\n\n        if (!descriptor) {\n            av_log(mxf->fc, AV_LOG_INFO, \"source track %d: stream %d, no descriptor found\\n\", source_track->track_id, st->index);\n            continue;\n        }\n        PRINT_KEY(mxf->fc, \"essence codec     ul\", descriptor->essence_codec_ul);\n        PRINT_KEY(mxf->fc, \"essence container ul\", descriptor->essence_container_ul);\n        essence_container_ul = &descriptor->essence_container_ul;\n        source_track->wrapping = (mxf->op == OPAtom) ? ClipWrapped : mxf_get_wrapping_kind(essence_container_ul);\n        if (source_track->wrapping == UnknownWrapped)\n            av_log(mxf->fc, AV_LOG_INFO, \"wrapping of stream %d is unknown\\n\", st->index);\n        /* HACK: replacing the original key with mxf_encrypted_essence_container\n         * is not allowed according to s429-6, try to find correct information anyway */\n        if (IS_KLV_KEY(essence_container_ul, mxf_encrypted_essence_container)) {\n            av_log(mxf->fc, AV_LOG_INFO, \"broken encrypted mxf file\\n\");\n            for (k = 0; k < mxf->metadata_sets_count; k++) {\n                MXFMetadataSet *metadata = mxf->metadata_sets[k];\n                if (metadata->type == CryptoContext) {\n                    essence_container_ul = &((MXFCryptoContext *)metadata)->source_container_ul;\n                    break;\n                }\n            }\n        }\n\n        /* TODO: drop PictureEssenceCoding and SoundEssenceCompression, only check EssenceContainer */\n        codec_ul = mxf_get_codec_ul(ff_mxf_codec_uls, &descriptor->essence_codec_ul);\n        st->codecpar->codec_id = (enum AVCodecID)codec_ul->id;\n        if (st->codecpar->codec_id == AV_CODEC_ID_NONE) {\n            codec_ul = mxf_get_codec_ul(ff_mxf_codec_uls, &descriptor->codec_ul);\n            st->codecpar->codec_id = (enum AVCodecID)codec_ul->id;\n        }\n\n        av_log(mxf->fc, AV_LOG_VERBOSE, \"%s: Universal Label: \",\n               avcodec_get_name(st->codecpar->codec_id));\n        for (k = 0; k < 16; k++) {\n            av_log(mxf->fc, AV_LOG_VERBOSE, \"%.2x\",\n                   descriptor->essence_codec_ul[k]);\n            if (!(k+1 & 19) || k == 5)\n                av_log(mxf->fc, AV_LOG_VERBOSE, \".\");\n        }\n        av_log(mxf->fc, AV_LOG_VERBOSE, \"\\n\");\n\n        mxf_add_umid_metadata(&st->metadata, \"file_package_umid\", source_package);\n        if (source_package->name && source_package->name[0])\n            av_dict_set(&st->metadata, \"file_package_name\", source_package->name, 0);\n        if (material_track->name && material_track->name[0])\n            av_dict_set(&st->metadata, \"track_name\", material_track->name, 0);\n\n        mxf_parse_physical_source_package(mxf, source_track, st);\n\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {\n            source_track->intra_only = mxf_is_intra_only(descriptor);\n            container_ul = mxf_get_codec_ul(mxf_picture_essence_container_uls, essence_container_ul);\n            if (st->codecpar->codec_id == AV_CODEC_ID_NONE)\n                st->codecpar->codec_id = container_ul->id;\n            st->codecpar->width = descriptor->width;\n            st->codecpar->height = descriptor->height; /* Field height, not frame height */\n            switch (descriptor->frame_layout) {\n                case FullFrame:\n                    st->codecpar->field_order = AV_FIELD_PROGRESSIVE;\n                    break;\n                case OneField:\n                    /* Every other line is stored and needs to be duplicated. */\n                    av_log(mxf->fc, AV_LOG_INFO, \"OneField frame layout isn't currently supported\\n\");\n                    break; /* The correct thing to do here is fall through, but by breaking we might be\n                              able to decode some streams at half the vertical resolution, rather than not al all.\n                              It's also for compatibility with the old behavior. */\n                case MixedFields:\n                    break;\n                case SegmentedFrame:\n                    st->codecpar->field_order = AV_FIELD_PROGRESSIVE;\n                case SeparateFields:\n                    av_log(mxf->fc, AV_LOG_DEBUG, \"video_line_map: (%d, %d), field_dominance: %d\\n\",\n                           descriptor->video_line_map[0], descriptor->video_line_map[1],\n                           descriptor->field_dominance);\n                    if ((descriptor->video_line_map[0] > 0) && (descriptor->video_line_map[1] > 0)) {\n                        /* Detect coded field order from VideoLineMap:\n                         *  (even, even) => bottom field coded first\n                         *  (even, odd)  => top field coded first\n                         *  (odd, even)  => top field coded first\n                         *  (odd, odd)   => bottom field coded first\n                         */\n                        if ((descriptor->video_line_map[0] + descriptor->video_line_map[1]) % 2) {\n                            switch (descriptor->field_dominance) {\n                                case MXF_FIELD_DOMINANCE_DEFAULT:\n                                case MXF_FIELD_DOMINANCE_FF:\n                                    st->codecpar->field_order = AV_FIELD_TT;\n                                    break;\n                                case MXF_FIELD_DOMINANCE_FL:\n                                    st->codecpar->field_order = AV_FIELD_TB;\n                                    break;\n                                default:\n                                    avpriv_request_sample(mxf->fc,\n                                                          \"Field dominance %d support\",\n                                                          descriptor->field_dominance);\n                            }\n                        } else {\n                            switch (descriptor->field_dominance) {\n                                case MXF_FIELD_DOMINANCE_DEFAULT:\n                                case MXF_FIELD_DOMINANCE_FF:\n                                    st->codecpar->field_order = AV_FIELD_BB;\n                                    break;\n                                case MXF_FIELD_DOMINANCE_FL:\n                                    st->codecpar->field_order = AV_FIELD_BT;\n                                    break;\n                                default:\n                                    avpriv_request_sample(mxf->fc,\n                                                          \"Field dominance %d support\",\n                                                          descriptor->field_dominance);\n                            }\n                        }\n                    }\n                    /* Turn field height into frame height. */\n                    st->codecpar->height *= 2;\n                    break;\n                default:\n                    av_log(mxf->fc, AV_LOG_INFO, \"Unknown frame layout type: %d\\n\", descriptor->frame_layout);\n            }\n            if (st->codecpar->codec_id == AV_CODEC_ID_RAWVIDEO) {\n                st->codecpar->format = descriptor->pix_fmt;\n                if (st->codecpar->format == AV_PIX_FMT_NONE) {\n                    pix_fmt_ul = mxf_get_codec_ul(ff_mxf_pixel_format_uls,\n                                                  &descriptor->essence_codec_ul);\n                    st->codecpar->format = (enum AVPixelFormat)pix_fmt_ul->id;\n                    if (st->codecpar->format== AV_PIX_FMT_NONE) {\n                        st->codecpar->codec_tag = mxf_get_codec_ul(ff_mxf_codec_tag_uls,\n                                                                   &descriptor->essence_codec_ul)->id;\n                        if (!st->codecpar->codec_tag) {\n                            /* support files created before RP224v10 by defaulting to UYVY422\n                               if subsampling is 4:2:2 and component depth is 8-bit */\n                            if (descriptor->horiz_subsampling == 2 &&\n                                descriptor->vert_subsampling == 1 &&\n                                descriptor->component_depth == 8) {\n                                st->codecpar->format = AV_PIX_FMT_UYVY422;\n                            }\n                        }\n                    }\n                }\n            }\n            st->need_parsing = AVSTREAM_PARSE_HEADERS;\n            if (material_track->sequence->origin) {\n                av_dict_set_int(&st->metadata, \"material_track_origin\", material_track->sequence->origin, 0);\n            }\n            if (source_track->sequence->origin) {\n                av_dict_set_int(&st->metadata, \"source_track_origin\", source_track->sequence->origin, 0);\n            }\n            if (descriptor->aspect_ratio.num && descriptor->aspect_ratio.den)\n                st->display_aspect_ratio = descriptor->aspect_ratio;\n        } else if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {\n            container_ul = mxf_get_codec_ul(mxf_sound_essence_container_uls, essence_container_ul);\n            /* Only overwrite existing codec ID if it is unset or A-law, which is the default according to SMPTE RP 224. */\n            if (st->codecpar->codec_id == AV_CODEC_ID_NONE || (st->codecpar->codec_id == AV_CODEC_ID_PCM_ALAW && (enum AVCodecID)container_ul->id != AV_CODEC_ID_NONE))\n                st->codecpar->codec_id = (enum AVCodecID)container_ul->id;\n            st->codecpar->channels = descriptor->channels;\n            st->codecpar->bits_per_coded_sample = descriptor->bits_per_sample;\n\n            if (descriptor->sample_rate.den > 0) {\n                st->codecpar->sample_rate = descriptor->sample_rate.num / descriptor->sample_rate.den;\n                avpriv_set_pts_info(st, 64, descriptor->sample_rate.den, descriptor->sample_rate.num);\n            } else {\n                av_log(mxf->fc, AV_LOG_WARNING, \"invalid sample rate (%d/%d) \"\n                       \"found for stream #%d, time base forced to 1/48000\\n\",\n                       descriptor->sample_rate.num, descriptor->sample_rate.den,\n                       st->index);\n                avpriv_set_pts_info(st, 64, 1, 48000);\n            }\n\n            /* if duration is set, rescale it from EditRate to SampleRate */\n            if (st->duration != AV_NOPTS_VALUE)\n                st->duration = av_rescale_q(st->duration,\n                                            av_inv_q(material_track->edit_rate),\n                                            st->time_base);\n\n            /* TODO: implement AV_CODEC_ID_RAWAUDIO */\n            if (st->codecpar->codec_id == AV_CODEC_ID_PCM_S16LE) {\n                if (descriptor->bits_per_sample > 16 && descriptor->bits_per_sample <= 24)\n                    st->codecpar->codec_id = AV_CODEC_ID_PCM_S24LE;\n                else if (descriptor->bits_per_sample == 32)\n                    st->codecpar->codec_id = AV_CODEC_ID_PCM_S32LE;\n            } else if (st->codecpar->codec_id == AV_CODEC_ID_PCM_S16BE) {\n                if (descriptor->bits_per_sample > 16 && descriptor->bits_per_sample <= 24)\n                    st->codecpar->codec_id = AV_CODEC_ID_PCM_S24BE;\n                else if (descriptor->bits_per_sample == 32)\n                    st->codecpar->codec_id = AV_CODEC_ID_PCM_S32BE;\n            } else if (st->codecpar->codec_id == AV_CODEC_ID_MP2) {\n                st->need_parsing = AVSTREAM_PARSE_FULL;\n            }\n        } else if (st->codecpar->codec_type == AVMEDIA_TYPE_DATA) {\n            enum AVMediaType type;\n            container_ul = mxf_get_codec_ul(mxf_data_essence_container_uls, essence_container_ul);\n            if (st->codecpar->codec_id == AV_CODEC_ID_NONE)\n                st->codecpar->codec_id = container_ul->id;\n            type = avcodec_get_type(st->codecpar->codec_id);\n            if (type == AVMEDIA_TYPE_SUBTITLE)\n                st->codecpar->codec_type = type;\n            if (container_ul->desc)\n                av_dict_set(&st->metadata, \"data_type\", container_ul->desc, 0);\n        }\n        if (descriptor->extradata) {\n            if (!ff_alloc_extradata(st->codecpar, descriptor->extradata_size)) {\n                memcpy(st->codecpar->extradata, descriptor->extradata, descriptor->extradata_size);\n            }\n        } else if (st->codecpar->codec_id == AV_CODEC_ID_H264) {\n            int coded_width = mxf_get_codec_ul(mxf_intra_only_picture_coded_width,\n                                               &descriptor->essence_codec_ul)->id;\n            if (coded_width)\n                st->codecpar->width = coded_width;\n            ret = ff_generate_avci_extradata(st);\n            if (ret < 0)\n                return ret;\n        }\n        if (st->codecpar->codec_type != AVMEDIA_TYPE_DATA && source_track->wrapping != FrameWrapped) {\n            /* TODO: decode timestamps */\n            st->need_parsing = AVSTREAM_PARSE_TIMESTAMPS;\n        }\n    }\n\n    ret = 0;\nfail_and_free:\n    return ret;\n}", "target": 1, "idx": 9735}
{"commit_id": "30ddcfe9bd1cce3e02f8135961bceb411419dbdb", "project": "adplug", "func": "std::string getauthor()\n    { return std::string(author + 1, *author); }", "target": 2, "idx": 9736}
{"commit_id": "6d647f6e458c9b727eae1a8077d27fa433ced788", "project": "gpac", "func": "static GF_Err BD_DecFieldReplace(GF_BifsDecoder * codec, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 NodeID, ind, field_ind, NumBits;\n\tGF_Node *node;\n\tGF_ChildNodeItem *prev_child;\n\tGF_FieldInfo field;\n\n\tNodeID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\tnode = gf_sg_find_node(codec->current_graph, NodeID);\n\tif (!node) return GF_NON_COMPLIANT_BITSTREAM;\n\tNumBits = gf_get_bit_size(gf_node_get_num_fields_in_mode(node, GF_SG_FIELD_CODING_IN)-1);\n\tind = gf_bs_read_int(bs, NumBits);\n\te = gf_bifs_get_field_index(node, ind, GF_SG_FIELD_CODING_IN, &field_ind);\n\tif (e) return e;\n\n\te = gf_node_get_field(node, field_ind, &field);\n\tif (e) return e;\n\n\tprev_child = NULL;\n\t/*store prev MFNode content*/\n\tif (field.fieldType == GF_SG_VRML_MFNODE) {\n\t\tprev_child = * ((GF_ChildNodeItem **) field.far_ptr);\n\t\t* ((GF_ChildNodeItem **) field.far_ptr) = NULL;\n\t}\n\t/*regular field*/\n\telse if (!gf_sg_vrml_is_sf_field(field.fieldType)) {\n\t\te = gf_sg_vrml_mf_reset(field.far_ptr, field.fieldType);\n\t\tif (e) return e;\n\t}\n\n\t/*parse the field*/\n\tcodec->is_com_dec = GF_TRUE;\n\te = gf_bifs_dec_field(codec, bs, node, &field, GF_FALSE);\n\tcodec->is_com_dec = GF_FALSE;\n\t/*remove prev nodes*/\n\tif (field.fieldType == GF_SG_VRML_MFNODE) {\n\t\tgf_node_unregister_children(node, prev_child);\n\t}\n\tif (!e) gf_bifs_check_field_change(node, &field);\n\treturn e;\n}", "target": 1, "idx": 9737}
{"commit_id": "5a15b72a270b514cd442872221a788a303bdaa88", "project": "chromium", "func": "void RenderFrameObserverNatives::OnDocumentElementCreated(\n    const v8::FunctionCallbackInfo<v8::Value>& args) {\n  CHECK(args.Length() == 2);\n  CHECK(args[0]->IsInt32());\n  CHECK(args[1]->IsFunction());\n\n  int frame_id = args[0]->Int32Value();\n\n  content::RenderFrame* frame = content::RenderFrame::FromRoutingID(frame_id);\n  if (!frame) {\n    LOG(WARNING) << \"No render frame found to register LoadWatcher.\";\n    return;\n  }\n\n  v8::Global<v8::Function> v8_callback(context()->isolate(),\n                                       args[1].As<v8::Function>());\n  base::Callback<void(bool)> callback(\n      base::Bind(&RenderFrameObserverNatives::InvokeCallback,\n                 weak_ptr_factory_.GetWeakPtr(), base::Passed(&v8_callback)));\n  if (ExtensionFrameHelper::Get(frame)->did_create_current_document_element()) {\n    // If the document element is already created, then we can call the callback\n    // immediately (though use PostTask to ensure that the callback is called\n    // asynchronously).\n    base::MessageLoop::current()->PostTask(FROM_HERE,\n                                           base::Bind(callback, true));\n  } else {\n    new LoadWatcher(frame, callback);\n  }\n\n  args.GetReturnValue().Set(true);\n}", "target": 3, "idx": 9738}
{"commit_id": "cf3ba049a2792ec2a4a877e343f5dd9654da53dc", "project": "Exiv2/exiv2", "func": "DataBuf PngChunk::readRawProfile(const DataBuf& text,bool iTXt)\n    {\n        DataBuf                 info;\n        unsigned char           unhex[103]={0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,\n                                            0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,\n                                            0,0,0,0,0,0,0,0,0,1, 2,3,4,5,6,7,8,9,0,0,\n                                            0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,\n                                            0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,10,11,12,\n                                            13,14,15};\n        if (text.size_ == 0) {\n            return DataBuf();\n        }\n\n        if ( iTXt ) {\n            info.alloc(text.size_);\n            ::memcpy(info.pData_,text.pData_,text.size_);\n            return  info;\n        }\n\n        const char *sp = (char*)text.pData_+1;\n        int pointerPos = 1;\n\n        // Look for newline\n        while (*sp != '\\n' && pointerPos < (text.size_ - 1))\n        {\n            sp++;\n            pointerPos++;\n        }\n\n        // Look for length\n        while ((*sp == '\\0' || *sp == ' ' || *sp == '\\n') && pointerPos < (text.size_ - 1))\n        {\n            sp++;\n            pointerPos++;\n        }\n\n        if (pointerPos == (text.size_ - 1))\n        {\n            return DataBuf();\n        }\n\n        long length = (long) atol(sp);\n\n        while (*sp != ' ' && *sp != '\\n' && pointerPos < (text.size_ - 1))\n        {\n            sp++;\n            pointerPos++;\n        }\n\n        if (pointerPos == (text.size_ - 1))\n        {\n            return DataBuf();\n        }\n\n        // Allocate space\n\n        if (length == 0)\n        {\n#ifdef DEBUG\n            std::cerr << \"Exiv2::PngChunk::readRawProfile: Unable To Copy Raw Profile: invalid profile length\\n\";\n#endif\n        }\n\n        info.alloc(length);\n\n        if (info.size_ != length)\n        {\n#ifdef DEBUG\n            std::cerr << \"Exiv2::PngChunk::readRawProfile: Unable To Copy Raw Profile: cannot allocate memory\\n\";\n#endif\n            return DataBuf();\n        }\n\n        // Copy profile, skipping white space and column 1 \"=\" signs\n\n        unsigned char *dp = (unsigned char*)info.pData_;\n        unsigned int nibbles = length * 2;\n\n        for (long i = 0; i < (long) nibbles; i++)\n        {\n            while (*sp < '0' || (*sp > '9' && *sp < 'a') || *sp > 'f')\n            {\n                if (*sp == '\\0')\n                {\n#ifdef DEBUG\n                    std::cerr << \"Exiv2::PngChunk::readRawProfile: Unable To Copy Raw Profile: ran out of data\\n\";\n#endif\n                    return DataBuf();\n                }\n\n                sp++;\n            }\n\n            if (i%2 == 0)\n                *dp = (unsigned char) (16*unhex[(int) *sp++]);\n            else\n                (*dp++) += unhex[(int) *sp++];\n        }\n\n        return info;\n\n    }", "target": 1, "idx": 9739}
{"commit_id": "31f780487e5ddc426888638786cdc47631687275", "project": "michaelrsweet/htmldoc", "func": "static int\t\t\t/* O - 0 = success, -1 = fail */\nimage_load_gif(image_t *img,\t/* I - Image pointer */\n               FILE    *fp,\t/* I - File to load from */\n               int     gray,\t/* I - 0 = color, 1 = grayscale */\n               int     load_data)/* I - 1 = load image data, 0 = just info */\n{\n  uchar\t\tbuf[1024];\t/* Input buffer */\n  gif_cmap_t\tcmap;\t\t/* Colormap */\n  int\t\tncolors,\t/* Bits per pixel */\n\t\ttransparent;\t/* Transparent color index */\n\n\n /*\n  * Read the header; we already know it is a GIF file...\n  */\n\n  fread(buf, 13, 1, fp);\n\n  img->width  = (buf[7] << 8) | buf[6];\n  img->height = (buf[9] << 8) | buf[8];\n  ncolors     = 2 << (buf[10] & 0x07);\n\n  if (img->width <= 0 || img->width > IMAGE_MAX_DIM || img->height <= 0 || img->height > IMAGE_MAX_DIM)\n    return (-1);\n\n  // If we are writing an encrypted PDF file, bump the use count so we create\n  // an image object (Acrobat 6 bug workaround)\n  if (Encryption)\n    img->use ++;\n\n  if (buf[10] & GIF_COLORMAP)\n    if (gif_read_cmap(fp, ncolors, cmap, &gray))\n      return (-1);\n\n  transparent = -1;\n\n  while (1)\n  {\n    switch (getc(fp))\n    {\n      case ';' :\t/* End of image */\n          return (-1);\t\t/* Early end of file */\n\n      case '!' :\t/* Extension record */\n          buf[0] = (uchar)getc(fp);\n          if (buf[0] == 0xf9)\t/* Graphic Control Extension */\n          {\n            gif_get_block(fp, buf);\n            if (buf[0] & 1)\t/* Get transparent color index */\n              transparent = buf[3];\n          }\n\n          while (gif_get_block(fp, buf) != 0);\n          break;\n\n      case ',' :\t/* Image data */\n          fread(buf, 9, 1, fp);\n\n          if (buf[8] & GIF_COLORMAP)\n          {\n            ncolors = 2 << (buf[8] & 0x07);\n\n\t    if (gif_read_cmap(fp, ncolors, cmap, &gray))\n\t      return (-1);\n\t  }\n\n          img->width  = (buf[5] << 8) | buf[4];\n          img->height = (buf[7] << 8) | buf[6];\n          img->depth  = gray ? 1 : 3;\n\n\t  if (img->width <= 0 || img->width > IMAGE_MAX_DIM || img->height <= 0 || img->height > IMAGE_MAX_DIM)\n\t    return (-1);\n\n          if (transparent >= 0)\n          {\n           /*\n            * Map transparent color to background color...\n            */\n\n            if (BodyColor[0])\n\t    {\n\t      float rgb[3]; /* RGB color */\n\n\n\t      get_color((uchar *)BodyColor, rgb);\n\n\t      cmap[transparent][0] = (uchar)(rgb[0] * 255.0f + 0.5f);\n\t      cmap[transparent][1] = (uchar)(rgb[1] * 255.0f + 0.5f);\n\t      cmap[transparent][2] = (uchar)(rgb[2] * 255.0f + 0.5f);\n\t    }\n\t    else\n\t    {\n\t      cmap[transparent][0] = 255;\n              cmap[transparent][1] = 255;\n              cmap[transparent][2] = 255;\n\t    }\n\n           /*\n\t    * Allocate a mask image...\n\t    */\n\n            image_need_mask(img);\n\t  }\n\n\t  if (!load_data)\n\t    return (0);\n\n          img->pixels = (uchar *)malloc((size_t)(img->width * img->height * img->depth));\n          if (img->pixels == NULL)\n            return (-1);\n\n\t  return (gif_read_image(fp, img, cmap, buf[8] & GIF_INTERLACE, transparent));\n    }\n  }\n}", "target": 1, "idx": 9740}
{"commit_id": "33e63d19e5496c151bad69f65cdbc7cba2b4c211", "project": "wireshark", "func": "static gboolean compare_by_coherent_set_key(gconstpointer key_a, gconstpointer key_b) {\n  return memcmp(key_a, key_b, sizeof(coherent_set_key)) == 0;\n}", "target": 1, "idx": 9741}
{"commit_id": "e49cdfb84fb5eca2a6261f3c51a3c793fab9f62e", "project": "brackeen/ok-file-formats", "func": "static void ok_png_decode2(ok_png_decoder *decoder) {\n    ok_png *png = decoder->png;\n\n    uint8_t png_header[8];\n    if (!ok_read(decoder, png_header, sizeof(png_header))) {\n        return;\n    }\n    uint8_t png_signature[8] = {137, 80, 78, 71, 13, 10, 26, 10};\n    if (memcmp(png_header, png_signature, 8) != 0) {\n        ok_png_error(decoder->png, OK_PNG_ERROR_INVALID, \"Invalid signature (not a PNG file)\");\n        return;\n    }\n\n    // When info_only is true, we only care about the IHDR chunk and whether or not\n    // the tRNS chunk exists.\n    bool info_only = (decoder->decode_flags & OK_PNG_INFO_ONLY) != 0;\n    bool hdr_found = false;\n    bool end_found = false;\n    while (!end_found) {\n        uint8_t chunk_header[8];\n        uint8_t chunk_footer[4];\n        if (!ok_read(decoder, chunk_header, sizeof(chunk_header))) {\n            return;\n        }\n        const uint32_t chunk_length = readBE32(chunk_header);\n        const uint32_t chunk_type = readBE32(chunk_header + 4);\n        bool success = false;\n\n        if (!hdr_found && chunk_type != OK_PNG_CHUNK_CGBI && chunk_type != OK_PNG_CHUNK_IHDR) {\n            ok_png_error(png, OK_PNG_ERROR_INVALID, \"IHDR chunk must appear first\");\n            return;\n        }\n        if (chunk_type == OK_PNG_CHUNK_IHDR) {\n            if (hdr_found) {\n                ok_png_error(png, OK_PNG_ERROR_INVALID, \"Multiple IHDR chunks not allowed\");\n                return;\n            }\n            hdr_found = true;\n            success = ok_png_read_header(decoder, chunk_length);\n            if (success && info_only) {\n                // If the png has alpha, then we have all the info we need.\n                // Otherwise, continue scanning to see if the tRNS chunk exists.\n                if (png->has_alpha) {\n                    return;\n                }\n            }\n        } else if (chunk_type == OK_PNG_CHUNK_CGBI) {\n            success = ok_seek(decoder, (long)chunk_length);\n            decoder->is_ios_format = true;\n        } else if (chunk_type == OK_PNG_CHUNK_PLTE && !info_only) {\n            success = ok_png_read_palette(decoder, chunk_length);\n        } else if (chunk_type == OK_PNG_CHUNK_TRNS) {\n            if (info_only) {\n                // No need to parse this chunk, we have all the info we need.\n                png->has_alpha = true;\n                return;\n            } else {\n                success = ok_png_read_transparency(decoder, chunk_length);\n            }\n        } else if (chunk_type == OK_PNG_CHUNK_IDAT) {\n            if (info_only) {\n                // Both IHDR and tRNS must come before IDAT, so we have all the info we need.\n                return;\n            }\n            success = ok_png_read_data(decoder, chunk_length);\n        } else if (chunk_type == OK_PNG_CHUNK_IEND) {\n            success = ok_seek(decoder, (long)chunk_length);\n            end_found = true;\n        } else {\n            // Ignore this chunk\n            success = ok_seek(decoder, (long)chunk_length);\n        }\n\n        if (!success) {\n            return;\n        }\n\n        // Read the footer (CRC) and ignore it\n        if (!ok_read(decoder, chunk_footer, sizeof(chunk_footer))) {\n            return;\n        }\n    }\n\n    // Sanity check\n    if (!decoder->decoding_completed) {\n        ok_png_error(png, OK_PNG_ERROR_INVALID, \"Missing imaga data\");\n    }\n}", "target": 2, "idx": 9742}
{"commit_id": "da649f031e36753c69268c5c027e695b8ae45e9a", "project": "ImageMagick", "func": "static Image *ExtractPostscript(Image *image,const ImageInfo *image_info,\n  MagickOffsetType PS_Offset,ssize_t PS_Size,ExceptionInfo *exception)\n{\n  char\n    postscript_file[MaxTextExtent];\n\n  const MagicInfo\n    *magic_info;\n\n  FILE\n    *ps_file;\n\n  int\n    c;\n\n  ImageInfo\n    *clone_info;\n\n  Image\n    *image2;\n\n  unsigned char\n    magick[2*MaxTextExtent];\n\n\n  if ((clone_info=CloneImageInfo(image_info)) == NULL)\n    return(image);\n  clone_info->blob=(void *) NULL;\n  clone_info->length=0;\n\n  /* Obtain temporary file */\n  (void) AcquireUniqueFilename(postscript_file);\n  ps_file=fopen_utf8(postscript_file,\"wb\");\n  if (ps_file == (FILE *) NULL)\n    goto FINISH;\n\n  /* Copy postscript to temporary file */\n  (void) SeekBlob(image,PS_Offset,SEEK_SET);\n  (void) ReadBlob(image, 2*MaxTextExtent, magick);\n\n  (void) SeekBlob(image,PS_Offset,SEEK_SET);\n  while (PS_Size-- > 0)\n  {\n    c=ReadBlobByte(image);\n    if (c == EOF)\n      break;\n    (void) fputc(c,ps_file);\n  }\n  (void) fclose(ps_file);\n\n    /* Detect file format - Check magic.mgk configuration file. */\n  magic_info=GetMagicInfo(magick,2*MaxTextExtent,exception);\n  if(magic_info == (const MagicInfo *) NULL) goto FINISH_UNL;\n  /*     printf(\"Detected:%s  \\n\",magic_info->name); */\n  if(exception->severity != UndefinedException) goto FINISH_UNL;\n  if(magic_info->name == (char *) NULL) goto FINISH_UNL;\n\n  (void) strncpy(clone_info->magick,magic_info->name,MaxTextExtent-1);\n\n    /* Read nested image */\n  /*FormatString(clone_info->filename,\"%s:%s\",magic_info->name,postscript_file);*/\n  FormatLocaleString(clone_info->filename,MaxTextExtent,\"%s\",postscript_file);\n  image2=ReadImage(clone_info,exception);\n\n  if (!image2)\n    goto FINISH_UNL;\n\n  /*\n    Replace current image with new image while copying base image\n    attributes.\n  */\n  (void) CopyMagickString(image2->filename,image->filename,MaxTextExtent);\n  (void) CopyMagickString(image2->magick_filename,image->magick_filename,MaxTextExtent);\n  (void) CopyMagickString(image2->magick,image->magick,MaxTextExtent);\n  image2->depth=image->depth;\n  DestroyBlob(image2);\n  image2->blob=ReferenceBlob(image->blob);\n\n  if ((image->rows == 0) || (image->columns == 0))\n    DeleteImageFromList(&image);\n\n  AppendImageToList(&image,image2);\n\n FINISH_UNL:\n  (void) RelinquishUniqueFileResource(postscript_file);\n FINISH:\n  DestroyImageInfo(clone_info);\n  return(image);\n}", "target": 1, "idx": 9743}
{"commit_id": "786de92b3cb26012d3d0f00ee37adf14527f35c4", "project": "torvalds/linux", "func": "static int uas_switch_interface(struct usb_device *udev,\n\t\t\t\tstruct usb_interface *intf)\n{\n\tstruct usb_host_interface *alt;\n\n\talt = uas_find_uas_alt_setting(intf);\n\tif (!alt)\n\t\treturn -ENODEV;\n\n\treturn usb_set_interface(udev, alt->desc.bInterfaceNumber,\n\t\t\talt->desc.bAlternateSetting);\n}", "target": 1, "idx": 9744}
{"commit_id": "21d19d0c64ff070dbf37279432837bf425c0d5dd", "project": "ImageMagick", "func": "static Image *ReadMAGICKImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  const void\n    *blob;\n\n  Image\n    *image;\n\n  ImageInfo\n    *blob_info;\n\n  register ssize_t\n    i;\n\n  size_t\n    extent;\n\n  blob_info=CloneImageInfo(image_info);\n  if (LocaleCompare(image_info->magick,\"MAGICK\") != 0)\n    (void) CopyMagickString(blob_info->filename,image_info->magick,\n      MaxTextExtent);\n  image=(Image *) NULL;\n  blob=(const void *) NULL;\n  extent=0;\n  for (i=0; MagickImageList[i].blob != (const void *) NULL; i++)\n    if (LocaleCompare(blob_info->filename,MagickImageList[i].name) == 0)\n      {\n        (void) CopyMagickString(blob_info->magick,MagickImageList[i].magick,\n          MaxTextExtent);\n        blob=MagickImageList[i].blob;\n        extent=MagickImageList[i].extent;\n        break;\n      }\n  if (blob == (const void *) NULL)\n    {\n      blob_info=DestroyImageInfo(blob_info);\n      ThrowReaderException(OptionError,\"UnrecognizedImageFormat\");\n    }\n  image=BlobToImage(blob_info,blob,extent,exception);\n  blob_info=DestroyImageInfo(blob_info);\n  if (image == (Image *) NULL)\n    return(image);\n  return(GetFirstImageInList(image));\n}", "target": 1, "idx": 9745}
{"commit_id": "5b597a2e5b28e2d5a52fc1be13f425f08f47cb62", "project": "php/php-src", "func": "static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC)\n{\n\tif (prev_options != NULL) {\n\t\t*prev_options = MBREX(regex_default_options);\n\t}\n\tif (prev_syntax != NULL) {\n\t\t*prev_syntax = MBREX(regex_default_syntax);\n\t}\n\tMBREX(regex_default_options) = options;\n\tMBREX(regex_default_syntax) = syntax;\n}", "target": 3, "idx": 9746}
{"commit_id": "a8f438d201fb165961ba1d5d3b80daa3637735f4", "project": "gpac", "func": "static void gf_media_update_bitrate_ex(GF_ISOFile *file, u32 track, Bool use_esd)\n{\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tu32 i, count, timescale, db_size, cdur, csize;\n\tu64 time_wnd, max_rate, avg_rate, bitrate;\n\tDouble br;\n\tGF_ISOSample sample;\n\n\tdb_size = 0;\n\tmax_rate = avg_rate = time_wnd = bitrate = 0;\n\n\tcsize = 0;\n\tcdur = 0;\n\tif (gf_isom_get_media_type(file, track)==GF_ISOM_MEDIA_AUDIO) {\n\t\tcsize = gf_isom_get_constant_sample_size(file, track);\n\t\tcdur = gf_isom_get_constant_sample_duration(file, track);\n\t\tif (cdur > 1) cdur = 0;\n\t}\n\n\tmemset(&sample, 0, sizeof(GF_ISOSample));\n\ttimescale = gf_isom_get_media_timescale(file, track);\n\tcount = gf_isom_get_sample_count(file, track);\n\n\tif (csize && cdur) {\n\t\tdb_size = 0;\n\t\tavg_rate = 8 * csize * timescale / cdur;\n\t\tbitrate = avg_rate;\n\t} else {\n\t\tu32 rate = 0;\n\t\tfor (i=0; i<count; i++) {\n\t\t\tu32 di;\n\t\t\tGF_ISOSample *samp = gf_isom_get_sample_info_ex(file, track, i+1, &di, NULL, &sample);\n\t\t\tif (!samp) break;\n\n\t\t\tif (samp->dataLength > db_size) db_size = samp->dataLength;\n\n\t\t\tavg_rate += samp->dataLength;\n\t\t\trate += samp->dataLength;\n\t\t\tif (samp->DTS > time_wnd + timescale) {\n\t\t\t\tif (rate > max_rate) max_rate = rate;\n\t\t\t\ttime_wnd = samp->DTS;\n\t\t\t\trate = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tbr = (Double) (s64) gf_isom_get_media_duration(file, track);\n\tbr /= timescale;\n\tif (br>0) {\n\t\tGF_ESD *esd = NULL;\n\t\tif (!csize || !cdur) {\n\t\t\tbitrate = (u32) ((Double) (s64)avg_rate / br);\n\t\t\tbitrate *= 8;\n\t\t\tmax_rate *= 8;\n\t\t}\n\t\tif (!max_rate) max_rate = bitrate;\n\n\t\tif (use_esd) esd = gf_isom_get_esd(file, track, 1);\n\t\tif (esd && esd->decoderConfig) {\n\t\t\tesd->decoderConfig->avgBitrate = (u32) bitrate;\n\t\t\tesd->decoderConfig->maxBitrate = (u32) max_rate;\n\t\t\tesd->decoderConfig->bufferSizeDB = db_size;\n\t\t\tgf_isom_change_mpeg4_description(file, track, 1, esd);\n\t\t} else {\n\t\t\t/*move to bps*/\n\t\t\tgf_isom_update_bitrate(file, track, 1, (u32) bitrate, (u32) max_rate, db_size);\n\t\t}\n\t\tif (esd) gf_odf_desc_del((GF_Descriptor *)esd);\n\t}\n#endif\n}", "target": 2, "idx": 9747}
{"commit_id": "c99d98cd189839dcf51aee94e7437b54b31f8abd", "project": "tensorflow", "func": "void Node::RunForwardTypeInference() {\n  VLOG(4) << \"Forward type inference: \" << props_->node_def.DebugString();\n\n  if (props_->fwd_type_fn == nullptr) {\n    return;\n  }\n\n  std::vector<Node*> input_nodes(props_->input_types.size(), nullptr);\n  std::vector<int> input_idx(props_->input_types.size(), 0);\n  for (const auto& edge : in_edges_) {\n    if (edge->IsControlEdge()) {\n      continue;\n    }\n    DCHECK(edge->dst_input() < input_nodes.size()) << DebugString();\n    int i = edge->dst_input();\n    input_nodes.at(i) = edge->src();\n    input_idx.at(i) = edge->src_output();\n  }\n\n  // Note: technically, we could use a very generic type when some of the inputs\n  // are unknown. But there is an expectation that a node will have complete\n  // inputs soon, so updating intermediate types is largely unnecessary.\n\n  for (const auto* node : input_nodes) {\n    if (node == nullptr) {\n      // Incomplete inputs, bail.\n      ClearTypeInfo();\n      return;\n    }\n  }\n\n  static FullTypeDef* no_type = new FullTypeDef();\n\n  std::vector<std::reference_wrapper<const FullTypeDef>> input_types;\n  for (int i = 0; i < input_nodes.size(); i++) {\n    const auto* node = input_nodes[i];\n    if (node->def().has_experimental_type()) {\n      const auto& node_t = node->def().experimental_type();\n      if (node_t.type_id() != TFT_UNSET) {\n        int ix = input_idx[i];\n        if (ix >= node_t.args_size()) {\n          LOG(WARNING) << name() << \" has bad type information: input \" << i\n                       << \" should have an output \" << ix\n                       << \" but instead only has \" << node_t.args_size()\n                       << \" outputs: \" << node_t.DebugString()\n                       << \"\\nThis indicates either \"\n                          \"a bug in op registration or a corrupted graph.\";\n          ClearTypeInfo();\n          return;\n        }\n        input_types.emplace_back(node_t.args(ix));\n      } else {\n        input_types.emplace_back(*no_type);\n      }\n    } else {\n      // Incomplete inputs, bail.\n      ClearTypeInfo();\n      return;\n    }\n  }\n\n  const auto infer_type = props_->fwd_type_fn(input_types);\n  const FullTypeDef infer_typedef = infer_type.ValueOrDie();\n  if (infer_typedef.type_id() != TFT_UNSET) {\n    MaybeCopyOnWrite();\n    *(props_->node_def.mutable_experimental_type()) = infer_typedef;\n  }\n}", "target": 2, "idx": 9748}
{"commit_id": "b102f0c522cf668c8382c56a4f771b37d011cda2", "project": "torvalds/linux", "func": "static void\nmt76_add_fragment(struct mt76_dev *dev, struct mt76_queue *q, void *data,\n\t\t  int len, bool more)\n{\n\tstruct page *page = virt_to_head_page(data);\n\tint offset = data - page_address(page);\n\tstruct sk_buff *skb = q->rx_head;\n\tstruct skb_shared_info *shinfo = skb_shinfo(skb);\n\n\tif (shinfo->nr_frags < ARRAY_SIZE(shinfo->frags)) {\n\t\toffset += q->buf_offset;\n\t\tskb_add_rx_frag(skb, shinfo->nr_frags, page, offset, len,\n\t\t\t\tq->buf_size);\n\t}\n\n\tif (more)\n\t\treturn;\n\n\tq->rx_head = NULL;\n\tdev->drv->rx_skb(dev, q - dev->q_rx, skb);\n}", "target": 1, "idx": 9749}
{"commit_id": "0c4120fffa3dffe97b95c486a120eded82afe8a6", "project": "enferex/pdfresurrect", "func": "int main(int argc, char **argv)\n{\n    int         i, n_valid, do_write, do_scrub;\n    char       *c, *dname, *name;\n    DIR        *dir;\n    FILE       *fp;\n    pdf_t      *pdf;\n    pdf_flag_t  flags;\n\n    if (argc < 2)\n      usage();\n\n    /* Args */\n    do_write = do_scrub = flags = 0;\n    name = NULL;\n    for (i=1; i<argc; i++)\n    {\n        if (strncmp(argv[i], \"-w\", 2) == 0)\n          do_write = 1;\n        else if (strncmp(argv[i], \"-i\", 2) == 0)\n          flags |= PDF_FLAG_DISP_CREATOR;\n        else if (strncmp(argv[i], \"-q\", 2) == 0)\n          flags |= PDF_FLAG_QUIET;\n        else if (strncmp(argv[i], \"-s\", 2) == 0)\n          do_scrub = 1;\n        else if (argv[i][0] != '-')\n          name = argv[i];\n        else if (argv[i][0] == '-')\n          usage();\n    }\n\n    if (!name)\n      usage();\n\n    if (!(fp = fopen(name, \"r\")))\n    {\n        ERR(\"Could not open file '%s'\\n\", argv[1]);\n        return -1;\n    }\n    else if (!pdf_is_pdf(fp))\n    {\n        ERR(\"'%s' specified is not a valid PDF\\n\", name);\n        fclose(fp);\n        return -1;\n    }\n\n    /* Load PDF */\n    if (!(pdf = init_pdf(fp, name)))\n    {\n        fclose(fp);\n        return -1;\n    }\n\n    /* Count valid xrefs */\n    for (i=0, n_valid=0; i<pdf->n_xrefs; i++)\n      if (pdf->xrefs[i].version)\n        ++n_valid;\n\n    /* Bail if we only have 1 valid */\n    if (n_valid < 2)\n    {\n        if (!(flags & (PDF_FLAG_QUIET | PDF_FLAG_DISP_CREATOR)))\n          printf(\"%s: There is only one version of this PDF\\n\", pdf->name);\n\n        if (do_write)\n        {\n            fclose(fp);\n            pdf_delete(pdf);\n            return 0;\n        }\n    }\n\n    dname = NULL;\n    if (do_write)\n    {\n        /* Create directory to place the various versions in */\n        if ((c = strrchr(name, '/')))\n          name = c + 1;\n\n        if ((c = strrchr(name, '.')))\n          *c = '\\0';\n\n        dname = safe_calloc(strlen(name) + 16);\n        sprintf(dname, \"%s-versions\", name);\n        if (!(dir = opendir(dname)))\n          mkdir(dname, S_IRWXU);\n        else\n        {\n            ERR(\"This directory already exists, PDF version extraction will \"\n                \"not occur.\\n\");\n            fclose(fp);\n            closedir(dir);\n            free(dname);\n            pdf_delete(pdf);\n            return -1;\n        }\n    \n        /* Write the pdf as a pervious version */\n        for (i=0; i<pdf->n_xrefs; i++)\n          if (pdf->xrefs[i].version)\n            write_version(fp, name, dname, &pdf->xrefs[i]);\n    }\n\n    /* Generate a per-object summary */\n    pdf_summarize(fp, pdf, dname, flags);\n\n    /* Have we been summoned to scrub history from this PDF */\n    if (do_scrub)\n      scrub_document(fp, pdf);\n\n    /* Display extra information */\n    if (flags & PDF_FLAG_DISP_CREATOR)\n      display_creator(fp, pdf);\n\n    fclose(fp);\n    free(dname);\n    pdf_delete(pdf);\n\n    return 0;\n}", "target": 2, "idx": 9750}
{"commit_id": "5eb9743410ce4657e9d54fef26a2ee31a1b5dd0", "project": "libtom/libtomcrypt", "func": "int rsa_verify_hash_ex(const unsigned char *sig,      unsigned long siglen,\n                       const unsigned char *hash,     unsigned long hashlen,\n                             int            padding,\n                             int            hash_idx, unsigned long saltlen,\n                             int           *stat,     rsa_key      *key)\n{\n  unsigned long modulus_bitlen, modulus_bytelen, x;\n  int           err;\n  unsigned char *tmpbuf;\n\n  LTC_ARGCHK(hash  != NULL);\n  LTC_ARGCHK(sig   != NULL);\n  LTC_ARGCHK(stat  != NULL);\n  LTC_ARGCHK(key   != NULL);\n\n  /* default to invalid */\n  *stat = 0;\n\n  /* valid padding? */\n\n  if ((padding != LTC_PKCS_1_V1_5) &&\n      (padding != LTC_PKCS_1_PSS)) {\n    return CRYPT_PK_INVALID_PADDING;\n  }\n\n  if (padding == LTC_PKCS_1_PSS) {\n    /* valid hash ? */\n    if ((err = hash_is_valid(hash_idx)) != CRYPT_OK) {\n       return err;\n    }\n  }\n\n  /* get modulus len in bits */\n  modulus_bitlen = mp_count_bits( (key->N));\n\n  /* outlen must be at least the size of the modulus */\n  modulus_bytelen = mp_unsigned_bin_size( (key->N));\n  if (modulus_bytelen != siglen) {\n     return CRYPT_INVALID_PACKET;\n  }\n\n  /* allocate temp buffer for decoded sig */\n  tmpbuf = XMALLOC(siglen);\n  if (tmpbuf == NULL) {\n     return CRYPT_MEM;\n  }\n\n  /* RSA decode it  */\n  x = siglen;\n  if ((err = ltc_mp.rsa_me(sig, siglen, tmpbuf, &x, PK_PUBLIC, key)) != CRYPT_OK) {\n     XFREE(tmpbuf);\n     return err;\n  }\n\n  /* make sure the output is the right size */\n  if (x != siglen) {\n     XFREE(tmpbuf);\n     return CRYPT_INVALID_PACKET;\n  }\n\n  if (padding == LTC_PKCS_1_PSS) {\n    /* PSS decode and verify it */\n\n    if(modulus_bitlen%8 == 1){\n      err = pkcs_1_pss_decode(hash, hashlen, tmpbuf+1, x-1, saltlen, hash_idx, modulus_bitlen, stat);\n    }\n    else{\n      err = pkcs_1_pss_decode(hash, hashlen, tmpbuf, x, saltlen, hash_idx, modulus_bitlen, stat);\n    }\n\n  } else {\n    /* PKCS #1 v1.5 decode it */\n    unsigned char *out;\n    unsigned long outlen, loid[16], reallen;\n    int           decoded;\n    ltc_asn1_list digestinfo[2], siginfo[2];\n\n    /* not all hashes have OIDs... so sad */\n    if (hash_descriptor[hash_idx].OIDlen == 0) {\n       err = CRYPT_INVALID_ARG;\n       goto bail_2;\n    }\n\n    /* allocate temp buffer for decoded hash */\n    outlen = ((modulus_bitlen >> 3) + (modulus_bitlen & 7 ? 1 : 0)) - 3;\n    out    = XMALLOC(outlen);\n    if (out == NULL) {\n      err = CRYPT_MEM;\n      goto bail_2;\n    }\n\n    if ((err = pkcs_1_v1_5_decode(tmpbuf, x, LTC_PKCS_1_EMSA, modulus_bitlen, out, &outlen, &decoded)) != CRYPT_OK) {\n      XFREE(out);\n      goto bail_2;\n    }\n\n    /* now we must decode out[0...outlen-1] using ASN.1, test the OID and then test the hash */\n    /* construct the SEQUENCE\n      SEQUENCE {\n         SEQUENCE {hashoid OID\n                   blah    NULL\n         }\n         hash    OCTET STRING\n      }\n   */\n    LTC_SET_ASN1(digestinfo, 0, LTC_ASN1_OBJECT_IDENTIFIER, loid, sizeof(loid)/sizeof(loid[0]));\n    LTC_SET_ASN1(digestinfo, 1, LTC_ASN1_NULL,              NULL,                          0);\n    LTC_SET_ASN1(siginfo,    0, LTC_ASN1_SEQUENCE,          digestinfo,                    2);\n    LTC_SET_ASN1(siginfo,    1, LTC_ASN1_OCTET_STRING,      tmpbuf,                        siglen);\n\n    if ((err = der_decode_sequence(out, outlen, siginfo, 2)) != CRYPT_OK) {\n       XFREE(out);\n       goto bail_2;\n    }\n\n    if ((err = der_length_sequence(siginfo, 2, &reallen)) != CRYPT_OK) {\n       XFREE(out);\n       goto bail_2;\n    }\n\n    /* test OID */\n    if ((reallen == outlen) &&\n        (digestinfo[0].size == hash_descriptor[hash_idx].OIDlen) &&\n        (XMEMCMP(digestinfo[0].data, hash_descriptor[hash_idx].OID, sizeof(unsigned long) * hash_descriptor[hash_idx].OIDlen) == 0) &&\n        (siginfo[1].size == hashlen) &&\n        (XMEMCMP(siginfo[1].data, hash, hashlen) == 0)) {\n       *stat = 1;\n    }\n\n#ifdef LTC_CLEAN_STACK\n    zeromem(out, outlen);\n#endif\n    XFREE(out);\n  }\n\nbail_2:\n#ifdef LTC_CLEAN_STACK\n  zeromem(tmpbuf, siglen);\n#endif\n  XFREE(tmpbuf);\n  return err;\n}", "target": 2, "idx": 9751}
{"commit_id": "128394eff343fc6d2f32172f03e24829539c5835", "project": "torvalds/linux", "func": "static ssize_t\nsg_write(struct file *filp, const char __user *buf, size_t count, loff_t * ppos)\n{\n\tint mxsize, cmd_size, k;\n\tint input_size, blocking;\n\tunsigned char opcode;\n\tSg_device *sdp;\n\tSg_fd *sfp;\n\tSg_request *srp;\n\tstruct sg_header old_hdr;\n\tsg_io_hdr_t *hp;\n\tunsigned char cmnd[SG_MAX_CDB_SIZE];\n\n\tif (unlikely(segment_eq(get_fs(), KERNEL_DS)))\n\t\treturn -EINVAL;\n\n\tif ((!(sfp = (Sg_fd *) filp->private_data)) || (!(sdp = sfp->parentdp)))\n\t\treturn -ENXIO;\n\tSCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sdp,\n\t\t\t\t      \"sg_write: count=%d\\n\", (int) count));\n\tif (atomic_read(&sdp->detaching))\n\t\treturn -ENODEV;\n\tif (!((filp->f_flags & O_NONBLOCK) ||\n\t      scsi_block_when_processing_errors(sdp->device)))\n\t\treturn -ENXIO;\n\n\tif (!access_ok(VERIFY_READ, buf, count))\n\t\treturn -EFAULT;\t/* protects following copy_from_user()s + get_user()s */\n\tif (count < SZ_SG_HEADER)\n\t\treturn -EIO;\n\tif (__copy_from_user(&old_hdr, buf, SZ_SG_HEADER))\n\t\treturn -EFAULT;\n\tblocking = !(filp->f_flags & O_NONBLOCK);\n\tif (old_hdr.reply_len < 0)\n\t\treturn sg_new_write(sfp, filp, buf, count,\n\t\t\t\t    blocking, 0, 0, NULL);\n\tif (count < (SZ_SG_HEADER + 6))\n\t\treturn -EIO;\t/* The minimum scsi command length is 6 bytes. */\n\n\tif (!(srp = sg_add_request(sfp))) {\n\t\tSCSI_LOG_TIMEOUT(1, sg_printk(KERN_INFO, sdp,\n\t\t\t\t\t      \"sg_write: queue full\\n\"));\n\t\treturn -EDOM;\n\t}\n\tbuf += SZ_SG_HEADER;\n\t__get_user(opcode, buf);\n\tif (sfp->next_cmd_len > 0) {\n\t\tcmd_size = sfp->next_cmd_len;\n\t\tsfp->next_cmd_len = 0;\t/* reset so only this write() effected */\n\t} else {\n\t\tcmd_size = COMMAND_SIZE(opcode);\t/* based on SCSI command group */\n\t\tif ((opcode >= 0xc0) && old_hdr.twelve_byte)\n\t\t\tcmd_size = 12;\n\t}\n\tSCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sdp,\n\t\t\"sg_write:   scsi opcode=0x%02x, cmd_size=%d\\n\", (int) opcode, cmd_size));\n/* Determine buffer size.  */\n\tinput_size = count - cmd_size;\n\tmxsize = (input_size > old_hdr.reply_len) ? input_size : old_hdr.reply_len;\n\tmxsize -= SZ_SG_HEADER;\n\tinput_size -= SZ_SG_HEADER;\n\tif (input_size < 0) {\n\t\tsg_remove_request(sfp, srp);\n\t\treturn -EIO;\t/* User did not pass enough bytes for this command. */\n\t}\n\thp = &srp->header;\n\thp->interface_id = '\\0';\t/* indicator of old interface tunnelled */\n\thp->cmd_len = (unsigned char) cmd_size;\n\thp->iovec_count = 0;\n\thp->mx_sb_len = 0;\n\tif (input_size > 0)\n\t\thp->dxfer_direction = (old_hdr.reply_len > SZ_SG_HEADER) ?\n\t\t    SG_DXFER_TO_FROM_DEV : SG_DXFER_TO_DEV;\n\telse\n\t\thp->dxfer_direction = (mxsize > 0) ? SG_DXFER_FROM_DEV : SG_DXFER_NONE;\n\thp->dxfer_len = mxsize;\n\tif ((hp->dxfer_direction == SG_DXFER_TO_DEV) ||\n\t    (hp->dxfer_direction == SG_DXFER_TO_FROM_DEV))\n\t\thp->dxferp = (char __user *)buf + cmd_size;\n\telse\n\t\thp->dxferp = NULL;\n\thp->sbp = NULL;\n\thp->timeout = old_hdr.reply_len;\t/* structure abuse ... */\n\thp->flags = input_size;\t/* structure abuse ... */\n\thp->pack_id = old_hdr.pack_id;\n\thp->usr_ptr = NULL;\n\tif (__copy_from_user(cmnd, buf, cmd_size))\n\t\treturn -EFAULT;\n\t/*\n\t * SG_DXFER_TO_FROM_DEV is functionally equivalent to SG_DXFER_FROM_DEV,\n\t * but is is possible that the app intended SG_DXFER_TO_DEV, because there\n\t * is a non-zero input_size, so emit a warning.\n\t */\n\tif (hp->dxfer_direction == SG_DXFER_TO_FROM_DEV) {\n\t\tstatic char cmd[TASK_COMM_LEN];\n\t\tif (strcmp(current->comm, cmd)) {\n\t\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\t\t   \"sg_write: data in/out %d/%d bytes \"\n\t\t\t\t\t   \"for SCSI command 0x%x-- guessing \"\n\t\t\t\t\t   \"data in;\\n   program %s not setting \"\n\t\t\t\t\t   \"count and/or reply_len properly\\n\",\n\t\t\t\t\t   old_hdr.reply_len - (int)SZ_SG_HEADER,\n\t\t\t\t\t   input_size, (unsigned int) cmnd[0],\n\t\t\t\t\t   current->comm);\n\t\t\tstrcpy(cmd, current->comm);\n\t\t}\n\t}\n\tk = sg_common_write(sfp, srp, cmnd, sfp->timeout, blocking);\n\treturn (k < 0) ? k : count;\n}", "target": 2, "idx": 9752}
{"commit_id": "bc7ffad53643a9c80231fc41f5582d6a8931c32c", "project": "polkit", "func": "static gboolean\npolkit_backend_interactive_authority_authentication_agent_response (PolkitBackendAuthority   *authority,\n                                                              PolkitSubject            *caller,\n                                                              uid_t                     uid,\n                                                              const gchar              *cookie,\n                                                              PolkitIdentity           *identity,\n                                                              GError                  **error)\n{\n  PolkitBackendInteractiveAuthority *interactive_authority;\n  PolkitBackendInteractiveAuthorityPrivate *priv;\n  PolkitIdentity *user_of_caller;\n  gchar *identity_str;\n  AuthenticationSession *session;\n  GList *l;\n  gboolean ret;\n\n  interactive_authority = POLKIT_BACKEND_INTERACTIVE_AUTHORITY (authority);\n  priv = POLKIT_BACKEND_INTERACTIVE_AUTHORITY_GET_PRIVATE (interactive_authority);\n\n  ret = FALSE;\n  user_of_caller = NULL;\n\n  identity_str = polkit_identity_to_string (identity);\n\n  g_debug (\"In authentication_agent_response for cookie '%s' and identity %s\",\n           cookie,\n           identity_str);\n\n  user_of_caller = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor,\n                                                                        caller, NULL,\n                                                                        error);\n  if (user_of_caller == NULL)\n    goto out;\n\n  /* only uid 0 is allowed to invoke this method */\n  if (!identity_is_root_user (user_of_caller))\n    {\n      g_set_error (error,\n                   POLKIT_ERROR,\n                   POLKIT_ERROR_FAILED,\n                   \"Only uid 0 may invoke this method. This incident has been logged.\");\n      /* TODO: actually log this */\n      goto out;\n    }\n\n  /* find the authentication session */\n  session = get_authentication_session_for_uid_and_cookie (interactive_authority, uid, cookie);\n  if (session == NULL)\n    {\n      g_set_error (error,\n                   POLKIT_ERROR,\n                   POLKIT_ERROR_FAILED,\n                   \"No session for cookie\");\n      goto out;\n    }\n\n  /* check that the authentication identity was one of the possibilities we allowed */\n  for (l = session->identities; l != NULL; l = l->next)\n    {\n      PolkitIdentity *i = POLKIT_IDENTITY (l->data);\n\n      if (polkit_identity_equal (i, identity))\n        break;\n    }\n\n  if (l == NULL)\n    {\n      g_set_error (error,\n                   POLKIT_ERROR,\n                   POLKIT_ERROR_FAILED,\n                   \"The authenticated identity is wrong\");\n      goto out;\n    }\n\n  /* checks out, mark the session as authenticated */\n  session->is_authenticated = TRUE;\n  session->authenticated_identity = g_object_ref (identity);\n\n  ret = TRUE;\n\n out:\n  g_free (identity_str);\n\n  if (user_of_caller != NULL)\n    g_object_unref (user_of_caller);\n\n  return ret;\n}", "target": 1, "idx": 9753}
{"commit_id": "9fa492cdc160cd27ce1046cb36f47d3b2b1efa21", "project": "torvalds/linux", "func": "static inline int compat_copy_match_to_user(struct ipt_entry_match *m,\n\t\tvoid * __user *dstptr, compat_uint_t *size)\n{\n\treturn xt_compat_match_to_user(m, dstptr, size);\n}", "target": 2, "idx": 9754}
{"commit_id": "643a16a0eb1d6ac23744bb6e90a00fc21148a9dc", "project": "torvalds/linux", "func": "int gru_check_context_placement(struct gru_thread_state *gts)\n{\n\tstruct gru_state *gru;\n\tint ret = 0;\n\n\t/*\n\t * If the current task is the context owner, verify that the\n\t * context is correctly placed. This test is skipped for non-owner\n\t * references. Pthread apps use non-owner references to the CBRs.\n\t */\n\tgru = gts->ts_gru;\n\t/*\n\t * If gru or gts->ts_tgid_owner isn't initialized properly, return\n\t * success to indicate that the caller does not need to unload the\n\t * gru context.The caller is responsible for their inspection and\n\t * reinitialization if needed.\n\t */\n\tif (!gru || gts->ts_tgid_owner != current->tgid)\n\t\treturn ret;\n\n\tif (!gru_check_chiplet_assignment(gru, gts)) {\n\t\tSTAT(check_context_unload);\n\t\tret = -EINVAL;\n\t} else if (gru_retarget_intr(gts)) {\n\t\tSTAT(check_context_retarget_intr);\n\t}\n\n\treturn ret;\n}", "target": 2, "idx": 9755}
{"commit_id": "a246b4d547708f33ff4d4b9a7a5dbac741dc89d8", "project": "torvalds/linux", "func": "static int sd_isoc_init(struct gspca_dev *gspca_dev)\n{\n\tstruct usb_interface_cache *intfc;\n\tstruct usb_host_interface *alt;\n\tint max_packet_size;\n\n\tswitch (gspca_dev->pixfmt.width) {\n\tcase 160:\n\t\tmax_packet_size = 450;\n\t\tbreak;\n\tcase 176:\n\t\tmax_packet_size = 600;\n\t\tbreak;\n\tdefault:\n\t\tmax_packet_size = 1022;\n\t\tbreak;\n\t}\n\n\tintfc = gspca_dev->dev->actconfig->intf_cache[0];\n\n\tif (intfc->num_altsetting < 2)\n\t\treturn -ENODEV;\n\n\talt = &intfc->altsetting[1];\n\n\tif (alt->desc.bNumEndpoints < 1)\n\t\treturn -ENODEV;\n\n\t/* Start isoc bandwidth \"negotiation\" at max isoc bandwidth */\n\talt->endpoint[0].desc.wMaxPacketSize = cpu_to_le16(max_packet_size);\n\n\treturn 0;\n}", "target": 2, "idx": 9756}
{"commit_id": "94fbc54b6c9309912fe3d53e7b63408bbe9a1b0d", "project": "h2o", "func": "void h2o_http2_conn_unregister_stream(h2o_http2_conn_t *conn, h2o_http2_stream_t *stream)\n{\n    h2o_http2_conn_preserve_stream_scheduler(conn, stream);\n\n    khiter_t iter = kh_get(h2o_http2_stream_t, conn->streams, stream->stream_id);\n    assert(iter != kh_end(conn->streams));\n    kh_del(h2o_http2_stream_t, conn->streams, iter);\n\n    if (stream->req_body.state != H2O_HTTP2_REQ_BODY_NONE && stream->req_body.state < H2O_HTTP2_REQ_BODY_CLOSE_DELIVERED) {\n        stream->req.proceed_req = NULL;\n        set_req_body_state(conn, stream, H2O_HTTP2_REQ_BODY_CLOSE_DELIVERED);\n    }\n\n    if (stream->blocked_by_server)\n        h2o_http2_stream_set_blocked_by_server(conn, stream, 0);\n\n    /* Decrement reset_budget if the stream was reset by peer, otherwise increment. By doing so, we penalize connections that\n     * generate resets for >50% of requests. */\n    if (stream->reset_by_peer) {\n        if (conn->dos_mitigation.reset_budget > 0)\n            --conn->dos_mitigation.reset_budget;\n    } else {\n        if (conn->dos_mitigation.reset_budget < conn->super.ctx->globalconf->http2.max_concurrent_requests_per_connection)\n            ++conn->dos_mitigation.reset_budget;\n    }\n\n    switch (stream->state) {\n    case H2O_HTTP2_STREAM_STATE_RECV_BODY:\n        if (h2o_linklist_is_linked(&stream->_link))\n            h2o_linklist_unlink(&stream->_link);\n    /* fallthru */\n    case H2O_HTTP2_STREAM_STATE_IDLE:\n    case H2O_HTTP2_STREAM_STATE_RECV_HEADERS:\n        assert(!h2o_linklist_is_linked(&stream->_link));\n        break;\n    case H2O_HTTP2_STREAM_STATE_REQ_PENDING:\n        assert(h2o_linklist_is_linked(&stream->_link));\n        h2o_linklist_unlink(&stream->_link);\n        break;\n    case H2O_HTTP2_STREAM_STATE_SEND_HEADERS:\n    case H2O_HTTP2_STREAM_STATE_SEND_BODY:\n    case H2O_HTTP2_STREAM_STATE_SEND_BODY_IS_FINAL:\n    case H2O_HTTP2_STREAM_STATE_END_STREAM:\n        if (h2o_linklist_is_linked(&stream->_link))\n            h2o_linklist_unlink(&stream->_link);\n        break;\n    }\n    if (stream->state != H2O_HTTP2_STREAM_STATE_END_STREAM)\n        h2o_http2_stream_set_state(conn, stream, H2O_HTTP2_STREAM_STATE_END_STREAM);\n\n    if (conn->state < H2O_HTTP2_CONN_STATE_IS_CLOSING) {\n        run_pending_requests(conn);\n        update_idle_timeout(conn);\n    }\n}", "target": 2, "idx": 9757}
{"commit_id": "5e3cc1ee1405a7eb3487ed24f786dec01b4cbe1f", "project": "torvalds/linux", "func": "int v9fs_refresh_inode_dotl(struct p9_fid *fid, struct inode *inode)\n{\n\tstruct p9_stat_dotl *st;\n\tstruct v9fs_session_info *v9ses;\n\tunsigned int flags;\n\n\tv9ses = v9fs_inode2v9ses(inode);\n\tst = p9_client_getattr_dotl(fid, P9_STATS_ALL);\n\tif (IS_ERR(st))\n\t\treturn PTR_ERR(st);\n\t/*\n\t * Don't update inode if the file type is different\n\t */\n\tif ((inode->i_mode & S_IFMT) != (st->st_mode & S_IFMT))\n\t\tgoto out;\n\n\t/*\n\t * We don't want to refresh inode->i_size,\n\t * because we may have cached data\n\t */\n\tflags = (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) ?\n\t\tV9FS_STAT2INODE_KEEP_ISIZE : 0;\n\tv9fs_stat2inode_dotl(st, inode, flags);\nout:\n\tkfree(st);\n\treturn 0;\n}", "target": 2, "idx": 9758}
{"commit_id": "caa4b35b4317d5147b3ab0fbdc9c075c7d2e9c12", "project": "torvalds/linux", "func": "static struct cbq_class *\ncbq_classify(struct sk_buff *skb, struct Qdisc *sch, int *qerr)\n{\n\tstruct cbq_sched_data *q = qdisc_priv(sch);\n\tstruct cbq_class *head = &q->link;\n\tstruct cbq_class **defmap;\n\tstruct cbq_class *cl = NULL;\n\tu32 prio = skb->priority;\n\tstruct tcf_proto *fl;\n\tstruct tcf_result res;\n\n\t/*\n\t *  Step 1. If skb->priority points to one of our classes, use it.\n\t */\n\tif (TC_H_MAJ(prio ^ sch->handle) == 0 &&\n\t    (cl = cbq_class_lookup(q, prio)) != NULL)\n\t\treturn cl;\n\n\t*qerr = NET_XMIT_SUCCESS | __NET_XMIT_BYPASS;\n\tfor (;;) {\n\t\tint result = 0;\n\t\tdefmap = head->defaults;\n\n\t\tfl = rcu_dereference_bh(head->filter_list);\n\t\t/*\n\t\t * Step 2+n. Apply classifier.\n\t\t */\n\t\tresult = tcf_classify(skb, NULL, fl, &res, true);\n\t\tif (!fl || result < 0)\n\t\t\tgoto fallback;\n\t\tif (result == TC_ACT_SHOT)\n\t\t\treturn NULL;\n\n\t\tcl = (void *)res.class;\n\t\tif (!cl) {\n\t\t\tif (TC_H_MAJ(res.classid))\n\t\t\t\tcl = cbq_class_lookup(q, res.classid);\n\t\t\telse if ((cl = defmap[res.classid & TC_PRIO_MAX]) == NULL)\n\t\t\t\tcl = defmap[TC_PRIO_BESTEFFORT];\n\n\t\t\tif (cl == NULL)\n\t\t\t\tgoto fallback;\n\t\t}\n\t\tif (cl->level >= head->level)\n\t\t\tgoto fallback;\n#ifdef CONFIG_NET_CLS_ACT\n\t\tswitch (result) {\n\t\tcase TC_ACT_QUEUED:\n\t\tcase TC_ACT_STOLEN:\n\t\tcase TC_ACT_TRAP:\n\t\t\t*qerr = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;\n\t\t\tfallthrough;\n\t\tcase TC_ACT_RECLASSIFY:\n\t\t\treturn cbq_reclassify(skb, cl);\n\t\t}\n#endif\n\t\tif (cl->level == 0)\n\t\t\treturn cl;\n\n\t\t/*\n\t\t * Step 3+n. If classifier selected a link sharing class,\n\t\t *\t   apply agency specific classifier.\n\t\t *\t   Repeat this procedure until we hit a leaf node.\n\t\t */\n\t\thead = cl;\n\t}\n\nfallback:\n\tcl = head;\n\n\t/*\n\t * Step 4. No success...\n\t */\n\tif (TC_H_MAJ(prio) == 0 &&\n\t    !(cl = head->defaults[prio & TC_PRIO_MAX]) &&\n\t    !(cl = head->defaults[TC_PRIO_BESTEFFORT]))\n\t\treturn head;\n\n\treturn cl;\n}", "target": 1, "idx": 9759}
{"commit_id": "3e21bc8a58b4ae38d24c7e283837cc279f35b6a5", "project": "ImageMagick/ImageMagick6", "func": "static MagickRealType ApplyEvaluateOperator(RandomInfo *random_info,\n  const Quantum pixel,const MagickEvaluateOperator op,\n  const MagickRealType value)\n{\n  MagickRealType\n    result;\n\n  result=0.0;\n  switch (op)\n  {\n    case UndefinedEvaluateOperator:\n      break;\n    case AbsEvaluateOperator:\n    {\n      result=(MagickRealType) fabs((double) (pixel+value));\n      break;\n    }\n    case AddEvaluateOperator:\n    {\n      result=(MagickRealType) (pixel+value);\n      break;\n    }\n    case AddModulusEvaluateOperator:\n    {\n      /*\n        This returns a 'floored modulus' of the addition which is a\n        positive result.  It differs from  % or fmod() which returns a\n        'truncated modulus' result, where floor() is replaced by trunc()\n        and could return a negative result (which is clipped).\n      */\n      result=pixel+value;\n      result-=(QuantumRange+1.0)*floor((double) result/(QuantumRange+1.0));\n      break;\n    }\n    case AndEvaluateOperator:\n    {\n      result=(MagickRealType) ((ssize_t) pixel & (ssize_t) (value+0.5));\n      break;\n    }\n    case CosineEvaluateOperator:\n    {\n      result=(MagickRealType) (QuantumRange*(0.5*cos((double) (2.0*MagickPI*\n        QuantumScale*pixel*value))+0.5));\n      break;\n    }\n    case DivideEvaluateOperator:\n    {\n      result=pixel/(value == 0.0 ? 1.0 : value);\n      break;\n    }\n    case ExponentialEvaluateOperator:\n    {\n      result=(MagickRealType) (QuantumRange*exp((double) (value*QuantumScale*\n        pixel)));\n      break;\n    }\n    case GaussianNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        GaussianNoise,value);\n      break;\n    }\n    case ImpulseNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        ImpulseNoise,value);\n      break;\n    }\n    case LaplacianNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        LaplacianNoise,value);\n      break;\n    }\n    case LeftShiftEvaluateOperator:\n    {\n      result=(MagickRealType) ((ssize_t) pixel << (ssize_t) (value+0.5));\n      break;\n    }\n    case LogEvaluateOperator:\n    {\n      if ((QuantumScale*pixel) >= MagickEpsilon)\n        result=(MagickRealType) (QuantumRange*log((double) (QuantumScale*value*\n          pixel+1.0))/log((double) (value+1.0)));\n      break;\n    }\n    case MaxEvaluateOperator:\n    {\n      result=(MagickRealType) EvaluateMax((double) pixel,value);\n      break;\n    }\n    case MeanEvaluateOperator:\n    {\n      result=(MagickRealType) (pixel+value);\n      break;\n    }\n    case MedianEvaluateOperator:\n    {\n      result=(MagickRealType) (pixel+value);\n      break;\n    }\n    case MinEvaluateOperator:\n    {\n      result=(MagickRealType) MagickMin((double) pixel,value);\n      break;\n    }\n    case MultiplicativeNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        MultiplicativeGaussianNoise,value);\n      break;\n    }\n    case MultiplyEvaluateOperator:\n    {\n      result=(MagickRealType) (value*pixel);\n      break;\n    }\n    case OrEvaluateOperator:\n    {\n      result=(MagickRealType) ((ssize_t) pixel | (ssize_t) (value+0.5));\n      break;\n    }\n    case PoissonNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        PoissonNoise,value);\n      break;\n    }\n    case PowEvaluateOperator:\n    {\n      result=(MagickRealType) (QuantumRange*pow((double) (QuantumScale*pixel),\n        (double) value));\n      break;\n    }\n    case RightShiftEvaluateOperator:\n    {\n      result=(MagickRealType) ((ssize_t) pixel >> (ssize_t) (value+0.5));\n      break;\n    }\n    case RootMeanSquareEvaluateOperator:\n    {\n      result=(MagickRealType) (pixel*pixel+value);\n      break;\n    }\n    case SetEvaluateOperator:\n    {\n      result=value;\n      break;\n    }\n    case SineEvaluateOperator:\n    {\n      result=(MagickRealType) (QuantumRange*(0.5*sin((double) (2.0*MagickPI*\n        QuantumScale*pixel*value))+0.5));\n      break;\n    }\n    case SubtractEvaluateOperator:\n    {\n      result=(MagickRealType) (pixel-value);\n      break;\n    }\n    case SumEvaluateOperator:\n    {\n      result=(MagickRealType) (pixel+value);\n      break;\n    }\n    case ThresholdEvaluateOperator:\n    {\n      result=(MagickRealType) (((MagickRealType) pixel <= value) ? 0 :\n        QuantumRange);\n      break;\n    }\n    case ThresholdBlackEvaluateOperator:\n    {\n      result=(MagickRealType) (((MagickRealType) pixel <= value) ? 0 : pixel);\n      break;\n    }\n    case ThresholdWhiteEvaluateOperator:\n    {\n      result=(MagickRealType) (((MagickRealType) pixel > value) ? QuantumRange :\n        pixel);\n      break;\n    }\n    case UniformNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        UniformNoise,value);\n      break;\n    }\n    case XorEvaluateOperator:\n    {\n      result=(MagickRealType) ((ssize_t) pixel ^ (ssize_t) (value+0.5));\n      break;\n    }\n  }\n  return(result);\n}", "target": 0, "idx": 9760}
{"commit_id": "224e6bc13fa353dd3b7f7a2334588f1c4229e58d", "project": "radareorg/radare2", "func": "static int java_switch_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {\n\tut8 op_byte = data[0];\n\tut64 offset = addr - java_get_method_start ();\n\tut8 pos = (offset+1)%4 ? 1 + 4 - (offset+1)%4 : 1;\n\n\tif (op_byte == 0xaa) {\n\t\t// handle a table switch condition\n\t\tif (pos + 8 + 8 > len) {\n\t\t\treturn op->size;\n\t\t}\n\t\tconst int min_val = (ut32)(UINT (data, pos + 4));\n\t\tconst int max_val = (ut32)(UINT (data, pos + 8));\n\n\t\tut32 default_loc = (ut32) (UINT (data, pos)), cur_case = 0;\n\t\top->switch_op = r_anal_switch_op_new (addr, min_val, default_loc);\n\t\tRAnalCaseOp *caseop = NULL;\n\t\tpos += 12;\n\t\tif (max_val > min_val && ((max_val - min_val)<(UT16_MAX/4))) {\n\t\t\t//caseop = r_anal_switch_op_add_case(op->switch_op, addr+default_loc, -1, addr+offset);\n\t\t\tfor (cur_case = 0; cur_case <= max_val - min_val; pos += 4, cur_case++) {\n\t\t\t\t//ut32 value = (ut32)(UINT (data, pos));\n\t\t\t\tif (pos + 4 >= len) {\n\t\t\t\t\t// switch is too big cant read further\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint offset = (int)(ut32)(R_BIN_JAVA_UINT (data, pos));\n\t\t\t\tcaseop = r_anal_switch_op_add_case (op->switch_op,\n\t\t\t\t\taddr + pos, cur_case + min_val, addr + offset);\n\t\t\t\tif (caseop) {\n\t\t\t\t\tcaseop->bb_ref_to = addr+offset;\n\t\t\t\t\tcaseop->bb_ref_from = addr; // TODO figure this one out\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Invalid switch boundaries at 0x%\"PFMT64x\"\\n\", addr);\n\t\t}\n\t}\n\top->size = pos;\n\treturn op->size;\n}", "target": 2, "idx": 9761}
{"commit_id": "fc82b0a2dfe7dbd35671c10510a8da1043d746a5", "project": "glibc", "func": "enum nss_status\n_nss_dns_gethostbyname4_r (const char *name, struct gaih_addrtuple **pat,\n\t\t\t   char *buffer, size_t buflen, int *errnop,\n\t\t\t   int *herrnop, int32_t *ttlp)\n{\n  if (__res_maybe_init (&_res, 0) == -1)\n    return NSS_STATUS_UNAVAIL;\n\n  /*\n   * if there aren't any dots, it could be a user-level alias.\n   * this is also done in res_query() since we are not the only\n   * function that looks up host names.\n   */\n  if (strchr (name, '.') == NULL)\n    {\n      char *tmp = alloca (NS_MAXDNAME);\n      const char *cp = res_hostalias (&_res, name, tmp, NS_MAXDNAME);\n      if (cp != NULL)\n\tname = cp;\n    }\n\n  union\n  {\n    querybuf *buf;\n    u_char *ptr;\n  } host_buffer;\n  querybuf *orig_host_buffer;\n  host_buffer.buf = orig_host_buffer = (querybuf *) alloca (2048);\n  u_char *ans2p = NULL;\n  int nans2p = 0;\n  int resplen2 = 0;\n  int ans2p_malloced = 0;\n\n  int olderr = errno;\n  enum nss_status status;\n  int n = __libc_res_nsearch (&_res, name, C_IN, T_QUERY_A_AND_AAAA,\n\t\t\t      host_buffer.buf->buf, 2048, &host_buffer.ptr,\n\t\t\t      &ans2p, &nans2p, &resplen2, &ans2p_malloced);\n  if (n >= 0)\n    {\n      status = gaih_getanswer (host_buffer.buf, n, (const querybuf *) ans2p,\n\t\t\t       resplen2, name, pat, buffer, buflen,\n\t\t\t       errnop, herrnop, ttlp);\n    }\n  else\n    {\n      switch (errno)\n\t{\n\tcase ESRCH:\n\t  status = NSS_STATUS_TRYAGAIN;\n\t  h_errno = TRY_AGAIN;\n\t  break;\n\t/* System has run out of file descriptors.  */\n\tcase EMFILE:\n\tcase ENFILE:\n\t  h_errno = NETDB_INTERNAL;\n\t  /* Fall through.  */\n\tcase ECONNREFUSED:\n\tcase ETIMEDOUT:\n\t  status = NSS_STATUS_UNAVAIL;\n\t  break;\n\tdefault:\n\t  status = NSS_STATUS_NOTFOUND;\n\t  break;\n\t}\n\n      *herrnop = h_errno;\n      if (h_errno == TRY_AGAIN)\n\t*errnop = EAGAIN;\n      else\n\t__set_errno (olderr);\n    }\n\n  /* Check whether ans2p was separately allocated.  */\n  if (ans2p_malloced)\n    free (ans2p);\n\n  if (host_buffer.buf != orig_host_buffer)\n    free (host_buffer.buf);\n\n  return status;\n}", "target": 2, "idx": 9762}
{"commit_id": "e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d", "project": "jasper-software/jasper", "func": "static int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_cmap_t *cmap = &box->data.cmap;\n\tjp2_cmapent_t *ent;\n\tunsigned int i;\n\tcmap->ents = 0;\n\n\tcmap->numchans = (box->datalen) / 4;\n\tif (!(cmap->ents = jas_alloc2(cmap->numchans, sizeof(jp2_cmapent_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < cmap->numchans; ++i) {\n\t\tent = &cmap->ents[i];\n\t\tif (jp2_getuint16(in, &ent->cmptno) ||\n\t\t  jp2_getuint8(in, &ent->map) ||\n\t\t  jp2_getuint8(in, &ent->pcol)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\t\n\treturn 0;\n}", "target": 1, "idx": 9763}
{"commit_id": "bc0bdc5afaa740d782fbf936aaeebd65e5c2921d", "project": "torvalds/linux", "func": "int rdma_listen(struct rdma_cm_id *id, int backlog)\n{\n\tstruct rdma_id_private *id_priv =\n\t\tcontainer_of(id, struct rdma_id_private, id);\n\tint ret;\n\n\tif (!cma_comp_exch(id_priv, RDMA_CM_ADDR_BOUND, RDMA_CM_LISTEN)) {\n\t\tstruct sockaddr_in any_in = {\n\t\t\t.sin_family = AF_INET,\n\t\t\t.sin_addr.s_addr = htonl(INADDR_ANY),\n\t\t};\n\n\t\t/* For a well behaved ULP state will be RDMA_CM_IDLE */\n\t\tret = rdma_bind_addr(id, (struct sockaddr *)&any_in);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (WARN_ON(!cma_comp_exch(id_priv, RDMA_CM_ADDR_BOUND,\n\t\t\t\t\t   RDMA_CM_LISTEN)))\n\t\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Once the ID reaches RDMA_CM_LISTEN it is not allowed to be reusable\n\t * any more, and has to be unique in the bind list.\n\t */\n\tif (id_priv->reuseaddr) {\n\t\tmutex_lock(&lock);\n\t\tret = cma_check_port(id_priv->bind_list, id_priv, 0);\n\t\tif (!ret)\n\t\t\tid_priv->reuseaddr = 0;\n\t\tmutex_unlock(&lock);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tid_priv->backlog = backlog;\n\tif (id_priv->cma_dev) {\n\t\tif (rdma_cap_ib_cm(id->device, 1)) {\n\t\t\tret = cma_ib_listen(id_priv);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t} else if (rdma_cap_iw_cm(id->device, 1)) {\n\t\t\tret = cma_iw_listen(id_priv, backlog);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t} else {\n\t\t\tret = -ENOSYS;\n\t\t\tgoto err;\n\t\t}\n\t} else {\n\t\tret = cma_listen_on_all(id_priv);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tid_priv->backlog = 0;\n\t/*\n\t * All the failure paths that lead here will not allow the req_handler's\n\t * to have run.\n\t */\n\tcma_comp_exch(id_priv, RDMA_CM_LISTEN, RDMA_CM_ADDR_BOUND);\n\treturn ret;\n}", "target": 2, "idx": 9764}
{"commit_id": "ce87eac0325581b600b3093fcd75080df14ccfda", "project": "wireshark", "func": "static int\ndissect_xra_tlv_burst_info(tvbuff_t * tvb, proto_tree * tree, void* data _U_, guint16 tlv_length) {\n  proto_item *it;\n  proto_tree *xra_tlv_burst_info_tree;\n\n  it = proto_tree_add_item (tree, hf_xra_tlv_burst_info, tvb, 0, tlv_length, ENC_NA);\n  xra_tlv_burst_info_tree = proto_item_add_subtree (it, ett_xra_tlv_burst_info);\n\n  unsigned tlv_index = 0;\n  while (tlv_index < tlv_length) {\n    guint8 type = tvb_get_guint8 (tvb, tlv_index);\n    ++tlv_index;\n    guint8 length = tvb_get_guint8 (tvb, tlv_index);\n    ++tlv_index;\n    switch (type) {\n      case XRA_BURST_INFO_BURST_ID_REFERENCE:\n        proto_tree_add_item (xra_tlv_burst_info_tree, hf_xra_tlv_burst_info_burst_id_reference, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_US_CHANNEL_ID:\n        proto_tree_add_item (xra_tlv_burst_info_tree, hf_xra_tlv_us_channel_id, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_SID:\n        proto_tree_add_item (xra_tlv_burst_info_tree, hf_xra_tlv_sid, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_IUC:\n        proto_tree_add_item (xra_tlv_burst_info_tree, hf_xra_tlv_iuc, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n\n      default:\n        proto_tree_add_item (xra_tlv_burst_info_tree, hf_xra_unknown, tvb, tlv_index, length, ENC_NA);\n        break;\n    }\n    tlv_index+=length;\n  }\n\n  return tvb_captured_length(tvb);\n}", "target": 1, "idx": 9765}
{"commit_id": "b3679121bb3c7017ff04b4c08402ffff5cf59b13", "project": "facebook/hhvm", "func": "bool handleBackslash(signed char& out) {\n    char ch = *p++;\n    switch (ch) {\n      case 0: return false;\n      case '\"': out = ch; return true;\n      case '\\\\': out = ch; return true;\n      case '/': out = ch; return true;\n      case 'b': out = '\\b'; return true;\n      case 'f': out = '\\f'; return true;\n      case 'n': out = '\\n'; return true;\n      case 'r': out = '\\r'; return true;\n      case 't': out = '\\t'; return true;\n      case 'u': {\n        if (UNLIKELY(is_tsimplejson)) {\n          auto const ch1 = *p++;\n          if (UNLIKELY(ch1 != '0')) return false;\n          auto const ch2 = *p++;\n          if (UNLIKELY(ch2 != '0')) return false;\n          auto const dch3 = dehexchar(*p++);\n          if (UNLIKELY(dch3 < 0)) return false;\n          auto const dch4 = dehexchar(*p++);\n          if (UNLIKELY(dch4 < 0)) return false;\n          out = (dch3 << 4) | dch4;\n          return true;\n        } else {\n          uint16_t u16cp = 0;\n          for (int i = 0; i < 4; i++) {\n            auto const hexv = dehexchar(*p++);\n            if (hexv < 0) return false; // includes check for end of string\n            u16cp <<= 4;\n            u16cp |= hexv;\n          }\n          if (u16cp > 0x7f) {\n            return false;\n          } else {\n            out = u16cp;\n            return true;\n          }\n        }\n      }\n      default: return false;\n    }\n  }", "target": 2, "idx": 9766}
{"commit_id": "b0b104adae26de607db43f346a7c450ef0c6af9a", "project": "cifsd-team/ksmbd", "func": "static int krb5_authenticate(struct ksmbd_work *work)\n{\n\tstruct smb2_sess_setup_req *req = work->request_buf;\n\tstruct smb2_sess_setup_rsp *rsp = work->response_buf;\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct ksmbd_session *sess = work->sess;\n\tchar *in_blob, *out_blob;\n\tstruct channel *chann = NULL;\n\tu64 prev_sess_id;\n\tint in_len, out_len;\n\tint retval;\n\n\tin_blob = (char *)&req->hdr.ProtocolId +\n\t\tle16_to_cpu(req->SecurityBufferOffset);\n\tin_len = le16_to_cpu(req->SecurityBufferLength);\n\tout_blob = (char *)&rsp->hdr.ProtocolId +\n\t\tle16_to_cpu(rsp->SecurityBufferOffset);\n\tout_len = work->response_sz -\n\t\toffsetof(struct smb2_hdr, smb2_buf_length) -\n\t\tle16_to_cpu(rsp->SecurityBufferOffset);\n\n\t/* Check previous session */\n\tprev_sess_id = le64_to_cpu(req->PreviousSessionId);\n\tif (prev_sess_id && prev_sess_id != sess->id)\n\t\tdestroy_previous_session(sess->user, prev_sess_id);\n\n\tif (sess->state == SMB2_SESSION_VALID)\n\t\tksmbd_free_user(sess->user);\n\n\tretval = ksmbd_krb5_authenticate(sess, in_blob, in_len,\n\t\t\t\t\t out_blob, &out_len);\n\tif (retval) {\n\t\tksmbd_debug(SMB, \"krb5 authentication failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\trsp->SecurityBufferLength = cpu_to_le16(out_len);\n\tinc_rfc1001_len(rsp, out_len - 1);\n\n\tif ((conn->sign || server_conf.enforced_signing) ||\n\t    (req->SecurityMode & SMB2_NEGOTIATE_SIGNING_REQUIRED))\n\t\tsess->sign = true;\n\n\tif (should_encrypt(conn)) {\n\t\tretval = conn->ops->generate_encryptionkey(sess);\n\t\tif (retval) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"SMB3 encryption key generation failed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsess->enc = true;\n\t\trsp->SessionFlags = SMB2_SESSION_FLAG_ENCRYPT_DATA_LE;\n\t\tsess->sign = false;\n\t}\n\n\tif (conn->dialect >= SMB30_PROT_ID) {\n\t\tchann = lookup_chann_list(sess, conn);\n\t\tif (!chann) {\n\t\t\tchann = kmalloc(sizeof(struct channel), GFP_KERNEL);\n\t\t\tif (!chann)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tchann->conn = conn;\n\t\t\tINIT_LIST_HEAD(&chann->chann_list);\n\t\t\tlist_add(&chann->chann_list, &sess->ksmbd_chann_list);\n\t\t}\n\t}\n\n\tif (conn->ops->generate_signingkey) {\n\t\tretval = conn->ops->generate_signingkey(sess, conn);\n\t\tif (retval) {\n\t\t\tksmbd_debug(SMB, \"SMB3 signing key generation failed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (conn->dialect > SMB20_PROT_ID) {\n\t\tif (!ksmbd_conn_lookup_dialect(conn)) {\n\t\t\tpr_err(\"fail to verify the dialect\\n\");\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 2, "idx": 9767}
{"commit_id": "15edc8d714b11dcff3a04e5d00b8db9adfdb81ed", "project": "wireshark", "func": "static guint8\nelem_dtmf_chars(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, guint32 offset, guint len, ansi_a_shared_data_t *data_p)\n{\n    guint8      oct;\n    guint32     curr_offset;\n    guint8      packed_len;\n    char       *str;\n\n    curr_offset = offset;\n\n    proto_tree_add_item(tree, hf_ansi_a_bdtmf_chars_num_chars, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\n    oct = tvb_get_guint8(tvb, curr_offset);\n    curr_offset++;\n\n    if (curr_offset - offset >= len) /* Sanity check */\n        return (curr_offset - offset);\n\n    packed_len = len - (curr_offset - offset);\n    str = (char*)tvb_bcd_dig_to_wmem_packet_str(tvb, curr_offset, packed_len, &Dgt_dtmf, FALSE);\n   /*\n     * the packed DTMF digits are not \"terminated\" with a '0xF' for an odd\n     * number of digits but the unpack routine expects it\n     */\n    if (oct & 0x01)\n    {\n        str[(2*packed_len)-1] = '\\0';\n    }\n\n    proto_tree_add_string(tree, hf_ansi_a_bdtmf_chars_digits, tvb, curr_offset, packed_len, str);\n    proto_item_append_text(data_p->elem_item, \" - (%s)\", str);\n\n    curr_offset += packed_len;\n\n    EXTRANEOUS_DATA_CHECK(len, curr_offset - offset);\n\n    return(curr_offset - offset);\n}", "target": 1, "idx": 9768}
{"commit_id": "74e19d451cfa4397b58745a1efcfce81d2eb6426", "project": "RIOT-OS/RIOT", "func": "void emcute_run(uint16_t port, const char *id)\n{\n    assert(strlen(id) >= MQTTSN_CLI_ID_MINLEN &&\n           strlen(id) <= MQTTSN_CLI_ID_MAXLEN);\n\n    sock_udp_ep_t local = SOCK_IPV6_EP_ANY;\n    sock_udp_ep_t remote;\n    local.port = port;\n    cli_id = id;\n    timer.callback = time_evt;\n    timer.arg = NULL;\n    mutex_init(&txlock);\n\n    if (sock_udp_create(&sock, &local, NULL, 0) < 0) {\n        LOG_ERROR(\"[emcute] unable to open UDP socket on port %i\\n\", (int)port);\n        return;\n    }\n\n    uint32_t start = xtimer_now_usec();\n    uint32_t t_out = (EMCUTE_KEEPALIVE * US_PER_SEC);\n\n    while (1) {\n        ssize_t len = sock_udp_recv(&sock, rbuf, sizeof(rbuf), t_out, &remote);\n\n        if ((len < 0) && (len != -ETIMEDOUT)) {\n            LOG_ERROR(\"[emcute] error while receiving UDP packet\\n\");\n            continue;\n        }\n\n        if (len >= 2) {\n            /* handle the packet */\n            uint16_t pkt_len;\n            /* catch invalid length field */\n            if ((len == 2) && (rbuf[0] == 0x01)) {\n                continue;\n            }\n            /* parse length field */\n            size_t pos = get_len(rbuf, &pkt_len);\n            /* verify length to prevent overflows */\n            if (((size_t)pkt_len > (size_t)len) || (pos >= (size_t)len)) {\n                continue;\n            }\n            /* get packet type */\n            uint8_t type = rbuf[pos];\n\n            switch (type) {\n                case CONNACK:       on_ack(type, 0, 2, 0);              break;\n                case WILLTOPICREQ:  on_ack(type, 0, 0, 0);              break;\n                case WILLMSGREQ:    on_ack(type, 0, 0, 0);              break;\n                case REGACK:        on_ack(type, 4, 6, 2);              break;\n                case PUBLISH:       on_publish((size_t)pkt_len, pos);   break;\n                case PUBACK:        on_ack(type, 4, 6, 0);              break;\n                case SUBACK:        on_ack(type, 5, 7, 3);              break;\n                case UNSUBACK:      on_ack(type, 2, 0, 0);              break;\n                case PINGREQ:       on_pingreq(&remote);                break;\n                case PINGRESP:      on_pingresp();                      break;\n                case DISCONNECT:    on_disconnect();                    break;\n                case WILLTOPICRESP: on_ack(type, 0, 0, 0);              break;\n                case WILLMSGRESP:   on_ack(type, 0, 0, 0);              break;\n                default:\n                    LOG_DEBUG(\"[emcute] received unexpected type [%s]\\n\",\n                              emcute_type_str(type));\n            }\n        }\n\n        uint32_t now = xtimer_now_usec();\n        if ((now - start) >= (EMCUTE_KEEPALIVE * US_PER_SEC)) {\n            send_ping();\n            start = now;\n            t_out = (EMCUTE_KEEPALIVE * US_PER_SEC);\n        }\n        else {\n            t_out = (EMCUTE_KEEPALIVE * US_PER_SEC) - (now - start);\n        }\n    }\n}", "target": 2, "idx": 9769}
{"commit_id": "2cb40c4d5feeaa09325522bd7d97910f1b59e379", "project": "polkit", "func": "PolkitIdentity *\npolkit_unix_group_new (gint gid)\n{\n  g_return_val_if_fail (gid != -1, NULL);\n\n  return POLKIT_IDENTITY (g_object_new (POLKIT_TYPE_UNIX_GROUP,\n                                       \"gid\", gid,\n                                       NULL));\n}", "target": 2, "idx": 9770}
{"commit_id": "3c5eb8b1be544e41d2c336191bc4936300ad7543", "project": "vadz/libtiff", "func": "void*\n_TIFFmalloc(tmsize_t s)\n{\n        if (s == 0)\n                return ((void *) NULL);\n\n\treturn (malloc((size_t) s));\n}", "target": 1, "idx": 9771}
{"commit_id": "d6f9d33a7db0b346195b6a15b5b99944ba41beee", "project": "FreeRDP", "func": "BOOL planar_decompress(BITMAP_PLANAR_CONTEXT* planar, const BYTE* pSrcData, UINT32 SrcSize,\n                       UINT32 nSrcWidth, UINT32 nSrcHeight, BYTE* pDstData, UINT32 DstFormat,\n                       UINT32 nDstStep, UINT32 nXDst, UINT32 nYDst, UINT32 nDstWidth,\n                       UINT32 nDstHeight, BOOL vFlip)\n{\n\tBOOL cs;\n\tBOOL rle;\n\tUINT32 cll;\n\tBOOL alpha;\n\tBOOL useAlpha = FALSE;\n\tINT32 status;\n\tconst BYTE* srcp;\n\tUINT32 subSize;\n\tUINT32 subWidth;\n\tUINT32 subHeight;\n\tUINT32 planeSize;\n\tINT32 rleSizes[4] = { 0, 0, 0, 0 };\n\tUINT32 rawSizes[4];\n\tUINT32 rawWidths[4];\n\tUINT32 rawHeights[4];\n\tBYTE FormatHeader;\n\tconst BYTE* planes[4] = { 0 };\n\tconst UINT32 w = MIN(nSrcWidth, nDstWidth);\n\tconst UINT32 h = MIN(nSrcHeight, nDstHeight);\n\tconst primitives_t* prims = primitives_get();\n\n\tWINPR_ASSERT(planar);\n\tWINPR_ASSERT(prims);\n\n\tif (nDstStep <= 0)\n\t\tnDstStep = nDstWidth * FreeRDPGetBytesPerPixel(DstFormat);\n\n\tsrcp = pSrcData;\n\n\tif (!pSrcData)\n\t{\n\t\tWLog_ERR(TAG, \"Invalid argument pSrcData=NULL\");\n\t\treturn FALSE;\n\t}\n\n\tif (!pDstData)\n\t{\n\t\tWLog_ERR(TAG, \"Invalid argument pDstData=NULL\");\n\t\treturn FALSE;\n\t}\n\n\tFormatHeader = *srcp++;\n\tcll = (FormatHeader & PLANAR_FORMAT_HEADER_CLL_MASK);\n\tcs = (FormatHeader & PLANAR_FORMAT_HEADER_CS) ? TRUE : FALSE;\n\trle = (FormatHeader & PLANAR_FORMAT_HEADER_RLE) ? TRUE : FALSE;\n\talpha = (FormatHeader & PLANAR_FORMAT_HEADER_NA) ? FALSE : TRUE;\n\n\tDstFormat = planar_invert_format(planar, alpha, DstFormat);\n\n\tif (alpha)\n\t\tuseAlpha = FreeRDPColorHasAlpha(DstFormat);\n\n\t// WLog_INFO(TAG, \"CLL: %\"PRIu32\" CS: %\"PRIu8\" RLE: %\"PRIu8\" ALPHA: %\"PRIu8\"\", cll, cs, rle,\n\t// alpha);\n\n\tif (!cll && cs)\n\t{\n\t\tWLog_ERR(TAG, \"Chroma subsampling requires YCoCg and does not work with RGB data\");\n\t\treturn FALSE; /* Chroma subsampling requires YCoCg */\n\t}\n\n\tsubWidth = (nSrcWidth / 2) + (nSrcWidth % 2);\n\tsubHeight = (nSrcHeight / 2) + (nSrcHeight % 2);\n\tplaneSize = nSrcWidth * nSrcHeight;\n\tsubSize = subWidth * subHeight;\n\n\tif (!cs)\n\t{\n\t\trawSizes[0] = planeSize; /* LumaOrRedPlane */\n\t\trawWidths[0] = nSrcWidth;\n\t\trawHeights[0] = nSrcHeight;\n\t\trawSizes[1] = planeSize; /* OrangeChromaOrGreenPlane */\n\t\trawWidths[1] = nSrcWidth;\n\t\trawHeights[1] = nSrcHeight;\n\t\trawSizes[2] = planeSize; /* GreenChromaOrBluePlane */\n\t\trawWidths[2] = nSrcWidth;\n\t\trawHeights[2] = nSrcHeight;\n\t\trawSizes[3] = planeSize; /* AlphaPlane */\n\t\trawWidths[3] = nSrcWidth;\n\t\trawHeights[3] = nSrcHeight;\n\t}\n\telse /* Chroma Subsampling */\n\t{\n\t\trawSizes[0] = planeSize; /* LumaOrRedPlane */\n\t\trawWidths[0] = nSrcWidth;\n\t\trawHeights[0] = nSrcHeight;\n\t\trawSizes[1] = subSize; /* OrangeChromaOrGreenPlane */\n\t\trawWidths[1] = subWidth;\n\t\trawHeights[1] = subHeight;\n\t\trawSizes[2] = subSize; /* GreenChromaOrBluePlane */\n\t\trawWidths[2] = subWidth;\n\t\trawHeights[2] = subHeight;\n\t\trawSizes[3] = planeSize; /* AlphaPlane */\n\t\trawWidths[3] = nSrcWidth;\n\t\trawHeights[3] = nSrcHeight;\n\t}\n\n\tif (!rle) /* RAW */\n\t{\n\t\tUINT32 base = planeSize * 3;\n\t\tif (cs)\n\t\t\tbase = planeSize + planeSize / 2;\n\n\t\tif (alpha)\n\t\t{\n\t\t\tif ((SrcSize - (srcp - pSrcData)) < (planeSize + base))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Alpha plane size mismatch %\" PRIu32 \" < %\" PRIu32,\n\t\t\t\t         SrcSize - (srcp - pSrcData), (planeSize + base));\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tplanes[3] = srcp;                    /* AlphaPlane */\n\t\t\tplanes[0] = planes[3] + rawSizes[3]; /* LumaOrRedPlane */\n\t\t\tplanes[1] = planes[0] + rawSizes[0]; /* OrangeChromaOrGreenPlane */\n\t\t\tplanes[2] = planes[1] + rawSizes[1]; /* GreenChromaOrBluePlane */\n\n\t\t\tif ((planes[2] + rawSizes[2]) > &pSrcData[SrcSize])\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"plane size mismatch %p + %\" PRIu32 \" > %p\", planes[2], rawSizes[2],\n\t\t\t\t         &pSrcData[SrcSize]);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((SrcSize - (srcp - pSrcData)) < base)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"plane size mismatch %\" PRIu32 \" < %\" PRIu32,\n\t\t\t\t         SrcSize - (srcp - pSrcData), base);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tplanes[0] = srcp;                    /* LumaOrRedPlane */\n\t\t\tplanes[1] = planes[0] + rawSizes[0]; /* OrangeChromaOrGreenPlane */\n\t\t\tplanes[2] = planes[1] + rawSizes[1]; /* GreenChromaOrBluePlane */\n\n\t\t\tif ((planes[2] + rawSizes[2]) > &pSrcData[SrcSize])\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"plane size mismatch %p + %\" PRIu32 \" > %p\", planes[2], rawSizes[2],\n\t\t\t\t         &pSrcData[SrcSize]);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t}\n\telse /* RLE */\n\t{\n\t\tif (alpha)\n\t\t{\n\t\t\tplanes[3] = srcp;\n\t\t\trleSizes[3] = planar_skip_plane_rle(planes[3], SrcSize - (planes[3] - pSrcData),\n\t\t\t                                    rawWidths[3], rawHeights[3]); /* AlphaPlane */\n\n\t\t\tif (rleSizes[3] < 0)\n\t\t\t\treturn FALSE;\n\n\t\t\tplanes[0] = planes[3] + rleSizes[3];\n\t\t}\n\t\telse\n\t\t\tplanes[0] = srcp;\n\n\t\trleSizes[0] = planar_skip_plane_rle(planes[0], SrcSize - (planes[0] - pSrcData),\n\t\t                                    rawWidths[0], rawHeights[0]); /* RedPlane */\n\n\t\tif (rleSizes[0] < 0)\n\t\t\treturn FALSE;\n\n\t\tplanes[1] = planes[0] + rleSizes[0];\n\t\trleSizes[1] = planar_skip_plane_rle(planes[1], SrcSize - (planes[1] - pSrcData),\n\t\t                                    rawWidths[1], rawHeights[1]); /* GreenPlane */\n\n\t\tif (rleSizes[1] < 1)\n\t\t\treturn FALSE;\n\n\t\tplanes[2] = planes[1] + rleSizes[1];\n\t\trleSizes[2] = planar_skip_plane_rle(planes[2], SrcSize - (planes[2] - pSrcData),\n\t\t                                    rawWidths[2], rawHeights[2]); /* BluePlane */\n\n\t\tif (rleSizes[2] < 1)\n\t\t\treturn FALSE;\n\t}\n\n\tif (!cll) /* RGB */\n\t{\n\t\tUINT32 TempFormat;\n\t\tBYTE* pTempData = pDstData;\n\t\tUINT32 nTempStep = nDstStep;\n\t\tUINT32 nTotalHeight = nYDst + nDstHeight;\n\n\t\tif (useAlpha)\n\t\t\tTempFormat = PIXEL_FORMAT_BGRA32;\n\t\telse\n\t\t\tTempFormat = PIXEL_FORMAT_BGRX32;\n\n\t\tTempFormat = planar_invert_format(planar, alpha, TempFormat);\n\n\t\tif ((TempFormat != DstFormat) || (nSrcWidth != nDstWidth) || (nSrcHeight != nDstHeight))\n\t\t{\n\t\t\tpTempData = planar->pTempData;\n\t\t\tnTempStep = planar->nTempStep;\n\t\t\tnTotalHeight = planar->maxHeight;\n\t\t}\n\n\t\tif (!rle) /* RAW */\n\t\t{\n\t\t\tif (!planar_decompress_planes_raw(planes, pTempData, TempFormat, nTempStep, nXDst,\n\t\t\t                                  nYDst, nSrcWidth, nSrcHeight, vFlip, nTotalHeight))\n\t\t\t\treturn FALSE;\n\n\t\t\tif (alpha)\n\t\t\t\tsrcp += rawSizes[0] + rawSizes[1] + rawSizes[2] + rawSizes[3];\n\t\t\telse /* NoAlpha */\n\t\t\t\tsrcp += rawSizes[0] + rawSizes[1] + rawSizes[2];\n\n\t\t\tif ((SrcSize - (srcp - pSrcData)) == 1)\n\t\t\t\tsrcp++; /* pad */\n\t\t}\n\t\telse /* RLE */\n\t\t{\n\t\t\tstatus =\n\t\t\t    planar_decompress_plane_rle(planes[0], rleSizes[0], pTempData, nTempStep, nXDst,\n\t\t\t                                nYDst, nSrcWidth, nSrcHeight, 2, vFlip); /* RedPlane */\n\n\t\t\tif (status < 0)\n\t\t\t\treturn FALSE;\n\n\t\t\tstatus = planar_decompress_plane_rle(planes[1], rleSizes[1], pTempData, nTempStep,\n\t\t\t                                     nXDst, nYDst, nSrcWidth, nSrcHeight, 1,\n\t\t\t                                     vFlip); /* GreenPlane */\n\n\t\t\tif (status < 0)\n\t\t\t\treturn FALSE;\n\n\t\t\tstatus =\n\t\t\t    planar_decompress_plane_rle(planes[2], rleSizes[2], pTempData, nTempStep, nXDst,\n\t\t\t                                nYDst, nSrcWidth, nSrcHeight, 0, vFlip); /* BluePlane */\n\n\t\t\tif (status < 0)\n\t\t\t\treturn FALSE;\n\n\t\t\tsrcp += rleSizes[0] + rleSizes[1] + rleSizes[2];\n\n\t\t\tif (useAlpha)\n\t\t\t{\n\t\t\t\tstatus = planar_decompress_plane_rle(planes[3], rleSizes[3], pTempData, nTempStep,\n\t\t\t\t                                     nXDst, nYDst, nSrcWidth, nSrcHeight, 3,\n\t\t\t\t                                     vFlip); /* AlphaPlane */\n\t\t\t}\n\t\t\telse\n\t\t\t\tstatus = planar_set_plane(0xFF, pTempData, nTempStep, nXDst, nYDst, nSrcWidth,\n\t\t\t\t                          nSrcHeight, 3, vFlip);\n\n\t\t\tif (status < 0)\n\t\t\t\treturn FALSE;\n\n\t\t\tif (alpha)\n\t\t\t\tsrcp += rleSizes[3];\n\t\t}\n\n\t\tif (pTempData != pDstData)\n\t\t{\n\t\t\tif (!freerdp_image_copy(pDstData, DstFormat, nDstStep, nXDst, nYDst, w, h, pTempData,\n\t\t\t                        TempFormat, nTempStep, nXDst, nYDst, NULL, FREERDP_FLIP_NONE))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"planar image copy failed\");\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t}\n\telse /* YCoCg */\n\t{\n\t\tUINT32 TempFormat;\n\t\tBYTE* pTempData = planar->pTempData;\n\t\tUINT32 nTempStep = planar->nTempStep;\n\t\tUINT32 nTotalHeight = planar->maxHeight;\n\t\tBYTE* dst = &pDstData[nXDst * FreeRDPGetBytesPerPixel(DstFormat) + nYDst * nDstStep];\n\n\t\tif (useAlpha)\n\t\t\tTempFormat = PIXEL_FORMAT_BGRA32;\n\t\telse\n\t\t\tTempFormat = PIXEL_FORMAT_BGRX32;\n\n\t\tif (!pTempData)\n\t\t\treturn FALSE;\n\n\t\tif (rle) /* RLE encoded data. Decode and handle it like raw data. */\n\t\t{\n\t\t\tBYTE* rleBuffer[4] = { 0 };\n\n\t\t\tif (!planar->rlePlanesBuffer)\n\t\t\t\treturn FALSE;\n\n\t\t\trleBuffer[3] = planar->rlePlanesBuffer;  /* AlphaPlane */\n\t\t\trleBuffer[0] = rleBuffer[3] + planeSize; /* LumaOrRedPlane */\n\t\t\trleBuffer[1] = rleBuffer[0] + planeSize; /* OrangeChromaOrGreenPlane */\n\t\t\trleBuffer[2] = rleBuffer[1] + planeSize; /* GreenChromaOrBluePlane */\n\t\t\tif (useAlpha)\n\t\t\t{\n\t\t\t\tstatus =\n\t\t\t\t    planar_decompress_plane_rle_only(planes[3], rleSizes[3], rleBuffer[3],\n\t\t\t\t                                     rawWidths[3], rawHeights[3]); /* AlphaPlane */\n\n\t\t\t\tif (status < 0)\n\t\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tif (alpha)\n\t\t\t\tsrcp += rleSizes[3];\n\n\t\t\tstatus = planar_decompress_plane_rle_only(planes[0], rleSizes[0], rleBuffer[0],\n\t\t\t                                          rawWidths[0], rawHeights[0]); /* LumaPlane */\n\n\t\t\tif (status < 0)\n\t\t\t\treturn FALSE;\n\n\t\t\tstatus =\n\t\t\t    planar_decompress_plane_rle_only(planes[1], rleSizes[1], rleBuffer[1], rawWidths[1],\n\t\t\t                                     rawHeights[1]); /* OrangeChromaPlane */\n\n\t\t\tif (status < 0)\n\t\t\t\treturn FALSE;\n\n\t\t\tstatus =\n\t\t\t    planar_decompress_plane_rle_only(planes[2], rleSizes[2], rleBuffer[2], rawWidths[2],\n\t\t\t                                     rawHeights[2]); /* GreenChromaPlane */\n\n\t\t\tif (status < 0)\n\t\t\t\treturn FALSE;\n\n\t\t\tplanes[0] = rleBuffer[0];\n\t\t\tplanes[1] = rleBuffer[1];\n\t\t\tplanes[2] = rleBuffer[2];\n\t\t\tplanes[3] = rleBuffer[3];\n\t\t}\n\n\t\t/* RAW */\n\t\t{\n\t\t\tif (cs)\n\t\t\t{ /* Chroma subsampling for Co and Cg:\n\t\t\t   * Each pixel contains the value that should be expanded to\n\t\t\t   * [2x,2y;2x+1,2y;2x+1,2y+1;2x;2y+1] */\n\t\t\t\tif (!planar_subsample_expand(planes[1], rawSizes[1], nSrcWidth, nSrcHeight,\n\t\t\t\t                             rawWidths[1], rawHeights[1], planar->deltaPlanes[0]))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tplanes[1] = planar->deltaPlanes[0];\n\t\t\t\trawSizes[1] = planeSize; /* OrangeChromaOrGreenPlane */\n\t\t\t\trawWidths[1] = nSrcWidth;\n\t\t\t\trawHeights[1] = nSrcHeight;\n\n\t\t\t\tif (!planar_subsample_expand(planes[2], rawSizes[2], nSrcWidth, nSrcHeight,\n\t\t\t\t                             rawWidths[2], rawHeights[2], planar->deltaPlanes[1]))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tplanes[2] = planar->deltaPlanes[1];\n\t\t\t\trawSizes[2] = planeSize; /* GreenChromaOrBluePlane */\n\t\t\t\trawWidths[2] = nSrcWidth;\n\t\t\t\trawHeights[2] = nSrcHeight;\n\t\t\t}\n\n\t\t\tif (!planar_decompress_planes_raw(planes, pTempData, TempFormat, nTempStep, nXDst,\n\t\t\t                                  nYDst, nSrcWidth, nSrcHeight, vFlip, nTotalHeight))\n\t\t\t\treturn FALSE;\n\n\t\t\tif (alpha)\n\t\t\t\tsrcp += rawSizes[0] + rawSizes[1] + rawSizes[2] + rawSizes[3];\n\t\t\telse /* NoAlpha */\n\t\t\t\tsrcp += rawSizes[0] + rawSizes[1] + rawSizes[2];\n\n\t\t\tif ((SrcSize - (srcp - pSrcData)) == 1)\n\t\t\t\tsrcp++; /* pad */\n\t\t}\n\n\t\tWINPR_ASSERT(prims->YCoCgToRGB_8u_AC4R);\n\t\tint rc = prims->YCoCgToRGB_8u_AC4R(pTempData, nTempStep, dst, DstFormat, nDstStep, w, h,\n\t\t                                   cll, useAlpha);\n\t\tif (rc != PRIMITIVES_SUCCESS)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"YCoCgToRGB_8u_AC4R failed with %d\", rc);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tWINPR_UNUSED(srcp);\n\treturn TRUE;\n}", "target": 2, "idx": 9772}
{"commit_id": "737e1f39da80e02912953269966d89afd196ad30", "project": "gpac", "func": "GF_EXPORT\nGF_3GPConfig *gf_isom_3gp_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex)\n{\n\tGF_3GPConfig *config, *res;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !StreamDescriptionIndex) return NULL;\n\n\tconfig = NULL;\n\tentry = (GF_SampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, StreamDescriptionIndex-1);\n\tif (!entry) return NULL;\n\tswitch (entry->type) {\n\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO) return NULL;\n\t\tif (! ((GF_MPEGAudioSampleEntryBox*)entry)->cfg_3gpp) return NULL;\n\t\tconfig = & ((GF_MPEGAudioSampleEntryBox*)entry)->cfg_3gpp->cfg;\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return NULL;\n\t\tif (! ((GF_MPEGVisualSampleEntryBox*)entry)->cfg_3gpp) return NULL;\n\t\tconfig = & ((GF_MPEGVisualSampleEntryBox*)entry)->cfg_3gpp->cfg;\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\tif (!config) return NULL;\n\n\tres = (GF_3GPConfig*)gf_malloc(sizeof(GF_3GPConfig));\n\tif (res)\n\t\tmemcpy(res, config, sizeof(GF_3GPConfig));\n\treturn res;\n}", "target": 2, "idx": 9773}
{"commit_id": "5c437bcc7a51edbef45242c5173cf7871fde2866", "project": "chromium", "func": "void ExtensionViewGuest::DidNavigateMainFrame(\n    const content::LoadCommittedDetails& details,\n    const content::FrameNavigateParams& params) {\n  if (attached() && !url::IsSameOriginWith(params.url, url_)) {\n    bad_message::ReceivedBadMessage(web_contents()->GetRenderProcessHost(),\n                                    bad_message::EVG_BAD_ORIGIN);\n  }\n}", "target": 1, "idx": 9774}
{"commit_id": "e63c4a7d04c145dafaf4b09de5f9f5de69cee8ef", "project": "WebAssembly/binaryen", "func": "void SExpressionWasmBuilder::parseFunction(Element& s, bool preParseImport) {\n  size_t i = 1;\n  Name name, exportName;\n  i = parseFunctionNames(s, name, exportName);\n  if (!preParseImport) {\n    if (!name.is()) {\n      // unnamed, use an index\n      name = Name::fromInt(functionCounter);\n    }\n    functionCounter++;\n  } else {\n    // just preparsing, functionCounter was incremented by preParseFunctionType\n    if (!name.is()) {\n      // unnamed, use an index\n      name = functionNames[functionCounter - 1];\n    }\n  }\n  if (exportName.is()) {\n    auto ex = make_unique<Export>();\n    ex->name = exportName;\n    ex->value = name;\n    ex->kind = ExternalKind::Function;\n    if (wasm.getExportOrNull(ex->name)) throw ParseException(\"duplicate export\", s.line, s.col);\n    wasm.addExport(ex.release());\n  }\n  Expression* body = nullptr;\n  localIndex = 0;\n  otherIndex = 0;\n  brokeToAutoBlock = false;\n  std::vector<NameType> typeParams; // we may have both params and a type. store the type info here\n  std::vector<NameType> params;\n  std::vector<NameType> vars;\n  Type result = none;\n  Name type;\n  Block* autoBlock = nullptr; // we may need to add a block for the very top level\n  Name importModule, importBase;\n  auto makeFunction = [&]() {\n    currFunction = std::unique_ptr<Function>(Builder(wasm).makeFunction(\n        name,\n        std::move(params),\n        result,\n        std::move(vars)\n    ));\n  };\n  auto ensureAutoBlock = [&]() {\n    if (!autoBlock) {\n      autoBlock = allocator.alloc<Block>();\n      autoBlock->list.push_back(body);\n      body = autoBlock;\n    }\n  };\n  for (;i < s.size(); i++) {\n    Element& curr = *s[i];\n    IString id = curr[0]->str();\n    if (id == PARAM || id == LOCAL) {\n      size_t j = 1;\n      while (j < curr.size()) {\n        IString name;\n        Type type = none;\n        if (!curr[j]->dollared()) { // dollared input symbols cannot be types\n          type = stringToType(curr[j]->str(), true);\n        }\n        if (type != none) {\n          // a type, so an unnamed parameter\n          name = Name::fromInt(localIndex);\n        } else {\n          name = curr[j]->str();\n          type = stringToType(curr[j+1]->str());\n          j++;\n        }\n        j++;\n        if (id == PARAM) {\n          params.emplace_back(name, type);\n        } else {\n          vars.emplace_back(name, type);\n        }\n        localIndex++;\n        currLocalTypes[name] = type;\n      }\n    } else if (id == RESULT) {\n      if (curr.size() > 2) throw ParseException(\"invalid result arity\", curr.line, curr.col);\n      result = stringToType(curr[1]->str());\n    } else if (id == TYPE) {\n      Name name = getFunctionTypeName(*curr[1]);\n      type = name;\n      if (!wasm.getFunctionTypeOrNull(name)) throw ParseException(\"unknown function type\");\n      FunctionType* type = wasm.getFunctionType(name);\n      result = type->result;\n      for (size_t j = 0; j < type->params.size(); j++) {\n        IString name = Name::fromInt(j);\n        Type currType = type->params[j];\n        typeParams.emplace_back(name, currType);\n        currLocalTypes[name] = currType;\n      }\n    } else if (id == IMPORT) {\n      importModule = curr[1]->str();\n      importBase = curr[2]->str();\n    } else {\n      // body\n      if (typeParams.size() > 0 && params.size() == 0) {\n        params = typeParams;\n      }\n      if (!currFunction) makeFunction();\n      Expression* ex = parseExpression(curr);\n      if (!body) {\n        body = ex;\n      } else {\n        ensureAutoBlock();\n        autoBlock->list.push_back(ex);\n      }\n    }\n  }\n  // see https://github.com/WebAssembly/spec/pull/301\n  if (type.isNull()) {\n    // if no function type name provided, then we generated one\n    auto functionType = make_unique<FunctionType>(sigToFunctionType(getSigFromStructs(result, params)));\n    for (auto& existing : wasm.functionTypes) {\n      if (existing->structuralComparison(*functionType)) {\n        type = existing->name;\n        break;\n      }\n    }\n    if (!type.is()) throw ParseException(\"no function type [internal error?]\", s.line, s.col);\n  }\n  if (importModule.is()) {\n    // this is an import, actually\n    if (!importBase.size()) throw ParseException(\"module but no base for import\");\n    if (!preParseImport) throw ParseException(\"!preParseImport in func\");\n    auto im = make_unique<Function>();\n    im->name = name;\n    im->module = importModule;\n    im->base = importBase;\n    im->type = type;\n    FunctionTypeUtils::fillFunction(im.get(), wasm.getFunctionType(type));\n    functionTypes[name] = im->result;\n    if (wasm.getFunctionOrNull(im->name)) throw ParseException(\"duplicate import\", s.line, s.col);\n    wasm.addFunction(im.release());\n    if (currFunction) throw ParseException(\"import module inside function dec\");\n    currLocalTypes.clear();\n    nameMapper.clear();\n    return;\n  }\n  if (preParseImport) throw ParseException(\"preParseImport in func\");\n  if (brokeToAutoBlock) {\n    ensureAutoBlock();\n    autoBlock->name = FAKE_RETURN;\n  }\n  if (autoBlock) {\n    autoBlock->finalize(result);\n  }\n  if (!currFunction) {\n    makeFunction();\n    body = allocator.alloc<Nop>();\n  }\n  if (currFunction->result != result) throw ParseException(\"bad func declaration\", s.line, s.col);\n  currFunction->body = body;\n  currFunction->type = type;\n  if (s.startLoc) {\n    currFunction->prologLocation.insert(getDebugLocation(*s.startLoc));\n  }\n  if (s.endLoc) {\n    currFunction->epilogLocation.insert(getDebugLocation(*s.endLoc));\n  }\n  if (wasm.getFunctionOrNull(currFunction->name)) throw ParseException(\"duplicate function\", s.line, s.col);\n  wasm.addFunction(currFunction.release());\n  currLocalTypes.clear();\n  nameMapper.clear();\n}", "target": 1, "idx": 9775}
{"commit_id": "535a786f124b739e3c857529cecc29e4eeb79778", "project": "podofo", "func": "void PdfXRefStreamParserObject::getIndices(vector<int64_t>& indices, int64_t size)\n{\n    // get the first object number in this crossref stream.\n    // it is not required to have an index key though\n    auto indexObj = this->GetDictionary().GetKey(\"Index\");\n    if (indexObj == nullptr)\n    {\n        // Default\n        indices.push_back(static_cast<int64_t>(0));\n        indices.push_back(size);\n    }\n    else\n    {\n        const PdfArray* arr;\n        if (!indexObj->TryGetArray(arr))\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::InvalidXRefStream, \"Invalid XRef Stream /Index\");\n\n        for (auto index : *arr)\n            indices.push_back(index.GetNumber());\n    }\n\n    // indices must be a multiple of 2\n    if (indices.size() % 2 != 0)\n        PODOFO_RAISE_ERROR_INFO(PdfErrorCode::InvalidXRefStream, \"Invalid XRef Stream /Index\");\n}", "target": 2, "idx": 9776}
{"commit_id": "fe3b639dc19b325846f4f6801f2f4604f56e3de3", "project": "openssl", "func": "int ossl_punycode_decode(const char *pEncoded, const size_t enc_len,\n                         unsigned int *pDecoded, unsigned int *pout_length)\n{\n    unsigned int n = initial_n;\n    unsigned int i = 0;\n    unsigned int bias = initial_bias;\n    size_t processed_in = 0, written_out = 0;\n    unsigned int max_out = *pout_length;\n\n    unsigned int basic_count = 0;\n    unsigned int loop;\n\n    for (loop = 0; loop < enc_len; loop++) {\n        if (pEncoded[loop] == delimiter)\n            basic_count = loop;\n    }\n\n    if (basic_count > 0) {\n        if (basic_count > max_out)\n            return 0;\n\n        for (loop = 0; loop < basic_count; loop++) {\n            if (is_basic(pEncoded[loop]) == 0)\n                return 0;\n\n            pDecoded[loop] = pEncoded[loop];\n            written_out++;\n        }\n        processed_in = basic_count + 1;\n    }\n\n    for (loop = processed_in; loop < enc_len;) {\n        unsigned int oldi = i;\n        unsigned int w = 1;\n        unsigned int k, t;\n        int digit;\n\n        for (k = base;; k += base) {\n            if (loop >= enc_len)\n                return 0;\n\n            digit = digit_decoded(pEncoded[loop]);\n            loop++;\n\n            if (digit < 0)\n                return 0;\n            if ((unsigned int)digit > (maxint - i) / w)\n                return 0;\n\n            i = i + digit * w;\n            t = (k <= bias) ? tmin : (k >= bias + tmax) ? tmax : k - bias;\n\n            if ((unsigned int)digit < t)\n                break;\n\n            if (w > maxint / (base - t))\n                return 0;\n            w = w * (base - t);\n        }\n\n        bias = adapt(i - oldi, written_out + 1, (oldi == 0));\n        if (i / (written_out + 1) > maxint - n)\n            return 0;\n        n = n + i / (written_out + 1);\n        i %= (written_out + 1);\n\n        if (written_out >= max_out)\n            return 0;\n\n        memmove(pDecoded + i + 1, pDecoded + i,\n                (written_out - i) * sizeof *pDecoded);\n        pDecoded[i] = n;\n        i++;\n        written_out++;\n    }\n\n    *pout_length = written_out;\n    return 1;\n}", "target": 2, "idx": 9777}
{"commit_id": "64875fa98ff6afd2f21a9727970fb4333efe95de", "project": "Haivision/srt", "func": "void CSndUList::realloc_()\n{\n   CSNode** temp = NULL;\n\n   try\n   {\n       temp = new CSNode *[2 * m_iArrayLength];\n   }\n   catch (...)\n   {\n       throw CUDTException(MJ_SYSTEMRES, MN_MEMORY, 0);\n   }\n\n   memcpy(temp, m_pHeap, sizeof(CSNode*) * m_iArrayLength);\n   m_iArrayLength *= 2;\n   delete[] m_pHeap;\n   m_pHeap = temp;\n}", "target": 3, "idx": 9778}
{"commit_id": "19a9cd607de73947fcfb104682f203ffe4e1f4e5", "project": "xorg/lib/libXi", "func": "XModifierKeymap *\nXGetDeviceModifierMapping(\n    register Display\t*dpy,\n    XDevice\t\t*dev)\n{\n    unsigned long nbytes;\n    XModifierKeymap *res;\n    xGetDeviceModifierMappingReq *req;\n    xGetDeviceModifierMappingReply rep;\n    XExtDisplayInfo *info = XInput_find_display(dpy);\n\n    LockDisplay(dpy);\n    if (_XiCheckExtInit(dpy, XInput_Initial_Release, info) == -1)\n        return NULL;\n\n    GetReq(GetDeviceModifierMapping, req);\n    req->reqType = info->codes->major_opcode;\n    req->ReqType = X_GetDeviceModifierMapping;\n    req->deviceid = dev->device_id;\n\n    if (!_XReply(dpy, (xReply *) & rep, 0, xFalse)) {\n\tUnlockDisplay(dpy);\n\tSyncHandle();\n\treturn (XModifierKeymap *) NULL;\n    }\n    if (rep.length < (INT_MAX >> 2) &&\n\trep.numKeyPerModifier == rep.length >> 1) {\n\tnbytes = (unsigned long)rep.length << 2;\n\tres = (XModifierKeymap *) Xmalloc(sizeof(XModifierKeymap));\n    } else {\n\tnbytes = 0;\n\tres = NULL;\n    }\n    if (res) {\n\tres->modifiermap = (KeyCode *) Xmalloc(nbytes);\n\tif (res->modifiermap)\n\t    _XReadPad(dpy, (char *)res->modifiermap, nbytes);\n\telse\n\t    _XEatDataWords(dpy, rep.length);\n\tres->max_keypermod = rep.numKeyPerModifier;\n    }\n\n    UnlockDisplay(dpy);\n    SyncHandle();\n    return (res);\n}", "target": 2, "idx": 9779}
{"commit_id": "9237a63c47bd314b807cda0bd2216264e82edbe8", "project": "openvswitch/ovs", "func": "static enum ofperr\ndecode_bundle(bool load, const struct nx_action_bundle *nab,\n              const struct vl_mff_map *vl_mff_map, uint64_t *tlv_bitmap,\n              struct ofpbuf *ofpacts)\n{\n    static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 5);\n    struct ofpact_bundle *bundle;\n    uint32_t slave_type;\n    size_t slaves_size, i;\n    enum ofperr error;\n\n    bundle = ofpact_put_BUNDLE(ofpacts);\n\n    bundle->n_slaves = ntohs(nab->n_slaves);\n    bundle->basis = ntohs(nab->basis);\n    bundle->fields = ntohs(nab->fields);\n    bundle->algorithm = ntohs(nab->algorithm);\n    slave_type = ntohl(nab->slave_type);\n    slaves_size = ntohs(nab->len) - sizeof *nab;\n\n    error = OFPERR_OFPBAC_BAD_ARGUMENT;\n    if (!flow_hash_fields_valid(bundle->fields)) {\n        VLOG_WARN_RL(&rl, \"unsupported fields %d\", (int) bundle->fields);\n    } else if (bundle->n_slaves > BUNDLE_MAX_SLAVES) {\n        VLOG_WARN_RL(&rl, \"too many slaves\");\n    } else if (bundle->algorithm != NX_BD_ALG_HRW\n               && bundle->algorithm != NX_BD_ALG_ACTIVE_BACKUP) {\n        VLOG_WARN_RL(&rl, \"unsupported algorithm %d\", (int) bundle->algorithm);\n    } else if (slave_type != mf_nxm_header(MFF_IN_PORT)) {\n        VLOG_WARN_RL(&rl, \"unsupported slave type %\"PRIu16, slave_type);\n    } else {\n        error = 0;\n    }\n\n    if (!is_all_zeros(nab->zero, sizeof nab->zero)) {\n        VLOG_WARN_RL(&rl, \"reserved field is nonzero\");\n        error = OFPERR_OFPBAC_BAD_ARGUMENT;\n    }\n\n    if (load) {\n        bundle->dst.ofs = nxm_decode_ofs(nab->ofs_nbits);\n        bundle->dst.n_bits = nxm_decode_n_bits(nab->ofs_nbits);\n        error = mf_vl_mff_mf_from_nxm_header(ntohl(nab->dst), vl_mff_map,\n                                             &bundle->dst.field, tlv_bitmap);\n        if (error) {\n            return error;\n        }\n\n        if (bundle->dst.n_bits < 16) {\n            VLOG_WARN_RL(&rl, \"bundle_load action requires at least 16 bit \"\n                         \"destination.\");\n            error = OFPERR_OFPBAC_BAD_ARGUMENT;\n        }\n    } else {\n        if (nab->ofs_nbits || nab->dst) {\n            VLOG_WARN_RL(&rl, \"bundle action has nonzero reserved fields\");\n            error = OFPERR_OFPBAC_BAD_ARGUMENT;\n        }\n    }\n\n    if (slaves_size < bundle->n_slaves * sizeof(ovs_be16)) {\n        VLOG_WARN_RL(&rl, \"Nicira action %s only has %\"PRIuSIZE\" bytes \"\n                     \"allocated for slaves.  %\"PRIuSIZE\" bytes are required \"\n                     \"for %\"PRIu16\" slaves.\",\n                     load ? \"bundle_load\" : \"bundle\", slaves_size,\n                     bundle->n_slaves * sizeof(ovs_be16), bundle->n_slaves);\n        error = OFPERR_OFPBAC_BAD_LEN;\n    } else {\n        for (i = 0; i < bundle->n_slaves; i++) {\n            ofp_port_t ofp_port\n                = u16_to_ofp(ntohs(((ovs_be16 *)(nab + 1))[i]));\n            ofpbuf_put(ofpacts, &ofp_port, sizeof ofp_port);\n            bundle = ofpacts->header;\n        }\n    }\n\n    ofpact_finish_BUNDLE(ofpacts, &bundle);\n    if (!error) {\n        error = bundle_check(bundle, OFPP_MAX, NULL);\n    }\n    return error;\n}", "target": 1, "idx": 9780}
{"commit_id": "9fee4ae076b1ec97b97efb79ece08d1dab4df29a", "project": "FreeRDP", "func": "BOOL region16_union_rect(REGION16* dst, const REGION16* src, const RECTANGLE_16* rect)\n{\n\tREGION16_DATA* data;\n\tconst RECTANGLE_16* srcExtents;\n\tRECTANGLE_16* dstExtents;\n\tconst RECTANGLE_16* currentBand, *endSrcRect, *nextBand;\n\tREGION16_DATA* newItems = NULL;\n\tREGION16_DATA* tmpItems = NULL;\n\tRECTANGLE_16* dstRect = NULL;\n\tUINT32 usedRects, srcNbRects;\n\tUINT16 topInterBand;\n\tassert(src);\n\tassert(src->data);\n\tassert(dst);\n\tsrcExtents = region16_extents(src);\n\tdstExtents = region16_extents_noconst(dst);\n\n\tif (!region16_n_rects(src))\n\t{\n\t\t/* source is empty, so the union is rect */\n\t\tdst->extents = *rect;\n\t\tdst->data = allocateRegion(1);\n\n\t\tif (!dst->data)\n\t\t\treturn FALSE;\n\n\t\tdstRect = region16_rects_noconst(dst);\n\t\tdstRect->top = rect->top;\n\t\tdstRect->left = rect->left;\n\t\tdstRect->right = rect->right;\n\t\tdstRect->bottom = rect->bottom;\n\t\treturn TRUE;\n\t}\n\n\tnewItems = allocateRegion((1 + region16_n_rects(src)) * 4);\n\n\tif (!newItems)\n\t\treturn FALSE;\n\n\tdstRect = (RECTANGLE_16*)(&newItems[1]);\n\tusedRects = 0;\n\n\t/* adds the piece of rect that is on the top of src */\n\tif (rect->top < srcExtents->top)\n\t{\n\t\tdstRect->top = rect->top;\n\t\tdstRect->left = rect->left;\n\t\tdstRect->right = rect->right;\n\t\tdstRect->bottom = MIN(srcExtents->top, rect->bottom);\n\t\tusedRects++;\n\t\tdstRect++;\n\t}\n\n\t/* treat possibly overlapping region */\n\tcurrentBand = region16_rects(src, &srcNbRects);\n\tendSrcRect = currentBand + srcNbRects;\n\n\twhile (currentBand < endSrcRect)\n\t{\n\t\tif ((currentBand->bottom <= rect->top) || (rect->bottom <= currentBand->top) ||\n\t\t    rectangle_contained_in_band(currentBand, endSrcRect, rect))\n\t\t{\n\t\t\t/* no overlap between rect and the band, rect is totally below or totally above\n\t\t\t * the current band, or rect is already covered by an item of the band.\n\t\t\t * let's copy all the rectangles from this band\n\t\t\t\t\t\t+----+\n\t\t\t\t\t\t|    |   rect (case 1)\n\t\t\t\t\t\t+----+\n\n\t\t\t   =================\n\t\t\tband of srcRect\n\t\t\t =================\n\t\t\t\t\t+----+\n\t\t\t\t\t|    |   rect (case 2)\n\t\t\t\t\t+----+\n\t\t\t*/\n\t\t\tregion16_copy_band_with_union(dstRect,\n\t\t\t                              currentBand, endSrcRect,\n\t\t\t                              currentBand->top, currentBand->bottom,\n\t\t\t                              NULL, &usedRects,\n\t\t\t                              &nextBand, &dstRect);\n\t\t\ttopInterBand = rect->top;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* rect overlaps the band:\n\t\t\t\t\t   |    |  |    |\n\t\t\t====^=================|    |==|    |=========================== band\n\t\t\t|   top split     |    |  |    |\n\t\t\tv                 | 1  |  | 2  |\n\t\t\t^                 |    |  |    |  +----+   +----+\n\t\t\t|   merge zone    |    |  |    |  |    |   | 4  |\n\t\t\tv                 +----+  |    |  |    |   +----+\n\t\t\t^                         |    |  | 3  |\n\t\t\t|   bottom split          |    |  |    |\n\t\t\t====v=========================|    |==|    |===================\n\t\t\t\t\t   |    |  |    |\n\n\t\t\t possible cases:\n\t\t\t 1) no top split, merge zone then a bottom split. The band will be splitted\n\t\t\t  in two\n\t\t\t 2) not band split, only the merge zone, band merged with rect but not splitted\n\t\t\t 3) a top split, the merge zone and no bottom split. The band will be split\n\t\t\t in two\n\t\t\t 4) a top split, the merge zone and also a bottom split. The band will be\n\t\t\t splitted in 3, but the coalesce algorithm may merge the created bands\n\t\t\t */\n\t\t\tUINT16 mergeTop = currentBand->top;\n\t\t\tUINT16 mergeBottom = currentBand->bottom;\n\n\t\t\t/* test if we need a top split, case 3 and 4 */\n\t\t\tif (rect->top > currentBand->top)\n\t\t\t{\n\t\t\t\tregion16_copy_band_with_union(dstRect,\n\t\t\t\t                              currentBand, endSrcRect,\n\t\t\t\t                              currentBand->top, rect->top,\n\t\t\t\t                              NULL, &usedRects,\n\t\t\t\t                              &nextBand, &dstRect);\n\t\t\t\tmergeTop = rect->top;\n\t\t\t}\n\n\t\t\t/* do the merge zone (all cases) */\n\t\t\tif (rect->bottom < currentBand->bottom)\n\t\t\t\tmergeBottom = rect->bottom;\n\n\t\t\tregion16_copy_band_with_union(dstRect,\n\t\t\t                              currentBand, endSrcRect,\n\t\t\t                              mergeTop, mergeBottom,\n\t\t\t                              rect, &usedRects,\n\t\t\t                              &nextBand, &dstRect);\n\n\t\t\t/* test if we need a bottom split, case 1 and 4 */\n\t\t\tif (rect->bottom < currentBand->bottom)\n\t\t\t{\n\t\t\t\tregion16_copy_band_with_union(dstRect,\n\t\t\t\t                              currentBand, endSrcRect,\n\t\t\t\t                              mergeBottom, currentBand->bottom,\n\t\t\t\t                              NULL, &usedRects,\n\t\t\t\t                              &nextBand, &dstRect);\n\t\t\t}\n\n\t\t\ttopInterBand = currentBand->bottom;\n\t\t}\n\n\t\t/* test if a piece of rect should be inserted as a new band between\n\t\t * the current band and the next one. band n and n+1 shouldn't touch.\n\t\t *\n\t\t * ==============================================================\n\t\t *                                                        band n\n\t\t *            +------+                    +------+\n\t\t * ===========| rect |====================|      |===============\n\t\t *            |      |    +------+        |      |\n\t\t *            +------+    | rect |        | rect |\n\t\t *                        +------+        |      |\n\t\t * =======================================|      |================\n\t\t *                                        +------+         band n+1\n\t\t * ===============================================================\n\t\t *\n\t\t */\n\t\tif ((nextBand < endSrcRect) && (nextBand->top != currentBand->bottom) &&\n\t\t    (rect->bottom > currentBand->bottom) && (rect->top < nextBand->top))\n\t\t{\n\t\t\tdstRect->right = rect->right;\n\t\t\tdstRect->left = rect->left;\n\t\t\tdstRect->top = topInterBand;\n\t\t\tdstRect->bottom = MIN(nextBand->top, rect->bottom);\n\t\t\tdstRect++;\n\t\t\tusedRects++;\n\t\t}\n\n\t\tcurrentBand = nextBand;\n\t}\n\n\t/* adds the piece of rect that is below src */\n\tif (srcExtents->bottom < rect->bottom)\n\t{\n\t\tdstRect->top = MAX(srcExtents->bottom, rect->top);\n\t\tdstRect->left = rect->left;\n\t\tdstRect->right = rect->right;\n\t\tdstRect->bottom = rect->bottom;\n\t\tusedRects++;\n\t\tdstRect++;\n\t}\n\n\tif ((src == dst) && (src->data->size > 0) && (src->data != &empty_region))\n\t\tfree(src->data);\n\n\tdstExtents->top = MIN(rect->top, srcExtents->top);\n\tdstExtents->left = MIN(rect->left, srcExtents->left);\n\tdstExtents->bottom = MAX(rect->bottom, srcExtents->bottom);\n\tdstExtents->right = MAX(rect->right, srcExtents->right);\n\tnewItems->size = sizeof(REGION16_DATA) + (usedRects * sizeof(RECTANGLE_16));\n\ttmpItems = realloc(newItems, newItems->size);\n\tif (!tmpItems)\n\t\tfree(newItems);\n\tnewItems = tmpItems;\n\tdst->data = newItems;\n\n\tif (!dst->data)\n\t{\n\t\tfree(newItems);\n\t\treturn FALSE;\n\t}\n\n\tdst->data->nbRects = usedRects;\n\treturn region16_simplify_bands(dst);\n}", "target": 2, "idx": 9781}
{"commit_id": "2a05c8f813de6f2278827734bf8102291e7484aa", "project": "ffmpeg", "func": "static int process_line(URLContext *h, char *line, int line_count,\n                        int *new_location)\n{\n    HTTPContext *s = h->priv_data;\n    const char *auto_method =  h->flags & AVIO_FLAG_READ ? \"POST\" : \"GET\";\n    char *tag, *p, *end, *method, *resource, *version;\n    int ret;\n\n    /* end of header */\n    if (line[0] == '\\0') {\n        s->end_header = 1;\n        return 0;\n    }\n\n    p = line;\n    if (line_count == 0) {\n        if (s->is_connected_server) {\n            // HTTP method\n            method = p;\n            while (*p && !av_isspace(*p))\n                p++;\n            *(p++) = '\\0';\n            av_log(h, AV_LOG_TRACE, \"Received method: %s\\n\", method);\n            if (s->method) {\n                if (av_strcasecmp(s->method, method)) {\n                    av_log(h, AV_LOG_ERROR, \"Received and expected HTTP method do not match. (%s expected, %s received)\\n\",\n                           s->method, method);\n                    return ff_http_averror(400, AVERROR(EIO));\n                }\n            } else {\n                // use autodetected HTTP method to expect\n                av_log(h, AV_LOG_TRACE, \"Autodetected %s HTTP method\\n\", auto_method);\n                if (av_strcasecmp(auto_method, method)) {\n                    av_log(h, AV_LOG_ERROR, \"Received and autodetected HTTP method did not match \"\n                           \"(%s autodetected %s received)\\n\", auto_method, method);\n                    return ff_http_averror(400, AVERROR(EIO));\n                }\n                if (!(s->method = av_strdup(method)))\n                    return AVERROR(ENOMEM);\n            }\n\n            // HTTP resource\n            while (av_isspace(*p))\n                p++;\n            resource = p;\n            while (!av_isspace(*p))\n                p++;\n            *(p++) = '\\0';\n            av_log(h, AV_LOG_TRACE, \"Requested resource: %s\\n\", resource);\n            if (!(s->resource = av_strdup(resource)))\n                return AVERROR(ENOMEM);\n\n            // HTTP version\n            while (av_isspace(*p))\n                p++;\n            version = p;\n            while (*p && !av_isspace(*p))\n                p++;\n            *p = '\\0';\n            if (av_strncasecmp(version, \"HTTP/\", 5)) {\n                av_log(h, AV_LOG_ERROR, \"Malformed HTTP version string.\\n\");\n                return ff_http_averror(400, AVERROR(EIO));\n            }\n            av_log(h, AV_LOG_TRACE, \"HTTP version string: %s\\n\", version);\n        } else {\n            while (!av_isspace(*p) && *p != '\\0')\n                p++;\n            while (av_isspace(*p))\n                p++;\n            s->http_code = strtol(p, &end, 10);\n\n            av_log(h, AV_LOG_TRACE, \"http_code=%d\\n\", s->http_code);\n\n            if ((ret = check_http_code(h, s->http_code, end)) < 0)\n                return ret;\n        }\n    } else {\n        while (*p != '\\0' && *p != ':')\n            p++;\n        if (*p != ':')\n            return 1;\n\n        *p  = '\\0';\n        tag = line;\n        p++;\n        while (av_isspace(*p))\n            p++;\n        if (!av_strcasecmp(tag, \"Location\")) {\n            if ((ret = parse_location(s, p)) < 0)\n                return ret;\n            *new_location = 1;\n        } else if (!av_strcasecmp(tag, \"Content-Length\") &&\n                   s->filesize == UINT64_MAX) {\n            s->filesize = strtoull(p, NULL, 10);\n        } else if (!av_strcasecmp(tag, \"Content-Range\")) {\n            parse_content_range(h, p);\n        } else if (!av_strcasecmp(tag, \"Accept-Ranges\") &&\n                   !strncmp(p, \"bytes\", 5) &&\n                   s->seekable == -1) {\n            h->is_streamed = 0;\n        } else if (!av_strcasecmp(tag, \"Transfer-Encoding\") &&\n                   !av_strncasecmp(p, \"chunked\", 7)) {\n            s->filesize  = UINT64_MAX;\n            s->chunksize = 0;\n        } else if (!av_strcasecmp(tag, \"WWW-Authenticate\")) {\n            ff_http_auth_handle_header(&s->auth_state, tag, p);\n        } else if (!av_strcasecmp(tag, \"Authentication-Info\")) {\n            ff_http_auth_handle_header(&s->auth_state, tag, p);\n        } else if (!av_strcasecmp(tag, \"Proxy-Authenticate\")) {\n            ff_http_auth_handle_header(&s->proxy_auth_state, tag, p);\n        } else if (!av_strcasecmp(tag, \"Connection\")) {\n            if (!strcmp(p, \"close\"))\n                s->willclose = 1;\n        } else if (!av_strcasecmp(tag, \"Server\")) {\n            if (!av_strcasecmp(p, \"AkamaiGHost\")) {\n                s->is_akamai = 1;\n            } else if (!av_strncasecmp(p, \"MediaGateway\", 12)) {\n                s->is_mediagateway = 1;\n            }\n        } else if (!av_strcasecmp(tag, \"Content-Type\")) {\n            av_free(s->mime_type);\n            s->mime_type = av_strdup(p);\n        } else if (!av_strcasecmp(tag, \"Set-Cookie\")) {\n            if (parse_cookie(s, p, &s->cookie_dict))\n                av_log(h, AV_LOG_WARNING, \"Unable to parse '%s'\\n\", p);\n        } else if (!av_strcasecmp(tag, \"Icy-MetaInt\")) {\n            s->icy_metaint = strtoull(p, NULL, 10);\n        } else if (!av_strncasecmp(tag, \"Icy-\", 4)) {\n            if ((ret = parse_icy(s, tag, p)) < 0)\n                return ret;\n        } else if (!av_strcasecmp(tag, \"Content-Encoding\")) {\n            if ((ret = parse_content_encoding(h, p)) < 0)\n                return ret;\n        }\n    }\n    return 1;\n}", "target": 3, "idx": 9782}
{"commit_id": "d919b2744cd05abae043490f0a3dd1946c1ccb8c", "project": "open5gs", "func": "int amf_namf_comm_handle_n1_n2_message_transfer(\n        ogs_sbi_stream_t *stream, ogs_sbi_message_t *recvmsg)\n{\n    int status;\n\n    amf_ue_t *amf_ue = NULL;\n    amf_sess_t *sess = NULL;\n\n    ogs_pkbuf_t *n1buf = NULL;\n    ogs_pkbuf_t *n2buf = NULL;\n\n    ogs_pkbuf_t *gmmbuf = NULL;\n    ogs_pkbuf_t *ngapbuf = NULL;\n\n    char *supi = NULL;\n    uint8_t pdu_session_id = OGS_NAS_PDU_SESSION_IDENTITY_UNASSIGNED;\n\n    ogs_sbi_message_t sendmsg;\n    ogs_sbi_response_t *response = NULL;\n\n    OpenAPI_n1_n2_message_transfer_req_data_t *N1N2MessageTransferReqData;\n    OpenAPI_n1_n2_message_transfer_rsp_data_t N1N2MessageTransferRspData;\n    OpenAPI_n1_message_container_t *n1MessageContainer = NULL;\n    OpenAPI_ref_to_binary_data_t *n1MessageContent = NULL;\n    OpenAPI_n2_info_container_t *n2InfoContainer = NULL;\n    OpenAPI_n2_sm_information_t *smInfo = NULL;\n    OpenAPI_n2_info_content_t *n2InfoContent = NULL;\n    OpenAPI_ref_to_binary_data_t *ngapData = NULL;\n\n    OpenAPI_ngap_ie_type_e ngapIeType = OpenAPI_ngap_ie_type_NULL;\n\n    ogs_assert(stream);\n    ogs_assert(recvmsg);\n\n    N1N2MessageTransferReqData = recvmsg->N1N2MessageTransferReqData;\n    if (!N1N2MessageTransferReqData) {\n        ogs_error(\"No N1N2MessageTransferReqData\");\n        return OGS_ERROR;\n    }\n\n    if (N1N2MessageTransferReqData->is_pdu_session_id == false) {\n        ogs_error(\"No PDU Session Identity\");\n        return OGS_ERROR;\n    }\n    pdu_session_id = N1N2MessageTransferReqData->pdu_session_id;\n\n    supi = recvmsg->h.resource.component[1];\n    if (!supi) {\n        ogs_error(\"No SUPI\");\n        return OGS_ERROR;\n    }\n\n    amf_ue = amf_ue_find_by_supi(supi);\n    if (!amf_ue) {\n        ogs_error(\"No UE context [%s]\", supi);\n        return OGS_ERROR;\n    }\n\n    sess = amf_sess_find_by_psi(amf_ue, pdu_session_id);\n    if (!sess) {\n        ogs_error(\"[%s] No PDU Session Context [%d]\",\n                amf_ue->supi, pdu_session_id);\n        return OGS_ERROR;\n    }\n\n    n1MessageContainer = N1N2MessageTransferReqData->n1_message_container;\n    if (n1MessageContainer) {\n        n1MessageContent = n1MessageContainer->n1_message_content;\n        if (!n1MessageContent || !n1MessageContent->content_id) {\n            ogs_error(\"No n1MessageContent\");\n            return OGS_ERROR;\n        }\n\n        n1buf = ogs_sbi_find_part_by_content_id(\n                recvmsg, n1MessageContent->content_id);\n        if (!n1buf) {\n            ogs_error(\"[%s] No N1 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        /*\n         * NOTE : The pkbuf created in the SBI message will be removed\n         *        from ogs_sbi_message_free(), so it must be copied.\n         */\n        n1buf = ogs_pkbuf_copy(n1buf);\n        ogs_assert(n1buf);\n    }\n\n    n2InfoContainer = N1N2MessageTransferReqData->n2_info_container;\n    if (n2InfoContainer) {\n        smInfo = n2InfoContainer->sm_info;\n        if (!smInfo) {\n            ogs_error(\"No smInfo\");\n            return OGS_ERROR;\n        }\n\n        n2InfoContent = smInfo->n2_info_content;\n        if (!n2InfoContent) {\n            ogs_error(\"No n2InfoContent\");\n            return OGS_ERROR;\n        }\n\n        ngapIeType = n2InfoContent->ngap_ie_type;\n\n        ngapData = n2InfoContent->ngap_data;\n        if (!ngapData || !ngapData->content_id) {\n            ogs_error(\"No ngapData\");\n            return OGS_ERROR;\n        }\n        n2buf = ogs_sbi_find_part_by_content_id(\n                recvmsg, ngapData->content_id);\n        if (!n2buf) {\n            ogs_error(\"[%s] No N2 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        /*\n         * NOTE : The pkbuf created in the SBI message will be removed\n         *        from ogs_sbi_message_free(), so it must be copied.\n         */\n        n2buf = ogs_pkbuf_copy(n2buf);\n        ogs_assert(n2buf);\n    }\n\n    memset(&sendmsg, 0, sizeof(sendmsg));\n\n    status = OGS_SBI_HTTP_STATUS_OK;\n\n    memset(&N1N2MessageTransferRspData, 0, sizeof(N1N2MessageTransferRspData));\n    N1N2MessageTransferRspData.cause =\n        OpenAPI_n1_n2_message_transfer_cause_N1_N2_TRANSFER_INITIATED;\n\n    sendmsg.N1N2MessageTransferRspData = &N1N2MessageTransferRspData;\n\n    switch (ngapIeType) {\n    case OpenAPI_ngap_ie_type_PDU_RES_SETUP_REQ:\n        if (!n2buf) {\n            ogs_error(\"[%s] No N2 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        if (n1buf) {\n            gmmbuf = gmm_build_dl_nas_transport(sess,\n                    OGS_NAS_PAYLOAD_CONTAINER_N1_SM_INFORMATION, n1buf, 0, 0);\n            ogs_assert(gmmbuf);\n        }\n\n        if (gmmbuf) {\n            ran_ue_t *ran_ue = NULL;\n\n            /***********************************\n             * 4.3.2 PDU Session Establishment *\n             ***********************************/\n\n            ran_ue = ran_ue_cycle(amf_ue->ran_ue);\n            ogs_assert(ran_ue);\n\n            if (sess->pdu_session_establishment_accept) {\n                ogs_pkbuf_free(sess->pdu_session_establishment_accept);\n                sess->pdu_session_establishment_accept = NULL;\n            }\n\n            if (ran_ue->initial_context_setup_request_sent == true) {\n                ngapbuf = ngap_sess_build_pdu_session_resource_setup_request(\n                        sess, gmmbuf, n2buf);\n                ogs_assert(ngapbuf);\n            } else {\n                ngapbuf = ngap_sess_build_initial_context_setup_request(\n                        sess, gmmbuf, n2buf);\n                ogs_assert(ngapbuf);\n\n                ran_ue->initial_context_setup_request_sent = true;\n            }\n\n            if (SESSION_CONTEXT_IN_SMF(sess)) {\n                /*\n                 * [1-CLIENT] /nsmf-pdusession/v1/sm-contexts\n                 * [2-SERVER] /namf-comm/v1/ue-contexts/{supi}/n1-n2-messages\n                 *\n                 * If [2-SERVER] arrives after [1-CLIENT],\n                 * sm-context-ref is created in [1-CLIENT].\n                 * So, the PDU session establishment accpet can be transmitted.\n                 */\n                if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK)\n                    ogs_error(\"nas_5gs_send_to_gnb() failed\");\n            } else {\n                sess->pdu_session_establishment_accept = ngapbuf;\n            }\n\n        } else {\n            /*********************************************\n             * 4.2.3.3 Network Triggered Service Request *\n             *********************************************/\n\n            if (CM_IDLE(amf_ue)) {\n                ogs_sbi_server_t *server = NULL;\n                ogs_sbi_header_t header;\n                ogs_sbi_client_t *client = NULL;\n                ogs_sockaddr_t *addr = NULL;\n\n                if (!N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri) {\n                    ogs_error(\"[%s:%d] No n1-n2-failure-notification-uri\",\n                            amf_ue->supi, sess->psi);\n                    return OGS_ERROR;\n                }\n\n                addr = ogs_sbi_getaddr_from_uri(\n                        N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri);\n                if (!addr) {\n                    ogs_error(\"[%s:%d] Invalid URI [%s]\",\n                            amf_ue->supi, sess->psi,\n                            N1N2MessageTransferReqData->\n                                n1n2_failure_txf_notif_uri);\n                    return OGS_ERROR;;\n                }\n\n                client = ogs_sbi_client_find(addr);\n                if (!client) {\n                    client = ogs_sbi_client_add(addr);\n                    ogs_assert(client);\n                }\n                OGS_SETUP_SBI_CLIENT(&sess->paging, client);\n\n                ogs_freeaddrinfo(addr);\n\n                status = OGS_SBI_HTTP_STATUS_ACCEPTED;\n                N1N2MessageTransferRspData.cause =\n                    OpenAPI_n1_n2_message_transfer_cause_ATTEMPTING_TO_REACH_UE;\n\n                /* Location */\n                server = ogs_sbi_server_from_stream(stream);\n                ogs_assert(server);\n\n                memset(&header, 0, sizeof(header));\n                header.service.name = (char *)OGS_SBI_SERVICE_NAME_NAMF_COMM;\n                header.api.version = (char *)OGS_SBI_API_V1;\n                header.resource.component[0] =\n                    (char *)OGS_SBI_RESOURCE_NAME_UE_CONTEXTS;\n                header.resource.component[1] = amf_ue->supi;\n                header.resource.component[2] =\n                    (char *)OGS_SBI_RESOURCE_NAME_N1_N2_MESSAGES;\n                header.resource.component[3] = sess->sm_context_ref;\n\n                sendmsg.http.location = ogs_sbi_server_uri(server, &header);\n\n                /* Store Paging Info */\n                AMF_SESS_STORE_PAGING_INFO(\n                        sess, sendmsg.http.location,\n                        N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri);\n\n                /* Store N2 Transfer message */\n                AMF_SESS_STORE_N2_TRANSFER(\n                        sess, pdu_session_resource_setup_request, n2buf);\n\n                ogs_assert(OGS_OK == ngap_send_paging(amf_ue));\n\n            } else if (CM_CONNECTED(amf_ue)) {\n                ogs_assert(OGS_OK ==\n                    ngap_send_pdu_resource_setup_request(sess, n2buf));\n\n            } else {\n\n                ogs_fatal(\"[%s] Invalid AMF-UE state\", amf_ue->supi);\n                ogs_assert_if_reached();\n\n            }\n\n        }\n        break;\n\n    case OpenAPI_ngap_ie_type_PDU_RES_MOD_REQ:\n        if (!n1buf) {\n            ogs_error(\"[%s] No N1 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n        if (!n2buf) {\n            ogs_error(\"[%s] No N2 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        if (CM_IDLE(amf_ue)) {\n            ogs_sbi_server_t *server = NULL;\n            ogs_sbi_header_t header;\n\n            status = OGS_SBI_HTTP_STATUS_ACCEPTED;\n            N1N2MessageTransferRspData.cause =\n                OpenAPI_n1_n2_message_transfer_cause_ATTEMPTING_TO_REACH_UE;\n\n            /* Location */\n            server = ogs_sbi_server_from_stream(stream);\n            ogs_assert(server);\n\n            memset(&header, 0, sizeof(header));\n            header.service.name = (char *)OGS_SBI_SERVICE_NAME_NAMF_COMM;\n            header.api.version = (char *)OGS_SBI_API_V1;\n            header.resource.component[0] =\n                (char *)OGS_SBI_RESOURCE_NAME_UE_CONTEXTS;\n            header.resource.component[1] = amf_ue->supi;\n            header.resource.component[2] =\n                (char *)OGS_SBI_RESOURCE_NAME_N1_N2_MESSAGES;\n            header.resource.component[3] = sess->sm_context_ref;\n\n            sendmsg.http.location = ogs_sbi_server_uri(server, &header);\n\n            /* Store Paging Info */\n            AMF_SESS_STORE_PAGING_INFO(\n                    sess, sendmsg.http.location, NULL);\n\n            /* Store 5GSM Message */\n            AMF_SESS_STORE_5GSM_MESSAGE(sess,\n                    OGS_NAS_5GS_PDU_SESSION_MODIFICATION_COMMAND,\n                    n1buf, n2buf);\n\n            ogs_assert(OGS_OK == ngap_send_paging(amf_ue));\n\n        } else if (CM_CONNECTED(amf_ue)) {\n            gmmbuf = gmm_build_dl_nas_transport(sess,\n                    OGS_NAS_PAYLOAD_CONTAINER_N1_SM_INFORMATION, n1buf, 0, 0);\n            ogs_assert(gmmbuf);\n\n            ngapbuf = ngap_build_pdu_session_resource_modify_request(\n                    sess, gmmbuf, n2buf);\n            ogs_assert(ngapbuf);\n\n            if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK)\n                ogs_error(\"nas_5gs_send_to_gnb() failed\");\n\n        } else {\n            ogs_fatal(\"[%s] Invalid AMF-UE state\", amf_ue->supi);\n            ogs_assert_if_reached();\n        }\n\n        break;\n\n    case OpenAPI_ngap_ie_type_PDU_RES_REL_CMD:\n        if (!n2buf) {\n            ogs_error(\"[%s] No N2 SM Content\", amf_ue->supi);\n            return OGS_ERROR;\n        }\n\n        if (n1buf)\n            ogs_pkbuf_free(n1buf);\n\n        if (CM_IDLE(amf_ue)) {\n            if (n2buf)\n                ogs_pkbuf_free(n2buf);\n\n            if (N1N2MessageTransferReqData->is_skip_ind == true &&\n                N1N2MessageTransferReqData->skip_ind == true) {\n                N1N2MessageTransferRspData.cause =\n                    OpenAPI_n1_n2_message_transfer_cause_N1_MSG_NOT_TRANSFERRED;\n            } else {\n                ogs_fatal(\"[%s] No skipInd\", amf_ue->supi);\n                ogs_assert_if_reached();\n            }\n\n        } else if (CM_CONNECTED(amf_ue)) {\n            ngapbuf = ngap_build_pdu_session_resource_release_command(\n                    sess, NULL, n2buf);\n            ogs_assert(ngapbuf);\n\n            if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK)\n                ogs_error(\"nas_5gs_send_to_gnb() failed\");\n\n        } else {\n            ogs_fatal(\"[%s] Invalid AMF-UE state\", amf_ue->supi);\n            ogs_assert_if_reached();\n        }\n        break;\n\n    default:\n        ogs_error(\"Not implemented ngapIeType[%d]\", ngapIeType);\n        ogs_assert_if_reached();\n    }\n\n    response = ogs_sbi_build_response(&sendmsg, status);\n    ogs_assert(response);\n    ogs_assert(true == ogs_sbi_server_send_response(stream, response));\n\n    if (sendmsg.http.location)\n        ogs_free(sendmsg.http.location);\n\n    return OGS_OK;\n}", "target": 2, "idx": 9783}
{"commit_id": "319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12", "project": "xen-project/xen", "func": "static int deassign_device(struct domain *d, uint16_t seg, uint8_t bus,\n                           uint8_t devfn)\n{\n    const struct domain_iommu *hd = dom_iommu(d);\n    struct pci_dev *pdev;\n    struct domain *target;\n    int ret = 0;\n\n    if ( !is_iommu_enabled(d) )\n        return -EINVAL;\n\n    ASSERT(pcidevs_locked());\n    pdev = pci_get_pdev_by_domain(d, seg, bus, devfn);\n    if ( !pdev )\n        return -ENODEV;\n\n    /* De-assignment from dom_io should de-quarantine the device */\n    target = (pdev->quarantine && pdev->domain != dom_io) ?\n        dom_io : hardware_domain;\n\n    while ( pdev->phantom_stride )\n    {\n        devfn += pdev->phantom_stride;\n        if ( PCI_SLOT(devfn) != PCI_SLOT(pdev->devfn) )\n            break;\n        ret = hd->platform_ops->reassign_device(d, target, devfn,\n                                                pci_to_dev(pdev));\n        if ( !ret )\n            continue;\n\n        printk(XENLOG_G_ERR \"%pd: deassign %04x:%02x:%02x.%u failed (%d)\\n\",\n               d, seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn), ret);\n        return ret;\n    }\n\n    devfn = pdev->devfn;\n    ret = hd->platform_ops->reassign_device(d, target, devfn,\n                                            pci_to_dev(pdev));\n    if ( ret )\n    {\n        dprintk(XENLOG_G_ERR,\n                \"%pd: deassign device (%04x:%02x:%02x.%u) failed\\n\",\n                d, seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn));\n        return ret;\n    }\n\n    if ( pdev->domain == hardware_domain  )\n        pdev->quarantine = false;\n\n    pdev->fault.count = 0;\n\n    return ret;\n}", "target": 1, "idx": 9784}
{"commit_id": "c88e739b1fad662240e99ecbd0bdaac871717987", "project": "torvalds/linux", "func": "static long __media_device_enum_links(struct media_device *mdev,\n\t\t\t\t      struct media_links_enum *links)\n{\n\tstruct media_entity *entity;\n\n\tentity = find_entity(mdev, links->entity);\n\tif (entity == NULL)\n\t\treturn -EINVAL;\n\n\tif (links->pads) {\n\t\tunsigned int p;\n\n\t\tfor (p = 0; p < entity->num_pads; p++) {\n\t\t\tstruct media_pad_desc pad;\n\n\t\t\tmemset(&pad, 0, sizeof(pad));\n\t\t\tmedia_device_kpad_to_upad(&entity->pads[p], &pad);\n\t\t\tif (copy_to_user(&links->pads[p], &pad, sizeof(pad)))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\tif (links->links) {\n\t\tstruct media_link_desc __user *ulink;\n\t\tunsigned int l;\n\n\t\tfor (l = 0, ulink = links->links; l < entity->num_links; l++) {\n\t\t\tstruct media_link_desc link;\n\n\t\t\t/* Ignore backlinks. */\n\t\t\tif (entity->links[l].source->entity != entity)\n\t\t\t\tcontinue;\n\n\t\t\tmemset(&link, 0, sizeof(link));\n\t\t\tmedia_device_kpad_to_upad(entity->links[l].source,\n\t\t\t\t\t\t  &link.source);\n\t\t\tmedia_device_kpad_to_upad(entity->links[l].sink,\n\t\t\t\t\t\t  &link.sink);\n\t\t\tlink.flags = entity->links[l].flags;\n\t\t\tif (copy_to_user(ulink, &link, sizeof(*ulink)))\n\t\t\t\treturn -EFAULT;\n\t\t\tulink++;\n\t\t}\n\t}\n\n\treturn 0;\n}", "target": 1, "idx": 9785}
{"commit_id": "319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12", "project": "xen-project/xen", "func": "static int device_assigned(u16 seg, u8 bus, u8 devfn)\n{\n    struct pci_dev *pdev;\n    int rc = 0;\n\n    pcidevs_lock();\n\n    pdev = pci_get_pdev(seg, bus, devfn);\n\n    if ( !pdev )\n        rc = -ENODEV;\n    /*\n     * If the device exists and it is not owned by either the hardware\n     * domain or dom_io then it must be assigned to a guest, or be\n     * hidden (owned by dom_xen).\n     */\n    else if ( pdev->domain != hardware_domain &&\n              pdev->domain != dom_io )\n        rc = -EBUSY;\n\n    pcidevs_unlock();\n\n    return rc;\n}", "target": 1, "idx": 9786}
{"commit_id": "5df913b7", "project": "OpenSC", "func": "static int insert_pin(\n\tsc_pkcs15_card_t *p15card,\n\tconst char       *path,\n\tunsigned char     id,\n\tunsigned char     auth_id,\n\tunsigned char     pin_reference,\n\tint               min_length,\n\tconst char       *label,\n\tint               pin_flags\n){\n\tsc_card_t *card=p15card->card;\n\tsc_context_t *ctx=p15card->card->ctx;\n\tsc_file_t *f = NULL;\n\tstruct sc_pkcs15_auth_info pin_info;\n\tstruct sc_pkcs15_object pin_obj;\n\tint r;\n\n\tmemset(&pin_info, 0, sizeof(pin_info));\n\tpin_info.auth_id.len      = 1;\n\tpin_info.auth_id.value[0] = id;\n\tpin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;\n\tpin_info.attrs.pin.reference        = pin_reference;\n\tpin_info.attrs.pin.flags            = pin_flags;\n\tpin_info.attrs.pin.type             = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;\n\tpin_info.attrs.pin.min_length       = min_length;\n\tpin_info.attrs.pin.stored_length    = 16;\n\tpin_info.attrs.pin.max_length       = 16;\n\tpin_info.attrs.pin.pad_char         = '\\0';\n\tpin_info.logged_in = SC_PIN_STATE_UNKNOWN;\n\tsc_format_path(path, &pin_info.path);\n\n\tmemset(&pin_obj, 0, sizeof(pin_obj));\n\tstrlcpy(pin_obj.label, label, sizeof(pin_obj.label));\n\tpin_obj.flags            = SC_PKCS15_CO_FLAG_MODIFIABLE | SC_PKCS15_CO_FLAG_PRIVATE;\n\tpin_obj.auth_id.len      = auth_id ? 0 : 1;\n\tpin_obj.auth_id.value[0] = auth_id;\n\n\tif(card->type == SC_CARD_TYPE_TCOS_V3) {\n\t\tunsigned char buf[256];\n\t\tint i, rec_no=0;\n\t\tif (pin_info.path.len >= 2) {\n\t\t\tpin_info.path.len -= 2;\n\t\t}\n\t\tsc_append_file_id(&pin_info.path, 0x5049);\n\t\tif (sc_select_file(card, &pin_info.path, NULL) != SC_SUCCESS) {\n\t\t\tsc_log(ctx, \n\t\t\t\t\"Select(%s) failed\\n\",\n\t\t\t\tsc_print_path(&pin_info.path));\n\t\t\treturn 1;\n\t\t}\n\t\tsc_log(ctx, \n\t\t\t\"Searching for PIN-Ref %02X\\n\", pin_reference);\n\t\twhile ((r = sc_read_record(card, ++rec_no, buf, sizeof(buf), SC_RECORD_BY_REC_NR)) > 0) {\n\t\t\tint found = 0, fbz = -1;\n\t\t\tif (r < 2 || buf[0] != 0xA0)\n\t\t\t\tcontinue;\n\t\t\tfor (i = 2; i < buf[1] + 2 && (i + 2) < r; i += 2 + buf[i + 1]) {\n\t\t\t\tif (buf[i] == 0x83 && buf[i + 1] == 1 && buf[i + 2] == pin_reference) {\n\t\t\t\t\t++found;\n\t\t\t\t}\n\t\t\t\tif (buf[i] == 0x90 && (i + 1 + buf[i + 1]) < r) {\n\t\t\t\t\tfbz = buf[i + 1 + buf[i + 1]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found) {\n\t\t\t\tpin_info.tries_left = fbz;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (r <= 0) {\n\t\t\tsc_log(ctx, \"No EF_PWDD-Record found\\n\");\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\tif (sc_select_file(card, &pin_info.path, &f) != SC_SUCCESS\n\t\t\t   \t|| !f->prop_attr || f->prop_attr_len < 4){\n\t\t\tsc_log(ctx, \"Select(%s) failed\\n\", path);\n\t\t\tsc_file_free(f);\n\t\t\treturn 1;\n\t\t}\n\t\tpin_info.tries_left = f->prop_attr[3];\n\t\tsc_file_free(f);\n\t}\n\n\tr=sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);\n\tif(r!=SC_SUCCESS){\n\t\tsc_log(ctx,  \"sc_pkcs15emu_add_pin_obj(%s) failed\\n\", path);\n\t\treturn 4;\n\t}\n\tsc_log(ctx,  \"%s: OK, FBZ=%d\\n\", path, pin_info.tries_left);\n\treturn 0;\n}", "target": 1, "idx": 9787}
{"commit_id": "2f2d0088eb93db5c649d2a5e34a3800a8a935fc5", "project": "torvalds/linux", "func": "static ssize_t nports_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *out)\n{\n\tchar *s = out;\n\n\t/*\n\t * Half the ports are for SPEED_HIGH and half for SPEED_SUPER,\n\t * thus the * 2.\n\t */\n\tout += sprintf(out, \"%d\\n\", VHCI_PORTS * vhci_num_controllers);\n\treturn out - s;\n}", "target": 1, "idx": 9788}
{"commit_id": "586a5180287262070637c8943f2f7efd652e4a2c", "project": "Cisco-Talos/clamav", "func": "void\nmessageAddArgument(message *m, const char *arg)\n{\n\tint offset;\n\tchar *p;\n\n\tassert(m != NULL);\n\n\tif(arg == NULL)\n\t\treturn;\t/* Note: this is not an error condition */\n\n\twhile(isspace(*arg))\n\t\targ++;\n\n\tif(*arg == '\\0')\n\t\t/* Empty argument? Probably a broken mail client... */\n\t\treturn;\n\n\tcli_dbgmsg(\"messageAddArgument, arg='%s'\\n\", arg);\n\n\tif(!usefulArg(arg))\n\t\treturn;\n\n\tfor(offset = 0; offset < m->numberOfArguments; offset++)\n\t\tif(m->mimeArguments[offset] == NULL)\n\t\t\tbreak;\n\t\telse if(strcasecmp(arg, m->mimeArguments[offset]) == 0)\n\t\t\treturn;\t/* already in there */\n\n\tif(offset == m->numberOfArguments) {\n\t\tchar **q;\n\n\t\tm->numberOfArguments++;\n\t\tq = (char **)cli_realloc(m->mimeArguments, m->numberOfArguments * sizeof(char *));\n\t\tif(q == NULL) {\n\t\t\tm->numberOfArguments--;\n\t\t\treturn;\n\t\t}\n\t\tm->mimeArguments = q;\n\t}\n\n\tp = m->mimeArguments[offset] = rfc2231(arg);\n\tif(!p) {\n\t\t/* problem inside rfc2231() */\n\t\tcli_dbgmsg(\"messageAddArgument, error from rfc2231()\\n\");\n\t\treturn;\n\t}\n\n\tif(strchr(p, '=') == NULL) {\n\t\tif(strncmp(p, \"filename\", 8) == 0) {\n\t\t\t/*\n\t\t\t * FIXME: Bounce message handling is corrupting the in\n\t\t\t * core copies of headers\n\t\t\t */\n                        if (strlen(p) > 8) {\n                            cli_dbgmsg(\"Possible data corruption fixed\\n\");\n                            p[8] = '=';\n                        } else {\n                            cli_dbgmsg(\"Possible data corruption not fixed\\n\");\n                        }\n\t\t} else {\n\t\t\tif(*p)\n\t\t\t\tcli_dbgmsg(\"messageAddArgument, '%s' contains no '='\\n\", p);\n\t\t\tfree(m->mimeArguments[offset]);\n\t\t\tm->mimeArguments[offset] = NULL;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * This is terribly broken from an RFC point of view but is useful\n\t * for catching viruses which have a filename but no type of\n\t * mime. By pretending defaulting to an application rather than\n\t * to nomime we can ensure they're saved and scanned\n\t */\n\tif((strncasecmp(p, \"filename=\", 9) == 0) || (strncasecmp(p, \"name=\", 5) == 0))\n\t\tif(messageGetMimeType(m) == NOMIME) {\n\t\t\tcli_dbgmsg(\"Force mime encoding to application\\n\");\n\t\t\tmessageSetMimeType(m, \"application\");\n\t\t}\n}", "target": 1, "idx": 9789}
{"commit_id": "5c9b08a875b07853be6c44e43ff5f7f059df666a", "project": "poppler", "func": "int main (int argc, char *argv[])\n///////////////////////////////////////////////////////////////////////////\n// Merge PDF files given by arguments 1 to argc-2 and write the result\n// to the file specified by argument argc-1.\n///////////////////////////////////////////////////////////////////////////\n{\n  int objectsCount = 0;\n  Guint numOffset = 0;\n  std::vector<Object> pages;\n  std::vector<Guint> offsets;\n  XRef *yRef, *countRef;\n  FILE *f;\n  OutStream *outStr;\n  int i;\n  int j, rootNum;\n  std::vector<PDFDoc *>docs;\n  int majorVersion = 0;\n  int minorVersion = 0;\n  char *fileName = argv[argc - 1];\n  int exitCode;\n\n  exitCode = 99;\n  const GBool ok = parseArgs (argDesc, &argc, argv);\n  if (!ok || argc < 3 || printVersion || printHelp) {\n    fprintf(stderr, \"pdfunite version %s\\n\", PACKAGE_VERSION);\n    fprintf(stderr, \"%s\\n\", popplerCopyright);\n    fprintf(stderr, \"%s\\n\", xpdfCopyright);\n    if (!printVersion) {\n      printUsage(\"pdfunite\", \"<PDF-sourcefile-1>..<PDF-sourcefile-n> <PDF-destfile>\",\n\targDesc);\n    }\n    if (printVersion || printHelp)\n      exitCode = 0;\n    return exitCode;\n  }\n  exitCode = 0;\n  globalParams = new GlobalParams();\n\n  for (i = 1; i < argc - 1; i++) {\n    GooString *gfileName = new GooString(argv[i]);\n    PDFDoc *doc = new PDFDoc(gfileName, NULL, NULL, NULL);\n    if (doc->isOk() && !doc->isEncrypted()) {\n      docs.push_back(doc);\n      if (doc->getPDFMajorVersion() > majorVersion) {\n        majorVersion = doc->getPDFMajorVersion();\n        minorVersion = doc->getPDFMinorVersion();\n      } else if (doc->getPDFMajorVersion() == majorVersion) {\n        if (doc->getPDFMinorVersion() > minorVersion) {\n          minorVersion = doc->getPDFMinorVersion();\n        }\n      }\n    } else if (doc->isOk()) {\n      error(errUnimplemented, -1, \"Could not merge encrypted files ('{0:s}')\", argv[i]);\n      return -1;\n    } else {\n      error(errSyntaxError, -1, \"Could not merge damaged documents ('{0:s}')\", argv[i]);\n      return -1;\n    }\n  }\n\n  if (!(f = fopen(fileName, \"wb\"))) {\n    error(errIO, -1, \"Could not open file '{0:s}'\", fileName);\n    return -1;\n  }\n  outStr = new FileOutStream(f, 0);\n\n  yRef = new XRef();\n  countRef = new XRef();\n  yRef->add(0, 65535, 0, gFalse);\n  PDFDoc::writeHeader(outStr, majorVersion, minorVersion);\n\n  // handle OutputIntents, AcroForm, OCProperties & Names\n  Object intents;\n  Object afObj;\n  Object ocObj;\n  Object names;\n  if (docs.size() >= 1) {\n    Object catObj;\n    docs[0]->getXRef()->getCatalog(&catObj);\n    Dict *catDict = catObj.getDict();\n    catDict->lookup(\"OutputIntents\", &intents);\n    catDict->lookupNF(\"AcroForm\", &afObj);\n    Ref *refPage = docs[0]->getCatalog()->getPageRef(1);\n    if (!afObj.isNull() && refPage) {\n      docs[0]->markAcroForm(&afObj, yRef, countRef, 0, refPage->num, refPage->num);\n    }\n    catDict->lookupNF(\"OCProperties\", &ocObj);\n    if (!ocObj.isNull() && ocObj.isDict() && refPage) {\n      docs[0]->markPageObjects(ocObj.getDict(), yRef, countRef, 0, refPage->num, refPage->num);\n    }\n    catDict->lookup(\"Names\", &names);\n    if (!names.isNull() && names.isDict() && refPage) {\n      docs[0]->markPageObjects(names.getDict(), yRef, countRef, 0, refPage->num, refPage->num);\n    }\n    if (intents.isArray() && intents.arrayGetLength() > 0) {\n      for (i = 1; i < (int) docs.size(); i++) {\n        Object pagecatObj, pageintents;\n        docs[i]->getXRef()->getCatalog(&pagecatObj);\n        Dict *pagecatDict = pagecatObj.getDict();\n        pagecatDict->lookup(\"OutputIntents\", &pageintents);\n        if (pageintents.isArray() && pageintents.arrayGetLength() > 0) {\n          for (j = intents.arrayGetLength() - 1; j >= 0; j--) {\n            Object intent;\n            intents.arrayGet(j, &intent, 0);\n            if (intent.isDict()) {\n              Object idf;\n              intent.dictLookup(\"OutputConditionIdentifier\", &idf);\n              if (idf.isString()) {\n                GooString *gidf = idf.getString();\n                GBool removeIntent = gTrue;\n                for (int k = 0; k < pageintents.arrayGetLength(); k++) {\n                  Object pgintent;\n                  pageintents.arrayGet(k, &pgintent, 0);\n                  if (pgintent.isDict()) {\n                    Object pgidf;\n                    pgintent.dictLookup(\"OutputConditionIdentifier\", &pgidf);\n                    if (pgidf.isString()) {\n                      GooString *gpgidf = pgidf.getString();\n                      if (gpgidf->cmp(gidf) == 0) {\n                        pgidf.free();\n                        removeIntent = gFalse;\n                        break;\n                      }\n                    }\n                    pgidf.free();\n                  }\n                }\n                if (removeIntent) {\n                  intents.arrayRemove(j);\n                  error(errSyntaxWarning, -1, \"Output intent {0:s} missing in pdf {1:s}, removed\",\n                   gidf->getCString(), docs[i]->getFileName()->getCString());\n                }\n              } else {\n                intents.arrayRemove(j);\n                error(errSyntaxWarning, -1, \"Invalid output intent dict, missing required OutputConditionIdentifier\");\n              }\n              idf.free();\n            } else {\n              intents.arrayRemove(j);\n            }\n            intent.free();\n          }\n        } else {\n          error(errSyntaxWarning, -1, \"Output intents differs, remove them all\");\n          intents.free();\n          break;\n        }\n        pagecatObj.free();\n        pageintents.free();\n      }\n    }\n    if (intents.isArray() && intents.arrayGetLength() > 0) {\n      for (j = intents.arrayGetLength() - 1; j >= 0; j--) {\n        Object intent;\n        intents.arrayGet(j, &intent, 0);\n        if (intent.isDict()) {\n          docs[0]->markPageObjects(intent.getDict(), yRef, countRef, numOffset, 0, 0);\n        } else {\n          intents.arrayRemove(j);\n        }\n        intent.free();\n      }\n    }\n    catObj.free();\n  }\n\n  for (i = 0; i < (int) docs.size(); i++) {\n    for (j = 1; j <= docs[i]->getNumPages(); j++) {\n      if (!docs[i]->getCatalog()->getPage(j)) {\n        continue;\n      }\n\n      PDFRectangle *cropBox = NULL;\n      if (docs[i]->getCatalog()->getPage(j)->isCropped())\n        cropBox = docs[i]->getCatalog()->getPage(j)->getCropBox();\n      docs[i]->replacePageDict(j,\n\t    docs[i]->getCatalog()->getPage(j)->getRotate(),\n\t    docs[i]->getCatalog()->getPage(j)->getMediaBox(), cropBox);\n      Ref *refPage = docs[i]->getCatalog()->getPageRef(j);\n      Object page;\n      docs[i]->getXRef()->fetch(refPage->num, refPage->gen, &page);\n      Dict *pageDict = page.getDict();\n      Dict *resDict = docs[i]->getCatalog()->getPage(j)->getResourceDict();\n      if (resDict) {\n        Object *newResource = new Object();\n        newResource->initDict(resDict);\n        pageDict->set(\"Resources\", newResource);\n        delete newResource;\n      }\n      pages.push_back(page);\n      offsets.push_back(numOffset);\n      docs[i]->markPageObjects(pageDict, yRef, countRef, numOffset, refPage->num, refPage->num);\n      Object annotsObj;\n      pageDict->lookupNF(\"Annots\", &annotsObj);\n      if (!annotsObj.isNull()) {\n        docs[i]->markAnnotations(&annotsObj, yRef, countRef, numOffset, refPage->num, refPage->num);\n        annotsObj.free();\n      }\n    }\n    Object pageCatObj, pageNames, pageForm;\n    docs[i]->getXRef()->getCatalog(&pageCatObj);\n    Dict *pageCatDict = pageCatObj.getDict();\n    pageCatDict->lookup(\"Names\", &pageNames);\n    if (!pageNames.isNull() && pageNames.isDict()) {\n      if (!names.isDict()) {\n        names.free();\n        names.initDict(yRef);\n      }\n      doMergeNameDict(docs[i], yRef, countRef, 0, 0, names.getDict(), pageNames.getDict(), numOffset);\n    }\n    pageCatDict->lookup(\"AcroForm\", &pageForm);\n    if (i > 0 && !pageForm.isNull() && pageForm.isDict()) {\n      if (afObj.isNull()) {\n        pageCatDict->lookupNF(\"AcroForm\", &afObj);\n      } else if (afObj.isDict()) {\n        doMergeFormDict(afObj.getDict(), pageForm.getDict(), numOffset);\n      }\n    }\n    pageForm.free();\n    pageNames.free();\n    pageCatObj.free();\n    objectsCount += docs[i]->writePageObjects(outStr, yRef, numOffset, gTrue);\n    numOffset = yRef->getNumObjects() + 1;\n  }\n\n  rootNum = yRef->getNumObjects() + 1;\n  yRef->add(rootNum, 0, outStr->getPos(), gTrue);\n  outStr->printf(\"%d 0 obj\\n\", rootNum);\n  outStr->printf(\"<< /Type /Catalog /Pages %d 0 R\", rootNum + 1);\n  // insert OutputIntents\n  if (intents.isArray() && intents.arrayGetLength() > 0) {\n    outStr->printf(\" /OutputIntents [\");\n    for (j = 0; j < intents.arrayGetLength(); j++) {\n      Object intent;\n      intents.arrayGet(j, &intent, 0);\n      if (intent.isDict()) {\n        PDFDoc::writeObject(&intent, outStr, yRef, 0, NULL, cryptRC4, 0, 0, 0);\n      }\n      intent.free();\n    }\n    outStr->printf(\"]\");\n  }\n  intents.free();\n  // insert AcroForm\n  if (!afObj.isNull()) {\n    outStr->printf(\" /AcroForm \");\n    PDFDoc::writeObject(&afObj, outStr, yRef, 0, NULL, cryptRC4, 0, 0, 0);\n    afObj.free();\n  }\n  // insert OCProperties\n  if (!ocObj.isNull() && ocObj.isDict()) {\n    outStr->printf(\" /OCProperties \");\n    PDFDoc::writeObject(&ocObj, outStr, yRef, 0, NULL, cryptRC4, 0, 0, 0);\n    ocObj.free();\n  }\n  // insert Names\n  if (!names.isNull() && names.isDict()) {\n    outStr->printf(\" /Names \");\n    PDFDoc::writeObject(&names, outStr, yRef, 0, NULL, cryptRC4, 0, 0, 0);\n    names.free();\n  }\n  outStr->printf(\">>\\nendobj\\n\");\n  objectsCount++;\n\n  yRef->add(rootNum + 1, 0, outStr->getPos(), gTrue);\n  outStr->printf(\"%d 0 obj\\n\", rootNum + 1);\n  outStr->printf(\"<< /Type /Pages /Kids [\");\n  for (j = 0; j < (int) pages.size(); j++)\n    outStr->printf(\" %d 0 R\", rootNum + j + 2);\n  outStr->printf(\" ] /Count %zd >>\\nendobj\\n\", pages.size());\n  objectsCount++;\n\n  for (i = 0; i < (int) pages.size(); i++) {\n    yRef->add(rootNum + i + 2, 0, outStr->getPos(), gTrue);\n    outStr->printf(\"%d 0 obj\\n\", rootNum + i + 2);\n    outStr->printf(\"<< \");\n    Dict *pageDict = pages[i].getDict();\n    for (j = 0; j < pageDict->getLength(); j++) {\n      if (j > 0)\n\toutStr->printf(\" \");\n      const char *key = pageDict->getKey(j);\n      Object value;\n      pageDict->getValNF(j, &value);\n      if (strcmp(key, \"Parent\") == 0) {\n        outStr->printf(\"/Parent %d 0 R\", rootNum + 1);\n      } else {\n        outStr->printf(\"/%s \", key);\n        PDFDoc::writeObject(&value, outStr, yRef, offsets[i], NULL, cryptRC4, 0, 0, 0);\n      }\n      value.free();\n    }\n    outStr->printf(\" >>\\nendobj\\n\");\n    objectsCount++;\n  }\n  Goffset uxrefOffset = outStr->getPos();\n  Ref ref;\n  ref.num = rootNum;\n  ref.gen = 0;\n  Dict *trailerDict = PDFDoc::createTrailerDict(objectsCount, gFalse, 0, &ref, yRef,\n                                                fileName, outStr->getPos());\n  PDFDoc::writeXRefTableTrailer(trailerDict, yRef, gTrue, // write all entries according to ISO 32000-1, 7.5.4 Cross-Reference Table: \"For a file that has never been incrementally updated, the cross-reference section shall contain only one subsection, whose object numbering begins at 0.\"\n                                uxrefOffset, outStr, yRef);\n  delete trailerDict;\n\n  outStr->close();\n  delete outStr;\n  fclose(f);\n  delete yRef;\n  delete countRef;\n  for (j = 0; j < (int) pages.size (); j++) pages[j].free();\n  for (i = 0; i < (int) docs.size (); i++) delete docs[i];\n  delete globalParams;\n  return exitCode;\n}", "target": 1, "idx": 9790}
{"commit_id": "7ffda4e809dec74449ebc330cebb9d2f4ab61360", "project": "envoyproxy/envoy", "func": "void OAuth2Filter::finishFlow() {\n  std::string token_payload;\n  if (config_->forwardBearerToken()) {\n    token_payload = absl::StrCat(host_, new_expires_, access_token_, id_token_, refresh_token_);\n  } else {\n    token_payload = absl::StrCat(host_, new_expires_);\n  }\n\n  auto& crypto_util = Envoy::Common::Crypto::UtilitySingleton::get();\n\n  auto token_secret = config_->tokenSecret();\n  std::vector<uint8_t> token_secret_vec(token_secret.begin(), token_secret.end());\n  const std::string pre_encoded_token =\n      Hex::encode(crypto_util.getSha256Hmac(token_secret_vec, token_payload));\n  std::string encoded_token;\n  absl::Base64Escape(pre_encoded_token, &encoded_token);\n\n  // We use HTTP Only cookies for the HMAC and Expiry.\n  const std::string cookie_tail = fmt::format(CookieTailFormatString, new_expires_);\n  const std::string cookie_tail_http_only =\n      fmt::format(CookieTailHttpOnlyFormatString, new_expires_);\n\n  // At this point we have all of the pieces needed to authorize a user.\n  // Now, we construct a redirect request to return the user to their\n  // previous state and additionally set the OAuth cookies in browser.\n  // The redirection should result in successfully passing this filter.\n  Http::ResponseHeaderMapPtr response_headers{Http::createHeaderMap<Http::ResponseHeaderMapImpl>(\n      {{Http::Headers::get().Status, std::to_string(enumToInt(Http::Code::Found))}})};\n\n  const CookieNames& cookie_names = config_->cookieNames();\n\n  response_headers->addReferenceKey(\n      Http::Headers::get().SetCookie,\n      absl::StrCat(cookie_names.oauth_hmac_, \"=\", encoded_token, cookie_tail_http_only));\n  response_headers->addReferenceKey(\n      Http::Headers::get().SetCookie,\n      absl::StrCat(cookie_names.oauth_expires_, \"=\", new_expires_, cookie_tail_http_only));\n\n  // If opted-in, we also create a new Bearer cookie for the authorization token provided by the\n  // auth server.\n  if (config_->forwardBearerToken()) {\n    response_headers->addReferenceKey(\n        Http::Headers::get().SetCookie,\n        absl::StrCat(cookie_names.bearer_token_, \"=\", access_token_, cookie_tail));\n    if (id_token_ != EMPTY_STRING) {\n      response_headers->addReferenceKey(Http::Headers::get().SetCookie,\n                                        absl::StrCat(\"IdToken=\", id_token_, cookie_tail));\n    }\n\n    if (refresh_token_ != EMPTY_STRING) {\n      response_headers->addReferenceKey(Http::Headers::get().SetCookie,\n                                        absl::StrCat(\"RefreshToken=\", refresh_token_, cookie_tail));\n    }\n  }\n\n  response_headers->setLocation(state_);\n\n  decoder_callbacks_->encodeHeaders(std::move(response_headers), true, REDIRECT_LOGGED_IN);\n  config_->stats().oauth_success_.inc();\n}", "target": 3, "idx": 9791}
{"commit_id": "71a1516b0376340d267caa85920cb0a4da261176", "project": "open5gs", "func": "static void pfcp_recv_cb(short when, ogs_socket_t fd, void *data)\n{\n    int rv;\n\n    ssize_t size;\n    sgwc_event_t *e = NULL;\n    ogs_pkbuf_t *pkbuf = NULL;\n    ogs_sockaddr_t from;\n    ogs_pfcp_node_t *node = NULL;\n    ogs_pfcp_header_t *h = NULL;\n\n    ogs_assert(fd != INVALID_SOCKET);\n\n    pkbuf = ogs_pkbuf_alloc(NULL, OGS_MAX_SDU_LEN);\n    ogs_assert(pkbuf);\n    ogs_pkbuf_put(pkbuf, OGS_MAX_SDU_LEN);\n\n    size = ogs_recvfrom(fd, pkbuf->data, pkbuf->len, 0, &from);\n    if (size <= 0) {\n        ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                \"ogs_recvfrom() failed\");\n        ogs_pkbuf_free(pkbuf);\n        return;\n    }\n\n    ogs_pkbuf_trim(pkbuf, size);\n\n    h = (ogs_pfcp_header_t *)pkbuf->data;\n    if (h->version != OGS_PFCP_VERSION) {\n        ogs_pfcp_header_t rsp;\n\n        ogs_error(\"Not supported version[%d]\", h->version);\n\n        memset(&rsp, 0, sizeof rsp);\n        rsp.flags = (OGS_PFCP_VERSION << 5);\n        rsp.type = OGS_PFCP_VERSION_NOT_SUPPORTED_RESPONSE_TYPE;\n        rsp.length = htobe16(4);\n        rsp.sqn_only = h->sqn_only;\n        if (ogs_sendto(fd, &rsp, 8, 0, &from) < 0) {\n            ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                    \"ogs_sendto() failed\");\n        }\n        ogs_pkbuf_free(pkbuf);\n\n        return;\n    }\n\n    e = sgwc_event_new(SGWC_EVT_SXA_MESSAGE);\n    ogs_assert(e);\n\n    node = ogs_pfcp_node_find(&ogs_pfcp_self()->pfcp_peer_list, &from);\n    if (!node) {\n        node = ogs_pfcp_node_add(&ogs_pfcp_self()->pfcp_peer_list, &from);\n        ogs_assert(node);\n\n        node->sock = data;\n        pfcp_node_fsm_init(node, false);\n    }\n    e->pfcp_node = node;\n    e->pkbuf = pkbuf;\n\n    rv = ogs_queue_push(ogs_app()->queue, e);\n    if (rv != OGS_OK) {\n        ogs_error(\"ogs_queue_push() failed:%d\", (int)rv);\n        ogs_pkbuf_free(e->pkbuf);\n        sgwc_event_free(e);\n    }\n}", "target": 2, "idx": 9792}
{"commit_id": "8c17c272184f0227e8bd42c2a7d62d5683a466a8", "project": "mate-desktop/mate-screensaver", "func": "static void\ngs_manager_destroy_windows (GSManager *manager)\n{\n\tGdkDisplay  *display;\n\tGSList      *l;\n\n\tg_return_if_fail (manager != NULL);\n\tg_return_if_fail (GS_IS_MANAGER (manager));\n\n\tif (manager->priv->windows == NULL)\n\t{\n\t\treturn;\n\t}\n\n\tdisplay = gdk_display_get_default ();\n\n\tg_signal_handlers_disconnect_by_func (display,\n\t                                      on_display_monitor_removed,\n\t                                      manager);\n\tg_signal_handlers_disconnect_by_func (display,\n\t                                      on_display_monitor_added,\n\t                                      manager);\n\n\tfor (l = manager->priv->windows; l; l = l->next)\n\t{\n\t\tgs_window_destroy (l->data);\n\t}\n\tg_slist_free (manager->priv->windows);\n\tmanager->priv->windows = NULL;\n}", "target": 1, "idx": 9793}
{"commit_id": "faa1ec748bed88bce0e61f3149e82b4661ab761c", "project": "netblue30/firejail", "func": "void shut(pid_t pid) {\n\tEUID_ASSERT();\n\n\tEUID_ROOT();\n\tchar *comm = pid_proc_comm(pid);\n\tEUID_USER();\n\tif (comm) {\n\t\tif (strcmp(comm, \"firejail\") != 0) {\n\t\t\tfprintf(stderr, \"Error: this is not a firejail sandbox\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tfree(comm);\n\t}\n\telse\n\t\terrExit(\"/proc/PID/comm\");\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission is denied to shutdown a sandbox created by a different user.\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tprintf(\"Sending SIGTERM to %u\\n\", pid);\n\tkill(pid, SIGTERM);\n\n\t// wait for not more than 11 seconds\n\tint monsec = 11;\n\tchar *monfile;\n\tif (asprintf(&monfile, \"/proc/%d/cmdline\", pid) == -1)\n\t\terrExit(\"asprintf\");\n\tint killdone = 0;\n\n\twhile (monsec) {\n\t\tsleep(1);\n\t\tmonsec--;\n\n\t\tFILE *fp = fopen(monfile, \"r\");\n\t\tif (!fp) {\n\t\t\tkilldone = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tchar c;\n\t\tsize_t count = fread(&c, 1, 1, fp);\n\t\tfclose(fp);\n\t\tif (count == 0) {\n\t\t\t// all done\n\t\t\tkilldone = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree(monfile);\n\n\n\t// force SIGKILL\n\tif (!killdone) {\n\t\t// kill the process and its child\n\t\tpid_t child;\n\t\tif (find_child(pid, &child) == 0) {\n\t\t\tprintf(\"Sending SIGKILL to %u\\n\", child);\n\t\t\tkill(child, SIGKILL);\n\t\t}\n\t\tprintf(\"Sending SIGKILL to %u\\n\", pid);\n\t\tkill(pid, SIGKILL);\n\t}\n\n\tEUID_ROOT();\n\tdelete_run_files(pid);\n}", "target": 2, "idx": 9794}
{"commit_id": "687cb0884a714ff484d038e9190edc874edcf146", "project": "torvalds/linux", "func": "static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)\n{\n\tstruct mmu_gather tlb;\n\tstruct vm_area_struct *vma;\n\tbool ret = true;\n\n\t/*\n\t * We have to make sure to not race with the victim exit path\n\t * and cause premature new oom victim selection:\n\t * __oom_reap_task_mm\t\texit_mm\n\t *   mmget_not_zero\n\t *\t\t\t\t  mmput\n\t *\t\t\t\t    atomic_dec_and_test\n\t *\t\t\t\t  exit_oom_victim\n\t *\t\t\t\t[...]\n\t *\t\t\t\tout_of_memory\n\t *\t\t\t\t  select_bad_process\n\t *\t\t\t\t    # no TIF_MEMDIE task selects new victim\n\t *  unmap_page_range # frees some memory\n\t */\n\tmutex_lock(&oom_lock);\n\n\tif (!down_read_trylock(&mm->mmap_sem)) {\n\t\tret = false;\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\tgoto unlock_oom;\n\t}\n\n\t/*\n\t * If the mm has notifiers then we would need to invalidate them around\n\t * unmap_page_range and that is risky because notifiers can sleep and\n\t * what they do is basically undeterministic.  So let's have a short\n\t * sleep to give the oom victim some more time.\n\t * TODO: we really want to get rid of this ugly hack and make sure that\n\t * notifiers cannot block for unbounded amount of time and add\n\t * mmu_notifier_invalidate_range_{start,end} around unmap_page_range\n\t */\n\tif (mm_has_notifiers(mm)) {\n\t\tup_read(&mm->mmap_sem);\n\t\tschedule_timeout_idle(HZ);\n\t\tgoto unlock_oom;\n\t}\n\n\t/*\n\t * MMF_OOM_SKIP is set by exit_mmap when the OOM reaper can't\n\t * work on the mm anymore. The check for MMF_OOM_SKIP must run\n\t * under mmap_sem for reading because it serializes against the\n\t * down_write();up_write() cycle in exit_mmap().\n\t */\n\tif (test_bit(MMF_OOM_SKIP, &mm->flags)) {\n\t\tup_read(&mm->mmap_sem);\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\tgoto unlock_oom;\n\t}\n\n\ttrace_start_task_reaping(tsk->pid);\n\n\t/*\n\t * Tell all users of get_user/copy_from_user etc... that the content\n\t * is no longer stable. No barriers really needed because unmapping\n\t * should imply barriers already and the reader would hit a page fault\n\t * if it stumbled over a reaped memory.\n\t */\n\tset_bit(MMF_UNSTABLE, &mm->flags);\n\n\tfor (vma = mm->mmap ; vma; vma = vma->vm_next) {\n\t\tif (!can_madv_dontneed_vma(vma))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Only anonymous pages have a good chance to be dropped\n\t\t * without additional steps which we cannot afford as we\n\t\t * are OOM already.\n\t\t *\n\t\t * We do not even care about fs backed pages because all\n\t\t * which are reclaimable have already been reclaimed and\n\t\t * we do not want to block exit_mmap by keeping mm ref\n\t\t * count elevated without a good reason.\n\t\t */\n\t\tif (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED)) {\n\t\t\ttlb_gather_mmu(&tlb, mm, vma->vm_start, vma->vm_end);\n\t\t\tunmap_page_range(&tlb, vma, vma->vm_start, vma->vm_end,\n\t\t\t\t\t NULL);\n\t\t\ttlb_finish_mmu(&tlb, vma->vm_start, vma->vm_end);\n\t\t}\n\t}\n\tpr_info(\"oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\",\n\t\t\ttask_pid_nr(tsk), tsk->comm,\n\t\t\tK(get_mm_counter(mm, MM_ANONPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_FILEPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_SHMEMPAGES)));\n\tup_read(&mm->mmap_sem);\n\n\ttrace_finish_task_reaping(tsk->pid);\nunlock_oom:\n\tmutex_unlock(&oom_lock);\n\treturn ret;\n}", "target": 2, "idx": 9795}
{"commit_id": "beba892bc0d4e4ded4d667ab1d2a94f4d75109a9", "project": "libtom/libtommath", "func": "mp_err mp_mul_2d(const mp_int *a, int b, mp_int *c)\n{\n   mp_digit d;\n   mp_err   err;\n\n   if (b < 0) {\n      return MP_VAL;\n   }\n\n   /* copy */\n   if (a != c) {\n      if ((err = mp_copy(a, c)) != MP_OKAY) {\n         return err;\n      }\n   }\n\n   if (c->alloc < (c->used + (b / MP_DIGIT_BIT) + 1)) {\n      if ((err = mp_grow(c, c->used + (b / MP_DIGIT_BIT) + 1)) != MP_OKAY) {\n         return err;\n      }\n   }\n\n   /* shift by as many digits in the bit count */\n   if (b >= MP_DIGIT_BIT) {\n      if ((err = mp_lshd(c, b / MP_DIGIT_BIT)) != MP_OKAY) {\n         return err;\n      }\n   }\n\n   /* shift any bit count < MP_DIGIT_BIT */\n   d = (mp_digit)(b % MP_DIGIT_BIT);\n   if (d != 0u) {\n      mp_digit *tmpc, shift, mask, r, rr;\n      int x;\n\n      /* bitmask for carries */\n      mask = ((mp_digit)1 << d) - (mp_digit)1;\n\n      /* shift for msbs */\n      shift = (mp_digit)MP_DIGIT_BIT - d;\n\n      /* alias */\n      tmpc = c->dp;\n\n      /* carry */\n      r    = 0;\n      for (x = 0; x < c->used; x++) {\n         /* get the higher bits of the current word */\n         rr = (*tmpc >> shift) & mask;\n\n         /* shift the current word and OR in the carry */\n         *tmpc = ((*tmpc << d) | r) & MP_MASK;\n         ++tmpc;\n\n         /* set the carry to the carry bits of the current word */\n         r = rr;\n      }\n\n      /* set final carry */\n      if (r != 0u) {\n         c->dp[(c->used)++] = r;\n      }\n   }\n   mp_clamp(c);\n   return MP_OKAY;\n}", "target": 3, "idx": 9796}
{"commit_id": "ff70494dd389ba570dbdbf36f217c28d4381c6b5", "project": "aircrack-ng", "func": "void gps_tracker( void )\n{\n\tssize_t unused;\n    int gpsd_sock;\n    char line[256], *temp;\n    struct sockaddr_in gpsd_addr;\n    int ret, is_json, pos;\n    fd_set read_fd;\n    struct timeval timeout;\n\n    /* attempt to connect to localhost, port 2947 */\n\n    pos = 0;\n    gpsd_sock = socket( AF_INET, SOCK_STREAM, 0 );\n\n    if( gpsd_sock < 0 ) {\n        return;\n    }\n\n    gpsd_addr.sin_family      = AF_INET;\n    gpsd_addr.sin_port        = htons( 2947 );\n    gpsd_addr.sin_addr.s_addr = inet_addr( \"127.0.0.1\" );\n\n    if( connect( gpsd_sock, (struct sockaddr *) &gpsd_addr,\n                 sizeof( gpsd_addr ) ) < 0 ) {\n        return;\n    }\n\n    // Check if it's GPSd < 2.92 or the new one\n    // 2.92+ immediately send stuff\n    // < 2.92 requires to send PVTAD command\n    FD_ZERO(&read_fd);\n    FD_SET(gpsd_sock, &read_fd);\n    timeout.tv_sec = 1;\n    timeout.tv_usec = 0;\n    is_json = select(gpsd_sock + 1, &read_fd, NULL, NULL, &timeout);\n    if (is_json) {\n    \t/*\n\t\t\t{\"class\":\"VERSION\",\"release\":\"2.95\",\"rev\":\"2010-11-16T21:12:35\",\"proto_major\":3,\"proto_minor\":3}\n\t\t\t?WATCH={\"json\":true};\n\t\t\t{\"class\":\"DEVICES\",\"devices\":[]}\n    \t */\n\n\n    \t// Get the crap and ignore it: {\"class\":\"VERSION\",\"release\":\"2.95\",\"rev\":\"2010-11-16T21:12:35\",\"proto_major\":3,\"proto_minor\":3}\n    \tif( recv( gpsd_sock, line, sizeof( line ) - 1, 0 ) <= 0 )\n    \t\treturn;\n\n    \tis_json = (line[0] == '{');\n    \tif (is_json) {\n\t\t\t// Send ?WATCH={\"json\":true};\n\t\t\tmemset( line, 0, sizeof( line ) );\n\t\t\tstrcpy(line, \"?WATCH={\\\"json\\\":true};\\n\");\n\t\t\tif( send( gpsd_sock, line, 22, 0 ) != 22 )\n\t\t\t\treturn;\n\n\t\t\t// Check that we have devices\n\t\t\tmemset(line, 0, sizeof(line));\n\t\t\tif( recv( gpsd_sock, line, sizeof( line ) - 1, 0 ) <= 0 )\n\t\t\t\treturn;\n\n\t\t\t// Stop processing if there is no device\n\t\t\tif (strncmp(line, \"{\\\"class\\\":\\\"DEVICES\\\",\\\"devices\\\":[]}\", 32) == 0) {\n\t\t\t\tclose(gpsd_sock);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tpos = strlen(line);\n\t\t\t}\n    \t}\n    }\n\n    /* loop reading the GPS coordinates */\n\n    while( G.do_exit == 0 )\n    {\n        usleep( 500000 );\n        memset( G.gps_loc, 0, sizeof( float ) * 5 );\n\n        /* read position, speed, heading, altitude */\n        if (is_json) {\n        \t// Format definition: http://catb.org/gpsd/gpsd_json.html\n\n        \tif (pos == sizeof( line )) {\n        \t\tmemset(line, 0, sizeof(line));\n        \t\tpos = 0;\n        \t}\n\n        \t// New version, JSON\n        \tif( recv( gpsd_sock, line + pos, sizeof( line ) - pos - 1, 0 ) <= 0 )\n        \t\treturn;\n\n        \t// search for TPV class: {\"class\":\"TPV\"\n        \ttemp = strstr(line, \"{\\\"class\\\":\\\"TPV\\\"\");\n        \tif (temp == NULL) {\n        \t\tcontinue;\n        \t}\n\n        \t// Make sure the data we have is complete\n        \tif (strchr(temp, '}') == NULL) {\n        \t\t// Move the data at the beginning of the buffer;\n        \t\tpos = strlen(temp);\n        \t\tif (temp != line) {\n        \t\t\tmemmove(line, temp, pos);\n        \t\t\tmemset(line + pos, 0, sizeof(line) - pos);\n        \t\t}\n        \t}\n\n\t\t\t// Example line: {\"class\":\"TPV\",\"tag\":\"MID2\",\"device\":\"/dev/ttyUSB0\",\"time\":1350957517.000,\"ept\":0.005,\"lat\":46.878936576,\"lon\":-115.832602964,\"alt\":1968.382,\"track\":0.0000,\"speed\":0.000,\"climb\":0.000,\"mode\":3}\n\n        \t// Latitude\n        \ttemp = strstr(temp, \"\\\"lat\\\":\");\n\t\t\tif (temp == NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = sscanf(temp + 6, \"%f\", &G.gps_loc[0]);\n\n\t\t\t// Longitude\n\t\t\ttemp = strstr(temp, \"\\\"lon\\\":\");\n\t\t\tif (temp == NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = sscanf(temp + 6, \"%f\", &G.gps_loc[1]);\n\n\t\t\t// Altitude\n\t\t\ttemp = strstr(temp, \"\\\"alt\\\":\");\n\t\t\tif (temp == NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = sscanf(temp + 6, \"%f\", &G.gps_loc[4]);\n\n\t\t\t// Speed\n\t\t\ttemp = strstr(temp, \"\\\"speed\\\":\");\n\t\t\tif (temp == NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = sscanf(temp + 6, \"%f\", &G.gps_loc[2]);\n\n\t\t\t// No more heading\n\n\t\t\t// Get the next TPV class\n\t\t\ttemp = strstr(temp, \"{\\\"class\\\":\\\"TPV\\\"\");\n\t\t\tif (temp == NULL) {\n\t\t\t\tmemset( line, 0, sizeof( line ) );\n\t\t\t\tpos = 0;\n\t\t\t} else {\n\t\t\t\tpos = strlen(temp);\n\t\t\t\tmemmove(line, temp, pos);\n\t\t\t\tmemset(line + pos, 0, sizeof(line) - pos);\n\t\t\t}\n\n        } else {\n        \tmemset( line, 0, sizeof( line ) );\n\n\t\t\tsnprintf( line,  sizeof( line ) - 1, \"PVTAD\\r\\n\" );\n\t\t\tif( send( gpsd_sock, line, 7, 0 ) != 7 )\n\t\t\t\treturn;\n\n\t\t\tmemset( line, 0, sizeof( line ) );\n\t\t\tif( recv( gpsd_sock, line, sizeof( line ) - 1, 0 ) <= 0 )\n\t\t\t\treturn;\n\n\t\t\tif( memcmp( line, \"GPSD,P=\", 7 ) != 0 )\n\t\t\t\tcontinue;\n\n\t\t\t/* make sure the coordinates are present */\n\n\t\t\tif( line[7] == '?' )\n\t\t\t\tcontinue;\n\n\t\t\tret = sscanf( line + 7, \"%f %f\", &G.gps_loc[0], &G.gps_loc[1] );\n\n\t\t\tif( ( temp = strstr( line, \"V=\" ) ) == NULL ) continue;\n\t\t\tret = sscanf( temp + 2, \"%f\", &G.gps_loc[2] ); /* speed */\n\n\t\t\tif( ( temp = strstr( line, \"T=\" ) ) == NULL ) continue;\n\t\t\tret = sscanf( temp + 2, \"%f\", &G.gps_loc[3] ); /* heading */\n\n\t\t\tif( ( temp = strstr( line, \"A=\" ) ) == NULL ) continue;\n\t\t\tret = sscanf( temp + 2, \"%f\", &G.gps_loc[4] ); /* altitude */\n        }\n\n        if (G.record_data)\n\t\t\tfputs( line, G.f_gps );\n\n\t\tG.save_gps = 1;\n\n        if (G.do_exit == 0)\n\t\t{\n\t\t\tunused = write( G.gc_pipe[1], G.gps_loc, sizeof( float ) * 5 );\n\t\t\tkill( getppid(), SIGUSR2 );\n\t\t}\n    }\n}", "target": 2, "idx": 9797}
{"commit_id": "637486261528e8aa3da9f26a4487dc254f4b7abb", "project": "systemd", "func": "static void async_polkit_query_free(AsyncPolkitQuery *q) {\n        if (!q)\n                return;\n\n        sd_bus_slot_unref(q->slot);\n\n        if (q->registry && q->request)\n                hashmap_remove(q->registry, q->request);\n\n        sd_bus_message_unref(q->request);\n        sd_bus_message_unref(q->reply);\n\n        free(q->action);\n        strv_free(q->details);\n\n        sd_event_source_disable_unref(q->defer_event_source);\n        free(q);\n}", "target": 2, "idx": 9798}
{"commit_id": "ec9eb22e008a69ea9dc21fdca4b9b836679965ee", "project": "tats/w3m", "func": "void\nformUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form)\n{\n    Buffer save;\n    char *p;\n    int spos, epos, rows, c_rows, pos, col = 0;\n    Line *l;\n\n    copyBuffer(&save, buf);\n    gotoLine(buf, a->start.line);\n    switch (form->type) {\n    case FORM_TEXTAREA:\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n#endif\t\t\t\t/* MENU_SELECT */\n\tspos = a->start.pos;\n\tepos = a->end.pos;\n\tbreak;\n    default:\n\tspos = a->start.pos + 1;\n\tepos = a->end.pos - 1;\n    }\n    switch (form->type) {\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n\tif (form->checked)\n\t    buf->currentLine->lineBuf[spos] = '*';\n\telse\n\t    buf->currentLine->lineBuf[spos] = ' ';\n\tbreak;\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_TEXTAREA:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n\tif (form->type == FORM_SELECT) {\n\t    p = form->label->ptr;\n\t    updateSelectOption(form, form->select_option);\n\t}\n\telse\n#endif\t\t\t\t/* MENU_SELECT */\n\t    if (!form->value)\n\t\tbreak;\n\t    p = form->value->ptr;\n\tl = buf->currentLine;\n\tif (!l)\n\t    break;\n\tif (form->type == FORM_TEXTAREA) {\n\t    int n = a->y - buf->currentLine->linenumber;\n\t    if (n > 0)\n\t\tfor (; l && n; l = l->prev, n--) ;\n\t    else if (n < 0)\n\t\tfor (; l && n; l = l->prev, n++) ;\n\t    if (!l)\n\t\tbreak;\n\t}\n\trows = form->rows ? form->rows : 1;\n\tcol = COLPOS(l, a->start.pos);\n\tfor (c_rows = 0; c_rows < rows; c_rows++, l = l->next) {\n\t    if (rows > 1) {\n\t\tpos = columnPos(l, col);\n\t\ta = retrieveAnchor(buf->formitem, l->linenumber, pos);\n\t\tif (a == NULL)\n\t\t    break;\n\t\tspos = a->start.pos;\n\t\tepos = a->end.pos;\n\t    }\n\t    if (a->start.line != a->end.line || spos > epos || epos >= l->len)\n\t\tbreak;\n\t    pos = form_update_line(l, &p, spos, epos, COLPOS(l, epos) - col,\n\t\t\t\t   rows > 1,\n\t\t\t\t   form->type == FORM_INPUT_PASSWORD);\n\t    if (pos != epos) {\n\t\tshiftAnchorPosition(buf->href, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->name, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->img, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->formitem, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t    }\n\t}\n\tbreak;\n    }\n    copyBuffer(buf, &save);\n    arrangeLine(buf);\n}", "target": 1, "idx": 9799}
{"commit_id": "7245bff300d3fa8bacbef7897ff080a6f1c23eba", "project": "php/php-src", "func": "static int spl_filesystem_file_read_csv(spl_filesystem_object *intern, char delimiter, char enclosure, char escape, zval *return_value TSRMLS_DC) /* {{{ */\n{\n\tint ret = SUCCESS;\n\n\tdo {\n\t\tret = spl_filesystem_file_read(intern, 1 TSRMLS_CC);\n\t} while (ret == SUCCESS && !intern->u.file.current_line_len && SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_SKIP_EMPTY));\n\n\tif (ret == SUCCESS) {\n\t\tsize_t buf_len = intern->u.file.current_line_len;\n\t\tchar *buf = estrndup(intern->u.file.current_line, buf_len);\n\n\t\tif (intern->u.file.current_zval) {\n\t\t\tzval_ptr_dtor(&intern->u.file.current_zval);\n\t\t}\n\t\tALLOC_INIT_ZVAL(intern->u.file.current_zval);\n\n\t\tphp_fgetcsv(intern->u.file.stream, delimiter, enclosure, escape, buf_len, buf, intern->u.file.current_zval TSRMLS_CC);\n\t\tif (return_value) {\n\t\t\tif (Z_TYPE_P(return_value) != IS_NULL) {\n\t\t\t\tzval_dtor(return_value);\n\t\t\t\tZVAL_NULL(return_value);\n\t\t\t}\n\t\t\tZVAL_ZVAL(return_value, intern->u.file.current_zval, 1, 0);\n\t\t}\n\t}\n\treturn ret;\n}", "target": 3, "idx": 9800}
{"commit_id": "1f37c04f2a762500222dda2459e6a04646feeedf", "project": "radareorg/radare2", "func": "static void process_constructors (RBinFile *bf, RList *ret, int bits) {\n\tRList *secs = sections (bf);\n\tRListIter *iter;\n\tRBinSection *sec;\n\tint i, type;\n\tr_list_foreach (secs, iter, sec) {\n\t\ttype = -1;\n\t\tif (!strcmp (sec->name, \".fini_array\")) {\n\t\t\ttype = R_BIN_ENTRY_TYPE_FINI;\n\t\t} else if (!strcmp (sec->name, \".init_array\")) {\n\t\t\ttype = R_BIN_ENTRY_TYPE_INIT;\n\t\t} else if (!strcmp (sec->name, \".preinit_array\")) {\n\t\t\ttype = R_BIN_ENTRY_TYPE_PREINIT;\n\t\t}\n\t\tif (type != -1) {\n\t\t\tut8 *buf = calloc (sec->size, 1);\n\t\t\tif (!buf) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t(void)r_buf_read_at (bf->buf, sec->paddr, buf, sec->size);\n\t\t\tif (bits == 32) {\n\t\t\t\tfor (i = 0; (i + 3) < sec->size; i += 4) {\n\t\t\t\t\tut32 addr32 = r_read_le32 (buf + i);\n\t\t\t\t\tif (addr32) {\n\t\t\t\t\t\tRBinAddr *ba = newEntry (sec->paddr + i, (ut64)addr32, type, bits);\n\t\t\t\t\t\tr_list_append (ret, ba);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (i = 0; (i + 7) < sec->size; i += 8) {\n\t\t\t\t\tut64 addr64 = r_read_le64 (buf + i);\n\t\t\t\t\tif (addr64) {\n\t\t\t\t\t\tRBinAddr *ba = newEntry (sec->paddr + i, addr64, type, bits);\n\t\t\t\t\t\tr_list_append (ret, ba);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree (buf);\n\t\t}\n\t}\n\tr_list_free (secs);\n}", "target": 1, "idx": 9801}
{"commit_id": "86030db849260dd8fb2ed975b9890aef1b62b692", "project": "miniupnp", "func": "static void\nGetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<OutboundPinholeTimeout>%d</OutboundPinholeTimeout>\"\n\t\t\"</u:%sResponse>\";\n\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tchar * int_ip, * int_port, * rem_host, * rem_port, * protocol;\n\tint opt=0;\n\t/*int proto=0;*/\n\tunsigned short iport, rport;\n\n\tif (GETFLAG(IPV6FCFWDISABLEDMASK))\n\t{\n\t\tSoapError(h, 702, \"FirewallDisabled\");\n\t\treturn;\n\t}\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tint_ip = GetValueFromNameValueList(&data, \"InternalClient\");\n\tint_port = GetValueFromNameValueList(&data, \"InternalPort\");\n\trem_host = GetValueFromNameValueList(&data, \"RemoteHost\");\n\trem_port = GetValueFromNameValueList(&data, \"RemotePort\");\n\tprotocol = GetValueFromNameValueList(&data, \"Protocol\");\n\n\tif (!int_port || !rem_port || !protocol)\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n\n\trport = (unsigned short)atoi(rem_port);\n\tiport = (unsigned short)atoi(int_port);\n\t/*proto = atoi(protocol);*/\n\n\tsyslog(LOG_INFO, \"%s: retrieving timeout for outbound pinhole from [%s]:%hu to [%s]:%hu protocol %s\", action, int_ip, iport,rem_host, rport, protocol);\n\n\t/* TODO */\n\tr = -1;/*upnp_check_outbound_pinhole(proto, &opt);*/\n\n\tswitch(r)\n\t{\n\t\tcase 1:\t/* success */\n\t\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t\t                   action, ns/*\"urn:schemas-upnp-org:service:WANIPv6FirewallControl:1\"*/,\n\t\t\t                   opt, action);\n\t\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t\t\tbreak;\n\t\tcase -5:\t/* Protocol not supported */\n\t\t\tSoapError(h, 705, \"ProtocolNotSupported\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tSoapError(h, 501, \"ActionFailed\");\n\t}\n\tClearNameValueList(&data);\n}", "target": 2, "idx": 9802}
{"commit_id": "0c3f5d0e0d9269ad47b8f4b061d7818993913189", "project": "tats/w3m", "func": "void\npush_symbol(Str str, char symbol, int width, int n)\n{\n    char buf[2], *p;\n    int i;\n\n#ifdef USE_M17N\n    if (width == 2)\n\tp = alt2_symbol[(unsigned char)symbol % N_SYMBOL];\n    else\n#endif\n\tp = alt_symbol[(unsigned char)symbol % N_SYMBOL];\n    for (i = 0; i < 2 && *p; i++, p++)\n\tbuf[i] = (*p == ' ') ? NBSP_CODE : *p;\n\n    Strcat(str, Sprintf(\"<_SYMBOL TYPE=%d>\", symbol));\n    for (; n > 0; n--)\n\tStrcat_charp_n(str, buf, i);\n    Strcat_charp(str, \"</_SYMBOL>\");\n}", "target": 1, "idx": 9803}
{"commit_id": "6e6e54f944a5ebb49e9110bdeff844d00a96c56c", "project": "LibreOffice/core", "func": "void ReadJPEG( JPEGReader* pJPEGReader, void* pInputStream, long* pLines,\n               Size const & previewSize )\n{\n    jpeg_decompress_struct cinfo;\n    ErrorManagerStruct jerr;\n\n    if ( setjmp( jerr.setjmp_buffer ) )\n    {\n        jpeg_destroy_decompress( &cinfo );\n        return;\n    }\n\n    cinfo.err = jpeg_std_error( &jerr.pub );\n    jerr.pub.error_exit = errorExit;\n    jerr.pub.output_message = outputMessage;\n\n    jpeg_create_decompress( &cinfo );\n    jpeg_svstream_src( &cinfo, pInputStream );\n    SourceManagerStruct *source = reinterpret_cast<SourceManagerStruct*>(cinfo.src);\n    jpeg_read_header( &cinfo, TRUE );\n\n    cinfo.scale_num = 1;\n    cinfo.scale_denom = 1;\n    cinfo.output_gamma = 1.0;\n    cinfo.raw_data_out = FALSE;\n    cinfo.quantize_colors = FALSE;\n\n    /* change scale for preview import */\n    long nPreviewWidth = previewSize.Width();\n    long nPreviewHeight = previewSize.Height();\n    if( nPreviewWidth || nPreviewHeight )\n    {\n        if( nPreviewWidth == 0 )\n        {\n            nPreviewWidth = ( cinfo.image_width * nPreviewHeight ) / cinfo.image_height;\n            if( nPreviewWidth <= 0 )\n            {\n                nPreviewWidth = 1;\n            }\n        }\n        else if( nPreviewHeight == 0 )\n        {\n            nPreviewHeight = ( cinfo.image_height * nPreviewWidth ) / cinfo.image_width;\n            if( nPreviewHeight <= 0 )\n            {\n                nPreviewHeight = 1;\n            }\n        }\n\n        for( cinfo.scale_denom = 1; cinfo.scale_denom < 8; cinfo.scale_denom *= 2 )\n        {\n            if( cinfo.image_width < nPreviewWidth * cinfo.scale_denom )\n                break;\n            if( cinfo.image_height < nPreviewHeight * cinfo.scale_denom )\n                break;\n        }\n\n        if( cinfo.scale_denom > 1 )\n        {\n            cinfo.dct_method            = JDCT_FASTEST;\n            cinfo.do_fancy_upsampling   = FALSE;\n            cinfo.do_block_smoothing    = FALSE;\n        }\n    }\n\n    jpeg_calc_output_dimensions(&cinfo);\n\n    long nWidth = cinfo.output_width;\n    long nHeight = cinfo.output_height;\n\n    bool bGray = (cinfo.output_components == 1);\n\n    JPEGCreateBitmapParam aCreateBitmapParam;\n\n    aCreateBitmapParam.nWidth = nWidth;\n    aCreateBitmapParam.nHeight = nHeight;\n\n    aCreateBitmapParam.density_unit = cinfo.density_unit;\n    aCreateBitmapParam.X_density = cinfo.X_density;\n    aCreateBitmapParam.Y_density = cinfo.Y_density;\n    aCreateBitmapParam.bGray = bGray;\n\n    bool bBitmapCreated = pJPEGReader->CreateBitmap(aCreateBitmapParam);\n\n    if (bBitmapCreated)\n    {\n        Bitmap::ScopedWriteAccess pAccess(pJPEGReader->GetBitmap());\n\n        if (pAccess)\n        {\n            int nPixelSize = 3;\n            J_COLOR_SPACE best_out_color_space = JCS_RGB;\n            ScanlineFormat eScanlineFormat = ScanlineFormat::N24BitTcRgb;\n            ScanlineFormat eFinalFormat = pAccess->GetScanlineFormat();\n            if (eFinalFormat == ScanlineFormat::N32BitTcBgra)\n            {\n                best_out_color_space = JCS_EXT_BGRA;\n                eScanlineFormat = eFinalFormat;\n                nPixelSize = 4;\n            }\n            else if (eFinalFormat == ScanlineFormat::N32BitTcRgba)\n            {\n                best_out_color_space = JCS_EXT_RGBA;\n                eScanlineFormat = eFinalFormat;\n                nPixelSize = 4;\n            }\n            else if (eFinalFormat == ScanlineFormat::N32BitTcArgb)\n            {\n                best_out_color_space = JCS_EXT_ARGB;\n                eScanlineFormat = eFinalFormat;\n                nPixelSize = 4;\n            }\n\n            if ( cinfo.jpeg_color_space == JCS_YCbCr )\n                cinfo.out_color_space = best_out_color_space;\n            else if ( cinfo.jpeg_color_space == JCS_YCCK )\n                cinfo.out_color_space = JCS_CMYK;\n\n            if (cinfo.out_color_space != JCS_CMYK &&\n                cinfo.out_color_space != JCS_GRAYSCALE &&\n                cinfo.out_color_space != best_out_color_space)\n            {\n                SAL_WARN(\"vcl.filter\", \"jpg with unknown out color space, forcing to :\" << best_out_color_space << \" gray \");\n                cinfo.out_color_space = best_out_color_space;\n            }\n\n            jpeg_start_decompress(&cinfo);\n\n            JSAMPLE* aRangeLimit = cinfo.sample_range_limit;\n\n            std::vector<sal_uInt8> pScanLineBuffer(nWidth * (bGray ? 1 : nPixelSize));\n            std::vector<sal_uInt8> pCYMKBuffer;\n\n            if (cinfo.out_color_space == JCS_CMYK)\n            {\n                pCYMKBuffer.resize(nWidth * 4);\n            }\n\n            std::unique_ptr<BitmapColor[]> pCols;\n\n            if (bGray)\n            {\n                pCols.reset(new BitmapColor[256]);\n\n                for (sal_uInt16 n = 0; n < 256; n++)\n                {\n                    const sal_uInt8 cGray = n;\n                    pCols[n] = pAccess->GetBestMatchingColor(BitmapColor(cGray, cGray, cGray));\n                }\n            }\n\n            for (*pLines = 0; *pLines < nHeight && !source->no_data_available; (*pLines)++)\n            {\n                size_t yIndex = *pLines;\n\n                sal_uInt8* p = (cinfo.out_color_space == JCS_CMYK) ? pCYMKBuffer.data() : pScanLineBuffer.data();\n                jpeg_read_scanlines(&cinfo, reinterpret_cast<JSAMPARRAY>(&p), 1);\n\n                if (bGray)\n                {\n                    for (long x = 0; x < nWidth; ++x)\n                    {\n                        sal_uInt8 nColorGray = pScanLineBuffer[x];\n                        pAccess->SetPixel(yIndex, x, pCols[nColorGray]);\n                    }\n                }\n                else if (cinfo.out_color_space == JCS_CMYK)\n                {\n                    // convert CMYK to RGB\n                    for (long cmyk = 0, x = 0; cmyk < nWidth * 4; cmyk += 4, ++x)\n                    {\n                        int color_C = 255 - pCYMKBuffer[cmyk + 0];\n                        int color_M = 255 - pCYMKBuffer[cmyk + 1];\n                        int color_Y = 255 - pCYMKBuffer[cmyk + 2];\n                        int color_K = 255 - pCYMKBuffer[cmyk + 3];\n\n                        sal_uInt8 cRed = aRangeLimit[255L - (color_C + color_K)];\n                        sal_uInt8 cGreen = aRangeLimit[255L - (color_M + color_K)];\n                        sal_uInt8 cBlue = aRangeLimit[255L - (color_Y + color_K)];\n\n                        pAccess->SetPixel(yIndex, x, BitmapColor(cRed, cGreen, cBlue));\n                    }\n                }\n                else\n                {\n                    pAccess->CopyScanline(yIndex, pScanLineBuffer.data(), eScanlineFormat, pScanLineBuffer.size());\n                }\n\n                /* PENDING ??? */\n                if (cinfo.err->msg_code == 113)\n                    break;\n            }\n        }\n    }\n\n    if (bBitmapCreated)\n    {\n        jpeg_finish_decompress( &cinfo );\n    }\n    else\n    {\n        jpeg_abort_decompress( &cinfo );\n    }\n\n    jpeg_destroy_decompress( &cinfo );\n}", "target": 3, "idx": 9804}
{"commit_id": "299f804acbb95a612ab7c504d25ab908aa59ae93", "project": "google/asylo", "func": "ssize_t enc_untrusted_recvfrom(int sockfd, void *buf, size_t len, int flags,\n                               struct sockaddr *src_addr, socklen_t *addrlen) {\n  int klinux_flags = TokLinuxRecvSendFlag(flags);\n  if (klinux_flags == 0 && flags != 0) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  MessageWriter input;\n  input.Push<int>(sockfd);\n  input.Push<uint64_t>(len);\n  input.Push<int>(klinux_flags);\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kRecvFromHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_recvfrom\", 4);\n\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n  // recvfrom() returns -1 on failure, with errno set to indicate the cause\n  // of the error.\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return result;\n  }\n\n  auto buffer_received = output.next();\n  memcpy(buf, buffer_received.data(), std::min(len, buffer_received.size()));\n\n  // If |src_addr| is not NULL, and the underlying protocol provides the source\n  // address, this source address is filled in. When |src_addr| is NULL, nothing\n  // is filled in; in this case, |addrlen| is not used, and should also be NULL.\n  if (src_addr != nullptr && addrlen != nullptr) {\n    auto klinux_sockaddr_buf = output.next();\n    const struct klinux_sockaddr *klinux_addr =\n        klinux_sockaddr_buf.As<struct klinux_sockaddr>();\n    FromkLinuxSockAddr(klinux_addr, klinux_sockaddr_buf.size(), src_addr,\n                       addrlen, TrustedPrimitives::BestEffortAbort);\n  }\n\n  return result;\n}", "target": 1, "idx": 9805}
{"commit_id": "3d0220f6861d713213b015b582e9f21e5b28d2e0", "project": "torvalds/linux", "func": "static int adjust_ptr_min_max_vals(struct bpf_verifier_env *env,\n\t\t\t\t   struct bpf_insn *insn,\n\t\t\t\t   const struct bpf_reg_state *ptr_reg,\n\t\t\t\t   const struct bpf_reg_state *off_reg)\n{\n\tstruct bpf_verifier_state *vstate = env->cur_state;\n\tstruct bpf_func_state *state = vstate->frame[vstate->curframe];\n\tstruct bpf_reg_state *regs = state->regs, *dst_reg;\n\tbool known = tnum_is_const(off_reg->var_off);\n\ts64 smin_val = off_reg->smin_value, smax_val = off_reg->smax_value,\n\t    smin_ptr = ptr_reg->smin_value, smax_ptr = ptr_reg->smax_value;\n\tu64 umin_val = off_reg->umin_value, umax_val = off_reg->umax_value,\n\t    umin_ptr = ptr_reg->umin_value, umax_ptr = ptr_reg->umax_value;\n\tstruct bpf_sanitize_info info = {};\n\tu8 opcode = BPF_OP(insn->code);\n\tu32 dst = insn->dst_reg;\n\tint ret;\n\n\tdst_reg = &regs[dst];\n\n\tif ((known && (smin_val != smax_val || umin_val != umax_val)) ||\n\t    smin_val > smax_val || umin_val > umax_val) {\n\t\t/* Taint dst register if offset had invalid bounds derived from\n\t\t * e.g. dead branches.\n\t\t */\n\t\t__mark_reg_unknown(env, dst_reg);\n\t\treturn 0;\n\t}\n\n\tif (BPF_CLASS(insn->code) != BPF_ALU64) {\n\t\t/* 32-bit ALU ops on pointers produce (meaningless) scalars */\n\t\tif (opcode == BPF_SUB && env->allow_ptr_leaks) {\n\t\t\t__mark_reg_unknown(env, dst_reg);\n\t\t\treturn 0;\n\t\t}\n\n\t\tverbose(env,\n\t\t\t\"R%d 32-bit pointer arithmetic prohibited\\n\",\n\t\t\tdst);\n\t\treturn -EACCES;\n\t}\n\n\tswitch (ptr_reg->type) {\n\tcase PTR_TO_MAP_VALUE_OR_NULL:\n\t\tverbose(env, \"R%d pointer arithmetic on %s prohibited, null-check it first\\n\",\n\t\t\tdst, reg_type_str[ptr_reg->type]);\n\t\treturn -EACCES;\n\tcase CONST_PTR_TO_MAP:\n\t\t/* smin_val represents the known value */\n\t\tif (known && smin_val == 0 && opcode == BPF_ADD)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase PTR_TO_PACKET_END:\n\tcase PTR_TO_SOCKET:\n\tcase PTR_TO_SOCKET_OR_NULL:\n\tcase PTR_TO_SOCK_COMMON:\n\tcase PTR_TO_SOCK_COMMON_OR_NULL:\n\tcase PTR_TO_TCP_SOCK:\n\tcase PTR_TO_TCP_SOCK_OR_NULL:\n\tcase PTR_TO_XDP_SOCK:\n\t\tverbose(env, \"R%d pointer arithmetic on %s prohibited\\n\",\n\t\t\tdst, reg_type_str[ptr_reg->type]);\n\t\treturn -EACCES;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* In case of 'scalar += pointer', dst_reg inherits pointer type and id.\n\t * The id may be overwritten later if we create a new variable offset.\n\t */\n\tdst_reg->type = ptr_reg->type;\n\tdst_reg->id = ptr_reg->id;\n\n\tif (!check_reg_sane_offset(env, off_reg, ptr_reg->type) ||\n\t    !check_reg_sane_offset(env, ptr_reg, ptr_reg->type))\n\t\treturn -EINVAL;\n\n\t/* pointer types do not carry 32-bit bounds at the moment. */\n\t__mark_reg32_unbounded(dst_reg);\n\n\tif (sanitize_needed(opcode)) {\n\t\tret = sanitize_ptr_alu(env, insn, ptr_reg, off_reg, dst_reg,\n\t\t\t\t       &info, false);\n\t\tif (ret < 0)\n\t\t\treturn sanitize_err(env, insn, ret, off_reg, dst_reg);\n\t}\n\n\tswitch (opcode) {\n\tcase BPF_ADD:\n\t\t/* We can take a fixed offset as long as it doesn't overflow\n\t\t * the s32 'off' field\n\t\t */\n\t\tif (known && (ptr_reg->off + smin_val ==\n\t\t\t      (s64)(s32)(ptr_reg->off + smin_val))) {\n\t\t\t/* pointer += K.  Accumulate it into fixed offset */\n\t\t\tdst_reg->smin_value = smin_ptr;\n\t\t\tdst_reg->smax_value = smax_ptr;\n\t\t\tdst_reg->umin_value = umin_ptr;\n\t\t\tdst_reg->umax_value = umax_ptr;\n\t\t\tdst_reg->var_off = ptr_reg->var_off;\n\t\t\tdst_reg->off = ptr_reg->off + smin_val;\n\t\t\tdst_reg->raw = ptr_reg->raw;\n\t\t\tbreak;\n\t\t}\n\t\t/* A new variable offset is created.  Note that off_reg->off\n\t\t * == 0, since it's a scalar.\n\t\t * dst_reg gets the pointer type and since some positive\n\t\t * integer value was added to the pointer, give it a new 'id'\n\t\t * if it's a PTR_TO_PACKET.\n\t\t * this creates a new 'base' pointer, off_reg (variable) gets\n\t\t * added into the variable offset, and we copy the fixed offset\n\t\t * from ptr_reg.\n\t\t */\n\t\tif (signed_add_overflows(smin_ptr, smin_val) ||\n\t\t    signed_add_overflows(smax_ptr, smax_val)) {\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value = smin_ptr + smin_val;\n\t\t\tdst_reg->smax_value = smax_ptr + smax_val;\n\t\t}\n\t\tif (umin_ptr + umin_val < umin_ptr ||\n\t\t    umax_ptr + umax_val < umax_ptr) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value = umin_ptr + umin_val;\n\t\t\tdst_reg->umax_value = umax_ptr + umax_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_add(ptr_reg->var_off, off_reg->var_off);\n\t\tdst_reg->off = ptr_reg->off;\n\t\tdst_reg->raw = ptr_reg->raw;\n\t\tif (reg_is_pkt_pointer(ptr_reg)) {\n\t\t\tdst_reg->id = ++env->id_gen;\n\t\t\t/* something was added to pkt_ptr, set range to zero */\n\t\t\tmemset(&dst_reg->raw, 0, sizeof(dst_reg->raw));\n\t\t}\n\t\tbreak;\n\tcase BPF_SUB:\n\t\tif (dst_reg == off_reg) {\n\t\t\t/* scalar -= pointer.  Creates an unknown scalar */\n\t\t\tverbose(env, \"R%d tried to subtract pointer from scalar\\n\",\n\t\t\t\tdst);\n\t\t\treturn -EACCES;\n\t\t}\n\t\t/* We don't allow subtraction from FP, because (according to\n\t\t * test_verifier.c test \"invalid fp arithmetic\", JITs might not\n\t\t * be able to deal with it.\n\t\t */\n\t\tif (ptr_reg->type == PTR_TO_STACK) {\n\t\t\tverbose(env, \"R%d subtraction from stack pointer prohibited\\n\",\n\t\t\t\tdst);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (known && (ptr_reg->off - smin_val ==\n\t\t\t      (s64)(s32)(ptr_reg->off - smin_val))) {\n\t\t\t/* pointer -= K.  Subtract it from fixed offset */\n\t\t\tdst_reg->smin_value = smin_ptr;\n\t\t\tdst_reg->smax_value = smax_ptr;\n\t\t\tdst_reg->umin_value = umin_ptr;\n\t\t\tdst_reg->umax_value = umax_ptr;\n\t\t\tdst_reg->var_off = ptr_reg->var_off;\n\t\t\tdst_reg->id = ptr_reg->id;\n\t\t\tdst_reg->off = ptr_reg->off - smin_val;\n\t\t\tdst_reg->raw = ptr_reg->raw;\n\t\t\tbreak;\n\t\t}\n\t\t/* A new variable offset is created.  If the subtrahend is known\n\t\t * nonnegative, then any reg->range we had before is still good.\n\t\t */\n\t\tif (signed_sub_overflows(smin_ptr, smax_val) ||\n\t\t    signed_sub_overflows(smax_ptr, smin_val)) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value = smin_ptr - smax_val;\n\t\t\tdst_reg->smax_value = smax_ptr - smin_val;\n\t\t}\n\t\tif (umin_ptr < umax_val) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\t/* Cannot overflow (as long as bounds are consistent) */\n\t\t\tdst_reg->umin_value = umin_ptr - umax_val;\n\t\t\tdst_reg->umax_value = umax_ptr - umin_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_sub(ptr_reg->var_off, off_reg->var_off);\n\t\tdst_reg->off = ptr_reg->off;\n\t\tdst_reg->raw = ptr_reg->raw;\n\t\tif (reg_is_pkt_pointer(ptr_reg)) {\n\t\t\tdst_reg->id = ++env->id_gen;\n\t\t\t/* something was added to pkt_ptr, set range to zero */\n\t\t\tif (smin_val < 0)\n\t\t\t\tmemset(&dst_reg->raw, 0, sizeof(dst_reg->raw));\n\t\t}\n\t\tbreak;\n\tcase BPF_AND:\n\tcase BPF_OR:\n\tcase BPF_XOR:\n\t\t/* bitwise ops on pointers are troublesome, prohibit. */\n\t\tverbose(env, \"R%d bitwise operator %s on pointer prohibited\\n\",\n\t\t\tdst, bpf_alu_string[opcode >> 4]);\n\t\treturn -EACCES;\n\tdefault:\n\t\t/* other operators (e.g. MUL,LSH) produce non-pointer results */\n\t\tverbose(env, \"R%d pointer arithmetic with %s operator prohibited\\n\",\n\t\t\tdst, bpf_alu_string[opcode >> 4]);\n\t\treturn -EACCES;\n\t}\n\n\tif (!check_reg_sane_offset(env, dst_reg, ptr_reg->type))\n\t\treturn -EINVAL;\n\n\t__update_reg_bounds(dst_reg);\n\t__reg_deduce_bounds(dst_reg);\n\t__reg_bound_offset(dst_reg);\n\n\tif (sanitize_check_bounds(env, insn, dst_reg) < 0)\n\t\treturn -EACCES;\n\tif (sanitize_needed(opcode)) {\n\t\tret = sanitize_ptr_alu(env, insn, dst_reg, off_reg, dst_reg,\n\t\t\t\t       &info, true);\n\t\tif (ret < 0)\n\t\t\treturn sanitize_err(env, insn, ret, off_reg, dst_reg);\n\t}\n\n\treturn 0;\n}", "target": 2, "idx": 9806}
{"commit_id": "2568a7e0832ee30b0a351016d03062ab4e0e0a3f", "project": "kernel/git/bluetooth/bluetooth-next", "func": "static void\nrelease_card(struct l1oip *hc)\n{\n\tint\tch;\n\n\thc->shutdown = true;\n\n\tdel_timer_sync(&hc->keep_tl);\n\tdel_timer_sync(&hc->timeout_tl);\n\n\tcancel_work_sync(&hc->workq);\n\n\tif (hc->socket_thread)\n\t\tl1oip_socket_close(hc);\n\n\tif (hc->registered && hc->chan[hc->d_idx].dch)\n\t\tmISDN_unregister_device(&hc->chan[hc->d_idx].dch->dev);\n\tfor (ch = 0; ch < 128; ch++) {\n\t\tif (hc->chan[ch].dch) {\n\t\t\tmISDN_freedchannel(hc->chan[ch].dch);\n\t\t\tkfree(hc->chan[ch].dch);\n\t\t}\n\t\tif (hc->chan[ch].bch) {\n\t\t\tmISDN_freebchannel(hc->chan[ch].bch);\n\t\t\tkfree(hc->chan[ch].bch);\n#ifdef REORDER_DEBUG\n\t\t\tdev_kfree_skb(hc->chan[ch].disorder_skb);\n#endif\n\t\t}\n\t}\n\n\tspin_lock(&l1oip_lock);\n\tlist_del(&hc->list);\n\tspin_unlock(&l1oip_lock);\n\n\tkfree(hc);\n}", "target": 2, "idx": 9807}
{"commit_id": "670fb73dd5ee8acab90971c4878de29f9fc43a02", "project": "Exiv2/exiv2", "func": "void TiffImage::readMetadata()\n    {\n#ifdef DEBUG\n        std::cerr << \"Reading TIFF file \" << io_->path() << \"\\n\";\n#endif\n        if (io_->open() != 0) {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n\n        IoCloser closer(*io_);\n        // Ensure that this is the correct image type\n        if (!isTiffType(*io_, false)) {\n            if (io_->error() || io_->eof())\n                throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAnImage, \"TIFF\");\n        }\n        clearMetadata();\n\n        ByteOrder bo = TiffParser::decode(exifData_,\n                                          iptcData_,\n                                          xmpData_,\n                                          io_->mmap(),\n                                          (uint32_t) io_->size());\n        setByteOrder(bo);\n\n        // read profile from the metadata\n        Exiv2::ExifKey            key(\"Exif.Image.InterColorProfile\");\n        Exiv2::ExifData::iterator pos   = exifData_.findKey(key);\n        if ( pos != exifData_.end() ) {\n            long size = pos->count() * pos->typeSize();\n            if (size == 0) {\n                throw Error(kerFailedToReadImageData);\n            }\n            iccProfile_.alloc(size);\n            pos->copy(iccProfile_.pData_,bo);\n        }\n\n    }", "target": 1, "idx": 9808}
{"commit_id": "788d0824269bef539fe31a785b1517882eafed93", "project": "torvalds/linux", "func": "static inline void io_uring_files_cancel(void)\n{\n\tif (current->io_uring)\n\t\t__io_uring_cancel(false);\n}", "target": 2, "idx": 9809}
{"commit_id": "08193b7f0cd3910256e00d599f0f3eb2519c44ca", "project": "facebook/hhvm", "func": "inline void StringData::setSize(int64_t len) {\n  assertx(!isImmutable() && !hasMultipleRefs());\n  assertx(len >= 0 && len <= capacity());\n  mutableData()[len] = 0;\n  m_lenAndHash = len;\n  assertx(m_hash == 0);\n  assertx(checkSane());\n}", "target": 3, "idx": 9810}
{"commit_id": "ecec76885bcfe3294685dc363fd1273df0d5d65f", "project": "torvalds/linux", "func": "static void free_nested(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!vmx->nested.vmxon && !vmx->nested.smm.vmxon)\n\t\treturn;\n\n\thrtimer_cancel(&vmx->nested.preemption_timer);\n\tvmx->nested.vmxon = false;\n\tvmx->nested.smm.vmxon = false;\n\tfree_vpid(vmx->nested.vpid02);\n\tvmx->nested.posted_intr_nv = -1;\n\tvmx->nested.current_vmptr = -1ull;\n\tif (enable_shadow_vmcs) {\n\t\tvmx_disable_shadow_vmcs(vmx);\n\t\tvmcs_clear(vmx->vmcs01.shadow_vmcs);\n\t\tfree_vmcs(vmx->vmcs01.shadow_vmcs);\n\t\tvmx->vmcs01.shadow_vmcs = NULL;\n\t}\n\tkfree(vmx->nested.cached_vmcs12);\n\tkfree(vmx->nested.cached_shadow_vmcs12);\n\t/* Unpin physical memory we referred to in the vmcs02 */\n\tif (vmx->nested.apic_access_page) {\n\t\tkvm_release_page_dirty(vmx->nested.apic_access_page);\n\t\tvmx->nested.apic_access_page = NULL;\n\t}\n\tif (vmx->nested.virtual_apic_page) {\n\t\tkvm_release_page_dirty(vmx->nested.virtual_apic_page);\n\t\tvmx->nested.virtual_apic_page = NULL;\n\t}\n\tif (vmx->nested.pi_desc_page) {\n\t\tkunmap(vmx->nested.pi_desc_page);\n\t\tkvm_release_page_dirty(vmx->nested.pi_desc_page);\n\t\tvmx->nested.pi_desc_page = NULL;\n\t\tvmx->nested.pi_desc = NULL;\n\t}\n\n\tkvm_mmu_free_roots(vcpu, &vcpu->arch.guest_mmu, KVM_MMU_ROOTS_ALL);\n\n\tnested_release_evmcs(vcpu);\n\n\tfree_loaded_vmcs(&vmx->nested.vmcs02);\n}", "target": 2, "idx": 9811}
{"commit_id": "055e547478a11a6360c7ce05e2afc3e366968a12", "project": "torvalds/linux", "func": "struct clock_source *dcn20_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\n\tif (!clk_src)\n\t\treturn NULL;\n\n\tif (dcn20_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\n\tkfree(clk_src);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 1, "idx": 9812}
{"commit_id": "d8a0cbc4f2979e0b1cadbe79f0b8b4ecb92477be", "project": "wireshark", "func": "static guint32\ns7comm_decode_ud_cyclic_subfunc(tvbuff_t *tvb,\n                                proto_tree *data_tree,\n                                guint8 type,                /* Type of data (request/response) */\n                                guint8 subfunc,             /* Subfunction */\n                                guint16 dlength,            /* length of data part given in header */\n                                guint32 offset)             /* Offset on data part +4 */\n{\n    gboolean know_data = FALSE;\n    guint32 offset_old;\n    guint32 len_item;\n    guint8 item_count;\n    guint8 i;\n\n    switch (subfunc)\n    {\n        case S7COMM_UD_SUBF_CYCLIC_MEM:\n            item_count = tvb_get_guint8(tvb, offset + 1);     /* first byte reserved??? */\n            proto_tree_add_uint(data_tree, hf_s7comm_param_itemcount, tvb, offset, 2, item_count);\n            offset += 2;\n            if (type == S7COMM_UD_TYPE_REQ) {                   /* Request to PLC to send cyclic data */\n                proto_tree_add_item(data_tree, hf_s7comm_cycl_interval_timebase, tvb, offset, 1, ENC_BIG_ENDIAN);\n                offset += 1;\n                proto_tree_add_item(data_tree, hf_s7comm_cycl_interval_time, tvb, offset, 1, ENC_BIG_ENDIAN);\n                offset += 1;\n                /* parse item data */\n                for (i = 0; i < item_count; i++) {\n                    offset_old = offset;\n                    offset = s7comm_decode_param_item(tvb, offset, data_tree, i);\n                    /* if length is not a multiple of 2 and this is not the last item, then add a fill-byte */\n                    len_item = offset - offset_old;\n                    if ((len_item % 2) && (i < (item_count-1))) {\n                        offset += 1;\n                    }\n                }\n\n            } else if (type == S7COMM_UD_TYPE_RES || type == S7COMM_UD_TYPE_PUSH) {   /* Response from PLC with the requested data */\n                /* parse item data */\n                offset = s7comm_decode_response_read_data(tvb, data_tree, item_count, offset);\n            }\n            know_data = TRUE;\n            break;\n    }\n\n    if (know_data == FALSE && dlength > 4) {\n        proto_tree_add_item(data_tree, hf_s7comm_userdata_data, tvb, offset, dlength - 4, ENC_NA);\n        offset += dlength;\n    }\n    return offset;\n}", "target": 2, "idx": 9813}
{"commit_id": "af368027a49a751d6ff4ee9e3f9961f35bb4fede", "project": "torvalds/linux", "func": "static int snd_timer_user_release(struct inode *inode, struct file *file)\n{\n\tstruct snd_timer_user *tu;\n\n\tif (file->private_data) {\n\t\ttu = file->private_data;\n\t\tfile->private_data = NULL;\n\t\tmutex_lock(&tu->ioctl_lock);\n\t\tif (tu->timeri)\n\t\t\tsnd_timer_close(tu->timeri);\n\t\tmutex_unlock(&tu->ioctl_lock);\n\t\tkfree(tu->queue);\n\t\tkfree(tu->tqueue);\n\t\tkfree(tu);\n\t}\n\treturn 0;\n}", "target": 1, "idx": 9814}
{"commit_id": "e9f57ebcba563e0cd532926cab83c92bb4d79360", "project": "torvalds/linux", "func": "int ovl_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tint err;\n\tstruct dentry *upperdentry;\n\n\t/*\n\t * Check for permissions before trying to copy-up.  This is redundant\n\t * since it will be rechecked later by ->setattr() on upper dentry.  But\n\t * without this, copy-up can be triggered by just about anybody.\n\t *\n\t * We don't initialize inode->size, which just means that\n\t * inode_newsize_ok() will always check against MAX_LFS_FILESIZE and not\n\t * check for a swapfile (which this won't be anyway).\n\t */\n\terr = inode_change_ok(dentry->d_inode, attr);\n\tif (err)\n\t\treturn err;\n\n\terr = ovl_want_write(dentry);\n\tif (err)\n\t\tgoto out;\n\n\terr = ovl_copy_up(dentry);\n\tif (!err) {\n\t\tupperdentry = ovl_dentry_upper(dentry);\n\n\t\tmutex_lock(&upperdentry->d_inode->i_mutex);\n\t\terr = notify_change(upperdentry, attr, NULL);\n\t\tmutex_unlock(&upperdentry->d_inode->i_mutex);\n\t}\n\tovl_drop_write(dentry);\nout:\n\treturn err;\n}", "target": 2, "idx": 9815}
{"commit_id": "070c4b92b8cd5390889716677a0b92444d6e087a", "project": "qemu", "func": "static void mcf_fec_do_tx(mcf_fec_state *s)\n{\n    uint32_t addr;\n    mcf_fec_bd bd;\n    int frame_size;\n    int len, descnt = 0;\n    uint8_t frame[FEC_MAX_FRAME_SIZE];\n    uint8_t *ptr;\n\n    DPRINTF(\"do_tx\\n\");\n    ptr = frame;\n    frame_size = 0;\n    addr = s->tx_descriptor;\n    while (descnt++ < FEC_MAX_DESC) {\n        mcf_fec_read_bd(&bd, addr);\n        DPRINTF(\"tx_bd %x flags %04x len %d data %08x\\n\",\n                addr, bd.flags, bd.length, bd.data);\n        if ((bd.flags & FEC_BD_R) == 0) {\n            /* Run out of descriptors to transmit.  */\n            break;\n        }\n        len = bd.length;\n        if (frame_size + len > FEC_MAX_FRAME_SIZE) {\n            len = FEC_MAX_FRAME_SIZE - frame_size;\n            s->eir |= FEC_INT_BABT;\n        }\n        cpu_physical_memory_read(bd.data, ptr, len);\n        ptr += len;\n        frame_size += len;\n        if (bd.flags & FEC_BD_L) {\n            /* Last buffer in frame.  */\n            DPRINTF(\"Sending packet\\n\");\n            qemu_send_packet(qemu_get_queue(s->nic), frame, len);\n            ptr = frame;\n            frame_size = 0;\n            s->eir |= FEC_INT_TXF;\n        }\n        s->eir |= FEC_INT_TXB;\n        bd.flags &= ~FEC_BD_R;\n        /* Write back the modified descriptor.  */\n        mcf_fec_write_bd(&bd, addr);\n        /* Advance to the next descriptor.  */\n        if ((bd.flags & FEC_BD_W) != 0) {\n            addr = s->etdsr;\n        } else {\n            addr += 8;\n        }\n    }\n    s->tx_descriptor = addr;\n}", "target": 1, "idx": 9816}
{"commit_id": "c2639afac631f5c1ffddf70ee8a6fe943d0bedf9", "project": "android", "func": "void SoftMP3::onQueueFilled(OMX_U32 /* portIndex */) {\n    if (mSignalledError || mOutputPortSettingsChange != NONE) {\n        return;\n    }\n\n    List<BufferInfo *> &inQueue = getPortQueue(0);\n    List<BufferInfo *> &outQueue = getPortQueue(1);\n\n    while ((!inQueue.empty() || (mSawInputEos && !mSignalledOutputEos)) && !outQueue.empty()) {\n        BufferInfo *inInfo = NULL;\n        OMX_BUFFERHEADERTYPE *inHeader = NULL;\n        if (!inQueue.empty()) {\n            inInfo = *inQueue.begin();\n            inHeader = inInfo->mHeader;\n        }\n\n        BufferInfo *outInfo = *outQueue.begin();\n        OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;\n        outHeader->nFlags = 0;\n\n        if (inHeader) {\n            if (inHeader->nOffset == 0 && inHeader->nFilledLen) {\n                mAnchorTimeUs = inHeader->nTimeStamp;\n                mNumFramesOutput = 0;\n            }\n\n            if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n                mSawInputEos = true;\n            }\n\n            mConfig->pInputBuffer =\n                inHeader->pBuffer + inHeader->nOffset;\n\n            mConfig->inputBufferCurrentLength = inHeader->nFilledLen;\n        } else {\n            mConfig->pInputBuffer = NULL;\n            mConfig->inputBufferCurrentLength = 0;\n        }\n        mConfig->inputBufferMaxLength = 0;\n        mConfig->inputBufferUsedLength = 0;\n\n        mConfig->outputFrameSize = kOutputBufferSize / sizeof(int16_t);\n        if ((int32)outHeader->nAllocLen < mConfig->outputFrameSize) {\n            ALOGE(\"input buffer too small: got %u, expected %u\",\n                outHeader->nAllocLen, mConfig->outputFrameSize);\n            android_errorWriteLog(0x534e4554, \"27793371\");\n            notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);\n            mSignalledError = true;\n            return;\n        }\n\n        mConfig->pOutputBuffer =\n            reinterpret_cast<int16_t *>(outHeader->pBuffer);\n\n        ERROR_CODE decoderErr;\n        if ((decoderErr = pvmp3_framedecoder(mConfig, mDecoderBuf))\n                != NO_DECODING_ERROR) {\n            ALOGV(\"mp3 decoder returned error %d\", decoderErr);\n\n            if (decoderErr != NO_ENOUGH_MAIN_DATA_ERROR\n                        && decoderErr != SIDE_INFO_ERROR) {\n                ALOGE(\"mp3 decoder returned error %d\", decoderErr);\n\n                notify(OMX_EventError, OMX_ErrorUndefined, decoderErr, NULL);\n                mSignalledError = true;\n                return;\n            }\n\n            if (mConfig->outputFrameSize == 0) {\n                mConfig->outputFrameSize = kOutputBufferSize / sizeof(int16_t);\n            }\n\n            if (decoderErr == NO_ENOUGH_MAIN_DATA_ERROR && mSawInputEos) {\n                if (!mIsFirst) {\n                    // pad the end of the stream with 529 samples, since that many samples\n                    // were trimmed off the beginning when decoding started\n                    outHeader->nOffset = 0;\n                    outHeader->nFilledLen = kPVMP3DecoderDelay * mNumChannels * sizeof(int16_t);\n\n                    if (!memsetSafe(outHeader, 0, outHeader->nFilledLen)) {\n                        return;\n                    }\n\n                }\n                outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n                mSignalledOutputEos = true;\n            } else {\n                // This is recoverable, just ignore the current frame and\n                // play silence instead.\n\n                // TODO: should we skip silence (and consume input data)\n                // if mIsFirst is true as we may not have a valid\n                // mConfig->samplingRate and mConfig->num_channels?\n                ALOGV_IF(mIsFirst, \"insufficient data for first frame, sending silence\");\n                if (!memsetSafe(outHeader, 0, mConfig->outputFrameSize * sizeof(int16_t))) {\n                    return;\n                }\n\n                if (inHeader) {\n                    mConfig->inputBufferUsedLength = inHeader->nFilledLen;\n                }\n            }\n        } else if (mConfig->samplingRate != mSamplingRate\n                || mConfig->num_channels != mNumChannels) {\n            mSamplingRate = mConfig->samplingRate;\n            mNumChannels = mConfig->num_channels;\n\n            notify(OMX_EventPortSettingsChanged, 1, 0, NULL);\n            mOutputPortSettingsChange = AWAITING_DISABLED;\n            return;\n        }\n\n        if (mIsFirst) {\n            mIsFirst = false;\n            // The decoder delay is 529 samples, so trim that many samples off\n            // the start of the first output buffer. This essentially makes this\n            // decoder have zero delay, which the rest of the pipeline assumes.\n            outHeader->nOffset =\n                kPVMP3DecoderDelay * mNumChannels * sizeof(int16_t);\n\n            outHeader->nFilledLen =\n                mConfig->outputFrameSize * sizeof(int16_t) - outHeader->nOffset;\n        } else if (!mSignalledOutputEos) {\n            outHeader->nOffset = 0;\n            outHeader->nFilledLen = mConfig->outputFrameSize * sizeof(int16_t);\n        }\n\n        outHeader->nTimeStamp =\n            mAnchorTimeUs + (mNumFramesOutput * 1000000ll) / mSamplingRate;\n\n        if (inHeader) {\n            CHECK_GE(inHeader->nFilledLen, mConfig->inputBufferUsedLength);\n\n            inHeader->nOffset += mConfig->inputBufferUsedLength;\n            inHeader->nFilledLen -= mConfig->inputBufferUsedLength;\n\n\n            if (inHeader->nFilledLen == 0) {\n                inInfo->mOwnedByUs = false;\n                inQueue.erase(inQueue.begin());\n                inInfo = NULL;\n                notifyEmptyBufferDone(inHeader);\n                inHeader = NULL;\n            }\n        }\n\n        mNumFramesOutput += mConfig->outputFrameSize / mNumChannels;\n\n        outInfo->mOwnedByUs = false;\n        outQueue.erase(outQueue.begin());\n        outInfo = NULL;\n        notifyFillBufferDone(outHeader);\n        outHeader = NULL;\n    }\n}", "target": 2, "idx": 9817}
{"commit_id": "29ee67c205855e848a0a26e6d0e4f65b6b943e0a", "project": "gnutls", "func": "int gnutls_handshake(gnutls_session_t session)\n{\n\tconst version_entry_st *vers = get_version(session);\n\tint ret;\n\n\tif (unlikely(session->internals.initial_negotiation_completed)) {\n\t\tif (vers->tls13_sem) {\n\t\t\tif (session->security_parameters.entity == GNUTLS_CLIENT) {\n\t\t\t\treturn gnutls_session_key_update(session, GNUTLS_KU_PEER);\n\t\t\t} else {\n\t\t\t\t/* This is a no-op for a server under TLS 1.3, as\n\t\t\t\t * a server has already called gnutls_rehandshake()\n\t\t\t\t * which performed a key update.\n\t\t\t\t */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (STATE == STATE0) {\n\t\tunsigned int tmo_ms;\n\t\tstruct timespec *end;\n\t\tstruct timespec *start;\n\n\t\t/* first call */\n\t\tif (session->internals.priorities == NULL ||\n\t\t    session->internals.priorities->cs.size == 0)\n\t\t\treturn gnutls_assert_val(GNUTLS_E_NO_PRIORITIES_WERE_SET);\n\n\t\tret =\n\t\t    _gnutls_epoch_setup_next(session, 0, NULL);\n\t\tif (ret < 0)\n\t\t\treturn gnutls_assert_val(ret);\n\n\t\tsession->internals.used_exts = 0;\n\t\tsession->internals.hsk_flags = 0;\n\t\tsession->internals.handshake_in_progress = 1;\n\t\tsession->internals.vc_status = -1;\n\t\tgnutls_gettime(&session->internals.handshake_start_time);\n\n\t\ttmo_ms = session->internals.handshake_timeout_ms;\n\t\tend = &session->internals.handshake_abs_timeout;\n\t\tstart = &session->internals.handshake_start_time;\n\n\t\tif (tmo_ms && end->tv_sec == 0 && end->tv_nsec == 0) {\n\t\t\tend->tv_sec =\n\t\t\t\tstart->tv_sec + (start->tv_nsec + tmo_ms * 1000000LL) / 1000000000LL;\n\t\t\tend->tv_nsec =\n\t\t\t\t(start->tv_nsec + tmo_ms * 1000000LL) % 1000000000LL;\n\t\t}\n\t}\n\n\tif (session->internals.recv_state == RECV_STATE_FALSE_START) {\n\t\tsession_invalidate(session);\n\t\treturn gnutls_assert_val(GNUTLS_E_HANDSHAKE_DURING_FALSE_START);\n\t}\n\n\tif (session->security_parameters.entity == GNUTLS_CLIENT) {\n\t\tdo {\n\t\t\tret = handshake_client(session);\n\t\t} while (ret == 1);\n\t} else {\n\t\tret = handshake_server(session);\n\t}\n\n\tif (ret < 0) {\n\t\treturn _gnutls_abort_handshake(session, ret);\n\t}\n\n\t/* clear handshake buffer */\n\tif (session->internals.recv_state != RECV_STATE_FALSE_START &&\n\t    session->internals.recv_state != RECV_STATE_EARLY_START) {\n\n\t\t_gnutls_handshake_hash_buffers_clear(session);\n\n\t\tif (IS_DTLS(session) == 0) {\n\t\t\t_gnutls_handshake_io_buffer_clear(session);\n\t\t} else {\n\t\t\t_dtls_async_timer_init(session);\n\t\t}\n\n\t\t_gnutls_handshake_internal_state_clear(session);\n\n\t\t_gnutls_buffer_clear(&session->internals.record_presend_buffer);\n\n\t\t_gnutls_epoch_bump(session);\n\t}\n\n\t/* Give an estimation of the round-trip under TLS1.3, used by gnutls_session_get_data2() */\n\tif (!IS_SERVER(session) && vers->tls13_sem) {\n\t\tstruct timespec handshake_finish_time;\n\t\tgnutls_gettime(&handshake_finish_time);\n\n\t\tif (!(session->internals.hsk_flags & HSK_HRR_RECEIVED)) {\n\t\t\tsession->internals.ertt = timespec_sub_ms(&handshake_finish_time, &session->internals.handshake_start_time)/2;\n\t\t} else {\n\t\t\tsession->internals.ertt = timespec_sub_ms(&handshake_finish_time, &session->internals.handshake_start_time)/4;\n\t\t}\n\t}\n\n\treturn 0;\n}", "target": 2, "idx": 9818}
{"commit_id": "6b485b146a1b9d6ce72dfd7b5f36456c166e7a16", "project": "FreeRDP", "func": "static UINT drive_process_irp_write(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tDRIVE_FILE* file;\n\tUINT32 Length;\n\tUINT64 Offset;\n\tvoid* ptr;\n\n\tif (!drive || !irp || !irp->input || !irp->output || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, Length);\n\tStream_Read_UINT64(irp->input, Offset);\n\tStream_Seek(irp->input, 20); /* Padding */\n\tptr = Stream_Pointer(irp->input);\n\tif (!Stream_SafeSeek(irp->input, Length))\n\t\treturn ERROR_INVALID_DATA;\n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\n\tif (!file)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tLength = 0;\n\t}\n\telse if (!drive_file_seek(file, Offset))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\tLength = 0;\n\t}\n\telse if (!drive_file_write(file, ptr, Length))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\tLength = 0;\n\t}\n\n\tStream_Write_UINT32(irp->output, Length);\n\tStream_Write_UINT8(irp->output, 0); /* Padding */\n\treturn irp->Complete(irp);\n}", "target": 0, "idx": 9819}
{"commit_id": "cadfad870154e14f745ec845708bc17d166065f2", "project": "torvalds/linux", "func": "void native_tss_update_io_bitmap(void)\n{\n\tstruct tss_struct *tss = this_cpu_ptr(&cpu_tss_rw);\n\tstruct thread_struct *t = &current->thread;\n\tu16 *base = &tss->x86_tss.io_bitmap_base;\n\n\tif (!test_thread_flag(TIF_IO_BITMAP)) {\n\t\tnative_tss_invalidate_io_bitmap();\n\t\treturn;\n\t}\n\n\tif (IS_ENABLED(CONFIG_X86_IOPL_IOPERM) && t->iopl_emul == 3) {\n\t\t*base = IO_BITMAP_OFFSET_VALID_ALL;\n\t} else {\n\t\tstruct io_bitmap *iobm = t->io_bitmap;\n\n\t\t/*\n\t\t * Only copy bitmap data when the sequence number differs. The\n\t\t * update time is accounted to the incoming task.\n\t\t */\n\t\tif (tss->io_bitmap.prev_sequence != iobm->sequence)\n\t\t\ttss_copy_io_bitmap(tss, iobm);\n\n\t\t/* Enable the bitmap */\n\t\t*base = IO_BITMAP_OFFSET_VALID_MAP;\n\t}\n\n\t/*\n\t * Make sure that the TSS limit is covering the IO bitmap. It might have\n\t * been cut down by a VMEXIT to 0x67 which would cause a subsequent I/O\n\t * access from user space to trigger a #GP because tbe bitmap is outside\n\t * the TSS limit.\n\t */\n\trefresh_tss_limit();\n}", "target": 2, "idx": 9820}
{"commit_id": "cec0593ae6c3bca65eff65741c2a10f3de3e0afe", "project": "wireshark", "func": "tvbuff_t *\ntvb_uncompress(tvbuff_t *tvb, const int offset, int comprlen)\n{\n\tgint       err;\n\tguint      bytes_out      = 0;\n\tguint8    *compr;\n\tguint8    *uncompr        = NULL;\n\ttvbuff_t  *uncompr_tvb    = NULL;\n\tz_streamp  strm;\n\tBytef     *strmbuf;\n\tguint      inits_done     = 0;\n\tgint       wbits          = MAX_WBITS;\n\tguint8    *next;\n\tguint      bufsiz;\n#ifdef TVB_Z_DEBUG\n\tguint      inflate_passes = 0;\n\tguint      bytes_in       = tvb_captured_length_remaining(tvb, offset);\n#endif\n\n\tif (tvb == NULL) {\n\t\treturn NULL;\n\t}\n\n\tcompr = (guint8 *)tvb_memdup(NULL, tvb, offset, comprlen);\n\n\tif (!compr)\n\t\treturn NULL;\n\n\t/*\n\t * Assume that the uncompressed data is at least twice as big as\n\t * the compressed size.\n\t */\n\tbufsiz = tvb_captured_length_remaining(tvb, offset) * 2;\n\tbufsiz = CLAMP(bufsiz, TVB_Z_MIN_BUFSIZ, TVB_Z_MAX_BUFSIZ);\n\n#ifdef TVB_Z_DEBUG\n\tprintf(\"bufsiz: %u bytes\\n\", bufsiz);\n#endif\n\n\tnext = compr;\n\n\tstrm            = g_new0(z_stream, 1);\n\tstrm->next_in   = next;\n\tstrm->avail_in  = comprlen;\n\n\tstrmbuf         = (Bytef *)g_malloc0(bufsiz);\n\tstrm->next_out  = strmbuf;\n\tstrm->avail_out = bufsiz;\n\n\terr = inflateInit2(strm, wbits);\n\tinits_done = 1;\n\tif (err != Z_OK) {\n\t\tinflateEnd(strm);\n\t\tg_free(strm);\n\t\tg_free(compr);\n\t\tg_free(strmbuf);\n\t\treturn NULL;\n\t}\n\n\twhile (1) {\n\t\tmemset(strmbuf, '\\0', bufsiz);\n\t\tstrm->next_out  = strmbuf;\n\t\tstrm->avail_out = bufsiz;\n\n\t\terr = inflate(strm, Z_SYNC_FLUSH);\n\n\t\tif (err == Z_OK || err == Z_STREAM_END) {\n\t\t\tguint bytes_pass = bufsiz - strm->avail_out;\n\n#ifdef TVB_Z_DEBUG\n\t\t\t++inflate_passes;\n#endif\n\n\t\t\tif (uncompr == NULL) {\n\t\t\t\t/*\n\t\t\t\t * This is ugly workaround for bug #6480\n\t\t\t\t * (https://bugs.wireshark.org/bugzilla/show_bug.cgi?id=6480)\n\t\t\t\t *\n\t\t\t\t * g_memdup(..., 0) returns NULL (g_malloc(0) also)\n\t\t\t\t * when uncompr is NULL logic below doesn't create tvb\n\t\t\t\t * which is later interpreted as decompression failed.\n\t\t\t\t */\n\t\t\t\tuncompr = (guint8 *)((bytes_pass || err != Z_STREAM_END) ?\n\t\t\t\t\t\tg_memdup(strmbuf, bytes_pass) :\n\t\t\t\t\t\tg_strdup(\"\"));\n\t\t\t} else {\n\t\t\t\tguint8 *new_data = (guint8 *)g_malloc0(bytes_out + bytes_pass);\n\n\t\t\t\tmemcpy(new_data, uncompr, bytes_out);\n\t\t\t\tmemcpy(new_data + bytes_out, strmbuf, bytes_pass);\n\n\t\t\t\tg_free(uncompr);\n\t\t\t\tuncompr = new_data;\n\t\t\t}\n\n\t\t\tbytes_out += bytes_pass;\n\n\t\t\tif (err == Z_STREAM_END) {\n\t\t\t\tinflateEnd(strm);\n\t\t\t\tg_free(strm);\n\t\t\t\tg_free(strmbuf);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (err == Z_BUF_ERROR) {\n\t\t\t/*\n\t\t\t * It's possible that not enough frames were captured\n\t\t\t * to decompress this fully, so return what we've done\n\t\t\t * so far, if any.\n\t\t\t */\n\t\t\tinflateEnd(strm);\n\t\t\tg_free(strm);\n\t\t\tg_free(strmbuf);\n\n\t\t\tif (uncompr != NULL) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tg_free(compr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t} else if (err == Z_DATA_ERROR && inits_done == 1\n\t\t\t&& uncompr == NULL && comprlen >= 2 &&\n\t\t\t(*compr  == 0x1f) && (*(compr + 1) == 0x8b)) {\n\t\t\t/*\n\t\t\t * inflate() is supposed to handle both gzip and deflate\n\t\t\t * streams automatically, but in reality it doesn't\n\t\t\t * seem to handle either (at least not within the\n\t\t\t * context of an HTTP response.)  We have to try\n\t\t\t * several tweaks, depending on the type of data and\n\t\t\t * version of the library installed.\n\t\t\t */\n\n\t\t\t/*\n\t\t\t * Gzip file format.  Skip past the header, since the\n\t\t\t * fix to make it work (setting windowBits to 31)\n\t\t\t * doesn't work with all versions of the library.\n\t\t\t */\n\t\t\tBytef *c = compr + 2;\n\t\t\tBytef  flags = 0;\n\n\t\t\t/* we read two bytes already (0x1f, 0x8b) and\n\t\t\t   need at least Z_DEFLATED, 1 byte flags, 4\n\t\t\t   bytes MTIME, 1 byte XFL, 1 byte OS */\n\t\t\tif (comprlen < 10 || *c != Z_DEFLATED) {\n\t\t\t\tinflateEnd(strm);\n\t\t\t\tg_free(strm);\n\t\t\t\tg_free(compr);\n\t\t\t\tg_free(strmbuf);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tc++;\n\t\t\tflags = *c;\n\t\t\tc++;\n\n\t\t\t/* Skip past the MTIME (4 bytes),\n\t\t\t   XFL, and OS fields (1 byte each). */\n\t\t\tc += 6;\n\n\t\t\tif (flags & (1 << 2)) {\n\t\t\t\t/* An Extra field is present. It\n\t\t\t\t   consists of 2 bytes xsize and xsize\n\t\t\t\t   bytes of data.\n\t\t\t\t   Read byte-by-byte (least significant\n\t\t\t\t   byte first) to make sure we abort\n\t\t\t\t   cleanly when the xsize is truncated\n\t\t\t\t   after the first byte. */\n\t\t\t\tguint16 xsize = 0;\n\n\t\t\t\tif (c-compr < comprlen) {\n\t\t\t\t\txsize += *c;\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t\tif (c-compr < comprlen) {\n\t\t\t\t\txsize += *c << 8;\n\t\t\t\t\tc++;\n\t\t\t\t}\n\n\t\t\t\tc += xsize;\n\t\t\t}\n\n\t\t\tif (flags & (1 << 3)) {\n\t\t\t\t/* A null terminated filename */\n\n\t\t\t\twhile ((c - compr) < comprlen && *c != '\\0') {\n\t\t\t\t\tc++;\n\t\t\t\t}\n\n\t\t\t\tc++;\n\t\t\t}\n\n\t\t\tif (flags & (1 << 4)) {\n\t\t\t\t/* A null terminated comment */\n\n\t\t\t\twhile ((c - compr) < comprlen && *c != '\\0') {\n\t\t\t\t\tc++;\n\t\t\t\t}\n\n\t\t\t\tc++;\n\t\t\t}\n\n\n\t\t\tif (c - compr > comprlen) {\n\t\t\t\tinflateEnd(strm);\n\t\t\t\tg_free(strm);\n\t\t\t\tg_free(compr);\n\t\t\t\tg_free(strmbuf);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\t/* Drop gzip header */\n\t\t\tcomprlen -= (int) (c - compr);\n\t\t\tnext = c;\n\n\t\t\tinflateReset(strm);\n\t\t\tstrm->next_in   = next;\n\t\t\tstrm->avail_in  = comprlen;\n\n\t\t\tinflateEnd(strm);\n\t\t\tinflateInit2(strm, wbits);\n\t\t\tinits_done++;\n\t\t} else if (err == Z_DATA_ERROR && uncompr == NULL &&\n\t\t\tinits_done <= 3) {\n\n\t\t\t/*\n\t\t\t * Re-init the stream with a negative\n\t\t\t * MAX_WBITS. This is necessary due to\n\t\t\t * some servers (Apache) not sending\n\t\t\t * the deflate header with the\n\t\t\t * content-encoded response.\n\t\t\t */\n\t\t\twbits = -MAX_WBITS;\n\n\t\t\tinflateReset(strm);\n\n\t\t\tstrm->next_in   = next;\n\t\t\tstrm->avail_in  = comprlen;\n\n\t\t\tinflateEnd(strm);\n\t\t\tmemset(strmbuf, '\\0', bufsiz);\n\t\t\tstrm->next_out  = strmbuf;\n\t\t\tstrm->avail_out = bufsiz;\n\n\t\t\terr = inflateInit2(strm, wbits);\n\n\t\t\tinits_done++;\n\n\t\t\tif (err != Z_OK) {\n\t\t\t\tg_free(strm);\n\t\t\t\tg_free(strmbuf);\n\t\t\t\tg_free(compr);\n\t\t\t\tg_free(uncompr);\n\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tinflateEnd(strm);\n\t\t\tg_free(strm);\n\t\t\tg_free(strmbuf);\n\n\t\t\tif (uncompr == NULL) {\n\t\t\t\tg_free(compr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n#ifdef TVB_Z_DEBUG\n\tprintf(\"inflate() total passes: %u\\n\", inflate_passes);\n\tprintf(\"bytes  in: %u\\nbytes out: %u\\n\\n\", bytes_in, bytes_out);\n#endif\n\n\tif (uncompr != NULL) {\n\t\tuncompr_tvb =  tvb_new_real_data((guint8*) uncompr, bytes_out, bytes_out);\n\t\ttvb_set_free_cb(uncompr_tvb, g_free);\n\t}\n\tg_free(compr);\n\treturn uncompr_tvb;\n}", "target": 1, "idx": 9821}
{"commit_id": "0558f33c06bb910e2879e355192227a8e8f0219d", "project": "torvalds/linux", "func": "static void sas_unregister_devs_sas_addr(struct domain_device *parent,\n\t\t\t\t\t int phy_id, bool last)\n{\n\tstruct expander_device *ex_dev = &parent->ex_dev;\n\tstruct ex_phy *phy = &ex_dev->ex_phy[phy_id];\n\tstruct domain_device *child, *n, *found = NULL;\n\tif (last) {\n\t\tlist_for_each_entry_safe(child, n,\n\t\t\t&ex_dev->children, siblings) {\n\t\t\tif (SAS_ADDR(child->sas_addr) ==\n\t\t\t    SAS_ADDR(phy->attached_sas_addr)) {\n\t\t\t\tset_bit(SAS_DEV_GONE, &child->state);\n\t\t\t\tif (child->dev_type == SAS_EDGE_EXPANDER_DEVICE ||\n\t\t\t\t    child->dev_type == SAS_FANOUT_EXPANDER_DEVICE)\n\t\t\t\t\tsas_unregister_ex_tree(parent->port, child);\n\t\t\t\telse\n\t\t\t\t\tsas_unregister_dev(parent->port, child);\n\t\t\t\tfound = child;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsas_disable_routing(parent, phy->attached_sas_addr);\n\t}\n\tmemset(phy->attached_sas_addr, 0, SAS_ADDR_SIZE);\n\tif (phy->port) {\n\t\tsas_port_delete_phy(phy->port, phy->phy);\n\t\tsas_device_set_phy(found, phy->port);\n\t\tif (phy->port->num_phys == 0)\n\t\t\tlist_add_tail(&phy->port->del_list,\n\t\t\t\t&parent->port->sas_port_del_list);\n\t\tphy->port = NULL;\n\t}\n}", "target": 1, "idx": 9822}
{"commit_id": "e235ac57e85b1802dcb12e541344a7f228e594bc", "project": "weidai11/cryptopp", "func": "inline bool IsAligned(const void *ptr)\n{\n\t// Switch to T* due to https://github.com/weidai11/cryptopp/issues/992\n\treturn IsAlignedOn(ptr, GetAlignmentOf<T*>());\n}", "target": 2, "idx": 9823}
{"commit_id": "a45b599ad808c3c982fdcdc12b0b8611c2f92824", "project": "torvalds/linux", "func": "static int\nsg_build_indirect(Sg_scatter_hold * schp, Sg_fd * sfp, int buff_size)\n{\n\tint ret_sz = 0, i, k, rem_sz, num, mx_sc_elems;\n\tint sg_tablesize = sfp->parentdp->sg_tablesize;\n\tint blk_size = buff_size, order;\n\tgfp_t gfp_mask = GFP_ATOMIC | __GFP_COMP | __GFP_NOWARN;\n\tstruct sg_device *sdp = sfp->parentdp;\n\n\tif (blk_size < 0)\n\t\treturn -EFAULT;\n\tif (0 == blk_size)\n\t\t++blk_size;\t/* don't know why */\n\t/* round request up to next highest SG_SECTOR_SZ byte boundary */\n\tblk_size = ALIGN(blk_size, SG_SECTOR_SZ);\n\tSCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\"sg_build_indirect: buff_size=%d, blk_size=%d\\n\",\n\t\tbuff_size, blk_size));\n\n\t/* N.B. ret_sz carried into this block ... */\n\tmx_sc_elems = sg_build_sgat(schp, sfp, sg_tablesize);\n\tif (mx_sc_elems < 0)\n\t\treturn mx_sc_elems;\t/* most likely -ENOMEM */\n\n\tnum = scatter_elem_sz;\n\tif (unlikely(num != scatter_elem_sz_prev)) {\n\t\tif (num < PAGE_SIZE) {\n\t\t\tscatter_elem_sz = PAGE_SIZE;\n\t\t\tscatter_elem_sz_prev = PAGE_SIZE;\n\t\t} else\n\t\t\tscatter_elem_sz_prev = num;\n\t}\n\n\tif (sdp->device->host->unchecked_isa_dma)\n\t\tgfp_mask |= GFP_DMA;\n\n\tif (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RAWIO))\n\t\tgfp_mask |= __GFP_ZERO;\n\n\torder = get_order(num);\nretry:\n\tret_sz = 1 << (PAGE_SHIFT + order);\n\n\tfor (k = 0, rem_sz = blk_size; rem_sz > 0 && k < mx_sc_elems;\n\t     k++, rem_sz -= ret_sz) {\n\n\t\tnum = (rem_sz > scatter_elem_sz_prev) ?\n\t\t\tscatter_elem_sz_prev : rem_sz;\n\n\t\tschp->pages[k] = alloc_pages(gfp_mask | __GFP_ZERO, order);\n\t\tif (!schp->pages[k])\n\t\t\tgoto out;\n\n\t\tif (num == scatter_elem_sz_prev) {\n\t\t\tif (unlikely(ret_sz > scatter_elem_sz_prev)) {\n\t\t\t\tscatter_elem_sz = ret_sz;\n\t\t\t\tscatter_elem_sz_prev = ret_sz;\n\t\t\t}\n\t\t}\n\n\t\tSCSI_LOG_TIMEOUT(5, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t\t \"sg_build_indirect: k=%d, num=%d, ret_sz=%d\\n\",\n\t\t\t\t k, num, ret_sz));\n\t}\t\t/* end of for loop */\n\n\tschp->page_order = order;\n\tschp->k_use_sg = k;\n\tSCSI_LOG_TIMEOUT(5, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t \"sg_build_indirect: k_use_sg=%d, rem_sz=%d\\n\",\n\t\t\t k, rem_sz));\n\n\tschp->bufflen = blk_size;\n\tif (rem_sz > 0)\t/* must have failed */\n\t\treturn -ENOMEM;\n\treturn 0;\nout:\n\tfor (i = 0; i < k; i++)\n\t\t__free_pages(schp->pages[i], order);\n\n\tif (--order >= 0)\n\t\tgoto retry;\n\n\treturn -ENOMEM;\n}", "target": 1, "idx": 9824}
{"commit_id": "27135d613f929214dd2f74ca106f32310bc7e65b", "project": "WebAssembly/binaryen", "func": "void WasmBinaryBuilder::pushExpression(Expression* curr) {\n  auto type = curr->type;\n  if (type.isTuple()) {\n    // Store tuple to local and push individual extracted values\n    Builder builder(wasm);\n    // Non-nullable types require special handling as they cannot be stored to\n    // a local.\n    std::vector<Type> finalTypes;\n    if (!wasm.features.hasGCNNLocals()) {\n      for (auto t : type) {\n        if (t.isNonNullable()) {\n          t = Type(t.getHeapType(), Nullable);\n        }\n        finalTypes.push_back(t);\n      }\n    }\n    auto nullableType = Type(Tuple(finalTypes));\n    requireFunctionContext(\"pushExpression-tuple\");\n    Index tuple = builder.addVar(currFunction, nullableType);\n    expressionStack.push_back(builder.makeLocalSet(tuple, curr));\n    for (Index i = 0; i < nullableType.size(); ++i) {\n      Expression* value =\n        builder.makeTupleExtract(builder.makeLocalGet(tuple, nullableType), i);\n      if (nullableType[i] != type[i]) {\n        // We modified this to be nullable; undo that.\n        value = builder.makeRefAs(RefAsNonNull, value);\n      }\n      expressionStack.push_back(value);\n    }\n  } else {\n    expressionStack.push_back(curr);\n  }\n}", "target": 1, "idx": 9825}
{"commit_id": "c8bcd9c5be24fb9e6132e97da5a35e55a83e36b9", "project": "torvalds/linux", "func": "void __do_SAK(struct tty_struct *tty)\n{\n#ifdef TTY_SOFT_SAK\n\ttty_hangup(tty);\n#else\n\tstruct task_struct *g, *p;\n\tstruct pid *session;\n\tint\t\ti;\n\tunsigned long flags;\n\n\tif (!tty)\n\t\treturn;\n\n\tspin_lock_irqsave(&tty->ctrl_lock, flags);\n\tsession = get_pid(tty->session);\n\tspin_unlock_irqrestore(&tty->ctrl_lock, flags);\n\n\ttty_ldisc_flush(tty);\n\n\ttty_driver_flush_buffer(tty);\n\n\tread_lock(&tasklist_lock);\n\t/* Kill the entire session */\n\tdo_each_pid_task(session, PIDTYPE_SID, p) {\n\t\ttty_notice(tty, \"SAK: killed process %d (%s): by session\\n\",\n\t\t\t   task_pid_nr(p), p->comm);\n\t\tgroup_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_SID);\n\t} while_each_pid_task(session, PIDTYPE_SID, p);\n\n\t/* Now kill any processes that happen to have the tty open */\n\tdo_each_thread(g, p) {\n\t\tif (p->signal->tty == tty) {\n\t\t\ttty_notice(tty, \"SAK: killed process %d (%s): by controlling tty\\n\",\n\t\t\t\t   task_pid_nr(p), p->comm);\n\t\t\tgroup_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_SID);\n\t\t\tcontinue;\n\t\t}\n\t\ttask_lock(p);\n\t\ti = iterate_fd(p->files, 0, this_tty, tty);\n\t\tif (i != 0) {\n\t\t\ttty_notice(tty, \"SAK: killed process %d (%s): by fd#%d\\n\",\n\t\t\t\t   task_pid_nr(p), p->comm, i - 1);\n\t\t\tgroup_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_SID);\n\t\t}\n\t\ttask_unlock(p);\n\t} while_each_thread(g, p);\n\tread_unlock(&tasklist_lock);\n\tput_pid(session);\n#endif\n}", "target": 1, "idx": 9826}
{"commit_id": "363a5328f4b0517e59572118ccfb7c626d81dca9", "project": "torvalds/linux", "func": "static struct sk_buff *tun_napi_alloc_frags(struct tun_file *tfile,\n\t\t\t\t\t    size_t len,\n\t\t\t\t\t    const struct iov_iter *it)\n{\n\tstruct sk_buff *skb;\n\tsize_t linear;\n\tint err;\n\tint i;\n\n\tif (it->nr_segs > MAX_SKB_FRAGS + 1 ||\n\t    len > (ETH_MAX_MTU - NET_SKB_PAD - NET_IP_ALIGN))\n\t\treturn ERR_PTR(-EMSGSIZE);\n\n\tlocal_bh_disable();\n\tskb = napi_get_frags(&tfile->napi);\n\tlocal_bh_enable();\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlinear = iov_iter_single_seg_count(it);\n\terr = __skb_grow(skb, linear);\n\tif (err)\n\t\tgoto free;\n\n\tskb->len = len;\n\tskb->data_len = len - linear;\n\tskb->truesize += skb->data_len;\n\n\tfor (i = 1; i < it->nr_segs; i++) {\n\t\tsize_t fragsz = it->iov[i].iov_len;\n\t\tstruct page *page;\n\t\tvoid *frag;\n\n\t\tif (fragsz == 0 || fragsz > PAGE_SIZE) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto free;\n\t\t}\n\t\tfrag = netdev_alloc_frag(fragsz);\n\t\tif (!frag) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t\tpage = virt_to_head_page(frag);\n\t\tskb_fill_page_desc(skb, i - 1, page,\n\t\t\t\t   frag - page_address(page), fragsz);\n\t}\n\n\treturn skb;\nfree:\n\t/* frees skb and all frags allocated with napi_alloc_frag() */\n\tnapi_free_frags(&tfile->napi);\n\treturn ERR_PTR(err);\n}", "target": 2, "idx": 9827}
{"commit_id": "fb5be6a7b4863ecc44963bb80ca614584b6c7817", "project": "torvalds/linux", "func": "static int gs_can_open(struct net_device *netdev)\n{\n\tstruct gs_can *dev = netdev_priv(netdev);\n\tstruct gs_usb *parent = dev->parent;\n\tint rc, i;\n\tstruct gs_device_mode *dm;\n\tu32 ctrlmode;\n\n\trc = open_candev(netdev);\n\tif (rc)\n\t\treturn rc;\n\n\tif (atomic_add_return(1, &parent->active_channels) == 1) {\n\t\tfor (i = 0; i < GS_MAX_RX_URBS; i++) {\n\t\t\tstruct urb *urb;\n\t\t\tu8 *buf;\n\n\t\t\t/* alloc rx urb */\n\t\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\t\tif (!urb)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t/* alloc rx buffer */\n\t\t\tbuf = usb_alloc_coherent(dev->udev,\n\t\t\t\t\t\t sizeof(struct gs_host_frame),\n\t\t\t\t\t\t GFP_KERNEL,\n\t\t\t\t\t\t &urb->transfer_dma);\n\t\t\tif (!buf) {\n\t\t\t\tnetdev_err(netdev,\n\t\t\t\t\t   \"No memory left for USB buffer\\n\");\n\t\t\t\tusb_free_urb(urb);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\t/* fill, anchor, and submit rx urb */\n\t\t\tusb_fill_bulk_urb(urb,\n\t\t\t\t\t  dev->udev,\n\t\t\t\t\t  usb_rcvbulkpipe(dev->udev,\n\t\t\t\t\t\t\t  GSUSB_ENDPOINT_IN),\n\t\t\t\t\t  buf,\n\t\t\t\t\t  sizeof(struct gs_host_frame),\n\t\t\t\t\t  gs_usb_receive_bulk_callback,\n\t\t\t\t\t  parent);\n\t\t\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\t\t\tusb_anchor_urb(urb, &parent->rx_submitted);\n\n\t\t\trc = usb_submit_urb(urb, GFP_KERNEL);\n\t\t\tif (rc) {\n\t\t\t\tif (rc == -ENODEV)\n\t\t\t\t\tnetif_device_detach(dev->netdev);\n\n\t\t\t\tnetdev_err(netdev,\n\t\t\t\t\t   \"usb_submit failed (err=%d)\\n\",\n\t\t\t\t\t   rc);\n\n\t\t\t\tusb_unanchor_urb(urb);\n\t\t\t\tusb_free_urb(urb);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Drop reference,\n\t\t\t * USB core will take care of freeing it\n\t\t\t */\n\t\t\tusb_free_urb(urb);\n\t\t}\n\t}\n\n\tdm = kmalloc(sizeof(*dm), GFP_KERNEL);\n\tif (!dm)\n\t\treturn -ENOMEM;\n\n\t/* flags */\n\tctrlmode = dev->can.ctrlmode;\n\tdm->flags = 0;\n\n\tif (ctrlmode & CAN_CTRLMODE_LOOPBACK)\n\t\tdm->flags |= GS_CAN_MODE_LOOP_BACK;\n\telse if (ctrlmode & CAN_CTRLMODE_LISTENONLY)\n\t\tdm->flags |= GS_CAN_MODE_LISTEN_ONLY;\n\n\t/* Controller is not allowed to retry TX\n\t * this mode is unavailable on atmels uc3c hardware\n\t */\n\tif (ctrlmode & CAN_CTRLMODE_ONE_SHOT)\n\t\tdm->flags |= GS_CAN_MODE_ONE_SHOT;\n\n\tif (ctrlmode & CAN_CTRLMODE_3_SAMPLES)\n\t\tdm->flags |= GS_CAN_MODE_TRIPLE_SAMPLE;\n\n\t/* finally start device */\n\tdm->mode = GS_CAN_MODE_START;\n\trc = usb_control_msg(interface_to_usbdev(dev->iface),\n\t\t\t     usb_sndctrlpipe(interface_to_usbdev(dev->iface), 0),\n\t\t\t     GS_USB_BREQ_MODE,\n\t\t\t     USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t     USB_RECIP_INTERFACE,\n\t\t\t     dev->channel,\n\t\t\t     0,\n\t\t\t     dm,\n\t\t\t     sizeof(*dm),\n\t\t\t     1000);\n\n\tif (rc < 0) {\n\t\tnetdev_err(netdev, \"Couldn't start device (err=%d)\\n\", rc);\n\t\tkfree(dm);\n\t\treturn rc;\n\t}\n\n\tkfree(dm);\n\n\tdev->can.state = CAN_STATE_ERROR_ACTIVE;\n\n\tif (!(dev->can.ctrlmode & CAN_CTRLMODE_LISTENONLY))\n\t\tnetif_start_queue(netdev);\n\n\treturn 0;\n}", "target": 2, "idx": 9828}
{"commit_id": "9cc02ede696272c5271a401e4f27c262359bc2f6", "project": "torvalds/linux", "func": "void rose_stop_idletimer(struct sock *sk)\n{\n\tsk_stop_timer(sk, &rose_sk(sk)->idletimer);\n}", "target": 1, "idx": 9829}
{"commit_id": "77991e92337bb7474c439e1f579648e4e42cb595", "project": "google/flatbuffers", "func": "void GenEnum(const EnumDef &enum_def) {\n    code_.SetValue(\"ENUM_NAME\", Name(enum_def));\n    code_.SetValue(\"BASE_TYPE\", GetEnumTypeForDecl(enum_def.underlying_type));\n    code_.SetValue(\"ENUM_NAME_SNAKE\", MakeSnakeCase(Name(enum_def)));\n    code_.SetValue(\"ENUM_NAME_CAPS\", MakeUpper(MakeSnakeCase(Name(enum_def))));\n    const EnumVal *minv = enum_def.MinValue();\n    const EnumVal *maxv = enum_def.MaxValue();\n    FLATBUFFERS_ASSERT(minv && maxv);\n    code_.SetValue(\"ENUM_MIN_BASE_VALUE\", enum_def.ToString(*minv));\n    code_.SetValue(\"ENUM_MAX_BASE_VALUE\", enum_def.ToString(*maxv));\n\n    if (IsBitFlagsEnum(enum_def)) {\n      // Defer to the convenient and canonical bitflags crate. We declare it in\n      // a module to #allow camel case constants in a smaller scope. This\n      // matches Flatbuffers c-modeled enums where variants are associated\n      // constants but in camel case.\n      code_ += \"#[allow(non_upper_case_globals)]\";\n      code_ += \"mod bitflags_{{ENUM_NAME_SNAKE}} {\";\n      code_ += \"  flatbuffers::bitflags::bitflags! {\";\n      GenComment(enum_def.doc_comment, \"    \");\n      code_ += \"    #[derive(Default)]\";\n      code_ += \"    pub struct {{ENUM_NAME}}: {{BASE_TYPE}} {\";\n      ForAllEnumValues1(enum_def, [&](const EnumVal &ev) {\n        this->GenComment(ev.doc_comment, \"      \");\n        code_ += \"      const {{VARIANT}} = {{VALUE}};\";\n      });\n      code_ += \"    }\";\n      code_ += \"  }\";\n      code_ += \"}\";\n      code_ += \"pub use self::bitflags_{{ENUM_NAME_SNAKE}}::{{ENUM_NAME}};\";\n      code_ += \"\";\n\n      code_.SetValue(\"FROM_BASE\", \"unsafe { Self::from_bits_unchecked(b) }\");\n      code_.SetValue(\"INTO_BASE\", \"self.bits()\");\n    } else {\n      // Normal, c-modelled enums.\n      // Deprecated associated constants;\n      const std::string deprecation_warning =\n          \"#[deprecated(since = \\\"2.0.0\\\", note = \\\"Use associated constants\"\n          \" instead. This will no longer be generated in 2021.\\\")]\";\n      code_ += deprecation_warning;\n      code_ +=\n          \"pub const ENUM_MIN_{{ENUM_NAME_CAPS}}: {{BASE_TYPE}}\"\n          \" = {{ENUM_MIN_BASE_VALUE}};\";\n      code_ += deprecation_warning;\n      code_ +=\n          \"pub const ENUM_MAX_{{ENUM_NAME_CAPS}}: {{BASE_TYPE}}\"\n          \" = {{ENUM_MAX_BASE_VALUE}};\";\n      auto num_fields = NumToString(enum_def.size());\n      code_ += deprecation_warning;\n      code_ += \"#[allow(non_camel_case_types)]\";\n      code_ += \"pub const ENUM_VALUES_{{ENUM_NAME_CAPS}}: [{{ENUM_NAME}}; \" +\n               num_fields + \"] = [\";\n      ForAllEnumValues1(enum_def, [&](const EnumVal &ev) {\n        code_ += \"  \" + GetEnumValue(enum_def, ev) + \",\";\n      });\n      code_ += \"];\";\n      code_ += \"\";\n\n      GenComment(enum_def.doc_comment);\n      // Derive Default to be 0. flatc enforces this when the enum\n      // is put into a struct, though this isn't documented behavior, it is\n      // needed to derive defaults in struct objects.\n      code_ +=\n          \"#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, \"\n          \"Default)]\";\n      code_ += \"#[repr(transparent)]\";\n      code_ += \"pub struct {{ENUM_NAME}}(pub {{BASE_TYPE}});\";\n      code_ += \"#[allow(non_upper_case_globals)]\";\n      code_ += \"impl {{ENUM_NAME}} {\";\n      ForAllEnumValues1(enum_def, [&](const EnumVal &ev) {\n        this->GenComment(ev.doc_comment, \"  \");\n        code_ += \"  pub const {{VARIANT}}: Self = Self({{VALUE}});\";\n      });\n      code_ += \"\";\n      // Generate Associated constants\n      code_ += \"  pub const ENUM_MIN: {{BASE_TYPE}} = {{ENUM_MIN_BASE_VALUE}};\";\n      code_ += \"  pub const ENUM_MAX: {{BASE_TYPE}} = {{ENUM_MAX_BASE_VALUE}};\";\n      code_ += \"  pub const ENUM_VALUES: &'static [Self] = &[\";\n      ForAllEnumValues(enum_def, [&]() { code_ += \"    Self::{{VARIANT}},\"; });\n      code_ += \"  ];\";\n      code_ += \"  /// Returns the variant's name or \\\"\\\" if unknown.\";\n      code_ += \"  pub fn variant_name(self) -> Option<&'static str> {\";\n      code_ += \"    match self {\";\n      ForAllEnumValues(enum_def, [&]() {\n        code_ += \"      Self::{{VARIANT}} => Some(\\\"{{VARIANT}}\\\"),\";\n      });\n      code_ += \"      _ => None,\";\n      code_ += \"    }\";\n      code_ += \"  }\";\n      code_ += \"}\";\n\n      // Generate Debug. Unknown variants are printed like \"<UNKNOWN 42>\".\n      code_ += \"impl std::fmt::Debug for {{ENUM_NAME}} {\";\n      code_ +=\n          \"  fn fmt(&self, f: &mut std::fmt::Formatter) ->\"\n          \" std::fmt::Result {\";\n      code_ += \"    if let Some(name) = self.variant_name() {\";\n      code_ += \"      f.write_str(name)\";\n      code_ += \"    } else {\";\n      code_ += \"      f.write_fmt(format_args!(\\\"<UNKNOWN {:?}>\\\", self.0))\";\n      code_ += \"    }\";\n      code_ += \"  }\";\n      code_ += \"}\";\n\n      code_.SetValue(\"FROM_BASE\", \"Self(b)\");\n      code_.SetValue(\"INTO_BASE\", \"self.0\");\n    }\n\n    // Generate Follow and Push so we can serialize and stuff.\n    code_ += \"impl<'a> flatbuffers::Follow<'a> for {{ENUM_NAME}} {\";\n    code_ += \"  type Inner = Self;\";\n    code_ += \"  #[inline]\";\n    code_ += \"  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\";\n    code_ += \"    let b = unsafe {\";\n    code_ += \"      flatbuffers::read_scalar_at::<{{BASE_TYPE}}>(buf, loc)\";\n    code_ += \"    };\";\n    code_ += \"    {{FROM_BASE}}\";\n    code_ += \"  }\";\n    code_ += \"}\";\n    code_ += \"\";\n    code_ += \"impl flatbuffers::Push for {{ENUM_NAME}} {\";\n    code_ += \"    type Output = {{ENUM_NAME}};\";\n    code_ += \"    #[inline]\";\n    code_ += \"    fn push(&self, dst: &mut [u8], _rest: &[u8]) {\";\n    code_ +=\n        \"        unsafe { flatbuffers::emplace_scalar::<{{BASE_TYPE}}>\"\n        \"(dst, {{INTO_BASE}}); }\";\n    code_ += \"    }\";\n    code_ += \"}\";\n    code_ += \"\";\n    code_ += \"impl flatbuffers::EndianScalar for {{ENUM_NAME}} {\";\n    code_ += \"  #[inline]\";\n    code_ += \"  fn to_little_endian(self) -> Self {\";\n    code_ += \"    let b = {{BASE_TYPE}}::to_le({{INTO_BASE}});\";\n    code_ += \"    {{FROM_BASE}}\";\n    code_ += \"  }\";\n    code_ += \"  #[inline]\";\n    code_ += \"  #[allow(clippy::wrong_self_convention)]\";\n    code_ += \"  fn from_little_endian(self) -> Self {\";\n    code_ += \"    let b = {{BASE_TYPE}}::from_le({{INTO_BASE}});\";\n    code_ += \"    {{FROM_BASE}}\";\n    code_ += \"  }\";\n    code_ += \"}\";\n    code_ += \"\";\n\n    // Generate verifier - deferring to the base type.\n    code_ += \"impl<'a> flatbuffers::Verifiable for {{ENUM_NAME}} {\";\n    code_ += \"  #[inline]\";\n    code_ += \"  fn run_verifier(\";\n    code_ += \"    v: &mut flatbuffers::Verifier, pos: usize\";\n    code_ += \"  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {\";\n    code_ += \"    use self::flatbuffers::Verifiable;\";\n    code_ += \"    {{BASE_TYPE}}::run_verifier(v, pos)\";\n    code_ += \"  }\";\n    code_ += \"}\";\n    code_ += \"\";\n    // Enums are basically integers.\n    code_ += \"impl flatbuffers::SimpleToVerifyInSlice for {{ENUM_NAME}} {}\";\n\n    if (enum_def.is_union) {\n      // Generate typesafe offset(s) for unions\n      code_.SetValue(\"NAME\", Name(enum_def));\n      code_.SetValue(\"UNION_OFFSET_NAME\", Name(enum_def) + \"UnionTableOffset\");\n      code_ += \"pub struct {{UNION_OFFSET_NAME}} {}\";\n      code_ += \"\";\n      if (parser_.opts.generate_object_based_api) { GenUnionObject(enum_def); }\n    }\n  }", "target": 2, "idx": 9830}
{"commit_id": "4f5d33f4f798b1c6d92b613f0087f639d9836971", "project": "kernel/git/klassert/ipsec-next", "func": "static struct slave *rlb_arp_xmit(struct sk_buff *skb, struct bonding *bond)\n{\n\tstruct slave *tx_slave = NULL;\n\tstruct net_device *dev;\n\tstruct arp_pkt *arp;\n\n\tif (!pskb_network_may_pull(skb, sizeof(*arp)))\n\t\treturn NULL;\n\tarp = (struct arp_pkt *)skb_network_header(skb);\n\n\t/* Don't modify or load balance ARPs that do not originate locally\n\t * (e.g.,arrive via a bridge).\n\t */\n\tif (!bond_slave_has_mac_rx(bond, arp->mac_src))\n\t\treturn NULL;\n\n\tdev = ip_dev_find(dev_net(bond->dev), arp->ip_src);\n\tif (dev) {\n\t\tif (netif_is_bridge_master(dev)) {\n\t\t\tdev_put(dev);\n\t\t\treturn NULL;\n\t\t}\n\t\tdev_put(dev);\n\t}\n\n\tif (arp->op_code == htons(ARPOP_REPLY)) {\n\t\t/* the arp must be sent on the selected rx channel */\n\t\ttx_slave = rlb_choose_channel(skb, bond, arp);\n\t\tif (tx_slave)\n\t\t\tbond_hw_addr_copy(arp->mac_src, tx_slave->dev->dev_addr,\n\t\t\t\t\t  tx_slave->dev->addr_len);\n\t\tnetdev_dbg(bond->dev, \"(slave %s): Server sent ARP Reply packet\\n\",\n\t\t\t   tx_slave ? tx_slave->dev->name : \"NULL\");\n\t} else if (arp->op_code == htons(ARPOP_REQUEST)) {\n\t\t/* Create an entry in the rx_hashtbl for this client as a\n\t\t * place holder.\n\t\t * When the arp reply is received the entry will be updated\n\t\t * with the correct unicast address of the client.\n\t\t */\n\t\ttx_slave = rlb_choose_channel(skb, bond, arp);\n\n\t\t/* The ARP reply packets must be delayed so that\n\t\t * they can cancel out the influence of the ARP request.\n\t\t */\n\t\tbond->alb_info.rlb_update_delay_counter = RLB_UPDATE_DELAY;\n\n\t\t/* arp requests are broadcast and are sent on the primary\n\t\t * the arp request will collapse all clients on the subnet to\n\t\t * the primary slave. We must register these clients to be\n\t\t * updated with their assigned mac.\n\t\t */\n\t\trlb_req_update_subnet_clients(bond, arp->ip_src);\n\t\tnetdev_dbg(bond->dev, \"(slave %s): Server sent ARP Request packet\\n\",\n\t\t\t   tx_slave ? tx_slave->dev->name : \"NULL\");\n\t}\n\n\treturn tx_slave;\n}", "target": 0, "idx": 9831}
{"commit_id": "c677ee92595335233eb0e7b59809a1a94e7a678a", "project": "android", "func": "void BTM_PINCodeReply (BD_ADDR bd_addr, UINT8 res, UINT8 pin_len, UINT8 *p_pin, UINT32 trusted_mask[])\n{\n    tBTM_SEC_DEV_REC *p_dev_rec;\n\n    BTM_TRACE_API (\"BTM_PINCodeReply(): PairState: %s   PairFlags: 0x%02x  PinLen:%d  Result:%d\",\n                    btm_pair_state_descr(btm_cb.pairing_state), btm_cb.pairing_flags, pin_len, res);\n\n    /* If timeout already expired or has been canceled, ignore the reply */\n    if (btm_cb.pairing_state != BTM_PAIR_STATE_WAIT_LOCAL_PIN)\n    {\n        BTM_TRACE_WARNING (\"BTM_PINCodeReply() - Wrong State: %d\", btm_cb.pairing_state);\n        return;\n    }\n\n    if (memcmp (bd_addr, btm_cb.pairing_bda, BD_ADDR_LEN) != 0)\n    {\n        BTM_TRACE_ERROR (\"BTM_PINCodeReply() - Wrong BD Addr\");\n        return;\n    }\n\n    if ((p_dev_rec = btm_find_dev (bd_addr)) == NULL)\n    {\n        BTM_TRACE_ERROR (\"BTM_PINCodeReply() - no dev CB\");\n        return;\n    }\n\n    if ( (pin_len > PIN_CODE_LEN) || (pin_len == 0) || (p_pin == NULL) )\n        res = BTM_ILLEGAL_VALUE;\n\n    if (res != BTM_SUCCESS)\n    {\n        /* if peer started dd OR we started dd and pre-fetch pin was not used send negative reply */\n        if ((btm_cb.pairing_flags & BTM_PAIR_FLAGS_PEER_STARTED_DD) ||\n            ((btm_cb.pairing_flags & BTM_PAIR_FLAGS_WE_STARTED_DD) &&\n            (btm_cb.pairing_flags & BTM_PAIR_FLAGS_DISC_WHEN_DONE)) )\n        {\n            /* use BTM_PAIR_STATE_WAIT_AUTH_COMPLETE to report authentication failed event */\n            btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);\n            btm_cb.acl_disc_reason = HCI_ERR_HOST_REJECT_SECURITY;\n\n            btsnd_hcic_pin_code_neg_reply (bd_addr);\n        }\n        else\n        {\n            p_dev_rec->security_required = BTM_SEC_NONE;\n            btm_sec_change_pairing_state (BTM_PAIR_STATE_IDLE);\n        }\n        return;\n    }\n    if (trusted_mask)\n        BTM_SEC_COPY_TRUSTED_DEVICE(trusted_mask, p_dev_rec->trusted_mask);\n    p_dev_rec->sec_flags   |= BTM_SEC_LINK_KEY_AUTHED;\n\n    if ( (btm_cb.pairing_flags & BTM_PAIR_FLAGS_WE_STARTED_DD)\n         &&  (p_dev_rec->hci_handle == BTM_SEC_INVALID_HANDLE)\n         &&  (btm_cb.security_mode_changed == FALSE) )\n    {\n        /* This is start of the dedicated bonding if local device is 2.0 */\n        btm_cb.pin_code_len = pin_len;\n        memcpy (btm_cb.pin_code, p_pin, pin_len);\n\n        btm_cb.security_mode_changed = TRUE;\n#ifdef APPL_AUTH_WRITE_EXCEPTION\n        if(!(APPL_AUTH_WRITE_EXCEPTION)(p_dev_rec->bd_addr))\n#endif\n        btsnd_hcic_write_auth_enable (TRUE);\n\n        btm_cb.acl_disc_reason = 0xff ;\n\n        /* if we rejected incoming connection request, we have to wait HCI_Connection_Complete event */\n        /*  before originating  */\n        if (btm_cb.pairing_flags & BTM_PAIR_FLAGS_REJECTED_CONNECT)\n        {\n            BTM_TRACE_WARNING (\"BTM_PINCodeReply(): waiting HCI_Connection_Complete after rejected incoming connection\");\n            /* we change state little bit early so btm_sec_connected() will originate connection */\n            /*   when existing ACL link is down completely */\n            btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_PIN_REQ);\n        }\n        /* if we already accepted incoming connection from pairing device */\n        else if (p_dev_rec->sm4 & BTM_SM4_CONN_PEND)\n        {\n            BTM_TRACE_WARNING (\"BTM_PINCodeReply(): link is connecting so wait pin code request from peer\");\n            btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_PIN_REQ);\n        }\n        else if (btm_sec_dd_create_conn(p_dev_rec) != BTM_CMD_STARTED)\n        {\n            btm_sec_change_pairing_state (BTM_PAIR_STATE_IDLE);\n            p_dev_rec->sec_flags &= ~BTM_SEC_LINK_KEY_AUTHED;\n\n            if (btm_cb.api.p_auth_complete_callback)\n                (*btm_cb.api.p_auth_complete_callback) (p_dev_rec->bd_addr,  p_dev_rec->dev_class,\n                                                    p_dev_rec->sec_bd_name, HCI_ERR_AUTH_FAILURE);\n        }\n        return;\n    }\n\n    btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);\n    btm_cb.acl_disc_reason = HCI_SUCCESS;\n\n    btsnd_hcic_pin_code_req_reply (bd_addr, pin_len, p_pin);\n}", "target": 2, "idx": 9832}
{"commit_id": "edb272e35ee57e7b89f3e127222c6981b6a1e730", "project": "wolfSSL/wolfssh", "func": "int wolfSSH_SFTP_RecvWrite(WOLFSSH* ssh, int reqId, byte* data, word32 maxSz)\n#ifndef USE_WINDOWS_API\n{\n    WFD    fd;\n    word32 sz;\n    int    ret  = WS_SUCCESS;\n    word32 idx  = 0;\n    word32 ofst[2] = {0,0};\n\n    word32 outSz = 0;\n    byte*  out   = NULL;\n\n    char  suc[] = \"Write File Success\";\n    char  err[] = \"Write File Error\";\n    char* res  = suc;\n    byte  type = WOLFSSH_FTP_OK;\n\n    if (ssh == NULL) {\n        return WS_BAD_ARGUMENT;\n    }\n\n    WLOG(WS_LOG_SFTP, \"Receiving WOLFSSH_FTP_WRITE\");\n\n    /* get file handle */\n    ato32(data + idx, &sz); idx += UINT32_SZ;\n    if (sz + idx > maxSz || sz > WOLFSSH_MAX_HANDLE) {\n        WLOG(WS_LOG_SFTP, \"Error with file handle size\");\n        res  = err;\n        type = WOLFSSH_FTP_FAILURE;\n        ret  = WS_BAD_FILE_E;\n    }\n\n    if (ret == WS_SUCCESS) {\n        WMEMSET((byte*)&fd, 0, sizeof(WFD));\n        WMEMCPY((byte*)&fd, data + idx, sz); idx += sz;\n\n        /* get offset into file */\n        ato32(data + idx, &ofst[1]); idx += UINT32_SZ;\n        ato32(data + idx, &ofst[0]); idx += UINT32_SZ;\n\n        /* get length to be written */\n        ato32(data + idx, &sz); idx += UINT32_SZ;\n        if (sz > maxSz - idx) {\n            return WS_BUFFER_E;\n        }\n\n        ret = WPWRITE(fd, data + idx, sz, ofst);\n        if (ret < 0) {\n    #if defined(WOLFSSL_NUCLEUS) && defined(DEBUG_WOLFSSH)\n            if (ret == NUF_NOSPC) {\n                WLOG(WS_LOG_SFTP, \"Ran out of memory\");\n            }\n    #endif\n            WLOG(WS_LOG_SFTP, \"Error writing to file\");\n            res  = err;\n            type = WOLFSSH_FTP_FAILURE;\n            ret  = WS_INVALID_STATE_E;\n        }\n        else {\n            ret = WS_SUCCESS;\n        }\n    }\n\n        if (sz > maxSz - idx) {\n            return WS_BUFFER_E;\n        }\n    if (wolfSSH_SFTP_CreateStatus(ssh, type, reqId, res, \"English\", NULL,\n                &outSz) != WS_SIZE_ONLY) {\n        return WS_FATAL_ERROR;\n    }\n    out = (byte*)WMALLOC(outSz, ssh->ctx->heap, DYNTYPE_BUFFER);\n    if (out == NULL) {\n        return WS_MEMORY_E;\n    }\n    if (wolfSSH_SFTP_CreateStatus(ssh, type, reqId, res, \"English\", out,\n                &outSz) != WS_SUCCESS) {\n        WFREE(out, ssh->ctx->heap, DYNTYPE_BUFFER);\n        return WS_FATAL_ERROR;\n    }\n\n    /* set send out buffer, \"out\" is taken by ssh  */\n    wolfSSH_SFTP_RecvSetSend(ssh, out, outSz);\n    return ret;\n}", "target": 3, "idx": 9833}
{"commit_id": "4c1586787ff43c9acd18a56c12d720e3e6be9f7c", "project": "qemu", "func": "static void coroutine_fn v9fs_link(void *opaque)\n{\n    V9fsPDU *pdu = opaque;\n    int32_t dfid, oldfid;\n    V9fsFidState *dfidp, *oldfidp;\n    V9fsString name;\n    size_t offset = 7;\n    int err = 0;\n\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dds\", &dfid, &oldfid, &name);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_link(pdu->tag, pdu->id, dfid, oldfid, name.data);\n\n    if (name_is_illegal(name.data)) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    if (!strcmp(\".\", name.data) || !strcmp(\"..\", name.data)) {\n        err = -EEXIST;\n        goto out_nofid;\n    }\n\n    dfidp = get_fid(pdu, dfid);\n    if (dfidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    oldfidp = get_fid(pdu, oldfid);\n    if (oldfidp == NULL) {\n        err = -ENOENT;\n        goto out;\n    }\n    err = v9fs_co_link(pdu, oldfidp, dfidp, &name);\n    if (!err) {\n        err = offset;\n    }\n    put_fid(pdu, oldfidp);\nout:\n    put_fid(pdu, dfidp);\nout_nofid:\n    v9fs_string_free(&name);\n    pdu_complete(pdu, err);\n}", "target": 1, "idx": 9834}
{"commit_id": "25821e6d74fab5fcc200fe5e818362e03e114428", "project": "ArtifexSoftware/mujs", "func": "double\njs_strtod(const char *string, char **endPtr)\n{\n\tint sign, expSign = FALSE;\n\tdouble fraction, dblExp, *d;\n\tregister const char *p;\n\tregister int c;\n\n\t/* Exponent read from \"EX\" field. */\n\tint exp = 0;\n\n\t/* Exponent that derives from the fractional part. Under normal\n\t * circumstances, it is the negative of the number of digits in F.\n\t * However, if I is very long, the last digits of I get dropped\n\t * (otherwise a long I with a large negative exponent could cause an\n\t * unnecessary overflow on I alone). In this case, fracExp is\n\t * incremented one for each dropped digit.\n\t */\n\tint fracExp = 0;\n\n\t/* Number of digits in mantissa. */\n\tint mantSize;\n\n\t/* Number of mantissa digits BEFORE decimal point. */\n\tint decPt;\n\n\t/* Temporarily holds location of exponent in string. */\n\tconst char *pExp;\n\n\t/*\n\t * Strip off leading blanks and check for a sign.\n\t */\n\n\tp = string;\n\twhile (*p == ' ' || *p == '\\t' || *p == '\\n' || *p == '\\r') {\n\t\tp += 1;\n\t}\n\tif (*p == '-') {\n\t\tsign = TRUE;\n\t\tp += 1;\n\t} else {\n\t\tif (*p == '+') {\n\t\t\tp += 1;\n\t\t}\n\t\tsign = FALSE;\n\t}\n\n\t/*\n\t * Count the number of digits in the mantissa (including the decimal\n\t * point), and also locate the decimal point.\n\t */\n\n\tdecPt = -1;\n\tfor (mantSize = 0; ; mantSize += 1)\n\t{\n\t\tc = *p;\n\t\tif (!(c>='0'&&c<='9')) {\n\t\t\tif ((c != '.') || (decPt >= 0)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdecPt = mantSize;\n\t\t}\n\t\tp += 1;\n\t}\n\n\t/*\n\t * Now suck up the digits in the mantissa. Use two integers to\n\t * collect 9 digits each (this is faster than using floating-point).\n\t * If the mantissa has more than 18 digits, ignore the extras, since\n\t * they can't affect the value anyway.\n\t */\n\n\tpExp = p;\n\tp -= mantSize;\n\tif (decPt < 0) {\n\t\tdecPt = mantSize;\n\t} else {\n\t\tmantSize -= 1;\t\t\t/* One of the digits was the point. */\n\t}\n\tif (mantSize > 18) {\n\t\tfracExp = decPt - 18;\n\t\tmantSize = 18;\n\t} else {\n\t\tfracExp = decPt - mantSize;\n\t}\n\tif (mantSize == 0) {\n\t\tfraction = 0.0;\n\t\tp = string;\n\t\tgoto done;\n\t} else {\n\t\tint frac1, frac2;\n\t\tfrac1 = 0;\n\t\tfor ( ; mantSize > 9; mantSize -= 1)\n\t\t{\n\t\t\tc = *p;\n\t\t\tp += 1;\n\t\t\tif (c == '.') {\n\t\t\t\tc = *p;\n\t\t\t\tp += 1;\n\t\t\t}\n\t\t\tfrac1 = 10*frac1 + (c - '0');\n\t\t}\n\t\tfrac2 = 0;\n\t\tfor (; mantSize > 0; mantSize -= 1)\n\t\t{\n\t\t\tc = *p;\n\t\t\tp += 1;\n\t\t\tif (c == '.') {\n\t\t\t\tc = *p;\n\t\t\t\tp += 1;\n\t\t\t}\n\t\t\tfrac2 = 10*frac2 + (c - '0');\n\t\t}\n\t\tfraction = (1.0e9 * frac1) + frac2;\n\t}\n\n\t/*\n\t * Skim off the exponent.\n\t */\n\n\tp = pExp;\n\tif ((*p == 'E') || (*p == 'e')) {\n\t\tp += 1;\n\t\tif (*p == '-') {\n\t\t\texpSign = TRUE;\n\t\t\tp += 1;\n\t\t} else {\n\t\t\tif (*p == '+') {\n\t\t\t\tp += 1;\n\t\t\t}\n\t\t\texpSign = FALSE;\n\t\t}\n\t\twhile ((*p >= '0') && (*p <= '9')) {\n\t\t\texp = exp * 10 + (*p - '0');\n\t\t\tp += 1;\n\t\t}\n\t}\n\tif (expSign) {\n\t\texp = fracExp - exp;\n\t} else {\n\t\texp = fracExp + exp;\n\t}\n\n\t/*\n\t * Generate a floating-point number that represents the exponent.\n\t * Do this by processing the exponent one bit at a time to combine\n\t * many powers of 2 of 10. Then combine the exponent with the\n\t * fraction.\n\t */\n\n\tif (exp < -maxExponent) {\n\t\texp = maxExponent;\n\t\texpSign = TRUE;\n\t\terrno = ERANGE;\n\t} else if (exp > maxExponent) {\n\t\texp = maxExponent;\n\t\texpSign = FALSE;\n\t\terrno = ERANGE;\n\t} else if (exp < 0) {\n\t\texpSign = TRUE;\n\t\texp = -exp;\n\t} else {\n\t\texpSign = FALSE;\n\t}\n\tdblExp = 1.0;\n\tfor (d = powersOf10; exp != 0; exp >>= 1, d += 1) {\n\t\tif (exp & 01) {\n\t\t\tdblExp *= *d;\n\t\t}\n\t}\n\tif (expSign) {\n\t\tfraction /= dblExp;\n\t} else {\n\t\tfraction *= dblExp;\n\t}\n\ndone:\n\tif (endPtr != NULL) {\n\t\t*endPtr = (char *) p;\n\t}\n\n\tif (sign) {\n\t\treturn -fraction;\n\t}\n\treturn fraction;\n}", "target": 1, "idx": 9835}
{"commit_id": "e086f4b35b1adf7edc35b4ad332dc7ed1edc5988", "project": "teeworlds", "func": "void CDataFileReader::UnloadData(int Index)\n{\n\tif(Index < 0 || Index >= m_pDataFile->m_Header.m_NumRawData)\n\t\treturn;\n\n\tmem_free(m_pDataFile->m_ppDataPtrs[Index]);\n\tm_pDataFile->m_ppDataPtrs[Index] = 0x0;\n}", "target": 3, "idx": 9836}
{"commit_id": "8d68dad9c9f220058e86dc7f3d05acca6b9aedf5", "project": "brackeen/ok-file-formats", "func": "static void ok_jpg_decode2(ok_jpg_decoder *decoder) {\n    ok_jpg *jpg = decoder->jpg;\n\n    // Read header\n    uint8_t jpg_header[2];\n    if (!ok_read(decoder, jpg_header, 2)) {\n        return;\n    }\n    if (jpg_header[0] != 0xFF || jpg_header[1] != 0xD8) {\n        ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, \"Invalid signature (not a JPEG file)\");\n        return;\n    }\n\n    while (!decoder->eoi_found) {\n        // Read marker\n        int marker;\n        if (decoder->next_marker != 0) {\n            marker = decoder->next_marker;\n            decoder->next_marker = 0;\n        } else {\n            while (true) {\n                uint8_t b;\n                if (!ok_read(decoder, &b, 1)) {\n                    return;\n                }\n                if (b == 0xFF) {\n                    if (!ok_read(decoder, &b, 1)) {\n                        return;\n                    }\n                    if (b != 0 && b != 0xFF) {\n                        marker = b;\n                        break;\n                    }\n                }\n            }\n        }\n\n        bool success = true;\n        if (marker == 0xC0 || marker == 0xC1 || marker == 0xC2) {\n            // SOF\n            decoder->progressive = (marker == 0xC2);\n            success = ok_jpg_read_sof(decoder);\n            if (success && decoder->info_only) {\n                return;\n            }\n        } else if (marker == 0xC4) {\n            // DHT\n            success = decoder->info_only ? ok_jpg_skip_segment(decoder) : ok_jpg_read_dht(decoder);\n        } else if (marker >= 0xD0 && marker <= 0xD7) {\n            decoder->next_marker = marker;\n            success = ok_jpg_decode_restart_if_needed(decoder);\n            if (success) {\n                success = ok_jpg_scan_to_next_marker(decoder);\n            }\n        } else if (marker == 0xD9) {\n            // EOI\n            decoder->eoi_found = true;\n            if (!decoder->info_only && decoder->progressive) {\n                ok_jpg_progressive_finish(decoder);\n            }\n        } else if (marker == 0xDA) {\n            // SOS\n            if (!decoder->info_only) {\n                success = ok_jpg_read_sos(decoder);\n            } else {\n                success = ok_jpg_skip_segment(decoder);\n                if (success) {\n                    success = ok_jpg_scan_to_next_marker(decoder);\n                }\n            }\n        } else if (marker == 0xDB) {\n            // DQT\n            success = decoder->info_only ? ok_jpg_skip_segment(decoder) : ok_jpg_read_dqt(decoder);\n        } else if (marker == 0xDD) {\n            // DRI\n            success = ok_jpg_read_dri(decoder);\n        } else if (marker == 0xE1) {\n            // APP1 - EXIF metadata\n            // (Expect to find before allocation in SOF)\n            if (decoder->sof_found) {\n                success = ok_jpg_skip_segment(decoder);\n            } else {\n                success = ok_jpg_read_exif(decoder);\n            }\n        } else if ((marker >= 0xE0 && marker <= 0xEF) || marker == 0xFE) {\n            // APP or Comment\n            success = ok_jpg_skip_segment(decoder);\n        } else if (marker == 0xFF) {\n            // Ignore\n        } else {\n            ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, \"Unsupported or corrupt JPEG\");\n            success = false;\n        }\n\n        if (!success) {\n            return;\n        }\n    }\n\n    if (decoder->num_components == 0) {\n        ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, \"SOF not found\");\n    } else {\n        for (int i = 0; i < decoder->num_components; i++) {\n            if (!decoder->components[i].complete) {\n                ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, \"Missing JPEG image data\");\n                break;\n            }\n        }\n    }\n}", "target": 2, "idx": 9837}
{"commit_id": "7a0f441e1410b3a0d97374c00c4007552d7dd27a", "project": "pdfium", "func": "static void opj_pi_update_decode_poc (opj_pi_iterator_t * p_pi,\n                               opj_tcp_t * p_tcp,\n                               OPJ_UINT32 p_max_precision,\n                               OPJ_UINT32 p_max_res)\n{\n\t/* loop*/\n\tOPJ_UINT32 pino;\n\n\t/* encoding prameters to set*/\n\tOPJ_UINT32 l_bound;\n\n\topj_pi_iterator_t * l_current_pi = 00;\n\topj_poc_t* l_current_poc = 0;\n\n    OPJ_ARG_NOT_USED(p_max_res);\n\n\t/* preconditions in debug*/\n\tassert(p_pi != 00);\n\tassert(p_tcp != 00);\n\n\t/* initializations*/\n\tl_bound = p_tcp->numpocs+1;\n\tl_current_pi = p_pi;\n\tl_current_poc = p_tcp->pocs;\n\n\tfor\t(pino = 0;pino<l_bound;++pino) {\n\t\tl_current_pi->poc.prg = l_current_poc->prg; /* Progression Order #0 */\n\t\tl_current_pi->first = 1;\n\n\t\tl_current_pi->poc.resno0 = l_current_poc->resno0; /* Resolution Level Index #0 (Start) */\n\t\tl_current_pi->poc.compno0 = l_current_poc->compno0; /* Component Index #0 (Start) */\n\t\tl_current_pi->poc.layno0 = 0;\n\t\tl_current_pi->poc.precno0 = 0;\n\t\tl_current_pi->poc.resno1 = l_current_poc->resno1; /* Resolution Level Index #0 (End) */\n\t\tl_current_pi->poc.compno1 = l_current_poc->compno1; /* Component Index #0 (End) */\n\t\tl_current_pi->poc.layno1 = opj_uint_min(l_current_poc->layno1, p_tcp->numlayers); /* Layer Index #0 (End) */\n\t\tl_current_pi->poc.precno1 = p_max_precision;\n\t\t++l_current_pi;\n\t\t++l_current_poc;\n\t}\n}", "target": 1, "idx": 9838}
{"commit_id": "0360aa7c418152a3e5e335a065ac3629cbb09559", "project": "android", "func": "static void btif_dm_auth_cmpl_evt (tBTA_DM_AUTH_CMPL *p_auth_cmpl)\n{\n    /* Save link key, if not temporary */\n    bt_bdaddr_t bd_addr;\n    bt_status_t status = BT_STATUS_FAIL;\n    bt_bond_state_t state = BT_BOND_STATE_NONE;\n    BOOLEAN skip_sdp = FALSE;\n\n    bdcpy(bd_addr.address, p_auth_cmpl->bd_addr);\n    if ( (p_auth_cmpl->success == TRUE) && (p_auth_cmpl->key_present) )\n    {\n        if ((p_auth_cmpl->key_type < HCI_LKEY_TYPE_DEBUG_COMB)  || (p_auth_cmpl->key_type == HCI_LKEY_TYPE_AUTH_COMB) ||\n            (p_auth_cmpl->key_type == HCI_LKEY_TYPE_CHANGED_COMB) || pairing_cb.bond_type == BOND_TYPE_PERSISTENT)\n        {\n            bt_status_t ret;\n            BTIF_TRACE_DEBUG(\"%s: Storing link key. key_type=0x%x, bond_type=%d\",\n                __FUNCTION__, p_auth_cmpl->key_type, pairing_cb.bond_type);\n            ret = btif_storage_add_bonded_device(&bd_addr,\n                                p_auth_cmpl->key, p_auth_cmpl->key_type,\n                                pairing_cb.pin_code_len);\n            ASSERTC(ret == BT_STATUS_SUCCESS, \"storing link key failed\", ret);\n        }\n        else\n        {\n            BTIF_TRACE_DEBUG(\"%s: Temporary key. Not storing. key_type=0x%x, bond_type=%d\",\n                __FUNCTION__, p_auth_cmpl->key_type, pairing_cb.bond_type);\n            if(pairing_cb.bond_type == BOND_TYPE_TEMPORARY)\n            {\n                BTIF_TRACE_DEBUG(\"%s: sending BT_BOND_STATE_NONE for Temp pairing\",\n                        __FUNCTION__);\n                bond_state_changed(BT_STATUS_SUCCESS, &bd_addr, BT_BOND_STATE_NONE);\n                return;\n            }\n        }\n    }\n\n    // Skip SDP for certain  HID Devices\n    if (p_auth_cmpl->success)\n    {\n        pairing_cb.timeout_retries = 0;\n        status = BT_STATUS_SUCCESS;\n        state = BT_BOND_STATE_BONDED;\n        bdcpy(bd_addr.address, p_auth_cmpl->bd_addr);\n\n        if (check_sdp_bl(&bd_addr) && check_cod_hid(&bd_addr, COD_HID_MAJOR))\n        {\n            ALOGW(\"%s:skip SDP\",\n                              __FUNCTION__);\n            skip_sdp = TRUE;\n        }\n        if(!pairing_cb.is_local_initiated && skip_sdp)\n        {\n            bond_state_changed(status, &bd_addr, state);\n\n            ALOGW(\"%s: Incoming HID Connection\",__FUNCTION__);\n            bt_property_t prop;\n            bt_bdaddr_t bd_addr;\n            bt_uuid_t  uuid;\n            char uuid_str[128] = UUID_HUMAN_INTERFACE_DEVICE;\n\n            string_to_uuid(uuid_str, &uuid);\n\n            prop.type = BT_PROPERTY_UUIDS;\n            prop.val = uuid.uu;\n            prop.len = MAX_UUID_SIZE;\n\n            /* Send the event to the BTIF */\n            HAL_CBACK(bt_hal_cbacks, remote_device_properties_cb,\n                             BT_STATUS_SUCCESS, &bd_addr, 1, &prop);\n        }\n        else\n        {\n            /* Trigger SDP on the device */\n            pairing_cb.sdp_attempts = 1;;\n\n            if(btif_dm_inquiry_in_progress)\n                btif_dm_cancel_discovery();\n\n            btif_dm_get_remote_services(&bd_addr);\n            }\n            /* Do not call bond_state_changed_cb yet. Wait till fetch remote service is complete */\n    }\n    else\n    {\n         /*Map the HCI fail reason  to  bt status  */\n        switch(p_auth_cmpl->fail_reason)\n        {\n            case HCI_ERR_PAGE_TIMEOUT:\n                if (blacklistPairingRetries(bd_addr.address) && pairing_cb.timeout_retries)\n                {\n                    BTIF_TRACE_WARNING(\"%s() - Pairing timeout; retrying (%d) ...\", __FUNCTION__, pairing_cb.timeout_retries);\n                    --pairing_cb.timeout_retries;\n                    btif_dm_cb_create_bond (&bd_addr, BTA_TRANSPORT_UNKNOWN);\n                    return;\n                }\n                /* Fall-through */\n            case HCI_ERR_CONNECTION_TOUT:\n                status =  BT_STATUS_RMT_DEV_DOWN;\n                break;\n\n            case HCI_ERR_PAIRING_NOT_ALLOWED:\n                status = BT_STATUS_AUTH_REJECTED;\n                break;\n\n            case HCI_ERR_LMP_RESPONSE_TIMEOUT:\n                status =  BT_STATUS_AUTH_FAILURE;\n                break;\n\n            /* map the auth failure codes, so we can retry pairing if necessary */\n            case HCI_ERR_AUTH_FAILURE:\n            case HCI_ERR_KEY_MISSING:\n                btif_storage_remove_bonded_device(&bd_addr);\n            case HCI_ERR_HOST_REJECT_SECURITY:\n            case HCI_ERR_ENCRY_MODE_NOT_ACCEPTABLE:\n            case HCI_ERR_UNIT_KEY_USED:\n            case HCI_ERR_PAIRING_WITH_UNIT_KEY_NOT_SUPPORTED:\n            case HCI_ERR_INSUFFCIENT_SECURITY:\n            case HCI_ERR_PEER_USER:\n            case HCI_ERR_UNSPECIFIED:\n                BTIF_TRACE_DEBUG(\" %s() Authentication fail reason %d\",\n                    __FUNCTION__, p_auth_cmpl->fail_reason);\n                if (pairing_cb.autopair_attempts  == 1)\n                {\n                    BTIF_TRACE_DEBUG(\"%s(): Adding device to blacklist \", __FUNCTION__);\n\n                    /* Add the device to dynamic black list only if this device belongs to Audio/pointing dev class  */\n                    if (check_cod(&bd_addr, COD_AV_HEADSETS) ||\n                        check_cod(&bd_addr, COD_AV_HANDSFREE) ||\n                        check_cod(&bd_addr, COD_AV_HEADPHONES) ||\n                        check_cod(&bd_addr, COD_AV_PORTABLE_AUDIO) ||\n                        check_cod(&bd_addr, COD_AV_HIFI_AUDIO) ||\n                        check_cod(&bd_addr, COD_HID_POINTING))\n                    {\n                        btif_storage_add_device_to_autopair_blacklist (&bd_addr);\n                    }\n                    pairing_cb.autopair_attempts++;\n\n                    /* Create the Bond once again */\n                    BTIF_TRACE_DEBUG(\"%s() auto pair failed. Reinitiate Bond\", __FUNCTION__);\n                    btif_dm_cb_create_bond (&bd_addr, BTA_TRANSPORT_UNKNOWN);\n                    return;\n                }\n                else\n                {\n                    /* if autopair attempts are more than 1, or not attempted */\n                    status =  BT_STATUS_AUTH_FAILURE;\n                }\n                break;\n\n            default:\n                status =  BT_STATUS_FAIL;\n        }\n        /* Special Handling for HID Devices */\n        if (check_cod(&bd_addr, COD_HID_POINTING)) {\n            /* Remove Device as bonded in nvram as authentication failed */\n            BTIF_TRACE_DEBUG(\"%s(): removing hid pointing device from nvram\", __FUNCTION__);\n            btif_storage_remove_bonded_device(&bd_addr);\n        }\n        bond_state_changed(status, &bd_addr, state);\n    }\n}", "target": 2, "idx": 9839}
{"commit_id": "838c0dc7641e1c991c0f3027bf94bee4606012f8", "project": "bluez", "func": "static struct pending_op *pending_ccc_new(struct bt_att *att,\n\t\t\t\t\tstruct gatt_db_attribute *attrib,\n\t\t\t\t\tuint16_t value,\n\t\t\t\t\tuint8_t link_type)\n{\n\tstruct pending_op *op;\n\tstruct btd_device *device;\n\n\tdevice = att_get_device(att);\n\tif (!device) {\n\t\terror(\"Unable to find device object\");\n\t\treturn NULL;\n\t}\n\n\top = new0(struct pending_op, 1);\n\n\top->data.iov_base = UINT_TO_PTR(value);\n\top->data.iov_len = sizeof(value);\n\n\top->att = bt_att_ref(att);\n\top->attrib = attrib;\n\top->link_type = link_type;\n\n\tbt_att_register_disconnect(att,\n\t\t\t\t   pending_disconnect_cb,\n\t\t\t\t   op,\n\t\t\t\t   NULL);\n\n\treturn op;\n}", "target": 3, "idx": 9840}
{"commit_id": "5d069dbe8aaf2a197142558b6fb2978189ba3454", "project": "torvalds/linux", "func": "ssize_t fuse_listxattr(struct dentry *entry, char *list, size_t size)\n{\n\tstruct inode *inode = d_inode(entry);\n\tstruct fuse_mount *fm = get_fuse_mount(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_getxattr_in inarg;\n\tstruct fuse_getxattr_out outarg;\n\tssize_t ret;\n\n\tif (fuse_is_bad(inode))\n\t\treturn -EIO;\n\n\tif (!fuse_allow_current_process(fm->fc))\n\t\treturn -EACCES;\n\n\tif (fm->fc->no_listxattr)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.size = size;\n\targs.opcode = FUSE_LISTXATTR;\n\targs.nodeid = get_node_id(inode);\n\targs.in_numargs = 1;\n\targs.in_args[0].size = sizeof(inarg);\n\targs.in_args[0].value = &inarg;\n\t/* This is really two different operations rolled into one */\n\targs.out_numargs = 1;\n\tif (size) {\n\t\targs.out_argvar = true;\n\t\targs.out_args[0].size = size;\n\t\targs.out_args[0].value = list;\n\t} else {\n\t\targs.out_args[0].size = sizeof(outarg);\n\t\targs.out_args[0].value = &outarg;\n\t}\n\tret = fuse_simple_request(fm, &args);\n\tif (!ret && !size)\n\t\tret = min_t(ssize_t, outarg.size, XATTR_LIST_MAX);\n\tif (ret > 0 && size)\n\t\tret = fuse_verify_xattr_list(list, ret);\n\tif (ret == -ENOSYS) {\n\t\tfm->fc->no_listxattr = 1;\n\t\tret = -EOPNOTSUPP;\n\t}\n\treturn ret;\n}", "target": 1, "idx": 9841}
{"commit_id": "ca8c013b5e97b1373b3bb1c97ea655e69f31a575", "project": "tensorflow", "func": "void operator()(OpKernelContext* ctx, const CPUDevice& d, int64 num_batches,\n                  int64 samples_per_batch, int64 num_elements,\n                  typename TTypes<T>::ConstFlat means,\n                  typename TTypes<T>::ConstFlat stddevs,\n                  typename TTypes<T>::ConstFlat minvals,\n                  typename TTypes<T>::ConstFlat maxvals,\n                  const random::PhiloxRandom& gen,\n                  typename TTypes<T>::Flat output) {\n    // The randn rejection sampling is used when the mean and at least this many\n    // standard deviations are inside the bounds.\n    // The uniform proposal samplers become less efficient as the bounds are\n    // further from the mean, the reverse is true for the randn sampler.\n    // This number was chosen by empirical benchmarking. If modified, the\n    // benchmarks in parameterized_truncated_normal_op_test should also be\n    // changed.\n    const T kStdDevsInsideBoundsToUseRandnSampler = T(1.3);\n    auto worker_threads = *(ctx->device()->tensorflow_cpu_worker_threads());\n\n    auto do_work = [samples_per_batch, num_elements, &ctx, &means, &stddevs,\n                    &minvals, &maxvals, &gen, &output,\n                    kStdDevsInsideBoundsToUseRandnSampler](int64 start_batch,\n                                                           int64 limit_batch) {\n      // Capturing \"gen\" by-value would only make a copy for the _shared_\n      // lambda.  Since we want to let each worker have its own copy, we pass\n      // \"gen\" by reference and explicitly do a copy assignment here.\n      random::PhiloxRandom gen_copy = gen;\n      // Skip takes units of 128 bytes.  +3 is so rounding doesn't lead to\n      // us using the same state in different batches.\n      // The sample from each iteration uses 2 random numbers.\n      gen_copy.Skip(start_batch * 2 * kMaxIterations * (samples_per_batch + 3) /\n                    4);\n      using Uniform = random::UniformDistribution<random::PhiloxRandom, T>;\n      Uniform dist;\n      using Normal = random::NormalDistribution<random::PhiloxRandom, T>;\n      Normal normal_dist;\n\n      // Vectorized intermediate calculations for uniform rejection sampling.\n      // We always generate at most 4 samples.\n      Eigen::array<T, 4> z;\n      Eigen::array<T, 4> g;\n\n      for (int64 b = start_batch; b < limit_batch; ++b) {\n        // We are passed a flat array for each of the parameter tensors.\n        // The input is either a scalar broadcasted to all batches or a vector\n        // with length num_batches, but the scalar becomes an array of length 1.\n        T mean = means((means.dimension(0) == 1) ? 0 : b);\n        T stddev = stddevs((stddevs.dimension(0) == 1) ? 0 : b);\n        T minval = minvals((minvals.dimension(0) == 1) ? 0 : b);\n        T maxval = maxvals((maxvals.dimension(0) == 1) ? 0 : b);\n\n        // The last batch can be short, if we adjusted num_batches and\n        // samples_per_batch.\n        const int64 limit_sample =\n            std::min((b + 1) * samples_per_batch, num_elements);\n        int64 sample = b * samples_per_batch;\n\n        // On GPU, this check will just fill samples with NAN if it fails.\n        OP_REQUIRES(ctx,\n                    stddev > T(0) && minval < maxval &&\n                        (Eigen::numext::isfinite(minval) ||\n                         Eigen::numext::isfinite(maxval)),\n                    errors::InvalidArgument(\"Invalid parameters\"));\n\n        int num_iterations = 0;\n\n        // If possible, make one-sided bound be the lower bound, or make both\n        // bounds positive. Otherwise, the bounds are on either side of the\n        // mean.\n        if ((Eigen::numext::isinf(minval) && minval < T(0)) || maxval < mean) {\n          // Reverse all calculations. normMin and normMax will be flipped.\n          std::swap(minval, maxval);\n          stddev = -stddev;\n        }\n\n        // Calculate normalized samples, then convert them.\n        const T normMin = (minval - mean) / stddev;\n        const T normMax = (maxval - mean) / stddev;\n\n        // Determine the method to use.\n        const T sqrtFactor = Eigen::numext::sqrt((normMin * normMin) + T(4));\n        const T cutoff =\n            T(2) *\n            Eigen::numext::exp(T(0.5) +\n                               (normMin * (normMin - sqrtFactor)) / T(4)) /\n            (normMin + sqrtFactor);\n        const T diff = normMax - normMin;\n\n        if (((normMin < -kStdDevsInsideBoundsToUseRandnSampler) &&\n             (normMax >= T(0.))) ||\n            ((normMax > kStdDevsInsideBoundsToUseRandnSampler) &&\n             (normMin <= T(0.)))) {\n          // If the bounds are a least 3 standard deviations from the mean\n          // on at least one side then we rejection sample by sampling\n          // from the normal distribution and rejecting samples outside\n          // the bounds.\n          // Under this condition the acceptance rate per iteration should\n          // always be ~ 50%. This sampler is more efficient (and more\n          // numerically stable when one or both bounds is far from the mean).\n\n          while (sample < limit_sample) {\n            const auto randn_sample = normal_dist(&gen_copy);\n            const int size = randn_sample.size();\n\n            for (int i = 0; i < size; i++) {\n              if ((randn_sample[i] >= normMin) &&\n                  (randn_sample[i] <= normMax)) {\n                output(sample) = randn_sample[i] * stddev + mean;\n                sample++;\n                if (sample >= limit_sample) {\n                  break;\n                }\n                num_iterations = 0;\n              } else {\n                num_iterations++;\n                if (num_iterations > kMaxIterations) {\n                  // This should never occur because this sampler should\n                  // (by the selection criteria above) be used if at least 3\n                  // standard deviations of one side of the distribution\n                  // is within the limits (so acceptance probability per\n                  // iterations >~ 1/2 per iteration).\n                  LOG(ERROR) << \"TruncatedNormal randn rejection sampler \"\n                             << \"exceeded maximum iterations for \"\n                             << \"normMin=\" << normMin << \" normMax=\" << normMax\n                             << \" kMaxIterations=\" << kMaxIterations;\n                  ctx->SetStatus(errors::Internal(\n                      \"TruncatedNormal randn rejection sampler failed to accept\"\n                      \" a sample.\"));\n                  return;\n                }\n              }\n            }\n          }\n        } else if (diff < cutoff) {\n          // Sample from a uniform distribution on [normMin, normMax].\n\n          const T plusFactor = (normMin < T(0)) ? T(0) : normMin * normMin;\n\n          while (sample < limit_sample) {\n            const auto rand = dist(&gen_copy);\n            const int size = rand.size();\n            // NOTE(ringwalt): These loops seem to only generate packed AVX\n            // instructions for float32.\n            for (int i = 0; i < size; i++) {\n              z[i] = rand[i] * diff + normMin;\n            }\n            for (int i = 0; i < size; i++) {\n              g[i] = (plusFactor - z[i] * z[i]) / T(2.0);\n            }\n\n            const auto u = dist(&gen_copy);\n            for (int i = 0; i < size; i++) {\n              auto accept = u[i] <= Eigen::numext::exp(g[i]);\n              if (accept || num_iterations + 1 >= kMaxIterations) {\n                // Accept the sample z.\n                // If we run out of iterations, just use the current uniform\n                // sample, but emit a warning.\n                // TODO(jjhunt) For small entropies (relative to the bounds),\n                // this sampler is poor and may take many iterations since\n                // the proposal distribution is the uniform distribution\n                // U(lower_bound, upper_bound).\n                if (!accept) {\n                  LOG(ERROR) << \"TruncatedNormal uniform rejection sampler \"\n                             << \"exceeded max iterations. Sample may contain \"\n                             << \"outliers.\";\n                  ctx->SetStatus(errors::Internal(\n                      \"TruncatedNormal uniform rejection sampler failed to \"\n                      \" accept a sample.\"));\n                  return;\n                }\n                output(sample) = z[i] * stddev + mean;\n                sample++;\n                if (sample >= limit_sample) {\n                  break;\n                }\n                num_iterations = 0;\n              } else {\n                num_iterations++;\n              }\n            }\n          }\n        } else {\n          // Sample from an exponential distribution with alpha maximizing\n          // acceptance probability, offset by normMin from the origin.\n          // Accept only if less than normMax.\n          const T alpha =\n              (normMin + Eigen::numext::sqrt((normMin * normMin) + T(4))) /\n              T(2);\n          while (sample < limit_sample) {\n            auto rand = dist(&gen_copy);\n            const int size = rand.size();\n            int i = 0;\n            while (i < size) {\n              const T z = -Eigen::numext::log(rand[i]) / alpha + normMin;\n              i++;\n              const T x = normMin < alpha ? alpha - z : normMin - alpha;\n              const T g = Eigen::numext::exp(-x * x / T(2.0));\n              const T u = rand[i];\n              i++;\n              auto accept = (u <= g && z < normMax);\n              if (accept || num_iterations + 1 >= kMaxIterations) {\n                if (!accept) {\n                  LOG(ERROR) << \"TruncatedNormal exponential distribution \"\n                             << \"rejection sampler exceeds max iterations. \"\n                             << \"Sample may contain outliers.\";\n                  ctx->SetStatus(errors::Internal(\n                      \"TruncatedNormal exponential distribution rejection\"\n                      \" sampler failed to accept a sample.\"));\n                  return;\n                }\n                output(sample) = z * stddev + mean;\n                sample++;\n                if (sample >= limit_sample) {\n                  break;\n                }\n                num_iterations = 0;\n              } else {\n                num_iterations++;\n              }\n            }\n          }\n        }\n      }\n    };\n    // The cost of the initial calculations for the batch.\n    const int64 batchInitCost =\n        // normMin, normMax\n        (Eigen::TensorOpCost::AddCost<T>() +\n         Eigen::TensorOpCost::MulCost<T>()) *\n            2\n        // sqrtFactor\n        + Eigen::TensorOpCost::AddCost<T>() +\n        Eigen::TensorOpCost::MulCost<T>() +\n        Eigen::internal::functor_traits<\n            Eigen::internal::scalar_sqrt_op<T>>::Cost\n        // cutoff\n        + Eigen::TensorOpCost::MulCost<T>() * 4 +\n        Eigen::internal::functor_traits<Eigen::internal::scalar_exp_op<T>>::Cost\n        // diff\n        + Eigen::TensorOpCost::AddCost<T>();\n    const int64 uniformSampleCost =\n        random::PhiloxRandom::kElementCost +\n        random::UniformDistribution<random::PhiloxRandom, T>::kElementCost;\n    // The cost of a single uniform sampling round.\n    const int64 uniformRejectionSamplingCost =\n        uniformSampleCost + Eigen::TensorOpCost::MulCost<T>() +\n        Eigen::TensorOpCost::AddCost<T>() +\n        Eigen::TensorOpCost::MulCost<T>() * 2 +\n        Eigen::TensorOpCost::AddCost<T>() + uniformSampleCost +\n        Eigen::internal::functor_traits<\n            Eigen::internal::scalar_exp_op<T>>::Cost +\n        Eigen::TensorOpCost::MulCost<T>() + Eigen::TensorOpCost::AddCost<T>();\n    // Estimate the cost for an entire batch.\n    // Assume we use uniform sampling, and accept the 2nd sample on average.\n    const int64 batchCost =\n        batchInitCost + uniformRejectionSamplingCost * 2 * samples_per_batch;\n    Shard(worker_threads.num_threads, worker_threads.workers, num_batches,\n          batchCost, do_work);\n  }", "target": 3, "idx": 9842}
{"commit_id": "e045199c7c9c5433d7f1461a741ed539a75cbfad", "project": "xen-project/xen", "func": "void send_guest_pirq(struct domain *d, const struct pirq *pirq)\n{\n    int port;\n    struct evtchn *chn;\n    unsigned long flags;\n\n    /*\n     * PV guests: It should not be possible to race with __evtchn_close(). The\n     *     caller of this function must synchronise with pirq_guest_unbind().\n     * HVM guests: Port is legitimately zero when the guest disables the\n     *     emulated interrupt/evtchn.\n     */\n    if ( pirq == NULL || (port = pirq->evtchn) == 0 )\n    {\n        BUG_ON(!is_hvm_domain(d));\n        return;\n    }\n\n    chn = evtchn_from_port(d, port);\n    spin_lock_irqsave(&chn->lock, flags);\n    evtchn_port_set_pending(d, chn->notify_vcpu_id, chn);\n    spin_unlock_irqrestore(&chn->lock, flags);\n}", "target": 2, "idx": 9843}
{"commit_id": "99e3a236dd43d06c65af0a2ef9cb44306aef6e02", "project": "torvalds/linux", "func": "static int xdp_umem_reg(struct xdp_umem *umem, struct xdp_umem_reg *mr)\n{\n\tbool unaligned_chunks = mr->flags & XDP_UMEM_UNALIGNED_CHUNK_FLAG;\n\tu32 chunk_size = mr->chunk_size, headroom = mr->headroom;\n\tunsigned int chunks, chunks_per_page;\n\tu64 addr = mr->addr, size = mr->len;\n\tint err;\n\n\tif (chunk_size < XDP_UMEM_MIN_CHUNK_SIZE || chunk_size > PAGE_SIZE) {\n\t\t/* Strictly speaking we could support this, if:\n\t\t * - huge pages, or*\n\t\t * - using an IOMMU, or\n\t\t * - making sure the memory area is consecutive\n\t\t * but for now, we simply say \"computer says no\".\n\t\t */\n\t\treturn -EINVAL;\n\t}\n\n\tif (mr->flags & ~(XDP_UMEM_UNALIGNED_CHUNK_FLAG |\n\t\t\tXDP_UMEM_USES_NEED_WAKEUP))\n\t\treturn -EINVAL;\n\n\tif (!unaligned_chunks && !is_power_of_2(chunk_size))\n\t\treturn -EINVAL;\n\n\tif (!PAGE_ALIGNED(addr)) {\n\t\t/* Memory area has to be page size aligned. For\n\t\t * simplicity, this might change.\n\t\t */\n\t\treturn -EINVAL;\n\t}\n\n\tif ((addr + size) < addr)\n\t\treturn -EINVAL;\n\n\tchunks = (unsigned int)div_u64(size, chunk_size);\n\tif (chunks == 0)\n\t\treturn -EINVAL;\n\n\tif (!unaligned_chunks) {\n\t\tchunks_per_page = PAGE_SIZE / chunk_size;\n\t\tif (chunks < chunks_per_page || chunks % chunks_per_page)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (headroom >= chunk_size - XDP_PACKET_HEADROOM)\n\t\treturn -EINVAL;\n\n\tumem->address = (unsigned long)addr;\n\tumem->chunk_mask = unaligned_chunks ? XSK_UNALIGNED_BUF_ADDR_MASK\n\t\t\t\t\t    : ~((u64)chunk_size - 1);\n\tumem->size = size;\n\tumem->headroom = headroom;\n\tumem->chunk_size_nohr = chunk_size - headroom;\n\tumem->npgs = size / PAGE_SIZE;\n\tumem->pgs = NULL;\n\tumem->user = NULL;\n\tumem->flags = mr->flags;\n\tINIT_LIST_HEAD(&umem->xsk_list);\n\tspin_lock_init(&umem->xsk_list_lock);\n\n\trefcount_set(&umem->users, 1);\n\n\terr = xdp_umem_account_pages(umem);\n\tif (err)\n\t\treturn err;\n\n\terr = xdp_umem_pin_pages(umem);\n\tif (err)\n\t\tgoto out_account;\n\n\tumem->pages = kvcalloc(umem->npgs, sizeof(*umem->pages),\n\t\t\t       GFP_KERNEL_ACCOUNT);\n\tif (!umem->pages) {\n\t\terr = -ENOMEM;\n\t\tgoto out_pin;\n\t}\n\n\terr = xdp_umem_map_pages(umem);\n\tif (!err)\n\t\treturn 0;\n\n\tkvfree(umem->pages);\n\nout_pin:\n\txdp_umem_unpin_pages(umem);\nout_account:\n\txdp_umem_unaccount_pages(umem);\n\treturn err;\n}", "target": 1, "idx": 9844}
{"commit_id": "11a83410153756ae350a82ed41b08d128ff7f998", "project": "iortcw", "func": "void Com_WriteConfig_f( void ) {\n\tchar filename[MAX_QPATH];\n\n\tif ( Cmd_Argc() != 2 ) {\n\t\tCom_Printf( \"Usage: writeconfig <filename>\\n\" );\n\t\treturn;\n\t}\n\n\tif (!COM_CompareExtension(filename, \".cfg\"))\n\t{\n\t\tCom_Printf(\"Com_WriteConfig_f: Only the \\\".cfg\\\" extension is supported by this command!\\n\");\n\t\treturn;\n\t}\n\n\tQ_strncpyz( filename, Cmd_Argv( 1 ), sizeof( filename ) );\n\tCOM_DefaultExtension( filename, sizeof( filename ), \".cfg\" );\n\tCom_Printf( \"Writing %s.\\n\", filename );\n\tCom_WriteConfigToFile( filename );\n}", "target": 2, "idx": 9845}
{"commit_id": "dedcbd106f8e52d5586b0205bc7677e4c9868f9c", "project": "libssh2", "func": "int\n_libssh2_packet_add(LIBSSH2_SESSION * session, unsigned char *data,\n                    size_t datalen, int macstate)\n{\n    int rc = 0;\n    unsigned char *message = NULL;\n    unsigned char *language = NULL;\n    size_t message_len = 0;\n    size_t language_len = 0;\n    LIBSSH2_CHANNEL *channelp = NULL;\n    size_t data_head = 0;\n    unsigned char msg = data[0];\n\n    switch(session->packAdd_state) {\n    case libssh2_NB_state_idle:\n        _libssh2_debug(session, LIBSSH2_TRACE_TRANS,\n                       \"Packet type %d received, length=%d\",\n                       (int) msg, (int) datalen);\n\n        if((macstate == LIBSSH2_MAC_INVALID) &&\n            (!session->macerror ||\n             LIBSSH2_MACERROR(session, (char *) data, datalen))) {\n            /* Bad MAC input, but no callback set or non-zero return from the\n               callback */\n\n            LIBSSH2_FREE(session, data);\n            return _libssh2_error(session, LIBSSH2_ERROR_INVALID_MAC,\n                                  \"Invalid MAC received\");\n        }\n        session->packAdd_state = libssh2_NB_state_allocated;\n        break;\n    case libssh2_NB_state_jump1:\n        goto libssh2_packet_add_jump_point1;\n    case libssh2_NB_state_jump2:\n        goto libssh2_packet_add_jump_point2;\n    case libssh2_NB_state_jump3:\n        goto libssh2_packet_add_jump_point3;\n    case libssh2_NB_state_jump4:\n        goto libssh2_packet_add_jump_point4;\n    case libssh2_NB_state_jump5:\n        goto libssh2_packet_add_jump_point5;\n    default: /* nothing to do */\n        break;\n    }\n\n    if(session->packAdd_state == libssh2_NB_state_allocated) {\n        /* A couple exceptions to the packet adding rule: */\n        switch(msg) {\n\n            /*\n              byte      SSH_MSG_DISCONNECT\n              uint32    reason code\n              string    description in ISO-10646 UTF-8 encoding [RFC3629]\n              string    language tag [RFC3066]\n            */\n\n        case SSH_MSG_DISCONNECT:\n            if(datalen >= 5) {\n                uint32_t reason = 0;\n                struct string_buf buf;\n                buf.data = (unsigned char *)data;\n                buf.dataptr = buf.data;\n                buf.len = datalen;\n                buf.dataptr++; /* advance past type */\n\n                _libssh2_get_u32(&buf, &reason);\n                _libssh2_get_string(&buf, &message, &message_len);\n                _libssh2_get_string(&buf, &language, &language_len);\n\n                if(session->ssh_msg_disconnect) {\n                    LIBSSH2_DISCONNECT(session, reason, (const char *)message,\n                                       message_len, (const char *)language,\n                                       language_len);\n                }\n\n                _libssh2_debug(session, LIBSSH2_TRACE_TRANS,\n                               \"Disconnect(%d): %s(%s)\", reason,\n                               message, language);\n            }\n\n            LIBSSH2_FREE(session, data);\n            session->socket_state = LIBSSH2_SOCKET_DISCONNECTED;\n            session->packAdd_state = libssh2_NB_state_idle;\n            return _libssh2_error(session, LIBSSH2_ERROR_SOCKET_DISCONNECT,\n                                  \"socket disconnect\");\n            /*\n              byte      SSH_MSG_IGNORE\n              string    data\n            */\n\n        case SSH_MSG_IGNORE:\n            if(datalen >= 2) {\n                if(session->ssh_msg_ignore) {\n                    LIBSSH2_IGNORE(session, (char *) data + 1, datalen - 1);\n                }\n            }\n            else if(session->ssh_msg_ignore) {\n                LIBSSH2_IGNORE(session, \"\", 0);\n            }\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return 0;\n\n            /*\n              byte      SSH_MSG_DEBUG\n              boolean   always_display\n              string    message in ISO-10646 UTF-8 encoding [RFC3629]\n              string    language tag [RFC3066]\n            */\n\n        case SSH_MSG_DEBUG:\n            if(datalen >= 2) {\n                int always_display = data[1];\n\n                if(datalen >= 6) {\n                    struct string_buf buf;\n                    buf.data = (unsigned char *)data;\n                    buf.dataptr = buf.data;\n                    buf.len = datalen;\n                    buf.dataptr += 2; /* advance past type & always display */\n\n                    _libssh2_get_string(&buf, &message, &message_len);\n                    _libssh2_get_string(&buf, &language, &language_len);\n                }\n\n                if(session->ssh_msg_debug) {\n                    LIBSSH2_DEBUG(session, always_display,\n                                  (const char *)message,\n                                  message_len, (const char *)language,\n                                  language_len);\n                }\n            }\n\n            /*\n             * _libssh2_debug will actually truncate this for us so\n             * that it's not an inordinate about of data\n             */\n            _libssh2_debug(session, LIBSSH2_TRACE_TRANS,\n                           \"Debug Packet: %s\", message);\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return 0;\n\n            /*\n              byte      SSH_MSG_GLOBAL_REQUEST\n              string    request name in US-ASCII only\n              boolean   want reply\n              ....      request-specific data follows\n            */\n\n        case SSH_MSG_GLOBAL_REQUEST:\n            if(datalen >= 5) {\n                uint32_t len = 0;\n                unsigned char want_reply = 0;\n                len = _libssh2_ntohu32(data + 1);\n                if((len <= (UINT_MAX - 6)) && (datalen >= (6 + len))) {\n                    want_reply = data[5 + len];\n                    _libssh2_debug(session,\n                                   LIBSSH2_TRACE_CONN,\n                                   \"Received global request type %.*s (wr %X)\",\n                                   len, data + 5, want_reply);\n                }\n\n\n                if(want_reply) {\n                    static const unsigned char packet =\n                        SSH_MSG_REQUEST_FAILURE;\n                  libssh2_packet_add_jump_point5:\n                    session->packAdd_state = libssh2_NB_state_jump5;\n                    rc = _libssh2_transport_send(session, &packet, 1, NULL, 0);\n                    if(rc == LIBSSH2_ERROR_EAGAIN)\n                        return rc;\n                }\n            }\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return 0;\n\n            /*\n              byte      SSH_MSG_CHANNEL_EXTENDED_DATA\n              uint32    recipient channel\n              uint32    data_type_code\n              string    data\n            */\n\n        case SSH_MSG_CHANNEL_EXTENDED_DATA:\n            /* streamid(4) */\n            data_head += 4;\n\n            /* fall-through */\n\n            /*\n              byte      SSH_MSG_CHANNEL_DATA\n              uint32    recipient channel\n              string    data\n            */\n\n        case SSH_MSG_CHANNEL_DATA:\n            /* packet_type(1) + channelno(4) + datalen(4) */\n            data_head += 9;\n\n            if(datalen >= data_head)\n                channelp =\n                    _libssh2_channel_locate(session,\n                                            _libssh2_ntohu32(data + 1));\n\n            if(!channelp) {\n                _libssh2_error(session, LIBSSH2_ERROR_CHANNEL_UNKNOWN,\n                               \"Packet received for unknown channel\");\n                LIBSSH2_FREE(session, data);\n                session->packAdd_state = libssh2_NB_state_idle;\n                return 0;\n            }\n#ifdef LIBSSH2DEBUG\n            {\n                uint32_t stream_id = 0;\n                if(msg == SSH_MSG_CHANNEL_EXTENDED_DATA)\n                    stream_id = _libssh2_ntohu32(data + 5);\n\n                _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                               \"%d bytes packet_add() for %lu/%lu/%lu\",\n                               (int) (datalen - data_head),\n                               channelp->local.id,\n                               channelp->remote.id,\n                               stream_id);\n            }\n#endif\n            if((channelp->remote.extended_data_ignore_mode ==\n                 LIBSSH2_CHANNEL_EXTENDED_DATA_IGNORE) &&\n                (msg == SSH_MSG_CHANNEL_EXTENDED_DATA)) {\n                /* Pretend we didn't receive this */\n                LIBSSH2_FREE(session, data);\n\n                _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                               \"Ignoring extended data and refunding %d bytes\",\n                               (int) (datalen - 13));\n                if(channelp->read_avail + datalen - data_head >=\n                    channelp->remote.window_size)\n                    datalen = channelp->remote.window_size -\n                        channelp->read_avail + data_head;\n\n                channelp->remote.window_size -= datalen - data_head;\n                _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                               \"shrinking window size by %lu bytes to %lu, \"\n                               \"read_avail %lu\",\n                               datalen - data_head,\n                               channelp->remote.window_size,\n                               channelp->read_avail);\n\n                session->packAdd_channelp = channelp;\n\n                /* Adjust the window based on the block we just freed */\n              libssh2_packet_add_jump_point1:\n                session->packAdd_state = libssh2_NB_state_jump1;\n                rc = _libssh2_channel_receive_window_adjust(session->\n                                                            packAdd_channelp,\n                                                            datalen - 13,\n                                                            1, NULL);\n                if(rc == LIBSSH2_ERROR_EAGAIN)\n                    return rc;\n\n                session->packAdd_state = libssh2_NB_state_idle;\n                return 0;\n            }\n\n            /*\n             * REMEMBER! remote means remote as source of data,\n             * NOT remote window!\n             */\n            if(channelp->remote.packet_size < (datalen - data_head)) {\n                /*\n                 * Spec says we MAY ignore bytes sent beyond\n                 * packet_size\n                 */\n                _libssh2_error(session,\n                               LIBSSH2_ERROR_CHANNEL_PACKET_EXCEEDED,\n                               \"Packet contains more data than we offered\"\n                               \" to receive, truncating\");\n                datalen = channelp->remote.packet_size + data_head;\n            }\n            if(channelp->remote.window_size <= channelp->read_avail) {\n                /*\n                 * Spec says we MAY ignore bytes sent beyond\n                 * window_size\n                 */\n                _libssh2_error(session,\n                               LIBSSH2_ERROR_CHANNEL_WINDOW_EXCEEDED,\n                               \"The current receive window is full,\"\n                               \" data ignored\");\n                LIBSSH2_FREE(session, data);\n                session->packAdd_state = libssh2_NB_state_idle;\n                return 0;\n            }\n            /* Reset EOF status */\n            channelp->remote.eof = 0;\n\n            if(channelp->read_avail + datalen - data_head >\n                channelp->remote.window_size) {\n                _libssh2_error(session,\n                               LIBSSH2_ERROR_CHANNEL_WINDOW_EXCEEDED,\n                               \"Remote sent more data than current \"\n                               \"window allows, truncating\");\n                datalen = channelp->remote.window_size -\n                    channelp->read_avail + data_head;\n            }\n\n            /* Update the read_avail counter. The window size will be\n             * updated once the data is actually read from the queue\n             * from an upper layer */\n            channelp->read_avail += datalen - data_head;\n\n            _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                           \"increasing read_avail by %lu bytes to %lu/%lu\",\n                           (long)(datalen - data_head),\n                           (long)channelp->read_avail,\n                           (long)channelp->remote.window_size);\n\n            break;\n\n            /*\n              byte      SSH_MSG_CHANNEL_EOF\n              uint32    recipient channel\n            */\n\n        case SSH_MSG_CHANNEL_EOF:\n            if(datalen >= 5)\n                channelp =\n                    _libssh2_channel_locate(session,\n                                            _libssh2_ntohu32(data + 1));\n            if(!channelp)\n                /* We may have freed already, just quietly ignore this... */\n                ;\n            else {\n                _libssh2_debug(session,\n                               LIBSSH2_TRACE_CONN,\n                               \"EOF received for channel %lu/%lu\",\n                               channelp->local.id,\n                               channelp->remote.id);\n                channelp->remote.eof = 1;\n            }\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return 0;\n\n            /*\n              byte      SSH_MSG_CHANNEL_REQUEST\n              uint32    recipient channel\n              string    request type in US-ASCII characters only\n              boolean   want reply\n              ....      type-specific data follows\n            */\n\n        case SSH_MSG_CHANNEL_REQUEST:\n            if(datalen >= 9) {\n                uint32_t channel = _libssh2_ntohu32(data + 1);\n                uint32_t len = _libssh2_ntohu32(data + 5);\n                unsigned char want_reply = 1;\n\n                if((len + 9) < datalen)\n                    want_reply = data[len + 9];\n\n                _libssh2_debug(session,\n                               LIBSSH2_TRACE_CONN,\n                               \"Channel %d received request type %.*s (wr %X)\",\n                               channel, len, data + 9, want_reply);\n\n                if(len == sizeof(\"exit-status\") - 1\n                    && (sizeof(\"exit-status\") - 1 + 9) <= datalen\n                    && !memcmp(\"exit-status\", data + 9,\n                               sizeof(\"exit-status\") - 1)) {\n\n                    /* we've got \"exit-status\" packet. Set the session value */\n                    if(datalen >= 20)\n                        channelp =\n                            _libssh2_channel_locate(session, channel);\n\n                    if(channelp && (sizeof(\"exit-status\") + 13) <= datalen) {\n                        channelp->exit_status =\n                            _libssh2_ntohu32(data + 9 + sizeof(\"exit-status\"));\n                        _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                                       \"Exit status %lu received for \"\n                                       \"channel %lu/%lu\",\n                                       channelp->exit_status,\n                                       channelp->local.id,\n                                       channelp->remote.id);\n                    }\n\n                }\n                else if(len == sizeof(\"exit-signal\") - 1\n                         && (sizeof(\"exit-signal\") - 1 + 9) <= datalen\n                         && !memcmp(\"exit-signal\", data + 9,\n                                    sizeof(\"exit-signal\") - 1)) {\n                    /* command terminated due to signal */\n                    if(datalen >= 20)\n                        channelp = _libssh2_channel_locate(session, channel);\n\n                    if(channelp && (sizeof(\"exit-signal\") + 13) <= datalen) {\n                        /* set signal name (without SIG prefix) */\n                        uint32_t namelen =\n                            _libssh2_ntohu32(data + 9 + sizeof(\"exit-signal\"));\n\n                        if(namelen <= UINT_MAX - 1) {\n                            channelp->exit_signal =\n                                LIBSSH2_ALLOC(session, namelen + 1);\n                        }\n                        else {\n                            channelp->exit_signal = NULL;\n                        }\n\n                        if(!channelp->exit_signal)\n                            rc = _libssh2_error(session, LIBSSH2_ERROR_ALLOC,\n                                                \"memory for signal name\");\n                        else if((sizeof(\"exit-signal\") + 13 + namelen <=\n                                 datalen)) {\n                            memcpy(channelp->exit_signal,\n                                   data + 13 + sizeof(\"exit-signal\"), namelen);\n                            channelp->exit_signal[namelen] = '\\0';\n                            /* TODO: save error message and language tag */\n                            _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                                           \"Exit signal %s received for \"\n                                           \"channel %lu/%lu\",\n                                           channelp->exit_signal,\n                                           channelp->local.id,\n                                           channelp->remote.id);\n                        }\n                    }\n                }\n\n\n                if(want_reply) {\n                    unsigned char packet[5];\n                  libssh2_packet_add_jump_point4:\n                    session->packAdd_state = libssh2_NB_state_jump4;\n                    packet[0] = SSH_MSG_CHANNEL_FAILURE;\n                    memcpy(&packet[1], data + 1, 4);\n                    rc = _libssh2_transport_send(session, packet, 5, NULL, 0);\n                    if(rc == LIBSSH2_ERROR_EAGAIN)\n                        return rc;\n                }\n            }\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return rc;\n\n            /*\n              byte      SSH_MSG_CHANNEL_CLOSE\n              uint32    recipient channel\n            */\n\n        case SSH_MSG_CHANNEL_CLOSE:\n            if(datalen >= 5)\n                channelp =\n                    _libssh2_channel_locate(session,\n                                            _libssh2_ntohu32(data + 1));\n            if(!channelp) {\n                /* We may have freed already, just quietly ignore this... */\n                LIBSSH2_FREE(session, data);\n                session->packAdd_state = libssh2_NB_state_idle;\n                return 0;\n            }\n            _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                           \"Close received for channel %lu/%lu\",\n                           channelp->local.id,\n                           channelp->remote.id);\n\n            channelp->remote.close = 1;\n            channelp->remote.eof = 1;\n\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return 0;\n\n            /*\n              byte      SSH_MSG_CHANNEL_OPEN\n              string    \"session\"\n              uint32    sender channel\n              uint32    initial window size\n              uint32    maximum packet size\n            */\n\n        case SSH_MSG_CHANNEL_OPEN:\n            if(datalen < 17)\n                ;\n            else if((datalen >= (sizeof(\"forwarded-tcpip\") + 4)) &&\n                     ((sizeof(\"forwarded-tcpip\") - 1) ==\n                      _libssh2_ntohu32(data + 1))\n                     &&\n                     (memcmp(data + 5, \"forwarded-tcpip\",\n                             sizeof(\"forwarded-tcpip\") - 1) == 0)) {\n\n                /* init the state struct */\n                memset(&session->packAdd_Qlstn_state, 0,\n                       sizeof(session->packAdd_Qlstn_state));\n\n              libssh2_packet_add_jump_point2:\n                session->packAdd_state = libssh2_NB_state_jump2;\n                rc = packet_queue_listener(session, data, datalen,\n                                           &session->packAdd_Qlstn_state);\n            }\n            else if((datalen >= (sizeof(\"x11\") + 4)) &&\n                     ((sizeof(\"x11\") - 1) == _libssh2_ntohu32(data + 1)) &&\n                     (memcmp(data + 5, \"x11\", sizeof(\"x11\") - 1) == 0)) {\n\n                /* init the state struct */\n                memset(&session->packAdd_x11open_state, 0,\n                       sizeof(session->packAdd_x11open_state));\n\n              libssh2_packet_add_jump_point3:\n                session->packAdd_state = libssh2_NB_state_jump3;\n                rc = packet_x11_open(session, data, datalen,\n                                     &session->packAdd_x11open_state);\n            }\n            if(rc == LIBSSH2_ERROR_EAGAIN)\n                return rc;\n\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return rc;\n\n            /*\n              byte      SSH_MSG_CHANNEL_WINDOW_ADJUST\n              uint32    recipient channel\n              uint32    bytes to add\n            */\n        case SSH_MSG_CHANNEL_WINDOW_ADJUST:\n            if(datalen < 9)\n                ;\n            else {\n                uint32_t bytestoadd = _libssh2_ntohu32(data + 5);\n                channelp =\n                    _libssh2_channel_locate(session,\n                                            _libssh2_ntohu32(data + 1));\n                if(channelp) {\n                    channelp->local.window_size += bytestoadd;\n\n                    _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                                   \"Window adjust for channel %lu/%lu, \"\n                                   \"adding %lu bytes, new window_size=%lu\",\n                                   channelp->local.id,\n                                   channelp->remote.id,\n                                   bytestoadd,\n                                   channelp->local.window_size);\n                }\n            }\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return 0;\n        default:\n            break;\n        }\n\n        session->packAdd_state = libssh2_NB_state_sent;\n    }\n\n    if(session->packAdd_state == libssh2_NB_state_sent) {\n        LIBSSH2_PACKET *packetp =\n            LIBSSH2_ALLOC(session, sizeof(LIBSSH2_PACKET));\n        if(!packetp) {\n            _libssh2_debug(session, LIBSSH2_ERROR_ALLOC,\n                           \"memory for packet\");\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return LIBSSH2_ERROR_ALLOC;\n        }\n        packetp->data = data;\n        packetp->data_len = datalen;\n        packetp->data_head = data_head;\n\n        _libssh2_list_add(&session->packets, &packetp->node);\n\n        session->packAdd_state = libssh2_NB_state_sent1;\n    }\n\n    if((msg == SSH_MSG_KEXINIT &&\n         !(session->state & LIBSSH2_STATE_EXCHANGING_KEYS)) ||\n        (session->packAdd_state == libssh2_NB_state_sent2)) {\n        if(session->packAdd_state == libssh2_NB_state_sent1) {\n            /*\n             * Remote wants new keys\n             * Well, it's already in the brigade,\n             * let's just call back into ourselves\n             */\n            _libssh2_debug(session, LIBSSH2_TRACE_TRANS, \"Renegotiating Keys\");\n\n            session->packAdd_state = libssh2_NB_state_sent2;\n        }\n\n        /*\n         * The KEXINIT message has been added to the queue.  The packAdd and\n         * readPack states need to be reset because _libssh2_kex_exchange\n         * (eventually) calls upon _libssh2_transport_read to read the rest of\n         * the key exchange conversation.\n         */\n        session->readPack_state = libssh2_NB_state_idle;\n        session->packet.total_num = 0;\n        session->packAdd_state = libssh2_NB_state_idle;\n        session->fullpacket_state = libssh2_NB_state_idle;\n\n        memset(&session->startup_key_state, 0, sizeof(key_exchange_state_t));\n\n        /*\n         * If there was a key reexchange failure, let's just hope we didn't\n         * send NEWKEYS yet, otherwise remote will drop us like a rock\n         */\n        rc = _libssh2_kex_exchange(session, 1, &session->startup_key_state);\n        if(rc == LIBSSH2_ERROR_EAGAIN)\n            return rc;\n    }\n\n    session->packAdd_state = libssh2_NB_state_idle;\n    return 0;\n}", "target": 2, "idx": 9846}
{"commit_id": "35eeff30caf34df835206f1c12bcf4b7c2bd6758", "project": "ffmpeg", "func": "static int export(AVFilterContext *ctx, StreamContext *sc, int input)\n{\n    SignatureContext* sic = ctx->priv;\n    char filename[1024];\n\n    if (sic->nb_inputs > 1) {\n        /* error already handled */\n        av_assert0(av_get_frame_filename(filename, sizeof(filename), sic->filename, input) == 0);\n    } else {\n        if (av_strlcpy(filename, sic->filename, sizeof(filename)) >= sizeof(filename))\n            return AVERROR(EINVAL);\n    }\n    if (sic->format == FORMAT_XML) {\n        return xml_export(ctx, sc, filename);\n    } else {\n        return binary_export(ctx, sc, filename);\n    }\n}", "target": 2, "idx": 9847}
{"commit_id": "f57bd745b4cbed577ea654fad4701bea4d38b44c", "project": "moonlight-stream/moonlight-common-c", "func": "static int setupStream(PRTSP_MESSAGE response, char* target, int* error) {\n    RTSP_MESSAGE request;\n    int ret;\n    char* transportValue;\n\n    *error = -1;\n\n    ret = initializeRtspRequest(&request, \"SETUP\", target);\n    if (ret != 0) {\n        if (hasSessionId) {\n            if (!addOption(&request, \"Session\", sessionIdString)) {\n                ret = 0;\n                goto FreeMessage;\n            }\n        }\n\n        if (AppVersionQuad[0] >= 6) {\n            // It looks like GFE doesn't care what we say our port is but\n            // we need to give it some port to successfully complete the\n            // handshake process.\n            transportValue = \"unicast;X-GS-ClientPort=50000-50001\";\n        }\n        else {\n            transportValue = \" \";\n        }\n        \n        if (addOption(&request, \"Transport\", transportValue) &&\n            addOption(&request, \"If-Modified-Since\",\n                \"Thu, 01 Jan 1970 00:00:00 GMT\")) {\n            ret = transactRtspMessage(&request, response, 0, error);\n        }\n        else {\n            ret = 0;\n        }\n\n    FreeMessage:\n        freeMessage(&request);\n    }\n\n    return ret;\n}", "target": 2, "idx": 9848}
{"commit_id": "5f8e44741f9f216e33736ea4ec65ca9ac03036e6", "project": "torvalds/linux", "func": "static int rtnl_fill_link_ifmap(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct rtnl_link_ifmap map;\n\n\tmemset(&map, 0, sizeof(map));\n\tmap.mem_start   = dev->mem_start;\n\tmap.mem_end     = dev->mem_end;\n\tmap.base_addr   = dev->base_addr;\n\tmap.irq         = dev->irq;\n\tmap.dma         = dev->dma;\n\tmap.port        = dev->if_port;\n\n\tif (nla_put(skb, IFLA_MAP, sizeof(map), &map))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}", "target": 0, "idx": 9849}
{"commit_id": "fba01dc76d6ea940ad7c8392e8f39f9647241d8e", "project": "CrowCpp/Crow", "func": "bool feed(const char* buffer, int length)\n        {\n            if (message_complete)\n                return true;\n\n            const static http_parser_settings settings_{\n              on_message_begin,\n              on_method,\n              on_url,\n              on_header_field,\n              on_header_value,\n              on_headers_complete,\n              on_body,\n              on_message_complete,\n            };\n\n            int nparsed = http_parser_execute(this, &settings_, buffer, length);\n            if (http_errno != CHPE_OK)\n            {\n                return false;\n            }\n            return nparsed == length;\n        }", "target": 3, "idx": 9850}
{"commit_id": "a2dca48d665c8771e9943ff4becb6e48d37ad517", "project": "openlink/virtuoso-opensource", "func": "void\nsqlg_vec_ts (sql_comp_t * sc, table_source_t * ts)\n{\n  /* set the casts. Set the refs.  The defs are set at the end. */\n  key_source_t *ks = ts->ts_order_ks;\n  search_spec_t *sp;\n  dk_set_t ssl_list = ks->ks_out_slots;\n  int cast_changes_card = 0;\n  int n_k_ssl = sp_ssl_count (sc, ks->ks_spec.ksp_spec_array, &ks->ks_n_vec_sort_cols, &cast_changes_card), ign = 0;\n  int n_r_ssl = sp_ssl_count (sc, ks->ks_row_spec, NULL, &cast_changes_card);\n  int fill = 0, inx = 0, n_out;\n  if (ts->ts_alternate)\n    {\n      sqlg_vec_alt_ts (sc, ts);\n      return;\n    }\n  ts->src_gen.src_batch_size = cc_new_instance_slot (sc->sc_cc);\n  ks->ks_ts = ts;\n  sc->sc_vec_first_of_qf = sqlg_qn_first_of (sc, (data_source_t *) ts);\n  ASG_SSL (res, all_res, ts->ts_current_of);\n  if (!ks->ks_is_qf_first)\n    {\n      ks->ks_vec_cast = (state_slot_t **) dk_alloc_box_zero (sizeof (caddr_t) * (n_r_ssl + n_k_ssl), DV_BIN);\n      ks->ks_vec_source = (state_slot_ref_t **) dk_alloc_box_zero (sizeof (caddr_t) * (n_r_ssl + n_k_ssl), DV_BIN);\n      ks->ks_dc_val_cast = (dc_val_cast_t *) dk_alloc_box_zero (sizeof (caddr_t) * (n_r_ssl + n_k_ssl), DV_BIN);\n      for (sp = ks->ks_spec.ksp_spec_array; sp; sp = sp->sp_next)\n\t{\n\t  sc->sc_vec_current_col = sch_id_to_col (wi_inst.wi_schema, sp->sp_cl.cl_col_id);\n\t  if (sp->sp_min_ssl)\n\t    {\n\t      sqlg_vec_cast (sc, ks->ks_vec_source, ks->ks_vec_cast, ks->ks_dc_val_cast, &sp->sp_min_ssl, fill,\n\t\t  &ks->ks_last_vec_param, &sp->sp_cl.cl_sqt, cast_changes_card);\n\t      if (sc->sc_in_cursor_def && sp->sp_min_ssl->ssl_type == SSL_VARIABLE)\n\t\tks->ks_copy_search_pars = 1;\n\t      fill++;\n\t    }\n\t  if (sp->sp_max_ssl)\n\t    {\n\t      sqlg_vec_cast (sc, ks->ks_vec_source, ks->ks_vec_cast, ks->ks_dc_val_cast, &sp->sp_max_ssl, fill,\n\t\t  &ks->ks_last_vec_param, &sp->sp_cl.cl_sqt, cast_changes_card);\n\t      if (sc->sc_in_cursor_def && sp->sp_max_ssl->ssl_type == SSL_VARIABLE)\n\t\tks->ks_copy_search_pars = 1;\n\t      fill++;\n\t    }\n\n\t}\n      for (sp = ks->ks_row_spec; sp; sp = sp->sp_next)\n\t{\n\t  sc->sc_vec_current_col = sch_id_to_col (wi_inst.wi_schema, sp->sp_cl.cl_col_id);\n\t  if (ks->ks_key->key_is_col)\n\t    {\n\t      dtp_t min_op = sp->sp_min_op, max_op = sp->sp_max_op;\n\t      if (!sp->sp_col_filter)\n\t    sp->sp_col_filter = col_find_op (CE_OP_CODE (sp->sp_min_op, sp->sp_max_op));\n\t      if (!sp->sp_col_filter && (CMP_GT == min_op || CMP_GTE == min_op || CMP_LT == max_op || CMP_LTE == max_op))\n\t\tsp->sp_col_filter = col_find_op (CE_ALL_LTGT);\n\t    }\n\t  if (sp->sp_min_ssl)\n\t    {\n\t      sql_type_t target_sqt = sp->sp_cl.cl_sqt;\n\t      if (ks->ks_key->key_is_col)\n\t\ttarget_sqt.sqt_dtp = target_sqt.sqt_col_dtp;\n\t      sqlg_vec_cast (sc, ks->ks_vec_source, ks->ks_vec_cast, ks->ks_dc_val_cast, &sp->sp_min_ssl, fill,\n\t\t  &ks->ks_last_vec_param, &target_sqt, cast_changes_card);\n\t      if (!ks->ks_first_row_vec_ssl && SSL_IS_VEC_OR_REF (sp->sp_min_ssl))\n\t\tks->ks_first_row_vec_ssl = sp->sp_min_ssl;\n\t      if (sc->sc_in_cursor_def && sp->sp_min_ssl->ssl_type == SSL_VARIABLE)\n\t\tks->ks_copy_search_pars = 1;\n\t      fill++;\n\t    }\n\t  if (sp->sp_max_ssl)\n\t    {\n\t      sql_type_t target_sqt = sp->sp_cl.cl_sqt;\n\t      if (ks->ks_key->key_is_col)\n\t\ttarget_sqt.sqt_dtp = target_sqt.sqt_col_dtp;\n\t      sqlg_vec_cast (sc, ks->ks_vec_source, ks->ks_vec_cast, ks->ks_dc_val_cast, &sp->sp_max_ssl, fill,\n\t\t  &ks->ks_last_vec_param, &target_sqt, cast_changes_card);\n\t      if (!ks->ks_first_row_vec_ssl && SSL_IS_VEC_OR_REF (sp->sp_max_ssl))\n\t\tks->ks_first_row_vec_ssl = sp->sp_max_ssl;\n\t      if (sc->sc_in_cursor_def && sp->sp_max_ssl->ssl_type == SSL_VARIABLE)\n\t\tks->ks_copy_search_pars = 1;\n\t      fill++;\n\t    }\n\t}\n      sc->sc_vec_current_col = NULL;\n    }\n  sc->sc_vec_first_of_qf = NULL;\n  sqlg_vec_ts_out_alias (sc, ts);\n  n_out = dk_set_length (ks->ks_out_slots);\n  ks->ks_v_out_map = (v_out_map_t *) dk_alloc_box_zero (n_out * sizeof (v_out_map_t), DV_BIN);\n  ssl_list = ks->ks_out_slots;\n  inx = 0;\n  if (ks->ks_is_proc_view)\n    {\n      dk_set_free (ks->ks_out_cols);\n      ks->ks_out_cols = dk_set_copy (ks->ks_key->key_parts);\n    }\n  DO_SET (dbe_column_t *, col, &ks->ks_out_cols)\n  {\n    state_slot_t *ssl = (state_slot_t *) ssl_list->data, *shadow;\n    oid_t col_id = IS_BOX_POINTER (col) ? col->col_id : (oid_t) (ptrlong) col;\n    if (ssl->ssl_alias_of)\n      ssl = ssl->ssl_alias_of;\n    shadow = (state_slot_t *) gethash ((void *) (ptrlong) ssl->ssl_index, sc->sc_vec_ssl_shadow);\n    if (shadow)\n      ssl_list->data = (void *) (ssl = shadow);\n    if (!IS_BOX_POINTER (col))\n      col = key_col_by_id (ks->ks_key, (ptrlong) col);\n    ssl_list = ssl_list->next;\n    if (!ks->ks_is_last || ks->ks_key->key_is_col)\n      {\n\tif (ks->ks_key->key_bit_cl && col_id == ks->ks_key->key_bit_cl->cl_col_id)\n\t  ks->ks_v_out_map[inx].om_is_null = OM_BM_COL;\n\telse if (CI_ROW == col_id)\n\t  {\n\t    if (ks->ks_key->key_is_col)\n\t      sqlc_new_error (sc->sc_cc, \"37000\", \"COL..\", \"Can't select _row from a column-wise key\");\n\t    ks->ks_v_out_map[inx].om_ref = dc_itc_append_row;\n\t    ssl->ssl_dtp = DV_ARRAY_OF_POINTER;\n\t  }\n\telse if (ks->ks_key->key_is_col)\n\t  {\n\t    ks->ks_v_out_map[inx].om_cl = *cl_list_find (ks->ks_key->key_row_var, col_id);\n\t    ks->ks_v_out_map[inx].om_ce_op = col_find_op (CE_DECODE);\n\t  }\n\telse\n\t  ks->ks_v_out_map[inx].om_cl = *key_find_cl (ks->ks_key, col_id);\n\tks->ks_v_out_map[inx].om_ssl = ssl;\n\t  ssl_set_dc_type (ssl);\n\tif (col)\n\t  ks->ks_v_out_map[inx].om_ref = col_ref_func (ks->ks_key, col, ks->ks_v_out_map[inx].om_ssl);\n\tssl->ssl_type = SSL_VEC;\n\tif (!ssl->ssl_box_index)\n\t  ssl->ssl_box_index = cc_new_instance_slot (sc->sc_cc);\n      }\n    ASG_SSL (NULL, NULL, ssl);\n    t_set_delete (&sc->sc_ssl_prereset_only, (void *) ssl);\t/* in a proc view the row ctr is assigned first in precode and then in the ts, must be in the continue reset list, else will overflow */\n    inx++;\n  }\n  END_DO_SET ();\n  if (ks->ks_vec_cast)\n    {\n      int inx;\n      DO_BOX (state_slot_t *, ssl, inx, ks->ks_vec_cast)\n      {\n\tif (ssl)\n\t  sethash ((void *) (ptrlong) ssl->ssl_index, sc->sc_vec_last_ref, (void *) ts);\n      }\n      END_DO_BOX;\n    }\n  if (ks->ks_key->key_is_col)\n    ks->ks_row_check = itc_col_row_check_dummy;\n  else if (!ks->ks_is_last)\n    ks->ks_row_check = ks->ks_key->key_is_bitmap ? itc_bm_vec_row_check : itc_vec_row_check;\n  ks->ks_param_nos = cc_new_instance_slot (sc->sc_cc);\n  DO_SET (state_slot_t *, ssl, &ks->ks_always_null)\n    ASG_SSL (NULL, NULL, ssl); /* when reading grouping sets with not all groupnig cols, some are filled in as null on all rows */\n  END_DO_SET ();\n  t_set_push (&sc->sc_vec_pred, (void *) ts);\n  DO_SET (search_spec_t *, sp, &ks->ks_hash_spec)\n  {\n    hash_range_spec_t *hrng = (hash_range_spec_t *) sp->sp_min_ssl;\n    REF_SSL (res, hrng->hrng_ht);\n  }\n  END_DO_SET ();\n  cv_vec_slots (sc, ks->ks_local_test, NULL, NULL, &ign);\n  if (ks->ks_local_code && !ks->ks_is_last)\n    {\n      ks->ks_ts->src_gen.src_after_code = ks->ks_local_code;\n      ks->ks_local_code = NULL;\n    }\n  else\n    {\n      ign = VEC_SINGLE_STATE;\n      cv_vec_slots (sc, ks->ks_local_code, NULL, NULL, &ign);\n      sqlg_new_vec_ssls (sc, &ks->ks_ts->src_gen);\n    }\n\n  sc->sc_vec_pred = sc->sc_vec_pred->next;\n  sqlg_ts_qp_copy (sc, ts);\n  REF_SSL (res, ks->ks_set_no);\n  if (IS_QN (ts, sort_read_input))\n    {\n      ts->clb.clb_nth_set = cc_new_instance_slot (sc->sc_cc);\n      ts->ts_sort_read_mask = sqlg_ts_sort_read_mask (sc, ts);\n    }\n}", "target": 2, "idx": 9851}
{"commit_id": "79e057fa5cc42b4c7a6b689bf6cb638ac40d2ec5", "project": "apache/trafficserver", "func": "void\nSSLNetVConnection::net_read_io(NetHandler *nh, EThread *lthread)\n{\n  int ret;\n  int64_t r     = 0;\n  int64_t bytes = 0;\n  NetState *s   = &this->read;\n\n  if (HttpProxyPort::TRANSPORT_BLIND_TUNNEL == this->attributes) {\n    this->super::net_read_io(nh, lthread);\n    return;\n  }\n\n  MUTEX_TRY_LOCK_FOR(lock, s->vio.mutex, lthread, s->vio._cont);\n  if (!lock.is_locked()) {\n    readReschedule(nh);\n    return;\n  }\n  // Got closed by the HttpSessionManager thread during a migration\n  // The closed flag should be stable once we get the s->vio.mutex in that case\n  // (the global session pool mutex).\n  if (this->closed) {\n    this->super::net_read_io(nh, lthread);\n    return;\n  }\n  // If the key renegotiation failed it's over, just signal the error and finish.\n  if (sslClientRenegotiationAbort == true) {\n    this->read.triggered = 0;\n    readSignalError(nh, (int)r);\n    Debug(\"ssl\", \"[SSLNetVConnection::net_read_io] client renegotiation setting read signal error\");\n    return;\n  }\n\n  // If it is not enabled, lower its priority.  This allows\n  // a fast connection to speed match a slower connection by\n  // shifting down in priority even if it could read.\n  if (!s->enabled || s->vio.op != VIO::READ) {\n    read_disable(nh, this);\n    return;\n  }\n\n  MIOBufferAccessor &buf = s->vio.buffer;\n  int64_t ntodo          = s->vio.ntodo();\n  ink_assert(buf.writer());\n\n  // Continue on if we are still in the handshake\n  if (!getSSLHandShakeComplete()) {\n    int err;\n\n    if (get_context() == NET_VCONNECTION_OUT) {\n      ret = sslStartHandShake(SSL_EVENT_CLIENT, err);\n    } else {\n      ret = sslStartHandShake(SSL_EVENT_SERVER, err);\n    }\n    // If we have flipped to blind tunnel, don't read ahead\n    if (this->handShakeReader) {\n      if (this->attributes != HttpProxyPort::TRANSPORT_BLIND_TUNNEL) {\n        // Check and consume data that has been read\n        update_rbio(false);\n      } else {\n        // Now in blind tunnel. Set things up to read what is in the buffer\n        // Must send the READ_COMPLETE here before considering\n        // forwarding on the handshake buffer, so the\n        // SSLNextProtocolTrampoline has a chance to do its\n        // thing before forwarding the buffers.\n        this->readSignalDone(VC_EVENT_READ_COMPLETE, nh);\n\n        // If the handshake isn't set yet, this means the tunnel\n        // decision was make in the SNI callback.  We must move\n        // the client hello message back into the standard read.vio\n        // so it will get forwarded onto the origin server\n        if (!this->getSSLHandShakeComplete()) {\n          this->sslHandShakeComplete = 1;\n\n          // Copy over all data already read in during the SSL_accept\n          // (the client hello message)\n          NetState *s            = &this->read;\n          MIOBufferAccessor &buf = s->vio.buffer;\n          int64_t r              = buf.writer()->write(this->handShakeHolder);\n          s->vio.nbytes += r;\n          s->vio.ndone += r;\n\n          // Clean up the handshake buffers\n          this->free_handshake_buffers();\n\n          if (r > 0) {\n            // Kick things again, so the data that was copied into the\n            // vio.read buffer gets processed\n            this->readSignalDone(VC_EVENT_READ_COMPLETE, nh);\n          }\n        }\n        return; // Leave if we are tunneling\n      }\n    }\n    if (ret == EVENT_ERROR) {\n      this->read.triggered = 0;\n      readSignalError(nh, err);\n    } else if (ret == SSL_HANDSHAKE_WANT_READ || ret == SSL_HANDSHAKE_WANT_ACCEPT) {\n      if (SSLConfigParams::ssl_handshake_timeout_in > 0) {\n        double handshake_time = ((double)(Thread::get_hrtime() - sslHandshakeBeginTime) / 1000000000);\n        Debug(\"ssl\", \"ssl handshake for vc %p, took %.3f seconds, configured handshake_timer: %d\", this, handshake_time,\n              SSLConfigParams::ssl_handshake_timeout_in);\n        if (handshake_time > SSLConfigParams::ssl_handshake_timeout_in) {\n          Debug(\"ssl\", \"ssl handshake for vc %p, expired, release the connection\", this);\n          read.triggered = 0;\n          nh->read_ready_list.remove(this);\n          readSignalError(nh, VC_EVENT_EOS);\n          return;\n        }\n      }\n      // move over to the socket if we haven't already\n      if (this->handShakeBuffer) {\n        read.triggered = update_rbio(true);\n      } else {\n        Debug(\"ssl\", \"Want read from socket\");\n        read.triggered = 0;\n      }\n      if (!read.triggered) {\n        nh->read_ready_list.remove(this);\n      }\n      readReschedule(nh);\n    } else if (ret == SSL_HANDSHAKE_WANT_CONNECT || ret == SSL_HANDSHAKE_WANT_WRITE) {\n      write.triggered = 0;\n      nh->write_ready_list.remove(this);\n      writeReschedule(nh);\n    } else if (ret == EVENT_DONE) {\n      // If this was driven by a zero length read, signal complete when\n      // the handshake is complete. Otherwise set up for continuing read\n      // operations.\n      if (ntodo <= 0) {\n        readSignalDone(VC_EVENT_READ_COMPLETE, nh);\n      } else {\n        read.triggered = 1;\n        if (read.enabled) {\n          nh->read_ready_list.in_or_enqueue(this);\n        }\n      }\n    } else if (ret == SSL_WAIT_FOR_HOOK) {\n      // avoid readReschedule - done when the plugin calls us back to reenable\n    } else {\n      readReschedule(nh);\n    }\n    return;\n  }\n\n  // If there is nothing to do or no space available, disable connection\n  if (ntodo <= 0 || !buf.writer()->write_avail()) {\n    read_disable(nh, this);\n    return;\n  }\n\n  // At this point we are at the post-handshake SSL processing\n  //\n  // not sure if this do-while loop is really needed here, please replace\n  // this comment if you know\n  do {\n    ret = ssl_read_from_net(this, lthread, r);\n    if (ret == SSL_READ_READY || ret == SSL_READ_ERROR_NONE) {\n      bytes += r;\n    }\n    ink_assert(bytes >= 0);\n  } while ((ret == SSL_READ_READY && bytes == 0) || ret == SSL_READ_ERROR_NONE);\n\n  if (bytes > 0) {\n    if (ret == SSL_READ_WOULD_BLOCK || ret == SSL_READ_READY) {\n      if (readSignalAndUpdate(VC_EVENT_READ_READY) != EVENT_CONT) {\n        Debug(\"ssl\", \"ssl_read_from_net, readSignal != EVENT_CONT\");\n        return;\n      }\n    }\n  }\n\n  switch (ret) {\n  case SSL_READ_READY:\n    readReschedule(nh);\n    return;\n    break;\n  case SSL_WRITE_WOULD_BLOCK:\n  case SSL_READ_WOULD_BLOCK:\n    if (lock.get_mutex() != s->vio.mutex.get()) {\n      Debug(\"ssl\", \"ssl_read_from_net, mutex switched\");\n      if (ret == SSL_READ_WOULD_BLOCK) {\n        readReschedule(nh);\n      } else {\n        writeReschedule(nh);\n      }\n      return;\n    }\n    // reset the trigger and remove from the ready queue\n    // we will need to be retriggered to read from this socket again\n    read.triggered = 0;\n    nh->read_ready_list.remove(this);\n    Debug(\"ssl\", \"read_from_net, read finished - would block\");\n#ifdef TS_USE_PORT\n    if (ret == SSL_READ_WOULD_BLOCK) {\n      readReschedule(nh);\n    } else {\n      writeReschedule(nh);\n    }\n#endif\n    break;\n\n  case SSL_READ_EOS:\n    // close the connection if we have SSL_READ_EOS, this is the return value from ssl_read_from_net() if we get an\n    // SSL_ERROR_ZERO_RETURN from SSL_get_error()\n    // SSL_ERROR_ZERO_RETURN means that the origin server closed the SSL connection\n    read.triggered = 0;\n    readSignalDone(VC_EVENT_EOS, nh);\n\n    if (bytes > 0) {\n      Debug(\"ssl\", \"read_from_net, read finished - EOS\");\n    } else {\n      Debug(\"ssl\", \"read_from_net, read finished - 0 useful bytes read, bytes used by SSL layer\");\n    }\n    break;\n  case SSL_READ_COMPLETE:\n    readSignalDone(VC_EVENT_READ_COMPLETE, nh);\n    Debug(\"ssl\", \"read_from_net, read finished - signal done\");\n    break;\n  case SSL_READ_ERROR:\n    this->read.triggered = 0;\n    readSignalError(nh, (int)r);\n    Debug(\"ssl\", \"read_from_net, read finished - read error\");\n    break;\n  }\n}", "target": 2, "idx": 9852}
{"commit_id": "8fe7b5f9960f4d9ec46787af394d180c39c6b2db", "project": "xen-project/xen", "func": "int evtchn_destroy(struct domain *d)\n{\n    unsigned int i;\n\n    /* After this barrier no new event-channel allocations can occur. */\n    BUG_ON(!d->is_dying);\n    spin_barrier(&d->event_lock);\n\n    /* Close all existing event channels. */\n    for ( i = d->valid_evtchns; --i; )\n    {\n        evtchn_close(d, i, 0);\n\n        /*\n         * Avoid preempting when called from domain_create()'s error path,\n         * and don't check too often (choice of frequency is arbitrary).\n         */\n        if ( i && !(i & 0x3f) && d->is_dying != DOMDYING_dead &&\n             hypercall_preempt_check() )\n        {\n            write_atomic(&d->valid_evtchns, i);\n            return -ERESTART;\n        }\n    }\n\n    ASSERT(!d->active_evtchns);\n\n    clear_global_virq_handlers(d);\n\n    evtchn_fifo_destroy(d);\n\n    return 0;\n}", "target": 1, "idx": 9853}
{"commit_id": "5ac1b9e24ff6afc465756edf845d2e9660bd34bf", "project": "tensorflow", "func": "static const char* ConvertScalar(PyObject* v, Eigen::half* out) {\n    return ConvertOneFloat<Eigen::half>(v, out);\n  }", "target": 1, "idx": 9854}
{"commit_id": "ce683e5f9d045e5d67d1312a42b359cb2ab2a13c", "project": "torvalds/linux", "func": "int xt_compat_check_entry_offsets(const void *base, const char *elems,\n\t\t\t\t  unsigned int target_offset,\n\t\t\t\t  unsigned int next_offset)\n{\n\tlong size_of_base_struct = elems - (const char *)base;\n\tconst struct compat_xt_entry_target *t;\n\tconst char *e = base;\n\n\tif (target_offset < size_of_base_struct)\n\t\treturn -EINVAL;\n\n\tif (target_offset + sizeof(*t) > next_offset)\n\t\treturn -EINVAL;\n\n\tt = (void *)(e + target_offset);\n\tif (t->u.target_size < sizeof(*t))\n\t\treturn -EINVAL;\n\n\tif (target_offset + t->u.target_size > next_offset)\n\t\treturn -EINVAL;\n\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) == 0 &&\n\t    target_offset + sizeof(struct compat_xt_standard_target) != next_offset)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}", "target": 2, "idx": 9855}
{"commit_id": "34cc326eb2c5695833361887fe0b32e8d987741c", "project": "ArtifexSoftware/ghostpdl", "func": "int\nerrorexec_find(i_ctx_t *i_ctx_p, ref *perror_object)\n{\n    long i;\n    const ref *ep;\n\n    for (i = 0; (ep = ref_stack_index(&e_stack, i)) != 0; ++i) {\n        if (r_is_estack_mark(ep)) {\n            if (ep->value.opproc == oparray_cleanup) {\n                /* See oppr: above. */\n                uint opindex = (uint)ep[1].value.intval;\n                if (opindex == 0) /* internal operator, ignore */\n                    continue;\n                op_index_ref(imemory, opindex, perror_object);\n                return 1;\n            }\n            if (ep->value.opproc == oparray_no_cleanup)\n                return 0;       /* protection disabled */\n            if (ep->value.opproc == errorexec_cleanup) {\n                if (r_has_type(ep + 1, t_null))\n                    return 0;\n                *perror_object = ep[1]; /* see .errorexec above */\n                return 1;\n            }\n        }\n    }\n    return 0;\n}", "target": 1, "idx": 9856}
{"commit_id": "8844618d8aa7a9973e7b527d038a2a589665002c", "project": "torvalds/linux", "func": "int ext4_mb_add_groupinfo(struct super_block *sb, ext4_group_t group,\n\t\t\t  struct ext4_group_desc *desc)\n{\n\tint i;\n\tint metalen = 0;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_group_info **meta_group_info;\n\tstruct kmem_cache *cachep = get_groupinfo_cache(sb->s_blocksize_bits);\n\n\t/*\n\t * First check if this group is the first of a reserved block.\n\t * If it's true, we have to allocate a new table of pointers\n\t * to ext4_group_info structures\n\t */\n\tif (group % EXT4_DESC_PER_BLOCK(sb) == 0) {\n\t\tmetalen = sizeof(*meta_group_info) <<\n\t\t\tEXT4_DESC_PER_BLOCK_BITS(sb);\n\t\tmeta_group_info = kmalloc(metalen, GFP_NOFS);\n\t\tif (meta_group_info == NULL) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't allocate mem \"\n\t\t\t\t \"for a buddy group\");\n\t\t\tgoto exit_meta_group_info;\n\t\t}\n\t\tsbi->s_group_info[group >> EXT4_DESC_PER_BLOCK_BITS(sb)] =\n\t\t\tmeta_group_info;\n\t}\n\n\tmeta_group_info =\n\t\tsbi->s_group_info[group >> EXT4_DESC_PER_BLOCK_BITS(sb)];\n\ti = group & (EXT4_DESC_PER_BLOCK(sb) - 1);\n\n\tmeta_group_info[i] = kmem_cache_zalloc(cachep, GFP_NOFS);\n\tif (meta_group_info[i] == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"can't allocate buddy mem\");\n\t\tgoto exit_group_info;\n\t}\n\tset_bit(EXT4_GROUP_INFO_NEED_INIT_BIT,\n\t\t&(meta_group_info[i]->bb_state));\n\n\t/*\n\t * initialize bb_free to be able to skip\n\t * empty groups without initialization\n\t */\n\tif (ext4_has_group_desc_csum(sb) &&\n\t    (desc->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT))) {\n\t\tmeta_group_info[i]->bb_free =\n\t\t\text4_free_clusters_after_init(sb, group, desc);\n\t} else {\n\t\tmeta_group_info[i]->bb_free =\n\t\t\text4_free_group_clusters(sb, desc);\n\t}\n\n\tINIT_LIST_HEAD(&meta_group_info[i]->bb_prealloc_list);\n\tinit_rwsem(&meta_group_info[i]->alloc_sem);\n\tmeta_group_info[i]->bb_free_root = RB_ROOT;\n\tmeta_group_info[i]->bb_largest_free_order = -1;  /* uninit */\n\n#ifdef DOUBLE_CHECK\n\t{\n\t\tstruct buffer_head *bh;\n\t\tmeta_group_info[i]->bb_bitmap =\n\t\t\tkmalloc(sb->s_blocksize, GFP_NOFS);\n\t\tBUG_ON(meta_group_info[i]->bb_bitmap == NULL);\n\t\tbh = ext4_read_block_bitmap(sb, group);\n\t\tBUG_ON(IS_ERR_OR_NULL(bh));\n\t\tmemcpy(meta_group_info[i]->bb_bitmap, bh->b_data,\n\t\t\tsb->s_blocksize);\n\t\tput_bh(bh);\n\t}\n#endif\n\n\treturn 0;\n\nexit_group_info:\n\t/* If a meta_group_info table has been allocated, release it now */\n\tif (group % EXT4_DESC_PER_BLOCK(sb) == 0) {\n\t\tkfree(sbi->s_group_info[group >> EXT4_DESC_PER_BLOCK_BITS(sb)]);\n\t\tsbi->s_group_info[group >> EXT4_DESC_PER_BLOCK_BITS(sb)] = NULL;\n\t}\nexit_meta_group_info:\n\treturn -ENOMEM;\n}", "target": 1, "idx": 9857}
{"commit_id": "84ac7260236a49c79eede91617700174c2c19b0c", "project": "torvalds/linux", "func": "static int packet_set_ring(struct sock *sk, union tpacket_req_u *req_u,\n\t\tint closing, int tx_ring)\n{\n\tstruct pgv *pg_vec = NULL;\n\tstruct packet_sock *po = pkt_sk(sk);\n\tint was_running, order = 0;\n\tstruct packet_ring_buffer *rb;\n\tstruct sk_buff_head *rb_queue;\n\t__be16 num;\n\tint err = -EINVAL;\n\t/* Added to avoid minimal code churn */\n\tstruct tpacket_req *req = &req_u->req;\n\n\tlock_sock(sk);\n\t/* Opening a Tx-ring is NOT supported in TPACKET_V3 */\n\tif (!closing && tx_ring && (po->tp_version > TPACKET_V2)) {\n\t\tnet_warn_ratelimited(\"Tx-ring is not supported.\\n\");\n\t\tgoto out;\n\t}\n\n\trb = tx_ring ? &po->tx_ring : &po->rx_ring;\n\trb_queue = tx_ring ? &sk->sk_write_queue : &sk->sk_receive_queue;\n\n\terr = -EBUSY;\n\tif (!closing) {\n\t\tif (atomic_read(&po->mapped))\n\t\t\tgoto out;\n\t\tif (packet_read_pending(rb))\n\t\t\tgoto out;\n\t}\n\n\tif (req->tp_block_nr) {\n\t\t/* Sanity tests and some calculations */\n\t\terr = -EBUSY;\n\t\tif (unlikely(rb->pg_vec))\n\t\t\tgoto out;\n\n\t\tswitch (po->tp_version) {\n\t\tcase TPACKET_V1:\n\t\t\tpo->tp_hdrlen = TPACKET_HDRLEN;\n\t\t\tbreak;\n\t\tcase TPACKET_V2:\n\t\t\tpo->tp_hdrlen = TPACKET2_HDRLEN;\n\t\t\tbreak;\n\t\tcase TPACKET_V3:\n\t\t\tpo->tp_hdrlen = TPACKET3_HDRLEN;\n\t\t\tbreak;\n\t\t}\n\n\t\terr = -EINVAL;\n\t\tif (unlikely((int)req->tp_block_size <= 0))\n\t\t\tgoto out;\n\t\tif (unlikely(!PAGE_ALIGNED(req->tp_block_size)))\n\t\t\tgoto out;\n\t\tif (po->tp_version >= TPACKET_V3 &&\n\t\t    (int)(req->tp_block_size -\n\t\t\t  BLK_PLUS_PRIV(req_u->req3.tp_sizeof_priv)) <= 0)\n\t\t\tgoto out;\n\t\tif (unlikely(req->tp_frame_size < po->tp_hdrlen +\n\t\t\t\t\tpo->tp_reserve))\n\t\t\tgoto out;\n\t\tif (unlikely(req->tp_frame_size & (TPACKET_ALIGNMENT - 1)))\n\t\t\tgoto out;\n\n\t\trb->frames_per_block = req->tp_block_size / req->tp_frame_size;\n\t\tif (unlikely(rb->frames_per_block == 0))\n\t\t\tgoto out;\n\t\tif (unlikely((rb->frames_per_block * req->tp_block_nr) !=\n\t\t\t\t\treq->tp_frame_nr))\n\t\t\tgoto out;\n\n\t\terr = -ENOMEM;\n\t\torder = get_order(req->tp_block_size);\n\t\tpg_vec = alloc_pg_vec(req, order);\n\t\tif (unlikely(!pg_vec))\n\t\t\tgoto out;\n\t\tswitch (po->tp_version) {\n\t\tcase TPACKET_V3:\n\t\t/* Transmit path is not supported. We checked\n\t\t * it above but just being paranoid\n\t\t */\n\t\t\tif (!tx_ring)\n\t\t\t\tinit_prb_bdqc(po, rb, pg_vec, req_u);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* Done */\n\telse {\n\t\terr = -EINVAL;\n\t\tif (unlikely(req->tp_frame_nr))\n\t\t\tgoto out;\n\t}\n\n\n\t/* Detach socket from network */\n\tspin_lock(&po->bind_lock);\n\twas_running = po->running;\n\tnum = po->num;\n\tif (was_running) {\n\t\tpo->num = 0;\n\t\t__unregister_prot_hook(sk, false);\n\t}\n\tspin_unlock(&po->bind_lock);\n\n\tsynchronize_net();\n\n\terr = -EBUSY;\n\tmutex_lock(&po->pg_vec_lock);\n\tif (closing || atomic_read(&po->mapped) == 0) {\n\t\terr = 0;\n\t\tspin_lock_bh(&rb_queue->lock);\n\t\tswap(rb->pg_vec, pg_vec);\n\t\trb->frame_max = (req->tp_frame_nr - 1);\n\t\trb->head = 0;\n\t\trb->frame_size = req->tp_frame_size;\n\t\tspin_unlock_bh(&rb_queue->lock);\n\n\t\tswap(rb->pg_vec_order, order);\n\t\tswap(rb->pg_vec_len, req->tp_block_nr);\n\n\t\trb->pg_vec_pages = req->tp_block_size/PAGE_SIZE;\n\t\tpo->prot_hook.func = (po->rx_ring.pg_vec) ?\n\t\t\t\t\t\ttpacket_rcv : packet_rcv;\n\t\tskb_queue_purge(rb_queue);\n\t\tif (atomic_read(&po->mapped))\n\t\t\tpr_err(\"packet_mmap: vma is busy: %d\\n\",\n\t\t\t       atomic_read(&po->mapped));\n\t}\n\tmutex_unlock(&po->pg_vec_lock);\n\n\tspin_lock(&po->bind_lock);\n\tif (was_running) {\n\t\tpo->num = num;\n\t\tregister_prot_hook(sk);\n\t}\n\tspin_unlock(&po->bind_lock);\n\tif (closing && (po->tp_version > TPACKET_V2)) {\n\t\t/* Because we don't support block-based V3 on tx-ring */\n\t\tif (!tx_ring)\n\t\t\tprb_shutdown_retire_blk_timer(po, rb_queue);\n\t}\n\n\tif (pg_vec)\n\t\tfree_pg_vec(pg_vec, order, req->tp_block_nr);\nout:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 2, "idx": 9858}
{"commit_id": "708dc2f1291e104fe4eef810bb8ffc1fae5b19c1", "project": "openssl", "func": "static int MOD_EXP_CTIME_COPY_TO_PREBUF(const BIGNUM *b, int top,\n                                        unsigned char *buf, int idx,\n                                        int window)\n{\n    int i, j;\n    int width = 1 << window;\n    BN_ULONG *table = (BN_ULONG *)buf;\n\n    if (top > b->top)\n        top = b->top;           /* this works because 'buf' is explicitly\n                                 * zeroed */\n    for (i = 0, j = idx; i < top; i++, j += width) {\n        table[j] = b->d[i];\n    }\n\n    return 1;\n}", "target": 1, "idx": 9859}
{"commit_id": "b64ce17852b180dfeea81cf458660be41a78974d", "project": "mruby", "func": "static void\ninit_copy(mrb_state *mrb, mrb_value dest, mrb_value obj)\n{\n  switch (mrb_type(obj)) {\n    case MRB_TT_ICLASS:\n      copy_class(mrb, dest, obj);\n      return;\n    case MRB_TT_CLASS:\n    case MRB_TT_MODULE:\n      copy_class(mrb, dest, obj);\n      mrb_iv_copy(mrb, dest, obj);\n      mrb_iv_remove(mrb, dest, mrb_intern_lit(mrb, \"__classname__\"));\n      break;\n    case MRB_TT_OBJECT:\n    case MRB_TT_SCLASS:\n    case MRB_TT_HASH:\n    case MRB_TT_DATA:\n    case MRB_TT_EXCEPTION:\n      mrb_iv_copy(mrb, dest, obj);\n      break;\n    case MRB_TT_ISTRUCT:\n      mrb_istruct_copy(dest, obj);\n      break;\n\n    default:\n      break;\n  }\n  mrb_funcall(mrb, dest, \"initialize_copy\", 1, obj);\n}", "target": 3, "idx": 9860}
{"commit_id": "7245bff300d3fa8bacbef7897ff080a6f1c23eba", "project": "php/php-src", "func": "zend_object_iterator *spl_filesystem_tree_get_iterator(zend_class_entry *ce, zval *object, int by_ref TSRMLS_DC)\n{\n\tspl_filesystem_iterator *iterator;\n\tspl_filesystem_object *dir_object;\n\n\tif (by_ref) {\n\t\tzend_error(E_ERROR, \"An iterator cannot be used with foreach by reference\");\n\t}\n\tdir_object = (spl_filesystem_object*)zend_object_store_get_object(object TSRMLS_CC);\n\titerator   = spl_filesystem_object_to_iterator(dir_object);\n\n\t/* initialize iterator if wasn't gotten before */\n\tif (iterator->intern.data == NULL) {\n\t\titerator->intern.data = object;\n\t\titerator->intern.funcs = &spl_filesystem_tree_it_funcs;\n\t}\n\tzval_add_ref(&object);\n\n\treturn (zend_object_iterator*)iterator;\n}", "target": 3, "idx": 9861}
{"commit_id": "360e95d45ac4123255a4c796db96337f332160ad", "project": "OpenSC", "func": "static int tcos_select_file(sc_card_t *card,\n\t\t\t    const sc_path_t *in_path,\n\t\t\t    sc_file_t **file_out)\n{\n\tsc_context_t *ctx;\n\tsc_apdu_t apdu;\n\tsc_file_t *file=NULL;\n\tu8 buf[SC_MAX_APDU_BUFFER_SIZE], pathbuf[SC_MAX_PATH_SIZE], *path = pathbuf;\n\tunsigned int i;\n\tint r, pathlen;\n\n\tassert(card != NULL && in_path != NULL);\n\tctx=card->ctx;\n\tmemcpy(path, in_path->value, in_path->len);\n\tpathlen = in_path->len;\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0, 0x04);\n\t\n\tswitch (in_path->type) {\n\tcase SC_PATH_TYPE_FILE_ID:\n\t\tif (pathlen != 2) return SC_ERROR_INVALID_ARGUMENTS;\n\t\t/* fall through */\n\tcase SC_PATH_TYPE_FROM_CURRENT:\n\t\tapdu.p1 = 9;\n\t\tbreak;\n\tcase SC_PATH_TYPE_DF_NAME:\n\t\tapdu.p1 = 4;\n\t\tbreak;\n\tcase SC_PATH_TYPE_PATH:\n\t\tapdu.p1 = 8;\n\t\tif (pathlen >= 2 && memcmp(path, \"\\x3F\\x00\", 2) == 0) path += 2, pathlen -= 2;\n\t\tif (pathlen == 0) apdu.p1 = 0;\n\t\tbreak;\n\tcase SC_PATH_TYPE_PARENT:\n\t\tapdu.p1 = 3;\n\t\tpathlen = 0;\n\t\tbreak;\n\tdefault:\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\tif( pathlen == 0 ) apdu.cse = SC_APDU_CASE_2_SHORT;\n\n\tapdu.lc = pathlen;\n\tapdu.data = path;\n\tapdu.datalen = pathlen;\n\n\tif (file_out != NULL) {\n\t\tapdu.resp = buf;\n\t\tapdu.resplen = sizeof(buf);\n\t\tapdu.le = 256;\n\t} else {\n\t\tapdu.resplen = 0;\n\t\tapdu.le = 0; \n\t\tapdu.p2 = 0x0C; \n\t\tapdu.cse = (pathlen == 0) ? SC_APDU_CASE_1 : SC_APDU_CASE_3_SHORT;\n\t}\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tSC_TEST_RET(ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tif (r || file_out == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, r);\n\n\tif (apdu.resplen < 1 || apdu.resp[0] != 0x62){\n\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"received invalid template %02X\\n\", apdu.resp[0]);\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t}\n\n\tfile = sc_file_new();\n\tif (file == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_OUT_OF_MEMORY);\n\t*file_out = file;\n\tfile->path = *in_path;\n\n\tfor(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){\n\t\tsize_t j, len=apdu.resp[i+1];\n\t\tunsigned char type=apdu.resp[i], *d=apdu.resp+i+2;\n\n\t\tswitch (type) {\n\t\tcase 0x80:\n\t\tcase 0x81:\n\t\t\tfile->size=0;\n\t\t\tfor(j=0; j<len; ++j) file->size = (file->size<<8) | d[j];\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tfile->shareable = (d[0] & 0x40) ? 1 : 0;\n\t\t\tfile->ef_structure = d[0] & 7;\n\t\t\tswitch ((d[0]>>3) & 7) {\n\t\t\tcase 0: file->type = SC_FILE_TYPE_WORKING_EF; break;\n\t\t\tcase 7: file->type = SC_FILE_TYPE_DF; break;\n\t\t\tdefault:\n\t\t\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"invalid file type %02X in file descriptor\\n\", d[0]);\n\t\t\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x83:\n\t\t\tfile->id = (d[0]<<8) | d[1];\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tfile->namelen = MIN(sizeof file->name, len);\n\t\t\tmemcpy(file->name, d, file->namelen);\n\t\t\tbreak;\n\t\tcase 0x86:\n\t\t\tsc_file_set_sec_attr(file, d, len); \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (len>0) sc_file_set_prop_attr(file, d, len); \n\t\t}\n\t}\n\tfile->magic = SC_FILE_MAGIC;\n\n\tparse_sec_attr(card, file, file->sec_attr, file->sec_attr_len);\n\n\treturn 0;\n}", "target": 1, "idx": 9862}
{"commit_id": "7248ddb7ddd363b15b86e65022773f791764c33a", "project": "appneta/tcpreplay", "func": "int \nmain(int argc, char *argv[])\n{\n    int optct, rcode;\n    pcap_t *dlt_pcap;\n#ifdef ENABLE_FRAGROUTE\n    char ebuf[FRAGROUTE_ERRBUF_LEN];\n#endif\n    tcprewrite_init();\n\n    /* call autoopts to process arguments */\n    optct = optionProcess(&tcprewriteOptions, argc, argv);\n    argc -= optct;\n    argv += optct;\n\n    /* parse the tcprewrite args */\n    post_args(argc, argv);\n\n    /* init tcpedit context */\n    if (tcpedit_init(&tcpedit, pcap_datalink(options.pin)) < 0) {\n        err_no_exitx(\"Error initializing tcpedit: %s\", tcpedit_geterr(tcpedit));\n        tcpedit_close(&tcpedit);\n        exit(-1);\n    }\n\n    /* parse the tcpedit args */\n    rcode = tcpedit_post_args(tcpedit);\n    if (rcode < 0) {\n        err_no_exitx(\"Unable to parse args: %s\", tcpedit_geterr(tcpedit));\n        tcpedit_close(&tcpedit);\n        exit(-1);\n    } else if (rcode == 1) {\n        warnx(\"%s\", tcpedit_geterr(tcpedit));\n    }\n\n    if (tcpedit_validate(tcpedit) < 0) {\n        err_no_exitx(\"Unable to edit packets given options:\\n%s\",\n                tcpedit_geterr(tcpedit));\n        tcpedit_close(&tcpedit);\n        exit(-1);\n    }\n\n    /* fuzzing init */\n    fuzzing_init(tcpedit->fuzz_seed, tcpedit->fuzz_factor);\n\n   /* open up the output file */\n    options.outfile = safe_strdup(OPT_ARG(OUTFILE));\n    dbgx(1, \"Rewriting DLT to %s\",\n            pcap_datalink_val_to_name(tcpedit_get_output_dlt(tcpedit)));\n    if ((dlt_pcap = pcap_open_dead(tcpedit_get_output_dlt(tcpedit), 65535)) == NULL) {\n        tcpedit_close(&tcpedit);\n        err(-1, \"Unable to open dead pcap handle.\");\n    }\n\n    dbgx(1, \"DLT of dlt_pcap is %s\",\n        pcap_datalink_val_to_name(pcap_datalink(dlt_pcap)));\n\n#ifdef ENABLE_FRAGROUTE\n    if (options.fragroute_args) {\n        if ((options.frag_ctx = fragroute_init(65535, pcap_datalink(dlt_pcap), options.fragroute_args, ebuf)) == NULL) {\n            err_no_exitx(\"%s\", ebuf);\n            tcpedit_close(&tcpedit);\n            exit(-1);\n        }\n    }\n#endif\n\n#ifdef ENABLE_VERBOSE\n    if (options.verbose) {\n        tcpdump_open(&tcpdump, dlt_pcap);\n    }\n#endif\n\n    if ((options.pout = pcap_dump_open(dlt_pcap, options.outfile)) == NULL) {\n        err_no_exitx(\"Unable to open output pcap file: %s\", pcap_geterr(dlt_pcap));\n        tcpedit_close(&tcpedit);\n        exit(-1);\n    }\n\n    pcap_close(dlt_pcap);\n\n    /* rewrite packets */\n    if (rewrite_packets(tcpedit, options.pin, options.pout) == TCPEDIT_ERROR) {\n        err_no_exitx(\"Error rewriting packets: %s\", tcpedit_geterr(tcpedit));\n        tcpedit_close(&tcpedit);\n        exit(-1);\n    }\n\n    /* clean up after ourselves */\n    pcap_dump_close(options.pout);\n    pcap_close(options.pin);\n    tcpedit_close(&tcpedit);\n\n#ifdef ENABLE_VERBOSE\n    tcpdump_close(&tcpdump);\n#endif\n\n#ifdef ENABLE_FRAGROUTE\n    if (options.frag_ctx) {\n        fragroute_close(options.frag_ctx);\n    }\n#endif\n\n#ifdef ENABLE_DMALLOC\n    dmalloc_shutdown();\n#endif\n\n    restore_stdin();\n    return 0;\n}", "target": 2, "idx": 9863}
{"commit_id": "e091d65835966ef56d53a4105a7362cafdb1582b", "project": "libvips", "func": "static const char *\nvips_utf8_strcasestr( const char *haystack_start, const char *needle_start, \n\tint len_bytes )\n{\n        int needle_len = g_utf8_strlen( needle_start, -1 );\n        int needle_len_bytes = strlen( needle_start );\n\n\tconst char *haystack;\n\n\tfor( haystack = haystack_start; \n\t\thaystack - haystack_start <= len_bytes - needle_len_bytes; \n\t\thaystack = g_utf8_find_next_char( haystack, NULL ) ) {\n                const char *needle_char;\n                const char *haystack_char;\n\t\tint i;\n\n                haystack_char = haystack;\n                needle_char = needle_start;\n                for( i = 0; i < needle_len; i++ ) {\n\t\t\t/* Haystack isn't necessarily null-terminated and\n\t\t\t * might end half-way through a utf-8 character, so we\n\t\t\t * need to be careful not to run off the end.\n\t\t\t */\n                        gunichar a = \n\t\t\t\tg_utf8_get_char_validated( haystack_char, \n\t\t\t\t\thaystack_start + len_bytes - haystack );\n                        gunichar b = \n\t\t\t\tg_utf8_get_char_validated( needle_char, -1 );\n\n                        /* Invalid utf8? \n\t\t\t *\n\t\t\t * gunichar is a uint32, so we can't compare < 0, we \n\t\t\t * have to look for -1 and -2 (the two possible error \n\t\t\t * values).\n                         */\n                        if( a == (gunichar) -1 ||\n\t\t\t\ta == (gunichar) -2 ||\n\t\t\t\tb == (gunichar) -1 ||\n\t\t\t\tb == (gunichar) -2 )\n                                return( NULL );\n\n                        /* Disallow codepoint U+0000 as it's a nul byte.\n                         * This is redundant with GLib >= 2.63.0, see:\n                         * https://gitlab.gnome.org/GNOME/glib/-/merge_requests/967\n                         */\n#if !GLIB_CHECK_VERSION( 2, 63, 0 )\n                        if( a == (gunichar) 0 )\n                                return( NULL );\n#endif\n\n                        /* Mismatch.\n                         */\n                        if( g_unichar_tolower( a ) != g_unichar_tolower( b ) )\n                                break;\n\n                        haystack_char = \n\t\t\t\tg_utf8_find_next_char( haystack_char, \n\t\t\t\t\thaystack_start + len_bytes );\n\n                        /* End of haystack. There can't be a complete needle\n                         * anywhere.\n                         */\n                        if( haystack_char == NULL )\n                                return( NULL );\n\n                        /* needle_char will never be NULL.\n                         */\n                        needle_char = \n\t\t\t\tg_utf8_find_next_char( needle_char, NULL );\n                }\n\n                if( i == needle_len )\n\t\t\t/* Walked the whole of needle, so we must have found a \n\t\t\t * complete match.\n\t\t\t */\n                        return( haystack );\n        }\n\n        /* Walked the whole of haystack without finding a match.\n         */\n        return( NULL );\n}", "target": 1, "idx": 9864}
{"commit_id": "2e48a12ab1e30d43498c2d53e878a11a1b5102d5", "project": "klibc", "func": "static void copyin_link(struct new_cpio_header *file_hdr, int in_file_des)\n{\n\tchar *link_name = NULL;\t/* Name of hard and symbolic links.  */\n\tint res;\t\t/* Result of various function calls.  */\n\n\tlink_name = (char *)xmalloc(file_hdr->c_filesize + 1);\n\tlink_name[file_hdr->c_filesize] = '\\0';\n\ttape_buffered_read(link_name, in_file_des, file_hdr->c_filesize);\n\ttape_skip_padding(in_file_des, file_hdr->c_filesize);\n\n\tres = symlink(link_name, file_hdr->c_name);\n\tif (res < 0) {\n\t\tfprintf(stderr, \"%s: symlink %s: %s\\n\",\n\t\t\tprogname, file_hdr->c_name, strerror(errno));\n\t\tfree(link_name);\n\t\treturn;\n\t}\n\tif ((lchown(file_hdr->c_name, file_hdr->c_uid, file_hdr->c_gid) < 0)\n\t    && errno != EPERM) {\n\t\tfprintf(stderr, \"%s: lchown %s: %s\\n\",\n\t\t\tprogname, file_hdr->c_name, strerror(errno));\n\t}\n\tfree(link_name);\n}", "target": 2, "idx": 9865}
{"commit_id": "0bc90e4062a5f9258c91eca018c019b179066c62", "project": "uclouvain/openjpeg", "func": "opj_volume_t* pgxtovolume(char *relpath, opj_cparameters_t *parameters)\n{\n\n    FILE *f = NULL;\n    int w, h, prec;\n    unsigned long offset;\n    int i, s, numcomps, maxvalue, sliceno, slicepos, maxslice = 0;\n\n    OPJ_COLOR_SPACE color_space;\n    opj_volume_cmptparm_t cmptparm; /* maximum of 1 component */\n    opj_volume_t * volume = NULL;\n\n    char endian1, endian2, sign;\n    char signtmp[32];\n    char temp[32];\n    opj_volume_comp_t *comp = NULL;\n\n    DIR *dirp;\n    struct dirent *direntp;\n\n    char *tmp = NULL, *tmp2 = NULL,\n          *point = NULL, *pgx = NULL;\n    char tmpdirpath[MAX_PATH];\n    char dirpath[MAX_PATH];\n    char pattern[MAX_PATH];\n    char pgxfiles[MAX_SLICES][MAX_PATH];\n    int pgxslicepos[MAX_SLICES];\n    char tmpno[3];\n\n    numcomps = 1;\n    color_space = CLRSPC_GRAY;\n    sliceno = 0;\n    maxvalue = 0;\n    memset(pgxfiles, 0, MAX_SLICES * MAX_PATH * sizeof(char));\n    memset(&cmptparm, 0, sizeof(opj_volume_cmptparm_t));\n\n    /* Separaci\u00f3n del caso de un \u00fanico slice frente al de muchos */\n    if ((tmp = strrchr(relpath, '-')) == NULL) {\n        /*fprintf(stdout,\"[INFO] A volume of only one slice....\\n\");*/\n        sliceno = 1;\n        maxslice = 1;\n        strcpy(pgxfiles[0], relpath);\n\n    } else {\n        /*Fetch only the path */\n        strcpy(tmpdirpath, relpath);\n        if ((tmp = strrchr(tmpdirpath, '/')) != NULL) {\n            tmp++;\n            *tmp = '\\0';\n            strcpy(dirpath, tmpdirpath);\n        } else {\n            strcpy(dirpath, \"./\");\n        }\n\n        /*Fetch the pattern of the volume slices*/\n        if ((tmp = strrchr(relpath, '/')) != NULL) {\n            tmp++;\n        } else {\n            tmp = relpath;\n        }\n        if ((tmp2 = strrchr(tmp, '-')) != NULL) {\n            *tmp2 = '\\0';\n        } else {\n            fprintf(stdout, \"[ERROR] tmp2 ha dado null. no ha encontrado el * %s %s\", tmp,\n                    relpath);\n            return NULL;\n        }\n        strcpy(pattern, tmp);\n\n        dirp = opendir(dirpath);\n        if (dirp == NULL) {\n            fprintf(stdout,\n                    \"[ERROR] Infile must be a .pgx file or a directory that contain pgx files\");\n            return NULL;\n        }\n\n        /*Read all .pgx files of directory */\n        while ((direntp = readdir(dirp)) != NULL) {\n            /* Found a directory, but ignore . and .. */\n            if (strcmp(\".\", direntp->d_name) == 0 || strcmp(\"..\", direntp->d_name) == 0) {\n                continue;\n            }\n\n            if (((pgx = strstr(direntp->d_name, pattern)) != NULL) &&\n                    ((tmp2 = strstr(direntp->d_name, \".pgx\")) != NULL)) {\n\n                strcpy(tmp, dirpath);\n                tmp = strcat(tmp, direntp->d_name);\n\n                /*Obtenemos el index de la secuencia de slices*/\n                if ((tmp2 = strpbrk(direntp->d_name, \"0123456789\")) == NULL) {\n                    continue;\n                }\n                i = 0;\n                while (tmp2 != NULL) {\n                    tmpno[i++] = *tmp2;\n                    point = tmp2;\n                    tmp2 = strpbrk(tmp2 + 1, \"0123456789\");\n                }\n                tmpno[i] = '\\0';\n\n                /*Comprobamos que no estamos leyendo algo raro como pattern.jp3d*/\n                if ((point = strpbrk(point, \".\")) == NULL) {\n                    break;\n                }\n                /*Slicepos --> index de slice; Sliceno --> no de slices hasta el momento*/\n                slicepos = atoi(tmpno);\n                pgxslicepos[sliceno] = slicepos - 1;\n                sliceno++;\n                if (slicepos > maxslice) {\n                    maxslice = slicepos;\n                }\n\n                /*Colocamos el slices en su posicion correspondiente*/\n                strcpy(pgxfiles[slicepos - 1], tmp);\n            }\n        }\n\n    }/* else if pattern*.pgx */\n\n    if (!sliceno) {\n        fprintf(stdout,\n                \"[ERROR] No slices with this pattern founded !! Please check input volume name\\n\");\n        return NULL;\n    }\n    /*if ( maxslice != sliceno) {\n        fprintf(stdout,\"[ERROR] Slices are not sequentially numbered !! Please rename them accordingly\\n\");\n        return NULL;\n    }*/\n\n    for (s = 0; s < sliceno; s++) {\n        int pos = maxslice == sliceno ? s : pgxslicepos[s];\n        f = fopen(pgxfiles[pos], \"rb\");\n        if (!f) {\n            fprintf(stdout, \"[ERROR] Failed to open %s for reading !\\n\", pgxfiles[s]);\n            return NULL;\n        }\n        fprintf(stdout, \"[INFO] Loading %s \\n\", pgxfiles[pos]);\n\n        fseek(f, 0, SEEK_SET);\n        fscanf(f, \"PG%31[ \\t]%c%c%31[ \\t+-]%d%31[ \\t]%d%31[ \\t]%d\", temp, &endian1,\n               &endian2, signtmp, &prec, temp, &w, temp, &h);\n\n        i = 0;\n        sign = '+';\n        while (signtmp[i] != '\\0') {\n            if (signtmp[i] == '-') {\n                sign = '-';\n            }\n            i++;\n        }\n\n        fgetc(f);\n        if (endian1 == 'M' && endian2 == 'L') {\n            cmptparm.bigendian = 1;\n        } else if (endian2 == 'M' && endian1 == 'L') {\n            cmptparm.bigendian = 0;\n        } else {\n            fprintf(stdout, \"[ERROR] Bad pgx header, please check input file\\n\");\n            fclose(f);\n            return NULL;\n        }\n\n        if (s == 0) {\n            /* initialize volume component */\n\n            cmptparm.x0 = parameters->volume_offset_x0;\n            cmptparm.y0 = parameters->volume_offset_y0;\n            cmptparm.z0 = parameters->volume_offset_z0;\n            cmptparm.w = !cmptparm.x0 ? (w - 1) * parameters->subsampling_dx + 1 :\n                         cmptparm.x0 + (w - 1) * parameters->subsampling_dx + 1;\n            cmptparm.h = !cmptparm.y0 ? (h - 1) * parameters->subsampling_dy + 1 :\n                         cmptparm.y0 + (h - 1) * parameters->subsampling_dy + 1;\n            cmptparm.l = !cmptparm.z0 ? (sliceno - 1) * parameters->subsampling_dz + 1 :\n                         cmptparm.z0 + (sliceno - 1) * parameters->subsampling_dz + 1;\n\n            if (sign == '-') {\n                cmptparm.sgnd = 1;\n            } else {\n                cmptparm.sgnd = 0;\n            }\n            cmptparm.prec = prec;\n            cmptparm.bpp = prec;\n            cmptparm.dcoffset = parameters->dcoffset;\n            cmptparm.dx = parameters->subsampling_dx;\n            cmptparm.dy = parameters->subsampling_dy;\n            cmptparm.dz = parameters->subsampling_dz;\n\n            /* create the volume */\n            volume = opj_volume_create(numcomps, &cmptparm, color_space);\n            if (!volume) {\n                fclose(f);\n                return NULL;\n            }\n            /* set volume offset and reference grid */\n            volume->x0 = cmptparm.x0;\n            volume->y0 = cmptparm.y0;\n            volume->z0 = cmptparm.z0;\n            volume->x1 = cmptparm.w;\n            volume->y1 = cmptparm.h;\n            volume->z1 = cmptparm.l;\n\n            /* set volume data :only one component, that is a volume*/\n            comp = &volume->comps[0];\n\n        }/*if sliceno==1*/\n\n        offset = w * h * s;\n\n        for (i = 0; i < w * h; i++) {\n            int v;\n            if (comp->prec <= 8) {\n                if (!comp->sgnd) {\n                    v = readuchar(f);\n                } else {\n                    v = (char) readuchar(f);\n                }\n            } else if (comp->prec <= 16) {\n                if (!comp->sgnd) {\n                    v = readushort(f, cmptparm.bigendian);\n                } else {\n                    v = (short) readushort(f, cmptparm.bigendian);\n                }\n            } else {\n                if (!comp->sgnd) {\n                    v = readuint(f, cmptparm.bigendian);\n                } else {\n                    v = (int) readuint(f, cmptparm.bigendian);\n                }\n            }\n            if (v > maxvalue) {\n                maxvalue = v;\n            }\n            comp->data[i + offset] = v;\n\n        }\n        fclose(f);\n    } /* for s --> sliceno*/\n    comp->bpp = int_floorlog2(maxvalue) + 1;\n    if (sliceno != 1) {\n        closedir(dirp);\n    }\n    /*dump_volume(stdout, volume);*/\n    return volume;\n}", "target": 3, "idx": 9866}
{"commit_id": "de9f869616dd95e95c00bdd6b0fcd3421e8a4323", "project": "torvalds/linux", "func": "static bool get_desc(struct desc_struct *out, unsigned short sel)\n{\n\tstruct desc_ptr gdt_desc = {0, 0};\n\tunsigned long desc_base;\n\n#ifdef CONFIG_MODIFY_LDT_SYSCALL\n\tif ((sel & SEGMENT_TI_MASK) == SEGMENT_LDT) {\n\t\tbool success = false;\n\t\tstruct ldt_struct *ldt;\n\n\t\t/* Bits [15:3] contain the index of the desired entry. */\n\t\tsel >>= 3;\n\n\t\tmutex_lock(&current->active_mm->context.lock);\n\t\tldt = current->active_mm->context.ldt;\n\t\tif (ldt && sel < ldt->nr_entries) {\n\t\t\t*out = ldt->entries[sel];\n\t\t\tsuccess = true;\n\t\t}\n\n\t\tmutex_unlock(&current->active_mm->context.lock);\n\n\t\treturn success;\n\t}\n#endif\n\tnative_store_gdt(&gdt_desc);\n\n\t/*\n\t * Segment descriptors have a size of 8 bytes. Thus, the index is\n\t * multiplied by 8 to obtain the memory offset of the desired descriptor\n\t * from the base of the GDT. As bits [15:3] of the segment selector\n\t * contain the index, it can be regarded as multiplied by 8 already.\n\t * All that remains is to clear bits [2:0].\n\t */\n\tdesc_base = sel & ~(SEGMENT_RPL_MASK | SEGMENT_TI_MASK);\n\n\tif (desc_base > gdt_desc.size)\n\t\treturn false;\n\n\t*out = *(struct desc_struct *)(gdt_desc.address + desc_base);\n\treturn true;\n}", "target": 2, "idx": 9867}
{"commit_id": "1ac2c130b210539ee1e5d67a7bac93f9d8007c0e", "project": "reddit/snudown", "func": "static int\nis_ref(const uint8_t *data, size_t beg, size_t end, size_t *last, struct link_ref **refs)\n{\n/*\tint n; */\n\tsize_t i = 0;\n\tsize_t id_offset, id_end;\n\tsize_t link_offset, link_end;\n\tsize_t title_offset, title_end;\n\tsize_t line_end;\n\n\t/* up to 3 optional leading spaces */\n\tif (beg + 3 >= end) return 0;\n\tif (data[beg] == ' ') { i = 1;\n\tif (data[beg + 1] == ' ') { i = 2;\n\tif (data[beg + 2] == ' ') { i = 3;\n\tif (data[beg + 3] == ' ') return 0; } } }\n\ti += beg;\n\n\t/* id part: anything but a newline between brackets */\n\tif (data[i] != '[') return 0;\n\ti++;\n\tid_offset = i;\n\twhile (i < end && data[i] != '\\n' && data[i] != '\\r' && data[i] != ']')\n\t\ti++;\n\tif (i >= end || data[i] != ']') return 0;\n\tid_end = i;\n\n\t/* spacer: colon (space | tab)* newline? (space | tab)* */\n\ti++;\n\tif (i >= end || data[i] != ':') return 0;\n\ti++;\n\twhile (i < end && data[i] == ' ') i++;\n\tif (i < end && (data[i] == '\\n' || data[i] == '\\r')) {\n\t\ti++;\n\t\tif (i < end && data[i] == '\\r' && data[i - 1] == '\\n') i++; }\n\twhile (i < end && data[i] == ' ') i++;\n\tif (i >= end) return 0;\n\n\t/* link: whitespace-free sequence, optionally between angle brackets */\n\tif (data[i] == '<')\n\t\ti++;\n\n\tlink_offset = i;\n\n\twhile (i < end && data[i] != ' ' && data[i] != '\\n' && data[i] != '\\r')\n\t\ti++;\n\n\tif (data[i - 1] == '>') link_end = i - 1;\n\telse link_end = i;\n\n\t/* optional spacer: (space | tab)* (newline | '\\'' | '\"' | '(' ) */\n\twhile (i < end && data[i] == ' ') i++;\n\tif (i < end && data[i] != '\\n' && data[i] != '\\r'\n\t\t\t&& data[i] != '\\'' && data[i] != '\"' && data[i] != '(')\n\t\treturn 0;\n\tline_end = 0;\n\t/* computing end-of-line */\n\tif (i >= end || data[i] == '\\r' || data[i] == '\\n') line_end = i;\n\tif (i + 1 < end && data[i] == '\\n' && data[i + 1] == '\\r')\n\t\tline_end = i + 1;\n\n\t/* optional (space|tab)* spacer after a newline */\n\tif (line_end) {\n\t\ti = line_end + 1;\n\t\twhile (i < end && data[i] == ' ') i++; }\n\n\t/* optional title: any non-newline sequence enclosed in '\"()\n\t\t\t\t\talone on its line */\n\ttitle_offset = title_end = 0;\n\tif (i + 1 < end\n\t&& (data[i] == '\\'' || data[i] == '\"' || data[i] == '(')) {\n\t\ti++;\n\t\ttitle_offset = i;\n\t\t/* looking for EOL */\n\t\twhile (i < end && data[i] != '\\n' && data[i] != '\\r') i++;\n\t\tif (i + 1 < end && data[i] == '\\n' && data[i + 1] == '\\r')\n\t\t\ttitle_end = i + 1;\n\t\telse\ttitle_end = i;\n\t\t/* stepping back */\n\t\ti -= 1;\n\t\twhile (i > title_offset && data[i] == ' ')\n\t\t\ti -= 1;\n\t\tif (i > title_offset\n\t\t&& (data[i] == '\\'' || data[i] == '\"' || data[i] == ')')) {\n\t\t\tline_end = title_end;\n\t\t\ttitle_end = i; } }\n\n\tif (!line_end || link_end == link_offset)\n\t\treturn 0; /* garbage after the link empty link */\n\n\t/* a valid ref has been found, filling-in return structures */\n\tif (last)\n\t\t*last = line_end;\n\n\tif (refs) {\n\t\tstruct link_ref *ref;\n\n\t\tref = add_link_ref(refs, data + id_offset, id_end - id_offset);\n\t\tif (!ref)\n\t\t\treturn 0;\n\n\t\tref->label = bufnew(id_end - id_offset);\n\t\tbufput(ref->label, data + id_offset, id_end - id_offset);\n\t\tref->link = bufnew(link_end - link_offset);\n\t\tbufput(ref->link, data + link_offset, link_end - link_offset);\n\n\t\tif (title_end > title_offset) {\n\t\t\tref->title = bufnew(title_end - title_offset);\n\t\t\tbufput(ref->title, data + title_offset, title_end - title_offset);\n\t\t}\n\t}\n\n\treturn 1;\n}", "target": 1, "idx": 9868}
{"commit_id": "8d6ee5aad20ecf69a7f59bd8c7fb416a0db87eda", "project": "electron", "func": "void OnPdfResourceIntercepted(\n    const GURL& original_url,\n    const content::ResourceRequestInfo::WebContentsGetter&\n        web_contents_getter) {\n  content::WebContents* web_contents = web_contents_getter.Run();\n  if (!web_contents)\n    return;\n\n  if (!WebContentsPreferences::IsPluginsEnabled(web_contents)) {\n    auto browser_context = web_contents->GetBrowserContext();\n    auto download_manager =\n      content::BrowserContext::GetDownloadManager(browser_context);\n\n    download_manager->DownloadUrl(\n        content::DownloadUrlParameters::CreateForWebContentsMainFrame(\n            web_contents, original_url));\n    return;\n  }\n\n  // The URL passes the original pdf resource url, that will be requested\n  // by the webui page.\n  // chrome://pdf-viewer/index.html?src=https://somepage/123.pdf\n  content::NavigationController::LoadURLParams params(\n      GURL(base::StringPrintf(\"%sindex.html?%s=%s\",\n                              kPdfViewerUIOrigin,\n                              kPdfPluginSrc,\n                              net::EscapeUrlEncodedData(original_url.spec(), false).c_str())));\n  web_contents->GetController().LoadURLWithParams(params);\n}", "target": 1, "idx": 9869}
{"commit_id": "5b8fdee725f8b4b2f8c5dd23da6bc1c05ee7a8f9", "project": "justdan96/tsMuxer", "func": "void VvcUnitWithProfile::profile_tier_level(bool profileTierPresentFlag, int MaxNumSubLayersMinus1)\n{\n    if (profileTierPresentFlag)\n    {\n        profile_idc = m_reader.getBits(7);\n        bool tier_flag = m_reader.getBit();\n    }\n    level_idc = m_reader.getBits(8);\n    m_reader.skipBits(2);  // ptl_frame_only_constraint_flag, ptl_multilayer_enabled_flag\n\n    if (profileTierPresentFlag)\n    {                           // general_constraints_info()\n        if (m_reader.getBit())  // gci_present_flag\n        {\n            m_reader.skipBits(32);\n            m_reader.skipBits(32);\n            m_reader.skipBits(7);\n            int gci_num_reserved_bits = m_reader.getBits(8);\n            for (int i = 0; i < gci_num_reserved_bits; i++) m_reader.skipBit();  // gci_reserved_zero_bit[i]\n        }\n        m_reader.skipBits(m_reader.getBitsLeft() % 8);  // gci_alignment_zero_bit\n    }\n    std::vector<int> ptl_sublayer_level_present_flag;\n    ptl_sublayer_level_present_flag.resize(MaxNumSubLayersMinus1);\n\n    for (int i = MaxNumSubLayersMinus1 - 1; i >= 0; i--) ptl_sublayer_level_present_flag[i] = m_reader.getBit();\n\n    m_reader.skipBits(m_reader.getBitsLeft() % 8);  // ptl_reserved_zero_bit\n\n    for (int i = MaxNumSubLayersMinus1 - 1; i >= 0; i--)\n        if (ptl_sublayer_level_present_flag[i])\n            m_reader.skipBits(8);  // sublayer_level_idc[i]\n    if (profileTierPresentFlag)\n    {\n        int ptl_num_sub_profiles = m_reader.getBits(8);\n        for (int i = 0; i < ptl_num_sub_profiles; i++) m_reader.skipBits(32);  // general_sub_profile_idc[i]\n    }\n}", "target": 1, "idx": 9870}
{"commit_id": "9cb636b5f6a8cc6d1b50809ec8f8d33ae0c84c95", "project": "torvalds/linux", "func": "static int efi_capsule_release(struct inode *inode, struct file *file)\n{\n\tstruct capsule_info *cap_info = file->private_data;\n\n\tif (cap_info->index > 0 &&\n\t    (cap_info->header.headersize == 0 ||\n\t     cap_info->count < cap_info->total_size)) {\n\t\tpr_err(\"capsule upload not complete\\n\");\n\t\tefi_free_all_buff_pages(cap_info);\n\t}\n\n\tkfree(cap_info->pages);\n\tkfree(cap_info->phys);\n\tkfree(file->private_data);\n\tfile->private_data = NULL;\n\treturn 0;\n}", "target": 1, "idx": 9871}
{"commit_id": "a2cdd07488e666aa93a49a3fc9c9b1299e27ef3c", "project": "torvalds/linux", "func": "static int rtl8xxxu_submit_int_urb(struct ieee80211_hw *hw)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tstruct urb *urb;\n\tu32 val32;\n\tint ret;\n\n\turb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\n\tusb_fill_int_urb(urb, priv->udev, priv->pipe_interrupt,\n\t\t\t priv->int_buf, USB_INTR_CONTENT_LENGTH,\n\t\t\t rtl8xxxu_int_complete, priv, 1);\n\tusb_anchor_urb(urb, &priv->int_anchor);\n\tret = usb_submit_urb(urb, GFP_KERNEL);\n\tif (ret) {\n\t\tusb_unanchor_urb(urb);\n\t\tusb_free_urb(urb);\n\t\tgoto error;\n\t}\n\n\tval32 = rtl8xxxu_read32(priv, REG_USB_HIMR);\n\tval32 |= USB_HIMR_CPWM;\n\trtl8xxxu_write32(priv, REG_USB_HIMR, val32);\n\nerror:\n\treturn ret;\n}", "target": 1, "idx": 9872}
{"commit_id": "2ab5aa7bf515135c2b02d42e9a72e4c98e17031a", "project": "libvips", "func": "int\nim_vips2dz( IMAGE *in, const char *filename )\n{\n\tchar *p, *q;\n\tchar name[FILENAME_MAX];\n\tchar mode[FILENAME_MAX];\n\tchar buf[FILENAME_MAX];\n\n\tint i;\n\tVipsForeignDzLayout layout = VIPS_FOREIGN_DZ_LAYOUT_DZ; \n\tchar *suffix = \".jpeg\";\n\tint overlap = 0;\n\tint tile_size = 256;\n\tVipsForeignDzDepth depth = VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL; \n\tgboolean centre = FALSE;\n\tVipsAngle angle = VIPS_ANGLE_D0; \n\n\t/* We can't use im_filename_split() --- it assumes that we have a\n\t * filename with an extension before the ':', and filename here is\n\t * actually a dirname.\n\t *\n\t * Just split on the first ':'.\n\t */\n\tim_strncpy( name, filename, FILENAME_MAX ); \n\tif( (p = strchr( name, ':' )) ) {\n\t\t*p = '\\0';\n\t\tim_strncpy( mode, p + 1, FILENAME_MAX ); \n\t}\n\telse \n\t\tstrcpy( mode, \"\" ); \n\n\tstrcpy( buf, mode ); \n\tp = &buf[0];\n\n\tif( (q = im_getnextoption( &p )) ) {\n\t\tif( (i = vips_enum_from_nick( \"im_vips2dz\", \n\t\t\tVIPS_TYPE_FOREIGN_DZ_LAYOUT, q )) < 0 ) \n\t\t\treturn( -1 );\n\t\tlayout = i;\n\t}\n\n\tif( (q = im_getnextoption( &p )) ) \n\t\tsuffix = g_strdup( q );\n\tif( (q = im_getnextoption( &p )) ) \n\t\toverlap = atoi( q ); \n\tif( (q = im_getnextoption( &p )) ) \n\t\ttile_size = atoi( q ); \n\n\tif( (q = im_getnextoption( &p )) ) {\n\t\tif( (i = vips_enum_from_nick( \"im_vips2dz\", \n\t\t\tVIPS_TYPE_FOREIGN_DZ_DEPTH, q )) < 0 )\n\t\t\treturn( -1 );\n\t\tdepth = i;\n\t}\n\n\tif( (q = im_getnextoption( &p )) ) {\n\t\tif( im_isprefix( \"cen\", q ) ) \n\t\t\tcentre = TRUE;\n\t}\n\n\tif( (q = im_getnextoption( &p )) ) {\n\t\tif( (i = vips_enum_from_nick( \"im_vips2dz\", \n\t\t\tVIPS_TYPE_ANGLE, q )) < 0 )\n\t\t\treturn( -1 );\n\t\tangle = i;\n\t}\n\n\tif( vips_dzsave( in, name,\n\t\t\"layout\", layout,\n\t\t\"suffix\", suffix,\n\t\t\"overlap\", overlap,\n\t\t\"tile_size\", tile_size,\n\t\t\"depth\", depth,\n\t\t\"centre\", centre,\n\t\t\"angle\", angle,\n\t\tNULL ) )\n\t\treturn( -1 );\n\n\treturn( 0 );\n}", "target": 1, "idx": 9873}
{"commit_id": "2f074f4685897ab7212e25931eeeb0212292829f", "project": "vim", "func": "int\ncurrent_quote(\n    oparg_T\t*oap,\n    long\tcount,\n    int\t\tinclude,\t// TRUE == include quote char\n    int\t\tquotechar)\t// Quote character\n{\n    char_u\t*line = ml_get_curline();\n    int\t\tcol_end;\n    int\t\tcol_start = curwin->w_cursor.col;\n    int\t\tinclusive = FALSE;\n    int\t\tvis_empty = TRUE;\t// Visual selection <= 1 char\n    int\t\tvis_bef_curs = FALSE;\t// Visual starts before cursor\n    int\t\tdid_exclusive_adj = FALSE;  // adjusted pos for 'selection'\n    int\t\tinside_quotes = FALSE;\t// Looks like \"i'\" done before\n    int\t\tselected_quote = FALSE;\t// Has quote inside selection\n    int\t\ti;\n    int\t\trestore_vis_bef = FALSE; // restore VIsual on abort\n\n    // When 'selection' is \"exclusive\" move the cursor to where it would be\n    // with 'selection' \"inclusive\", so that the logic is the same for both.\n    // The cursor then is moved forward after adjusting the area.\n    if (VIsual_active)\n    {\n\t// this only works within one line\n\tif (VIsual.lnum != curwin->w_cursor.lnum)\n\t    return FALSE;\n\n\tvis_bef_curs = LT_POS(VIsual, curwin->w_cursor);\n\tvis_empty = EQUAL_POS(VIsual, curwin->w_cursor);\n\tif (*p_sel == 'e')\n\t{\n\t    if (vis_bef_curs)\n\t    {\n\t\tdec_cursor();\n\t\tdid_exclusive_adj = TRUE;\n\t    }\n\t    else if (!vis_empty)\n\t    {\n\t\tdec(&VIsual);\n\t\tdid_exclusive_adj = TRUE;\n\t    }\n\t    vis_empty = EQUAL_POS(VIsual, curwin->w_cursor);\n\t    if (!vis_bef_curs && !vis_empty)\n\t    {\n\t\t// VIsual needs to be the start of Visual selection.\n\t\tpos_T t = curwin->w_cursor;\n\n\t\tcurwin->w_cursor = VIsual;\n\t\tVIsual = t;\n\t\tvis_bef_curs = TRUE;\n\t\trestore_vis_bef = TRUE;\n\t    }\n\t}\n    }\n\n    if (!vis_empty)\n    {\n\t// Check if the existing selection exactly spans the text inside\n\t// quotes.\n\tif (vis_bef_curs)\n\t{\n\t    inside_quotes = VIsual.col > 0\n\t\t\t&& line[VIsual.col - 1] == quotechar\n\t\t\t&& line[curwin->w_cursor.col] != NUL\n\t\t\t&& line[curwin->w_cursor.col + 1] == quotechar;\n\t    i = VIsual.col;\n\t    col_end = curwin->w_cursor.col;\n\t}\n\telse\n\t{\n\t    inside_quotes = curwin->w_cursor.col > 0\n\t\t\t&& line[curwin->w_cursor.col - 1] == quotechar\n\t\t\t&& line[VIsual.col] != NUL\n\t\t\t&& line[VIsual.col + 1] == quotechar;\n\t    i = curwin->w_cursor.col;\n\t    col_end = VIsual.col;\n\t}\n\n\t// Find out if we have a quote in the selection.\n\twhile (i <= col_end)\n\t{\n\t    // check for going over the end of the line, which can happen if\n\t    // the line was changed after the Visual area was selected.\n\t    if (line[i] == NUL)\n\t\tbreak;\n\t    if (line[i++] == quotechar)\n\t    {\n\t\tselected_quote = TRUE;\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    if (!vis_empty && line[col_start] == quotechar)\n    {\n\t// Already selecting something and on a quote character.  Find the\n\t// next quoted string.\n\tif (vis_bef_curs)\n\t{\n\t    // Assume we are on a closing quote: move to after the next\n\t    // opening quote.\n\t    col_start = find_next_quote(line, col_start + 1, quotechar, NULL);\n\t    if (col_start < 0)\n\t\tgoto abort_search;\n\t    col_end = find_next_quote(line, col_start + 1, quotechar,\n\t\t\t\t\t\t\t      curbuf->b_p_qe);\n\t    if (col_end < 0)\n\t    {\n\t\t// We were on a starting quote perhaps?\n\t\tcol_end = col_start;\n\t\tcol_start = curwin->w_cursor.col;\n\t    }\n\t}\n\telse\n\t{\n\t    col_end = find_prev_quote(line, col_start, quotechar, NULL);\n\t    if (line[col_end] != quotechar)\n\t\tgoto abort_search;\n\t    col_start = find_prev_quote(line, col_end, quotechar,\n\t\t\t\t\t\t\t      curbuf->b_p_qe);\n\t    if (line[col_start] != quotechar)\n\t    {\n\t\t// We were on an ending quote perhaps?\n\t\tcol_start = col_end;\n\t\tcol_end = curwin->w_cursor.col;\n\t    }\n\t}\n    }\n    else\n\n    if (line[col_start] == quotechar || !vis_empty)\n    {\n\tint\tfirst_col = col_start;\n\n\tif (!vis_empty)\n\t{\n\t    if (vis_bef_curs)\n\t\tfirst_col = find_next_quote(line, col_start, quotechar, NULL);\n\t    else\n\t\tfirst_col = find_prev_quote(line, col_start, quotechar, NULL);\n\t}\n\n\t// The cursor is on a quote, we don't know if it's the opening or\n\t// closing quote.  Search from the start of the line to find out.\n\t// Also do this when there is a Visual area, a' may leave the cursor\n\t// in between two strings.\n\tcol_start = 0;\n\tfor (;;)\n\t{\n\t    // Find open quote character.\n\t    col_start = find_next_quote(line, col_start, quotechar, NULL);\n\t    if (col_start < 0 || col_start > first_col)\n\t\tgoto abort_search;\n\t    // Find close quote character.\n\t    col_end = find_next_quote(line, col_start + 1, quotechar,\n\t\t\t\t\t\t\t      curbuf->b_p_qe);\n\t    if (col_end < 0)\n\t\tgoto abort_search;\n\t    // If is cursor between start and end quote character, it is\n\t    // target text object.\n\t    if (col_start <= first_col && first_col <= col_end)\n\t\tbreak;\n\t    col_start = col_end + 1;\n\t}\n    }\n    else\n    {\n\t// Search backward for a starting quote.\n\tcol_start = find_prev_quote(line, col_start, quotechar, curbuf->b_p_qe);\n\tif (line[col_start] != quotechar)\n\t{\n\t    // No quote before the cursor, look after the cursor.\n\t    col_start = find_next_quote(line, col_start, quotechar, NULL);\n\t    if (col_start < 0)\n\t\tgoto abort_search;\n\t}\n\n\t// Find close quote character.\n\tcol_end = find_next_quote(line, col_start + 1, quotechar,\n\t\t\t\t\t\t\t      curbuf->b_p_qe);\n\tif (col_end < 0)\n\t    goto abort_search;\n    }\n\n    // When \"include\" is TRUE, include spaces after closing quote or before\n    // the starting quote.\n    if (include)\n    {\n\tif (VIM_ISWHITE(line[col_end + 1]))\n\t    while (VIM_ISWHITE(line[col_end + 1]))\n\t\t++col_end;\n\telse\n\t    while (col_start > 0 && VIM_ISWHITE(line[col_start - 1]))\n\t\t--col_start;\n    }\n\n    // Set start position.  After vi\" another i\" must include the \".\n    // For v2i\" include the quotes.\n    if (!include && count < 2 && (vis_empty || !inside_quotes))\n\t++col_start;\n    curwin->w_cursor.col = col_start;\n    if (VIsual_active)\n    {\n\t// Set the start of the Visual area when the Visual area was empty, we\n\t// were just inside quotes or the Visual area didn't start at a quote\n\t// and didn't include a quote.\n\tif (vis_empty\n\t\t|| (vis_bef_curs\n\t\t    && !selected_quote\n\t\t    && (inside_quotes\n\t\t\t|| (line[VIsual.col] != quotechar\n\t\t\t    && (VIsual.col == 0\n\t\t\t\t|| line[VIsual.col - 1] != quotechar)))))\n\t{\n\t    VIsual = curwin->w_cursor;\n\t    redraw_curbuf_later(INVERTED);\n\t}\n    }\n    else\n    {\n\toap->start = curwin->w_cursor;\n\toap->motion_type = MCHAR;\n    }\n\n    // Set end position.\n    curwin->w_cursor.col = col_end;\n    if ((include || count > 1 // After vi\" another i\" must include the \".\n\t\t|| (!vis_empty && inside_quotes)\n\t) && inc_cursor() == 2)\n\tinclusive = TRUE;\n    if (VIsual_active)\n    {\n\tif (vis_empty || vis_bef_curs)\n\t{\n\t    // decrement cursor when 'selection' is not exclusive\n\t    if (*p_sel != 'e')\n\t\tdec_cursor();\n\t}\n\telse\n\t{\n\t    // Cursor is at start of Visual area.  Set the end of the Visual\n\t    // area when it was just inside quotes or it didn't end at a\n\t    // quote.\n\t    if (inside_quotes\n\t\t    || (!selected_quote\n\t\t\t&& line[VIsual.col] != quotechar\n\t\t\t&& (line[VIsual.col] == NUL\n\t\t\t    || line[VIsual.col + 1] != quotechar)))\n\t    {\n\t\tdec_cursor();\n\t\tVIsual = curwin->w_cursor;\n\t    }\n\t    curwin->w_cursor.col = col_start;\n\t}\n\tif (VIsual_mode == 'V')\n\t{\n\t    VIsual_mode = 'v';\n\t    redraw_cmdline = TRUE;\t\t// show mode later\n\t}\n    }\n    else\n    {\n\t// Set inclusive and other oap's flags.\n\toap->inclusive = inclusive;\n    }\n\n    return OK;\n\nabort_search:\n    if (VIsual_active && *p_sel == 'e')\n    {\n\tif (did_exclusive_adj)\n\t    inc_cursor();\n\tif (restore_vis_bef)\n\t{\n\t    pos_T t = curwin->w_cursor;\n\n\t    curwin->w_cursor = VIsual;\n\t    VIsual = t;\n\t}\n    }\n    return FALSE;\n}", "target": 2, "idx": 9874}
{"commit_id": "c84e4b2dd4050ef3eecc13fcfa6842373ba4519c", "project": "xen-project/xen", "func": "void gic_raise_inflight_irq(struct vcpu *v, unsigned int virtual_irq)\n{\n    struct pending_irq *n = irq_to_pending(v, virtual_irq);\n\n    /* If an LPI has been removed meanwhile, there is nothing left to raise. */\n    if ( unlikely(!n) )\n        return;\n\n    ASSERT(spin_is_locked(&v->arch.vgic.lock));\n\n    /* Don't try to update the LR if the interrupt is disabled */\n    if ( !test_bit(GIC_IRQ_GUEST_ENABLED, &n->status) )\n        return;\n\n    if ( list_empty(&n->lr_queue) )\n    {\n        if ( v == current )\n            gic_update_one_lr(v, n->lr);\n    }\n#ifdef GIC_DEBUG\n    else\n        gdprintk(XENLOG_DEBUG, \"trying to inject irq=%u into d%dv%d, when it is still lr_pending\\n\",\n                 virtual_irq, v->domain->domain_id, v->vcpu_id);\n#endif\n}", "target": 1, "idx": 9875}
{"commit_id": "4794b5dd34688158fb51a2943032569d3780c4b8", "project": "xorg/lib/libXcursor", "func": "XcursorComment *\nXcursorCommentCreate (XcursorUInt comment_type, int length)\n{\n    XcursorComment  *comment;\n\n    if (length < 0 || length > XCURSOR_COMMENT_MAX_LEN)\n\treturn NULL;\n\n    comment = malloc (sizeof (XcursorComment) + length + 1);\n    if (!comment)\n\treturn NULL;\n    comment->version = XCURSOR_COMMENT_VERSION;\n    comment->comment_type = comment_type;\n    comment->comment = (char *) (comment + 1);\n    comment->comment[0] = '\\0';\n    return comment;\n}", "target": 2, "idx": 9876}
{"commit_id": "b497b5942a8beb8f89ca1c359c54ad67ec843055", "project": "bluez", "func": "static int update_discovery_filter(struct btd_adapter *adapter)\n{\n\tstruct mgmt_cp_start_service_discovery *sd_cp;\n\n\tDBG(\"\");\n\n\tif (discovery_filter_to_mgmt_cp(adapter, &sd_cp)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"discovery_filter_to_mgmt_cp returned error\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Only attempt to overwrite current discoverable setting when not\n\t * discoverable.\n\t */\n\tif (!(adapter->current_settings & MGMT_OP_SET_DISCOVERABLE)) {\n\t\tGSList *l;\n\n\t\tfor (l = adapter->discovery_list; l; l = g_slist_next(l)) {\n\t\t\tstruct discovery_client *client = l->data;\n\n\t\t\tif (!client->discovery_filter)\n\t\t\t\tcontinue;\n\n\t\t\tif (client->discovery_filter->discoverable) {\n\t\t\t\tset_discovery_discoverable(adapter, true);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * If filters are equal, then don't update scan, except for when\n\t * starting discovery.\n\t */\n\tif (filters_equal(adapter->current_discovery_filter, sd_cp) &&\n\t    adapter->discovering != 0) {\n\t\tDBG(\"filters were equal, deciding to not restart the scan.\");\n\t\tg_free(sd_cp);\n\t\treturn 0;\n\t}\n\n\tg_free(adapter->current_discovery_filter);\n\tadapter->current_discovery_filter = sd_cp;\n\n\ttrigger_start_discovery(adapter, 0);\n\n\treturn -EINPROGRESS;\n}", "target": 1, "idx": 9877}
{"commit_id": "987a3b5cf7175916e2a4b6ea5b8e70f830dfe732", "project": "acpica", "func": "ACPI_STATUS\nAcpiDsCreateOperands (\n    ACPI_WALK_STATE         *WalkState,\n    ACPI_PARSE_OBJECT       *FirstArg)\n{\n    ACPI_STATUS             Status = AE_OK;\n    ACPI_PARSE_OBJECT       *Arg;\n    ACPI_PARSE_OBJECT       *Arguments[ACPI_OBJ_NUM_OPERANDS];\n    UINT32                  ArgCount = 0;\n    UINT32                  Index = WalkState->NumOperands;\n    UINT32                  PrevNumOperands = WalkState->NumOperands;\n    UINT32                  NewNumOperands;\n    UINT32                  i;\n\n\n    ACPI_FUNCTION_TRACE_PTR (DsCreateOperands, FirstArg);\n\n\n    /* Get all arguments in the list */\n\n    Arg = FirstArg;\n    while (Arg)\n    {\n        if (Index >= ACPI_OBJ_NUM_OPERANDS)\n        {\n            return_ACPI_STATUS (AE_BAD_DATA);\n        }\n\n        Arguments[Index] = Arg;\n        WalkState->Operands [Index] = NULL;\n\n        /* Move on to next argument, if any */\n\n        Arg = Arg->Common.Next;\n        ArgCount++;\n        Index++;\n    }\n\n    ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,\n        \"NumOperands %d, ArgCount %d, Index %d\\n\",\n        WalkState->NumOperands, ArgCount, Index));\n\n    /* Create the interpreter arguments, in reverse order */\n\n    NewNumOperands = Index;\n    Index--;\n    for (i = 0; i < ArgCount; i++)\n    {\n        Arg = Arguments[Index];\n        WalkState->OperandIndex = (UINT8) Index;\n\n        Status = AcpiDsCreateOperand (WalkState, Arg, Index);\n        if (ACPI_FAILURE (Status))\n        {\n            goto Cleanup;\n        }\n\n        ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,\n            \"Created Arg #%u (%p) %u args total\\n\",\n            Index, Arg, ArgCount));\n        Index--;\n    }\n\n    return_ACPI_STATUS (Status);\n\n\nCleanup:\n    /*\n     * We must undo everything done above; meaning that we must\n     * pop everything off of the operand stack and delete those\n     * objects\n     */\n    WalkState->NumOperands = i;\n    AcpiDsObjStackPopAndDelete (NewNumOperands, WalkState);\n\n    /* Restore operand count */\n    WalkState->NumOperands = PrevNumOperands;\n\n    ACPI_EXCEPTION ((AE_INFO, Status, \"While creating Arg %u\", Index));\n    return_ACPI_STATUS (Status);\n}", "target": 1, "idx": 9878}
{"commit_id": "5d069dbe8aaf2a197142558b6fb2978189ba3454", "project": "torvalds/linux", "func": "static int fuse_direntplus_link(struct file *file,\n\t\t\t\tstruct fuse_direntplus *direntplus,\n\t\t\t\tu64 attr_version)\n{\n\tstruct fuse_entry_out *o = &direntplus->entry_out;\n\tstruct fuse_dirent *dirent = &direntplus->dirent;\n\tstruct dentry *parent = file->f_path.dentry;\n\tstruct qstr name = QSTR_INIT(dirent->name, dirent->namelen);\n\tstruct dentry *dentry;\n\tstruct dentry *alias;\n\tstruct inode *dir = d_inode(parent);\n\tstruct fuse_conn *fc;\n\tstruct inode *inode;\n\tDECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq);\n\n\tif (!o->nodeid) {\n\t\t/*\n\t\t * Unlike in the case of fuse_lookup, zero nodeid does not mean\n\t\t * ENOENT. Instead, it only means the userspace filesystem did\n\t\t * not want to return attributes/handle for this entry.\n\t\t *\n\t\t * So do nothing.\n\t\t */\n\t\treturn 0;\n\t}\n\n\tif (name.name[0] == '.') {\n\t\t/*\n\t\t * We could potentially refresh the attributes of the directory\n\t\t * and its parent?\n\t\t */\n\t\tif (name.len == 1)\n\t\t\treturn 0;\n\t\tif (name.name[1] == '.' && name.len == 2)\n\t\t\treturn 0;\n\t}\n\n\tif (invalid_nodeid(o->nodeid))\n\t\treturn -EIO;\n\tif (fuse_invalid_attr(&o->attr))\n\t\treturn -EIO;\n\n\tfc = get_fuse_conn(dir);\n\n\tname.hash = full_name_hash(parent, name.name, name.len);\n\tdentry = d_lookup(parent, &name);\n\tif (!dentry) {\nretry:\n\t\tdentry = d_alloc_parallel(parent, &name, &wq);\n\t\tif (IS_ERR(dentry))\n\t\t\treturn PTR_ERR(dentry);\n\t}\n\tif (!d_in_lookup(dentry)) {\n\t\tstruct fuse_inode *fi;\n\t\tinode = d_inode(dentry);\n\t\tif (!inode ||\n\t\t    get_node_id(inode) != o->nodeid ||\n\t\t    ((o->attr.mode ^ inode->i_mode) & S_IFMT)) {\n\t\t\td_invalidate(dentry);\n\t\t\tdput(dentry);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (fuse_is_bad(inode)) {\n\t\t\tdput(dentry);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tfi = get_fuse_inode(inode);\n\t\tspin_lock(&fi->lock);\n\t\tfi->nlookup++;\n\t\tspin_unlock(&fi->lock);\n\n\t\tforget_all_cached_acls(inode);\n\t\tfuse_change_attributes(inode, &o->attr,\n\t\t\t\t       entry_attr_timeout(o),\n\t\t\t\t       attr_version);\n\t\t/*\n\t\t * The other branch comes via fuse_iget()\n\t\t * which bumps nlookup inside\n\t\t */\n\t} else {\n\t\tinode = fuse_iget(dir->i_sb, o->nodeid, o->generation,\n\t\t\t\t  &o->attr, entry_attr_timeout(o),\n\t\t\t\t  attr_version);\n\t\tif (!inode)\n\t\t\tinode = ERR_PTR(-ENOMEM);\n\n\t\talias = d_splice_alias(inode, dentry);\n\t\td_lookup_done(dentry);\n\t\tif (alias) {\n\t\t\tdput(dentry);\n\t\t\tdentry = alias;\n\t\t}\n\t\tif (IS_ERR(dentry))\n\t\t\treturn PTR_ERR(dentry);\n\t}\n\tif (fc->readdirplus_auto)\n\t\tset_bit(FUSE_I_INIT_RDPLUS, &get_fuse_inode(inode)->state);\n\tfuse_change_entry_timeout(dentry, o);\n\n\tdput(dentry);\n\treturn 0;\n}", "target": 1, "idx": 9879}
{"commit_id": "040757f738e13caaa9c5078bca79aa97e11dde88", "project": "torvalds/linux", "func": "static void put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ucounts_lock, flags);\n\tucounts->count -= 1;\n\tif (!ucounts->count)\n\t\thlist_del_init(&ucounts->node);\n\telse\n\t\tucounts = NULL;\n\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\n\tkfree(ucounts);\n}", "target": 2, "idx": 9880}
{"commit_id": "bea2a9e3e00b275dc40cfa09c760c715b8753e03", "project": "qemu", "func": "static void dwc2_handle_packet(DWC2State *s, uint32_t devadr, USBDevice *dev,\n                               USBEndpoint *ep, uint32_t index, bool send)\n{\n    DWC2Packet *p;\n    uint32_t hcchar = s->hreg1[index];\n    uint32_t hctsiz = s->hreg1[index + 4];\n    uint32_t hcdma = s->hreg1[index + 5];\n    uint32_t chan, epnum, epdir, eptype, mps, pid, pcnt, len, tlen, intr = 0;\n    uint32_t tpcnt, stsidx, actual = 0;\n    bool do_intr = false, done = false;\n\n    epnum = get_field(hcchar, HCCHAR_EPNUM);\n    epdir = get_bit(hcchar, HCCHAR_EPDIR);\n    eptype = get_field(hcchar, HCCHAR_EPTYPE);\n    mps = get_field(hcchar, HCCHAR_MPS);\n    pid = get_field(hctsiz, TSIZ_SC_MC_PID);\n    pcnt = get_field(hctsiz, TSIZ_PKTCNT);\n    len = get_field(hctsiz, TSIZ_XFERSIZE);\n    if (len > DWC2_MAX_XFER_SIZE) {\n        qemu_log_mask(LOG_GUEST_ERROR,\n                      \"%s: HCTSIZ transfer size too large\\n\", __func__);\n        return;\n    }\n\n    chan = index >> 3;\n    p = &s->packet[chan];\n\n    trace_usb_dwc2_handle_packet(chan, dev, &p->packet, epnum, types[eptype],\n                                 dirs[epdir], mps, len, pcnt);\n\n    if (mps == 0) {\n        qemu_log_mask(LOG_GUEST_ERROR,\n                \"%s: Bad HCCHAR_MPS set to zero\\n\", __func__);\n        return;\n    }\n\n    if (eptype == USB_ENDPOINT_XFER_CONTROL && pid == TSIZ_SC_MC_PID_SETUP) {\n        pid = USB_TOKEN_SETUP;\n    } else {\n        pid = epdir ? USB_TOKEN_IN : USB_TOKEN_OUT;\n    }\n\n    if (send) {\n        tlen = len;\n        if (p->small) {\n            if (tlen > mps) {\n                tlen = mps;\n            }\n        }\n\n        if (pid != USB_TOKEN_IN) {\n            trace_usb_dwc2_memory_read(hcdma, tlen);\n            if (dma_memory_read(&s->dma_as, hcdma,\n                                s->usb_buf[chan], tlen) != MEMTX_OK) {\n                qemu_log_mask(LOG_GUEST_ERROR, \"%s: dma_memory_read failed\\n\",\n                              __func__);\n            }\n        }\n\n        usb_packet_init(&p->packet);\n        usb_packet_setup(&p->packet, pid, ep, 0, hcdma,\n                         pid != USB_TOKEN_IN, true);\n        usb_packet_addbuf(&p->packet, s->usb_buf[chan], tlen);\n        p->async = DWC2_ASYNC_NONE;\n        usb_handle_packet(dev, &p->packet);\n    } else {\n        tlen = p->len;\n    }\n\n    stsidx = -p->packet.status;\n    assert(stsidx < sizeof(pstatus) / sizeof(*pstatus));\n    actual = p->packet.actual_length;\n    trace_usb_dwc2_packet_status(pstatus[stsidx], actual);\n\nbabble:\n    if (p->packet.status != USB_RET_SUCCESS &&\n            p->packet.status != USB_RET_NAK &&\n            p->packet.status != USB_RET_STALL &&\n            p->packet.status != USB_RET_ASYNC) {\n        trace_usb_dwc2_packet_error(pstatus[stsidx]);\n    }\n\n    if (p->packet.status == USB_RET_ASYNC) {\n        trace_usb_dwc2_async_packet(&p->packet, chan, dev, epnum,\n                                    dirs[epdir], tlen);\n        usb_device_flush_ep_queue(dev, ep);\n        assert(p->async != DWC2_ASYNC_INFLIGHT);\n        p->devadr = devadr;\n        p->epnum = epnum;\n        p->epdir = epdir;\n        p->mps = mps;\n        p->pid = pid;\n        p->index = index;\n        p->pcnt = pcnt;\n        p->len = tlen;\n        p->async = DWC2_ASYNC_INFLIGHT;\n        p->needs_service = false;\n        return;\n    }\n\n    if (p->packet.status == USB_RET_SUCCESS) {\n        if (actual > tlen) {\n            p->packet.status = USB_RET_BABBLE;\n            goto babble;\n        }\n\n        if (pid == USB_TOKEN_IN) {\n            trace_usb_dwc2_memory_write(hcdma, actual);\n            if (dma_memory_write(&s->dma_as, hcdma, s->usb_buf[chan],\n                                 actual) != MEMTX_OK) {\n                qemu_log_mask(LOG_GUEST_ERROR, \"%s: dma_memory_write failed\\n\",\n                              __func__);\n            }\n        }\n\n        tpcnt = actual / mps;\n        if (actual % mps) {\n            tpcnt++;\n            if (pid == USB_TOKEN_IN) {\n                done = true;\n            }\n        }\n\n        pcnt -= tpcnt < pcnt ? tpcnt : pcnt;\n        set_field(&hctsiz, pcnt, TSIZ_PKTCNT);\n        len -= actual < len ? actual : len;\n        set_field(&hctsiz, len, TSIZ_XFERSIZE);\n        s->hreg1[index + 4] = hctsiz;\n        hcdma += actual;\n        s->hreg1[index + 5] = hcdma;\n\n        if (!pcnt || len == 0 || actual == 0) {\n            done = true;\n        }\n    } else {\n        intr |= pintr[stsidx];\n        if (p->packet.status == USB_RET_NAK &&\n            (eptype == USB_ENDPOINT_XFER_CONTROL ||\n             eptype == USB_ENDPOINT_XFER_BULK)) {\n            /*\n             * for ctrl/bulk, automatically retry on NAK,\n             * but send the interrupt anyway\n             */\n            intr &= ~HCINTMSK_RESERVED14_31;\n            s->hreg1[index + 2] |= intr;\n            do_intr = true;\n        } else {\n            intr |= HCINTMSK_CHHLTD;\n            done = true;\n        }\n    }\n\n    usb_packet_cleanup(&p->packet);\n\n    if (done) {\n        hcchar &= ~HCCHAR_CHENA;\n        s->hreg1[index] = hcchar;\n        if (!(intr & HCINTMSK_CHHLTD)) {\n            intr |= HCINTMSK_CHHLTD | HCINTMSK_XFERCOMPL;\n        }\n        intr &= ~HCINTMSK_RESERVED14_31;\n        s->hreg1[index + 2] |= intr;\n        p->needs_service = false;\n        trace_usb_dwc2_packet_done(pstatus[stsidx], actual, len, pcnt);\n        dwc2_update_hc_irq(s, index);\n        return;\n    }\n\n    p->devadr = devadr;\n    p->epnum = epnum;\n    p->epdir = epdir;\n    p->mps = mps;\n    p->pid = pid;\n    p->index = index;\n    p->pcnt = pcnt;\n    p->len = len;\n    p->needs_service = true;\n    trace_usb_dwc2_packet_next(pstatus[stsidx], len, pcnt);\n    if (do_intr) {\n        dwc2_update_hc_irq(s, index);\n    }\n}", "target": 1, "idx": 9881}
{"commit_id": "4382b5dfd02a42ba5d1a25038c78079c24a05638", "project": "eProsima/Fast-DDS", "func": "bool MessageReceiver::proc_Submsg_Heartbeat(\n        CDRMessage_t* msg,\n        SubmessageHeader_t* smh) const\n{\n    eprosima::shared_lock<eprosima::shared_mutex> guard(mtx_);\n\n    bool endiannessFlag = (smh->flags & BIT(0)) != 0;\n    bool finalFlag = (smh->flags & BIT(1)) != 0;\n    bool livelinessFlag = (smh->flags & BIT(2)) != 0;\n    //Assign message endianness\n    if (endiannessFlag)\n    {\n        msg->msg_endian = LITTLEEND;\n    }\n    else\n    {\n        msg->msg_endian = BIGEND;\n    }\n\n    GUID_t readerGUID;\n    GUID_t writerGUID;\n    readerGUID.guidPrefix = dest_guid_prefix_;\n    CDRMessage::readEntityId(msg, &readerGUID.entityId);\n    writerGUID.guidPrefix = source_guid_prefix_;\n    CDRMessage::readEntityId(msg, &writerGUID.entityId);\n    SequenceNumber_t firstSN;\n    SequenceNumber_t lastSN;\n    CDRMessage::readSequenceNumber(msg, &firstSN);\n    CDRMessage::readSequenceNumber(msg, &lastSN);\n\n    SequenceNumber_t zeroSN;\n    if (firstSN <= zeroSN)\n    {\n        EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Invalid Heartbeat received (\" << firstSN << \" <= 0), ignoring\");\n        return false;\n    }\n    if (lastSN < firstSN && lastSN != firstSN - 1)\n    {\n        EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Invalid Heartbeat received (\" << firstSN << \") - (\" <<\n                lastSN << \"), ignoring\");\n        return false;\n    }\n    uint32_t HBCount;\n    if (!CDRMessage::readUInt32(msg, &HBCount))\n    {\n        EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Unable to read heartbeat count from heartbeat message\");\n        return false;\n    }\n\n    //Look for the correct reader and writers:\n    findAllReaders(readerGUID.entityId,\n            [&writerGUID, &HBCount, &firstSN, &lastSN, finalFlag, livelinessFlag](RTPSReader* reader)\n            {\n                reader->processHeartbeatMsg(writerGUID, HBCount, firstSN, lastSN, finalFlag, livelinessFlag);\n            });\n\n    return true;\n}", "target": 2, "idx": 9882}
{"commit_id": "b17d5e860f30e8be2caeb0022b63be4c76660178", "project": "ONLYOFFICE/core", "func": "int          Read(void* pDestBuffer, unsigned int nSize)\n        {\n            if (m_nPos >= m_nLen)\n                nSize = 0;\n            else if (nSize > (m_nLen - m_nPos))\n                nSize = m_nLen - m_nPos;\n\n            memcpy( pDestBuffer, (m_sFile + m_nPos), nSize );\n            m_nPos += nSize;\n\n            return nSize;\n        }", "target": 3, "idx": 9883}
{"commit_id": "dd528b3aabd13863f855a68e76966e4e019fc399", "project": "babelouest/rhonabwy", "func": "int\nrsa_oaep_sha1_decrypt(const struct rsa_private_key *key,\n\t    size_t label_length, const uint8_t *label,\n\t    size_t *length, uint8_t *message,\n\t    const mpz_t gibberish)\n{\n  mpz_t m;\n  int res;\n  struct sha1_ctx ctx;\n\n  if (nettle_mpz_sizeinbase_256_u (gibberish) > key->size ||\n      key->size < (2*SHA1_DIGEST_SIZE)+2) {\n    return 0;\n  }\n\n  mpz_init(m);\n  rsa_compute_root(key, m, gibberish);\n\n  res = pkcs1_oaep_decrypt (key->size, m, SHA1_DIGEST_SIZE,\n                            &ctx, &nettle_sha1, (nettle_hash_init_func*)&sha1_init, (nettle_hash_update_func*)&sha1_update, (nettle_hash_digest_func*)&sha1_digest,\n                            label_length, label, length, message);\n  mpz_clear(m);\n  return res;\n}", "target": 2, "idx": 9884}
{"commit_id": "21a6f570ba33fa9f52f1bba87f07acc4e8c178f4", "project": "radareorg/radare2", "func": "static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) {\n\tconst char *section_name = \"\";\n\tconst char *link_section_name = \"\";\n\tchar *end = NULL;\n\tElf_(Shdr) *link_shdr = NULL;\n\tut8 dfs[sizeof (Elf_(Verdef))] = {0};\n\tSdb *sdb;\n\tint cnt, i;\n\tif (shdr->sh_link > bin->ehdr.e_shnum) {\n\t\treturn false;\n\t}\n\tlink_shdr = &bin->shdr[shdr->sh_link];\n\tif (shdr->sh_size < 1) {\n\t\treturn false;\n\t}\n\tElf_(Verdef) *defs = calloc (shdr->sh_size, sizeof (char));\n\tif (!defs) {\n\t\treturn false;\n\t}\n\tif (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {\n\t\tsection_name = &bin->shstrtab[shdr->sh_name];\n\t}\n\tif (link_shdr && bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) {\n\t\tlink_section_name = &bin->shstrtab[link_shdr->sh_name];\n\t}\n\tif (!defs) {\n\t\tbprintf (\"Warning: Cannot allocate memory (Check Elf_(Verdef))\\n\");\n\t\treturn NULL;\n\t}\n\tsdb = sdb_new0 ();\n\tend = (char *)defs + shdr->sh_size;\n\tsdb_set (sdb, \"section_name\", section_name, 0);\n\tsdb_num_set (sdb, \"entries\", shdr->sh_info, 0);\n\tsdb_num_set (sdb, \"addr\", shdr->sh_addr, 0);\n\tsdb_num_set (sdb, \"offset\", shdr->sh_offset, 0);\n\tsdb_num_set (sdb, \"link\", shdr->sh_link, 0);\n\tsdb_set (sdb, \"link_section_name\", link_section_name, 0);\n\n\tfor (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && ((char *)defs + i < end); ++cnt) {\n\t\tSdb *sdb_verdef = sdb_new0 ();\n\t\tchar *vstart = ((char*)defs) + i;\n\t\tchar key[32] = {0};\n\t\tElf_(Verdef) *verdef = (Elf_(Verdef)*)vstart;\n\t\tElf_(Verdaux) aux = {0};\n\t\tint j = 0;\n\t\tint isum = 0;\n\n\t\tr_buf_read_at (bin->b, shdr->sh_offset + i, dfs, sizeof (Elf_(Verdef)));\n\t\tverdef->vd_version = READ16 (dfs, j)\n\t\tverdef->vd_flags = READ16 (dfs, j)\n\t\tverdef->vd_ndx = READ16 (dfs, j)\n\t\tverdef->vd_cnt = READ16 (dfs, j)\n\t\tverdef->vd_hash = READ32 (dfs, j)\n\t\tverdef->vd_aux = READ32 (dfs, j)\n\t\tverdef->vd_next = READ32 (dfs, j)\n\t\tvstart += verdef->vd_aux;\n\t\tif (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tj = 0;\n\t\taux.vda_name = READ32 (vstart, j)\n\t\taux.vda_next = READ32 (vstart, j)\n\n\t\tisum = i + verdef->vd_aux;\n\t\tif (aux.vda_name > bin->dynstr_size) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tsdb_num_set (sdb_verdef, \"idx\", i, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_version\", verdef->vd_version, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_ndx\", verdef->vd_ndx, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_cnt\", verdef->vd_cnt, 0);\n\t\tsdb_set (sdb_verdef, \"vda_name\", &bin->dynstr[aux.vda_name], 0);\n\t\tsdb_set (sdb_verdef, \"flags\", get_ver_flags (verdef->vd_flags), 0);\n\n\t\tfor (j = 1; j < verdef->vd_cnt; ++j) {\n\t\t\tint k;\n\t\t\tSdb *sdb_parent = sdb_new0 ();\n\t\t\tisum += aux.vda_next;\n\t\t\tvstart += aux.vda_next;\n\t\t\tif (vstart > end || vstart + sizeof(Elf_(Verdaux)) > end) {\n\t\t\t\tsdb_free (sdb_verdef);\n\t\t\t\tsdb_free (sdb_parent);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tk = 0;\n\t\t\taux.vda_name = READ32 (vstart, k)\n\t\t\taux.vda_next = READ32 (vstart, k)\n\t\t\tif (aux.vda_name > bin->dynstr_size) {\n\t\t\t\tsdb_free (sdb_verdef);\n\t\t\t\tsdb_free (sdb_parent);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tsdb_num_set (sdb_parent, \"idx\", isum, 0);\n\t\t\tsdb_num_set (sdb_parent, \"parent\", j, 0);\n\t\t\tsdb_set (sdb_parent, \"vda_name\", &bin->dynstr[aux.vda_name], 0);\n\t\t\tsnprintf (key, sizeof (key), \"parent%d\", j - 1);\n\t\t\tsdb_ns_set (sdb_verdef, key, sdb_parent);\n\t\t}\n\n\t\tsnprintf (key, sizeof (key), \"verdef%d\", cnt);\n\t\tsdb_ns_set (sdb, key, sdb_verdef);\n\t\tif (!verdef->vd_next) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\t\tif ((st32)verdef->vd_next < 1) {\n\t\t\teprintf (\"Warning: Invalid vd_next in the ELF version\\n\");\n\t\t\tbreak;\n\t\t}\n\t\ti += verdef->vd_next;\n\t}", "target": 2, "idx": 9885}
{"commit_id": "7873f8334c8d31031f8cfa83bd97ac6029309e4f", "project": "sudo-project/sudo", "func": "unsigned int\nsudoers_lookup(struct sudo_nss_list *snl, struct sudoers_context *ctx,\n    time_t now, sudoers_lookup_callback_fn_t callback, void *cb_data,\n    int *cmnd_status, int pwflag)\n{\n    struct defaults_list *defs = NULL;\n    struct sudoers_parse_tree *parse_tree = NULL;\n    struct cmndspec *cs = NULL;\n    struct sudo_nss *nss;\n    struct cmnd_info info;\n    unsigned int validated = FLAG_NO_USER | FLAG_NO_HOST;\n    int m, match = UNSPEC;\n    debug_decl(sudoers_lookup, SUDOERS_DEBUG_PARSER);\n\n    /*\n     * Special case checking the \"validate\", \"list\" and \"kill\" pseudo-commands.\n     */\n    if (pwflag) {\n\tdebug_return_uint(sudoers_lookup_pseudo(snl, ctx, now, callback,\n\t    cb_data, pwflag));\n    }\n\n    /* Need to be runas user while stat'ing things. */\n    if (!set_perms(ctx, PERM_RUNAS))\n\tdebug_return_uint(validated);\n\n    /* Query each sudoers source and check the user. */\n    TAILQ_FOREACH(nss, snl, entries) {\n\tif (nss->query(ctx, nss, ctx->user.pw) == -1) {\n\t    /* The query function should have printed an error message. */\n\t    SET(validated, VALIDATE_ERROR);\n\t    break;\n\t}\n\n\tm = sudoers_lookup_check(nss, ctx, &validated, &info, now, callback,\n\t    cb_data, &cs, &defs);\n\tif (SPECIFIED(m)) {\n\t    match = m;\n\t    parse_tree = nss->parse_tree;\n\t}\n\n\tif (!sudo_nss_can_continue(nss, m))\n\t    break;\n    }\n    if (SPECIFIED(match)) {\n\tif (info.cmnd_path != NULL) {\n\t    /* Update cmnd, cmnd_stat, cmnd_status from matching entry. */\n\t    free(ctx->user.cmnd);\n\t    ctx->user.cmnd = info.cmnd_path;\n\t    if (ctx->user.cmnd_stat != NULL)\n\t\t*ctx->user.cmnd_stat = info.cmnd_stat;\n\t    *cmnd_status = info.status;\n\t}\n\tif (defs != NULL)\n\t    (void)update_defaults(ctx, parse_tree, defs, SETDEF_GENERIC, false);\n\tif (!apply_cmndspec(ctx, cs))\n\t    SET(validated, VALIDATE_ERROR);\n\telse if (match == ALLOW)\n\t    SET(validated, VALIDATE_SUCCESS);\n\telse\n\t    SET(validated, VALIDATE_FAILURE);\n    }\n    if (!restore_perms())\n\tSET(validated, VALIDATE_ERROR);\n    debug_return_uint(validated);\n}", "target": 2, "idx": 9886}
{"commit_id": "e6db8a95174d0a63ba95504fbb1804b9a551bafd", "project": "vim", "func": "void\nscroll_cursor_bot(int min_scroll, int set_topbot)\n{\n    int\t\tused;\n    int\t\tscrolled = 0;\n    int\t\textra = 0;\n    int\t\ti;\n    linenr_T\tline_count;\n    linenr_T\told_topline = curwin->w_topline;\n    int\t\told_skipcol = curwin->w_skipcol;\n    lineoff_T\tloff;\n    lineoff_T\tboff;\n#ifdef FEAT_DIFF\n    int\t\told_topfill = curwin->w_topfill;\n    int\t\tfill_below_window;\n#endif\n    linenr_T\told_botline = curwin->w_botline;\n    linenr_T\told_valid = curwin->w_valid;\n    int\t\told_empty_rows = curwin->w_empty_rows;\n    linenr_T\tcln;\t\t    // Cursor Line Number\n    long\tso = get_scrolloff_value();\n    int\t\tdo_sms = curwin->w_p_wrap && curwin->w_p_sms;\n\n    cln = curwin->w_cursor.lnum;\n    if (set_topbot)\n    {\n\tint set_skipcol = FALSE;\n\n\tused = 0;\n\tcurwin->w_botline = cln + 1;\n#ifdef FEAT_DIFF\n\tloff.fill = 0;\n#endif\n\tfor (curwin->w_topline = curwin->w_botline;\n\t\tcurwin->w_topline > 1;\n\t\tcurwin->w_topline = loff.lnum)\n\t{\n\t    loff.lnum = curwin->w_topline;\n\t    topline_back_winheight(&loff, FALSE);\n\t    if (loff.height == MAXCOL)\n\t\tbreak;\n\t    if (used + loff.height > curwin->w_height)\n\t    {\n\t\tif (do_sms)\n\t\t{\n\t\t    // 'smoothscroll' and 'wrap' are set.  The above line is\n\t\t    // too long to show in its entirety, so we show just a part\n\t\t    // of it.\n\t\t    if (used < curwin->w_height)\n\t\t    {\n\t\t\tint plines_offset = used + loff.height\n\t\t\t\t\t\t\t    - curwin->w_height;\n\t\t\tused = curwin->w_height;\n#ifdef FEAT_DIFF\n\t\t\tcurwin->w_topfill = loff.fill;\n#endif\n\t\t\tcurwin->w_topline = loff.lnum;\n\t\t\tcurwin->w_skipcol = skipcol_from_plines(\n\t\t\t\t\t\t\tcurwin, plines_offset);\n\t\t\tset_skipcol = TRUE;\n\t\t    }\n\t\t}\n\t\tbreak;\n\t    }\n\t    used += loff.height;\n#ifdef FEAT_DIFF\n\t    curwin->w_topfill = loff.fill;\n#endif\n\t}\n\tset_empty_rows(curwin, used);\n\tcurwin->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;\n\tif (curwin->w_topline != old_topline\n#ifdef FEAT_DIFF\n\t\t|| curwin->w_topfill != old_topfill\n#endif\n\t\t|| set_skipcol\n\t\t|| curwin->w_skipcol != 0)\n\t{\n\t    curwin->w_valid &= ~(VALID_WROW|VALID_CROW);\n\t    if (set_skipcol)\n\t\tredraw_later(UPD_NOT_VALID);\n\t    else\n\t\treset_skipcol();\n\t}\n    }\n    else\n\tvalidate_botline();\n\n    // The lines of the cursor line itself are always used.\n#ifdef FEAT_DIFF\n    used = plines_nofill(cln);\n#else\n    validate_cheight();\n    used = curwin->w_cline_height;\n#endif\n\n    // If the cursor is on or below botline, we will at least scroll by the\n    // height of the cursor line, which is \"used\".  Correct for empty lines,\n    // which are really part of botline.\n    if (cln >= curwin->w_botline)\n    {\n\tscrolled = used;\n\tif (cln == curwin->w_botline)\n\t    scrolled -= curwin->w_empty_rows;\n\tif (do_sms)\n\t{\n\t    // 'smoothscroll' and 'wrap' are set.\n\t    // Calculate how many screen lines the current top line of window\n\t    // occupies. If it is occupying more than the entire window, we\n\t    // need to scroll the additional clipped lines to scroll past the\n\t    // top line before we can move on to the other lines.\n\t    int top_plines =\n#ifdef FEAT_DIFF\n\t\t\t    plines_win_nofill\n#else\n\t\t\t    plines_win\n#endif\n\t\t\t\t\t(curwin, curwin->w_topline, FALSE);\n\t    int skip_lines = 0;\n\t    int width1 = curwin->w_width - curwin_col_off();\n\t    if (width1 > 0)\n\t    {\n\t\tint width2 = width1 + curwin_col_off2();\n\t\t// similar formula is used in curs_columns()\n\t\tif (curwin->w_skipcol > width1)\n\t\t    skip_lines += (curwin->w_skipcol - width1) / width2 + 1;\n\t\telse if (curwin->w_skipcol > 0)\n\t\t    skip_lines = 1;\n\n\t\ttop_plines -= skip_lines;\n\t\tif (top_plines > curwin->w_height)\n\t\t{\n\t\t    scrolled += (top_plines - curwin->w_height);\n\t\t}\n\t    }\n\t}\n    }\n\n    /*\n     * Stop counting lines to scroll when\n     * - hitting start of the file\n     * - scrolled nothing or at least 'sj' lines\n     * - at least 'scrolloff' lines below the cursor\n     * - lines between botline and cursor have been counted\n     */\n#ifdef FEAT_FOLDING\n    if (!hasFolding(curwin->w_cursor.lnum, &loff.lnum, &boff.lnum))\n#endif\n    {\n\tloff.lnum = cln;\n\tboff.lnum = cln;\n    }\n#ifdef FEAT_DIFF\n    loff.fill = 0;\n    boff.fill = 0;\n    fill_below_window = diff_check_fill(curwin, curwin->w_botline)\n\t\t\t\t\t\t      - curwin->w_filler_rows;\n#endif\n\n    while (loff.lnum > 1)\n    {\n\t// Stop when scrolled nothing or at least \"min_scroll\", found \"extra\"\n\t// context for 'scrolloff' and counted all lines below the window.\n\tif ((((scrolled <= 0 || scrolled >= min_scroll)\n\t\t    && extra >= (mouse_dragging > 0 ? mouse_dragging - 1 : so))\n\t\t    || boff.lnum + 1 > curbuf->b_ml.ml_line_count)\n\t\t&& loff.lnum <= curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t&& (loff.lnum < curwin->w_botline\n\t\t    || loff.fill >= fill_below_window)\n#endif\n\t\t)\n\t    break;\n\n\t// Add one line above\n\ttopline_back(&loff);\n\tif (loff.height == MAXCOL)\n\t    used = MAXCOL;\n\telse\n\t    used += loff.height;\n\tif (used > curwin->w_height)\n\t    break;\n\tif (loff.lnum >= curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t&& (loff.lnum > curwin->w_botline\n\t\t    || loff.fill <= fill_below_window)\n#endif\n\t\t)\n\t{\n\t    // Count screen lines that are below the window.\n\t    scrolled += loff.height;\n\t    if (loff.lnum == curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t\t    && loff.fill == 0\n#endif\n\t\t    )\n\t\tscrolled -= curwin->w_empty_rows;\n\t}\n\n\tif (boff.lnum < curbuf->b_ml.ml_line_count)\n\t{\n\t    // Add one line below\n\t    botline_forw(&boff);\n\t    used += boff.height;\n\t    if (used > curwin->w_height)\n\t\tbreak;\n\t    if (extra < ( mouse_dragging > 0 ? mouse_dragging - 1 : so)\n\t\t    || scrolled < min_scroll)\n\t    {\n\t\textra += boff.height;\n\t\tif (boff.lnum >= curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t\t|| (boff.lnum + 1 == curwin->w_botline\n\t\t\t    && boff.fill > curwin->w_filler_rows)\n#endif\n\t\t   )\n\t\t{\n\t\t    // Count screen lines that are below the window.\n\t\t    scrolled += boff.height;\n\t\t    if (boff.lnum == curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t\t    && boff.fill == 0\n#endif\n\t\t\t    )\n\t\t\tscrolled -= curwin->w_empty_rows;\n\t\t}\n\t    }\n\t}\n    }\n\n    // curwin->w_empty_rows is larger, no need to scroll\n    if (scrolled <= 0)\n\tline_count = 0;\n    // more than a screenfull, don't scroll but redraw\n    else if (used > curwin->w_height)\n\tline_count = used;\n    // scroll minimal number of lines\n    else\n    {\n\tline_count = 0;\n#ifdef FEAT_DIFF\n\tboff.fill = curwin->w_topfill;\n#endif\n\tboff.lnum = curwin->w_topline - 1;\n\tfor (i = 0; i < scrolled && boff.lnum < curwin->w_botline; )\n\t{\n\t    botline_forw(&boff);\n\t    i += boff.height;\n\t    ++line_count;\n\t}\n\tif (i < scrolled)\t// below curwin->w_botline, don't scroll\n\t    line_count = 9999;\n    }\n\n    /*\n     * Scroll up if the cursor is off the bottom of the screen a bit.\n     * Otherwise put it at 1/2 of the screen.\n     */\n    if (line_count >= curwin->w_height && line_count > min_scroll)\n\tscroll_cursor_halfway(FALSE, TRUE);\n    else if (line_count > 0)\n    {\n\tif (do_sms)\n\t    scrollup(scrolled, TRUE);  // TODO\n\telse\n\t    scrollup(line_count, TRUE);\n    }\n\n    /*\n     * If topline didn't change we need to restore w_botline and w_empty_rows\n     * (we changed them).\n     * If topline did change, update_screen() will set botline.\n     */\n    if (curwin->w_topline == old_topline\n\t    && curwin->w_skipcol == old_skipcol\n\t    && set_topbot)\n    {\n\tcurwin->w_botline = old_botline;\n\tcurwin->w_empty_rows = old_empty_rows;\n\tcurwin->w_valid = old_valid;\n    }\n    curwin->w_valid |= VALID_TOPLINE;\n}", "target": 2, "idx": 9887}
{"commit_id": "14755416e364f17fb1870882fa778c7fec7f16e3", "project": "tensorflow", "func": "static port::StatusOr<CudnnRnnSequenceTensorDescriptor> Create(\n      GpuExecutor* parent, int max_seq_length, int batch_size, int data_size,\n      cudnnDataType_t data_type) {\n    if (max_seq_length <= 0) {\n      return port::Status(port::error::INVALID_ARGUMENT, \"max_seq_length <= 0\");\n    }\n    int dims[] = {batch_size, data_size, 1};\n    int strides[] = {dims[1] * dims[2], dims[2], 1};\n    TensorDescriptor tensor_desc = CreateTensorDescriptor();\n    RETURN_IF_CUDNN_ERROR(cudnnSetTensorNdDescriptor(\n        /*tensorDesc=*/tensor_desc.get(), /*dataType=*/data_type,\n        /*nbDims=*/sizeof(dims) / sizeof(dims[0]), /*dimA=*/dims,\n        /*strideA=*/strides));\n    return CudnnRnnSequenceTensorDescriptor(parent, max_seq_length, batch_size,\n                                            data_size, data_type,\n                                            nullptr,\n                                            std::move(tensor_desc));\n  }", "target": 1, "idx": 9888}
{"commit_id": "0a70f118475e037732557796accd0878a00fc25a", "project": "torvalds/linux", "func": "static void tcp_internal_pacing(struct sock *sk, const struct sk_buff *skb)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tktime_t expire, now;\n\tu64 len_ns;\n\tu32 rate;\n\n\tif (!tcp_needs_internal_pacing(sk))\n\t\treturn;\n\trate = sk->sk_pacing_rate;\n\tif (!rate || rate == ~0U)\n\t\treturn;\n\n\tlen_ns = (u64)skb->len * NSEC_PER_SEC;\n\tdo_div(len_ns, rate);\n\tnow = ktime_get();\n\t/* If hrtimer is already armed, then our caller has not\n\t * used tcp_pacing_check().\n\t */\n\tif (unlikely(hrtimer_is_queued(&tp->pacing_timer))) {\n\t\texpire = hrtimer_get_softexpires(&tp->pacing_timer);\n\t\tif (ktime_after(expire, now))\n\t\t\tnow = expire;\n\t\tif (hrtimer_try_to_cancel(&tp->pacing_timer) == 1)\n\t\t\t__sock_put(sk);\n\t}\n\thrtimer_start(&tp->pacing_timer, ktime_add_ns(now, len_ns),\n\t\t      HRTIMER_MODE_ABS_PINNED_SOFT);\n\tsock_hold(sk);\n}", "target": 1, "idx": 9889}
{"commit_id": "ff82911cd3f69f028f2537825c9720ff78bc3f19", "project": "qemu", "func": "static ssize_t nbd_co_send_reply(NBDRequestData *req, NBDReply *reply,\n                                 int len)\n{\n    NBDClient *client = req->client;\n    ssize_t rc, ret;\n\n    g_assert(qemu_in_coroutine());\n    qemu_co_mutex_lock(&client->send_lock);\n    client->send_coroutine = qemu_coroutine_self();\n\n    if (!len) {\n        rc = nbd_send_reply(client->ioc, reply);\n    } else {\n        qio_channel_set_cork(client->ioc, true);\n        rc = nbd_send_reply(client->ioc, reply);\n        if (rc >= 0) {\n            ret = write_sync(client->ioc, req->data, len);\n            if (ret != len) {\n                rc = -EIO;\n            }\n        }\n        qio_channel_set_cork(client->ioc, false);\n    }\n\n    client->send_coroutine = NULL;\n    qemu_co_mutex_unlock(&client->send_lock);\n    return rc;\n}", "target": 1, "idx": 9890}
{"commit_id": "2b6f22dc64d456471a1dc6df09d515771d1427c8", "project": "android", "func": "H264SwDecRet H264SwDecInit(H264SwDecInst *decInst, u32 noOutputReordering)\n{\n    u32 rv = 0;\n\n    decContainer_t *pDecCont;\n\n    DEC_API_TRC(\"H264SwDecInit#\");\n\n    /* check that right shift on negative numbers is performed signed */\n    /*lint -save -e* following check causes multiple lint messages */\n    if ( ((-1)>>1) != (-1) )\n    {\n        DEC_API_TRC(\"H264SwDecInit# ERROR: Right shift is not signed\");\n        return(H264SWDEC_INITFAIL);\n    }\n    /*lint -restore */\n\n    if (decInst == NULL)\n    {\n        DEC_API_TRC(\"H264SwDecInit# ERROR: decInst == NULL\");\n        return(H264SWDEC_PARAM_ERR);\n    }\n\n    pDecCont = (decContainer_t *)H264SwDecMalloc(sizeof(decContainer_t), 1);\n\n    if (pDecCont == NULL)\n    {\n        DEC_API_TRC(\"H264SwDecInit# ERROR: Memory allocation failed\");\n        return(H264SWDEC_MEMFAIL);\n    }\n\n#ifdef H264DEC_TRACE\n    sprintf(pDecCont->str, \"H264SwDecInit# decInst %p noOutputReordering %d\",\n            (void*)decInst, noOutputReordering);\n    DEC_API_TRC(pDecCont->str);\n#endif\n\n    rv = h264bsdInit(&pDecCont->storage, noOutputReordering);\n    if (rv != HANTRO_OK)\n    {\n        H264SwDecRelease(pDecCont);\n        return(H264SWDEC_MEMFAIL);\n    }\n\n    pDecCont->decStat  = INITIALIZED;\n    pDecCont->picNumber = 0;\n\n#ifdef H264DEC_TRACE\n    sprintf(pDecCont->str, \"H264SwDecInit# OK: return %p\", (void*)pDecCont);\n    DEC_API_TRC(pDecCont->str);\n#endif\n\n    *decInst = (decContainer_t *)pDecCont;\n\n    return(H264SWDEC_OK);\n\n}", "target": 2, "idx": 9891}
{"commit_id": "6e8e163b46d0823526f1afbbe6f66c668fc811d1", "project": "xen-project/xen", "func": "int relinquish_p2m_mapping(struct domain *d)\n{\n    struct p2m_domain *p2m = p2m_get_hostp2m(d);\n    unsigned long count = 0;\n    p2m_type_t t;\n    int rc = 0;\n    unsigned int order;\n    gfn_t start, end;\n\n    p2m_write_lock(p2m);\n\n    start = p2m->lowest_mapped_gfn;\n    end = gfn_add(p2m->max_mapped_gfn, 1);\n\n    for ( ; gfn_x(start) < gfn_x(end);\n          start = gfn_next_boundary(start, order) )\n    {\n        mfn_t mfn = p2m_get_entry(p2m, start, &t, NULL, &order, NULL);\n\n        count++;\n        /*\n         * Arbitrarily preempt every 512 iterations.\n         */\n        if ( !(count % 512) && hypercall_preempt_check() )\n        {\n            rc = -ERESTART;\n            break;\n        }\n\n        /*\n         * p2m_set_entry will take care of removing reference on page\n         * when it is necessary and removing the mapping in the p2m.\n         */\n        if ( !mfn_eq(mfn, INVALID_MFN) )\n        {\n            /*\n             * For valid mapping, the start will always be aligned as\n             * entry will be removed whilst relinquishing.\n             */\n            rc = __p2m_set_entry(p2m, start, order, INVALID_MFN,\n                                 p2m_invalid, p2m_access_rwx);\n            if ( unlikely(rc) )\n            {\n                printk(XENLOG_G_ERR \"Unable to remove mapping gfn=%#\"PRI_gfn\" order=%u from the p2m of domain %d\\n\", gfn_x(start), order, d->domain_id);\n                break;\n            }\n        }\n    }\n\n    /*\n     * Update lowest_mapped_gfn so on the next call we still start where\n     * we stopped.\n     */\n    p2m->lowest_mapped_gfn = start;\n\n    p2m_write_unlock(p2m);\n\n    return rc;\n}", "target": 2, "idx": 9892}
{"commit_id": "301ae88b331d37a2a16159b65b255f4f9eb39314", "project": "tensorflow", "func": "Status GetFirstDimensionSize(OpKernelContext* context, INDEX_TYPE* result) {\n    const Tensor first_partition_tensor =\n        context->input(kFirstPartitionInputIndex);\n    if (row_partition_types_.empty()) {\n      return errors::InvalidArgument(\"No row_partition_types given.\");\n    }\n    const RowPartitionType first_partition_type = row_partition_types_[0];\n    switch (first_partition_type) {\n      case RowPartitionType::FIRST_DIM_SIZE:\n        *result = first_partition_tensor.scalar<INDEX_TYPE>()();\n        return Status::OK();\n      case RowPartitionType::VALUE_ROWIDS:\n        return errors::InvalidArgument(\n            \"Cannot handle VALUE_ROWIDS in first dimension.\");\n      case RowPartitionType::ROW_SPLITS:\n        *result = first_partition_tensor.shape().dim_size(0) - 1;\n        return Status::OK();\n      default:\n        return errors::InvalidArgument(\n            \"Cannot handle type \",\n            RowPartitionTypeToString(first_partition_type));\n    }\n  }", "target": 2, "idx": 9893}
{"commit_id": "43bc256d8ae44b92d2734a3c5bc73957a4d7c1ec", "project": "vadz/libtiff", "func": "static int\nOJPEGDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)\n{\n        static const char module[]=\"OJPEGDecode\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\t(void)s;\n        if( !sp->decoder_ok )\n        {\n            TIFFErrorExt(tif->tif_clientdata,module,\"Cannot decode: decoder not correctly initialized\");\n            return 0;\n        }\n\tif (sp->libjpeg_jpeg_query_style==0)\n\t{\n\t\tif (OJPEGDecodeRaw(tif,buf,cc)==0)\n\t\t\treturn(0);\n\t}\n\telse\n\t{\n\t\tif (OJPEGDecodeScanlines(tif,buf,cc)==0)\n\t\t\treturn(0);\n\t}\n\treturn(1);\n}", "target": 1, "idx": 9894}
{"commit_id": "5d45b69b590cabc5127282d1ade3bca1598e5f5c", "project": "wireshark", "func": "static gint dissect_wccp2_alternate_mask_value_set_list(tvbuff_t *tvb, int offset,\n                                                        int length, packet_info *pinfo, proto_tree *info_tree, wccp_address_table* addr_table)\n{\n  proto_tree *list_tree;\n  guint num_of_val_elements;\n  guint i;\n\n  if (length < 4)\n    return length - 4;\n\n  list_tree = proto_tree_add_subtree(info_tree, tvb, offset, length,\n                               ett_alternate_mask_value_set, NULL, \"Alternate Mask/Value Set List\");\n\n  num_of_val_elements = tvb_get_ntohl(tvb, offset);\n  proto_tree_add_uint(list_tree, hf_alt_assignment_mask_value_set_list_num_elements, tvb, offset, 4, num_of_val_elements);\n  EAT(4);\n\n  for(i=0;i<num_of_val_elements;i++) {\n    gint new_length;\n\n    new_length=dissect_wccp2_alternate_mask_value_set_element(tvb, offset, length, i, pinfo, list_tree, addr_table);\n\n    CHECK_LENGTH_ADVANCE_OFFSET(new_length);\n  }\n  return length;\n}", "target": 2, "idx": 9895}
{"commit_id": "118815ca7c9f82c1f83f8f64d9e0e54673f31677", "project": "wireshark", "func": "static int add_uint_string(proto_tree *tree, int hf_string, tvbuff_t *tvb, int offset)\n{\n\tproto_item* ti;\n\tint length;\n\n\tti = proto_tree_add_item(tree, hf_string, tvb,\n\t\t\t\t\t\toffset, 4, ENC_ASCII|ENC_BIG_ENDIAN);\n\tlength = dword_align(tvb_get_ntohl(tvb, offset))+4;\n\tproto_item_set_len(ti, length);\n\tint ret_offset = offset + length;\n\tif (length < 4 || ret_offset < offset) {\n\t\texpert_add_info_format(NULL, ti, &ei_gdsdb_invalid_length, \"Invalid length: %d\", length);\n\t\treturn tvb_reported_length(tvb);\n\t}\n\treturn ret_offset;\n}", "target": 2, "idx": 9896}
{"commit_id": "32452a3eb8b64e01e2be717f518c0be046975b9d", "project": "torvalds/linux", "func": "static int io_rw_init_file(struct io_kiocb *req, fmode_t mode)\n{\n\tstruct kiocb *kiocb = &req->rw.kiocb;\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct file *file = req->file;\n\tint ret;\n\n\tif (unlikely(!file || !(file->f_mode & mode)))\n\t\treturn -EBADF;\n\n\tif (!io_req_ffs_set(req))\n\t\treq->flags |= io_file_get_flags(file) << REQ_F_SUPPORT_NOWAIT_BIT;\n\n\tkiocb->ki_flags = iocb_flags(file);\n\tret = kiocb_set_rw_flags(kiocb, req->rw.flags);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\t/*\n\t * If the file is marked O_NONBLOCK, still allow retry for it if it\n\t * supports async. Otherwise it's impossible to use O_NONBLOCK files\n\t * reliably. If not, or it IOCB_NOWAIT is set, don't retry.\n\t */\n\tif ((kiocb->ki_flags & IOCB_NOWAIT) ||\n\t    ((file->f_flags & O_NONBLOCK) && !io_file_supports_nowait(req)))\n\t\treq->flags |= REQ_F_NOWAIT;\n\n\tif (ctx->flags & IORING_SETUP_IOPOLL) {\n\t\tif (!(kiocb->ki_flags & IOCB_DIRECT) || !file->f_op->iopoll)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tkiocb->private = NULL;\n\t\tkiocb->ki_flags |= IOCB_HIPRI | IOCB_ALLOC_CACHE;\n\t\tkiocb->ki_complete = io_complete_rw_iopoll;\n\t\treq->iopoll_completed = 0;\n\t} else {\n\t\tif (kiocb->ki_flags & IOCB_HIPRI)\n\t\t\treturn -EINVAL;\n\t\tkiocb->ki_complete = io_complete_rw;\n\t}\n\n\treturn 0;\n}", "target": 2, "idx": 9897}
{"commit_id": "c9f2c53169ffe90980724a46f64e9f5c2c3d9fc5", "project": "axiomatic-systems/Bento4", "func": "AP4_StszAtom::AP4_StszAtom(AP4_UI32        size, \n                           AP4_UI08        version,\n                           AP4_UI32        flags,\n                           AP4_ByteStream& stream) :\n    AP4_Atom(AP4_ATOM_TYPE_STSZ, size, version, flags),\n    m_SampleSize(0),\n    m_SampleCount(0)\n{\n    if (size < AP4_FULL_ATOM_HEADER_SIZE + 8) {\n        return;\n    }\n\n    stream.ReadUI32(m_SampleSize);\n    AP4_UI32 sample_count;\n    stream.ReadUI32(sample_count);\n    if (m_SampleSize == 0) { // means that the samples have different sizes\n        // check for overflow\n        if (m_SampleCount > (size - AP4_FULL_ATOM_HEADER_SIZE - 8) / 4) {\n            return;\n        }\n        \n        // read the entries\n        unsigned char* buffer = new unsigned char[sample_count * 4];\n        AP4_Result result = stream.Read(buffer, sample_count*4);\n        if (AP4_FAILED(result)) {\n            delete[] buffer;\n            return;\n        }\n        m_SampleCount = sample_count;\n        m_Entries.SetItemCount((AP4_Cardinal)sample_count);\n        for (unsigned int i=0; i<sample_count; i++) {\n            m_Entries[i] = AP4_BytesToUInt32BE(&buffer[i*4]);\n        }\n        delete[] buffer;\n    }\n}", "target": 2, "idx": 9898}
{"commit_id": "ce07d891a0891d3c0d0c2d73d577490486b809e1", "project": "torvalds/linux", "func": "void __detach_mounts(struct dentry *dentry)\n{\n\tstruct mountpoint *mp;\n\tstruct mount *mnt;\n\n\tnamespace_lock();\n\tmp = lookup_mountpoint(dentry);\n\tif (!mp)\n\t\tgoto out_unlock;\n\n\tlock_mount_hash();\n\twhile (!hlist_empty(&mp->m_list)) {\n\t\tmnt = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list);\n\t\tif (mnt->mnt.mnt_flags & MNT_UMOUNT) {\n\t\t\tstruct mount *p, *tmp;\n\t\t\tlist_for_each_entry_safe(p, tmp, &mnt->mnt_mounts,  mnt_child) {\n\t\t\t\thlist_add_head(&p->mnt_umount.s_list, &unmounted);\n\t\t\t\tumount_mnt(p);\n\t\t\t}\n\t\t}\n\t\telse umount_tree(mnt, 0);\n\t}\n\tunlock_mount_hash();\n\tput_mountpoint(mp);\nout_unlock:\n\tnamespace_unlock();\n}", "target": 1, "idx": 9899}
{"commit_id": "3fdc211b01b29f252166937238efe02d15cb5780", "project": "xen-project/xen", "func": "int map_vcpu_info(struct vcpu *v, unsigned long gfn, unsigned offset)\n{\n    struct domain *d = v->domain;\n    void *mapping;\n    vcpu_info_t *new_info;\n    struct page_info *page;\n    unsigned int align;\n\n    if ( offset > (PAGE_SIZE - sizeof(vcpu_info_t)) )\n        return -EINVAL;\n\n#ifdef CONFIG_COMPAT\n    if ( has_32bit_shinfo(d) )\n        align = alignof(new_info->compat);\n    else\n#endif\n        align = alignof(*new_info);\n    if ( offset & (align - 1) )\n        return -EINVAL;\n\n    if ( !mfn_eq(v->vcpu_info_mfn, INVALID_MFN) )\n        return -EINVAL;\n\n    /* Run this command on yourself or on other offline VCPUS. */\n    if ( (v != current) && !(v->pause_flags & VPF_down) )\n        return -EINVAL;\n\n    page = get_page_from_gfn(d, gfn, NULL, P2M_ALLOC);\n    if ( !page )\n        return -EINVAL;\n\n    if ( !get_page_type(page, PGT_writable_page) )\n    {\n        put_page(page);\n        return -EINVAL;\n    }\n\n    mapping = __map_domain_page_global(page);\n    if ( mapping == NULL )\n    {\n        put_page_and_type(page);\n        return -ENOMEM;\n    }\n\n    new_info = (vcpu_info_t *)(mapping + offset);\n\n    if ( v->vcpu_info == &dummy_vcpu_info )\n    {\n        memset(new_info, 0, sizeof(*new_info));\n#ifdef XEN_HAVE_PV_UPCALL_MASK\n        __vcpu_info(v, new_info, evtchn_upcall_mask) = 1;\n#endif\n    }\n    else\n    {\n        memcpy(new_info, v->vcpu_info, sizeof(*new_info));\n    }\n\n    v->vcpu_info = new_info;\n    v->vcpu_info_mfn = page_to_mfn(page);\n\n    /* Set new vcpu_info pointer /before/ setting pending flags. */\n    smp_wmb();\n\n    /*\n     * Mark everything as being pending just to make sure nothing gets\n     * lost.  The domain will get a spurious event, but it can cope.\n     */\n#ifdef CONFIG_COMPAT\n    if ( !has_32bit_shinfo(d) )\n        write_atomic(&new_info->native.evtchn_pending_sel, ~0);\n    else\n#endif\n        write_atomic(&vcpu_info(v, evtchn_pending_sel), ~0);\n    vcpu_mark_events_pending(v);\n\n    return 0;\n}", "target": 1, "idx": 9900}
{"commit_id": "e6ed9c1a4b02dc219de1648f44cd808a56171b81", "project": "facebook/hermes", "func": "static bool inferUnaryArith(UnaryOperatorInst *UOI, Type numberResultType) {\n  Value *op = UOI->getSingleOperand();\n\n  if (op->getType().isNumberType()) {\n    UOI->setType(numberResultType);\n    return true;\n  }\n\n  if (op->getType().isBigIntType()) {\n    UOI->setType(Type::createBigInt());\n    return true;\n  }\n\n  Type mayBeBigInt = isBigIntOrObject(op->getType()) ? Type::createBigInt()\n                                                     : Type::createNoType();\n\n  // - ?? => Number|?BigInt. BigInt is only possible if op.Type is\n  // BigInt|Object.\n  UOI->setType(Type::unionTy(numberResultType, mayBeBigInt));\n  return true;\n}", "target": 3, "idx": 9901}
{"commit_id": "cc00bcaa589914096edef7fb87ca5cee4a166b5c", "project": "torvalds/linux", "func": "unsigned int arpt_do_table(struct sk_buff *skb,\n\t\t\t   const struct nf_hook_state *state,\n\t\t\t   struct xt_table *table)\n{\n\tunsigned int hook = state->hook;\n\tstatic const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));\n\tunsigned int verdict = NF_DROP;\n\tconst struct arphdr *arp;\n\tstruct arpt_entry *e, **jumpstack;\n\tconst char *indev, *outdev;\n\tconst void *table_base;\n\tunsigned int cpu, stackidx = 0;\n\tconst struct xt_table_info *private;\n\tstruct xt_action_param acpar;\n\tunsigned int addend;\n\n\tif (!pskb_may_pull(skb, arp_hdr_len(skb->dev)))\n\t\treturn NF_DROP;\n\n\tindev = state->in ? state->in->name : nulldevname;\n\toutdev = state->out ? state->out->name : nulldevname;\n\n\tlocal_bh_disable();\n\taddend = xt_write_recseq_begin();\n\tprivate = rcu_access_pointer(table->private);\n\tcpu     = smp_processor_id();\n\ttable_base = private->entries;\n\tjumpstack  = (struct arpt_entry **)private->jumpstack[cpu];\n\n\t/* No TEE support for arptables, so no need to switch to alternate\n\t * stack.  All targets that reenter must return absolute verdicts.\n\t */\n\te = get_entry(table_base, private->hook_entry[hook]);\n\n\tacpar.state   = state;\n\tacpar.hotdrop = false;\n\n\tarp = arp_hdr(skb);\n\tdo {\n\t\tconst struct xt_entry_target *t;\n\t\tstruct xt_counters *counter;\n\n\t\tif (!arp_packet_match(arp, skb->dev, indev, outdev, &e->arp)) {\n\t\t\te = arpt_next_entry(e);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcounter = xt_get_this_cpu_counter(&e->counters);\n\t\tADD_COUNTER(*counter, arp_hdr_len(skb->dev), 1);\n\n\t\tt = arpt_get_target_c(e);\n\n\t\t/* Standard target? */\n\t\tif (!t->u.kernel.target->target) {\n\t\t\tint v;\n\n\t\t\tv = ((struct xt_standard_target *)t)->verdict;\n\t\t\tif (v < 0) {\n\t\t\t\t/* Pop from stack? */\n\t\t\t\tif (v != XT_RETURN) {\n\t\t\t\t\tverdict = (unsigned int)(-v) - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (stackidx == 0) {\n\t\t\t\t\te = get_entry(table_base,\n\t\t\t\t\t\t      private->underflow[hook]);\n\t\t\t\t} else {\n\t\t\t\t\te = jumpstack[--stackidx];\n\t\t\t\t\te = arpt_next_entry(e);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (table_base + v\n\t\t\t    != arpt_next_entry(e)) {\n\t\t\t\tif (unlikely(stackidx >= private->stacksize)) {\n\t\t\t\t\tverdict = NF_DROP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tjumpstack[stackidx++] = e;\n\t\t\t}\n\n\t\t\te = get_entry(table_base, v);\n\t\t\tcontinue;\n\t\t}\n\n\t\tacpar.target   = t->u.kernel.target;\n\t\tacpar.targinfo = t->data;\n\t\tverdict = t->u.kernel.target->target(skb, &acpar);\n\n\t\tif (verdict == XT_CONTINUE) {\n\t\t\t/* Target might have changed stuff. */\n\t\t\tarp = arp_hdr(skb);\n\t\t\te = arpt_next_entry(e);\n\t\t} else {\n\t\t\t/* Verdict */\n\t\t\tbreak;\n\t\t}\n\t} while (!acpar.hotdrop);\n\txt_write_recseq_end(addend);\n\tlocal_bh_enable();\n\n\tif (acpar.hotdrop)\n\t\treturn NF_DROP;\n\telse\n\t\treturn verdict;\n}", "target": 1, "idx": 9902}
{"commit_id": "9c87439d9afa14a365ff13e73adc809cb2c3d97b", "project": "sparklemotion/nokogiri", "func": "static VALUE from_document(int argc, VALUE *argv, VALUE klass)\n{\n  VALUE document;\n  VALUE parse_options;\n  xmlDocPtr doc;\n  xmlRelaxNGParserCtxtPtr ctx;\n  xmlRelaxNGPtr schema;\n  VALUE errors;\n  VALUE rb_schema;\n  int scanned_args = 0;\n\n  scanned_args = rb_scan_args(argc, argv, \"11\", &document, &parse_options);\n\n  Data_Get_Struct(document, xmlDoc, doc);\n  doc = doc->doc; /* In case someone passes us a node. ugh. */\n\n  if (scanned_args == 1) {\n    parse_options = rb_const_get(rb_const_get(mNokogiriXml, rb_intern(\"ParseOptions\")), rb_intern(\"DEFAULT_SCHEMA\"));\n  }\n\n  ctx = xmlRelaxNGNewDocParserCtxt(doc);\n\n  errors = rb_ary_new();\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n\n#ifdef HAVE_XMLRELAXNGSETPARSERSTRUCTUREDERRORS\n  xmlRelaxNGSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n\n  schema = xmlRelaxNGParse(ctx);\n\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlRelaxNGFreeParserCtxt(ctx);\n\n  if(NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if(error)\n      Nokogiri_error_raise(NULL, error);\n    else\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n\n    return Qnil;\n  }\n\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n  rb_iv_set(rb_schema, \"@parse_options\", parse_options);\n\n  return rb_schema;\n}", "target": 0, "idx": 9903}
{"commit_id": "365abe807cab2d60dc9ec307292a06181f77a9c2", "project": "facebook/hhvm", "func": "bool HHVM_FUNCTION(mb_parse_str,\n                   const String& encoded_string,\n                   VRefParam result /* = null */) {\n  php_mb_encoding_handler_info_t info;\n  info.data_type              = PARSE_STRING;\n  info.separator              = \";&\";\n  info.force_register_globals = false;\n  info.report_errors          = 1;\n  info.to_encoding            = MBSTRG(current_internal_encoding);\n  info.to_language            = MBSTRG(current_language);\n  info.from_encodings         = MBSTRG(http_input_list);\n  info.num_from_encodings     = MBSTRG(http_input_list_size);\n  info.from_language          = MBSTRG(current_language);\n\n  char *encstr = req::strndup(encoded_string.data(), encoded_string.size());\n  Array resultArr = Array::Create();\n  mbfl_encoding *detected =\n    _php_mb_encoding_handler_ex(&info, resultArr, encstr);\n  req::free(encstr);\n  result.assignIfRef(resultArr);\n\n  MBSTRG(http_input_identify) = detected;\n  return detected != nullptr;\n}", "target": 3, "idx": 9904}
{"commit_id": "373c1c9b691fd4c6831b3a114a006b639304c2af", "project": "ffmpeg", "func": "static int read_header(AVFormatContext *s)\n{\n    WtvContext *wtv = s->priv_data;\n    unsigned root_sector;\n    int root_size;\n    uint8_t root[WTV_SECTOR_SIZE];\n    AVIOContext *pb;\n    int64_t timeline_pos;\n    int64_t ret;\n\n    wtv->epoch          =\n    wtv->pts            =\n    wtv->last_valid_pts = AV_NOPTS_VALUE;\n\n    /* read root directory sector */\n    avio_skip(s->pb, 0x30);\n    root_size = avio_rl32(s->pb);\n    if (root_size > sizeof(root)) {\n        av_log(s, AV_LOG_ERROR, \"root directory size exceeds sector size\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    avio_skip(s->pb, 4);\n    root_sector = avio_rl32(s->pb);\n\n    ret = seek_by_sector(s->pb, root_sector, 0);\n    if (ret < 0)\n        return ret;\n    root_size = avio_read(s->pb, root, root_size);\n    if (root_size < 0)\n        return AVERROR_INVALIDDATA;\n\n    /* parse chunks up until first data chunk */\n    wtv->pb = wtvfile_open(s, root, root_size, ff_timeline_le16);\n    if (!wtv->pb) {\n        av_log(s, AV_LOG_ERROR, \"timeline data missing\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    ret = parse_chunks(s, SEEK_TO_DATA, 0, 0);\n    if (ret < 0) {\n        wtvfile_close(wtv->pb);\n        return ret;\n    }\n    avio_seek(wtv->pb, -32, SEEK_CUR);\n\n    timeline_pos = avio_tell(s->pb); // save before opening another file\n\n    /* read metadata */\n    pb = wtvfile_open(s, root, root_size, ff_table_0_entries_legacy_attrib_le16);\n    if (pb) {\n        parse_legacy_attrib(s, pb);\n        wtvfile_close(pb);\n    }\n\n    s->ctx_flags |= AVFMTCTX_NOHEADER; // Needed for noStreams.wtv\n\n    /* read seek index */\n    if (s->nb_streams) {\n        AVStream *st = s->streams[0];\n        pb = wtvfile_open(s, root, root_size, ff_table_0_entries_time_le16);\n        if (pb) {\n            while(1) {\n                uint64_t timestamp = avio_rl64(pb);\n                uint64_t frame_nb  = avio_rl64(pb);\n                if (avio_feof(pb))\n                    break;\n                ff_add_index_entry(&wtv->index_entries, &wtv->nb_index_entries, &wtv->index_entries_allocated_size,\n                                   0, timestamp, frame_nb, 0, AVINDEX_KEYFRAME);\n            }\n            wtvfile_close(pb);\n\n            if (wtv->nb_index_entries) {\n                pb = wtvfile_open(s, root, root_size, ff_timeline_table_0_entries_Events_le16);\n                if (pb) {\n                    AVIndexEntry *e = wtv->index_entries;\n                    AVIndexEntry *e_end = wtv->index_entries + wtv->nb_index_entries - 1;\n                    uint64_t last_position = 0;\n                    while (1) {\n                        uint64_t frame_nb = avio_rl64(pb);\n                        uint64_t position = avio_rl64(pb);\n                        while (e <= e_end && frame_nb > e->size) {\n                            e->pos = last_position;\n                            e++;\n                        }\n                        if (avio_feof(pb))\n                            break;\n                        last_position = position;\n                    }\n                    e_end->pos = last_position;\n                    wtvfile_close(pb);\n                    st->duration = e_end->timestamp;\n                }\n            }\n        }\n    }\n\n    avio_seek(s->pb, timeline_pos, SEEK_SET);\n    return 0;\n}", "target": 1, "idx": 9905}
{"commit_id": "de0b1bae6461f67243282555475f88b2384a1eb9", "project": "qemu", "func": "static uint64_t pac_sub(uint64_t i)\n{\n    static const uint8_t sub[16] = {\n        0xb, 0x6, 0x8, 0xf, 0xc, 0x0, 0x9, 0xe,\n        0x3, 0x7, 0x4, 0x5, 0xd, 0x2, 0x1, 0xa,\n    };\n    uint64_t o = 0;\n    int b;\n\n    for (b = 0; b < 64; b += 4) {\n        o |= (uint64_t)sub[(i >> b) & 0xf] << b;\n    }\n    return o;\n}", "target": 1, "idx": 9906}
{"commit_id": "7ec54f9eb62b5d177e30eb8b1cad795a5f8d8986", "project": "qemu-project/qemu", "func": "static void usbredir_handle_interrupt_out_data(USBRedirDevice *dev,\n                                               USBPacket *p, uint8_t ep)\n{\n    struct usb_redir_interrupt_packet_header interrupt_packet;\n    g_autofree uint8_t *buf = g_malloc(p->iov.size);\n\n    DPRINTF(\"interrupt-out ep %02X len %zd id %\"PRIu64\"\\n\", ep,\n            p->iov.size, p->id);\n\n    interrupt_packet.endpoint  = ep;\n    interrupt_packet.length    = p->iov.size;\n\n    usb_packet_copy(p, buf, p->iov.size);\n    usbredir_log_data(dev, \"interrupt data out:\", buf, p->iov.size);\n    usbredirparser_send_interrupt_packet(dev->parser, p->id,\n                                    &interrupt_packet, buf, p->iov.size);\n    usbredirparser_do_write(dev->parser);\n}", "target": 1, "idx": 9907}
{"commit_id": "4f10021e7ee527c1aa24853e2947e38e154d9ccb", "project": "michaelrsweet/pdfio", "func": "bool\t\t\t\t\t// O - `true` on success, `false` on failure\n_pdfioTokenGet(_pdfio_token_t *tb,\t// I - Token buffer/stack\n\t       char           *buffer,\t// I - String buffer\n\t       size_t         bufsize)\t// I - Size of string buffer\n{\n  // See if we have a token waiting on the stack...\n  if (tb->num_tokens > 0)\n  {\n    // Yes, return it...\n    size_t len;\t\t\t\t// Length of token\n\n    tb->num_tokens --;\n\n    if ((len = strlen(tb->tokens[tb->num_tokens])) > (bufsize - 1))\n    {\n      // Value too large...\n      PDFIO_DEBUG(\"_pdfioTokenGet(tb=%p, buffer=%p, bufsize=%u): Token '%s' from stack too large.\\n\", tb, buffer, (unsigned)bufsize, tb->tokens[tb->num_tokens]);\n      *buffer = '\\0';\n      return (false);\n    }\n\n    memcpy(buffer, tb->tokens[tb->num_tokens], len);\n    buffer[len] = '\\0';\n\n    PDFIO_DEBUG(\"_pdfioTokenGet(tb=%p, buffer=%p, bufsize=%u): Popping '%s' from stack.\\n\", tb, buffer, (unsigned)bufsize, buffer);\n\n    free(tb->tokens[tb->num_tokens]);\n    tb->tokens[tb->num_tokens] = NULL;\n\n    return (true);\n  }\n\n  // No, read a new one...\n  return (_pdfioTokenRead(tb, buffer, bufsize));\n}", "target": 1, "idx": 9908}
{"commit_id": "8fed5e334131abaf9c5e17307642fbf6ce4a57ec", "project": "google/asylo", "func": "int enc_untrusted_inet_pton(int af, const char *src, void *dst) {\n  if (!src || !dst) {\n    return 0;\n  }\n\n  MessageWriter input;\n  input.Push<int>(TokLinuxAfFamily(af));\n  input.PushByReference(Extent{\n      src, std::min(strlen(src) + 1, static_cast<size_t>(INET6_ADDRSTRLEN))});\n  MessageReader output;\n\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kInetPtonHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_inet_pton\", 3);\n\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return -1;\n  }\n\n  auto klinux_addr_buffer = output.next();\n  size_t max_size = 0;\n  if (af == AF_INET) {\n    if (klinux_addr_buffer.size() != sizeof(klinux_in_addr)) {\n      ::asylo::primitives::TrustedPrimitives::BestEffortAbort(\n          \"enc_untrusted_inet_pton: unexpected output size\");\n    }\n    max_size = sizeof(struct in_addr);\n  } else if (af == AF_INET6) {\n    if (klinux_addr_buffer.size() != sizeof(klinux_in6_addr)) {\n      ::asylo::primitives::TrustedPrimitives::BestEffortAbort(\n          \"enc_untrusted_inet_pton: unexpected output size\");\n    }\n    max_size = sizeof(struct in6_addr);\n  }\n  memcpy(dst, klinux_addr_buffer.data(),\n         std::min(klinux_addr_buffer.size(), max_size));\n  return result;\n}", "target": 1, "idx": 9909}
{"commit_id": "cadff53c093210404aed01c4cf586adb8caa07af", "project": "fluent/fluent-bit", "func": "int flb_gzip_compress(void *in_data, size_t in_len,\n                      void **out_data, size_t *out_len)\n{\n    int flush;\n    int status;\n    int footer_start;\n    uint8_t *pb;\n    size_t out_size;\n    void *out_buf;\n    z_stream strm;\n    mz_ulong crc;\n\n\n    /*\n     * GZIP relies on an algorithm with worst-case expansion\n     * of 5 bytes per 32KB data. This means we need to create a variable\n     * length output, that depends on the input length.\n     * See RFC 1951 for details.\n     */\n    int max_input_expansion = ((int)(in_len / 32000) + 1) * 5;\n\n    /*\n     * Max compressed size is equal to sum of:\n     *   10 byte header\n     *   8 byte foot\n     *   max input expansion\n     *   size of input\n     */\n    out_size = 10 + 8 + max_input_expansion + in_len;\n    out_buf = flb_malloc(out_size);\n\n    if (!out_buf) {\n        flb_errno();\n        flb_error(\"[gzip] could not allocate outgoing buffer\");\n        return -1;\n    }\n\n    /* Initialize streaming buffer context */\n    memset(&strm, '\\0', sizeof(strm));\n    strm.zalloc    = Z_NULL;\n    strm.zfree     = Z_NULL;\n    strm.opaque    = Z_NULL;\n    strm.next_in   = in_data;\n    strm.avail_in  = in_len;\n    strm.total_out = 0;\n\n    /* Deflate mode */\n    deflateInit2(&strm, Z_DEFAULT_COMPRESSION,\n                 Z_DEFLATED, -Z_DEFAULT_WINDOW_BITS, 9, Z_DEFAULT_STRATEGY);\n\n    /*\n     * Miniz don't support GZip format directly, instead we will:\n     *\n     * - append manual GZip magic bytes\n     * - deflate raw content\n     * - append manual CRC32 data\n     */\n    gzip_header(out_buf);\n\n    /* Header offset */\n    pb = (uint8_t *) out_buf + FLB_GZIP_HEADER_OFFSET;\n\n    flush = Z_NO_FLUSH;\n    while (1) {\n        strm.next_out  = pb + strm.total_out;\n        strm.avail_out = out_size - (pb - (uint8_t *) out_buf);\n\n        if (strm.avail_in == 0) {\n            flush = Z_FINISH;\n        }\n\n        status = deflate(&strm, flush);\n        if (status == Z_STREAM_END) {\n            break;\n        }\n        else if (status != Z_OK) {\n            deflateEnd(&strm);\n            return -1;\n        }\n    }\n\n    if (deflateEnd(&strm) != Z_OK) {\n        flb_free(out_buf);\n        return -1;\n    }\n    *out_len = strm.total_out;\n\n    /* Construct the gzip checksum (CRC32 footer) */\n    footer_start = FLB_GZIP_HEADER_OFFSET + *out_len;\n    pb = (uint8_t *) out_buf + footer_start;\n\n    crc = mz_crc32(MZ_CRC32_INIT, in_data, in_len);\n    *pb++ = crc & 0xFF;\n    *pb++ = (crc >> 8) & 0xFF;\n    *pb++ = (crc >> 16) & 0xFF;\n    *pb++ = (crc >> 24) & 0xFF;\n    *pb++ = in_len & 0xFF;\n    *pb++ = (in_len >> 8) & 0xFF;\n    *pb++ = (in_len >> 16) & 0xFF;\n    *pb++ = (in_len >> 24) & 0xFF;\n\n    /* Set the real buffer size for the caller */\n    *out_len += FLB_GZIP_HEADER_OFFSET + 8;\n    *out_data = out_buf;\n\n    return 0;\n}", "target": 2, "idx": 9910}
{"commit_id": "abba6d7774cdd73665e69f6aa45f42439729e414", "project": "zephyrproject-rtos/zephyr", "func": "void shell_spaces_trim(char *str)\n{\n\tu16_t len = shell_strlen(str);\n\tu16_t shift = 0U;\n\n\tif (!str) {\n\t\treturn;\n\t}\n\n\tfor (u16_t i = 0; i < len - 1; i++) {\n\t\tif (isspace((int)str[i])) {\n\t\t\tfor (u16_t j = i + 1; j < len; j++) {\n\t\t\t\tif (isspace((int)str[j])) {\n\t\t\t\t\tshift++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (shift > 0) {\n\t\t\t\t\t/* +1 for EOS */\n\t\t\t\t\tmemmove(&str[i + 1],\n\t\t\t\t\t\t&str[j],\n\t\t\t\t\t\tlen - j + 1);\n\t\t\t\t\tlen -= shift;\n\t\t\t\t\tshift = 0U;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}", "target": 1, "idx": 9911}
{"commit_id": "030e47a29976709a50603e3f34e82278e5f462df", "project": "openlink/virtuoso-opensource", "func": "void\nsqlc_cursor (sql_comp_t * sc, ST ** ptree, int cr_type)\n{\n  ST *tree = *ptree;\n  int is_id;\n  int cr_forced_static = 0;\n\n  sc->sc_no_remote = 1;\n\n  if (IS_UNION_ST (tree))\n    {\n      tree = sqlp_view_def (NULL, tree, 1);\n      tree = sqlc_union_dt_wrap (sc, tree);\n      *ptree = tree;\n    }\n  sqlc_top_select_wrap_dt (sc, tree);\n  sql_stmt_comp (sc, ptree);\n  tree = *ptree;\n\n  if (sc->sc_so)\n    is_id = sqlo_cr_is_identifiable (sc->sc_so, tree);\n  else\n    is_id = sqlc_cr_is_identifiable (sc, tree);\n  if (!is_id)\n    cr_forced_static = 1;\n  {\n    NEW_VARZ (query_cursor_t, qc);\n    if (sc->sc_cc->cc_query->qr_cursor)\n      {\n\tqc_free (sc->sc_cc->cc_query->qr_cursor);\n\tfprintf (stderr, \"Freeing qc in sqlc_cursor\\n\");\n      }\n    sc->sc_cc->cc_query->qr_cursor = qc;\n    sc->sc_cc->cc_query->qr_cursor_type = cr_type;\n\n    if (sc->sc_so)\n      {\n\tif (!cr_forced_static\n\t    && -1 == sqlo_qc_make_cols (sc->sc_so, qc, tree))\n\t  cr_forced_static = 1;\n      }\n    else\n      {\n\tif (!cr_forced_static\n\t    && -1 == qc_make_cols (sc, qc, tree))\n\t  cr_forced_static = 1;\n      }\n    if (!cr_forced_static)\n      {\n\tqc->qc_cursor_type = cr_type;\n\tif (sc->sc_so)\n\t  sqlo_qc_make_stmts (sc->sc_so, qc);\n\telse\n\t  qc_make_stmts (sc, qc);\n      }\n    else\n      {\n\tqc_make_static (sc, qc, ptree);\n\ttree = *ptree;\n      }\n  }\n}", "target": 2, "idx": 9912}
{"commit_id": "8122f6d6d409b53151a20c5578fc525ee97315e8", "project": "poppler", "func": "static void downsample_row_box_filter (\n        int start, int width,\n        uint32_t *src, uint32_t *src_limit, uint32_t *dest,\n        int coverage[], int pixel_coverage)\n{\n    /* we need an array of the pixel contribution of each destination pixel on the boundaries.\n     * we invert the value to get the value on the other size of the box */\n    /*\n\n       value  = a * contribution * 1/box_size\n       value += a * 1/box_size\n       value += a * 1/box_size\n       value += a * 1/box_size\n       value += a * (1 - contribution) * 1/box_size\n                a * (1/box_size - contribution * 1/box_size)\n\n        box size is constant\n\n\n       value = a * contribution_a * 1/box_size + b * contribution_b * 1/box_size\n               contribution_b = (1 - contribution_a)\n                              = (1 - contribution_a_next)\n    */\n\n    /* box size = ceil(src_width/dest_width) */\n    int x = 0;\n\n    /* skip to start */\n    /* XXX: it might be possible to do this directly instead of iteratively, however\n     * the iterative solution is simple */\n    while (x < start && src < src_limit)\n    {\n        int box = 1 << FIXED_SHIFT;\n        int start_coverage = coverage[x];\n        box -= start_coverage;\n        src++;\n        while (box >= pixel_coverage && src < src_limit)\n        {\n            src++;\n            box -= pixel_coverage;\n        }\n        x++;\n    }\n\n    while (x < start + width && src < src_limit)\n    {\n        uint32_t a = 0;\n        uint32_t r = 0;\n        uint32_t g = 0;\n        uint32_t b = 0;\n        int box = 1 << FIXED_SHIFT;\n        int start_coverage = coverage[x];\n\n        a = ((*src >> 24) & 0xff) * start_coverage;\n        r = ((*src >> 16) & 0xff) * start_coverage;\n        g = ((*src >>  8) & 0xff) * start_coverage;\n        b = ((*src >>  0) & 0xff) * start_coverage;\n        src++;\n        x++;\n        box -= start_coverage;\n\n        while (box >= pixel_coverage && src < src_limit)\n        {\n            a += ((*src >> 24) & 0xff) * pixel_coverage;\n            r += ((*src >> 16) & 0xff) * pixel_coverage;\n            g += ((*src >>  8) & 0xff) * pixel_coverage;\n            b += ((*src >>  0) & 0xff) * pixel_coverage;\n            src++;\n\n            box -= pixel_coverage;\n        }\n\n        /* multiply by whatever is leftover\n         * this ensures that we don't bias down.\n         * i.e. start_coverage + n*pixel_coverage + box == 1 << 24 */\n        if (box > 0 && src < src_limit)\n        {\n            a += ((*src >> 24) & 0xff) * box;\n            r += ((*src >> 16) & 0xff) * box;\n            g += ((*src >>  8) & 0xff) * box;\n            b += ((*src >>  0) & 0xff) * box;\n        }\n\n        a >>= FIXED_SHIFT;\n        r >>= FIXED_SHIFT;\n        g >>= FIXED_SHIFT;\n        b >>= FIXED_SHIFT;\n\n        *dest = (a << 24) | (r << 16) | (g << 8) | b;\n        dest++;\n    }\n}", "target": 3, "idx": 9913}
{"commit_id": "4c3e1956ee35fdcc5ffdb28782050164b4623c0b", "project": "ffmpeg", "func": "static int lag_decode_frame(AVCodecContext *avctx,\n                            void *data, int *got_frame, AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    LagarithContext *l = avctx->priv_data;\n    ThreadFrame frame = { .f = data };\n    AVFrame *const p  = data;\n    uint8_t frametype = 0;\n    uint32_t offset_gu = 0, offset_bv = 0, offset_ry = 9;\n    uint32_t offs[4];\n    uint8_t *srcs[4], *dst;\n    int i, j, planes = 3;\n\n    p->key_frame = 1;\n\n    frametype = buf[0];\n\n    offset_gu = AV_RL32(buf + 1);\n    offset_bv = AV_RL32(buf + 5);\n\n    switch (frametype) {\n    case FRAME_SOLID_RGBA:\n        avctx->pix_fmt = AV_PIX_FMT_RGB32;\n\n        if (ff_thread_get_buffer(avctx, &frame, 0) < 0) {\n            av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n            return -1;\n        }\n\n        dst = p->data[0];\n        for (j = 0; j < avctx->height; j++) {\n            for (i = 0; i < avctx->width; i++)\n                AV_WN32(dst + i * 4, offset_gu);\n            dst += p->linesize[0];\n        }\n        break;\n    case FRAME_ARITH_RGBA:\n        avctx->pix_fmt = AV_PIX_FMT_RGB32;\n        planes = 4;\n        offset_ry += 4;\n        offs[3] = AV_RL32(buf + 9);\n    case FRAME_ARITH_RGB24:\n    case FRAME_U_RGB24:\n        if (frametype == FRAME_ARITH_RGB24 || frametype == FRAME_U_RGB24)\n            avctx->pix_fmt = AV_PIX_FMT_RGB24;\n\n        if (ff_thread_get_buffer(avctx, &frame, 0) < 0) {\n            av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n            return -1;\n        }\n\n        offs[0] = offset_bv;\n        offs[1] = offset_gu;\n        offs[2] = offset_ry;\n\n        l->rgb_stride = FFALIGN(avctx->width, 16);\n        av_fast_malloc(&l->rgb_planes, &l->rgb_planes_allocated,\n                       l->rgb_stride * avctx->height * planes + 1);\n        if (!l->rgb_planes) {\n            av_log(avctx, AV_LOG_ERROR, \"cannot allocate temporary buffer\\n\");\n            return AVERROR(ENOMEM);\n        }\n        for (i = 0; i < planes; i++)\n            srcs[i] = l->rgb_planes + (i + 1) * l->rgb_stride * avctx->height - l->rgb_stride;\n        if (offset_ry >= buf_size ||\n            offset_gu >= buf_size ||\n            offset_bv >= buf_size ||\n            (planes == 4 && offs[3] >= buf_size)) {\n            av_log(avctx, AV_LOG_ERROR,\n                    \"Invalid frame offsets\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        for (i = 0; i < planes; i++)\n            lag_decode_arith_plane(l, srcs[i],\n                                   avctx->width, avctx->height,\n                                   -l->rgb_stride, buf + offs[i],\n                                   buf_size - offs[i]);\n        dst = p->data[0];\n        for (i = 0; i < planes; i++)\n            srcs[i] = l->rgb_planes + i * l->rgb_stride * avctx->height;\n        for (j = 0; j < avctx->height; j++) {\n            for (i = 0; i < avctx->width; i++) {\n                uint8_t r, g, b, a;\n                r = srcs[0][i];\n                g = srcs[1][i];\n                b = srcs[2][i];\n                r += g;\n                b += g;\n                if (frametype == FRAME_ARITH_RGBA) {\n                    a = srcs[3][i];\n                    AV_WN32(dst + i * 4, MKBETAG(a, r, g, b));\n                } else {\n                    dst[i * 3 + 0] = r;\n                    dst[i * 3 + 1] = g;\n                    dst[i * 3 + 2] = b;\n                }\n            }\n            dst += p->linesize[0];\n            for (i = 0; i < planes; i++)\n                srcs[i] += l->rgb_stride;\n        }\n        break;\n    case FRAME_ARITH_YUY2:\n        avctx->pix_fmt = AV_PIX_FMT_YUV422P;\n\n        if (ff_thread_get_buffer(avctx, &frame, 0) < 0) {\n            av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n            return -1;\n        }\n\n        if (offset_ry >= buf_size ||\n            offset_gu >= buf_size ||\n            offset_bv >= buf_size) {\n            av_log(avctx, AV_LOG_ERROR,\n                   \"Invalid frame offsets\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n\n        lag_decode_arith_plane(l, p->data[0], avctx->width, avctx->height,\n                               p->linesize[0], buf + offset_ry,\n                               buf_size - offset_ry);\n        lag_decode_arith_plane(l, p->data[1], avctx->width / 2,\n                               avctx->height, p->linesize[1],\n                               buf + offset_gu, buf_size - offset_gu);\n        lag_decode_arith_plane(l, p->data[2], avctx->width / 2,\n                               avctx->height, p->linesize[2],\n                               buf + offset_bv, buf_size - offset_bv);\n        break;\n    case FRAME_ARITH_YV12:\n        avctx->pix_fmt = AV_PIX_FMT_YUV420P;\n\n        if (ff_thread_get_buffer(avctx, &frame, 0) < 0) {\n            av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n            return -1;\n        }\n\n        if (offset_ry >= buf_size ||\n            offset_gu >= buf_size ||\n            offset_bv >= buf_size) {\n            av_log(avctx, AV_LOG_ERROR,\n                   \"Invalid frame offsets\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n\n        lag_decode_arith_plane(l, p->data[0], avctx->width, avctx->height,\n                               p->linesize[0], buf + offset_ry,\n                               buf_size - offset_ry);\n        lag_decode_arith_plane(l, p->data[2], avctx->width / 2,\n                               avctx->height / 2, p->linesize[2],\n                               buf + offset_gu, buf_size - offset_gu);\n        lag_decode_arith_plane(l, p->data[1], avctx->width / 2,\n                               avctx->height / 2, p->linesize[1],\n                               buf + offset_bv, buf_size - offset_bv);\n        break;\n    default:\n        av_log(avctx, AV_LOG_ERROR,\n               \"Unsupported Lagarith frame type: %#x\\n\", frametype);\n        return -1;\n    }\n\n    *got_frame = 1;\n\n    return buf_size;\n}", "target": 2, "idx": 9914}
{"commit_id": "5c114c91d4ff31859fcd84cf8bf349b737b90d99", "project": "mruby", "func": "static void\nmark_context_stack(mrb_state *mrb, struct mrb_context *c)\n{\n  size_t i;\n  size_t e;\n  mrb_value nil;\n\n  if (c->stack == NULL) return;\n  e = c->stack - c->stbase;\n  if (c->ci) e += c->ci->nregs;\n  if (c->stbase + e > c->stend) e = c->stend - c->stbase;\n  for (i=0; i<e; i++) {\n    mrb_value v = c->stbase[i];\n\n    if (!mrb_immediate_p(v)) {\n      mrb_gc_mark(mrb, mrb_basic_ptr(v));\n    }\n  }\n  e = c->stend - c->stbase;\n  nil = mrb_nil_value();\n  for (; i<e; i++) {\n    c->stbase[i] = nil;\n  }\n}", "target": 2, "idx": 9915}
{"commit_id": "7edc761a01cda8e1b37677f673985582330317d2", "project": "wireshark", "func": "static gboolean k12_seek_read(wtap *wth, gint64 seek_off, struct wtap_pkthdr *phdr, Buffer *buf, int *err, gchar **err_info) {\n    k12_t *k12 = (k12_t *)wth->priv;\n    guint8* buffer;\n    gint len;\n    gboolean status;\n\n    K12_DBG(5,(\"k12_seek_read: ENTER\"));\n\n    if ( file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1) {\n        K12_DBG(5,(\"k12_seek_read: SEEK ERROR\"));\n        return FALSE;\n    }\n\n    len = get_record(k12, wth->random_fh, seek_off, TRUE, err, err_info);\n    if (len < 0) {\n        K12_DBG(5,(\"k12_seek_read: READ ERROR\"));\n        return FALSE;\n    } else if (len < K12_RECORD_SRC_ID + 4) {\n        /* Record not large enough to contain a src ID */\n        K12_DBG(5,(\"k12_seek_read: SHORT READ\"));\n        *err = WTAP_ERR_SHORT_READ;\n        return FALSE;\n    }\n\n    buffer = k12->rand_read_buff;\n\n    status = process_packet_data(phdr, buf, buffer, (guint)len, k12, err, err_info);\n\n    K12_DBG(5,(\"k12_seek_read: DONE OK\"));\n\n    return status;\n}", "target": 2, "idx": 9916}
{"commit_id": "e045199c7c9c5433d7f1461a741ed539a75cbfad", "project": "xen-project/xen", "func": "static bool_t evtchn_fifo_is_busy(const struct domain *d,\n                                  const struct evtchn *evtchn)\n{\n    const event_word_t *word = evtchn_fifo_word_from_port(d, evtchn->port);\n\n    return word && guest_test_bit(d, EVTCHN_FIFO_LINKED, word);\n}", "target": 2, "idx": 9917}
{"commit_id": "6b7339f4c31ad69c8e9c0b2859276e22cf72176d", "project": "torvalds/linux", "func": "static int do_fault(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long address, pte_t *page_table, pmd_t *pmd,\n\t\tunsigned int flags, pte_t orig_pte)\n{\n\tpgoff_t pgoff = (((address & PAGE_MASK)\n\t\t\t- vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\n\tpte_unmap(page_table);\n\t/* The VMA was not fully populated on mmap() or missing VM_DONTEXPAND */\n\tif (!vma->vm_ops->fault)\n\t\treturn VM_FAULT_SIGBUS;\n\tif (!(flags & FAULT_FLAG_WRITE))\n\t\treturn do_read_fault(mm, vma, address, pmd, pgoff, flags,\n\t\t\t\torig_pte);\n\tif (!(vma->vm_flags & VM_SHARED))\n\t\treturn do_cow_fault(mm, vma, address, pmd, pgoff, flags,\n\t\t\t\torig_pte);\n\treturn do_shared_fault(mm, vma, address, pmd, pgoff, flags, orig_pte);\n}", "target": 2, "idx": 9918}
{"commit_id": "a4f247707f08e322f0b41e82c3e06e224240a654", "project": "jsummers/imageworsener", "func": "static int iw_process_rows_intermediate_to_final(struct iw_context *ctx, int intermed_channel,\n\tconst struct iw_csdescr *out_csdescr)\n{\n\tint i,j;\n\tint z;\n\tint k;\n\tint retval=0;\n\tiw_tmpsample tmpsamp;\n\tiw_tmpsample alphasamp = 0.0;\n\tiw_tmpsample *inpix_tofree = NULL; // Used if we need a separate temp buffer for input samples\n\tiw_tmpsample *outpix_tofree = NULL; // Used if we need a separate temp buffer for output samples\n\t// Do any of the output channels use error-diffusion dithering?\n\tint using_errdiffdither = 0;\n\tint output_channel;\n\tint is_alpha_channel;\n\tint bkgd_has_transparency;\n\tdouble tmpbkgdalpha=0.0;\n\tint alt_bkgd = 0; // Nonzero if we should use bkgd2 for this sample\n\tstruct iw_resize_settings *rs = NULL;\n\tint ditherfamily, dithersubtype;\n\tstruct iw_channelinfo_intermed *int_ci;\n\tstruct iw_channelinfo_out *out_ci;\n\n\tiw_tmpsample *in_pix = NULL;\n\tiw_tmpsample *out_pix = NULL;\n\tint num_in_pix;\n\tint num_out_pix;\n\tstruct iw_channelinfo_out default_ci_out;\n\n\tnum_in_pix = ctx->intermed_canvas_width;\n\tnum_out_pix = ctx->img2.width;\n\n\tint_ci = &ctx->intermed_ci[intermed_channel];\n\toutput_channel = int_ci->corresponding_output_channel;\n\tif(output_channel>=0) {\n\t\tout_ci = &ctx->img2_ci[output_channel];\n\t}\n\telse {\n\t\t// If there is no output channelinfo struct, create a temporary one to\n\t\t// use.\n\t\t// TODO: This is admittedly ugly, but we use these settings for a few\n\t\t// things even when there is no corresponding output channel, and I\n\t\t// don't remember exactly why.\n\t\tiw_zeromem(&default_ci_out, sizeof(struct iw_channelinfo_out));\n\t\tdefault_ci_out.channeltype = IW_CHANNELTYPE_NONALPHA;\n\t\tout_ci = &default_ci_out;\n\t}\n\n\tis_alpha_channel = (int_ci->channeltype==IW_CHANNELTYPE_ALPHA);\n\tbkgd_has_transparency = iw_bkgd_has_transparency(ctx);\n\n\tinpix_tofree = (iw_tmpsample*)iw_malloc(ctx, num_in_pix * sizeof(iw_tmpsample));\n\tin_pix = inpix_tofree;\n\n\t// We need an output buffer.\n\toutpix_tofree = (iw_tmpsample*)iw_malloc(ctx, num_out_pix * sizeof(iw_tmpsample));\n\tif(!outpix_tofree) goto done;\n\tout_pix = outpix_tofree;\n\n\t// Decide if the 'nearest color table' optimization can be used\n\tif(ctx->nearest_color_table && !is_alpha_channel &&\n\t   out_ci->ditherfamily==IW_DITHERFAMILY_NONE &&\n\t   out_ci->color_count==0)\n\t{\n\t\tout_ci->use_nearest_color_table = 1;\n\t}\n\telse {\n\t\tout_ci->use_nearest_color_table = 0;\n\t}\n\n\t// Seed the PRNG, if necessary.\n\tditherfamily = out_ci->ditherfamily;\n\tdithersubtype = out_ci->dithersubtype;\n\tif(ditherfamily==IW_DITHERFAMILY_RANDOM) {\n\t\t// Decide what random seed to use. The alpha channel always has its own\n\t\t// seed. If using \"r\" (not \"r2\") dithering, every channel has its own seed.\n\t\tif(dithersubtype==IW_DITHERSUBTYPE_SAMEPATTERN && out_ci->channeltype!=IW_CHANNELTYPE_ALPHA)\n\t\t{\n\t\t\tiwpvt_prng_set_random_seed(ctx->prng,ctx->random_seed);\n\t\t}\n\t\telse {\n\t\t\tiwpvt_prng_set_random_seed(ctx->prng,ctx->random_seed+out_ci->channeltype);\n\t\t}\n\t}\n\n\t// Initialize Floyd-Steinberg dithering.\n\tif(output_channel>=0 && out_ci->ditherfamily==IW_DITHERFAMILY_ERRDIFF) {\n\t\tusing_errdiffdither = 1;\n\t\tfor(i=0;i<ctx->img2.width;i++) {\n\t\t\tfor(k=0;k<IW_DITHER_MAXROWS;k++) {\n\t\t\t\tctx->dither_errors[k][i] = 0.0;\n\t\t\t}\n\t\t}\n\t}\n\n\trs=&ctx->resize_settings[IW_DIMENSION_H];\n\n\t// If the resize context for this dimension already exists, we should be\n\t// able to reuse it. Otherwise, create a new one.\n\tif(!rs->rrctx) {\n\t\trs->rrctx = iwpvt_resize_rows_init(ctx,rs,int_ci->channeltype,\n\t\t\tnum_in_pix, num_out_pix);\n\t\tif(!rs->rrctx) goto done;\n\t}\n\n\tfor(j=0;j<ctx->intermed_canvas_height;j++) {\n\n\t\t// As needed, either copy the input pixels to a temp buffer (inpix, which\n\t\t// ctx->in_pix already points to), or point ctx->in_pix directly to the\n\t\t// intermediate data.\n\t\tif(is_alpha_channel) {\n\t\t\tfor(i=0;i<num_in_pix;i++) {\n\t\t\t\tinpix_tofree[i] = ctx->intermediate_alpha32[((size_t)j)*ctx->intermed_canvas_width+i];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor(i=0;i<num_in_pix;i++) {\n\t\t\t\tinpix_tofree[i] = ctx->intermediate32[((size_t)j)*ctx->intermed_canvas_width+i];\n\t\t\t}\n\t\t}\n\n\t\t// Resize ctx->in_pix to ctx->out_pix.\n\t\tiwpvt_resize_row_main(rs->rrctx,in_pix,out_pix);\n\n\t\tif(ctx->intclamp)\n\t\t\tclamp_output_samples(ctx,out_pix,num_out_pix);\n\n\t\t// If necessary, copy the resized samples to the final_alpha image\n\t\tif(is_alpha_channel && outpix_tofree && ctx->final_alpha32) {\n\t\t\tfor(i=0;i<num_out_pix;i++) {\n\t\t\t\tctx->final_alpha32[((size_t)j)*ctx->img2.width+i] = (iw_float32)outpix_tofree[i];\n\t\t\t}\n\t\t}\n\n\t\t// Now convert the out_pix and put them in the final image.\n\n\t\tif(output_channel == -1) {\n\t\t\t// No corresponding output channel.\n\t\t\t// (Presumably because this is an alpha channel that's being\n\t\t\t// removed because we're applying a background.)\n\t\t\tgoto here;\n\t\t}\n\n\t\tfor(z=0;z<ctx->img2.width;z++) {\n\t\t\t// For decent Floyd-Steinberg dithering, we need to process alternate\n\t\t\t// rows in reverse order.\n\t\t\tif(using_errdiffdither && (j%2))\n\t\t\t\ti=ctx->img2.width-1-z;\n\t\t\telse\n\t\t\t\ti=z;\n\n\t\t\ttmpsamp = out_pix[i];\n\n\t\t\tif(ctx->bkgd_checkerboard) {\n\t\t\t\talt_bkgd = (((ctx->bkgd_check_origin[IW_DIMENSION_H]+i)/ctx->bkgd_check_size)%2) !=\n\t\t\t\t\t(((ctx->bkgd_check_origin[IW_DIMENSION_V]+j)/ctx->bkgd_check_size)%2);\n\t\t\t}\n\n\t\t\tif(bkgd_has_transparency) {\n\t\t\t\ttmpbkgdalpha = alt_bkgd ? ctx->bkgd2alpha : ctx->bkgd1alpha;\n\t\t\t}\n\n\t\t\tif(int_ci->need_unassoc_alpha_processing) {\n\t\t\t\t// Convert color samples back to unassociated alpha.\n\t\t\t\talphasamp = ctx->final_alpha32[((size_t)j)*ctx->img2.width + i];\n\n\t\t\t\tif(alphasamp!=0.0) {\n\t\t\t\t\ttmpsamp /= alphasamp;\n\t\t\t\t}\n\n\t\t\t\tif(ctx->apply_bkgd && ctx->apply_bkgd_strategy==IW_BKGD_STRATEGY_LATE) {\n\t\t\t\t\t// Apply a background color (or checkerboard pattern).\n\t\t\t\t\tdouble bkcolor;\n\t\t\t\t\tbkcolor = alt_bkgd ? out_ci->bkgd2_color_lin : out_ci->bkgd1_color_lin;\n\n\t\t\t\t\tif(bkgd_has_transparency) {\n\t\t\t\t\t\ttmpsamp = tmpsamp*alphasamp + bkcolor*tmpbkgdalpha*(1.0-alphasamp);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttmpsamp = tmpsamp*alphasamp + bkcolor*(1.0-alphasamp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(is_alpha_channel && bkgd_has_transparency) {\n\t\t\t\t// Composite the alpha of the foreground over the alpha of the background.\n\t\t\t\ttmpsamp = tmpsamp + tmpbkgdalpha*(1.0-tmpsamp);\n\t\t\t}\n\n\t\t\tif(ctx->img2.sampletype==IW_SAMPLETYPE_FLOATINGPOINT)\n\t\t\t\tput_sample_convert_from_linear_flt(ctx,tmpsamp,i,j,output_channel,out_csdescr);\n\t\t\telse\n\t\t\t\tput_sample_convert_from_linear(ctx,tmpsamp,i,j,output_channel,out_csdescr);\n\n\t\t}\n\n\t\tif(using_errdiffdither) {\n\t\t\t// Move \"next row\" error data to \"this row\", and clear the \"next row\".\n\t\t\t// TODO: Obviously, it would be more efficient to just swap pointers\n\t\t\t// to the rows.\n\t\t\tfor(i=0;i<ctx->img2.width;i++) {\n\t\t\t\t// Move data in all rows but the first row up one row.\n\t\t\t\tfor(k=0;k<IW_DITHER_MAXROWS-1;k++) {\n\t\t\t\t\tctx->dither_errors[k][i] = ctx->dither_errors[k+1][i];\n\t\t\t\t}\n\t\t\t\t// Clear the last row.\n\t\t\t\tctx->dither_errors[IW_DITHER_MAXROWS-1][i] = 0.0;\n\t\t\t}\n\t\t}\n\nhere:\n\t\t;\n\t}\n\n\tretval=1;\n\ndone:\n\tif(rs && rs->disable_rrctx_cache && rs->rrctx) {\n\t\t// In some cases, the channels may need different resize contexts.\n\t\t// Delete the current context, so that it doesn't get reused.\n\t\tiwpvt_resize_rows_done(rs->rrctx);\n\t\trs->rrctx = NULL;\n\t}\n\tif(inpix_tofree) iw_free(ctx,inpix_tofree);\n\tif(outpix_tofree) iw_free(ctx,outpix_tofree);\n\n\treturn retval;\n}", "target": 1, "idx": 9919}
{"commit_id": "5e0ecfb42f5f65629fd7a4edd6c4afe7ff0feb04", "project": "tensorflow", "func": "void Compute(OpKernelContext *ctx) override {\n    const Tensor *a_indices_t, *a_values_t, *a_shape_t, *b_indices_t,\n        *b_values_t, *b_shape_t;\n    OP_REQUIRES_OK(ctx, ctx->input(\"a_indices\", &a_indices_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"a_values\", &a_values_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"a_shape\", &a_shape_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"b_indices\", &b_indices_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"b_values\", &b_values_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"b_shape\", &b_shape_t));\n\n    // Validations.\n    OP_REQUIRES_OK(ctx, sparse_utils::ValidateSparseTensor<int64_t>(\n                            *a_indices_t, *a_values_t, *a_shape_t,\n                            sparse_utils::IndexValidation::kUnordered));\n    OP_REQUIRES_OK(ctx, sparse_utils::ValidateSparseTensor<int64_t>(\n                            *b_indices_t, *b_values_t, *b_shape_t,\n                            sparse_utils::IndexValidation::kUnordered));\n\n    const int64_t a_nnz = a_indices_t->dim_size(0);\n    const int64_t b_nnz = b_indices_t->dim_size(0);\n\n    const auto a_values = a_values_t->vec<T>();\n    const auto b_values = b_values_t->vec<T>();\n\n    const int num_dims = a_indices_t->dim_size(1);\n    OP_REQUIRES(ctx, num_dims > 0,\n                errors::InvalidArgument(\"Tensors must not be empty\"));\n    OP_REQUIRES(ctx, a_shape_t->IsSameSize(*b_shape_t),\n                errors::InvalidArgument(\n                    \"Operands do not have the same ranks; got shapes: \",\n                    a_shape_t->SummarizeValue(10), \" and \",\n                    b_shape_t->SummarizeValue(10)));\n    const auto a_shape = a_shape_t->flat<int64_t>();\n    const auto b_shape = b_shape_t->flat<int64_t>();\n    for (int i = 0; i < a_shape_t->NumElements(); ++i) {\n      OP_REQUIRES(ctx, a_shape(i) == b_shape(i),\n                  errors::InvalidArgument(\"Operands' shapes do not match: got \",\n                                          a_shape(i), \" and \", b_shape(i),\n                                          \" for dimension \", i));\n    }\n\n    const auto a_indices_mat = a_indices_t->matrix<int64_t>();\n    const auto b_indices_mat = b_indices_t->matrix<int64_t>();\n    std::vector<T> a_augmented_values, b_augmented_values;\n    std::vector<std::pair<bool, int64_t>> entries_to_copy;  // from_a?, idx\n    UnionSparseIndicesAndValues(a_indices_mat, a_values, a_nnz, b_indices_mat,\n                                b_values, b_nnz, num_dims, &a_augmented_values,\n                                &b_augmented_values, &entries_to_copy);\n\n    // Allocates and fills output tensors.\n    const int64_t sum_nnz = a_augmented_values.size();\n    Tensor *output_indices_t, *output_values_t;\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_output(0, TensorShape({sum_nnz, num_dims}),\n                                        &output_indices_t));\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_output(1, TensorShape({sum_nnz}), &output_values_t));\n    auto output_indices_mat = output_indices_t->matrix<int64_t>();\n\n    for (int64_t i = 0; i < sum_nnz; ++i) {\n      const bool from_a = entries_to_copy[i].first;\n      const int64_t idx = entries_to_copy[i].second;\n      output_indices_mat.chip<0>(i) =\n          from_a ? a_indices_mat.chip<0>(idx) : b_indices_mat.chip<0>(idx);\n    }\n\n    // Performs the functor operation using Eigen.\n    //\n    // Note that the two stack-allocated std::vector's may not be aligned. Using\n    // allocate_temp() would've given us aligned storage, but we do not know\n    // their sizes in advance, so we couldn't use allocate_temp() anyway.\n    //\n    // TODO(zongheng): measure if it's worthwhile to somehow force alignment.\n    using UnalignedTensorMap =\n        Eigen::TensorMap<Eigen::Tensor<const T, 1, Eigen::RowMajor>,\n                         Eigen::Unaligned>;\n    auto a_augmented_values_t =\n        UnalignedTensorMap(a_augmented_values.data(), sum_nnz);\n    auto b_augmented_values_t =\n        UnalignedTensorMap(b_augmented_values.data(), sum_nnz);\n    output_values_t->flat<T>().device(ctx->eigen_device<Device>()) =\n        a_augmented_values_t.binaryExpr(b_augmented_values_t,\n                                        typename Functor::func());\n  }", "target": 2, "idx": 9920}
{"commit_id": "7dac4a1726a9c64a517d595c40e95e2d0d135f6f", "project": "kernel/git/tytso/ext4", "func": "static struct buffer_head *\next4_read_inode_bitmap(struct super_block *sb, ext4_group_t block_group)\n{\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct buffer_head *bh = NULL;\n\text4_fsblk_t bitmap_blk;\n\tint err;\n\n\tdesc = ext4_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\n\tbitmap_blk = ext4_inode_bitmap(sb, desc);\n\tif ((bitmap_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||\n\t    (bitmap_blk >= ext4_blocks_count(sbi->s_es))) {\n\t\text4_error(sb, \"Invalid inode bitmap blk %llu in \"\n\t\t\t   \"block_group %u\", bitmap_blk, block_group);\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\t}\n\tbh = sb_getblk(sb, bitmap_blk);\n\tif (unlikely(!bh)) {\n\t\text4_error(sb, \"Cannot read inode bitmap - \"\n\t\t\t    \"block_group = %u, inode_bitmap = %llu\",\n\t\t\t    block_group, bitmap_blk);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tif (bitmap_uptodate(bh))\n\t\tgoto verify;\n\n\tlock_buffer(bh);\n\tif (bitmap_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\tgoto verify;\n\t}\n\n\text4_lock_group(sb, block_group);\n\tif (desc->bg_flags & cpu_to_le16(EXT4_BG_INODE_UNINIT)) {\n\t\tmemset(bh->b_data, 0, (EXT4_INODES_PER_GROUP(sb) + 7) / 8);\n\t\text4_mark_bitmap_end(EXT4_INODES_PER_GROUP(sb),\n\t\t\t\t     sb->s_blocksize * 8, bh->b_data);\n\t\tset_bitmap_uptodate(bh);\n\t\tset_buffer_uptodate(bh);\n\t\tset_buffer_verified(bh);\n\t\text4_unlock_group(sb, block_group);\n\t\tunlock_buffer(bh);\n\t\treturn bh;\n\t}\n\text4_unlock_group(sb, block_group);\n\n\tif (buffer_uptodate(bh)) {\n\t\t/*\n\t\t * if not uninit if bh is uptodate,\n\t\t * bitmap is also uptodate\n\t\t */\n\t\tset_bitmap_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\tgoto verify;\n\t}\n\t/*\n\t * submit the buffer_head for reading\n\t */\n\ttrace_ext4_load_inode_bitmap(sb, block_group);\n\tbh->b_end_io = ext4_end_bitmap_read;\n\tget_bh(bh);\n\tsubmit_bh(REQ_OP_READ, REQ_META | REQ_PRIO, bh);\n\twait_on_buffer(bh);\n\tif (!buffer_uptodate(bh)) {\n\t\tput_bh(bh);\n\t\text4_error(sb, \"Cannot read inode bitmap - \"\n\t\t\t   \"block_group = %u, inode_bitmap = %llu\",\n\t\t\t   block_group, bitmap_blk);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\nverify:\n\terr = ext4_validate_inode_bitmap(sb, desc, block_group, bh);\n\tif (err)\n\t\tgoto out;\n\treturn bh;\nout:\n\tput_bh(bh);\n\treturn ERR_PTR(err);\n}", "target": 1, "idx": 9921}
{"commit_id": "c800e2987b10bb3af6ef644b515b5d6392f8861d", "project": "open62541", "func": "static status\naddMultiArrayContentJSON(CtxJson *ctx, void* array, const UA_DataType *type, \n                         size_t *index, UA_UInt32 *arrayDimensions, size_t dimensionIndex, \n                         size_t dimensionSize) {\n    /* Check the recursion limit */\n    if(ctx->depth >= UA_JSON_ENCODING_MAX_RECURSION)\n        return UA_STATUSCODE_BADENCODINGERROR;\n    \n    /* Stop recursion: The inner Arrays are written */\n    status ret;\n    if(dimensionIndex == (dimensionSize - 1)) {\n        ret = encodeJsonArray(ctx, ((u8*)array) + (type->memSize * *index),\n                              arrayDimensions[dimensionIndex], type);\n        (*index) += arrayDimensions[dimensionIndex];\n        return ret;\n    }\n\n    /* Recurse to the next dimension */\n    ret = writeJsonArrStart(ctx);\n    for(size_t i = 0; i < arrayDimensions[dimensionIndex]; i++) {\n        ret |= writeJsonCommaIfNeeded(ctx);\n        ret |= addMultiArrayContentJSON(ctx, array, type, index, arrayDimensions,\n                                        dimensionIndex + 1, dimensionSize);\n        ctx->commaNeeded[ctx->depth] = true;\n        if(ret != UA_STATUSCODE_GOOD)\n            return ret;\n    }\n    ret |= writeJsonArrEnd(ctx);\n    return ret;\n}", "target": 1, "idx": 9922}
{"commit_id": "8d1d605b3d8c49bdfe9376454f0196738bed8166", "project": "upx", "func": "Elf32_Sym const *PackLinuxElf32::elf_lookup(char const *name) const\n{\n    if (hashtab && dynsym && dynstr) {\n        unsigned const nbucket = get_te32(&hashtab[0]);\n        unsigned const *const buckets = &hashtab[2];\n        unsigned const *const chains = &buckets[nbucket];\n        if (!nbucket\n        ||  (unsigned)(file_size - ((char const *)buckets - (char const *)(void const *)file_image))\n                <= sizeof(unsigned)*nbucket ) {\n            char msg[80]; snprintf(msg, sizeof(msg),\n                \"bad nbucket %#x\\n\", nbucket);\n            throwCantPack(msg);\n        }\n        unsigned const m = elf_hash(name) % nbucket;\n        unsigned si;\n        for (si= get_te32(&buckets[m]); 0!=si; si= get_te32(&chains[si])) {\n            char const *const p= get_dynsym_name(si, (unsigned)-1);\n            if (0==strcmp(name, p)) {\n                return &dynsym[si];\n            }\n        }\n    }\n    if (gashtab && dynsym && dynstr) {\n        unsigned const n_bucket = get_te32(&gashtab[0]);\n        unsigned const symbias  = get_te32(&gashtab[1]);\n        unsigned const n_bitmask = get_te32(&gashtab[2]);\n        unsigned const gnu_shift = get_te32(&gashtab[3]);\n        unsigned const *const bitmask = &gashtab[4];\n        unsigned const *const buckets = &bitmask[n_bitmask];\n        unsigned const *const hasharr = &buckets[n_bucket];\n        if (!n_bucket\n        || (void const *)&file_image[file_size] <= (void const *)hasharr) {\n            char msg[80]; snprintf(msg, sizeof(msg),\n                \"bad n_bucket %#x\\n\", n_bucket);\n            throwCantPack(msg);\n        }\n        if (!n_bitmask\n        || (unsigned)(file_size - ((char const *)bitmask - (char const *)(void const *)file_image))\n                <= sizeof(unsigned)*n_bitmask ) {\n            char msg[80]; snprintf(msg, sizeof(msg),\n                \"bad n_bitmask %#x\\n\", n_bitmask);\n            throwCantPack(msg);\n        }\n\n        unsigned const h = gnu_hash(name);\n        unsigned const hbit1 = 037& h;\n        unsigned const hbit2 = 037& (h>>gnu_shift);\n        unsigned const w = get_te32(&bitmask[(n_bitmask -1) & (h>>5)]);\n\n        if (1& (w>>hbit1) & (w>>hbit2)) {\n            unsigned bucket = get_te32(&buckets[h % n_bucket]);\n            if (n_bucket <= bucket) {\n                char msg[80]; snprintf(msg, sizeof(msg),\n                        \"bad DT_GNU_HASH n_bucket{%#x} <= buckets[%d]{%#x}\\n\",\n                        n_bucket, h % n_bucket, bucket);\n                throwCantPack(msg);\n            }\n            if (0!=bucket) {\n                Elf32_Sym const *dsp = &dynsym[bucket];\n                unsigned const *hp = &hasharr[bucket - symbias];\n\n                do if (0==((h ^ get_te32(hp))>>1)) {\n                    unsigned st_name = get_te32(&dsp->st_name);\n                    char const *const p = get_str_name(st_name, (unsigned)-1);\n                    if (0==strcmp(name, p)) {\n                        return dsp;\n                    }\n                } while (++dsp,\n                        (char const *)hp < (char const *)&file_image[file_size]\n                    &&  0==(1u& get_te32(hp++)));\n            }\n        }\n    }\n    return 0;\n\n}", "target": 1, "idx": 9923}
{"commit_id": "b4d6cf6836ce025ba1811b7bbec52680c7204223", "project": "qpdf", "func": "QPDFObjectHandle\nQPDFObjectHandle::parseInternal(PointerHolder<InputSource> input,\n                                std::string const& object_description,\n                                QPDFTokenizer& tokenizer, bool& empty,\n                                StringDecrypter* decrypter, QPDF* context,\n                                bool content_stream)\n{\n    // This method must take care not to resolve any objects. Don't\n    // check the type of any object without first ensuring that it is\n    // a direct object. Otherwise, doing so may have the side effect\n    // of reading the object and changing the file pointer.\n\n    empty = false;\n\n    QPDFObjectHandle object;\n\n    std::vector<std::vector<QPDFObjectHandle> > olist_stack;\n    olist_stack.push_back(std::vector<QPDFObjectHandle>());\n    std::vector<parser_state_e> state_stack;\n    state_stack.push_back(st_top);\n    std::vector<qpdf_offset_t> offset_stack;\n    qpdf_offset_t offset = input->tell();\n    offset_stack.push_back(offset);\n    bool done = false;\n    while (! done)\n    {\n        std::vector<QPDFObjectHandle>& olist = olist_stack.back();\n        parser_state_e state = state_stack.back();\n        offset = offset_stack.back();\n\n\tobject = QPDFObjectHandle();\n\n\tQPDFTokenizer::Token token =\n            tokenizer.readToken(input, object_description, true);\n\n\tswitch (token.getType())\n\t{\n          case QPDFTokenizer::tt_eof:\n            if (! content_stream)\n            {\n                QTC::TC(\"qpdf\", \"QPDFObjectHandle eof in parseInternal\");\n                warn(context,\n                     QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                             object_description,\n                             input->getLastOffset(),\n                             \"unexpected EOF\"));\n            }\n            state = st_eof;\n            break;\n\n          case QPDFTokenizer::tt_bad:\n\t    QTC::TC(\"qpdf\", \"QPDFObjectHandle bad token in parse\");\n            warn(context,\n                 QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                         object_description,\n                         input->getLastOffset(),\n                         token.getErrorMessage()));\n            object = newNull();\n\t    break;\n\n\t  case QPDFTokenizer::tt_brace_open:\n\t  case QPDFTokenizer::tt_brace_close:\n\t    QTC::TC(\"qpdf\", \"QPDFObjectHandle bad brace\");\n            warn(context,\n                 QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                         object_description,\n                         input->getLastOffset(),\n                         \"treating unexpected brace token as null\"));\n            object = newNull();\n\t    break;\n\n\t  case QPDFTokenizer::tt_array_close:\n\t    if (state == st_array)\n\t    {\n                state = st_stop;\n\t    }\n\t    else\n\t    {\n\t\tQTC::TC(\"qpdf\", \"QPDFObjectHandle bad array close\");\n                warn(context,\n                     QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                             object_description,\n                             input->getLastOffset(),\n                             \"treating unexpected array close token as null\"));\n                object = newNull();\n\t    }\n\t    break;\n\n\t  case QPDFTokenizer::tt_dict_close:\n\t    if (state == st_dictionary)\n\t    {\n                state = st_stop;\n\t    }\n\t    else\n\t    {\n\t\tQTC::TC(\"qpdf\", \"QPDFObjectHandle bad dictionary close\");\n                warn(context,\n                     QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                             object_description,\n                             input->getLastOffset(),\n                             \"unexpected dictionary close token\"));\n                object = newNull();\n\t    }\n\t    break;\n\n\t  case QPDFTokenizer::tt_array_open:\n\t  case QPDFTokenizer::tt_dict_open:\n            if (olist_stack.size() > 500)\n            {\n\t\tQTC::TC(\"qpdf\", \"QPDFObjectHandle too deep\");\n                warn(context,\n                     QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                             object_description,\n                             input->getLastOffset(),\n                             \"ignoring excessively deeply nested data structure\"));\n                object = newNull();\n                state = st_top;\n            }\n            else\n            {\n                olist_stack.push_back(std::vector<QPDFObjectHandle>());\n                state = st_start;\n                offset_stack.push_back(input->tell());\n                state_stack.push_back(\n                    (token.getType() == QPDFTokenizer::tt_array_open) ?\n                    st_array : st_dictionary);\n            }\n\t    break;\n\n\t  case QPDFTokenizer::tt_bool:\n\t    object = newBool((token.getValue() == \"true\"));\n\t    break;\n\n\t  case QPDFTokenizer::tt_null:\n\t    object = newNull();\n\t    break;\n\n\t  case QPDFTokenizer::tt_integer:\n\t    object = newInteger(QUtil::string_to_ll(token.getValue().c_str()));\n\t    break;\n\n\t  case QPDFTokenizer::tt_real:\n\t    object = newReal(token.getValue());\n\t    break;\n\n\t  case QPDFTokenizer::tt_name:\n\t    object = newName(token.getValue());\n\t    break;\n\n\t  case QPDFTokenizer::tt_word:\n\t    {\n\t\tstd::string const& value = token.getValue();\n                if (content_stream)\n                {\n                    object = QPDFObjectHandle::newOperator(value);\n                }\n\t\telse if ((value == \"R\") && (state != st_top) &&\n                         (olist.size() >= 2) &&\n                         (! olist.at(olist.size() - 1).isIndirect()) &&\n                         (olist.at(olist.size() - 1).isInteger()) &&\n                         (! olist.at(olist.size() - 2).isIndirect()) &&\n                         (olist.at(olist.size() - 2).isInteger()))\n\t\t{\n                    if (context == 0)\n                    {\n                        QTC::TC(\"qpdf\", \"QPDFObjectHandle indirect without context\");\n                        throw std::logic_error(\n                            \"QPDFObjectHandle::parse called without context\"\n                            \" on an object with indirect references\");\n                    }\n\t\t    // Try to resolve indirect objects\n\t\t    object = newIndirect(\n\t\t\tcontext,\n\t\t\tolist.at(olist.size() - 2).getIntValue(),\n\t\t\tolist.at(olist.size() - 1).getIntValue());\n\t\t    olist.pop_back();\n\t\t    olist.pop_back();\n\t\t}\n\t\telse if ((value == \"endobj\") && (state == st_top))\n\t\t{\n\t\t    // We just saw endobj without having read\n\t\t    // anything.  Treat this as a null and do not move\n\t\t    // the input source's offset.\n\t\t    object = newNull();\n\t\t    input->seek(input->getLastOffset(), SEEK_SET);\n                    empty = true;\n\t\t}\n\t\telse\n\t\t{\n                    QTC::TC(\"qpdf\", \"QPDFObjectHandle treat word as string\");\n                    warn(context,\n                         QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                                 object_description,\n                                 input->getLastOffset(),\n                                 \"unknown token while reading object;\"\n                                 \" treating as string\"));\n                    object = newString(value);\n\t\t}\n\t    }\n\t    break;\n\n\t  case QPDFTokenizer::tt_string:\n\t    {\n\t\tstd::string val = token.getValue();\n                if (decrypter)\n                {\n                    decrypter->decryptString(val);\n                }\n\t\tobject = QPDFObjectHandle::newString(val);\n\t    }\n\n\t    break;\n\n\t  default:\n            warn(context,\n                 QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                         object_description,\n                         input->getLastOffset(),\n                         \"treating unknown token type as null while \"\n                         \"reading object\"));\n            object = newNull();\n\t    break;\n\t}\n\n        if ((! object.isInitialized()) &&\n            (! ((state == st_start) ||\n                (state == st_stop) ||\n                (state == st_eof))))\n        {\n            throw std::logic_error(\n                \"QPDFObjectHandle::parseInternal: \"\n                \"unexpected uninitialized object\");\n            object = newNull();\n        }\n\n        switch (state)\n        {\n          case st_eof:\n            if (state_stack.size() > 1)\n            {\n                warn(context,\n                     QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                             object_description,\n                             input->getLastOffset(),\n                             \"parse error while reading object\"));\n            }\n            done = true;\n            // In content stream mode, leave object uninitialized to\n            // indicate EOF\n            if (! content_stream)\n            {\n                object = newNull();\n            }\n            break;\n\n          case st_dictionary:\n          case st_array:\n            setObjectDescriptionFromInput(\n                object, context, object_description, input,\n                input->getLastOffset());\n            olist.push_back(object);\n            break;\n\n          case st_top:\n            done = true;\n            break;\n\n          case st_start:\n            break;\n\n          case st_stop:\n            if ((state_stack.size() < 2) || (olist_stack.size() < 2))\n            {\n                throw std::logic_error(\n                    \"QPDFObjectHandle::parseInternal: st_stop encountered\"\n                    \" with insufficient elements in stack\");\n            }\n            parser_state_e old_state = state_stack.back();\n            state_stack.pop_back();\n            if (old_state == st_array)\n            {\n                object = newArray(olist);\n                setObjectDescriptionFromInput(\n                    object, context, object_description, input, offset);\n            }\n            else if (old_state == st_dictionary)\n            {\n                // Convert list to map. Alternating elements are keys.\n                // Attempt to recover more or less gracefully from\n                // invalid dictionaries.\n                std::set<std::string> names;\n                for (std::vector<QPDFObjectHandle>::iterator iter =\n                         olist.begin();\n                     iter != olist.end(); ++iter)\n                {\n                    if ((! (*iter).isIndirect()) && (*iter).isName())\n                    {\n                        names.insert((*iter).getName());\n                    }\n                }\n\n                std::map<std::string, QPDFObjectHandle> dict;\n                int next_fake_key = 1;\n                for (unsigned int i = 0; i < olist.size(); ++i)\n                {\n                    QPDFObjectHandle key_obj = olist.at(i);\n                    QPDFObjectHandle val;\n                    if (key_obj.isIndirect() || (! key_obj.isName()))\n                    {\n                        bool found_fake = false;\n                        std::string candidate;\n                        while (! found_fake)\n                        {\n                            candidate =\n                                \"/QPDFFake\" +\n                                QUtil::int_to_string(next_fake_key++);\n                            found_fake = (names.count(candidate) == 0);\n                            QTC::TC(\"qpdf\", \"QPDFObjectHandle found fake\",\n                                    (found_fake ? 0 : 1));\n                        }\n                        warn(context,\n                             QPDFExc(\n                                 qpdf_e_damaged_pdf,\n                                 input->getName(), object_description, offset,\n                                 \"expected dictionary key but found\"\n                                 \" non-name object; inserting key \" +\n                                 candidate));\n                        val = key_obj;\n                        key_obj = newName(candidate);\n                    }\n                    else if (i + 1 >= olist.size())\n                    {\n                        QTC::TC(\"qpdf\", \"QPDFObjectHandle no val for last key\");\n                        warn(context,\n                             QPDFExc(\n                                 qpdf_e_damaged_pdf,\n                                 input->getName(), object_description, offset,\n                                 \"dictionary ended prematurely; \"\n                                 \"using null as value for last key\"));\n                        val = newNull();\n                        setObjectDescriptionFromInput(\n                            val, context, object_description, input, offset);\n                    }\n                    else\n                    {\n                        val = olist.at(++i);\n                    }\n                    dict[key_obj.getName()] = val;\n                }\n                object = newDictionary(dict);\n                setObjectDescriptionFromInput(\n                    object, context, object_description, input, offset);\n            }\n            olist_stack.pop_back();\n            offset_stack.pop_back();\n            if (state_stack.back() == st_top)\n            {\n                done = true;\n            }\n            else\n            {\n                olist_stack.back().push_back(object);\n            }\n        }\n    }\n\n    setObjectDescriptionFromInput(\n        object, context, object_description, input, offset);\n    return object;\n}", "target": 2, "idx": 9924}
{"commit_id": "aca969cacf07f41070d788ce2b8ca71f09d5207d", "project": "torvalds/linux", "func": "static int fill_thread_core_info(struct elf_thread_core_info *t,\n\t\t\t\t const struct user_regset_view *view,\n\t\t\t\t long signr, size_t *total)\n{\n\tunsigned int i;\n\tunsigned int regset0_size = regset_size(t->task, &view->regsets[0]);\n\n\t/*\n\t * NT_PRSTATUS is the one special case, because the regset data\n\t * goes into the pr_reg field inside the note contents, rather\n\t * than being the whole note contents.  We fill the reset in here.\n\t * We assume that regset 0 is NT_PRSTATUS.\n\t */\n\tfill_prstatus(&t->prstatus, t->task, signr);\n\t(void) view->regsets[0].get(t->task, &view->regsets[0], 0, regset0_size,\n\t\t\t\t    &t->prstatus.pr_reg, NULL);\n\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS,\n\t\t  PRSTATUS_SIZE(t->prstatus, regset0_size), &t->prstatus);\n\t*total += notesize(&t->notes[0]);\n\n\tdo_thread_regset_writeback(t->task, &view->regsets[0]);\n\n\t/*\n\t * Each other regset might generate a note too.  For each regset\n\t * that has no core_note_type or is inactive, we leave t->notes[i]\n\t * all zero and we'll know to skip writing it later.\n\t */\n\tfor (i = 1; i < view->n; ++i) {\n\t\tconst struct user_regset *regset = &view->regsets[i];\n\t\tdo_thread_regset_writeback(t->task, regset);\n\t\tif (regset->core_note_type && regset->get &&\n\t\t    (!regset->active || regset->active(t->task, regset) > 0)) {\n\t\t\tint ret;\n\t\t\tsize_t size = regset_size(t->task, regset);\n\t\t\tvoid *data = kzalloc(size, GFP_KERNEL);\n\t\t\tif (unlikely(!data))\n\t\t\t\treturn 0;\n\t\t\tret = regset->get(t->task, regset,\n\t\t\t\t\t  0, size, data, NULL);\n\t\t\tif (unlikely(ret))\n\t\t\t\tkfree(data);\n\t\t\telse {\n\t\t\t\tif (regset->core_note_type != NT_PRFPREG)\n\t\t\t\t\tfill_note(&t->notes[i], \"LINUX\",\n\t\t\t\t\t\t  regset->core_note_type,\n\t\t\t\t\t\t  size, data);\n\t\t\t\telse {\n\t\t\t\t\tSET_PR_FPVALID(&t->prstatus,\n\t\t\t\t\t\t\t1, regset0_size);\n\t\t\t\t\tfill_note(&t->notes[i], \"CORE\",\n\t\t\t\t\t\t  NT_PRFPREG, size, data);\n\t\t\t\t}\n\t\t\t\t*total += notesize(&t->notes[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}", "target": 0, "idx": 9925}
{"commit_id": "ed188f6dcdf0935c939ed813cf8745d50742014b", "project": "ffmpeg", "func": "static int aa_read_header(AVFormatContext *s)\n{\n    int i, j, idx, largest_idx = -1;\n    uint32_t nkey, nval, toc_size, npairs, header_seed = 0, start;\n    char key[128], val[128], codec_name[64] = {0};\n    uint8_t output[24], dst[8], src[8];\n    int64_t largest_size = -1, current_size = -1, chapter_pos;\n    struct toc_entry {\n        uint32_t offset;\n        uint32_t size;\n    } TOC[MAX_TOC_ENTRIES];\n    uint32_t header_key_part[4];\n    uint8_t header_key[16] = {0};\n    AADemuxContext *c = s->priv_data;\n    AVIOContext *pb = s->pb;\n    AVStream *st;\n    int ret;\n\n    /* parse .aa header */\n    avio_skip(pb, 4); // file size\n    avio_skip(pb, 4); // magic string\n    toc_size = avio_rb32(pb); // TOC size\n    avio_skip(pb, 4); // unidentified integer\n    if (toc_size > MAX_TOC_ENTRIES)\n        return AVERROR_INVALIDDATA;\n    for (i = 0; i < toc_size; i++) { // read TOC\n        avio_skip(pb, 4); // TOC entry index\n        TOC[i].offset = avio_rb32(pb); // block offset\n        TOC[i].size = avio_rb32(pb); // block size\n    }\n    avio_skip(pb, 24); // header termination block (ignored)\n    npairs = avio_rb32(pb); // read dictionary entries\n    if (npairs > MAX_DICTIONARY_ENTRIES)\n        return AVERROR_INVALIDDATA;\n    for (i = 0; i < npairs; i++) {\n        memset(val, 0, sizeof(val));\n        memset(key, 0, sizeof(key));\n        avio_skip(pb, 1); // unidentified integer\n        nkey = avio_rb32(pb); // key string length\n        nval = avio_rb32(pb); // value string length\n        avio_get_str(pb, nkey, key, sizeof(key));\n        avio_get_str(pb, nval, val, sizeof(val));\n        if (!strcmp(key, \"codec\")) {\n            av_log(s, AV_LOG_DEBUG, \"Codec is <%s>\\n\", val);\n            strncpy(codec_name, val, sizeof(codec_name) - 1);\n        } else if (!strcmp(key, \"HeaderSeed\")) {\n            av_log(s, AV_LOG_DEBUG, \"HeaderSeed is <%s>\\n\", val);\n            header_seed = atoi(val);\n        } else if (!strcmp(key, \"HeaderKey\")) { // this looks like \"1234567890 1234567890 1234567890 1234567890\"\n            av_log(s, AV_LOG_DEBUG, \"HeaderKey is <%s>\\n\", val);\n\n            ret = sscanf(val, \"%\"SCNu32\"%\"SCNu32\"%\"SCNu32\"%\"SCNu32,\n                   &header_key_part[0], &header_key_part[1], &header_key_part[2], &header_key_part[3]);\n            if (ret != 4)\n                return AVERROR_INVALIDDATA;\n\n            for (idx = 0; idx < 4; idx++) {\n                AV_WB32(&header_key[idx * 4], header_key_part[idx]); // convert each part to BE!\n            }\n            av_log(s, AV_LOG_DEBUG, \"Processed HeaderKey is \");\n            for (i = 0; i < 16; i++)\n                av_log(s, AV_LOG_DEBUG, \"%02x\", header_key[i]);\n            av_log(s, AV_LOG_DEBUG, \"\\n\");\n        } else {\n            av_dict_set(&s->metadata, key, val, 0);\n        }\n    }\n\n    /* verify fixed key */\n    if (c->aa_fixed_key_len != 16) {\n        av_log(s, AV_LOG_ERROR, \"aa_fixed_key value needs to be 16 bytes!\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    /* verify codec */\n    if ((c->codec_second_size = get_second_size(codec_name)) == -1) {\n        av_log(s, AV_LOG_ERROR, \"unknown codec <%s>!\\n\", codec_name);\n        return AVERROR(EINVAL);\n    }\n\n    /* decryption key derivation */\n    c->tea_ctx = av_tea_alloc();\n    if (!c->tea_ctx)\n        return AVERROR(ENOMEM);\n    av_tea_init(c->tea_ctx, c->aa_fixed_key, 16);\n    output[0] = output[1] = 0; // purely for padding purposes\n    memcpy(output + 2, header_key, 16);\n    idx = 0;\n    for (i = 0; i < 3; i++) { // TEA CBC with weird mixed endianness\n        AV_WB32(src, header_seed);\n        AV_WB32(src + 4, header_seed + 1);\n        header_seed += 2;\n        av_tea_crypt(c->tea_ctx, dst, src, 1, NULL, 0); // TEA ECB encrypt\n        for (j = 0; j < TEA_BLOCK_SIZE && idx < 18; j+=1, idx+=1) {\n            output[idx] = output[idx] ^ dst[j];\n        }\n    }\n    memcpy(c->file_key, output + 2, 16); // skip first 2 bytes of output\n    av_log(s, AV_LOG_DEBUG, \"File key is \");\n    for (i = 0; i < 16; i++)\n        av_log(s, AV_LOG_DEBUG, \"%02x\", c->file_key[i]);\n    av_log(s, AV_LOG_DEBUG, \"\\n\");\n\n    /* decoder setup */\n    st = avformat_new_stream(s, NULL);\n    if (!st) {\n        av_freep(&c->tea_ctx);\n        return AVERROR(ENOMEM);\n    }\n    st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n    if (!strcmp(codec_name, \"mp332\")) {\n        st->codecpar->codec_id = AV_CODEC_ID_MP3;\n        st->codecpar->sample_rate = 22050;\n        st->need_parsing = AVSTREAM_PARSE_FULL_RAW;\n        avpriv_set_pts_info(st, 64, 8, 32000 * TIMEPREC);\n        // encoded audio frame is MP3_FRAME_SIZE bytes (+1 with padding, unlikely)\n    } else if (!strcmp(codec_name, \"acelp85\")) {\n        st->codecpar->codec_id = AV_CODEC_ID_SIPR;\n        st->codecpar->block_align = 19;\n        st->codecpar->channels = 1;\n        st->codecpar->sample_rate = 8500;\n        st->codecpar->bit_rate = 8500;\n        st->need_parsing = AVSTREAM_PARSE_FULL_RAW;\n        avpriv_set_pts_info(st, 64, 8, 8500 * TIMEPREC);\n    } else if (!strcmp(codec_name, \"acelp16\")) {\n        st->codecpar->codec_id = AV_CODEC_ID_SIPR;\n        st->codecpar->block_align = 20;\n        st->codecpar->channels = 1;\n        st->codecpar->sample_rate = 16000;\n        st->codecpar->bit_rate = 16000;\n        st->need_parsing = AVSTREAM_PARSE_FULL_RAW;\n        avpriv_set_pts_info(st, 64, 8, 16000 * TIMEPREC);\n    }\n\n    /* determine, and jump to audio start offset */\n    for (i = 1; i < toc_size; i++) { // skip the first entry!\n        current_size = TOC[i].size;\n        if (current_size > largest_size) {\n            largest_idx = i;\n            largest_size = current_size;\n        }\n    }\n    start = TOC[largest_idx].offset;\n    avio_seek(pb, start, SEEK_SET);\n\n    // extract chapter positions. since all formats have constant bit rate, use it\n    // as time base in bytes/s, for easy stream position <-> timestamp conversion\n    st->start_time = 0;\n    c->content_start = start;\n    c->content_end = start + largest_size;\n\n    while ((chapter_pos = avio_tell(pb)) >= 0 && chapter_pos < c->content_end) {\n        int chapter_idx = s->nb_chapters;\n        uint32_t chapter_size = avio_rb32(pb);\n        if (chapter_size == 0) break;\n        chapter_pos -= start + CHAPTER_HEADER_SIZE * chapter_idx;\n        avio_skip(pb, 4 + chapter_size);\n        if (!avpriv_new_chapter(s, chapter_idx, st->time_base,\n            chapter_pos * TIMEPREC, (chapter_pos + chapter_size) * TIMEPREC, NULL))\n                return AVERROR(ENOMEM);\n    }\n\n    st->duration = (largest_size - CHAPTER_HEADER_SIZE * s->nb_chapters) * TIMEPREC;\n\n    ff_update_cur_dts(s, st, 0);\n    avio_seek(pb, start, SEEK_SET);\n    c->current_chapter_size = 0;\n    c->seek_offset = 0;\n\n    return 0;\n}", "target": 3, "idx": 9926}
{"commit_id": "aab0e2a661b2b6bf7915c0aefe807fb60d6d9d13", "project": "qemu", "func": "static void ati_cursor_define(ATIVGAState *s)\n{\n    uint8_t data[1024];\n    uint32_t srcoff;\n    int i, j, idx = 0;\n\n    if ((s->regs.cur_offset & BIT(31)) || s->cursor_guest_mode) {\n        return; /* Do not update cursor if locked or rendered by guest */\n    }\n    /* FIXME handle cur_hv_offs correctly */\n    srcoff = s->regs.cur_offset -\n        (s->regs.cur_hv_offs >> 16) - (s->regs.cur_hv_offs & 0xffff) * 16;\n    for (i = 0; i < 64; i++) {\n        for (j = 0; j < 8; j++, idx++) {\n            data[idx] = vga_read_byte(&s->vga, srcoff + i * 16 + j);\n            data[512 + idx] = vga_read_byte(&s->vga, srcoff + i * 16 + j + 8);\n        }\n    }\n    if (!s->cursor) {\n        s->cursor = cursor_alloc(64, 64);\n    }\n    cursor_set_mono(s->cursor, s->regs.cur_color1, s->regs.cur_color0,\n                    &data[512], 1, &data[0]);\n    dpy_cursor_define(s->vga.con, s->cursor);\n}", "target": 1, "idx": 9927}
{"commit_id": "1b736a815be0222f4b24289cf17575fc15707305", "project": "qt/qtbase", "func": "bool QHstsHeaderParser::parse(const QList<QPair<QByteArray, QByteArray>> &headers)\n{\n    for (const auto &h : headers) {\n        // We compare directly because header name was already 'trimmed' for us:\n        if (h.first.compare(\"Strict-Transport-Security\", Qt::CaseInsensitive) == 0) {\n            header = h.second;\n            // RFC6797, 8.1:\n            //\n            //  The UA MUST ignore any STS header fields not conforming to the\n            // grammar specified in Section 6.1 (\"Strict-Transport-Security HTTP\n            // Response Header Field\").\n            //\n            // If a UA receives more than one STS header field in an HTTP\n            // response message over secure transport, then the UA MUST process\n            // only the first such header field.\n            //\n            // We read this as: ignore all invalid headers and take the first valid:\n            if (parseSTSHeader() && maxAgeFound) {\n                expiry = QDateTime::currentDateTimeUtc().addSecs(maxAge);\n                return true;\n            }\n        }\n    }\n\n    // In case it was set by a syntactically correct header (but without\n    // REQUIRED max-age directive):\n    subDomainsFound = false;\n\n    return false;\n}", "target": 1, "idx": 9928}
{"commit_id": "537bc7c723439b9194a358f64d871dd326c18887", "project": "tensorflow", "func": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  const auto* params = reinterpret_cast<TfLiteSVDFParams*>(node->builtin_data);\n  OpData* op_data = reinterpret_cast<OpData*>(node->user_data);\n  int scratch_tensor_index = op_data->scratch_tensor_index;\n\n  // Check we have all the inputs and outputs we need.\n  TF_LITE_ENSURE_EQ(context, node->outputs->size, 1);\n  TF_LITE_ENSURE_EQ(context, node->inputs->size, 5);\n\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  const TfLiteTensor* weights_feature;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kWeightsFeatureTensor,\n                                          &weights_feature));\n  const TfLiteTensor* weights_time;\n  TF_LITE_ENSURE_OK(\n      context, GetInputSafe(context, node, kWeightsTimeTensor, &weights_time));\n\n  TF_LITE_ENSURE(context,\n                 input->type == kTfLiteFloat32 || input->type == kTfLiteInt8);\n\n  // Check all the parameters of tensor match within themselves and match the\n  // input configuration.\n  const int rank = params->rank;\n  const int batch_size = input->dims->data[0];\n  const int num_filters = weights_feature->dims->data[0];\n  TF_LITE_ENSURE(context, rank != 0);\n  TF_LITE_ENSURE_EQ(context, num_filters % rank, 0);\n  const int num_units = num_filters / rank;\n  const int memory_size = weights_time->dims->data[1];\n  TF_LITE_ENSURE_EQ(context, input->dims->data[1],\n                    weights_feature->dims->data[1]);\n  TF_LITE_ENSURE_EQ(context, weights_time->dims->data[0], num_filters);\n\n  const TfLiteTensor* bias = GetOptionalInputTensor(context, node, kBiasTensor);\n  if (bias) {\n    TF_LITE_ENSURE_EQ(context, bias->dims->data[0], num_units);\n  }\n\n  const TfLiteTensor* state;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kStateTensor, &state));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  // Check the shape of input state tensors.\n  TF_LITE_ENSURE_EQ(context, NumDimensions(state), 2);\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(state, 0), batch_size);\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(state, 1),\n                    memory_size * num_filters);\n\n  // Resize output.\n  TfLiteIntArray* output_size_array = TfLiteIntArrayCreate(2);\n  output_size_array->data[0] = batch_size;\n  output_size_array->data[1] = num_units;\n  TF_LITE_ENSURE_OK(context,\n                    context->ResizeTensor(context, output, output_size_array));\n\n  // The weights are of consistent type, so it suffices to check one.\n  const bool is_hybrid_op = IsHybridOp(input, weights_feature);\n  const bool is_full_integer = input->type == kTfLiteInt8;\n\n  // Resize scratch.\n  TfLiteIntArrayFree(node->temporaries);\n  if (is_hybrid_op) {\n    node->temporaries = TfLiteIntArrayCreate(6);\n  } else if (is_full_integer) {\n    node->temporaries = TfLiteIntArrayCreate(2);\n  } else {\n    node->temporaries = TfLiteIntArrayCreate(1);\n  }\n  node->temporaries->data[0] = scratch_tensor_index;\n\n  TfLiteIntArray* scratch_size_array = TfLiteIntArrayCreate(2);\n  scratch_size_array->data[0] = batch_size;\n  scratch_size_array->data[1] = num_filters;\n\n  TfLiteTensor* scratch_tensor;\n  TF_LITE_ENSURE_OK(\n      context, GetTemporarySafe(context, node, /*index=*/0, &scratch_tensor));\n\n  // The scratch buffer is of type int32 for full integer svdf and it's of type\n  // float32 for hybrid and float case.\n  if (is_full_integer) {\n    scratch_tensor->type = kTfLiteInt32;\n  } else {\n    scratch_tensor->type = kTfLiteFloat32;\n  }\n  scratch_tensor->allocation_type = kTfLiteArenaRw;\n  TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scratch_tensor,\n                                                   scratch_size_array));\n\n  if (is_hybrid_op) {\n    op_data->compute_row_sums = true;\n    // Tell interpreter to allocate temporary tensors to store quantized values\n    // of input tensors.\n    node->temporaries->data[1] = scratch_tensor_index + 1;\n    TfLiteTensor* input_quantized;\n    TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/1,\n                                                &input_quantized));\n    input_quantized->type = weights_feature->type;\n    input_quantized->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqual(input_quantized->dims, input->dims)) {\n      TfLiteIntArray* input_quantized_size = TfLiteIntArrayCopy(input->dims);\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_quantized,\n                                                       input_quantized_size));\n    }\n\n    // Tell interpreter to allocate temporary tensors to store scaling factors.\n    node->temporaries->data[2] = scratch_tensor_index + 2;\n    TfLiteTensor* scaling_factors;\n    TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/2,\n                                                &scaling_factors));\n    scaling_factors->type = kTfLiteFloat32;\n    scaling_factors->allocation_type = kTfLiteArenaRw;\n    int scaling_dims[1] = {batch_size};\n    if (!TfLiteIntArrayEqualsArray(scaling_factors->dims, 1, scaling_dims)) {\n      TfLiteIntArray* scaling_factors_size = TfLiteIntArrayCreate(1);\n      scaling_factors_size->data[0] = batch_size;\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scaling_factors,\n                                                       scaling_factors_size));\n    }\n\n    // Used to store dequantized weights_time matrix for hybrid computation of\n    // matmul(state, weights_time), which occurs in floating point.\n    node->temporaries->data[3] = scratch_tensor_index + 3;\n    TfLiteTensor* float_weights_time;\n    TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/3,\n                                                &float_weights_time));\n    float_weights_time->type = kTfLiteFloat32;\n    // Persistent so that we can compute the dequantized weights only once.\n    float_weights_time->allocation_type = kTfLiteArenaRwPersistent;\n    if (!TfLiteIntArrayEqual(float_weights_time->dims, weights_time->dims)) {\n      TfLiteIntArray* float_weights_time_size =\n          TfLiteIntArrayCopy(weights_time->dims);\n      TF_LITE_ENSURE_OK(context,\n                        context->ResizeTensor(context, float_weights_time,\n                                              float_weights_time_size));\n    }\n\n    node->temporaries->data[4] = scratch_tensor_index + 4;\n    TfLiteTensor* zero_points;\n    TF_LITE_ENSURE_OK(\n        context, GetTemporarySafe(context, node, /*index=*/4, &zero_points));\n    zero_points->type = kTfLiteFloat32;\n    zero_points->allocation_type = kTfLiteArenaRw;\n    int zero_points_dims[1] = {batch_size};\n    if (!TfLiteIntArrayEqualsArray(zero_points->dims, 1, zero_points_dims)) {\n      TfLiteIntArray* zero_points_size = TfLiteIntArrayCreate(1);\n      zero_points_size->data[0] = zero_points_dims[0];\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, zero_points,\n                                                       zero_points_size));\n    }\n\n    node->temporaries->data[5] = scratch_tensor_index + 5;\n    TfLiteTensor* row_sums;\n    TF_LITE_ENSURE_OK(context,\n                      GetTemporarySafe(context, node, /*index=*/5, &row_sums));\n    row_sums->type = kTfLiteFloat32;\n    row_sums->allocation_type = kTfLiteArenaRwPersistent;\n    int row_sums_dims[1] = {num_filters};\n    if (!TfLiteIntArrayEqualsArray(row_sums->dims, 1, row_sums_dims)) {\n      TfLiteIntArray* row_sums_size = TfLiteIntArrayCreate(1);\n      row_sums_size->data[0] = row_sums_dims[0];\n      TF_LITE_ENSURE_OK(\n          context, context->ResizeTensor(context, row_sums, row_sums_size));\n    }\n  }\n  if (is_full_integer) {\n    // Allocated one extra tensor.\n    TfLiteIntArray* output_temp_size_array = TfLiteIntArrayCreate(2);\n    output_temp_size_array->data[0] = num_units;\n    output_temp_size_array->data[1] = batch_size;\n    node->temporaries->data[1] = scratch_tensor_index + 1;\n    TfLiteTensor* output_temp;\n    TF_LITE_ENSURE_OK(\n        context, GetTemporarySafe(context, node, /*index=*/1, &output_temp));\n    output_temp->type = kTfLiteInt32;\n    output_temp->allocation_type = kTfLiteArenaRw;\n    TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, output_temp,\n                                                     output_temp_size_array));\n\n    // Calculate effective scales.\n    TF_LITE_ENSURE(context, input->quantization.type != kTfLiteNoQuantization);\n    auto* input_params =\n        reinterpret_cast<TfLiteAffineQuantization*>(input->quantization.params);\n    TF_LITE_ENSURE(context,\n                   weights_feature->quantization.type != kTfLiteNoQuantization);\n    auto* weights_feature_params = reinterpret_cast<TfLiteAffineQuantization*>(\n        weights_feature->quantization.params);\n    TF_LITE_ENSURE(context, state->quantization.type != kTfLiteNoQuantization);\n    auto* state_params =\n        reinterpret_cast<TfLiteAffineQuantization*>(state->quantization.params);\n    TF_LITE_ENSURE(context,\n                   weights_time->quantization.type != kTfLiteNoQuantization);\n    auto* weight_time_params = reinterpret_cast<TfLiteAffineQuantization*>(\n        weights_time->quantization.params);\n    TF_LITE_ENSURE(context, output->quantization.type != kTfLiteNoQuantization);\n    auto* output_params = reinterpret_cast<TfLiteAffineQuantization*>(\n        output->quantization.params);\n    const double effective_scale_1 = input_params->scale->data[0] *\n                                     weights_feature_params->scale->data[0] /\n                                     state_params->scale->data[0];\n    const double effective_scale_2 = state_params->scale->data[0] *\n                                     weight_time_params->scale->data[0] /\n                                     output_params->scale->data[0];\n    QuantizeMultiplier(effective_scale_1, &op_data->effective_scale_1_a,\n                       &op_data->effective_scale_1_b);\n    QuantizeMultiplier(effective_scale_2, &op_data->effective_scale_2_a,\n                       &op_data->effective_scale_2_b);\n  }\n  return kTfLiteOk;\n}", "target": 1, "idx": 9929}
{"commit_id": "5a15b72a270b514cd442872221a788a303bdaa88", "project": "chromium", "func": "void DidFailProvisionalLoad(const blink::WebURLError& error) override {\n    // Use PostTask to avoid running user scripts while handling this\n    // DidFailProvisionalLoad notification.\n    base::MessageLoop::current()->PostTask(FROM_HERE,\n                                           base::Bind(callback_, false));\n    delete this;\n  }", "target": 3, "idx": 9930}
{"commit_id": "4ba6da096611d11849aa37ee342c032a306ee885", "project": "pistacheio/pistache", "func": "std::optional<Path> PathGroup::path(const std::string& name,\n                                            Http::Method method) const\n        {\n            auto group = paths(name);\n            auto it    = std::find_if(std::begin(group), std::end(group),\n                                      [&](const Path& p) { return p.method == method; });\n\n            if (it != std::end(group))\n            {\n                return std::optional<Path>(*it);\n            }\n            return std::nullopt;\n        }", "target": 1, "idx": 9931}
{"commit_id": "5beb00c93d3adb5c23149535624d27c67bc146ea", "project": "TokTok/c-toxcore", "func": "static int confirm_TCP_connection(TCP_Server *tcp_server, const Mono_Time *mono_time, TCP_Secure_Connection *con,\n                                  const uint8_t *data,\n                                  uint16_t length)\n{\n    int index = add_accepted(tcp_server, mono_time, con);\n\n    if (index == -1) {\n        kill_TCP_secure_connection(con);\n        return -1;\n    }\n\n    wipe_secure_connection(con);\n\n    if (handle_TCP_packet(tcp_server, index, data, length) == -1) {\n        kill_accepted(tcp_server, index);\n        return -1;\n    }\n\n    return index;\n}", "target": 2, "idx": 9932}
{"commit_id": "659142ecf71a0da240ab0ff7cf929ee25c32b9bc", "project": "qemu", "func": "void ide_dma_cb(void *opaque, int ret)\n{\n    IDEState *s = opaque;\n    int n;\n    int64_t sector_num;\n    bool stay_active = false;\n\n    if (ret == -ECANCELED) {\n        return;\n    }\n    if (ret < 0) {\n        int op = IDE_RETRY_DMA;\n\n        if (s->dma_cmd == IDE_DMA_READ)\n            op |= IDE_RETRY_READ;\n        else if (s->dma_cmd == IDE_DMA_TRIM)\n            op |= IDE_RETRY_TRIM;\n\n        if (ide_handle_rw_error(s, -ret, op)) {\n            return;\n        }\n    }\n\n    n = s->io_buffer_size >> 9;\n    if (n > s->nsector) {\n        /* The PRDs were longer than needed for this request. Shorten them so\n         * we don't get a negative remainder. The Active bit must remain set\n         * after the request completes. */\n        n = s->nsector;\n        stay_active = true;\n    }\n\n    sector_num = ide_get_sector(s);\n    if (n > 0) {\n        assert(s->io_buffer_size == s->sg.size);\n        dma_buf_commit(s, s->io_buffer_size);\n        sector_num += n;\n        ide_set_sector(s, sector_num);\n        s->nsector -= n;\n    }\n\n    /* end of transfer ? */\n    if (s->nsector == 0) {\n        s->status = READY_STAT | SEEK_STAT;\n        ide_set_irq(s->bus);\n        goto eot;\n    }\n\n    /* launch next transfer */\n    n = s->nsector;\n    s->io_buffer_index = 0;\n    s->io_buffer_size = n * 512;\n    if (s->bus->dma->ops->prepare_buf(s->bus->dma, ide_cmd_is_read(s)) == 0) {\n        /* The PRDs were too short. Reset the Active bit, but don't raise an\n         * interrupt. */\n        s->status = READY_STAT | SEEK_STAT;\n        goto eot;\n    }\n\n#ifdef DEBUG_AIO\n    printf(\"ide_dma_cb: sector_num=%\" PRId64 \" n=%d, cmd_cmd=%d\\n\",\n           sector_num, n, s->dma_cmd);\n#endif\n\n    if ((s->dma_cmd == IDE_DMA_READ || s->dma_cmd == IDE_DMA_WRITE) &&\n        !ide_sect_range_ok(s, sector_num, n)) {\n        ide_dma_error(s);\n        return;\n    }\n\n    switch (s->dma_cmd) {\n    case IDE_DMA_READ:\n        s->bus->dma->aiocb = dma_blk_read(s->blk, &s->sg, sector_num,\n                                          ide_dma_cb, s);\n        break;\n    case IDE_DMA_WRITE:\n        s->bus->dma->aiocb = dma_blk_write(s->blk, &s->sg, sector_num,\n                                           ide_dma_cb, s);\n        break;\n    case IDE_DMA_TRIM:\n        s->bus->dma->aiocb = dma_blk_io(s->blk, &s->sg, sector_num,\n                                        ide_issue_trim, ide_dma_cb, s,\n                                        DMA_DIRECTION_TO_DEVICE);\n        break;\n    }\n    return;\n\neot:\n    if (s->dma_cmd == IDE_DMA_READ || s->dma_cmd == IDE_DMA_WRITE) {\n        block_acct_done(blk_get_stats(s->blk), &s->acct);\n    }\n    ide_set_inactive(s, stay_active);\n}", "target": 1, "idx": 9933}
{"commit_id": "dae97cbafc5c06ebbc6b34e76ba614104f1b73e1", "project": "appneta/tcpreplay", "func": "int\ndo_checksum(tcpedit_t *tcpedit, uint8_t *data, int proto, int len) {\n    ipv4_hdr_t *ipv4;\n    ipv6_hdr_t *ipv6;\n    tcp_hdr_t *tcp;\n    udp_hdr_t *udp;\n    icmpv4_hdr_t *icmp;\n    icmpv6_hdr_t *icmp6;\n    u_char *layer;\n    int ip_hl;\n    int sum;\n\n    sum = 0;\n    ipv4 = NULL;\n    ipv6 = NULL;\n    assert(data);\n\n    if (!data || len <= 0 || len > 65535) {\n        tcpedit_setwarn(tcpedit, \"%s\", \"Unable to checksum packets with no L3+ data\");\n        return TCPEDIT_WARN;\n    }\n\n    ipv4 = (ipv4_hdr_t *)data;\n    if (ipv4->ip_v == 6) {\n        ipv6 = (ipv6_hdr_t *)data;\n        ipv4 = NULL;\n\n        proto = get_ipv6_l4proto(ipv6, len);\n        dbgx(3, \"layer4 proto is 0x%hx\", (uint16_t)proto);\n\n        layer = (u_char*)get_layer4_v6(ipv6, len);\n        if (!layer) {\n            tcpedit_setwarn(tcpedit, \"%s\", \"Packet to short for checksum\");\n            return TCPEDIT_WARN;\n        }\n\n        ip_hl = layer - (u_char*)data;\n        dbgx(3, \"ip_hl proto is 0x%d\", ip_hl);\n\n        len -= (ip_hl - TCPR_IPV6_H);\n    } else {\n        ip_hl = ipv4->ip_hl << 2;\n    }\n\n    switch (proto) {\n\n        case IPPROTO_TCP:\n            tcp = (tcp_hdr_t *)(data + ip_hl);\n#ifdef STUPID_SOLARIS_CHECKSUM_BUG\n            tcp->th_sum = tcp->th_off << 2;\n            return (TCPEDIT_OK);\n#endif\n            tcp->th_sum = 0;\n\n            /* Note, we do both src & dst IP's at the same time, that's why the\n             * length is 2x a single IP\n             */\n            if (ipv6 != NULL) {\n                sum = do_checksum_math((uint16_t *)&ipv6->ip_src, 32);\n            } else {\n                sum = do_checksum_math((uint16_t *)&ipv4->ip_src, 8);\n            }\n            sum += ntohs(IPPROTO_TCP + len);\n            sum += do_checksum_math((uint16_t *)tcp, len);\n            tcp->th_sum = CHECKSUM_CARRY(sum);\n            break;\n\n        case IPPROTO_UDP:\n            udp = (udp_hdr_t *)(data + ip_hl);\n            /* No need to recalculate UDP checksums if already 0 */\n            if (udp->uh_sum == 0)\n                break;\n            udp->uh_sum = 0;\n            if (ipv6 != NULL) {\n                sum = do_checksum_math((uint16_t *)&ipv6->ip_src, 32);\n            } else {\n                sum = do_checksum_math((uint16_t *)&ipv4->ip_src, 8);\n            }\n            sum += ntohs(IPPROTO_UDP + len);\n            sum += do_checksum_math((uint16_t *)udp, len);\n            udp->uh_sum = CHECKSUM_CARRY(sum);\n            break;\n\n        case IPPROTO_ICMP:\n            icmp = (icmpv4_hdr_t *)(data + ip_hl);\n            icmp->icmp_sum = 0;\n            if (ipv6 != NULL) {\n                sum = do_checksum_math((uint16_t *)&ipv6->ip_src, 32);\n                icmp->icmp_sum = CHECKSUM_CARRY(sum);\n            }\n            sum += do_checksum_math((uint16_t *)icmp, len);\n            icmp->icmp_sum = CHECKSUM_CARRY(sum);\n            break;\n\n        case IPPROTO_ICMP6:\n            icmp6 = (icmpv6_hdr_t *)(data + ip_hl);\n            icmp6->icmp_sum = 0;\n            if (ipv6 != NULL) {\n                sum = do_checksum_math((u_int16_t *)&ipv6->ip_src, 32);\n            }\n            sum += ntohs(IPPROTO_ICMP6 + len);\n            sum += do_checksum_math((u_int16_t *)icmp6, len);\n            icmp6->icmp_sum = CHECKSUM_CARRY(sum);\n            break;\n\n\n        case IPPROTO_IP:\n            if (ipv4) {\n                ipv4->ip_sum = 0;\n                sum = do_checksum_math((uint16_t *)data, ip_hl);\n                ipv4->ip_sum = CHECKSUM_CARRY(sum);\n            }\n            break;\n\n        case IPPROTO_IGMP:\n        case IPPROTO_GRE:\n        case IPPROTO_OSPF:\n        case IPPROTO_OSPF_LSA:\n        case IPPROTO_VRRP:\n        case TCPR_PROTO_CDP:\n        case TCPR_PROTO_ISL:\n        default:\n            tcpedit_setwarn(tcpedit, \"Unsupported protocol for checksum: 0x%x\", proto);\n            return TCPEDIT_WARN;\n    }\n\n    return TCPEDIT_OK;\n}", "target": 2, "idx": 9934}
{"commit_id": "24282de142000d2ed2c19783b40a1351872dfc54", "project": "radareorg/radare2", "func": "static void r_trie_node_free(RTrieNode **n) {\n\tif (!n || *n) {\n\t\treturn;\n\t}\n\tint i;\n\tfor (i = 0; i < ALPHABET_SIZE; i++){\n\t\tr_trie_node_free (&(*n)->child[i]);\n\t}\n\tR_FREE (*n);\n}", "target": 1, "idx": 9935}
{"commit_id": "7391a506352c009fe044dead7baad9e22dd279ee", "project": "libimobiledevice/libplist", "func": "int main(int argc, char *argv[])\n{\n    FILE *iplist = NULL;\n    plist_t root_node = NULL;\n    char *plist_out = NULL;\n    uint32_t size = 0;\n    int read_size = 0;\n    char *plist_entire = NULL;\n    struct stat filestats;\n    options_t *options = parse_arguments(argc, argv);\n\n    if (!options)\n    {\n        print_usage(argc, argv);\n        return 0;\n    }\n\n    // read input file\n    iplist = fopen(options->in_file, \"rb\");\n    if (!iplist) {\n        free(options);\n        return 1;\n    }\n\n    stat(options->in_file, &filestats);\n\n    if (filestats.st_size < 8) {\n        printf(\"ERROR: Input file is too small to contain valid plist data.\\n\");\n        return -1;\n    }\n\n    plist_entire = (char *) malloc(sizeof(char) * (filestats.st_size + 1));\n    read_size = fread(plist_entire, sizeof(char), filestats.st_size, iplist);\n    fclose(iplist);\n\n    // convert from binary to xml or vice-versa\n    if (memcmp(plist_entire, \"bplist00\", 8) == 0)\n    {\n        plist_from_bin(plist_entire, read_size, &root_node);\n        plist_to_xml(root_node, &plist_out, &size);\n    }\n    else\n    {\n        plist_from_xml(plist_entire, read_size, &root_node);\n        plist_to_bin(root_node, &plist_out, &size);\n    }\n    plist_free(root_node);\n    free(plist_entire);\n\n    if (plist_out)\n    {\n        if (options->out_file != NULL)\n        {\n            FILE *oplist = fopen(options->out_file, \"wb\");\n            if (!oplist) {\n                free(options);\n                return 1;\n            }\n            fwrite(plist_out, size, sizeof(char), oplist);\n            fclose(oplist);\n        }\n        // if no output file specified, write to stdout\n        else\n            fwrite(plist_out, size, sizeof(char), stdout);\n\n        free(plist_out);\n    }\n    else\n        printf(\"ERROR: Failed to convert input file.\\n\");\n\n    free(options);\n    return 0;\n}", "target": 3, "idx": 9936}
{"commit_id": "aacae2065744adb05e858d327198c7bbe7f452b0", "project": "opencv", "func": "bool  JpegDecoder::readData( Mat& img )\n{\n    volatile bool result = false;\n    size_t step = img.step;\n    bool color = img.channels() > 1;\n\n    if( m_state && m_width && m_height )\n    {\n        jpeg_decompress_struct* cinfo = &((JpegState*)m_state)->cinfo;\n        JpegErrorMgr* jerr = &((JpegState*)m_state)->jerr;\n        JSAMPARRAY buffer = 0;\n\n        if( setjmp( jerr->setjmp_buffer ) == 0 )\n        {\n            /* check if this is a mjpeg image format */\n            if ( cinfo->ac_huff_tbl_ptrs[0] == NULL &&\n                cinfo->ac_huff_tbl_ptrs[1] == NULL &&\n                cinfo->dc_huff_tbl_ptrs[0] == NULL &&\n                cinfo->dc_huff_tbl_ptrs[1] == NULL )\n            {\n                /* yes, this is a mjpeg image format, so load the correct\n                huffman table */\n                my_jpeg_load_dht( cinfo,\n                    my_jpeg_odml_dht,\n                    cinfo->ac_huff_tbl_ptrs,\n                    cinfo->dc_huff_tbl_ptrs );\n            }\n\n            if( color )\n            {\n                if( cinfo->num_components != 4 )\n                {\n                    cinfo->out_color_space = JCS_RGB;\n                    cinfo->out_color_components = 3;\n                }\n                else\n                {\n                    cinfo->out_color_space = JCS_CMYK;\n                    cinfo->out_color_components = 4;\n                }\n            }\n            else\n            {\n                if( cinfo->num_components != 4 )\n                {\n                    cinfo->out_color_space = JCS_GRAYSCALE;\n                    cinfo->out_color_components = 1;\n                }\n                else\n                {\n                    cinfo->out_color_space = JCS_CMYK;\n                    cinfo->out_color_components = 4;\n                }\n            }\n\n            jpeg_start_decompress( cinfo );\n\n            buffer = (*cinfo->mem->alloc_sarray)((j_common_ptr)cinfo,\n                                              JPOOL_IMAGE, m_width*4, 1 );\n\n            uchar* data = img.ptr();\n            for( ; m_height--; data += step )\n            {\n                jpeg_read_scanlines( cinfo, buffer, 1 );\n                if( color )\n                {\n                    if( cinfo->out_color_components == 3 )\n                        icvCvt_RGB2BGR_8u_C3R( buffer[0], 0, data, 0, cvSize(m_width,1) );\n                    else\n                        icvCvt_CMYK2BGR_8u_C4C3R( buffer[0], 0, data, 0, cvSize(m_width,1) );\n                }\n                else\n                {\n                    if( cinfo->out_color_components == 1 )\n                        memcpy( data, buffer[0], m_width );\n                    else\n                        icvCvt_CMYK2Gray_8u_C4C1R( buffer[0], 0, data, 0, cvSize(m_width,1) );\n                }\n            }\n\n            result = true;\n            jpeg_finish_decompress( cinfo );\n        }\n    }\n\n    close();\n    return result;\n}", "target": 1, "idx": 9937}
{"commit_id": "11559e49e65bdf00922ad5ae28913ec6a198d508", "project": "pjsip/pjproject", "func": "PJ_DEF(void) pjmedia_rtcp_init2( pjmedia_rtcp_session *sess,\n\t\t\t\t const pjmedia_rtcp_session_setting *settings)\n{\n    pjmedia_rtcp_sr_pkt *sr_pkt = &sess->rtcp_sr_pkt;\n    pj_time_val now;\n    \n    /* Memset everything */\n    pj_bzero(sess, sizeof(pjmedia_rtcp_session));\n\n    /* Last RX timestamp in RTP packet */\n    sess->rtp_last_ts = (unsigned)-1;\n\n    /* Name */\n    sess->name = settings->name ? settings->name : (char*)THIS_FILE;\n\n    /* Set clock rate */\n    sess->clock_rate = settings->clock_rate;\n    sess->pkt_size = settings->samples_per_frame;\n\n    /* Init common RTCP SR header */\n    sr_pkt->common.version = 2;\n    sr_pkt->common.count = 1;\n    sr_pkt->common.pt = RTCP_SR;\n    sr_pkt->common.length = pj_htons(12);\n    sr_pkt->common.ssrc = pj_htonl(settings->ssrc);\n    \n    /* Copy to RTCP RR header */\n    pj_memcpy(&sess->rtcp_rr_pkt.common, &sr_pkt->common, \n\t      sizeof(pjmedia_rtcp_common));\n    sess->rtcp_rr_pkt.common.pt = RTCP_RR;\n    sess->rtcp_rr_pkt.common.length = pj_htons(7);\n\n    /* Copy to RTCP FB common header */\n    pj_memcpy(&sess->rtcp_fb_com, &sr_pkt->common, \n\t      sizeof(pjmedia_rtcp_common));\n    sess->rtcp_fb_com.ssrc_src = 0;\n\n    /* Get time and timestamp base and frequency */\n    pj_gettimeofday(&now);\n    sess->tv_base = now;\n    pj_get_timestamp(&sess->ts_base);\n    pj_get_timestamp_freq(&sess->ts_freq);\n    sess->rtp_ts_base = settings->rtp_ts_base;\n\n    /* Initialize statistics states */\n    pjmedia_rtcp_init_stat(&sess->stat);\n\n    /* RR will be initialized on receipt of the first RTP packet. */\n}", "target": 3, "idx": 9938}
{"commit_id": "10b3823a7619ed22d42764733eb052c4159bc8c1", "project": "ImageMagick", "func": "static MagickBooleanType WritePDBImage(const ImageInfo *image_info,Image *image)\n{\n  const char\n    *comment;\n\n  int\n    bits;\n\n  MagickBooleanType\n    status;\n\n  PDBImage\n    pdb_image;\n\n  PDBInfo\n    pdb_info;\n\n  QuantumInfo\n    *quantum_info;\n\n  register const PixelPacket\n    *p;\n\n  register ssize_t\n    x;\n\n  register unsigned char\n    *q;\n\n  size_t\n    bits_per_pixel,\n    literal,\n    packets,\n    packet_size,\n    repeat;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *buffer,\n    *runlength,\n    *scanline;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) TransformImageColorspace(image,sRGBColorspace);\n  if ((image -> colors <= 2 ) ||\n      (GetImageType(image,&image->exception ) == BilevelType)) {\n    bits_per_pixel=1;\n  } else if (image->colors <= 4) {\n    bits_per_pixel=2;\n  } else if (image->colors <= 8) {\n    bits_per_pixel=3;\n  } else {\n    bits_per_pixel=4;\n  }\n  (void) ResetMagickMemory(&pdb_info,0,sizeof(pdb_info));\n  (void) CopyMagickString(pdb_info.name,image_info->filename,\n    sizeof(pdb_info.name));\n  pdb_info.attributes=0;\n  pdb_info.version=0;\n  pdb_info.create_time=time(NULL);\n  pdb_info.modify_time=pdb_info.create_time;\n  pdb_info.archive_time=0;\n  pdb_info.modify_number=0;\n  pdb_info.application_info=0;\n  pdb_info.sort_info=0;\n  (void) CopyMagickMemory(pdb_info.type,\"vIMG\",4);\n  (void) CopyMagickMemory(pdb_info.id,\"View\",4);\n  pdb_info.seed=0;\n  pdb_info.next_record=0;\n  comment=GetImageProperty(image,\"comment\");\n  pdb_info.number_records=(comment == (const char *) NULL ? 1 : 2);\n  (void) WriteBlob(image,sizeof(pdb_info.name),(unsigned char *) pdb_info.name);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_info.attributes);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_info.version);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.create_time);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.modify_time);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.archive_time);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.modify_number);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.application_info);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.sort_info);\n  (void) WriteBlob(image,4,(unsigned char *) pdb_info.type);\n  (void) WriteBlob(image,4,(unsigned char *) pdb_info.id);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.seed);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.next_record);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_info.number_records);\n  (void) CopyMagickString(pdb_image.name,pdb_info.name,sizeof(pdb_image.name));\n  pdb_image.version=1;  /* RLE Compressed */\n  switch (bits_per_pixel)\n  {\n    case 1: pdb_image.type=(unsigned char) 0xff; break;  /* monochrome */\n    case 2: pdb_image.type=(unsigned char) 0x00; break;  /* 2 bit gray */\n    default: pdb_image.type=(unsigned char) 0x02;  /* 4 bit gray */\n  }\n  pdb_image.reserved_1=0;\n  pdb_image.note=0;\n  pdb_image.x_last=0;\n  pdb_image.y_last=0;\n  pdb_image.reserved_2=0;\n  pdb_image.x_anchor=(unsigned short) 0xffff;\n  pdb_image.y_anchor=(unsigned short) 0xffff;\n  pdb_image.width=(short) image->columns;\n  if (image->columns % 16)\n    pdb_image.width=(short) (16*(image->columns/16+1));\n  pdb_image.height=(short) image->rows;\n  packets=((bits_per_pixel*image->columns+7)/8);\n  runlength=(unsigned char *) AcquireQuantumMemory(9UL*packets,\n    image->rows*sizeof(*runlength));\n  if (runlength == (unsigned char *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  buffer=(unsigned char *) AcquireQuantumMemory(512,sizeof(*buffer));\n  if (buffer == (unsigned char *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  packet_size=(size_t) (image->depth > 8 ? 2 : 1);\n  scanline=(unsigned char *) AcquireQuantumMemory(image->columns,packet_size*\n    sizeof(*scanline));\n  if (scanline == (unsigned char *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n    (void) TransformImageColorspace(image,sRGBColorspace);\n  /*\n    Convert to GRAY raster scanline.\n  */\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  status=SetQuantumDepth(image,quantum_info,image->depth > 8 ? 16 : 8);\n  bits=8/(int) bits_per_pixel-1;  /* start at most significant bits */\n  literal=0;\n  repeat=0;\n  q=runlength;\n  buffer[0]=0x00;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n    if (p == (const PixelPacket *) NULL)\n      break;\n    (void) ExportQuantumPixels(image,(const CacheView *) NULL,quantum_info,\n      GrayQuantum,scanline,&image->exception);\n    for (x=0; x < (ssize_t) pdb_image.width; x++)\n    {\n      if (x < (ssize_t) image->columns)\n        buffer[literal+repeat]|=(0xff-scanline[x*packet_size]) >>\n          (8-bits_per_pixel) << bits*bits_per_pixel;\n      bits--;\n      if (bits < 0)\n        {\n          if (((literal+repeat) > 0) &&\n              (buffer[literal+repeat] == buffer[literal+repeat-1]))\n            {\n              if (repeat == 0)\n                {\n                  literal--;\n                  repeat++;\n                }\n              repeat++;\n              if (0x7f < repeat)\n                {\n                  q=EncodeRLE(q,buffer,literal,repeat);\n                  literal=0;\n                  repeat=0;\n                }\n            }\n          else\n            {\n              if (repeat >= 2)\n                literal+=repeat;\n              else\n                {\n                  q=EncodeRLE(q,buffer,literal,repeat);\n                  buffer[0]=buffer[literal+repeat];\n                  literal=0;\n                }\n              literal++;\n              repeat=0;\n              if (0x7f < literal)\n                {\n                  q=EncodeRLE(q,buffer,(literal < 0x80 ? literal : 0x80),0);\n                  (void) CopyMagickMemory(buffer,buffer+literal+repeat,0x80);\n                  literal-=0x80;\n                }\n            }\n        bits=8/(int) bits_per_pixel-1;\n        buffer[literal+repeat]=0x00;\n      }\n    }\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  q=EncodeRLE(q,buffer,literal,repeat);\n  scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  /*\n    Write the Image record header.\n  */\n  (void) WriteBlobMSBLong(image,(unsigned int) (TellBlob(image)+8*\n    pdb_info.number_records));\n  (void) WriteBlobByte(image,0x40);\n  (void) WriteBlobByte(image,0x6f);\n  (void) WriteBlobByte(image,0x80);\n  (void) WriteBlobByte(image,0);\n  if (pdb_info.number_records > 1)\n    {\n      /*\n        Write the comment record header.\n      */\n      (void) WriteBlobMSBLong(image,(unsigned int) (TellBlob(image)+8+58+q-\n        runlength));\n      (void) WriteBlobByte(image,0x40);\n      (void) WriteBlobByte(image,0x6f);\n      (void) WriteBlobByte(image,0x80);\n      (void) WriteBlobByte(image,1);\n    }\n  /*\n    Write the Image data.\n  */\n  (void) WriteBlob(image,sizeof(pdb_image.name),(unsigned char *)\n    pdb_image.name);\n  (void) WriteBlobByte(image,(unsigned char) pdb_image.version);\n  (void) WriteBlobByte(image,pdb_image.type);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_image.reserved_1);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_image.note);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_image.x_last);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_image.y_last);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_image.reserved_2);\n  (void) WriteBlobMSBShort(image,pdb_image.x_anchor);\n  (void) WriteBlobMSBShort(image,pdb_image.y_anchor);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_image.width);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_image.height);\n  (void) WriteBlob(image,(size_t) (q-runlength),runlength);\n  runlength=(unsigned char *) RelinquishMagickMemory(runlength);\n  if (pdb_info.number_records > 1)\n    (void) WriteBlobString(image,comment);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}", "target": 2, "idx": 9939}
{"commit_id": "0efd112bb62f566877750ad62ee828bff579b4e2", "project": "babelouest/glewlwyd", "func": "static json_t * check_attestation_fido_u2f(json_t * j_params, unsigned char * credential_id, size_t credential_id_len, unsigned char * cert_x, size_t cert_x_len, unsigned char * cert_y, size_t cert_y_len, cbor_item_t * att_stmt, unsigned char * rpid_hash, size_t rpid_hash_len, const unsigned char * client_data) {\n  json_t * j_error = json_array(), * j_return;\n  cbor_item_t * key = NULL, * x5c = NULL, * sig = NULL, * att_cert = NULL;\n  int i, ret;\n  char * message = NULL;\n  gnutls_pubkey_t pubkey = NULL;\n  gnutls_x509_crt_t cert = NULL;\n  gnutls_datum_t cert_dat, data, signature, cert_issued_by;\n  unsigned char * data_signed = NULL, client_data_hash[32], cert_export[32], cert_export_b64[64];\n  size_t data_signed_offset = 0, client_data_hash_len = 32, cert_export_len = 32, cert_export_b64_len = 0;\n  \n  if (j_error != NULL) {\n    do {\n      if (gnutls_x509_crt_init(&cert)) {\n        json_array_append_new(j_error, json_string(\"check_attestation_fido_u2f - Error gnutls_x509_crt_init\"));\n        break;\n      }\n      if (gnutls_pubkey_init(&pubkey)) {\n        json_array_append_new(j_error, json_string(\"check_attestation_fido_u2f - Error gnutls_pubkey_init\"));\n        break;\n      }\n      \n      // Step 1\n      if (att_stmt == NULL || !cbor_isa_map(att_stmt) || cbor_map_size(att_stmt) != 2) {\n        json_array_append_new(j_error, json_string(\"CBOR map value 'attStmt' invalid format\"));\n        break;\n      }\n      for (i=0; i<2; i++) {\n        key = cbor_map_handle(att_stmt)[i].key;\n        if (cbor_isa_string(key)) {\n          if (0 == o_strncmp((const char *)cbor_string_handle(key), \"x5c\", MIN(o_strlen(\"x5c\"), cbor_string_length(key)))) {\n            x5c = cbor_map_handle(att_stmt)[i].value;\n          } else if (0 == o_strncmp((const char *)cbor_string_handle(key), \"sig\", MIN(o_strlen(\"sig\"), cbor_string_length(key)))) {\n            sig = cbor_map_handle(att_stmt)[i].value;\n          } else {\n            message = msprintf(\"attStmt map element %d key is not valid: '%.*s'\", i, cbor_string_length(key), cbor_string_handle(key));\n            json_array_append_new(j_error, json_string(message));\n            o_free(message);\n            break;\n          }\n        } else {\n          message = msprintf(\"attStmt map element %d key is not a string\", i);\n          json_array_append_new(j_error, json_string(message));\n          o_free(message);\n          break;\n        }\n      }\n      if (x5c == NULL || !cbor_isa_array(x5c) || cbor_array_size(x5c) != 1) {\n        json_array_append_new(j_error, json_string(\"CBOR map value 'x5c' invalid format\"));\n        break;\n      }\n      att_cert = cbor_array_get(x5c, 0);\n      cert_dat.data = cbor_bytestring_handle(att_cert);\n      cert_dat.size = cbor_bytestring_length(att_cert);\n      if ((ret = gnutls_x509_crt_import(cert, &cert_dat, GNUTLS_X509_FMT_DER)) < 0) {\n        json_array_append_new(j_error, json_string(\"Error importing x509 certificate\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - Error gnutls_pcert_import_x509_raw: %d\", ret);\n        break;\n      }\n      if (json_object_get(j_params, \"root-ca-list\") != json_null() && validate_certificate_from_root(j_params, cert, x5c) != G_OK) {\n        json_array_append_new(j_error, json_string(\"Unrecognized certificate authority\"));\n        if (gnutls_x509_crt_get_issuer_dn2(cert, &cert_issued_by) >= 0) {\n          message = msprintf(\"Unrecognized certificate autohority: %.*s\", cert_issued_by.size, cert_issued_by.data);\n          y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - %s\", message);\n          o_free(message);\n          gnutls_free(cert_issued_by.data);\n        } else {\n          y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - Unrecognized certificate autohority (unable to get issuer dn)\");\n        }\n        break;\n      }\n      if ((ret = gnutls_pubkey_import_x509(pubkey, cert, 0)) < 0) {\n        json_array_append_new(j_error, json_string(\"Error importing x509 certificate\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - Error gnutls_pubkey_import_x509: %d\", ret);\n        break;\n      }\n      if ((ret = gnutls_x509_crt_get_key_id(cert, GNUTLS_KEYID_USE_SHA256, cert_export, &cert_export_len)) < 0) {\n        json_array_append_new(j_error, json_string(\"Error exporting x509 certificate\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - Error gnutls_x509_crt_get_key_id: %d\", ret);\n        break;\n      }\n      if (!o_base64_encode(cert_export, cert_export_len, cert_export_b64, &cert_export_b64_len)) {\n        json_array_append_new(j_error, json_string(\"Internal error\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - Error o_base64_encode cert_export\");\n        break;\n      }\n      if (!generate_digest_raw(digest_SHA256, client_data, o_strlen((char *)client_data), client_data_hash, &client_data_hash_len)) {\n        json_array_append_new(j_error, json_string(\"Internal error\"));\n        y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_fido_u2f - Error generate_digest_raw client_data\");\n        break;\n      }\n\n      if (sig == NULL || !cbor_isa_bytestring(sig)) {\n        json_array_append_new(j_error, json_string(\"Error sig is not a bytestring\"));\n        break;\n      }\n      \n      if ((data_signed = o_malloc(rpid_hash_len+client_data_hash_len+credential_id_len+cert_x_len+cert_y_len+2)) == NULL) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - Error allocating data_signed\");\n        json_array_append_new(j_error, json_string(\"Internal error\"));\n        break;\n      }\n      \n      // Build bytestring to verify signature\n      data_signed[0] = 0x0;\n      data_signed_offset = 1;\n      \n      memcpy(data_signed+data_signed_offset, rpid_hash, rpid_hash_len);\n      data_signed_offset += rpid_hash_len;\n      \n      memcpy(data_signed+data_signed_offset, client_data_hash, client_data_hash_len);\n      data_signed_offset+=client_data_hash_len;\n      \n      memcpy(data_signed+data_signed_offset, credential_id, credential_id_len);\n      data_signed_offset+=credential_id_len;\n      \n      data_signed[data_signed_offset] = 0x04;\n      data_signed_offset++;\n      \n      memcpy(data_signed+data_signed_offset, cert_x, cert_x_len);\n      data_signed_offset+=cert_x_len;\n      \n      memcpy(data_signed+data_signed_offset, cert_y, cert_y_len);\n      data_signed_offset+=cert_y_len;\n        \n      // Let's verify sig over data_signed\n      data.data = data_signed;\n      data.size = data_signed_offset;\n      \n      signature.data = cbor_bytestring_handle(sig);\n      signature.size = cbor_bytestring_length(sig);\n      \n      if (gnutls_pubkey_verify_data2(pubkey, GNUTLS_SIGN_ECDSA_SHA256, 0, &data, &signature)) {\n        json_array_append_new(j_error, json_string(\"Invalid signature\"));\n      }\n      \n    } while (0);\n    o_free(data_signed);\n    \n    if (json_array_size(j_error)) {\n      j_return = json_pack(\"{sisO}\", \"result\", G_ERROR_PARAM, \"error\", j_error);\n    } else {\n      j_return = json_pack(\"{sis{ss%}}\", \"result\", G_OK, \"data\", \"certificate\", cert_export_b64, cert_export_b64_len);\n    }\n    json_decref(j_error);\n    gnutls_pubkey_deinit(pubkey);\n    gnutls_x509_crt_deinit(cert);\n    if (att_cert != NULL) {\n      cbor_decref(&att_cert);\n    }\n    \n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_fido_u2f - Error allocating resources for j_error\");\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n  }\n  return j_return;\n}", "target": 3, "idx": 9940}
{"commit_id": "f57bd745b4cbed577ea654fad4701bea4d38b44c", "project": "moonlight-stream/moonlight-common-c", "func": "static PSDP_OPTION getAttributesList(char*urlSafeAddr) {\n    PSDP_OPTION optionHead;\n    char payloadStr[92];\n    int audioChannelCount;\n    int audioChannelMask;\n    int err;\n\n    optionHead = NULL;\n    err = 0;\n\n    sprintf(payloadStr, \"%d\", StreamConfig.width);\n    err |= addAttributeString(&optionHead, \"x-nv-video[0].clientViewportWd\", payloadStr);\n    sprintf(payloadStr, \"%d\", StreamConfig.height);\n    err |= addAttributeString(&optionHead, \"x-nv-video[0].clientViewportHt\", payloadStr);\n\n    sprintf(payloadStr, \"%d\", StreamConfig.fps);\n    err |= addAttributeString(&optionHead, \"x-nv-video[0].maxFPS\", payloadStr);\n\n    sprintf(payloadStr, \"%d\", StreamConfig.packetSize);\n    err |= addAttributeString(&optionHead, \"x-nv-video[0].packetSize\", payloadStr);\n\n    err |= addAttributeString(&optionHead, \"x-nv-video[0].rateControlMode\", \"4\");\n\n    err |= addAttributeString(&optionHead, \"x-nv-video[0].timeoutLengthMs\", \"7000\");\n    err |= addAttributeString(&optionHead, \"x-nv-video[0].framesWithInvalidRefThreshold\", \"0\");\n\n    sprintf(payloadStr, \"%d\", StreamConfig.bitrate);\n    if (AppVersionQuad[0] >= 5) {\n        err |= addAttributeString(&optionHead, \"x-nv-vqos[0].bw.minimumBitrateKbps\", payloadStr);\n        err |= addAttributeString(&optionHead, \"x-nv-vqos[0].bw.maximumBitrateKbps\", payloadStr);\n    }\n    else {\n        if (StreamConfig.streamingRemotely) {\n            err |= addAttributeString(&optionHead, \"x-nv-video[0].averageBitrate\", \"4\");\n            err |= addAttributeString(&optionHead, \"x-nv-video[0].peakBitrate\", \"4\");\n        }\n        // We don't support dynamic bitrate scaling properly (it tends to bounce between min and max and never\n        // settle on the optimal bitrate if it's somewhere in the middle), so we'll just latch the bitrate\n        // to the requested value.\n\n        err |= addAttributeString(&optionHead, \"x-nv-vqos[0].bw.minimumBitrate\", payloadStr);\n        err |= addAttributeString(&optionHead, \"x-nv-vqos[0].bw.maximumBitrate\", payloadStr);\n    }\n\n    // Using FEC turns padding on which makes us have to take the slow path\n    // in the depacketizer, not to mention exposing some ambiguous cases with\n    // distinguishing padding from valid sequences. Since we can only perform\n    // execute an FEC recovery on a 1 packet frame, we'll just turn it off completely.\n    err |= addAttributeString(&optionHead, \"x-nv-vqos[0].fec.enable\", \"0\");\n\n    err |= addAttributeString(&optionHead, \"x-nv-vqos[0].videoQualityScoreUpdateTime\", \"5000\");\n\n    if (StreamConfig.streamingRemotely) {\n        err |= addAttributeString(&optionHead, \"x-nv-vqos[0].qosTrafficType\", \"0\");\n        err |= addAttributeString(&optionHead, \"x-nv-aqos.qosTrafficType\", \"0\");\n    }\n    else {\n        err |= addAttributeString(&optionHead, \"x-nv-vqos[0].qosTrafficType\", \"5\");\n        err |= addAttributeString(&optionHead, \"x-nv-aqos.qosTrafficType\", \"4\");\n    }\n\n    if (AppVersionQuad[0] == 3) {\n        err |= addGen3Options(&optionHead, urlSafeAddr);\n    }\n    else if (AppVersionQuad[0] == 4) {\n        err |= addGen4Options(&optionHead, urlSafeAddr);\n    }\n    else {\n        err |= addGen5Options(&optionHead);\n    }\n\n    if (AppVersionQuad[0] >= 4) {\n        if (NegotiatedVideoFormat == VIDEO_FORMAT_H265) {\n            err |= addAttributeString(&optionHead, \"x-nv-clientSupportHevc\", \"1\");\n            err |= addAttributeString(&optionHead, \"x-nv-vqos[0].bitStreamFormat\", \"1\");\n            \n            // Disable slicing on HEVC\n            err |= addAttributeString(&optionHead, \"x-nv-video[0].videoEncoderSlicesPerFrame\", \"1\");\n        }\n        else {\n            unsigned char slicesPerFrame;\n            \n            err |= addAttributeString(&optionHead, \"x-nv-clientSupportHevc\", \"0\");\n            err |= addAttributeString(&optionHead, \"x-nv-vqos[0].bitStreamFormat\", \"0\");\n            \n            // Use slicing for increased performance on some decoders\n            slicesPerFrame = (unsigned char)(VideoCallbacks.capabilities >> 24);\n            if (slicesPerFrame == 0) {\n                // If not using slicing, we request 1 slice per frame\n                slicesPerFrame = 1;\n            }\n            sprintf(payloadStr, \"%d\", slicesPerFrame);\n            err |= addAttributeString(&optionHead, \"x-nv-video[0].videoEncoderSlicesPerFrame\", payloadStr);\n        }\n        \n        if (StreamConfig.audioConfiguration == AUDIO_CONFIGURATION_51_SURROUND) {\n            audioChannelCount = CHANNEL_COUNT_51_SURROUND;\n            audioChannelMask = CHANNEL_MASK_51_SURROUND;\n        }\n        else {\n            audioChannelCount = CHANNEL_COUNT_STEREO;\n            audioChannelMask = CHANNEL_MASK_STEREO;\n        }\n\n        sprintf(payloadStr, \"%d\", audioChannelCount);\n        err |= addAttributeString(&optionHead, \"x-nv-audio.surround.numChannels\", payloadStr);\n        sprintf(payloadStr, \"%d\", audioChannelMask);\n        err |= addAttributeString(&optionHead, \"x-nv-audio.surround.channelMask\", payloadStr);\n        if (audioChannelCount > 2) {\n            err |= addAttributeString(&optionHead, \"x-nv-audio.surround.enable\", \"1\");\n        }\n        else {\n            err |= addAttributeString(&optionHead, \"x-nv-audio.surround.enable\", \"0\");\n        }\n    }\n\n    if (err == 0) {\n        return optionHead;\n    }\n\n    freeAttributeList(optionHead);\n    return NULL;\n}", "target": 2, "idx": 9941}
{"commit_id": "cf6771c857eb9a290e2c19ddacfdd3ed98b27618", "project": "gpac", "func": "u32 gf_bs_read_ue_log_idx3(GF_BitStream *bs, const char *fname, s32 idx1, s32 idx2, s32 idx3)\n{\n\tu32 val=0, code;\n\ts32 nb_lead = -1;\n\tu32 bits = 0;\n\tfor (code=0; !code; nb_lead++) {\n\t\tif (nb_lead>=32) {\n\t\t\t//gf_bs_read_int keeps returning 0 on EOS, so if no more bits available, rbsp was truncated otherwise code is broken in rbsp)\n\t\t\t//we only test once nb_lead>=32 to avoid testing at each bit read\n\t\t\tif (!gf_bs_available(bs)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[Core] exp-golomb read failed, not enough bits in bitstream !\\n\"));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[Core] corrupted exp-golomb code, %d leading zeros, max 31 allowed !\\n\", nb_lead));\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\tcode = gf_bs_read_int(bs, 1);\n\t\tbits++;\n\t}\n\n\tif (nb_lead) {\n\t\tu32 leads=1;\n\t\tval = gf_bs_read_int(bs, nb_lead);\n\t\tleads <<= nb_lead;\n\t\tleads -= 1;\n\t\tval += leads;\n//\t\tval += (1 << nb_lead) - 1;\n\t\tbits += nb_lead;\n\t}\n\n\tif (fname) {\n\t\tgf_bs_log_idx(bs, bits, fname, val, idx1, idx2, idx3);\n\t}\n\treturn val;\n}", "target": 1, "idx": 9942}
{"commit_id": "0f931751fb20f565c4e94aa6df58d54a003cdb30", "project": "tensorflow", "func": "void Compute(OpKernelContext* context) override {\n    // Here's the basic idea:\n    // Batch and depth dimension are independent from row and col dimension. And\n    // because FractionalAvgPool currently only support pooling along row and\n    // col, we can basically think of this 4D tensor backpropagation as\n    // operation of a series of 2D planes.\n    //\n    // For each element of a 'slice' (2D plane) of output_backprop, we need to\n    // figure out its contributors when doing FractionalAvgPool operation. This\n    // can be done based on row_pooling_sequence, col_pooling_seq and\n    // overlapping.\n    // Once we figure out the original contributors, we just need to evenly\n    // divide the value of this element among these contributors.\n    //\n    // Internally, we divide the out_backprop tensor and store it in a temporary\n    // tensor of double type. And cast it to the corresponding type.\n    typedef Eigen::Map<const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>\n        ConstEigenMatrixMap;\n    typedef Eigen::Map<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>>\n        EigenDoubleMatrixMap;\n\n    // Grab the inputs.\n    const Tensor& orig_input_tensor_shape = context->input(0);\n    OP_REQUIRES(context,\n                orig_input_tensor_shape.dims() == 1 &&\n                    orig_input_tensor_shape.NumElements() == 4,\n                errors::InvalidArgument(\"original input tensor shape must be\"\n                                        \"1-dimensional and 4 elements\"));\n    const Tensor& out_backprop = context->input(1);\n    const Tensor& row_seq_tensor = context->input(2);\n    const Tensor& col_seq_tensor = context->input(3);\n\n    const int64_t out_batch = out_backprop.dim_size(0);\n    const int64_t out_rows = out_backprop.dim_size(1);\n    const int64_t out_cols = out_backprop.dim_size(2);\n    const int64_t out_depth = out_backprop.dim_size(3);\n\n    OP_REQUIRES(context, row_seq_tensor.NumElements() > out_rows,\n                errors::InvalidArgument(\"Given out_backprop shape \",\n                                        out_backprop.shape().DebugString(),\n                                        \", row_seq_tensor must have at least \",\n                                        out_rows + 1, \" elements, but got \",\n                                        row_seq_tensor.NumElements()));\n    OP_REQUIRES(context, col_seq_tensor.NumElements() > out_cols,\n                errors::InvalidArgument(\"Given out_backprop shape \",\n                                        out_backprop.shape().DebugString(),\n                                        \", col_seq_tensor must have at least \",\n                                        out_cols + 1, \" elements, but got \",\n                                        col_seq_tensor.NumElements()));\n\n    auto row_seq_tensor_flat = row_seq_tensor.flat<int64>();\n    auto col_seq_tensor_flat = col_seq_tensor.flat<int64>();\n    auto orig_input_tensor_shape_flat = orig_input_tensor_shape.flat<int64>();\n\n    const int64_t in_batch = orig_input_tensor_shape_flat(0);\n    const int64_t in_rows = orig_input_tensor_shape_flat(1);\n    const int64_t in_cols = orig_input_tensor_shape_flat(2);\n    const int64_t in_depth = orig_input_tensor_shape_flat(3);\n    OP_REQUIRES(\n        context, in_batch != 0,\n        errors::InvalidArgument(\"Batch dimension of input must not be 0\"));\n    OP_REQUIRES(\n        context, in_rows != 0,\n        errors::InvalidArgument(\"Rows dimension of input must not be 0\"));\n    OP_REQUIRES(\n        context, in_cols != 0,\n        errors::InvalidArgument(\"Columns dimension of input must not be 0\"));\n    OP_REQUIRES(\n        context, in_depth != 0,\n        errors::InvalidArgument(\"Depth dimension of input must not be 0\"));\n\n    constexpr int tensor_in_and_out_dims = 4;\n    // Transform orig_input_tensor_shape into TensorShape\n    TensorShape in_shape;\n    for (auto i = 0; i < tensor_in_and_out_dims; ++i) {\n      in_shape.AddDim(orig_input_tensor_shape_flat(i));\n    }\n\n    // Create intermediate in_backprop.\n    Tensor in_backprop_tensor_temp;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_temp(\n                                {0}, DataTypeToEnum<double>::v(), in_shape,\n                                &in_backprop_tensor_temp));\n    in_backprop_tensor_temp.flat<double>().setZero();\n    // Transform 4D tensor to 2D matrix.\n    EigenDoubleMatrixMap in_backprop_tensor_temp_mat(\n        in_backprop_tensor_temp.flat<double>().data(), in_depth,\n        in_cols * in_rows * in_batch);\n    ConstEigenMatrixMap out_backprop_mat(out_backprop.flat<T>().data(),\n                                         out_depth,\n                                         out_cols * out_rows * out_batch);\n    // Loop through each element of out_backprop and evenly distribute the\n    // element to the corresponding pooling cell.\n    const int64_t in_max_row_index = in_rows - 1;\n    const int64_t in_max_col_index = in_cols - 1;\n    for (int64_t b = 0; b < out_batch; ++b) {\n      for (int64_t r = 0; r < out_rows; ++r) {\n        const int64_t in_row_start = row_seq_tensor_flat(r);\n        int64_t in_row_end = overlapping_ ? row_seq_tensor_flat(r + 1)\n                                          : row_seq_tensor_flat(r + 1) - 1;\n        in_row_end = std::min(in_row_end, in_max_row_index);\n        for (int64_t c = 0; c < out_cols; ++c) {\n          const int64_t in_col_start = col_seq_tensor_flat(c);\n          int64_t in_col_end = overlapping_ ? col_seq_tensor_flat(c + 1)\n                                            : col_seq_tensor_flat(c + 1) - 1;\n          in_col_end = std::min(in_col_end, in_max_col_index);\n\n          const int64_t num_elements_in_pooling_cell =\n              (in_row_end - in_row_start + 1) * (in_col_end - in_col_start + 1);\n          const int64_t out_index = (b * out_rows + r) * out_cols + c;\n          // Now we can evenly distribute out_backprop(b, h, w, *) to\n          // in_backprop(b, hs:he, ws:we, *).\n          for (int64_t in_r = in_row_start; in_r <= in_row_end; ++in_r) {\n            for (int64_t in_c = in_col_start; in_c <= in_col_end; ++in_c) {\n              const int64_t in_index = (b * in_rows + in_r) * in_cols + in_c;\n              // Walk through each channel (depth).\n              for (int64_t d = 0; d < out_depth; ++d) {\n                const double out_backprop_element = static_cast<double>(\n                    out_backprop_mat.coeffRef(d, out_index));\n                double& in_backprop_ref =\n                    in_backprop_tensor_temp_mat.coeffRef(d, in_index);\n                in_backprop_ref +=\n                    out_backprop_element / num_elements_in_pooling_cell;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Depending on the type, cast double to type T.\n    Tensor* in_backprop_tensor = nullptr;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                {0}, 0, in_shape, &in_backprop_tensor));\n    auto in_backprop_tensor_flat = in_backprop_tensor->flat<T>();\n    auto in_backprop_tensor_temp_flat = in_backprop_tensor_temp.flat<double>();\n    for (int64_t i = 0; i < in_backprop_tensor_flat.size(); ++i) {\n      in_backprop_tensor_flat(i) =\n          static_cast<T>(in_backprop_tensor_temp_flat(i));\n    }\n  }", "target": 2, "idx": 9943}
{"commit_id": "8e585e623b1d666b4ef736ed609264639cb27701", "project": "gpac", "func": "GF_Err gf_isom_box_parse_ex(GF_Box **outBox, GF_BitStream *bs, u32 parent_type, Bool is_root_box)\n{\n\tu32 type, uuid_type, hdr_size;\n\tu64 size, start, payload_start, end;\n\tchar uuid[16];\n\tGF_Err e;\n\tGF_Box *newBox;\n\tBool skip_logs = gf_bs_get_cookie(bs) ? GF_TRUE : GF_FALSE;\n\tBool is_special = GF_TRUE;\n\n\tif ((bs == NULL) || (outBox == NULL) ) return GF_BAD_PARAM;\n\t*outBox = NULL;\n\tif (gf_bs_available(bs) < 8) {\n\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t}\n\n\tstart = gf_bs_get_position(bs);\n\n\tuuid_type = 0;\n\tsize = (u64) gf_bs_read_u32(bs);\n\thdr_size = 4;\n\t/*fix for some boxes found in some old hinted files*/\n\tif ((size >= 2) && (size <= 4)) {\n\t\tsize = 4;\n\t\ttype = GF_ISOM_BOX_TYPE_VOID;\n\t} else {\n\t\ttype = gf_bs_read_u32(bs);\n\t\thdr_size += 4;\n\t\t/*no size means till end of file - EXCEPT FOR some old QuickTime boxes...*/\n\t\tif (type == GF_ISOM_BOX_TYPE_TOTL)\n\t\t\tsize = 12;\n\t\tif (!size) {\n\t\t\tif (is_root_box) {\n\t\t\t\tif (!skip_logs) {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Warning Read Box type %s (0x%08X) size 0 reading till the end of file\\n\", gf_4cc_to_str(type), type));\n\t\t\t\t}\n\t\t\t\tsize = gf_bs_available(bs) + 8;\n\t\t\t} else {\n\t\t\t\tif (!skip_logs) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Read Box type %s (0x%08X) at position \"LLU\" has size 0 but is not at root/file level, skipping\\n\", gf_4cc_to_str(type), type, start));\n\t\t\t\t}\n\t\t\t\treturn GF_OK;\n//\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t}\n\t}\n\t/*handle uuid*/\n\tmemset(uuid, 0, 16);\n\tif (type == GF_ISOM_BOX_TYPE_UUID ) {\n\t\tif (gf_bs_available(bs) < 16) {\n\t\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t\t}\n\t\tgf_bs_read_data(bs, uuid, 16);\n\t\thdr_size += 16;\n\t\tuuid_type = gf_isom_solve_uuid_box(uuid);\n\t}\n\n\t//handle large box\n\tif (size == 1) {\n\t\tif (gf_bs_available(bs) < 8) {\n\t\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t\t}\n\t\tsize = gf_bs_read_u64(bs);\n\t\thdr_size += 8;\n\t}\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Read Box type %s size \"LLD\" start \"LLD\"\\n\", gf_4cc_to_str(type), LLD_CAST size, LLD_CAST start));\n\n\tif ( size < hdr_size ) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box size \"LLD\" less than box header size %d\\n\", LLD_CAST size, hdr_size));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\t//some special boxes (references and track groups) are handled by a single generic box with an associated ref/group type\n\tif (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TREF)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFT);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t\t((GF_TrackReferenceTypeBox*)newBox)->reference_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_IREF)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFI);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t\t((GF_ItemReferenceTypeBox*)newBox)->reference_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TRGR)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_TRGT);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t\t((GF_TrackGroupTypeBox*)newBox)->group_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_GRPL)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_GRPT);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t\t((GF_EntityToGroupTypeBox*)newBox)->grouping_type = type;\n\t} else {\n\t\t//OK, create the box based on the type\n\t\tis_special = GF_FALSE;\n\t\tnewBox = gf_isom_box_new_ex(uuid_type ? uuid_type : type, parent_type, skip_logs, is_root_box);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t}\n\n\t//OK, init and read this box\n\tif (type==GF_ISOM_BOX_TYPE_UUID && !is_special) {\n\t\tmemcpy(((GF_UUIDBox *)newBox)->uuid, uuid, 16);\n\t\t((GF_UUIDBox *)newBox)->internal_4cc = uuid_type;\n\t}\n\n\tif (!newBox->type) newBox->type = type;\n\tpayload_start = gf_bs_get_position(bs);\n\nretry_unknown_box:\n\n\tend = gf_bs_available(bs);\n\tif (size - hdr_size > end ) {\n\t\tnewBox->size = size - hdr_size - end;\n\t\t*outBox = newBox;\n\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t}\n\n\tnewBox->size = size - hdr_size;\n\n\t//parse even if size is 0 - this makes sure that we perform box parsing (usually in box->read)\n\te = gf_isom_full_box_read(newBox, bs);\n\tif (!e) e = gf_isom_box_read(newBox, bs);\n\tnewBox->size = size;\n\tend = gf_bs_get_position(bs);\n\n\tif (e && (e != GF_ISOM_INCOMPLETE_FILE)) {\n\t\tgf_isom_box_del(newBox);\n\t\t*outBox = NULL;\n\n\t\tif (parent_type==GF_ISOM_BOX_TYPE_STSD) {\n\t\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_UNKNOWN);\n\t\t\t((GF_UnknownBox *)newBox)->original_4cc = type;\n\t\t\tnewBox->size = size;\n\t\t\tgf_bs_seek(bs, payload_start);\n\t\t\tgoto retry_unknown_box;\n\t\t}\n\t\tif (!skip_logs) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Read Box \\\"%s\\\" (start \"LLU\") failed (%s) - skipping\\n\", gf_4cc_to_str(type), start, gf_error_to_string(e)));\n\t\t}\n\t\t//we don't try to reparse known boxes that have been failing (too dangerous)\n\t\treturn e;\n\t}\n\n\tif (end-start > size) {\n\t\tif (!skip_logs) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" size \"LLU\" (start \"LLU\") invalid (read \"LLU\")\\n\", gf_4cc_to_str(type), LLU_CAST size, start, LLU_CAST (end-start) ));\n\t\t}\n\t\t/*let's still try to load the file since no error was notified*/\n\t\tgf_bs_seek(bs, start+size);\n\t} else if (end-start < size) {\n\t\tu32 to_skip = (u32) (size-(end-start));\n\t\tif (!skip_logs) {\n\t\t\tif ((to_skip!=4) || gf_bs_peek_bits(bs, 32, 0)) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" (start \"LLU\") has %u extra bytes\\n\", gf_4cc_to_str(type), start, to_skip));\n\t\t\t}\n\t\t}\n\t\tgf_bs_skip_bytes(bs, to_skip);\n\t}\n\t*outBox = newBox;\n\n\treturn e;\n}", "target": 1, "idx": 9944}
{"commit_id": "dfb4357da6ddbdf57d583ba64361c9d792b0e0b1", "project": "kernel/git/tip/tip", "func": "static inline int\n__mod_timer(struct timer_list *timer, unsigned long expires, bool pending_only)\n{\n\tstruct timer_base *base, *new_base;\n\tunsigned int idx = UINT_MAX;\n\tunsigned long clk = 0, flags;\n\tint ret = 0;\n\n\tBUG_ON(!timer->function);\n\n\t/*\n\t * This is a common optimization triggered by the networking code - if\n\t * the timer is re-modified to have the same timeout or ends up in the\n\t * same array bucket then just return:\n\t */\n\tif (timer_pending(timer)) {\n\t\tif (timer->expires == expires)\n\t\t\treturn 1;\n\n\t\t/*\n\t\t * We lock timer base and calculate the bucket index right\n\t\t * here. If the timer ends up in the same bucket, then we\n\t\t * just update the expiry time and avoid the whole\n\t\t * dequeue/enqueue dance.\n\t\t */\n\t\tbase = lock_timer_base(timer, &flags);\n\n\t\tclk = base->clk;\n\t\tidx = calc_wheel_index(expires, clk);\n\n\t\t/*\n\t\t * Retrieve and compare the array index of the pending\n\t\t * timer. If it matches set the expiry to the new value so a\n\t\t * subsequent call will exit in the expires check above.\n\t\t */\n\t\tif (idx == timer_get_idx(timer)) {\n\t\t\ttimer->expires = expires;\n\t\t\tret = 1;\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else {\n\t\tbase = lock_timer_base(timer, &flags);\n\t}\n\n\tret = detach_if_pending(timer, base, false);\n\tif (!ret && pending_only)\n\t\tgoto out_unlock;\n\n\tdebug_activate(timer, expires);\n\n\tnew_base = get_target_base(base, timer->flags);\n\n\tif (base != new_base) {\n\t\t/*\n\t\t * We are trying to schedule the timer on the new base.\n\t\t * However we can't change timer's base while it is running,\n\t\t * otherwise del_timer_sync() can't detect that the timer's\n\t\t * handler yet has not finished. This also guarantees that the\n\t\t * timer is serialized wrt itself.\n\t\t */\n\t\tif (likely(base->running_timer != timer)) {\n\t\t\t/* See the comment in lock_timer_base() */\n\t\t\ttimer->flags |= TIMER_MIGRATING;\n\n\t\t\tspin_unlock(&base->lock);\n\t\t\tbase = new_base;\n\t\t\tspin_lock(&base->lock);\n\t\t\tWRITE_ONCE(timer->flags,\n\t\t\t\t   (timer->flags & ~TIMER_BASEMASK) | base->cpu);\n\t\t}\n\t}\n\n\t/* Try to forward a stale timer base clock */\n\tforward_timer_base(base);\n\n\ttimer->expires = expires;\n\t/*\n\t * If 'idx' was calculated above and the base time did not advance\n\t * between calculating 'idx' and possibly switching the base, only\n\t * enqueue_timer() and trigger_dyntick_cpu() is required. Otherwise\n\t * we need to (re)calculate the wheel index via\n\t * internal_add_timer().\n\t */\n\tif (idx != UINT_MAX && clk == base->clk) {\n\t\tenqueue_timer(base, timer, idx);\n\t\ttrigger_dyntick_cpu(base, timer);\n\t} else {\n\t\tinternal_add_timer(base, timer);\n\t}\n\nout_unlock:\n\tspin_unlock_irqrestore(&base->lock, flags);\n\n\treturn ret;\n}", "target": 1, "idx": 9945}
{"commit_id": "d6bbe53a96b031ab8b53d20241825ddf9e8bf8f1", "project": "libtiff", "func": "static enum TIFFReadDirEntryErr\nTIFFReadDirEntryArrayWithLimit(TIFF *tif, TIFFDirEntry *direntry,\n                               uint32_t *count, uint32_t desttypesize,\n                               void **value, uint64_t maxcount)\n{\n    int typesize;\n    uint32_t datasize;\n    void *data;\n    uint64_t target_count64;\n    int original_datasize_clamped;\n    typesize = TIFFDataWidth(direntry->tdir_type);\n\n    target_count64 =\n        (direntry->tdir_count > maxcount) ? maxcount : direntry->tdir_count;\n\n    if ((target_count64 == 0) || (typesize == 0))\n    {\n        *value = 0;\n        return (TIFFReadDirEntryErrOk);\n    }\n    (void)desttypesize;\n\n    /* We just want to know if the original tag size is more than 4 bytes\n     * (classic TIFF) or 8 bytes (BigTIFF)\n     */\n    original_datasize_clamped =\n        ((direntry->tdir_count > 10) ? 10 : (int)direntry->tdir_count) *\n        typesize;\n\n    /*\n     * As a sanity check, make sure we have no more than a 2GB tag array\n     * in either the current data type or the dest data type.  This also\n     * avoids problems with overflow of tmsize_t on 32bit systems.\n     */\n    if ((uint64_t)(MAX_SIZE_TAG_DATA / typesize) < target_count64)\n        return (TIFFReadDirEntryErrSizesan);\n    if ((uint64_t)(MAX_SIZE_TAG_DATA / desttypesize) < target_count64)\n        return (TIFFReadDirEntryErrSizesan);\n\n    *count = (uint32_t)target_count64;\n    datasize = (*count) * typesize;\n    assert((tmsize_t)datasize > 0);\n\n    /* Before allocating a huge amount of memory for corrupted files, check if\n     * size of requested memory is not greater than file size.\n     */\n    uint64_t filesize = TIFFGetFileSize(tif);\n    if (datasize > filesize)\n    {\n        TIFFWarningExtR(tif, \"ReadDirEntryArray\",\n                        \"Requested memory size for tag %d (0x%x) %\" PRIu32\n                        \" is greather than filesize %\" PRIu64\n                        \". Memory not allocated, tag not read\",\n                        direntry->tdir_tag, direntry->tdir_tag, datasize,\n                        filesize);\n        return (TIFFReadDirEntryErrAlloc);\n    }\n\n    if (isMapped(tif) && datasize > (uint64_t)tif->tif_size)\n        return TIFFReadDirEntryErrIo;\n\n    if (!isMapped(tif) && (((tif->tif_flags & TIFF_BIGTIFF) && datasize > 8) ||\n                           (!(tif->tif_flags & TIFF_BIGTIFF) && datasize > 4)))\n    {\n        data = NULL;\n    }\n    else\n    {\n        data = _TIFFCheckMalloc(tif, *count, typesize, \"ReadDirEntryArray\");\n        if (data == 0)\n            return (TIFFReadDirEntryErrAlloc);\n    }\n    if (!(tif->tif_flags & TIFF_BIGTIFF))\n    {\n        /* Only the condition on original_datasize_clamped. The second\n         * one is implied, but Coverity Scan cannot see it. */\n        if (original_datasize_clamped <= 4 && datasize <= 4)\n            _TIFFmemcpy(data, &direntry->tdir_offset, datasize);\n        else\n        {\n            enum TIFFReadDirEntryErr err;\n            uint32_t offset = direntry->tdir_offset.toff_long;\n            if (tif->tif_flags & TIFF_SWAB)\n                TIFFSwabLong(&offset);\n            if (isMapped(tif))\n                err = TIFFReadDirEntryData(tif, (uint64_t)offset,\n                                           (tmsize_t)datasize, data);\n            else\n                err = TIFFReadDirEntryDataAndRealloc(tif, (uint64_t)offset,\n                                                     (tmsize_t)datasize, &data);\n            if (err != TIFFReadDirEntryErrOk)\n            {\n                _TIFFfreeExt(tif, data);\n                return (err);\n            }\n        }\n    }\n    else\n    {\n        /* See above comment for the Classic TIFF case */\n        if (original_datasize_clamped <= 8 && datasize <= 8)\n            _TIFFmemcpy(data, &direntry->tdir_offset, datasize);\n        else\n        {\n            enum TIFFReadDirEntryErr err;\n            uint64_t offset = direntry->tdir_offset.toff_long8;\n            if (tif->tif_flags & TIFF_SWAB)\n                TIFFSwabLong8(&offset);\n            if (isMapped(tif))\n                err = TIFFReadDirEntryData(tif, (uint64_t)offset,\n                                           (tmsize_t)datasize, data);\n            else\n                err = TIFFReadDirEntryDataAndRealloc(tif, (uint64_t)offset,\n                                                     (tmsize_t)datasize, &data);\n            if (err != TIFFReadDirEntryErrOk)\n            {\n                _TIFFfreeExt(tif, data);\n                return (err);\n            }\n        }\n    }\n    *value = data;\n    return (TIFFReadDirEntryErrOk);\n}", "target": 1, "idx": 9946}
{"commit_id": "0927ed3ae99444e7b47b84e43118deb10fe37529", "project": "radareorg/radare2", "func": "R_API RBinJavaAttrInfo *r_bin_java_rti_annotations_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tut64 offset = 0;\n\tif (buf_offset + 32 >= sz) {\n\t\treturn NULL;\n\t}\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\toffset += 6;\n\tif (attr) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_RUNTIME_INVISIBLE_ANNOTATION_ATTR;\n\t\tattr->info.annotation_array.num_annotations = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tattr->info.annotation_array.annotations = r_list_newf (r_bin_java_annotation_free);\n\t\tfor (i = 0; i < attr->info.rtv_annotations_attr.num_annotations; i++) {\n\t\t\tif (offset >= sz) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRBinJavaAnnotation *annotation = r_bin_java_annotation_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\t\tif (annotation) {\n\t\t\t\toffset += annotation->size;\n\t\t\t}\n\t\t\tr_list_append (attr->info.annotation_array.annotations, (void *) annotation);\n\t\t}\n\t\tattr->size = offset;\n\t}\n\treturn attr;\n}", "target": 2, "idx": 9947}
{"commit_id": "427215d85e8d1476da1a86b8d67aceb485eb3631", "project": "torvalds/linux", "func": "static bool has_locked_children(struct mount *mnt, struct dentry *dentry)\n{\n\tstruct mount *child;\n\n\tlist_for_each_entry(child, &mnt->mnt_mounts, mnt_child) {\n\t\tif (!is_subdir(child->mnt_mountpoint, dentry))\n\t\t\tcontinue;\n\n\t\tif (child->mnt.mnt_flags & MNT_LOCKED)\n\t\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1, "idx": 9948}
{"commit_id": "779b648c5f6aa9b33f4728f79dd4d0efec0bf860", "project": "upx", "func": "void\nPackLinuxElf64::PackLinuxElf64help1(InputFile *f)\n{\n    e_type  = get_te16(&ehdri.e_type);\n    e_phnum = get_te16(&ehdri.e_phnum);\n    e_shnum = get_te16(&ehdri.e_shnum);\n    unsigned const e_phentsize = get_te16(&ehdri.e_phentsize);\n    if (memcmp((char const *)&ehdri, \"\\x7f\\x45\\x4c\\x46\", 4)  // \"\\177ELF\"\n    || ehdri.e_ident[Elf64_Ehdr::EI_CLASS]!=Elf64_Ehdr::ELFCLASS64\n    || sizeof(Elf64_Phdr) != e_phentsize\n    || (Elf64_Ehdr::ELFDATA2MSB == ehdri.e_ident[Elf64_Ehdr::EI_DATA]\n            && &N_BELE_RTP::be_policy != bele)\n    || (Elf64_Ehdr::ELFDATA2LSB == ehdri.e_ident[Elf64_Ehdr::EI_DATA]\n            && &N_BELE_RTP::le_policy != bele)) {\n        e_phoff = 0;\n        e_shoff = 0;\n        sz_phdrs = 0;\n        return;\n    }\n    if (0==e_phnum) throwCantUnpack(\"0==e_phnum\");\n    e_phoff = get_te64(&ehdri.e_phoff);\n    upx_uint64_t const last_Phdr = e_phoff + e_phnum * sizeof(Elf64_Phdr);\n    if (last_Phdr < e_phoff  // wrap-around\n    ||  e_phoff != sizeof(Elf64_Ehdr)  // must be contiguous\n    ||  (unsigned long)file_size < last_Phdr) {\n        throwCantUnpack(\"bad e_phoff\");\n    }\n    e_shoff = get_te64(&ehdri.e_shoff);\n    upx_uint64_t const last_Shdr = e_shoff + e_shnum * sizeof(Elf64_Shdr);\n    if (last_Shdr < e_shoff  // wrap-around\n    ||  (e_shnum && e_shoff < last_Phdr)\n    ||  (unsigned long)file_size < last_Shdr) {\n        if (opt->cmd == CMD_COMPRESS) {\n            throwCantUnpack(\"bad e_shoff\");\n        }\n    }\n    sz_phdrs = e_phnum * e_phentsize;\n    sz_elf_hdrs = sz_phdrs + sizeof(Elf64_Ehdr);\n\n    if (f && Elf64_Ehdr::ET_DYN!=e_type) {\n        unsigned const len = sz_phdrs + e_phoff;\n        alloc_file_image(file_image, len);\n        f->seek(0, SEEK_SET);\n        f->readx(file_image, len);\n        phdri= (Elf64_Phdr       *)(e_phoff + file_image);  // do not free() !!\n    }\n    if (f && Elf64_Ehdr::ET_DYN==e_type) {\n        // The DT_SYMTAB has no designated length.  Read the whole file.\n        alloc_file_image(file_image, file_size);\n        f->seek(0, SEEK_SET);\n        f->readx(file_image, file_size);\n        phdri= (Elf64_Phdr *)(e_phoff + file_image);  // do not free() !!\n        shdri= (Elf64_Shdr *)(e_shoff + file_image);  // do not free() !!\n        if (opt->cmd != CMD_COMPRESS) {\n            shdri = nullptr;\n        }\n        sec_dynsym = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM);\n        if (sec_dynsym) {\n            unsigned t = get_te32(&sec_dynsym->sh_link);\n            if (e_shnum <= t)\n                throwCantPack(\"bad dynsym->sh_link\");\n            sec_dynstr = &shdri[t];\n        }\n\n        Elf64_Phdr const *phdr= phdri;\n        for (int j = e_phnum; --j>=0; ++phdr)\n        if (Elf64_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {\n            upx_uint64_t offset = check_pt_dynamic(phdr);\n            dynseg= (Elf64_Dyn const *)(offset + file_image);\n            invert_pt_dynamic(dynseg,\n                umin(get_te64(&phdr->p_filesz), file_size - offset));\n        }\n        else if (PT_LOAD64==get_te32(&phdr->p_type)) {\n            check_pt_load(phdr);\n        }\n        // elf_find_dynamic() returns 0 if 0==dynseg.\n        dynstr =      (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB);\n        dynsym = (Elf64_Sym const *)elf_find_dynamic(Elf64_Dyn::DT_SYMTAB);\n        gashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_GNU_HASH);\n        hashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_HASH);\n        if (3& ((upx_uintptr_t)dynsym | (upx_uintptr_t)gashtab | (upx_uintptr_t)hashtab)) {\n            throwCantPack(\"unaligned DT_SYMTAB, DT_GNU_HASH, or DT_HASH/n\");\n        }\n        jni_onload_sym = elf_lookup(\"JNI_OnLoad\");\n        if (jni_onload_sym) {\n            jni_onload_va = get_te64(&jni_onload_sym->st_value);\n            jni_onload_va = 0;  // FIXME not understood; need example\n        }\n    }\n}", "target": 1, "idx": 9949}
{"commit_id": "38b164ace7d6ae1c367883a3d67d7f559783faad", "project": "mruby", "func": "static int\ngen_values(codegen_scope *s, node *t, int val, int limit)\n{\n  int n = 0;\n  int first = 1;\n  int slimit = GEN_VAL_STACK_MAX;\n\n  if (limit == 0) limit = GEN_LIT_ARY_MAX;\n  if (cursp() >= slimit) slimit = INT16_MAX;\n\n  if (!val) {\n    while (t) {\n      codegen(s, t->car, NOVAL);\n      n++;\n      t = t->cdr;\n    }\n    return n;\n  }\n\n  while (t) {\n    int is_splat = nint(t->car->car) == NODE_SPLAT;\n\n    if (is_splat || cursp() >= slimit) { /* flush stack */\n      pop_n(n);\n      if (first) {\n        if (n == 0) {\n          genop_1(s, OP_LOADNIL, cursp());\n        }\n        else {\n          genop_2(s, OP_ARRAY, cursp(), n);\n        }\n        push();\n        first = 0;\n        limit = GEN_LIT_ARY_MAX;\n      }\n      else if (n > 0) {\n        pop();\n        genop_2(s, OP_ARYPUSH, cursp(), n);\n        push();\n      }\n      n = 0;\n    }\n    codegen(s, t->car, val);\n    if (is_splat) {\n      pop(); pop();\n      genop_1(s, OP_ARYCAT, cursp());\n      push();\n    }\n    else {\n      n++;\n    }\n    t = t->cdr;\n  }\n  if (!first) {\n    pop();\n    if (n > 0) {\n      pop_n(n);\n      genop_2(s, OP_ARYPUSH, cursp(), n);\n    }\n    return -1;                  /* variable length */\n  }\n  else if (n > limit) {\n    pop_n(n);\n    genop_2(s, OP_ARRAY, cursp(), n);\n    return -1;\n  }\n  return n;\n}", "target": 3, "idx": 9950}
{"commit_id": "d0c7feaf87678371c2c09b3709400be416b2dc62", "project": "torvalds/linux", "func": "static xfs_failaddr_t\nxfs_agf_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_mount;\n\tstruct xfs_agf\t\t*agf = XFS_BUF_TO_AGF(bp);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tif (!uuid_equal(&agf->agf_uuid, &mp->m_sb.sb_meta_uuid))\n\t\t\treturn __this_address;\n\t\tif (!xfs_log_check_lsn(mp,\n\t\t\t\tbe64_to_cpu(XFS_BUF_TO_AGF(bp)->agf_lsn)))\n\t\t\treturn __this_address;\n\t}\n\n\tif (!xfs_verify_magic(bp, agf->agf_magicnum))\n\t\treturn __this_address;\n\n\tif (!(XFS_AGF_GOOD_VERSION(be32_to_cpu(agf->agf_versionnum)) &&\n\t      be32_to_cpu(agf->agf_freeblks) <= be32_to_cpu(agf->agf_length) &&\n\t      be32_to_cpu(agf->agf_flfirst) < xfs_agfl_size(mp) &&\n\t      be32_to_cpu(agf->agf_fllast) < xfs_agfl_size(mp) &&\n\t      be32_to_cpu(agf->agf_flcount) <= xfs_agfl_size(mp)))\n\t\treturn __this_address;\n\n\tif (be32_to_cpu(agf->agf_length) > mp->m_sb.sb_dblocks)\n\t\treturn __this_address;\n\n\tif (be32_to_cpu(agf->agf_freeblks) < be32_to_cpu(agf->agf_longest) ||\n\t    be32_to_cpu(agf->agf_freeblks) > be32_to_cpu(agf->agf_length))\n\t\treturn __this_address;\n\n\tif (be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNO]) < 1 ||\n\t    be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNT]) < 1 ||\n\t    be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNO]) > XFS_BTREE_MAXLEVELS ||\n\t    be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNT]) > XFS_BTREE_MAXLEVELS)\n\t\treturn __this_address;\n\n\tif (xfs_sb_version_hasrmapbt(&mp->m_sb) &&\n\t    (be32_to_cpu(agf->agf_levels[XFS_BTNUM_RMAP]) < 1 ||\n\t     be32_to_cpu(agf->agf_levels[XFS_BTNUM_RMAP]) > XFS_BTREE_MAXLEVELS))\n\t\treturn __this_address;\n\n\tif (xfs_sb_version_hasrmapbt(&mp->m_sb) &&\n\t    be32_to_cpu(agf->agf_rmap_blocks) > be32_to_cpu(agf->agf_length))\n\t\treturn __this_address;\n\n\t/*\n\t * during growfs operations, the perag is not fully initialised,\n\t * so we can't use it for any useful checking. growfs ensures we can't\n\t * use it by using uncached buffers that don't have the perag attached\n\t * so we can detect and avoid this problem.\n\t */\n\tif (bp->b_pag && be32_to_cpu(agf->agf_seqno) != bp->b_pag->pag_agno)\n\t\treturn __this_address;\n\n\tif (xfs_sb_version_haslazysbcount(&mp->m_sb) &&\n\t    be32_to_cpu(agf->agf_btreeblks) > be32_to_cpu(agf->agf_length))\n\t\treturn __this_address;\n\n\tif (xfs_sb_version_hasreflink(&mp->m_sb) &&\n\t    be32_to_cpu(agf->agf_refcount_blocks) >\n\t    be32_to_cpu(agf->agf_length))\n\t\treturn __this_address;\n\n\tif (xfs_sb_version_hasreflink(&mp->m_sb) &&\n\t    (be32_to_cpu(agf->agf_refcount_level) < 1 ||\n\t     be32_to_cpu(agf->agf_refcount_level) > XFS_BTREE_MAXLEVELS))\n\t\treturn __this_address;\n\n\treturn NULL;\n\n}", "target": 1, "idx": 9951}
{"commit_id": "404ef011c300207cdb1e531670384564aae04bdc", "project": "rpm-software-management/rpm", "func": "int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,\n              rpmpsm psm, char ** failedFile)\n{\n    FD_t payload = rpmtePayload(te);\n    rpmfi fi = rpmfiNewArchiveReader(payload, files, RPMFI_ITER_READ_ARCHIVE);\n    rpmfs fs = rpmteGetFileStates(te);\n    rpmPlugins plugins = rpmtsPlugins(ts);\n    struct stat sb;\n    int saveerrno = errno;\n    int rc = 0;\n    int nodigest = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOFILEDIGEST) ? 1 : 0;\n    int nofcaps = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOCAPS) ? 1 : 0;\n    int firsthardlink = -1;\n    int skip;\n    rpmFileAction action;\n    char *tid = NULL;\n    const char *suffix;\n    char *fpath = NULL;\n\n    if (fi == NULL) {\n\trc = RPMERR_BAD_MAGIC;\n\tgoto exit;\n    }\n\n    /* transaction id used for temporary path suffix while installing */\n    rasprintf(&tid, \";%08x\", (unsigned)rpmtsGetTid(ts));\n\n    /* Detect and create directories not explicitly in package. */\n    rc = fsmMkdirs(files, fs, plugins);\n\n    while (!rc) {\n\t/* Read next payload header. */\n\trc = rpmfiNext(fi);\n\n\tif (rc < 0) {\n\t    if (rc == RPMERR_ITER_END)\n\t\trc = 0;\n\t    break;\n\t}\n\n\taction = rpmfsGetAction(fs, rpmfiFX(fi));\n\tskip = XFA_SKIPPING(action);\n\tsuffix = S_ISDIR(rpmfiFMode(fi)) ? NULL : tid;\n\tif (action != FA_TOUCH) {\n\t    fpath = fsmFsPath(fi, suffix);\n\t} else {\n\t    fpath = fsmFsPath(fi, \"\");\n\t}\n\n\t/* Remap file perms, owner, and group. */\n\trc = rpmfiStat(fi, 1, &sb);\n\n\tfsmDebug(fpath, action, &sb);\n\n        /* Exit on error. */\n        if (rc)\n            break;\n\n\t/* Run fsm file pre hook for all plugins */\n\trc = rpmpluginsCallFsmFilePre(plugins, fi, fpath,\n\t\t\t\t      sb.st_mode, action);\n\tif (rc) {\n\t    skip = 1;\n\t} else {\n\t    setFileState(fs, rpmfiFX(fi));\n\t}\n\n        if (!skip) {\n\t    int setmeta = 1;\n\n\t    /* Directories replacing something need early backup */\n\t    if (!suffix) {\n\t\trc = fsmBackup(fi, action);\n\t    }\n\t    /* Assume file does't exist when tmp suffix is in use */\n\t    if (!suffix) {\n\t\trc = fsmVerify(fpath, fi);\n\t    } else {\n\t\trc = (action == FA_TOUCH) ? 0 : RPMERR_ENOENT;\n\t    }\n\n            if (S_ISREG(sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmMkfile(fi, fpath, files, psm, nodigest,\n\t\t\t\t   &setmeta, &firsthardlink);\n\t\t}\n            } else if (S_ISDIR(sb.st_mode)) {\n                if (rc == RPMERR_ENOENT) {\n                    mode_t mode = sb.st_mode;\n                    mode &= ~07777;\n                    mode |=  00700;\n                    rc = fsmMkdir(fpath, mode);\n                }\n            } else if (S_ISLNK(sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmSymlink(rpmfiFLink(fi), fpath);\n\t\t}\n            } else if (S_ISFIFO(sb.st_mode)) {\n                /* This mimics cpio S_ISSOCK() behavior but probably isn't right */\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMkfifo(fpath, 0000);\n                }\n            } else if (S_ISCHR(sb.st_mode) ||\n                       S_ISBLK(sb.st_mode) ||\n                       S_ISSOCK(sb.st_mode))\n            {\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMknod(fpath, sb.st_mode, sb.st_rdev);\n                }\n            } else {\n                /* XXX Special case /dev/log, which shouldn't be packaged anyways */\n                if (!IS_DEV_LOG(fpath))\n                    rc = RPMERR_UNKNOWN_FILETYPE;\n            }\n\t    /* Set permissions, timestamps etc for non-hardlink entries */\n\t    if (!rc && setmeta) {\n\t\trc = fsmSetmeta(fpath, fi, plugins, action, &sb, nofcaps);\n\t    }\n        } else if (firsthardlink >= 0 && rpmfiArchiveHasContent(fi)) {\n\t    /* we skip the hard linked file containing the content */\n\t    /* write the content to the first used instead */\n\t    char *fn = rpmfilesFN(files, firsthardlink);\n\t    rc = expandRegular(fi, fn, psm, 0, nodigest, 0);\n\t    firsthardlink = -1;\n\t    free(fn);\n\t}\n\n        if (rc) {\n            if (!skip) {\n                /* XXX only erase if temp fn w suffix is in use */\n                if (suffix && (action != FA_TOUCH)) {\n\t\t    (void) fsmRemove(fpath, sb.st_mode);\n                }\n                errno = saveerrno;\n            }\n        } else {\n\t    /* Notify on success. */\n\t    rpmpsmNotify(psm, RPMCALLBACK_INST_PROGRESS, rpmfiArchiveTell(fi));\n\n\t    if (!skip) {\n\t\t/* Backup file if needed. Directories are handled earlier */\n\t\tif (suffix)\n\t\t    rc = fsmBackup(fi, action);\n\n\t\tif (!rc)\n\t\t    rc = fsmCommit(&fpath, fi, action, suffix);\n\t    }\n\t}\n\n\tif (rc)\n\t    *failedFile = xstrdup(fpath);\n\n\t/* Run fsm file post hook for all plugins */\n\trpmpluginsCallFsmFilePost(plugins, fi, fpath,\n\t\t\t\t  sb.st_mode, action, rc);\n\tfpath = _free(fpath);\n    }\n\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_UNCOMPRESS), fdOp(payload, FDSTAT_READ));\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_DIGEST), fdOp(payload, FDSTAT_DIGEST));\n\nexit:\n\n    /* No need to bother with close errors on read */\n    rpmfiArchiveClose(fi);\n    rpmfiFree(fi);\n    Fclose(payload);\n    free(tid);\n    free(fpath);\n\n    return rc;\n}", "target": 2, "idx": 9952}
{"commit_id": "268068f25673242d1d5130d96202d3288c91b700", "project": "android", "func": "void close_all_sockets(atransport* t) {\n    asocket* s;\n\n    /* this is a little gross, but since s->close() *will* modify\n    ** the list out from under you, your options are limited.\n    */\n    std::lock_guard<std::recursive_mutex> lock(local_socket_list_lock);\nrestart:\n    for (s = local_socket_list.next; s != &local_socket_list; s = s->next) {\n        if (s->transport == t || (s->peer && s->peer->transport == t)) {\n            local_socket_close(s);\n            goto restart;\n        }\n    }\n}", "target": 2, "idx": 9953}
{"commit_id": "ee332a01a8a3e87e5787927318eecc214196376c", "project": "nginx/njs", "func": "static njs_ret_t\nnjs_string_prototype_to_upper_case(njs_vm_t *vm, njs_value_t *args,\n    nxt_uint_t nargs, njs_index_t unused)\n{\n    size_t             size, length;\n    u_char             *p, *start;\n    const u_char       *s, *end;\n    njs_string_prop_t  string;\n\n    (void) njs_string_prop(&string, &args[0]);\n\n    start = njs_string_alloc(vm, &vm->retval, string.size, string.length);\n    if (nxt_slow_path(start == NULL)) {\n        return NXT_ERROR;\n    }\n\n    p = start;\n    s = string.start;\n    size = string.size;\n\n    if (string.length == 0 || string.length == size) {\n        /* Byte or ASCII string. */\n\n        while (size != 0) {\n            *p++ = nxt_upper_case(*s++);\n            size--;\n        }\n\n    } else {\n        /* UTF-8 string. */\n        end = s + size;\n        length = string.length;\n\n        while (length != 0) {\n            p = nxt_utf8_encode(p, nxt_utf8_upper_case(&s, end));\n            length--;\n        }\n    }\n\n    return NXT_OK;\n}", "target": 3, "idx": 9954}
{"commit_id": "ea1eca00fd92fa17f0e25ac25652622924a9a6a0", "project": "gpac", "func": "static void nhmldump_send_frame(GF_NHMLDumpCtx *ctx, char *data, u32 data_size, GF_FilterPacket *pck)\n{\n\tGF_FilterPacket *dst_pck;\n\tchar nhml[1024];\n\tconst GF_PropertyValue *p;\n\tu32 size;\n\tu8 *output;\n\tGF_FilterSAPType sap = gf_filter_pck_get_sap(pck);\n\tu64 dts = gf_filter_pck_get_dts(pck);\n\tu64 cts = gf_filter_pck_get_cts(pck);\n\n\tif (dts==GF_FILTER_NO_TS) dts = cts;\n\tif (cts==GF_FILTER_NO_TS) cts = dts;\n\n\tctx->pck_num++;\n\tsprintf(nhml, \"<NHNTSample number=\\\"%d\\\" DTS=\\\"\"LLU\"\\\" dataLength=\\\"%d\\\" \", ctx->pck_num, dts, data_size);\n\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\tif (ctx->pckp || (cts != dts) ) {\n\t\tsprintf(nhml, \"CTSOffset=\\\"%d\\\" \", (s32) ((s64)cts - (s64)dts));\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t}\n\tif (sap==GF_FILTER_SAP_1) {\n\t\tsprintf(nhml, \"isRAP=\\\"yes\\\" \");\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t} else if (sap) {\n\t\tsprintf(nhml, \"SAPType=\\\"%d\\\" \", sap);\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t} else if (ctx->pckp) {\n\t\tsprintf(nhml, \"isRAP=\\\"no\\\" \");\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\tif ((sap==GF_FILTER_SAP_4) || (sap==GF_FILTER_SAP_4_PROL)) {\n\t\t\ts32 roll = gf_filter_pck_get_roll_info(pck);\n\t\t\tsprintf(nhml, \"SAPType=\\\"4\\\" %s=\\\"%d\\\" \", (sap==GF_FILTER_SAP_4_PROL) ? \"prol\" : \"roll\", roll);\n\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\t}\n\t}\n\n\tif (ctx->pckp) {\n\t\tu64 bo;\n\t\tu32 duration, idx;\n\t\tsprintf(nhml, \"mediaOffset=\\\"\"LLU\"\\\" \", ctx->mdia_pos);\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\n\t\tbo = gf_filter_pck_get_byte_offset(pck);\n\t\tif (bo!=GF_FILTER_NO_BO) {\n\t\t\tsprintf(nhml, \"sourceByteOffset=\\\"\"LLU\"\\\" \", bo);\n\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\t}\n\t\tduration = gf_filter_pck_get_duration(pck);\n\t\tif (duration) {\n\t\t\tsprintf(nhml, \"duration=\\\"%d\\\" \", duration);\n\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\t}\n\t\tidx = gf_filter_pck_get_carousel_version(pck);\n\t\tif (idx) {\n\t\t\tsprintf(nhml, \"carouselVersion=\\\"%d\\\" \", idx);\n\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\t}\n\t\tidx = 0;\n\t\twhile (1) {\n\t\t\tu32 prop_4cc;\n\t\t\tconst char *prop_name;\n\t\t\tp = gf_filter_pck_enum_properties(pck, &idx, &prop_4cc, &prop_name);\n\t\t\tif (!p) break;\n\t\t\tif (prop_4cc == GF_PROP_PCK_SUBS) continue;\n\t\t\tnhmldump_pck_property(ctx, prop_4cc, prop_name, p);\n\t\t}\n\t}\n\n\tif (ctx->chksum) {\n\t\tif (ctx->chksum==1) {\n\t\t\tu32 crc = gf_crc_32(data, data_size);\n\t\t\tsprintf(nhml, \"crc=\\\"%08X\\\" \", crc);\n\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\t} else {\n\t\t\tu32 j;\n\t\t\tu8 hash[GF_SHA1_DIGEST_SIZE];\n\t\t\tgf_sha1_csum(data, data_size, hash);\n\t\t\tsprintf(nhml, \"sha1=\\\"\");\n\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\t\tfor (j=0; j<20; j++) {\n\t\t\t\tsprintf(nhml, \"%02X\", hash[j]);\n\t\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\t\t}\n\t\t\tsprintf(nhml, \"\\\" \");\n\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\t}\n\t}\n\n\tsprintf(nhml, \">\\n\");\n\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\n\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_SUBS);\n\tif (p) {\n\t\tu32 offset_in_sample = 0;\n\t\tBool first_subs = GF_TRUE;\n\t\tif (!ctx->bs_r) ctx->bs_r = gf_bs_new(p->value.data.ptr, p->value.data.size, GF_BITSTREAM_READ);\n\t\telse gf_bs_reassign_buffer(ctx->bs_r, p->value.data.ptr, p->value.data.size);\n\n\t\t//(data) binary blob containing N [(u32)flags(u32)size(u32)reserved(u8)priority(u8) discardable]\n\t\twhile (gf_bs_available(ctx->bs_r)) {\n\t\t\tu32 s_flags = gf_bs_read_u32(ctx->bs_r);\n\t\t\tu32 s_size = gf_bs_read_u32(ctx->bs_r);\n\t\t\tu32 s_res = gf_bs_read_u32(ctx->bs_r);\n\t\t\tu8 s_prio = gf_bs_read_u8(ctx->bs_r);\n\t\t\tu8 s_discard = gf_bs_read_u8(ctx->bs_r);\n\n\n\t\t\tif (offset_in_sample + s_size > data_size) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"Wrong subsample info: sample size %d vs subsample offset+size %dn\", data_size, offset_in_sample + s_size));\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (ctx->is_stpp && ctx->nhmlonly) {\n\t\t\t\tif (first_subs) {\n\t\t\t\t\tsprintf(nhml, \"<NHNTSubSample>\\n\");\n\t\t\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\n\t\t\t\t\tgf_bs_write_data(ctx->bs_w, data, s_size);\n\n\t\t\t\t\tsprintf(nhml, \"</NHNTSubSample>\\n\");\n\t\t\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\t\t\t} else {\n\t\t\t\t\tu32 d_size;\n\t\t\t\t\tif (ctx->b64_buffer_size < 2*s_size + 3) {\n\t\t\t\t\t\tctx->b64_buffer_size = 2 * s_size + 3;\n\t\t\t\t\t\tctx->b64_buffer = gf_realloc(ctx->b64_buffer, ctx->b64_buffer_size);\n\t\t\t\t\t}\n\t\t\t\t\td_size = gf_base64_encode(data + offset_in_sample, s_size, ctx->b64_buffer, ctx->b64_buffer_size);\n\t\t\t\t\tctx->b64_buffer[d_size] = 0;\n\t\t\t\t\tsprintf(nhml, \"<NHNTSubSample data=\\\"data:application/octet-string;base64,\");\n\t\t\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\t\t\t\tgf_bs_write_data(ctx->bs_w, ctx->b64_buffer, d_size);\n\t\t\t\t\tsprintf(nhml, \"\\\">\\n\");\n\t\t\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsprintf(nhml, \"<NHNTSubSample size=\\\"%d\\\" flags=\\\"%d\\\" reserved=\\\"%d\\\" priority=\\\"%d\\\" discard=\\\"%d\\\" />\\n\", s_size, s_flags, s_res, s_prio, s_discard);\n\t\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\t\t}\n\t\t\tfirst_subs = GF_FALSE;\n\t\t}\n\t} else if (ctx->is_stpp && ctx->nhmlonly) {\n\t\tsprintf(nhml, \"<NHNTSubSample><![CDATA[\\n\");\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\tgf_bs_write_data(ctx->bs_w, data, data_size);\n\t\tsprintf(nhml, \"]]></NHNTSubSample>\\n\");\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t}\n\tsprintf(nhml, \"</NHNTSample>\\n\");\n\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\n\tgf_bs_get_content_no_truncate(ctx->bs_w, &ctx->nhml_buffer, &size, &ctx->nhml_buffer_size);\n\n\tif (ctx->filep) {\n\t\tgf_fwrite(ctx->nhml_buffer, size, ctx->filep);\n\t\treturn;\n\t}\n\n\tdst_pck = gf_filter_pck_new_alloc(ctx->opid_nhml, size, &output);\n\tif (dst_pck) {\n\t\tmemcpy(output, ctx->nhml_buffer, size);\n\t\tgf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);\n\t\tgf_filter_pck_send(dst_pck);\n\t}\n\n\tctx->mdia_pos += data_size;\n\n\tif (ctx->opid_mdia) {\n\t\t//send the complete data packet\n\t\tdst_pck = gf_filter_pck_new_ref(ctx->opid_mdia, 0, data_size, pck);\n\t\tif (!dst_pck) return;\n\n\t\tgf_filter_pck_merge_properties(pck, dst_pck);\n\t\t//keep byte offset ?\n//\t\tgf_filter_pck_set_byte_offset(dst_pck, GF_FILTER_NO_BO);\n\n\t\tgf_filter_pck_set_framing(dst_pck, ctx->first, GF_FALSE);\n\t\tgf_filter_pck_send(dst_pck);\n\t}\n}", "target": 2, "idx": 9955}
{"commit_id": "ab9d06d51ff8c3eab9ba9ea85e422179dbd12b15", "project": "Samsung/mTower", "func": "TEE_Result TEE_MACComputeFinal(TEE_OperationHandle operation,\n\t\t\t       const void *message, uint32_t messageLen,\n\t\t\t       void *mac, uint32_t *macLen)\n{\n\tTEE_Result res;\n\tuint64_t ml;\n\n\tif (operation == TEE_HANDLE_NULL ||\n\t    (message == NULL && messageLen != 0) ||\n\t    mac == NULL ||\n\t    macLen == NULL) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\t}\n\n\tif (operation->info.operationClass != TEE_OPERATION_MAC) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\t}\n\n\tif ((operation->info.handleState & TEE_HANDLE_FLAG_INITIALIZED) == 0) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\t}\n\n\tif (operation->operationState != TEE_OPERATION_STATE_ACTIVE) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\t}\n\n\tif (CONFIG_MAX_CRYPTO_CHUNK_SIZE < *macLen) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\t}\n\n\tml = *macLen;\n\tres = utee_hash_final(operation->state, message, messageLen, mac, &ml);\n\t*macLen = ml;\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\toperation->info.handleState &= ~TEE_HANDLE_FLAG_INITIALIZED;\n\n\toperation->operationState = TEE_OPERATION_STATE_INITIAL;\n\nout:\n\tif (res != TEE_SUCCESS &&\n\t    res != TEE_ERROR_SHORT_BUFFER)\n\t\tTEE_Panic(res);\n\n\treturn res;\n}", "target": 2, "idx": 9956}
{"commit_id": "9d2f8f9c65d4da35437f50ed9e812a2c5ab313e2", "project": "xen-project/xen", "func": "int gnttab_map_frame(struct domain *d, unsigned long idx, gfn_t gfn,\n                     mfn_t *mfn)\n{\n    int rc = 0;\n    struct grant_table *gt = d->grant_table;\n    bool status = false;\n\n    grant_write_lock(gt);\n\n    if ( gt->gt_version == 0 )\n        gt->gt_version = 1;\n\n    if ( gt->gt_version == 2 &&\n         (idx & XENMAPIDX_grant_table_status) )\n    {\n        idx &= ~XENMAPIDX_grant_table_status;\n        status = true;\n        if ( idx < nr_status_frames(gt) )\n            *mfn = _mfn(virt_to_mfn(gt->status[idx]));\n        else\n            rc = -EINVAL;\n    }\n    else\n    {\n        if ( (idx >= nr_grant_frames(gt)) && (idx < gt->max_grant_frames) )\n            gnttab_grow_table(d, idx + 1);\n\n        if ( idx < nr_grant_frames(gt) )\n            *mfn = _mfn(virt_to_mfn(gt->shared_raw[idx]));\n        else\n            rc = -EINVAL;\n    }\n\n    if ( !rc )\n        gnttab_set_frame_gfn(gt, status, idx, gfn);\n\n    grant_write_unlock(gt);\n\n    return rc;\n}", "target": 2, "idx": 9957}
{"commit_id": "38096961c7cd109110ac21d3ed7dad7e0cb0ae06", "project": "sqlite", "func": "static int renameUnmapSelectCb(Walker *pWalker, Select *p){\n  Parse *pParse = pWalker->pParse;\n  int i;\n  if( pParse->nErr ) return WRC_Abort;\n  if( p->selFlags & SF_View ) return WRC_Prune;\n  if( ALWAYS(p->pEList) ){\n    ExprList *pList = p->pEList;\n    for(i=0; i<pList->nExpr; i++){\n      if( pList->a[i].zName ){\n        sqlite3RenameTokenRemap(pParse, 0, (void*)pList->a[i].zName);\n      }\n    }\n  }\n  if( ALWAYS(p->pSrc) ){  /* Every Select as a SrcList, even if it is empty */\n    SrcList *pSrc = p->pSrc;\n    for(i=0; i<pSrc->nSrc; i++){\n      sqlite3RenameTokenRemap(pParse, 0, (void*)pSrc->a[i].zName);\n    }\n  }\n\n  renameWalkWith(pWalker, p);\n  return WRC_Continue;\n}", "target": 1, "idx": 9958}
{"commit_id": "73b854874e723f38e84e5ff57a9eeb99653ca74c", "project": "upx", "func": "unsigned  // checked .p_offset; sz_dynseg set\nPackLinuxElf32::check_pt_dynamic(Elf32_Phdr const *const phdr)\n{\n    unsigned t = get_te32(&phdr->p_offset), s = sizeof(Elf32_Dyn) + t;\n    unsigned vaddr = get_te32(&phdr->p_vaddr);\n    unsigned filesz = get_te32(&phdr->p_filesz), memsz = get_te32(&phdr->p_memsz);\n    unsigned align = get_te32(&phdr->p_align);\n    if (s < t || (u32_t)file_size < s || t < sizeof(Elf32_Ehdr)\n    ||  (3 & t) || (7 & (filesz | memsz))  // .balign 4; 8==sizeof(Elf32_Dyn)\n    ||  (-1+ align) & (t ^ vaddr)\n    ||  (unsigned long)file_size <= memsz\n    ||  filesz < sizeof(Elf32_Dyn)\n    ||  memsz  < sizeof(Elf32_Dyn)\n    ||  filesz < memsz) {\n        char msg[50]; snprintf(msg, sizeof(msg), \"bad PT_DYNAMIC phdr[%u]\",\n            (unsigned)(phdr - phdri));\n        throwCantPack(msg);\n    }\n    sz_dynseg = memsz;\n    return t;\n}", "target": 1, "idx": 9959}
{"commit_id": "3d52307cf0033e3275975b668b7138ba1343f28d", "project": "MapServer", "func": "static int\nmsOGRFileNextShape(layerObj *layer, shapeObj *shape,\n                   msOGRFileInfo *psInfo )\n{\n  OGRFeatureH hFeature = NULL;\n\n  if (psInfo == NULL || psInfo->hLayer == NULL) {\n    msSetError(MS_MISCERR, \"Assertion failed: OGR layer not opened!!!\",\n               \"msOGRFileNextShape()\");\n    return(MS_FAILURE);\n  }\n\n  /* ------------------------------------------------------------------\n   * Read until we find a feature that matches attribute filter and\n   * whose geometry is compatible with current layer type.\n   * ------------------------------------------------------------------ */\n  msFreeShape(shape);\n  shape->type = MS_SHAPE_NULL;\n\n  ACQUIRE_OGR_LOCK;\n  while (shape->type == MS_SHAPE_NULL) {\n    if( hFeature )\n      OGR_F_Destroy( hFeature );\n\n    if( (hFeature = OGR_L_GetNextFeature( psInfo->hLayer )) == NULL ) {\n      psInfo->last_record_index_read = -1;\n      if( CPLGetLastErrorType() == CE_Failure ) {\n        msSetError(MS_OGRERR, \"OGR GetNextFeature() error'd. Check logs.\",\n                   \"msOGRFileNextShape()\");\n        msDebug(\"msOGRFileNextShape(): %s\\n\",\n                CPLGetLastErrorMsg() );\n        RELEASE_OGR_LOCK;\n        return MS_FAILURE;\n      } else {\n        RELEASE_OGR_LOCK;\n        if (layer->debug >= MS_DEBUGLEVEL_VV)\n          msDebug(\"msOGRFileNextShape: Returning MS_DONE (no more shapes)\\n\" );\n        return MS_DONE;  // No more features to read\n      }\n    }\n\n    psInfo->last_record_index_read++;\n\n    if(layer->numitems > 0) {\n      shape->values = msOGRGetValues(layer, hFeature);\n      shape->numvalues = layer->numitems;\n      if(!shape->values) {\n        OGR_F_Destroy( hFeature );\n        RELEASE_OGR_LOCK;\n        return(MS_FAILURE);\n      }\n    }\n\n    // Feature matched filter expression... process geometry\n    // shape->type will be set if geom is compatible with layer type\n    if (ogrConvertGeometry(ogrGetLinearGeometry( hFeature ), shape,\n                           layer->type) == MS_SUCCESS) {\n      if (shape->type != MS_SHAPE_NULL)\n        break; // Shape is ready to be returned!\n\n      if (layer->debug >= MS_DEBUGLEVEL_VVV)\n        msDebug(\"msOGRFileNextShape: Rejecting feature (shapeid = \" CPL_FRMT_GIB \", tileid=%d) of incompatible type for this layer (feature wkbType %d, layer type %d)\\n\",\n                (GIntBig)OGR_F_GetFID( hFeature ), psInfo->nTileId,\n                OGR_F_GetGeometryRef( hFeature )==NULL ? wkbFlatten(wkbUnknown):wkbFlatten( OGR_G_GetGeometryType( OGR_F_GetGeometryRef( hFeature ) ) ),\n                layer->type);\n\n    } else {\n      msFreeShape(shape);\n      OGR_F_Destroy( hFeature );\n      RELEASE_OGR_LOCK;\n      return MS_FAILURE; // Error message already produced.\n    }\n\n    // Feature rejected... free shape to clear attributes values.\n    msFreeShape(shape);\n    shape->type = MS_SHAPE_NULL;\n  }\n\n  shape->index =  (int)OGR_F_GetFID( hFeature ); // FIXME? GetFID() is a 64bit integer in GDAL 2.0\n  shape->resultindex = psInfo->last_record_index_read;\n  shape->tileindex = psInfo->nTileId;\n\n  if (layer->debug >= MS_DEBUGLEVEL_VVV)\n    msDebug(\"msOGRFileNextShape: Returning shape=%ld, tile=%d\\n\",\n            shape->index, shape->tileindex );\n\n  // Keep ref. to last feature read in case we need style info.\n  if (psInfo->hLastFeature)\n    OGR_F_Destroy( psInfo->hLastFeature );\n  psInfo->hLastFeature = hFeature;\n\n  RELEASE_OGR_LOCK;\n\n  return MS_SUCCESS;\n}", "target": 2, "idx": 9960}
{"commit_id": "d2f5d424ba8752f9a9e9dad410546ec1b46caa0a", "project": "poppler", "func": "int main(int argc, char *argv[]) {\n  GooString *fileName;\n  UnicodeMap *uMap;\n  GooString *ownerPW, *userPW;\n  PDFDoc *doc;\n  char uBuf[8];\n  char path[1024];\n  char *p;\n  bool ok;\n  int exitCode;\n  GooList *embeddedFiles = nullptr;\n  int nFiles, nPages, n, i, j;\n  FileSpec *fileSpec;\n  Page *page;\n  Annots *annots;\n  Annot *annot;\n  const GooString *s1;\n  Unicode u;\n  bool isUnicode;\n\n  Win32Console win32Console(&argc, &argv);\n  exitCode = 99;\n\n  // parse args\n  ok = parseArgs(argDesc, &argc, argv);\n  if ((doList ? 1 : 0) +\n      ((saveNum != 0) ? 1 : 0) +\n      (saveAll ? 1 : 0) != 1) {\n    ok = false;\n  }\n  if (!ok || argc != 2 || printVersion || printHelp) {\n    fprintf(stderr, \"pdfdetach version %s\\n\", PACKAGE_VERSION);\n    fprintf(stderr, \"%s\\n\", popplerCopyright);\n    fprintf(stderr, \"%s\\n\", xpdfCopyright);\n    if (!printVersion) {\n      printUsage(\"pdfdetach\", \"<PDF-file>\", argDesc);\n    }\n    goto err0;\n  }\n  fileName = new GooString(argv[1]);\n\n  // read config file\n  globalParams = new GlobalParams();\n  if (textEncName[0]) {\n    globalParams->setTextEncoding(textEncName);\n  }\n\n  // get mapping to output encoding\n  if (!(uMap = globalParams->getTextEncoding())) {\n    error(errConfig, -1, \"Couldn't get text encoding\");\n    delete fileName;\n    goto err1;\n  }\n\n  // open PDF file\n  if (ownerPassword[0] != '\\001') {\n    ownerPW = new GooString(ownerPassword);\n  } else {\n    ownerPW = nullptr;\n  }\n  if (userPassword[0] != '\\001') {\n    userPW = new GooString(userPassword);\n  } else {\n    userPW = nullptr;\n  }\n\n  doc = PDFDocFactory().createPDFDoc(*fileName, ownerPW, userPW);\n\n  if (userPW) {\n    delete userPW;\n  }\n  if (ownerPW) {\n    delete ownerPW;\n  }\n  if (!doc->isOk()) {\n    exitCode = 1;\n    goto err2;\n  }\n\n  embeddedFiles = new GooList();\n  for (i = 0; i < doc->getCatalog()->numEmbeddedFiles(); ++i)\n    embeddedFiles->push_back(doc->getCatalog()->embeddedFile(i));\n\n  nPages = doc->getCatalog()->getNumPages();\n  for (i = 0; i < nPages; ++i) {\n    page = doc->getCatalog()->getPage(i + 1);\n    if (!page)\n      continue;\n    annots = page->getAnnots();\n    if (!annots)\n      break;\n\n    for (j = 0; j < annots->getNumAnnots(); ++j) {\n      annot = annots->getAnnot(j);\n      if (annot->getType() != Annot::typeFileAttachment)\n        continue;\n      embeddedFiles->push_back(new FileSpec(static_cast<AnnotFileAttachment *>(annot)->getFile()));\n    }\n  }\n\n  nFiles = embeddedFiles->getLength();\n\n  // list embedded files\n  if (doList) {\n    printf(\"%d embedded files\\n\", nFiles);\n    for (i = 0; i < nFiles; ++i) {\n      fileSpec = static_cast<FileSpec *>(embeddedFiles->get(i));\n      printf(\"%d: \", i+1);\n      s1 = fileSpec->getFileName();\n      if (!s1) {\n\texitCode = 3;\n\tgoto err2;\n      }\n      if (s1->hasUnicodeMarker()) {\n        isUnicode = true;\n        j = 2;\n      } else {\n        isUnicode = false;\n        j = 0;\n      }\n      while (j < s1->getLength()) {\n        if (isUnicode) {\n          u = ((s1->getChar(j) & 0xff) << 8) | (s1->getChar(j+1) & 0xff);\n          j += 2;\n        } else {\n          u = pdfDocEncoding[s1->getChar(j) & 0xff];\n          ++j;\n        }\n        n = uMap->mapUnicode(u, uBuf, sizeof(uBuf));\n        fwrite(uBuf, 1, n, stdout);\n      }\n      fputc('\\n', stdout);\n    }\n\n  // save all embedded files\n  } else if (saveAll) {\n    for (i = 0; i < nFiles; ++i) {\n      fileSpec = static_cast<FileSpec *>(embeddedFiles->get(i));\n      if (savePath[0]) {\n\tn = strlen(savePath);\n\tif (n > (int)sizeof(path) - 2) {\n\t  n = sizeof(path) - 2;\n\t}\n\tmemcpy(path, savePath, n);\n\tpath[n] = '/';\n\tp = path + n + 1;\n      } else {\n\tp = path;\n      }\n      s1 = fileSpec->getFileName();\n      if (!s1) {\n\texitCode = 3;\n\tgoto err2;\n      }\n      if (s1->hasUnicodeMarker()) {\n        isUnicode = true;\n        j = 2;\n      } else {\n        isUnicode = false;\n        j = 0;\n      }\n      while (j < s1->getLength()) {\n        if (isUnicode) {\n          u = ((s1->getChar(j) & 0xff) << 8) | (s1->getChar(j+1) & 0xff);\n          j += 2;\n        } else {\n          u = pdfDocEncoding[s1->getChar(j) & 0xff];\n          ++j;\n        }\n        n = uMap->mapUnicode(u, uBuf, sizeof(uBuf));\n        if (p + n >= path + sizeof(path))\n          break;\n        memcpy(p, uBuf, n);\n        p += n;\n      }\n      *p = '\\0';\n\n      auto *embFile = fileSpec->getEmbeddedFile();\n      if (!embFile || !embFile->isOk()) {\n\texitCode = 3;\n\tgoto err2;\n      }\n      if (!embFile->save(path)) {\n\terror(errIO, -1, \"Error saving embedded file as '{0:s}'\", p);\n\texitCode = 2;\n\tgoto err2;\n      }\n    }\n\n  // save an embedded file\n  } else {\n    if (saveNum < 1 || saveNum > nFiles) {\n      error(errCommandLine, -1, \"Invalid file number\");\n      goto err2;\n    }\n\n    fileSpec = static_cast<FileSpec *>(embeddedFiles->get(saveNum - 1));\n    if (savePath[0]) {\n      p = savePath;\n    } else {\n      p = path;\n      s1 = fileSpec->getFileName();\n      if (!s1) {\n\texitCode = 3;\n\tgoto err2;\n      }\n      if (s1->hasUnicodeMarker()) {\n        isUnicode = true;\n        j = 2;\n      } else {\n        isUnicode = false;\n        j = 0;\n      }\n      while (j < s1->getLength()) {\n        if (isUnicode) {\n          u = ((s1->getChar(j) & 0xff) << 8) | (s1->getChar(j+1) & 0xff);\n          j += 2;\n        } else {\n          u = pdfDocEncoding[s1->getChar(j) & 0xff];\n          ++j;\n        }\n        n = uMap->mapUnicode(u, uBuf, sizeof(uBuf));\n        if (p + n >= path + sizeof(path))\n          break;\n        memcpy(p, uBuf, n);\n        p += n;\n      }\n      *p = '\\0';\n      p = path;\n    }\n\n    auto *embFile = fileSpec->getEmbeddedFile();\n    if (!embFile || !embFile->isOk()) {\n      exitCode = 3;\n      goto err2;\n    }\n    if (!embFile->save(p)) {\n      error(errIO, -1, \"Error saving embedded file as '{0:s}'\", p);\n      exitCode = 2;\n      goto err2;\n    }\n  }\n\n  exitCode = 0;\n\n  // clean up\n err2:\n  if (embeddedFiles)\n    deleteGooList<FileSpec>(embeddedFiles);\n  uMap->decRefCnt();\n  delete doc;\n err1:\n  delete globalParams;\n err0:\n\n  return exitCode;\n}", "target": 1, "idx": 9961}
{"commit_id": "733ee3208306b1ea32697b356c0215180fc3f049", "project": "FreeRDP", "func": "static int update_prepare_order_info(rdpContext* context, ORDER_INFO* orderInfo, UINT32 orderType)\n{\n\tint length = 1;\n\torderInfo->fieldFlags = 0;\n\torderInfo->orderType = orderType;\n\torderInfo->controlFlags = ORDER_STANDARD;\n\torderInfo->controlFlags |= ORDER_TYPE_CHANGE;\n\tlength += 1;\n\tlength += get_primary_drawing_order_field_bytes(orderInfo->orderType, NULL);\n\tlength += update_prepare_bounds(context, orderInfo);\n\treturn length;\n}", "target": 0, "idx": 9962}
{"commit_id": "998912346c0da53a6dbb71fab3a138586b596b30", "project": "torvalds/linux", "func": "static void ov511_mode_init_regs(struct sd *sd)\n{\n\tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n\tint hsegs, vsegs, packet_size, fps, needed;\n\tint interlaced = 0;\n\tstruct usb_host_interface *alt;\n\tstruct usb_interface *intf;\n\n\tintf = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);\n\talt = usb_altnum_to_altsetting(intf, sd->gspca_dev.alt);\n\tif (!alt) {\n\t\tgspca_err(gspca_dev, \"Couldn't get altsetting\\n\");\n\t\tsd->gspca_dev.usb_err = -EIO;\n\t\treturn;\n\t}\n\n\tif (alt->desc.bNumEndpoints < 1) {\n\t\tsd->gspca_dev.usb_err = -ENODEV;\n\t\treturn;\n\t}\n\n\tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n\treg_w(sd, R51x_FIFO_PSIZE, packet_size >> 5);\n\n\treg_w(sd, R511_CAM_UV_EN, 0x01);\n\treg_w(sd, R511_SNAP_UV_EN, 0x01);\n\treg_w(sd, R511_SNAP_OPTS, 0x03);\n\n\t/* Here I'm assuming that snapshot size == image size.\n\t * I hope that's always true. --claudio\n\t */\n\thsegs = (sd->gspca_dev.pixfmt.width >> 3) - 1;\n\tvsegs = (sd->gspca_dev.pixfmt.height >> 3) - 1;\n\n\treg_w(sd, R511_CAM_PXCNT, hsegs);\n\treg_w(sd, R511_CAM_LNCNT, vsegs);\n\treg_w(sd, R511_CAM_PXDIV, 0x00);\n\treg_w(sd, R511_CAM_LNDIV, 0x00);\n\n\t/* YUV420, low pass filter on */\n\treg_w(sd, R511_CAM_OPTS, 0x03);\n\n\t/* Snapshot additions */\n\treg_w(sd, R511_SNAP_PXCNT, hsegs);\n\treg_w(sd, R511_SNAP_LNCNT, vsegs);\n\treg_w(sd, R511_SNAP_PXDIV, 0x00);\n\treg_w(sd, R511_SNAP_LNDIV, 0x00);\n\n\t/******** Set the framerate ********/\n\tif (frame_rate > 0)\n\t\tsd->frame_rate = frame_rate;\n\n\tswitch (sd->sensor) {\n\tcase SEN_OV6620:\n\t\t/* No framerate control, doesn't like higher rates yet */\n\t\tsd->clockdiv = 3;\n\t\tbreak;\n\n\t/* Note once the FIXME's in mode_init_ov_sensor_regs() are fixed\n\t   for more sensors we need to do this for them too */\n\tcase SEN_OV7620:\n\tcase SEN_OV7620AE:\n\tcase SEN_OV7640:\n\tcase SEN_OV7648:\n\tcase SEN_OV76BE:\n\t\tif (sd->gspca_dev.pixfmt.width == 320)\n\t\t\tinterlaced = 1;\n\t\t/* Fall through */\n\tcase SEN_OV6630:\n\tcase SEN_OV7610:\n\tcase SEN_OV7670:\n\t\tswitch (sd->frame_rate) {\n\t\tcase 30:\n\t\tcase 25:\n\t\t\t/* Not enough bandwidth to do 640x480 @ 30 fps */\n\t\t\tif (sd->gspca_dev.pixfmt.width != 640) {\n\t\t\t\tsd->clockdiv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* For 640x480 case */\n\t\t\t/* fall through */\n\t\tdefault:\n/*\t\tcase 20: */\n/*\t\tcase 15: */\n\t\t\tsd->clockdiv = 1;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tsd->clockdiv = 2;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tsd->clockdiv = 5;\n\t\t\tbreak;\n\t\t}\n\t\tif (interlaced) {\n\t\t\tsd->clockdiv = (sd->clockdiv + 1) * 2 - 1;\n\t\t\t/* Higher then 10 does not work */\n\t\t\tif (sd->clockdiv > 10)\n\t\t\t\tsd->clockdiv = 10;\n\t\t}\n\t\tbreak;\n\n\tcase SEN_OV8610:\n\t\t/* No framerate control ?? */\n\t\tsd->clockdiv = 0;\n\t\tbreak;\n\t}\n\n\t/* Check if we have enough bandwidth to disable compression */\n\tfps = (interlaced ? 60 : 30) / (sd->clockdiv + 1) + 1;\n\tneeded = fps * sd->gspca_dev.pixfmt.width *\n\t\t\tsd->gspca_dev.pixfmt.height * 3 / 2;\n\t/* 1000 isoc packets/sec */\n\tif (needed > 1000 * packet_size) {\n\t\t/* Enable Y and UV quantization and compression */\n\t\treg_w(sd, R511_COMP_EN, 0x07);\n\t\treg_w(sd, R511_COMP_LUT_EN, 0x03);\n\t} else {\n\t\treg_w(sd, R511_COMP_EN, 0x06);\n\t\treg_w(sd, R511_COMP_LUT_EN, 0x00);\n\t}\n\n\treg_w(sd, R51x_SYS_RESET, OV511_RESET_OMNICE);\n\treg_w(sd, R51x_SYS_RESET, 0);\n}", "target": 1, "idx": 9963}
{"commit_id": "19be0eaffa3ac7d8eb6784ad9bdbc7d67ed8e619", "project": "torvalds/linux", "func": "static struct page *follow_page_pte(struct vm_area_struct *vma,\n\t\tunsigned long address, pmd_t *pmd, unsigned int flags)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct dev_pagemap *pgmap = NULL;\n\tstruct page *page;\n\tspinlock_t *ptl;\n\tpte_t *ptep, pte;\n\nretry:\n\tif (unlikely(pmd_bad(*pmd)))\n\t\treturn no_page_table(vma, flags);\n\n\tptep = pte_offset_map_lock(mm, pmd, address, &ptl);\n\tpte = *ptep;\n\tif (!pte_present(pte)) {\n\t\tswp_entry_t entry;\n\t\t/*\n\t\t * KSM's break_ksm() relies upon recognizing a ksm page\n\t\t * even while it is being migrated, so for that case we\n\t\t * need migration_entry_wait().\n\t\t */\n\t\tif (likely(!(flags & FOLL_MIGRATION)))\n\t\t\tgoto no_page;\n\t\tif (pte_none(pte))\n\t\t\tgoto no_page;\n\t\tentry = pte_to_swp_entry(pte);\n\t\tif (!is_migration_entry(entry))\n\t\t\tgoto no_page;\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\tmigration_entry_wait(mm, pmd, address);\n\t\tgoto retry;\n\t}\n\tif ((flags & FOLL_NUMA) && pte_protnone(pte))\n\t\tgoto no_page;\n\tif ((flags & FOLL_WRITE) && !can_follow_write_pte(pte, flags)) {\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\treturn NULL;\n\t}\n\n\tpage = vm_normal_page(vma, address, pte);\n\tif (!page && pte_devmap(pte) && (flags & FOLL_GET)) {\n\t\t/*\n\t\t * Only return device mapping pages in the FOLL_GET case since\n\t\t * they are only valid while holding the pgmap reference.\n\t\t */\n\t\tpgmap = get_dev_pagemap(pte_pfn(pte), NULL);\n\t\tif (pgmap)\n\t\t\tpage = pte_page(pte);\n\t\telse\n\t\t\tgoto no_page;\n\t} else if (unlikely(!page)) {\n\t\tif (flags & FOLL_DUMP) {\n\t\t\t/* Avoid special (like zero) pages in core dumps */\n\t\t\tpage = ERR_PTR(-EFAULT);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (is_zero_pfn(pte_pfn(pte))) {\n\t\t\tpage = pte_page(pte);\n\t\t} else {\n\t\t\tint ret;\n\n\t\t\tret = follow_pfn_pte(vma, address, ptep, flags);\n\t\t\tpage = ERR_PTR(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (flags & FOLL_SPLIT && PageTransCompound(page)) {\n\t\tint ret;\n\t\tget_page(page);\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\tlock_page(page);\n\t\tret = split_huge_page(page);\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t\tgoto retry;\n\t}\n\n\tif (flags & FOLL_GET) {\n\t\tget_page(page);\n\n\t\t/* drop the pgmap reference now that we hold the page */\n\t\tif (pgmap) {\n\t\t\tput_dev_pagemap(pgmap);\n\t\t\tpgmap = NULL;\n\t\t}\n\t}\n\tif (flags & FOLL_TOUCH) {\n\t\tif ((flags & FOLL_WRITE) &&\n\t\t    !pte_dirty(pte) && !PageDirty(page))\n\t\t\tset_page_dirty(page);\n\t\t/*\n\t\t * pte_mkyoung() would be more correct here, but atomic care\n\t\t * is needed to avoid losing the dirty bit: it is easier to use\n\t\t * mark_page_accessed().\n\t\t */\n\t\tmark_page_accessed(page);\n\t}\n\tif ((flags & FOLL_MLOCK) && (vma->vm_flags & VM_LOCKED)) {\n\t\t/* Do not mlock pte-mapped THP */\n\t\tif (PageTransCompound(page))\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * The preliminary mapping check is mainly to avoid the\n\t\t * pointless overhead of lock_page on the ZERO_PAGE\n\t\t * which might bounce very badly if there is contention.\n\t\t *\n\t\t * If the page is already locked, we don't need to\n\t\t * handle it now - vmscan will handle it later if and\n\t\t * when it attempts to reclaim the page.\n\t\t */\n\t\tif (page->mapping && trylock_page(page)) {\n\t\t\tlru_add_drain();  /* push cached pages to LRU */\n\t\t\t/*\n\t\t\t * Because we lock page here, and migration is\n\t\t\t * blocked by the pte's page reference, and we\n\t\t\t * know the page is still mapped, we don't even\n\t\t\t * need to check for file-cache page truncation.\n\t\t\t */\n\t\t\tmlock_vma_page(page);\n\t\t\tunlock_page(page);\n\t\t}\n\t}\nout:\n\tpte_unmap_unlock(ptep, ptl);\n\treturn page;\nno_page:\n\tpte_unmap_unlock(ptep, ptl);\n\tif (!pte_none(pte))\n\t\treturn NULL;\n\treturn no_page_table(vma, flags);\n}", "target": 2, "idx": 9964}
{"commit_id": "bf33f87dd04c371ea33feb821b60d63d754e3124", "project": "kernel/git/mkp/scsi", "func": "static long\nsg_ioctl(struct file *filp, unsigned int cmd_in, unsigned long arg)\n{\n\tvoid __user *p = (void __user *)arg;\n\tint __user *ip = p;\n\tint result, val, read_only;\n\tSg_device *sdp;\n\tSg_fd *sfp;\n\tSg_request *srp;\n\tunsigned long iflags;\n\n\tif ((!(sfp = (Sg_fd *) filp->private_data)) || (!(sdp = sfp->parentdp)))\n\t\treturn -ENXIO;\n\n\tSCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sdp,\n\t\t\t\t   \"sg_ioctl: cmd=0x%x\\n\", (int) cmd_in));\n\tread_only = (O_RDWR != (filp->f_flags & O_ACCMODE));\n\n\tswitch (cmd_in) {\n\tcase SG_IO:\n\t\tif (atomic_read(&sdp->detaching))\n\t\t\treturn -ENODEV;\n\t\tif (!scsi_block_when_processing_errors(sdp->device))\n\t\t\treturn -ENXIO;\n\t\tif (!access_ok(VERIFY_WRITE, p, SZ_SG_IO_HDR))\n\t\t\treturn -EFAULT;\n\t\tresult = sg_new_write(sfp, filp, p, SZ_SG_IO_HDR,\n\t\t\t\t 1, read_only, 1, &srp);\n\t\tif (result < 0)\n\t\t\treturn result;\n\t\tresult = wait_event_interruptible(sfp->read_wait,\n\t\t\t(srp_done(sfp, srp) || atomic_read(&sdp->detaching)));\n\t\tif (atomic_read(&sdp->detaching))\n\t\t\treturn -ENODEV;\n\t\twrite_lock_irq(&sfp->rq_list_lock);\n\t\tif (srp->done) {\n\t\t\tsrp->done = 2;\n\t\t\twrite_unlock_irq(&sfp->rq_list_lock);\n\t\t\tresult = sg_new_read(sfp, p, SZ_SG_IO_HDR, srp);\n\t\t\treturn (result < 0) ? result : 0;\n\t\t}\n\t\tsrp->orphan = 1;\n\t\twrite_unlock_irq(&sfp->rq_list_lock);\n\t\treturn result;\t/* -ERESTARTSYS because signal hit process */\n\tcase SG_SET_TIMEOUT:\n\t\tresult = get_user(val, ip);\n\t\tif (result)\n\t\t\treturn result;\n\t\tif (val < 0)\n\t\t\treturn -EIO;\n\t\tif (val >= mult_frac((s64)INT_MAX, USER_HZ, HZ))\n\t\t\tval = min_t(s64, mult_frac((s64)INT_MAX, USER_HZ, HZ),\n\t\t\t\t    INT_MAX);\n\t\tsfp->timeout_user = val;\n\t\tsfp->timeout = mult_frac(val, HZ, USER_HZ);\n\n\t\treturn 0;\n\tcase SG_GET_TIMEOUT:\t/* N.B. User receives timeout as return value */\n\t\t\t\t/* strange ..., for backward compatibility */\n\t\treturn sfp->timeout_user;\n\tcase SG_SET_FORCE_LOW_DMA:\n\t\tresult = get_user(val, ip);\n\t\tif (result)\n\t\t\treturn result;\n\t\tif (val) {\n\t\t\tsfp->low_dma = 1;\n\t\t\tif ((0 == sfp->low_dma) && (0 == sg_res_in_use(sfp))) {\n\t\t\t\tval = (int) sfp->reserve.bufflen;\n\t\t\t\tsg_remove_scat(sfp, &sfp->reserve);\n\t\t\t\tsg_build_reserve(sfp, val);\n\t\t\t}\n\t\t} else {\n\t\t\tif (atomic_read(&sdp->detaching))\n\t\t\t\treturn -ENODEV;\n\t\t\tsfp->low_dma = sdp->device->host->unchecked_isa_dma;\n\t\t}\n\t\treturn 0;\n\tcase SG_GET_LOW_DMA:\n\t\treturn put_user((int) sfp->low_dma, ip);\n\tcase SG_GET_SCSI_ID:\n\t\tif (!access_ok(VERIFY_WRITE, p, sizeof (sg_scsi_id_t)))\n\t\t\treturn -EFAULT;\n\t\telse {\n\t\t\tsg_scsi_id_t __user *sg_idp = p;\n\n\t\t\tif (atomic_read(&sdp->detaching))\n\t\t\t\treturn -ENODEV;\n\t\t\t__put_user((int) sdp->device->host->host_no,\n\t\t\t\t   &sg_idp->host_no);\n\t\t\t__put_user((int) sdp->device->channel,\n\t\t\t\t   &sg_idp->channel);\n\t\t\t__put_user((int) sdp->device->id, &sg_idp->scsi_id);\n\t\t\t__put_user((int) sdp->device->lun, &sg_idp->lun);\n\t\t\t__put_user((int) sdp->device->type, &sg_idp->scsi_type);\n\t\t\t__put_user((short) sdp->device->host->cmd_per_lun,\n\t\t\t\t   &sg_idp->h_cmd_per_lun);\n\t\t\t__put_user((short) sdp->device->queue_depth,\n\t\t\t\t   &sg_idp->d_queue_depth);\n\t\t\t__put_user(0, &sg_idp->unused[0]);\n\t\t\t__put_user(0, &sg_idp->unused[1]);\n\t\t\treturn 0;\n\t\t}\n\tcase SG_SET_FORCE_PACK_ID:\n\t\tresult = get_user(val, ip);\n\t\tif (result)\n\t\t\treturn result;\n\t\tsfp->force_packid = val ? 1 : 0;\n\t\treturn 0;\n\tcase SG_GET_PACK_ID:\n\t\tif (!access_ok(VERIFY_WRITE, ip, sizeof (int)))\n\t\t\treturn -EFAULT;\n\t\tread_lock_irqsave(&sfp->rq_list_lock, iflags);\n\t\tfor (srp = sfp->headrp; srp; srp = srp->nextrp) {\n\t\t\tif ((1 == srp->done) && (!srp->sg_io_owned)) {\n\t\t\t\tread_unlock_irqrestore(&sfp->rq_list_lock,\n\t\t\t\t\t\t       iflags);\n\t\t\t\t__put_user(srp->header.pack_id, ip);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tread_unlock_irqrestore(&sfp->rq_list_lock, iflags);\n\t\t__put_user(-1, ip);\n\t\treturn 0;\n\tcase SG_GET_NUM_WAITING:\n\t\tread_lock_irqsave(&sfp->rq_list_lock, iflags);\n\t\tfor (val = 0, srp = sfp->headrp; srp; srp = srp->nextrp) {\n\t\t\tif ((1 == srp->done) && (!srp->sg_io_owned))\n\t\t\t\t++val;\n\t\t}\n\t\tread_unlock_irqrestore(&sfp->rq_list_lock, iflags);\n\t\treturn put_user(val, ip);\n\tcase SG_GET_SG_TABLESIZE:\n\t\treturn put_user(sdp->sg_tablesize, ip);\n\tcase SG_SET_RESERVED_SIZE:\n\t\tresult = get_user(val, ip);\n\t\tif (result)\n\t\t\treturn result;\n                if (val < 0)\n                        return -EINVAL;\n\t\tval = min_t(int, val,\n\t\t\t    max_sectors_bytes(sdp->device->request_queue));\n\t\tif (val != sfp->reserve.bufflen) {\n\t\t\tif (sg_res_in_use(sfp) || sfp->mmap_called)\n\t\t\t\treturn -EBUSY;\n\t\t\tsg_remove_scat(sfp, &sfp->reserve);\n\t\t\tsg_build_reserve(sfp, val);\n\t\t}\n\t\treturn 0;\n\tcase SG_GET_RESERVED_SIZE:\n\t\tval = min_t(int, sfp->reserve.bufflen,\n\t\t\t    max_sectors_bytes(sdp->device->request_queue));\n\t\treturn put_user(val, ip);\n\tcase SG_SET_COMMAND_Q:\n\t\tresult = get_user(val, ip);\n\t\tif (result)\n\t\t\treturn result;\n\t\tsfp->cmd_q = val ? 1 : 0;\n\t\treturn 0;\n\tcase SG_GET_COMMAND_Q:\n\t\treturn put_user((int) sfp->cmd_q, ip);\n\tcase SG_SET_KEEP_ORPHAN:\n\t\tresult = get_user(val, ip);\n\t\tif (result)\n\t\t\treturn result;\n\t\tsfp->keep_orphan = val;\n\t\treturn 0;\n\tcase SG_GET_KEEP_ORPHAN:\n\t\treturn put_user((int) sfp->keep_orphan, ip);\n\tcase SG_NEXT_CMD_LEN:\n\t\tresult = get_user(val, ip);\n\t\tif (result)\n\t\t\treturn result;\n\t\tif (val > SG_MAX_CDB_SIZE)\n\t\t\treturn -ENOMEM;\n\t\tsfp->next_cmd_len = (val > 0) ? val : 0;\n\t\treturn 0;\n\tcase SG_GET_VERSION_NUM:\n\t\treturn put_user(sg_version_num, ip);\n\tcase SG_GET_ACCESS_COUNT:\n\t\t/* faked - we don't have a real access count anymore */\n\t\tval = (sdp->device ? 1 : 0);\n\t\treturn put_user(val, ip);\n\tcase SG_GET_REQUEST_TABLE:\n\t\tif (!access_ok(VERIFY_WRITE, p, SZ_SG_REQ_INFO * SG_MAX_QUEUE))\n\t\t\treturn -EFAULT;\n\t\telse {\n\t\t\tsg_req_info_t *rinfo;\n\t\t\tunsigned int ms;\n\n\t\t\trinfo = kmalloc(SZ_SG_REQ_INFO * SG_MAX_QUEUE,\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!rinfo)\n\t\t\t\treturn -ENOMEM;\n\t\t\tread_lock_irqsave(&sfp->rq_list_lock, iflags);\n\t\t\tfor (srp = sfp->headrp, val = 0; val < SG_MAX_QUEUE;\n\t\t\t     ++val, srp = srp ? srp->nextrp : srp) {\n\t\t\t\tmemset(&rinfo[val], 0, SZ_SG_REQ_INFO);\n\t\t\t\tif (srp) {\n\t\t\t\t\trinfo[val].req_state = srp->done + 1;\n\t\t\t\t\trinfo[val].problem =\n\t\t\t\t\t    srp->header.masked_status & \n\t\t\t\t\t    srp->header.host_status & \n\t\t\t\t\t    srp->header.driver_status;\n\t\t\t\t\tif (srp->done)\n\t\t\t\t\t\trinfo[val].duration =\n\t\t\t\t\t\t\tsrp->header.duration;\n\t\t\t\t\telse {\n\t\t\t\t\t\tms = jiffies_to_msecs(jiffies);\n\t\t\t\t\t\trinfo[val].duration =\n\t\t\t\t\t\t    (ms > srp->header.duration) ?\n\t\t\t\t\t\t    (ms - srp->header.duration) : 0;\n\t\t\t\t\t}\n\t\t\t\t\trinfo[val].orphan = srp->orphan;\n\t\t\t\t\trinfo[val].sg_io_owned =\n\t\t\t\t\t\t\tsrp->sg_io_owned;\n\t\t\t\t\trinfo[val].pack_id =\n\t\t\t\t\t\t\tsrp->header.pack_id;\n\t\t\t\t\trinfo[val].usr_ptr =\n\t\t\t\t\t\t\tsrp->header.usr_ptr;\n\t\t\t\t}\n\t\t\t}\n\t\t\tread_unlock_irqrestore(&sfp->rq_list_lock, iflags);\n\t\t\tresult = __copy_to_user(p, rinfo, \n\t\t\t\t\t\tSZ_SG_REQ_INFO * SG_MAX_QUEUE);\n\t\t\tresult = result ? -EFAULT : 0;\n\t\t\tkfree(rinfo);\n\t\t\treturn result;\n\t\t}\n\tcase SG_EMULATED_HOST:\n\t\tif (atomic_read(&sdp->detaching))\n\t\t\treturn -ENODEV;\n\t\treturn put_user(sdp->device->host->hostt->emulated, ip);\n\tcase SCSI_IOCTL_SEND_COMMAND:\n\t\tif (atomic_read(&sdp->detaching))\n\t\t\treturn -ENODEV;\n\t\tif (read_only) {\n\t\t\tunsigned char opcode = WRITE_6;\n\t\t\tScsi_Ioctl_Command __user *siocp = p;\n\n\t\t\tif (copy_from_user(&opcode, siocp->data, 1))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (sg_allow_access(filp, &opcode))\n\t\t\t\treturn -EPERM;\n\t\t}\n\t\treturn sg_scsi_ioctl(sdp->device->request_queue, NULL, filp->f_mode, p);\n\tcase SG_SET_DEBUG:\n\t\tresult = get_user(val, ip);\n\t\tif (result)\n\t\t\treturn result;\n\t\tsdp->sgdebug = (char) val;\n\t\treturn 0;\n\tcase BLKSECTGET:\n\t\treturn put_user(max_sectors_bytes(sdp->device->request_queue),\n\t\t\t\tip);\n\tcase BLKTRACESETUP:\n\t\treturn blk_trace_setup(sdp->device->request_queue,\n\t\t\t\t       sdp->disk->disk_name,\n\t\t\t\t       MKDEV(SCSI_GENERIC_MAJOR, sdp->index),\n\t\t\t\t       NULL,\n\t\t\t\t       (char *)arg);\n\tcase BLKTRACESTART:\n\t\treturn blk_trace_startstop(sdp->device->request_queue, 1);\n\tcase BLKTRACESTOP:\n\t\treturn blk_trace_startstop(sdp->device->request_queue, 0);\n\tcase BLKTRACETEARDOWN:\n\t\treturn blk_trace_remove(sdp->device->request_queue);\n\tcase SCSI_IOCTL_GET_IDLUN:\n\tcase SCSI_IOCTL_GET_BUS_NUMBER:\n\tcase SCSI_IOCTL_PROBE_HOST:\n\tcase SG_GET_TRANSFORM:\n\tcase SG_SCSI_RESET:\n\t\tif (atomic_read(&sdp->detaching))\n\t\t\treturn -ENODEV;\n\t\tbreak;\n\tdefault:\n\t\tif (read_only)\n\t\t\treturn -EPERM;\t/* don't know so take safe approach */\n\t\tbreak;\n\t}\n\n\tresult = scsi_ioctl_block_when_processing_errors(sdp->device,\n\t\t\tcmd_in, filp->f_flags & O_NDELAY);\n\tif (result)\n\t\treturn result;\n\treturn scsi_ioctl(sdp->device, cmd_in, p);\n}", "target": 2, "idx": 9965}
{"commit_id": "23ccf3cabb4baf6e8af4b1af3fcc59c904736f21", "project": "ffmpeg", "func": "int ff_htmlmarkup_to_ass(void *log_ctx, AVBPrint *dst, const char *in)\n{\n    char *param, buffer[128], tmp[128];\n    int len, tag_close, sptr = 1, line_start = 1, an = 0, end = 0;\n    SrtStack stack[16];\n    int closing_brace_missing = 0;\n\n    stack[0].tag[0] = 0;\n    strcpy(stack[0].param[PARAM_SIZE],  \"{\\\\fs}\");\n    strcpy(stack[0].param[PARAM_COLOR], \"{\\\\c}\");\n    strcpy(stack[0].param[PARAM_FACE],  \"{\\\\fn}\");\n\n    for (; !end && *in; in++) {\n        switch (*in) {\n        case '\\r':\n            break;\n        case '\\n':\n            if (line_start) {\n                end = 1;\n                break;\n            }\n            rstrip_spaces_buf(dst);\n            av_bprintf(dst, \"\\\\N\");\n            line_start = 1;\n            break;\n        case ' ':\n            if (!line_start)\n                av_bprint_chars(dst, *in, 1);\n            break;\n        case '{':    /* skip all {\\xxx} substrings except for {\\an%d}\n                        and all microdvd like styles such as {Y:xxx} */\n            len = 0;\n            an += sscanf(in, \"{\\\\an%*1u}%n\", &len) >= 0 && len > 0;\n\n            if (!closing_brace_missing) {\n                if (   (an != 1 && in[1] == '\\\\')\n                    || (in[1] && strchr(\"CcFfoPSsYy\", in[1]) && in[2] == ':')) {\n                    char *bracep = strchr(in+2, '}');\n                    if (bracep) {\n                        in = bracep;\n                        break;\n                    } else\n                        closing_brace_missing = 1;\n                }\n            }\n\n            av_bprint_chars(dst, *in, 1);\n            break;\n        case '<':\n            tag_close = in[1] == '/';\n            len = 0;\n            if (scantag(in+tag_close+1, buffer, &len) && len > 0) {\n                const char *tagname = buffer;\n                while (*tagname == ' ')\n                    tagname++;\n                if ((param = strchr(tagname, ' ')))\n                    *param++ = 0;\n                if ((!tag_close && sptr < FF_ARRAY_ELEMS(stack) && *tagname) ||\n                    ( tag_close && sptr > 0 && !strcmp(stack[sptr-1].tag, tagname))) {\n                    int i, j, unknown = 0;\n                    in += len + tag_close;\n                    if (!tag_close)\n                        memset(stack+sptr, 0, sizeof(*stack));\n                    if (!strcmp(tagname, \"font\")) {\n                        if (tag_close) {\n                            for (i=PARAM_NUMBER-1; i>=0; i--)\n                                if (stack[sptr-1].param[i][0])\n                                    for (j=sptr-2; j>=0; j--)\n                                        if (stack[j].param[i][0]) {\n                                            av_bprintf(dst, \"%s\", stack[j].param[i]);\n                                            break;\n                                        }\n                        } else {\n                            while (param) {\n                                if (!strncmp(param, \"size=\", 5)) {\n                                    unsigned font_size;\n                                    param += 5 + (param[5] == '\"');\n                                    if (sscanf(param, \"%u\", &font_size) == 1) {\n                                        snprintf(stack[sptr].param[PARAM_SIZE],\n                                             sizeof(stack[0].param[PARAM_SIZE]),\n                                             \"{\\\\fs%u}\", font_size);\n                                    }\n                                } else if (!strncmp(param, \"color=\", 6)) {\n                                    param += 6 + (param[6] == '\"');\n                                    snprintf(stack[sptr].param[PARAM_COLOR],\n                                         sizeof(stack[0].param[PARAM_COLOR]),\n                                         \"{\\\\c&H%X&}\",\n                                         html_color_parse(log_ctx, param));\n                                } else if (!strncmp(param, \"face=\", 5)) {\n                                    param += 5 + (param[5] == '\"');\n                                    len = strcspn(param,\n                                                  param[-1] == '\"' ? \"\\\"\" :\" \");\n                                    av_strlcpy(tmp, param,\n                                               FFMIN(sizeof(tmp), len+1));\n                                    param += len;\n                                    snprintf(stack[sptr].param[PARAM_FACE],\n                                             sizeof(stack[0].param[PARAM_FACE]),\n                                             \"{\\\\fn%s}\", tmp);\n                                }\n                                if ((param = strchr(param, ' ')))\n                                    param++;\n                            }\n                            for (i=0; i<PARAM_NUMBER; i++)\n                                if (stack[sptr].param[i][0])\n                                    av_bprintf(dst, \"%s\", stack[sptr].param[i]);\n                        }\n                    } else if (tagname[0] && !tagname[1] && strspn(tagname, \"bisu\") == 1) {\n                        av_bprintf(dst, \"{\\\\%c%d}\", tagname[0], !tag_close);\n                    } else {\n                        unknown = 1;\n                        snprintf(tmp, sizeof(tmp), \"</%s>\", tagname);\n                    }\n                    if (tag_close) {\n                        sptr--;\n                    } else if (unknown && !strstr(in, tmp)) {\n                        in -= len + tag_close;\n                        av_bprint_chars(dst, *in, 1);\n                    } else\n                        av_strlcpy(stack[sptr++].tag, tagname,\n                                   sizeof(stack[0].tag));\n                    break;\n                }\n            }\n        default:\n            av_bprint_chars(dst, *in, 1);\n            break;\n        }\n        if (*in != ' ' && *in != '\\r' && *in != '\\n')\n            line_start = 0;\n    }\n\n    if (!av_bprint_is_complete(dst))\n        return AVERROR(ENOMEM);\n\n    while (dst->len >= 2 && !strncmp(&dst->str[dst->len - 2], \"\\\\N\", 2))\n        dst->len -= 2;\n    dst->str[dst->len] = 0;\n    rstrip_spaces_buf(dst);\n\n    return 0;\n}", "target": 1, "idx": 9966}
{"commit_id": "f38e895dfc0d97bce64f73ce99df706911d9aa07", "project": "wireshark", "func": "void\ncfile_dump_open_failure_message(const char *progname, const char *filename,\n                                int err, int file_type_subtype)\n{\n    if (err < 0) {\n        /*\n         * Wiretap error.\n         * Get a string that describes what we're opening.\n         */\n        char *file_description = input_file_description(filename);\n\n        switch (err) {\n\n        case WTAP_ERR_NOT_REGULAR_FILE:\n            cmdarg_err(\"The %s is a \\\"special file\\\" or socket or other non-regular file.\",\n                       file_description);\n            break;\n\n        case WTAP_ERR_CANT_WRITE_TO_PIPE:\n            cmdarg_err(\"The %s is a pipe, and \\\"%s\\\" capture files can't be written to a pipe.\",\n                       file_description,\n                       wtap_file_type_subtype_short_string(file_type_subtype));\n            break;\n\n        case WTAP_ERR_UNWRITABLE_FILE_TYPE:\n            cmdarg_err(\"%s doesn't support writing capture files in that format.\",\n                       progname);\n            break;\n\n        case WTAP_ERR_UNWRITABLE_ENCAP:\n            cmdarg_err(\"The capture file being read can't be written as a \\\"%s\\\" file.\",\n                       wtap_file_type_subtype_short_string(file_type_subtype));\n            break;\n\n        case WTAP_ERR_ENCAP_PER_PACKET_UNSUPPORTED:\n            cmdarg_err(\"The capture file being read can't be written as a \\\"%s\\\" file.\",\n                       wtap_file_type_subtype_short_string(file_type_subtype));\n            break;\n\n        case WTAP_ERR_CANT_OPEN:\n            cmdarg_err(\"The %s could not be created for some unknown reason.\",\n                       file_description);\n            break;\n\n        case WTAP_ERR_SHORT_WRITE:\n            cmdarg_err(\"A full header couldn't be written to the %s.\",\n                       file_description);\n            break;\n\n        case WTAP_ERR_COMPRESSION_NOT_SUPPORTED:\n            cmdarg_err(\"This file type cannot be written as a compressed file.\");\n            break;\n\n        default:\n            cmdarg_err(\"The %s could not be created: %s.\",\n                       file_description,\n                       wtap_strerror(err));\n            break;\n        }\n        g_free(file_description);\n    } else\n        cmdarg_err(file_open_error_message(err, TRUE), filename);\n}", "target": 2, "idx": 9967}
{"commit_id": "36a4d82dddbbd421d2b8e79e1cab68c8126d5075", "project": "torvalds/linux", "func": "static int ntfs_attr_find(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst u8 *val, const u32 val_len, ntfs_attr_search_ctx *ctx)\n{\n\tATTR_RECORD *a;\n\tntfs_volume *vol = ctx->ntfs_ino->vol;\n\tntfschar *upcase = vol->upcase;\n\tu32 upcase_len = vol->upcase_len;\n\n\t/*\n\t * Iterate over attributes in mft record starting at @ctx->attr, or the\n\t * attribute following that, if @ctx->is_first is 'true'.\n\t */\n\tif (ctx->is_first) {\n\t\ta = ctx->attr;\n\t\tctx->is_first = false;\n\t} else\n\t\ta = (ATTR_RECORD*)((u8*)ctx->attr +\n\t\t\t\tle32_to_cpu(ctx->attr->length));\n\tfor (;;\ta = (ATTR_RECORD*)((u8*)a + le32_to_cpu(a->length))) {\n\t\tu8 *mrec_end = (u8 *)ctx->mrec +\n\t\t               le32_to_cpu(ctx->mrec->bytes_allocated);\n\t\tu8 *name_end;\n\n\t\t/* check whether ATTR_RECORD wrap */\n\t\tif ((u8 *)a < (u8 *)ctx->mrec)\n\t\t\tbreak;\n\n\t\t/* check whether Attribute Record Header is within bounds */\n\t\tif ((u8 *)a > mrec_end ||\n\t\t    (u8 *)a + sizeof(ATTR_RECORD) > mrec_end)\n\t\t\tbreak;\n\n\t\t/* check whether ATTR_RECORD's name is within bounds */\n\t\tname_end = (u8 *)a + le16_to_cpu(a->name_offset) +\n\t\t\t   a->name_length * sizeof(ntfschar);\n\t\tif (name_end > mrec_end)\n\t\t\tbreak;\n\n\t\tctx->attr = a;\n\t\tif (unlikely(le32_to_cpu(a->type) > le32_to_cpu(type) ||\n\t\t\t\ta->type == AT_END))\n\t\t\treturn -ENOENT;\n\t\tif (unlikely(!a->length))\n\t\t\tbreak;\n\t\tif (a->type != type)\n\t\t\tcontinue;\n\t\t/*\n\t\t * If @name is present, compare the two names.  If @name is\n\t\t * missing, assume we want an unnamed attribute.\n\t\t */\n\t\tif (!name) {\n\t\t\t/* The search failed if the found attribute is named. */\n\t\t\tif (a->name_length)\n\t\t\t\treturn -ENOENT;\n\t\t} else if (!ntfs_are_names_equal(name, name_len,\n\t\t\t    (ntfschar*)((u8*)a + le16_to_cpu(a->name_offset)),\n\t\t\t    a->name_length, ic, upcase, upcase_len)) {\n\t\t\tregister int rc;\n\n\t\t\trc = ntfs_collate_names(name, name_len,\n\t\t\t\t\t(ntfschar*)((u8*)a +\n\t\t\t\t\tle16_to_cpu(a->name_offset)),\n\t\t\t\t\ta->name_length, 1, IGNORE_CASE,\n\t\t\t\t\tupcase, upcase_len);\n\t\t\t/*\n\t\t\t * If @name collates before a->name, there is no\n\t\t\t * matching attribute.\n\t\t\t */\n\t\t\tif (rc == -1)\n\t\t\t\treturn -ENOENT;\n\t\t\t/* If the strings are not equal, continue search. */\n\t\t\tif (rc)\n\t\t\t\tcontinue;\n\t\t\trc = ntfs_collate_names(name, name_len,\n\t\t\t\t\t(ntfschar*)((u8*)a +\n\t\t\t\t\tle16_to_cpu(a->name_offset)),\n\t\t\t\t\ta->name_length, 1, CASE_SENSITIVE,\n\t\t\t\t\tupcase, upcase_len);\n\t\t\tif (rc == -1)\n\t\t\t\treturn -ENOENT;\n\t\t\tif (rc)\n\t\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * The names match or @name not present and attribute is\n\t\t * unnamed.  If no @val specified, we have found the attribute\n\t\t * and are done.\n\t\t */\n\t\tif (!val)\n\t\t\treturn 0;\n\t\t/* @val is present; compare values. */\n\t\telse {\n\t\t\tregister int rc;\n\n\t\t\trc = memcmp(val, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tmin_t(u32, val_len, le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length)));\n\t\t\t/*\n\t\t\t * If @val collates before the current attribute's\n\t\t\t * value, there is no matching attribute.\n\t\t\t */\n\t\t\tif (!rc) {\n\t\t\t\tregister u32 avl;\n\n\t\t\t\tavl = le32_to_cpu(\n\t\t\t\t\t\ta->data.resident.value_length);\n\t\t\t\tif (val_len == avl)\n\t\t\t\t\treturn 0;\n\t\t\t\tif (val_len < avl)\n\t\t\t\t\treturn -ENOENT;\n\t\t\t} else if (rc < 0)\n\t\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\tntfs_error(vol->sb, \"Inode is corrupt.  Run chkdsk.\");\n\tNVolSetErrors(vol);\n\treturn -EIO;\n}", "target": 2, "idx": 9968}
{"commit_id": "7f4a9a9b2a49547eae24d2e19bc5c346e9026479", "project": "curl", "func": "void Curl_detach_connnection(struct Curl_easy *data)\n{\n  struct connectdata *conn = data->conn;\n  if(conn) {\n    Curl_llist_remove(&conn->easyq, &data->conn_queue, NULL);\n    Curl_ssl_detach_conn(data, conn);\n  }\n  data->conn = NULL;\n}", "target": 2, "idx": 9969}
{"commit_id": "7d63315a64267c565d1f34b9cb523a14616fed24", "project": "ImageMagick", "func": "static Image *ReadWPGImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  typedef struct\n  {\n    size_t FileId;\n    MagickOffsetType DataOffset;\n    unsigned int ProductType;\n    unsigned int FileType;\n    unsigned char MajorVersion;\n    unsigned char MinorVersion;\n    unsigned int EncryptKey;\n    unsigned int Reserved;\n  } WPGHeader;\n\n  typedef struct\n  {\n    unsigned char RecType;\n    size_t RecordLength;\n  } WPGRecord;\n\n  typedef struct\n  {\n    unsigned char Class;\n    unsigned char RecType;\n    size_t Extension;\n    size_t RecordLength;\n  } WPG2Record;\n\n  typedef struct\n  {\n    unsigned  HorizontalUnits;\n    unsigned  VerticalUnits;\n    unsigned char PosSizePrecision;\n  } WPG2Start;\n\n  typedef struct\n  {\n    unsigned int Width;\n    unsigned int Height;\n    unsigned int Depth;\n    unsigned int HorzRes;\n    unsigned int VertRes;\n  } WPGBitmapType1;\n\n  typedef struct\n  {\n    unsigned int Width;\n    unsigned int Height;\n    unsigned char Depth;\n    unsigned char Compression;\n  } WPG2BitmapType1;\n\n  typedef struct\n  {\n    unsigned int RotAngle;\n    unsigned int LowLeftX;\n    unsigned int LowLeftY;\n    unsigned int UpRightX;\n    unsigned int UpRightY;\n    unsigned int Width;\n    unsigned int Height;\n    unsigned int Depth;\n    unsigned int HorzRes;\n    unsigned int VertRes;\n  } WPGBitmapType2;\n\n  typedef struct\n  {\n    unsigned int StartIndex;\n    unsigned int NumOfEntries;\n  } WPGColorMapRec;\n\n  /*\n  typedef struct {\n    size_t PS_unknown1;\n    unsigned int PS_unknown2;\n    unsigned int PS_unknown3;\n  } WPGPSl1Record;  \n  */\n\n  Image\n    *image;\n\n  unsigned int\n    status;\n\n  WPGHeader\n    Header;\n\n  WPGRecord\n    Rec;\n\n  WPG2Record\n    Rec2;\n\n  WPG2Start StartWPG;\n\n  WPGBitmapType1\n    BitmapHeader1;\n\n  WPG2BitmapType1\n    Bitmap2Header1;\n\n  WPGBitmapType2\n    BitmapHeader2;\n\n  WPGColorMapRec\n    WPG_Palette;\n\n  int\n    i,\n    bpp,\n    WPG2Flags;\n\n  ssize_t\n    ldblk;\n\n  size_t\n    one;\n\n  unsigned char\n    *BImgBuff;\n\n  tCTM CTM;         /*current transform matrix*/\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  one=1;\n  image=AcquireImage(image_info,exception);\n  image->depth=8;\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read WPG image.\n  */\n  Header.FileId=ReadBlobLSBLong(image);\n  Header.DataOffset=(MagickOffsetType) ReadBlobLSBLong(image);\n  Header.ProductType=ReadBlobLSBShort(image);\n  Header.FileType=ReadBlobLSBShort(image);\n  Header.MajorVersion=ReadBlobByte(image);\n  Header.MinorVersion=ReadBlobByte(image);\n  Header.EncryptKey=ReadBlobLSBShort(image);\n  Header.Reserved=ReadBlobLSBShort(image);\n\n  if (Header.FileId!=0x435057FF || (Header.ProductType>>8)!=0x16)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (Header.EncryptKey!=0)\n    ThrowReaderException(CoderError,\"EncryptedWPGImageFileNotSupported\");\n\n  image->columns = 1;\n  image->rows = 1;\n  image->colors = 0;\n  bpp=0;\n  BitmapHeader2.RotAngle=0;\n  Rec2.RecordLength=0;\n\n  switch(Header.FileType)\n    {\n    case 1:     /* WPG level 1 */\n      while(!EOFBlob(image)) /* object parser loop */\n        {\n          (void) SeekBlob(image,Header.DataOffset,SEEK_SET);\n          if(EOFBlob(image))\n            break;\n\n          Rec.RecType=(i=ReadBlobByte(image));\n          if(i==EOF)\n            break;\n          Rd_WP_DWORD(image,&Rec.RecordLength);\n          if (Rec.RecordLength > GetBlobSize(image))\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n          if(EOFBlob(image))\n            break;\n\n          Header.DataOffset=TellBlob(image)+Rec.RecordLength;\n\n          switch(Rec.RecType)\n            {\n            case 0x0B: /* bitmap type 1 */\n              BitmapHeader1.Width=ReadBlobLSBShort(image);\n              BitmapHeader1.Height=ReadBlobLSBShort(image);\n              if ((BitmapHeader1.Width == 0) || (BitmapHeader1.Height == 0))\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              BitmapHeader1.Depth=ReadBlobLSBShort(image);\n              BitmapHeader1.HorzRes=ReadBlobLSBShort(image);\n              BitmapHeader1.VertRes=ReadBlobLSBShort(image);\n\n              if(BitmapHeader1.HorzRes && BitmapHeader1.VertRes)\n                {\n                  image->units=PixelsPerCentimeterResolution;\n                  image->resolution.x=BitmapHeader1.HorzRes/470.0;\n                  image->resolution.y=BitmapHeader1.VertRes/470.0;\n                }\n              image->columns=BitmapHeader1.Width;\n              image->rows=BitmapHeader1.Height;\n              bpp=BitmapHeader1.Depth;\n\n              goto UnpackRaster;\n\n            case 0x0E:  /*Color palette */\n              WPG_Palette.StartIndex=ReadBlobLSBShort(image);\n              WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);\n              if ((WPG_Palette.NumOfEntries-WPG_Palette.StartIndex) >\n                  (Rec2.RecordLength-2-2) / 3)\n                ThrowReaderException(CorruptImageError,\"InvalidColormapIndex\");\n              image->colors=WPG_Palette.NumOfEntries;\n              if (!AcquireImageColormap(image,image->colors,exception))\n                goto NoMemory;\n              for (i=WPG_Palette.StartIndex;\n                   i < (int)WPG_Palette.NumOfEntries; i++)\n                {\n                  image->colormap[i].red=ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image));\n                  image->colormap[i].green=ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image));\n                  image->colormap[i].blue=ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image));\n                }\n              break;\n     \n            case 0x11:  /* Start PS l1 */\n              if(Rec.RecordLength > 8)\n                image=ExtractPostscript(image,image_info,\n                  TellBlob(image)+8,   /* skip PS header in the wpg */\n                  (ssize_t) Rec.RecordLength-8,exception);\n              break;     \n\n            case 0x14:  /* bitmap type 2 */\n              BitmapHeader2.RotAngle=ReadBlobLSBShort(image);\n              BitmapHeader2.LowLeftX=ReadBlobLSBShort(image);\n              BitmapHeader2.LowLeftY=ReadBlobLSBShort(image);\n              BitmapHeader2.UpRightX=ReadBlobLSBShort(image);\n              BitmapHeader2.UpRightY=ReadBlobLSBShort(image);\n              BitmapHeader2.Width=ReadBlobLSBShort(image);\n              BitmapHeader2.Height=ReadBlobLSBShort(image);\n              if ((BitmapHeader2.Width == 0) || (BitmapHeader2.Height == 0))\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              BitmapHeader2.Depth=ReadBlobLSBShort(image);\n              BitmapHeader2.HorzRes=ReadBlobLSBShort(image);\n              BitmapHeader2.VertRes=ReadBlobLSBShort(image);\n\n              image->units=PixelsPerCentimeterResolution;\n              image->page.width=(unsigned int)\n                ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightX)/470.0);\n              image->page.height=(unsigned int)\n                ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightY)/470.0);\n              image->page.x=(int) (BitmapHeader2.LowLeftX/470.0);\n              image->page.y=(int) (BitmapHeader2.LowLeftX/470.0);\n              if(BitmapHeader2.HorzRes && BitmapHeader2.VertRes)\n                {\n                  image->resolution.x=BitmapHeader2.HorzRes/470.0;\n                  image->resolution.y=BitmapHeader2.VertRes/470.0;\n                }\n              image->columns=BitmapHeader2.Width;\n              image->rows=BitmapHeader2.Height;\n              bpp=BitmapHeader2.Depth;\n\n            UnpackRaster:      \n              status=SetImageExtent(image,image->columns,image->rows,exception);\n              if (status == MagickFalse)\n                break;\n              if ((image->colors == 0) && (bpp != 24))\n                {\n                  image->colors=one << bpp;\n                  if (!AcquireImageColormap(image,image->colors,exception))\n                    {\n                    NoMemory:\n                      ThrowReaderException(ResourceLimitError,\n                        \"MemoryAllocationFailed\");\n                    }\n                  /* printf(\"Load default colormap \\n\"); */\n                  for (i=0; (i < (int) image->colors) && (i < 256); i++)\n                    {               \n                      image->colormap[i].red=ScaleCharToQuantum(WPG1_Palette[i].Red);\n                      image->colormap[i].green=ScaleCharToQuantum(WPG1_Palette[i].Green);\n                      image->colormap[i].blue=ScaleCharToQuantum(WPG1_Palette[i].Blue);\n                    }\n                }\n              else\n                {\n                  if (bpp < 24)\n                    if ( (image->colors < (one << bpp)) && (bpp != 24) )\n                      image->colormap=(PixelInfo *) ResizeQuantumMemory(\n                        image->colormap,(size_t) (one << bpp),\n                        sizeof(*image->colormap));\n                }\n          \n              if (bpp == 1)\n                {\n                  if(image->colormap[0].red==0 &&\n                     image->colormap[0].green==0 &&\n                     image->colormap[0].blue==0 &&\n                     image->colormap[1].red==0 &&\n                     image->colormap[1].green==0 &&\n                     image->colormap[1].blue==0)\n                    {  /* fix crippled monochrome palette */\n                      image->colormap[1].red =\n                        image->colormap[1].green =\n                        image->colormap[1].blue = QuantumRange;\n                    }\n                }      \n\n              if(UnpackWPGRaster(image,bpp,exception) < 0)\n                /* The raster cannot be unpacked */\n                {\n                DecompressionFailed:\n                  ThrowReaderException(CoderError,\"UnableToDecompressImage\");\n                    }\n\n              if(Rec.RecType==0x14 && BitmapHeader2.RotAngle!=0 && !image_info->ping)\n                {  \n                  /* flop command */\n                  if(BitmapHeader2.RotAngle & 0x8000)\n                    {\n                      Image\n                        *flop_image;\n\n                      flop_image = FlopImage(image, exception);\n                      if (flop_image != (Image *) NULL) {\n                        DuplicateBlob(flop_image,image);\n                        ReplaceImageInList(&image,flop_image);\n                      }\n                    }\n                  /* flip command */\n                  if(BitmapHeader2.RotAngle & 0x2000)\n                    {\n                      Image\n                        *flip_image;\n\n                      flip_image = FlipImage(image, exception);\n                      if (flip_image != (Image *) NULL) {\n                        DuplicateBlob(flip_image,image);\n                        ReplaceImageInList(&image,flip_image);\n                      }\n                    }\n                  /* rotate command */\n                  if(BitmapHeader2.RotAngle & 0x0FFF)\n                    {\n                      Image\n                        *rotate_image;\n\n                      rotate_image=RotateImage(image,(BitmapHeader2.RotAngle &\n                        0x0FFF), exception);\n                      if (rotate_image != (Image *) NULL) {\n                        DuplicateBlob(rotate_image,image);\n                        ReplaceImageInList(&image,rotate_image);\n                      }\n                    }\n                }\n\n              /* Allocate next image structure. */\n              AcquireNextImage(image_info,image,exception);\n              image->depth=8;\n              if (image->next == (Image *) NULL)\n                goto Finish;\n              image=SyncNextImageInList(image);\n              image->columns=image->rows=1;\n              image->colors=0;\n              break;\n\n            case 0x1B:  /* Postscript l2 */\n              if(Rec.RecordLength>0x3C)\n                image=ExtractPostscript(image,image_info,\n                  TellBlob(image)+0x3C,   /* skip PS l2 header in the wpg */\n                  (ssize_t) Rec.RecordLength-0x3C,exception);\n              break;\n            }\n        }\n      break;\n\n    case 2:  /* WPG level 2 */\n      (void) memset(CTM,0,sizeof(CTM));\n      StartWPG.PosSizePrecision = 0;\n      while(!EOFBlob(image)) /* object parser loop */\n        {\n          (void) SeekBlob(image,Header.DataOffset,SEEK_SET);\n          if(EOFBlob(image))\n            break;\n\n          Rec2.Class=(i=ReadBlobByte(image));\n          if(i==EOF)\n            break;\n          Rec2.RecType=(i=ReadBlobByte(image));\n          if(i==EOF)\n            break;\n          Rd_WP_DWORD(image,&Rec2.Extension);\n          Rd_WP_DWORD(image,&Rec2.RecordLength);\n          if(EOFBlob(image))\n            break;\n\n          Header.DataOffset=TellBlob(image)+Rec2.RecordLength;\n\n          switch(Rec2.RecType)\n            {\n      case 1:\n              StartWPG.HorizontalUnits=ReadBlobLSBShort(image);\n              StartWPG.VerticalUnits=ReadBlobLSBShort(image);\n              StartWPG.PosSizePrecision=ReadBlobByte(image);\n              break;\n            case 0x0C:    /* Color palette */\n              WPG_Palette.StartIndex=ReadBlobLSBShort(image);\n              WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);\n              if ((WPG_Palette.NumOfEntries-WPG_Palette.StartIndex) >\n                  (Rec2.RecordLength-2-2) / 3)\n                ThrowReaderException(CorruptImageError,\"InvalidColormapIndex\");\n              image->colors=WPG_Palette.NumOfEntries;\n              if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              for (i=WPG_Palette.StartIndex;\n                   i < (int)WPG_Palette.NumOfEntries; i++)\n                {\n                  image->colormap[i].red=ScaleCharToQuantum((char)\n                    ReadBlobByte(image));\n                  image->colormap[i].green=ScaleCharToQuantum((char)\n                    ReadBlobByte(image));\n                  image->colormap[i].blue=ScaleCharToQuantum((char)\n                    ReadBlobByte(image));\n                  (void) ReadBlobByte(image);   /*Opacity??*/\n                }\n              break;\n            case 0x0E:\n              Bitmap2Header1.Width=ReadBlobLSBShort(image);\n              Bitmap2Header1.Height=ReadBlobLSBShort(image);\n              if ((Bitmap2Header1.Width == 0) || (Bitmap2Header1.Height == 0))\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              Bitmap2Header1.Depth=ReadBlobByte(image);\n              Bitmap2Header1.Compression=ReadBlobByte(image);\n\n              if(Bitmap2Header1.Compression > 1)\n                continue; /*Unknown compression method */\n              switch(Bitmap2Header1.Depth)\n                {\n                case 1:\n                  bpp=1;\n                  break;\n                case 2:\n                  bpp=2;\n                  break;\n                case 3:\n                  bpp=4;\n                  break;\n                case 4:\n                  bpp=8;\n                  break;\n                case 8:\n                  bpp=24;\n                  break;\n                default:\n                  continue;  /*Ignore raster with unknown depth*/\n                }\n              image->columns=Bitmap2Header1.Width;\n              image->rows=Bitmap2Header1.Height;\n              status=SetImageExtent(image,image->columns,image->rows,exception);\n              if (status == MagickFalse)\n                break;\n              if ((image->colors == 0) && (bpp != 24))\n                {\n                  image->colors=one << bpp;\n                  if (!AcquireImageColormap(image,image->colors,exception))\n                    goto NoMemory;\n                }\n              else\n                {\n                  if(bpp < 24)\n                    if( image->colors<(one << bpp) && bpp!=24 )\n                      image->colormap=(PixelInfo *) ResizeQuantumMemory(\n                       image->colormap,(size_t) (one << bpp),\n                       sizeof(*image->colormap));\n                }\n\n\n              switch(Bitmap2Header1.Compression)\n                {\n                case 0:    /*Uncompressed raster*/\n                  {\n                    ldblk=(ssize_t) ((bpp*image->columns+7)/8);\n                    BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t)\n                      ldblk+1,sizeof(*BImgBuff));\n                    if (BImgBuff == (unsigned char *) NULL)\n                      goto NoMemory;\n\n                    for(i=0; i< (ssize_t) image->rows; i++)\n                      {\n                        (void) ReadBlob(image,ldblk,BImgBuff);\n                        InsertRow(image,BImgBuff,i,bpp,exception);\n                      }\n\n                    if(BImgBuff)\n                      BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);\n                    break;\n                  }\n                case 1:    /*RLE for WPG2 */\n                  {\n                    if( UnpackWPG2Raster(image,bpp,exception) < 0)\n                      goto DecompressionFailed;\n                    break;\n                  }   \n                }\n\n              if(CTM[0][0]<0 && !image_info->ping)\n                {    /*?? RotAngle=360-RotAngle;*/\n                  Image\n                    *flop_image;\n\n                  flop_image = FlopImage(image, exception);\n                  if (flop_image != (Image *) NULL) {\n                    DuplicateBlob(flop_image,image);\n                    ReplaceImageInList(&image,flop_image);\n                  }\n                  /* Try to change CTM according to Flip - I am not sure, must be checked.\n                     Tx(0,0)=-1;      Tx(1,0)=0;   Tx(2,0)=0;\n                     Tx(0,1)= 0;      Tx(1,1)=1;   Tx(2,1)=0;\n                     Tx(0,2)=(WPG._2Rect.X_ur+WPG._2Rect.X_ll);\n                     Tx(1,2)=0;   Tx(2,2)=1; */\n                }\n              if(CTM[1][1]<0 && !image_info->ping)\n                {    /*?? RotAngle=360-RotAngle;*/\n                  Image\n                    *flip_image;\n\n                   flip_image = FlipImage(image, exception);\n                   if (flip_image != (Image *) NULL) {\n                     DuplicateBlob(flip_image,image);\n                     ReplaceImageInList(&image,flip_image);\n                    }\n                  /* Try to change CTM according to Flip - I am not sure, must be checked.\n                     float_matrix Tx(3,3);\n                     Tx(0,0)= 1;   Tx(1,0)= 0;   Tx(2,0)=0;\n                     Tx(0,1)= 0;   Tx(1,1)=-1;   Tx(2,1)=0;\n                     Tx(0,2)= 0;   Tx(1,2)=(WPG._2Rect.Y_ur+WPG._2Rect.Y_ll);\n                     Tx(2,2)=1; */\n              }\n\n\n              /* Allocate next image structure. */\n              AcquireNextImage(image_info,image,exception);\n              image->depth=8;\n              if (image->next == (Image *) NULL)\n                goto Finish;\n              image=SyncNextImageInList(image);\n              image->columns=image->rows=1;\n              image->colors=0;\n              break;\n\n            case 0x12:  /* Postscript WPG2*/\n        i=ReadBlobLSBShort(image);\n              if(Rec2.RecordLength > (unsigned int) i)\n                image=ExtractPostscript(image,image_info,\n                  TellBlob(image)+i,    /*skip PS header in the wpg2*/\n                  (ssize_t) (Rec2.RecordLength-i-2),exception);\n              break;\n\n      case 0x1B:          /*bitmap rectangle*/\n              WPG2Flags = LoadWPG2Flags(image,StartWPG.PosSizePrecision,NULL,&CTM);\n              (void) WPG2Flags;\n              break;\n            }\n        }\n\n      break;\n\n    default:\n      {\n         ThrowReaderException(CoderError,\"DataEncodingSchemeIsNotSupported\");\n      }\n   }\n\n Finish:\n  (void) CloseBlob(image);\n\n  {\n    Image\n      *p;\n\n    ssize_t\n      scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n    /*\n      Fix scene numbers.\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=(size_t) scene++;\n  }\n  if (image == (Image *) NULL)\n    ThrowReaderException(CorruptImageError,\n      \"ImageFileDoesNotContainAnyImageData\");\n  return(image);\n}", "target": 1, "idx": 9970}
{"commit_id": "04f2d32871bb3b11d7dc024039952f2fe2750306", "project": "acassen/keepalived", "func": "void\nmem_log_init(const char* prog_name, const char *banner)\n{\n\tsize_t log_name_len;\n\tchar *log_name;\n\n\tif (__test_bit(LOG_CONSOLE_BIT, &debug)) {\n\t\tlog_op = stderr;\n\t\treturn;\n\t}\n\n\tif (log_op)\n\t\tfclose(log_op);\n\n\tlog_name_len = 5 + strlen(prog_name) + 5 + 7 + 4 + 1;\t/* \"/tmp/\" + prog_name + \"_mem.\" + PID + \".log\" + '\\0\" */\n\tlog_name = malloc(log_name_len);\n\tif (!log_name) {\n\t\tlog_message(LOG_INFO, \"Unable to malloc log file name\");\n\t\tlog_op = stderr;\n\t\treturn;\n\t}\n\n\tsnprintf(log_name, log_name_len, \"/tmp/%s_mem.%d.log\", prog_name, getpid());\n\tlog_op = fopen_safe(log_name, \"a\");\n\tif (log_op == NULL) {\n\t\tlog_message(LOG_INFO, \"Unable to open %s for appending\", log_name);\n\t\tlog_op = stderr;\n\t}\n\telse {\n\t\tint fd = fileno(log_op);\n\n\t\t/* We don't want any children to inherit the log file */\n\t\tfcntl(fd, F_SETFD, fcntl(fd, F_GETFD) | FD_CLOEXEC);\n\n\t\t/* Make the log output line buffered. This was to ensure that\n\t\t * children didn't inherit the buffer, but the CLOEXEC above\n\t\t * should resolve that. */\n\t\tsetlinebuf(log_op);\n\n\t\tfprintf(log_op, \"\\n\");\n\t}\n\n\tfree(log_name);\n\n\tterminate_banner = banner;\n}", "target": 1, "idx": 9971}
{"commit_id": "f7399b62d7fbc596f1b2871578c1d2053bedf1dd", "project": "strukturag/libheif", "func": "Error HeifContext::get_id_of_non_virtual_child_image(heif_item_id id, heif_item_id& out) const\n{\n  std::string image_type = m_heif_file->get_item_type(id);\n  if (image_type==\"grid\" ||\n      image_type==\"iden\" ||\n      image_type==\"iovl\") {\n    auto iref_box = m_heif_file->get_iref_box();\n    if (!iref_box) {\n      return Error(heif_error_Invalid_input,\n                   heif_suberror_No_item_data,\n                   \"Derived image does not reference any other image items\");\n    }\n\n    std::vector<heif_item_id> image_references = iref_box->get_references(id, fourcc(\"dimg\"));\n\n    // TODO: check whether this really can be recursive (e.g. overlay of grid images)\n\n    if (image_references.empty()) {\n      return Error(heif_error_Invalid_input,\n                   heif_suberror_No_item_data,\n                   \"Derived image does not reference any other image items\");\n    }\n    else {\n      return get_id_of_non_virtual_child_image(image_references[0], out);\n    }\n  }\n  else {\n    out = id;\n    return Error::Ok;\n  }\n}", "target": 2, "idx": 9972}
{"commit_id": "232282fd8f9c21eefe8d2d2b96cdbbb172fe7b7c", "project": "libtiff", "func": "static int\nwriteImageSections(TIFF *in, TIFF *out, struct image_data *image,\n\t\t   struct pagedef *page, struct pageseg *sections,\n\t\t   struct dump_opts * dump, unsigned char *src_buff,\n                   unsigned char **sect_buff_ptr)\n  {\n  double  hres, vres;\n  uint32_t  i, k, width, length, sectsize;\n  unsigned char *sect_buff = *sect_buff_ptr;\n\n  hres = page->hres;\n  vres = page->vres;\n\n  k = page->cols * page->rows;\n  if ((k < 1) || (k > MAX_SECTIONS))\n   {\n   TIFFError(\"writeImageSections\",\n\t     \"%\"PRIu32\" Rows and Columns exceed maximum sections\\nIncrease resolution or reduce sections\", k);\n   return (-1);\n   }\n\n  for (i = 0; i < k; i++)\n    {\n    width  = sections[i].x2 - sections[i].x1 + 1;\n    length = sections[i].y2 - sections[i].y1 + 1;\n    sectsize = (uint32_t)\n\t    ceil((width * image->bps * image->spp + 7) / (double)8) * length;\n    /* allocate a buffer if we don't have one already */\n    if (createImageSection(sectsize, sect_buff_ptr))\n      {\n      TIFFError(\"writeImageSections\", \"Unable to allocate section buffer\");\n      exit(EXIT_FAILURE);\n      }\n    sect_buff = *sect_buff_ptr;\n\n    if (extractImageSection (image, &sections[i], src_buff, sect_buff))\n      {\n      TIFFError(\"writeImageSections\", \"Unable to extract image sections\");\n      exit(EXIT_FAILURE);\n      }\n\n  /* call the write routine here instead of outside the loop */\n    if (writeSingleSection(in, out, image, dump, width, length, hres, vres, sect_buff))\n      {\n      TIFFError(\"writeImageSections\", \"Unable to write image section\");\n      exit(EXIT_FAILURE);\n      }\n    }\n\n  return (0);\n  }", "target": 2, "idx": 9973}
{"commit_id": "aacae2065744adb05e858d327198c7bbe7f452b0", "project": "opencv", "func": "bool  Jpeg2KDecoder::readData( Mat& img )\n{\n    bool result = false;\n    int color = img.channels() > 1;\n    uchar* data = img.ptr();\n    size_t step = img.step;\n    jas_stream_t* stream = (jas_stream_t*)m_stream;\n    jas_image_t* image = (jas_image_t*)m_image;\n\n#ifndef _WIN32\n    // At least on some Linux instances the\n    // system libjasper segfaults when\n    // converting color to grey.\n    // We do this conversion manually at the end.\n    Mat clr;\n    if (CV_MAT_CN(img.type()) < CV_MAT_CN(this->type()))\n    {\n        clr.create(img.size().height, img.size().width, this->type());\n        color = true;\n        data = clr.ptr();\n        step = (int)clr.step;\n    }\n#endif\n\n    if( stream && image )\n    {\n        bool convert;\n        int colorspace;\n        if( color )\n        {\n            convert = (jas_image_clrspc( image ) != JAS_CLRSPC_SRGB);\n            colorspace = JAS_CLRSPC_SRGB;\n        }\n        else\n        {\n            convert = (jas_clrspc_fam( jas_image_clrspc( image ) ) != JAS_CLRSPC_FAM_GRAY);\n            colorspace = JAS_CLRSPC_SGRAY; // TODO GENGRAY or SGRAY? (GENGRAY fails on Win.)\n        }\n\n        // convert to the desired colorspace\n        if( convert )\n        {\n            jas_cmprof_t *clrprof = jas_cmprof_createfromclrspc( colorspace );\n            if( clrprof )\n            {\n                jas_image_t *_img = jas_image_chclrspc( image, clrprof, JAS_CMXFORM_INTENT_RELCLR );\n                if( _img )\n                {\n                    jas_image_destroy( image );\n                    m_image = image = _img;\n                    result = true;\n                }\n                else\n                    fprintf(stderr, \"JPEG 2000 LOADER ERROR: cannot convert colorspace\\n\");\n                jas_cmprof_destroy( clrprof );\n            }\n            else\n                fprintf(stderr, \"JPEG 2000 LOADER ERROR: unable to create colorspace\\n\");\n        }\n        else\n            result = true;\n\n        if( result )\n        {\n            int ncmpts;\n            int cmptlut[3];\n            if( color )\n            {\n                cmptlut[0] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_RGB_B );\n                cmptlut[1] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_RGB_G );\n                cmptlut[2] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_RGB_R );\n                if( cmptlut[0] < 0 || cmptlut[1] < 0 || cmptlut[2] < 0 )\n                    result = false;\n                ncmpts = 3;\n            }\n            else\n            {\n                cmptlut[0] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_GRAY_Y );\n                if( cmptlut[0] < 0 )\n                    result = false;\n                ncmpts = 1;\n            }\n\n            if( result )\n            {\n                for( int i = 0; i < ncmpts; i++ )\n                {\n                    int maxval = 1 << jas_image_cmptprec( image, cmptlut[i] );\n                    int offset =  jas_image_cmptsgnd( image, cmptlut[i] ) ? maxval / 2 : 0;\n\n                    int yend = jas_image_cmptbry( image, cmptlut[i] );\n                    int ystep = jas_image_cmptvstep( image, cmptlut[i] );\n                    int xend = jas_image_cmptbrx( image, cmptlut[i] );\n                    int xstep = jas_image_cmpthstep( image, cmptlut[i] );\n\n                    jas_matrix_t *buffer = jas_matrix_create( yend / ystep, xend / xstep );\n                    if( buffer )\n                    {\n                        if( !jas_image_readcmpt( image, cmptlut[i], 0, 0, xend / xstep, yend / ystep, buffer ))\n                        {\n                            if( img.depth() == CV_8U )\n                                result = readComponent8u( data + i, buffer, validateToInt(step), cmptlut[i], maxval, offset, ncmpts );\n                            else\n                                result = readComponent16u( ((unsigned short *)data) + i, buffer, validateToInt(step / 2), cmptlut[i], maxval, offset, ncmpts );\n                            if( !result )\n                            {\n                                i = ncmpts;\n                                result = false;\n                            }\n                        }\n                        jas_matrix_destroy( buffer );\n                    }\n                }\n            }\n        }\n        else\n            fprintf(stderr, \"JPEG2000 LOADER ERROR: colorspace conversion failed\\n\" );\n    }\n\n    close();\n\n#ifndef _WIN32\n    if (!clr.empty())\n    {\n        cv::cvtColor(clr, img, COLOR_BGR2GRAY);\n    }\n#endif\n\n    return result;\n}", "target": 1, "idx": 9974}
{"commit_id": "66d42ed8b25b64eb63111a2b8582c5afc8bf1105", "project": "torvalds/linux", "func": "static void ppp_cp_parse_cr(struct net_device *dev, u16 pid, u8 id,\n\t\t\t    unsigned int req_len, const u8 *data)\n{\n\tstatic u8 const valid_accm[6] = { LCP_OPTION_ACCM, 6, 0, 0, 0, 0 };\n\tconst u8 *opt;\n\tu8 *out;\n\tunsigned int len = req_len, nak_len = 0, rej_len = 0;\n\n\tif (!(out = kmalloc(len, GFP_ATOMIC))) {\n\t\tdev->stats.rx_dropped++;\n\t\treturn;\t/* out of memory, ignore CR packet */\n\t}\n\n\tfor (opt = data; len; len -= opt[1], opt += opt[1]) {\n\t\tif (len < 2 || opt[1] < 2 || len < opt[1])\n\t\t\tgoto err_out;\n\n\t\tif (pid == PID_LCP)\n\t\t\tswitch (opt[0]) {\n\t\t\tcase LCP_OPTION_MRU:\n\t\t\t\tcontinue; /* MRU always OK and > 1500 bytes? */\n\n\t\t\tcase LCP_OPTION_ACCM: /* async control character map */\n\t\t\t\tif (opt[1] < sizeof(valid_accm))\n\t\t\t\t\tgoto err_out;\n\t\t\t\tif (!memcmp(opt, valid_accm,\n\t\t\t\t\t    sizeof(valid_accm)))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (!rej_len) { /* NAK it */\n\t\t\t\t\tmemcpy(out + nak_len, valid_accm,\n\t\t\t\t\t       sizeof(valid_accm));\n\t\t\t\t\tnak_len += sizeof(valid_accm);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase LCP_OPTION_MAGIC:\n\t\t\t\tif (len < 6)\n\t\t\t\t\tgoto err_out;\n\t\t\t\tif (opt[1] != 6 || (!opt[2] && !opt[3] &&\n\t\t\t\t\t\t    !opt[4] && !opt[5]))\n\t\t\t\t\tbreak; /* reject invalid magic number */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t/* reject this option */\n\t\tmemcpy(out + rej_len, opt, opt[1]);\n\t\trej_len += opt[1];\n\t}\n\n\tif (rej_len)\n\t\tppp_cp_event(dev, pid, RCR_BAD, CP_CONF_REJ, id, rej_len, out);\n\telse if (nak_len)\n\t\tppp_cp_event(dev, pid, RCR_BAD, CP_CONF_NAK, id, nak_len, out);\n\telse\n\t\tppp_cp_event(dev, pid, RCR_GOOD, CP_CONF_ACK, id, req_len, data);\n\n\tkfree(out);\n\treturn;\n\nerr_out:\n\tdev->stats.rx_errors++;\n\tkfree(out);\n}", "target": 2, "idx": 9975}
{"commit_id": "1dcd10aceabbc03bf571ea32b892c522cbe923de", "project": "the-tcpdump-group/tcpdump", "func": "int\nethertype_print(netdissect_options *ndo,\n                u_short ether_type, const u_char *p,\n                u_int length, u_int caplen,\n                const struct lladdr_info *src, const struct lladdr_info *dst)\n{\n\tswitch (ether_type) {\n\n\tcase ETHERTYPE_IP:\n\t        ip_print(ndo, p, length);\n\t\treturn (1);\n\n\tcase ETHERTYPE_IPV6:\n\t\tip6_print(ndo, p, length);\n\t\treturn (1);\n\n\tcase ETHERTYPE_ARP:\n\tcase ETHERTYPE_REVARP:\n\t        arp_print(ndo, p, length, caplen);\n\t\treturn (1);\n\n\tcase ETHERTYPE_DN:\n\t\tdecnet_print(ndo, p, length, caplen);\n\t\treturn (1);\n\n\tcase ETHERTYPE_ATALK:\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo, \"et1 \"));\n\t\tatalk_print(ndo, p, length);\n\t\treturn (1);\n\n\tcase ETHERTYPE_AARP:\n\t\taarp_print(ndo, p, length);\n\t\treturn (1);\n\n\tcase ETHERTYPE_IPX:\n\t\tND_PRINT((ndo, \"(NOV-ETHII) \"));\n\t\tipx_print(ndo, p, length);\n\t\treturn (1);\n\n\tcase ETHERTYPE_ISO:\n\t\tif (length == 0 || caplen == 0) {\n\t\t\tND_PRINT((ndo, \" [|osi]\"));\n\t\t\treturn (1);\n\t\t}\n\t\tisoclns_print(ndo, p + 1, length - 1);\n\t\treturn(1);\n\n\tcase ETHERTYPE_PPPOED:\n\tcase ETHERTYPE_PPPOES:\n\tcase ETHERTYPE_PPPOED2:\n\tcase ETHERTYPE_PPPOES2:\n\t\tpppoe_print(ndo, p, length);\n\t\treturn (1);\n\n\tcase ETHERTYPE_EAPOL:\n\t        eap_print(ndo, p, length);\n\t\treturn (1);\n\n\tcase ETHERTYPE_RRCP:\n\t        rrcp_print(ndo, p, length, src, dst);\n\t\treturn (1);\n\n\tcase ETHERTYPE_PPP:\n\t\tif (length) {\n\t\t\tND_PRINT((ndo, \": \"));\n\t\t\tppp_print(ndo, p, length);\n\t\t}\n\t\treturn (1);\n\n\tcase ETHERTYPE_MPCP:\n\t        mpcp_print(ndo, p, length);\n\t\treturn (1);\n\n\tcase ETHERTYPE_SLOW:\n\t        slow_print(ndo, p, length);\n\t\treturn (1);\n\n\tcase ETHERTYPE_CFM:\n\tcase ETHERTYPE_CFM_OLD:\n\t\tcfm_print(ndo, p, length);\n\t\treturn (1);\n\n\tcase ETHERTYPE_LLDP:\n\t\tlldp_print(ndo, p, length);\n\t\treturn (1);\n\n        case ETHERTYPE_NSH:\n                nsh_print(ndo, p, length);\n                return (1);\n\n        case ETHERTYPE_LOOPBACK:\n\t\tloopback_print(ndo, p, length);\n                return (1);\n\n\tcase ETHERTYPE_MPLS:\n\tcase ETHERTYPE_MPLS_MULTI:\n\t\tmpls_print(ndo, p, length);\n\t\treturn (1);\n\n\tcase ETHERTYPE_TIPC:\n\t\ttipc_print(ndo, p, length, caplen);\n\t\treturn (1);\n\n\tcase ETHERTYPE_MS_NLB_HB:\n\t\tmsnlb_print(ndo, p);\n\t\treturn (1);\n\n        case ETHERTYPE_GEONET_OLD:\n        case ETHERTYPE_GEONET:\n                geonet_print(ndo, p, length, src);\n                return (1);\n\n        case ETHERTYPE_CALM_FAST:\n                calm_fast_print(ndo, p, length, src);\n                return (1);\n\n\tcase ETHERTYPE_AOE:\n\t\taoe_print(ndo, p, length);\n\t\treturn (1);\n\n\tcase ETHERTYPE_MEDSA:\n\t\tmedsa_print(ndo, p, length, caplen, src, dst);\n\t\treturn (1);\n\n\tcase ETHERTYPE_LAT:\n\tcase ETHERTYPE_SCA:\n\tcase ETHERTYPE_MOPRC:\n\tcase ETHERTYPE_MOPDL:\n\tcase ETHERTYPE_IEEE1905_1:\n\t\t/* default_print for now */\n\tdefault:\n\t\treturn (0);\n\t}\n}", "target": 3, "idx": 9976}
{"commit_id": "7aaf54a1884f71dc363f0b884e57bcb67407a6cd", "project": "xorg/xserver", "func": "int\nProcXChangeFeedbackControl(ClientPtr client)\n{\n    unsigned len;\n    DeviceIntPtr dev;\n    KbdFeedbackPtr k;\n    PtrFeedbackPtr p;\n    IntegerFeedbackPtr i;\n    StringFeedbackPtr s;\n    BellFeedbackPtr b;\n    LedFeedbackPtr l;\n    int rc;\n\n    REQUEST(xChangeFeedbackControlReq);\n    REQUEST_AT_LEAST_SIZE(xChangeFeedbackControlReq);\n\n    len = stuff->length - bytes_to_int32(sizeof(xChangeFeedbackControlReq));\n    rc = dixLookupDevice(&dev, stuff->deviceid, client, DixManageAccess);\n    if (rc != Success)\n        return rc;\n\n    switch (stuff->feedbackid) {\n    case KbdFeedbackClass:\n        if (len != bytes_to_int32(sizeof(xKbdFeedbackCtl)))\n            return BadLength;\n\n        for (k = dev->kbdfeed; k; k = k->next)\n            if (k->ctrl.id == ((xKbdFeedbackCtl *) &stuff[1])->id)\n                return ChangeKbdFeedback(client, dev, stuff->mask, k,\n                                         (xKbdFeedbackCtl *) &stuff[1]);\n        break;\n    case PtrFeedbackClass:\n        if (len != bytes_to_int32(sizeof(xPtrFeedbackCtl)))\n            return BadLength;\n\n        for (p = dev->ptrfeed; p; p = p->next)\n            if (p->ctrl.id == ((xPtrFeedbackCtl *) &stuff[1])->id)\n                return ChangePtrFeedback(client, dev, stuff->mask, p,\n                                         (xPtrFeedbackCtl *) &stuff[1]);\n        break;\n    case StringFeedbackClass:\n    {\n        xStringFeedbackCtl *f;\n\n        REQUEST_AT_LEAST_EXTRA_SIZE(xChangeFeedbackControlReq,\n                                    sizeof(xStringFeedbackCtl));\n        f = ((xStringFeedbackCtl *) &stuff[1]);\n        if (client->swapped) {\n            if (len < bytes_to_int32(sizeof(xStringFeedbackCtl)))\n                return BadLength;\n            swaps(&f->num_keysyms);\n        }\n        if (len !=\n            (bytes_to_int32(sizeof(xStringFeedbackCtl)) + f->num_keysyms))\n            return BadLength;\n\n        for (s = dev->stringfeed; s; s = s->next)\n            if (s->ctrl.id == ((xStringFeedbackCtl *) &stuff[1])->id)\n                return ChangeStringFeedback(client, dev, stuff->mask, s,\n                                            (xStringFeedbackCtl *) &stuff[1]);\n        break;\n    }\n    case IntegerFeedbackClass:\n        if (len != bytes_to_int32(sizeof(xIntegerFeedbackCtl)))\n            return BadLength;\n\n        for (i = dev->intfeed; i; i = i->next)\n            if (i->ctrl.id == ((xIntegerFeedbackCtl *) &stuff[1])->id)\n                return ChangeIntegerFeedback(client, dev, stuff->mask, i,\n                                             (xIntegerFeedbackCtl *) &\n                                             stuff[1]);\n        break;\n    case LedFeedbackClass:\n        if (len != bytes_to_int32(sizeof(xLedFeedbackCtl)))\n            return BadLength;\n\n        for (l = dev->leds; l; l = l->next)\n            if (l->ctrl.id == ((xLedFeedbackCtl *) &stuff[1])->id)\n                return ChangeLedFeedback(client, dev, stuff->mask, l,\n                                         (xLedFeedbackCtl *) &stuff[1]);\n        break;\n    case BellFeedbackClass:\n        if (len != bytes_to_int32(sizeof(xBellFeedbackCtl)))\n            return BadLength;\n\n        for (b = dev->bell; b; b = b->next)\n            if (b->ctrl.id == ((xBellFeedbackCtl *) &stuff[1])->id)\n                return ChangeBellFeedback(client, dev, stuff->mask, b,\n                                          (xBellFeedbackCtl *) &stuff[1]);\n        break;\n    default:\n        break;\n    }\n\n    return BadMatch;\n}", "target": 2, "idx": 9977}
{"commit_id": "6bff06cdb8e9b4e8ed2e789ee9340877759536fd", "project": "gpac", "func": "void BD_CheckSFTimeOffset(GF_BifsDecoder *codec, GF_Node *node, GF_FieldInfo *inf)\n{\n\tif (inf->name && (gf_node_get_tag(node) != TAG_ProtoNode)) {\n\t\tif (!stricmp(inf->name, \"startTime\") || !stricmp(inf->name, \"stopTime\"))\n\t\t\tBD_OffsetSFTime(codec,  (Double *)inf->far_ptr);\n\t} else if (gf_sg_proto_field_is_sftime_offset(node, inf)) {\n\t\tBD_OffsetSFTime(codec,  (Double *)inf->far_ptr);\n\t}\n}", "target": 1, "idx": 9978}
{"commit_id": "0f8cf3b8497dc45c010c44ed9e96518e11e19fc3", "project": "php/php-src", "func": "static inline int add_post_vars(zval *arr, post_var_data_t *vars, zend_bool eof TSRMLS_DC)\n{\n\tuint64_t max_vars = PG(max_input_vars);\n\n\tvars->ptr = vars->str.c;\n\tvars->end = vars->str.c + vars->str.len;\n\twhile (add_post_var(arr, vars, eof TSRMLS_CC)) {\n\t\tif (++vars->cnt > max_vars) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING,\n\t\t\t\t\t\"Input variables exceeded %\" PRIu64 \". \"\n\t\t\t\t\t\"To increase the limit change max_input_vars in php.ini.\",\n\t\t\t\t\tmax_vars);\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\n\tif (!eof && vars->str.c != vars->ptr) {\n\t\tmemmove(vars->str.c, vars->ptr, vars->str.len = vars->end - vars->ptr);\n\t}\n\treturn SUCCESS;\n}", "target": 2, "idx": 9979}
{"commit_id": "099016b7e8d70a6d5dd814e788bba08d33d48426", "project": "json-c", "func": "int array_list_del_idx(struct array_list *arr, size_t idx, size_t count)\n{\n\tsize_t i, stop;\n\n\t/* Avoid overflow in calculation with large indices. */\n\tif (idx > SIZE_T_MAX - count)\n\t\treturn -1;\n\tstop = idx + count;\n\tif (idx >= arr->length || stop > arr->length)\n\t\treturn -1;\n\tfor (i = idx; i < stop; ++i)\n\t{\n\t\tif (arr->array[i])\n\t\t\tarr->free_fn(arr->array[i]);\n\t}\n\tmemmove(arr->array + idx, arr->array + stop, (arr->length - stop) * sizeof(void *));\n\tarr->length -= count;\n\treturn 0;\n}", "target": 2, "idx": 9980}
{"commit_id": "233affe3fcdc851fa82cb058871bddd0046e1c87", "project": "leozide/leocad", "func": "void lcPiecesLibrary::ReleaseBuffers()\n{\n\tlcContext* Context = lcContext::GetGlobalOffscreenContext();\n\n\tContext->MakeCurrent();\n\tContext->DestroyVertexBuffer(mVertexBuffer);\n\tContext->DestroyIndexBuffer(mIndexBuffer);\n\n\tmBuffersDirty = true;\n}", "target": 1, "idx": 9981}
{"commit_id": "cd1da25a87358eb3b5512fd259310e95b19a05ec", "project": "FreeRDP", "func": "static BOOL nsc_stream_initialize(NSC_CONTEXT* context, wStream* s)\n{\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(context->priv);\n\tif (!Stream_CheckAndLogRequiredLengthWLog(context->priv->log, s, 20))\n\t\treturn FALSE;\n\n\tsize_t total = 0;\n\tfor (size_t i = 0; i < 4; i++)\n\t{\n\t\tStream_Read_UINT32(s, context->PlaneByteCount[i]);\n\t\ttotal += context->PlaneByteCount[i];\n\t}\n\n\tStream_Read_UINT8(s, context->ColorLossLevel);         /* ColorLossLevel (1 byte) */\n\tStream_Read_UINT8(s, context->ChromaSubsamplingLevel); /* ChromaSubsamplingLevel (1 byte) */\n\tStream_Seek(s, 2);                                     /* Reserved (2 bytes) */\n\tcontext->Planes = Stream_Pointer(s);\n\tcontext->PlanesSize = total;\n\treturn Stream_CheckAndLogRequiredLengthWLog(context->priv->log, s, total);\n}", "target": 1, "idx": 9982}
{"commit_id": "da5c0f119203ad9728920456a0f52a6d850c01cd", "project": "torvalds/linux", "func": "int nfc_activate_target(struct nfc_dev *dev, u32 target_idx, u32 protocol)\n{\n\tint rc;\n\tstruct nfc_target *target;\n\n\tpr_debug(\"dev_name=%s target_idx=%u protocol=%u\\n\",\n\t\t dev_name(&dev->dev), target_idx, protocol);\n\n\tdevice_lock(&dev->dev);\n\n\tif (dev->shutting_down) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (dev->active_target) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\n\ttarget = nfc_find_target(dev, target_idx);\n\tif (target == NULL) {\n\t\trc = -ENOTCONN;\n\t\tgoto error;\n\t}\n\n\trc = dev->ops->activate_target(dev, target, protocol);\n\tif (!rc) {\n\t\tdev->active_target = target;\n\t\tdev->rf_mode = NFC_RF_INITIATOR;\n\n\t\tif (dev->ops->check_presence && !dev->shutting_down)\n\t\t\tmod_timer(&dev->check_pres_timer, jiffies +\n\t\t\t\t  msecs_to_jiffies(NFC_CHECK_PRES_FREQ_MS));\n\t}\n\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1, "idx": 9983}
{"commit_id": "b0cf030b30a9b63e678fee294321642beb42b724", "project": "wireshark", "func": "static gint dissect_mutable_member(proto_tree *tree , tvbuff_t * tvb, gint offset, guint encoding, guint encoding_version,\n        dissection_info * info, gboolean * is_end, gboolean show) {\n\n    proto_tree * member;\n    guint32 member_id, member_length;\n    mutable_member_mapping * mapping;\n    gint64 key;\n\n    rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n    if ((member_id & PID_LIST_END) == PID_LIST_END){\n    /* If this is the end of the list, don't add a tree.\n    * If we add more logic here in the future, take into account that\n    * offset is incremented by 4 */\n        offset += 0;\n        *is_end = TRUE;\n        return offset;\n    }\n    if (member_length == 0){\n        return offset;\n    }\n    member = proto_tree_add_subtree_format(tree, tvb, offset, member_length, ett_rtps_dissection_tree,\n        NULL, \"ID: %d, Length: %d\", member_id, member_length);\n\n    {\n        if (info->base_type_id > 0) {\n            key = (info->base_type_id + info->base_type_id * member_id);\n            mapping = (mutable_member_mapping *) wmem_map_lookup(mutable_member_mappings, &(key));\n            if (mapping) { /* the library knows how to dissect this */\n                proto_item_append_text(member, \"(base found 0x%016\" PRIx64 \")\", key);\n                dissect_user_defined(tree, tvb, offset, encoding, encoding_version, NULL, mapping->member_type_id,\n                    mapping->member_name, EXTENSIBILITY_INVALID, offset, 0, mapping->member_id, show);\n                proto_item_set_hidden(member);\n                return check_offset_addition(offset, member_length, tree, NULL, tvb);\n            } else\n                proto_item_append_text(member, \"(base not found 0x%016\" PRIx64 \" from 0x%016\" PRIx64 \")\",\n                  key, info->base_type_id);\n        }\n    }\n\n    key = (info->type_id + info->type_id * member_id);\n    mapping = (mutable_member_mapping *) wmem_map_lookup(mutable_member_mappings, &(key));\n    if (mapping) { /* the library knows how to dissect this */\n        proto_item_append_text(member, \"(found 0x%016\" PRIx64 \")\", key);\n        dissect_user_defined(tree, tvb, offset, encoding, encoding_version, NULL, mapping->member_type_id,\n            mapping->member_name, EXTENSIBILITY_INVALID, offset, 0, mapping->member_id, show);\n\n    } else\n        proto_item_append_text(member, \"(not found 0x%016\" PRIx64 \" from 0x%016\" PRIx64 \")\",\n                  key, info->type_id);\n    proto_item_set_hidden(member);\n    return check_offset_addition(offset, member_length, tree, NULL, tvb);\n}", "target": 1, "idx": 9984}
{"commit_id": "f4616202e5578e65746cf7e7ceeba63bee1b094b", "project": "gpac", "func": "static GF_XMTParser *xmt_new_parser(GF_SceneLoader *load)\n{\n\tGF_XMTParser *parser;\n\tif ((load->type==GF_SM_LOAD_XSR) && !load->ctx) return NULL;\n\tGF_SAFEALLOC(parser, GF_XMTParser);\n\tif (!parser) return NULL;\n\n\tparser->nodes = gf_list_new();\n\tparser->descriptors = gf_list_new();\n\tparser->od_links = gf_list_new();\n\tparser->esd_links = gf_list_new();\n\tparser->def_nodes = gf_list_new();\n\tparser->peeked_nodes = gf_list_new();\n\tparser->inserted_routes = gf_list_new();\n\tparser->unresolved_routes = gf_list_new();\n\n\tparser->sax_parser = gf_xml_sax_new(xmt_node_start, xmt_node_end, xmt_text_content, parser);\n\tparser->load = load;\n\tload->loader_priv = parser;\n\tif (load->ctx) load->ctx->is_pixel_metrics = 1;\n\n\treturn parser;\n}", "target": 2, "idx": 9985}
{"commit_id": "f15fb784bbc537917cf59a5de922131fc5c18431", "project": "nginx/njs", "func": "static njs_ret_t\nnjs_string_replace_regexp(njs_vm_t *vm, njs_value_t *args,\n    njs_string_replace_t *r)\n{\n    int                        *captures;\n    u_char                     *p, *start;\n    njs_ret_t                  ret;\n    const u_char               *end;\n    njs_regexp_pattern_t       *pattern;\n    njs_string_replace_part_t  replace;\n\n    pattern = args[1].data.u.regexp->pattern;\n    end = r->part[0].start + r->part[0].size;\n\n    replace = r->part[1];\n\n    do {\n        ret = njs_regexp_match(vm, &pattern->regex[r->type],\n                               r->part[0].start, r->part[0].size,\n                               r->match_data);\n\n        if (ret >= 0) {\n            captures = nxt_regex_captures(r->match_data);\n\n            if (r->substitutions != NULL) {\n                ret = njs_string_replace_substitute(vm, r, captures);\n                if (nxt_slow_path(ret != NXT_OK)) {\n                    return ret;\n                }\n\n                if (!pattern->global) {\n                    return njs_string_replace_regexp_join(vm, r);\n                }\n\n            } else {\n                if (r->part != r->parts.start) {\n                    r->part = nxt_array_add(&r->parts, &njs_array_mem_proto,\n                                            vm->mem_pool);\n                    if (nxt_slow_path(r->part == NULL)) {\n                        return NXT_ERROR;\n                    }\n\n                    r->part = nxt_array_add(&r->parts, &njs_array_mem_proto,\n                                            vm->mem_pool);\n                    if (nxt_slow_path(r->part == NULL)) {\n                        return NXT_ERROR;\n                    }\n\n                    r->part -= 2;\n                }\n\n                if (captures[1] == 0) {\n\n                    /* Empty match. */\n\n                    start = r->part[0].start;\n\n                    if (start < end) {\n                        p = (u_char *) nxt_utf8_next(start, end);\n\n                        r->part[1].start = start;\n                        r->part[1].size = p - start;\n\n                        r->part[2].start = p;\n                        r->part[2].size = end - p;\n\n                    } else {\n                        r->part[1].size = 0;\n                        r->part[2].size = 0;\n\n                        /* To exit the loop. */\n                        r->part[2].start = start + 1;\n                    }\n\n                    if (r->function != NULL) {\n                        return njs_string_replace_regexp_function(vm, args, r,\n                                                                 captures, ret);\n                    }\n\n                    r->part[0] = replace;\n\n                } else {\n                    r->part[2].start = r->part[0].start + captures[1];\n                    r->part[2].size = r->part[0].size - captures[1];\n                    njs_set_invalid(&r->part[2].value);\n\n                    if (r->function != NULL) {\n                        return njs_string_replace_regexp_function(vm, args, r,\n                                                                 captures, ret);\n                    }\n\n                    r->part[0].size = captures[0];\n\n                    r->part[1] = replace;\n                }\n\n                if (!pattern->global) {\n                    return njs_string_replace_regexp_join(vm, r);\n                }\n\n                r->part += 2;\n            }\n\n        } else if (ret == NXT_REGEX_NOMATCH) {\n            break;\n\n        } else {\n            return NXT_ERROR;\n        }\n\n    } while (r->part[0].start <= end);\n\n    if (r->part != r->parts.start) {\n        return njs_string_replace_regexp_join(vm, r);\n    }\n\n    nxt_regex_match_data_free(r->match_data, vm->regex_context);\n\n    nxt_array_destroy(&r->parts, &njs_array_mem_proto, vm->mem_pool);\n\n    njs_string_copy(&vm->retval, &args[0]);\n\n    return NXT_OK;\n}", "target": 3, "idx": 9986}
{"commit_id": "3217f01b0525596c214a66d4154ce20c437c530f", "project": "NVIDIA-Genomics-Research/GenomeWorks", "func": "BatchBlock::BatchBlock(int32_t device_id, size_t avail_mem, int32_t max_sequences_per_poa, int8_t output_mask, bool banded_alignment)\n    : max_sequences_per_poa_(throw_on_negative(max_sequences_per_poa, \"Maximum sequences per POA has to be non-negative\"))\n    , banded_alignment_(banded_alignment)\n    , device_id_(throw_on_negative(device_id, \"Device ID has to be non-negative\"))\n    , output_mask_(output_mask)\n{\n    matrix_sequence_dimension_ = banded_alignment_ ? CUDAPOA_BANDED_MAX_MATRIX_SEQUENCE_DIMENSION : CUDAPOA_MAX_MATRIX_SEQUENCE_DIMENSION;\n    max_graph_dimension_       = banded_alignment_ ? CUDAPOA_MAX_MATRIX_GRAPH_DIMENSION_BANDED : CUDAPOA_MAX_MATRIX_GRAPH_DIMENSION;\n    max_nodes_per_window_      = banded_alignment_ ? CUDAPOA_MAX_NODES_PER_WINDOW_BANDED : CUDAPOA_MAX_NODES_PER_WINDOW;\n\n    // calculate static and dynamic sizes of buffers needed per POA entry.\n    size_t host_size_fixed, device_size_fixed;\n    size_t host_size_per_poa, device_size_per_poa;\n    std::tie(host_size_fixed, device_size_fixed, host_size_per_poa, device_size_per_poa) = calculate_space_per_poa();\n\n    // Using 2x as a buffer.\n    size_t minimum_device_mem = 2 * (device_size_fixed + device_size_per_poa);\n    if (avail_mem < minimum_device_mem)\n    {\n        std::string msg = std::string(\"Require at least \")\n                              .append(std::to_string(minimum_device_mem))\n                              .append(\" bytes of device memory per CUDAPOA batch to process correctly.\");\n        throw std::runtime_error(msg);\n    }\n\n    // Calculate max POAs possible based on heirustics and available memory.\n    // TODO: Remove this fixed partitioing and making the filling up of buffer\n    // fully dynamic.\n    const float fraction_for_metadata = 0.4f;\n    max_poas_                         = (avail_mem * fraction_for_metadata) / device_size_per_poa;\n\n    // Update final sizes for block based on calculated maximum POAs.\n    output_size_ = max_poas_ * static_cast<size_t>(CUDAPOA_MAX_CONSENSUS_SIZE);\n    input_size_  = max_poas_ * max_sequences_per_poa_ * static_cast<size_t>(CUDAPOA_MAX_SEQUENCE_SIZE);\n    total_h_     = max_poas_ * host_size_per_poa + host_size_fixed;\n    total_d_     = avail_mem;\n\n    // Allocate.\n    CGA_CU_CHECK_ERR(cudaSetDevice(device_id_));\n    CGA_CU_CHECK_ERR(cudaHostAlloc((void**)&block_data_h_, total_h_, cudaHostAllocDefault));\n    CGA_CU_CHECK_ERR(cudaMalloc((void**)&block_data_d_, total_d_));\n}", "target": 3, "idx": 9987}
{"commit_id": "b282620b7a8818910c42a29b8f0855a2d13eec14", "project": "radareorg/radare2", "func": "static int parse(RParse *p, const char *data, char *str) {\n\tint i, len = strlen (data);\n\tchar w0[WSZ];\n\tchar w1[WSZ];\n\tchar w2[WSZ];\n\tchar w3[WSZ];\n\tchar w4[WSZ];\n\tchar *buf, *ptr, *optr;\n\n\t// malloc can be slow here :?\n\tif (!(buf = malloc (len + 1))) {\n\t\treturn false;\n\t}\n\tmemcpy (buf, data, len + 1);\n\n\tr_str_trim (buf);\n\tif (*buf) {\n\t\tw0[0] = '\\0';\n\t\tw1[0] = '\\0';\n\t\tw2[0] = '\\0';\n\t\tw3[0] = '\\0';\n\t\tw4[0] = '\\0';\n\t\tptr = strchr (buf, ' ');\n\t\tif (!ptr) {\n\t\t\tptr = strchr (buf, '\\t');\n\t\t}\n\t\tif (ptr) {\n\t\t\t*ptr = '\\0';\n\t\t\tfor (++ptr; *ptr == ' '; ptr++) {\n\t\t\t\t//nothing to see here\n\t\t\t}\n\t\t\tstrncpy (w0, buf, WSZ - 1);\n\t\t\tstrncpy (w1, ptr, WSZ - 1);\n\n\t\t\toptr = ptr;\n\t\t\tptr = strchr (ptr, ',');\n\t\t\tif (ptr) {\n\t\t\t\t*ptr = '\\0';\n\t\t\t\tfor (++ptr; *ptr == ' '; ptr++) {\n\t\t\t\t\t//nothing to see here\n\t\t\t\t}\n\t\t\t\tstrncpy (w1, optr, WSZ - 1);\n\t\t\t\tstrncpy (w2, ptr, WSZ - 1);\n\t\t\t\toptr = ptr;\n\t\t\t\tptr = strchr (ptr, ',');\n\t\t\t\tif (ptr) {\n\t\t\t\t\t*ptr = '\\0';\n\t\t\t\t\tfor (++ptr; *ptr == ' '; ptr++) {\n\t\t\t\t\t\t//nothing to see here\n\t\t\t\t\t}\n\t\t\t\t\tstrncpy (w2, optr, WSZ - 1);\n\t\t\t\t\tstrncpy (w3, ptr, WSZ - 1);\n\t\t\t\t\toptr = ptr;\n\t\t\t\t\t// bonus\n\t\t\t\t\tptr = strchr (ptr, ',');\n\t\t\t\t\tif (ptr) {\n\t\t\t\t\t\t*ptr = '\\0';\n\t\t\t\t\t\tfor (++ptr; *ptr == ' '; ptr++) {\n\t\t\t\t\t\t\t//nothing to see here\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstrncpy (w3, optr, WSZ - 1);\n\t\t\t\t\t\tstrncpy (w4, ptr, WSZ - 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tstrncpy (w0, buf, WSZ - 1);\n\t\t}\n\t\t{\n\t\t\tconst char *wa[] = { w0, w1, w2, w3, w4 };\n\t\t\tint nw = 0;\n\t\t\tfor (i = 0; i < 5; i++) {\n\t\t\t\tif (wa[i][0] != '\\0') {\n\t\t\t\t\tnw++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t(void)replace (nw, wa, str);\n\t\t}\n\t}\n\tfree (buf);\n\treturn true;\n}", "target": 2, "idx": 9988}
{"commit_id": "ed19bc806809ad10c4ddce515d375581b86ede85", "project": "ArtifexSoftware/mupdf", "func": "static void\nfz_append_display_node(\n\tfz_context *ctx,\n\tfz_device *dev,\n\tfz_display_command cmd,\n\tint flags,\n\tconst fz_rect *rect,\n\tconst fz_path *path,\n\tconst float *color,\n\tfz_colorspace *colorspace,\n\tconst float *alpha,\n\tconst fz_matrix *ctm,\n\tconst fz_stroke_state *stroke,\n\tconst void *private_data,\n\tint private_data_len)\n{\n\tfz_display_node node = { 0 };\n\tfz_display_node *node_ptr;\n\tfz_list_device *writer = (fz_list_device *)dev;\n\tfz_display_list *list = writer->list;\n\tint size;\n\tint rect_off = 0;\n\tint path_off = 0;\n\tint color_off = 0;\n\tint colorspace_off = 0;\n\tint alpha_off = 0;\n\tint ctm_off = 0;\n\tint stroke_off = 0;\n\tint rect_for_updates = 0;\n\tint private_off = 0;\n\tfz_path *my_path = NULL;\n\tfz_stroke_state *my_stroke = NULL;\n\tfz_rect local_rect;\n\tint path_size = 0;\n\n\tswitch (cmd)\n\t{\n\tcase FZ_CMD_CLIP_PATH:\n\tcase FZ_CMD_CLIP_STROKE_PATH:\n\tcase FZ_CMD_CLIP_TEXT:\n\tcase FZ_CMD_CLIP_STROKE_TEXT:\n\tcase FZ_CMD_CLIP_IMAGE_MASK:\n\t\tif (writer->top < STACK_SIZE)\n\t\t{\n\t\t\trect_for_updates = 1;\n\t\t\twriter->stack[writer->top].rect = fz_empty_rect;\n\t\t}\n\t\twriter->top++;\n\t\tbreak;\n\tcase FZ_CMD_END_MASK:\n\t\tif (writer->top < STACK_SIZE)\n\t\t{\n\t\t\twriter->stack[writer->top].update = NULL;\n\t\t\twriter->stack[writer->top].rect = fz_empty_rect;\n\t\t}\n\t\twriter->top++;\n\t\tbreak;\n\tcase FZ_CMD_BEGIN_TILE:\n\t\twriter->tiled++;\n\t\tif (writer->top > 0 && writer->top <= STACK_SIZE)\n\t\t{\n\t\t\twriter->stack[writer->top-1].rect = fz_infinite_rect;\n\t\t}\n\t\tbreak;\n\tcase FZ_CMD_END_TILE:\n\t\twriter->tiled--;\n\t\tbreak;\n\tcase FZ_CMD_END_GROUP:\n\t\tbreak;\n\tcase FZ_CMD_POP_CLIP:\n\t\tif (writer->top > STACK_SIZE)\n\t\t{\n\t\t\twriter->top--;\n\t\t\trect = &fz_infinite_rect;\n\t\t}\n\t\telse if (writer->top > 0)\n\t\t{\n\t\t\tfz_rect *update;\n\t\t\twriter->top--;\n\t\t\tupdate = writer->stack[writer->top].update;\n\t\t\tif (writer->tiled == 0)\n\t\t\t{\n\t\t\t\tif (update)\n\t\t\t\t{\n\t\t\t\t\t*update = fz_intersect_rect(*update, writer->stack[writer->top].rect);\n\t\t\t\t\tlocal_rect = *update;\n\t\t\t\t\trect = &local_rect;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\trect = &writer->stack[writer->top].rect;\n\t\t\t}\n\t\t\telse\n\t\t\t\trect = &fz_infinite_rect;\n\t\t}\n\t\t/* fallthrough */\n\tdefault:\n\t\tif (writer->top > 0 && writer->tiled == 0 && writer->top <= STACK_SIZE && rect)\n\t\t\twriter->stack[writer->top-1].rect = fz_union_rect(writer->stack[writer->top-1].rect, *rect);\n\t\tbreak;\n\t}\n\n\tsize = 1; /* 1 for the fz_display_node */\n\tnode.cmd = cmd;\n\n\t/* Figure out what we need to write, and the offsets at which we will\n\t * write it. */\n\tif (rect_for_updates || (rect != NULL && (writer->rect.x0 != rect->x0 || writer->rect.y0 != rect->y0 || writer->rect.x1 != rect->x1 || writer->rect.y1 != rect->y1)))\n\t{\n\t\tnode.rect = 1;\n\t\trect_off = size;\n\t\tsize += SIZE_IN_NODES(sizeof(fz_rect));\n\t}\n\tif (color || colorspace)\n\t{\n\t\tif (colorspace != writer->colorspace)\n\t\t{\n\t\t\tassert(color);\n\t\t\tif (colorspace == fz_device_gray(ctx))\n\t\t\t{\n\t\t\t\tif (color[0] == 0.0f)\n\t\t\t\t\tnode.cs = CS_GRAY_0, color = NULL;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnode.cs = CS_GRAY_1;\n\t\t\t\t\tif (color[0] == 1.0f)\n\t\t\t\t\t\tcolor = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (colorspace == fz_device_rgb(ctx))\n\t\t\t{\n\t\t\t\tif (color[0] == 0.0f && color[1] == 0.0f && color[2] == 0.0f)\n\t\t\t\t\tnode.cs = CS_RGB_0, color = NULL;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnode.cs = CS_RGB_1;\n\t\t\t\t\tif (color[0] == 1.0f && color[1] == 1.0f && color[2] == 1.0f)\n\t\t\t\t\t\tcolor = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (colorspace == fz_device_cmyk(ctx))\n\t\t\t{\n\t\t\t\tnode.cs = CS_CMYK_0;\n\t\t\t\tif (color[0] == 0.0f && color[1] == 0.0f && color[2] == 0.0f)\n\t\t\t\t{\n\t\t\t\t\tif (color[3] == 0.0f)\n\t\t\t\t\t\tcolor = NULL;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tnode.cs = CS_CMYK_1;\n\t\t\t\t\t\tif (color[3] == 1.0f)\n\t\t\t\t\t\t\tcolor = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint i;\n\t\t\t\tint n = fz_colorspace_n(ctx, colorspace);\n\n\t\t\t\tcolorspace_off = size;\n\t\t\t\tsize += SIZE_IN_NODES(sizeof(fz_colorspace *));\n\t\t\t\tnode.cs = CS_OTHER_0;\n\t\t\t\tfor (i = 0; i < n; i++)\n\t\t\t\t\tif (color[i] != 0.0f)\n\t\t\t\t\t\tbreak;\n\t\t\t\tif (i == n)\n\t\t\t\t\tcolor = NULL;\n\t\t\t\tmemset(writer->color, 0, sizeof(float)*n);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Colorspace is unchanged, but color may have changed\n\t\t\t * to something best coded as a colorspace change */\n\t\t\tif (colorspace == fz_device_gray(ctx))\n\t\t\t{\n\t\t\t\tif (writer->color[0] != color[0])\n\t\t\t\t{\n\t\t\t\t\tif (color[0] == 0.0f)\n\t\t\t\t\t{\n\t\t\t\t\t\tnode.cs = CS_GRAY_0;\n\t\t\t\t\t\tcolor = NULL;\n\t\t\t\t\t}\n\t\t\t\t\telse if (color[0] == 1.0f)\n\t\t\t\t\t{\n\t\t\t\t\t\tnode.cs = CS_GRAY_1;\n\t\t\t\t\t\tcolor = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (colorspace == fz_device_rgb(ctx))\n\t\t\t{\n\t\t\t\tif (writer->color[0] != color[0] || writer->color[1] != color[1] || writer->color[2] != color[2])\n\t\t\t\t{\n\t\t\t\t\tif (color[0] == 0.0f && color[1] == 0.0f && color[2] == 0.0f)\n\t\t\t\t\t{\n\t\t\t\t\t\tnode.cs = CS_RGB_0;\n\t\t\t\t\t\tcolor = NULL;\n\t\t\t\t\t}\n\t\t\t\t\telse if (color[0] == 1.0f && color[1] == 1.0f && color[2] == 1.0f)\n\t\t\t\t\t{\n\t\t\t\t\t\tnode.cs = CS_RGB_1;\n\t\t\t\t\t\tcolor = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (colorspace == fz_device_cmyk(ctx))\n\t\t\t{\n\t\t\t\tif (writer->color[0] != color[0] || writer->color[1] != color[1] || writer->color[2] != color[2] || writer->color[3] != color[3])\n\t\t\t\t{\n\t\t\t\t\tif (color[0] == 0.0f && color[1] == 0.0f && color[2] == 0.0f)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (color[3] == 0.0f)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnode.cs = CS_CMYK_0;\n\t\t\t\t\t\t\tcolor = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (color[3] == 1.0f)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnode.cs = CS_CMYK_1;\n\t\t\t\t\t\t\tcolor = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint i;\n\t\t\t\tint n = fz_colorspace_n(ctx, colorspace);\n\t\t\t\tfor (i=0; i < n; i++)\n\t\t\t\t\tif (color[i] != 0.0f)\n\t\t\t\t\t\tbreak;\n\t\t\t\tif (i == n)\n\t\t\t\t{\n\t\t\t\t\tnode.cs = CS_OTHER_0;\n\t\t\t\t\tcolorspace_off = size;\n\t\t\t\t\tsize += SIZE_IN_NODES(sizeof(fz_colorspace *));\n\t\t\t\t\tcolor = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (color)\n\t{\n\t\tint i, n;\n\t\tconst float *wc = &writer->color[0];\n\n\t\tassert(colorspace != NULL);\n\t\tn = fz_colorspace_n(ctx, colorspace);\n\t\ti = 0;\n\t\t/* Only check colors if the colorspace is unchanged. If the\n\t\t * colorspace *has* changed and the colors are implicit then\n\t\t * this will have been caught above. */\n\t\tif (colorspace == writer->colorspace)\n\t\t\tfor (; i < n; i++)\n\t\t\t\tif (color[i] != wc[i])\n\t\t\t\t\tbreak;\n\n\t\tif (i != n)\n\t\t{\n\t\t\tnode.color = 1;\n\t\t\tcolor_off = size;\n\t\t\tsize += n * SIZE_IN_NODES(sizeof(float));\n\t\t}\n\t}\n\tif (alpha && (*alpha != writer->alpha))\n\t{\n\t\tif (*alpha >= 1.0f)\n\t\t\tnode.alpha = ALPHA_1;\n\t\telse if (*alpha <= 0.0f)\n\t\t\tnode.alpha = ALPHA_0;\n\t\telse\n\t\t{\n\t\t\talpha_off = size;\n\t\t\tsize += SIZE_IN_NODES(sizeof(float));\n\t\t\tnode.alpha = ALPHA_PRESENT;\n\t\t}\n\t}\n\tif (ctm && (ctm->a != writer->ctm.a || ctm->b != writer->ctm.b || ctm->c != writer->ctm.c || ctm->d != writer->ctm.d || ctm->e != writer->ctm.e || ctm->f != writer->ctm.f))\n\t{\n\t\tint ctm_flags;\n\n\t\tctm_off = size;\n\t\tctm_flags = CTM_UNCHANGED;\n\t\tif (ctm->a != writer->ctm.a || ctm->d != writer->ctm.d)\n\t\t\tctm_flags = CTM_CHANGE_AD, size += SIZE_IN_NODES(2*sizeof(float));\n\t\tif (ctm->b != writer->ctm.b || ctm->c != writer->ctm.c)\n\t\t\tctm_flags |= CTM_CHANGE_BC, size += SIZE_IN_NODES(2*sizeof(float));\n\t\tif (ctm->e != writer->ctm.e || ctm->f != writer->ctm.f)\n\t\t\tctm_flags |= CTM_CHANGE_EF, size += SIZE_IN_NODES(2*sizeof(float));\n\t\tnode.ctm = ctm_flags;\n\t}\n\tif (stroke && (writer->stroke == NULL || stroke != writer->stroke))\n\t{\n\t\tstroke_off = size;\n\t\tsize += SIZE_IN_NODES(sizeof(fz_stroke_state *));\n\t\tnode.stroke = 1;\n\t}\n\tif (path && (writer->path == NULL || path != writer->path))\n\t{\n\t\tint max = SIZE_IN_NODES(MAX_NODE_SIZE) - size - SIZE_IN_NODES(private_data_len);\n\t\tpath_size = SIZE_IN_NODES(fz_pack_path(ctx, NULL, max, path));\n\t\tnode.path = 1;\n\t\tpath_off = size;\n\n\t\tsize += path_size;\n\t}\n\tif (private_data != NULL)\n\t{\n\t\tprivate_off = size;\n\t\tsize += SIZE_IN_NODES(private_data_len);\n\t}\n\n\twhile (list->len + size > list->max)\n\t{\n\t\tint newsize = list->max * 2;\n\t\tfz_display_node *old = list->list;\n\t\tptrdiff_t diff;\n\t\tint i, n;\n\n\t\tif (newsize < 256)\n\t\t\tnewsize = 256;\n\t\tlist->list = fz_realloc_array(ctx, list->list, newsize, fz_display_node);\n\t\tlist->max = newsize;\n\t\tdiff = (char *)(list->list) - (char *)old;\n\t\tn = (writer->top < STACK_SIZE ? writer->top : STACK_SIZE);\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tif (writer->stack[i].update != NULL)\n\t\t\t\twriter->stack[i].update = (fz_rect *)(((char *)writer->stack[i].update) + diff);\n\t\t}\n\t\tif (writer->path)\n\t\t\twriter->path = (fz_path *)(((char *)writer->path) + diff);\n\t}\n\n\t/* Write the node to the list */\n\tnode.size = size;\n\tnode.flags = flags;\n\tassert(size < (1<<9));\n\tnode_ptr = &list->list[list->len];\n\t*node_ptr = node;\n\n\t/* Path is the most frequent one, so try to avoid the try/catch in\n\t * this case */\n\tif (path_off)\n\t{\n\t\tmy_path = (void *)(&node_ptr[path_off]);\n\t\t(void)fz_pack_path(ctx, (void *)my_path, path_size * sizeof(fz_display_node), path);\n\t}\n\n\tif (stroke_off)\n\t{\n\t\tfz_try(ctx)\n\t\t{\n\t\t\tmy_stroke = fz_keep_stroke_state(ctx, stroke);\n\t\t}\n\t\tfz_catch(ctx)\n\t\t{\n\t\t\tfz_drop_path(ctx, my_path);\n\t\t\tfz_rethrow(ctx);\n\t\t}\n\t}\n\n\tif (rect_off)\n\t{\n\t\tfz_rect *out_rect = (fz_rect *)(void *)(&node_ptr[rect_off]);\n\t\twriter->rect = *rect;\n\t\t*out_rect = *rect;\n\t\tif (rect_for_updates)\n\t\t\twriter->stack[writer->top-1].update = out_rect;\n\t}\n\tif (path_off)\n\t{\n\t\tfz_drop_path(ctx, writer->path);\n\t\twriter->path = fz_keep_path(ctx, my_path); /* Can never fail */\n\t}\n\tif (node.cs)\n\t{\n\t\tfz_drop_colorspace(ctx, writer->colorspace);\n\t\tswitch(node.cs)\n\t\t{\n\t\tcase CS_GRAY_0:\n\t\t\twriter->colorspace = fz_keep_colorspace(ctx, fz_device_gray(ctx));\n\t\t\twriter->color[0] = 0;\n\t\t\tbreak;\n\t\tcase CS_GRAY_1:\n\t\t\twriter->colorspace = fz_keep_colorspace(ctx, fz_device_gray(ctx));\n\t\t\twriter->color[0] = 1;\n\t\t\tbreak;\n\t\tcase CS_RGB_0:\n\t\t\twriter->color[0] = 0;\n\t\t\twriter->color[1] = 0;\n\t\t\twriter->color[2] = 0;\n\t\t\twriter->colorspace = fz_keep_colorspace(ctx, fz_device_rgb(ctx));\n\t\t\tbreak;\n\t\tcase CS_RGB_1:\n\t\t\twriter->color[0] = 1;\n\t\t\twriter->color[1] = 1;\n\t\t\twriter->color[2] = 1;\n\t\t\twriter->colorspace = fz_keep_colorspace(ctx, fz_device_rgb(ctx));\n\t\t\tbreak;\n\t\tcase CS_CMYK_0:\n\t\t\twriter->color[0] = 0;\n\t\t\twriter->color[1] = 0;\n\t\t\twriter->color[2] = 0;\n\t\t\twriter->color[3] = 0;\n\t\t\twriter->colorspace = fz_keep_colorspace(ctx, fz_device_cmyk(ctx));\n\t\t\tbreak;\n\t\tcase CS_CMYK_1:\n\t\t\twriter->color[0] = 0;\n\t\t\twriter->color[1] = 0;\n\t\t\twriter->color[2] = 0;\n\t\t\twriter->color[3] = 1;\n\t\t\twriter->colorspace = fz_keep_colorspace(ctx, fz_device_cmyk(ctx));\n\t\t\tbreak;\n\t\tdefault:\n\t\t{\n\t\t\tfz_colorspace **out_colorspace = (fz_colorspace **)(void *)(&node_ptr[colorspace_off]);\n\t\t\tint i, n;\n\t\t\tn = fz_colorspace_n(ctx, colorspace);\n\t\t\t*out_colorspace = fz_keep_colorspace(ctx, colorspace);\n\n\t\t\twriter->colorspace = fz_keep_colorspace(ctx, colorspace);\n\t\t\tfor (i = 0; i < n; i++)\n\t\t\t\twriter->color[i] = 0;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t}\n\tif (color_off)\n\t{\n\t\tint n = fz_colorspace_n(ctx, colorspace);\n\t\tfloat *out_color = (float *)(void *)(&node_ptr[color_off]);\n\t\tmemcpy(writer->color, color, n * sizeof(float));\n\t\tmemcpy(out_color, color, n * sizeof(float));\n\t}\n\tif (node.alpha)\n\t{\n\t\twriter->alpha = *alpha;\n\t\tif (alpha_off)\n\t\t{\n\t\t\tfloat *out_alpha = (float *)(void *)(&node_ptr[alpha_off]);\n\t\t\t*out_alpha = *alpha;\n\t\t}\n\t}\n\tif (ctm_off)\n\t{\n\t\tfloat *out_ctm = (float *)(void *)(&node_ptr[ctm_off]);\n\t\tif (node.ctm & CTM_CHANGE_AD)\n\t\t{\n\t\t\twriter->ctm.a = *out_ctm++ = ctm->a;\n\t\t\twriter->ctm.d = *out_ctm++ = ctm->d;\n\t\t}\n\t\tif (node.ctm & CTM_CHANGE_BC)\n\t\t{\n\t\t\twriter->ctm.b = *out_ctm++ = ctm->b;\n\t\t\twriter->ctm.c = *out_ctm++ = ctm->c;\n\t\t}\n\t\tif (node.ctm & CTM_CHANGE_EF)\n\t\t{\n\t\t\twriter->ctm.e = *out_ctm++ = ctm->e;\n\t\t\twriter->ctm.f = *out_ctm = ctm->f;\n\t\t}\n\t}\n\tif (stroke_off)\n\t{\n\t\tfz_stroke_state **out_stroke = (fz_stroke_state **)(void *)(&node_ptr[stroke_off]);\n\t\t*out_stroke = my_stroke;\n\t\tfz_drop_stroke_state(ctx, writer->stroke);\n\t\t/* Can never fail as my_stroke was kept above */\n\t\twriter->stroke = fz_keep_stroke_state(ctx, my_stroke);\n\t}\n\tif (private_off)\n\t{\n\t\tchar *out_private = (char *)(void *)(&node_ptr[private_off]);\n\t\tmemcpy(out_private, private_data, private_data_len);\n\t}\n\tlist->len += size;\n}", "target": 2, "idx": 9989}
{"commit_id": "1ca02cf2879a5e1511a2f2109f0925cf4c892862", "project": "qt/qtbase", "func": "void QPaintEngineEx::stroke(const QVectorPath &path, const QPen &inPen)\n{\n#ifdef QT_DEBUG_DRAW\n    qDebug() << \"QPaintEngineEx::stroke()\" << pen;\n#endif\n\n    Q_D(QPaintEngineEx);\n\n    if (path.isEmpty())\n        return;\n\n    if (!d->strokeHandler) {\n        d->strokeHandler = new StrokeHandler(path.elementCount()+4);\n        d->stroker.setMoveToHook(qpaintengineex_moveTo);\n        d->stroker.setLineToHook(qpaintengineex_lineTo);\n        d->stroker.setCubicToHook(qpaintengineex_cubicTo);\n    }\n\n    QRectF clipRect;\n    QPen pen = inPen;\n    if (pen.style() > Qt::SolidLine) {\n        QRectF cpRect = path.controlPointRect();\n        const QTransform &xf = state()->matrix;\n        if (pen.isCosmetic()) {\n            clipRect = d->exDeviceRect;\n            cpRect.translate(xf.dx(), xf.dy());\n        } else {\n            clipRect = xf.inverted().mapRect(QRectF(d->exDeviceRect));\n        }\n        // Check to avoid generating unwieldy amount of dashes that will not be visible anyway\n        QRectF extentRect = cpRect & clipRect;\n        qreal extent = qMax(extentRect.width(), extentRect.height());\n        qreal patternLength = 0;\n        const QList<qreal> pattern = pen.dashPattern();\n        const int patternSize = qMin(pattern.size(), 32);\n        for (int i = 0; i < patternSize; i++)\n            patternLength += qMax(pattern.at(i), qreal(0));\n        if (pen.widthF())\n            patternLength *= pen.widthF();\n        if (qFuzzyIsNull(patternLength)) {\n            pen.setStyle(Qt::NoPen);\n        } else if (qFuzzyIsNull(extent) || extent / patternLength > 10000) {\n            // approximate stream of tiny dashes with semi-transparent solid line\n            pen.setStyle(Qt::SolidLine);\n            QColor color(pen.color());\n            color.setAlpha(color.alpha() / 2);\n            pen.setColor(color);\n        }\n    }\n\n    if (!qpen_fast_equals(pen, d->strokerPen)) {\n        d->strokerPen = pen;\n        d->stroker.setJoinStyle(pen.joinStyle());\n        d->stroker.setCapStyle(pen.capStyle());\n        d->stroker.setMiterLimit(pen.miterLimit());\n        qreal penWidth = pen.widthF();\n        if (penWidth == 0)\n            d->stroker.setStrokeWidth(1);\n        else\n            d->stroker.setStrokeWidth(penWidth);\n\n        Qt::PenStyle style = pen.style();\n        if (style == Qt::SolidLine) {\n            d->activeStroker = &d->stroker;\n        } else if (style == Qt::NoPen) {\n            d->activeStroker = nullptr;\n        } else {\n            d->dasher.setDashPattern(pen.dashPattern());\n            d->dasher.setDashOffset(pen.dashOffset());\n            d->activeStroker = &d->dasher;\n        }\n    }\n\n    if (!d->activeStroker) {\n        return;\n    }\n\n    if (!clipRect.isNull())\n        d->activeStroker->setClipRect(clipRect);\n\n    if (d->activeStroker == &d->stroker)\n        d->stroker.setForceOpen(path.hasExplicitOpen());\n\n    const QPainterPath::ElementType *types = path.elements();\n    const qreal *points = path.points();\n    int pointCount = path.elementCount();\n\n    const qreal *lastPoint = points + (pointCount<<1);\n\n    d->strokeHandler->types.reset();\n    d->strokeHandler->pts.reset();\n\n    // Some engines might decide to optimize for the non-shape hint later on...\n    uint flags = QVectorPath::WindingFill;\n\n    if (path.elementCount() > 2)\n        flags |= QVectorPath::NonConvexShapeMask;\n\n    if (d->stroker.capStyle() == Qt::RoundCap || d->stroker.joinStyle() == Qt::RoundJoin)\n        flags |= QVectorPath::CurvedShapeMask;\n\n    // ### Perspective Xforms are currently not supported...\n    if (!pen.isCosmetic()) {\n        // We include cosmetic pens in this case to avoid having to\n        // change the current transform. Normal transformed,\n        // non-cosmetic pens will be transformed as part of fill\n        // later, so they are also covered here..\n        d->activeStroker->setCurveThresholdFromTransform(state()->matrix);\n        d->activeStroker->begin(d->strokeHandler);\n        if (types) {\n            while (points < lastPoint) {\n                switch (*types) {\n                case QPainterPath::MoveToElement:\n                    d->activeStroker->moveTo(points[0], points[1]);\n                    points += 2;\n                    ++types;\n                    break;\n                case QPainterPath::LineToElement:\n                    d->activeStroker->lineTo(points[0], points[1]);\n                    points += 2;\n                    ++types;\n                    break;\n                case QPainterPath::CurveToElement:\n                    d->activeStroker->cubicTo(points[0], points[1],\n                                              points[2], points[3],\n                                              points[4], points[5]);\n                    points += 6;\n                    types += 3;\n                    flags |= QVectorPath::CurvedShapeMask;\n                    break;\n                default:\n                    break;\n                }\n            }\n            if (path.hasImplicitClose())\n                d->activeStroker->lineTo(path.points()[0], path.points()[1]);\n\n        } else {\n            d->activeStroker->moveTo(points[0], points[1]);\n            points += 2;\n            while (points < lastPoint) {\n                d->activeStroker->lineTo(points[0], points[1]);\n                points += 2;\n            }\n            if (path.hasImplicitClose())\n                d->activeStroker->lineTo(path.points()[0], path.points()[1]);\n        }\n        d->activeStroker->end();\n\n        if (!d->strokeHandler->types.size()) // an empty path...\n            return;\n\n        QVectorPath strokePath(d->strokeHandler->pts.data(),\n                               d->strokeHandler->types.size(),\n                               d->strokeHandler->types.data(),\n                               flags);\n        fill(strokePath, pen.brush());\n    } else {\n        // For cosmetic pens we need a bit of trickery... We to process xform the input points\n        if (state()->matrix.type() >= QTransform::TxProject) {\n            QPainterPath painterPath = state()->matrix.map(path.convertToPainterPath());\n            d->activeStroker->strokePath(painterPath, d->strokeHandler, QTransform());\n        } else {\n            d->activeStroker->setCurveThresholdFromTransform(QTransform());\n            d->activeStroker->begin(d->strokeHandler);\n            if (types) {\n                while (points < lastPoint) {\n                    switch (*types) {\n                    case QPainterPath::MoveToElement: {\n                        QPointF pt = (*(const QPointF *) points) * state()->matrix;\n                        d->activeStroker->moveTo(pt.x(), pt.y());\n                        points += 2;\n                        ++types;\n                        break;\n                    }\n                    case QPainterPath::LineToElement: {\n                        QPointF pt = (*(const QPointF *) points) * state()->matrix;\n                        d->activeStroker->lineTo(pt.x(), pt.y());\n                        points += 2;\n                        ++types;\n                        break;\n                    }\n                    case QPainterPath::CurveToElement: {\n                        QPointF c1 = ((const QPointF *) points)[0] * state()->matrix;\n                        QPointF c2 = ((const QPointF *) points)[1] * state()->matrix;\n                        QPointF e =  ((const QPointF *) points)[2] * state()->matrix;\n                        d->activeStroker->cubicTo(c1.x(), c1.y(), c2.x(), c2.y(), e.x(), e.y());\n                        points += 6;\n                        types += 3;\n                        flags |= QVectorPath::CurvedShapeMask;\n                        break;\n                    }\n                    default:\n                        break;\n                    }\n                }\n                if (path.hasImplicitClose()) {\n                    QPointF pt = * ((const QPointF *) path.points()) * state()->matrix;\n                    d->activeStroker->lineTo(pt.x(), pt.y());\n                }\n\n            } else {\n                QPointF p = ((const QPointF *)points)[0] * state()->matrix;\n                d->activeStroker->moveTo(p.x(), p.y());\n                points += 2;\n                while (points < lastPoint) {\n                    QPointF p = ((const QPointF *)points)[0] * state()->matrix;\n                    d->activeStroker->lineTo(p.x(), p.y());\n                    points += 2;\n                }\n                if (path.hasImplicitClose())\n                    d->activeStroker->lineTo(p.x(), p.y());\n            }\n            d->activeStroker->end();\n        }\n\n        QVectorPath strokePath(d->strokeHandler->pts.data(),\n                               d->strokeHandler->types.size(),\n                               d->strokeHandler->types.data(),\n                               flags);\n\n        QTransform xform = state()->matrix;\n        state()->matrix = QTransform();\n        transformChanged();\n\n        QBrush brush = pen.brush();\n        if (qbrush_style(brush) != Qt::SolidPattern)\n            brush.setTransform(brush.transform() * xform);\n\n        fill(strokePath, brush);\n\n        state()->matrix = xform;\n        transformChanged();\n    }\n}", "target": 2, "idx": 9990}
{"commit_id": "2b04e8f6bbb196cab4b232af0f8d48ff2c7a8058", "project": "torvalds/linux", "func": "struct bio *bio_map_user_iov(struct request_queue *q,\n\t\t\t     const struct iov_iter *iter,\n\t\t\t     gfp_t gfp_mask)\n{\n\tint j;\n\tint nr_pages = 0;\n\tstruct page **pages;\n\tstruct bio *bio;\n\tint cur_page = 0;\n\tint ret, offset;\n\tstruct iov_iter i;\n\tstruct iovec iov;\n\tstruct bio_vec *bvec;\n\n\tiov_for_each(iov, i, *iter) {\n\t\tunsigned long uaddr = (unsigned long) iov.iov_base;\n\t\tunsigned long len = iov.iov_len;\n\t\tunsigned long end = (uaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\tunsigned long start = uaddr >> PAGE_SHIFT;\n\n\t\t/*\n\t\t * Overflow, abort\n\t\t */\n\t\tif (end < start)\n\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\tnr_pages += end - start;\n\t\t/*\n\t\t * buffer must be aligned to at least logical block size for now\n\t\t */\n\t\tif (uaddr & queue_dma_alignment(q))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (!nr_pages)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tbio = bio_kmalloc(gfp_mask, nr_pages);\n\tif (!bio)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = -ENOMEM;\n\tpages = kcalloc(nr_pages, sizeof(struct page *), gfp_mask);\n\tif (!pages)\n\t\tgoto out;\n\n\tiov_for_each(iov, i, *iter) {\n\t\tunsigned long uaddr = (unsigned long) iov.iov_base;\n\t\tunsigned long len = iov.iov_len;\n\t\tunsigned long end = (uaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\tunsigned long start = uaddr >> PAGE_SHIFT;\n\t\tconst int local_nr_pages = end - start;\n\t\tconst int page_limit = cur_page + local_nr_pages;\n\n\t\tret = get_user_pages_fast(uaddr, local_nr_pages,\n\t\t\t\t(iter->type & WRITE) != WRITE,\n\t\t\t\t&pages[cur_page]);\n\t\tif (unlikely(ret < local_nr_pages)) {\n\t\t\tfor (j = cur_page; j < page_limit; j++) {\n\t\t\t\tif (!pages[j])\n\t\t\t\t\tbreak;\n\t\t\t\tput_page(pages[j]);\n\t\t\t}\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_unmap;\n\t\t}\n\n\t\toffset = offset_in_page(uaddr);\n\t\tfor (j = cur_page; j < page_limit; j++) {\n\t\t\tunsigned int bytes = PAGE_SIZE - offset;\n\t\t\tunsigned short prev_bi_vcnt = bio->bi_vcnt;\n\n\t\t\tif (len <= 0)\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tif (bytes > len)\n\t\t\t\tbytes = len;\n\n\t\t\t/*\n\t\t\t * sorry...\n\t\t\t */\n\t\t\tif (bio_add_pc_page(q, bio, pages[j], bytes, offset) <\n\t\t\t\t\t    bytes)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * check if vector was merged with previous\n\t\t\t * drop page reference if needed\n\t\t\t */\n\t\t\tif (bio->bi_vcnt == prev_bi_vcnt)\n\t\t\t\tput_page(pages[j]);\n\n\t\t\tlen -= bytes;\n\t\t\toffset = 0;\n\t\t}\n\n\t\tcur_page = j;\n\t\t/*\n\t\t * release the pages we didn't map into the bio, if any\n\t\t */\n\t\twhile (j < page_limit)\n\t\t\tput_page(pages[j++]);\n\t}\n\n\tkfree(pages);\n\n\tbio_set_flag(bio, BIO_USER_MAPPED);\n\n\t/*\n\t * subtle -- if bio_map_user_iov() ended up bouncing a bio,\n\t * it would normally disappear when its bi_end_io is run.\n\t * however, we need it for the unmap, so grab an extra\n\t * reference to it\n\t */\n\tbio_get(bio);\n\treturn bio;\n\n out_unmap:\n\tbio_for_each_segment_all(bvec, bio, j) {\n\t\tput_page(bvec->bv_page);\n\t}\n out:\n\tkfree(pages);\n\tbio_put(bio);\n\treturn ERR_PTR(ret);\n}", "target": 1, "idx": 9991}
{"commit_id": "7a7b5df84b6b4e5d599c7289526eed96541a0654", "project": "torvalds/linux", "func": "static int cp2112_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tstruct cp2112_device *dev;\n\tu8 buf[3];\n\tstruct cp2112_smbus_config_report config;\n\tint ret;\n\n\tdev = devm_kzalloc(&hdev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->in_out_buffer = devm_kzalloc(&hdev->dev, CP2112_REPORT_MAX_LENGTH,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!dev->in_out_buffer)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&dev->lock);\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_HIDRAW);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = hid_hw_open(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"hw open failed\\n\");\n\t\tgoto err_hid_stop;\n\t}\n\n\tret = hid_hw_power(hdev, PM_HINT_FULLON);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"power management error: %d\\n\", ret);\n\t\tgoto err_hid_close;\n\t}\n\n\tret = cp2112_hid_get(hdev, CP2112_GET_VERSION_INFO, buf, sizeof(buf),\n\t\t\t     HID_FEATURE_REPORT);\n\tif (ret != sizeof(buf)) {\n\t\thid_err(hdev, \"error requesting version\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t\tgoto err_power_normal;\n\t}\n\n\thid_info(hdev, \"Part Number: 0x%02X Device Version: 0x%02X\\n\",\n\t\t buf[1], buf[2]);\n\n\tret = cp2112_hid_get(hdev, CP2112_SMBUS_CONFIG, (u8 *)&config,\n\t\t\t     sizeof(config), HID_FEATURE_REPORT);\n\tif (ret != sizeof(config)) {\n\t\thid_err(hdev, \"error requesting SMBus config\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t\tgoto err_power_normal;\n\t}\n\n\tconfig.retry_time = cpu_to_be16(1);\n\n\tret = cp2112_hid_output(hdev, (u8 *)&config, sizeof(config),\n\t\t\t\tHID_FEATURE_REPORT);\n\tif (ret != sizeof(config)) {\n\t\thid_err(hdev, \"error setting SMBus config\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t\tgoto err_power_normal;\n\t}\n\n\thid_set_drvdata(hdev, (void *)dev);\n\tdev->hdev\t\t= hdev;\n\tdev->adap.owner\t\t= THIS_MODULE;\n\tdev->adap.class\t\t= I2C_CLASS_HWMON;\n\tdev->adap.algo\t\t= &smbus_algorithm;\n\tdev->adap.algo_data\t= dev;\n\tdev->adap.dev.parent\t= &hdev->dev;\n\tsnprintf(dev->adap.name, sizeof(dev->adap.name),\n\t\t \"CP2112 SMBus Bridge on hiddev%d\", hdev->minor);\n\tdev->hwversion = buf[2];\n\tinit_waitqueue_head(&dev->wait);\n\n\thid_device_io_start(hdev);\n\tret = i2c_add_adapter(&dev->adap);\n\thid_device_io_stop(hdev);\n\n\tif (ret) {\n\t\thid_err(hdev, \"error registering i2c adapter\\n\");\n\t\tgoto err_power_normal;\n\t}\n\n\thid_dbg(hdev, \"adapter registered\\n\");\n\n\tdev->gc.label\t\t\t= \"cp2112_gpio\";\n\tdev->gc.direction_input\t\t= cp2112_gpio_direction_input;\n\tdev->gc.direction_output\t= cp2112_gpio_direction_output;\n\tdev->gc.set\t\t\t= cp2112_gpio_set;\n\tdev->gc.get\t\t\t= cp2112_gpio_get;\n\tdev->gc.base\t\t\t= -1;\n\tdev->gc.ngpio\t\t\t= 8;\n\tdev->gc.can_sleep\t\t= 1;\n\tdev->gc.parent\t\t\t= &hdev->dev;\n\n\tret = gpiochip_add_data(&dev->gc, dev);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"error registering gpio chip\\n\");\n\t\tgoto err_free_i2c;\n\t}\n\n\tret = sysfs_create_group(&hdev->dev.kobj, &cp2112_attr_group);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"error creating sysfs attrs\\n\");\n\t\tgoto err_gpiochip_remove;\n\t}\n\n\tchmod_sysfs_attrs(hdev);\n\thid_hw_power(hdev, PM_HINT_NORMAL);\n\n\tret = gpiochip_irqchip_add(&dev->gc, &cp2112_gpio_irqchip, 0,\n\t\t\t\t   handle_simple_irq, IRQ_TYPE_NONE);\n\tif (ret) {\n\t\tdev_err(dev->gc.parent, \"failed to add IRQ chip\\n\");\n\t\tgoto err_sysfs_remove;\n\t}\n\n\treturn ret;\n\nerr_sysfs_remove:\n\tsysfs_remove_group(&hdev->dev.kobj, &cp2112_attr_group);\nerr_gpiochip_remove:\n\tgpiochip_remove(&dev->gc);\nerr_free_i2c:\n\ti2c_del_adapter(&dev->adap);\nerr_power_normal:\n\thid_hw_power(hdev, PM_HINT_NORMAL);\nerr_hid_close:\n\thid_hw_close(hdev);\nerr_hid_stop:\n\thid_hw_stop(hdev);\n\treturn ret;\n}", "target": 1, "idx": 9992}
{"commit_id": "9cc02ede696272c5271a401e4f27c262359bc2f6", "project": "torvalds/linux", "func": "void rose_stop_heartbeat(struct sock *sk)\n{\n\tsk_stop_timer(sk, &sk->sk_timer);\n}", "target": 1, "idx": 9993}
{"commit_id": "df5f01c6ed0c20d269f7239901d21883cc871bbb", "project": "USBGuard/usbguard", "func": "void DBusBridge::handlePolicyMethodCall(const std::string& method_name, GVariant* parameters, GDBusMethodInvocation* invocation)\n  {\n    if (method_name == \"listRules\") {\n      if (! isAuthorizedByPolkit(invocation)) {\n        return;\n      }\n\n      const char* label_cstr = nullptr;\n      g_variant_get(parameters, \"(&s)\", &label_cstr);\n      std::string label(label_cstr);\n      auto rules = listRules(label);\n\n      if (rules.size() > 0) {\n        auto gvbuilder = g_variant_builder_new(G_VARIANT_TYPE_ARRAY);\n\n        try {\n          for (auto rule : rules) {\n            g_variant_builder_add(gvbuilder, \"(us)\",\n              rule.getRuleID(),\n              rule.toString().c_str());\n          }\n\n          g_dbus_method_invocation_return_value(invocation, g_variant_new(\"(a(us))\", gvbuilder));\n        }\n        catch (...) {\n          g_variant_builder_unref(gvbuilder);\n          throw;\n        }\n\n        g_variant_builder_unref(gvbuilder);\n      }\n      else {\n        g_dbus_method_invocation_return_value(invocation, g_variant_new(\"(a(us))\", nullptr));\n      }\n\n      return;\n    }\n\n    if (method_name == \"appendRule\") {\n      if (! isAuthorizedByPolkit(invocation)) {\n        return;\n      }\n\n      const char* rule_spec_cstr = nullptr;\n      uint32_t parent_id = 0;\n      gboolean temporary = false;\n      g_variant_get(parameters, \"(&sub)\", &rule_spec_cstr, &parent_id, &temporary);\n      std::string rule_spec(rule_spec_cstr);\n      const uint32_t rule_id = appendRule(rule_spec, parent_id, !temporary);\n      g_dbus_method_invocation_return_value(invocation, g_variant_new(\"(u)\", rule_id));\n      return;\n    }\n\n    if (method_name == \"removeRule\") {\n      if (! isAuthorizedByPolkit(invocation)) {\n        return;\n      }\n\n      uint32_t rule_id = 0;\n      g_variant_get(parameters, \"(u)\", &rule_id);\n      removeRule(rule_id);\n      g_dbus_method_invocation_return_value(invocation, nullptr);\n      return;\n    }\n\n    g_dbus_method_invocation_return_error(invocation, G_DBUS_ERROR,\n      G_DBUS_ERROR_UNKNOWN_METHOD, \"Unknown method interface\");\n    return;\n  }", "target": 2, "idx": 9994}
{"commit_id": "5e611f32841e746932fbcbea292ca502ed9e694b", "project": "neovim", "func": "void \nopenscript (\n    char_u *name,\n    int directly                   /* when TRUE execute directly */\n)\n{\n  if (curscript + 1 == NSCRIPT) {\n    EMSG(_(e_nesting));\n    return;\n  }\n\n  // Disallow sourcing a file in the sandbox, the commands would be executed\n  // later, possibly outside of the sandbox.\n  if (check_secure()) {\n    return;\n  }\n\n  if (ignore_script)\n    /* Not reading from script, also don't open one.  Warning message? */\n    return;\n\n  if (scriptin[curscript] != NULL)      /* already reading script */\n    ++curscript;\n  /* use NameBuff for expanded name */\n  expand_env(name, NameBuff, MAXPATHL);\n  int error;\n  if ((scriptin[curscript] = file_open_new(&error, (char *)NameBuff,\n                                           kFileReadOnly, 0)) == NULL) {\n    emsgf(_(e_notopen_2), name, os_strerror(error));\n    if (curscript) {\n      curscript--;\n    }\n    return;\n  }\n  save_typebuf();\n\n  /*\n   * Execute the commands from the file right now when using \":source!\"\n   * after \":global\" or \":argdo\" or in a loop.  Also when another command\n   * follows.  This means the display won't be updated.  Don't do this\n   * always, \"make test\" would fail.\n   */\n  if (directly) {\n    oparg_T oa;\n    int oldcurscript;\n    int save_State = State;\n    int save_restart_edit = restart_edit;\n    int save_insertmode = p_im;\n    int save_finish_op = finish_op;\n    int save_msg_scroll = msg_scroll;\n\n    State = NORMAL;\n    msg_scroll = FALSE;         /* no msg scrolling in Normal mode */\n    restart_edit = 0;           /* don't go to Insert mode */\n    p_im = FALSE;               /* don't use 'insertmode' */\n    clear_oparg(&oa);\n    finish_op = FALSE;\n\n    oldcurscript = curscript;\n    do {\n      update_topline_cursor();          /* update cursor position and topline */\n      normal_cmd(&oa, FALSE);           /* execute one command */\n      vpeekc();                         /* check for end of file */\n    } while (scriptin[oldcurscript] != NULL);\n\n    State = save_State;\n    msg_scroll = save_msg_scroll;\n    restart_edit = save_restart_edit;\n    p_im = save_insertmode;\n    finish_op = save_finish_op;\n  }\n}", "target": 2, "idx": 9995}
{"commit_id": "0f2122045b946241a9e549c2a76cea54fa58a7ff", "project": "torvalds/linux", "func": "static int io_uring_flush(struct file *file, void *data)\n{\n\tstruct io_ring_ctx *ctx = file->private_data;\n\n\t/*\n\t * If the task is going away, cancel work it may have pending\n\t */\n\tif (fatal_signal_pending(current) || (current->flags & PF_EXITING))\n\t\tdata = NULL;\n\n\tio_uring_cancel_task_requests(ctx, data);\n\tio_uring_attempt_task_drop(file, !data);\n\treturn 0;\n}", "target": 2, "idx": 9996}
{"commit_id": "33ce512c476330e7e4881d1377645ffb87985808", "project": "mz-automation/libiec61850", "func": "void\nEthernet_getInterfaceMACAddress(const char* interfaceId, uint8_t* addr)\n{\n    struct ifreq buffer;\n\n    int sock = socket(PF_INET, SOCK_DGRAM, 0);\n\n    memset(&buffer, 0x00, sizeof(buffer));\n\n    strncpy(buffer.ifr_name, interfaceId, IFNAMSIZ);\n\n    ioctl(sock, SIOCGIFHWADDR, &buffer);\n\n    close(sock);\n\n    int i;\n\n    for(i = 0; i < 6; i++ )\n    {\n        addr[i] = (unsigned char)buffer.ifr_hwaddr.sa_data[i];\n    }\n}", "target": 3, "idx": 9997}
{"commit_id": "4b6dd3b53cd5c6d4d4df378a2fc62c1707522b31", "project": "envoyproxy/envoy", "func": "void ConnPoolImplBase::checkForIdleAndCloseIdleConnsIfDraining() {\n  if (is_draining_for_deletion_) {\n    closeIdleConnectionsForDrainingPool();\n  }\n\n  checkForIdleAndNotify();\n}", "target": 1, "idx": 9998}
{"commit_id": "0d0e57697f162da4aa218b5feafe614fb666db07", "project": "torvalds/linux", "func": "static void print_bpf_insn(const struct bpf_verifier_env *env,\n\t\t\t   const struct bpf_insn *insn)\n{\n\tu8 class = BPF_CLASS(insn->code);\n\n\tif (class == BPF_ALU || class == BPF_ALU64) {\n\t\tif (BPF_SRC(insn->code) == BPF_X)\n\t\t\tverbose(\"(%02x) %sr%d %s %sr%d\\n\",\n\t\t\t\tinsn->code, class == BPF_ALU ? \"(u32) \" : \"\",\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tbpf_alu_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tclass == BPF_ALU ? \"(u32) \" : \"\",\n\t\t\t\tinsn->src_reg);\n\t\telse\n\t\t\tverbose(\"(%02x) %sr%d %s %s%d\\n\",\n\t\t\t\tinsn->code, class == BPF_ALU ? \"(u32) \" : \"\",\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tbpf_alu_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tclass == BPF_ALU ? \"(u32) \" : \"\",\n\t\t\t\tinsn->imm);\n\t} else if (class == BPF_STX) {\n\t\tif (BPF_MODE(insn->code) == BPF_MEM)\n\t\t\tverbose(\"(%02x) *(%s *)(r%d %+d) = r%d\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tinsn->off, insn->src_reg);\n\t\telse if (BPF_MODE(insn->code) == BPF_XADD)\n\t\t\tverbose(\"(%02x) lock *(%s *)(r%d %+d) += r%d\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->dst_reg, insn->off,\n\t\t\t\tinsn->src_reg);\n\t\telse\n\t\t\tverbose(\"BUG_%02x\\n\", insn->code);\n\t} else if (class == BPF_ST) {\n\t\tif (BPF_MODE(insn->code) != BPF_MEM) {\n\t\t\tverbose(\"BUG_st_%02x\\n\", insn->code);\n\t\t\treturn;\n\t\t}\n\t\tverbose(\"(%02x) *(%s *)(r%d %+d) = %d\\n\",\n\t\t\tinsn->code,\n\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\tinsn->dst_reg,\n\t\t\tinsn->off, insn->imm);\n\t} else if (class == BPF_LDX) {\n\t\tif (BPF_MODE(insn->code) != BPF_MEM) {\n\t\t\tverbose(\"BUG_ldx_%02x\\n\", insn->code);\n\t\t\treturn;\n\t\t}\n\t\tverbose(\"(%02x) r%d = *(%s *)(r%d %+d)\\n\",\n\t\t\tinsn->code, insn->dst_reg,\n\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\tinsn->src_reg, insn->off);\n\t} else if (class == BPF_LD) {\n\t\tif (BPF_MODE(insn->code) == BPF_ABS) {\n\t\t\tverbose(\"(%02x) r0 = *(%s *)skb[%d]\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->imm);\n\t\t} else if (BPF_MODE(insn->code) == BPF_IND) {\n\t\t\tverbose(\"(%02x) r0 = *(%s *)skb[r%d + %d]\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->src_reg, insn->imm);\n\t\t} else if (BPF_MODE(insn->code) == BPF_IMM &&\n\t\t\t   BPF_SIZE(insn->code) == BPF_DW) {\n\t\t\t/* At this point, we already made sure that the second\n\t\t\t * part of the ldimm64 insn is accessible.\n\t\t\t */\n\t\t\tu64 imm = ((u64)(insn + 1)->imm << 32) | (u32)insn->imm;\n\t\t\tbool map_ptr = insn->src_reg == BPF_PSEUDO_MAP_FD;\n\n\t\t\tif (map_ptr && !env->allow_ptr_leaks)\n\t\t\t\timm = 0;\n\n\t\t\tverbose(\"(%02x) r%d = 0x%llx\\n\", insn->code,\n\t\t\t\tinsn->dst_reg, (unsigned long long)imm);\n\t\t} else {\n\t\t\tverbose(\"BUG_ld_%02x\\n\", insn->code);\n\t\t\treturn;\n\t\t}\n\t} else if (class == BPF_JMP) {\n\t\tu8 opcode = BPF_OP(insn->code);\n\n\t\tif (opcode == BPF_CALL) {\n\t\t\tverbose(\"(%02x) call %s#%d\\n\", insn->code,\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t} else if (insn->code == (BPF_JMP | BPF_JA)) {\n\t\t\tverbose(\"(%02x) goto pc%+d\\n\",\n\t\t\t\tinsn->code, insn->off);\n\t\t} else if (insn->code == (BPF_JMP | BPF_EXIT)) {\n\t\t\tverbose(\"(%02x) exit\\n\", insn->code);\n\t\t} else if (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tverbose(\"(%02x) if r%d %s r%d goto pc%+d\\n\",\n\t\t\t\tinsn->code, insn->dst_reg,\n\t\t\t\tbpf_jmp_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tinsn->src_reg, insn->off);\n\t\t} else {\n\t\t\tverbose(\"(%02x) if r%d %s 0x%x goto pc%+d\\n\",\n\t\t\t\tinsn->code, insn->dst_reg,\n\t\t\t\tbpf_jmp_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tinsn->imm, insn->off);\n\t\t}\n\t} else {\n\t\tverbose(\"(%02x) %s\\n\", insn->code, bpf_class_string[class]);\n\t}\n}", "target": 1, "idx": 9999}
{"commit_id": "aa0858100096a3490edf93034a80e66a4d61aad5", "project": "the-tcpdump-group/tcpdump", "func": "static void\nubik_print(netdissect_options *ndo,\n           register const u_char *bp)\n{\n\tint ubik_op;\n\tint32_t temp;\n\n\t/*\n\t * Print out the afs call we're invoking.  The table used here was\n\t * gleaned from ubik/ubik_int.xg\n\t */\n\n\tubik_op = EXTRACT_32BITS(bp + sizeof(struct rx_header));\n\n\tND_PRINT((ndo, \" ubik call %s\", tok2str(ubik_req, \"op#%d\", ubik_op)));\n\n\t/*\n\t * Decode some of the arguments to the Ubik calls\n\t */\n\n\tbp += sizeof(struct rx_header) + 4;\n\n\tswitch (ubik_op) {\n\t\tcase 10000:\t\t/* Beacon */\n\t\t\tND_TCHECK2(bp[0], 4);\n\t\t\ttemp = EXTRACT_32BITS(bp);\n\t\t\tbp += sizeof(int32_t);\n\t\t\tND_PRINT((ndo, \" syncsite %s\", temp ? \"yes\" : \"no\"));\n\t\t\tND_PRINT((ndo, \" votestart\"));\n\t\t\tDATEOUT();\n\t\t\tND_PRINT((ndo, \" dbversion\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT((ndo, \" tid\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tbreak;\n\t\tcase 10003:\t\t/* Get sync site */\n\t\t\tND_PRINT((ndo, \" site\"));\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 20000:\t\t/* Begin */\n\t\tcase 20001:\t\t/* Commit */\n\t\tcase 20007:\t\t/* Abort */\n\t\tcase 20008:\t\t/* Release locks */\n\t\tcase 20010:\t\t/* Writev */\n\t\t\tND_PRINT((ndo, \" tid\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tbreak;\n\t\tcase 20002:\t\t/* Lock */\n\t\t\tND_PRINT((ndo, \" tid\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT((ndo, \" file\"));\n\t\t\tINTOUT();\n\t\t\tND_PRINT((ndo, \" pos\"));\n\t\t\tINTOUT();\n\t\t\tND_PRINT((ndo, \" length\"));\n\t\t\tINTOUT();\n\t\t\tND_TCHECK_32BITS(bp);\n\t\t\ttemp = EXTRACT_32BITS(bp);\n\t\t\tbp += sizeof(int32_t);\n\t\t\ttok2str(ubik_lock_types, \"type %d\", temp);\n\t\t\tbreak;\n\t\tcase 20003:\t\t/* Write */\n\t\t\tND_PRINT((ndo, \" tid\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT((ndo, \" file\"));\n\t\t\tINTOUT();\n\t\t\tND_PRINT((ndo, \" pos\"));\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 20005:\t\t/* Get file */\n\t\t\tND_PRINT((ndo, \" file\"));\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 20006:\t\t/* Send file */\n\t\t\tND_PRINT((ndo, \" file\"));\n\t\t\tINTOUT();\n\t\t\tND_PRINT((ndo, \" length\"));\n\t\t\tINTOUT();\n\t\t\tND_PRINT((ndo, \" dbversion\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tbreak;\n\t\tcase 20009:\t\t/* Truncate */\n\t\t\tND_PRINT((ndo, \" tid\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT((ndo, \" file\"));\n\t\t\tINTOUT();\n\t\t\tND_PRINT((ndo, \" length\"));\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 20012:\t\t/* Set version */\n\t\t\tND_PRINT((ndo, \" tid\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT((ndo, \" oldversion\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT((ndo, \" newversion\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t;\n\t}\n\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \" [|ubik]\"));\n}", "target": 3, "idx": 10000}
{"commit_id": "330f1716df49c0d3474c18b6dcd370a9dcf57422", "project": "php/php-src", "func": "static void exif_iif_add_value(image_info_type *image_info, int section_index, char *name, int tag, int format, int length, void* value, size_t value_len, int motorola_intel)\n{\n\tsize_t idex;\n\tvoid *vptr, *vptr_end;\n\timage_info_value *info_value;\n\timage_info_data  *info_data;\n\timage_info_data  *list;\n\n\tif (length < 0) {\n\t\treturn;\n\t}\n\n\tlist = safe_erealloc(image_info->info_list[section_index].list, (image_info->info_list[section_index].count+1), sizeof(image_info_data), 0);\n\timage_info->info_list[section_index].list = list;\n\n\tinfo_data  = &image_info->info_list[section_index].list[image_info->info_list[section_index].count];\n\tmemset(info_data, 0, sizeof(image_info_data));\n\tinfo_data->tag    = tag;\n\tinfo_data->format = format;\n\tinfo_data->length = length;\n\tinfo_data->name   = estrdup(name);\n\tinfo_value        = &info_data->value;\n\n\tswitch (format) {\n\t\tcase TAG_FMT_STRING:\n\t\t\tif (length > value_len) {\n\t\t\t\texif_error_docref(\"exif_iif_add_value\" EXIFERR_CC, image_info, E_WARNING, \"length > value_len: %d > %zu\", length, value_len);\n\t\t\t\tvalue = NULL;\n\t\t\t}\n\t\t\tif (value) {\n\t\t\t\tlength = (int)php_strnlen(value, length);\n\t\t\t\tinfo_value->s = estrndup(value, length);\n\t\t\t\tinfo_data->length = length;\n\t\t\t} else {\n\t\t\t\tinfo_data->length = 0;\n\t\t\t\tinfo_value->s = estrdup(\"\");\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Standard says more types possible but skip them...\n\t\t\t * but allow users to handle data if they know how to\n\t\t\t * So not return but use type UNDEFINED\n\t\t\t * return;\n\t\t\t */\n\t\t\tinfo_data->tag = TAG_FMT_UNDEFINED;/* otherwise not freed from memory */\n\t\tcase TAG_FMT_SBYTE:\n\t\tcase TAG_FMT_BYTE:\n\t\t/* in contrast to strings bytes do not need to allocate buffer for NULL if length==0 */\n\t\t\tif (!length)\n\t\t\t\tbreak;\n\t\tcase TAG_FMT_UNDEFINED:\n\t\t\tif (length > value_len) {\n\t\t\t\texif_error_docref(\"exif_iif_add_value\" EXIFERR_CC, image_info, E_WARNING, \"length > value_len: %d > %zu\", length, value_len);\n\t\t\t\tvalue = NULL;\n\t\t\t}\n\t\t\tif (value) {\n\t\t\t\tif (tag == TAG_MAKER_NOTE) {\n\t\t\t\t\tlength = (int) php_strnlen(value, length);\n\t\t\t\t}\n\n\t\t\t\t/* do not recompute length here */\n\t\t\t\tinfo_value->s = estrndup(value, length);\n\t\t\t\tinfo_data->length = length;\n\t\t\t} else {\n\t\t\t\tinfo_data->length = 0;\n\t\t\t\tinfo_value->s = estrdup(\"\");\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TAG_FMT_USHORT:\n\t\tcase TAG_FMT_ULONG:\n\t\tcase TAG_FMT_URATIONAL:\n\t\tcase TAG_FMT_SSHORT:\n\t\tcase TAG_FMT_SLONG:\n\t\tcase TAG_FMT_SRATIONAL:\n\t\tcase TAG_FMT_SINGLE:\n\t\tcase TAG_FMT_DOUBLE:\n\t\t\tif (length==0) {\n\t\t\t\tbreak;\n\t\t\t} else\n\t\t\tif (length>1) {\n\t\t\t\tinfo_value->list = safe_emalloc(length, sizeof(image_info_value), 0);\n\t\t\t} else {\n\t\t\t\tinfo_value = &info_data->value;\n\t\t\t}\n\t\t\tvptr_end = value+value_len;\n\t\t\tfor (idex=0,vptr=value; idex<(size_t)length; idex++,vptr=(char *) vptr + php_tiff_bytes_per_format[format]) {\n\t\t\t\tif (vptr_end - vptr < php_tiff_bytes_per_format[format]) {\n\t\t\t\t\texif_error_docref(\"exif_iif_add_value\" EXIFERR_CC, image_info, E_WARNING, \"Value too short\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (length>1) {\n\t\t\t\t\tinfo_value = &info_data->value.list[idex];\n\t\t\t\t}\n\t\t\t\tswitch (format) {\n\t\t\t\t\tcase TAG_FMT_USHORT:\n\t\t\t\t\t\tinfo_value->u = php_ifd_get16u(vptr, motorola_intel);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TAG_FMT_ULONG:\n\t\t\t\t\t\tinfo_value->u = php_ifd_get32u(vptr, motorola_intel);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TAG_FMT_URATIONAL:\n\t\t\t\t\t\tinfo_value->ur.num = php_ifd_get32u(vptr, motorola_intel);\n\t\t\t\t\t\tinfo_value->ur.den = php_ifd_get32u(4+(char *)vptr, motorola_intel);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TAG_FMT_SSHORT:\n\t\t\t\t\t\tinfo_value->i = php_ifd_get16s(vptr, motorola_intel);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TAG_FMT_SLONG:\n\t\t\t\t\t\tinfo_value->i = php_ifd_get32s(vptr, motorola_intel);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TAG_FMT_SRATIONAL:\n\t\t\t\t\t\tinfo_value->sr.num = php_ifd_get32u(vptr, motorola_intel);\n\t\t\t\t\t\tinfo_value->sr.den = php_ifd_get32u(4+(char *)vptr, motorola_intel);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TAG_FMT_SINGLE:\n#ifdef EXIF_DEBUG\n\t\t\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Found value of type single\");\n#endif\n\t\t\t\t\t\tinfo_value->f = *(float *)value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TAG_FMT_DOUBLE:\n#ifdef EXIF_DEBUG\n\t\t\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Found value of type double\");\n#endif\n\t\t\t\t\t\tinfo_value->d = *(double *)value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t}\n\timage_info->sections_found |= 1<<section_index;\n\timage_info->info_list[section_index].count++;\n}", "target": 3, "idx": 10001}
{"commit_id": "e831aad6d48874abab6efa37d4460da2be3ac765", "project": "appneta/tcpreplay", "func": "int \ndlt_jnpr_ether_cleanup(tcpeditdlt_t *ctx)\n{\n    tcpeditdlt_plugin_t *plugin;\n    \n    assert(ctx);\n\n    if ((plugin = tcpedit_dlt_getplugin(ctx, dlt_value)) == NULL) {\n        tcpedit_seterr(ctx->tcpedit, \"Unable to cleanup unregistered plugin %s\", dlt_name);\n        return TCPEDIT_ERROR;\n    }\n\n    safe_free(plugin->name);\n    plugin->name = NULL;\n    if (plugin->config != NULL) {\n        /* clean up the en10mb plugin */\n        jnpr_ether_config_t *config;\n\n        config = (jnpr_ether_config_t *)ctx->encoder->config;\n        if (config->subctx != NULL)\n            tcpedit_dlt_cleanup(config->subctx);\n        safe_free(plugin->config);\n        plugin->config = NULL;\n        plugin->config_size = 0;\n    }\n\n    return TCPEDIT_OK; /* success */\n}", "target": 2, "idx": 10002}
{"commit_id": "ab128218225d3542596ca3a02aee80d55494bef8", "project": "xen-project/xen", "func": "static int chk_domain_generation(unsigned int domid, uint64_t gen)\n{\n\tstruct domain *d;\n\n\tif (!xc_handle && domid == 0)\n\t\treturn 1;\n\n\td = find_domain_struct(domid);\n\n\treturn (d && d->generation <= gen) ? 1 : 0;\n}", "target": 2, "idx": 10003}
{"commit_id": "34fa79a6cde56d6d428ab0d3160cb094ebad3305", "project": "git", "func": "char *path_name(const struct name_path *path, const char *name)\n{\n\tconst struct name_path *p;\n\tchar *n, *m;\n\tint nlen = strlen(name);\n\tint len = nlen + 1;\n\n\tfor (p = path; p; p = p->up) {\n\t\tif (p->elem_len)\n\t\t\tlen += p->elem_len + 1;\n\t}\n\tn = xmalloc(len);\n\tm = n + len - (nlen + 1);\n\tmemcpy(m, name, nlen + 1);\n\tfor (p = path; p; p = p->up) {\n\t\tif (p->elem_len) {\n\t\t\tm -= p->elem_len + 1;\n\t\t\tmemcpy(m, p->elem, p->elem_len);\n\t\t\tm[p->elem_len] = '/';\n\t\t}\n\t}\n\treturn n;\n}", "target": 3, "idx": 10004}
{"commit_id": "8f659a03a0ba9289b9aeb9b4470e6fb263d6f483", "project": "torvalds/linux", "func": "static int raw_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tstruct ipcm_cookie ipc;\n\tstruct rtable *rt = NULL;\n\tstruct flowi4 fl4;\n\tint free = 0;\n\t__be32 daddr;\n\t__be32 saddr;\n\tu8  tos;\n\tint err;\n\tstruct ip_options_data opt_copy;\n\tstruct raw_frag_vec rfv;\n\tint hdrincl;\n\n\terr = -EMSGSIZE;\n\tif (len > 0xFFFF)\n\t\tgoto out;\n\n\t/* hdrincl should be READ_ONCE(inet->hdrincl)\n\t * but READ_ONCE() doesn't work with bit fields\n\t */\n\thdrincl = inet->hdrincl;\n\t/*\n\t *\tCheck the flags.\n\t */\n\n\terr = -EOPNOTSUPP;\n\tif (msg->msg_flags & MSG_OOB)\t/* Mirror BSD error message */\n\t\tgoto out;               /* compatibility */\n\n\t/*\n\t *\tGet and verify the address.\n\t */\n\n\tif (msg->msg_namelen) {\n\t\tDECLARE_SOCKADDR(struct sockaddr_in *, usin, msg->msg_name);\n\t\terr = -EINVAL;\n\t\tif (msg->msg_namelen < sizeof(*usin))\n\t\t\tgoto out;\n\t\tif (usin->sin_family != AF_INET) {\n\t\t\tpr_info_once(\"%s: %s forgot to set AF_INET. Fix it!\\n\",\n\t\t\t\t     __func__, current->comm);\n\t\t\terr = -EAFNOSUPPORT;\n\t\t\tif (usin->sin_family)\n\t\t\t\tgoto out;\n\t\t}\n\t\tdaddr = usin->sin_addr.s_addr;\n\t\t/* ANK: I did not forget to get protocol from port field.\n\t\t * I just do not know, who uses this weirdness.\n\t\t * IP_HDRINCL is much more convenient.\n\t\t */\n\t} else {\n\t\terr = -EDESTADDRREQ;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\t\tdaddr = inet->inet_daddr;\n\t}\n\n\tipc.sockc.tsflags = sk->sk_tsflags;\n\tipc.addr = inet->inet_saddr;\n\tipc.opt = NULL;\n\tipc.tx_flags = 0;\n\tipc.ttl = 0;\n\tipc.tos = -1;\n\tipc.oif = sk->sk_bound_dev_if;\n\n\tif (msg->msg_controllen) {\n\t\terr = ip_cmsg_send(sk, msg, &ipc, false);\n\t\tif (unlikely(err)) {\n\t\t\tkfree(ipc.opt);\n\t\t\tgoto out;\n\t\t}\n\t\tif (ipc.opt)\n\t\t\tfree = 1;\n\t}\n\n\tsaddr = ipc.addr;\n\tipc.addr = daddr;\n\n\tif (!ipc.opt) {\n\t\tstruct ip_options_rcu *inet_opt;\n\n\t\trcu_read_lock();\n\t\tinet_opt = rcu_dereference(inet->inet_opt);\n\t\tif (inet_opt) {\n\t\t\tmemcpy(&opt_copy, inet_opt,\n\t\t\t       sizeof(*inet_opt) + inet_opt->opt.optlen);\n\t\t\tipc.opt = &opt_copy.opt;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tif (ipc.opt) {\n\t\terr = -EINVAL;\n\t\t/* Linux does not mangle headers on raw sockets,\n\t\t * so that IP options + IP_HDRINCL is non-sense.\n\t\t */\n\t\tif (hdrincl)\n\t\t\tgoto done;\n\t\tif (ipc.opt->opt.srr) {\n\t\t\tif (!daddr)\n\t\t\t\tgoto done;\n\t\t\tdaddr = ipc.opt->opt.faddr;\n\t\t}\n\t}\n\ttos = get_rtconn_flags(&ipc, sk);\n\tif (msg->msg_flags & MSG_DONTROUTE)\n\t\ttos |= RTO_ONLINK;\n\n\tif (ipv4_is_multicast(daddr)) {\n\t\tif (!ipc.oif)\n\t\t\tipc.oif = inet->mc_index;\n\t\tif (!saddr)\n\t\t\tsaddr = inet->mc_addr;\n\t} else if (!ipc.oif)\n\t\tipc.oif = inet->uc_index;\n\n\tflowi4_init_output(&fl4, ipc.oif, sk->sk_mark, tos,\n\t\t\t   RT_SCOPE_UNIVERSE,\n\t\t\t   hdrincl ? IPPROTO_RAW : sk->sk_protocol,\n\t\t\t   inet_sk_flowi_flags(sk) |\n\t\t\t    (hdrincl ? FLOWI_FLAG_KNOWN_NH : 0),\n\t\t\t   daddr, saddr, 0, 0, sk->sk_uid);\n\n\tif (!hdrincl) {\n\t\trfv.msg = msg;\n\t\trfv.hlen = 0;\n\n\t\terr = raw_probe_proto_opt(&rfv, &fl4);\n\t\tif (err)\n\t\t\tgoto done;\n\t}\n\n\tsecurity_sk_classify_flow(sk, flowi4_to_flowi(&fl4));\n\trt = ip_route_output_flow(net, &fl4, sk);\n\tif (IS_ERR(rt)) {\n\t\terr = PTR_ERR(rt);\n\t\trt = NULL;\n\t\tgoto done;\n\t}\n\n\terr = -EACCES;\n\tif (rt->rt_flags & RTCF_BROADCAST && !sock_flag(sk, SOCK_BROADCAST))\n\t\tgoto done;\n\n\tif (msg->msg_flags & MSG_CONFIRM)\n\t\tgoto do_confirm;\nback_from_confirm:\n\n\tif (hdrincl)\n\t\terr = raw_send_hdrinc(sk, &fl4, msg, len,\n\t\t\t\t      &rt, msg->msg_flags, &ipc.sockc);\n\n\t else {\n\t\tsock_tx_timestamp(sk, ipc.sockc.tsflags, &ipc.tx_flags);\n\n\t\tif (!ipc.addr)\n\t\t\tipc.addr = fl4.daddr;\n\t\tlock_sock(sk);\n\t\terr = ip_append_data(sk, &fl4, raw_getfrag,\n\t\t\t\t     &rfv, len, 0,\n\t\t\t\t     &ipc, &rt, msg->msg_flags);\n\t\tif (err)\n\t\t\tip_flush_pending_frames(sk);\n\t\telse if (!(msg->msg_flags & MSG_MORE)) {\n\t\t\terr = ip_push_pending_frames(sk, &fl4);\n\t\t\tif (err == -ENOBUFS && !inet->recverr)\n\t\t\t\terr = 0;\n\t\t}\n\t\trelease_sock(sk);\n\t}\ndone:\n\tif (free)\n\t\tkfree(ipc.opt);\n\tip_rt_put(rt);\n\nout:\n\tif (err < 0)\n\t\treturn err;\n\treturn len;\n\ndo_confirm:\n\tif (msg->msg_flags & MSG_PROBE)\n\t\tdst_confirm_neigh(&rt->dst, &fl4.daddr);\n\tif (!(msg->msg_flags & MSG_PROBE) || len)\n\t\tgoto back_from_confirm;\n\terr = 0;\n\tgoto done;\n}", "target": 2, "idx": 10005}
{"commit_id": "e41f331e90b383e3208cefb74e006df44bf3a4b8", "project": "LibRaw", "func": "int crxFreeImageData(CrxImage *img)\n{\n#ifdef LIBRAW_CR3_MEMPOOL\n\timg->memmgr.cleanup();\n#else\n  CrxTile *tile = img->tiles;\n  int nTiles = img->tileRows * img->tileCols;\n\n  if (img->tiles)\n  {\n    for (int32_t curTile = 0; curTile < nTiles; curTile++, tile++)\n      if (tile[curTile].comps)\n        for (int32_t curPlane = 0; curPlane < img->nPlanes; curPlane++)\n          crxFreeSubbandData(img, tile[curTile].comps + curPlane);\n    free(img->tiles);\n    img->tiles = 0;\n  }\n\n  if (img->planeBuf)\n  {\n    free(img->planeBuf);\n    img->planeBuf = 0;\n  }\n#endif\n  return 0;\n}", "target": 1, "idx": 10006}
{"commit_id": "43ea0649d4b70fdcf3e9fa5c03aee1bbba0b04bb", "project": "chromium", "func": "void ImageDocumentParser::finish()\n{\n    if (!isStopped() && document()->imageElement() && document()->cachedImage()) {\n        ImageResource* cachedImage = document()->cachedImage();\n        DocumentLoader* loader = document()->loader();\n        cachedImage->setResponse(loader->response());\n        cachedImage->setLoadFinishTime(loader->timing().responseEnd());\n        cachedImage->finish();\n\n        // Report the natural image size in the page title, regardless of zoom level.\n        // At a zoom level of 1 the image is guaranteed to have an integer size.\n        IntSize size = flooredIntSize(cachedImage->imageSize(LayoutObject::shouldRespectImageOrientation(document()->imageElement()->layoutObject()), 1.0f));\n        if (size.width()) {\n            // Compute the title, we use the decoded filename of the resource, falling\n            // back on the (decoded) hostname if there is no path.\n            String fileName = decodeURLEscapeSequences(document()->url().lastPathComponent());\n            if (fileName.isEmpty())\n                fileName = document()->url().host();\n            document()->setTitle(imageTitle(fileName, size));\n            if (isDetached())\n                return;\n        }\n\n        document()->imageUpdated();\n    }\n\n    if (!isDetached())\n        document()->finishedParsing();\n}", "target": 2, "idx": 10007}
{"commit_id": "8be9da8280dfa69d5df4417d4d81bda1cab78010", "project": "upx", "func": "void const *\nPackLinuxElf32::elf_find_dynamic(unsigned int key) const\n{\n    Elf32_Dyn const *dynp= dynseg;\n    if (dynp)\n    for (; (unsigned)((char const *)dynp - (char const *)dynseg) < sz_dynseg\n            && Elf32_Dyn::DT_NULL!=dynp->d_tag; ++dynp) if (get_te32(&dynp->d_tag)==key) {\n        unsigned const t= elf_get_offset_from_address(get_te32(&dynp->d_val));\n        if (t && t < file_size) {\n            return t + file_image;\n        }\n        break;\n    }\n    return 0;\n}", "target": 1, "idx": 10008}
{"commit_id": "81af26364c21c196dd21fb5e14c7fa9ce7debd17", "project": "nginx/njs", "func": "njs_int_t\nnjs_array_convert_to_slow_array(njs_vm_t *vm, njs_array_t *array)\n{\n    uint32_t           i, length;\n    njs_value_t        index, value;\n    njs_object_prop_t  *prop;\n\n    if (njs_slow_path(!array->object.fast_array)) {\n        return NJS_OK;\n    }\n\n    njs_set_array(&value, array);\n    array->object.fast_array = 0;\n\n    length = array->length;\n\n    for (i = 0; i < length; i++) {\n        if (njs_is_valid(&array->start[i])) {\n            njs_uint32_to_string(&index, i);\n            prop = njs_object_property_add(vm, &value, &index, 0);\n            if (njs_slow_path(prop == NULL)) {\n                return NJS_ERROR;\n            }\n\n            prop->value = array->start[i];\n        }\n    }\n\n    /* GC: release value. */\n\n    njs_mp_free(vm->mem_pool, array->start);\n    array->start = NULL;\n\n    return NJS_OK;\n}", "target": 1, "idx": 10009}
{"commit_id": "c70f49dda4946d6db6aa55588f6a756b76bd84ea", "project": "gpac", "func": "static\nu32 UpdateRuns(GF_ISOFile *movie, GF_TrackFragmentBox *traf)\n{\n\tu32 sampleCount, i, j, RunSize, RunDur, RunFlags, NeedFlags, UseCTS;\n\t/* enum:\n\t   0 - use values per sample in the trun box\n\t   1 - use default values from track fragment header\n\t   2 - use default values from track extends header */\n\tu32 UseDefaultSize, UseDefaultDur, UseDefaultFlag;\n\tGF_TrackFragmentRunBox *trun;\n\tGF_TrunEntry *ent;\n\n\tsampleCount = 0;\n\n#ifndef USE_BASE_DATA_OFFSET\n\tif (movie->use_segments) {\n\t\ttraf->tfhd->flags = GF_ISOM_MOOF_BASE_OFFSET;\n\t} else\n#endif\n\t{\n\t\tif (movie->force_moof_base_offset) {\n\t\t\ttraf->tfhd->flags = GF_ISOM_MOOF_BASE_OFFSET;\n\t\t} else {\n\t\t\ttraf->tfhd->flags = GF_ISOM_TRAF_BASE_OFFSET;\n\t\t}\n\t}\n\n\t//empty runs\n\tif (traf->tfhd->EmptyDuration) {\n\t\twhile (gf_list_count(traf->TrackRuns)) {\n\t\t\ttrun = (GF_TrackFragmentRunBox *)gf_list_get(traf->TrackRuns, 0);\n\t\t\tgf_list_rem(traf->TrackRuns, 0);\n\t\t\tgf_list_del_item(movie->moof->trun_list, trun);\n\t\t\tgf_isom_box_del_parent(&traf->child_boxes, (GF_Box *)trun);\n\t\t}\n\t\ttraf->tfhd->flags |= GF_ISOM_TRAF_DUR_EMPTY;\n\t\tif (traf->tfhd->EmptyDuration != traf->trex->def_sample_duration) {\n\t\t\ttraf->tfhd->def_sample_duration = traf->tfhd->EmptyDuration;\n\t\t\ttraf->tfhd->flags |= GF_ISOM_TRAF_SAMPLE_DUR;\n\t\t}\n\t\treturn 0;\n\t}\n\n\n\tUseDefaultSize = 0;\n\tUseDefaultDur = 0;\n\tUseDefaultFlag = 0;\n\n\ti=0;\n\twhile ((trun = (GF_TrackFragmentRunBox *)gf_list_enum(traf->TrackRuns, &i))) {\n\t\tGF_TrunEntry *first_ent = NULL;\n\t\tRunSize = 0;\n\t\tRunDur = 0;\n\t\tRunFlags = 0;\n\t\tUseCTS = 0;\n\t\tNeedFlags = 0;\n\n\t\t//process all samples in run\n\t\tfor (j=0; j<trun->nb_samples; j++) {\n\t\t\tent = &trun->samples[j];\n\t\t\tif (!j) {\n\t\t\t\tfirst_ent = ent;\n\t\t\t\tRunSize = ent->size;\n\t\t\t\tif (ent->nb_pack) RunSize /= ent->nb_pack;\n\t\t\t\tRunDur = ent->Duration;\n\t\t\t}\n\t\t\t//we may have one entry only ...\n\t\t\tif (j || (trun->nb_samples==1)) {\n\t\t\t\tu32 ssize = ent->size;\n\t\t\t\tif (ent->nb_pack) ssize /= ent->nb_pack;\n\n\t\t\t\t//flags are only after first entry\n\t\t\t\tif (j==1 || (trun->nb_samples==1) ) RunFlags = ent->flags;\n\n\t\t\t\tif (ssize != RunSize) RunSize = 0;\n\t\t\t\tif (RunDur && (ent->Duration != RunDur))\n\t\t\t\t\tRunDur = 0;\n\t\t\t\tif (j && (RunFlags != ent->flags)) NeedFlags = 1;\n\t\t\t}\n\t\t\tif (ent->CTS_Offset) UseCTS = 1;\n\t\t}\n\t\t//empty list\n\t\tif (!first_ent) {\n\t\t\ti--;\n\t\t\tgf_list_rem(traf->TrackRuns, i);\n\t\t\tgf_list_del_item(movie->moof->trun_list, trun);\n\t\t\tcontinue;\n\t\t}\n\t\ttrun->flags = 0;\n\n\t\t//size checking\n\t\t//constant size, check if this is from current fragment default or global default\n\t\tif (RunSize && (traf->trex->def_sample_size == RunSize) && !traf->trex->cannot_use_default) {\n\t\t\tif (!UseDefaultSize) UseDefaultSize = 2;\n\t\t\telse if (UseDefaultSize==1) RunSize = 0;\n\t\t} else if (RunSize && (traf->tfhd->def_sample_size == RunSize)) {\n\t\t\tif (!UseDefaultSize) UseDefaultSize = 1;\n\t\t\telse if (UseDefaultSize==2) RunSize = 0;\n\t\t}\n\t\t//we could check for single entry runs and set the default size in the tfhd but\n\t\t//that's no bit saving...\n\t\telse {\n\t\t\tRunSize=0;\n\t\t}\n\n\t\tif (!RunSize) trun->flags |= GF_ISOM_TRUN_SIZE;\n\n\t\t//duration checking\n\t\tif (RunDur && (traf->trex->def_sample_duration == RunDur) && !traf->trex->cannot_use_default) {\n\t\t\tif (!UseDefaultDur) UseDefaultDur = 2;\n\t\t\telse if (UseDefaultDur==1) RunDur = 0;\n\t\t} else if (RunDur && (traf->tfhd->def_sample_duration == RunDur)) {\n\t\t\tif (!UseDefaultDur) UseDefaultDur = 1;\n\t\t\telse if (UseDefaultDur==2) RunDur = 0;\n\t\t}\n\t\tif (!RunDur) trun->flags |= GF_ISOM_TRUN_DURATION;\n\n\t\t//flag checking\n\t\tif (!NeedFlags) {\n\t\t\t// all samples flags are the same after the 2nd entry\n\t\t\tif (RunFlags == traf->trex->def_sample_flags && !traf->trex->cannot_use_default) {\n\t\t\t\t/* this run can use trex flags */\n\t\t\t\tif (!UseDefaultFlag) {\n\t\t\t\t\t/* if all previous runs used explicit flags per sample, we can still use trex flags for this run */\n\t\t\t\t\tUseDefaultFlag = 2;\n\t\t\t\t} else if (UseDefaultFlag==1) {\n\t\t\t\t\t/* otherwise if one of the previous runs did use tfhd flags,\n\t\t\t\t\twe have no choice but to explicitly use flags per sample for this run */\n\t\t\t\t\tNeedFlags = GF_TRUE;\n\t\t\t\t}\n\t\t\t} else if (RunFlags == traf->tfhd->def_sample_flags) {\n\t\t\t\t/* this run can use tfhd flags */\n\t\t\t\tif (!UseDefaultFlag) {\n\t\t\t\t\t/* if all previous runs used explicit flags per sample, we can still use tfhd flags for this run */\n\t\t\t\t\tUseDefaultFlag = 1;\n\t\t\t\t} else if(UseDefaultFlag==2) {\n\t\t\t\t\t/* otherwise if one of the previous runs did use trex flags,\n\t\t\t\t\twe have no choice but to explicitly use flags per sample for this run */\n\t\t\t\t\tNeedFlags = GF_TRUE;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* the flags for the 2nd and following entries are different from trex and tfhd default values\n\t\t\t\t   (possible case: 2 samples in trun, and first sample was used to set default flags) */\n\t\t\t\tNeedFlags = GF_TRUE;\n\t\t\t}\n\t\t}\n\t\tif (NeedFlags) {\n\t\t\t//one flags entry per sample only\n\t\t\ttrun->flags |= GF_ISOM_TRUN_FLAGS;\n\t\t} else {\n\t\t\t/* this run can use default flags for the 2nd and following entries,\n\t\t\t   we just need to check if the first entry flags need to be singled out*/\n\t\t\tif (first_ent->flags != RunFlags) {\n\t\t\t\ttrun->flags |= GF_ISOM_TRUN_FIRST_FLAG;\n\t\t\t\t//if not old arch write the flags\n\t\t\t\t//in old arch we write 0, which means all deps unknown and sync sample set\n\t\t\t\tif (!traf->no_sdtp_first_flags)\n\t\t\t\t\ttrun->first_sample_flags = first_ent->flags;\n\t\t\t}\n\t\t}\n\n\t\t//CTS flag\n\t\tif (UseCTS) trun->flags |= GF_ISOM_TRUN_CTS_OFFSET;\n\n\t\t//run data offset if the offset indicated is 0 (first sample in this MDAT) don't\n\t\t//indicate it\n\t\tif (trun->data_offset)\n\t\t\ttrun->flags |= GF_ISOM_TRUN_DATA_OFFSET;\n\n\t\tsampleCount += trun->sample_count;\n\t}\n\n\t//after all runs in the traf are processed, update TRAF flags\n\tif (UseDefaultSize==1)\n\t\ttraf->tfhd->flags |= GF_ISOM_TRAF_SAMPLE_SIZE;\n\tif (UseDefaultDur==1)\n\t\ttraf->tfhd->flags |= GF_ISOM_TRAF_SAMPLE_DUR;\n\tif (UseDefaultFlag==1)\n\t\ttraf->tfhd->flags |= GF_ISOM_TRAF_SAMPLE_FLAGS;\n\tif (traf->trex->cannot_use_default || (traf->tfhd->sample_desc_index != traf->trex->def_sample_desc_index))\n\t\ttraf->tfhd->flags |= GF_ISOM_TRAF_SAMPLE_DESC;\n\n\n\treturn sampleCount;\n}", "target": 2, "idx": 10010}
{"commit_id": "4d45a96e57fbabf00a7378b337d0ddcace6f38c1", "project": "ArtifexSoftware/mujs", "func": "static js_Ast *bitor(js_State *J, int notin)\n{\n\tjs_Ast *a = bitxor(J, notin);\n\tSAVEREC();\n\twhile (jsP_accept(J, '|')) {\n\t\tINCREC();\n\t\ta = EXP2(BITOR, a, bitxor(J, notin));\n\t}\n\tPOPREC();\n\treturn a;\n}", "target": 1, "idx": 10011}
{"commit_id": "1b3105a132b925a1d300c2f03b3cd213875ffca8", "project": "WebAssembly/wabt", "func": "Result BinaryReaderIR::TopLabelExpr(LabelNode** label, Expr** expr) {\n  CHECK_RESULT(TopLabel(label));\n  LabelNode* parent_label;\n  CHECK_RESULT(GetLabelAt(&parent_label, 1));\n  if (parent_label->exprs->empty()) {\n    PrintError(\"TopLabelExpr: parent label has empty expr list\");\n    return Result::Error;\n  }\n  *expr = &parent_label->exprs->back();\n  return Result::Ok;\n}", "target": 2, "idx": 10012}
{"commit_id": "faf47b94e24314d74907f3f6bc874105f2c962ed", "project": "ArtifexSoftware/mupdf", "func": "static fz_page *\nsvg_load_page(fz_context *ctx, fz_document *doc_, int number)\n{\n\tsvg_document *doc = (svg_document*)doc_;\n\tsvg_page *page;\n\n\tif (number != 0)\n\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"cannot find page %d\", number);\n\n\tpage = fz_new_derived_page(ctx, svg_page);\n\tpage->super.bound_page = svg_bound_page;\n\tpage->super.run_page_contents = svg_run_page;\n\tpage->super.drop_page = svg_drop_page;\n\tpage->doc = doc;\n\n\treturn (fz_page*)page;\n}", "target": 1, "idx": 10013}
{"commit_id": "f5da52e308a6aeea6d5f3df98c4da295d7e9cc27", "project": "openssl", "func": "int asn1_ex_c2i(ASN1_VALUE **pval, const unsigned char *cont, int len,\n                int utype, char *free_cont, const ASN1_ITEM *it)\n{\n    ASN1_VALUE **opval = NULL;\n    ASN1_STRING *stmp;\n    ASN1_TYPE *typ = NULL;\n    int ret = 0;\n    const ASN1_PRIMITIVE_FUNCS *pf;\n    ASN1_INTEGER **tint;\n    pf = it->funcs;\n\n    if (pf && pf->prim_c2i)\n        return pf->prim_c2i(pval, cont, len, utype, free_cont, it);\n    /* If ANY type clear type and set pointer to internal value */\n    if (it->utype == V_ASN1_ANY) {\n        if (!*pval) {\n            typ = ASN1_TYPE_new();\n            if (typ == NULL)\n                goto err;\n            *pval = (ASN1_VALUE *)typ;\n        } else\n            typ = (ASN1_TYPE *)*pval;\n\n        if (utype != typ->type)\n            ASN1_TYPE_set(typ, utype, NULL);\n        opval = pval;\n        pval = &typ->value.asn1_value;\n    }\n    switch (utype) {\n    case V_ASN1_OBJECT:\n        if (!c2i_ASN1_OBJECT((ASN1_OBJECT **)pval, &cont, len))\n            goto err;\n        break;\n\n    case V_ASN1_NULL:\n        if (len) {\n            ASN1err(ASN1_F_ASN1_EX_C2I, ASN1_R_NULL_IS_WRONG_LENGTH);\n            goto err;\n        }\n        *pval = (ASN1_VALUE *)1;\n        break;\n\n    case V_ASN1_BOOLEAN:\n        if (len != 1) {\n            ASN1err(ASN1_F_ASN1_EX_C2I, ASN1_R_BOOLEAN_IS_WRONG_LENGTH);\n            goto err;\n        } else {\n            ASN1_BOOLEAN *tbool;\n            tbool = (ASN1_BOOLEAN *)pval;\n            *tbool = *cont;\n        }\n        break;\n\n    case V_ASN1_BIT_STRING:\n        if (!c2i_ASN1_BIT_STRING((ASN1_BIT_STRING **)pval, &cont, len))\n            goto err;\n        break;\n\n    case V_ASN1_INTEGER:\n    case V_ASN1_ENUMERATED:\n        tint = (ASN1_INTEGER **)pval;\n        if (!c2i_ASN1_INTEGER(tint, &cont, len))\n            goto err;\n        /* Fixup type to match the expected form */\n        (*tint)->type = utype | ((*tint)->type & V_ASN1_NEG);\n        break;\n\n    case V_ASN1_OCTET_STRING:\n    case V_ASN1_NUMERICSTRING:\n    case V_ASN1_PRINTABLESTRING:\n    case V_ASN1_T61STRING:\n    case V_ASN1_VIDEOTEXSTRING:\n    case V_ASN1_IA5STRING:\n    case V_ASN1_UTCTIME:\n    case V_ASN1_GENERALIZEDTIME:\n    case V_ASN1_GRAPHICSTRING:\n    case V_ASN1_VISIBLESTRING:\n    case V_ASN1_GENERALSTRING:\n    case V_ASN1_UNIVERSALSTRING:\n    case V_ASN1_BMPSTRING:\n    case V_ASN1_UTF8STRING:\n    case V_ASN1_OTHER:\n    case V_ASN1_SET:\n    case V_ASN1_SEQUENCE:\n    default:\n        if (utype == V_ASN1_BMPSTRING && (len & 1)) {\n            ASN1err(ASN1_F_ASN1_EX_C2I, ASN1_R_BMPSTRING_IS_WRONG_LENGTH);\n            goto err;\n        }\n        if (utype == V_ASN1_UNIVERSALSTRING && (len & 3)) {\n            ASN1err(ASN1_F_ASN1_EX_C2I,\n                    ASN1_R_UNIVERSALSTRING_IS_WRONG_LENGTH);\n            goto err;\n        }\n        /* All based on ASN1_STRING and handled the same */\n        if (!*pval) {\n            stmp = ASN1_STRING_type_new(utype);\n            if (!stmp) {\n                ASN1err(ASN1_F_ASN1_EX_C2I, ERR_R_MALLOC_FAILURE);\n                goto err;\n            }\n            *pval = (ASN1_VALUE *)stmp;\n        } else {\n            stmp = (ASN1_STRING *)*pval;\n            stmp->type = utype;\n        }\n        /* If we've already allocated a buffer use it */\n        if (*free_cont) {\n            if (stmp->data)\n                OPENSSL_free(stmp->data);\n            stmp->data = (unsigned char *)cont; /* UGLY CAST! RL */\n            stmp->length = len;\n            *free_cont = 0;\n        } else {\n            if (!ASN1_STRING_set(stmp, cont, len)) {\n                ASN1err(ASN1_F_ASN1_EX_C2I, ERR_R_MALLOC_FAILURE);\n                ASN1_STRING_free(stmp);\n                *pval = NULL;\n                goto err;\n            }\n        }\n        break;\n    }\n    /* If ASN1_ANY and NULL type fix up value */\n    if (typ && (utype == V_ASN1_NULL))\n        typ->value.ptr = NULL;\n\n    ret = 1;\n err:\n    if (!ret) {\n        ASN1_TYPE_free(typ);\n        if (opval)\n            *opval = NULL;\n    }\n    return ret;\n}", "target": 3, "idx": 10014}
{"commit_id": "7f50591861525f76e3ec7a63392656ff8c030af9", "project": "ArtifexSoftware/mujs", "func": "Reprog *regcompx(void *(*alloc)(void *ctx, void *p, int n), void *ctx,\n\tconst char *pattern, int cflags, const char **errorp)\n{\n\tstruct cstate g;\n\tRenode *node;\n\tReinst *split, *jump;\n\tint i, n;\n\n\tg.pstart = NULL;\n\tg.prog = NULL;\n\n\tif (setjmp(g.kaboom)) {\n\t\tif (errorp) *errorp = g.error;\n\t\talloc(ctx, g.pstart, 0);\n\t\talloc(ctx, g.prog, 0);\n\t\treturn NULL;\n\t}\n\n\tg.prog = alloc(ctx, NULL, sizeof (Reprog));\n\tif (!g.prog)\n\t\tdie(&g, \"cannot allocate regular expression\");\n\tn = strlen(pattern) * 2;\n\tif (n > MAXPROG)\n\t\tdie(&g, \"program too large\");\n\tif (n > 0) {\n\t\tg.pstart = g.pend = alloc(ctx, NULL, sizeof (Renode) * n);\n\t\tif (!g.pstart)\n\t\t\tdie(&g, \"cannot allocate regular expression parse list\");\n\t}\n\n\tg.source = pattern;\n\tg.ncclass = 0;\n\tg.nsub = 1;\n\tfor (i = 0; i < MAXSUB; ++i)\n\t\tg.sub[i] = 0;\n\n\tg.prog->flags = cflags;\n\n\tnext(&g);\n\tnode = parsealt(&g);\n\tif (g.lookahead == ')')\n\t\tdie(&g, \"unmatched ')'\");\n\tif (g.lookahead != 0)\n\t\tdie(&g, \"syntax error\");\n\n#ifdef TEST\n\tdumpnode(node);\n\tputchar('\\n');\n#endif\n\n\tn = 6 + count(&g, node);\n\tif (n < 0 || n > MAXPROG)\n\t\tdie(&g, \"program too large\");\n\n\tg.prog->nsub = g.nsub;\n\tg.prog->start = g.prog->end = alloc(ctx, NULL, n * sizeof (Reinst));\n\tif (!g.prog->start)\n\t\tdie(&g, \"cannot allocate regular expression instruction list\");\n\n\tsplit = emit(g.prog, I_SPLIT);\n\tsplit->x = split + 3;\n\tsplit->y = split + 1;\n\temit(g.prog, I_ANYNL);\n\tjump = emit(g.prog, I_JUMP);\n\tjump->x = split;\n\temit(g.prog, I_LPAR);\n\tcompile(g.prog, node);\n\temit(g.prog, I_RPAR);\n\temit(g.prog, I_END);\n\n#ifdef TEST\n\tdumpprog(g.prog);\n#endif\n\n\talloc(ctx, g.pstart, 0);\n\n\tif (errorp) *errorp = NULL;\n\treturn g.prog;\n}", "target": 3, "idx": 10015}
{"commit_id": "1773b7a34bc08734aee7d3f5dfe65d06389fe15a", "project": "gpac", "func": "GF_Err gp_rtp_builder_do_vvc(GP_RTPPacketizer *builder, u8 *nalu, u32 nalu_size, u8 IsAUEnd, u32 FullAUSize)\n{\n\tu32 do_flush, bytesLeft, size;\n\n\tdo_flush = 0;\n\tif (!nalu) do_flush = 1;\n\telse if (builder->sl_header.accessUnitStartFlag) do_flush = 1;\n\t/*we must NOT fragment a NALU*/\n\telse if (builder->bytesInPacket + nalu_size + 4 >= builder->Path_MTU) do_flush = 2; //2 bytes PayloadHdr for AP + 2 bytes NAL size\n\t/*aggregation is disabled*/\n\telse if (! (builder->flags & GP_RTP_PCK_USE_MULTI) ) do_flush = 2;\n\n\tif (builder->bytesInPacket && do_flush) {\n\t\tbuilder->rtp_header.Marker = (do_flush==1) ? 1 : 0;\n\t\t/*insert payload_hdr in case of AP*/\n\t\tif (strlen(builder->hevc_payload_hdr)) {\n\t\t\tbuilder->OnData(builder->cbk_obj, (char *)builder->hevc_payload_hdr, 2, GF_TRUE);\n\t\t\tmemset(builder->hevc_payload_hdr, 0, 2);\n\t\t}\n\t\tbuilder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);\n\t\tbuilder->bytesInPacket = 0;\n\t}\n\n\tif (!nalu) return GF_OK;\n\tif (nalu_size<2) return GF_NON_COMPLIANT_BITSTREAM;\n\n\t/*need a new RTP packet*/\n\tif (!builder->bytesInPacket) {\n\t\tbuilder->rtp_header.PayloadType = builder->PayloadType;\n\t\tbuilder->rtp_header.TimeStamp = (u32) builder->sl_header.compositionTimeStamp;\n\t\tbuilder->rtp_header.SequenceNumber += 1;\n\t\tbuilder->OnNewPacket(builder->cbk_obj, &builder->rtp_header);\n\t}\n\n\t/*at this point we're sure the NALU fits in current packet OR must be splitted*/\n\t/*check that we should use single NALU packet mode or aggreation packets mode*/\n\tif (builder->bytesInPacket+nalu_size+4 < builder->Path_MTU) {\n\t\tBool use_AP = (builder->flags & GP_RTP_PCK_USE_MULTI) ? GF_TRUE : GF_FALSE;\n\t\t/*if this is the AU end and no NALU in packet, go for single NALU packet mode*/\n\t\tif (IsAUEnd && !builder->bytesInPacket) use_AP = GF_FALSE;\n\n\t\tif (use_AP) {\n\t\t\tchar nal_s[2];\n\t\t\t/*declare PayloadHdr for AP*/\n\t\t\tif (!builder->bytesInPacket) {\n\t\t\t\t//copy everything, reassign type (byte 1 bits 8-3)\n\t\t\t\tbuilder->hevc_payload_hdr[0] = nalu[0];\n\t\t\t\tbuilder->hevc_payload_hdr[1] = (RTP_VVC_AGG_NAL << 3) | (nalu[1] & 0x7);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/*F bit of AP is 0 if the F bit of each aggreated NALU is 0; otherwise its must be 1*/\n\t\t\t\t/*LayerId and TID must be the lowest value of LayerId and TID of all aggreated NALU*/\n\t\t\t\tu8 cur_LayerId, cur_TID, new_LayerId, new_TID;\n\n\t\t\t\tbuilder->hevc_payload_hdr[0] |= (nalu[0] & 0x80);\n\t\t\t\tcur_LayerId = (builder->hevc_payload_hdr[0] & 0x3F);\n\t\t\t\tnew_LayerId = (nalu[0] & 0x3F);\n\t\t\t\tif (cur_LayerId > new_LayerId) {\n\t\t\t\t\tbuilder->hevc_payload_hdr[0] = (builder->hevc_payload_hdr[0] & 0xC0) | new_LayerId;\n\t\t\t\t}\n\t\t\t\tcur_TID = builder->hevc_payload_hdr[1] & 0x3;\n\t\t\t\tnew_TID = nalu[1] & 0x3;\n\t\t\t\tif (cur_TID > new_TID) {\n\t\t\t\t\tbuilder->hevc_payload_hdr[1] = (builder->hevc_payload_hdr[1] & 0xF8) | new_TID;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*add NALU size*/\n\t\t\tnal_s[0] = nalu_size>>8;\n\t\t\tnal_s[1] = nalu_size&0x00ff;\n\t\t\tbuilder->OnData(builder->cbk_obj, (char *)nal_s, 2, GF_FALSE);\n\t\t\tbuilder->bytesInPacket += 2;\n\t\t}\n\t\t/*add data*/\n\t\tif (builder->OnDataReference)\n\t\t\tbuilder->OnDataReference(builder->cbk_obj, nalu_size, 0);\n\t\telse\n\t\t\tbuilder->OnData(builder->cbk_obj, nalu, nalu_size, GF_FALSE);\n\n\t\tbuilder->bytesInPacket += nalu_size;\n\n\t\tif (IsAUEnd) {\n\t\t\tbuilder->rtp_header.Marker = 1;\n\t\t\tif (strlen(builder->hevc_payload_hdr)) {\n\t\t\t\tbuilder->OnData(builder->cbk_obj, (char *)builder->hevc_payload_hdr, 2, GF_TRUE);\n\t\t\t\tmemset(builder->hevc_payload_hdr, 0, 2);\n\t\t\t}\n\t\t\tbuilder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);\n\t\t\tbuilder->bytesInPacket = 0;\n\t\t}\n\t}\n\t/*fragmentation unit*/\n\telse {\n\t\tu32 offset;\n\t\tu8 payload_hdr[2];\n\t\tu8 shdr;\n\n\t\tassert(nalu_size + 4 >=builder->Path_MTU);\n\t\tassert(!builder->bytesInPacket);\n\n\t\t/*FU payload doesn't have the NAL hdr (2 bytes*/\n\t\tbytesLeft = nalu_size - 2;\n\t\toffset = 2;\n\t\twhile (bytesLeft) {\n\t\t\tu8 nut;\n\n\t\t\tif (3 + bytesLeft > builder->Path_MTU) {\n\t\t\t\tsize = builder->Path_MTU - 3;\n\t\t\t} else {\n\t\t\t\tsize = bytesLeft;\n\t\t\t}\n\n\t\t\t/*declare PayloadHdr for FU*/\n\t\t\tmemset(payload_hdr, 0, 2);\n\t\t\t/*copy everything and assign type*/\n\t\t\tpayload_hdr[0] = nalu[0];\n\t\t\tpayload_hdr[1] = (((u32) RTP_VVC_FRAG_NAL) << 3) | (nalu[1] & 0x7);\n\t\t\tbuilder->OnData(builder->cbk_obj, (char *)payload_hdr, 2, GF_FALSE);\n\n\t\t\tnut = nalu[1] >> 3;\n\t\t\t/*declare FU header*/\n\t\t\tshdr = 0;\n\t\t\t/*assign type*/\n\t\t\tshdr |= nut;\n\t\t\t/*start bit*/\n\t\t\tif (offset==2) shdr |= 0x80;\n\t\t\t/*end bit*/\n\t\t\telse if (size == bytesLeft) {\n\t\t\t\tshdr |= 0x40;\n\t\t\t\t//VCL, last packet of picture, set P bit\n\t\t\t\tif (nut <= GF_VVC_NALU_SLICE_GDR) {\n\t\t\t\t\tshdr |= 0x20;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbuilder->OnData(builder->cbk_obj, &shdr, 1, GF_FALSE);\n\n\t\t\t/*add data*/\n\t\t\tif (builder->OnDataReference)\n\t\t\t\tbuilder->OnDataReference(builder->cbk_obj, size, offset);\n\t\t\telse\n\t\t\t\tbuilder->OnData(builder->cbk_obj, nalu+offset, size, GF_FALSE);\n\n\t\t\toffset += size;\n\t\t\tbytesLeft -= size;\n\n\t\t\t/*flush no matter what (FUs cannot be agreggated)*/\n\t\t\tbuilder->rtp_header.Marker = (IsAUEnd && !bytesLeft) ? 1 : 0;\n\t\t\tbuilder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);\n\t\t\tbuilder->bytesInPacket = 0;\n\n\t\t\tif (bytesLeft) {\n\t\t\t\tbuilder->rtp_header.PayloadType = builder->PayloadType;\n\t\t\t\tbuilder->rtp_header.TimeStamp = (u32) builder->sl_header.compositionTimeStamp;\n\t\t\t\tbuilder->rtp_header.SequenceNumber += 1;\n\t\t\t\tbuilder->OnNewPacket(builder->cbk_obj, &builder->rtp_header);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}", "target": 1, "idx": 10016}
{"commit_id": "c5f30c70e48786e1aef8c815f35e406a6c4fb3ae", "project": "Samsung/mTower", "func": "TEE_Result tee_ta_init_pseudo_ta_session(const TEE_UUID *uuid,\n\t\t\tstruct tee_ta_session *s)\n{\n\tstruct pseudo_ta_ctx *stc = NULL;\n\tstruct tee_ta_ctx *ctx;\n\tconst struct pseudo_ta_head *ta;\n\n  DMSG(\"Lookup pseudo TA %pUl\", (void *)uuid);\n\n\tta = &__start_ta_head_section;\n\twhile (true) {\n\t\tif (ta >= &__stop_ta_head_section)\n\t\t\treturn TEE_ERROR_ITEM_NOT_FOUND;\n//    uuid_print(&ta->uuid);\n//    uuid_print(uuid);\n\t\tif (memcmp(&ta->uuid, uuid, sizeof(TEE_UUID)) == 0)\n\t\t\tbreak;\n\t\tta++;\n\t}\n\n\t/* Load a new TA and create a session */\n\tDMSG(\"Open %s\", ta->name);\n\t// stc = calloc(1, sizeof(struct pseudo_ta_ctx));\n\tstc = TEE_Malloc(sizeof(struct pseudo_ta_ctx), TEE_MALLOC_FILL_ZERO);\n\tif (!stc)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tctx = &stc->ctx;\n\n//\tctx->ref_count = 1;\n\ts->ctx = ctx;\n\tctx->flags = ta->flags;\n\tstc->pseudo_ta = ta;\n\tctx->uuid = ta->uuid;\n\tctx->ops = &pseudo_ta_ops;\n\tTAILQ_INSERT_TAIL(&tee_ctxes, ctx, link);\n\n\tDMSG(\"%s : %pUl\", stc->pseudo_ta->name, (void *)&ctx->uuid);\n\n\treturn TEE_SUCCESS;\n}", "target": 2, "idx": 10017}
{"commit_id": "f93083be72a3b3d956b52a7ec13f307a27b6e093", "project": "wolfSSL/wolfssl", "func": "static int DecodeBasicOcspResponse(byte* source, word32* ioIndex,\n            OcspResponse* resp, word32 size, void* cm, void* heap, int noVerify)\n{\n    int    length;\n    word32 idx = *ioIndex;\n    word32 end_index;\n    int    ret;\n    int    sigLength;\n\n    WOLFSSL_ENTER(\"DecodeBasicOcspResponse\");\n    (void)heap;\n\n    if (GetSequence(source, &idx, &length, size) < 0)\n        return ASN_PARSE_E;\n\n    if (idx + length > size)\n        return ASN_INPUT_E;\n    end_index = idx + length;\n\n    if ((ret = DecodeResponseData(source, &idx, resp, size)) < 0)\n        return ret; /* ASN_PARSE_E, ASN_BEFORE_DATE_E, ASN_AFTER_DATE_E */\n\n    /* Get the signature algorithm */\n    if (GetAlgoId(source, &idx, &resp->sigOID, oidSigType, size) < 0)\n        return ASN_PARSE_E;\n\n    ret = CheckBitString(source, &idx, &sigLength, size, 1, NULL);\n    if (ret != 0)\n        return ret;\n\n    resp->sigSz = sigLength;\n    resp->sig = source + idx;\n    idx += sigLength;\n\n    /*\n     * Check the length of the BasicOcspResponse against the current index to\n     * see if there are certificates, they are optional.\n     */\n#ifndef WOLFSSL_NO_OCSP_OPTIONAL_CERTS\n    if (idx < end_index)\n    {\n        DecodedCert cert;\n\n        if (DecodeCerts(source, &idx, resp, size) < 0)\n            return ASN_PARSE_E;\n\n        InitDecodedCert(&cert, resp->cert, resp->certSz, heap);\n\n        /* Don't verify if we don't have access to Cert Manager. */\n        ret = ParseCertRelative(&cert, CERT_TYPE,\n                                noVerify ? NO_VERIFY : VERIFY_OCSP_CERT, cm);\n        if (ret < 0) {\n            WOLFSSL_MSG(\"\\tOCSP Responder certificate parsing failed\");\n            FreeDecodedCert(&cert);\n            return ret;\n        }\n\n#ifndef WOLFSSL_NO_OCSP_ISSUER_CHECK\n        if ((cert.extExtKeyUsage & EXTKEYUSE_OCSP_SIGN) == 0) {\n            if (XMEMCMP(cert.subjectHash,\n                        resp->single->issuerHash, OCSP_DIGEST_SIZE) == 0) {\n                WOLFSSL_MSG(\"\\tOCSP Response signed by issuer\");\n            }\n            else {\n                WOLFSSL_MSG(\"\\tOCSP Responder key usage check failed\");\n    #ifdef OPENSSL_EXTRA\n                resp->verifyError = OCSP_BAD_ISSUER;\n    #else\n                FreeDecodedCert(&cert);\n                return BAD_OCSP_RESPONDER;\n    #endif\n            }\n        }\n#endif\n\n        /* ConfirmSignature is blocking here */\n        ret = ConfirmSignature(&cert.sigCtx,\n            resp->response, resp->responseSz,\n            cert.publicKey, cert.pubKeySize, cert.keyOID,\n            resp->sig, resp->sigSz, resp->sigOID, NULL);\n\n        FreeDecodedCert(&cert);\n\n        if (ret != 0) {\n            WOLFSSL_MSG(\"\\tOCSP Confirm signature failed\");\n            return ASN_OCSP_CONFIRM_E;\n        }\n    }\n    else\n#endif /* WOLFSSL_NO_OCSP_OPTIONAL_CERTS */\n    {\n        Signer* ca;\n        int sigValid = -1;\n\n        #ifndef NO_SKID\n            ca = GetCA(cm, resp->single->issuerKeyHash);\n        #else\n            ca = GetCA(cm, resp->single->issuerHash);\n        #endif\n\n        if (ca) {\n            SignatureCtx sigCtx;\n            InitSignatureCtx(&sigCtx, heap, INVALID_DEVID);\n\n            /* ConfirmSignature is blocking here */\n            sigValid = ConfirmSignature(&sigCtx, resp->response,\n                resp->responseSz, ca->publicKey, ca->pubKeySize, ca->keyOID,\n                                resp->sig, resp->sigSz, resp->sigOID, NULL);\n        }\n        if (ca == NULL || sigValid != 0) {\n            WOLFSSL_MSG(\"\\tOCSP Confirm signature failed\");\n            return ASN_OCSP_CONFIRM_E;\n        }\n\n        (void)noVerify;\n    }\n\n    *ioIndex = idx;\n    return 0;\n}", "target": 1, "idx": 10018}
{"commit_id": "9bfab35522301794483f8f9ed60820bdec9be59e", "project": "neomutt", "func": "static int nntp_hcache_namer(const char *path, char *dest, size_t destlen)\n{\n  int count = snprintf(dest, destlen, \"%s.hcache\", path);\n\n  /* Strip out any directories in the path */\n  char *first = strchr(dest, '/');\n  char *last = strrchr(dest, '/');\n  if (first && last && (last > first))\n  {\n    memmove(first, last, strlen(last) + 1);\n    count -= (last - first);\n  }\n\n  return count;\n}", "target": 3, "idx": 10019}
{"commit_id": "b101a6bbd4f2181c360bd38e7683df4a03cba83e", "project": "php/php-src", "func": "static void zend_throw_or_error(int fetch_type, zend_class_entry *exception_ce, const char *format, ...) /* {{{ */\n{\n\tva_list va;\n\tchar *message = NULL;\n\n\tva_start(va, format);\n\tzend_vspprintf(&message, 0, format, va);\n\n\tif (fetch_type & ZEND_FETCH_CLASS_EXCEPTION) {\n\t\tzend_throw_error(exception_ce, \"%s\", message);\n\t} else {\n\t\tzend_error(E_ERROR, \"%s\", message);\n\t}\n\n\tefree(message);\n\tva_end(va);\n}", "target": 3, "idx": 10020}
{"commit_id": "4564a002bcb6094cc460bc0d5ddff9423fe6dd28", "project": "poppler", "func": "int main(int argc, char *argv[])\n///////////////////////////////////////////////////////////////////////////\n// Merge PDF files given by arguments 1 to argc-2 and write the result\n// to the file specified by argument argc-1.\n///////////////////////////////////////////////////////////////////////////\n{\n    int objectsCount = 0;\n    unsigned int numOffset = 0;\n    std::vector<Object> pages;\n    std::vector<unsigned int> offsets;\n    XRef *yRef, *countRef;\n    FILE *f;\n    OutStream *outStr;\n    int i;\n    int j, rootNum;\n    std::vector<PDFDoc *> docs;\n    int majorVersion = 0;\n    int minorVersion = 0;\n    char *fileName = argv[argc - 1];\n\n    const bool ok = parseArgs(argDesc, &argc, argv);\n    if (!ok || argc < 3 || printVersion || printHelp) {\n        fprintf(stderr, \"pdfunite version %s\\n\", PACKAGE_VERSION);\n        fprintf(stderr, \"%s\\n\", popplerCopyright);\n        fprintf(stderr, \"%s\\n\", xpdfCopyright);\n        if (!printVersion) {\n            printUsage(\"pdfunite\", \"<PDF-sourcefile-1>..<PDF-sourcefile-n> <PDF-destfile>\", argDesc);\n        }\n        if (printVersion || printHelp) {\n            return 0;\n        }\n        return 99;\n    }\n    globalParams = std::make_unique<GlobalParams>();\n\n    for (i = 1; i < argc - 1; i++) {\n        PDFDoc *doc = new PDFDoc(std::make_unique<GooString>(argv[i]));\n        if (doc->isOk() && !doc->isEncrypted() && doc->getXRef()->getCatalog().isDict()) {\n            docs.push_back(doc);\n            if (doc->getPDFMajorVersion() > majorVersion) {\n                majorVersion = doc->getPDFMajorVersion();\n                minorVersion = doc->getPDFMinorVersion();\n            } else if (doc->getPDFMajorVersion() == majorVersion) {\n                if (doc->getPDFMinorVersion() > minorVersion) {\n                    minorVersion = doc->getPDFMinorVersion();\n                }\n            }\n        } else if (doc->isOk()) {\n            if (doc->isEncrypted()) {\n                error(errUnimplemented, -1, \"Could not merge encrypted files ('{0:s}')\", argv[i]);\n                return -1;\n            } else if (!doc->getXRef()->getCatalog().isDict()) {\n                error(errSyntaxError, -1, \"XRef's Catalog is not a dictionary ('{0:s}')\", argv[i]);\n                return -1;\n            }\n        } else {\n            error(errSyntaxError, -1, \"Could not merge damaged documents ('{0:s}')\", argv[i]);\n            return -1;\n        }\n    }\n\n    if (!(f = fopen(fileName, \"wb\"))) {\n        error(errIO, -1, \"Could not open file '{0:s}'\", fileName);\n        return -1;\n    }\n    outStr = new FileOutStream(f, 0);\n\n    yRef = new XRef();\n    countRef = new XRef();\n    yRef->add(0, 65535, 0, false);\n    PDFDoc::writeHeader(outStr, majorVersion, minorVersion);\n\n    // handle OutputIntents, AcroForm, OCProperties & Names\n    Object intents;\n    Object names;\n    Object afObj;\n    Object ocObj;\n    if (docs.size() >= 1) {\n        Object catObj = docs[0]->getXRef()->getCatalog();\n        if (!catObj.isDict()) {\n            fclose(f);\n            delete yRef;\n            delete countRef;\n            delete outStr;\n            error(errSyntaxError, -1, \"XRef's Catalog is not a dictionary.\");\n            return -1;\n        }\n        Dict *catDict = catObj.getDict();\n        intents = catDict->lookup(\"OutputIntents\");\n        afObj = catDict->lookupNF(\"AcroForm\").copy();\n        Ref *refPage = docs[0]->getCatalog()->getPageRef(1);\n        if (!afObj.isNull() && refPage) {\n            docs[0]->markAcroForm(&afObj, yRef, countRef, 0, refPage->num, refPage->num);\n        }\n        ocObj = catDict->lookupNF(\"OCProperties\").copy();\n        if (!ocObj.isNull() && ocObj.isDict() && refPage) {\n            docs[0]->markPageObjects(ocObj.getDict(), yRef, countRef, 0, refPage->num, refPage->num);\n        }\n        names = catDict->lookup(\"Names\");\n        if (!names.isNull() && names.isDict() && refPage) {\n            docs[0]->markPageObjects(names.getDict(), yRef, countRef, 0, refPage->num, refPage->num);\n        }\n        if (intents.isArray() && intents.arrayGetLength() > 0) {\n            for (i = 1; i < (int)docs.size(); i++) {\n                Object pagecatObj = docs[i]->getXRef()->getCatalog();\n                Dict *pagecatDict = pagecatObj.getDict();\n                Object pageintents = pagecatDict->lookup(\"OutputIntents\");\n                if (pageintents.isArray() && pageintents.arrayGetLength() > 0) {\n                    for (j = intents.arrayGetLength() - 1; j >= 0; j--) {\n                        Object intent = intents.arrayGet(j, 0);\n                        if (intent.isDict()) {\n                            Object idf = intent.dictLookup(\"OutputConditionIdentifier\");\n                            if (idf.isString()) {\n                                const GooString *gidf = idf.getString();\n                                bool removeIntent = true;\n                                for (int k = 0; k < pageintents.arrayGetLength(); k++) {\n                                    Object pgintent = pageintents.arrayGet(k, 0);\n                                    if (pgintent.isDict()) {\n                                        Object pgidf = pgintent.dictLookup(\"OutputConditionIdentifier\");\n                                        if (pgidf.isString()) {\n                                            const GooString *gpgidf = pgidf.getString();\n                                            if (gpgidf->cmp(gidf) == 0) {\n                                                removeIntent = false;\n                                                break;\n                                            }\n                                        }\n                                    }\n                                }\n                                if (removeIntent) {\n                                    intents.arrayRemove(j);\n                                    error(errSyntaxWarning, -1, \"Output intent {0:s} missing in pdf {1:s}, removed\", gidf->c_str(), docs[i]->getFileName()->c_str());\n                                }\n                            } else {\n                                intents.arrayRemove(j);\n                                error(errSyntaxWarning, -1, \"Invalid output intent dict, missing required OutputConditionIdentifier\");\n                            }\n                        } else {\n                            intents.arrayRemove(j);\n                        }\n                    }\n                } else {\n                    error(errSyntaxWarning, -1, \"Output intents differs, remove them all\");\n                    break;\n                }\n            }\n        }\n        if (intents.isArray() && intents.arrayGetLength() > 0) {\n            for (j = intents.arrayGetLength() - 1; j >= 0; j--) {\n                Object intent = intents.arrayGet(j, 0);\n                if (intent.isDict()) {\n                    docs[0]->markPageObjects(intent.getDict(), yRef, countRef, numOffset, 0, 0);\n                } else {\n                    intents.arrayRemove(j);\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < (int)docs.size(); i++) {\n        for (j = 1; j <= docs[i]->getNumPages(); j++) {\n            if (!docs[i]->getCatalog()->getPage(j)) {\n                continue;\n            }\n\n            const PDFRectangle *cropBox = nullptr;\n            if (docs[i]->getCatalog()->getPage(j)->isCropped()) {\n                cropBox = docs[i]->getCatalog()->getPage(j)->getCropBox();\n            }\n            if (!docs[i]->replacePageDict(j, docs[i]->getCatalog()->getPage(j)->getRotate(), docs[i]->getCatalog()->getPage(j)->getMediaBox(), cropBox)) {\n                fclose(f);\n                delete yRef;\n                delete countRef;\n                delete outStr;\n                error(errSyntaxError, -1, \"PDFDoc::replacePageDict failed.\");\n                return -1;\n            }\n            Ref *refPage = docs[i]->getCatalog()->getPageRef(j);\n            Object page = docs[i]->getXRef()->fetch(*refPage);\n            Dict *pageDict = page.getDict();\n            Object *resDict = docs[i]->getCatalog()->getPage(j)->getResourceDictObject();\n            if (resDict->isDict()) {\n                pageDict->set(\"Resources\", resDict->copy());\n            }\n            pages.push_back(std::move(page));\n            offsets.push_back(numOffset);\n            docs[i]->markPageObjects(pageDict, yRef, countRef, numOffset, refPage->num, refPage->num);\n            Object annotsObj = pageDict->lookupNF(\"Annots\").copy();\n            if (!annotsObj.isNull()) {\n                docs[i]->markAnnotations(&annotsObj, yRef, countRef, numOffset, refPage->num, refPage->num);\n            }\n        }\n        Object pageCatObj = docs[i]->getXRef()->getCatalog();\n        if (!pageCatObj.isDict()) {\n            fclose(f);\n            delete yRef;\n            delete countRef;\n            delete outStr;\n            error(errSyntaxError, -1, \"XRef's Catalog is not a dictionary.\");\n            return -1;\n        }\n        Dict *pageCatDict = pageCatObj.getDict();\n        Object pageNames = pageCatDict->lookup(\"Names\");\n        if (!pageNames.isNull() && pageNames.isDict()) {\n            if (!names.isDict()) {\n                names = Object(new Dict(yRef));\n            }\n            doMergeNameDict(docs[i], yRef, countRef, 0, 0, names.getDict(), pageNames.getDict(), numOffset);\n        }\n        Object pageForm = pageCatDict->lookup(\"AcroForm\");\n        if (i > 0 && !pageForm.isNull() && pageForm.isDict()) {\n            if (afObj.isNull()) {\n                afObj = pageCatDict->lookupNF(\"AcroForm\").copy();\n            } else if (afObj.isDict()) {\n                doMergeFormDict(afObj.getDict(), pageForm.getDict(), numOffset);\n            }\n        }\n        objectsCount += docs[i]->writePageObjects(outStr, yRef, numOffset, true);\n        numOffset = yRef->getNumObjects() + 1;\n    }\n\n    rootNum = yRef->getNumObjects() + 1;\n    yRef->add(rootNum, 0, outStr->getPos(), true);\n    outStr->printf(\"%d 0 obj\\n\", rootNum);\n    outStr->printf(\"<< /Type /Catalog /Pages %d 0 R\", rootNum + 1);\n    // insert OutputIntents\n    if (intents.isArray() && intents.arrayGetLength() > 0) {\n        outStr->printf(\" /OutputIntents [\");\n        for (j = 0; j < intents.arrayGetLength(); j++) {\n            Object intent = intents.arrayGet(j, 0);\n            if (intent.isDict()) {\n                PDFDoc::writeObject(&intent, outStr, yRef, 0, nullptr, cryptRC4, 0, 0, 0);\n            }\n        }\n        outStr->printf(\"]\");\n    }\n    // insert AcroForm\n    if (!afObj.isNull()) {\n        outStr->printf(\" /AcroForm \");\n        PDFDoc::writeObject(&afObj, outStr, yRef, 0, nullptr, cryptRC4, 0, 0, 0);\n    }\n    // insert OCProperties\n    if (!ocObj.isNull() && ocObj.isDict()) {\n        outStr->printf(\" /OCProperties \");\n        PDFDoc::writeObject(&ocObj, outStr, yRef, 0, nullptr, cryptRC4, 0, 0, 0);\n    }\n    // insert Names\n    if (!names.isNull() && names.isDict()) {\n        outStr->printf(\" /Names \");\n        PDFDoc::writeObject(&names, outStr, yRef, 0, nullptr, cryptRC4, 0, 0, 0);\n    }\n    outStr->printf(\">>\\nendobj\\n\");\n    objectsCount++;\n\n    yRef->add(rootNum + 1, 0, outStr->getPos(), true);\n    outStr->printf(\"%d 0 obj\\n\", rootNum + 1);\n    outStr->printf(\"<< /Type /Pages /Kids [\");\n    for (j = 0; j < (int)pages.size(); j++) {\n        outStr->printf(\" %d 0 R\", rootNum + j + 2);\n    }\n    outStr->printf(\" ] /Count %zd >>\\nendobj\\n\", pages.size());\n    objectsCount++;\n\n    for (i = 0; i < (int)pages.size(); i++) {\n        yRef->add(rootNum + i + 2, 0, outStr->getPos(), true);\n        outStr->printf(\"%d 0 obj\\n\", rootNum + i + 2);\n        outStr->printf(\"<< \");\n        Dict *pageDict = pages[i].getDict();\n        for (j = 0; j < pageDict->getLength(); j++) {\n            if (j > 0) {\n                outStr->printf(\" \");\n            }\n            const char *key = pageDict->getKey(j);\n            Object value = pageDict->getValNF(j).copy();\n            if (strcmp(key, \"Parent\") == 0) {\n                outStr->printf(\"/Parent %d 0 R\", rootNum + 1);\n            } else {\n                outStr->printf(\"/%s \", key);\n                PDFDoc::writeObject(&value, outStr, yRef, offsets[i], nullptr, cryptRC4, 0, 0, 0);\n            }\n        }\n        outStr->printf(\" >>\\nendobj\\n\");\n        objectsCount++;\n    }\n    Goffset uxrefOffset = outStr->getPos();\n    Ref ref;\n    ref.num = rootNum;\n    ref.gen = 0;\n    Object trailerDict = PDFDoc::createTrailerDict(objectsCount, false, 0, &ref, yRef, fileName, outStr->getPos());\n    PDFDoc::writeXRefTableTrailer(std::move(trailerDict), yRef, true, // write all entries according to ISO 32000-1, 7.5.4 Cross-Reference Table: \"For a file that has never been incrementally updated, the cross-reference section shall\n                                                                      // contain only one subsection, whose object numbering begins at 0.\"\n                                  uxrefOffset, outStr, yRef);\n\n    outStr->close();\n    delete outStr;\n    fclose(f);\n    delete yRef;\n    delete countRef;\n    for (i = 0; i < (int)docs.size(); i++) {\n        delete docs[i];\n    }\n    return 0;\n}", "target": 1, "idx": 10021}
{"commit_id": "d689d14dbcd768c028eab2fb378d849e543dcfe9", "project": "appneta/tcpreplay", "func": "int\nmain(int argc, char *argv[])\n{\n    int i, fd, swapped, pkthdrlen, ret, optct, backwards, caplentoobig;\n    struct pcap_file_header pcap_fh;\n    struct pcap_pkthdr pcap_ph;\n    struct pcap_sf_patched_pkthdr pcap_patched_ph; /* Kuznetzov */\n    char buf[10000];\n    struct stat statinfo;\n    uint64_t pktcnt;\n    uint32_t readword;\n    int32_t last_sec, last_usec, caplen;\n\n    optct = optionProcess(&tcpcapinfoOptions, argc, argv);\n    argc -= optct;\n    argv += optct;\n\n#ifdef DEBUG\n    if (HAVE_OPT(DBUG))\n        debug = OPT_VALUE_DBUG;\n#endif\n\n    for (i = 0; i < argc; i++) {\n        dbgx(1, \"processing:  %s\\n\", argv[i]);\n        if ((fd = open(argv[i], O_RDONLY)) < 0)\n            errx(-1, \"Error opening file %s: %s\", argv[i], strerror(errno));\n\n        if (fstat(fd, &statinfo) < 0)\n            errx(-1, \"Error getting file stat info %s: %s\", argv[i], strerror(errno));\n\n        printf(\"file size   = %\"PRIu64\" bytes\\n\", (uint64_t)statinfo.st_size);\n\n        if ((ret = read(fd, &buf, sizeof(pcap_fh))) != sizeof(pcap_fh))\n            errx(-1, \"File too small.  Unable to read pcap_file_header from %s\", argv[i]);\n\n        dbgx(3, \"Read %d bytes for file header\", ret);\n\n        swapped = 0;\n\n        memcpy(&pcap_fh, &buf, sizeof(pcap_fh));\n\n        pkthdrlen = 16; /* pcap_pkthdr isn't the actual on-disk format for 64bit systems! */\n\n        switch (pcap_fh.magic) {\n            case TCPDUMP_MAGIC:\n            printf(\"magic       = 0x%08\"PRIx32\" (tcpdump) (%s)\\n\", pcap_fh.magic, is_not_swapped);\n            break;\n\n            case SWAPLONG(TCPDUMP_MAGIC):\n            printf(\"magic       = 0x%08\"PRIx32\" (tcpdump/swapped) (%s)\\n\", pcap_fh.magic, is_swapped);\n            swapped = 1;\n            break;\n\n            case KUZNETZOV_TCPDUMP_MAGIC:\n            pkthdrlen = sizeof(pcap_patched_ph);\n            printf(\"magic       = 0x%08\"PRIx32\" (Kuznetzov) (%s)\\n\", pcap_fh.magic, is_not_swapped);\n            break;\n\n            case SWAPLONG(KUZNETZOV_TCPDUMP_MAGIC):\n            pkthdrlen = sizeof(pcap_patched_ph);\n            printf(\"magic       = 0x%08\"PRIx32\" (Kuznetzov/swapped) (%s)\\n\", pcap_fh.magic, is_swapped);\n            swapped = 1;\n            break;\n\n            case FMESQUITA_TCPDUMP_MAGIC:\n            printf(\"magic       = 0x%08\"PRIx32\" (Fmesquita) (%s)\\n\", pcap_fh.magic, is_not_swapped);\n            break;\n\n            case SWAPLONG(FMESQUITA_TCPDUMP_MAGIC):\n            printf(\"magic       = 0x%08\"PRIx32\" (Fmesquita) (%s)\\n\", pcap_fh.magic, is_swapped);\n            swapped = 1;\n            break;\n\n            case NAVTEL_TCPDUMP_MAGIC:\n            printf(\"magic       = 0x%08\"PRIx32\" (Navtel) (%s)\\n\", pcap_fh.magic, is_not_swapped);\n            break;\n\n            case SWAPLONG(NAVTEL_TCPDUMP_MAGIC):\n            printf(\"magic       = 0x%08\"PRIx32\" (Navtel/swapped) (%s)\\n\", pcap_fh.magic, is_swapped);\n            swapped = 1;\n            break;\n\n            case NSEC_TCPDUMP_MAGIC:\n            printf(\"magic       = 0x%08\"PRIx32\" (Nsec) (%s)\\n\", pcap_fh.magic, is_not_swapped);\n            break;\n\n            case SWAPLONG(NSEC_TCPDUMP_MAGIC):\n            printf(\"magic       = 0x%08\"PRIx32\" (Nsec/swapped) (%s)\\n\", pcap_fh.magic, is_swapped);\n            swapped = 1;\n            break;\n\n            default:\n            printf(\"magic       = 0x%08\"PRIx32\" (unknown)\\n\", pcap_fh.magic);\n        }\n\n        if (swapped == 1) {\n            pcap_fh.version_major = SWAPSHORT(pcap_fh.version_major);\n            pcap_fh.version_minor = SWAPSHORT(pcap_fh.version_minor);\n            pcap_fh.thiszone = SWAPLONG(pcap_fh.thiszone);\n            pcap_fh.sigfigs = SWAPLONG(pcap_fh.sigfigs);\n            pcap_fh.snaplen = SWAPLONG(pcap_fh.snaplen);\n            pcap_fh.linktype = SWAPLONG(pcap_fh.linktype);\n        }\n\n        printf(\"version     = %hu.%hu\\n\", pcap_fh.version_major, pcap_fh.version_minor);\n        printf(\"thiszone    = 0x%08\"PRIx32\"\\n\", pcap_fh.thiszone);\n        printf(\"sigfigs     = 0x%08\"PRIx32\"\\n\", pcap_fh.sigfigs);\n        printf(\"snaplen     = %\"PRIu32\"\\n\", pcap_fh.snaplen);\n        printf(\"linktype    = 0x%08\"PRIx32\"\\n\", pcap_fh.linktype);\n\n        if (pcap_fh.version_major != 2 && pcap_fh.version_minor != 4) {\n            printf(\"Sorry, we only support file format version 2.4\\n\");\n            close(fd);\n            continue;\n        }\n\n        dbgx(5, \"Packet header len: %d\", pkthdrlen);\n\n        if (pkthdrlen == 24) {\n            printf(\"Packet\\tOrigLen\\t\\tCaplen\\t\\tTimestamp\\t\\tIndex\\tProto\\tPktType\\tPktCsum\\tNote\\n\");\n        } else {\n            printf(\"Packet\\tOrigLen\\t\\tCaplen\\t\\tTimestamp\\tCsum\\tNote\\n\");\n        }\n\n        pktcnt = 0;\n        last_sec = 0;\n        last_usec = 0;\n        while ((ret = read(fd, &buf, pkthdrlen)) == pkthdrlen) {\n            pktcnt ++;\n            backwards = 0;\n            caplentoobig = 0;\n            dbgx(3, \"Read %d bytes for packet %\"PRIu64\" header\", ret, pktcnt);\n\n            memset(&pcap_ph, 0, sizeof(pcap_ph));\n\n            /* see what packet header we're using */\n            if (pkthdrlen == sizeof(pcap_patched_ph)) {\n                memcpy(&pcap_patched_ph, &buf, sizeof(pcap_patched_ph));\n\n                if (swapped == 1) {\n                    dbg(3, \"Swapping packet header bytes...\");\n                    pcap_patched_ph.caplen = SWAPLONG(pcap_patched_ph.caplen);\n                    pcap_patched_ph.len = SWAPLONG(pcap_patched_ph.len);\n                    pcap_patched_ph.ts.tv_sec = SWAPLONG(pcap_patched_ph.ts.tv_sec);\n                    pcap_patched_ph.ts.tv_usec = SWAPLONG(pcap_patched_ph.ts.tv_usec);\n                    pcap_patched_ph.index = SWAPLONG(pcap_patched_ph.index);\n                    pcap_patched_ph.protocol = SWAPSHORT(pcap_patched_ph.protocol);\n                }\n                printf(\"%\"PRIu64\"\\t%4\"PRIu32\"\\t\\t%4\"PRIu32\"\\t\\t%\"\n                        PRIx32\".%\"PRIx32\"\\t\\t%4\"PRIu32\"\\t%4hu\\t%4hhu\", \n                        pktcnt, pcap_patched_ph.len, pcap_patched_ph.caplen, \n                        pcap_patched_ph.ts.tv_sec, pcap_patched_ph.ts.tv_usec,\n                        pcap_patched_ph.index, pcap_patched_ph.protocol, pcap_patched_ph.pkt_type);\n\n                if (pcap_fh.snaplen < pcap_patched_ph.caplen) {\n                    caplentoobig = 1;\n                }\n\n                caplen = pcap_patched_ph.caplen;\n\n            } else {\n                /* manually map on-disk bytes to our memory structure */\n                memcpy(&readword, buf, 4);\n                pcap_ph.ts.tv_sec = readword;\n                memcpy(&readword, &buf[4], 4);\n                pcap_ph.ts.tv_usec = readword;\n                memcpy(&pcap_ph.caplen, &buf[8], 4);\n                memcpy(&pcap_ph.len, &buf[12], 4);\n\n                if (swapped == 1) {\n                    dbg(3, \"Swapping packet header bytes...\");\n                    pcap_ph.caplen = SWAPLONG(pcap_ph.caplen);\n                    pcap_ph.len = SWAPLONG(pcap_ph.len);\n                    pcap_ph.ts.tv_sec = SWAPLONG(pcap_ph.ts.tv_sec);\n                    pcap_ph.ts.tv_usec = SWAPLONG(pcap_ph.ts.tv_usec);\n                }\n                printf(\"%\"PRIu64\"\\t%4\"PRIu32\"\\t\\t%4\"PRIu32\"\\t\\t%\"\n                        PRIx32\".%\"PRIx32,\n                        pktcnt, pcap_ph.len, pcap_ph.caplen, \n                        (unsigned int)pcap_ph.ts.tv_sec, (unsigned int)pcap_ph.ts.tv_usec);\n                if (pcap_fh.snaplen < pcap_ph.caplen) {\n                    caplentoobig = 1;\n                }\n                caplen = pcap_ph.caplen;\n            }\n\n            if (caplentoobig) {\n                printf(\"\\n\\nCapture file appears to be damaged or corrupt.\\n\"\n                        \"Contains packet of size %u, bigger than snap length %u\\n\",\n                        caplen, pcap_fh.snaplen);\n\n                close(fd);\n                break;\n            }\n\n            /* check to make sure timestamps don't go backwards */\n            if (last_sec > 0 && last_usec > 0) {\n                if ((pcap_ph.ts.tv_sec == last_sec) ? \n                        (pcap_ph.ts.tv_usec < last_usec) : \n                        (pcap_ph.ts.tv_sec < last_sec)) {\n                    backwards = 1;\n                }\n            }\n            if (pkthdrlen == sizeof(pcap_patched_ph)) {\n                last_sec = pcap_patched_ph.ts.tv_sec;\n                last_usec = pcap_patched_ph.ts.tv_usec;\n            } else {\n                last_sec = pcap_ph.ts.tv_sec;\n                last_usec = pcap_ph.ts.tv_usec;\n            }\n\n            /* read the frame */\n            if ((ret = read(fd, &buf, caplen)) != caplen) {\n                if (ret < 0) {\n                    printf(\"Error reading file: %s: %s\\n\", argv[i], strerror(errno));\n                } else {\n                    printf(\"File truncated!  Unable to jump to next packet.\\n\");\n                }\n\n                close(fd);\n                break;\n            }\n\n            /* print the frame checksum */\n            printf(\"\\t%x\\t\", do_checksum_math((u_int16_t *)buf, caplen));\n\n            /* print the Note */\n            if (! backwards && ! caplentoobig) {\n                printf(\"OK\\n\");\n            } else if (backwards && ! caplentoobig) {\n                printf(\"BAD_TS\\n\");\n            } else if (caplentoobig && ! backwards) {\n                printf(\"TOOBIG\\n\");\n            } else if (backwards && caplentoobig) {\n                printf(\"BAD_TS|TOOBIG\");\n            } \n\n        }\n\n    }\n\n    exit(0);\n\n}", "target": 2, "idx": 10022}
{"commit_id": "c756e23eb09dac519fe161c88587cc034306630f", "project": "nginx/njs", "func": "static njs_int_t\nnjs_iterator_to_array_handler(njs_vm_t *vm, njs_iterator_args_t *args,\n    njs_value_t *value, int64_t index)\n{\n    njs_value_t  array;\n\n    njs_set_array(&array, args->data);\n\n    return njs_value_property_i64_set(vm, &array, index, value);\n}", "target": 2, "idx": 10023}
{"commit_id": "31ed93a5623f24ca94e6d47e895ba735d9d97d46", "project": "nginx/njs", "func": "static njs_int_t\nnjs_promise_perform_any_handler(njs_vm_t *vm, njs_iterator_args_t *args,\n    njs_value_t *value, int64_t index)\n{\n    njs_int_t                    ret;\n    njs_array_t                  *array;\n    njs_value_t                  arguments[2], next;\n    njs_function_t               *on_rejected;\n    njs_promise_capability_t     *capability;\n    njs_promise_all_context_t    *context;\n    njs_promise_iterator_args_t  *pargs;\n\n    if (!njs_is_valid(value)) {\n        value = njs_value_arg(&njs_value_undefined);\n    }\n\n    pargs = (njs_promise_iterator_args_t *) args;\n\n    capability = pargs->capability;\n\n    array = pargs->args.data;\n    njs_set_undefined(&array->start[index]);\n\n    ret = njs_function_call(vm, pargs->function, pargs->constructor, value, 1,\n                            &next);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n\n    on_rejected = njs_promise_create_function(vm,\n                                            sizeof(njs_promise_all_context_t));\n    if (njs_slow_path(on_rejected == NULL)) {\n        return NJS_ERROR;\n    }\n\n    on_rejected->u.native = njs_promise_any_reject_element_functions;\n    on_rejected->args_count = 1;\n\n    context = on_rejected->context;\n\n    context->already_called = 0;\n    context->index = (uint32_t) index;\n    context->values = pargs->args.data;\n    context->capability = capability;\n    context->remaining_elements = pargs->remaining;\n\n    (*pargs->remaining)++;\n\n    arguments[0] = capability->resolve;\n    njs_set_function(&arguments[1], on_rejected);\n\n    ret = njs_promise_invoke_then(vm, &next, arguments, 2);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n\n    return NJS_OK;\n}", "target": 1, "idx": 10024}
{"commit_id": "75ddbb90468c4bbc21140fe0d37291314bc26ff8", "project": "sass/libsass", "func": "Compound_Selector_Obj get_arg_sel(const std::string& argname, Env& env, Signature sig, ParserState pstate, Backtraces traces, Context& ctx) {\n      Expression_Obj exp = ARG(argname, Expression);\n      if (exp->concrete_type() == Expression::NULL_VAL) {\n        std::stringstream msg;\n        msg << argname << \": null is not a string for `\" << function_name(sig) << \"'\";\n        error(msg.str(), exp->pstate(), traces);\n      }\n      if (String_Constant_Ptr str = Cast<String_Constant>(exp)) {\n        str->quote_mark(0);\n      }\n      std::string exp_src = exp->to_string(ctx.c_options);\n      Selector_List_Obj sel_list = Parser::parse_selector(exp_src.c_str(), ctx, traces, exp->pstate(), pstate.src, /*allow_parent=*/false);\n      if (sel_list->length() == 0) return {};\n      Complex_Selector_Obj first = sel_list->first();\n      if (!first->tail()) return first->head();\n      return first->tail()->head();\n    }", "target": 1, "idx": 10025}
{"commit_id": "ff98b28", "project": "GNOME/gdm", "func": "static void\non_display_status_changed (GdmDisplay *display,\n                           GParamSpec *arg1,\n                           GdmManager *manager)\n{\n        int         status;\n        int         display_number = -1;\n        char       *session_type = NULL;\n#ifdef WITH_PLYMOUTH\n        gboolean    display_is_local = FALSE;\n        gboolean    quit_plymouth = FALSE;\n\n        g_object_get (display,\n                      \"is-local\", &display_is_local,\n                      NULL);\n        quit_plymouth = display_is_local && manager->priv->plymouth_is_running;\n#endif\n\n        g_object_get (display,\n                      \"x11-display-number\", &display_number,\n                      \"session-type\", &session_type,\n                      NULL);\n\n        status = gdm_display_get_status (display);\n\n        switch (status) {\n                case GDM_DISPLAY_PREPARED:\n                case GDM_DISPLAY_MANAGED:\n                        if ((display_number == -1 && status == GDM_DISPLAY_PREPARED) ||\n                            (display_number != -1 && status == GDM_DISPLAY_MANAGED)) {\n                                char *session_class;\n\n                                g_object_get (display,\n                                              \"session-class\", &session_class,\n                                              NULL);\n                                if (g_strcmp0 (session_class, \"greeter\") == 0)\n                                        set_up_session (manager, display);\n                                g_free (session_class);\n                        }\n\n                        if (status == GDM_DISPLAY_MANAGED) {\n                                greeter_display_started (manager, display);\n                        }\n                        break;\n                case GDM_DISPLAY_FAILED:\n                case GDM_DISPLAY_UNMANAGED:\n                case GDM_DISPLAY_FINISHED:\n#ifdef WITH_PLYMOUTH\n                        if (quit_plymouth) {\n                                plymouth_quit_without_transition ();\n                                manager->priv->plymouth_is_running = FALSE;\n                        }\n#endif\n\n                        if (status == GDM_DISPLAY_FINISHED || g_strcmp0 (session_type, \"x11\") == 0) {\n                                manager->priv->ran_once = TRUE;\n                        }\n                        maybe_start_pending_initial_login (manager, display);\n                        break;\n                default:\n                        break;\n        }\n\n}", "target": 1, "idx": 10026}
{"commit_id": "81f9c4e4177d31ced6f52a89bb70e93bfb77ca03", "project": "torvalds/linux", "func": "void\nupdate_max_tr(struct trace_array *tr, struct task_struct *tsk, int cpu)\n{\n\tif (tr->stop_count)\n\t\treturn;\n\n\tWARN_ON_ONCE(!irqs_disabled());\n\n\tif (!tr->allocated_snapshot) {\n\t\t/* Only the nop tracer should hit this when disabling */\n\t\tWARN_ON_ONCE(tr->current_trace != &nop_trace);\n\t\treturn;\n\t}\n\n\tarch_spin_lock(&tr->max_lock);\n\n\tswap(tr->trace_buffer.buffer, tr->max_buffer.buffer);\n\n\t__update_max_tr(tr, tsk, cpu);\n\tarch_spin_unlock(&tr->max_lock);\n}", "target": 3, "idx": 10027}
{"commit_id": "c3e2219216c92919a6bd1711f340f5faa98695e6", "project": "torvalds/linux", "func": "int blk_mq_init_sched(struct request_queue *q, struct elevator_type *e)\n{\n\tstruct blk_mq_hw_ctx *hctx;\n\tstruct elevator_queue *eq;\n\tunsigned int i;\n\tint ret;\n\n\tif (!e) {\n\t\tq->elevator = NULL;\n\t\tq->nr_requests = q->tag_set->queue_depth;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Default to double of smaller one between hw queue_depth and 128,\n\t * since we don't split into sync/async like the old code did.\n\t * Additionally, this is a per-hw queue depth.\n\t */\n\tq->nr_requests = 2 * min_t(unsigned int, q->tag_set->queue_depth,\n\t\t\t\t   BLKDEV_MAX_RQ);\n\n\tqueue_for_each_hw_ctx(q, hctx, i) {\n\t\tret = blk_mq_sched_alloc_tags(q, hctx, i);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tret = e->ops.init_sched(q, e);\n\tif (ret)\n\t\tgoto err;\n\n\tblk_mq_debugfs_register_sched(q);\n\n\tqueue_for_each_hw_ctx(q, hctx, i) {\n\t\tif (e->ops.init_hctx) {\n\t\t\tret = e->ops.init_hctx(hctx, i);\n\t\t\tif (ret) {\n\t\t\t\teq = q->elevator;\n\t\t\t\tblk_mq_sched_free_requests(q);\n\t\t\t\tblk_mq_exit_sched(q, eq);\n\t\t\t\tkobject_put(&eq->kobj);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tblk_mq_debugfs_register_sched_hctx(q, hctx);\n\t}\n\n\treturn 0;\n\nerr:\n\tblk_mq_sched_free_requests(q);\n\tblk_mq_sched_tags_teardown(q);\n\tq->elevator = NULL;\n\treturn ret;\n}", "target": 2, "idx": 10028}
{"commit_id": "992480c30f75943e9cd6245bb2015c7737f9b661", "project": "VirusTotal/yara", "func": "int _yr_scan_match_callback(\n    uint8_t* match_data,\n    int32_t match_length,\n    int flags,\n    void* args)\n{\n  CALLBACK_ARGS* callback_args = (CALLBACK_ARGS*) args;\n\n  YR_STRING* string = callback_args->string;\n  YR_MATCH* new_match;\n\n  int result = ERROR_SUCCESS;\n  int tidx = callback_args->context->tidx;\n\n  size_t match_offset = match_data - callback_args->data;\n\n  // total match length is the sum of backward and forward matches.\n  match_length += callback_args->forward_matches;\n\n  // make sure that match fits into the data.\n  assert(match_offset + match_length <= callback_args->data_size);\n\n  if (callback_args->full_word)\n  {\n    if (flags & RE_FLAGS_WIDE)\n    {\n      if (match_offset >= 2 &&\n          *(match_data - 1) == 0 &&\n          isalnum(*(match_data - 2)))\n        return ERROR_SUCCESS;\n\n      if (match_offset + match_length + 1 < callback_args->data_size &&\n          *(match_data + match_length + 1) == 0 &&\n          isalnum(*(match_data + match_length)))\n        return ERROR_SUCCESS;\n    }\n    else\n    {\n      if (match_offset >= 1 &&\n          isalnum(*(match_data - 1)))\n        return ERROR_SUCCESS;\n\n      if (match_offset + match_length < callback_args->data_size &&\n          isalnum(*(match_data + match_length)))\n        return ERROR_SUCCESS;\n    }\n  }\n\n  if (STRING_IS_CHAIN_PART(string))\n  {\n    result = _yr_scan_verify_chained_string_match(\n        string,\n        callback_args->context,\n        match_data,\n        callback_args->data_base,\n        match_offset,\n        match_length);\n  }\n  else\n  {\n    if (string->matches[tidx].count == 0)\n    {\n      // If this is the first match for the string, put the string in the\n      // list of strings whose flags needs to be cleared after the scan.\n\n      FAIL_ON_ERROR(yr_arena_write_data(\n          callback_args->context->matching_strings_arena,\n          &string,\n          sizeof(string),\n          NULL));\n    }\n\n    FAIL_ON_ERROR(yr_arena_allocate_memory(\n        callback_args->context->matches_arena,\n        sizeof(YR_MATCH),\n        (void**) &new_match));\n\n    new_match->data_length = yr_min(match_length, MAX_MATCH_DATA);\n\n    FAIL_ON_ERROR(yr_arena_write_data(\n        callback_args->context->matches_arena,\n        match_data,\n        new_match->data_length,\n        (void**) &new_match->data));\n\n    if (result == ERROR_SUCCESS)\n    {\n      new_match->base = callback_args->data_base;\n      new_match->offset = match_offset;\n      new_match->match_length = match_length;\n      new_match->prev = NULL;\n      new_match->next = NULL;\n\n      FAIL_ON_ERROR(_yr_scan_add_match_to_list(\n          new_match,\n          &string->matches[tidx],\n          STRING_IS_GREEDY_REGEXP(string)));\n    }\n  }\n\n  return result;\n}", "target": 2, "idx": 10029}
{"commit_id": "28fdce547c417b868c521f87fb58f71ca6b1e3f7", "project": "wireshark", "func": "static gint rtps_util_add_type_member(proto_tree *tree,\n        tvbuff_t * tvb, gint offset, const guint encoding,\n        dissection_info * info, dissection_element * member_object) {\n  proto_tree * member_property, *annotation_tree;\n  guint32 member_id = 0, member_length = 0;\n  guint32 long_number, i;\n  guint16 short_number;\n  guint64 member_type_id;\n  gint offset_tmp;\n  gchar * name = NULL;\n\n  member_property = proto_tree_add_subtree(tree, tvb, offset, 0,\n                ett_rtps_type_element, NULL, \"Member Property\");\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n  offset_tmp = offset;\n  short_number = tvb_get_guint16(tvb, offset_tmp, encoding);\n  proto_tree_add_bitmask_value(member_property, tvb, offset_tmp, hf_rtps_type_object_flags,\n          ett_rtps_flags, MEMBER_FLAGS, short_number);\n  if (member_object) member_object->flags = short_number;\n  offset_tmp += 2;\n  ALIGN_ZERO(offset_tmp, 4, offset);\n  proto_tree_add_item(member_property, hf_rtps_type_object_member_id, tvb, offset_tmp, 4, encoding);\n  member_id = tvb_get_guint32(tvb, offset_tmp, encoding);\n  offset_tmp += 4;\n  offset_tmp = rtps_util_add_type_id(member_property, tvb, offset_tmp, encoding,\n          offset, -1, tree, &member_type_id);\n  rtps_util_add_string(member_property, tvb, offset_tmp, hf_rtps_type_object_name, encoding);\n  long_number = tvb_get_guint32(tvb, offset_tmp, encoding);\n  name = tvb_get_string_enc(wmem_packet_scope(), tvb, offset_tmp+4, long_number, ENC_ASCII);\n  proto_item_append_text(tree, \" %s (ID: %d)\", name, member_id);\n  if (member_object) {\n    member_object->member_id = member_id;\n    (void) g_strlcpy(member_object->member_name, name, sizeof(member_object->member_name));\n    member_object->type_id = member_type_id;\n  }\n  if (info && info->extensibility == EXTENSIBILITY_MUTABLE) {\n      mutable_member_mapping * mutable_mapping = NULL;\n      mutable_mapping = wmem_new(wmem_file_scope(), mutable_member_mapping);\n      (void) g_strlcpy(mutable_mapping->member_name, name, sizeof(mutable_mapping->member_name));\n      mutable_mapping->struct_type_id = info->type_id;\n      mutable_mapping->member_type_id = member_type_id;\n      mutable_mapping->member_id = member_id;\n      mutable_mapping->key = (mutable_mapping->struct_type_id + mutable_mapping->struct_type_id * mutable_mapping->member_id);\n      proto_item_append_text(tree, \"(Inserted 0x%016\" PRIx64 \" from 0x%016\" PRIx64 \")\", mutable_mapping->key, mutable_mapping->struct_type_id);\n      wmem_map_insert(mutable_member_mappings, &(mutable_mapping->key), (void *) mutable_mapping);\n\n  }\n\n  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);\n\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n  offset_tmp = offset;\n  long_number = tvb_get_guint32(tvb, offset_tmp, encoding);\n  annotation_tree = proto_tree_add_subtree_format(tree, tvb, offset_tmp, member_length,\n              ett_rtps_type_annotation_usage_list, NULL, \"Annotation Usage Member List (%d elements)\",\n              long_number);\n  offset_tmp += 4;\n  for (i = 0; i < long_number ; i++) {\n        offset_tmp = rtps_util_add_type_annotation_usage(annotation_tree, tvb, offset_tmp,\n                encoding, offset);\n  }\n  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);\n\n  long_number = tvb_get_guint32(tvb, offset, encoding);\n  if ((long_number & PID_LIST_END) == PID_LIST_END) {\n    offset += 4;\n  }\n\n  return offset;\n}", "target": 1, "idx": 10030}
{"commit_id": "9fe2de783dbcbe74144678d60a4e3923367044b2", "project": "wireshark", "func": "static gboolean\ndissect_eap_identity_wlan(tvbuff_t *tvb, packet_info* pinfo, proto_tree* tree, int offset, gint size)\n{\n  guint       mnc = 0;\n  guint       mcc = 0;\n  guint       mcc_mnc = 0;\n  proto_tree* eap_identity_tree = NULL;\n  guint8      eap_identity_prefix = 0;\n  guint8*     identity = NULL;\n  gchar**     tokens = NULL;\n  guint       ntokens = 0;\n  gboolean    ret = TRUE;\n  int         hf_eap_identity_wlan_mcc_mnc;\n  proto_item* item;\n\n  identity = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, size, ENC_ASCII);\n\n  tokens = g_strsplit_set(identity, \"@.\", -1);\n\n  while(tokens[ntokens])\n    ntokens++;\n\n  /* The WLAN identity must have the form of\n     <imsi>@wlan.mnc<mnc>.mcc<mcc>.3gppnetwork.org\n     If not, we don't have a wlan identity\n  */\n  if (ntokens != 6 || g_ascii_strncasecmp(tokens[1], \"wlan\", 4) ||\n      g_ascii_strncasecmp(tokens[4], \"3gppnetwork\", 11) ||\n      g_ascii_strncasecmp(tokens[5], \"org\", 3)) {\n    ret = FALSE;\n    goto end;\n  }\n\n  /* It is very likely that we have a WLAN identity (EAP-AKA/EAP-SIM) */\n  /* Go on with the dissection */\n  eap_identity_tree = proto_item_add_subtree(tree, ett_identity);\n  eap_identity_prefix = tokens[0][0];\n  item = proto_tree_add_uint(eap_identity_tree, hf_eap_identity_wlan_prefix,\n    tvb, offset, 1, eap_identity_prefix);\n\n  switch(eap_identity_prefix) {\n    case '0':\n    case '1':\n    case '6':\n      dissect_e212_utf8_imsi(tvb, pinfo, eap_identity_tree, offset + 1, (guint)strlen(tokens[0]) - 1);\n      break;\n    case '2':\n    case '3':\n    case '7':\n      proto_tree_add_item(eap_identity_tree, hf_eap_identity_pseudo, tvb, offset + 1, (guint)strlen(tokens[0]) - 1, ENC_ASCII|ENC_NA);\n      break;\n    case '4':\n    case '5':\n    case '8':\n      proto_tree_add_item(eap_identity_tree, hf_eap_identity_reauth, tvb, offset + 1, (guint)strlen(tokens[0]) - 1, ENC_ASCII|ENC_NA);\n      break;\n    default:\n      expert_add_info(pinfo, item, &ei_eap_identity_invalid);\n  }\n\n  /* guess if we have a 3 bytes mnc by comparing the first bytes with the imsi */\n  /* XXX Should we force matches on \"mnc\" and \"mmc\"? */\n  if (!sscanf(tokens[2], \"%*3c%u\", &mnc) || !sscanf(tokens[3], \"%*3c%u\", &mcc)) {\n    ret = FALSE;\n    goto end;\n  }\n\n  if (!g_ascii_strncasecmp(tokens[0], tokens[2] + 3, 3)) {\n    mcc_mnc = 1000 * mcc + mnc;\n    hf_eap_identity_wlan_mcc_mnc = hf_eap_identity_wlan_mcc_mnc_3digits;\n  } else {\n    mcc_mnc = 100 * mcc + mnc;\n    hf_eap_identity_wlan_mcc_mnc = hf_eap_identity_wlan_mcc_mnc_2digits;\n  }\n\n  proto_tree_add_uint(eap_identity_tree, hf_eap_identity_wlan_mcc_mnc,\n    tvb, offset + (guint)strlen(tokens[0]) + (guint)strlen(\"@wlan.\") +\n    (guint)strlen(\"mnc\"), (guint)strlen(tokens[2]) - (guint)strlen(\"mnc\"),\n    mcc_mnc);\n\n  proto_tree_add_uint(eap_identity_tree, hf_eap_identity_wlan_mcc,\n    tvb, offset + (guint)(strlen(tokens[0]) + strlen(\"@wlan.\") +\n    strlen(tokens[2]) + 1 + strlen(\"mcc\")),\n    (guint)(strlen(tokens[3]) - strlen(\"mcc\")), mcc);\nend:\n  g_strfreev(tokens);\n  return ret;\n}", "target": 2, "idx": 10031}
{"commit_id": "8d444b41d09a700c7ee6f9182a649f3f2d325abb", "project": "nbdkit/libnbd", "func": "static void\nnull_asynch_write (struct rw *rw,\n                   struct command *command,\n                   nbd_completion_callback cb)\n{\n  int dummy = 0;\n\n  cb.callback (cb.user_data, &dummy);\n}", "target": 1, "idx": 10032}
{"commit_id": "cb4636f7c0af2e97a4eef7a3cdcbd85a71247bfe", "project": "unbit/uwsgi", "func": "char *uwsgi_expand_path(char *dir, int dir_len, char *ptr) {\n\tif (dir_len > PATH_MAX)\n\t{\n\t\tuwsgi_log(\"invalid path size: %d (max %d)\\n\", dir_len, PATH_MAX);\n\t\treturn NULL;\n\t}\n\tchar *src = uwsgi_concat2n(dir, dir_len, \"\", 0);\n\tchar *dst = ptr;\n\tif (!dst)\n\t\tdst = uwsgi_malloc(PATH_MAX + 1);\n\tif (!realpath(src, dst)) {\n\t\tuwsgi_error_realpath(src);\n\t\tif (!ptr)\n\t\t\tfree(dst);\n\t\tfree(src);\n\t\treturn NULL;\n\t}\n\tfree(src);\n\treturn dst;\n}", "target": 3, "idx": 10033}
{"commit_id": "86b7570cfba845e8209c6aec2d15e487bb1d8bb4", "project": "nothings/stb", "func": "static int stbi__jpeg_decode_block(stbi__jpeg *j, short data[64], stbi__huffman *hdc, stbi__huffman *hac, stbi__int16 *fac, int b, stbi__uint16 *dequant)\n{\n   int diff,dc,k;\n   int t;\n\n   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);\n   t = stbi__jpeg_huff_decode(j, hdc);\n   if (t < 0 || t > 15) return stbi__err(\"bad huffman code\",\"Corrupt JPEG\");\n\n   // 0 all the ac values now so we can do it 32-bits at a time\n   memset(data,0,64*sizeof(data[0]));\n\n   diff = t ? stbi__extend_receive(j, t) : 0;\n   dc = j->img_comp[b].dc_pred + diff;\n   j->img_comp[b].dc_pred = dc;\n   data[0] = (short) (dc * dequant[0]);\n\n   // decode AC components, see JPEG spec\n   k = 1;\n   do {\n      unsigned int zig;\n      int c,r,s;\n      if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);\n      c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);\n      r = fac[c];\n      if (r) { // fast-AC path\n         k += (r >> 4) & 15; // run\n         s = r & 15; // combined length\n         j->code_buffer <<= s;\n         j->code_bits -= s;\n         // decode into unzigzag'd location\n         zig = stbi__jpeg_dezigzag[k++];\n         data[zig] = (short) ((r >> 8) * dequant[zig]);\n      } else {\n         int rs = stbi__jpeg_huff_decode(j, hac);\n         if (rs < 0) return stbi__err(\"bad huffman code\",\"Corrupt JPEG\");\n         s = rs & 15;\n         r = rs >> 4;\n         if (s == 0) {\n            if (rs != 0xf0) break; // end block\n            k += 16;\n         } else {\n            k += r;\n            // decode into unzigzag'd location\n            zig = stbi__jpeg_dezigzag[k++];\n            data[zig] = (short) (stbi__extend_receive(j,s) * dequant[zig]);\n         }\n      }\n   } while (k < 64);\n   return 1;\n}", "target": 2, "idx": 10034}
{"commit_id": "8dca25d26c7ca2caf6138267f6f17111212c156e", "project": "the-tcpdump-group/tcpdump", "func": "static const u_char *\nikev2_auth_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len _U_, const u_char *ep,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct ikev2_auth a;\n\tconst char *v2_auth[]={ \"invalid\", \"rsasig\",\n\t\t\t\t\"shared-secret\", \"dsssig\" };\n\tconst u_char *authdata = (const u_char*)ext + sizeof(a);\n\tunsigned int len;\n\n\tND_TCHECK2(*ext, sizeof(a));\n\tUNALIGNED_MEMCPY(&a, ext, sizeof(a));\n\tikev2_pay_print(ndo, NPSTR(tpay), a.h.critical);\n\tlen = ntohs(a.h.len);\n\n\t/*\n\t * Our caller has ensured that the length is >= 4.\n\t */\n\tND_PRINT((ndo,\" len=%u method=%s\", len-4,\n\t\t  STR_OR_ID(a.auth_method, v2_auth)));\n\tif (len > 4) {\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\tND_PRINT((ndo, \" authdata=(\"));\n\t\t\tif (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))\n\t\t\t\tgoto trunc;\n\t\t\tND_PRINT((ndo, \") \"));\n\t\t} else if (ndo->ndo_vflag) {\n\t\t\tif (!ike_show_somedata(ndo, authdata, ep))\n\t\t\t\tgoto trunc;\n\t\t}\n\t}\n\n\treturn (const u_char *)ext + len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}", "target": 3, "idx": 10035}
{"commit_id": "35a571346a94fb93b5b3b6a599675ef3384bc75c", "project": "torvalds/linux", "func": "static bool nested_vmx_exit_handled_io(struct kvm_vcpu *vcpu,\n\t\t\t\t       struct vmcs12 *vmcs12)\n{\n\tunsigned long exit_qualification;\n\tunsigned short port;\n\tint size;\n\n\tif (!nested_cpu_has(vmcs12, CPU_BASED_USE_IO_BITMAPS))\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_UNCOND_IO_EXITING);\n\n\texit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\n\tport = exit_qualification >> 16;\n\tsize = (exit_qualification & 7) + 1;\n\n\treturn nested_vmx_check_io_bitmaps(vcpu, port, size);\n}", "target": 1, "idx": 10036}
{"commit_id": "63bcca251f093d83da7e290ab4bbd38ae69089b5", "project": "virglrenderer", "func": "void vrend_launch_grid(struct vrend_context *ctx,\n                       UNUSED uint32_t *block,\n                       uint32_t *grid,\n                       uint32_t indirect_handle,\n                       uint32_t indirect_offset)\n{\n   bool new_program = false;\n   struct vrend_resource *indirect_res = NULL;\n\n   if (!has_feature(feat_compute_shader))\n      return;\n\n   if (ctx->sub->cs_shader_dirty) {\n      struct vrend_linked_shader_program *prog;\n      bool cs_dirty;\n\n      ctx->sub->cs_shader_dirty = false;\n\n      if (!ctx->sub->shaders[PIPE_SHADER_COMPUTE]) {\n         vrend_printf(\"dropping rendering due to missing shaders: %s\\n\", ctx->debug_name);\n         return;\n      }\n\n      vrend_shader_select(ctx, ctx->sub->shaders[PIPE_SHADER_COMPUTE], &cs_dirty);\n      if (!ctx->sub->shaders[PIPE_SHADER_COMPUTE]->current) {\n         vrend_printf( \"failure to compile shader variants: %s\\n\", ctx->debug_name);\n         return;\n      }\n      if (ctx->sub->shaders[PIPE_SHADER_COMPUTE]->current->id != (GLuint)ctx->sub->prog_ids[PIPE_SHADER_COMPUTE]) {\n         prog = lookup_cs_shader_program(ctx, ctx->sub->shaders[PIPE_SHADER_COMPUTE]->current->id);\n         if (!prog) {\n            prog = add_cs_shader_program(ctx, ctx->sub->shaders[PIPE_SHADER_COMPUTE]->current);\n            if (!prog)\n               return;\n         }\n      } else\n         prog = ctx->sub->prog;\n\n      if (ctx->sub->prog != prog) {\n         new_program = true;\n         ctx->sub->prog_ids[PIPE_SHADER_VERTEX] = -1;\n         ctx->sub->prog_ids[PIPE_SHADER_COMPUTE] = ctx->sub->shaders[PIPE_SHADER_COMPUTE]->current->id;\n         ctx->sub->prog = prog;\n         prog->ref_context = ctx->sub;\n      }\n      ctx->sub->shader_dirty = true;\n   }\n\n   if (!ctx->sub->prog) {\n      vrend_printf(\"%s: Skipping compute shader execution due to missing shaders: %s\\n\",\n                   __func__, ctx->debug_name);\n      return;\n   }\n\n   vrend_use_program(ctx, ctx->sub->prog->id);\n\n   vrend_draw_bind_ubo_shader(ctx, PIPE_SHADER_COMPUTE, 0);\n   vrend_draw_bind_const_shader(ctx, PIPE_SHADER_COMPUTE, new_program);\n   vrend_draw_bind_samplers_shader(ctx, PIPE_SHADER_COMPUTE, 0);\n   vrend_draw_bind_images_shader(ctx, PIPE_SHADER_COMPUTE);\n   vrend_draw_bind_ssbo_shader(ctx, PIPE_SHADER_COMPUTE);\n   vrend_draw_bind_abo_shader(ctx);\n\n   if (indirect_handle) {\n      indirect_res = vrend_renderer_ctx_res_lookup(ctx, indirect_handle);\n      if (!indirect_res) {\n         report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_RESOURCE, indirect_handle);\n         return;\n      }\n   }\n\n   if (indirect_res)\n      glBindBuffer(GL_DISPATCH_INDIRECT_BUFFER, indirect_res->id);\n   else\n      glBindBuffer(GL_DISPATCH_INDIRECT_BUFFER, 0);\n\n   if (indirect_res) {\n      glDispatchComputeIndirect(indirect_offset);\n   } else {\n      glDispatchCompute(grid[0], grid[1], grid[2]);\n   }\n}", "target": 1, "idx": 10037}
{"commit_id": "4e0f718daf97d47cf7dec122da1be970f145c809", "project": "torvalds/linux", "func": "static void ax25_kill_by_device(struct net_device *dev)\n{\n\tax25_dev *ax25_dev;\n\tax25_cb *s;\n\tstruct sock *sk;\n\n\tif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\n\t\treturn;\n\n\tspin_lock_bh(&ax25_list_lock);\nagain:\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->ax25_dev == ax25_dev) {\n\t\t\tsk = s->sk;\n\t\t\tsock_hold(sk);\n\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\tlock_sock(sk);\n\t\t\ts->ax25_dev = NULL;\n\t\t\trelease_sock(sk);\n\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\tspin_lock_bh(&ax25_list_lock);\n\t\t\tsock_put(sk);\n\t\t\t/* The entry could have been deleted from the\n\t\t\t * list meanwhile and thus the next pointer is\n\t\t\t * no longer valid.  Play it safe and restart\n\t\t\t * the scan.  Forward progress is ensured\n\t\t\t * because we set s->ax25_dev to NULL and we\n\t\t\t * are never passed a NULL 'dev' argument.\n\t\t\t */\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock_bh(&ax25_list_lock);\n}", "target": 2, "idx": 10038}
{"commit_id": "55667441c84fa5e0911a0aac44fb059c15ba6da2", "project": "torvalds/linux", "func": "static inline u32 ___skb_get_hash(const struct sk_buff *skb,\n\t\t\t\t  struct flow_keys *keys,\n\t\t\t\t  const siphash_key_t *keyval)\n{\n\tskb_flow_dissect_flow_keys(skb, keys,\n\t\t\t\t   FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL);\n\n\treturn __flow_hash_from_keys(keys, keyval);\n}", "target": 1, "idx": 10039}
{"commit_id": "d8c9138bf240975848b1c54db648ec4cd516a48f", "project": "GNOME/gvfs", "func": "static void\ng_vfs_daemon_init (GVfsDaemon *daemon)\n{\n  GError *error;\n  gint max_threads = 1; /* TODO: handle max threads */\n\n  daemon->thread_pool = g_thread_pool_new (job_handler_callback,\n\t\t\t\t\t   daemon,\n\t\t\t\t\t   max_threads,\n\t\t\t\t\t   FALSE, NULL);\n  /* TODO: verify thread_pool != NULL in a nicer way */\n  g_assert (daemon->thread_pool != NULL);\n\n  g_mutex_init (&daemon->lock);\n\n  daemon->mount_counter = 0;\n  \n  daemon->jobs = NULL;\n  daemon->registered_paths =\n    g_hash_table_new_full (g_str_hash, g_str_equal,\n\t\t\t   g_free, (GDestroyNotify)registered_path_free);\n\n  /* This is where we store active client connections so when a new filter is registered,\n   * we re-register them on all active connections */\n  daemon->client_connections =\n    g_hash_table_new_full (g_direct_hash, g_direct_equal, g_object_unref, NULL);\n\n  daemon->conn = g_bus_get_sync (G_BUS_TYPE_SESSION, NULL, NULL);\n  g_assert (daemon->conn != NULL);\n  daemon->auth_observer = g_dbus_auth_observer_new ();\n  g_signal_connect (daemon->auth_observer, \"authorize-authenticated-peer\", G_CALLBACK (authorize_authenticated_peer_cb), NULL);\n\n  daemon->daemon_skeleton = gvfs_dbus_daemon_skeleton_new ();\n  g_signal_connect (daemon->daemon_skeleton, \"handle-get-connection\", G_CALLBACK (handle_get_connection), daemon);\n  g_signal_connect (daemon->daemon_skeleton, \"handle-cancel\", G_CALLBACK (handle_cancel), daemon);\n  g_signal_connect (daemon->daemon_skeleton, \"handle-list-monitor-implementations\", G_CALLBACK (handle_list_monitor_implementations), daemon);\n  \n  error = NULL;\n  if (!g_dbus_interface_skeleton_export (G_DBUS_INTERFACE_SKELETON (daemon->daemon_skeleton),\n                                         daemon->conn,\n                                         G_VFS_DBUS_DAEMON_PATH,\n                                         &error))\n    {\n      g_warning (\"Error exporting daemon interface: %s (%s, %d)\\n\",\n                  error->message, g_quark_to_string (error->domain), error->code);\n      g_error_free (error);\n    }\n\n  daemon->mountable_skeleton = gvfs_dbus_mountable_skeleton_new ();\n  g_signal_connect (daemon->mountable_skeleton, \"handle-mount\", G_CALLBACK (daemon_handle_mount), daemon);\n  \n  error = NULL;\n  if (!g_dbus_interface_skeleton_export (G_DBUS_INTERFACE_SKELETON (daemon->mountable_skeleton),\n      daemon->conn,\n                                         G_VFS_DBUS_MOUNTABLE_PATH,\n                                         &error))\n    {\n      g_warning (\"Error exporting mountable interface: %s (%s, %d)\\n\",\n                  error->message, g_quark_to_string (error->domain), error->code);\n      g_error_free (error);\n    }\n}", "target": 2, "idx": 10040}
{"commit_id": "49edccd7165696dcc0bf79f50cae4011313ddd28", "project": "upx", "func": "void PackLinuxElf64::pack1(OutputFile *fo, Filter & /*ft*/)\n{\n    fi->seek(0, SEEK_SET);\n    fi->readx(&ehdri, sizeof(ehdri));\n    assert(e_phoff == sizeof(Elf64_Ehdr));  // checked by canPack()\n    sz_phdrs = e_phnum * get_te16(&ehdri.e_phentsize);\n\n    Elf64_Phdr *phdr = phdri;\n    note_size = 0;\n    for (unsigned j=0; j < e_phnum; ++phdr, ++j) {\n        if (PT_NOTE64 == get_te32(&phdr->p_type)) {\n            note_size += up4(get_te64(&phdr->p_filesz));\n        }\n    }\n    if (note_size) {\n        note_body = New(unsigned char, note_size);\n        note_size = 0;\n    }\n    phdr = phdri;\n    for (unsigned j=0; j < e_phnum; ++phdr, ++j) {\n        unsigned const type = get_te32(&phdr->p_type);\n        if (PT_NOTE64 == type) {\n            unsigned const len = get_te64(&phdr->p_filesz);\n            fi->seek(get_te64(&phdr->p_offset), SEEK_SET);\n            fi->readx(&note_body[note_size], len);\n            note_size += up4(len);\n        }\n        if (PT_LOAD64 == type) {\n            unsigned x = get_te64(&phdr->p_align) >> lg2_page;\n            while (x>>=1) {\n                ++lg2_page;\n            }\n        }\n        if (PT_GNU_STACK64 == type) {\n            gnu_stack = phdr;\n        }\n    }\n    page_size =  1u  <<lg2_page;\n    page_mask = ~0ull<<lg2_page;\n\n    progid = 0;  // getRandomId();  not useful, so do not clutter\n    sz_elf_hdrs = sizeof(ehdri) + sz_phdrs;\n    if (0!=xct_off) {  // shared library\n        sz_elf_hdrs = xct_off;\n        lowmem.alloc(xct_off + (!opt->o_unix.android_shlib\n            ? 0\n            : e_shnum * sizeof(Elf64_Shdr)));\n        memcpy(lowmem, file_image, xct_off);  // android omits Shdr here\n        fo->write(lowmem, xct_off);  // < SHF_EXECINSTR (typ: in .plt or .init)\n        if (opt->o_unix.android_shlib) {\n            // In order to pacify the runtime linker on Android \"O\" (\"Oreo\"),\n            // we will splice-in a 4KiB page that contains an \"extra\" copy\n            // of the Shdr, any PT_NOTE above xct_off, and shstrtab.\n            // File order: Ehdr, Phdr[], section contents below xct_off,\n            //    Shdr_copy[], PT_NOTEs.hi, shstrtab.\n            xct_va  += asl_delta;\n            //xct_off += asl_delta;  // not yet\n\n            // Relocate PT_DYNAMIC (in 2nd PT_LOAD)\n            Elf64_Dyn *dyn = const_cast<Elf64_Dyn *>(dynseg);\n            for (; dyn->d_tag; ++dyn) {\n                upx_uint64_t d_tag = get_te64(&dyn->d_tag);\n                if (Elf64_Dyn::DT_FINI       == d_tag\n                ||  Elf64_Dyn::DT_FINI_ARRAY == d_tag\n                ||  Elf64_Dyn::DT_INIT_ARRAY == d_tag\n                ||  Elf64_Dyn::DT_PREINIT_ARRAY == d_tag\n                ||  Elf64_Dyn::DT_PLTGOT      == d_tag) {\n                    upx_uint64_t d_val = get_te64(&dyn->d_val);\n                    set_te64(&dyn->d_val, asl_delta + d_val);\n                }\n            }\n\n            // Relocate dynsym (DT_SYMTAB) which is below xct_va\n            upx_uint64_t const off_dynsym = get_te64(&sec_dynsym->sh_offset);\n            upx_uint64_t const sz_dynsym  = get_te64(&sec_dynsym->sh_size);\n            if ((upx_uint64_t)file_size < sz_dynsym\n            ||  (upx_uint64_t)file_size < off_dynsym\n            || ((upx_uint64_t)file_size - off_dynsym) < sz_dynsym) {\n                throwCantPack(\"bad DT_SYMTAB\");\n            }\n            Elf64_Sym *dyntym = (Elf64_Sym *)lowmem.subref(\n                \"bad dynsym\", off_dynsym, sz_dynsym);\n            Elf64_Sym *sym = dyntym;\n            for (int j = sz_dynsym / sizeof(Elf64_Sym); --j>=0; ++sym) {\n                upx_uint64_t symval = get_te64(&sym->st_value);\n                unsigned symsec = get_te16(&sym->st_shndx);\n                if (Elf64_Sym::SHN_UNDEF != symsec\n                &&  Elf64_Sym::SHN_ABS   != symsec\n                &&  xct_off <= symval) {\n                    set_te64(&sym->st_value, asl_delta + symval);\n                }\n                if (Elf64_Sym::SHN_ABS == symsec && xct_off <= symval) {\n                    adjABS(sym, asl_delta);\n                }\n            }\n\n            // Relocate Phdr virtual addresses, but not physical offsets and sizes\n            unsigned char buf_notes[512]; memset(buf_notes, 0, sizeof(buf_notes));\n            unsigned len_notes = 0;\n            phdr = (Elf64_Phdr *)lowmem.subref(\n                \"bad e_phoff\", e_phoff, e_phnum * sizeof(Elf64_Phdr));\n            for (unsigned j = 0; j < e_phnum; ++j, ++phdr) {\n                upx_uint64_t offset = get_te64(&phdr->p_offset);\n                if (xct_off <= offset) { // above the extra page\n                    if (PT_NOTE64 == get_te32(&phdr->p_type)) {\n                        upx_uint64_t memsz = get_te64(&phdr->p_memsz);\n                        if (sizeof(buf_notes) < (memsz + len_notes)) {\n                            throwCantPack(\"PT_NOTES too big\");\n                        }\n                        set_te64(&phdr->p_vaddr,\n                            len_notes + (e_shnum * sizeof(Elf64_Shdr)) + xct_off);\n                        phdr->p_offset = phdr->p_paddr = phdr->p_vaddr;\n                        memcpy(&buf_notes[len_notes], &file_image[offset], memsz);\n                        len_notes += memsz;\n                    }\n                    else {\n                        //set_te64(&phdr->p_offset, asl_delta + offset);  // physical\n                        upx_uint64_t addr = get_te64(&phdr->p_paddr);\n                        set_te64(&phdr->p_paddr, asl_delta + addr);\n                                     addr = get_te64(&phdr->p_vaddr);\n                        set_te64(&phdr->p_vaddr, asl_delta + addr);\n                    }\n                }\n                // .p_filesz,.p_memsz are updated in ::pack3\n            }\n\n            Elf64_Ehdr *const ehdr = (Elf64_Ehdr *)&lowmem[0];\n            upx_uint64_t e_entry = get_te64(&ehdr->e_entry);\n            if (xct_off < e_entry) {\n                set_te64(&ehdr->e_entry, asl_delta + e_entry);\n            }\n            // Relocate Shdr; and Rela, Rel (below xct_off)\n            set_te64(&ehdr->e_shoff, xct_off);\n            memcpy(&lowmem[xct_off], shdri, e_shnum * sizeof(Elf64_Shdr));\n            Elf64_Shdr *const shdro = (Elf64_Shdr *)&lowmem[xct_off];\n            Elf64_Shdr *shdr = shdro;\n            upx_uint64_t sz_shstrtab  = get_te64(&sec_strndx->sh_size);\n            for (unsigned j = 0; j < e_shnum; ++j, ++shdr) {\n                unsigned sh_type = get_te32(&shdr->sh_type);\n                upx_uint64_t sh_size = get_te64(&shdr->sh_size);\n                upx_uint64_t sh_offset = get_te64(&shdr->sh_offset);\n                upx_uint64_t sh_entsize = get_te64(&shdr->sh_entsize);\n                if ((upx_uint64_t)file_size < sh_size\n                ||  (upx_uint64_t)file_size < sh_offset\n                || ((upx_uint64_t)file_size - sh_offset) < sh_size) {\n                    throwCantPack(\"bad SHT_STRNDX\");\n                }\n\n                if (xct_off <= sh_offset) {\n                    upx_uint64_t addr = get_te64(&shdr->sh_addr);\n                    set_te64(&shdr->sh_addr, asl_delta + addr);\n                }\n                if (Elf64_Shdr::SHT_RELA == sh_type) {\n                    if (sizeof(Elf64_Rela) != sh_entsize) {\n                        char msg[50];\n                        snprintf(msg, sizeof(msg), \"bad Rela.sh_entsize %lu\", (long)sh_entsize);\n                        throwCantPack(msg);\n                    }\n                    n_jmp_slot = 0;\n                    plt_off = ~0ull;\n                    Elf64_Rela *const relb = (Elf64_Rela *)lowmem.subref(\n                         \"bad Rela offset\", sh_offset, sh_size);\n                    Elf64_Rela *rela = relb;\n                    for (int k = sh_size / sh_entsize; --k >= 0; ++rela) {\n                        upx_uint64_t r_addend = get_te64(&rela->r_addend);\n                        upx_uint64_t r_offset = get_te64(&rela->r_offset);\n                        upx_uint64_t r_info   = get_te64(&rela->r_info);\n                        unsigned r_type = ELF64_R_TYPE(r_info);\n                        if (xct_off <= r_offset) {\n                            set_te64(&rela->r_offset, asl_delta + r_offset);\n                        }\n                        if (Elf64_Ehdr::EM_AARCH64 == e_machine) switch (r_type) {\n                            default: {\n                                char msg[90]; snprintf(msg, sizeof(msg),\n                                    \"unexpected relocation %#x [%#x]\",\n                                    r_type, -1 + (unsigned)(sh_size / sh_entsize) - k);\n                                throwCantPack(msg);\n                            } break;\n                            case R_AARCH64_ABS64: // FALL THROUGH\n                            case R_AARCH64_GLOB_DAT: // FALL THROUGH\n                            case R_AARCH64_RELATIVE: {\n                                if (xct_off <= r_addend) {\n                                    set_te64(&rela->r_addend, asl_delta + r_addend);\n                                }\n                            } break;\n                            case R_AARCH64_JUMP_SLOT: {\n                                // .rela.plt contains offset of the \"first time\" target\n                                if (plt_off > r_offset) {\n                                    plt_off = r_offset;\n                                }\n                                upx_uint64_t d = elf_get_offset_from_address(r_offset);\n                                upx_uint64_t w = get_te64(&file_image[d]);\n                                if (xct_off <= w) {\n                                    set_te64(&file_image[d], asl_delta + w);\n                                }\n                                ++n_jmp_slot;\n                            } break;\n                        }\n                    }\n                    fo->seek(sh_offset, SEEK_SET);\n                    fo->rewrite(relb, sh_size);\n                }\n                if (Elf64_Shdr::SHT_REL == sh_type) {\n                    if (sizeof(Elf64_Rel) != sh_entsize) {\n                        char msg[50];\n                        snprintf(msg, sizeof(msg), \"bad Rel.sh_entsize %lu\", (long)sh_entsize);\n                        throwCantPack(msg);\n                    }\n                    Elf64_Rel *rel = (Elf64_Rel *)lowmem.subref(\n                            \"bad Rel sh_offset\", sh_offset, sh_size);\n                    for (int k = sh_size / sh_entsize; --k >= 0; ++rel) {\n                        upx_uint64_t r_offset = get_te64(&rel->r_offset);\n                        if (xct_off <= r_offset) {\n                            set_te64(&rel->r_offset, asl_delta + r_offset);\n                        }\n                        // r_offset must be in 2nd PT_LOAD; .p_vaddr was already relocated\n                        upx_uint64_t d = elf_get_offset_from_address(asl_delta + r_offset);\n                        upx_uint64_t w = get_te64(&file_image[d]);\n                        upx_uint64_t r_info = get_te64(&rel->r_info);\n                        unsigned r_type = ELF64_R_TYPE(r_info);\n                        if (xct_off <= w\n                        &&  Elf64_Ehdr::EM_AARCH64 == e_machine\n                        &&  (  R_AARCH64_RELATIVE  == r_type\n                            || R_AARCH64_JUMP_SLOT == r_type)) {\n                            set_te64(&file_image[d], asl_delta + w);\n                        }\n                    }\n                }\n                if (Elf64_Shdr::SHT_NOTE == sh_type) {\n                    if (!(Elf64_Shdr::SHF_ALLOC & get_te64(&shdr->sh_flags))) {\n                        // example: version numer of 'gold' linker (static binder)\n                        if (sizeof(buf_notes) < (sh_size + len_notes)) {\n                            throwCantPack(\"SHT_NOTEs too big\");\n                        }\n                        set_te64(&shdro[j].sh_offset,\n                            len_notes + (e_shnum * sizeof(Elf64_Shdr)) + xct_off);\n                        memcpy(&buf_notes[len_notes], &file_image[sh_offset], sh_size);\n                        len_notes += sh_size;\n                    }\n                    else { // SHF_ALLOC: in PT_LOAD; but move sh_addr and sh_offset\n                        // Not sure why we need this conditional.\n                        // Anyway, some Android have multiple SHT_NOTE sections.\n                        if (xct_off <= sh_offset) {\n                            upx_uint64_t pos = xct_off + e_shnum * sizeof(Elf64_Shdr);\n                            set_te64(&shdr->sh_addr,   pos);\n                            set_te64(&shdr->sh_offset, pos);\n                        }\n                    }\n                }\n            }\n            // shstrndx will move\n            set_te64(&shdro[get_te16(&ehdri.e_shstrndx)].sh_offset,\n                len_notes + e_shnum * sizeof(Elf64_Shdr) + xct_off);\n\n            // (Re-)write all changes below xct_off\n            fo->seek(0, SEEK_SET);\n            fo->rewrite(lowmem, xct_off);\n\n            // New copy of Shdr\n            Elf64_Shdr blank; memset(&blank, 0, sizeof(blank));\n            set_te64(&blank.sh_offset, xct_off);  // hint for \"upx -d\"\n            fo->write(&blank, sizeof(blank));\n            fo->write(&shdro[1], (-1+ e_shnum) * sizeof(Elf64_Shdr));\n\n            if (len_notes) {\n                fo->write(buf_notes, len_notes);\n            }\n\n            // New copy of Shdr[.e_shstrndx].[ sh_offset, +.sh_size )\n            fo->write(shstrtab,  sz_shstrtab);\n\n            sz_elf_hdrs = fpad8(fo);\n            //xct_off += asl_delta;  // wait until ::pack3\n        }\n        memset(&linfo, 0, sizeof(linfo));\n        fo->write(&linfo, sizeof(linfo));\n    }\n\n    // only execute if option present\n    if (opt->o_unix.preserve_build_id) {\n        // set this so we can use elf_find_section_name\n        e_shnum = get_te16(&ehdri.e_shnum);\n        MemBuffer mb_shdri;\n        if (!shdri) {\n            mb_shdri.alloc(e_shnum * sizeof(Elf64_Shdr));\n            shdri = (Elf64_Shdr *)mb_shdri.getVoidPtr();\n            e_shoff = get_te64(&ehdri.e_shoff);\n            fi->seek(e_shoff, SEEK_SET);\n            fi->readx(shdri, e_shnum * sizeof(Elf64_Shdr));\n        }\n        //set the shstrtab\n        sec_strndx = &shdri[get_te16(&ehdri.e_shstrndx)];\n\n        upx_uint64_t sh_size = get_te64(&sec_strndx->sh_size);\n        char *strtab = New(char, sh_size);\n        fi->seek(0,SEEK_SET);\n        fi->seek(sec_strndx->sh_offset,SEEK_SET);\n        fi->readx(strtab, sh_size);\n\n        shstrtab = (const char*)strtab;\n\n        Elf64_Shdr const *buildid = elf_find_section_name(\".note.gnu.build-id\");\n        if (buildid) {\n            unsigned bid_sh_size = get_te32(&buildid->sh_size);\n            unsigned char *data = New(unsigned char, bid_sh_size);\n            memset(data,0,bid_sh_size);\n            fi->seek(0,SEEK_SET);\n            fi->seek(buildid->sh_offset,SEEK_SET);\n            fi->readx(data,bid_sh_size);\n\n            buildid_data  = data;\n\n            o_elf_shnum = 3;\n            memset(&shdrout,0,sizeof(shdrout));\n\n            //setup the build-id\n            memcpy(&shdrout.shdr[1], buildid, sizeof(shdrout.shdr[1]));\n            set_te32(&shdrout.shdr[1].sh_name, 1);\n\n            //setup the shstrtab\n            memcpy(&shdrout.shdr[2], sec_strndx, sizeof(shdrout.shdr[2]));\n            set_te32(&shdrout.shdr[2].sh_name, 20);\n            set_te32(&shdrout.shdr[2].sh_size, 29); //size of our static shstrtab\n        }\n    }\n}", "target": 2, "idx": 10041}
{"commit_id": "ccb1ac3c8cec47fbbbf2e80ced80644005c65252", "project": "wireshark", "func": "static void\ndissect_q931_IEs(tvbuff_t *tvb, packet_info *pinfo, proto_tree *root_tree,\n    proto_tree *q931_tree, gboolean is_over_ip, int offset, int initial_codeset,\n    q931_packet_info *q931_pi)\n{\n    proto_item  *ti;\n    proto_tree  *ie_tree = NULL;\n    guint8      info_element;\n    guint8      dummy;\n    guint16     info_element_len;\n    int         codeset, locked_codeset;\n    gboolean    non_locking_shift, first_segment;\n    tvbuff_t    *h225_tvb, *next_tvb;\n    e164_info_t e164_info;\n    e164_info.e164_number_type = NONE;\n    e164_info.nature_of_address = NONE;\n    e164_info.E164_number_str = \"\";\n    e164_info.E164_number_length = NONE;\n\n    codeset = locked_codeset = initial_codeset;\n    first_segment = FALSE;\n    while (tvb_reported_length_remaining(tvb, offset) > 0) {\n        info_element = tvb_get_guint8(tvb, offset);\n\n        /* Check for the codeset shift */\n        if ((info_element & Q931_IE_SO_MASK) &&\n            ((info_element & Q931_IE_SO_IDENTIFIER_MASK) == Q931_IE_SHIFT)) {\n            non_locking_shift = info_element & Q931_IE_SHIFT_NON_LOCKING;\n            codeset = info_element & Q931_IE_SHIFT_CODESET;\n            if (!non_locking_shift)\n                locked_codeset = codeset;\n            if (q931_tree != NULL) {\n                proto_tree_add_uint_format(q931_tree, hf_q931_locking_codeset, tvb, offset, 1,\n                    codeset, \"%s shift to codeset %u: %s\",\n                    (non_locking_shift ? \"Non-locking\" : \"Locking\"),\n                    codeset, val_to_str(codeset, q931_codeset_vals,\n                      \"Unknown (0x%02X)\"));\n            }\n            offset += 1;\n            continue;\n        }\n\n        /*\n         * Check for the single-octet IEs.\n         */\n        if (info_element & Q931_IE_SO_MASK) {\n            /*\n             * Check for subdissectors for this IE or\n             * for all IEs in this codeset.\n             */\n            if (dissector_get_uint_handle(codeset_dissector_table, codeset) ||\n                dissector_get_uint_handle(ie_dissector_table, (codeset << 8) | (info_element & Q931_IE_SO_IDENTIFIER_MASK))) {\n                next_tvb = tvb_new_subset_length (tvb, offset, 1);\n                if (dissector_try_uint(ie_dissector_table, (codeset << 8) | (info_element & Q931_IE_SO_IDENTIFIER_MASK), next_tvb, pinfo, q931_tree) ||\n                    dissector_try_uint(codeset_dissector_table, codeset, next_tvb, pinfo, q931_tree)) {\n                    offset += 1;\n                    codeset = locked_codeset;\n                    continue;\n                }\n            }\n\n            switch ((codeset << 8) | (info_element & Q931_IE_SO_IDENTIFIER_MASK)) {\n\n            case CS0 | Q931_IE_MORE_DATA_OR_SEND_COMP:\n                switch (info_element) {\n\n                case Q931_IE_MORE_DATA:\n                    proto_tree_add_item(q931_tree, hf_q931_more_data, tvb, offset, 1, ENC_NA);\n                    break;\n\n                case Q931_IE_SENDING_COMPLETE:\n                    proto_tree_add_item(q931_tree, hf_q931_sending_complete, tvb, offset, 1, ENC_NA);\n                    break;\n\n                default:\n                    proto_tree_add_expert_format(q931_tree, pinfo, &ei_q931_information_element, tvb, offset, 1,\n                            \"Unknown information element (0x%02X)\", info_element);\n                    break;\n                }\n                break;\n\n            case CS0 | Q931_IE_CONGESTION_LEVEL:\n                proto_tree_add_item(q931_tree, hf_q931_congestion_level, tvb, offset, 1, ENC_BIG_ENDIAN);\n                break;\n\n            case CS0 | Q931_IE_REPEAT_INDICATOR:\n                proto_tree_add_item(q931_tree, hf_q931_repeat_indicator, tvb, offset, 1, ENC_BIG_ENDIAN);\n                break;\n\n            default:\n                proto_tree_add_expert_format(q931_tree, pinfo, &ei_q931_information_element, tvb, offset, 1,\n                        \"Unknown information element (0x%02X)\", info_element);\n                break;\n            }\n            offset += 1;\n            codeset = locked_codeset;\n            continue;\n        }\n\n        /*\n         * Variable-length IE.\n         *\n         * According to page 18 from Recommendation H.225.0 :\n         * \" Length of user-user contents contents\n         * - Shall be 2 octets instead of 1 (as in Figure 4-36/Q.931)\"\n         *\n         * We assume that if this is Q.931-over-TPKT, it might\n         * be H.225 traffic, and check for the IE being a user-user\n         * IE with ASN.1 encoding of the user information.\n         */\n        if (is_over_ip && tvb_bytes_exist(tvb, offset, 4) &&\n            codeset == 0 && tvb_get_guint8(tvb, offset) == Q931_IE_USER_USER &&\n            tvb_get_guint8(tvb, offset + 3) == Q931_PROTOCOL_DISCRIMINATOR_ASN1)  {\n            info_element_len = tvb_get_ntohs(tvb, offset + 1);\n            if (q931_tree != NULL) {\n                ie_tree = proto_tree_add_subtree(q931_tree, tvb, offset,\n                    1+2+info_element_len, ett_q931_ie[info_element], NULL,\n                    val_to_str(info_element,\n                      q931_info_element_vals[codeset],\n                      \"Unknown information element (0x%02X)\"));\n                proto_tree_add_uint_format_value(ie_tree, hf_q931_information_element, tvb, offset, 1, info_element, \"%s\", val_to_str(info_element,\n                      q931_info_element_vals[codeset], \"Unknown (0x%02X)\"));\n                proto_tree_add_item(ie_tree, hf_q931_information_element_len, tvb, offset + 1, 2, ENC_BIG_ENDIAN);\n                proto_tree_add_item(ie_tree, hf_q931_user_protocol_discriminator, tvb, offset + 3, 1, ENC_NA);\n            }\n\n            if (info_element_len > 1) {\n                /*\n                 * If we don't desegment limit the length\n                 * to the actual size in the frame\n                 */\n                if (!pinfo->can_desegment) {\n                    info_element_len = MIN(info_element_len, tvb_captured_length_remaining(tvb, offset + 3));\n                }\n                /*\n                 * Do we have a handle for the H.225\n                 * dissector?\n                 */\n                if (h225_handle != NULL) {\n                    /*\n                     * Yes - call it, regardless of\n                     * whether we're building a\n                     * protocol tree or not.\n                     */\n                    h225_tvb = tvb_new_subset_length(tvb,\n                        offset + 4, info_element_len - 1);\n                    call_dissector(h225_handle, h225_tvb,\n                        pinfo, root_tree);\n                } else {\n                    /*\n                     * No - just show it as \"User\n                     * information\" (if \"ie_tree\" is\n                     * null, this won't add anything).\n                     */\n                    proto_tree_add_item(ie_tree, hf_q931_user_information_bytes, tvb, offset + 4, info_element_len - 1, ENC_NA);\n                }\n            }\n            offset += 1 + 2 + info_element_len;\n        } else {\n            info_element_len = tvb_get_guint8(tvb, offset + 1);\n\n            if (first_segment && (tvb_reported_length_remaining(tvb, offset + 2) < info_element_len)) {  /* incomplete IE at the end of the 1st segment */\n                proto_tree_add_expert(q931_tree, pinfo, &ei_q931_incomplete_ie, tvb, offset, -1);\n                break;\n            }\n\n            /*\n             * Check for subdissectors for this IE or\n             * for all IEs in this codeset.\n             */\n            if (dissector_get_uint_handle(codeset_dissector_table, codeset) ||\n                dissector_get_uint_handle(ie_dissector_table, (codeset << 8) | info_element)) {\n                next_tvb = tvb_new_subset_length (tvb, offset, info_element_len + 2);\n                if (dissector_try_uint(ie_dissector_table, (codeset << 8) | info_element, next_tvb, pinfo, q931_tree) ||\n                    dissector_try_uint(codeset_dissector_table, codeset, next_tvb, pinfo, q931_tree)) {\n                    offset += 2 + info_element_len;\n                    codeset = locked_codeset;\n                    continue;\n                }\n            }\n\n            ie_tree = proto_tree_add_subtree(q931_tree, tvb, offset, 1+1+info_element_len, ett_q931_ie[info_element], &ti,\n                    val_to_str(info_element, q931_info_element_vals[codeset], \"Unknown information element (0x%02X)\"));\n            proto_tree_add_uint_format_value(ie_tree, hf_q931_information_element, tvb, offset, 1, info_element, \"%s\",\n                    val_to_str(info_element, q931_info_element_vals[codeset], \"Unknown (0x%02X)\"));\n            proto_tree_add_uint(ie_tree, hf_q931_information_element_len, tvb, offset + 1, 1, info_element_len);\n\n            if (((codeset << 8) | info_element) == (CS0 | Q931_IE_SEGMENTED_MESSAGE)) {\n                dissect_q931_segmented_message_ie(tvb, pinfo, offset + 2, info_element_len, ie_tree, ti);\n                col_append_fstr(pinfo->cinfo, COL_INFO, \" of %s\",\n                        val_to_str_ext(tvb_get_guint8(tvb, offset + 3), &q931_message_type_vals_ext, \"Unknown message type (0x%02X)\"));\n\n                if (tvb_get_guint8(tvb, offset + 2) & 0x80) {  /* the 1st segment */\n                    first_segment = TRUE;\n                } else {  /* not the 1st segment */\n                    proto_tree_add_item(q931_tree, hf_q931_message_segment, tvb, offset + 4, -1, ENC_NA);\n                    info_element_len += tvb_reported_length_remaining(tvb, offset + 4);\n                }\n            } else {\n                /*\n                 * For the calling number, called number,\n                 * and release cause IEs, don't check\n                 * for the tree being null, as\n                 * the dissectors for those IEs also\n                 * supply information for the tap used\n                 * in VoIP calls.\n                 */\n                switch ((codeset << 8) | info_element) {\n\n                case CS0 | Q931_IE_BEARER_CAPABILITY:\n                case CS0 | Q931_IE_LOW_LAYER_COMPAT:\n                    if (q931_tree != NULL) {\n                        dissect_q931_bearer_capability_ie(tvb,\n                            offset + 2, info_element_len,\n                            ie_tree);\n                    }\n                    break;\n\n                case CS0 | Q931_IE_CAUSE:\n                    dissect_q931_cause_ie_with_info(tvb,\n                        offset + 2, info_element_len,\n                        ie_tree,\n                        hf_q931_cause_value, &dummy, q931_info_element_vals0, q931_pi);\n                    break;\n\n                case CS0 | Q931_IE_CHANGE_STATUS:\n                    if (q931_tree != NULL) {\n                        dissect_q931_change_status_ie(tvb,\n                            offset + 2, info_element_len,\n                            ie_tree);\n                    }\n                    break;\n\n                case CS0 | Q931_IE_CALL_STATE:\n                    if (q931_tree != NULL) {\n                        dissect_q931_call_state_ie(tvb,\n                            offset + 2, info_element_len,\n                            ie_tree);\n                    }\n                    break;\n\n                case CS0 | Q931_IE_CHANNEL_IDENTIFICATION:\n                    if (q931_tree != NULL) {\n                        dissect_q931_channel_identification_ie(\n                            tvb, offset + 2, info_element_len,\n                            ie_tree);\n                    }\n                    break;\n\n                case CS0 | Q931_IE_PROGRESS_INDICATOR:\n                    if (q931_tree != NULL) {\n                        dissect_q931_progress_indicator_ie(tvb,\n                            offset + 2, info_element_len,\n                            ie_tree);\n                    }\n                    break;\n\n                case CS0 | Q931_IE_NETWORK_SPECIFIC_FACIL:\n                case CS0 | Q931_IE_TRANSIT_NETWORK_SEL:\n                    if (q931_tree != NULL) {\n                        dissect_q931_ns_facilities_ie(tvb,\n                            offset + 2, info_element_len,\n                            ie_tree);\n                    }\n                    break;\n\n                case CS0 | Q931_IE_NOTIFICATION_INDICATOR:\n                    if (q931_tree != NULL) {\n                        dissect_q931_notification_indicator_ie(\n                            tvb, offset + 2, info_element_len,\n                            ie_tree);\n                    }\n                    break;\n\n                case CS0 | Q931_IE_DISPLAY:\n                    if (q931_tree != NULL) {\n                        dissect_q931_ia5_ie(tvb, offset + 2, info_element_len, ie_tree, hf_q931_display_information);\n                    }\n                    break;\n\n                case CS0 | Q931_IE_DATE_TIME:\n                    dissect_q931_date_time_ie(tvb, pinfo,\n                            offset + 2, info_element_len,\n                            ie_tree);\n                    break;\n\n                case CS0 | Q931_IE_KEYPAD_FACILITY:\n                    if (q931_tree != NULL) {\n                        dissect_q931_ia5_ie(tvb, offset + 2, info_element_len, ie_tree, hf_q931_keypad_facility);\n                    }\n                    break;\n\n                case CS0 | Q931_IE_SIGNAL:\n                    dissect_q931_signal_ie(tvb, pinfo,\n                            offset + 2, info_element_len,\n                            ie_tree, ti);\n                    break;\n\n                case CS0 | Q931_IE_INFORMATION_RATE:\n                    dissect_q931_information_rate_ie(tvb, pinfo,\n                            offset + 2, info_element_len,\n                            ie_tree, ti);\n                    break;\n\n                case CS0 | Q931_IE_E2E_TRANSIT_DELAY:\n                    dissect_q931_e2e_transit_delay_ie(tvb, pinfo,\n                            offset + 2, info_element_len,\n                            ie_tree, ti);\n                    break;\n\n                case CS0 | Q931_IE_TD_SELECTION_AND_INT:\n                    dissect_q931_td_selection_and_int_ie(\n                            tvb, pinfo, offset + 2, info_element_len,\n                            ie_tree, ti);\n                    break;\n\n                case CS0 | Q931_IE_PL_BINARY_PARAMETERS:\n                    if (q931_tree != NULL) {\n                        dissect_q931_pl_binary_parameters_ie(\n                            tvb, offset + 2, info_element_len,\n                            ie_tree);\n                    }\n                    break;\n\n                case CS0 | Q931_IE_PL_WINDOW_SIZE:\n                    if (q931_tree != NULL) {\n                        dissect_q931_pl_window_size_ie(tvb,\n                            offset + 2, info_element_len,\n                            ie_tree);\n                    }\n                    break;\n\n                case CS0 | Q931_IE_PACKET_SIZE:\n                    if (q931_tree != NULL) {\n                        dissect_q931_packet_size_ie(tvb,\n                            offset + 2, info_element_len,\n                            ie_tree);\n                    }\n                    break;\n\n                case CS0 | Q931_IE_CUG:\n                    if (q931_tree != NULL) {\n                        dissect_q931_cug_ie(tvb,\n                            offset + 2, info_element_len,\n                            ie_tree);\n                    }\n                    break;\n\n                case CS0 | Q931_IE_REVERSE_CHARGE_IND:\n                    if (q931_tree != NULL) {\n                        dissect_q931_reverse_charge_ind_ie(tvb,\n                            offset + 2, info_element_len,\n                            ie_tree);\n                    }\n                    break;\n\n                case CS0 | Q931_IE_CONNECTED_NUMBER_DEFAULT:\n                    if (q931_tree != NULL) {\n                        dissect_q931_number_ie(tvb,\n                            offset + 2, info_element_len,\n                            ie_tree,\n                            hf_q931_connected_number, e164_info, q931_pi);\n                    }\n                    break;\n\n\n                case CS0 | Q931_IE_CALLING_PARTY_NUMBER:\n                    e164_info.e164_number_type = CALLING_PARTY_NUMBER;\n                    dissect_q931_number_ie(tvb,\n                        offset + 2, info_element_len,\n                        ie_tree,\n                        hf_q931_calling_party_number, e164_info, q931_pi);\n                    break;\n\n                case CS0 | Q931_IE_CALLED_PARTY_NUMBER:\n                    e164_info.e164_number_type = CALLED_PARTY_NUMBER;\n                    dissect_q931_number_ie(tvb,\n                        offset + 2, info_element_len,\n                        ie_tree,\n                        hf_q931_called_party_number, e164_info, q931_pi);\n                    break;\n\n                case CS0 | Q931_IE_CALLING_PARTY_SUBADDR:\n                case CS0 | Q931_IE_CALLED_PARTY_SUBADDR:\n                    if (q931_tree != NULL) {\n                        dissect_q931_party_subaddr_ie(tvb,\n                            offset + 2, info_element_len,\n                            ie_tree);\n                    }\n                    break;\n\n                case CS0 | Q931_IE_REDIRECTING_NUMBER:\n                    if (q931_tree != NULL) {\n                        dissect_q931_number_ie(tvb,\n                            offset + 2, info_element_len,\n                            ie_tree,\n                            hf_q931_redirecting_number, e164_info, q931_pi);\n                    }\n                    break;\n\n                case CS0 | Q931_IE_RESTART_INDICATOR:\n                    dissect_q931_restart_indicator_ie(tvb, pinfo,\n                            offset + 2, info_element_len,\n                            ie_tree, ti);\n                    break;\n\n                case CS0 | Q931_IE_HIGH_LAYER_COMPAT:\n                    if (q931_tree != NULL) {\n                        dissect_q931_high_layer_compat_ie(tvb,\n                            offset + 2, info_element_len,\n                            ie_tree);\n                    }\n                    break;\n\n                case CS0 | Q931_IE_USER_USER:\n                    if (q931_tree != NULL) {\n                        dissect_q931_user_user_ie(tvb, pinfo,\n                            offset + 2, info_element_len,\n                            ie_tree);\n                    }\n                    break;\n\n                case CS5 | Q931_IE_PARTY_CATEGORY:\n                    if (q931_tree != NULL) {\n                        dissect_q931_party_category_ie(tvb,\n                            offset + 2, info_element_len,\n                            ie_tree);\n                    }\n                    break;\n\n                case CS6 | Q931_IE_DISPLAY:\n                    if (q931_tree != NULL) {\n                        dissect_q931_ia5_ie(tvb, offset + 2, info_element_len, ie_tree, hf_q931_avaya_display);\n                    }\n                    break;\n\n                default:\n                    if (q931_tree != NULL) {\n                        proto_tree_add_item(ie_tree, hf_q931_data, tvb,\n                            offset + 2, info_element_len, ENC_NA);\n                    }\n                    break;\n                }\n            }\n            offset += 1 + 1 + info_element_len;\n        }\n        codeset = locked_codeset;\n    }\n    tap_queue_packet(q931_tap, pinfo, q931_pi);\n}", "target": 2, "idx": 10042}
{"commit_id": "81cdb259fb6d8c1c4ecfeea389ff5a73c07f5755", "project": "torvalds/linux", "func": "static void rtc_irq_eoi_tracking_reset(struct kvm_ioapic *ioapic)\n{\n\tioapic->rtc_status.pending_eoi = 0;\n\tbitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPU_ID);\n}", "target": 2, "idx": 10043}
{"commit_id": "2e716c32be6aa20e1813b0002878853e71f8b2f4", "project": "wireshark", "func": "static guint32\ndissect_dcm_tag_value(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, dcm_state_pdv_t *pdv,\n                      guint32 offset, guint16 grp, guint16 elm,\n                      guint32 vl, guint32 vl_max, const gchar* vr, gchar **tag_value)\n{\n    /* Based on the value representation, decode the value of one tag. Returns new offset */\n\n    proto_item *pitem = NULL;\n\n    gboolean is_little_endian;\n\n    if (pdv->syntax == DCM_EBE) is_little_endian = FALSE;\n    else                        is_little_endian = TRUE;\n\n\n    /* Make sure we have all the bytes of the item; this should throw\n       and exception if vl_max is so large that it causes the offset\n       to overflow. */\n    tvb_ensure_bytes_exist(tvb, offset, vl_max);\n\n    /* ---------------------------------------------------------------------------\n       Potentially long types. Obey vl_max\n       ---------------------------------------------------------------------------\n    */\n\n    if ((strncmp(vr, \"AE\", 2) == 0) || (strncmp(vr, \"AS\", 2) == 0) || (strncmp(vr, \"CS\", 2) == 0) ||\n        (strncmp(vr, \"DA\", 2) == 0) || (strncmp(vr, \"DS\", 2) == 0) || (strncmp(vr, \"DT\", 2) == 0) ||\n        (strncmp(vr, \"IS\", 2) == 0) || (strncmp(vr, \"LO\", 2) == 0) || (strncmp(vr, \"LT\", 2) == 0) ||\n        (strncmp(vr, \"PN\", 2) == 0) || (strncmp(vr, \"SH\", 2) == 0) || (strncmp(vr, \"ST\", 2) == 0) ||\n        (strncmp(vr, \"TM\", 2) == 0) || (strncmp(vr, \"UI\", 2) == 0) || (strncmp(vr, \"UT\", 2) == 0) ) {\n        /* 15 ways to represent a string ... */\n\n        gchar   *vals;\n        dcm_uid_t *uid = NULL;\n        guint8 val8;\n\n        val8 = tvb_get_guint8(tvb, offset + vl_max - 1);\n        if (val8 == 0x00) {\n            /* Last byte of string is 0x00, i.e. padded */\n            vals = tvb_format_text(tvb, offset, vl_max - 1);\n        }\n        else {\n            vals = tvb_format_text(tvb, offset, vl_max);\n        }\n\n        if ((strncmp(vr, \"UI\", 2) == 0)) {\n            /* This is a UID. Attempt a lookup. Will only return something for classes of course */\n\n            uid = (dcm_uid_t *)g_hash_table_lookup(dcm_uid_table, (gpointer) vals);\n            if (uid) {\n                g_snprintf(*tag_value, MAX_BUF_LEN, \"%s (%s)\", vals, uid->name);\n            }\n            else {\n                g_snprintf(*tag_value, MAX_BUF_LEN, \"%s\", vals);\n            }\n        }\n        else {\n            if (strlen(vals) > 50) {\n                g_snprintf(*tag_value, MAX_BUF_LEN, \"%-50.50s...\", vals);\n            }\n            else {\n                g_snprintf(*tag_value, MAX_BUF_LEN, \"%s\", vals);\n            }\n        }\n        proto_tree_add_string_format(tree, hf_dcm_tag_value_str, tvb, offset, vl_max, *tag_value, \"%-8.8s%s\", \"Value:\", *tag_value);\n\n        if (grp == 0x0000 && elm == 0x0902) {\n            /* The error comment */\n            pdv->comment = wmem_strdup(wmem_file_scope(), g_strstrip(vals));\n        }\n    }\n    else if ((strncmp(vr, \"OB\", 2) == 0) || (strncmp(vr, \"OF\", 2) == 0) ||\n             (strncmp(vr, \"OW\", 2) == 0)) {\n        /* Array of Bytes, Float or Words. Don't perform any decoding */\n\n        proto_tree_add_bytes_format(tree, hf_dcm_tag_value_byte, tvb, offset, vl_max,\n            NULL, \"%-8.8s%s\", \"Value:\", \"(binary)\");\n\n        g_snprintf(*tag_value, MAX_BUF_LEN, \"(binary)\");\n    }\n    else if (strncmp(vr, \"UN\", 2) == 0) {\n        /* Usually the case for private tags in implicit syntax, since tag was not found and vr not specified */\n        guint8    val8;\n        gchar    *vals;\n        guint32  i;\n\n        /* String detector, i.e. check if we only have alpha-numeric character */\n        gboolean        is_string = TRUE;\n        gboolean        is_padded = FALSE;\n\n        for (i = 0; i < vl_max ; i++) {\n            val8 = tvb_get_guint8(tvb, offset + i);\n\n            if ((val8 == 0x09) || (val8 == 0x0A) || (val8 == 0x0D)) {\n                /* TAB, LF, CR */\n            }\n            else if ((val8 >= 0x20) && (val8 <= 0x7E)) {\n                /* No extended ASCII, 0-9, A-Z, a-z */\n            }\n            else if ((i == vl_max -1) && (val8 == 0x00)) {\n                /* Last Byte can be null*/\n                is_padded = TRUE;\n            }\n            else {\n                /* Here's the code */\n                is_string = FALSE;\n            }\n        }\n\n        if (is_string) {\n            vals = tvb_format_text(tvb, offset, (is_padded ? vl_max - 1 : vl_max));\n            proto_tree_add_string_format(tree, hf_dcm_tag_value_str, tvb, offset, vl_max,\n                vals, \"%-8.8s%s\", \"Value:\", vals);\n\n            g_snprintf(*tag_value, MAX_BUF_LEN, \"%s\", vals);\n        }\n        else {\n            proto_tree_add_bytes_format(tree, hf_dcm_tag_value_byte, tvb, offset, vl_max,\n                NULL, \"%-8.8s%s\", \"Value:\", \"(binary)\");\n\n            g_snprintf(*tag_value, MAX_BUF_LEN, \"(binary)\");\n        }\n    }\n    /* ---------------------------------------------------------------------------\n       Smaller types. vl/vl_max are not used. Fixed item length from 2 to 8 bytes\n       ---------------------------------------------------------------------------\n    */\n    else if (strncmp(vr, \"AT\", 2) == 0)  {      /* Attribute Tag */\n        /* 2*2 Bytes */\n\n        guint16 at_grp;\n        guint16 at_elm;\n        guint32 at_offset = 0;\n        const gchar *at_value = \"\";\n\n        while(at_offset < vl_max-3) {\n            if (is_little_endian)   at_grp = tvb_get_letohs(tvb, offset+at_offset);\n            else                    at_grp = tvb_get_ntohs(tvb, offset+at_offset);\n\n            if (is_little_endian)   at_elm = tvb_get_letohs(tvb, offset+at_offset+2);\n            else                    at_elm = tvb_get_ntohs(tvb, offset+at_offset+2);\n\n            proto_tree_add_uint_format(tree, hf_dcm_tag_value_32u, tvb, offset+at_offset, 4,\n                (at_grp << 16) | at_elm, \"%-8.8s%04x,%04x\", \"Value:\", at_grp, at_elm);\n\n            at_value = wmem_strdup_printf(wmem_packet_scope(),\"%s(%04x,%04x)\", at_value, at_grp, at_elm);\n\n            at_offset += 4;\n        }\n        g_snprintf(*tag_value, MAX_BUF_LEN, \"%s\", at_value);\n    }\n    else if (strncmp(vr, \"FL\", 2) == 0)  {      /* Single Float */\n\n        gfloat valf;\n\n        if (is_little_endian) valf = tvb_get_letohieee_float(tvb, offset);\n        else                  valf = tvb_get_ntohieee_float(tvb, offset);\n\n        proto_tree_add_bytes_format(tree, hf_dcm_tag_value_byte, tvb, offset, 4,\n            NULL, \"%-8.8s%f\", \"Value:\", valf);\n\n        g_snprintf(*tag_value, MAX_BUF_LEN, \"%f\", valf);\n    }\n    else if (strncmp(vr, \"FD\", 2) == 0)  {      /* Double Float */\n\n        gdouble vald;\n\n        if (is_little_endian) vald = tvb_get_letohieee_double(tvb, offset);\n        else                  vald = tvb_get_ntohieee_double(tvb, offset);\n\n        proto_tree_add_bytes_format(tree, hf_dcm_tag_value_byte, tvb, offset, 8,\n            NULL, \"%-8.8s%f\", \"Value:\", vald);\n\n        g_snprintf(*tag_value, MAX_BUF_LEN, \"%f\", vald);\n    }\n    else if (strncmp(vr, \"SL\", 2) == 0)  {          /* Signed Long */\n        gint32  val32;\n\n        if (is_little_endian)   val32 = tvb_get_letohl(tvb, offset);\n        else                    val32 = tvb_get_ntohl(tvb, offset);\n\n        proto_tree_add_int_format(tree, hf_dcm_tag_value_32s, tvb, offset, 4,\n            val32, \"%-8.8s%d\", \"Value:\", val32);\n\n        g_snprintf(*tag_value, MAX_BUF_LEN, \"%d\", val32);\n    }\n    else if (strncmp(vr, \"SS\", 2) == 0)  {          /* Signed Short */\n        gint16  val16;\n\n        if (is_little_endian)   val16 = tvb_get_letohs(tvb, offset);\n        else                    val16 = tvb_get_ntohs(tvb, offset);\n\n        proto_tree_add_int_format(tree, hf_dcm_tag_value_16s, tvb, offset, 2,\n            val16, \"%-8.8s%d\", \"Value:\", val16);\n\n        g_snprintf(*tag_value, MAX_BUF_LEN, \"%d\", val16);\n    }\n    else if (strncmp(vr, \"UL\", 2) == 0)  {          /* Unsigned Long */\n        guint32  val32;\n\n        if (is_little_endian)   val32 = tvb_get_letohl(tvb, offset);\n        else                    val32 = tvb_get_ntohl(tvb, offset);\n\n        proto_tree_add_uint_format(tree, hf_dcm_tag_value_32u, tvb, offset, 4,\n            val32, \"%-8.8s%u\", \"Value:\", val32);\n\n        g_snprintf(*tag_value, MAX_BUF_LEN, \"%u\", val32);\n    }\n    else if (strncmp(vr, \"US\", 2) == 0)  {          /* Unsigned Short */\n        const gchar *status_message = NULL;\n        guint16     val16;\n\n        if (is_little_endian)   val16 = tvb_get_letohs(tvb, offset);\n        else                    val16 = tvb_get_ntohs(tvb, offset);\n\n        if (grp == 0x0000 && elm == 0x0100) {\n            /* This is a command */\n            g_snprintf(*tag_value, MAX_BUF_LEN, \"%s\", dcm_cmd2str(val16));\n\n            pdv->command = wmem_strdup(wmem_file_scope(), *tag_value);\n        }\n        else if (grp == 0x0000 && elm == 0x0900) {\n            /* This is a status message. If value is not 0x0000, add an expert info */\n\n            status_message = dcm_rsp2str(val16);\n            g_snprintf(*tag_value, MAX_BUF_LEN, \"%s (0x%02x)\", status_message, val16);\n\n            if (val16 != 0x0000 && ((val16 & 0xFF00) != 0xFF00)) {\n                /* Not 0x0000 0xFFxx */\n                pdv->is_warning = TRUE;\n            }\n\n            pdv->status = wmem_strdup(wmem_file_scope(), status_message);\n\n        }\n        else {\n            g_snprintf(*tag_value, MAX_BUF_LEN, \"%u\", val16);\n        }\n\n        if (grp == 0x0000) {\n            if (elm == 0x0110) {                /* (0000,0110) Message ID */\n                pdv->message_id = val16;\n            }\n            else if (elm == 0x0120) {           /* (0000,0120) Message ID Being Responded To */\n                pdv->message_id_resp = val16;\n            }\n            else if (elm == 0x1020) {           /* (0000,1020) Number of Remaining Sub-operations */\n                pdv->no_remaining = val16;\n            }\n            else if (elm == 0x1021) {           /* (0000,1021) Number of Completed Sub-operations */\n                pdv->no_completed = val16;\n            }\n            else if (elm == 0x1022) {           /* (0000,1022) Number of Failed Sub-operations  */\n                pdv->no_failed = val16;\n            }\n            else if (elm == 0x1023) {           /* (0000,1023) Number of Warning Sub-operations */\n                pdv->no_warning = val16;\n            }\n        }\n\n        pitem = proto_tree_add_uint_format(tree, hf_dcm_tag_value_16u, tvb, offset, 2,\n                    val16, \"%-8.8s%s\", \"Value:\", *tag_value);\n\n        if (pdv->is_warning && status_message) {\n            expert_add_info(pinfo, pitem, &ei_dcm_status_msg);\n        }\n    }\n    /* Invalid VR, can only occur with Explicit syntax */\n    else {\n        proto_tree_add_bytes_format(tree, hf_dcm_tag_value_byte, tvb, offset, vl_max,\n            NULL, \"%-8.8s%s\", \"Value:\", (vl > vl_max ? \"\" : \"(unknown VR)\"));\n\n        g_snprintf(*tag_value, MAX_BUF_LEN, \"(unknown VR)\");\n    }\n    offset += vl_max;\n\n    return offset;\n\n}", "target": 2, "idx": 10044}
{"commit_id": "a30d7d90c4f718e46fb41a99b3d52800e1011b73", "project": "android", "func": "status_t BnGraphicBufferProducer::onTransact(\n    uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)\n{\n    switch(code) {\n        case REQUEST_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            int bufferIdx   = data.readInt32();\n            sp<GraphicBuffer> buffer;\n            int result = requestBuffer(bufferIdx, &buffer);\n            reply->writeInt32(buffer != 0);\n            if (buffer != 0) {\n                reply->write(*buffer);\n            }\n            reply->writeInt32(result);\n            return NO_ERROR;\n        }\n        case SET_BUFFER_COUNT: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            int bufferCount = data.readInt32();\n            int result = setBufferCount(bufferCount);\n            reply->writeInt32(result);\n            return NO_ERROR;\n        }\n        case DEQUEUE_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            bool async = static_cast<bool>(data.readInt32());\n            uint32_t width = data.readUint32();\n            uint32_t height = data.readUint32();\n            PixelFormat format = static_cast<PixelFormat>(data.readInt32());\n            uint32_t usage = data.readUint32();\n            int buf = 0;\n            sp<Fence> fence;\n            int result = dequeueBuffer(&buf, &fence, async, width, height,\n                    format, usage);\n            reply->writeInt32(buf);\n            reply->writeInt32(fence != NULL);\n            if (fence != NULL) {\n                reply->write(*fence);\n            }\n            reply->writeInt32(result);\n            return NO_ERROR;\n        }\n        case DETACH_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            int slot = data.readInt32();\n            int result = detachBuffer(slot);\n            reply->writeInt32(result);\n            return NO_ERROR;\n        }\n        case DETACH_NEXT_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            sp<GraphicBuffer> buffer;\n            sp<Fence> fence;\n            int32_t result = detachNextBuffer(&buffer, &fence);\n            reply->writeInt32(result);\n            if (result == NO_ERROR) {\n                reply->writeInt32(buffer != NULL);\n                if (buffer != NULL) {\n                    reply->write(*buffer);\n                }\n                reply->writeInt32(fence != NULL);\n                if (fence != NULL) {\n                    reply->write(*fence);\n                }\n            }\n            return NO_ERROR;\n        }\n        case ATTACH_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            sp<GraphicBuffer> buffer = new GraphicBuffer();\n            data.read(*buffer.get());\n            int slot = 0;\n            int result = attachBuffer(&slot, buffer);\n            reply->writeInt32(slot);\n            reply->writeInt32(result);\n            return NO_ERROR;\n        }\n        case QUEUE_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            int buf = data.readInt32();\n            QueueBufferInput input(data);\n            QueueBufferOutput* const output =\n                    reinterpret_cast<QueueBufferOutput *>(\n                            reply->writeInplace(sizeof(QueueBufferOutput)));\n            memset(output, 0, sizeof(QueueBufferOutput));\n            status_t result = queueBuffer(buf, input, output);\n            reply->writeInt32(result);\n            return NO_ERROR;\n        }\n        case CANCEL_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            int buf = data.readInt32();\n            sp<Fence> fence = new Fence();\n            data.read(*fence.get());\n            cancelBuffer(buf, fence);\n            return NO_ERROR;\n        }\n        case QUERY: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            int value = 0;\n            int what = data.readInt32();\n            int res = query(what, &value);\n            reply->writeInt32(value);\n            reply->writeInt32(res);\n            return NO_ERROR;\n        }\n        case CONNECT: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            sp<IProducerListener> listener;\n            if (data.readInt32() == 1) {\n                listener = IProducerListener::asInterface(data.readStrongBinder());\n            }\n            int api = data.readInt32();\n            bool producerControlledByApp = data.readInt32();\n            QueueBufferOutput* const output =\n                    reinterpret_cast<QueueBufferOutput *>(\n                            reply->writeInplace(sizeof(QueueBufferOutput)));\n            memset(output, 0, sizeof(QueueBufferOutput));\n            status_t res = connect(listener, api, producerControlledByApp, output);\n            reply->writeInt32(res);\n            return NO_ERROR;\n        }\n        case DISCONNECT: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            int api = data.readInt32();\n            status_t res = disconnect(api);\n            reply->writeInt32(res);\n            return NO_ERROR;\n        }\n        case SET_SIDEBAND_STREAM: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            sp<NativeHandle> stream;\n            if (data.readInt32()) {\n                stream = NativeHandle::create(data.readNativeHandle(), true);\n            }\n            status_t result = setSidebandStream(stream);\n            reply->writeInt32(result);\n            return NO_ERROR;\n        }\n        case ALLOCATE_BUFFERS: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            bool async = static_cast<bool>(data.readInt32());\n            uint32_t width = data.readUint32();\n            uint32_t height = data.readUint32();\n            PixelFormat format = static_cast<PixelFormat>(data.readInt32());\n            uint32_t usage = data.readUint32();\n            allocateBuffers(async, width, height, format, usage);\n            return NO_ERROR;\n        }\n        case ALLOW_ALLOCATION: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            bool allow = static_cast<bool>(data.readInt32());\n            status_t result = allowAllocation(allow);\n            reply->writeInt32(result);\n            return NO_ERROR;\n        }\n        case SET_GENERATION_NUMBER: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            uint32_t generationNumber = data.readUint32();\n            status_t result = setGenerationNumber(generationNumber);\n            reply->writeInt32(result);\n            return NO_ERROR;\n        }\n        case GET_CONSUMER_NAME: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            reply->writeString8(getConsumerName());\n            return NO_ERROR;\n        }\n    }\n    return BBinder::onTransact(code, data, reply, flags);\n}", "target": 1, "idx": 10045}
{"commit_id": "7e90aed666e809c0db5de9d1816802a7dcea28d9", "project": "wireshark", "func": "double asn1_get_real(const guint8 *real_ptr, gint len) {\n  guint8 octet;\n  const guint8 *p;\n  guint8 *buf;\n  double val = 0;\n\n  /* 8.5.2    If the real value is the value zero,\n   *          there shall be no contents octets in the encoding.\n   */\n  if (len < 1) return val;\n\n  octet = real_ptr[0];\n  p = real_ptr + 1;\n  len -= 1;\n  if (octet & 0x80) {  /* binary encoding */\n    int i;\n    gboolean Eneg;\n    gint8 S; /* Sign */\n    guint8 B; /* Base */\n    guint8 F; /* scaling Factor */\n    gint32 E = 0; /* Exponent (supported max 3 octets/24 bit) */\n    guint64 N = 0; /* N (supported max 8 octets/64 bit) */\n\n    guint8 lenE, lenN;\n\n    if(octet & 0x40) S = -1; else S = 1;\n    switch(octet & 0x30) {\n      case 0x00: B = 2; break;\n      case 0x10: B = 8; break;\n      case 0x20: B = 16; break;\n      case 0x30: /* Reserved */\n      default:\n        /* TODO Add some warning in tree about reserved value for Base */\n        return 0;\n    }\n    F = (octet & 0x0c) >> 2;\n\n    /* 8.5.6.4 Exponent length */\n    lenE = (octet & 0x3) + 1;\n    if(lenE == 4)\n    {\n      /* we can't handle exponents > 24 bits */\n      /* TODO Next octet(s) define length of exponent */\n      DISSECTOR_ASSERT_NOT_REACHED();\n    }\n\n    /* Ensure the buffer len and its content are coherent */\n    DISSECTOR_ASSERT(lenE < len - 1);\n\n    Eneg = (*p) & 0x80 ? TRUE : FALSE;\n    for (i = 0; i < lenE; i++) {\n      if(Eneg) {\n        /* 2's complement: inverse bits */\n        E = (E<<8) | ((guint8) ~(*p));\n      } else {\n        E = (E<<8) | *p;\n      }\n      p++;\n    }\n    if(Eneg) {\n      /* 2's complement: ... and add 1 (and make negative of course) */\n      E = -(E + 1);\n    }\n\n    lenN = len - lenE;\n    if(lenN > 8)\n    {\n      /* we can't handle integers > 64 bits */\n      DISSECTOR_ASSERT_NOT_REACHED();\n    }\n    for (i=0; i<lenN; i++) {\n      N = (N<<8) | *p;\n      p++;\n    }\n    val = (double) S * N * pow(2, F) * pow(B, E);\n#ifdef DEBUG\n    ws_debug_printf(\"S = %d, N = %lu, F = %u, B = %u, E = %d -> %f\\n\", S, N, F, B, E, val);\n#endif\n  } else if (octet & 0x40) {  /* SpecialRealValue */\n    switch (octet & 0x3F) {\n      case 0x00: val = HUGE_VAL; break;\n      case 0x01: val = -HUGE_VAL; break;\n    }\n  } else {  /* decimal encoding */\n    buf = g_strndup(p, len);\n    val = g_ascii_strtod(buf, NULL);\n    g_free(buf);\n  }\n\n  return val;\n}", "target": 2, "idx": 10046}
{"commit_id": "690b2549b19563ec5ad53e5c82f6a944d910086e", "project": "torvalds/linux", "func": "static int ismt_access(struct i2c_adapter *adap, u16 addr,\n\t\t       unsigned short flags, char read_write, u8 command,\n\t\t       int size, union i2c_smbus_data *data)\n{\n\tint ret;\n\tunsigned long time_left;\n\tdma_addr_t dma_addr = 0; /* address of the data buffer */\n\tu8 dma_size = 0;\n\tenum dma_data_direction dma_direction = 0;\n\tstruct ismt_desc *desc;\n\tstruct ismt_priv *priv = i2c_get_adapdata(adap);\n\tstruct device *dev = &priv->pci_dev->dev;\n\tu8 *dma_buffer = PTR_ALIGN(&priv->buffer[0], 16);\n\n\tdesc = &priv->hw[priv->head];\n\n\t/* Initialize the DMA buffer */\n\tmemset(priv->buffer, 0, sizeof(priv->buffer));\n\n\t/* Initialize the descriptor */\n\tmemset(desc, 0, sizeof(struct ismt_desc));\n\tdesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, read_write);\n\n\t/* Always clear the log entries */\n\tmemset(priv->log, 0, ISMT_LOG_ENTRIES * sizeof(u32));\n\n\t/* Initialize common control bits */\n\tif (likely(pci_dev_msi_enabled(priv->pci_dev)))\n\t\tdesc->control = ISMT_DESC_INT | ISMT_DESC_FAIR;\n\telse\n\t\tdesc->control = ISMT_DESC_FAIR;\n\n\tif ((flags & I2C_CLIENT_PEC) && (size != I2C_SMBUS_QUICK)\n\t    && (size != I2C_SMBUS_I2C_BLOCK_DATA))\n\t\tdesc->control |= ISMT_DESC_PEC;\n\n\tswitch (size) {\n\tcase I2C_SMBUS_QUICK:\n\t\tdev_dbg(dev, \"I2C_SMBUS_QUICK\\n\");\n\t\tbreak;\n\n\tcase I2C_SMBUS_BYTE:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t/*\n\t\t\t * Send Byte\n\t\t\t * The command field contains the write data\n\t\t\t */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE:  WRITE\\n\");\n\t\t\tdesc->control |= ISMT_DESC_CWRL;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t} else {\n\t\t\t/* Receive Byte */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE:  READ\\n\");\n\t\t\tdma_size = 1;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t\tdesc->rd_len = 1;\n\t\t}\n\t\tbreak;\n\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t/*\n\t\t\t * Write Byte\n\t\t\t * Command plus 1 data byte\n\t\t\t */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE_DATA:  WRITE\\n\");\n\t\t\tdesc->wr_len_cmd = 2;\n\t\t\tdma_size = 2;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdma_buffer[0] = command;\n\t\t\tdma_buffer[1] = data->byte;\n\t\t} else {\n\t\t\t/* Read Byte */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE_DATA:  READ\\n\");\n\t\t\tdesc->control |= ISMT_DESC_CWRL;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->rd_len = 1;\n\t\t\tdma_size = 1;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t}\n\t\tbreak;\n\n\tcase I2C_SMBUS_WORD_DATA:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t/* Write Word */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_WORD_DATA:  WRITE\\n\");\n\t\t\tdesc->wr_len_cmd = 3;\n\t\t\tdma_size = 3;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdma_buffer[0] = command;\n\t\t\tdma_buffer[1] = data->word & 0xff;\n\t\t\tdma_buffer[2] = data->word >> 8;\n\t\t} else {\n\t\t\t/* Read Word */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_WORD_DATA:  READ\\n\");\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->control |= ISMT_DESC_CWRL;\n\t\t\tdesc->rd_len = 2;\n\t\t\tdma_size = 2;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t}\n\t\tbreak;\n\n\tcase I2C_SMBUS_PROC_CALL:\n\t\tdev_dbg(dev, \"I2C_SMBUS_PROC_CALL\\n\");\n\t\tdesc->wr_len_cmd = 3;\n\t\tdesc->rd_len = 2;\n\t\tdma_size = 3;\n\t\tdma_direction = DMA_BIDIRECTIONAL;\n\t\tdma_buffer[0] = command;\n\t\tdma_buffer[1] = data->word & 0xff;\n\t\tdma_buffer[2] = data->word >> 8;\n\t\tbreak;\n\n\tcase I2C_SMBUS_BLOCK_DATA:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t/* Block Write */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BLOCK_DATA:  WRITE\\n\");\n\t\t\tdma_size = data->block[0] + 1;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdesc->wr_len_cmd = dma_size;\n\t\t\tdesc->control |= ISMT_DESC_BLK;\n\t\t\tdma_buffer[0] = command;\n\t\t\tmemcpy(&dma_buffer[1], &data->block[1], dma_size - 1);\n\t\t} else {\n\t\t\t/* Block Read */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BLOCK_DATA:  READ\\n\");\n\t\t\tdma_size = I2C_SMBUS_BLOCK_MAX;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t\tdesc->rd_len = dma_size;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->control |= (ISMT_DESC_BLK | ISMT_DESC_CWRL);\n\t\t}\n\t\tbreak;\n\n\tcase I2C_SMBUS_BLOCK_PROC_CALL:\n\t\tdev_dbg(dev, \"I2C_SMBUS_BLOCK_PROC_CALL\\n\");\n\t\tif (data->block[0] > I2C_SMBUS_BLOCK_MAX)\n\t\t\treturn -EINVAL;\n\n\t\tdma_size = I2C_SMBUS_BLOCK_MAX;\n\t\tdesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, 1);\n\t\tdesc->wr_len_cmd = data->block[0] + 1;\n\t\tdesc->rd_len = dma_size;\n\t\tdesc->control |= ISMT_DESC_BLK;\n\t\tdma_direction = DMA_BIDIRECTIONAL;\n\t\tdma_buffer[0] = command;\n\t\tmemcpy(&dma_buffer[1], &data->block[1], data->block[0]);\n\t\tbreak;\n\n\tcase I2C_SMBUS_I2C_BLOCK_DATA:\n\t\t/* Make sure the length is valid */\n\t\tif (data->block[0] < 1)\n\t\t\tdata->block[0] = 1;\n\n\t\tif (data->block[0] > I2C_SMBUS_BLOCK_MAX)\n\t\t\tdata->block[0] = I2C_SMBUS_BLOCK_MAX;\n\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t/* i2c Block Write */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_I2C_BLOCK_DATA:  WRITE\\n\");\n\t\t\tdma_size = data->block[0] + 1;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdesc->wr_len_cmd = dma_size;\n\t\t\tdesc->control |= ISMT_DESC_I2C;\n\t\t\tdma_buffer[0] = command;\n\t\t\tmemcpy(&dma_buffer[1], &data->block[1], dma_size - 1);\n\t\t} else {\n\t\t\t/* i2c Block Read */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_I2C_BLOCK_DATA:  READ\\n\");\n\t\t\tdma_size = data->block[0];\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t\tdesc->rd_len = dma_size;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->control |= (ISMT_DESC_I2C | ISMT_DESC_CWRL);\n\t\t\t/*\n\t\t\t * Per the \"Table 15-15. I2C Commands\",\n\t\t\t * in the External Design Specification (EDS),\n\t\t\t * (Document Number: 508084, Revision: 2.0),\n\t\t\t * the _rw bit must be 0\n\t\t\t */\n\t\t\tdesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, 0);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Unsupported transaction %d\\n\",\n\t\t\tsize);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t/* map the data buffer */\n\tif (dma_size != 0) {\n\t\tdev_dbg(dev, \" dev=%p\\n\", dev);\n\t\tdev_dbg(dev, \" data=%p\\n\", data);\n\t\tdev_dbg(dev, \" dma_buffer=%p\\n\", dma_buffer);\n\t\tdev_dbg(dev, \" dma_size=%d\\n\", dma_size);\n\t\tdev_dbg(dev, \" dma_direction=%d\\n\", dma_direction);\n\n\t\tdma_addr = dma_map_single(dev,\n\t\t\t\t      dma_buffer,\n\t\t\t\t      dma_size,\n\t\t\t\t      dma_direction);\n\n\t\tif (dma_mapping_error(dev, dma_addr)) {\n\t\t\tdev_err(dev, \"Error in mapping dma buffer %p\\n\",\n\t\t\t\tdma_buffer);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tdev_dbg(dev, \" dma_addr = %pad\\n\", &dma_addr);\n\n\t\tdesc->dptr_low = lower_32_bits(dma_addr);\n\t\tdesc->dptr_high = upper_32_bits(dma_addr);\n\t}\n\n\treinit_completion(&priv->cmp);\n\n\t/* Add the descriptor */\n\tismt_submit_desc(priv);\n\n\t/* Now we wait for interrupt completion, 1s */\n\ttime_left = wait_for_completion_timeout(&priv->cmp, HZ*1);\n\n\t/* unmap the data buffer */\n\tif (dma_size != 0)\n\t\tdma_unmap_single(dev, dma_addr, dma_size, dma_direction);\n\n\tif (unlikely(!time_left)) {\n\t\tdev_err(dev, \"completion wait timed out\\n\");\n\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\t/* do any post processing of the descriptor here */\n\tret = ismt_process_desc(desc, data, priv, size, read_write);\n\nout:\n\t/* Update the ring pointer */\n\tpriv->head++;\n\tpriv->head %= ISMT_DESC_ENTRIES;\n\n\treturn ret;\n}", "target": 1, "idx": 10047}
{"commit_id": "a06247c6804f1a7c86a2e5398a4c1f1db1471848", "project": "torvalds/linux", "func": "static ssize_t cgroup_pressure_write(struct kernfs_open_file *of, char *buf,\n\t\t\t\t\t  size_t nbytes, enum psi_res res)\n{\n\tstruct cgroup_file_ctx *ctx = of->priv;\n\tstruct psi_trigger *new;\n\tstruct cgroup *cgrp;\n\tstruct psi_group *psi;\n\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENODEV;\n\n\tcgroup_get(cgrp);\n\tcgroup_kn_unlock(of->kn);\n\n\t/* Allow only one trigger per file descriptor */\n\tif (ctx->psi.trigger) {\n\t\tcgroup_put(cgrp);\n\t\treturn -EBUSY;\n\t}\n\n\tpsi = cgroup_ino(cgrp) == 1 ? &psi_system : &cgrp->psi;\n\tnew = psi_trigger_create(psi, buf, nbytes, res);\n\tif (IS_ERR(new)) {\n\t\tcgroup_put(cgrp);\n\t\treturn PTR_ERR(new);\n\t}\n\n\tsmp_store_release(&ctx->psi.trigger, new);\n\tcgroup_put(cgrp);\n\n\treturn nbytes;\n}", "target": 2, "idx": 10048}
{"commit_id": "840f3af31a5b8d2d395d9367c826ed756e380fb9", "project": "eclipse-openj9/openj9", "func": "J9Method *   \nresolveStaticSplitMethodRef(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA splitTableIndex, UDATA resolveFlags)\n{\n\tJ9RAMStaticMethodRef *ramStaticMethodRef = (J9RAMStaticMethodRef *)&vmStruct->floatTemp1;\n\tU_16 cpIndex = *(J9ROMCLASS_STATICSPLITMETHODREFINDEXES(ramCP->ramClass->romClass) + splitTableIndex);\n\tJ9Method *method = ramCP->ramClass->staticSplitMethodTable[splitTableIndex];\n\n\tif (method == (J9Method*)vmStruct->javaVM->initialMethods.initialStaticMethod) {\n\t\tmethod = resolveStaticMethodRefInto(vmStruct, ramCP, cpIndex, resolveFlags, ramStaticMethodRef);\n\n\t\tif (NULL != method) {\n\t\t\t/* Check for <clinit> case. */\n\t\t\tif (((resolveFlags & J9_RESOLVE_FLAG_CHECK_CLINIT) == J9_RESOLVE_FLAG_CHECK_CLINIT)\n\t\t\t\t&& (J9_CLASS_FROM_METHOD(method)->initializeStatus == (UDATA)vmStruct)\n\t\t\t) {\n\t\t\t\treturn (J9Method *) -1;\n\t\t\t} else if (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\t\t\t\n\t\t\t\tramCP->ramClass->staticSplitMethodTable[splitTableIndex] = method;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn method;\n}", "target": 1, "idx": 10049}
{"commit_id": "7eb4a2c6272c6727595b974f24843cf7785c62b0", "project": "FISCO-BCOS", "func": "bool PBFTEngine::handleViewChangeMsg(ViewChangeMsgInterface::Ptr _viewChangeMsg)\n{\n    if (!isValidViewChangeMsg(_viewChangeMsg->from(), _viewChangeMsg))\n    {\n        return false;\n    }\n    m_cacheProcessor->addViewChangeReq(_viewChangeMsg);\n    // try to trigger fast view change if receive more than (f+1) valid view\n    // change messages whose view is greater than the current view: sends a\n    // view-change message for the smallest view in the set, even if its timer has\n    // not expired\n    auto leaderIndex =\n        m_config->leaderIndexInNewViewPeriod(_viewChangeMsg->index() + 1, _viewChangeMsg->index());\n    if (_viewChangeMsg->generatedFrom() == leaderIndex)\n    {\n        auto view = m_cacheProcessor->tryToTriggerFastViewChange();\n        if (view > 0)\n        {\n            // trigger timeout to reach fast view change\n            triggerTimeout();\n        }\n    }\n    auto newViewMsg = m_cacheProcessor->checkAndTryIntoNewView();\n    if (newViewMsg)\n    {\n        reHandlePrePrepareProposals(newViewMsg);\n        return true;\n    }\n    return true;\n}", "target": 2, "idx": 10050}
{"commit_id": "c927a3492698c254637da836762f9b1f86cffabc", "project": "openssl", "func": "static int nc_match(GENERAL_NAME *gen, NAME_CONSTRAINTS *nc)\n{\n    GENERAL_SUBTREE *sub;\n    int i, r, match = 0;\n    int effective_type = gen->type;\n\n    /*\n     * We need to compare not gen->type field but an \"effective\" type because\n     * the otherName field may contain EAI email address treated specially\n     * according to RFC 8398, section 6\n     */\n    if (effective_type == GEN_OTHERNAME &&\n        (OBJ_obj2nid(gen->d.otherName->type_id) == NID_id_on_SmtpUTF8Mailbox)) {\n        effective_type = GEN_EMAIL;\n    }\n\n    /*\n     * Permitted subtrees: if any subtrees exist of matching the type at\n     * least one subtree must match.\n     */\n\n    for (i = 0; i < sk_GENERAL_SUBTREE_num(nc->permittedSubtrees); i++) {\n        sub = sk_GENERAL_SUBTREE_value(nc->permittedSubtrees, i);\n        if (effective_type != sub->base->type\n            || (effective_type == GEN_OTHERNAME &&\n                OBJ_cmp(gen->d.otherName->type_id,\n                        sub->base->d.otherName->type_id) != 0))\n            continue;\n        if (!nc_minmax_valid(sub))\n            return X509_V_ERR_SUBTREE_MINMAX;\n        /* If we already have a match don't bother trying any more */\n        if (match == 2)\n            continue;\n        if (match == 0)\n            match = 1;\n        r = nc_match_single(effective_type, gen, sub->base);\n        if (r == X509_V_OK)\n            match = 2;\n        else if (r != X509_V_ERR_PERMITTED_VIOLATION)\n            return r;\n    }\n\n    if (match == 1)\n        return X509_V_ERR_PERMITTED_VIOLATION;\n\n    /* Excluded subtrees: must not match any of these */\n\n    for (i = 0; i < sk_GENERAL_SUBTREE_num(nc->excludedSubtrees); i++) {\n        sub = sk_GENERAL_SUBTREE_value(nc->excludedSubtrees, i);\n        if (effective_type != sub->base->type\n            || (effective_type == GEN_OTHERNAME &&\n                OBJ_cmp(gen->d.otherName->type_id,\n                        sub->base->d.otherName->type_id) != 0))\n            continue;\n        if (!nc_minmax_valid(sub))\n            return X509_V_ERR_SUBTREE_MINMAX;\n\n        r = nc_match_single(effective_type, gen, sub->base);\n        if (r == X509_V_OK)\n            return X509_V_ERR_EXCLUDED_VIOLATION;\n        else if (r != X509_V_ERR_PERMITTED_VIOLATION)\n            return r;\n\n    }\n\n    return X509_V_OK;\n\n}", "target": 1, "idx": 10051}
{"commit_id": "304a654a0d57bf0f00d8998185f0360332cfa36c", "project": "xorg/lib/libX11", "func": "WireToEventCookieType XESetWireToEventCookie(\n    Display *dpy,       /* display */\n    int extension,      /* extension major opcode */\n    WireToEventCookieType proc /* routine to call for generic events */\n    )\n{\n\tWireToEventCookieType oldproc;\n\tif (extension < FirstExtensionRequest ||\n\t    extension > LastExtensionRequest) {\n\t    fprintf(stderr, \"Xlib: ignoring invalid extension opcode %d\\n\",\n\t\t    extension);\n\t    return (WireToEventCookieType)_XUnknownWireEventCookie;\n\t}\n\tif (proc == NULL) proc = (WireToEventCookieType)_XUnknownWireEventCookie;\n\tLockDisplay (dpy);\n\toldproc = dpy->generic_event_vec[extension & 0x7F];\n\tdpy->generic_event_vec[extension & 0x7F] = proc;\n\tUnlockDisplay (dpy);\n\treturn (WireToEventCookieType)oldproc;\n}", "target": 2, "idx": 10052}
{"commit_id": "40d373ede795443ae6f2f756e9fb1f4f4ae90bbe", "project": "wireapp/wire-avs", "func": "static void prekey_handler(const char *userid,\n\t\t\t   const uint8_t *key, size_t key_len,\n\t\t\t   uint16_t id, const char *clientid,\n\t\t\t   bool last, void *arg)\n{\n\tstruct session *sess;\n\tchar lclientid[64];\n\tint err;\n\n\toutput(\"prekey_handler: %zu bytes, user:%s[%u] -> %s\\n\",\n\t       key_len, userid, id, clientid);\n\n\terr = client_id_load(lclientid, sizeof(lclientid));\n\tif (err) {\n\t\tdebug(\"my clientid not set -- cannot store prekeys\\n\");\n\t\treturn;\n\t}\n\n\tsess = cryptobox_session_find(g_cryptobox, userid, clientid, lclientid);\n\tif (sess) {\n\t\toutput(\"prekey: session found\\n\");\n\t}\n\telse {\n\t\tinfo(\"conv: adding key to cryptobox for clientid=%s\\n\",\n\t\t     clientid);\n\n\t\terr = cryptobox_session_add_send(g_cryptobox, userid, clientid, lclientid,\n\t\t\t\t\t\t key, key_len);\n\t\tif (err) {\n\t\t\twarning(\"cryptobox_session_add_send failed (%m)\\n\",\n\t\t\t\terr);\n\t\t}\n\t}\n\n\tif (last) {\n\t\toutput(\"prekey_handler: all prekeys fetched\\n\");\n\t}\n}", "target": 3, "idx": 10053}
{"commit_id": "7a7b5df84b6b4e5d599c7289526eed96541a0654", "project": "torvalds/linux", "func": "static int cp2112_gpio_get_all(struct gpio_chip *chip)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tint ret;\n\n\tmutex_lock(&dev->lock);\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_GET, buf,\n\t\t\t\t CP2112_GPIO_GET_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_GET_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO values: %d\\n\", ret);\n\t\tret = ret < 0 ? ret : -EIO;\n\t\tgoto exit;\n\t}\n\n\tret = buf[1];\n\nexit:\n\tmutex_unlock(&dev->lock);\n\n\treturn ret;\n}", "target": 1, "idx": 10054}
{"commit_id": "9f0fe9563366f62a71d34c92229da3432ec5cf0e", "project": "phaag/nfdump", "func": "void FixExtensionMap(extension_map_t *map) {\nint i, extension_size, max_elements;\n\n\tif (( map->size & 0x3 ) != 0 ) {\n\t\tprintf(\"PANIC! - Verify map id %i: WARNING: map size %i not aligned!\\n\", map->map_id, map->size);\n\t\texit(255);\n\t}\n\n\tif ( ((int)map->size - (int)sizeof(extension_map_t)) <= 0 ) {\n\t\tprintf(\"PANIC! - Verify map id %i: ERROR: map size %i too small!\\n\", map->map_id, map->size);\n\t\texit(255);\n\t}\n\n\tmax_elements = (map->size - sizeof(extension_map_t)) / sizeof(uint16_t);\n\textension_size = 0;\n\ti=0;\n\twhile (map->ex_id[i] && i <= max_elements) {\n\t\tint id = map->ex_id[i];\n\t\tif ( id > Max_num_extensions ) {\n\t\t\tprintf(\"PANIC! - Verify map id %i: ERROR: element id %i out of range [%i]!\\n\", map->map_id, id, Max_num_extensions);\n\t\t\texit(255);\n\t\t}\n\t\textension_size += extension_descriptor[id].size;\n\t\ti++;\n\t}\n\n\t// silently fix extension size bug of nfdump <= 1.6.2 ..\n\tif ( (extension_size != map->extension_size ) ) {\n#ifdef DEVEL\n\t\tprintf(\"FixExtension map extension size from %i to %i\\n\", map->extension_size, extension_size);\n#endif\n\t\tmap->extension_size = extension_size;\n\t}\n\n\tif ( (i != max_elements ) && ((max_elements-i) != 1) ) {\n\t\t// off by 1 is the opt alignment\n\t\tprintf(\"Verify map id %i: ERROR: Expected %i elements in map, but found %i!\\n\", map->map_id, max_elements, i);\n\t}\n\n}", "target": 2, "idx": 10055}
{"commit_id": "24182d959f661327525a20d9a94c98a8ec016778", "project": "the-tcpdump-group/tcpdump", "func": "const u_char *\nsmb_fdata(netdissect_options *ndo,\n          const u_char *buf, const char *fmt, const u_char *maxbuf,\n          int unicodestr)\n{\n    static int depth = 0;\n    char s[128];\n    char *p;\n\n    while (*fmt) {\n\tswitch (*fmt) {\n\tcase '*':\n\t    fmt++;\n\t    while (buf < maxbuf) {\n\t\tconst u_char *buf2;\n\t\tdepth++;\n\t\t/* Not sure how this relates with the protocol specification,\n\t\t * but in order to avoid stack exhaustion recurse at most that\n\t\t * many levels.\n\t\t */\n\t\tif (depth == 10)\n\t\t\tND_PRINT((ndo, \"(too many nested levels, not recursing)\"));\n\t\telse\n\t\t\tbuf2 = smb_fdata(ndo, buf, fmt, maxbuf, unicodestr);\n\t\tdepth--;\n\t\tif (buf2 == NULL)\n\t\t    return(NULL);\n\t\tif (buf2 == buf)\n\t\t    return(buf);\n\t\tbuf = buf2;\n\t    }\n\t    return(buf);\n\n\tcase '|':\n\t    fmt++;\n\t    if (buf >= maxbuf)\n\t\treturn(buf);\n\t    break;\n\n\tcase '%':\n\t    fmt++;\n\t    buf = maxbuf;\n\t    break;\n\n\tcase '#':\n\t    fmt++;\n\t    return(buf);\n\t    break;\n\n\tcase '[':\n\t    fmt++;\n\t    if (buf >= maxbuf)\n\t\treturn(buf);\n\t    memset(s, 0, sizeof(s));\n\t    p = strchr(fmt, ']');\n\t    if ((size_t)(p - fmt + 1) > sizeof(s)) {\n\t\t/* overrun */\n\t\treturn(buf);\n\t    }\n\t    strncpy(s, fmt, p - fmt);\n\t    s[p - fmt] = '\\0';\n\t    fmt = p + 1;\n\t    buf = smb_fdata1(ndo, buf, s, maxbuf, unicodestr);\n\t    if (buf == NULL)\n\t\treturn(NULL);\n\t    break;\n\n\tdefault:\n\t    ND_PRINT((ndo, \"%c\", *fmt));\n\t    fmt++;\n\t    break;\n\t}\n    }\n    if (!depth && buf < maxbuf) {\n\tsize_t len = PTR_DIFF(maxbuf, buf);\n\tND_PRINT((ndo, \"Data: (%lu bytes)\\n\", (unsigned long)len));\n\tsmb_print_data(ndo, buf, len);\n\treturn(buf + len);\n    }\n    return(buf);\n}", "target": 2, "idx": 10056}
{"commit_id": "6252d702c5311ce916caf75ed82e5c8245171c92", "project": "torvalds/linux", "func": "static inline void pud_free_tlb(struct mmu_gather *tlb, pud_t *pud)\n{\n#ifdef __s390x__\n\tif (tlb->mm->context.asce_limit <= (1UL << 42))\n\t\treturn;\n\tif (!tlb->fullmm) {\n\t\ttlb->array[--tlb->nr_pxds] = pud;\n\t\tif (tlb->nr_ptes >= tlb->nr_pxds)\n\t\t\ttlb_flush_mmu(tlb, 0, 0);\n\t} else\n\t\tpud_free(tlb->mm, pud);\n#endif\n}", "target": 2, "idx": 10057}
{"commit_id": "b8dcfeb065bbfd777cdc5f5433da9a87f25e6ec6", "project": "chromium", "func": "bool BindingSecurity::shouldAllowAccessToFrame(v8::Isolate* isolate, const LocalDOMWindow* accessingWindow, const Frame* target, SecurityReportingOption reportingOption)\n{\n    if (!target || !target->securityContext())\n        return false;\n    return canAccessFrame(accessingWindow, target->securityContext()->getSecurityOrigin(), target->domWindow(), reportingOption);\n}", "target": 1, "idx": 10058}
{"commit_id": "8136138492ab51ae8a311be589b8b131d04125ce", "project": "kiwix/libkiwix", "func": "std::unique_ptr<Response> InternalServer::handle_content(const RequestContext& request)\n{\n  const std::string url = request.get_url();\n  const std::string pattern = url.substr((url.find_last_of('/'))+1);\n  if (m_verbose.load()) {\n    printf(\"** running handle_content\\n\");\n  }\n\n  const std::string bookName = get_book_name(request);\n  if (bookName.empty())\n    return build_homepage(request);\n\n  std::shared_ptr<zim::Archive> archive;\n  try {\n    const std::string bookId = mp_nameMapper->getIdForName(bookName);\n    archive = mp_library->getArchiveById(bookId);\n  } catch (const std::out_of_range& e) {}\n\n  if (archive == nullptr) {\n    std::string searchURL = m_root + \"/search?pattern=\" + kiwix::urlEncode(pattern, true); // Make a full search on the entire library.\n    const std::string details = searchSuggestionHTML(searchURL, kiwix::urlDecode(pattern));\n\n    return Response::build_404(*this, request.get_full_url(), bookName, \"\", details);\n  }\n\n  auto urlStr = request.get_url().substr(bookName.size()+1);\n  if (urlStr[0] == '/') {\n    urlStr = urlStr.substr(1);\n  }\n\n  try {\n    auto entry = getEntryFromPath(*archive, urlStr);\n    if (entry.isRedirect() || urlStr.empty()) {\n      // If urlStr is empty, we want to mainPage.\n      // We must do a redirection to the real page.\n      return build_redirect(bookName, getFinalItem(*archive, entry));\n    }\n    auto response = ItemResponse::build(*this, request, entry.getItem());\n    try {\n      dynamic_cast<ContentResponse&>(*response).set_taskbar(bookName, getArchiveTitle(*archive));\n    } catch (std::bad_cast& e) {}\n\n    if (m_verbose.load()) {\n      printf(\"Found %s\\n\", entry.getPath().c_str());\n      printf(\"mimeType: %s\\n\", entry.getItem(true).getMimetype().c_str());\n    }\n\n    return response;\n  } catch(zim::EntryNotFound& e) {\n    if (m_verbose.load())\n      printf(\"Failed to find %s\\n\", urlStr.c_str());\n\n    std::string searchURL = m_root + \"/search?content=\" + bookName + \"&pattern=\" + kiwix::urlEncode(pattern, true); // Make a search on this specific book only.\n    const std::string details = searchSuggestionHTML(searchURL, kiwix::urlDecode(pattern));\n\n    return Response::build_404(*this, request.get_full_url(), bookName, getArchiveTitle(*archive), details);\n  }\n}", "target": 1, "idx": 10059}
{"commit_id": "817b8b9c5396d2b2d92311b46719aad5d3339dbe", "project": "torvalds/linux", "func": "static int elo_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tstruct elo_priv *priv;\n\tint ret;\n\tstruct usb_device *udev;\n\n\tif (!hid_is_usb(hdev))\n\t\treturn -EINVAL;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tINIT_DELAYED_WORK(&priv->work, elo_work);\n\tudev = interface_to_usbdev(to_usb_interface(hdev->dev.parent));\n\tpriv->usbdev = usb_get_dev(udev);\n\n\thid_set_drvdata(hdev, priv);\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\tif (elo_broken_firmware(priv->usbdev)) {\n\t\thid_info(hdev, \"broken firmware found, installing workaround\\n\");\n\t\tqueue_delayed_work(wq, &priv->work, ELO_PERIODIC_READ_INTERVAL);\n\t}\n\n\treturn 0;\nerr_free:\n\tusb_put_dev(udev);\n\tkfree(priv);\n\treturn ret;\n}", "target": 1, "idx": 10060}
{"commit_id": "9c22495e5eeeae9e00a1596720c969656bb8d678", "project": "libtiff", "func": "static int correct_orientation(struct image_data *image,\n                               unsigned char **work_buff_ptr)\n{\n    uint16_t mirror, rotation;\n    unsigned char *work_buff;\n\n    work_buff = *work_buff_ptr;\n    if ((image == NULL) || (work_buff == NULL))\n    {\n        TIFFError(\"correct_orientatin\", \"Invalid image or buffer pointer\");\n        return (-1);\n    }\n\n    if ((image->adjustments & MIRROR_HORIZ) ||\n        (image->adjustments & MIRROR_VERT))\n    {\n        mirror = (uint16_t)(image->adjustments & MIRROR_BOTH);\n        if (mirrorImage(image->spp, image->bps, mirror, image->width,\n                        image->length, work_buff))\n        {\n            TIFFError(\"correct_orientation\", \"Unable to mirror image\");\n            return (-1);\n        }\n    }\n\n    if (image->adjustments & ROTATE_ANY)\n    {\n        if (image->adjustments & ROTATECW_90)\n            rotation = (uint16_t)90;\n        else if (image->adjustments & ROTATECW_180)\n            rotation = (uint16_t)180;\n        else if (image->adjustments & ROTATECW_270)\n            rotation = (uint16_t)270;\n        else\n        {\n            TIFFError(\"correct_orientation\", \"Invalid rotation value: %\" PRIu16,\n                      (uint16_t)(image->adjustments & ROTATE_ANY));\n            return (-1);\n        }\n\n        if (rotateImage(rotation, image, &image->width, &image->length,\n                        work_buff_ptr, NULL))\n        {\n            TIFFError(\"correct_orientation\", \"Unable to rotate image\");\n            return (-1);\n        }\n        image->orientation = ORIENTATION_TOPLEFT;\n    }\n\n    return (0);\n}", "target": 1, "idx": 10061}
{"commit_id": "6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91", "project": "torvalds/linux", "func": "static int\ncheck_compat_entry_size_and_hooks(struct compat_ipt_entry *e,\n\t\t\t\t  struct xt_table_info *newinfo,\n\t\t\t\t  unsigned int *size,\n\t\t\t\t  const unsigned char *base,\n\t\t\t\t  const unsigned char *limit,\n\t\t\t\t  const unsigned int *hook_entries,\n\t\t\t\t  const unsigned int *underflows,\n\t\t\t\t  const char *name)\n{\n\tstruct xt_entry_match *ematch;\n\tstruct xt_entry_target *t;\n\tstruct xt_target *target;\n\tunsigned int entry_offset;\n\tunsigned int j;\n\tint ret, off, h;\n\n\tduprintf(\"check_compat_entry_size_and_hooks %p\\n\", e);\n\tif ((unsigned long)e % __alignof__(struct compat_ipt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct compat_ipt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p, limit = %p\\n\", e, limit);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset < sizeof(struct compat_ipt_entry) +\n\t\t\t     sizeof(struct compat_xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\t/* For purposes of check_entry casting the compat entry is fine */\n\tret = check_entry((struct ipt_entry *)e);\n\tif (ret)\n\t\treturn ret;\n\n\toff = sizeof(struct ipt_entry) - sizeof(struct compat_ipt_entry);\n\tentry_offset = (void *)e - (void *)base;\n\tj = 0;\n\txt_ematch_foreach(ematch, e) {\n\t\tret = compat_find_calc_match(ematch, name, &e->ip, &off);\n\t\tif (ret != 0)\n\t\t\tgoto release_matches;\n\t\t++j;\n\t}\n\n\tt = compat_ipt_get_target(e);\n\ttarget = xt_request_find_target(NFPROTO_IPV4, t->u.user.name,\n\t\t\t\t\tt->u.user.revision);\n\tif (IS_ERR(target)) {\n\t\tduprintf(\"check_compat_entry_size_and_hooks: `%s' not found\\n\",\n\t\t\t t->u.user.name);\n\t\tret = PTR_ERR(target);\n\t\tgoto release_matches;\n\t}\n\tt->u.kernel.target = target;\n\n\toff += xt_compat_target_offset(target);\n\t*size += off;\n\tret = xt_compat_add_offset(AF_INET, entry_offset, off);\n\tif (ret)\n\t\tgoto out;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h])\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t}\n\n\t/* Clear counters and comefrom */\n\tmemset(&e->counters, 0, sizeof(e->counters));\n\te->comefrom = 0;\n\treturn 0;\n\nout:\n\tmodule_put(t->u.kernel.target->me);\nrelease_matches:\n\txt_ematch_foreach(ematch, e) {\n\t\tif (j-- == 0)\n\t\t\tbreak;\n\t\tmodule_put(ematch->u.kernel.match->me);\n\t}\n\treturn ret;\n}", "target": 2, "idx": 10062}
{"commit_id": "73a8c425adaad7526de81586fcb053acde807757", "project": "gpac", "func": "static s32 naludmx_parse_nal_avc(GF_NALUDmxCtx *ctx, char *data, u32 size, u32 nal_type, Bool *skip_nal, Bool *is_slice, Bool *is_islice)\n{\n\ts32 ps_idx = 0;\n\ts32 res = 0;\n\n\tif (!size) return -1;\n\tgf_bs_reassign_buffer(ctx->bs_r, data, size);\n\t*skip_nal = GF_FALSE;\n\tres = gf_avc_parse_nalu(ctx->bs_r, ctx->avc_state);\n\tif (res < 0) {\n\t\tif (res == -1) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Error parsing NAL unit type %u\\n\", ctx->log_name, nal_type));\n\t\t}\n\t\t*skip_nal = GF_TRUE;\n\t}\n\tctx->nb_nalus++;\n\n\tswitch (nal_type) {\n\tcase GF_AVC_NALU_SVC_SUBSEQ_PARAM:\n\tcase GF_AVC_NALU_SEQ_PARAM:\n\t\tps_idx = ctx->avc_state->last_ps_idx;\n\t\tif (ps_idx<0) {\n\t\t\tif (ctx->avc_state->sps[0].profile_idc) {\n\t\t\t\tGF_LOG(ctx->avc_state->sps[0].profile_idc ? GF_LOG_WARNING : GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Error parsing Sequence Param Set\\n\", ctx->log_name));\n\t\t\t}\n\t\t} else {\n\t\t\tnaludmx_queue_param_set(ctx, data, size, GF_AVC_NALU_SEQ_PARAM, ps_idx, 0, 0);\n\t\t}\n\t\t*skip_nal = GF_TRUE;\n\t\treturn 0;\n\n\tcase GF_AVC_NALU_PIC_PARAM:\n\t\tps_idx = ctx->avc_state->last_ps_idx;\n\t\tif (ps_idx<0) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Error parsing Picture Param Set\\n\", ctx->log_name));\n\t\t} else {\n\t\t\tnaludmx_queue_param_set(ctx, data, size, GF_AVC_NALU_PIC_PARAM, ps_idx, 0, 0);\n\t\t}\n\t\t*skip_nal = GF_TRUE;\n\t\treturn 0;\n\n\tcase GF_AVC_NALU_SEQ_PARAM_EXT:\n\t\tps_idx = ctx->avc_state->last_ps_idx;\n\t\tif (ps_idx<0) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Error parsing Sequence Param Set Extension\\n\", ctx->log_name));\n\t\t} else {\n\t\t\tnaludmx_queue_param_set(ctx, data, size, GF_AVC_NALU_SEQ_PARAM_EXT, ps_idx, 0, 0);\n\t\t}\n\t\t*skip_nal = GF_TRUE;\n\t\treturn 0;\n\n\tcase GF_AVC_NALU_SEI:\n\t\tif (ctx->avc_state->sps_active_idx != -1) {\n\t\t\tnaludmx_push_prefix(ctx, data, size, GF_TRUE);\n\n\t\t\t*skip_nal = GF_TRUE;\n\n\t\t\tif (ctx->nosei) {\n\t\t\t\tctx->sei_buffer_size = 0;\n\t\t\t} else {\n\t\t\t\tctx->nb_sei++;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\n\tcase GF_AVC_NALU_ACCESS_UNIT:\n\t\tctx->nb_aud++;\n\t\tif (!ctx->audelim) {\n\t\t\t*skip_nal = GF_TRUE;\n\t\t} else if (!ctx->opid) {\n\t\t\tctx->has_initial_aud = GF_TRUE;\n\t\t\tmemcpy(ctx->init_aud, data, 2);\n\t\t}\n\t\treturn 1;\n\t/*remove*/\n\tcase GF_AVC_NALU_FILLER_DATA:\n\tcase GF_AVC_NALU_END_OF_SEQ:\n\tcase GF_AVC_NALU_END_OF_STREAM:\n\t\t*skip_nal = GF_TRUE;\n\t\treturn 0;\n\n\t//update stats\n\tcase GF_AVC_NALU_NON_IDR_SLICE:\n\tcase GF_AVC_NALU_DP_A_SLICE:\n\tcase GF_AVC_NALU_DP_B_SLICE:\n\tcase GF_AVC_NALU_DP_C_SLICE:\n\tcase GF_AVC_NALU_IDR_SLICE:\n\t\t*is_slice = GF_TRUE;\n\t\tswitch (ctx->avc_state->s_info.slice_type) {\n\t\tcase GF_AVC_TYPE_P:\n\t\tcase GF_AVC_TYPE2_P:\n\t\t\tctx->nb_p++;\n\t\t\tbreak;\n\t\tcase GF_AVC_TYPE_I:\n\t\tcase GF_AVC_TYPE2_I:\n\t\t\tctx->nb_i++;\n\t\t\t*is_islice = GF_TRUE;\n\t\t\tbreak;\n\t\tcase GF_AVC_TYPE_B:\n\t\tcase GF_AVC_TYPE2_B:\n\t\t\tctx->nb_b++;\n\t\t\tbreak;\n\t\tcase GF_AVC_TYPE_SP:\n\t\tcase GF_AVC_TYPE2_SP:\n\t\t\tctx->nb_sp++;\n\t\t\tbreak;\n\t\tcase GF_AVC_TYPE_SI:\n\t\tcase GF_AVC_TYPE2_SI:\n\t\t\tctx->nb_si++;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase GF_AVC_NALU_SVC_SLICE:\n\t\tif (!ctx->explicit) {\n\t\t\tu32 i;\n\t\t\tfor (i = 0; i < gf_list_count(ctx->pps); i ++) {\n\t\t\t\tGF_NALUFFParam *slc = (GF_NALUFFParam*)gf_list_get(ctx->pps, i);\n\t\t\t\tif (ctx->avc_state->s_info.pps && ctx->avc_state->s_info.pps->id == slc->id) {\n\t\t\t\t\t/* This PPS is used by an SVC NAL unit, it should be moved to the SVC Config Record) */\n\t\t\t\t\tgf_list_rem(ctx->pps, i);\n\t\t\t\t\ti--;\n\t\t\t\t\tif (!ctx->pps_svc) ctx->pps_svc = gf_list_new(ctx->pps_svc);\n\t\t\t\t\tgf_list_add(ctx->pps_svc, slc);\n\t\t\t\t\tctx->ps_modified = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t*is_slice = GF_TRUE;\n\t\t//we disable temporal scalability when parsing mvc - never used and many encoders screw up POC in enhancemen\n\t\tif (ctx->is_mvc && (res>=0)) {\n\t\t\tres=0;\n\t\t\tctx->avc_state->s_info.poc = ctx->last_poc;\n\t\t}\n        if (ctx->avc_state->s_info.sps) {\n            switch (ctx->avc_state->s_info.slice_type) {\n            case GF_AVC_TYPE_P:\n            case GF_AVC_TYPE2_P:\n                ctx->avc_state->s_info.sps->nb_ep++;\n                break;\n            case GF_AVC_TYPE_I:\n            case GF_AVC_TYPE2_I:\n                ctx->avc_state->s_info.sps->nb_ei++;\n                break;\n            case GF_AVC_TYPE_B:\n            case GF_AVC_TYPE2_B:\n                ctx->avc_state->s_info.sps->nb_eb++;\n                break;\n            }\n        }\n        break;\n\tcase GF_AVC_NALU_SLICE_AUX:\n\t\t*is_slice = GF_TRUE;\n\t\tbreak;\n\n\tcase GF_AVC_NALU_DV_RPU:\n\t\tif (ctx->dv_mode==DVMODE_CLEAN) {\n\t\t\t*skip_nal = GF_TRUE;\n\t\t} else {\n\t\t\tctx->nb_dv_rpu ++;\n\t\t\tif (ctx->nb_dv_rpu==1)\n\t\t\t\tnaludmx_set_dolby_vision(ctx);\n\t\t}\n\t\tbreak;\n\tcase GF_AVC_NALU_DV_EL:\n\t\tif ((ctx->dv_mode==DVMODE_CLEAN) || (ctx->dv_mode==DVMODE_SINGLE)) {\n\t\t\t*skip_nal = GF_TRUE;\n\t\t} else {\n\t\t\tctx->nb_dv_el ++;\n\t\t\tif (ctx->nb_dv_el==1)\n\t\t\t\tnaludmx_set_dolby_vision(ctx);\n\t\t}\n\t\tbreak;\n\t}\n\treturn res;\n}", "target": 2, "idx": 10063}
{"commit_id": "0a00c43d64c58a85e6250120f2377302675b0fe3", "project": "facebook/proxygen", "func": "void detachThreadLocals() {\n    resetControlMessages_.cancelTimeout();\n    resetDirectErrors_.cancelTimeout();\n    resetHeaders_.cancelTimeout();\n    timer_ = nullptr;\n    // Free pass when switching threads\n    numControlMsgsInCurrentInterval_ = 0;\n    numDirectErrorHandlingInCurrentInterval_ = 0;\n  }", "target": 2, "idx": 10064}
{"commit_id": "7e112c1563632f57cfa1c4fa964987f823da17fa", "project": "chromium", "func": "void PasswordGenerationAgent::ShowEditingPopup() {\n  if (!render_frame())\n    return;\n  Send(new AutofillHostMsg_ShowPasswordEditingPopup(\n           routing_id(),\n           render_frame()->GetRenderView()->ElementBoundsInWindow(\n               generation_element_),\n           *generation_form_data_->form));\n  editing_popup_shown_ = true;\n}", "target": 2, "idx": 10065}
{"commit_id": "65a259a0258b2036b168cdeff6e9db434471225a", "project": "libvips", "func": "static float\nvips_mask_point( VipsPoint *point, int x, int y )\n{\n\tVipsMask *mask = VIPS_MASK( point ); \n\tVipsMaskClass *class = VIPS_MASK_GET_CLASS( point ); \n\n\t/* VIPS_MAX to prevent /0.\n\t */\n\tint half_width = VIPS_MAX( point->width / 2, 1 );\n\tint half_height = VIPS_MAX( point->height / 2, 1 );\n\n\tdouble result;\n\n\t/* Move centre for an optical transform mask.\n\t */\n\tif( !mask->optical ) {\n\t\tx = (x + half_width) % point->width;\n\t\ty = (y + half_height) % point->height;\n\t}\n\n\tx = x - half_width;\n\ty = y - half_height;\n\n\tif( !mask->nodc && \n\t\tx == 0 &&\n\t\ty == 0 )\n\t\t/* DC component is always 1.\n\t\t */\n\t\tresult = 1.0;\n\telse {\n\t\tdouble dx, dy;\n\n\t\tdx = (double) x / half_width;\n\t\tdy = (double) y / half_height;\n\n\t\tresult = class->point( mask, dx, dy );\n\n\t\t/* Invert filter sense for a highpass filter, or to swap\n\t\t * band-pass for band-reject. \n\t\t */\n\t\tif( mask->reject )\n\t\t\tresult = 1.0 - result;\n\t}\n\n\treturn( result ); \n}", "target": 1, "idx": 10066}
{"commit_id": "54d83fc74aa9ec72794373cb47432c5f7fb1a309", "project": "torvalds/linux", "func": "static int mark_source_chains(const struct xt_table_info *newinfo,\n\t\t\t      unsigned int valid_hooks, void *entry0)\n{\n\tunsigned int hook;\n\n\t/* No recursion; use packet counter to save back ptrs (reset\n\t * to 0 as we leave), and comefrom to save source hook bitmask.\n\t */\n\tfor (hook = 0; hook < NF_ARP_NUMHOOKS; hook++) {\n\t\tunsigned int pos = newinfo->hook_entry[hook];\n\t\tstruct arpt_entry *e\n\t\t\t= (struct arpt_entry *)(entry0 + pos);\n\n\t\tif (!(valid_hooks & (1 << hook)))\n\t\t\tcontinue;\n\n\t\t/* Set initial back pointer. */\n\t\te->counters.pcnt = pos;\n\n\t\tfor (;;) {\n\t\t\tconst struct xt_standard_target *t\n\t\t\t\t= (void *)arpt_get_target_c(e);\n\t\t\tint visited = e->comefrom & (1 << hook);\n\n\t\t\tif (e->comefrom & (1 << NF_ARP_NUMHOOKS)) {\n\t\t\t\tpr_notice(\"arptables: loop hook %u pos %u %08X.\\n\",\n\t\t\t\t       hook, pos, e->comefrom);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\te->comefrom\n\t\t\t\t|= ((1 << hook) | (1 << NF_ARP_NUMHOOKS));\n\n\t\t\t/* Unconditional return/END. */\n\t\t\tif ((unconditional(e) &&\n\t\t\t     (strcmp(t->target.u.user.name,\n\t\t\t\t     XT_STANDARD_TARGET) == 0) &&\n\t\t\t     t->verdict < 0) || visited) {\n\t\t\t\tunsigned int oldpos, size;\n\n\t\t\t\tif ((strcmp(t->target.u.user.name,\n\t\t\t\t\t    XT_STANDARD_TARGET) == 0) &&\n\t\t\t\t    t->verdict < -NF_MAX_VERDICT - 1) {\n\t\t\t\t\tduprintf(\"mark_source_chains: bad \"\n\t\t\t\t\t\t\"negative verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tt->verdict);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\t/* Return: backtrack through the last\n\t\t\t\t * big jump.\n\t\t\t\t */\n\t\t\t\tdo {\n\t\t\t\t\te->comefrom ^= (1<<NF_ARP_NUMHOOKS);\n\t\t\t\t\toldpos = pos;\n\t\t\t\t\tpos = e->counters.pcnt;\n\t\t\t\t\te->counters.pcnt = 0;\n\n\t\t\t\t\t/* We're at the start. */\n\t\t\t\t\tif (pos == oldpos)\n\t\t\t\t\t\tgoto next;\n\n\t\t\t\t\te = (struct arpt_entry *)\n\t\t\t\t\t\t(entry0 + pos);\n\t\t\t\t} while (oldpos == pos + e->next_offset);\n\n\t\t\t\t/* Move along one */\n\t\t\t\tsize = e->next_offset;\n\t\t\t\te = (struct arpt_entry *)\n\t\t\t\t\t(entry0 + pos + size);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos += size;\n\t\t\t} else {\n\t\t\t\tint newpos = t->verdict;\n\n\t\t\t\tif (strcmp(t->target.u.user.name,\n\t\t\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t\t\t    newpos >= 0) {\n\t\t\t\t\tif (newpos > newinfo->size -\n\t\t\t\t\t\tsizeof(struct arpt_entry)) {\n\t\t\t\t\t\tduprintf(\"mark_source_chains: \"\n\t\t\t\t\t\t\t\"bad verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tnewpos);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* This a jump; chase it. */\n\t\t\t\t\tduprintf(\"Jump rule %u -> %u\\n\",\n\t\t\t\t\t\t pos, newpos);\n\t\t\t\t} else {\n\t\t\t\t\t/* ... this is a fallthru */\n\t\t\t\t\tnewpos = pos + e->next_offset;\n\t\t\t\t}\n\t\t\t\te = (struct arpt_entry *)\n\t\t\t\t\t(entry0 + newpos);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos = newpos;\n\t\t\t}\n\t\t}\nnext:\n\t\tduprintf(\"Finished chain %u\\n\", hook);\n\t}\n\treturn 1;\n}", "target": 2, "idx": 10067}
{"commit_id": "21674033ee246f698887604c7af7ba1962a40ddf", "project": "OSGeo/gdal", "func": "static int\ngtStripContig(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n\tTIFF* tif = img->tif;\n\ttileContigRoutine put = img->put.contig;\n\tuint32 row, y, nrow, nrowsub, rowstoread;\n\ttmsize_t pos;\n\tunsigned char* buf = NULL;\n\tuint32 rowsperstrip;\n\tuint16 subsamplinghor,subsamplingver;\n\tuint32 imagewidth = img->width;\n\ttmsize_t scanline;\n\tint32 fromskew, toskew;\n\tint ret = 1, flip;\n        tmsize_t maxstripsize;\n\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_YCBCRSUBSAMPLING, &subsamplinghor, &subsamplingver);\n\tif( subsamplingver == 0 ) {\n\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"Invalid vertical YCbCr subsampling\");\n\t\treturn (0);\n\t}\n\t\n\tmaxstripsize = TIFFStripSize(tif);\n\n\tflip = setorientation(img);\n\tif (flip & FLIP_VERTICALLY) {\n\t\ty = h - 1;\n\t\ttoskew = -(int32)(w + w);\n\t} else {\n\t\ty = 0;\n\t\ttoskew = -(int32)(w - w);\n\t}\n\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n\n\tscanline = TIFFScanlineSize(tif);\n\tfromskew = (w < imagewidth ? imagewidth - w : 0);\n\tfor (row = 0; row < h; row += nrow)\n\t{\n\t\tuint32 temp;\n\t\trowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n\t\tnrow = (row + rowstoread > h ? h - row : rowstoread);\n\t\tnrowsub = nrow;\n\t\tif ((nrowsub%subsamplingver)!=0)\n\t\t\tnrowsub+=subsamplingver-nrowsub%subsamplingver;\n\t\ttemp = (row + img->row_offset)%rowsperstrip + nrowsub;\n\t\tif( scanline > 0 && temp > (size_t)(TIFF_TMSIZE_T_MAX / scanline) )\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"Integer overflow in gtStripContig\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (_TIFFReadEncodedStripAndAllocBuffer(tif,\n\t\t    TIFFComputeStrip(tif,row+img->row_offset, 0),\n\t\t    (void**)(&buf),\n                    maxstripsize,\n\t\t    temp * scanline)==(tmsize_t)(-1)\n\t\t    && (buf == NULL || img->stoponerr))\n\t\t{\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tpos = ((row + img->row_offset) % rowsperstrip) * scanline + \\\n\t\t\t((tmsize_t) img->col_offset * img->samplesperpixel);\n\t\t(*put)(img, raster+y*w, 0, y, w, nrow, fromskew, toskew, buf + pos);\n\t\ty += ((flip & FLIP_VERTICALLY) ? -(int32) nrow : (int32) nrow);\n\t}\n\n\tif (flip & FLIP_HORIZONTALLY) {\n\t\tuint32 line;\n\n\t\tfor (line = 0; line < h; line++) {\n\t\t\tuint32 *left = raster + (line * w);\n\t\t\tuint32 *right = left + w - 1;\n\n\t\t\twhile ( left < right ) {\n\t\t\t\tuint32 temp = *left;\n\t\t\t\t*left = *right;\n\t\t\t\t*right = temp;\n\t\t\t\tleft++;\n\t\t\t\tright--;\n\t\t\t}\n\t\t}\n\t}\n\n\t_TIFFfree(buf);\n\treturn (ret);\n}", "target": 2, "idx": 10068}
{"commit_id": "2b16dbd8f73269cb15ca61ece75cf8d2d196ed28", "project": "ArtifexSoftware/mupdf", "func": "static void\nsvg_run_use(fz_context *ctx, fz_device *dev, svg_document *doc, fz_xml *root, const svg_state *inherit_state)\n{\n\tsvg_state local_state = *inherit_state;\n\n\tchar *xlink_href_att = fz_xml_att(root, \"xlink:href\");\n\tchar *x_att = fz_xml_att(root, \"x\");\n\tchar *y_att = fz_xml_att(root, \"y\");\n\n\tfloat x = 0;\n\tfloat y = 0;\n\n\tsvg_parse_common(ctx, doc, root, &local_state);\n\tif (x_att) x = svg_parse_length(x_att, local_state.viewbox_w, local_state.fontsize);\n\tif (y_att) y = svg_parse_length(y_att, local_state.viewbox_h, local_state.fontsize);\n\n\tfz_pre_translate(&local_state.transform, x, y);\n\n\tif (xlink_href_att && xlink_href_att[0] == '#')\n\t{\n\t\tfz_xml *linked = fz_tree_lookup(ctx, doc->idmap, xlink_href_att + 1);\n\t\tif (linked)\n\t\t{\n\t\t\tif (fz_xml_is_tag(linked, \"symbol\"))\n\t\t\t\tsvg_run_use_symbol(ctx, dev, doc, root, linked, &local_state);\n\t\t\telse\n\t\t\t\tsvg_run_element(ctx, dev, doc, linked, &local_state);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfz_warn(ctx, \"svg: cannot find linked symbol\");\n}", "target": 2, "idx": 10069}
{"commit_id": "afb9ff7982971aba6e42472de0db4c1bedfc641b", "project": "wireshark", "func": "static void\nmbim_dissect_providers(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gint offset)\n{\n    proto_tree *subtree;\n    gint base_offset;\n    guint32 i, elem_count;\n    wmem_array_t *pair_list;\n    struct mbim_pair_list pair_list_item, *p_pair_list_item;\n\n    base_offset = offset;\n    proto_tree_add_item_ret_uint(tree, hf_mbim_providers_elem_count, tvb, offset, 4, ENC_LITTLE_ENDIAN, &elem_count);\n    offset += 4;\n    if (elem_count) {\n        pair_list = wmem_array_new(wmem_packet_scope(), sizeof(struct mbim_pair_list));\n        subtree = proto_tree_add_subtree(tree, tvb, offset, 8*elem_count, ett_mbim_pair_list, NULL, \"Providers Ref List\");\n        for (i = 0; i < elem_count; i++) {\n            proto_tree_add_item_ret_uint(subtree, hf_mbim_providers_provider_offset, tvb, offset, 4, ENC_LITTLE_ENDIAN, &pair_list_item.offset);\n            offset += 4;\n            proto_tree_add_item_ret_uint(subtree, hf_mbim_providers_provider_size, tvb, offset, 4, ENC_LITTLE_ENDIAN, &pair_list_item.size);\n            offset += 4;\n            wmem_array_append_one(pair_list, pair_list_item);\n        }\n        for (i = 0; i < elem_count; i++) {\n            p_pair_list_item = (struct mbim_pair_list*)wmem_array_index(pair_list, i);\n            if (p_pair_list_item->offset && p_pair_list_item->size) {\n                subtree = proto_tree_add_subtree_format(tree, tvb, base_offset + p_pair_list_item->offset, p_pair_list_item->size,\n                            ett_mbim_pair_list, NULL, \"Provider #%u\", i+1);\n                mbim_dissect_provider(tvb, pinfo, subtree, base_offset + p_pair_list_item->offset);\n            }\n        }\n    }\n}", "target": 2, "idx": 10070}
{"commit_id": "cf6da6b79080a8c16984102fdc85f7ce28dca613", "project": "python-pillow/Pillow", "func": "static void\nj2ku_gray_l(opj_image_t *in, const JPEG2KTILEINFO *tileinfo,\n            const UINT8 *tiledata, Imaging im)\n{\n    unsigned x0 = tileinfo->x0 - in->x0, y0 = tileinfo->y0 - in->y0;\n    unsigned w = tileinfo->x1 - tileinfo->x0;\n    unsigned h = tileinfo->y1 - tileinfo->y0;\n\n    int shift = 8 - in->comps[0].prec;\n    int offset = in->comps[0].sgnd ? 1 << (in->comps[0].prec - 1) : 0;\n    int csiz = (in->comps[0].prec + 7) >> 3;\n\n    unsigned x, y;\n\n    if (csiz == 3)\n        csiz = 4;\n\n    if (shift < 0)\n        offset += 1 << (-shift - 1);\n\n    /* csiz*h*w + offset = tileinfo.datasize */\n    switch (csiz) {\n    case 1:\n        for (y = 0; y < h; ++y) {\n            const UINT8 *data = &tiledata[y * w];\n            UINT8 *row = (UINT8 *)im->image[y0 + y] + x0;\n            for (x = 0; x < w; ++x)\n                *row++ = j2ku_shift(offset + *data++, shift);\n        }\n        break;\n    case 2:\n        for (y = 0; y < h; ++y) {\n            const UINT16 *data = (const UINT16 *)&tiledata[2 * y * w];\n            UINT8 *row = (UINT8 *)im->image[y0 + y] + x0;\n            for (x = 0; x < w; ++x)\n                *row++ = j2ku_shift(offset + *data++, shift);\n        }\n        break;\n    case 4:\n        for (y = 0; y < h; ++y) {\n            const UINT32 *data = (const UINT32 *)&tiledata[4 * y * w];\n            UINT8 *row = (UINT8 *)im->image[y0 + y] + x0;\n            for (x = 0; x < w; ++x)\n                *row++ = j2ku_shift(offset + *data++, shift);\n        }\n        break;\n    }\n}", "target": 1, "idx": 10071}
{"commit_id": "6410733a8a0dff2fe581338ff631670cf91889db", "project": "xen-project/xen", "func": "static int _put_page_type(struct page_info *page, bool preemptible,\n                          struct page_info *ptpg)\n{\n    unsigned long nx, x, y = page->u.inuse.type_info;\n    int rc = 0;\n\n    for ( ; ; )\n    {\n        x  = y;\n        nx = x - 1;\n\n        ASSERT((x & PGT_count_mask) != 0);\n\n        if ( unlikely((nx & PGT_count_mask) == 0) )\n        {\n            if ( unlikely((nx & PGT_type_mask) <= PGT_l4_page_table) &&\n                 likely(nx & (PGT_validated|PGT_partial)) )\n            {\n                /*\n                 * Page-table pages must be unvalidated when count is zero. The\n                 * 'free' is safe because the refcnt is non-zero and validated\n                 * bit is clear => other ops will spin or fail.\n                 */\n                nx = x & ~(PGT_validated|PGT_partial);\n                if ( unlikely((y = cmpxchg(&page->u.inuse.type_info,\n                                           x, nx)) != x) )\n                    continue;\n                /* We cleared the 'valid bit' so we do the clean up. */\n                rc = _put_final_page_type(page, x, preemptible, ptpg);\n                ptpg = NULL;\n                if ( x & PGT_partial )\n                    put_page(page);\n                break;\n            }\n\n            if ( ptpg && PGT_type_equal(x, ptpg->u.inuse.type_info) )\n            {\n                /*\n                 * set_tlbflush_timestamp() accesses the same union\n                 * linear_pt_count lives in. Unvalidated page table pages,\n                 * however, should occur during domain destruction only\n                 * anyway.  Updating of linear_pt_count luckily is not\n                 * necessary anymore for a dying domain.\n                 */\n                ASSERT(page_get_owner(page)->is_dying);\n                ASSERT(page->linear_pt_count < 0);\n                ASSERT(ptpg->linear_pt_count > 0);\n                ptpg = NULL;\n            }\n\n            set_tlbflush_timestamp(page);\n        }\n        else if ( unlikely((nx & (PGT_locked | PGT_count_mask)) ==\n                           (PGT_locked | 1)) )\n        {\n            /*\n             * We must not drop the second to last reference when the page is\n             * locked, as page_unlock() doesn't do any cleanup of the type.\n             */\n            cpu_relax();\n            y = page->u.inuse.type_info;\n            continue;\n        }\n\n        if ( likely((y = cmpxchg(&page->u.inuse.type_info, x, nx)) == x) )\n            break;\n\n        if ( preemptible && hypercall_preempt_check() )\n            return -EINTR;\n    }\n\n    if ( ptpg && PGT_type_equal(x, ptpg->u.inuse.type_info) )\n    {\n        ASSERT(!rc);\n        dec_linear_uses(page);\n        dec_linear_entries(ptpg);\n    }\n\n    return rc;\n}", "target": 1, "idx": 10072}
{"commit_id": "7e27a9d5f22f9f7ead11738b1546d0b5c737266b", "project": "binutils-gdb", "func": "static void\nihex_bad_byte (bfd *abfd, unsigned int lineno, int c, bfd_boolean error)\n{\n  if (c == EOF)\n    {\n      if (! error)\n\tbfd_set_error (bfd_error_file_truncated);\n    }\n  else\n    {\n      char buf[10];\n\n      if (! ISPRINT (c))\n\tsprintf (buf, \"\\\\%03o\", (unsigned int) c & 0xff);\n      else\n\t{\n\t  buf[0] = c;\n\t  buf[1] = '\\0';\n\t}\n      (*_bfd_error_handler)\n\t(_(\"%B:%d: unexpected character `%s' in Intel Hex file\"),\n\t abfd, lineno, buf);\n      bfd_set_error (bfd_error_bad_value);\n    }\n}", "target": 3, "idx": 10073}
{"commit_id": "256825d4eb33dc301496710d15cf5a7ae924088b", "project": "ImageMagick", "func": "static MagickBooleanType TIFFWritePhotoshopLayers(Image* image,\n  const ImageInfo *image_info,EndianType endian,ExceptionInfo *exception)\n{\n  BlobInfo\n    *blob;\n\n  CustomStreamInfo\n    *custom_stream;\n\n  Image\n    *base_image,\n    *next;\n\n  ImageInfo\n    *clone_info;\n\n  MagickBooleanType\n    status;\n\n  PhotoshopProfile\n    profile;\n\n  PSDInfo\n    info;\n\n  StringInfo\n    *layers;\n\n  base_image=CloneImage(image,0,0,MagickFalse,exception);\n  if (base_image == (Image *) NULL)\n    return(MagickTrue);\n  clone_info=CloneImageInfo(image_info);\n  if (clone_info == (ImageInfo *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  profile.offset=0;\n  profile.quantum=MagickMinBlobExtent;\n  layers=AcquireStringInfo(profile.quantum);\n  if (layers == (StringInfo *) NULL)\n    {\n      base_image=DestroyImage(base_image);\n      clone_info=DestroyImageInfo(clone_info);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  profile.data=layers;\n  profile.extent=layers->length;\n  custom_stream=TIFFAcquireCustomStreamForWriting(&profile,exception);\n  if (custom_stream == (CustomStreamInfo *) NULL)\n    {\n      base_image=DestroyImage(base_image);\n      clone_info=DestroyImageInfo(clone_info);\n      layers=DestroyStringInfo(layers);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  blob=CloneBlobInfo((BlobInfo *) NULL);\n  if (blob == (BlobInfo *) NULL)\n    {\n      base_image=DestroyImage(base_image);\n      clone_info=DestroyImageInfo(clone_info);\n      layers=DestroyStringInfo(layers);\n      custom_stream=DestroyCustomStreamInfo(custom_stream);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  DestroyBlob(base_image);\n  base_image->blob=blob;\n  next=base_image;\n  while (next != (Image *) NULL)\n    next=SyncNextImageInList(next);\n  AttachCustomStream(base_image->blob,custom_stream);\n  InitPSDInfo(image,&info);\n  base_image->endian=endian;\n  WriteBlobString(base_image,\"Adobe Photoshop Document Data Block\");\n  WriteBlobByte(base_image,0);\n  WriteBlobString(base_image,base_image->endian == LSBEndian ? \"MIB8ryaL\" :\n    \"8BIMLayr\");\n  status=WritePSDLayers(base_image,clone_info,&info,exception);\n  if (status != MagickFalse)\n    {\n      SetStringInfoLength(layers,(size_t) profile.offset);\n      status=SetImageProfile(image,\"tiff:37724\",layers,exception);\n    }\n  next=base_image;\n  while (next != (Image *) NULL)\n  {\n    CloseBlob(next);\n    next=next->next;\n  }\n  layers=DestroyStringInfo(layers);\n  clone_info=DestroyImageInfo(clone_info);\n  custom_stream=DestroyCustomStreamInfo(custom_stream);\n  return(status);\n}", "target": 1, "idx": 10074}
{"commit_id": "790c2f9d15b594350ae9bca7b236f2b1859de02c", "project": "torvalds/linux", "func": "static ssize_t unix_stream_sendpage(struct socket *socket, struct page *page,\n\t\t\t\t    int offset, size_t size, int flags)\n{\n\tint err;\n\tbool send_sigpipe = false;\n\tbool init_scm = true;\n\tstruct scm_cookie scm;\n\tstruct sock *other, *sk = socket->sk;\n\tstruct sk_buff *skb, *newskb = NULL, *tail = NULL;\n\n\tif (flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tother = unix_peer(sk);\n\tif (!other || sk->sk_state != TCP_ESTABLISHED)\n\t\treturn -ENOTCONN;\n\n\tif (false) {\nalloc_skb:\n\t\tspin_unlock(&other->sk_receive_queue.lock);\n\t\tunix_state_unlock(other);\n\t\tmutex_unlock(&unix_sk(other)->iolock);\n\t\tnewskb = sock_alloc_send_pskb(sk, 0, 0, flags & MSG_DONTWAIT,\n\t\t\t\t\t      &err, 0);\n\t\tif (!newskb)\n\t\t\tgoto err;\n\t}\n\n\t/* we must acquire iolock as we modify already present\n\t * skbs in the sk_receive_queue and mess with skb->len\n\t */\n\terr = mutex_lock_interruptible(&unix_sk(other)->iolock);\n\tif (err) {\n\t\terr = flags & MSG_DONTWAIT ? -EAGAIN : -ERESTARTSYS;\n\t\tgoto err;\n\t}\n\n\tif (sk->sk_shutdown & SEND_SHUTDOWN) {\n\t\terr = -EPIPE;\n\t\tsend_sigpipe = true;\n\t\tgoto err_unlock;\n\t}\n\n\tunix_state_lock(other);\n\n\tif (sock_flag(other, SOCK_DEAD) ||\n\t    other->sk_shutdown & RCV_SHUTDOWN) {\n\t\terr = -EPIPE;\n\t\tsend_sigpipe = true;\n\t\tgoto err_state_unlock;\n\t}\n\n\tif (init_scm) {\n\t\terr = maybe_init_creds(&scm, socket, other);\n\t\tif (err)\n\t\t\tgoto err_state_unlock;\n\t\tinit_scm = false;\n\t}\n\n\tspin_lock(&other->sk_receive_queue.lock);\n\tskb = skb_peek_tail(&other->sk_receive_queue);\n\tif (tail && tail == skb) {\n\t\tskb = newskb;\n\t} else if (!skb || !unix_skb_scm_eq(skb, &scm)) {\n\t\tif (newskb) {\n\t\t\tskb = newskb;\n\t\t} else {\n\t\t\ttail = skb;\n\t\t\tgoto alloc_skb;\n\t\t}\n\t} else if (newskb) {\n\t\t/* this is fast path, we don't necessarily need to\n\t\t * call to kfree_skb even though with newskb == NULL\n\t\t * this - does no harm\n\t\t */\n\t\tconsume_skb(newskb);\n\t\tnewskb = NULL;\n\t}\n\n\tif (skb_append_pagefrags(skb, page, offset, size)) {\n\t\ttail = skb;\n\t\tgoto alloc_skb;\n\t}\n\n\tskb->len += size;\n\tskb->data_len += size;\n\tskb->truesize += size;\n\trefcount_add(size, &sk->sk_wmem_alloc);\n\n\tif (newskb) {\n\t\tunix_scm_to_skb(&scm, skb, false);\n\t\t__skb_queue_tail(&other->sk_receive_queue, newskb);\n\t}\n\n\tspin_unlock(&other->sk_receive_queue.lock);\n\tunix_state_unlock(other);\n\tmutex_unlock(&unix_sk(other)->iolock);\n\n\tother->sk_data_ready(other);\n\tscm_destroy(&scm);\n\treturn size;\n\nerr_state_unlock:\n\tunix_state_unlock(other);\nerr_unlock:\n\tmutex_unlock(&unix_sk(other)->iolock);\nerr:\n\tkfree_skb(newskb);\n\tif (send_sigpipe && !(flags & MSG_NOSIGNAL))\n\t\tsend_sig(SIGPIPE, current, 0);\n\tif (!init_scm)\n\t\tscm_destroy(&scm);\n\treturn err;\n}", "target": 2, "idx": 10075}
{"commit_id": "2646e6c1558bac66285daeab54c7d490ed332b15", "project": "laverdet/isolated-vm", "func": "auto Phase3() -> Local<Value> final {\n\t\t\treturn Undefined(Isolate::GetCurrent());\n\t\t}", "target": 2, "idx": 10076}
{"commit_id": "b7f6cbb9d43f7384e1f38f8764b9a48216c8a525", "project": "xen-project/xen", "func": "static void\n__gnttab_unmap_common_complete(struct gnttab_unmap_common *op)\n{\n    struct domain *ld, *rd = op->rd;\n    struct grant_table *rgt;\n    struct active_grant_entry *act;\n    grant_entry_header_t *sha;\n    struct page_info *pg;\n    uint16_t *status;\n\n    if ( rd == NULL )\n    { \n        /*\n         * Suggests that __gntab_unmap_common failed in\n         * rcu_lock_domain_by_id() or earlier, and so we have nothing\n         * to complete\n         */\n        return;\n    }\n\n    ld = current->domain;\n\n    rcu_lock_domain(rd);\n    rgt = rd->grant_table;\n\n    grant_read_lock(rgt);\n    if ( rgt->gt_version == 0 )\n        goto unlock_out;\n\n    act = active_entry_acquire(rgt, op->ref);\n    sha = shared_entry_header(rgt, op->ref);\n\n    if ( rgt->gt_version == 1 )\n        status = &sha->flags;\n    else\n        status = &status_entry(rgt, op->ref);\n\n    if ( unlikely(op->frame != act->frame) ) \n    {\n        /*\n         * Suggests that __gntab_unmap_common failed early and so\n         * nothing further to do\n         */\n        goto act_release_out;\n    }\n\n    pg = mfn_to_page(op->frame);\n\n    if ( op->flags & GNTMAP_device_map ) \n    {\n        if ( !is_iomem_page(_mfn(act->frame)) )\n        {\n            if ( op->flags & GNTMAP_readonly )\n                put_page(pg);\n            else\n                put_page_and_type(pg);\n        }\n\n        ASSERT(act->pin & (GNTPIN_devw_mask | GNTPIN_devr_mask));\n        if ( op->flags & GNTMAP_readonly )\n            act->pin -= GNTPIN_devr_inc;\n        else\n            act->pin -= GNTPIN_devw_inc;\n    }\n\n    if ( (op->host_addr != 0) && (op->flags & GNTMAP_host_map) )\n    {\n        if ( op->status != 0 ) \n        {\n            /*\n             * Suggests that __gntab_unmap_common failed in\n             * replace_grant_host_mapping() or IOMMU handling, so nothing\n             * further to do (short of re-establishing the mapping in the\n             * latter case).\n             */\n            goto act_release_out;\n        }\n\n        if ( !is_iomem_page(_mfn(op->frame)) )\n        {\n            if ( gnttab_host_mapping_get_page_type(op, ld, rd) )\n                put_page_type(pg);\n            put_page(pg);\n        }\n\n        ASSERT(act->pin & (GNTPIN_hstw_mask | GNTPIN_hstr_mask));\n        if ( op->flags & GNTMAP_readonly )\n            act->pin -= GNTPIN_hstr_inc;\n        else\n            act->pin -= GNTPIN_hstw_inc;\n    }\n\n    if ( ((act->pin & (GNTPIN_devw_mask|GNTPIN_hstw_mask)) == 0) &&\n         !(op->flags & GNTMAP_readonly) )\n        gnttab_clear_flag(_GTF_writing, status);\n\n    if ( act->pin == 0 )\n        gnttab_clear_flag(_GTF_reading, status);\n\n act_release_out:\n    active_entry_release(act);\n unlock_out:\n    grant_read_unlock(rgt);\n\n    rcu_unlock_domain(rd);\n}", "target": 3, "idx": 10077}
{"commit_id": "2864e767053317538feafa815046fff89e5a16be", "project": "bminor/glibc", "func": "static char *\nexpand_dynamic_string_token (struct link_map *l, const char *s)\n{\n  /* We make two runs over the string.  First we determine how large the\n     resulting string is and then we copy it over.  Since this is now\n     frequently executed operation we are looking here not for performance\n     but rather for code size.  */\n  size_t cnt;\n  size_t total;\n  char *result;\n\n  /* Determine the number of DST elements.  */\n  cnt = DL_DST_COUNT (s, 1);\n\n  /* If we do not have to replace anything simply copy the string.  */\n  if (cnt == 0)\n    return local_strdup (s);\n\n  /* Determine the length of the substituted string.  */\n  total = DL_DST_REQUIRED (l, s, strlen (s), cnt);\n\n  /* Allocate the necessary memory.  */\n  result = (char *) malloc (total + 1);\n  if (result == NULL)\n    return NULL;\n\n  return DL_DST_SUBSTITUTE (l, s, result, 1);\n}", "target": 3, "idx": 10078}
{"commit_id": "16ce101db85db694a91380aa4c89b25530871d33", "project": "torvalds/linux", "func": "int\nsvm_range_restore_pages(struct amdgpu_device *adev, unsigned int pasid,\n\t\t\tuint64_t addr, bool write_fault)\n{\n\tstruct mm_struct *mm = NULL;\n\tstruct svm_range_list *svms;\n\tstruct svm_range *prange;\n\tstruct kfd_process *p;\n\tktime_t timestamp = ktime_get_boottime();\n\tint32_t best_loc;\n\tint32_t gpuidx = MAX_GPU_INSTANCE;\n\tbool write_locked = false;\n\tstruct vm_area_struct *vma;\n\tbool migration = false;\n\tint r = 0;\n\n\tif (!KFD_IS_SVM_API_SUPPORTED(adev->kfd.dev)) {\n\t\tpr_debug(\"device does not support SVM\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tp = kfd_lookup_process_by_pasid(pasid);\n\tif (!p) {\n\t\tpr_debug(\"kfd process not founded pasid 0x%x\\n\", pasid);\n\t\treturn 0;\n\t}\n\tsvms = &p->svms;\n\n\tpr_debug(\"restoring svms 0x%p fault address 0x%llx\\n\", svms, addr);\n\n\tif (atomic_read(&svms->drain_pagefaults)) {\n\t\tpr_debug(\"draining retry fault, drop fault 0x%llx\\n\", addr);\n\t\tr = 0;\n\t\tgoto out;\n\t}\n\n\tif (!p->xnack_enabled) {\n\t\tpr_debug(\"XNACK not enabled for pasid 0x%x\\n\", pasid);\n\t\tr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t/* p->lead_thread is available as kfd_process_wq_release flush the work\n\t * before releasing task ref.\n\t */\n\tmm = get_task_mm(p->lead_thread);\n\tif (!mm) {\n\t\tpr_debug(\"svms 0x%p failed to get mm\\n\", svms);\n\t\tr = 0;\n\t\tgoto out;\n\t}\n\n\tmmap_read_lock(mm);\nretry_write_locked:\n\tmutex_lock(&svms->lock);\n\tprange = svm_range_from_addr(svms, addr, NULL);\n\tif (!prange) {\n\t\tpr_debug(\"failed to find prange svms 0x%p address [0x%llx]\\n\",\n\t\t\t svms, addr);\n\t\tif (!write_locked) {\n\t\t\t/* Need the write lock to create new range with MMU notifier.\n\t\t\t * Also flush pending deferred work to make sure the interval\n\t\t\t * tree is up to date before we add a new range\n\t\t\t */\n\t\t\tmutex_unlock(&svms->lock);\n\t\t\tmmap_read_unlock(mm);\n\t\t\tmmap_write_lock(mm);\n\t\t\twrite_locked = true;\n\t\t\tgoto retry_write_locked;\n\t\t}\n\t\tprange = svm_range_create_unregistered_range(adev, p, mm, addr);\n\t\tif (!prange) {\n\t\t\tpr_debug(\"failed to create unregistered range svms 0x%p address [0x%llx]\\n\",\n\t\t\t\t svms, addr);\n\t\t\tmmap_write_downgrade(mm);\n\t\t\tr = -EFAULT;\n\t\t\tgoto out_unlock_svms;\n\t\t}\n\t}\n\tif (write_locked)\n\t\tmmap_write_downgrade(mm);\n\n\tmutex_lock(&prange->migrate_mutex);\n\n\tif (svm_range_skip_recover(prange)) {\n\t\tamdgpu_gmc_filter_faults_remove(adev, addr, pasid);\n\t\tr = 0;\n\t\tgoto out_unlock_range;\n\t}\n\n\t/* skip duplicate vm fault on different pages of same range */\n\tif (ktime_before(timestamp, ktime_add_ns(prange->validate_timestamp,\n\t\t\t\tAMDGPU_SVM_RANGE_RETRY_FAULT_PENDING))) {\n\t\tpr_debug(\"svms 0x%p [0x%lx %lx] already restored\\n\",\n\t\t\t svms, prange->start, prange->last);\n\t\tr = 0;\n\t\tgoto out_unlock_range;\n\t}\n\n\t/* __do_munmap removed VMA, return success as we are handling stale\n\t * retry fault.\n\t */\n\tvma = find_vma(mm, addr << PAGE_SHIFT);\n\tif (!vma || (addr << PAGE_SHIFT) < vma->vm_start) {\n\t\tpr_debug(\"address 0x%llx VMA is removed\\n\", addr);\n\t\tr = 0;\n\t\tgoto out_unlock_range;\n\t}\n\n\tif (!svm_fault_allowed(vma, write_fault)) {\n\t\tpr_debug(\"fault addr 0x%llx no %s permission\\n\", addr,\n\t\t\twrite_fault ? \"write\" : \"read\");\n\t\tr = -EPERM;\n\t\tgoto out_unlock_range;\n\t}\n\n\tbest_loc = svm_range_best_restore_location(prange, adev, &gpuidx);\n\tif (best_loc == -1) {\n\t\tpr_debug(\"svms %p failed get best restore loc [0x%lx 0x%lx]\\n\",\n\t\t\t svms, prange->start, prange->last);\n\t\tr = -EACCES;\n\t\tgoto out_unlock_range;\n\t}\n\n\tpr_debug(\"svms %p [0x%lx 0x%lx] best restore 0x%x, actual loc 0x%x\\n\",\n\t\t svms, prange->start, prange->last, best_loc,\n\t\t prange->actual_loc);\n\n\tkfd_smi_event_page_fault_start(adev->kfd.dev, p->lead_thread->pid, addr,\n\t\t\t\t       write_fault, timestamp);\n\n\tif (prange->actual_loc != best_loc) {\n\t\tmigration = true;\n\t\tif (best_loc) {\n\t\t\tr = svm_migrate_to_vram(prange, best_loc, mm,\n\t\t\t\t\tKFD_MIGRATE_TRIGGER_PAGEFAULT_GPU);\n\t\t\tif (r) {\n\t\t\t\tpr_debug(\"svm_migrate_to_vram failed (%d) at %llx, falling back to system memory\\n\",\n\t\t\t\t\t r, addr);\n\t\t\t\t/* Fallback to system memory if migration to\n\t\t\t\t * VRAM failed\n\t\t\t\t */\n\t\t\t\tif (prange->actual_loc)\n\t\t\t\t\tr = svm_migrate_vram_to_ram(prange, mm,\n\t\t\t\t\t   KFD_MIGRATE_TRIGGER_PAGEFAULT_GPU,\n\t\t\t\t\t   NULL);\n\t\t\t\telse\n\t\t\t\t\tr = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tr = svm_migrate_vram_to_ram(prange, mm,\n\t\t\t\t\tKFD_MIGRATE_TRIGGER_PAGEFAULT_GPU,\n\t\t\t\t\tNULL);\n\t\t}\n\t\tif (r) {\n\t\t\tpr_debug(\"failed %d to migrate svms %p [0x%lx 0x%lx]\\n\",\n\t\t\t\t r, svms, prange->start, prange->last);\n\t\t\tgoto out_unlock_range;\n\t\t}\n\t}\n\n\tr = svm_range_validate_and_map(mm, prange, gpuidx, false, false, false);\n\tif (r)\n\t\tpr_debug(\"failed %d to map svms 0x%p [0x%lx 0x%lx] to gpus\\n\",\n\t\t\t r, svms, prange->start, prange->last);\n\n\tkfd_smi_event_page_fault_end(adev->kfd.dev, p->lead_thread->pid, addr,\n\t\t\t\t     migration);\n\nout_unlock_range:\n\tmutex_unlock(&prange->migrate_mutex);\nout_unlock_svms:\n\tmutex_unlock(&svms->lock);\n\tmmap_read_unlock(mm);\n\n\tsvm_range_count_fault(adev, p, gpuidx);\n\n\tmmput(mm);\nout:\n\tkfd_unref_process(p);\n\n\tif (r == -EAGAIN) {\n\t\tpr_debug(\"recover vm fault later\\n\");\n\t\tamdgpu_gmc_filter_faults_remove(adev, addr, pasid);\n\t\tr = 0;\n\t}\n\treturn r;\n}", "target": 1, "idx": 10079}
{"commit_id": "dc7de8d3d604426c7a6e628d90cb9fb88e7b4c2c", "project": "gpac", "func": "GF_Err BD_DecMFFieldVec(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node, GF_FieldInfo *field, Bool is_mem_com)\n{\n\tGF_Err e;\n\tu32 NbBits, nbFields;\n\tu32 i;\n\tGF_ChildNodeItem *last;\n\tu8 qp_local, qp_on, initial_qp;\n\tGF_FieldInfo sffield;\n\n\tmemset(&sffield, 0, sizeof(GF_FieldInfo));\n\tsffield.fieldIndex = field->fieldIndex;\n\tsffield.fieldType = gf_sg_vrml_get_sf_type(field->fieldType);\n\tsffield.NDTtype = field->NDTtype;\n\tsffield.name = field->name;\n\n\tinitial_qp = qp_local = qp_on = 0;\n\n\t//vector description - alloc the MF size before\n\tNbBits = gf_bs_read_int(bs, 5);\n\tnbFields = gf_bs_read_int(bs, NbBits);\n\n\tif (codec->ActiveQP) {\n\t\tinitial_qp = 1;\n\t\t/*this is for QP 14*/\n\t\tgf_bifs_dec_qp14_set_length(codec, nbFields);\n\t}\n\n\tif (field->fieldType != GF_SG_VRML_MFNODE) {\n\t\te = gf_sg_vrml_mf_alloc(field->far_ptr, field->fieldType, nbFields);\n\t\tif (e) return e;\n\n\t\tfor (i=0; i<nbFields; i++) {\n\t\t\te = gf_sg_vrml_mf_get_item(field->far_ptr, field->fieldType, & sffield.far_ptr, i);\n\t\t\tif (e) return e;\n\t\t\te = gf_bifs_dec_sf_field(codec, bs, node, &sffield, GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\te = GF_OK;\n\tlast = NULL;\n\tfor (i=0; i<nbFields; i++) {\n\t\tGF_Node *new_node = gf_bifs_dec_node(codec, bs, field->NDTtype);\n\t\tif (new_node) {\n\t\t\te = gf_node_register(new_node, is_mem_com ? NULL : node);\n\t\t\tif (e) goto exit;\n\n\t\t\tif (node) {\n\t\t\t\t/*special case for QP, register as the current QP*/\n\t\t\t\tif (gf_node_get_tag(new_node) == TAG_MPEG4_QuantizationParameter) {\n\t\t\t\t\tqp_local = ((M_QuantizationParameter *)new_node)->isLocal;\n\t\t\t\t\t/*we have a QP in the same scope, remove previous\n\t\t\t\t\tNB: we assume this is the right behavior, the spec doesn't say\n\t\t\t\t\twhether QP is cumulative or not*/\n\t\t\t\t\tif (qp_on) gf_bifs_dec_qp_remove(codec, GF_FALSE);\n\n\t\t\t\t\te = gf_bifs_dec_qp_set(codec, new_node);\n\t\t\t\t\tif (e) goto exit;\n\t\t\t\t\tqp_on = 1;\n\t\t\t\t\tif (qp_local) qp_local = 2;\n\t\t\t\t\tif (codec->force_keep_qp) {\n\t\t\t\t\t\te = gf_node_list_add_child_last(field->far_ptr, new_node, &last);\n\t\t\t\t\t\tif (e) goto exit;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_node_register(new_node, NULL);\n\t\t\t\t\t\tgf_node_unregister(new_node, node);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\te = gf_node_list_add_child_last(field->far_ptr, new_node, &last);\n\t\t\t\t\tif (e) goto exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*proto coding*/\n\t\t\telse if (codec->pCurrentProto) {\n\t\t\t\t/*TO DO: what happens if this is a QP node on the interface ?*/\n\t\t\t\te = gf_node_list_add_child_last( (GF_ChildNodeItem **)field->far_ptr, new_node, &last);\n\t\t\t\tif (e)goto exit;\n\t\t\t}\n\t\t} else {\n\t\t\te = codec->LastError ? codec->LastError : GF_NON_COMPLIANT_BITSTREAM;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\nexit:\n\n\t/*according to the spec, the QP applies to the current node itself, not just children.\n\tIf IsLocal is TRUE remove the node*/\n\tif (qp_on && qp_local) {\n\t\tif (qp_local == 2) {\n//\t\t\t\tqp_local = 1;\n\t\t} else {\n\t\t\t//ask to get rid of QP and reactivate if we had a QP when entering the node\n\t\t\tgf_bifs_dec_qp_remove(codec, initial_qp);\n//\t\t\t\tqp_local = 0;\n\t\t}\n\t}\n\n\t/*finally delete the QP if any (local or not) as we get out of this node*/\n\tif (qp_on) gf_bifs_dec_qp_remove(codec, GF_TRUE);\n\treturn e;\n}", "target": 2, "idx": 10080}
{"commit_id": "ae0ab82434509d6e75f4a2f1e1a0dd2ee3dc3681", "project": "projectacrn/acrn-hypervisor", "func": "int\nvq_getchain(struct virtio_vq_info *vq, uint16_t *pidx,\n\t    struct iovec *iov, int n_iov, uint16_t *flags)\n{\n\tint i;\n\tu_int ndesc, n_indir;\n\tu_int idx, next;\n\n\tvolatile struct vring_desc *vdir, *vindir, *vp;\n\tstruct vmctx *ctx;\n\tstruct virtio_base *base;\n\tconst char *name;\n\n\tbase = vq->base;\n\tname = base->vops->name;\n\n\t/*\n\t * Note: it's the responsibility of the guest not to\n\t * update vq->avail->idx until all of the descriptors\n\t * the guest has written are valid (including all their\n\t * next fields and vd_flags).\n\t *\n\t * Compute (last_avail - idx) in integers mod 2**16.  This is\n\t * the number of descriptors the device has made available\n\t * since the last time we updated vq->last_avail.\n\t *\n\t * We just need to do the subtraction as an unsigned int,\n\t * then trim off excess bits.\n\t */\n\tidx = vq->last_avail;\n\tndesc = (uint16_t)((u_int)vq->avail->idx - idx);\n\tif (ndesc == 0)\n\t\treturn 0;\n\tif (ndesc > vq->qsize) {\n\t\t/* XXX need better way to diagnose issues */\n\t\tpr_err(\"%s: ndesc (%u) out of range, driver confused?\\r\\n\",\n\t\t    name, (u_int)ndesc);\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Now count/parse \"involved\" descriptors starting from\n\t * the head of the chain.\n\t *\n\t * To prevent loops, we could be more complicated and\n\t * check whether we're re-visiting a previously visited\n\t * index, but we just abort if the count gets excessive.\n\t */\n\tctx = base->dev->vmctx;\n\t*pidx = next = vq->avail->ring[idx & (vq->qsize - 1)];\n\tvq->last_avail++;\n\tfor (i = 0; i < VQ_MAX_DESCRIPTORS; next = vdir->next) {\n\t\tif (next >= vq->qsize) {\n\t\t\tpr_err(\"%s: descriptor index %u out of range, \"\n\t\t\t    \"driver confused?\\r\\n\",\n\t\t\t    name, next);\n\t\t\treturn -1;\n\t\t}\n\t\tvdir = &vq->desc[next];\n\t\tif ((vdir->flags & VRING_DESC_F_INDIRECT) == 0) {\n\t\t\tif (_vq_record(i, vdir, ctx, iov, n_iov, flags)) {\n\t\t\t\tpr_err(\"%s: mapping to host failed\\r\\n\", name);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\ti++;\n\t\t} else if ((base->device_caps &\n\t\t    (1 << VIRTIO_RING_F_INDIRECT_DESC)) == 0) {\n\t\t\tpr_err(\"%s: descriptor has forbidden INDIRECT flag, \"\n\t\t\t    \"driver confused?\\r\\n\",\n\t\t\t    name);\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tn_indir = vdir->len / 16;\n\t\t\tif ((vdir->len & 0xf) || n_indir == 0) {\n\t\t\t\tpr_err(\"%s: invalid indir len 0x%x, \"\n\t\t\t\t    \"driver confused?\\r\\n\",\n\t\t\t\t    name, (u_int)vdir->len);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tvindir = paddr_guest2host(ctx,\n\t\t\t    vdir->addr, vdir->len);\n\n\t\t\tif (!vindir) {\n\t\t\t\tpr_err(\"%s cannot get host memory\\r\\n\", name);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Indirects start at the 0th, then follow\n\t\t\t * their own embedded \"next\"s until those run\n\t\t\t * out.  Each one's indirect flag must be off\n\t\t\t * (we don't really have to check, could just\n\t\t\t * ignore errors...).\n\t\t\t */\n\t\t\tnext = 0;\n\t\t\tfor (;;) {\n\t\t\t\tvp = &vindir[next];\n\t\t\t\tif (vp->flags & VRING_DESC_F_INDIRECT) {\n\t\t\t\t\tpr_err(\"%s: indirect desc has INDIR flag,\"\n\t\t\t\t\t    \" driver confused?\\r\\n\",\n\t\t\t\t\t    name);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (_vq_record(i, vp, ctx, iov, n_iov, flags)) {\n\t\t\t\t\tpr_err(\"%s: mapping to host failed\\r\\n\", name);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (++i > VQ_MAX_DESCRIPTORS)\n\t\t\t\t\tgoto loopy;\n\t\t\t\tif ((vp->flags & VRING_DESC_F_NEXT) == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tnext = vp->next;\n\t\t\t\tif (next >= n_indir) {\n\t\t\t\t\tpr_err(\"%s: invalid next %u > %u, \"\n\t\t\t\t\t    \"driver confused?\\r\\n\",\n\t\t\t\t\t    name, (u_int)next, n_indir);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ((vdir->flags & VRING_DESC_F_NEXT) == 0)\n\t\t\treturn i;\n\t}\nloopy:\n\tpr_err(\"%s: descriptor loop? count > %d - driver confused?\\r\\n\",\n\t    name, i);\n\treturn -1;\n}", "target": 2, "idx": 10081}
{"commit_id": "6ef36ab967c71690ebe7e5ef997a8be4da3bc844", "project": "torvalds/linux", "func": "static void balloon_process(struct work_struct *work)\n{\n\tenum bp_state state = BP_DONE;\n\tlong credit;\n\n\n\tdo {\n\t\tmutex_lock(&balloon_mutex);\n\n\t\tcredit = current_credit();\n\n\t\tif (credit > 0) {\n\t\t\tif (balloon_is_inflated())\n\t\t\t\tstate = increase_reservation(credit);\n\t\t\telse\n\t\t\t\tstate = reserve_additional_memory();\n\t\t}\n\n\t\tif (credit < 0) {\n\t\t\tlong n_pages;\n\n\t\t\tn_pages = min(-credit, si_mem_available());\n\t\t\tstate = decrease_reservation(n_pages, GFP_BALLOON);\n\t\t\tif (state == BP_DONE && n_pages != -credit &&\n\t\t\t    n_pages < totalreserve_pages)\n\t\t\t\tstate = BP_EAGAIN;\n\t\t}\n\n\t\tstate = update_schedule(state);\n\n\t\tmutex_unlock(&balloon_mutex);\n\n\t\tcond_resched();\n\n\t} while (credit && state == BP_DONE);\n\n\t/* Schedule more work if there is some still to be done. */\n\tif (state == BP_EAGAIN)\n\t\tschedule_delayed_work(&balloon_worker, balloon_stats.schedule_delay * HZ);\n}", "target": 1, "idx": 10082}
{"commit_id": "4794b5dd34688158fb51a2943032569d3780c4b8", "project": "xorg/lib/libXcursor", "func": "static XcursorImage *\n_XcursorReadImage (XcursorFile\t\t*file,\n\t\t   XcursorFileHeader\t*fileHeader,\n\t\t   int\t\t\ttoc)\n{\n    XcursorChunkHeader\tchunkHeader;\n    XcursorImage\thead;\n    XcursorImage\t*image;\n    int\t\t\tn;\n    XcursorPixel\t*p;\n\n    if (!file || !fileHeader)\n        return NULL;\n\n    if (!_XcursorFileReadChunkHeader (file, fileHeader, toc, &chunkHeader))\n\treturn NULL;\n    if (!_XcursorReadUInt (file, &head.width))\n\treturn NULL;\n    if (!_XcursorReadUInt (file, &head.height))\n\treturn NULL;\n    if (!_XcursorReadUInt (file, &head.xhot))\n\treturn NULL;\n    if (!_XcursorReadUInt (file, &head.yhot))\n\treturn NULL;\n    if (!_XcursorReadUInt (file, &head.delay))\n\treturn NULL;\n    /* sanity check data */\n    if (head.width > XCURSOR_IMAGE_MAX_SIZE  ||\n\thead.height > XCURSOR_IMAGE_MAX_SIZE)\n\treturn NULL;\n    if (head.width == 0 || head.height == 0)\n\treturn NULL;\n    if (head.xhot > head.width || head.yhot > head.height)\n\treturn NULL;\n\n    /* Create the image and initialize it */\n    image = XcursorImageCreate (head.width, head.height);\n    if (image == NULL)\n\treturn NULL;\n    if (chunkHeader.version < image->version)\n\timage->version = chunkHeader.version;\n    image->size = chunkHeader.subtype;\n    image->xhot = head.xhot;\n    image->yhot = head.yhot;\n    image->delay = head.delay;\n    n = image->width * image->height;\n    p = image->pixels;\n    while (n--)\n    {\n\tif (!_XcursorReadUInt (file, p))\n\t{\n\t    XcursorImageDestroy (image);\n\t    return NULL;\n\t}\n\tp++;\n    }\n    return image;\n}", "target": 2, "idx": 10083}
{"commit_id": "5f5a1318653c08e435cfa52f60b6a712815b659d", "project": "qemu", "func": "uint32_t virtio_config_readw(VirtIODevice *vdev, uint32_t addr)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint16_t val;\n\n    if (addr + sizeof(val) > vdev->config_len) {\n        return (uint32_t)-1;\n    }\n\n    k->get_config(vdev, vdev->config);\n\n    val = lduw_p(vdev->config + addr);\n    return val;\n}", "target": 2, "idx": 10084}
{"commit_id": "9fe0761c47c0d4270d1a5220cfd25de080350d50", "project": "sparklemotion/nokogiri", "func": "static VALUE\nrb_xml_reader_attribute_hash(VALUE rb_reader)\n{\n  VALUE rb_attributes = rb_hash_new();\n  xmlTextReaderPtr c_reader;\n  xmlNodePtr c_node;\n  xmlAttrPtr c_property;\n\n  Data_Get_Struct(rb_reader, xmlTextReader, c_reader);\n\n  if (!has_attributes(c_reader)) {\n    return rb_attributes;\n  }\n\n  c_node = xmlTextReaderExpand(c_reader);\n  if (c_node == NULL) {\n    return Qnil;\n  }\n\n  c_property = c_node->properties;\n  while (c_property != NULL) {\n    VALUE rb_name = NOKOGIRI_STR_NEW2(c_property->name);\n    VALUE rb_value = Qnil;\n    xmlChar *c_value = xmlNodeGetContent((xmlNode *)c_property);\n\n    if (c_value) {\n      rb_value = NOKOGIRI_STR_NEW2(c_value);\n      xmlFree(c_value);\n    }\n\n    rb_hash_aset(rb_attributes, rb_name, rb_value);\n\n    c_property = c_property->next;\n  }\n\n  return rb_attributes;\n}", "target": 2, "idx": 10085}
{"commit_id": "c9f838d104fed6f2f61d68164712e3204bf5271b", "project": "torvalds/linux", "func": "static int install_thread_keyring(void)\n{\n\tstruct cred *new;\n\tint ret;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tret = install_thread_keyring_to_cred(new);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\treturn ret;\n\t}\n\n\treturn commit_creds(new);\n}", "target": 1, "idx": 10086}
{"commit_id": "02cbeeb6207508b0f04a2c6181445c8eb3f1e117", "project": "xen-project/xen", "func": "void grant_table_init_vcpu(struct vcpu *v)\n{\n    spin_lock_init(&v->maptrack_freelist_lock);\n    v->maptrack_head = MAPTRACK_TAIL;\n    v->maptrack_tail = MAPTRACK_TAIL;\n}", "target": 2, "idx": 10087}
{"commit_id": "1d1c75b6316d21933069a9d201f966d84099f6ca", "project": "swaywm/swaylock", "func": "static void destroy_surface(struct swaylock_surface *surface) {\n\twl_list_remove(&surface->link);\n\tif (surface->layer_surface != NULL) {\n\t\tzwlr_layer_surface_v1_destroy(surface->layer_surface);\n\t}\n\tif (surface->ext_session_lock_surface_v1 != NULL) {\n\t\text_session_lock_surface_v1_destroy(surface->ext_session_lock_surface_v1);\n\t}\n\tif (surface->surface != NULL) {\n\t\twl_surface_destroy(surface->surface);\n\t}\n\tdestroy_buffer(&surface->buffers[0]);\n\tdestroy_buffer(&surface->buffers[1]);\n\tdestroy_buffer(&surface->indicator_buffers[0]);\n\tdestroy_buffer(&surface->indicator_buffers[1]);\n\twl_output_destroy(surface->output);\n\tfree(surface);\n}", "target": 3, "idx": 10088}
{"commit_id": "a4270d6795b0580287453ea55974d948393e66ef", "project": "torvalds/linux", "func": "static struct sk_buff *napi_frags_skb(struct napi_struct *napi)\n{\n\tstruct sk_buff *skb = napi->skb;\n\tconst struct ethhdr *eth;\n\tunsigned int hlen = sizeof(*eth);\n\n\tnapi->skb = NULL;\n\n\tskb_reset_mac_header(skb);\n\tskb_gro_reset_offset(skb);\n\n\tif (unlikely(skb_gro_header_hard(skb, hlen))) {\n\t\teth = skb_gro_header_slow(skb, hlen, 0);\n\t\tif (unlikely(!eth)) {\n\t\t\tnet_warn_ratelimited(\"%s: dropping impossible skb from %s\\n\",\n\t\t\t\t\t     __func__, napi->dev->name);\n\t\t\tnapi_reuse_skb(napi, skb);\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\teth = (const struct ethhdr *)skb->data;\n\t\tgro_pull_from_frag0(skb, hlen);\n\t\tNAPI_GRO_CB(skb)->frag0 += hlen;\n\t\tNAPI_GRO_CB(skb)->frag0_len -= hlen;\n\t}\n\t__skb_pull(skb, hlen);\n\n\t/*\n\t * This works because the only protocols we care about don't require\n\t * special handling.\n\t * We'll fix it up properly in napi_frags_finish()\n\t */\n\tskb->protocol = eth->h_proto;\n\n\treturn skb;\n}", "target": 1, "idx": 10089}
{"commit_id": "b9aea5854bcf6f2de8f7a7f1550874e392b94be2", "project": "nginx/njs", "func": "uint32_t\nnjs_string_trim(const njs_value_t *value, njs_string_prop_t *string,\n    unsigned mode)\n{\n    uint32_t              cp, trim;\n    const u_char          *p, *prev, *start, *end;\n    njs_unicode_decode_t  ctx;\n\n    trim = 0;\n\n    njs_string_prop(string, value);\n\n    start = string->start;\n    end = string->start + string->size;\n\n    if (njs_is_byte_or_ascii_string(string)) {\n\n        if (mode & NJS_TRIM_START) {\n            for ( ;; ) {\n                if (start == end) {\n                    break;\n                }\n\n                if (njs_is_whitespace(*start)) {\n                    start++;\n                    trim++;\n                    continue;\n                }\n\n                break;\n            }\n        }\n\n        if (mode & NJS_TRIM_END) {\n            for ( ;; ) {\n                if (start == end) {\n                    break;\n                }\n\n                end--;\n\n                if (njs_is_whitespace(*end)) {\n                    trim++;\n                    continue;\n                }\n\n                end++;\n                break;\n            }\n        }\n\n    } else {\n        /* UTF-8 string. */\n\n        if (mode & NJS_TRIM_START) {\n            njs_utf8_decode_init(&ctx);\n\n            for ( ;; ) {\n                if (start == end) {\n                    break;\n                }\n\n                p = start;\n                cp = njs_utf8_decode(&ctx, &start, end);\n\n                if (njs_utf8_is_whitespace(cp)) {\n                    trim++;\n                    continue;\n                }\n\n                start = p;\n                break;\n            }\n        }\n\n        if (mode & NJS_TRIM_END) {\n            prev = end;\n\n            njs_utf8_decode_init(&ctx);\n\n            for ( ;; ) {\n                if (start == prev) {\n                    end = prev;\n                    break;\n                }\n\n                prev = njs_utf8_prev(prev);\n                p = prev;\n                cp = njs_utf8_decode(&ctx, &p, end);\n\n                if (njs_utf8_is_whitespace(cp)) {\n                    trim++;\n                    continue;\n                }\n\n                end = p;\n                break;\n            }\n        }\n    }\n\n    if (start == end) {\n        string->length = 0;\n        string->size = 0;\n        return trim;\n    }\n\n    string->start = (u_char *) start;\n    string->size = end - start;\n\n    if (string->length != 0) {\n        string->length -= trim;\n    }\n\n    return trim;\n}", "target": 1, "idx": 10090}
{"commit_id": "68f67ef6cf1f41e77337be3bc4bff91f3a3c6324", "project": "android", "func": "bool ASessionDescription::getDimensions(\n        size_t index, unsigned long PT,\n        int32_t *width, int32_t *height) const {\n    *width = 0;\n    *height = 0;\n\n    char key[33];\n    snprintf(key, sizeof(key), \"a=framesize:%lu\", PT);\n    if (PT > 9999999) {\n        android_errorWriteLog(0x534e4554, \"25747670\");\n    }\n    AString value;\n    if (!findAttribute(index, key, &value)) {\n        return false;\n    }\n\n    const char *s = value.c_str();\n    char *end;\n    *width = strtoul(s, &end, 10);\n    CHECK_GT(end, s);\n    CHECK_EQ(*end, '-');\n\n    s = end + 1;\n    *height = strtoul(s, &end, 10);\n    CHECK_GT(end, s);\n    CHECK_EQ(*end, '\\0');\n\n    return true;\n}", "target": 1, "idx": 10091}
{"commit_id": "f17bfd9f1da05f30f23a4dd05e9d2363e1406948", "project": "radareorg/radare2", "func": "static int opmov(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tst64 offset = 0;\n\tint mod = 0;\n\tint base = 0;\n\tint rex = 0;\n\tut64 immediate = 0;\n\tif (op->operands[1].type & OT_CONSTANT) {\n\t\tif (!op->operands[1].is_good_flag) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (op->operands[1].immediate == -1) {\n\t\t\treturn -1;\n\t\t}\n\t\timmediate = op->operands[1].immediate * op->operands[1].sign;\n\t\tif (op->operands[0].type & OT_GPREG && !(op->operands[0].type & OT_MEMORY)) {\n\t\t\tif (a->bits == 64 && ((op->operands[0].type & OT_QWORD) | (op->operands[1].type & OT_QWORD))) {\n\t\t\t\tif (!(op->operands[1].type & OT_CONSTANT) && op->operands[1].extended) {\n\t\t\t\t\tdata[l++] = 0x49;\n\t\t\t\t} else {\n\t\t\t\t\tdata[l++] = 0x48;\n\t\t\t\t}\n\t\t\t} else if (op->operands[0].extended) {\n\t\t\t\tdata[l++] = 0x41;\n\t\t\t}\n\t\t\tif (op->operands[0].type & OT_WORD) {\n\t\t\t\tif (a->bits > 16) {\n\t\t\t\t\tdata[l++] = 0x66;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (op->operands[0].type & OT_BYTE) {\n\t\t\t\tdata[l++] = 0xb0 | op->operands[0].reg;\n\t\t\t\tdata[l++] = immediate;\n\t\t\t} else {\n\t\t\t\tif (a->bits == 64 &&\n\t\t\t\t\t((op->operands[0].type & OT_QWORD) |\n\t\t\t\t\t(op->operands[1].type & OT_QWORD)) &&\n\t\t\t\t\timmediate < UT32_MAX) {\n\t\t\t\t\t\tdata[l++] = 0xc7;\n\t\t\t\t \t\tdata[l++] = 0xc0 | op->operands[0].reg;\n\t\t\t\t} else {\n\t\t\t\t\tdata[l++] = 0xb8 | op->operands[0].reg;\n\t\t\t\t}\n\t\t\t\tdata[l++] = immediate;\n\t\t\t\tdata[l++] = immediate >> 8;\n\t\t\t\tif (!(op->operands[0].type & OT_WORD)) {\n\t\t\t\t\tdata[l++] = immediate >> 16;\n\t\t\t\t\tdata[l++] = immediate >> 24;\n\t\t\t\t}\n\t\t\t\tif (a->bits == 64 && immediate > UT32_MAX) {\n\t\t\t\t\tdata[l++] = immediate >> 32;\n\t\t\t\t\tdata[l++] = immediate >> 40;\n\t\t\t\t\tdata[l++] = immediate >> 48;\n\t\t\t\t\tdata[l++] = immediate >> 56;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (op->operands[0].type & OT_MEMORY) {\n\t\t\tif (!op->operands[0].explicit_size) {\n\t\t\t\tif (op->operands[0].type & OT_GPREG) {\n\t\t\t\t\t((Opcode *)op)->operands[0].dest_size = op->operands[0].reg_size;\n\t\t\t\t} else {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint dest_bits = 8 * ((op->operands[0].dest_size & ALL_SIZE) >> OPSIZE_SHIFT);\n\t\t\tint reg_bits = 8 * ((op->operands[0].reg_size & ALL_SIZE) >> OPSIZE_SHIFT);\n\t\t\tint offset = op->operands[0].offset * op->operands[0].offset_sign;\n\n\t\t\t//addr_size_override prefix\n\t\t\tbool use_aso = false;\n\t\t\tif (reg_bits < a->bits) {\n\t\t\t\tuse_aso = true;\n\t\t\t}\n\n\t\t\t//op_size_override prefix\n\t\t\tbool use_oso = false;\n\t\t\tif (dest_bits == 16) {\n\t\t\t\tuse_oso = true;\n\t\t\t}\n\n\t\t\tbool rip_rel = op->operands[0].regs[0] == X86R_RIP;\n\n\t\t\t//rex prefix\n\t\t\tint rex = 1 << 6;\n\t\t\tbool use_rex = false;\n\t\t\tif (dest_bits == 64) {\t\t\t//W field\n\t\t\t\tuse_rex = true;\n\t\t\t\trex |= 1 << 3;\n\t\t\t}\n\t\t\tif (op->operands[0].extended) {\t\t//B field\n\t\t\t\tuse_rex = true;\n\t\t\t\trex |= 1;\n\t\t\t}\n\n\t\t\t//opcode selection\n\t\t\tint opcode;\n\t\t\tif (dest_bits == 8) {\n\t\t\t\topcode = 0xc6;\n\t\t\t} else {\n\t\t\t\topcode = 0xc7;\n\t\t\t}\n\n\t\t\t//modrm and SIB selection\n\t\t\tint modrm = 0;\n\t\t\tint mod;\n\t\t\tint reg = 0;\n\t\t\tint rm;\n\t\t\tbool use_sib = false;\n\t\t\tint sib;\n\t\t\t//mod\n\t\t\tif (offset == 0) {\n\t\t\t\tmod = 0;\n\t\t\t} else if (offset < 128 && offset > -129) {\n\t\t\t\tmod = 1;\n\t\t\t} else {\n\t\t\t\tmod = 2;\n\t\t\t}\n\n\t\t\tif (reg_bits == 16) {\n\t\t\t\tif (op->operands[0].regs[0] == X86R_BX && op->operands[0].regs[1] == X86R_SI) {\n\t\t\t\t\trm = B0000;\n\t\t\t\t} else if (op->operands[0].regs[0] == X86R_BX && op->operands[0].regs[1] == X86R_DI) {\n\t\t\t\t\trm = B0001;\n\t\t\t\t} else if (op->operands[0].regs[0] == X86R_BP && op->operands[0].regs[1] == X86R_SI) {\n\t\t\t\t\trm = B0010;\n\t\t\t\t} else if (op->operands[0].regs[0] == X86R_BP && op->operands[0].regs[1] == X86R_DI) {\n\t\t\t\t\trm = B0011;\n\t\t\t\t} else if (op->operands[0].regs[0] == X86R_SI && op->operands[0].regs[1] == -1) {\n\t\t\t\t\trm = B0100;\n\t\t\t\t} else if (op->operands[0].regs[0] == X86R_DI && op->operands[0].regs[1] == -1) {\n\t\t\t\t\trm = B0101;\n\t\t\t\t} else if (op->operands[0].regs[0] == X86R_BX && op->operands[0].regs[1] == -1) {\n\t\t\t\t\trm = B0111;\n\t\t\t\t} else {\n\t\t\t\t\t//TODO allow for displacement only when parser is reworked\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tmodrm = (mod << 6) | (reg << 3) | rm;\n\t\t\t} else {\n\t\t\t\t//rm\n\t\t\t\tif (op->operands[0].extended) {\n\t\t\t\t\trm = op->operands[0].reg;\n\t\t\t\t} else {\n\t\t\t\t\trm = op->operands[0].regs[0];\n\t\t\t\t}\n\t\t\t\t//[epb] alone is illegal, so we need to fake a [ebp+0]\n\t\t\t\tif (rm == 5 && mod == 0) {\n\t\t\t\t\tmod = 1;\n\t\t\t\t}\n\n\t\t\t\t//sib\n\t\t\t\tint index = op->operands[0].regs[1];\n\t\t\t\tint scale = getsib(op->operands[0].scale[1]);\n\t\t\t\tif (index != -1) {\n\t\t\t\t\tuse_sib = true;\n\t\t\t\t\tsib = (scale << 6) | (index << 3) | rm;\n\t\t\t\t} else if (rm == 4) {\n\t\t\t\t\tuse_sib = true;\n\t\t\t\t\tsib = 0x24;\n\t\t\t\t}\n\t\t\t\tif (use_sib) {\n\t\t\t\t\trm = B0100;\n\t\t\t\t}\n\t\t\t\tif (rip_rel) {\n\t\t\t\t\tmodrm = (B0000 << 6) | (reg << 3) | B0101;\n\t\t\t\t\tsib = (scale << 6) | (B0100 << 3) | B0101;\n\t\t\t\t} else {\n\t\t\t\t\tmodrm = (mod << 6) | (reg << 3) | rm;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//build the final result\n\t\t\tif (use_aso) {\n\t\t\t\tdata[l++] = 0x67;\n\t\t\t}\n\t\t\tif (use_oso) {\n\t\t\t\tdata[l++] = 0x66;\n\t\t\t}\n\t\t\tif (use_rex) {\n\t\t\t\tdata[l++] = rex;\n\t\t\t}\n\t\t\tdata[l++] = opcode;\n\t\t\tdata[l++] = modrm;\n\t\t\tif (use_sib) {\n\t\t\t\tdata[l++] = sib;\n\t\t\t}\n\t\t\t//offset\n\t\t\tif (mod == 1) {\n\t\t\t\tdata[l++] = offset;\n\t\t\t} else if (reg_bits == 16 && mod == 2) {\n\t\t\t\tdata[l++] = offset;\n\t\t\t\tdata[l++] = offset >> 8;\n\t\t\t} else if (mod == 2 || rip_rel) {\n\t\t\t\tdata[l++] = offset;\n\t\t\t\tdata[l++] = offset >> 8;\n\t\t\t\tdata[l++] = offset >> 16;\n\t\t\t\tdata[l++] = offset >> 24;\n\t\t\t}\n\t\t\t//immediate\n\t\t\tint byte;\n\t\t\tfor (byte = 0; byte < dest_bits && byte < 32; byte += 8) {\n\t\t\t\tdata[l++] = (immediate >> byte);\n\t\t\t}\n\t\t}\n\t} else if (op->operands[1].type & OT_REGALL &&\n\t\t\t !(op->operands[1].type & OT_MEMORY)) {\n\t\tif (op->operands[0].type & OT_CONSTANT) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (op->operands[0].type & OT_REGTYPE & OT_SEGMENTREG &&\n\t\t    op->operands[1].type & OT_REGTYPE & OT_SEGMENTREG) {\n\t\t\t\treturn -1;\n\t\t}\n\t\t// Check reg sizes match\n\t\tif (op->operands[0].type & OT_REGTYPE && op->operands[1].type & OT_REGTYPE) {\n\t\t\tif (!((op->operands[0].type & ALL_SIZE) &\n\t\t\t(op->operands[1].type & ALL_SIZE))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif (a->bits == 64) {\n\t\t\tif (op->operands[0].extended) {\n\t\t\t\trex = 1;\n\t\t\t}\n\t\t\tif (op->operands[1].extended) {\n\t\t\t\trex += 4;\n\t\t\t}\n\t\t\tif (op->operands[1].type & OT_QWORD) {\n\t\t\t\tif (!(op->operands[0].type & OT_QWORD)) {\n\t\t\t\t\tdata[l++] = 0x67;\n\t\t\t\t\tdata[l++] = 0x48;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (op->operands[1].type & OT_QWORD &&\n\t\t\t\top->operands[0].type & OT_QWORD) {\n\t\t\t\tdata[l++] = 0x48 | rex;\n\t\t\t}\n\t\t\tif (op->operands[1].type & OT_DWORD &&\n\t\t\t\top->operands[0].type & OT_DWORD) {\n\t\t\t\tdata[l++] = 0x40 | rex;\n\t\t\t}\n\t\t} else if (op->operands[0].extended && op->operands[1].extended) {\n\t\t\tdata[l++] = 0x45;\n\t\t}\n\t\toffset = op->operands[0].offset * op->operands[0].offset_sign;\n\t\tif (op->operands[1].type & OT_REGTYPE & OT_SEGMENTREG) {\n\t\t\tdata[l++] = 0x8c;\n\t\t} else {\n\t\t\tif (op->operands[0].type & OT_WORD) {\n\t\t\t\tdata[l++] = 0x66;\n\t\t\t}\n\t\t\tdata[l++] = (op->operands[0].type & OT_BYTE) ? 0x88 : 0x89;\n\t\t}\n\n\t\tif (op->operands[0].scale[0] > 1) {\n\t\t\t\tdata[l++] = op->operands[1].reg << 3 | 4;\n\t\t\t\tdata[l++] = getsib (op->operands[0].scale[0]) << 6 |\n\t\t\t\t\t\t    op->operands[0].regs[0] << 3 | 5;\n\n\t\t\t\tdata[l++] = offset;\n\t\t\t\tdata[l++] = offset >> 8;\n\t\t\t\tdata[l++] = offset >> 16;\n\t\t\t\tdata[l++] = offset >> 24;\n\n\t\t\t\treturn l;\n\t\t\t}\n\n\t\tif (!(op->operands[0].type & OT_MEMORY)) {\n\t\t\tif (op->operands[0].reg == X86R_UNDEFINED ||\n\t\t\t\top->operands[1].reg == X86R_UNDEFINED) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmod = 0x3;\n\t\t\tdata[l++] = mod << 6 | op->operands[1].reg << 3 | op->operands[0].reg;\n\t\t} else if (op->operands[0].regs[0] == X86R_UNDEFINED) {\n\t\t\tdata[l++] = op->operands[1].reg << 3 | 0x5;\n\t\t\tdata[l++] = offset;\n\t\t\tdata[l++] = offset >> 8;\n\t\t\tdata[l++] = offset >> 16;\n\t\t\tdata[l++] = offset >> 24;\n\t\t} else {\n\t\t\tif (op->operands[0].type & OT_MEMORY) {\n\t\t\t\tif (op->operands[0].regs[1] != X86R_UNDEFINED) {\n\t\t\t\t\tdata[l++] = op->operands[1].reg << 3 | 0x4;\n\t\t\t\t\tdata[l++] = op->operands[0].regs[1] << 3 | op->operands[0].regs[0];\n\t\t\t\t\treturn l;\n\t\t\t\t}\n\t\t\t\tif (offset) {\n\t\t\t\t\tmod = (offset > 128 || offset < -129) ? 0x2 : 0x1;\n\t\t\t\t}\n\t\t\t\tif (op->operands[0].regs[0] == X86R_EBP) {\n\t\t\t\t\tmod = 0x2;\n\t\t\t\t}\n\t\t\t\tdata[l++] = mod << 6 | op->operands[1].reg << 3 | op->operands[0].regs[0];\n\t\t\t\tif (op->operands[0].regs[0] == X86R_ESP) {\n\t\t\t\t\tdata[l++] = 0x24;\n\t\t\t\t}\n\t\t\t\tif (offset) {\n\t\t\t\t\tdata[l++] = offset;\n\t\t\t\t}\n\t\t\t\tif (mod == 2) {\n\t\t\t\t\t// warning C4293: '>>': shift count negative or too big, undefined behavior\n\t\t\t\t\tdata[l++] = offset >> 8;\n\t\t\t\t\tdata[l++] = offset >> 16;\n\t\t\t\t\tdata[l++] = offset >> 24;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (op->operands[1].type & OT_MEMORY) {\n\t\tif (op->operands[0].type & OT_MEMORY) {\n\t\t\treturn -1;\n\t\t}\n\t\toffset = op->operands[1].offset * op->operands[1].offset_sign;\n\t\tif (op->operands[0].reg == X86R_EAX && op->operands[1].regs[0] == X86R_UNDEFINED) {\n\t\t\tif (a->bits == 64) {\n\t\t\t\tdata[l++] = 0x48;\n\t\t\t}\n\t\t\tif (op->operands[0].type & OT_BYTE) {\n\t\t\t\tdata[l++] = 0xa0;\n\t\t\t} else {\n\t\t\t\tdata[l++] = 0xa1;\n\t\t\t}\n\t\t\tdata[l++] = offset;\n\t\t\tdata[l++] = offset >> 8;\n\t\t\tdata[l++] = offset >> 16;\n\t\t\tdata[l++] = offset >> 24;\n\t\t\tif (a->bits == 64) {\n\t\t\t\tdata[l++] = offset >> 32;\n\t\t\t\tdata[l++] = offset >> 40;\n\t\t\t\tdata[l++] = offset >> 48;\n\t\t\t\tdata[l++] = offset >> 54;\n\t\t\t}\n\t\t\treturn l;\n\t\t}\n\t\tif (op->operands[0].type & OT_BYTE && a->bits == 64 && op->operands[1].regs[0]) {\n\t\t\tif (op->operands[1].regs[0] >= X86R_R8 &&\n\t\t\t    op->operands[0].reg < 4) {\n\t\t\t\tdata[l++] = 0x41;\n\t\t\t\tdata[l++] = 0x8a;\n\t\t\t\tdata[l++] = op->operands[0].reg << 3 | (op->operands[1].regs[0] - 8);\n\t\t\t\treturn l;\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (op->operands[1].type & OT_REGTYPE & OT_SEGMENTREG) {\n\t\t\tif (op->operands[1].scale[0] == 0) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tdata[l++] = SEG_REG_PREFIXES[op->operands[1].regs[0] % 6];\n\t\t\tdata[l++] = 0x8b;\n\t\t\tdata[l++] = (((ut32)op->operands[0].reg) << 3) | 0x5;\n\t\t\tdata[l++] = offset;\n\t\t\tdata[l++] = offset >> 8;\n\t\t\tdata[l++] = offset >> 16;\n\t\t\tdata[l++] = offset >> 24;\n\t\t\treturn l;\n\t\t}\n\n\t\tif (a->bits == 64) {\n\t\t\tif (op->operands[0].type & OT_QWORD) {\n\t\t\t\tif (!(op->operands[1].type & OT_QWORD)) {\n\t\t\t\t\tif (op->operands[1].regs[0] != -1) {\n\t\t\t\t\t\tdata[l++] = 0x67;\n\t\t\t\t\t}\n\t\t\t\t\tdata[l++] = 0x48;\n\t\t\t\t}\n\t\t\t} else if (op->operands[1].type & OT_DWORD) {\n\t\t\t\tdata[l++] = 0x44;\n\t\t\t} else if (!(op->operands[1].type & OT_QWORD)) {\n\t\t\t\tdata[l++] = 0x67;\n\t\t\t}\n\t\t\tif (op->operands[1].type & OT_QWORD &&\n\t\t\t\top->operands[0].type & OT_QWORD) {\n\t\t\t\tdata[l++] = 0x48;\n\t\t\t}\n\t\t}\n\n\t\tif (op->operands[0].type & OT_WORD) {\n\t\t\tdata[l++] = 0x66;\n\t\t\tdata[l++] = op->operands[1].type & OT_BYTE ? 0x8a : 0x8b;\n\t\t} else {\n\t\t\tdata[l++] = (op->operands[1].type & OT_BYTE ||\n\t\t\t\top->operands[0].type & OT_BYTE) ?\n\t\t\t\t0x8a : 0x8b;\n\t\t}\n\n\t\tif (op->operands[1].regs[0] == X86R_UNDEFINED) {\n\t\t\tif (a->bits == 64) {\n\t\t\t\tdata[l++] = op->operands[0].reg << 3 | 0x4;\n\t\t\t\tdata[l++] = 0x25;\n\t\t\t} else {\n\t\t\t\tdata[l++] = op->operands[0].reg << 3 | 0x5;\n\t\t\t}\n\t\t\tdata[l++] = offset;\n\t\t\tdata[l++] = offset >> 8;\n\t\t\tdata[l++] = offset >> 16;\n\t\t\tdata[l++] = offset >> 24;\n\t\t} else {\n\t\t\tif (op->operands[1].scale[0] > 1) {\n\t\t\t\tdata[l++] = op->operands[0].reg << 3 | 4;\n\n\t\t\t\tif (op->operands[1].scale[0] >= 2) {\n\t\t\t\t\tbase = 5;\n\t\t\t\t}\n\t\t\t\tif (base) {\n\t\t\t\t\tdata[l++] = getsib (op->operands[1].scale[0]) << 6 | op->operands[1].regs[0] << 3 | base;\n\t\t\t\t} else {\n\t\t\t\t\tdata[l++] = getsib (op->operands[1].scale[0]) << 3 | op->operands[1].regs[0];\n\t\t\t\t}\n\t\t\t\tif (offset || base) {\n\t\t\t\t\tdata[l++] = offset;\n\t\t\t\t\tdata[l++] = offset >> 8;\n\t\t\t\t\tdata[l++] = offset >> 16;\n\t\t\t\t\tdata[l++] = offset >> 24;\n\t\t\t\t}\n\t\t\t\treturn l;\n\t\t\t}\n\t\t\tif (op->operands[1].regs[1] != X86R_UNDEFINED) {\n\t\t\t\tdata[l++] = op->operands[0].reg << 3 | 0x4;\n\t\t\t\tdata[l++] = op->operands[1].regs[1] << 3 | op->operands[1].regs[0];\n\t\t\t\treturn l;\n\t\t\t}\n\n\t\t\tif (offset || op->operands[1].regs[0] == X86R_EBP) {\n\t\t\t\tmod = 0x2;\n\t\t\t\tif (op->operands[1].offset > 127) {\n\t\t\t\t\tmod = 0x4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->bits == 64 && offset && op->operands[0].type & OT_QWORD) {\n\t\t\t\tif (op->operands[1].regs[0] == X86R_RIP) {\n\t\t\t\t\tdata[l++] = 0x5;\n\t\t\t\t} else {\n\t\t\t\t\tif (op->operands[1].offset > 127) {\n\t\t\t\t\t\tdata[l++] = 0x80 | op->operands[0].reg << 3 | op->operands[1].regs[0];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdata[l++] = 0x40 | op->operands[1].regs[0];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (op->operands[1].offset > 127) {\n\t\t\t\t\tmod = 0x1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (op->operands[1].regs[0] == X86R_EIP && (op->operands[0].type & OT_DWORD)) {\n\t\t\t\t\tdata[l++] = 0x0d;\n\t\t\t\t} else if (op->operands[1].regs[0] == X86R_RIP && (op->operands[0].type & OT_QWORD)) {\n\t\t\t\t\tdata[l++] = 0x05;\n\t\t\t\t} else {\n\t\t\t\t\tdata[l++] = mod << 5 | op->operands[0].reg << 3 | op->operands[1].regs[0];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (op->operands[1].regs[0] == X86R_ESP) {\n\t\t\t\tdata[l++] = 0x24;\n\t\t\t}\n\t\t\tif (mod >= 0x2) {\n\t\t\t\tdata[l++] = offset;\n\t\t\t\tif (op->operands[1].offset > 128 || op->operands[1].regs[0] == X86R_EIP) {\n\t\t\t\t\tdata[l++] = offset >> 8;\n\t\t\t\t\tdata[l++] = offset >> 16;\n\t\t\t\t\tdata[l++] = offset >> 24;\n\t\t\t\t}\n\t\t\t} else if (a->bits == 64 && (offset || op->operands[1].regs[0] == X86R_RIP)) {\n\t\t\t\tdata[l++] = offset;\n\t\t\t\tif (op->operands[1].offset > 127 || op->operands[1].regs[0] == X86R_RIP) {\n\t\t\t\t\tdata[l++] = offset >> 8;\n\t\t\t\t\tdata[l++] = offset >> 16;\n\t\t\t\t\tdata[l++] = offset >> 24;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn l;\n}", "target": 1, "idx": 10092}
{"commit_id": "ab79efab0a0ba01a74df782eb7fa44b044dae8b5", "project": "torvalds/linux", "func": "static int ovl_copy_up_locked(struct dentry *workdir, struct dentry *upperdir,\n\t\t\t      struct dentry *dentry, struct path *lowerpath,\n\t\t\t      struct kstat *stat, struct iattr *attr,\n\t\t\t      const char *link)\n{\n\tstruct inode *wdir = workdir->d_inode;\n\tstruct inode *udir = upperdir->d_inode;\n\tstruct dentry *newdentry = NULL;\n\tstruct dentry *upper = NULL;\n\tumode_t mode = stat->mode;\n\tint err;\n\n\tnewdentry = ovl_lookup_temp(workdir, dentry);\n\terr = PTR_ERR(newdentry);\n\tif (IS_ERR(newdentry))\n\t\tgoto out;\n\n\tupper = lookup_one_len(dentry->d_name.name, upperdir,\n\t\t\t       dentry->d_name.len);\n\terr = PTR_ERR(upper);\n\tif (IS_ERR(upper))\n\t\tgoto out1;\n\n\t/* Can't properly set mode on creation because of the umask */\n\tstat->mode &= S_IFMT;\n\terr = ovl_create_real(wdir, newdentry, stat, link, NULL, true);\n\tstat->mode = mode;\n\tif (err)\n\t\tgoto out2;\n\n\tif (S_ISREG(stat->mode)) {\n\t\tstruct path upperpath;\n\t\tovl_path_upper(dentry, &upperpath);\n\t\tBUG_ON(upperpath.dentry != NULL);\n\t\tupperpath.dentry = newdentry;\n\n\t\terr = ovl_copy_up_data(lowerpath, &upperpath, stat->size);\n\t\tif (err)\n\t\t\tgoto out_cleanup;\n\t}\n\n\terr = ovl_copy_xattr(lowerpath->dentry, newdentry);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\tmutex_lock(&newdentry->d_inode->i_mutex);\n\terr = ovl_set_attr(newdentry, stat);\n\tif (!err && attr)\n\t\terr = notify_change(newdentry, attr, NULL);\n\tmutex_unlock(&newdentry->d_inode->i_mutex);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\terr = ovl_do_rename(wdir, newdentry, udir, upper, 0);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\tovl_dentry_update(dentry, newdentry);\n\tnewdentry = NULL;\n\n\t/*\n\t * Non-directores become opaque when copied up.\n\t */\n\tif (!S_ISDIR(stat->mode))\n\t\tovl_dentry_set_opaque(dentry, true);\nout2:\n\tdput(upper);\nout1:\n\tdput(newdentry);\nout:\n\treturn err;\n\nout_cleanup:\n\tovl_cleanup(wdir, newdentry);\n\tgoto out2;\n}", "target": 1, "idx": 10093}
{"commit_id": "42cf4e63ee7f0eb830644ea37c37a2a9e256befd", "project": "labapart/gattlib", "func": "static gatt_connection_t *initialize_gattlib_connection(const gchar *src, const gchar *dst,\n\t\tuint8_t dest_type, BtIOSecLevel sec_level, int psm, int mtu,\n\t\tgatt_connect_cb_t connect_cb,\n\t\tio_connect_arg_t* io_connect_arg)\n{\n\tbdaddr_t sba, dba;\n\tGError *err = NULL;\n\tint ret;\n\n\tio_connect_arg->error = NULL;\n\n\t/* Check if the GattLib thread has been started */\n\tif (g_gattlib_thread.ref == 0) {\n\t\t/* Start it */\n\n\t\t/* Create a thread that will handle Bluetooth events */\n\t\tint error = pthread_create(&g_gattlib_thread.thread, NULL, &connection_thread, &g_gattlib_thread);\n\t\tif (error != 0) {\n\t\t\tfprintf(stderr, \"Cannot create connection thread: %s\", strerror(error));\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* Wait for the loop to be started */\n\t\twhile (!g_gattlib_thread.loop || !g_main_loop_is_running (g_gattlib_thread.loop)) {\n\t\t\tusleep(1000);\n\t\t}\n\t} else {\n\t\t/* Increase the reference to know how many GATT connection use the loop */\n\t\tg_gattlib_thread.ref++;\n\t}\n\n\t/* Remote device */\n\tif (dst == NULL) {\n\t\tfprintf(stderr, \"Remote Bluetooth address required\\n\");\n\t\treturn NULL;\n\t}\n\n\tret = str2ba(dst, &dba);\n\tif (ret != 0) {\n\t\tfprintf(stderr, \"Destination address '%s' is not valid.\\n\", dst);\n\t\treturn NULL;\n\t}\n\n\t/* Local adapter */\n\tif (src != NULL) {\n\t\tif (!strncmp(src, \"hci\", 3)) {\n\t\t\thci_devba(atoi(src + 3), &sba);\n\t\t} else {\n\t\t\tret = str2ba(src, &sba);\n\t\t\tif (ret != 0) {\n\t\t\t\tfprintf(stderr, \"Source address '%s' is not valid.\\n\", src);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tbacpy(&sba, BDADDR_ANY);\n\t}\n\n\t/* Not used for BR/EDR */\n\tif ((dest_type != BDADDR_LE_PUBLIC) && (dest_type != BDADDR_LE_RANDOM)) {\n\t\treturn NULL;\n\t}\n\n\tif ((sec_level != BT_IO_SEC_LOW) && (sec_level != BT_IO_SEC_MEDIUM) && (sec_level != BT_IO_SEC_HIGH)) {\n\t\treturn NULL;\n\t}\n\n\tgattlib_context_t* conn_context = calloc(sizeof(gattlib_context_t), 1);\n\tif (conn_context == NULL) {\n\t\treturn NULL;\n\t}\n\n\tgatt_connection_t* conn = calloc(sizeof(gatt_connection_t), 1);\n\tif (conn == NULL) {\n\t\treturn NULL;\n\t}\n\n\tconn->context = conn_context;\n\n    /* Intialize bt_io_connect argument */\n\tio_connect_arg->conn       = conn;\n\tio_connect_arg->connect_cb = connect_cb;\n\tio_connect_arg->connected  = FALSE;\n\tio_connect_arg->timeout    = FALSE;\n\tio_connect_arg->error      = NULL;\n\n\tif (psm == 0) {\n\t\tconn_context->io = bt_io_connect(\n#if BLUEZ_VERSION_MAJOR == 4\n\t\t\t\tBT_IO_L2CAP,\n#endif\n\t\t\t\tio_connect_cb, io_connect_arg, NULL, &err,\n\t\t\t\tBT_IO_OPT_SOURCE_BDADDR, &sba,\n#if BLUEZ_VERSION_MAJOR == 5\n\t\t\t\tBT_IO_OPT_SOURCE_TYPE, BDADDR_LE_PUBLIC,\n#endif\n\t\t\t\tBT_IO_OPT_DEST_BDADDR, &dba,\n\t\t\t\tBT_IO_OPT_DEST_TYPE, dest_type,\n\t\t\t\tBT_IO_OPT_CID, ATT_CID,\n\t\t\t\tBT_IO_OPT_SEC_LEVEL, sec_level,\n\t\t\t\tBT_IO_OPT_TIMEOUT, CONNECTION_TIMEOUT,\n\t\t\t\tBT_IO_OPT_INVALID);\n\t} else {\n\t\tconn_context->io = bt_io_connect(\n#if BLUEZ_VERSION_MAJOR == 4\n\t\t\t\tBT_IO_L2CAP,\n#endif\n\t\t\t\tio_connect_cb, io_connect_arg, NULL, &err,\n\t\t\t\tBT_IO_OPT_SOURCE_BDADDR, &sba,\n#if BLUEZ_VERSION_MAJOR == 5\n\t\t\t\tBT_IO_OPT_SOURCE_TYPE, BDADDR_LE_PUBLIC,\n#endif\n\t\t\t\tBT_IO_OPT_DEST_BDADDR, &dba,\n\t\t\t\tBT_IO_OPT_PSM, psm,\n\t\t\t\tBT_IO_OPT_IMTU, mtu,\n\t\t\t\tBT_IO_OPT_SEC_LEVEL, sec_level,\n\t\t\t\tBT_IO_OPT_TIMEOUT, CONNECTION_TIMEOUT,\n\t\t\t\tBT_IO_OPT_INVALID);\n\t}\n\n\tif (err) {\n\t\tfprintf(stderr, \"%s\\n\", err->message);\n\t\tg_error_free(err);\n\t\tfree(conn_context);\n\t\tfree(conn);\n\t\treturn NULL;\n\t} else {\n\t\treturn conn;\n\t}\n}", "target": 2, "idx": 10094}
{"commit_id": "a80776332fd8c99b58beab5d91a6675e85013628", "project": "chromium", "func": "bool UserScriptInjector::ShouldInjectCss(\n    UserScript::RunLocation run_location) const {\n  return script_ && run_location == UserScript::DOCUMENT_START &&\n         !script_->css_scripts().empty();\n}", "target": 2, "idx": 10095}
{"commit_id": "b29c457a6511435960115c0f548c4360d5f4801d", "project": "torvalds/linux", "func": "static int translate_compat_table(struct net *net,\n\t\t\t\t  struct xt_table_info **pinfo,\n\t\t\t\t  void **pentry0,\n\t\t\t\t  const struct compat_arpt_replace *compatr)\n{\n\tunsigned int i, j;\n\tstruct xt_table_info *newinfo, *info;\n\tvoid *pos, *entry0, *entry1;\n\tstruct compat_arpt_entry *iter0;\n\tstruct arpt_replace repl;\n\tunsigned int size;\n\tint ret;\n\n\tinfo = *pinfo;\n\tentry0 = *pentry0;\n\tsize = compatr->size;\n\tinfo->number = compatr->num_entries;\n\n\tj = 0;\n\txt_compat_lock(NFPROTO_ARP);\n\tret = xt_compat_init_offsets(NFPROTO_ARP, compatr->num_entries);\n\tif (ret)\n\t\tgoto out_unlock;\n\t/* Walk through entries, checking offsets. */\n\txt_entry_foreach(iter0, entry0, compatr->size) {\n\t\tret = check_compat_entry_size_and_hooks(iter0, info, &size,\n\t\t\t\t\t\t\tentry0,\n\t\t\t\t\t\t\tentry0 + compatr->size);\n\t\tif (ret != 0)\n\t\t\tgoto out_unlock;\n\t\t++j;\n\t}\n\n\tret = -EINVAL;\n\tif (j != compatr->num_entries)\n\t\tgoto out_unlock;\n\n\tret = -ENOMEM;\n\tnewinfo = xt_alloc_table_info(size);\n\tif (!newinfo)\n\t\tgoto out_unlock;\n\n\tmemset(newinfo->entries, 0, size);\n\n\tnewinfo->number = compatr->num_entries;\n\tfor (i = 0; i < NF_ARP_NUMHOOKS; i++) {\n\t\tnewinfo->hook_entry[i] = compatr->hook_entry[i];\n\t\tnewinfo->underflow[i] = compatr->underflow[i];\n\t}\n\tentry1 = newinfo->entries;\n\tpos = entry1;\n\tsize = compatr->size;\n\txt_entry_foreach(iter0, entry0, compatr->size)\n\t\tcompat_copy_entry_from_user(iter0, &pos, &size,\n\t\t\t\t\t    newinfo, entry1);\n\n\t/* all module references in entry0 are now gone */\n\n\txt_compat_flush_offsets(NFPROTO_ARP);\n\txt_compat_unlock(NFPROTO_ARP);\n\n\tmemcpy(&repl, compatr, sizeof(*compatr));\n\n\tfor (i = 0; i < NF_ARP_NUMHOOKS; i++) {\n\t\trepl.hook_entry[i] = newinfo->hook_entry[i];\n\t\trepl.underflow[i] = newinfo->underflow[i];\n\t}\n\n\trepl.num_counters = 0;\n\trepl.counters = NULL;\n\trepl.size = newinfo->size;\n\tret = translate_table(net, newinfo, entry1, &repl);\n\tif (ret)\n\t\tgoto free_newinfo;\n\n\t*pinfo = newinfo;\n\t*pentry0 = entry1;\n\txt_free_table_info(info);\n\treturn 0;\n\nfree_newinfo:\n\txt_free_table_info(newinfo);\n\treturn ret;\nout_unlock:\n\txt_compat_flush_offsets(NFPROTO_ARP);\n\txt_compat_unlock(NFPROTO_ARP);\n\txt_entry_foreach(iter0, entry0, compatr->size) {\n\t\tif (j-- == 0)\n\t\t\tbreak;\n\t\tcompat_release_entry(iter0);\n\t}\n\treturn ret;\n}", "target": 2, "idx": 10096}
{"commit_id": "a00d237346894c6067a594983be6634f4168c9ad", "project": "facebook/hermes", "func": "CallResult<HermesValue>\nhermesBuiltinCopyDataProperties(void *, Runtime &runtime, NativeArgs args) {\n  GCScope gcScope{runtime};\n\n  // 1. Assert: Type(target) is Object.\n  Handle<JSObject> target = args.dyncastArg<JSObject>(0);\n  // To be safe, ignore non-objects.\n  if (!target)\n    return HermesValue::encodeUndefinedValue();\n\n  // 3. If source is undefined or null, return target.\n  Handle<> untypedSource = args.getArgHandle(1);\n  if (untypedSource->isNull() || untypedSource->isUndefined())\n    return target.getHermesValue();\n\n  // 4. Let from be ! ToObject(source).\n  Handle<JSObject> source = untypedSource->isObject()\n      ? Handle<JSObject>::vmcast(untypedSource)\n      : Handle<JSObject>::vmcast(\n            runtime.makeHandle(*toObject(runtime, untypedSource)));\n\n  // 2. Assert: excludedItems is a List of property keys.\n  // In Hermes, excludedItems is represented as a JSObject, created by\n  // bytecode emitted by the compiler, whose keys are the excluded\n  // propertyKeys\n  Handle<JSObject> excludedItems = args.dyncastArg<JSObject>(2);\n  assert(\n      (!excludedItems || !excludedItems->isProxyObject()) &&\n      \"excludedItems internal List is a Proxy\");\n\n  // We cannot use the fast path if the object is a proxy, host object, or when\n  // there could potentially be an accessor defined on the object. This is\n  // because in order to use JSObject::forEachOwnPropertyWhile, we must not\n  // modify the underlying property map or hidden class. However, if we have an\n  // accessor, we cannot guarantee that condition, so we use the slow path.\n  if (source->isProxyObject() || source->isHostObject() ||\n      source->getClass(runtime)->getMayHaveAccessor()) {\n    return copyDataPropertiesSlowPath_RJS(\n        runtime, target, source, excludedItems);\n  }\n\n  MutableHandle<> nameHandle{runtime};\n  MutableHandle<> valueHandle{runtime};\n  MutableHandle<SymbolID> tmpSymbolStorage{runtime};\n\n  // Process all named properties/symbols.\n  bool success = JSObject::forEachOwnPropertyWhile(\n      source,\n      runtime,\n      // indexedCB.\n      [&source,\n       &target,\n       &excludedItems,\n       &nameHandle,\n       &valueHandle,\n       &tmpSymbolStorage](\n          Runtime &runtime, uint32_t index, ComputedPropertyDescriptor desc) {\n        if (!desc.flags.enumerable)\n          return true;\n\n        nameHandle = HermesValue::encodeNumberValue(index);\n\n        if (excludedItems) {\n          assert(\n              !excludedItems->isProxyObject() &&\n              \"internal excludedItems object is a proxy\");\n          ComputedPropertyDescriptor xdesc;\n          auto cr = JSObject::getOwnComputedPrimitiveDescriptor(\n              excludedItems,\n              runtime,\n              nameHandle,\n              JSObject::IgnoreProxy::Yes,\n              tmpSymbolStorage,\n              xdesc);\n          if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION))\n            return false;\n          if (*cr)\n            return true;\n        }\n\n        valueHandle = JSObject::getOwnIndexed(\n            createPseudoHandle(source.get()), runtime, index);\n\n        if (LLVM_UNLIKELY(\n                JSObject::defineOwnComputedPrimitive(\n                    target,\n                    runtime,\n                    nameHandle,\n                    DefinePropertyFlags::getDefaultNewPropertyFlags(),\n                    valueHandle) == ExecutionStatus::EXCEPTION)) {\n          return false;\n        }\n\n        return true;\n      },\n      // namedCB.\n      [&source, &target, &excludedItems, &valueHandle](\n          Runtime &runtime, SymbolID sym, NamedPropertyDescriptor desc) {\n        if (!desc.flags.enumerable)\n          return true;\n        if (InternalProperty::isInternal(sym))\n          return true;\n\n        // Skip excluded items.\n        if (excludedItems) {\n          auto cr = JSObject::hasNamedOrIndexed(excludedItems, runtime, sym);\n          assert(\n              cr != ExecutionStatus::EXCEPTION &&\n              \"hasNamedOrIndex failed, which can only happen with a proxy, \"\n              \"but excludedItems should never be a proxy\");\n          if (*cr)\n            return true;\n        }\n\n        SmallHermesValue shv =\n            JSObject::getNamedSlotValueUnsafe(*source, runtime, desc);\n        valueHandle = runtime.makeHandle(shv.unboxToHV(runtime));\n\n        // sym can be an index-like property, so we have to bypass the assert in\n        // defineOwnPropertyInternal.\n        if (LLVM_UNLIKELY(\n                JSObject::defineOwnPropertyInternal(\n                    target,\n                    runtime,\n                    sym,\n                    DefinePropertyFlags::getDefaultNewPropertyFlags(),\n                    valueHandle) == ExecutionStatus::EXCEPTION)) {\n          return false;\n        }\n\n        return true;\n      });\n\n  if (LLVM_UNLIKELY(!success))\n    return ExecutionStatus::EXCEPTION;\n\n  return target.getHermesValue();\n}", "target": 3, "idx": 10097}
{"commit_id": "0da8b8b801f9276359262f1ef8274c7812d3dfda", "project": "php/php-src", "func": "static inline void write_s3row_data(\n\tconst entity_stage3_row *r,\n\tunsigned orig_cp,\n\tenum entity_charset charset,\n\tzval *arr)\n{\n\tchar key[9] = \"\"; /* two unicode code points in UTF-8 */\n\tchar entity[LONGEST_ENTITY_LENGTH + 2] = {'&'};\n\tsize_t written_k1;\n\n\twritten_k1 = write_octet_sequence(key, charset, orig_cp);\n\n\tif (!r->ambiguous) {\n\t\tsize_t l = r->data.ent.entity_len;\n\t\tmemcpy(&entity[1], r->data.ent.entity, l);\n\t\tentity[l + 1] = ';';\n\t\tadd_assoc_stringl_ex(arr, key, written_k1 + 1, entity, l + 2, 1);\n\t} else {\n\t\tunsigned i,\n\t\t\t     num_entries;\n\t\tconst entity_multicodepoint_row *mcpr = r->data.multicodepoint_table;\n\n\t\tif (mcpr[0].leading_entry.default_entity != NULL) {\n\t\t\tsize_t l = mcpr[0].leading_entry.default_entity_len;\n\t\t\tmemcpy(&entity[1], mcpr[0].leading_entry.default_entity, l);\n\t\t\tentity[l + 1] = ';';\n\t\t\tadd_assoc_stringl_ex(arr, key, written_k1 + 1, entity, l + 2, 1);\n\t\t}\n\t\tnum_entries = mcpr[0].leading_entry.size;\n\t\tfor (i = 1; i <= num_entries; i++) {\n\t\t\tsize_t   l,\n\t\t\t\t     written_k2;\n\t\t\tunsigned uni_cp,\n\t\t\t\t\t spe_cp;\n\n\t\t\tuni_cp = mcpr[i].normal_entry.second_cp;\n\t\t\tl = mcpr[i].normal_entry.entity_len;\n\n\t\t\tif (!CHARSET_UNICODE_COMPAT(charset)) {\n\t\t\t\tif (map_from_unicode(uni_cp, charset, &spe_cp) == FAILURE)\n\t\t\t\t\tcontinue; /* non representable in this charset */\n\t\t\t} else {\n\t\t\t\tspe_cp = uni_cp;\n\t\t\t}\n\n\t\t\twritten_k2 = write_octet_sequence(&key[written_k1], charset, spe_cp);\n\t\t\tmemcpy(&entity[1], mcpr[i].normal_entry.entity, l);\n\t\t\tentity[l + 1] = ';';\n\t\t\tentity[l + 1] = '\\0';\n\t\t\tadd_assoc_stringl_ex(arr, key, written_k1 + written_k2 + 1, entity, l + 1, 1);\n\t\t}\n\t}\n}", "target": 2, "idx": 10098}
{"commit_id": "faa76f39014ed3b5e2c158593b1335522e573c7f", "project": "tensorflow", "func": "void SparseFillEmptyRowsOpImpl(OpKernelContext* context,\n                               AsyncOpKernel::DoneCallback done = nullptr) {\n  // Note that setting this empty lambda as the default parameter value directly\n  // can cause strange compiler/linker errors, so we do it like this instead.\n  if (!done) {\n    done = [] {};\n  }\n\n  const int kIndicesInput = 0;\n  const int kValuesInput = 1;\n  const int kDenseShapeInput = 2;\n  const int kDefaultValueInput = 3;\n\n  const Tensor& indices_t = context->input(kIndicesInput);\n  const Tensor& values_t = context->input(kValuesInput);\n  const Tensor& dense_shape_t = context->input(kDenseShapeInput);\n  const Tensor& default_value_t = context->input(kDefaultValueInput);\n\n  OP_REQUIRES_ASYNC(\n      context, TensorShapeUtils::IsVector(dense_shape_t.shape()),\n      errors::InvalidArgument(\"dense_shape must be a vector, saw: \",\n                              dense_shape_t.shape().DebugString()),\n      done);\n  OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsMatrix(indices_t.shape()),\n                    errors::InvalidArgument(\"indices must be a matrix, saw: \",\n                                            indices_t.shape().DebugString()),\n                    done);\n  OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsVector(values_t.shape()),\n                    errors::InvalidArgument(\"values must be a vector, saw: \",\n                                            values_t.shape().DebugString()),\n                    done);\n  OP_REQUIRES_ASYNC(\n      context, TensorShapeUtils::IsScalar(default_value_t.shape()),\n      errors::InvalidArgument(\"default_value must be a scalar, saw: \",\n                              default_value_t.shape().DebugString()),\n      done);\n  // TODO(ebrevdo): add shape checks between values, indices,\n  // Also add check that dense rank > 0.\n  OP_REQUIRES_ASYNC(context, dense_shape_t.NumElements() != 0,\n                    errors::InvalidArgument(\"Dense shape cannot be empty.\"),\n                    done);\n\n  using FunctorType = functor::SparseFillEmptyRows<Device, T, Tindex>;\n  OP_REQUIRES_OK_ASYNC(context,\n                       FunctorType()(context, default_value_t, indices_t,\n                                     values_t, dense_shape_t, done),\n                       done);\n}", "target": 0, "idx": 10099}
{"commit_id": "330359921e2e4c2f3f3a10b5bab86942d63c4428", "project": "projectacrn/acrn-hypervisor", "func": "static int\npci_xhci_complete_commands(struct pci_xhci_vdev *xdev)\n{\n\tstruct xhci_trb\tevtrb;\n\tstruct xhci_trb\t*trb;\n\tuint64_t\tcrcr;\n\tuint32_t\tccs;\t\t/* cycle state (XHCI 4.9.2) */\n\tuint32_t\ttype;\n\tuint32_t\tslot;\n\tuint32_t\tcmderr;\n\n\txdev->opregs.crcr |= XHCI_CRCR_LO_CRR;\n\n\ttrb = xdev->opregs.cr_p;\n\tccs = xdev->opregs.crcr & XHCI_CRCR_LO_RCS;\n\tcrcr = xdev->opregs.crcr & ~0xF;\n\tif (!trb) {\n\t\tUPRINTF(LDBG, \"Get the invalid guest address!\\r\\n\");\n\t\tgoto out;\n\t}\n\n\twhile (1) {\n\t\txdev->opregs.cr_p = trb;\n\n\t\ttype = XHCI_TRB_3_TYPE_GET(trb->dwTrb3);\n\n\t\tif ((trb->dwTrb3 & XHCI_TRB_3_CYCLE_BIT) !=\n\t\t    (ccs & XHCI_TRB_3_CYCLE_BIT))\n\t\t\tbreak;\n\n\t\tUPRINTF(LDBG, \"cmd type 0x%x, Trb0 x%016lx dwTrb2 x%08x\"\n\t\t\t\" dwTrb3 x%08x, TRB_CYCLE %u/ccs %u\\r\\n\",\n\t\t\ttype, trb->qwTrb0, trb->dwTrb2, trb->dwTrb3,\n\t\t\ttrb->dwTrb3 & XHCI_TRB_3_CYCLE_BIT, ccs);\n\n\t\tcmderr = XHCI_TRB_ERROR_SUCCESS;\n\t\tevtrb.dwTrb2 = 0;\n\t\tevtrb.dwTrb3 = (ccs & XHCI_TRB_3_CYCLE_BIT) |\n\t\t      XHCI_TRB_3_TYPE_SET(XHCI_TRB_EVENT_CMD_COMPLETE);\n\t\tslot = 0;\n\n\t\tswitch (type) {\n\t\tcase XHCI_TRB_TYPE_LINK:\t\t\t/* 0x06 */\n\t\t\tif (trb->dwTrb3 & XHCI_TRB_3_TC_BIT)\n\t\t\t\tccs ^= XHCI_CRCR_LO_RCS;\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_ENABLE_SLOT:\t\t\t/* 0x09 */\n\t\t\t/*\n\t\t\t *From xHCI spec 4.5.3.2, the only command that\n\t\t\t *software is allowed to issue for the slot in\n\t\t\t *disabled state is the Enable Slot Command.\n\t\t\t * */\n\t\t\tcmderr = pci_xhci_cmd_enable_slot(xdev, &slot);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_DISABLE_SLOT:\t\t/* 0x0A */\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_disable_slot(xdev, slot);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_ADDRESS_DEVICE:\t\t/* 0x0B */\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_address_device(xdev, slot, trb);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_CONFIGURE_EP:\t\t/* 0x0C */\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_config_ep(xdev, slot, trb);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_EVALUATE_CTX:\t\t/* 0x0D */\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_eval_ctx(xdev, slot, trb);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_RESET_EP:\t\t\t/* 0x0E */\n\t\t\tUPRINTF(LDBG, \"Reset Endpoint on slot %d\\r\\n\", slot);\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_reset_ep(xdev, slot, trb);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_STOP_EP:\t\t\t/* 0x0F */\n\t\t\tUPRINTF(LDBG, \"Stop Endpoint on slot %d\\r\\n\", slot);\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_reset_ep(xdev, slot, trb);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_SET_TR_DEQUEUE:\t\t/* 0x10 */\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_set_tr(xdev, slot, trb);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_RESET_DEVICE:\t\t/* 0x11 */\n\t\t\tXHCI_GET_SLOT(xdev, trb, slot, cmderr);\n\t\t\tif (slot)\n\t\t\t\tcmderr = pci_xhci_cmd_reset_device(xdev, slot);\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_FORCE_EVENT:\t\t\t/* 0x12 */\n\t\t\t/* TODO: */\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_NEGOTIATE_BW:\t\t/* 0x13 */\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_SET_LATENCY_TOL:\t\t/* 0x14 */\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_GET_PORT_BW:\t\t\t/* 0x15 */\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_FORCE_HEADER:\t\t/* 0x16 */\n\t\t\tbreak;\n\n\t\tcase XHCI_TRB_TYPE_NOOP_CMD:\t\t\t/* 0x17 */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tUPRINTF(LDBG, \"unsupported cmd %x\\r\\n\", type);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (type != XHCI_TRB_TYPE_LINK) {\n\t\t\t/*\n\t\t\t * insert command completion event and assert intr\n\t\t\t */\n\t\t\tevtrb.qwTrb0 = crcr;\n\t\t\tevtrb.dwTrb2 |= XHCI_TRB_2_ERROR_SET(cmderr);\n\t\t\tevtrb.dwTrb3 |= XHCI_TRB_3_SLOT_SET(slot);\n\t\t\tUPRINTF(LDBG, \"command 0x%x result: 0x%x\\r\\n\",\n\t\t\t\ttype, cmderr);\n\t\t\tif (pci_xhci_insert_event(xdev, &evtrb, 1) != 0) {\n\t\t\t\tUPRINTF(LFTL, \"Failed to inject command completion event!\\r\\n\");\n\t\t\t\treturn -ENAVAIL;\n\t\t\t}\n\t\t}\n\n\t\ttrb = pci_xhci_trb_next(xdev, trb, &crcr);\n\t\tif (!trb) {\n\t\t\tUPRINTF(LDBG, \"Get the invalid trb in %s!\\r\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\txdev->opregs.crcr = crcr | (xdev->opregs.crcr & XHCI_CRCR_LO_CA) | ccs;\n\txdev->opregs.crcr &= ~XHCI_CRCR_LO_CRR;\n\treturn 0;\n}", "target": 2, "idx": 10100}
{"commit_id": "f044caeed5c0f1566d804f37cbddb2d5ccfd75ea", "project": "AcademySoftwareFoundation/openexr", "func": "void\nTiledInputFile::initialize ()\n{\n    // fix bad types in header (arises when a tool built against an older version of\n    // OpenEXR converts a scanline image to tiled)\n    // only applies when file is a single part, regular image, tiled file\n    //\n    if(!isMultiPart(_data->version) &&\n       !isNonImage(_data->version) && \n       isTiled(_data->version) && \n       _data->header.hasType() )\n    {\n        _data->header.setType(TILEDIMAGE);\n    }\n    \n    if (_data->partNumber == -1)\n    {\n        if (!isTiled (_data->version))\n            throw IEX_NAMESPACE::ArgExc (\"Expected a tiled file but the file is not tiled.\");\n\n        if (isNonImage (_data->version))\n            throw IEX_NAMESPACE::ArgExc (\"File is not a regular tiled image.\");\n\n    }\n    else\n    {\n        if(_data->header.hasType() && _data->header.type()!=TILEDIMAGE)\n        {\n            throw IEX_NAMESPACE::ArgExc (\"TiledInputFile used for non-tiledimage part.\");\n        }\n    }\n    \n    _data->header.sanityCheck (true);\n\n    _data->tileDesc = _data->header.tileDescription();\n    _data->lineOrder = _data->header.lineOrder();\n\n    //\n    // Save the dataWindow information\n    //\n    \n    const Box2i &dataWindow = _data->header.dataWindow();\n    _data->minX = dataWindow.min.x;\n    _data->maxX = dataWindow.max.x;\n    _data->minY = dataWindow.min.y;\n    _data->maxY = dataWindow.max.y;\n\n    //\n    // Precompute level and tile information to speed up utility functions\n    //\n\n    precalculateTileInfo (_data->tileDesc,\n\t\t\t  _data->minX, _data->maxX,\n\t\t\t  _data->minY, _data->maxY,\n\t\t\t  _data->numXTiles, _data->numYTiles,\n\t\t\t  _data->numXLevels, _data->numYLevels);    \n\n    _data->bytesPerPixel = calculateBytesPerPixel (_data->header);\n\n    _data->maxBytesPerTileLine = _data->bytesPerPixel * _data->tileDesc.xSize;\n\n    _data->tileBufferSize = _data->maxBytesPerTileLine * _data->tileDesc.ySize;\n\n    //\n    // OpenEXR has a limit of INT_MAX compressed bytes per tile\n    // disallow uncompressed tile sizes above INT_MAX too to guarantee file is written\n    //\n    if( _data->tileBufferSize > INT_MAX )\n    {\n        throw IEX_NAMESPACE::ArgExc (\"Tile size too large for OpenEXR format\");\n    }\n\n\n    //\n    // Create all the TileBuffers and allocate their internal buffers\n    //\n\n    for (size_t i = 0; i < _data->tileBuffers.size(); i++)\n    {\n        _data->tileBuffers[i] = new TileBuffer (newTileCompressor\n\t\t\t\t\t\t  (_data->header.compression(),\n\t\t\t\t\t\t   _data->maxBytesPerTileLine,\n\t\t\t\t\t\t   _data->tileDesc.ySize,\n\t\t\t\t\t\t   _data->header));\n\n        if (!_data->_streamData->is->isMemoryMapped ())\n            _data->tileBuffers[i]->buffer = new char [_data->tileBufferSize];\n    }\n\n    _data->tileOffsets = TileOffsets (_data->tileDesc.mode,\n\t\t\t\t      _data->numXLevels,\n\t\t\t\t      _data->numYLevels,\n\t\t\t\t      _data->numXTiles,\n\t\t\t\t      _data->numYTiles);\n}", "target": 1, "idx": 10101}
{"commit_id": "23c9775fb6afb7be1472944e02396f29771dc8e2", "project": "wocommunity/wonder", "func": "int WebObjects_translate(request_rec *r) {\n   WebObjects_config *wc;\n   WOURLComponents url;\n   WOURLError urlerr;\n   WOURLError charcheck;\n\n   wc = (WebObjects_config *)ap_get_module_config(r->server->module_config, &WebObjects_module);\n\n   /* WOLog(WO_DBG,\"<WebObjects Apache Module> new translate: %s\",r->uri); */\n   if (strncmp(wc->WebObjects_alias, r->uri, strlen(wc->WebObjects_alias)) == 0) {\n      url = WOURLComponents_Initializer;\n\n#ifndef __PRESERVE_UNSAFE_URLS\n      // Make sure the URL does not contain forbidden characters (0x0D or 0x0A).\n      charcheck = WOValidateInitialURL( r->uri );\n      if ( charcheck != WOURLOK ) {\n         WOLog(WO_ERR, \"WebObjects_translate(): declining request due to forbidden URL characters\");\n         return DECLINED;\n      }\n#endif\n\n\n      urlerr = WOParseApplicationName(&url, r->uri);\n      if (urlerr != WOURLOK && !((urlerr == WOURLInvalidApplicationName) && ac_authorizeAppListing(&url))) {\n         /* WOLog(WO_DBG,\"<WebObjects Apache Module> translate - DECLINED: %s\",r->uri); */\n         return DECLINED;\n      }\n      if (!adaptorEnabled)\n      {\n         WOLog(WO_ERR, \"WebObjects_translate(): declining request due to initialization failure\");\n         return DECLINED;\n      }\n      /*\n       *\twe'll take it - mark our handler...\n       */\n      r->handler = (char *)ap_pstrdup(r->pool, WEBOBJECTS);\n      return OK;\n   }\n   /* WOLog(WO_DBG,\"<WebObjects Apache Module> translate - DECLINED: %s\",r->uri); */\n   return DECLINED;\n}", "target": 1, "idx": 10102}
{"commit_id": "91d0540ac9beaa86719a05b749219a69baa0dd8d", "project": "GNOME/libxslt", "func": "static void\nxsltNumberFormatRoman(xsltNumberDataPtr data,\n\t\t      xmlBufferPtr buffer,\n\t\t      double number,\n\t\t      int is_upper)\n{\n    /*\n     * See discussion in xsltNumberFormatAlpha. Also use a reasonable upper\n     * bound to avoid denial of service.\n     */\n    if (number < 1.0 || number > 5000.0) {\n        xsltNumberFormatDecimal(buffer, number, '0', 1,\n                                data->digitsPerGroup,\n                                data->groupingCharacter,\n                                data->groupingCharacterLen);\n        return;\n    }\n\n    /*\n     * Based on an example by Jim Walsh\n     */\n    while (number >= 1000.0) {\n\txmlBufferCCat(buffer, (is_upper) ? \"M\" : \"m\");\n\tnumber -= 1000.0;\n    }\n    if (number >= 900.0) {\n\txmlBufferCCat(buffer, (is_upper) ? \"CM\" : \"cm\");\n\tnumber -= 900.0;\n    }\n    while (number >= 500.0) {\n\txmlBufferCCat(buffer, (is_upper) ? \"D\" : \"d\");\n\tnumber -= 500.0;\n    }\n    if (number >= 400.0) {\n\txmlBufferCCat(buffer, (is_upper) ? \"CD\" : \"cd\");\n\tnumber -= 400.0;\n    }\n    while (number >= 100.0) {\n\txmlBufferCCat(buffer, (is_upper) ? \"C\" : \"c\");\n\tnumber -= 100.0;\n    }\n    if (number >= 90.0) {\n\txmlBufferCCat(buffer, (is_upper) ? \"XC\" : \"xc\");\n\tnumber -= 90.0;\n    }\n    while (number >= 50.0) {\n\txmlBufferCCat(buffer, (is_upper) ? \"L\" : \"l\");\n\tnumber -= 50.0;\n    }\n    if (number >= 40.0) {\n\txmlBufferCCat(buffer, (is_upper) ? \"XL\" : \"xl\");\n\tnumber -= 40.0;\n    }\n    while (number >= 10.0) {\n\txmlBufferCCat(buffer, (is_upper) ? \"X\" : \"x\");\n\tnumber -= 10.0;\n    }\n    if (number >= 9.0) {\n\txmlBufferCCat(buffer, (is_upper) ? \"IX\" : \"ix\");\n\tnumber -= 9.0;\n    }\n    while (number >= 5.0) {\n\txmlBufferCCat(buffer, (is_upper) ? \"V\" : \"v\");\n\tnumber -= 5.0;\n    }\n    if (number >= 4.0) {\n\txmlBufferCCat(buffer, (is_upper) ? \"IV\" : \"iv\");\n\tnumber -= 4.0;\n    }\n    while (number >= 1.0) {\n\txmlBufferCCat(buffer, (is_upper) ? \"I\" : \"i\");\n\tnumber--;\n    }\n}", "target": 2, "idx": 10103}
{"commit_id": "112992b05b2d2ca63f3c78eefe1cf8d192d7303a", "project": "xen-project/xen", "func": "static inline bool_t port_is_valid(struct domain *d, unsigned int p)\n{\n    if ( p >= read_atomic(&d->valid_evtchns) )\n        return false;\n\n    /*\n     * The caller will usually access the event channel afterwards and\n     * may be done without taking the per-domain lock. The barrier is\n     * going in pair the smp_wmb() barrier in evtchn_allocate_port().\n     */\n    smp_rmb();\n\n    return true;\n}", "target": 2, "idx": 10104}
{"commit_id": "0c4120fffa3dffe97b95c486a120eded82afe8a6", "project": "enferex/pdfresurrect", "func": "static void write_version(\n    FILE       *fp,\n    const char *fname,\n    const char *dirname,\n    xref_t     *xref)\n{\n    long  start;\n    char *c, *new_fname, data;\n    FILE *new_fp;\n    \n    start = ftell(fp);\n\n    /* Create file */\n    if ((c = strstr(fname, \".pdf\")))\n      *c = '\\0';\n    new_fname = safe_calloc(strlen(fname) + strlen(dirname) + 16);\n    snprintf(new_fname, strlen(fname) + strlen(dirname) + 16,\n             \"%s/%s-version-%d.pdf\", dirname, fname, xref->version);\n\n    if (!(new_fp = fopen(new_fname, \"w\")))\n    {\n        ERR(\"Could not create file '%s'\\n\", new_fname);\n        fseek(fp, start, SEEK_SET);\n        free(new_fname);\n        return;\n    }\n    \n    /* Copy original PDF */\n    fseek(fp, 0, SEEK_SET);\n    while (fread(&data, 1, 1, fp))\n      fwrite(&data, 1, 1, new_fp);\n\n    /* Emit an older startxref, refering to an older version. */\n    fprintf(new_fp, \"\\r\\nstartxref\\r\\n%ld\\r\\n%%%%EOF\", xref->start);\n\n    /* Clean */\n    fclose(new_fp);\n    free(new_fname);\n    fseek(fp, start, SEEK_SET);\n}", "target": 2, "idx": 10105}
{"commit_id": "00314989401bfee5ffcb5e579162071c86e72f61", "project": "chromium", "func": "FrameLoader::FrameLoader(LocalFrame* frame)\n    : m_frame(frame)\n    , m_progressTracker(ProgressTracker::create(frame))\n    , m_loadType(FrameLoadTypeStandard)\n    , m_inStopAllLoaders(false)\n    , m_checkTimer(this, &FrameLoader::checkTimerFired)\n    , m_didAccessInitialDocument(false)\n    , m_forcedSandboxFlags(SandboxNone)\n    , m_dispatchingDidClearWindowObjectInMainWorld(false)\n    , m_protectProvisionalLoader(false)\n{\n    TRACE_EVENT_OBJECT_CREATED_WITH_ID(\"loading\", \"FrameLoader\", this);\n    takeObjectSnapshot();\n}", "target": 2, "idx": 10106}
{"commit_id": "a9bf2520ab5abb69f9328906e406fbebfb36159a", "project": "galkahana/HummusJS", "func": "IOBasicTypes::LongBufferSizeType ObjectByteWriterWithPosition::Write(const IOBasicTypes::Byte* inBuffer,IOBasicTypes::LongBufferSizeType inBufferSize)\n{\n\tCREATE_ISOLATE_CONTEXT;\n\tCREATE_ESCAPABLE_SCOPE;\n\n    Local<Object> anArray = NEW_ARRAY((int)inBufferSize);\n    for(int i=0;i<(int)inBufferSize;++i)\n        anArray->Set(GET_CURRENT_CONTEXT, NEW_NUMBER(i),NEW_NUMBER(inBuffer[i]));\n    \n\tLocal<Value> value = OBJECT_FROM_PERSISTENT(mObject)->Get(GET_CURRENT_CONTEXT, NEW_STRING(\"write\")).ToLocalChecked();\n    if(value->IsUndefined() || !value->IsFunction())\n    {\n\t\tTHROW_EXCEPTION(\"write is not a function, it should be you know...\");\n        return 0;\n    }\n    Local<Function> func = Local<Function>::Cast(value);\n    \n    Local<Value> args[1];\n    args[0] = anArray;\n    MaybeLocal<Value> maybe;\n    TryCatch try_catch(Isolate::GetCurrent());\n\n    maybe = func->Call(GET_CURRENT_CONTEXT,  OBJECT_FROM_PERSISTENT(mObject), 1, args);\n    Local <Value> result;\n\n    if (!maybe.ToLocal(&result)) {\n       try_catch.ReThrow();\n       return 0;\n    }\n    if(result.IsEmpty())\n    {\n        THROW_EXCEPTION(\"wrong return value. it's empty. return the number of written characters\");\n        return 0;\n    }\n    else if(result->IsNumber())\n    {\n        return TO_UINT32(result)->Value();\n    }\n    else\n    {\n        THROW_EXCEPTION(\"wrong return value. write should return the number of written characters\");\n        return 0;\n    }\n}", "target": 2, "idx": 10107}
{"commit_id": "56d0332bf91104cfc877635f6c82e9348587df04", "project": "pymumu/smartdns", "func": "int dns_HTTPS_add_ipv6hint(struct dns_rr_nested *svcparam, unsigned char *addr[], int addr_num)\n{\n\tif (_dns_left_len(&svcparam->context) < 4 + addr_num * DNS_RR_AAAA_LEN) {\n\t\treturn -1;\n\t}\n\n\tunsigned short value = DNS_HTTPS_T_IPV6HINT;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\n\tvalue = addr_num * DNS_RR_AAAA_LEN;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\n\tfor (int i = 0; i < addr_num; i++) {\n\t\tdns_add_rr_nested_memcpy(svcparam, addr[i], DNS_RR_AAAA_LEN);\n\t}\n\n\treturn 0;\n}", "target": 3, "idx": 10108}
{"commit_id": "fbfa4d1083ea84c5429992ca3e996d7d4fbc8238", "project": "YanVugenfirer/kvm-guest-drivers-windows", "func": "static __inline tTcpIpPacketParsingResult\nProcessTCPHeader(tTcpIpPacketParsingResult _res, PVOID pIpHeader, ULONG len, USHORT ipHeaderSize)\n{\n    ULONG tcpipDataAt;\n    tTcpIpPacketParsingResult res = _res;\n    tcpipDataAt = ipHeaderSize + sizeof(TCPHeader);\n    res.TcpUdp = ppresIsTCP;\n\n    if (len >= tcpipDataAt)\n    {\n        TCPHeader *pTcpHeader = (TCPHeader *)RtlOffsetToPointer(pIpHeader, ipHeaderSize);\n        res.xxpStatus = ppresXxpKnown;\n        res.xxpFull = TRUE;\n        tcpipDataAt = ipHeaderSize + TCP_HEADER_LENGTH(pTcpHeader);\n        res.XxpIpHeaderSize = tcpipDataAt;\n    }\n    else\n    {\n        DPrintf(2, (\"tcp: %d < min headers %d\\n\", len, tcpipDataAt));\n        res.xxpFull = FALSE;\n        res.xxpStatus = ppresXxpIncomplete;\n    }\n    return res;\n}", "target": 2, "idx": 10109}
{"commit_id": "9c87439d9afa14a365ff13e73adc809cb2c3d97b", "project": "sparklemotion/nokogiri", "func": "void init_xml_relax_ng()\n{\n  VALUE nokogiri = rb_define_module(\"Nokogiri\");\n  VALUE xml = rb_define_module_under(nokogiri, \"XML\");\n  VALUE klass = rb_define_class_under(xml, \"RelaxNG\", cNokogiriXmlSchema);\n\n  cNokogiriXmlRelaxNG = klass;\n\n  rb_define_singleton_method(klass, \"read_memory\", read_memory, -1);\n  rb_define_singleton_method(klass, \"from_document\", from_document, -1);\n  rb_define_private_method(klass, \"validate_document\", validate_document, 1);\n}", "target": 0, "idx": 10110}
{"commit_id": "aacae2065744adb05e858d327198c7bbe7f452b0", "project": "opencv", "func": "bool  SunRasterDecoder::readData( Mat& img )\n{\n    int color = img.channels() > 1;\n    uchar* data = img.ptr();\n    size_t step = img.step;\n    uchar  gray_palette[256] = {0};\n    bool   result = false;\n    int  src_pitch = ((m_width*m_bpp + 7)/8 + 1) & -2;\n    int  nch = color ? 3 : 1;\n    int  width3 = m_width*nch;\n    int  y;\n\n    if( m_offset < 0 || !m_strm.isOpened())\n        return false;\n\n    AutoBuffer<uchar> _src(src_pitch + 32);\n    uchar* src = _src;\n    AutoBuffer<uchar> _bgr(m_width*3 + 32);\n    uchar* bgr = _bgr;\n\n    if( !color && m_maptype == RMT_EQUAL_RGB )\n        CvtPaletteToGray( m_palette, gray_palette, 1 << m_bpp );\n\n    try\n    {\n        m_strm.setPos( m_offset );\n\n        switch( m_bpp )\n        {\n        /************************* 1 BPP ************************/\n        case 1:\n            if( m_type != RAS_BYTE_ENCODED )\n            {\n                for( y = 0; y < m_height; y++, data += step )\n                {\n                    m_strm.getBytes( src, src_pitch );\n                    if( color )\n                        FillColorRow1( data, src, m_width, m_palette );\n                    else\n                        FillGrayRow1( data, src, m_width, gray_palette );\n                }\n                result = true;\n            }\n            else\n            {\n                uchar* line_end = src + (m_width*m_bpp + 7)/8;\n                uchar* tsrc = src;\n                y = 0;\n\n                for(;;)\n                {\n                    int max_count = (int)(line_end - tsrc);\n                    int code = 0, len = 0, len1 = 0;\n\n                    do\n                    {\n                        code = m_strm.getByte();\n                        if( code == 0x80 )\n                        {\n                            len = m_strm.getByte();\n                            if( len != 0 ) break;\n                        }\n                        tsrc[len1] = (uchar)code;\n                    }\n                    while( ++len1 < max_count );\n\n                    tsrc += len1;\n\n                    if( len > 0 ) // encoded mode\n                    {\n                        ++len;\n                        code = m_strm.getByte();\n                        if( len > line_end - tsrc )\n                        {\n                            assert(0);\n                            goto bad_decoding_1bpp;\n                        }\n\n                        memset( tsrc, code, len );\n                        tsrc += len;\n                    }\n\n                    if( tsrc >= line_end )\n                    {\n                        tsrc = src;\n                        if( color )\n                            FillColorRow1( data, src, m_width, m_palette );\n                        else\n                            FillGrayRow1( data, src, m_width, gray_palette );\n                        data += step;\n                        if( ++y >= m_height ) break;\n                    }\n                }\n                result = true;\nbad_decoding_1bpp:\n                ;\n            }\n            break;\n        /************************* 8 BPP ************************/\n        case 8:\n            if( m_type != RAS_BYTE_ENCODED )\n            {\n                for( y = 0; y < m_height; y++, data += step )\n                {\n                    m_strm.getBytes( src, src_pitch );\n                    if( color )\n                        FillColorRow8( data, src, m_width, m_palette );\n                    else\n                        FillGrayRow8( data, src, m_width, gray_palette );\n                }\n                result = true;\n            }\n            else // RLE-encoded\n            {\n                uchar* line_end = data + width3;\n                y = 0;\n\n                for(;;)\n                {\n                    int max_count = (int)(line_end - data);\n                    int code = 0, len = 0, len1;\n                    uchar* tsrc = src;\n\n                    do\n                    {\n                        code = m_strm.getByte();\n                        if( code == 0x80 )\n                        {\n                            len = m_strm.getByte();\n                            if( len != 0 ) break;\n                        }\n                        *tsrc++ = (uchar)code;\n                    }\n                    while( (max_count -= nch) > 0 );\n\n                    len1 = (int)(tsrc - src);\n\n                    if( len1 > 0 )\n                    {\n                        if( color )\n                            FillColorRow8( data, src, len1, m_palette );\n                        else\n                            FillGrayRow8( data, src, len1, gray_palette );\n                        data += len1*nch;\n                    }\n\n                    if( len > 0 ) // encoded mode\n                    {\n                        len = (len + 1)*nch;\n                        code = m_strm.getByte();\n\n                        if( color )\n                            data = FillUniColor( data, line_end, validateToInt(step), width3,\n                                                 y, m_height, len,\n                                                 m_palette[code] );\n                        else\n                            data = FillUniGray( data, line_end, validateToInt(step), width3,\n                                                y, m_height, len,\n                                                gray_palette[code] );\n                        if( y >= m_height )\n                            break;\n                    }\n\n                    if( data == line_end )\n                    {\n                        if( m_strm.getByte() != 0 )\n                            goto bad_decoding_end;\n                        line_end += step;\n                        data = line_end - width3;\n                        if( ++y >= m_height ) break;\n                    }\n                }\n\n                result = true;\nbad_decoding_end:\n                ;\n            }\n            break;\n        /************************* 24 BPP ************************/\n        case 24:\n            for( y = 0; y < m_height; y++, data += step )\n            {\n                m_strm.getBytes( color ? data : bgr, src_pitch );\n\n                if( color )\n                {\n                    if( m_type == RAS_FORMAT_RGB )\n                        icvCvt_RGB2BGR_8u_C3R( data, 0, data, 0, cvSize(m_width,1) );\n                }\n                else\n                {\n                    icvCvt_BGR2Gray_8u_C3C1R( bgr, 0, data, 0, cvSize(m_width,1),\n                                              m_type == RAS_FORMAT_RGB ? 2 : 0 );\n                }\n            }\n            result = true;\n            break;\n        /************************* 32 BPP ************************/\n        case 32:\n            for( y = 0; y < m_height; y++, data += step )\n            {\n                /* hack: a0 b0 g0 r0 a1 b1 g1 r1 ... are written to src + 3,\n                   so when we look at src + 4, we see b0 g0 r0 x b1 g1 g1 x ... */\n                m_strm.getBytes( src + 3, src_pitch );\n\n                if( color )\n                    icvCvt_BGRA2BGR_8u_C4C3R( src + 4, 0, data, 0, cvSize(m_width,1),\n                                              m_type == RAS_FORMAT_RGB ? 2 : 0 );\n                else\n                    icvCvt_BGRA2Gray_8u_C4C1R( src + 4, 0, data, 0, cvSize(m_width,1),\n                                               m_type == RAS_FORMAT_RGB ? 2 : 0 );\n            }\n            result = true;\n            break;\n        default:\n            assert(0);\n        }\n    }\n    catch( ... )\n    {\n    }\n\n    return result;\n}", "target": 1, "idx": 10111}
{"commit_id": "ea7395f39f601a7750d48d606e9d10ea0b7beefe", "project": "gpac", "func": "GF_Err video_sample_entry_box_size(GF_Box *s)\n{\n\tGF_Box *b;\n\tu32 pos=0;\n\tGF_MPEGVisualSampleEntryBox *ptr = (GF_MPEGVisualSampleEntryBox *)s;\n\tgf_isom_video_sample_entry_size((GF_VisualSampleEntryBox *)s);\n\n\t/*make sure we write the config box first, we don't care about the rest*/\n\n\t/*mp4v*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->esd, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_3gpp, &pos);\n\t/*avc / SVC + MVC*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->avc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->svc_config, &pos);\n\tif (ptr->mvc_config) {\n\t\tgf_isom_check_position(s, gf_isom_box_find_child(s->child_boxes, GF_ISOM_BOX_TYPE_VWID), &pos);\n\t\tgf_isom_check_position(s, (GF_Box *)ptr->mvc_config, &pos);\n\t}\n\n\t/*HEVC*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->hevc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->lhvc_config, &pos);\n\n\t/*VVC*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->vvc_config, &pos);\n\n\t/*AV1*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->av1_config, &pos);\n\n\t/*VPx*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->vp_config, &pos);\n\n\t/*JP2H*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->jp2h, &pos);\n\n\t/*DolbyVision*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->dovi_config, &pos);\n\n\tb = gf_isom_box_find_child(ptr->child_boxes, GF_ISOM_BOX_TYPE_ST3D);\n\tif (b) gf_isom_check_position(s, b, &pos);\n\n\tb = gf_isom_box_find_child(ptr->child_boxes, GF_ISOM_BOX_TYPE_SV3D);\n\tif (b) gf_isom_check_position(s, b, &pos);\n\treturn GF_OK;\n}", "target": 2, "idx": 10112}
{"commit_id": "8210a2864372723b49c526e2b102fdc00c9c4699", "project": "ArtifexSoftware/ghostpdl", "func": "static inline int\nmake_table_template(gx_device     * pdev,\n                    gx_path       * path,\n              const gs_fixed_rect * ibox,\n                    int             intersection_size,\n                    fixed           adjust,\n                    int           * scanlinesp,\n                    int          ** indexp,\n                    int          ** tablep)\n{\n    int             scanlines;\n    const subpath * restrict psub;\n    int           * restrict index;\n    int           * restrict table;\n    int             i;\n    int             offset, delta;\n    fixed           base_y = ibox->p.y;\n\n    *scanlinesp = 0;\n    *indexp     = NULL;\n    *tablep     = NULL;\n\n    /* Step 1: Make us a table */\n    scanlines = ibox->q.y-base_y;\n    /* +1 simplifies the loop below */\n    index = (int *)gs_alloc_bytes(pdev->memory,\n                                  (scanlines+1) * sizeof(*index),\n                                  \"scanc index buffer\");\n    if (index == NULL)\n        return_error(gs_error_VMerror);\n\n    /* Step 1 continued: Blank the index */\n    memset(index, 0, (scanlines+1)*sizeof(int));\n\n    /* Step 1 continued: Run through the path, filling in the index */\n    for (psub = path->first_subpath; psub != 0;) {\n        const segment * restrict pseg = (const segment *)psub;\n        fixed          ey = pseg->pt.y + adjust;\n        fixed          iy = ey;\n        int            iey = fixed2int(iy) - base_y;\n\n        assert(pseg->type == s_start);\n\n        /* Allow for 2 extra intersections on the start scanline.\n         * This copes with the 'zero height rectangle' case. */\n        if (iey >= 0 && iey < scanlines)\n        {\n            index[iey] += 2;\n            if (iey+1 < scanlines)\n                index[iey+1] -= 2;\n        }\n\n        while ((pseg = pseg->next) != 0 &&\n               pseg->type != s_start\n            ) {\n            fixed sy = ey;\n            ey = pseg->pt.y + adjust;\n\n            switch (pseg->type) {\n                default:\n                case s_start: /* Should never happen */\n                case s_dash:  /* We should never be seeing a dash here */\n                    assert(\"This should never happen\" == NULL);\n                    break;\n                case s_curve: {\n                    const curve_segment *const restrict pcur = (const curve_segment *)pseg;\n                    fixed c1y = pcur->p1.y + adjust;\n                    fixed c2y = pcur->p2.y + adjust;\n                    fixed maxy = sy, miny = sy;\n                    int imaxy, iminy;\n                    if (miny > c1y)\n                        miny = c1y;\n                    if (miny > c2y)\n                        miny = c2y;\n                    if (miny > ey)\n                        miny = ey;\n                    if (maxy < c1y)\n                        maxy = c1y;\n                    if (maxy < c2y)\n                        maxy = c2y;\n                    if (maxy < ey)\n                        maxy = ey;\n#ifdef DEBUG_SCAN_CONVERTER\n                    if (debugging_scan_converter)\n                        dlprintf2(\"Curve (%x->%x) \", miny, maxy);\n#endif\n                    iminy = fixed2int(miny) - base_y;\n                    if (iminy < 0)\n                        iminy = 0;\n                    if (iminy < scanlines) {\n                        imaxy = fixed2int(maxy) - base_y;\n                        if (imaxy >= 0) {\n#ifdef DEBUG_SCAN_CONVERTER\n                            if (debugging_scan_converter)\n                                dlprintf1(\"+%x \", iminy);\n#endif\n                            index[iminy]+=3;\n                            if (imaxy < scanlines)\n#ifdef DEBUG_SCAN_CONVERTER\n                                if (debugging_scan_converter)\n                                    dlprintf1(\"-%x \", imaxy+1);\n#endif\n                                index[imaxy+1]-=3;\n                        }\n                    }\n#ifdef DEBUG_SCAN_CONVERTER\n                    if (debugging_scan_converter)\n                        dlprintf(\"\\n\");\n#endif\n                    break;\n                }\n                case s_gap:\n                case s_line:\n                case s_line_close: {\n                    fixed miny, maxy;\n                    int imaxy, iminy;\n                    if (sy == ey) {\n#ifdef DEBUG_SCAN_CONVERTER\n                        if (debugging_scan_converter)\n                            dlprintf(\"Line (Horiz)\\n\");\n#endif\n                        break;\n                    }\n                    if (sy < ey)\n                        miny = sy, maxy = ey;\n                    else\n                        miny = ey, maxy = sy;\n#ifdef DEBUG_SCAN_CONVERTER\n                    if (debugging_scan_converter)\n                        dlprintf2(\"Line (%x->%x) \", miny, maxy);\n#endif\n                    iminy = fixed2int(miny) - base_y;\n                    if (iminy < 0)\n                        iminy = 0;\n                    if (iminy < scanlines) {\n                        imaxy = fixed2int(maxy) - base_y;\n                        if (imaxy >= 0) {\n#ifdef DEBUG_SCAN_CONVERTER\n                            if (debugging_scan_converter)\n                                dlprintf1(\"+%x \", iminy);\n#endif\n                            index[iminy]++;\n                            if (imaxy < scanlines) {\n#ifdef DEBUG_SCAN_CONVERTER\n                                if (debugging_scan_converter)\n                                    dlprintf1(\"-%x \", imaxy+1);\n#endif\n                                index[imaxy+1]--;\n                            }\n                        }\n                    }\n#ifdef DEBUG_SCAN_CONVERTER\n                    if (debugging_scan_converter)\n                        dlprintf(\"\\n\");\n#endif\n                    break;\n                }\n            }\n        }\n\n        /* And close any segments that need it */\n        if (ey != iy) {\n            fixed miny, maxy;\n            int imaxy, iminy;\n            if (iy < ey)\n                miny = iy, maxy = ey;\n            else\n                miny = ey, maxy = iy;\n#ifdef DEBUG_SCAN_CONVERTER\n            if (debugging_scan_converter)\n                dlprintf2(\"Close (%x->%x) \", miny, maxy);\n#endif\n            iminy = fixed2int(miny) - base_y;\n            if (iminy < 0)\n                iminy = 0;\n            if (iminy < scanlines) {\n                imaxy = fixed2int(maxy) - base_y;\n                if (imaxy >= 0) {\n#ifdef DEBUG_SCAN_CONVERTER\n                    if (debugging_scan_converter)\n                        dlprintf1(\"+%x \", iminy);\n#endif\n                    index[iminy]++;\n                    if (imaxy < scanlines) {\n#ifdef DEBUG_SCAN_CONVERTER\n                        if (debugging_scan_converter)\n                            dlprintf1(\"-%x \", imaxy+1);\n#endif\n                        index[imaxy+1]--;\n                    }\n                }\n            }\n#ifdef DEBUG_SCAN_CONVERTER\n            if (debugging_scan_converter)\n                dlprintf(\"\\n\");\n#endif\n        }\n#ifdef DEBUG_SCAN_CONVERTER\n        if (debugging_scan_converter)\n            dlprintf(\"\\n\");\n#endif\n        psub = (const subpath *)pseg;\n    }\n\n    /* Step 1 continued: index now contains a list of deltas (how the\n     * number of intersects on line x differs from the number on line x-1).\n     * First convert them to be the real number of intersects on that line.\n     * Sum these values to get us the total nunber of intersects. Then\n     * convert the table to be a list of offsets into the real intersect\n     * buffer. */\n    offset = 0;\n    delta  = 0;\n    for (i=0; i < scanlines; i++) {\n        delta    += intersection_size*index[i];  /* delta = Num ints on this scanline. */\n        index[i]  = offset;                      /* Offset into table for this lines data. */\n        offset   += delta+1;                     /* Adjust offset for next line. */\n    }\n\n    /* End of step 1: index[i] = offset into table 2 for scanline i's\n     * intersection data. offset = Total number of int entries required for\n     * table. */\n\n    /* Step 2: Collect the real intersections */\n    table = (int *)gs_alloc_bytes(pdev->memory, offset * sizeof(*table),\n                                  \"scanc intersects buffer\");\n    if (table == NULL) {\n        gs_free_object(pdev->memory, table, \"scanc index buffer\");\n        return_error(gs_error_VMerror);\n    }\n\n    /* Step 2 continued: initialise table's data; each scanlines data starts\n     * with a count of the number of intersects so far, followed by a record\n     * of the intersect points on this scanline. */\n    for (i=0; i < scanlines; i++) {\n        table[index[i]] = 0;\n    }\n\n    *scanlinesp = scanlines;\n    *tablep     = table;\n    *indexp     = index;\n\n    return 0;\n}", "target": 2, "idx": 10113}
{"commit_id": "6709d4b7bc2e079241fdef15d1160581c5261c10", "project": "torvalds/linux", "func": "void nfc_llcp_mac_is_down(struct nfc_dev *dev)\n{\n\tstruct nfc_llcp_local *local;\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL)\n\t\treturn;\n\n\tlocal->remote_miu = LLCP_DEFAULT_MIU;\n\tlocal->remote_lto = LLCP_DEFAULT_LTO;\n\n\t/* Close and purge all existing sockets */\n\tnfc_llcp_socket_release(local, true, 0);\n\n\tnfc_llcp_local_put(local);\n}", "target": 1, "idx": 10114}
{"commit_id": "652dd12a858989b14eed4e84e453059cd3ba340e", "project": "GNOME/libxml2", "func": "xmlChar *\nxmlValidCtxtNormalizeAttributeValue(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\n\t     xmlNodePtr elem, const xmlChar *name, const xmlChar *value) {\n    xmlChar *ret;\n    xmlAttributePtr attrDecl = NULL;\n    int extsubset = 0;\n\n    if (doc == NULL) return(NULL);\n    if (elem == NULL) return(NULL);\n    if (name == NULL) return(NULL);\n    if (value == NULL) return(NULL);\n\n    if ((elem->ns != NULL) && (elem->ns->prefix != NULL)) {\n\txmlChar fn[50];\n\txmlChar *fullname;\n\n\tfullname = xmlBuildQName(elem->name, elem->ns->prefix, fn, 50);\n\tif (fullname == NULL)\n\t    return(NULL);\n\tattrDecl = xmlGetDtdAttrDesc(doc->intSubset, fullname, name);\n\tif ((attrDecl == NULL) && (doc->extSubset != NULL)) {\n\t    attrDecl = xmlGetDtdAttrDesc(doc->extSubset, fullname, name);\n\t    if (attrDecl != NULL)\n\t\textsubset = 1;\n\t}\n\tif ((fullname != fn) && (fullname != elem->name))\n\t    xmlFree(fullname);\n    }\n    if ((attrDecl == NULL) && (doc->intSubset != NULL))\n\tattrDecl = xmlGetDtdAttrDesc(doc->intSubset, elem->name, name);\n    if ((attrDecl == NULL) && (doc->extSubset != NULL)) {\n\tattrDecl = xmlGetDtdAttrDesc(doc->extSubset, elem->name, name);\n\tif (attrDecl != NULL)\n\t    extsubset = 1;\n    }\n\n    if (attrDecl == NULL)\n\treturn(NULL);\n    if (attrDecl->atype == XML_ATTRIBUTE_CDATA)\n\treturn(NULL);\n\n    ret = xmlStrdup(value);\n    if (ret == NULL)\n\treturn(NULL);\n    xmlValidNormalizeString(ret);\n    if ((doc->standalone) && (extsubset == 1) && (!xmlStrEqual(value, ret))) {\n\txmlErrValidNode(ctxt, elem, XML_DTD_NOT_STANDALONE,\n\"standalone: %s on %s value had to be normalized based on external subset declaration\\n\",\n\t       name, elem->name, NULL);\n\tctxt->valid = 0;\n    }\n    return(ret);\n}", "target": 2, "idx": 10115}
{"commit_id": "c518adafa39f37858697ac9309c6cf1805581446", "project": "torvalds/linux", "func": "static int\nvsock_stream_recvmsg(struct socket *sock, struct msghdr *msg, size_t len,\n\t\t     int flags)\n{\n\tstruct sock *sk;\n\tstruct vsock_sock *vsk;\n\tconst struct vsock_transport *transport;\n\tint err;\n\tsize_t target;\n\tssize_t copied;\n\tlong timeout;\n\tstruct vsock_transport_recv_notify_data recv_data;\n\n\tDEFINE_WAIT(wait);\n\n\tsk = sock->sk;\n\tvsk = vsock_sk(sk);\n\terr = 0;\n\n\tlock_sock(sk);\n\n\ttransport = vsk->transport;\n\n\tif (!transport || sk->sk_state != TCP_ESTABLISHED) {\n\t\t/* Recvmsg is supposed to return 0 if a peer performs an\n\t\t * orderly shutdown. Differentiate between that case and when a\n\t\t * peer has not connected or a local shutdown occured with the\n\t\t * SOCK_DONE flag.\n\t\t */\n\t\tif (sock_flag(sk, SOCK_DONE))\n\t\t\terr = 0;\n\t\telse\n\t\t\terr = -ENOTCONN;\n\n\t\tgoto out;\n\t}\n\n\tif (flags & MSG_OOB) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\t/* We don't check peer_shutdown flag here since peer may actually shut\n\t * down, but there can be data in the queue that a local socket can\n\t * receive.\n\t */\n\tif (sk->sk_shutdown & RCV_SHUTDOWN) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\t/* It is valid on Linux to pass in a zero-length receive buffer.  This\n\t * is not an error.  We may as well bail out now.\n\t */\n\tif (!len) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\t/* We must not copy less than target bytes into the user's buffer\n\t * before returning successfully, so we wait for the consume queue to\n\t * have that much data to consume before dequeueing.  Note that this\n\t * makes it impossible to handle cases where target is greater than the\n\t * queue size.\n\t */\n\ttarget = sock_rcvlowat(sk, flags & MSG_WAITALL, len);\n\tif (target >= transport->stream_rcvhiwat(vsk)) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\ttimeout = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n\tcopied = 0;\n\n\terr = transport->notify_recv_init(vsk, target, &recv_data);\n\tif (err < 0)\n\t\tgoto out;\n\n\n\twhile (1) {\n\t\ts64 ready;\n\n\t\tprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\t\tready = vsock_stream_has_data(vsk);\n\n\t\tif (ready == 0) {\n\t\t\tif (sk->sk_err != 0 ||\n\t\t\t    (sk->sk_shutdown & RCV_SHUTDOWN) ||\n\t\t\t    (vsk->peer_shutdown & SEND_SHUTDOWN)) {\n\t\t\t\tfinish_wait(sk_sleep(sk), &wait);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Don't wait for non-blocking sockets. */\n\t\t\tif (timeout == 0) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tfinish_wait(sk_sleep(sk), &wait);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\terr = transport->notify_recv_pre_block(\n\t\t\t\t\tvsk, target, &recv_data);\n\t\t\tif (err < 0) {\n\t\t\t\tfinish_wait(sk_sleep(sk), &wait);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trelease_sock(sk);\n\t\t\ttimeout = schedule_timeout(timeout);\n\t\t\tlock_sock(sk);\n\n\t\t\tif (signal_pending(current)) {\n\t\t\t\terr = sock_intr_errno(timeout);\n\t\t\t\tfinish_wait(sk_sleep(sk), &wait);\n\t\t\t\tbreak;\n\t\t\t} else if (timeout == 0) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tfinish_wait(sk_sleep(sk), &wait);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tssize_t read;\n\n\t\t\tfinish_wait(sk_sleep(sk), &wait);\n\n\t\t\tif (ready < 0) {\n\t\t\t\t/* Invalid queue pair content. XXX This should\n\t\t\t\t* be changed to a connection reset in a later\n\t\t\t\t* change.\n\t\t\t\t*/\n\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\terr = transport->notify_recv_pre_dequeue(\n\t\t\t\t\tvsk, target, &recv_data);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\n\t\t\tread = transport->stream_dequeue(\n\t\t\t\t\tvsk, msg,\n\t\t\t\t\tlen - copied, flags);\n\t\t\tif (read < 0) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcopied += read;\n\n\t\t\terr = transport->notify_recv_post_dequeue(\n\t\t\t\t\tvsk, target, read,\n\t\t\t\t\t!(flags & MSG_PEEK), &recv_data);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\n\t\t\tif (read >= target || flags & MSG_PEEK)\n\t\t\t\tbreak;\n\n\t\t\ttarget -= read;\n\t\t}\n\t}\n\n\tif (sk->sk_err)\n\t\terr = -sk->sk_err;\n\telse if (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\terr = 0;\n\n\tif (copied > 0)\n\t\terr = copied;\n\nout:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 2, "idx": 10116}
{"commit_id": "e7142a0703bc93f75e213e96ebc19000022afed9", "project": "android", "func": "status_t MPEG4Extractor::readMetaData() {\n    if (mInitCheck != NO_INIT) {\n        return mInitCheck;\n    }\n\n    off64_t offset = 0;\n    status_t err;\n    bool sawMoovOrSidx = false;\n\n    while (!(sawMoovOrSidx && (mMdatFound || mMoofFound))) {\n        off64_t orig_offset = offset;\n        err = parseChunk(&offset, 0);\n\n        if (err != OK && err != UNKNOWN_ERROR) {\n            break;\n        } else if (offset <= orig_offset) {\n            // only continue parsing if the offset was advanced,\n            // otherwise we might end up in an infinite loop\n            ALOGE(\"did not advance: %lld->%lld\", (long long)orig_offset, (long long)offset);\n            err = ERROR_MALFORMED;\n            break;\n        } else if (err == UNKNOWN_ERROR) {\n            sawMoovOrSidx = true;\n        }\n    }\n\n    if (mInitCheck == OK) {\n        if (mHasVideo) {\n            mFileMetaData->setCString(\n                    kKeyMIMEType, MEDIA_MIMETYPE_CONTAINER_MPEG4);\n        } else {\n            mFileMetaData->setCString(kKeyMIMEType, \"audio/mp4\");\n        }\n    } else {\n        mInitCheck = err;\n    }\n\n    CHECK_NE(err, (status_t)NO_INIT);\n\n    // copy pssh data into file metadata\n    uint64_t psshsize = 0;\n    for (size_t i = 0; i < mPssh.size(); i++) {\n        psshsize += 20 + mPssh[i].datalen;\n    }\n    if (psshsize > 0 && psshsize <= UINT32_MAX) {\n        char *buf = (char*)malloc(psshsize);\n        if (!buf) {\n            ALOGE(\"b/28471206\");\n            return NO_MEMORY;\n        }\n        char *ptr = buf;\n        for (size_t i = 0; i < mPssh.size(); i++) {\n            memcpy(ptr, mPssh[i].uuid, 20); // uuid + length\n            memcpy(ptr + 20, mPssh[i].data, mPssh[i].datalen);\n            ptr += (20 + mPssh[i].datalen);\n        }\n        mFileMetaData->setData(kKeyPssh, 'pssh', buf, psshsize);\n        free(buf);\n    }\n    return mInitCheck;\n}", "target": 2, "idx": 10117}
{"commit_id": "f57bd745b4cbed577ea654fad4701bea4d38b44c", "project": "moonlight-stream/moonlight-common-c", "func": "static int sendMessageEnet(short ptype, short paylen, const void* payload) {\n    PNVCTL_ENET_PACKET_HEADER packet;\n    ENetPacket* enetPacket;\n    ENetEvent event;\n    int err;\n\n    LC_ASSERT(AppVersionQuad[0] >= 5);\n    \n    // We may be trying to disconnect, so our peer could be gone.\n    // This check is safe because we're guaranteed to be holding enetMutex.\n    if (peer == NULL) {\n        return 0;\n    }\n\n    packet = malloc(sizeof(*packet) + paylen);\n    if (packet == NULL) {\n        return 0;\n    }\n\n    packet->type = ptype;\n    memcpy(&packet[1], payload, paylen);\n\n    // Gen 5+ servers do control protocol over ENet instead of TCP\n    while ((err = serviceEnetHost(client, &event, 0)) > 0) {\n        if (event.type == ENET_EVENT_TYPE_RECEIVE) {\n            enet_packet_destroy(event.packet);\n        }\n        else if (event.type == ENET_EVENT_TYPE_DISCONNECT) {\n            Limelog(\"Control stream received disconnect event\\n\");\n            free(packet);\n            return 0;\n        }\n    }\n    \n    if (err < 0) {\n        Limelog(\"Control stream connection failed\\n\");\n        return 0;\n    }\n\n    enetPacket = enet_packet_create(packet, sizeof(*packet) + paylen, ENET_PACKET_FLAG_RELIABLE);\n    if (packet == NULL) {\n        free(packet);\n        return 0;\n    }\n\n    if (enet_peer_send(peer, 0, enetPacket) < 0) {\n        Limelog(\"Failed to send ENet control packet\\n\");\n        enet_packet_destroy(enetPacket);\n        free(packet);\n        return 0;\n    }\n    \n    enet_host_flush(client);\n\n    free(packet);\n\n    return 1;\n}", "target": 2, "idx": 10118}
{"commit_id": "b348d7dddb6c4fbfc810b7a0626e8ec9e29f7cbb", "project": "torvalds/linux", "func": "int usbip_recv_xbuff(struct usbip_device *ud, struct urb *urb)\n{\n\tint ret;\n\tint size;\n\n\tif (ud->side == USBIP_STUB) {\n\t\t/* the direction of urb must be OUT. */\n\t\tif (usb_pipein(urb->pipe))\n\t\t\treturn 0;\n\n\t\tsize = urb->transfer_buffer_length;\n\t} else {\n\t\t/* the direction of urb must be IN. */\n\t\tif (usb_pipeout(urb->pipe))\n\t\t\treturn 0;\n\n\t\tsize = urb->actual_length;\n\t}\n\n\t/* no need to recv xbuff */\n\tif (!(size > 0))\n\t\treturn 0;\n\n\tif (size > urb->transfer_buffer_length) {\n\t\t/* should not happen, probably malicious packet */\n\t\tif (ud->side == USBIP_STUB) {\n\t\t\tusbip_event_add(ud, SDEV_EVENT_ERROR_TCP);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tusbip_event_add(ud, VDEV_EVENT_ERROR_TCP);\n\t\t\treturn -EPIPE;\n\t\t}\n\t}\n\n\tret = usbip_recv(ud->tcp_socket, urb->transfer_buffer, size);\n\tif (ret != size) {\n\t\tdev_err(&urb->dev->dev, \"recv xbuf, %d\\n\", ret);\n\t\tif (ud->side == USBIP_STUB) {\n\t\t\tusbip_event_add(ud, SDEV_EVENT_ERROR_TCP);\n\t\t} else {\n\t\t\tusbip_event_add(ud, VDEV_EVENT_ERROR_TCP);\n\t\t\treturn -EPIPE;\n\t\t}\n\t}\n\n\treturn ret;\n}", "target": 3, "idx": 10119}
{"commit_id": "cc080e9e9be16ccf26135d366d7d2b65209f1d56", "project": "torvalds/linux", "func": "int fuse_dev_release(struct inode *inode, struct file *file)\n{\n\tstruct fuse_dev *fud = fuse_get_dev(file);\n\n\tif (fud) {\n\t\tstruct fuse_conn *fc = fud->fc;\n\n\t\tWARN_ON(!list_empty(&fc->pq.io));\n\t\tWARN_ON(fc->iq.fasync != NULL);\n\t\tfuse_abort_conn(fc);\n\t\tfuse_dev_free(fud);\n\t}\n\n\treturn 0;\n}", "target": 1, "idx": 10120}
{"commit_id": "1e206baedf8bef0334cca3eb92bab134ef525a28", "project": "tensorflow", "func": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLiteDivParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  const TfLiteTensor* input1;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor1, &input1));\n  const TfLiteTensor* input2;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor2, &input2));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  // TODO(b/193904910): This can written with C++ templates\n#define TF_LITE_CHECK_DIV_NON_ZERO(data_type)                       \\\n  const auto* input2_data = GetTensorData<data_type>(input2);       \\\n  const size_t input2_elements = input2->bytes / sizeof(data_type); \\\n  for (size_t i = 0; i < input2_elements; i++) {                    \\\n    TF_LITE_ENSURE(context, input2_data[i] != 0);                   \\\n  }\n\n  if (output->type == kTfLiteFloat32) {\n    // Div by zero seems ok in this case, just like in TF case infinities are\n    // returned. So we don't do a check at this point.\n    EvalDiv<kernel_type>(context, node, params, data, input1, input2, output);\n  } else if (output->type == kTfLiteInt32) {\n    TF_LITE_CHECK_DIV_NON_ZERO(int32_t);\n    EvalDiv<kernel_type>(context, node, params, data, input1, input2, output);\n  } else if (output->type == kTfLiteUInt8) {\n    TF_LITE_CHECK_DIV_NON_ZERO(uint8_t);\n    TF_LITE_ENSURE_OK(\n        context, EvalQuantized<kernel_type>(context, node, params, data, input1,\n                                            input2, output));\n  } else {\n    context->ReportError(\n        context,\n        \"Div only supports FLOAT32, INT32 and quantized UINT8 now, got %d.\",\n        output->type);\n    return kTfLiteError;\n  }\n#undef TF_LITE_CHECK_DIV_NON_ZERO\n\n  return kTfLiteOk;\n}", "target": 1, "idx": 10121}
{"commit_id": "b534e304568585707c4a92422aeca25cf908ff02", "project": "the-tcpdump-group/tcpdump", "func": "u_int\njuniper_ggsn_print(netdissect_options *ndo,\n                   const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n        struct juniper_ggsn_header {\n            uint8_t svc_id;\n            uint8_t flags_len;\n            uint8_t proto;\n            uint8_t flags;\n            uint8_t vlan_id[2];\n            uint8_t res[2];\n        };\n        const struct juniper_ggsn_header *gh;\n\n        l2info.pictype = DLT_JUNIPER_GGSN;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n\n        p+=l2info.header_len;\n        gh = (struct juniper_ggsn_header *)&l2info.cookie;\n\n        ND_TCHECK(*gh);\n        if (ndo->ndo_eflag) {\n            ND_PRINT((ndo, \"proto %s (%u), vlan %u: \",\n                   tok2str(juniper_protocol_values,\"Unknown\",gh->proto),\n                   gh->proto,\n                   EXTRACT_16BITS(&gh->vlan_id[0])));\n        }\n\n        switch (gh->proto) {\n        case JUNIPER_PROTO_IPV4:\n            ip_print(ndo, p, l2info.length);\n            break;\n        case JUNIPER_PROTO_IPV6:\n            ip6_print(ndo, p, l2info.length);\n            break;\n        default:\n            if (!ndo->ndo_eflag)\n                ND_PRINT((ndo, \"unknown GGSN proto (%u)\", gh->proto));\n        }\n\n        return l2info.header_len;\n\ntrunc:\n\tND_PRINT((ndo, \"[|juniper_services]\"));\n\treturn l2info.header_len;\n}", "target": 3, "idx": 10122}
{"commit_id": "0adcb34c49bee5b19bd29b16a578c510c23597ea", "project": "libexpat", "func": "static enum XML_Error\nstoreAtts(XML_Parser parser, const ENCODING *enc, const char *attStr,\n          TAG_NAME *tagNamePtr, BINDING **bindingsPtr,\n          enum XML_Account account) {\n  DTD *const dtd = parser->m_dtd; /* save one level of indirection */\n  ELEMENT_TYPE *elementType;\n  int nDefaultAtts;\n  const XML_Char **appAtts; /* the attribute list for the application */\n  int attIndex = 0;\n  int prefixLen;\n  int i;\n  int n;\n  XML_Char *uri;\n  int nPrefixes = 0;\n  BINDING *binding;\n  const XML_Char *localPart;\n\n  /* lookup the element type name */\n  elementType\n      = (ELEMENT_TYPE *)lookup(parser, &dtd->elementTypes, tagNamePtr->str, 0);\n  if (! elementType) {\n    const XML_Char *name = poolCopyString(&dtd->pool, tagNamePtr->str);\n    if (! name)\n      return XML_ERROR_NO_MEMORY;\n    elementType = (ELEMENT_TYPE *)lookup(parser, &dtd->elementTypes, name,\n                                         sizeof(ELEMENT_TYPE));\n    if (! elementType)\n      return XML_ERROR_NO_MEMORY;\n    if (parser->m_ns && ! setElementTypePrefix(parser, elementType))\n      return XML_ERROR_NO_MEMORY;\n  }\n  nDefaultAtts = elementType->nDefaultAtts;\n\n  /* get the attributes from the tokenizer */\n  n = XmlGetAttributes(enc, attStr, parser->m_attsSize, parser->m_atts);\n  if (n + nDefaultAtts > parser->m_attsSize) {\n    int oldAttsSize = parser->m_attsSize;\n    ATTRIBUTE *temp;\n#ifdef XML_ATTR_INFO\n    XML_AttrInfo *temp2;\n#endif\n    parser->m_attsSize = n + nDefaultAtts + INIT_ATTS_SIZE;\n    temp = (ATTRIBUTE *)REALLOC(parser, (void *)parser->m_atts,\n                                parser->m_attsSize * sizeof(ATTRIBUTE));\n    if (temp == NULL) {\n      parser->m_attsSize = oldAttsSize;\n      return XML_ERROR_NO_MEMORY;\n    }\n    parser->m_atts = temp;\n#ifdef XML_ATTR_INFO\n    temp2 = (XML_AttrInfo *)REALLOC(parser, (void *)parser->m_attInfo,\n                                    parser->m_attsSize * sizeof(XML_AttrInfo));\n    if (temp2 == NULL) {\n      parser->m_attsSize = oldAttsSize;\n      return XML_ERROR_NO_MEMORY;\n    }\n    parser->m_attInfo = temp2;\n#endif\n    if (n > oldAttsSize)\n      XmlGetAttributes(enc, attStr, n, parser->m_atts);\n  }\n\n  appAtts = (const XML_Char **)parser->m_atts;\n  for (i = 0; i < n; i++) {\n    ATTRIBUTE *currAtt = &parser->m_atts[i];\n#ifdef XML_ATTR_INFO\n    XML_AttrInfo *currAttInfo = &parser->m_attInfo[i];\n#endif\n    /* add the name and value to the attribute list */\n    ATTRIBUTE_ID *attId\n        = getAttributeId(parser, enc, currAtt->name,\n                         currAtt->name + XmlNameLength(enc, currAtt->name));\n    if (! attId)\n      return XML_ERROR_NO_MEMORY;\n#ifdef XML_ATTR_INFO\n    currAttInfo->nameStart\n        = parser->m_parseEndByteIndex - (parser->m_parseEndPtr - currAtt->name);\n    currAttInfo->nameEnd\n        = currAttInfo->nameStart + XmlNameLength(enc, currAtt->name);\n    currAttInfo->valueStart = parser->m_parseEndByteIndex\n                              - (parser->m_parseEndPtr - currAtt->valuePtr);\n    currAttInfo->valueEnd = parser->m_parseEndByteIndex\n                            - (parser->m_parseEndPtr - currAtt->valueEnd);\n#endif\n    /* Detect duplicate attributes by their QNames. This does not work when\n       namespace processing is turned on and different prefixes for the same\n       namespace are used. For this case we have a check further down.\n    */\n    if ((attId->name)[-1]) {\n      if (enc == parser->m_encoding)\n        parser->m_eventPtr = parser->m_atts[i].name;\n      return XML_ERROR_DUPLICATE_ATTRIBUTE;\n    }\n    (attId->name)[-1] = 1;\n    appAtts[attIndex++] = attId->name;\n    if (! parser->m_atts[i].normalized) {\n      enum XML_Error result;\n      XML_Bool isCdata = XML_TRUE;\n\n      /* figure out whether declared as other than CDATA */\n      if (attId->maybeTokenized) {\n        int j;\n        for (j = 0; j < nDefaultAtts; j++) {\n          if (attId == elementType->defaultAtts[j].id) {\n            isCdata = elementType->defaultAtts[j].isCdata;\n            break;\n          }\n        }\n      }\n\n      /* normalize the attribute value */\n      result = storeAttributeValue(\n          parser, enc, isCdata, parser->m_atts[i].valuePtr,\n          parser->m_atts[i].valueEnd, &parser->m_tempPool, account);\n      if (result)\n        return result;\n      appAtts[attIndex] = poolStart(&parser->m_tempPool);\n      poolFinish(&parser->m_tempPool);\n    } else {\n      /* the value did not need normalizing */\n      appAtts[attIndex] = poolStoreString(&parser->m_tempPool, enc,\n                                          parser->m_atts[i].valuePtr,\n                                          parser->m_atts[i].valueEnd);\n      if (appAtts[attIndex] == 0)\n        return XML_ERROR_NO_MEMORY;\n      poolFinish(&parser->m_tempPool);\n    }\n    /* handle prefixed attribute names */\n    if (attId->prefix) {\n      if (attId->xmlns) {\n        /* deal with namespace declarations here */\n        enum XML_Error result = addBinding(parser, attId->prefix, attId,\n                                           appAtts[attIndex], bindingsPtr);\n        if (result)\n          return result;\n        --attIndex;\n      } else {\n        /* deal with other prefixed names later */\n        attIndex++;\n        nPrefixes++;\n        (attId->name)[-1] = 2;\n      }\n    } else\n      attIndex++;\n  }\n\n  /* set-up for XML_GetSpecifiedAttributeCount and XML_GetIdAttributeIndex */\n  parser->m_nSpecifiedAtts = attIndex;\n  if (elementType->idAtt && (elementType->idAtt->name)[-1]) {\n    for (i = 0; i < attIndex; i += 2)\n      if (appAtts[i] == elementType->idAtt->name) {\n        parser->m_idAttIndex = i;\n        break;\n      }\n  } else\n    parser->m_idAttIndex = -1;\n\n  /* do attribute defaulting */\n  for (i = 0; i < nDefaultAtts; i++) {\n    const DEFAULT_ATTRIBUTE *da = elementType->defaultAtts + i;\n    if (! (da->id->name)[-1] && da->value) {\n      if (da->id->prefix) {\n        if (da->id->xmlns) {\n          enum XML_Error result = addBinding(parser, da->id->prefix, da->id,\n                                             da->value, bindingsPtr);\n          if (result)\n            return result;\n        } else {\n          (da->id->name)[-1] = 2;\n          nPrefixes++;\n          appAtts[attIndex++] = da->id->name;\n          appAtts[attIndex++] = da->value;\n        }\n      } else {\n        (da->id->name)[-1] = 1;\n        appAtts[attIndex++] = da->id->name;\n        appAtts[attIndex++] = da->value;\n      }\n    }\n  }\n  appAtts[attIndex] = 0;\n\n  /* expand prefixed attribute names, check for duplicates,\n     and clear flags that say whether attributes were specified */\n  i = 0;\n  if (nPrefixes) {\n    int j; /* hash table index */\n    unsigned long version = parser->m_nsAttsVersion;\n\n    /* Detect and prevent invalid shift */\n    if (parser->m_nsAttsPower >= sizeof(unsigned int) * 8 /* bits per byte */) {\n      return XML_ERROR_NO_MEMORY;\n    }\n\n    unsigned int nsAttsSize = 1u << parser->m_nsAttsPower;\n    unsigned char oldNsAttsPower = parser->m_nsAttsPower;\n    /* size of hash table must be at least 2 * (# of prefixed attributes) */\n    if ((nPrefixes << 1)\n        >> parser->m_nsAttsPower) { /* true for m_nsAttsPower = 0 */\n      NS_ATT *temp;\n      /* hash table size must also be a power of 2 and >= 8 */\n      while (nPrefixes >> parser->m_nsAttsPower++)\n        ;\n      if (parser->m_nsAttsPower < 3)\n        parser->m_nsAttsPower = 3;\n\n      /* Detect and prevent invalid shift */\n      if (parser->m_nsAttsPower >= sizeof(nsAttsSize) * 8 /* bits per byte */) {\n        /* Restore actual size of memory in m_nsAtts */\n        parser->m_nsAttsPower = oldNsAttsPower;\n        return XML_ERROR_NO_MEMORY;\n      }\n\n      nsAttsSize = 1u << parser->m_nsAttsPower;\n\n      /* Detect and prevent integer overflow.\n       * The preprocessor guard addresses the \"always false\" warning\n       * from -Wtype-limits on platforms where\n       * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#if UINT_MAX >= SIZE_MAX\n      if (nsAttsSize > (size_t)(-1) / sizeof(NS_ATT)) {\n        /* Restore actual size of memory in m_nsAtts */\n        parser->m_nsAttsPower = oldNsAttsPower;\n        return XML_ERROR_NO_MEMORY;\n      }\n#endif\n\n      temp = (NS_ATT *)REALLOC(parser, parser->m_nsAtts,\n                               nsAttsSize * sizeof(NS_ATT));\n      if (! temp) {\n        /* Restore actual size of memory in m_nsAtts */\n        parser->m_nsAttsPower = oldNsAttsPower;\n        return XML_ERROR_NO_MEMORY;\n      }\n      parser->m_nsAtts = temp;\n      version = 0; /* force re-initialization of m_nsAtts hash table */\n    }\n    /* using a version flag saves us from initializing m_nsAtts every time */\n    if (! version) { /* initialize version flags when version wraps around */\n      version = INIT_ATTS_VERSION;\n      for (j = nsAttsSize; j != 0;)\n        parser->m_nsAtts[--j].version = version;\n    }\n    parser->m_nsAttsVersion = --version;\n\n    /* expand prefixed names and check for duplicates */\n    for (; i < attIndex; i += 2) {\n      const XML_Char *s = appAtts[i];\n      if (s[-1] == 2) { /* prefixed */\n        ATTRIBUTE_ID *id;\n        const BINDING *b;\n        unsigned long uriHash;\n        struct siphash sip_state;\n        struct sipkey sip_key;\n\n        copy_salt_to_sipkey(parser, &sip_key);\n        sip24_init(&sip_state, &sip_key);\n\n        ((XML_Char *)s)[-1] = 0; /* clear flag */\n        id = (ATTRIBUTE_ID *)lookup(parser, &dtd->attributeIds, s, 0);\n        if (! id || ! id->prefix) {\n          /* This code is walking through the appAtts array, dealing\n           * with (in this case) a prefixed attribute name.  To be in\n           * the array, the attribute must have already been bound, so\n           * has to have passed through the hash table lookup once\n           * already.  That implies that an entry for it already\n           * exists, so the lookup above will return a pointer to\n           * already allocated memory.  There is no opportunaity for\n           * the allocator to fail, so the condition above cannot be\n           * fulfilled.\n           *\n           * Since it is difficult to be certain that the above\n           * analysis is complete, we retain the test and merely\n           * remove the code from coverage tests.\n           */\n          return XML_ERROR_NO_MEMORY; /* LCOV_EXCL_LINE */\n        }\n        b = id->prefix->binding;\n        if (! b)\n          return XML_ERROR_UNBOUND_PREFIX;\n\n        for (j = 0; j < b->uriLen; j++) {\n          const XML_Char c = b->uri[j];\n          if (! poolAppendChar(&parser->m_tempPool, c))\n            return XML_ERROR_NO_MEMORY;\n        }\n\n        sip24_update(&sip_state, b->uri, b->uriLen * sizeof(XML_Char));\n\n        while (*s++ != XML_T(ASCII_COLON))\n          ;\n\n        sip24_update(&sip_state, s, keylen(s) * sizeof(XML_Char));\n\n        do { /* copies null terminator */\n          if (! poolAppendChar(&parser->m_tempPool, *s))\n            return XML_ERROR_NO_MEMORY;\n        } while (*s++);\n\n        uriHash = (unsigned long)sip24_final(&sip_state);\n\n        { /* Check hash table for duplicate of expanded name (uriName).\n             Derived from code in lookup(parser, HASH_TABLE *table, ...).\n          */\n          unsigned char step = 0;\n          unsigned long mask = nsAttsSize - 1;\n          j = uriHash & mask; /* index into hash table */\n          while (parser->m_nsAtts[j].version == version) {\n            /* for speed we compare stored hash values first */\n            if (uriHash == parser->m_nsAtts[j].hash) {\n              const XML_Char *s1 = poolStart(&parser->m_tempPool);\n              const XML_Char *s2 = parser->m_nsAtts[j].uriName;\n              /* s1 is null terminated, but not s2 */\n              for (; *s1 == *s2 && *s1 != 0; s1++, s2++)\n                ;\n              if (*s1 == 0)\n                return XML_ERROR_DUPLICATE_ATTRIBUTE;\n            }\n            if (! step)\n              step = PROBE_STEP(uriHash, mask, parser->m_nsAttsPower);\n            j < step ? (j += nsAttsSize - step) : (j -= step);\n          }\n        }\n\n        if (parser->m_ns_triplets) { /* append namespace separator and prefix */\n          parser->m_tempPool.ptr[-1] = parser->m_namespaceSeparator;\n          s = b->prefix->name;\n          do {\n            if (! poolAppendChar(&parser->m_tempPool, *s))\n              return XML_ERROR_NO_MEMORY;\n          } while (*s++);\n        }\n\n        /* store expanded name in attribute list */\n        s = poolStart(&parser->m_tempPool);\n        poolFinish(&parser->m_tempPool);\n        appAtts[i] = s;\n\n        /* fill empty slot with new version, uriName and hash value */\n        parser->m_nsAtts[j].version = version;\n        parser->m_nsAtts[j].hash = uriHash;\n        parser->m_nsAtts[j].uriName = s;\n\n        if (! --nPrefixes) {\n          i += 2;\n          break;\n        }\n      } else                     /* not prefixed */\n        ((XML_Char *)s)[-1] = 0; /* clear flag */\n    }\n  }\n  /* clear flags for the remaining attributes */\n  for (; i < attIndex; i += 2)\n    ((XML_Char *)(appAtts[i]))[-1] = 0;\n  for (binding = *bindingsPtr; binding; binding = binding->nextTagBinding)\n    binding->attId->name[-1] = 0;\n\n  if (! parser->m_ns)\n    return XML_ERROR_NONE;\n\n  /* expand the element type name */\n  if (elementType->prefix) {\n    binding = elementType->prefix->binding;\n    if (! binding)\n      return XML_ERROR_UNBOUND_PREFIX;\n    localPart = tagNamePtr->str;\n    while (*localPart++ != XML_T(ASCII_COLON))\n      ;\n  } else if (dtd->defaultPrefix.binding) {\n    binding = dtd->defaultPrefix.binding;\n    localPart = tagNamePtr->str;\n  } else\n    return XML_ERROR_NONE;\n  prefixLen = 0;\n  if (parser->m_ns_triplets && binding->prefix->name) {\n    for (; binding->prefix->name[prefixLen++];)\n      ; /* prefixLen includes null terminator */\n  }\n  tagNamePtr->localPart = localPart;\n  tagNamePtr->uriLen = binding->uriLen;\n  tagNamePtr->prefix = binding->prefix->name;\n  tagNamePtr->prefixLen = prefixLen;\n  for (i = 0; localPart[i++];)\n    ; /* i includes null terminator */\n  n = i + binding->uriLen + prefixLen;\n  if (n > binding->uriAlloc) {\n    TAG *p;\n    uri = (XML_Char *)MALLOC(parser, (n + EXPAND_SPARE) * sizeof(XML_Char));\n    if (! uri)\n      return XML_ERROR_NO_MEMORY;\n    binding->uriAlloc = n + EXPAND_SPARE;\n    memcpy(uri, binding->uri, binding->uriLen * sizeof(XML_Char));\n    for (p = parser->m_tagStack; p; p = p->parent)\n      if (p->name.str == binding->uri)\n        p->name.str = uri;\n    FREE(parser, binding->uri);\n    binding->uri = uri;\n  }\n  /* if m_namespaceSeparator != '\\0' then uri includes it already */\n  uri = binding->uri + binding->uriLen;\n  memcpy(uri, localPart, i * sizeof(XML_Char));\n  /* we always have a namespace separator between localPart and prefix */\n  if (prefixLen) {\n    uri += i - 1;\n    *uri = parser->m_namespaceSeparator; /* replace null terminator */\n    memcpy(uri + 1, binding->prefix->name, prefixLen * sizeof(XML_Char));\n  }\n  tagNamePtr->str = binding->uri;\n  return XML_ERROR_NONE;\n}", "target": 2, "idx": 10123}
{"commit_id": "0330f6bf32e20c18cadf578daada42a343540340", "project": "Exiv2/exiv2", "func": "DataBuf LoaderTiff::getData() const\n    {\n        const ExifData &exifData = image_.exifData();\n\n        ExifData preview;\n\n        // copy tags\n        for (ExifData::const_iterator pos = exifData.begin(); pos != exifData.end(); ++pos) {\n            if (pos->groupName() == group_) {\n                /*\n                   Write only the necessary TIFF image tags\n                   tags that especially could cause problems are:\n                   \"NewSubfileType\" - the result is no longer a thumbnail, it is a standalone image\n                   \"Orientation\" - this tag typically appears only in the \"Image\" group. Deleting it ensures\n                                   consistent result for all previews, including JPEG\n                */\n                uint16_t tag = pos->tag();\n                if (tag != 0x00fe && tag != 0x00ff && Internal::isTiffImageTag(tag, Internal::ifd0Id)) {\n                    preview.add(ExifKey(tag, \"Image\"), &pos->value());\n                }\n            }\n        }\n\n        Value &dataValue = const_cast<Value&>(preview[\"Exif.Image.\" + offsetTag_].value());\n\n        if (dataValue.sizeDataArea() == 0) {\n            // image data are not available via exifData, read them from image_.io()\n            BasicIo &io = image_.io();\n\n            if (io.open() != 0) {\n                throw Error(kerDataSourceOpenFailed, io.path(), strError());\n            }\n            IoCloser closer(io);\n\n            const Exiv2::byte* base = io.mmap();\n\n            const Value &sizes = preview[\"Exif.Image.\" + sizeTag_].value();\n\n            if (sizes.count() == dataValue.count()) {\n                if (sizes.count() == 1) {\n                    // this saves one copying of the buffer\n                    uint32_t offset = dataValue.toLong(0);\n                    uint32_t size = sizes.toLong(0);\n                    if (offset + size <= static_cast<uint32_t>(io.size()))\n                        dataValue.setDataArea(base + offset, size);\n                }\n                else {\n                    // FIXME: the buffer is probably copied twice, it should be optimized\n                    DataBuf buf(size_);\n                    uint32_t idxBuf = 0;\n                    for (int i = 0; i < sizes.count(); i++) {\n                        uint32_t offset = dataValue.toLong(i);\n                        uint32_t size = sizes.toLong(i);\n                        if (size!=0 && offset + size <= static_cast<uint32_t>(io.size()))\n                            memcpy(&buf.pData_[idxBuf], base + offset, size);\n                        idxBuf += size;\n                    }\n                    dataValue.setDataArea(buf.pData_, buf.size_);\n                }\n            }\n        }\n\n        // Fix compression value in the CR2 IFD2 image\n        if (0 == strcmp(group_, \"Image2\") && image_.mimeType() == \"image/x-canon-cr2\") {\n            preview[\"Exif.Image.Compression\"] = uint16_t(1);\n        }\n\n        // write new image\n        MemIo mio;\n        IptcData emptyIptc;\n        XmpData  emptyXmp;\n        TiffParser::encode(mio, 0, 0, Exiv2::littleEndian, preview, emptyIptc, emptyXmp);\n        return DataBuf(mio.mmap(), (long) mio.size());\n    }", "target": 3, "idx": 10124}
{"commit_id": "2c8973c39478cd3c8cf11d9f27cc0556a106d006", "project": "android", "func": "Status AudioPolicyService::startInput(int32_t portIdAidl)\n{\n    audio_port_handle_t portId = VALUE_OR_RETURN_BINDER_STATUS(\n            aidl2legacy_int32_t_audio_port_handle_t(portIdAidl));\n\n    if (mAudioPolicyManager == NULL) {\n        return binderStatusFromStatusT(NO_INIT);\n    }\n    sp<AudioRecordClient> client;\n    {\n        Mutex::Autolock _l(mLock);\n\n        ssize_t index = mAudioRecordClients.indexOfKey(portId);\n        if (index < 0) {\n            return binderStatusFromStatusT(INVALID_OPERATION);\n        }\n        client = mAudioRecordClients.valueAt(index);\n    }\n\n    std::stringstream msg;\n    msg << \"Audio recording on session \" << client->session;\n\n    // check calling permissions\n    if (!(startRecording(client->attributionSource, String16(msg.str().c_str()),\n                         client->attributes.source)\n            || client->attributes.source == AUDIO_SOURCE_FM_TUNER\n            || client->attributes.source == AUDIO_SOURCE_REMOTE_SUBMIX\n            || client->attributes.source == AUDIO_SOURCE_ECHO_REFERENCE)) {\n        ALOGE(\"%s permission denied: recording not allowed for attribution source %s\",\n                __func__, client->attributionSource.toString().c_str());\n        return binderStatusFromStatusT(PERMISSION_DENIED);\n    }\n\n    Mutex::Autolock _l(mLock);\n\n    ALOGW_IF(client->silenced, \"startInput on silenced input for port %d, uid %d. Unsilencing.\",\n            portIdAidl,\n            client->attributionSource.uid);\n\n    if (client->active) {\n        ALOGE(\"Client should never be active before startInput. Uid %d port %d\",\n                client->attributionSource.uid, portId);\n        finishRecording(client->attributionSource, client->attributes.source);\n        return binderStatusFromStatusT(INVALID_OPERATION);\n    }\n\n    // Force the possibly silenced client to be unsilenced since we just called\n    // startRecording (i.e. we have assumed it is unsilenced).\n    // At this point in time, the client is inactive, so no calls to appops are sent in\n    // setAppState_l.\n    // This ensures existing clients have the same behavior as new clients (starting unsilenced).\n    // TODO(b/282076713)\n    setAppState_l(client, APP_STATE_TOP);\n\n    client->active = true;\n    client->startTimeNs = systemTime();\n    // This call updates the silenced state, and since we are active, appropriately notifies appops\n    // if we silence the track.\n    updateUidStates_l();\n\n    status_t status;\n    {\n        AutoCallerClear acc;\n        status = mAudioPolicyManager->startInput(portId);\n\n    }\n\n    // including successes gets very verbose\n    // but once we cut over to statsd, log them all.\n    if (status != NO_ERROR) {\n\n        static constexpr char kAudioPolicy[] = \"audiopolicy\";\n\n        static constexpr char kAudioPolicyStatus[] = \"android.media.audiopolicy.status\";\n        static constexpr char kAudioPolicyRqstSrc[] = \"android.media.audiopolicy.rqst.src\";\n        static constexpr char kAudioPolicyRqstPkg[] = \"android.media.audiopolicy.rqst.pkg\";\n        static constexpr char kAudioPolicyRqstSession[] = \"android.media.audiopolicy.rqst.session\";\n        static constexpr char kAudioPolicyRqstDevice[] =\n                \"android.media.audiopolicy.rqst.device\";\n        static constexpr char kAudioPolicyActiveSrc[] = \"android.media.audiopolicy.active.src\";\n        static constexpr char kAudioPolicyActivePkg[] = \"android.media.audiopolicy.active.pkg\";\n        static constexpr char kAudioPolicyActiveSession[] =\n                \"android.media.audiopolicy.active.session\";\n        static constexpr char kAudioPolicyActiveDevice[] =\n                \"android.media.audiopolicy.active.device\";\n\n        mediametrics::Item *item = mediametrics::Item::create(kAudioPolicy);\n        if (item != NULL) {\n\n            item->setInt32(kAudioPolicyStatus, status);\n\n            item->setCString(kAudioPolicyRqstSrc,\n                             toString(client->attributes.source).c_str());\n            item->setInt32(kAudioPolicyRqstSession, client->session);\n            if (client->attributionSource.packageName.has_value() &&\n                client->attributionSource.packageName.value().size() != 0) {\n                item->setCString(kAudioPolicyRqstPkg,\n                    client->attributionSource.packageName.value().c_str());\n            } else {\n                item->setCString(kAudioPolicyRqstPkg,\n                    std::to_string(client->attributionSource.uid).c_str());\n            }\n            item->setCString(\n                    kAudioPolicyRqstDevice, getDeviceTypeStrForPortId(client->deviceId).c_str());\n\n            int count = mAudioRecordClients.size();\n            for (int i = 0; i < count ; i++) {\n                if (portId == mAudioRecordClients.keyAt(i)) {\n                    continue;\n                }\n                sp<AudioRecordClient> other = mAudioRecordClients.valueAt(i);\n                if (other->active) {\n                    // keeps the last of the clients marked active\n                    item->setCString(kAudioPolicyActiveSrc,\n                                     toString(other->attributes.source).c_str());\n                    item->setInt32(kAudioPolicyActiveSession, other->session);\n                    if (other->attributionSource.packageName.has_value() &&\n                        other->attributionSource.packageName.value().size() != 0) {\n                        item->setCString(kAudioPolicyActivePkg,\n                            other->attributionSource.packageName.value().c_str());\n                    } else {\n                        item->setCString(kAudioPolicyRqstPkg, std::to_string(\n                            other->attributionSource.uid).c_str());\n                    }\n                    item->setCString(kAudioPolicyActiveDevice,\n                                     getDeviceTypeStrForPortId(other->deviceId).c_str());\n                }\n            }\n            item->selfrecord();\n            delete item;\n            item = NULL;\n        }\n    }\n\n    if (status != NO_ERROR) {\n        client->active = false;\n        client->startTimeNs = 0;\n        updateUidStates_l();\n        finishRecording(client->attributionSource, client->attributes.source);\n    }\n\n    return binderStatusFromStatusT(status);\n}", "target": 0, "idx": 10125}
{"commit_id": "7fafcfdf6377b18b2a726ea554d6e593ba44349f", "project": "torvalds/linux", "func": "static inline void free_ep_req(struct usb_ep *ep, struct usb_request *req)\n{\n\tWARN_ON(req->buf == NULL);\n\tkfree(req->buf);\n\treq->buf = NULL;\n\tusb_ep_free_request(ep, req);\n}", "target": 3, "idx": 10126}
{"commit_id": "6709d4b7bc2e079241fdef15d1160581c5261c10", "project": "torvalds/linux", "func": "static int nfc_genl_llc_sdreq(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tstruct nfc_llcp_local *local;\n\tstruct nlattr *attr, *sdp_attrs[NFC_SDP_ATTR_MAX+1];\n\tu32 idx;\n\tu8 tid;\n\tchar *uri;\n\tint rc = 0, rem;\n\tsize_t uri_len, tlvs_len;\n\tstruct hlist_head sdreq_list;\n\tstruct nfc_llcp_sdp_tlv *sdreq;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_LLC_SDP])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tdevice_lock(&dev->dev);\n\n\tif (dev->dep_link_up == false) {\n\t\trc = -ENOLINK;\n\t\tgoto exit;\n\t}\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (!local) {\n\t\trc = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tINIT_HLIST_HEAD(&sdreq_list);\n\n\ttlvs_len = 0;\n\n\tnla_for_each_nested(attr, info->attrs[NFC_ATTR_LLC_SDP], rem) {\n\t\trc = nla_parse_nested_deprecated(sdp_attrs, NFC_SDP_ATTR_MAX,\n\t\t\t\t\t\t attr, nfc_sdp_genl_policy,\n\t\t\t\t\t\t info->extack);\n\n\t\tif (rc != 0) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto put_local;\n\t\t}\n\n\t\tif (!sdp_attrs[NFC_SDP_ATTR_URI])\n\t\t\tcontinue;\n\n\t\turi_len = nla_len(sdp_attrs[NFC_SDP_ATTR_URI]);\n\t\tif (uri_len == 0)\n\t\t\tcontinue;\n\n\t\turi = nla_data(sdp_attrs[NFC_SDP_ATTR_URI]);\n\t\tif (uri == NULL || *uri == 0)\n\t\t\tcontinue;\n\n\t\ttid = local->sdreq_next_tid++;\n\n\t\tsdreq = nfc_llcp_build_sdreq_tlv(tid, uri, uri_len);\n\t\tif (sdreq == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto put_local;\n\t\t}\n\n\t\ttlvs_len += sdreq->tlv_len;\n\n\t\thlist_add_head(&sdreq->node, &sdreq_list);\n\t}\n\n\tif (hlist_empty(&sdreq_list)) {\n\t\trc = -EINVAL;\n\t\tgoto put_local;\n\t}\n\n\trc = nfc_llcp_send_snl_sdreq(local, &sdreq_list, tlvs_len);\n\nput_local:\n\tnfc_llcp_local_put(local);\n\nexit:\n\tdevice_unlock(&dev->dev);\n\n\tnfc_put_device(dev);\n\n\treturn rc;\n}", "target": 1, "idx": 10127}
{"commit_id": "e49d943e9f5f90411313e64d0ae6b646edc85043", "project": "chromium", "func": "static void handleMetaReferrer(const String& attributeValue, CachedDocumentParameters* documentParameters, CSSPreloadScanner* cssScanner)\n{\n    ReferrerPolicy metaReferrerPolicy = ReferrerPolicyDefault;\n    if (!attributeValue.isEmpty() && !attributeValue.isNull() && SecurityPolicy::referrerPolicyFromString(attributeValue, &metaReferrerPolicy)) {\n        documentParameters->referrerPolicy = metaReferrerPolicy;\n    }\n    cssScanner->setReferrerPolicy(documentParameters->referrerPolicy);\n}", "target": 1, "idx": 10128}
{"commit_id": "65756b4082cd79a2d99b2ccb5b392291fd53703f", "project": "android", "func": "void SoftAMR::onQueueFilled(OMX_U32 /* portIndex */) {\n    List<BufferInfo *> &inQueue = getPortQueue(0);\n    List<BufferInfo *> &outQueue = getPortQueue(1);\n\n    if (mSignalledError || mOutputPortSettingsChange != NONE) {\n        return;\n    }\n\n    while (!inQueue.empty() && !outQueue.empty()) {\n        BufferInfo *inInfo = *inQueue.begin();\n        OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;\n\n        if (inHeader->nFilledLen == 0) {\n            inInfo->mOwnedByUs = false;\n            inQueue.erase(inQueue.begin());\n            notifyEmptyBufferDone(inHeader);\n            continue;\n        }\n\n        BufferInfo *outInfo = *outQueue.begin();\n        OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;\n\n        if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n            inQueue.erase(inQueue.begin());\n            inInfo->mOwnedByUs = false;\n            notifyEmptyBufferDone(inHeader);\n\n            outHeader->nFilledLen = 0;\n            outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n\n            outQueue.erase(outQueue.begin());\n            outInfo->mOwnedByUs = false;\n            notifyFillBufferDone(outHeader);\n            return;\n        }\n\n        if (inHeader->nOffset == 0) {\n            mAnchorTimeUs = inHeader->nTimeStamp;\n            mNumSamplesOutput = 0;\n        }\n\n        const uint8_t *inputPtr = inHeader->pBuffer + inHeader->nOffset;\n        int32_t numBytesRead;\n\n        if (mMode == MODE_NARROW) {\n            if (outHeader->nAllocLen < kNumSamplesPerFrameNB * sizeof(int16_t)) {\n                ALOGE(\"b/27662364: NB expected output buffer %zu bytes vs %u\",\n                       kNumSamplesPerFrameNB * sizeof(int16_t), outHeader->nAllocLen);\n                android_errorWriteLog(0x534e4554, \"27662364\");\n                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);\n                mSignalledError = true;\n                return;\n            }\n\n            int16 mode = ((inputPtr[0] >> 3) & 0x0f);\n            // for WMF since MIME_IETF is used when calling AMRDecode.\n            size_t frameSize = WmfDecBytesPerFrame[mode] + 1;\n\n            if (inHeader->nFilledLen < frameSize) {\n                ALOGE(\"b/27662364: expected %zu bytes vs %u\", frameSize, inHeader->nFilledLen);\n                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);\n                mSignalledError = true;\n                return;\n            }\n\n            numBytesRead =\n                AMRDecode(mState,\n                  (Frame_Type_3GPP)((inputPtr[0] >> 3) & 0x0f),\n                  (UWord8 *)&inputPtr[1],\n                  reinterpret_cast<int16_t *>(outHeader->pBuffer),\n                  MIME_IETF);\n\n            if (numBytesRead == -1) {\n                ALOGE(\"PV AMR decoder AMRDecode() call failed\");\n\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n\n                return;\n            }\n\n            ++numBytesRead;  // Include the frame type header byte.\n\n            if (static_cast<size_t>(numBytesRead) > inHeader->nFilledLen) {\n                // This is bad, should never have happened, but did. Abort now.\n\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n\n                return;\n            }\n        } else {\n            if (outHeader->nAllocLen < kNumSamplesPerFrameWB * sizeof(int16_t)) {\n                ALOGE(\"b/27662364: WB expected output buffer %zu bytes vs %u\",\n                       kNumSamplesPerFrameWB * sizeof(int16_t), outHeader->nAllocLen);\n                android_errorWriteLog(0x534e4554, \"27662364\");\n                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);\n                mSignalledError = true;\n                return;\n            }\n\n            int16 mode = ((inputPtr[0] >> 3) & 0x0f);\n\n            if (mode >= 10 && mode <= 13) {\n                ALOGE(\"encountered illegal frame type %d in AMR WB content.\",\n                      mode);\n\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n\n                return;\n            }\n\n            size_t frameSize = getFrameSize(mode);\n            if (inHeader->nFilledLen < frameSize) {\n                ALOGE(\"b/27662364: expected %zu bytes vs %u\", frameSize, inHeader->nFilledLen);\n                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);\n                mSignalledError = true;\n                return;\n            }\n\n            int16_t *outPtr = (int16_t *)outHeader->pBuffer;\n\n            if (mode >= 9) {\n                // Produce silence instead of comfort noise and for\n                // speech lost/no data.\n                memset(outPtr, 0, kNumSamplesPerFrameWB * sizeof(int16_t));\n            } else if (mode < 9) {\n                int16 frameType;\n                RX_State_wb rx_state;\n                mime_unsorting(\n                        const_cast<uint8_t *>(&inputPtr[1]),\n                        mInputSampleBuffer,\n                        &frameType, &mode, 1, &rx_state);\n\n                int16_t numSamplesOutput;\n                pvDecoder_AmrWb(\n                        mode, mInputSampleBuffer,\n                        outPtr,\n                        &numSamplesOutput,\n                        mDecoderBuf, frameType, mDecoderCookie);\n\n                CHECK_EQ((int)numSamplesOutput, (int)kNumSamplesPerFrameWB);\n\n                for (int i = 0; i < kNumSamplesPerFrameWB; ++i) {\n                    /* Delete the 2 LSBs (14-bit output) */\n                    outPtr[i] &= 0xfffC;\n                }\n            }\n\n            numBytesRead = frameSize;\n        }\n\n        inHeader->nOffset += numBytesRead;\n        inHeader->nFilledLen -= numBytesRead;\n\n        outHeader->nFlags = 0;\n        outHeader->nOffset = 0;\n\n        if (mMode == MODE_NARROW) {\n            outHeader->nFilledLen = kNumSamplesPerFrameNB * sizeof(int16_t);\n\n            outHeader->nTimeStamp =\n                mAnchorTimeUs\n                    + (mNumSamplesOutput * 1000000ll) / kSampleRateNB;\n\n            mNumSamplesOutput += kNumSamplesPerFrameNB;\n        } else {\n            outHeader->nFilledLen = kNumSamplesPerFrameWB * sizeof(int16_t);\n\n            outHeader->nTimeStamp =\n                mAnchorTimeUs\n                    + (mNumSamplesOutput * 1000000ll) / kSampleRateWB;\n\n            mNumSamplesOutput += kNumSamplesPerFrameWB;\n        }\n\n        if (inHeader->nFilledLen == 0) {\n            inInfo->mOwnedByUs = false;\n            inQueue.erase(inQueue.begin());\n            inInfo = NULL;\n            notifyEmptyBufferDone(inHeader);\n            inHeader = NULL;\n        }\n\n        outInfo->mOwnedByUs = false;\n        outQueue.erase(outQueue.begin());\n        outInfo = NULL;\n        notifyFillBufferDone(outHeader);\n        outHeader = NULL;\n\n        ++mInputBufferCount;\n    }\n}", "target": 2, "idx": 10129}
{"commit_id": "8d3e9104ea10f8b53a0b5a2a806e6388acd41a40", "project": "podofo", "func": "PdfObject* PdfDictionary::findKeyParent(const string_view& key) const\n{\n    utls::RecursionGuard guard;\n    auto obj = findKey(key);\n    if (obj == nullptr)\n    {\n        auto parent = findKey(\"Parent\");\n        if (parent == nullptr || parent->GetIndirectReference() == GetOwner()->GetIndirectReference())\n        {\n            return nullptr;\n        }\n        else\n        {\n            PdfDictionary* parentDict;\n            if (parent->TryGetDictionary(parentDict))\n                return parentDict->findKeyParent(key);\n            else\n                return nullptr;\n        }\n    }\n    else\n    {\n        return obj;\n    }\n}", "target": 1, "idx": 10130}
{"commit_id": "e99502f76271d6bc4e374fe368c50c67a1fd3070", "project": "torvalds/linux", "func": "static void xen_free_irq(unsigned irq)\n{\n\tstruct irq_info *info = info_for_irq(irq);\n\tunsigned long flags;\n\n\tif (WARN_ON(!info))\n\t\treturn;\n\n\twrite_lock_irqsave(&evtchn_rwlock, flags);\n\n\tif (!list_empty(&info->eoi_list))\n\t\tlateeoi_list_del(info);\n\n\tlist_del(&info->list);\n\n\tset_info_for_irq(irq, NULL);\n\n\tWARN_ON(info->refcnt > 0);\n\n\twrite_unlock_irqrestore(&evtchn_rwlock, flags);\n\n\tkfree(info);\n\n\t/* Legacy IRQ descriptors are managed by the arch. */\n\tif (irq < nr_legacy_irqs())\n\t\treturn;\n\n\tirq_free_desc(irq);\n}", "target": 1, "idx": 10131}
{"commit_id": "57cbb8c148999ba8f14ed53435fc071ac9953afd", "project": "freetype/freetype2", "func": "FT_CALLBACK_DEF( FT_Error )\n  tt_cmap14_validate( FT_Byte*      table,\n                      FT_Validator  valid )\n  {\n    FT_Byte*  p;\n    FT_ULong  length;\n    FT_ULong  num_selectors;\n\n\n    if ( table + 2 + 4 + 4 > valid->limit )\n      FT_INVALID_TOO_SHORT;\n\n    p             = table + 2;\n    length        = TT_NEXT_ULONG( p );\n    num_selectors = TT_NEXT_ULONG( p );\n\n    if ( length > (FT_ULong)( valid->limit - table ) ||\n         /* length < 10 + 11 * num_selectors ? */\n         length < 10                                 ||\n         ( length - 10 ) / 11 < num_selectors        )\n      FT_INVALID_TOO_SHORT;\n\n    /* check selectors, they must be in increasing order */\n    {\n      /* we start lastVarSel at 1 because a variant selector value of 0\n       * isn't valid.\n       */\n      FT_ULong  n, lastVarSel = 1;\n\n\n      for ( n = 0; n < num_selectors; n++ )\n      {\n        FT_ULong  varSel    = TT_NEXT_UINT24( p );\n        FT_ULong  defOff    = TT_NEXT_ULONG( p );\n        FT_ULong  nondefOff = TT_NEXT_ULONG( p );\n\n\n        if ( defOff >= length || nondefOff >= length )\n          FT_INVALID_TOO_SHORT;\n\n        if ( varSel < lastVarSel )\n          FT_INVALID_DATA;\n\n        lastVarSel = varSel + 1;\n\n        /* check the default table (these glyphs should be reached     */\n        /* through the normal Unicode cmap, no GIDs, just check order) */\n        if ( defOff != 0 )\n        {\n          FT_Byte*  defp     = table + defOff;\n          FT_ULong  numRanges;\n          FT_ULong  i;\n          FT_ULong  lastBase = 0;\n\n\n          if ( defp + 4 > valid->limit )\n            FT_INVALID_TOO_SHORT;\n\n          numRanges = TT_NEXT_ULONG( defp );\n\n          /* defp + numRanges * 4 > valid->limit ? */\n          if ( numRanges > (FT_ULong)( valid->limit - defp ) / 4 )\n            FT_INVALID_TOO_SHORT;\n\n          for ( i = 0; i < numRanges; ++i )\n          {\n            FT_ULong  base = TT_NEXT_UINT24( defp );\n            FT_ULong  cnt  = FT_NEXT_BYTE( defp );\n\n\n            if ( base + cnt >= 0x110000UL )              /* end of Unicode */\n              FT_INVALID_DATA;\n\n            if ( base < lastBase )\n              FT_INVALID_DATA;\n\n            lastBase = base + cnt + 1U;\n          }\n        }\n\n        /* and the non-default table (these glyphs are specified here) */\n        if ( nondefOff != 0 )\n        {\n          FT_Byte*  ndp        = table + nondefOff;\n          FT_ULong  numMappings;\n          FT_ULong  i, lastUni = 0;\n\n\n          if ( ndp + 4 > valid->limit )\n            FT_INVALID_TOO_SHORT;\n\n          numMappings = TT_NEXT_ULONG( ndp );\n\n          /* numMappings * 5 > (FT_ULong)( valid->limit - ndp ) ? */\n          if ( numMappings > ( (FT_ULong)( valid->limit - ndp ) ) / 5 )\n            FT_INVALID_TOO_SHORT;\n\n          for ( i = 0; i < numMappings; ++i )\n          {\n            FT_ULong  uni = TT_NEXT_UINT24( ndp );\n            FT_ULong  gid = TT_NEXT_USHORT( ndp );\n\n\n            if ( uni >= 0x110000UL )                     /* end of Unicode */\n              FT_INVALID_DATA;\n\n            if ( uni < lastUni )\n              FT_INVALID_DATA;\n\n            lastUni = uni + 1U;\n\n            if ( valid->level >= FT_VALIDATE_TIGHT    &&\n                 gid >= TT_VALID_GLYPH_COUNT( valid ) )\n              FT_INVALID_GLYPH_ID;\n          }\n        }\n      }\n    }\n\n    return FT_Err_Ok;\n  }", "target": 1, "idx": 10132}
{"commit_id": "68948017423a12786704e54227b8b2f918c2fd27", "project": "rizinorg/rizin", "func": "static pyc_object *get_complex_object(RzBinPycObj *pyc, RzBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n1 = 0;\n\tut32 n2 = 0;\n\n\tret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\n\tif ((pyc->magic_int & 0xffff) <= 62061) {\n\t\tn1 = get_ut8(buffer, &error);\n\t} else {\n\t\tn1 = get_st32(buffer, &error);\n\t}\n\tif (error || UT32_ADD_OVFCHK(n1, 1)) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\tut8 *s1 = malloc(n1 + 1);\n\tif (!s1) {\n\t\treturn NULL;\n\t}\n\t/* object contain string representation of the number */\n\tif (rz_buf_read(buffer, s1, n1) != n1) {\n\t\tRZ_FREE(s1);\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\ts1[n1] = '\\0';\n\n\tif ((pyc->magic_int & 0xffff) <= 62061) {\n\t\tn2 = get_ut8(buffer, &error);\n\t} else {\n\t\tn2 = get_st32(buffer, &error);\n\t}\n\tif (error || UT32_ADD_OVFCHK(n2, 1)) {\n\t\treturn NULL;\n\t}\n\tut8 *s2 = malloc(n2 + 1);\n\tif (!s2) {\n\t\treturn NULL;\n\t}\n\t/* object contain string representation of the number */\n\tif (rz_buf_read(buffer, s2, n2) != n2) {\n\t\tRZ_FREE(s1);\n\t\tRZ_FREE(s2);\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\ts2[n2] = '\\0';\n\n\tret->type = TYPE_COMPLEX;\n\tret->data = rz_str_newf(\"%s+%sj\", s1, s2);\n\tRZ_FREE(s1);\n\tRZ_FREE(s2);\n\tif (!ret->data) {\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}", "target": 2, "idx": 10133}
{"commit_id": "712f4aad406bb1ed67f3f98d04c044191f0ff593", "project": "torvalds/linux", "func": "static int unix_attach_fds(struct scm_cookie *scm, struct sk_buff *skb)\n{\n\tint i;\n\tunsigned char max_level = 0;\n\tint unix_sock_count = 0;\n\n\tif (too_many_unix_fds(current))\n\t\treturn -ETOOMANYREFS;\n\n\tfor (i = scm->fp->count - 1; i >= 0; i--) {\n\t\tstruct sock *sk = unix_get_socket(scm->fp->fp[i]);\n\n\t\tif (sk) {\n\t\t\tunix_sock_count++;\n\t\t\tmax_level = max(max_level,\n\t\t\t\t\tunix_sk(sk)->recursion_level);\n\t\t}\n\t}\n\tif (unlikely(max_level > MAX_RECURSION_LEVEL))\n\t\treturn -ETOOMANYREFS;\n\n\t/*\n\t * Need to duplicate file references for the sake of garbage\n\t * collection.  Otherwise a socket in the fps might become a\n\t * candidate for GC while the skb is not yet queued.\n\t */\n\tUNIXCB(skb).fp = scm_fp_dup(scm->fp);\n\tif (!UNIXCB(skb).fp)\n\t\treturn -ENOMEM;\n\n\tfor (i = scm->fp->count - 1; i >= 0; i--)\n\t\tunix_inflight(scm->fp->fp[i]);\n\treturn max_level;\n}", "target": 1, "idx": 10134}
{"commit_id": "3bfe2049c222b23342ff2a216cd5a869e8a14897", "project": "kernel/git/tip/tip", "func": "static int f2fs_move_inline_dirents(struct inode *dir, struct page *ipage,\n\t\t\t\tstruct f2fs_inline_dentry *inline_dentry)\n{\n\tstruct page *page;\n\tstruct dnode_of_data dn;\n\tstruct f2fs_dentry_block *dentry_blk;\n\tint err;\n\n\tpage = grab_cache_page(dir->i_mapping, 0);\n\tif (!page) {\n\t\tf2fs_put_page(ipage, 1);\n\t\treturn -ENOMEM;\n\t}\n\n\tset_new_dnode(&dn, dir, ipage, NULL, 0);\n\terr = f2fs_reserve_block(&dn, 0);\n\tif (err)\n\t\tgoto out;\n\n\tif (unlikely(dn.data_blkaddr != NEW_ADDR)) {\n\t\tf2fs_put_dnode(&dn);\n\t\tset_sbi_flag(F2FS_P_SB(page), SBI_NEED_FSCK);\n\t\tf2fs_msg(F2FS_P_SB(page)->sb, KERN_WARNING,\n\t\t\t\"%s: corrupted inline inode ino=%lx, i_addr[0]:0x%x, \"\n\t\t\t\"run fsck to fix.\",\n\t\t\t__func__, dir->i_ino, dn.data_blkaddr);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tf2fs_wait_on_page_writeback(page, DATA);\n\tzero_user_segment(page, MAX_INLINE_DATA, PAGE_CACHE_SIZE);\n\n\tdentry_blk = kmap_atomic(page);\n\n\t/* copy data from inline dentry block to new dentry block */\n\tmemcpy(dentry_blk->dentry_bitmap, inline_dentry->dentry_bitmap,\n\t\t\t\t\tINLINE_DENTRY_BITMAP_SIZE);\n\tmemset(dentry_blk->dentry_bitmap + INLINE_DENTRY_BITMAP_SIZE, 0,\n\t\t\tSIZE_OF_DENTRY_BITMAP - INLINE_DENTRY_BITMAP_SIZE);\n\t/*\n\t * we do not need to zero out remainder part of dentry and filename\n\t * field, since we have used bitmap for marking the usage status of\n\t * them, besides, we can also ignore copying/zeroing reserved space\n\t * of dentry block, because them haven't been used so far.\n\t */\n\tmemcpy(dentry_blk->dentry, inline_dentry->dentry,\n\t\t\tsizeof(struct f2fs_dir_entry) * NR_INLINE_DENTRY);\n\tmemcpy(dentry_blk->filename, inline_dentry->filename,\n\t\t\t\t\tNR_INLINE_DENTRY * F2FS_SLOT_LEN);\n\n\tkunmap_atomic(dentry_blk);\n\tSetPageUptodate(page);\n\tset_page_dirty(page);\n\n\t/* clear inline dir and flag after data writeback */\n\ttruncate_inline_inode(ipage, 0);\n\n\tstat_dec_inline_dir(dir);\n\tclear_inode_flag(F2FS_I(dir), FI_INLINE_DENTRY);\n\n\tif (i_size_read(dir) < PAGE_CACHE_SIZE) {\n\t\ti_size_write(dir, PAGE_CACHE_SIZE);\n\t\tset_inode_flag(F2FS_I(dir), FI_UPDATE_DIR);\n\t}\n\n\tsync_inode_page(&dn);\nout:\n\tf2fs_put_page(page, 1);\n\treturn err;\n}", "target": 1, "idx": 10135}
{"commit_id": "9e7695bbee18525eaa6d12b32230313ae8a36a81", "project": "wireshark", "func": "static void\ndissect_sccp_optional_parameters(tvbuff_t *tvb, packet_info *pinfo,\n                                 proto_tree *sccp_tree, proto_tree *tree,\n                                 int offset, sccp_decode_context_t* sccp_info)\n{\n  guint8 parameter_type;\n\n  while ((parameter_type = tvb_get_guint8(tvb, offset)) !=\n         PARAMETER_END_OF_OPTIONAL_PARAMETERS) {\n\n    offset += PARAMETER_TYPE_LENGTH;\n    offset += dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,\n                                              parameter_type, offset, sccp_info);\n  }\n\n  /* Process end of optional parameters */\n  dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree, parameter_type, offset,\n                         END_OF_OPTIONAL_PARAMETERS_LENGTH, sccp_info);\n\n}", "target": 2, "idx": 10136}
{"commit_id": "9fe27a9b445f7e911286ed31c1087ceac567736b", "project": "android", "func": "uint8_t rfc_parse_data(tRFC_MCB* p_mcb, MX_FRAME* p_frame, BT_HDR* p_buf) {\n  uint8_t ead, eal, fcs;\n  uint8_t* p_data = (uint8_t*)(p_buf + 1) + p_buf->offset;\n  uint8_t* p_start = p_data;\n  uint16_t len;\n\n  if (p_buf->len < RFCOMM_CTRL_FRAME_LEN) {\n    RFCOMM_TRACE_ERROR(\"Bad Length1: %d\", p_buf->len);\n    return (RFC_EVENT_BAD_FRAME);\n  }\n\n  RFCOMM_PARSE_CTRL_FIELD(ead, p_frame->cr, p_frame->dlci, p_data);\n  if (!ead) {\n    RFCOMM_TRACE_ERROR(\"Bad Address(EA must be 1)\");\n    return (RFC_EVENT_BAD_FRAME);\n  }\n  RFCOMM_PARSE_TYPE_FIELD(p_frame->type, p_frame->pf, p_data);\n\n  eal = *(p_data)&RFCOMM_EA;\n  len = *(p_data)++ >> RFCOMM_SHIFT_LENGTH1;\n  if (eal == 0 && p_buf->len < RFCOMM_CTRL_FRAME_LEN) {\n    len += (*(p_data)++ << RFCOMM_SHIFT_LENGTH2);\n  } else if (eal == 0) {\n    RFCOMM_TRACE_ERROR(\"Bad Length when EAL = 0: %d\", p_buf->len);\n    android_errorWriteLog(0x534e4554, \"78288018\");\n    return RFC_EVENT_BAD_FRAME;\n  }\n\n  p_buf->len -= (3 + !ead + !eal + 1); /* Additional 1 for FCS */\n  p_buf->offset += (3 + !ead + !eal);\n\n  /* handle credit if credit based flow control */\n  if ((p_mcb->flow == PORT_FC_CREDIT) && (p_frame->type == RFCOMM_UIH) &&\n      (p_frame->dlci != RFCOMM_MX_DLCI) && (p_frame->pf == 1)) {\n    p_frame->credit = *p_data++;\n    p_buf->len--;\n    p_buf->offset++;\n  } else\n    p_frame->credit = 0;\n\n  if (p_buf->len != len) {\n    RFCOMM_TRACE_ERROR(\"Bad Length2 %d %d\", p_buf->len, len);\n    return (RFC_EVENT_BAD_FRAME);\n  }\n\n  fcs = *(p_data + len);\n\n  /* All control frames that we are sending are sent with P=1, expect */\n  /* reply with F=1 */\n  /* According to TS 07.10 spec ivalid frames are discarded without */\n  /* notification to the sender */\n  switch (p_frame->type) {\n    case RFCOMM_SABME:\n      if (RFCOMM_FRAME_IS_RSP(p_mcb->is_initiator, p_frame->cr) ||\n          !p_frame->pf || len || !RFCOMM_VALID_DLCI(p_frame->dlci) ||\n          !rfc_check_fcs(RFCOMM_CTRL_FRAME_LEN, p_start, fcs)) {\n        RFCOMM_TRACE_ERROR(\"Bad SABME\");\n        return (RFC_EVENT_BAD_FRAME);\n      } else\n        return (RFC_EVENT_SABME);\n\n    case RFCOMM_UA:\n      if (RFCOMM_FRAME_IS_CMD(p_mcb->is_initiator, p_frame->cr) ||\n          !p_frame->pf || len || !RFCOMM_VALID_DLCI(p_frame->dlci) ||\n          !rfc_check_fcs(RFCOMM_CTRL_FRAME_LEN, p_start, fcs)) {\n        RFCOMM_TRACE_ERROR(\"Bad UA\");\n        return (RFC_EVENT_BAD_FRAME);\n      } else\n        return (RFC_EVENT_UA);\n\n    case RFCOMM_DM:\n      if (RFCOMM_FRAME_IS_CMD(p_mcb->is_initiator, p_frame->cr) || len ||\n          !RFCOMM_VALID_DLCI(p_frame->dlci) ||\n          !rfc_check_fcs(RFCOMM_CTRL_FRAME_LEN, p_start, fcs)) {\n        RFCOMM_TRACE_ERROR(\"Bad DM\");\n        return (RFC_EVENT_BAD_FRAME);\n      } else\n        return (RFC_EVENT_DM);\n\n    case RFCOMM_DISC:\n      if (RFCOMM_FRAME_IS_RSP(p_mcb->is_initiator, p_frame->cr) ||\n          !p_frame->pf || len || !RFCOMM_VALID_DLCI(p_frame->dlci) ||\n          !rfc_check_fcs(RFCOMM_CTRL_FRAME_LEN, p_start, fcs)) {\n        RFCOMM_TRACE_ERROR(\"Bad DISC\");\n        return (RFC_EVENT_BAD_FRAME);\n      } else\n        return (RFC_EVENT_DISC);\n\n    case RFCOMM_UIH:\n      if (!RFCOMM_VALID_DLCI(p_frame->dlci)) {\n        RFCOMM_TRACE_ERROR(\"Bad UIH - invalid DLCI\");\n        return (RFC_EVENT_BAD_FRAME);\n      } else if (!rfc_check_fcs(2, p_start, fcs)) {\n        RFCOMM_TRACE_ERROR(\"Bad UIH - FCS\");\n        return (RFC_EVENT_BAD_FRAME);\n      } else if (RFCOMM_FRAME_IS_RSP(p_mcb->is_initiator, p_frame->cr)) {\n        /* we assume that this is ok to allow bad implementations to work */\n        RFCOMM_TRACE_ERROR(\"Bad UIH - response\");\n        return (RFC_EVENT_UIH);\n      } else\n        return (RFC_EVENT_UIH);\n  }\n\n  return (RFC_EVENT_BAD_FRAME);\n}", "target": 1, "idx": 10137}
{"commit_id": "9f939335a07085aa9a9663efd1dca06ef6405d62", "project": "systemd", "func": "static int dns_packet_read_type_window(DnsPacket *p, Bitmap **types, size_t *start) {\n        uint8_t window;\n        uint8_t length;\n        const uint8_t *bitmap;\n        uint8_t bit = 0;\n        unsigned i;\n        bool found = false;\n        _cleanup_(rewind_dns_packet) DnsPacketRewinder rewinder;\n        int r;\n\n        assert(p);\n        assert(types);\n        INIT_REWINDER(rewinder, p);\n\n        r = bitmap_ensure_allocated(types);\n        if (r < 0)\n                return r;\n\n        r = dns_packet_read_uint8(p, &window, NULL);\n        if (r < 0)\n                return r;\n\n        r = dns_packet_read_uint8(p, &length, NULL);\n        if (r < 0)\n                return r;\n\n        if (length == 0 || length > 32)\n                return -EBADMSG;\n\n        r = dns_packet_read(p, length, (const void **)&bitmap, NULL);\n        if (r < 0)\n                return r;\n\n        for (i = 0; i < length; i++) {\n                uint8_t bitmask = 1 << 7;\n\n                if (!bitmap[i]) {\n                        found = false;\n                        bit += 8;\n                        continue;\n                }\n\n                found = true;\n\n                for (; bitmask; bit++, bitmask >>= 1)\n                        if (bitmap[i] & bitmask) {\n                                uint16_t n;\n\n                                n = (uint16_t) window << 8 | (uint16_t) bit;\n\n                                /* Ignore pseudo-types. see RFC4034 section 4.1.2 */\n                                if (dns_type_is_pseudo(n))\n                                        continue;\n\n                                r = bitmap_set(*types, n);\n                                if (r < 0)\n                                        return r;\n                        }\n        }\n\n        if (!found)\n                return -EBADMSG;\n\n        if (start)\n                *start = rewinder.saved_rindex;\n        CANCEL_REWINDER(rewinder);\n\n        return 0;\n}", "target": 2, "idx": 10138}
{"commit_id": "220ec8cceaff2e3bda20f09164a6a96654957840", "project": "sirdude/gurbalib", "func": "static void main(string arg) {\n   string file, *exparg;\n   int szof;\n   \n   /* remove capability of path traversal */\n   /* discoverd by David Byrne of X-Force Red */\n   exparg = explode(arg, \"/\");\n   szof = sizeof(exparg);\n   if (szof > 1) {\n      return 1;\n   }\n\n   if (!alsos) {\n      setup_alsos();\n   }\n\n   if (empty_str(arg) || (arg == \"help\")) {\n      this_player()->more(usage());\n      return;\n   }\n\n   if (sscanf(arg, \"-%s\", arg)) {\n      this_player()->more(usage());\n      return;\n   }\n\n   file = normalize_path(arg, \"/doc/help/\");\n   if (show_help(file)) {\n      return;\n   }\n\n   if (query_wizard(this_player())) {\n      file = normalize_path(arg, \"/doc/help/wiz/\");\n      if (show_help(file)) {\n         return;\n      }\n   }\n\n   if (show_help_for_command(arg)) {\n      return;\n   }\n\n   write(capitalize(arg) + \": Unknown help topic.\");\n   if (query_wizard(this_player())) {\n      write(\"Try one of the following for more info:\\n\");\n      write(\"\\tman \" + arg + \"\\n\");\n      write(\"\\t\" + arg + \" -h\\n\");\n   } else {\n      write(\"If \" + arg + \" is a command, for more info try: \" + \n         arg + \" -h\\n\");\n   }\n   LOG_D->write_log(\"help\", this_player()->query_Name() +\n      \" on \" + ctime(time()) + \": \" + arg + \"\\n\");\n   return;\n}", "target": 2, "idx": 10139}
{"commit_id": "229abab99f39f11624e5651f819e7f1f8eddedcc", "project": "debauchee/barrier", "func": "void\nClient::connect()\n{\n    if (m_stream != NULL) {\n        return;\n    }\n    if (m_suspended) {\n        m_connectOnResume = true;\n        return;\n    }\n\n    auto security_level = ConnectionSecurityLevel::PLAINTEXT;\n    if (m_useSecureNetwork) {\n        // client always authenticates server\n        security_level = ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED;\n    }\n\n    try {\n        // resolve the server hostname.  do this every time we connect\n        // in case we couldn't resolve the address earlier or the address\n        // has changed (which can happen frequently if this is a laptop\n        // being shuttled between various networks).  patch by Brent\n        // Priddy.\n        m_serverAddress.resolve();\n\n        // m_serverAddress will be null if the hostname address is not reolved\n        if (m_serverAddress.getAddress() != NULL) {\n          // to help users troubleshoot, show server host name (issue: 60)\n          LOG((CLOG_NOTE \"connecting to '%s': %s:%i\",\n          m_serverAddress.getHostname().c_str(),\n          ARCH->addrToString(m_serverAddress.getAddress()).c_str(),\n          m_serverAddress.getPort()));\n        }\n\n        // create the socket\n        IDataSocket* socket = m_socketFactory->create(ARCH->getAddrFamily(m_serverAddress.getAddress()),\n                                                      security_level);\n        m_socket = dynamic_cast<TCPSocket*>(socket);\n\n        // filter socket messages, including a packetizing filter\n        m_stream = socket;\n        m_stream = new PacketStreamFilter(m_events, m_stream, true);\n\n        // connect\n        LOG((CLOG_DEBUG1 \"connecting to server\"));\n        setupConnecting();\n        setupTimer();\n        socket->connect(m_serverAddress);\n    }\n    catch (XBase& e) {\n        cleanupTimer();\n        cleanupConnecting();\n        cleanupStream();\n        LOG((CLOG_DEBUG1 \"connection failed\"));\n        sendConnectionFailedEvent(e.what());\n        return;\n    }\n}", "target": 2, "idx": 10140}
{"commit_id": "eafdcfa4b6d5187a5326442a82608ab03d9dddcb", "project": "wireshark", "func": "static int\ndissect_spoolss_buffer_data(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t    proto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\tBUFFER *b = (BUFFER *)di->private_data;\n\tproto_item *item;\n\tguint32 size;\n\tconst guint8 *data;\n\n\tif (di->conformant_run)\n\t\treturn offset;\n\n\t/* Dissect size and data */\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t    hf_buffer_size, &size);\n\n\t/* Before going any further, we must ensure the bytes\n\t   actually esist in the tvb */\n\tif ((guint32)tvb_reported_length_remaining(tvb, offset) < size) {\n\t\texpert_add_info(pinfo, tree, &ei_buffer_size_too_long);\n\t\treturn offset;\n\t}\n\n\toffset = dissect_ndr_uint8s(tvb, offset, pinfo, NULL, di, drep,\n\t\t\t\t    hf_buffer_data, size, &data);\n\n\titem = proto_tree_add_item(\n\t\ttree, hf_buffer_data, tvb, offset - size,\n\t\tsize, ENC_NA);\n\n\t/* Return buffer info */\n\n\tif (b) {\n\n\t\t/* I'm not sure about this.  Putting the buffer into\n\t\t   its own tvb makes sense and the dissection code is\n\t\t   much clearer, but the data is a proper subset of\n\t\t   the actual tvb.  Not adding the new data source\n\t\t   makes the hex display confusing as it switches\n\t\t   between the 'DCERPC over SMB' tvb and the buffer\n\t\t   tvb with no visual cues as to what is going on. */\n\n\t\tb->tvb = tvb_new_child_real_data(tvb, data, size, size);\n\t\tadd_new_data_source(pinfo, b->tvb, \"SPOOLSS buffer\");\n\n\t\tb->item = item;\n\t\tb->tree = proto_item_add_subtree(item, ett_BUFFER);\n\t}\n\n\treturn offset;\n}", "target": 2, "idx": 10141}
{"commit_id": "881d9c6af9da4257c69c327c4e2f1508b2fa754b", "project": "openssh/openssh-portable", "func": "static void\nprocess_add_identity(SocketEntry *e)\n{\n\tIdentity *id;\n\tint success = 0, confirm = 0;\n\tchar *fp, *comment = NULL, *sk_provider = NULL;\n\tchar canonical_provider[PATH_MAX];\n\ttime_t death = 0;\n\tu_int seconds = 0;\n\tstruct dest_constraint *dest_constraints = NULL;\n\tsize_t ndest_constraints = 0;\n\tstruct sshkey *k = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tdebug2_f(\"entering\");\n\tif ((r = sshkey_private_deserialize(e->request, &k)) != 0 ||\n\t    k == NULL ||\n\t    (r = sshbuf_get_cstring(e->request, &comment, NULL)) != 0) {\n\t\terror_fr(r, \"parse\");\n\t\tgoto out;\n\t}\n\tif (parse_key_constraints(e->request, k, &death, &seconds, &confirm,\n\t    &sk_provider, &dest_constraints, &ndest_constraints) != 0) {\n\t\terror_f(\"failed to parse constraints\");\n\t\tsshbuf_reset(e->request);\n\t\tgoto out;\n\t}\n\tdump_dest_constraints(__func__, dest_constraints, ndest_constraints);\n\n\tif (sk_provider != NULL) {\n\t\tif (!sshkey_is_sk(k)) {\n\t\t\terror(\"Cannot add provider: %s is not an \"\n\t\t\t    \"authenticator-hosted key\", sshkey_type(k));\n\t\t\tgoto out;\n\t\t}\n\t\tif (strcasecmp(sk_provider, \"internal\") == 0) {\n\t\t\tdebug_f(\"internal provider\");\n\t\t} else {\n\t\t\tif (e->nsession_ids != 0 && !remote_add_provider) {\n\t\t\t\tverbose(\"failed add of SK provider \\\"%.100s\\\": \"\n\t\t\t\t    \"remote addition of providers is disabled\",\n\t\t\t\t    sk_provider);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (realpath(sk_provider, canonical_provider) == NULL) {\n\t\t\t\tverbose(\"failed provider \\\"%.100s\\\": \"\n\t\t\t\t    \"realpath: %s\", sk_provider,\n\t\t\t\t    strerror(errno));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tfree(sk_provider);\n\t\t\tsk_provider = xstrdup(canonical_provider);\n\t\t\tif (match_pattern_list(sk_provider,\n\t\t\t    allowed_providers, 0) != 1) {\n\t\t\t\terror(\"Refusing add key: \"\n\t\t\t\t    \"provider %s not allowed\", sk_provider);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\tif ((r = sshkey_shield_private(k)) != 0) {\n\t\terror_fr(r, \"shield private\");\n\t\tgoto out;\n\t}\n\tif (lifetime && !death)\n\t\tdeath = monotime() + lifetime;\n\tif ((id = lookup_identity(k)) == NULL) {\n\t\tid = xcalloc(1, sizeof(Identity));\n\t\tTAILQ_INSERT_TAIL(&idtab->idlist, id, next);\n\t\t/* Increment the number of identities. */\n\t\tidtab->nentries++;\n\t} else {\n\t\t/* identity not visible, do not update */\n\t\tif (identity_permitted(id, e, NULL, NULL, NULL) != 0)\n\t\t\tgoto out; /* error already logged */\n\t\t/* key state might have been updated */\n\t\tsshkey_free(id->key);\n\t\tfree(id->comment);\n\t\tfree(id->sk_provider);\n\t\tfree_dest_constraints(id->dest_constraints,\n\t\t    id->ndest_constraints);\n\t}\n\t/* success */\n\tid->key = k;\n\tid->comment = comment;\n\tid->death = death;\n\tid->confirm = confirm;\n\tid->sk_provider = sk_provider;\n\tid->dest_constraints = dest_constraints;\n\tid->ndest_constraints = ndest_constraints;\n\n\tif ((fp = sshkey_fingerprint(k, SSH_FP_HASH_DEFAULT,\n\t    SSH_FP_DEFAULT)) == NULL)\n\t\tfatal_f(\"sshkey_fingerprint failed\");\n\tdebug_f(\"add %s %s \\\"%.100s\\\" (life: %u) (confirm: %u) \"\n\t    \"(provider: %s) (destination constraints: %zu)\",\n\t    sshkey_ssh_name(k), fp, comment, seconds, confirm,\n\t    sk_provider == NULL ? \"none\" : sk_provider, ndest_constraints);\n\tfree(fp);\n\t/* transferred */\n\tk = NULL;\n\tcomment = NULL;\n\tsk_provider = NULL;\n\tdest_constraints = NULL;\n\tndest_constraints = 0;\n\tsuccess = 1;\n out:\n\tfree(sk_provider);\n\tfree(comment);\n\tsshkey_free(k);\n\tfree_dest_constraints(dest_constraints, ndest_constraints);\n\tsend_status(e, success);\n}", "target": 1, "idx": 10142}
{"commit_id": "778500563a9f7ceba996937dc886bd8cde29b42b", "project": "mruby", "func": "static mrb_value\nfiber_switch(mrb_state *mrb, mrb_value self, mrb_int len, const mrb_value *a, mrb_bool resume, mrb_bool vmexec)\n{\n  struct mrb_context *c = fiber_check(mrb, self);\n  struct mrb_context *old_c = mrb->c;\n  enum mrb_fiber_state status;\n  mrb_value value;\n\n  fiber_check_cfunc(mrb, c);\n  status = c->status;\n  if (resume && status == MRB_FIBER_TRANSFERRED) {\n    mrb_raise(mrb, E_FIBER_ERROR, \"resuming transferred fiber\");\n  }\n  if (status == MRB_FIBER_RUNNING || status == MRB_FIBER_RESUMED) {\n    mrb_raise(mrb, E_FIBER_ERROR, \"double resume (fib)\");\n  }\n  if (status == MRB_FIBER_TERMINATED) {\n    mrb_raise(mrb, E_FIBER_ERROR, \"resuming dead fiber\");\n  }\n  old_c->status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED;\n  c->prev = resume ? mrb->c : (c->prev ? c->prev : mrb->root_c);\n  fiber_switch_context(mrb, c);\n  if (status == MRB_FIBER_CREATED) {\n    mrb_value *b, *e;\n\n    mrb_stack_extend(mrb, len+2); /* for receiver and (optional) block */\n    b = c->stack+1;\n    e = b + len;\n    while (b<e) {\n      *b++ = *a++;\n    }\n    c->cibase->argc = (int)len;\n    value = c->stack[0] = MRB_PROC_ENV(c->ci->proc)->stack[0];\n  }\n  else {\n    value = fiber_result(mrb, a, len);\n  }\n\n  if (vmexec) {\n    c->vmexec = TRUE;\n    value = mrb_vm_exec(mrb, c->ci[-1].proc, c->ci->pc);\n    mrb->c = old_c;\n  }\n  else {\n    MARK_CONTEXT_MODIFY(c);\n  }\n  return value;\n}", "target": 2, "idx": 10143}
{"commit_id": "a3691602960e0a479565b439645e6b883a11a273", "project": "cesanta/mongoose", "func": "struct mg_str *mg_get_http_header(struct http_message *hm, const char *name) {\n  size_t i, len = strlen(name);\n\n  for (i = 0; i < MG_MAX_HTTP_HEADERS && hm->header_names[i].len > 0; i++) {\n    struct mg_str *h = &hm->header_names[i], *v = &hm->header_values[i];\n    if (h->p != NULL && h->len == len && !mg_ncasecmp(h->p, name, len))\n      return v;\n  }\n\n  return NULL;\n}", "target": 3, "idx": 10144}
{"commit_id": "7f821fc9c77a9b01fe7b1d6e72717b33d8d64142", "project": "torvalds/linux", "func": "static void tm_reclaim_thread(struct thread_struct *thr,\n\t\t\t      struct thread_info *ti, uint8_t cause)\n{\n\tunsigned long msr_diff = 0;\n\n\t/*\n\t * If FP/VSX registers have been already saved to the\n\t * thread_struct, move them to the transact_fp array.\n\t * We clear the TIF_RESTORE_TM bit since after the reclaim\n\t * the thread will no longer be transactional.\n\t */\n\tif (test_ti_thread_flag(ti, TIF_RESTORE_TM)) {\n\t\tmsr_diff = thr->ckpt_regs.msr & ~thr->regs->msr;\n\t\tif (msr_diff & MSR_FP)\n\t\t\tmemcpy(&thr->transact_fp, &thr->fp_state,\n\t\t\t       sizeof(struct thread_fp_state));\n\t\tif (msr_diff & MSR_VEC)\n\t\t\tmemcpy(&thr->transact_vr, &thr->vr_state,\n\t\t\t       sizeof(struct thread_vr_state));\n\t\tclear_ti_thread_flag(ti, TIF_RESTORE_TM);\n\t\tmsr_diff &= MSR_FP | MSR_VEC | MSR_VSX | MSR_FE0 | MSR_FE1;\n\t}\n\n\t/*\n\t * Use the current MSR TM suspended bit to track if we have\n\t * checkpointed state outstanding.\n\t * On signal delivery, we'd normally reclaim the checkpointed\n\t * state to obtain stack pointer (see:get_tm_stackpointer()).\n\t * This will then directly return to userspace without going\n\t * through __switch_to(). However, if the stack frame is bad,\n\t * we need to exit this thread which calls __switch_to() which\n\t * will again attempt to reclaim the already saved tm state.\n\t * Hence we need to check that we've not already reclaimed\n\t * this state.\n\t * We do this using the current MSR, rather tracking it in\n\t * some specific thread_struct bit, as it has the additional\n\t * benifit of checking for a potential TM bad thing exception.\n\t */\n\tif (!MSR_TM_SUSPENDED(mfmsr()))\n\t\treturn;\n\n\ttm_reclaim(thr, thr->regs->msr, cause);\n\n\t/* Having done the reclaim, we now have the checkpointed\n\t * FP/VSX values in the registers.  These might be valid\n\t * even if we have previously called enable_kernel_fp() or\n\t * flush_fp_to_thread(), so update thr->regs->msr to\n\t * indicate their current validity.\n\t */\n\tthr->regs->msr |= msr_diff;\n}", "target": 1, "idx": 10145}
{"commit_id": "a3917d95d516e3de267d3cfa5d4d3715a90e8777", "project": "CESNET/libyang", "func": "static struct lys_node *\nread_yin_anydata(struct lys_module *module, struct lys_node *parent, struct lyxml_elem *yin, LYS_NODE type,\n                 int options, struct unres_schema *unres)\n{\n    struct ly_ctx *ctx = module->ctx;\n    struct lys_node *retval;\n    struct lys_node_anydata *anyxml;\n    struct lyxml_elem *sub, *next;\n    const char *value;\n    int r;\n    int f_mand = 0;\n    int c_must = 0, c_ftrs = 0, c_ext = 0;\n    void *reallocated;\n\n    anyxml = calloc(1, sizeof *anyxml);\n    LY_CHECK_ERR_RETURN(!anyxml, LOGMEM(ctx), NULL);\n\n    anyxml->nodetype = type;\n    anyxml->prev = (struct lys_node *)anyxml;\n    retval = (struct lys_node *)anyxml;\n\n    if (read_yin_common(module, parent, retval, LYEXT_PAR_NODE, yin,\n            OPT_IDENT | OPT_MODULE | ((options & LYS_PARSE_OPT_CFG_IGNORE) ? OPT_CFG_IGNORE :\n            (options & LYS_PARSE_OPT_CFG_NOINHERIT) ? OPT_CFG_PARSE : OPT_CFG_PARSE | OPT_CFG_INHERIT), unres)) {\n        goto error;\n    }\n\n    LOGDBG(LY_LDGYIN, \"parsing %s statement \\\"%s\\\"\", yin->name, retval->name);\n\n    /* insert the node into the schema tree */\n    if (lys_node_addchild(parent, lys_main_module(module), retval, options)) {\n        goto error;\n    }\n\n    LY_TREE_FOR_SAFE(yin->child, next, sub) {\n        if (strcmp(sub->ns->value, LY_NSYIN)) {\n            /* extension */\n            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ext, retval->ext_size, \"extensions\", \"anydata\", error);\n            c_ext++;\n        } else if (!strcmp(sub->name, \"mandatory\")) {\n            if (f_mand) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);\n                goto error;\n            }\n            /* just checking the flags in leaf is not sufficient, we would allow\n             * multiple mandatory statements with the \"false\" value\n             */\n            f_mand = 1;\n\n            GETVAL(ctx, value, sub, \"value\");\n            if (!strcmp(value, \"true\")) {\n                anyxml->flags |= LYS_MAND_TRUE;\n            } else if (!strcmp(value, \"false\")) {\n                anyxml->flags |= LYS_MAND_FALSE;\n            } else {\n                LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);\n                goto error;\n            }\n            /* else false is the default value, so we can ignore it */\n\n            if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_MANDATORY, 0, unres)) {\n                goto error;\n            }\n            lyxml_free(ctx, sub);\n        } else if (!strcmp(sub->name, \"when\")) {\n            if (anyxml->when) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);\n                goto error;\n            }\n\n            anyxml->when = read_yin_when(module, sub, unres);\n            if (!anyxml->when) {\n                lyxml_free(ctx, sub);\n                goto error;\n            }\n            lyxml_free(ctx, sub);\n        } else if (!strcmp(sub->name, \"must\")) {\n            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_must, anyxml->must_size, \"musts\", \"anydata\", error);\n            c_must++;\n        } else if (!strcmp(sub->name, \"if-feature\")) {\n            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ftrs, retval->iffeature_size, \"if-features\", \"anydata\", error);\n            c_ftrs++;\n\n        } else {\n            LOGVAL(ctx, LYE_INSTMT, LY_VLOG_LYS, retval, sub->name);\n            goto error;\n        }\n    }\n\n    /* middle part - process nodes with cardinality of 0..n */\n    if (c_must) {\n        anyxml->must = calloc(c_must, sizeof *anyxml->must);\n        LY_CHECK_ERR_GOTO(!anyxml->must, LOGMEM(ctx), error);\n    }\n    if (c_ftrs) {\n        anyxml->iffeature = calloc(c_ftrs, sizeof *anyxml->iffeature);\n        LY_CHECK_ERR_GOTO(!anyxml->iffeature, LOGMEM(ctx), error);\n    }\n    if (c_ext) {\n        /* some extensions may be already present from the substatements */\n        reallocated = realloc(retval->ext, (c_ext + retval->ext_size) * sizeof *retval->ext);\n        LY_CHECK_ERR_GOTO(!reallocated, LOGMEM(ctx), error);\n        retval->ext = reallocated;\n\n        /* init memory */\n        memset(&retval->ext[retval->ext_size], 0, c_ext * sizeof *retval->ext);\n    }\n\n    LY_TREE_FOR_SAFE(yin->child, next, sub) {\n        if (strcmp(sub->ns->value, LY_NSYIN)) {\n            /* extension */\n            r = lyp_yin_fill_ext(retval, LYEXT_PAR_NODE, 0, 0, module, sub, &retval->ext, &retval->ext_size, unres);\n            if (r) {\n                goto error;\n            }\n        } else if (!strcmp(sub->name, \"must\")) {\n            r = fill_yin_must(module, sub, &anyxml->must[anyxml->must_size], unres);\n            anyxml->must_size++;\n            if (r) {\n                goto error;\n            }\n        } else if (!strcmp(sub->name, \"if-feature\")) {\n            r = fill_yin_iffeature(retval, 0, sub, &anyxml->iffeature[anyxml->iffeature_size], unres);\n            anyxml->iffeature_size++;\n            if (r) {\n                goto error;\n            }\n        }\n    }\n\n    lyp_reduce_ext_list(&retval->ext, retval->ext_size, c_ext + retval->ext_size);\n\n    /* check XPath dependencies */\n    if (!(ctx->models.flags & LY_CTX_TRUSTED) && (anyxml->when || anyxml->must)) {\n        if (options & LYS_PARSE_OPT_INGRP) {\n            if (lyxp_node_check_syntax(retval)) {\n                goto error;\n            }\n        } else {\n            if (unres_schema_add_node(module, unres, retval, UNRES_XPATH, NULL) == -1) {\n                goto error;\n            }\n        }\n    }\n\n    for (r = 0; r < retval->ext_size; ++r) {\n        /* set flag, which represent LYEXT_OPT_VALID */\n        if (retval->ext[r] && (retval->ext[r]->flags & LYEXT_OPT_VALID)) {\n            retval->flags |= LYS_VALID_EXT;\n            break;\n        }\n    }\n\n    return retval;\n\nerror:\n    lys_node_free(ctx, retval, NULL, 0);\n    return NULL;\n}", "target": 2, "idx": 10146}
{"commit_id": "7ce5b2b590256ce53d6af28c1d203fb3bc1d2d97", "project": "vim", "func": "static void\nchanged_common(\n    linenr_T\tlnum,\n    colnr_T\tcol,\n    linenr_T\tlnume,\n    long\txtra)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n    int\t\ti;\n    int\t\tcols;\n    pos_T\t*p;\n    int\t\tadd;\n\n    // mark the buffer as modified\n    changed();\n\n#ifdef FEAT_EVAL\n    may_record_change(lnum, col, lnume, xtra);\n#endif\n#ifdef FEAT_DIFF\n    if (curwin->w_p_diff && diff_internal())\n\tcurtab->tp_diff_update = TRUE;\n#endif\n\n    // set the '. mark\n    if ((cmdmod.cmod_flags & CMOD_KEEPJUMPS) == 0)\n    {\n\tcurbuf->b_last_change.lnum = lnum;\n\tcurbuf->b_last_change.col = col;\n\n\t// Create a new entry if a new undo-able change was started or we\n\t// don't have an entry yet.\n\tif (curbuf->b_new_change || curbuf->b_changelistlen == 0)\n\t{\n\t    if (curbuf->b_changelistlen == 0)\n\t\tadd = TRUE;\n\t    else\n\t    {\n\t\t// Don't create a new entry when the line number is the same\n\t\t// as the last one and the column is not too far away.  Avoids\n\t\t// creating many entries for typing \"xxxxx\".\n\t\tp = &curbuf->b_changelist[curbuf->b_changelistlen - 1];\n\t\tif (p->lnum != lnum)\n\t\t    add = TRUE;\n\t\telse\n\t\t{\n\t\t    cols = comp_textwidth(FALSE);\n\t\t    if (cols == 0)\n\t\t\tcols = 79;\n\t\t    add = (p->col + cols < col || col + cols < p->col);\n\t\t}\n\t    }\n\t    if (add)\n\t    {\n\t\t// This is the first of a new sequence of undo-able changes\n\t\t// and it's at some distance of the last change.  Use a new\n\t\t// position in the changelist.\n\t\tcurbuf->b_new_change = FALSE;\n\n\t\tif (curbuf->b_changelistlen == JUMPLISTSIZE)\n\t\t{\n\t\t    // changelist is full: remove oldest entry\n\t\t    curbuf->b_changelistlen = JUMPLISTSIZE - 1;\n\t\t    mch_memmove(curbuf->b_changelist, curbuf->b_changelist + 1,\n\t\t\t\t\t  sizeof(pos_T) * (JUMPLISTSIZE - 1));\n\t\t    FOR_ALL_TAB_WINDOWS(tp, wp)\n\t\t    {\n\t\t\t// Correct position in changelist for other windows on\n\t\t\t// this buffer.\n\t\t\tif (wp->w_buffer == curbuf && wp->w_changelistidx > 0)\n\t\t\t    --wp->w_changelistidx;\n\t\t    }\n\t\t}\n\t\tFOR_ALL_TAB_WINDOWS(tp, wp)\n\t\t{\n\t\t    // For other windows, if the position in the changelist is\n\t\t    // at the end it stays at the end.\n\t\t    if (wp->w_buffer == curbuf\n\t\t\t    && wp->w_changelistidx == curbuf->b_changelistlen)\n\t\t\t++wp->w_changelistidx;\n\t\t}\n\t\t++curbuf->b_changelistlen;\n\t    }\n\t}\n\tcurbuf->b_changelist[curbuf->b_changelistlen - 1] =\n\t\t\t\t\t\t\tcurbuf->b_last_change;\n\t// The current window is always after the last change, so that \"g,\"\n\t// takes you back to it.\n\tcurwin->w_changelistidx = curbuf->b_changelistlen;\n    }\n\n    if (VIsual_active)\n\tcheck_visual_pos();\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n    {\n\tif (wp->w_buffer == curbuf)\n\t{\n#ifdef FEAT_FOLDING\n\t    linenr_T last = lnume + xtra - 1;  // last line after the change\n#endif\n\t    // Mark this window to be redrawn later.\n\t    if (wp->w_redr_type < VALID)\n\t\twp->w_redr_type = VALID;\n\n\t    // Check if a change in the buffer has invalidated the cached\n\t    // values for the cursor.\n#ifdef FEAT_FOLDING\n\t    // Update the folds for this window.  Can't postpone this, because\n\t    // a following operator might work on the whole fold: \">>dd\".\n\t    foldUpdate(wp, lnum, last);\n\n\t    // The change may cause lines above or below the change to become\n\t    // included in a fold.  Set lnum/lnume to the first/last line that\n\t    // might be displayed differently.\n\t    // Set w_cline_folded here as an efficient way to update it when\n\t    // inserting lines just above a closed fold.\n\t    i = hasFoldingWin(wp, lnum, &lnum, NULL, FALSE, NULL);\n\t    if (wp->w_cursor.lnum == lnum)\n\t\twp->w_cline_folded = i;\n\t    i = hasFoldingWin(wp, last, NULL, &last, FALSE, NULL);\n\t    if (wp->w_cursor.lnum == last)\n\t\twp->w_cline_folded = i;\n\n\t    // If the changed line is in a range of previously folded lines,\n\t    // compare with the first line in that range.\n\t    if (wp->w_cursor.lnum <= lnum)\n\t    {\n\t\ti = find_wl_entry(wp, lnum);\n\t\tif (i >= 0 && wp->w_cursor.lnum > wp->w_lines[i].wl_lnum)\n\t\t    changed_line_abv_curs_win(wp);\n\t    }\n#endif\n\t    if (wp->w_cursor.lnum > lnum)\n\t\tchanged_line_abv_curs_win(wp);\n\t    else if (wp->w_cursor.lnum == lnum && wp->w_cursor.col >= col)\n\t\tchanged_cline_bef_curs_win(wp);\n\t    if (wp->w_botline >= lnum)\n\t    {\n\t\tif (xtra < 0)\n\t\t    invalidate_botline_win(wp);\n\t\telse\n\t\t    // Assume that botline doesn't change (inserted lines make\n\t\t    // other lines scroll down below botline).\n\t\t    approximate_botline_win(wp);\n\t    }\n\n\t    // Check if any w_lines[] entries have become invalid.\n\t    // For entries below the change: Correct the lnums for\n\t    // inserted/deleted lines.  Makes it possible to stop displaying\n\t    // after the change.\n\t    for (i = 0; i < wp->w_lines_valid; ++i)\n\t\tif (wp->w_lines[i].wl_valid)\n\t\t{\n\t\t    if (wp->w_lines[i].wl_lnum >= lnum)\n\t\t    {\n\t\t\tif (wp->w_lines[i].wl_lnum < lnume)\n\t\t\t{\n\t\t\t    // line included in change\n\t\t\t    wp->w_lines[i].wl_valid = FALSE;\n\t\t\t}\n\t\t\telse if (xtra != 0)\n\t\t\t{\n\t\t\t    // line below change\n\t\t\t    wp->w_lines[i].wl_lnum += xtra;\n#ifdef FEAT_FOLDING\n\t\t\t    wp->w_lines[i].wl_lastlnum += xtra;\n#endif\n\t\t\t}\n\t\t    }\n#ifdef FEAT_FOLDING\n\t\t    else if (wp->w_lines[i].wl_lastlnum >= lnum)\n\t\t    {\n\t\t\t// change somewhere inside this range of folded lines,\n\t\t\t// may need to be redrawn\n\t\t\twp->w_lines[i].wl_valid = FALSE;\n\t\t    }\n#endif\n\t\t}\n\n#ifdef FEAT_FOLDING\n\t    // Take care of side effects for setting w_topline when folds have\n\t    // changed.  Esp. when the buffer was changed in another window.\n\t    if (hasAnyFolding(wp))\n\t\tset_topline(wp, wp->w_topline);\n#endif\n\t    // If lines have been added or removed, relative numbering always\n\t    // requires a redraw.\n\t    if (wp->w_p_rnu && xtra != 0)\n\t    {\n\t\twp->w_last_cursor_lnum_rnu = 0;\n\t\tredraw_win_later(wp, VALID);\n\t    }\n#ifdef FEAT_SYN_HL\n\t    // Cursor line highlighting probably need to be updated with\n\t    // \"VALID\" if it's below the change.\n\t    // If the cursor line is inside the change we need to redraw more.\n\t    if (wp->w_p_cul)\n\t    {\n\t\tif (xtra == 0)\n\t\t    redraw_win_later(wp, VALID);\n\t\telse if (lnum <= wp->w_last_cursorline)\n\t\t    redraw_win_later(wp, SOME_VALID);\n\t    }\n#endif\n\t}\n    }\n\n    // Call update_screen() later, which checks out what needs to be redrawn,\n    // since it notices b_mod_set and then uses b_mod_*.\n    if (must_redraw < VALID)\n\tmust_redraw = VALID;\n\n    // when the cursor line is changed always trigger CursorMoved\n    if (lnum <= curwin->w_cursor.lnum\n\t\t && lnume + (xtra < 0 ? -xtra : xtra) > curwin->w_cursor.lnum)\n\tlast_cursormoved.lnum = 0;\n}", "target": 2, "idx": 10147}
{"commit_id": "31fa3304049fc406a201a72293cce140f0557dca", "project": "mruby", "func": "static void\nprepare_singleton_class(mrb_state *mrb, struct RBasic *o)\n{\n  struct RClass *sc, *c;\n\n  mrb_assert(o->c);\n  if (o->c->tt == MRB_TT_SCLASS) return;\n  sc = MRB_OBJ_ALLOC(mrb, MRB_TT_SCLASS, mrb->class_class);\n  sc->flags |= MRB_FL_CLASS_IS_INHERITED;\n  sc->mt = mt_new(mrb);\n  sc->iv = 0;\n  if (o->tt == MRB_TT_CLASS) {\n    c = (struct RClass*)o;\n    if (!c->super) {\n      sc->super = mrb->class_class;\n    }\n    else {\n      sc->super = c->super->c;\n    }\n  }\n  else if (o->tt == MRB_TT_SCLASS) {\n    c = (struct RClass*)o;\n    while (c->super->tt == MRB_TT_ICLASS)\n      c = c->super;\n    make_metaclass(mrb, c->super);\n    sc->super = c->super->c;\n  }\n  else {\n    sc->super = o->c;\n    prepare_singleton_class(mrb, (struct RBasic*)sc);\n  }\n  o->c = sc;\n  mrb_field_write_barrier(mrb, (struct RBasic*)o, (struct RBasic*)sc);\n  mrb_field_write_barrier(mrb, (struct RBasic*)sc, (struct RBasic*)o);\n  mrb_obj_iv_set(mrb, (struct RObject*)sc, MRB_SYM(__attached__), mrb_obj_value(o));\n  sc->flags |= o->flags & MRB_FL_OBJ_IS_FROZEN;\n}", "target": 2, "idx": 10148}
{"commit_id": "ce684dd008532ea0bf9d4a1d89bacb35f4a83f4d", "project": "libvips", "func": "static int\nvips_foreign_load_gif_scan_image( VipsForeignLoadGif *gif ) \n{\n\tVipsObjectClass *class = VIPS_OBJECT_GET_CLASS( gif );\n\tGifFileType *file = gif->file;\n\n\tColorMapObject *map;\n\tGifByteType *extension;\n\n\tif( DGifGetImageDesc( gif->file ) == GIF_ERROR ) {\n\t\tvips_foreign_load_gif_error( gif ); \n\t\treturn( -1 );\n\t}\n\n\t/* Check that the frame looks sane. Perhaps giflib checks\n\t * this for us.\n\t */\n\tif( file->Image.Left < 0 ||\n\t\tfile->Image.Width < 1 ||\n\t\tfile->Image.Width > 10000 ||\n\t\tfile->Image.Left + file->Image.Width > file->SWidth ||\n\t\tfile->Image.Top < 0 ||\n\t\tfile->Image.Height < 1 ||\n\t\tfile->Image.Height > 10000 ||\n\t\tfile->Image.Top + file->Image.Height > file->SHeight ) {\n\t\tvips_error( class->nickname, \"%s\", _( \"bad frame size\" ) ); \n\t\treturn( -1 ); \n\t}\n\n\t/* Test for a non-greyscale colourmap for this frame.\n\t */\n\tmap = file->Image.ColorMap ? file->Image.ColorMap : file->SColorMap;\n\tif( !gif->has_colour &&\n\t\tmap ) {\n\t\tint i;\n\n\t\tfor( i = 0; i < map->ColorCount; i++ ) \n\t\t\tif( map->Colors[i].Red != map->Colors[i].Green ||\n\t\t\t\tmap->Colors[i].Green != map->Colors[i].Blue ) {\n\t\t\t\tgif->has_colour = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\t/* Step over compressed image data.\n\t */\n\tdo {\n\t\tif( vips_foreign_load_gif_code_next( gif, &extension ) ) \n\t\t\treturn( -1 );\n\t} while( extension != NULL );\n\n\treturn( 0 );\n}", "target": 2, "idx": 10149}
{"commit_id": "967c05aee439e6e5d7d805e195b3a20ef5c433d6", "project": "kernel/git/netdev/net", "func": "static void tcp_mtu_probing(struct inet_connection_sock *icsk, struct sock *sk)\n{\n\tconst struct net *net = sock_net(sk);\n\tint mss;\n\n\t/* Black hole detection */\n\tif (!net->ipv4.sysctl_tcp_mtu_probing)\n\t\treturn;\n\n\tif (!icsk->icsk_mtup.enabled) {\n\t\ticsk->icsk_mtup.enabled = 1;\n\t\ticsk->icsk_mtup.probe_timestamp = tcp_jiffies32;\n\t} else {\n\t\tmss = tcp_mtu_to_mss(sk, icsk->icsk_mtup.search_low) >> 1;\n\t\tmss = min(net->ipv4.sysctl_tcp_base_mss, mss);\n\t\tmss = max(mss, 68 - tcp_sk(sk)->tcp_header_len);\n\t\tmss = max(mss, net->ipv4.sysctl_tcp_min_snd_mss);\n\t\ticsk->icsk_mtup.search_low = tcp_mss_to_mtu(sk, mss);\n\t}\n\ttcp_sync_mss(sk, icsk->icsk_pmtu_cookie);\n}", "target": 2, "idx": 10150}
{"commit_id": "0614e2b73768b502fc32a75349823356d98aae2c", "project": "torvalds/linux", "func": "static int ax25_create(struct net *net, struct socket *sock, int protocol,\n\t\t       int kern)\n{\n\tstruct sock *sk;\n\tax25_cb *ax25;\n\n\tif (protocol < 0 || protocol > SK_PROTOCOL_MAX)\n\t\treturn -EINVAL;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\tswitch (sock->type) {\n\tcase SOCK_DGRAM:\n\t\tif (protocol == 0 || protocol == PF_AX25)\n\t\t\tprotocol = AX25_P_TEXT;\n\t\tbreak;\n\n\tcase SOCK_SEQPACKET:\n\t\tswitch (protocol) {\n\t\tcase 0:\n\t\tcase PF_AX25:\t/* For CLX */\n\t\t\tprotocol = AX25_P_TEXT;\n\t\t\tbreak;\n\t\tcase AX25_P_SEGMENT:\n#ifdef CONFIG_INET\n\t\tcase AX25_P_ARP:\n\t\tcase AX25_P_IP:\n#endif\n#ifdef CONFIG_NETROM\n\t\tcase AX25_P_NETROM:\n#endif\n#ifdef CONFIG_ROSE\n\t\tcase AX25_P_ROSE:\n#endif\n\t\t\treturn -ESOCKTNOSUPPORT;\n#ifdef CONFIG_NETROM_MODULE\n\t\tcase AX25_P_NETROM:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_NETROM))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_ROSE_MODULE\n\t\tcase AX25_P_ROSE:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_ROSE))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SOCK_RAW:\n\t\tif (!capable(CAP_NET_RAW))\n\t\t\treturn -EPERM;\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\n\tsk = sk_alloc(net, PF_AX25, GFP_ATOMIC, &ax25_proto, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\n\tax25 = ax25_sk(sk)->cb = ax25_create_cb();\n\tif (!ax25) {\n\t\tsk_free(sk);\n\t\treturn -ENOMEM;\n\t}\n\n\tsock_init_data(sock, sk);\n\n\tsk->sk_destruct = ax25_free_sock;\n\tsock->ops    = &ax25_proto_ops;\n\tsk->sk_protocol = protocol;\n\n\tax25->sk    = sk;\n\n\treturn 0;\n}", "target": 0, "idx": 10151}
{"commit_id": "37455483889bd1c641bdaafc493d1cc236b74904", "project": "merbanan/rtl_433", "func": "static int acurite_00275rm_decode(r_device *decoder, bitbuffer_t *bitbuffer)\n{\n    int result = 0;\n    bitbuffer_invert(bitbuffer);\n\n    // This sensor repeats a signal three times. Combine as fallback.\n    uint8_t *b_rows[3] = {0};\n    int n_rows         = 0;\n    for (int row = 0; row < bitbuffer->num_rows; ++row) {\n        if (n_rows < 3 && bitbuffer->bits_per_row[row] == 88) {\n            b_rows[n_rows] = bitbuffer->bb[row];\n            n_rows++;\n        }\n    }\n\n    // Combine signal if exactly three repeats were found\n    if (n_rows == 3) {\n        bitbuffer_add_row(bitbuffer);\n        uint8_t *b = bitbuffer->bb[bitbuffer->num_rows - 1];\n        for (int i = 0; i < 11; ++i) {\n            // The majority bit count wins\n            b[i] = (b_rows[0][i] & b_rows[1][i]) |\n                    (b_rows[1][i] & b_rows[2][i]) |\n                    (b_rows[2][i] & b_rows[0][i]);\n        }\n        bitbuffer->bits_per_row[bitbuffer->num_rows - 1] = 88;\n    }\n\n    // Output the first valid row\n    for (int row = 0; row < bitbuffer->num_rows; ++row) {\n        if (bitbuffer->bits_per_row[row] != 88) {\n            result = DECODE_ABORT_LENGTH;\n            continue; // return DECODE_ABORT_LENGTH;\n        }\n        uint8_t *b = bitbuffer->bb[row];\n\n        // Check CRC\n        if (crc16lsb(b, 11, 0x00b2, 0x00d0) != 0) {\n            decoder_log_bitrow(decoder, 1, __func__, b, 11 * 8, \"sensor bad CRC\");\n            result = DECODE_FAIL_MIC;\n            continue; // return DECODE_FAIL_MIC;\n        }\n\n        //  Decode common fields\n        int id          = (b[0] << 16) | (b[1] << 8) | b[3];\n        int battery_low = (b[2] & 0x40) == 0;\n        int model_flag  = (b[2] & 1);\n        float tempc     = ((b[4] << 4) | (b[5] >> 4)) * 0.1 - 100;\n        int probe       = b[5] & 3;\n        int humidity    = ((b[6] & 0x1f) << 2) | (b[7] >> 6);\n\n        //  Water probe (detects water leak)\n        int water = (b[7] & 0x0f) == 15; // valid only if (probe == 1)\n        //  Soil probe (detects temperature)\n        float ptempc = (((b[7] & 0x0f) << 8) | b[8]) * 0.1 - 100; // valid only if (probe == 2 || probe == 3)\n        //  Spot probe (detects temperature and humidity)\n        int phumidity = b[9] & 0x7f; // valid only if (probe == 3)\n\n        /* clang-format off */\n        data_t *data = data_make(\n                \"model\",            \"\",             DATA_STRING,    model_flag ? \"Acurite-00275rm\" : \"Acurite-00276rm\",\n                \"subtype\",          \"Probe\",        DATA_INT,       probe,\n                \"id\",               \"\",             DATA_INT,       id,\n                \"battery_ok\",       \"Battery\",      DATA_INT,       !battery_low,\n                \"temperature_C\",    \"Celsius\",      DATA_FORMAT,    \"%.1f C\",  DATA_DOUBLE, tempc,\n                \"humidity\",         \"Humidity\",     DATA_FORMAT,    \"%u %%\", DATA_INT,      humidity,\n                \"water\",            \"\",             DATA_COND, probe == 1, DATA_INT,        water,\n                \"temperature_1_C\",  \"Celsius\",      DATA_COND, probe == 2, DATA_FORMAT, \"%.1f C\",   DATA_DOUBLE, ptempc,\n                \"temperature_1_C\",  \"Celsius\",      DATA_COND, probe == 3, DATA_FORMAT, \"%.1f C\",   DATA_DOUBLE, ptempc,\n                \"humidity_1\",       \"Humidity\",     DATA_COND, probe == 3, DATA_FORMAT, \"%u %%\",    DATA_INT,    phumidity,\n                \"mic\",              \"Integrity\",    DATA_STRING,    \"CRC\",\n                NULL);\n        /* clang-format on */\n\n        decoder_output_data(decoder, data);\n\n        return 1;\n    }\n    // Only returns the latest result, but better than nothing.\n    return result;\n}", "target": 1, "idx": 10152}
{"commit_id": "b0dc999e0b45355314616321dbb6cb71e729fc9d", "project": "GNOME/gnome-session", "func": "static gboolean\naccept_ice_connection (GIOChannel           *source,\n                       GIOCondition          condition,\n                       GsmIceConnectionData *data)\n{\n        IceConn         ice_conn;\n        IceAcceptStatus status;\n\n        g_debug (\"GsmXsmpServer: accept_ice_connection()\");\n\n        ice_conn = IceAcceptConnection (data->listener, &status);\n        if (status != IceAcceptSuccess) {\n                g_debug (\"GsmXsmpServer: IceAcceptConnection returned %d\", status);\n                return TRUE;\n        }\n\n        auth_ice_connection (ice_conn);\n\n        return TRUE;\n}", "target": 1, "idx": 10153}
{"commit_id": "625bab309d9dd21db2d8ae2aa3511810d32842a8", "project": "wireshark", "func": "static int\ndissect_docsis (tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, void* data _U_)\n{\n  guint8 fc = 0;\n  guint8 fctype = 0;\n  guint8 fcparm = 0;\n  guint8 exthdr = 0;\n  guint16 mac_parm = 0;\n  guint8 hdrlen = DOCSIS_MIN_HEADER_LEN;\n  guint16 len_sid = 0;\n  tvbuff_t *next_tvb = NULL;\n  tvbuff_t *mgt_tvb = NULL;\n  gint pdulen = 0;\n  guint16 payload_length = 0;\n  guint16 framelen = 0;\n  gboolean save_fragmented;\n\n  proto_item *ti;\n  proto_tree *docsis_tree;\n\n  /* concatlen and concatpos are declared static to allow for recursive calls to\n   * the dissect_docsis routine when dissecting Concatenated frames\n   */\n  static guint16 concatlen;\n  static guint16 concatpos;\n\n  /* Extract Frame Control parts */\n  fc = tvb_get_guint8 (tvb, 0); /* Frame Control Byte */\n  fctype = (fc >> 6) & 0x03;    /* Frame Control Type:  2 MSB Bits */\n  fcparm = (fc >> 1) & 0x1F;    /* Frame Control Parameter: Next 5 Bits */\n  exthdr = (fc & 0x01);         /* Extended Header Bit: LSB */\n\n  /* Extract the MAC Parm; MAC Parm and SID offsets; change for a Queue Depth Request */\n  if (fcparm == FCPARM_QUEUE_DEPTH_REQ_FRM) {\n    mac_parm = tvb_get_ntohs (tvb, 1);\n    len_sid = tvb_get_ntohs (tvb, 3);\n    hdrlen = DOCSIS_MIN_HEADER_LEN + 1; // 7-byte header for this message type\n  } else {\n    mac_parm = tvb_get_guint8 (tvb, 1);\n    len_sid = tvb_get_ntohs (tvb, 2);\n  }\n\n  /* Set Header Length based on presence of Extended header */\n  if (exthdr == EXT_HDR_ON) {\n    hdrlen += mac_parm;\n  }\n\n  /* Captured Payload Length is based on the length of the header */\n  payload_length = tvb_captured_length_remaining (tvb, hdrlen);\n\n  /* If this is a Request Frame, then pdulen is 0 and framelen is 6 */\n  if ((fctype == FCTYPE_MACSPC) && (fcparm == FCPARM_RQST_FRM || fcparm == FCPARM_QUEUE_DEPTH_REQ_FRM))\n  {\n    pdulen = 0;\n    if (fcparm == FCPARM_QUEUE_DEPTH_REQ_FRM)\n      framelen = DOCSIS_MIN_HEADER_LEN + 1;\n    else\n      framelen = DOCSIS_MIN_HEADER_LEN;\n  } else {\n    framelen = DOCSIS_MIN_HEADER_LEN + len_sid;\n    pdulen = len_sid - (mac_parm + 2);\n  }\n\n  /* Make entries in Protocol column and Info column on summary display */\n  col_set_str (pinfo->cinfo, COL_PROTOCOL, \"DOCSIS\");\n\n  switch (fctype)\n  {\n    case FCTYPE_PACKET:\n      col_set_str (pinfo->cinfo, COL_INFO, \"Packet PDU\");\n      break;\n    case FCTYPE_RESERVED:\n      col_set_str (pinfo->cinfo, COL_INFO, \"Reserved PDU\");\n      break;\n    case FCTYPE_ISOLAT:\n      col_set_str (pinfo->cinfo, COL_INFO, \"Isolation PDU\");\n      break;\n    case FCTYPE_MACSPC:\n      if (fcparm == FCPARM_RQST_FRM)\n        col_add_fstr (pinfo->cinfo, COL_INFO,\n                      \"Request Frame SID = %u Mini Slots = %u\", len_sid,\n                      mac_parm);\n      else if (fcparm == FCPARM_QUEUE_DEPTH_REQ_FRM)\n        col_add_fstr (pinfo->cinfo, COL_INFO,\n                      \"Request Frame SID = %u Bytes Requested = %u\", len_sid,\n                      mac_parm);\n      else if (fcparm == FCPARM_FRAG_HDR)\n        col_set_str (pinfo->cinfo, COL_INFO, \"Fragmented Frame\");\n      else\n        col_set_str (pinfo->cinfo, COL_INFO, \"Mac Specific\");\n      break;\n  }  /* switch fctype */\n\n  ti = proto_tree_add_item(tree, proto_docsis, tvb, 0, hdrlen, ENC_NA);\n  docsis_tree = proto_item_add_subtree (ti, ett_docsis);\n\n  /* add an item to the subtree, see section 1.6 for more information */\n\n  /* Add in FC Byte fields */\n  proto_tree_add_item (docsis_tree, hf_docsis_fctype, tvb, 0, 1, ENC_BIG_ENDIAN);\n\n  switch (fctype)\n  {\n    case FCTYPE_PACKET:\n    {\n      proto_item_append_text (ti, \" Packet PDU\");\n      proto_tree_add_item (docsis_tree, hf_docsis_fcparm, tvb, 0, 1, ENC_BIG_ENDIAN);\n      proto_tree_add_item (docsis_tree, hf_docsis_exthdr, tvb, 0, 1, ENC_BIG_ENDIAN);\n      /* Dissect Length field for a PDU */\n      dissect_exthdr_length_field (tvb, pinfo, docsis_tree, exthdr, mac_parm, len_sid, &payload_length);\n      /* Dissect Header Check Sequence field for a PDU */\n      dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen);\n      if (pdulen > 0)\n      {\n        next_tvb =  tvb_new_subset_remaining(tvb, hdrlen);\n        call_dissector (eth_withoutfcs_handle, next_tvb, pinfo, docsis_tree);\n      }\n      if (concatlen > 0)\n      {\n        concatlen = concatlen - framelen;\n        concatpos += framelen;\n      }\n      break;\n    }\n    case FCTYPE_RESERVED:\n    {\n      proto_item_append_text (ti, \" Reserved PDU\");\n      proto_tree_add_item (docsis_tree, hf_docsis_fcparm, tvb, 0, 1, ENC_BIG_ENDIAN);\n      proto_tree_add_item (docsis_tree, hf_docsis_exthdr, tvb, 0, 1, ENC_BIG_ENDIAN);\n      /* Dissect Length field for a PDU */\n      dissect_exthdr_length_field (tvb, pinfo, docsis_tree, exthdr, mac_parm, len_sid, &payload_length);\n      /* Dissect Header Check Sequence field for a PDU */\n      dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen);\n\n      if (concatlen > 0)\n      {\n        concatlen = concatlen - framelen;\n        concatpos += framelen;\n      }\n\n      /* Don't do anything for a Reserved Frame */\n      next_tvb =  tvb_new_subset_remaining(tvb, hdrlen);\n      call_data_dissector(next_tvb, pinfo, tree);\n      break;\n    }\n    case FCTYPE_ISOLAT:\n    {\n      proto_item_append_text (ti, \" Isolation PDU\");\n      proto_tree_add_item (docsis_tree, hf_docsis_fcparm, tvb, 0, 1, ENC_BIG_ENDIAN);\n      proto_tree_add_item (docsis_tree, hf_docsis_exthdr, tvb, 0, 1, ENC_BIG_ENDIAN);\n      /* Dissect Length field for a PDU */\n      dissect_exthdr_length_field (tvb, pinfo, docsis_tree, exthdr, mac_parm, len_sid, &payload_length);\n      /* Dissect Header Check Sequence field for a PDU */\n      dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen);\n      if (pdulen > 0)\n      {\n        next_tvb =  tvb_new_subset_remaining(tvb, hdrlen);\n        call_dissector (eth_withoutfcs_handle, next_tvb, pinfo, docsis_tree);\n      }\n      if (concatlen > 0)\n      {\n        concatlen = concatlen - framelen;\n        concatpos += framelen;\n      }\n      break;\n    }\n    case FCTYPE_MACSPC:\n    {\n      proto_item_append_text (ti, \" MAC-Specific PDU\");\n      proto_tree_add_item (docsis_tree, hf_docsis_machdr_fcparm, tvb, 0, 1, ENC_BIG_ENDIAN);\n      proto_tree_add_item (docsis_tree, hf_docsis_exthdr, tvb, 0, 1, ENC_BIG_ENDIAN);\n      switch(fcparm)\n      {\n        case FCPARM_TIMING_HDR:\n          // no break\n        case FCPARM_MAC_MGMT_HDR:\n        {\n          /* Dissect Length field for a PDU */\n          dissect_exthdr_length_field (tvb, pinfo, docsis_tree, exthdr, mac_parm, len_sid, &payload_length);\n          /* Dissect Header Check Sequence field for a PDU */\n          dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen);\n\n          /* Pass off to the DOCSIS Management dissector/s */\n          mgt_tvb = tvb_new_subset_remaining(tvb, hdrlen);\n          call_dissector (docsis_mgmt_handle, mgt_tvb, pinfo, docsis_tree);\n\n          if (concatlen > 0)\n          {\n            concatlen = concatlen - framelen;\n            concatpos += framelen;\n          }\n\n          break;\n        }\n        case FCPARM_RQST_FRM:\n        {\n          /* Decode for a Request Frame.  No extended header */\n          proto_tree_add_uint (docsis_tree, hf_docsis_mini_slots, tvb, 1, 1, mac_parm);\n          proto_tree_add_uint (docsis_tree, hf_docsis_sid, tvb, 2, 2, len_sid);\n          /* Dissect Header Check Sequence field for a PDU */\n          dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen);\n\n          if (concatlen > 0)\n          {\n            concatlen = concatlen - framelen;\n            concatpos += framelen;\n          }\n\n          /* Don't do anything for a Request Frame, there is no data following it*/\n          break;\n        }\n        case FCPARM_FRAG_HDR:\n        {\n          /* Check if this is a fragmentation header */\n          save_fragmented = pinfo->fragmented;\n          pinfo->fragmented = TRUE;\n\n          /* Dissect Length field for a PDU */\n          dissect_exthdr_length_field (tvb, pinfo, docsis_tree, exthdr, mac_parm, len_sid, &payload_length);\n          /* Dissect Header Check Sequence field for a PDU */\n          dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen);\n\n          /* Grab the Fragment FCS */\n          guint32 sent_fcs = tvb_get_ntohl(tvb, (hdrlen + len_sid - 4));\n          guint32 fcs = crc32_802_tvb(tvb, tvb_captured_length(tvb) - 4);\n\n          /* Only defragment valid frames with a good FCS */\n          if (sent_fcs == fcs)\n          {\n            fragment_item *frag_msg = NULL;\n            frag_msg = fragment_add_seq_check(&docsis_reassembly_table,\n                                              tvb, hdrlen, pinfo,\n                                              frag_sid, NULL, /* ID for fragments belonging together */\n                                              frag_seq, /* Fragment Sequence Number */\n                                              (len_sid - 4), /* fragment length - to the end */\n                                              !(frag_flags & FRAG_LAST)); /* More fragments? */\n\n            next_tvb = process_reassembled_data(tvb, hdrlen, pinfo,\n                                                \"Reassembled Message\", frag_msg, &docsis_frag_items,\n                                                NULL, docsis_tree);\n\n            if (frag_flags == FRAG_LAST)\n              pinfo->fragmented = FALSE;\n            else\n              pinfo->fragmented = TRUE;\n\n            if (frag_msg) { /* Reassembled */\n              proto_item_append_text (ti, \" (Message Reassembled)\");\n            } else { /* Not last packet of reassembled Short Message */\n              proto_item_append_text (ti, \" (Message fragment %u)\", frag_seq);\n\n            }\n\n            if(next_tvb)\n            {\n              /* By default assume an Ethernet payload */\n              call_dissector (eth_withoutfcs_handle, next_tvb, pinfo, docsis_tree);\n            } else {\n              /* Otherwise treat as Data */\n              tvbuff_t *payload_tvb = tvb_new_subset_length_caplen(tvb, hdrlen, (len_sid - 4), -1);\n              call_data_dissector(payload_tvb, pinfo, docsis_tree);\n            }\n          } else {\n            /* Report frames with a bad FCS */\n            expert_add_info(pinfo, ti, &ei_docsis_frag_fcs_bad);\n          }\n\n          /* Add the Fragment FCS to the end of the parent tree */\n          proto_tree_add_checksum(docsis_tree, tvb, (hdrlen + len_sid - 4), hf_docsis_frag_fcs, hf_docsis_frag_fcs_status, &ei_docsis_frag_fcs_bad, pinfo, fcs, ENC_BIG_ENDIAN, PROTO_CHECKSUM_VERIFY);\n\n          pinfo->fragmented = save_fragmented;\n\n          if (concatlen > 0)\n          {\n            concatlen = concatlen - framelen;\n            concatpos += framelen;\n          }\n\n          break;\n        }\n        case FCPARM_QUEUE_DEPTH_REQ_FRM:\n        {\n          /* Decode for a Queue-depth Based Request */\n          proto_tree_add_uint (docsis_tree, hf_docsis_requested_size, tvb, 1, 2, mac_parm);\n          proto_tree_add_uint (docsis_tree, hf_docsis_sid, tvb, 3, 2, len_sid);\n          /* Dissect Header Check Sequence field for a PDU */\n          dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen);\n\n          if (concatlen > 0)\n          {\n            concatlen = concatlen - framelen;\n            concatpos += framelen;\n          }\n\n          /* No PDU Payload for this frame */\n          break;\n        }\n        case FCPARM_CONCAT_HDR:\n        {\n          /* Decode for a Concatenated Header; ONLY for DOCSIS versions < 3.1.  No Extended Header */\n          proto_item_append_text (ti, \" (Concatenated Header)\");\n          proto_tree_add_item (docsis_tree, hf_docsis_concat_cnt, tvb, 1, 1, ENC_BIG_ENDIAN);\n          proto_tree_add_item (docsis_tree, hf_docsis_len, tvb, 2, 2, ENC_BIG_ENDIAN);\n          /* Dissect Header Check Sequence field for a PDU */\n          dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen);\n\n          /* If this is a concatenated frame setup the length of the concatenated\n           * frame and set the position to the first byte of the first frame\n           */\n          concatlen = len_sid;\n          concatpos = DOCSIS_MIN_HEADER_LEN;\n\n          /* Call the docsis dissector on the same frame\n           * to dissect DOCSIS frames within the concatenated\n           * frame.  concatpos and concatlen are declared\n           * static and are decremented and incremented\n           * respectively when the inner\n           * docsis frames are dissected. */\n          while (concatlen > 0)\n          {\n            next_tvb = tvb_new_subset_length_caplen (tvb, concatpos, -1, concatlen);\n            call_dissector (docsis_handle, next_tvb, pinfo, docsis_tree);\n          }\n          concatlen = 0;\n          concatpos = 0;\n          break;\n        }\n        default:\n            /* Unknown parameter, stop dissection */\n          concatlen = 0;\n          break;\n      } /* switch fcparm */\n      break;\n    }\n  } /* switch fctype*/\n\n  return tvb_captured_length(tvb);\n}", "target": 2, "idx": 10154}
{"commit_id": "68f67ef6cf1f41e77337be3bc4bff91f3a3c6324", "project": "android", "func": "void ASessionDescription::getFormatType(\n        size_t index, unsigned long *PT,\n        AString *desc, AString *params) const {\n    AString format;\n    getFormat(index, &format);\n\n    const char *lastSpacePos = strrchr(format.c_str(), ' ');\n    CHECK(lastSpacePos != NULL);\n\n    char *end;\n    unsigned long x = strtoul(lastSpacePos + 1, &end, 10);\n    CHECK_GT(end, lastSpacePos + 1);\n    CHECK_EQ(*end, '\\0');\n\n    *PT = x;\n\n    char key[32];\n    snprintf(key, sizeof(key), \"a=rtpmap:%lu\", x);\n\n    CHECK(findAttribute(index, key, desc));\n\n    snprintf(key, sizeof(key), \"a=fmtp:%lu\", x);\n    if (!findAttribute(index, key, params)) {\n        params->clear();\n    }\n}", "target": 1, "idx": 10155}
{"commit_id": "c4c07b4d6fa1f11880eab8e076d3d060ef3f55fc", "project": "torvalds/linux", "func": "int snmp_helper(void *context, size_t hdrlen, unsigned char tag,\n\t\tconst void *data, size_t datalen)\n{\n\tstruct snmp_ctx *ctx = (struct snmp_ctx *)context;\n\t__be32 *pdata;\n\n\tif (datalen != 4)\n\t\treturn -EINVAL;\n\tpdata = (__be32 *)data;\n\tif (*pdata == ctx->from) {\n\t\tpr_debug(\"%s: %pI4 to %pI4\\n\", __func__,\n\t\t\t (void *)&ctx->from, (void *)&ctx->to);\n\n\t\tif (*ctx->check)\n\t\t\tfast_csum(ctx, (unsigned char *)data - ctx->begin);\n\t\t*pdata = ctx->to;\n\t}\n\n\treturn 1;\n}", "target": 2, "idx": 10156}
{"commit_id": "a4ae828ee416a66d8c7bf5ee71d653c2cc6a26dd", "project": "python/cpython", "func": "static PyObject *\n_pickle_UnpicklerMemoProxy_copy_impl(UnpicklerMemoProxyObject *self)\n/*[clinic end generated code: output=e12af7e9bc1e4c77 input=97769247ce032c1d]*/\n{\n    size_t i;\n    PyObject *new_memo = PyDict_New();\n    if (new_memo == NULL)\n        return NULL;\n\n    for (i = 0; i < self->unpickler->memo_size; i++) {\n        int status;\n        PyObject *key, *value;\n\n        value = self->unpickler->memo[i];\n        if (value == NULL)\n            continue;\n\n        key = PyLong_FromSsize_t(i);\n        if (key == NULL)\n            goto error;\n        status = PyDict_SetItem(new_memo, key, value);\n        Py_DECREF(key);\n        if (status < 0)\n            goto error;\n    }\n    return new_memo;\n\nerror:\n    Py_DECREF(new_memo);\n    return NULL;\n}", "target": 2, "idx": 10157}
{"commit_id": "77c955200ddd1761d6ed7a6c1578349fedbb55e4", "project": "android", "func": "bool SkRgnBuilder::init(int maxHeight, int maxTransitions, bool pathIsInverse) {\n    if ((maxHeight | maxTransitions) < 0) {\n        return false;\n    }\n\n    if (pathIsInverse) {\n        // allow for additional X transitions to \"invert\" each scanline\n        // [ L' ... normal transitions ... R' ]\n        //\n        maxTransitions += 2;\n    }\n\n    // compute the count with +1 and +3 slop for the working buffer\n    int64_t count = sk_64_mul(maxHeight + 1, 3 + maxTransitions);\n\n    if (pathIsInverse) {\n        // allow for two \"empty\" rows for the top and bottom\n        //      [ Y, 1, L, R, S] == 5 (*2 for top and bottom)\n        count += 10;\n    }\n\n    if (count < 0 || !sk_64_isS32(count)) {\n        return false;\n    }\n    fStorageCount = sk_64_asS32(count);\n\n    fStorage = (SkRegion::RunType*)sk_malloc_canfail(fStorageCount, sizeof(SkRegion::RunType));\n    if (nullptr == fStorage) {\n        return false;\n    }\n\n    fCurrScanline = nullptr;    // signal empty collection\n    fPrevScanline = nullptr;    // signal first scanline\n    return true;\n}", "target": 2, "idx": 10158}
{"commit_id": "04a567494786d5bb50894fc8bb8fea0cf496bea8", "project": "ImageMagick", "func": "static MagickBooleanType ReadPSDChannel(Image *image,\n  const ImageInfo *image_info,const PSDInfo *psd_info,LayerInfo* layer_info,\n  const size_t channel,const PSDCompressionType compression,\n  ExceptionInfo *exception)\n{\n  Image\n    *channel_image,\n    *mask;\n\n  MagickOffsetType\n    offset;\n\n  MagickBooleanType\n    status;\n\n  channel_image=image;\n  mask=(Image *) NULL;\n  if ((layer_info->channel_info[channel].type < -1) &&\n      (layer_info->mask.page.width > 0) && (layer_info->mask.page.height > 0))\n    {\n      const char\n        *option;\n\n      /*\n        Ignore mask that is not a user supplied layer mask, if the mask is\n        disabled or if the flags have unsupported values.\n      */\n      option=GetImageOption(image_info,\"psd:preserve-opacity-mask\");\n      if ((layer_info->channel_info[channel].type != -2) ||\n          (layer_info->mask.flags > 2) || ((layer_info->mask.flags & 0x02) &&\n           (IsStringTrue(option) == MagickFalse)))\n        {\n          SeekBlob(image,layer_info->channel_info[channel].size-2,SEEK_CUR);\n          return(MagickTrue);\n        }\n      mask=CloneImage(image,layer_info->mask.page.width,\n        layer_info->mask.page.height,MagickFalse,exception);\n      if (mask != (Image *) NULL)\n        {\n          SetImageType(mask,GrayscaleType,exception);\n          channel_image=mask;\n        }\n    }\n\n  offset=TellBlob(image);\n  status=MagickFalse;\n  switch(compression)\n  {\n    case Raw:\n      status=ReadPSDChannelRaw(channel_image,psd_info->channels,\n        layer_info->channel_info[channel].type,exception);\n      break;\n    case RLE:\n      {\n        MagickOffsetType\n          *sizes;\n\n        sizes=ReadPSDRLESizes(channel_image,psd_info,channel_image->rows);\n        if (sizes == (MagickOffsetType *) NULL)\n          ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n            image->filename);\n        status=ReadPSDChannelRLE(channel_image,psd_info,\n          layer_info->channel_info[channel].type,sizes,exception);\n        sizes=(MagickOffsetType *) RelinquishMagickMemory(sizes);\n      }\n      break;\n    case ZipWithPrediction:\n    case ZipWithoutPrediction:\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n      status=ReadPSDChannelZip(channel_image,layer_info->channels,\n        layer_info->channel_info[channel].type,compression,\n        layer_info->channel_info[channel].size-2,exception);\n#else\n      (void) ThrowMagickException(exception,GetMagickModule(),\n          MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\n            \"'%s' (ZLIB)\",image->filename);\n#endif\n      break;\n    default:\n      (void) ThrowMagickException(exception,GetMagickModule(),TypeWarning,\n        \"CompressionNotSupported\",\"'%.20g'\",(double) compression);\n      break;\n  }\n\n  SeekBlob(image,offset+layer_info->channel_info[channel].size-2,SEEK_SET);\n  if (status == MagickFalse)\n    {\n      if (mask != (Image *) NULL)\n        DestroyImage(mask);\n      ThrowBinaryException(CoderError,\"UnableToDecompressImage\",\n        image->filename);\n    }\n  layer_info->mask.image=mask;\n  return(status);\n}", "target": 1, "idx": 10159}
{"commit_id": "d3e09bf4654fe5478b6dbf2b26ebab6271317d81", "project": "harfbuzz", "func": "void subtract (const hb_bit_set_invertible_t &other)\n  {\n    if (likely (inverted == other.inverted))\n    {\n      if (unlikely (inverted))\n\tprocess (hb_bitwise_lt, other);\n      else\n\tprocess (hb_bitwise_gt, other); /* Main branch. */\n    }\n    else\n    {\n      if (unlikely (inverted))\n\tprocess (hb_bitwise_or, other);\n      else\n\tprocess (hb_bitwise_and, other);\n    }\n    if (likely (s.successful))\n      inverted = inverted && !other.inverted;\n  }", "target": 1, "idx": 10160}
{"commit_id": "5d45b69b590cabc5127282d1ade3bca1598e5f5c", "project": "wireshark", "func": "static gint\ndissect_wccp2_mask_value_set_list(tvbuff_t *tvb, int offset,\n                                  int length, packet_info *pinfo, proto_tree *info_tree, wccp_address_table* addr_table)\n{\n  guint num_of_elem;\n  guint i;\n  proto_item *te;\n  proto_tree *element_tree;\n  guint start;\n\n\n  if (length < 4)\n    return length - 4;\n\n  element_tree = proto_tree_add_subtree(info_tree, tvb, offset, 4, ett_mv_set_list, &te, \"Mask/Value Set List\");\n  start = offset;\n\n\n  num_of_elem = tvb_get_ntohl(tvb, offset);\n  proto_tree_add_item(element_tree, hf_mask_value_set_list_num_elements,\n                      tvb, offset, 4, ENC_BIG_ENDIAN);\n  /*  proto_tree_add_uint(element_tree, , tvb, offset, 4, num_of_elem); */\n  EAT(4);\n\n  for (i = 0; i < num_of_elem; i++)\n    {\n      gint new_length;\n\n      new_length=dissect_wccp2_mask_value_set_element(tvb, offset, length, i, pinfo, element_tree, addr_table);\n\n      CHECK_LENGTH_ADVANCE_OFFSET(new_length);\n    }\n\n  proto_item_set_len(te, offset-start);\n  return length;\n}", "target": 2, "idx": 10161}
{"commit_id": "b2bbd9fdf209911d94b23cc33f4daccbceb7fa8a", "project": "wireshark", "func": "static void\ndissect_coap_opt_object_security(tvbuff_t *tvb, proto_item *head_item, proto_tree *subtree, gint offset, gint opt_length, packet_info *pinfo, coap_info *coinfo, coap_common_dissect_t *dissect_hf)\n{\n\tguint8 flag_byte = 0;\n\tgboolean non_compressed = FALSE;\n\tgboolean expand = FALSE;\n\tgboolean signature_present = FALSE;\n\tgboolean kid_context_present = FALSE;\n\tgboolean kid_present = FALSE;\n\tguint8 piv_len = 0;\n\tguint8 kid_context_len = 0;\n\tguint8 kid_len = 0;\n\n\tcoinfo->object_security = TRUE;\n\n\tcoinfo->oscore_info->piv = NULL;\n\tcoinfo->oscore_info->piv_len = 0;\n\tcoinfo->oscore_info->kid_context = NULL;\n\tcoinfo->oscore_info->kid_context_len = 0;\n\tcoinfo->oscore_info->kid = NULL;\n\tcoinfo->oscore_info->kid_len = 0;\n\n\tif (opt_length == 0) { /* option length is zero, means flag byte is 0x00*/\n\t\t/* add info to the head of the packet detail */\n\t\tproto_item_append_text(head_item, \": 00 (no Flag Byte)\");\n\t} else {\n\t\tflag_byte = tvb_get_guint8(tvb, offset);\n\n\t\tproto_tree_add_item(subtree, dissect_hf->hf.opt_object_security_non_compressed, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\tnon_compressed = flag_byte & COAP_OBJECT_SECURITY_NON_COMPRESSED_MASK;\n\n\t\tproto_tree_add_item(subtree, dissect_hf->hf.opt_object_security_expand, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\texpand = flag_byte & COAP_OBJECT_SECURITY_EXPAND_MASK;\n\n\t\tproto_tree_add_item(subtree, dissect_hf->hf.opt_object_security_signature, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\tsignature_present = flag_byte & COAP_OBJECT_SECURITY_SIGNATURE_MASK;\n\n\t\tproto_tree_add_item(subtree, dissect_hf->hf.opt_object_security_kid_context_present, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\tkid_context_present = flag_byte & COAP_OBJECT_SECURITY_KID_CONTEXT_MASK;\n\n\t\tproto_tree_add_item(subtree, dissect_hf->hf.opt_object_security_kid_present, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\tkid_present = flag_byte & COAP_OBJECT_SECURITY_KID_MASK;\n\n\t\tproto_tree_add_item(subtree, dissect_hf->hf.opt_object_security_piv_len, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\tpiv_len = (flag_byte & COAP_OBJECT_SECURITY_PIVLEN_MASK) >> 0;\n\n\t\t/* kid_len is what remains in the option after all other fields are parsed\n\t\twe calculate kid_len by subtracting from option length as we parse individual fields */\n\t\tkid_len = opt_length;\n\n\t\toffset += 1;\n\t\tkid_len -= 1;\n\n\t\tif (non_compressed || expand || signature_present) {\n\t\t\t/* how these bits are handled is not yet specified */\n\t\t\texpert_add_info_format(pinfo, subtree, &dissect_hf->ei.opt_object_security_bad, \"Unsupported format\");\n\t\t}\n\n\t\tif (piv_len > 0) {\n\t\t\tproto_tree_add_item(subtree, dissect_hf->hf.opt_object_security_piv, tvb, offset, piv_len, ENC_NA);\n\t\t\tcoinfo->oscore_info->piv = (guint8 *) tvb_memdup(wmem_packet_scope(), tvb, offset, piv_len);\n\t\t\tcoinfo->oscore_info->piv_len = piv_len;\n\n\t\t\toffset += piv_len;\n\t\t\tkid_len -= piv_len;\n\t\t}\n\n\t\tif (kid_context_present) {\n\t\t\tproto_tree_add_item(subtree, dissect_hf->hf.opt_object_security_kid_context_len, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\t\tkid_context_len = tvb_get_guint8(tvb, offset);\n\n\t\t\toffset += 1;\n\t\t\tkid_len -= 1;\n\n\t\t\tproto_tree_add_item(subtree, dissect_hf->hf.opt_object_security_kid_context, tvb, offset, kid_context_len, ENC_NA);\n\t\t\tcoinfo->oscore_info->kid_context = (guint8 *) tvb_memdup(wmem_packet_scope(), tvb, offset, kid_context_len);\n\t\t\tcoinfo->oscore_info->kid_context_len = kid_context_len;\n\n\t\t\toffset += kid_context_len;\n\t\t\tkid_len -= kid_context_len;\n\t\t}\n\n\t\tif (kid_present) {\n\t\t\tif(kid_len > 0) {\n\t\t\t\tproto_tree_add_item(subtree, dissect_hf->hf.opt_object_security_kid, tvb, offset, kid_len, ENC_NA);\n\t\t\t\tcoinfo->oscore_info->kid = (guint8 *) tvb_memdup(wmem_packet_scope(), tvb, offset, kid_len);\n\t\t\t\tcoinfo->oscore_info->kid_len = kid_len;\n\n\t\t\t} else {\n\t\t\t\texpert_add_info_format(pinfo, subtree, &dissect_hf->ei.opt_object_security_bad, \"Key ID flag is set but there are no remaining bytes to be processed\");\n\t\t\t}\n\t\t}\n\n\t\tproto_item_append_text(head_item, \": Key ID:%s, Key ID Context:%s, Partial IV:%s\",\n\t\t\t\t coinfo->oscore_info->kid == NULL ? nullstr : bytes_to_str(wmem_packet_scope(), coinfo->oscore_info->kid, coinfo->oscore_info->kid_len),\n\t\t\t\t coinfo->oscore_info->kid_context == NULL ? nullstr : bytes_to_str(wmem_packet_scope(), coinfo->oscore_info->kid_context, coinfo->oscore_info->kid_context_len),\n\t\t\t\t coinfo->oscore_info->piv == NULL ? nullstr : bytes_to_str(wmem_packet_scope(), coinfo->oscore_info->piv, coinfo->oscore_info->piv_len));\n\t}\n}", "target": 2, "idx": 10162}
{"commit_id": "6d24a51b94beb1991cddce221f90b455e2d50db7", "project": "vim", "func": "static void\nqf_jump_newwin(qf_info_T\t*qi,\n\tint\t\tdir,\n\tint\t\terrornr,\n\tint\t\tforceit,\n\tint\t\tnewwin)\n{\n    qf_list_T\t\t*qfl;\n    qfline_T\t\t*qf_ptr;\n    qfline_T\t\t*old_qf_ptr;\n    int\t\t\tqf_index;\n    int\t\t\told_qf_index;\n    char_u\t\t*old_swb = p_swb;\n    unsigned\t\told_swb_flags = swb_flags;\n    int\t\t\tprev_winid;\n    int\t\t\topened_window = FALSE;\n    int\t\t\tprint_message = TRUE;\n    int\t\t\told_KeyTyped = KeyTyped; // getting file may reset it\n    int\t\t\tretval = OK;\n\n    if (qi == NULL)\n\tqi = &ql_info;\n\n    if (qf_stack_empty(qi) || qf_list_empty(qf_get_curlist(qi)))\n    {\n\temsg(_(e_no_errors));\n\treturn;\n    }\n\n    incr_quickfix_busy();\n\n    qfl = qf_get_curlist(qi);\n\n    qf_ptr = qfl->qf_ptr;\n    old_qf_ptr = qf_ptr;\n    qf_index = qfl->qf_index;\n    old_qf_index = qf_index;\n\n    qf_ptr = qf_get_entry(qfl, errornr, dir, &qf_index);\n    if (qf_ptr == NULL)\n    {\n\tqf_ptr = old_qf_ptr;\n\tqf_index = old_qf_index;\n\tgoto theend;\n    }\n\n    qfl->qf_index = qf_index;\n    qfl->qf_ptr = qf_ptr;\n    if (qf_win_pos_update(qi, old_qf_index))\n\t// No need to print the error message if it's visible in the error\n\t// window\n\tprint_message = FALSE;\n\n    prev_winid = curwin->w_id;\n\n    retval = qf_jump_open_window(qi, qf_ptr, newwin, &opened_window);\n    if (retval == FAIL)\n\tgoto failed;\n    if (retval == QF_ABORT)\n    {\n\tqi = NULL;\n\tqf_ptr = NULL;\n\tgoto theend;\n    }\n    if (retval == NOTDONE)\n\tgoto theend;\n\n    retval = qf_jump_to_buffer(qi, qf_index, qf_ptr, forceit, prev_winid,\n\t\t\t\t  &opened_window, old_KeyTyped, print_message);\n    if (retval == QF_ABORT)\n    {\n\t// Quickfix/location list was modified by an autocmd\n\tqi = NULL;\n\tqf_ptr = NULL;\n    }\n\n    if (retval != OK)\n    {\n\tif (opened_window)\n\t    win_close(curwin, TRUE);    // Close opened window\n\tif (qf_ptr != NULL && qf_ptr->qf_fnum != 0)\n\t{\n\t    // Couldn't open file, so put index back where it was.  This could\n\t    // happen if the file was readonly and we changed something.\nfailed:\n\t    qf_ptr = old_qf_ptr;\n\t    qf_index = old_qf_index;\n\t}\n    }\ntheend:\n    if (qi != NULL)\n    {\n\tqfl->qf_ptr = qf_ptr;\n\tqfl->qf_index = qf_index;\n    }\n    if (p_swb != old_swb && p_swb == empty_option)\n    {\n\t// Restore old 'switchbuf' value, but not when an autocommand or\n\t// modeline has changed the value.\n\tp_swb = old_swb;\n\tswb_flags = old_swb_flags;\n    }\n    decr_quickfix_busy();\n}", "target": 2, "idx": 10163}
{"commit_id": "9da202f7f4bc80b6975909b684bbc0764a31c4e9", "project": "brave/brave-core", "func": "WebUIFactoryFunction GetWebUIFactoryFunction(WebUI* web_ui,\n                                             Profile* profile,\n                                             const GURL& url) {\n  // This will get called a lot to check all URLs, so do a quick check of other\n  // schemes to filter out most URLs.\n  //\n  // This has a narrow scoper scope than content::HasWebUIScheme(url) which also\n  // allows both `chrome-untrusted` and `chrome-devtools`.\n  if (!url.SchemeIs(content::kBraveUIScheme) &&\n      !url.SchemeIs(content::kChromeUIScheme)) {\n    return nullptr;\n  }\n\n  if (url.host_piece() == kAdblockHost ||\n      url.host_piece() == kAdblockInternalsHost ||\n      url.host_piece() == kWebcompatReporterHost ||\n      (url.host_piece() == kSkusInternalsHost &&\n       base::FeatureList::IsEnabled(skus::features::kSkusFeature)) ||\n#if BUILDFLAG(ENABLE_IPFS_INTERNALS_WEBUI)\n      (url.host_piece() == kIPFSWebUIHost &&\n       ipfs::IpfsServiceFactory::IsIpfsEnabled(profile)) ||\n#endif  // BUILDFLAG(ENABLE_IPFS_INTERNALS_WEBUI)\n#if BUILDFLAG(IS_ANDROID)\n      (url.is_valid() && url.host_piece() == kWalletPageHost &&\n       (url.path() == kWalletSwapPagePath ||\n        url.path() == kWalletSendPagePath || url.path() == kWalletBuyPagePath ||\n        url.path() == kWalletDepositPagePath)) ||\n#else\n      (base::FeatureList::IsEnabled(\n           brave_news::features::kBraveNewsFeedUpdate) &&\n       url.host_piece() == kBraveNewsInternalsHost) ||\n      ((url.host_piece() == kWalletPanelHost ||\n        url.host_piece() == kWalletPageHost) &&\n       brave_wallet::IsAllowedForContext(profile)) ||\n      url.host_piece() == kBraveRewardsPanelHost ||\n      url.host_piece() == kBraveTipPanelHost ||\n      url.host_piece() == kSpeedreaderPanelHost ||\n      // On Android New Tab is a native page implemented in Java, so no need in\n      // WebUI.\n      url.host_piece() == chrome::kChromeUINewTabHost ||\n      url.host_piece() == chrome::kChromeUISettingsHost ||\n      ((url.host_piece() == kWelcomeHost ||\n        url.host_piece() == chrome::kChromeUIWelcomeURL) &&\n       !profile->IsGuestSession()) ||\n      url.host_piece() == kShieldsPanelHost ||\n      (url.host_piece() == kCookieListOptInHost &&\n       base::FeatureList::IsEnabled(\n           brave_shields::features::kBraveAdblockCookieListOptIn)) ||\n#endif  // BUILDFLAG(IS_ANDROID)\n#if BUILDFLAG(ENABLE_TOR)\n      url.host_piece() == kTorInternalsHost ||\n#endif\n      url.host_piece() == kRewardsPageHost ||\n      url.host_piece() == kRewardsInternalsHost) {\n    return &NewWebUI;\n  }\n\n  return nullptr;\n}", "target": 1, "idx": 10164}
{"commit_id": "77e70d351db7de07a46ac49b87a6c3c7a60fca7e", "project": "torvalds/linux", "func": "static void sunkbd_enable(struct sunkbd *sunkbd, bool enable)\n{\n\tserio_pause_rx(sunkbd->serio);\n\tsunkbd->enabled = enable;\n\tserio_continue_rx(sunkbd->serio);\n\n\tif (!enable) {\n\t\twake_up_interruptible(&sunkbd->wait);\n\t\tcancel_work_sync(&sunkbd->tq);\n\t}\n}", "target": 2, "idx": 10165}
{"commit_id": "96db9023b881d7cd9f379b0c154650d6c108e9a3", "project": "openssl", "func": "int\ndtls1_process_heartbeat(SSL *s)\n\t{\n\tunsigned char *p = &s->s3->rrec.data[0], *pl;\n\tunsigned short hbtype;\n\tunsigned int payload;\n\tunsigned int padding = 16; /* Use minimum padding */\n\n\tif (s->msg_callback)\n\t\ts->msg_callback(0, s->version, TLS1_RT_HEARTBEAT,\n\t\t\t&s->s3->rrec.data[0], s->s3->rrec.length,\n\t\t\ts, s->msg_callback_arg);\n\n\t/* Read type and payload length first */\n\tif (1 + 2 + 16 > s->s3->rrec.length)\n\t\treturn 0; /* silently discard */\n\thbtype = *p++;\n\tn2s(p, payload);\n\tif (1 + 2 + payload + 16 > s->s3->rrec.length)\n\t\treturn 0; /* silently discard per RFC 6520 sec. 4 */\n\tpl = p;\n\n\tif (hbtype == TLS1_HB_REQUEST)\n\t\t{\n\t\tunsigned char *buffer, *bp;\n\t\tunsigned int write_length = 1 /* heartbeat type */ +\n\t\t\t\t\t    2 /* heartbeat length */ +\n\t\t\t\t\t    payload + padding;\n\t\tint r;\n\n\t\tif (write_length > SSL3_RT_MAX_PLAIN_LENGTH)\n\t\t\treturn 0;\n\n\t\t/* Allocate memory for the response, size is 1 byte\n\t\t * message type, plus 2 bytes payload length, plus\n\t\t * payload, plus padding\n\t\t */\n\t\tbuffer = OPENSSL_malloc(write_length);\n\t\tbp = buffer;\n\n\t\t/* Enter response type, length and copy payload */\n\t\t*bp++ = TLS1_HB_RESPONSE;\n\t\ts2n(payload, bp);\n\t\tmemcpy(bp, pl, payload);\n\t\tbp += payload;\n\t\t/* Random padding */\n\t\tRAND_pseudo_bytes(bp, padding);\n\n\t\tr = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, write_length);\n\n\t\tif (r >= 0 && s->msg_callback)\n\t\t\ts->msg_callback(1, s->version, TLS1_RT_HEARTBEAT,\n\t\t\t\tbuffer, write_length,\n\t\t\t\ts, s->msg_callback_arg);\n\n\t\tOPENSSL_free(buffer);\n\n\t\tif (r < 0)\n\t\t\treturn r;\n\t\t}\n\telse if (hbtype == TLS1_HB_RESPONSE)\n\t\t{\n\t\tunsigned int seq;\n\n\t\t/* We only send sequence numbers (2 bytes unsigned int),\n\t\t * and 16 random bytes, so we just try to read the\n\t\t * sequence number */\n\t\tn2s(pl, seq);\n\n\t\tif (payload == 18 && seq == s->tlsext_hb_seq)\n\t\t\t{\n\t\t\tdtls1_stop_timer(s);\n\t\t\ts->tlsext_hb_seq++;\n\t\t\ts->tlsext_hb_pending = 0;\n\t\t\t}\n\t\t}\n\n\treturn 0;\n\t}", "target": 2, "idx": 10166}
{"commit_id": "e5feaf2c96a08390f89a72972b5f8b808ca34e79", "project": "mity/md4c", "func": "static int\nmd_is_named_entity_contents(MD_CTX* ctx, const CHAR* text, OFF beg, OFF max_end, OFF* p_end)\n{\n    OFF off = beg;\n\n    if(off < max_end  &&  ISALPHA_(text[off]))\n        off++;\n    else\n        return FALSE;\n\n    while(off < max_end  &&  ISALNUM_(text[off])  &&  off - beg <= 48)\n        off++;\n\n    if(2 <= off - beg  &&  off - beg <= 48) {\n        *p_end = off;\n        return TRUE;\n    } else {\n        return FALSE;\n    }\n}", "target": 3, "idx": 10167}
{"commit_id": "2b3a0909beff8963b390034c594e0b6be6a4e531", "project": "wireshark", "func": "static void\ndissect_rtmpt_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, rtmpt_conv_t *rconv, int cdir, guint32 seq, guint32 lastackseq)\n{\n        int     offset = 0;\n        int     remain;\n        int     want;\n\n        guint8  header_type;\n        int     basic_hlen;\n        int     message_hlen;\n\n        guint32 id;\n        guint32 ts     = 0;\n        guint32 tsd    = 0;\n        int     body_len;\n        guint8  cmd;\n        guint32 src;\n        int     chunk_size;\n        guint32 save_seq = 0;\n\n        rtmpt_frag_t   *tf;\n        rtmpt_id_t     *ti;\n        rtmpt_packet_t *tp;\n        tvbuff_t       *pktbuf;\n\n        remain = tvb_reported_length(tvb);\n        if (!remain)\n                return;\n\n        RTMPT_DEBUG(\"Segment: cdir=%d seq=%d-%d\\n\", cdir, seq, seq+remain-1);\n\n        if (pinfo->fd->flags.visited) {\n                /* Already done the work, so just dump the existing state */\n                wmem_stack_t *packets;\n\n                /* List all RTMP packets terminating in this TCP segment, from end to beginning */\n\n                packets = wmem_stack_new(wmem_packet_scope());\n                wmem_stack_push(packets, 0);\n\n                tp = (rtmpt_packet_t *)wmem_tree_lookup32_le(rconv->packets[cdir], seq+remain-1);\n                while (tp && tp->lastseq >= seq && tp->lastseq >= save_seq) {\n                        wmem_stack_push(packets, tp);\n                        save_seq = tp->lastseq+1; /* Ensure sequence is increasing */\n                        tp = (rtmpt_packet_t *)wmem_tree_lookup32_le(rconv->packets[cdir], tp->lastseq-1);\n                }\n\n                /* Dissect the generated list in reverse order (beginning to end) */\n\n                while ((tp=(rtmpt_packet_t *)wmem_stack_pop(packets)) != NULL) {\n                        if (tp->resident) {\n                                pktbuf = tvb_new_child_real_data(tvb, tp->data.p, tp->have, tp->have);\n                                add_new_data_source(pinfo, pktbuf, \"Unchunked RTMP\");\n                        } else {\n                                pktbuf = tvb_new_subset_length(tvb, tp->data.offset, tp->have);\n                        }\n                        dissect_rtmpt(pktbuf, pinfo, tree, rconv, cdir, tp);\n                }\n\n                return;\n        }\n\n        while (remain>0) {\n                tf = NULL;\n                ti = NULL;\n                tp = NULL;\n\n                /* Check for outstanding fragmented headers/chunks first */\n\n                if (offset == 0) {\n                        tf = (rtmpt_frag_t *)wmem_tree_lookup32_le(rconv->frags[cdir], seq+offset-1);\n\n                        if (tf) {\n                                /* May need to reassemble cross-TCP-segment fragments */\n                                RTMPT_DEBUG(\"  tf seq=%d lseq=%d h=%d l=%d\\n\", tf->seq, tf->lastseq, tf->have, tf->len);\n                                if (tf->have >= tf->len || seq+offset < tf->seq || seq+offset > tf->lastseq+tf->len-tf->have) {\n                                        tf = NULL;\n                                } else if (!tf->ishdr) {\n                                        ti = (rtmpt_id_t *)wmem_tree_lookup32(rconv->ids[cdir], tf->saved.id);\n                                        if (ti) {\n                                                tp = (rtmpt_packet_t *)wmem_tree_lookup32_le(ti->packets, seq+offset-1);\n                                        }\n                                        if (tp && tp->chunkwant) {\n                                                goto unchunk;\n                                        }\n                                        tf = NULL;\n                                        ti = NULL;\n                                        tp = NULL;\n                                }\n\n                                if (tf) {\n                                        /* The preceding segment contained an incomplete chunk header */\n\n                                        want = tf->len - tf->have;\n                                        if (remain<want)\n                                                want = remain;\n\n                                        tvb_memcpy(tvb, tf->saved.d+tf->have, offset, want);\n\n                                        id = tf->saved.d[0];\n                                        header_type = (id>>6) & 3;\n                                        basic_hlen = rtmpt_basic_header_length(id);\n\n                                        if ((header_type < 3) && (tf->have < (basic_hlen+3)) && (tf->have+want >= (basic_hlen+3))) {\n                                                if (pntoh24(tf->saved.d+basic_hlen) == 0xffffff) {\n                                                        tf->len += 4;\n                                                }\n                                        }\n\n                                        tf->have += want;\n                                        tf->lastseq = seq+want-1;\n                                        remain -= want;\n                                        offset += want;\n\n                                        if (tf->have < tf->len) {\n                                                return;\n                                        }\n                                }\n                        }\n                }\n\n                if (!tf) {\n                        /* No preceeding data, get header data starting at current position */\n                        id = tvb_get_guint8(tvb, offset);\n\n                        if (id == RTMPT_MAGIC && seq+offset == RTMPT_HANDSHAKE_OFFSET_1) {\n                                header_type = 4;\n                                basic_hlen = 1;\n                                message_hlen = 0;\n                                id = lastackseq == 1 ? RTMPT_TYPE_HANDSHAKE_1 : RTMPT_TYPE_HANDSHAKE_2;\n                        } else if (seq+offset == RTMPT_HANDSHAKE_OFFSET_2) {\n                                header_type = 4;\n                                basic_hlen = 0;\n                                message_hlen = 0;\n                                id = RTMPT_TYPE_HANDSHAKE_3;\n                        } else {\n                                header_type = (id>>6) & 3;\n                                basic_hlen = rtmpt_basic_header_length(id);\n                                message_hlen = rtmpt_message_header_length(id);\n\n                                if ((header_type < 3) && (remain >= (basic_hlen+3))) {\n                                        if (tvb_get_ntoh24(tvb, offset+basic_hlen) == 0xffffff) {\n                                                message_hlen += 4;\n                                        }\n                                }\n\n                                if (remain < (basic_hlen+message_hlen)) {\n                                        /* Ran out of packet mid-header, save and try again next time */\n                                        tf = wmem_new(wmem_file_scope(), rtmpt_frag_t);\n                                        tf->ishdr = 1;\n                                        tf->seq = seq + offset;\n                                        tf->lastseq = tf->seq + remain - 1;\n                                        tf->len = basic_hlen + message_hlen;\n                                        tvb_memcpy(tvb, tf->saved.d, offset, remain);\n                                        tf->have = remain;\n                                        wmem_tree_insert32(rconv->frags[cdir], seq+offset, tf);\n                                        return;\n                                }\n\n                                id = id & 0x3f;\n                                if (id == 0)\n                                        id = tvb_get_guint8(tvb, offset+1) + 64;\n                                else if (id == 1)\n                                        id = tvb_get_letohs(tvb, offset+1) + 64;\n                        }\n\n                } else {\n                        /* Use reassembled header data */\n                        id = tf->saved.d[0];\n                        header_type = (id>>6) & 3;\n                        basic_hlen = rtmpt_basic_header_length(id);\n                        message_hlen = tf->len - basic_hlen;\n\n                        id = id & 0x3f;\n                        if (id == 0)\n                                id = tf->saved.d[1] + 64;\n                        else if (id == 1)\n                                id = pletoh16(tf->saved.d+1) + 64;\n                }\n\n                /* Calculate header values, defaulting from previous packets with same id */\n\n                if (id <= RTMPT_ID_MAX)\n                        ti = (rtmpt_id_t *)wmem_tree_lookup32(rconv->ids[cdir], id);\n                if (ti)\n                        tp = (rtmpt_packet_t *)wmem_tree_lookup32_le(ti->packets, seq+offset-1);\n\n                if (header_type == 0)\n                        src = tf ? pntoh32(tf->saved.d+basic_hlen+7) : tvb_get_ntohl(tvb, offset+basic_hlen+7);\n                else if (ti)\n                        src = ti->src;\n                else src = 0;\n\n                if (header_type < 2)\n                        cmd = tf ? tf->saved.d[basic_hlen+6] : tvb_get_guint8(tvb, offset+basic_hlen+6);\n                else if (ti)\n                        cmd = ti->cmd;\n                else\n                        cmd = 0;\n\n                /* Calculate chunk_size now as a last-resort default payload length */\n                if (id > RTMPT_ID_MAX) {\n                        if (id == RTMPT_TYPE_HANDSHAKE_1)\n                                chunk_size = body_len = 1536;\n                        else if (id == RTMPT_TYPE_HANDSHAKE_2)\n                                chunk_size = body_len = 3072;\n                        else /* if (id == RTMPT_TYPE_HANDSHAKE_3) */\n                                chunk_size = body_len = 1536;\n                } else {\n                        chunk_size = GPOINTER_TO_INT(wmem_tree_lookup32_le(rconv->chunksize[cdir], seq+offset-1));\n                        if (!chunk_size)\n                                chunk_size = RTMPT_DEFAULT_CHUNK_SIZE;\n\n                        if (header_type < 2)\n                                body_len = tf ? pntoh24(tf->saved.d+basic_hlen+3) : tvb_get_ntoh24(tvb, offset+basic_hlen+3);\n                        else if (ti)\n                                body_len = ti->len;\n                        else\n                                body_len = chunk_size;\n\n                        if (body_len > (gint)rtmpt_max_packet_size) {\n                                return;\n                        }\n                }\n\n                if (!ti || !tp || header_type<3 || tp->have == tp->want || tp->chunkhave != tp->chunkwant) {\n                        /* Start a new packet if:\n                         *   no previous packet with same id\n                         *   not a short 1-byte header\n                         *   previous packet with same id was complete\n                         *   previous incomplete chunk not handled by fragment handler\n                         */\n                        RTMPT_DEBUG(\"New packet cdir=%d seq=%d ti=%p tp=%p header_type=%d header_len=%d id=%d tph=%d tpw=%d len=%d cs=%d\\n\",\n                                    cdir, seq+offset,\n                                    ti, tp, header_type, basic_hlen+message_hlen, id, tp?tp->have:0, tp?tp->want:0, body_len, chunk_size);\n\n                        if (!ti) {\n                                ti = wmem_new(wmem_file_scope(), rtmpt_id_t);\n                                ti->packets = wmem_tree_new(wmem_file_scope());\n                                ti->ts  = 0;\n                                ti->tsd = 0;\n                                wmem_tree_insert32(rconv->ids[cdir], id, ti);\n                        }\n\n                        if (header_type == 0) {\n                                ts = tf ? pntoh24(tf->saved.d+basic_hlen) : tvb_get_ntoh24(tvb, offset+basic_hlen);\n                                if (ts == 0xffffff) {\n                                        ts = tf ? pntoh32(tf->saved.d+basic_hlen+11) : tvb_get_ntohl(tvb, offset+basic_hlen+11);\n                                }\n                                tsd = ts - ti->ts;\n                        } else if (header_type < 3) {\n                                tsd = tf ? pntoh24(tf->saved.d+basic_hlen) : tvb_get_ntoh24(tvb, offset+basic_hlen);\n                                if (tsd == 0xffffff) {\n                                        ts  = tf ? pntoh32(tf->saved.d+basic_hlen+message_hlen-4) : tvb_get_ntohl(tvb, offset+basic_hlen+message_hlen-4);\n                                        tsd = ti->tsd; /* questionable */\n                                } else {\n                                        ts  = ti->ts + tsd;\n                                }\n                        } else {\n                                ts  = ti->ts + ti->tsd;\n                                tsd = ti->tsd;\n                        }\n\n                        /* create a new packet structure */\n                        tp             = wmem_new(wmem_file_scope(), rtmpt_packet_t);\n                        tp->seq        = tp->lastseq = tf ? tf->seq : seq+offset;\n                        tp->have       = 0;\n                        tp->want       = basic_hlen + message_hlen + body_len;\n                        tp->chunkwant  = 0;\n                        tp->chunkhave  = 0;\n                        tp->bhlen      = basic_hlen;\n                        tp->mhlen      = message_hlen;\n                        tp->fmt        = header_type;\n                        tp->id         = id;\n                        tp->ts         = ts;\n                        tp->len        = body_len;\n                        if (id > RTMPT_ID_MAX)\n                                tp->cmd = id;\n                        else\n                                tp->cmd = cmd & 0x7f;\n                        tp->src        = src;\n                        tp->txid       = 0;\n                        tp->isresponse = FALSE;\n                        tp->otherframe = 0;\n\n                        /* Save the header information for future defaulting needs */\n                        ti->ts  = ts;\n                        ti->tsd = tsd;\n                        ti->len = body_len;\n                        ti->cmd = cmd;\n                        ti->src = src;\n\n                        /* store against the id only until unchunking is complete */\n                        wmem_tree_insert32(ti->packets, tp->seq, tp);\n\n                        if (!tf && body_len <= chunk_size && tp->want <= remain) {\n                                /* The easy case - a whole packet contiguous and fully within this segment */\n                                tp->resident    = FALSE;\n                                tp->data.offset = offset;\n                                tp->lastseq     = seq+offset+tp->want-1;\n                                tp->have        = tp->want;\n\n                                wmem_tree_insert32(rconv->packets[cdir], tp->lastseq, tp);\n\n                                pktbuf = tvb_new_subset_length(tvb, tp->data.offset, tp->have);\n                                dissect_rtmpt(pktbuf, pinfo, tree, rconv, cdir, tp);\n\n                                offset += tp->want;\n                                remain -= tp->want;\n                                continue;\n\n                        } else {\n                                /* Some more reassembly required */\n                                tp->resident = TRUE;\n                                tp->data.p = (guint8 *)wmem_alloc(wmem_file_scope(), tp->bhlen+tp->mhlen+tp->len);\n\n                                if (tf && tf->ishdr) {\n                                        memcpy(tp->data.p, tf->saved.d, tf->len);\n                                } else {\n                                        tvb_memcpy(tvb, tp->data.p, offset, basic_hlen+message_hlen);\n                                        offset += basic_hlen + message_hlen;\n                                        remain -= basic_hlen + message_hlen;\n                                }\n\n                                tp->lastseq = seq+offset-1;\n                                tp->have = basic_hlen + message_hlen;\n\n                                if (tp->have == tp->want) {\n                                        wmem_tree_insert32(rconv->packets[cdir], tp->lastseq, tp);\n\n                                        pktbuf = tvb_new_child_real_data(tvb, tp->data.p, tp->have, tp->have);\n                                        add_new_data_source(pinfo, pktbuf, \"Unchunked RTMP\");\n                                        dissect_rtmpt(pktbuf, pinfo, tree, rconv, cdir, tp);\n                                        continue;\n                                }\n\n                                tp->chunkwant = chunk_size;\n                                if (tp->chunkwant > tp->want-tp->have)\n                                        tp->chunkwant = tp->want - tp->have;\n                        }\n                } else {\n                        RTMPT_DEBUG(\"Old packet cdir=%d seq=%d ti=%p tp=%p header_len=%d id=%d tph=%d tpw=%d len=%d cs=%d\\n\",\n                                    cdir, seq+offset,\n                                    ti, tp, basic_hlen+message_hlen, id, tp?tp->have:0, tp?tp->want:0, body_len, chunk_size);\n\n                        tp->chunkwant = chunk_size;\n                        if (tp->chunkwant > tp->want-tp->have)\n                                tp->chunkwant = tp->want - tp->have;\n\n                        offset += basic_hlen + message_hlen;\n                        remain -= basic_hlen + message_hlen;\n                }\n\n                tf = NULL;\n\n                /* Last case to deal with is unchunking the packet body */\n        unchunk:\n                want = tp->chunkwant - tp->chunkhave;\n                if (want > remain)\n                        want = remain;\n                RTMPT_DEBUG(\"  cw=%d ch=%d r=%d w=%d\\n\", tp->chunkwant, tp->chunkhave, remain, want);\n\n                tvb_memcpy(tvb, tp->data.p+tp->have, offset, want);\n\n                if (tf) {\n                        tf->have += want;\n                        tf->lastseq = seq+offset+want-1;\n                }\n                tp->lastseq = seq+offset+want-1;\n                tp->have += want;\n                tp->chunkhave += want;\n\n                offset += want;\n                remain -= want;\n\n                if (tp->chunkhave == tp->chunkwant) {\n                        /* Chunk is complete - wait for next header */\n                        tp->chunkhave = 0;\n                        tp->chunkwant = 0;\n                }\n\n                if (tp->have == tp->want) {\n                        /* Whole packet is complete */\n                        wmem_tree_insert32(rconv->packets[cdir], tp->lastseq, tp);\n\n                        pktbuf = tvb_new_child_real_data(tvb, tp->data.p, tp->have, tp->have);\n                        add_new_data_source(pinfo, pktbuf, \"Unchunked RTMP\");\n                        dissect_rtmpt(pktbuf, pinfo, tree, rconv, cdir, tp);\n                } else if (tp->chunkhave < tp->chunkwant) {\n                        /* Chunk is split across segment boundary */\n                        rtmpt_frag_t *tf2 = wmem_new(wmem_file_scope(), rtmpt_frag_t);\n                        tf2->ishdr    = 0;\n                        tf2->seq      = seq + offset - want;\n                        tf2->lastseq  = tf2->seq + remain - 1 + want;\n                        tf2->have     = tp->chunkhave;\n                        tf2->len      = tp->chunkwant;\n                        tf2->saved.id = tp->id;\n                        RTMPT_DEBUG(\"  inserting tf @ %d\\n\", seq+offset-want-1);\n                        wmem_tree_insert32(rconv->frags[cdir], seq+offset-want-1, tf2);\n                }\n        }\n}", "target": 2, "idx": 10168}
{"commit_id": "f5c7f5dfbaf0d2f7d946d0fe86f08e6bcb36ed0d", "project": "openssl", "func": "WORK_STATE ossl_statem_server_pre_work(SSL *s, WORK_STATE wst)\n{\n    OSSL_STATEM *st = &s->statem;\n\n    switch (st->hand_state) {\n    case TLS_ST_SW_HELLO_REQ:\n        s->shutdown = 0;\n        if (SSL_IS_DTLS(s))\n            dtls1_clear_sent_buffer(s);\n        break;\n\n    case DTLS_ST_SW_HELLO_VERIFY_REQUEST:\n        s->shutdown = 0;\n        if (SSL_IS_DTLS(s)) {\n            dtls1_clear_sent_buffer(s);\n            /* We don't buffer this message so don't use the timer */\n            st->use_timer = 0;\n        }\n        break;\n\n    case TLS_ST_SW_SRVR_HELLO:\n        if (SSL_IS_DTLS(s)) {\n            /*\n             * Messages we write from now on should be bufferred and\n             * retransmitted if necessary, so we need to use the timer now\n             */\n            st->use_timer = 1;\n        }\n        break;\n\n    case TLS_ST_SW_SRVR_DONE:\n#ifndef OPENSSL_NO_SCTP\n        if (SSL_IS_DTLS(s) && BIO_dgram_is_sctp(SSL_get_wbio(s)))\n            return dtls_wait_for_dry(s);\n#endif\n        return WORK_FINISHED_CONTINUE;\n\n    case TLS_ST_SW_SESSION_TICKET:\n        if (SSL_IS_DTLS(s)) {\n            /*\n             * We're into the last flight. We don't retransmit the last flight\n             * unless we need to, so we don't use the timer\n             */\n            st->use_timer = 0;\n        }\n        break;\n\n    case TLS_ST_SW_CHANGE:\n        s->session->cipher = s->s3->tmp.new_cipher;\n        if (!s->method->ssl3_enc->setup_key_block(s)) {\n            ossl_statem_set_error(s);\n            return WORK_ERROR;\n        }\n        if (SSL_IS_DTLS(s)) {\n            /*\n             * We're into the last flight. We don't retransmit the last flight\n             * unless we need to, so we don't use the timer. This might have\n             * already been set to 0 if we sent a NewSessionTicket message,\n             * but we'll set it again here in case we didn't.\n             */\n            st->use_timer = 0;\n        }\n        return WORK_FINISHED_CONTINUE;\n\n    case TLS_ST_OK:\n        return tls_finish_handshake(s, wst);\n\n    default:\n        /* No pre work to be done */\n        break;\n    }\n\n    return WORK_FINISHED_CONTINUE;\n}", "target": 2, "idx": 10169}
{"commit_id": "cb373ab6614c910407c5e5a93ab935144e62b037", "project": "saitoha/libsixel", "func": "SIXELAPI SIXELSTATUS\nsixel_dither_new(\n    sixel_dither_t    /* out */ **ppdither, /* dither object to be created */\n    int               /* in */  ncolors,    /* required colors */\n    sixel_allocator_t /* in */  *allocator) /* allocator, null if you use\n                                               default allocator */\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    size_t headsize;\n    size_t datasize;\n    size_t wholesize;\n    int quality_mode;\n\n    if (ppdither == NULL) {\n        sixel_helper_set_additional_message(\n            \"sixel_dither_new: ppdither is null.\");\n        status = SIXEL_BAD_ARGUMENT;\n        goto end;\n    }\n\n    if (allocator == NULL) {\n        status = sixel_allocator_new(&allocator, NULL, NULL, NULL, NULL);\n        if (SIXEL_FAILED(status)) {\n            *ppdither = NULL;\n            goto end;\n        }\n    } else {\n        sixel_allocator_ref(allocator);\n    }\n\n    if (ncolors < 0) {\n        ncolors = 256;\n        quality_mode = SIXEL_QUALITY_HIGHCOLOR;\n    } else {\n        if (ncolors > SIXEL_PALETTE_MAX) {\n            status = SIXEL_BAD_INPUT;\n            ncolors = 256;\n        } else if (ncolors < 1) {\n            status = SIXEL_BAD_INPUT;\n            sixel_helper_set_additional_message(\n                \"sixel_dither_new: palette colors must be more than 0\");\n            goto end;\n        }\n        quality_mode = SIXEL_QUALITY_LOW;\n    }\n    headsize = sizeof(sixel_dither_t);\n    datasize = (size_t)(ncolors * 3);\n    wholesize = headsize + datasize;\n\n    *ppdither = (sixel_dither_t *)sixel_allocator_malloc(allocator, wholesize);\n    if (*ppdither == NULL) {\n        sixel_allocator_unref(allocator);\n        sixel_helper_set_additional_message(\n            \"sixel_dither_new: sixel_allocator_malloc() failed.\");\n        status = SIXEL_BAD_ALLOCATION;\n        goto end;\n    }\n\n    (*ppdither)->ref = 1;\n    (*ppdither)->palette = (unsigned char*)(*ppdither + 1);\n    (*ppdither)->cachetable = NULL;\n    (*ppdither)->reqcolors = ncolors;\n    (*ppdither)->ncolors = ncolors;\n    (*ppdither)->origcolors = (-1);\n    (*ppdither)->keycolor = (-1);\n    (*ppdither)->optimized = 0;\n    (*ppdither)->optimize_palette = 0;\n    (*ppdither)->complexion = 1;\n    (*ppdither)->bodyonly = 0;\n    (*ppdither)->method_for_largest = SIXEL_LARGE_NORM;\n    (*ppdither)->method_for_rep = SIXEL_REP_CENTER_BOX;\n    (*ppdither)->method_for_diffuse = SIXEL_DIFFUSE_FS;\n    (*ppdither)->quality_mode = quality_mode;\n    (*ppdither)->pixelformat = SIXEL_PIXELFORMAT_RGB888;\n    (*ppdither)->allocator = allocator;\n\n    status = SIXEL_OK;\n\nend:\n    return status;\n}", "target": 1, "idx": 10170}
{"commit_id": "8d385b247bca40ece40c9279391054bc98934325", "project": "xen-project/xen", "func": "void evtchn_free(struct domain *d, struct evtchn *chn)\n{\n    /* Clear pending event to avoid unexpected behavior on re-bind. */\n    evtchn_port_clear_pending(d, chn);\n\n    if ( consumer_is_xen(chn) )\n        write_atomic(&d->xen_evtchns, d->xen_evtchns - 1);\n    write_atomic(&d->active_evtchns, d->active_evtchns - 1);\n\n    /* Reset binding to vcpu0 when the channel is freed. */\n    chn->state          = ECS_FREE;\n    chn->notify_vcpu_id = 0;\n    chn->xen_consumer   = 0;\n\n    xsm_evtchn_close_post(chn);\n}", "target": 2, "idx": 10171}
{"commit_id": "2232473733b7313d67de8836ea3b29eec6e8e285", "project": "GNOME/libxslt", "func": "static xmlNodePtr\nxsltCopyText(xsltTransformContextPtr ctxt, xmlNodePtr target,\n\t     xmlNodePtr cur, int interned)\n{\n    xmlNodePtr copy;\n\n    if ((cur->type != XML_TEXT_NODE) &&\n\t(cur->type != XML_CDATA_SECTION_NODE))\n\treturn(NULL);\n    if (cur->content == NULL)\n\treturn(NULL);\n\n#ifdef WITH_XSLT_DEBUG_PROCESS\n    if (cur->type == XML_CDATA_SECTION_NODE) {\n\tXSLT_TRACE(ctxt,XSLT_TRACE_COPY_TEXT,xsltGenericDebug(xsltGenericDebugContext,\n\t\t\t \"xsltCopyText: copy CDATA text %s\\n\",\n\t\t\t cur->content));\n    } else if (cur->name == xmlStringTextNoenc) {\n\tXSLT_TRACE(ctxt,XSLT_TRACE_COPY_TEXT,xsltGenericDebug(xsltGenericDebugContext,\n\t\t     \"xsltCopyText: copy unescaped text %s\\n\",\n\t\t\t cur->content));\n    } else {\n\tXSLT_TRACE(ctxt,XSLT_TRACE_COPY_TEXT,xsltGenericDebug(xsltGenericDebugContext,\n\t\t\t \"xsltCopyText: copy text %s\\n\",\n\t\t\t cur->content));\n    }\n#endif\n\n    /*\n    * Play save and reset the merging mechanism for every new\n    * target node.\n    */\n    if ((target == NULL) || (target->children == NULL)) {\n\tctxt->lasttext = NULL;\n    }\n\n    if ((ctxt->style->cdataSection != NULL) &&\n\t(ctxt->type == XSLT_OUTPUT_XML) &&\n\t(target != NULL) &&\n\t(target->type == XML_ELEMENT_NODE) &&\n\t(((target->ns == NULL) &&\n\t  (xmlHashLookup2(ctxt->style->cdataSection,\n\t\t          target->name, NULL) != NULL)) ||\n\t ((target->ns != NULL) &&\n\t  (xmlHashLookup2(ctxt->style->cdataSection,\n\t                  target->name, target->ns->href) != NULL))))\n    {\n\t/*\n\t* Process \"cdata-section-elements\".\n\t*/\n\t/*\n\t* OPTIMIZE TODO: xsltCopyText() is also used for attribute content.\n\t*/\n\t/*\n\t* TODO: Since this doesn't merge adjacent CDATA-section nodes,\n\t* we'll get: <![CDATA[x]]><!CDATA[y]]>.\n\t* TODO: Reported in #321505.\n\t*/\n\tif ((target->last != NULL) &&\n\t     (target->last->type == XML_CDATA_SECTION_NODE))\n\t{\n\t    /*\n\t    * Append to existing CDATA-section node.\n\t    */\n\t    copy = xsltAddTextString(ctxt, target->last, cur->content,\n\t\txmlStrlen(cur->content));\n\t    goto exit;\n\t} else {\n\t    unsigned int len;\n\n\t    len = xmlStrlen(cur->content);\n\t    copy = xmlNewCDataBlock(ctxt->output, cur->content, len);\n\t    if (copy == NULL)\n\t\tgoto exit;\n\t    ctxt->lasttext = copy->content;\n\t    ctxt->lasttsize = len;\n\t    ctxt->lasttuse = len;\n\t}\n    } else if ((target != NULL) &&\n\t(target->last != NULL) &&\n\t/* both escaped or both non-escaped text-nodes */\n\t(((target->last->type == XML_TEXT_NODE) &&\n\t(target->last->name == cur->name)) ||\n        /* non-escaped text nodes and CDATA-section nodes */\n\t(((target->last->type == XML_CDATA_SECTION_NODE) &&\n\t(cur->name == xmlStringTextNoenc)))))\n    {\n\t/*\n\t * we are appending to an existing text node\n\t */\n\tcopy = xsltAddTextString(ctxt, target->last, cur->content,\n\t    xmlStrlen(cur->content));\n\tgoto exit;\n    } else if ((interned) && (target != NULL) &&\n\t(target->doc != NULL) &&\n\t(target->doc->dict == ctxt->dict))\n    {\n\t/*\n\t* TODO: DO we want to use this also for \"text\" output?\n\t*/\n        copy = xmlNewTextLen(NULL, 0);\n\tif (copy == NULL)\n\t    goto exit;\n\tif (cur->name == xmlStringTextNoenc)\n\t    copy->name = xmlStringTextNoenc;\n\n\t/*\n\t * Must confirm that content is in dict (bug 302821)\n\t * TODO: This check should be not needed for text coming\n\t * from the stylesheets\n\t */\n\tif (xmlDictOwns(ctxt->dict, cur->content))\n\t    copy->content = cur->content;\n\telse {\n\t    if ((copy->content = xmlStrdup(cur->content)) == NULL)\n\t\treturn NULL;\n\t}\n\n\tctxt->lasttext = NULL;\n    } else {\n        /*\n\t * normal processing. keep counters to extend the text node\n\t * in xsltAddTextString if needed.\n\t */\n        unsigned int len;\n\n\tlen = xmlStrlen(cur->content);\n\tcopy = xmlNewTextLen(cur->content, len);\n\tif (copy == NULL)\n\t    goto exit;\n\tif (cur->name == xmlStringTextNoenc)\n\t    copy->name = xmlStringTextNoenc;\n\tctxt->lasttext = copy->content;\n\tctxt->lasttsize = len;\n\tctxt->lasttuse = len;\n    }\n    if (copy != NULL) {\n\tif (target != NULL) {\n\t    copy->doc = target->doc;\n\t    /*\n\t    * MAYBE TODO: Maybe we should reset the ctxt->lasttext here\n\t    *  to ensure that the optimized text-merging mechanism\n\t    *  won't interfere with normal node-merging in any case.\n\t    */\n\t    copy = xsltAddChild(target, copy);\n\t}\n    } else {\n\txsltTransformError(ctxt, NULL, target,\n\t\t\t \"xsltCopyText: text copy failed\\n\");\n    }\n\nexit:\n    if ((copy == NULL) || (copy->content == NULL)) {\n\txsltTransformError(ctxt, NULL, target,\n\t    \"Internal error in xsltCopyText(): \"\n\t    \"Failed to copy the string.\\n\");\n\tctxt->state = XSLT_STATE_STOPPED;\n    }\n    return(copy);\n}", "target": 2, "idx": 10172}
{"commit_id": "cf54ebff3b7361989712fd9c0128a9b255578163", "project": "binutils-gdb", "func": "bfd_boolean\n_bfd_elf_parse_gnu_properties (bfd *abfd, Elf_Internal_Note *note)\n{\n  const struct elf_backend_data *bed = get_elf_backend_data (abfd);\n  unsigned int align_size = bed->s->elfclass == ELFCLASS64 ? 8 : 4;\n  bfd_byte *ptr = (bfd_byte *) note->descdata;\n  bfd_byte *ptr_end = ptr + note->descsz;\n\n  if (note->descsz < 8 || (note->descsz % align_size) != 0)\n    {\nbad_size:\n      _bfd_error_handler\n\t(_(\"warning: %B: corrupt GNU_PROPERTY_TYPE (%ld) size: %#lx\"),\n\t abfd, note->type, note->descsz);\n      return FALSE;\n    }\n\n  while (ptr != ptr_end)\n    {\n      unsigned int type;\n      unsigned int datasz;\n      elf_property *prop;\n\n      if ((size_t) (ptr_end - ptr) < 8)\n\tgoto bad_size;\n\n      type = bfd_h_get_32 (abfd, ptr);\n      datasz = bfd_h_get_32 (abfd, ptr + 4);\n      ptr += 8;\n\n      if (datasz > (size_t) (ptr_end - ptr))\n\t{\n\t  _bfd_error_handler\n\t    (_(\"warning: %B: corrupt GNU_PROPERTY_TYPE (%ld) type (0x%x) datasz: 0x%x\"),\n\t     abfd, note->type, type, datasz);\n\t  /* Clear all properties.  */\n\t  elf_properties (abfd) = NULL;\n\t  return FALSE;\n\t}\n\n      if (type >= GNU_PROPERTY_LOPROC)\n\t{\n\t  if (bed->elf_machine_code == EM_NONE)\n\t    {\n\t      /* Ignore processor-specific properties with generic ELF\n\t\t target vector.  They should be handled by the matching\n\t\t ELF target vector.  */\n\t      goto next;\n\t    }\n\t  else if (type < GNU_PROPERTY_LOUSER\n\t\t   && bed->parse_gnu_properties)\n\t    {\n\t      enum elf_property_kind kind\n\t\t= bed->parse_gnu_properties (abfd, type, ptr, datasz);\n\t      if (kind == property_corrupt)\n\t\t{\n\t\t  /* Clear all properties.  */\n\t\t  elf_properties (abfd) = NULL;\n\t\t  return FALSE;\n\t\t}\n\t      else if (kind != property_ignored)\n\t\tgoto next;\n\t    }\n\t}\n      else\n\t{\n\t  switch (type)\n\t    {\n\t    case GNU_PROPERTY_STACK_SIZE:\n\t      if (datasz != align_size)\n\t\t{\n\t\t  _bfd_error_handler\n\t\t    (_(\"warning: %B: corrupt stack size: 0x%x\"),\n\t\t     abfd, datasz);\n\t\t  /* Clear all properties.  */\n\t\t  elf_properties (abfd) = NULL;\n\t\t  return FALSE;\n\t\t}\n\t      prop = _bfd_elf_get_property (abfd, type, datasz);\n\t      if (datasz == 8)\n\t\tprop->u.number = bfd_h_get_64 (abfd, ptr);\n\t      else\n\t\tprop->u.number = bfd_h_get_32 (abfd, ptr);\n\t      prop->pr_kind = property_number;\n\t      goto next;\n\n\t    case GNU_PROPERTY_NO_COPY_ON_PROTECTED:\n\t      if (datasz != 0)\n\t\t{\n\t\t  _bfd_error_handler\n\t\t    (_(\"warning: %B: corrupt no copy on protected size: 0x%x\"),\n\t\t     abfd, datasz);\n\t\t  /* Clear all properties.  */\n\t\t  elf_properties (abfd) = NULL;\n\t\t  return FALSE;\n\t\t}\n\t      prop = _bfd_elf_get_property (abfd, type, datasz);\n\t      elf_has_no_copy_on_protected (abfd) = TRUE;\n\t      prop->pr_kind = property_number;\n\t      goto next;\n\n\t    default:\n\t      break;\n\t    }\n\t}\n\n      _bfd_error_handler\n\t(_(\"warning: %B: unsupported GNU_PROPERTY_TYPE (%ld) type: 0x%x\"),\n\t abfd, note->type, type);\n\nnext:\n      ptr += (datasz + (align_size - 1)) & ~ (align_size - 1);\n    }\n\n  return TRUE;\n}", "target": 2, "idx": 10173}
{"commit_id": "c2426bba00a01de6913738df8fa78e0215fcce02", "project": "tensorflow", "func": "int64_t TensorByteSize(const TensorProto& t) {\n  // num_elements returns -1 if shape is not fully defined.\n  int64_t num_elems = PartialTensorShape(t.tensor_shape()).num_elements();\n  return num_elems < 0 ? -1 : num_elems * DataTypeSize(t.dtype());\n}", "target": 1, "idx": 10174}
{"commit_id": "21998a351512eba4ed5969006f0c55882d995ada", "project": "torvalds/linux", "func": "static int ib_prctl_get(struct task_struct *task)\n{\n\tif (!boot_cpu_has_bug(X86_BUG_SPECTRE_V2))\n\t\treturn PR_SPEC_NOT_AFFECTED;\n\n\tif (spectre_v2_user_ibpb == SPECTRE_V2_USER_NONE &&\n\t    spectre_v2_user_stibp == SPECTRE_V2_USER_NONE)\n\t\treturn PR_SPEC_ENABLE;\n\telse if (spectre_v2_user_ibpb == SPECTRE_V2_USER_STRICT ||\n\t    spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT ||\n\t    spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT_PREFERRED)\n\t\treturn PR_SPEC_DISABLE;\n\telse if (spectre_v2_user_ibpb == SPECTRE_V2_USER_PRCTL ||\n\t    spectre_v2_user_ibpb == SPECTRE_V2_USER_SECCOMP ||\n\t    spectre_v2_user_stibp == SPECTRE_V2_USER_PRCTL ||\n\t    spectre_v2_user_stibp == SPECTRE_V2_USER_SECCOMP) {\n\t\tif (task_spec_ib_force_disable(task))\n\t\t\treturn PR_SPEC_PRCTL | PR_SPEC_FORCE_DISABLE;\n\t\tif (task_spec_ib_disable(task))\n\t\t\treturn PR_SPEC_PRCTL | PR_SPEC_DISABLE;\n\t\treturn PR_SPEC_PRCTL | PR_SPEC_ENABLE;\n\t} else\n\t\treturn PR_SPEC_NOT_AFFECTED;\n}", "target": 1, "idx": 10175}
{"commit_id": "9b46d38dd3c4de6048a488b655c7319f845af185", "project": "radareorg/radare2", "func": "static int parseOperand(RAsm *a, const char *str, Operand *op, bool isrepop) {\n\tsize_t pos, nextpos = 0;\n\tx86newTokenType last_type;\n\tint size_token = 1;\n\tbool explicit_size = false;\n\tint reg_index = 0;\n\t// Reset type\n\top->type = 0;\n\t// Consume tokens denoting the operand size\n\twhile (size_token) {\n\t\tpos = nextpos;\n\t\tlast_type = getToken (str, &pos, &nextpos);\n\n\t\t// Token may indicate size: then skip\n\t\tif (!r_str_ncasecmp (str + pos, \"ptr\", 3)) {\n\t\t\tcontinue;\n\t\t} else if (!r_str_ncasecmp (str + pos, \"byte\", 4)) {\n\t\t\top->type |= OT_MEMORY | OT_BYTE;\n\t\t\top->dest_size = OT_BYTE;\n\t\t\texplicit_size = true;\n\t\t} else if (!r_str_ncasecmp (str + pos, \"word\", 4)) {\n\t\t\top->type |= OT_MEMORY | OT_WORD;\n\t\t\top->dest_size = OT_WORD;\n\t\t\texplicit_size = true;\n\t\t} else if (!r_str_ncasecmp (str + pos, \"dword\", 5)) {\n\t\t\top->type |= OT_MEMORY | OT_DWORD;\n\t\t\top->dest_size = OT_DWORD;\n\t\t\texplicit_size = true;\n\t\t} else if (!r_str_ncasecmp (str + pos, \"qword\", 5)) {\n\t\t\top->type |= OT_MEMORY | OT_QWORD;\n\t\t\top->dest_size = OT_QWORD;\n\t\t\texplicit_size = true;\n\t\t} else if (!r_str_ncasecmp (str + pos, \"oword\", 5)) {\n\t\t\top->type |= OT_MEMORY | OT_OWORD;\n\t\t\top->dest_size = OT_OWORD;\n\t\t\texplicit_size = true;\n\t\t} else if (!r_str_ncasecmp (str + pos, \"tbyte\", 5)) {\n\t\t\top->type |= OT_MEMORY | OT_TBYTE;\n\t\t\top->dest_size = OT_TBYTE;\n\t\t\texplicit_size = true;\n\t\t} else { // the current token doesn't denote a size\n\t\t\tsize_token = 0;\n\t\t}\n\t}\n\n\t// Next token: register, immediate, or '['\n\tif (str[pos] == '[') {\n\t\t// Don't care about size, if none is given.\n\t\tif (!op->type) {\n\t\t\top->type = OT_MEMORY;\n\t\t}\n\t\t// At the moment, we only accept plain linear combinations:\n\t\t// part := address | [factor *] register\n\t\t// address := part {+ part}*\n\t\top->offset = op->scale[0] = op->scale[1] = 0;\n\n\t\tut64 temp = 1;\n\t\tRegister reg = X86R_UNDEFINED;\n\t\tbool first_reg = true;\n\t\twhile (str[pos] != ']') {\n\t\t\tif (pos > nextpos) {\n\t\t\t//\teprintf (\"Error parsing instruction\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpos = nextpos;\n\t\t\tif (!str[pos]) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlast_type = getToken (str, &pos, &nextpos);\n\n\t\t\tif (last_type == TT_SPECIAL) {\n\t\t\t\tif (str[pos] == '+' || str[pos] == '-' || str[pos] == ']') {\n\t\t\t\t\tif (reg != X86R_UNDEFINED) {\n\t\t\t\t\t\tif (reg_index < 2) {\n\t\t\t\t\t\t\top->regs[reg_index] = reg;\n\t\t\t\t\t\t\top->scale[reg_index] = temp;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t++reg_index;\n\t\t\t\t\t} else {\n\t\t\t\t\t\top->offset += temp;\n\t\t\t\t\t\tif (reg_index < 2) {\n\t\t\t\t\t\t\top->regs[reg_index] = X86R_UNDEFINED;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ttemp = 1;\n\t\t\t\t\treg = X86R_UNDEFINED;\n\t\t\t\t} else if (str[pos] == '*') {\n\t\t\t\t\t// go to ], + or - to get scale\n\n\t\t\t\t\t// Something to do here?\n\t\t\t\t\t// Seems we are just ignoring '*' or assuming it implicitly.\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (last_type == TT_WORD) {\n\t\t\t\tut32 reg_type = 0;\n\n\t\t\t\t// We can't multiply registers\n\t\t\t\tif (reg != X86R_UNDEFINED) {\n\t\t\t\t\top->type = 0;\t// Make the result invalid\n\t\t\t\t}\n\n\t\t\t\t// Reset nextpos: parseReg wants to parse from the beginning\n\t\t\t\tnextpos = pos;\n\t\t\t\treg = parseReg (a, str, &nextpos, &reg_type);\n\n\t\t\t\tif (first_reg) {\n\t\t\t\t\top->extended = false;\n\t\t\t\t\tif (reg > 8) {\n\t\t\t\t\t\top->extended = true;\n\t\t\t\t\t\top->reg = reg - 9;\n\t\t\t\t\t}\n\t\t\t\t\tfirst_reg = false;\n\t\t\t\t} else if (reg > 8) {\n\t\t\t\t\top->reg = reg - 9;\n\t\t\t\t}\n\t\t\t\tif (reg_type & OT_REGTYPE & OT_SEGMENTREG) {\n\t\t\t\t\top->reg = reg;\n\t\t\t\t\top->type = reg_type;\n\t\t\t\t\tparse_segment_offset (a, str, &nextpos, op, reg_index);\n\t\t\t\t\treturn nextpos;\n\t\t\t\t}\n\n\t\t\t\t// Still going to need to know the size if not specified\n\t\t\t\tif (!explicit_size) {\n\t\t\t\t\top->type |= reg_type;\n\t\t\t\t}\n\t\t\t\top->reg_size = reg_type;\n\t\t\t\top->explicit_size = explicit_size;\n\n\t\t\t\t// Addressing only via general purpose registers\n\t\t\t\tif (!(reg_type & OT_GPREG)) {\n\t\t\t\t\top->type = 0;\t// Make the result invalid\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tchar *p = strchr (str, '+');\n\t\t\t\top->offset_sign = 1;\n\t\t\t\tif (!p) {\n\t\t\t\t\tp = strchr (str, '-');\n\t\t\t\t\tif (p) {\n\t\t\t\t\t\top->offset_sign = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//with SIB notation, we need to consider the right sign\n\t\t\t\tchar * plus = strchr (str, '+');\n\t\t\t\tchar * minus = strchr (str, '-');\n\t\t\t\tchar * closeB = strchr (str, ']');\n\t\t\t\tif (plus && minus && plus < closeB && minus < closeB) {\n\t\t\t\t\top->offset_sign = -1;\n\t\t\t\t}\n\t\t\t\t// If there's a scale, we don't want to parse out the\n\t\t\t\t// scale with the offset (scale + offset) otherwise the scale\n\t\t\t\t// will be the sum of the two. This splits the numbers\n\t\t\t\tchar *tmp;\n\t\t\t\ttmp = malloc (strlen (str + pos) + 1);\n\t\t\t\tstrcpy (tmp, str + pos);\n\t\t\t\tstrtok (tmp, \"+-\");\n\t\t\t\tst64 read = getnum (a, tmp);\n\t\t\t\tfree (tmp);\n\t\t\t\ttemp *= read;\n\t\t\t}\n\t\t}\n\t} else if (last_type == TT_WORD) {   // register\n\t\tnextpos = pos;\n\t\tRFlagItem *flag;\n\n\t\tif (isrepop) {\n\t\t\top->is_good_flag = false;\n\t\t\tstrncpy (op->rep_op, str, MAX_REPOP_LENGTH - 1);\n\t\t\top->rep_op[MAX_REPOP_LENGTH - 1] = '\\0';\n\t\t\treturn nextpos;\n\t\t}\n\n\t\top->reg = parseReg (a, str, &nextpos, &op->type);\n\n\t\top->extended = false;\n\t\tif (op->reg > 8) {\n\t\t\top->extended = true;\n\t\t\top->reg -= 9;\n\t\t}\n\t\tif (op->type & OT_REGTYPE & OT_SEGMENTREG) {\n\t\t\tparse_segment_offset (a, str, &nextpos, op, reg_index);\n\t\t\treturn nextpos;\n\t\t}\n\t\tif (op->reg == X86R_UNDEFINED) {\n\t\t\top->is_good_flag = false;\n\t\t\tif (a->num && a->num->value == 0) {\n\t\t\t\treturn nextpos;\n\t\t\t}\n\t\t\top->type = OT_CONSTANT;\n\t\t\tRCore *core = a->num? (RCore *)(a->num->userptr): NULL;\n\t\t\tif (core && (flag = r_flag_get (core->flags, str))) {\n\t\t\t\top->is_good_flag = true;\n\t\t\t}\n\n\t\t\tchar *p = strchr (str, '-');\n\t\t\tif (p) {\n\t\t\t\top->sign = -1;\n\t\t\t\tstr = ++p;\n\t\t\t}\n\t\t\top->immediate = getnum (a, str);\n\t\t} else if (op->reg < X86R_UNDEFINED) {\n\t\t\tstrncpy (op->rep_op, str, MAX_REPOP_LENGTH - 1);\n\t\t\top->rep_op[MAX_REPOP_LENGTH - 1] = '\\0';\n\t\t}\n\t} else {                             // immediate\n\t\t// We don't know the size, so let's just set no size flag.\n\t\top->type = OT_CONSTANT;\n\t\top->sign = 1;\n\t\tchar *p = strchr (str, '-');\n\t\tif (p) {\n\t\t\top->sign = -1;\n\t\t\tstr = ++p;\n\t\t}\n\t\top->immediate = getnum (a, str);\n\t}\n\n\treturn nextpos;\n}", "target": 1, "idx": 10176}
{"commit_id": "e996e322ffd42aaa051602da182d03178d0f13e1", "project": "wget", "func": "uerr_t\nftp_loop (struct url *u, struct url *original_url, char **local_file, int *dt,\n          struct url *proxy, bool recursive, bool glob)\n{\n  ccon con;                     /* FTP connection */\n  uerr_t res;\n\n  *dt = 0;\n\n  xzero (con);\n\n  con.csock = -1;\n  con.st = ON_YOUR_OWN;\n  con.rs = ST_UNIX;\n  con.id = NULL;\n  con.proxy = proxy;\n\n  /* If the file name is empty, the user probably wants a directory\n     index.  We'll provide one, properly HTML-ized.  Unless\n     opt.htmlify is 0, of course.  :-) */\n  if (!*u->file && !recursive)\n    {\n      struct fileinfo *f;\n      res = ftp_get_listing (u, original_url, &con, &f);\n\n      if (res == RETROK)\n        {\n          if (opt.htmlify && !opt.spider)\n            {\n              struct url *url_file = opt.trustservernames ? u : original_url;\n              char *filename = (opt.output_document\n                                ? xstrdup (opt.output_document)\n                                : (con.target ? xstrdup (con.target)\n                                   : url_file_name (url_file, NULL)));\n              res = ftp_index (filename, u, f);\n              if (res == FTPOK && opt.verbose)\n                {\n                  if (!opt.output_document)\n                    {\n                      struct_stat st;\n                      wgint sz;\n                      if (stat (filename, &st) == 0)\n                        sz = st.st_size;\n                      else\n                        sz = -1;\n                      logprintf (LOG_NOTQUIET,\n                                 _(\"Wrote HTML-ized index to %s [%s].\\n\"),\n                                 quote (filename), number_to_static_string (sz));\n                    }\n                  else\n                    logprintf (LOG_NOTQUIET,\n                               _(\"Wrote HTML-ized index to %s.\\n\"),\n                               quote (filename));\n                }\n              xfree (filename);\n            }\n          freefileinfo (f);\n        }\n    }\n  else\n    {\n      bool ispattern = false;\n      if (glob)\n        {\n          /* Treat the URL as a pattern if the file name part of the\n             URL path contains wildcards.  (Don't check for u->file\n             because it is unescaped and therefore doesn't leave users\n             the option to escape literal '*' as %2A.)  */\n          char *file_part = strrchr (u->path, '/');\n          if (!file_part)\n            file_part = u->path;\n          ispattern = has_wildcards_p (file_part);\n        }\n      if (ispattern || recursive || opt.timestamping || opt.preserve_perm)\n        {\n          /* ftp_retrieve_glob is a catch-all function that gets called\n             if we need globbing, time-stamping, recursion or preserve\n             permissions.  Its third argument is just what we really need.  */\n          res = ftp_retrieve_glob (u, original_url, &con,\n                                   ispattern ? GLOB_GLOBALL : GLOB_GETONE);\n        }\n      else\n        {\n          res = ftp_loop_internal (u, original_url, NULL, &con, local_file, false);\n        }\n    }\n  if (res == FTPOK)\n    res = RETROK;\n  if (res == RETROK)\n    *dt |= RETROKF;\n  /* If a connection was left, quench it.  */\n  if (con.csock != -1)\n    fd_close (con.csock);\n  xfree (con.id);\n  xfree (con.target);\n  return res;\n}", "target": 2, "idx": 10177}
{"commit_id": "60bfb401ad5a4a8ae995dcd36372fe15c71e1a35", "project": "libgd", "func": "static inline LineContribType * _gdContributionsAlloc(unsigned int line_length, unsigned int windows_size)\n{\n\tunsigned int u = 0;\n\tLineContribType *res;\n\tsize_t weights_size;\n\n\tif (overflow2(windows_size, sizeof(double))) {\n\t\treturn NULL;\n\t} else {\n\t\tweights_size = windows_size * sizeof(double);\n\t}\n\tres = (LineContribType *) gdMalloc(sizeof(LineContribType));\n\tif (!res) {\n\t\treturn NULL;\n\t}\n\tres->WindowSize = windows_size;\n\tres->LineLength = line_length;\n\tif (overflow2(line_length, sizeof(ContributionType))) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tres->ContribRow = (ContributionType *) gdMalloc(line_length * sizeof(ContributionType));\n\tif (res->ContribRow == NULL) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tfor (u = 0 ; u < line_length ; u++) {\n\t\tres->ContribRow[u].Weights = (double *) gdMalloc(weights_size);\n\t\tif (res->ContribRow[u].Weights == NULL) {\n\t\t\tunsigned int i;\n\n\t\t\tfor (i=0;i<u;i++) {\n\t\t\t\tgdFree(res->ContribRow[i].Weights);\n\t\t\t}\n\t\t\tgdFree(res->ContribRow);\n\t\t\tgdFree(res);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn res;\n}", "target": 3, "idx": 10178}
{"commit_id": "6d202a0514fb6a406456b8b728cde776becb25f8", "project": "ImageMagick", "func": "static Image *ReadPDBImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  unsigned char\n    attributes,\n    tag[3];\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  PDBImage\n    pdb_image;\n\n  PDBInfo\n    pdb_info;\n\n  Quantum\n    index;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bits_per_pixel,\n    num_pad_bytes,\n    one,\n    packets;\n\n  ssize_t\n    count,\n    img_offset,\n    comment_offset = 0,\n    y;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Determine if this a PDB image file.\n  */\n  count=ReadBlob(image,sizeof(pdb_info.name),(unsigned char *) pdb_info.name);\n  if (count != sizeof(pdb_info.name))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  pdb_info.attributes=(short) ReadBlobMSBShort(image);\n  pdb_info.version=(short) ReadBlobMSBShort(image);\n  pdb_info.create_time=ReadBlobMSBLong(image);\n  pdb_info.modify_time=ReadBlobMSBLong(image);\n  pdb_info.archive_time=ReadBlobMSBLong(image);\n  pdb_info.modify_number=ReadBlobMSBLong(image);\n  pdb_info.application_info=ReadBlobMSBLong(image);\n  pdb_info.sort_info=ReadBlobMSBLong(image);\n  (void) ReadBlob(image,4,(unsigned char *) pdb_info.type);\n  (void) ReadBlob(image,4,(unsigned char *) pdb_info.id);\n  pdb_info.seed=ReadBlobMSBLong(image);\n  pdb_info.next_record=ReadBlobMSBLong(image);\n  pdb_info.number_records=(short) ReadBlobMSBShort(image);\n  if ((memcmp(pdb_info.type,\"vIMG\",4) != 0) ||\n      (memcmp(pdb_info.id,\"View\",4) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (pdb_info.next_record != 0)\n    ThrowReaderException(CoderError,\"MultipleRecordListNotSupported\");\n  /*\n    Read record header.\n  */\n  img_offset=(ssize_t) ((int) ReadBlobMSBLong(image));\n  attributes=(unsigned char) ReadBlobByte(image);\n  (void) attributes;\n  count=ReadBlob(image,3,(unsigned char *) tag);\n  if (count != 3  ||  memcmp(tag,\"\\x6f\\x80\\x00\",3) != 0)\n    ThrowReaderException(CorruptImageError,\"CorruptImage\");\n  if (pdb_info.number_records > 1)\n    {\n      comment_offset=(ssize_t) ((int) ReadBlobMSBLong(image));\n      attributes=(unsigned char) ReadBlobByte(image);\n      count=ReadBlob(image,3,(unsigned char *) tag);\n      if (count != 3  ||  memcmp(tag,\"\\x6f\\x80\\x01\",3) != 0)\n        ThrowReaderException(CorruptImageError,\"CorruptImage\");\n    }\n  num_pad_bytes = (size_t) (img_offset - TellBlob( image ));\n  while (num_pad_bytes-- != 0)\n  {\n    int\n      c;\n\n    c=ReadBlobByte(image);\n    if (c == EOF)\n      break;\n  }\n  /*\n    Read image header.\n  */\n  count=ReadBlob(image,sizeof(pdb_image.name),(unsigned char *) pdb_image.name);\n  if (count != sizeof(pdb_image.name))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  pdb_image.version=ReadBlobByte(image);\n  pdb_image.type=(unsigned char) ((int) ReadBlobByte(image));\n  pdb_image.reserved_1=ReadBlobMSBLong(image);\n  pdb_image.note=ReadBlobMSBLong(image);\n  pdb_image.x_last=(short) ReadBlobMSBShort(image);\n  pdb_image.y_last=(short) ReadBlobMSBShort(image);\n  pdb_image.reserved_2=ReadBlobMSBLong(image);\n  pdb_image.x_anchor=ReadBlobMSBShort(image);\n  pdb_image.y_anchor=ReadBlobMSBShort(image);\n  pdb_image.width=(short) ReadBlobMSBShort(image);\n  pdb_image.height=(short) ReadBlobMSBShort(image);\n  /*\n    Initialize image structure.\n  */\n  image->columns=(size_t) pdb_image.width;\n  image->rows=(size_t) pdb_image.height;\n  image->depth=8;\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  image->storage_class=PseudoClass;\n  bits_per_pixel=pdb_image.type == 0 ? 2UL : pdb_image.type == 2 ? 4UL : 1UL;\n  one=1;\n  if (AcquireImageColormap(image,one << bits_per_pixel,exception) == MagickFalse)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  packets=(bits_per_pixel*image->columns+7)/8;\n  pixels=(unsigned char *) AcquireQuantumMemory(packets+257UL,image->rows*\n    sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  switch (pdb_image.version & 0x07) \n  {\n    case 0:\n    {\n      image->compression=NoCompression;\n      count=(ssize_t) ReadBlob(image, packets * image -> rows, pixels);\n      break;\n    }\n    case 1:\n    {\n      image->compression=RLECompression;\n      if (!DecodeImage(image, pixels, packets * image -> rows))\n        ThrowReaderException( CorruptImageError, \"RLEDecoderError\" );\n      break;\n    }\n    default:\n      ThrowReaderException(CorruptImageError,\n         \"UnrecognizedImageCompressionType\" );\n  }\n  p=pixels;\n  switch (bits_per_pixel)\n  {\n    case 1:\n    {\n      int\n        bit;\n\n      /*\n        Read 1-bit PDB image.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n        {\n          for (bit=0; bit < 8; bit++)\n          {\n            index=(Quantum) (*p & (0x80 >> bit) ? 0x00 : 0x01);\n            SetPixelIndex(image,index,q);\n            q+=GetPixelChannels(image);\n          }\n          p++;\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n      (void) SyncImage(image,exception);\n      break;\n    }\n    case 2:\n    {\n      /*\n        Read 2-bit PDB image.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) image->columns-3; x+=4)\n        {\n          index=ConstrainColormapIndex(image,3UL-((*p >> 6) & 0x03),exception);\n          SetPixelIndex(image,index,q);\n          q+=GetPixelChannels(image);\n          index=ConstrainColormapIndex(image,3UL-((*p >> 4) & 0x03),exception);\n          SetPixelIndex(image,index,q);\n          q+=GetPixelChannels(image);\n          index=ConstrainColormapIndex(image,3UL-((*p >> 2) & 0x03),exception);\n          SetPixelIndex(image,index,q);\n          q+=GetPixelChannels(image);\n          index=ConstrainColormapIndex(image,3UL-((*p) & 0x03),exception);\n          SetPixelIndex(image,index,q);\n          p++;\n          q+=GetPixelChannels(image);\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n      (void) SyncImage(image,exception);\n      break;\n    }\n    case 4:\n    {\n      /*\n        Read 4-bit PDB image.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) image->columns-1; x+=2)\n        {\n          index=ConstrainColormapIndex(image,15UL-((*p >> 4) & 0x0f),exception);\n          SetPixelIndex(image,index,q);\n          q+=GetPixelChannels(image);\n          index=ConstrainColormapIndex(image,15UL-((*p) & 0x0f),exception);\n          SetPixelIndex(image,index,q);\n          p++;\n          q+=GetPixelChannels(image);\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n      (void) SyncImage(image,exception);\n      break;\n    }\n    default:\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  }\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  if (pdb_info.number_records > 1)\n    {\n      char\n        *comment;\n\n      int\n        c;\n\n      register char\n        *p;\n\n      size_t\n        length;\n\n      num_pad_bytes = (size_t) (comment_offset - TellBlob( image ));\n      while (num_pad_bytes--) ReadBlobByte( image );\n\n      /*\n        Read comment.\n      */\n      c=ReadBlobByte(image);\n      length=MagickPathExtent;\n      comment=AcquireString((char *) NULL);\n      for (p=comment; c != EOF; p++)\n      {\n        if ((size_t) (p-comment+MagickPathExtent) >= length)\n          {\n            *p='\\0';\n            length<<=1;\n            length+=MagickPathExtent;\n            comment=(char *) ResizeQuantumMemory(comment,length+MagickPathExtent,\n              sizeof(*comment));\n            if (comment == (char *) NULL)\n              break;\n            p=comment+strlen(comment);\n          }\n        *p=c;\n        c=ReadBlobByte(image);\n      }\n      *p='\\0';\n      if (comment == (char *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      (void) SetImageProperty(image,\"comment\",comment,exception);\n      comment=DestroyString(comment);\n    }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}", "target": 1, "idx": 10179}
{"commit_id": "2646e6c1558bac66285daeab54c7d490ed332b15", "project": "laverdet/isolated-vm", "func": "DeleteRunner(ReferenceHandle& that, Local<Value> key_handle) :\n\t\tAccessorRunner{that, key_handle} {}", "target": 2, "idx": 10180}
{"commit_id": "d8a0cbc4f2979e0b1cadbe79f0b8b4ecb92477be", "project": "wireshark", "func": "static guint32\ns7comm_decode_ud_cpu_alarm_main(tvbuff_t *tvb,\n                                packet_info *pinfo,\n                                proto_tree *data_tree,\n                                guint8 type,                /* Type of data (request/response) */\n                                guint8 subfunc,             /* Subfunction */\n                                guint32 offset)             /* Offset on data part +4 */\n{\n    guint32 start_offset;\n    guint32 asc_start_offset;\n    guint32 msg_obj_start_offset;\n    guint32 ev_id;\n    proto_item *msg_item = NULL;\n    proto_tree *msg_item_tree = NULL;\n    proto_item *msg_obj_item = NULL;\n    proto_tree *msg_obj_item_tree = NULL;\n    proto_item *msg_work_item = NULL;\n    proto_tree *msg_work_item_tree = NULL;\n    guint8 nr_objects;\n    guint8 i;\n    guint8 syntax_id;\n    guint8 nr_of_additional_values;\n    guint8 signalstate;\n    guint8 sig_nr;\n    guint8 ret_val;\n    guint8 querytype;\n    guint8 varspec_length;\n\n    start_offset = offset;\n\n    msg_item = proto_tree_add_item(data_tree, hf_s7comm_cpu_alarm_message_item, tvb, offset, 0, ENC_NA);\n    msg_item_tree = proto_item_add_subtree(msg_item, ett_s7comm_cpu_alarm_message);\n\n    if (subfunc == S7COMM_UD_SUBF_CPU_ALARM8_IND || subfunc == S7COMM_UD_SUBF_CPU_ALARMACK_IND ||\n        subfunc == S7COMM_UD_SUBF_CPU_ALARMSQ_IND || subfunc == S7COMM_UD_SUBF_CPU_ALARMS_IND ||\n        subfunc == S7COMM_UD_SUBF_CPU_NOTIFY_IND || subfunc == S7COMM_UD_SUBF_CPU_NOTIFY8_IND) {\n        msg_work_item = proto_tree_add_item(msg_item_tree, hf_s7comm_cpu_alarm_message_timestamp_coming, tvb, offset, 8, ENC_NA);\n        msg_work_item_tree = proto_item_add_subtree(msg_work_item, ett_s7comm_cpu_alarm_message_timestamp);\n        offset = s7comm_add_timestamp_to_tree(tvb, msg_work_item_tree, offset, TRUE, FALSE);\n    }\n    proto_tree_add_item(msg_item_tree, hf_s7comm_cpu_alarm_message_function, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset += 1;\n    nr_objects = tvb_get_guint8(tvb, offset);\n    proto_tree_add_uint(msg_item_tree, hf_s7comm_cpu_alarm_message_nr_objects, tvb, offset, 1, nr_objects);\n    offset += 1;\n    for (i = 0; i < nr_objects; i++) {\n        msg_obj_start_offset = offset;\n        msg_obj_item = proto_tree_add_item(msg_item_tree, hf_s7comm_cpu_alarm_message_obj_item, tvb, offset, 0, ENC_NA);\n        msg_obj_item_tree = proto_item_add_subtree(msg_obj_item, ett_s7comm_cpu_alarm_message_object);\n        proto_item_append_text(msg_obj_item_tree, \" [%d]\", i+1);\n        if (type == S7COMM_UD_TYPE_REQ || type == S7COMM_UD_TYPE_PUSH) {\n            proto_tree_add_item(msg_obj_item_tree, hf_s7comm_item_varspec, tvb, offset, 1, ENC_BIG_ENDIAN);\n            offset += 1;\n            varspec_length = tvb_get_guint8(tvb, offset);\n            proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_item_varspec_length, tvb, offset, 1, varspec_length);\n            offset += 1;\n            syntax_id = tvb_get_guint8(tvb, offset);\n            proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_item_syntax_id, tvb, offset, 1, syntax_id);\n            offset += 1;\n            switch (syntax_id) {\n                case S7COMM_SYNTAXID_ALARM_LOCKFREESET:\n                case S7COMM_SYNTAXID_ALARM_INDSET:\n                case S7COMM_SYNTAXID_NOTIFY_INDSET:\n                case S7COMM_SYNTAXID_ALARM_ACKSET:\n                    nr_of_additional_values = tvb_get_guint8(tvb, offset);\n                    proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_nr_add_values, tvb, offset, 1, nr_of_additional_values);\n                    offset += 1;\n                    ev_id = tvb_get_ntohl(tvb, offset);\n                    proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_eventid, tvb, offset, 4, ev_id);\n                    offset += 4;\n                    proto_item_append_text(msg_obj_item_tree, \": EventID=0x%08x\", ev_id);\n                    col_append_fstr(pinfo->cinfo, COL_INFO, \" EventID=0x%08x\", ev_id);\n                    if (syntax_id == S7COMM_SYNTAXID_ALARM_INDSET || syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) {\n                        signalstate = tvb_get_guint8(tvb, offset);\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_eventstate,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        /* show SIG with True values for a quick overview in info-column */\n                        if (signalstate > 0) {\n                            col_append_fstr(pinfo->cinfo, COL_INFO, \" On=[\");\n                            for (sig_nr = 0; sig_nr < 8; sig_nr++) {\n                                if (signalstate & 0x01) {\n                                    signalstate >>= 1;\n                                    if (signalstate == 0) {\n                                        col_append_fstr(pinfo->cinfo, COL_INFO, \"SIG_%d\", sig_nr + 1);\n                                    } else {\n                                        col_append_fstr(pinfo->cinfo, COL_INFO, \"SIG_%d,\", sig_nr + 1);\n                                    }\n                                } else {\n                                    signalstate >>= 1;\n                                }\n                            }\n                            col_append_fstr(pinfo->cinfo, COL_INFO, \"]\");\n                        }\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_state,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                    }\n                    if (syntax_id == S7COMM_SYNTAXID_ALARM_INDSET || syntax_id == S7COMM_SYNTAXID_ALARM_ACKSET || syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) {\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_ackstate_going,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_ackstate_coming,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                    }\n                    if (syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) {\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_event_going,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_event_coming,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_event_lastchanged,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_event_reserved, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        offset += 1;\n                    }\n                    if (syntax_id == S7COMM_SYNTAXID_ALARM_INDSET || syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) {\n                        if (nr_of_additional_values > 0) {\n                            asc_start_offset = offset;\n                            msg_work_item = proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_associated_value, tvb, offset, 0, ENC_NA);\n                            msg_work_item_tree = proto_item_add_subtree(msg_work_item, ett_s7comm_cpu_alarm_message_associated_value);\n                            offset = s7comm_decode_response_read_data(tvb, msg_work_item_tree, nr_of_additional_values, offset);\n                            proto_item_set_len(msg_work_item_tree, offset - asc_start_offset);\n                        }\n                    }\n                    break;\n                case S7COMM_SYNTAXID_ALARM_QUERYREQSET:\n                    proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_query_unknown1, tvb, offset, 1, ENC_BIG_ENDIAN);\n                    offset += 1;\n                    querytype = tvb_get_guint8(tvb, offset);\n                    proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_cpu_alarm_query_querytype, tvb, offset, 1, querytype);\n                    offset += 1;\n                    proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_query_unknown2, tvb, offset, 1, ENC_BIG_ENDIAN);\n                    offset += 1;\n                    ev_id = tvb_get_ntohl(tvb, offset);\n                    /* there is a querytype=8, which only occurs when a previous SZL request 0x131 index 0x10 has a missing flag in funk_1 */\n                    switch (querytype) {\n                        case S7COMM_ALARM_MESSAGE_QUERYTYPE_BYALARMTYPE:\n                            proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_query_alarmtype, tvb, offset, 4, ENC_BIG_ENDIAN);\n                            col_append_fstr(pinfo->cinfo, COL_INFO, \" ByAlarmtype=%s\",\n                                val_to_str(ev_id, alarm_message_query_alarmtype_names, \"Unknown Alarmtype: %u\"));\n                            break;\n                        case S7COMM_ALARM_MESSAGE_QUERYTYPE_BYEVENTID:\n                            proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_eventid, tvb, offset, 4, ENC_BIG_ENDIAN);\n                            col_append_fstr(pinfo->cinfo, COL_INFO, \" ByEventID=0x%08x\", ev_id);\n                            break;\n                        default:\n                            break;\n                    }\n                    offset += 4;\n                    break;\n                default:\n                    /* for current unknown syntax id, set offset to end of dataset. The varspec_length includes\n                     * the byte for the syntax_id, so minus one.\n                     */\n                    offset += (varspec_length - 1);\n                    break;\n            }\n        } else if (type == S7COMM_UD_TYPE_RES) {\n            ret_val = tvb_get_guint8(tvb, offset);\n            proto_item_append_text(msg_obj_item_tree, \": (%s)\", val_to_str(ret_val, s7comm_item_return_valuenames, \"Unknown code: 0x%02x\"));\n            proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_data_returncode, tvb, offset, 1, ret_val);\n            offset += 1;\n        }\n        proto_item_set_len(msg_obj_item_tree, offset - msg_obj_start_offset);\n    }\n    proto_item_set_len(msg_item_tree, offset - start_offset);\n    return offset;\n}", "target": 2, "idx": 10181}
{"commit_id": "94be770ef6d5e1091290e3af217a0fbd1ef1172e", "project": "nothings/stb", "func": "static int stbi__process_frame_header(stbi__jpeg *z, int scan)\n{\n   stbi__context *s = z->s;\n   int Lf,p,i,q, h_max=1,v_max=1,c;\n   Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err(\"bad SOF len\",\"Corrupt JPEG\"); // JPEG\n   p  = stbi__get8(s);            if (p != 8) return stbi__err(\"only 8-bit\",\"JPEG format not supported: 8-bit only\"); // JPEG baseline\n   s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err(\"no header height\", \"JPEG format not supported: delayed height\"); // Legal, but we don't handle it--but neither does IJG\n   s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err(\"0 width\",\"Corrupt JPEG\"); // JPEG requires\n   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err(\"too large\",\"Very large image (corrupt?)\");\n   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err(\"too large\",\"Very large image (corrupt?)\");\n   c = stbi__get8(s);\n   if (c != 3 && c != 1 && c != 4) return stbi__err(\"bad component count\",\"Corrupt JPEG\");\n   s->img_n = c;\n   for (i=0; i < c; ++i) {\n      z->img_comp[i].data = NULL;\n      z->img_comp[i].linebuf = NULL;\n   }\n\n   if (Lf != 8+3*s->img_n) return stbi__err(\"bad SOF len\",\"Corrupt JPEG\");\n\n   z->rgb = 0;\n   for (i=0; i < s->img_n; ++i) {\n      static const unsigned char rgb[3] = { 'R', 'G', 'B' };\n      z->img_comp[i].id = stbi__get8(s);\n      if (s->img_n == 3 && z->img_comp[i].id == rgb[i])\n         ++z->rgb;\n      q = stbi__get8(s);\n      z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err(\"bad H\",\"Corrupt JPEG\");\n      z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err(\"bad V\",\"Corrupt JPEG\");\n      z->img_comp[i].tq = stbi__get8(s);  if (z->img_comp[i].tq > 3) return stbi__err(\"bad TQ\",\"Corrupt JPEG\");\n   }\n\n   if (scan != STBI__SCAN_load) return 1;\n\n   if (!stbi__mad3sizes_valid(s->img_x, s->img_y, s->img_n, 0)) return stbi__err(\"too large\", \"Image too large to decode\");\n\n   for (i=0; i < s->img_n; ++i) {\n      if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;\n      if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;\n   }\n\n   // check that plane subsampling factors are integer ratios; our resamplers can't deal with fractional ratios\n   // and I've never seen a non-corrupted JPEG file actually use them\n   for (i=0; i < s->img_n; ++i) {\n      if (h_max % z->img_comp[i].h != 0) return stbi__err(\"bad H\",\"Corrupt JPEG\");\n      if (v_max % z->img_comp[i].v != 0) return stbi__err(\"bad V\",\"Corrupt JPEG\");\n   }\n\n   // compute interleaved mcu info\n   z->img_h_max = h_max;\n   z->img_v_max = v_max;\n   z->img_mcu_w = h_max * 8;\n   z->img_mcu_h = v_max * 8;\n   // these sizes can't be more than 17 bits\n   z->img_mcu_x = (s->img_x + z->img_mcu_w-1) / z->img_mcu_w;\n   z->img_mcu_y = (s->img_y + z->img_mcu_h-1) / z->img_mcu_h;\n\n   for (i=0; i < s->img_n; ++i) {\n      // number of effective pixels (e.g. for non-interleaved MCU)\n      z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max-1) / h_max;\n      z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max-1) / v_max;\n      // to simplify generation, we'll allocate enough memory to decode\n      // the bogus oversized data from using interleaved MCUs and their\n      // big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't\n      // discard the extra data until colorspace conversion\n      //\n      // img_mcu_x, img_mcu_y: <=17 bits; comp[i].h and .v are <=4 (checked earlier)\n      // so these muls can't overflow with 32-bit ints (which we require)\n      z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;\n      z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;\n      z->img_comp[i].coeff = 0;\n      z->img_comp[i].raw_coeff = 0;\n      z->img_comp[i].linebuf = NULL;\n      z->img_comp[i].raw_data = stbi__malloc_mad2(z->img_comp[i].w2, z->img_comp[i].h2, 15);\n      if (z->img_comp[i].raw_data == NULL)\n         return stbi__free_jpeg_components(z, i+1, stbi__err(\"outofmem\", \"Out of memory\"));\n      // align blocks for idct using mmx/sse\n      z->img_comp[i].data = (stbi_uc*) (((size_t) z->img_comp[i].raw_data + 15) & ~15);\n      if (z->progressive) {\n         // w2, h2 are multiples of 8 (see above)\n         z->img_comp[i].coeff_w = z->img_comp[i].w2 / 8;\n         z->img_comp[i].coeff_h = z->img_comp[i].h2 / 8;\n         z->img_comp[i].raw_coeff = stbi__malloc_mad3(z->img_comp[i].w2, z->img_comp[i].h2, sizeof(short), 15);\n         if (z->img_comp[i].raw_coeff == NULL)\n            return stbi__free_jpeg_components(z, i+1, stbi__err(\"outofmem\", \"Out of memory\"));\n         z->img_comp[i].coeff = (short*) (((size_t) z->img_comp[i].raw_coeff + 15) & ~15);\n      }\n   }\n\n   return 1;\n}", "target": 2, "idx": 10182}
{"commit_id": "79b59a2dfcb68897ee89d98587d09e55f07e68d7", "project": "torproject/tor", "func": "int\nconnection_exit_begin_conn(cell_t *cell, circuit_t *circ)\n{\n  edge_connection_t *n_stream;\n  relay_header_t rh;\n  char *address = NULL;\n  uint16_t port = 0;\n  or_circuit_t *or_circ = NULL;\n  origin_circuit_t *origin_circ = NULL;\n  crypt_path_t *layer_hint = NULL;\n  const or_options_t *options = get_options();\n  begin_cell_t bcell;\n  int rv;\n  uint8_t end_reason=0;\n\n  assert_circuit_ok(circ);\n  if (!CIRCUIT_IS_ORIGIN(circ)) {\n    or_circ = TO_OR_CIRCUIT(circ);\n  } else {\n    tor_assert(circ->purpose == CIRCUIT_PURPOSE_S_REND_JOINED);\n    origin_circ = TO_ORIGIN_CIRCUIT(circ);\n    layer_hint = origin_circ->cpath->prev;\n  }\n\n  relay_header_unpack(&rh, cell->payload);\n  if (rh.length > RELAY_PAYLOAD_SIZE)\n    return -END_CIRC_REASON_TORPROTOCOL;\n\n  /* Note: we have to use relay_send_command_from_edge here, not\n   * connection_edge_end or connection_edge_send_command, since those require\n   * that we have a stream connected to a circuit, and we don't connect to a\n   * circuit until we have a pending/successful resolve. */\n\n  if (!server_mode(options) &&\n      circ->purpose != CIRCUIT_PURPOSE_S_REND_JOINED) {\n    log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n           \"Relay begin cell at non-server. Closing.\");\n    relay_send_end_cell_from_edge(rh.stream_id, circ,\n                                  END_STREAM_REASON_EXITPOLICY, NULL);\n    return 0;\n  }\n\n  rv = begin_cell_parse(cell, &bcell, &end_reason);\n  if (rv < -1) {\n    return -END_CIRC_REASON_TORPROTOCOL;\n  } else if (rv == -1) {\n    tor_free(bcell.address);\n    relay_send_end_cell_from_edge(rh.stream_id, circ, end_reason, layer_hint);\n    return 0;\n  }\n\n  if (! bcell.is_begindir) {\n    /* Steal reference */\n    address = bcell.address;\n    port = bcell.port;\n\n    if (or_circ && or_circ->p_chan) {\n      if (!options->AllowSingleHopExits &&\n           (or_circ->is_first_hop ||\n            (!connection_or_digest_is_known_relay(\n                or_circ->p_chan->identity_digest) &&\n          should_refuse_unknown_exits(options)))) {\n        /* Don't let clients use us as a single-hop proxy, unless the user\n         * has explicitly allowed that in the config. It attracts attackers\n         * and users who'd be better off with, well, single-hop proxies.\n         */\n        log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n               \"Attempt by %s to open a stream %s. Closing.\",\n               safe_str(channel_get_canonical_remote_descr(or_circ->p_chan)),\n               or_circ->is_first_hop ? \"on first hop of circuit\" :\n                                       \"from unknown relay\");\n        relay_send_end_cell_from_edge(rh.stream_id, circ,\n                                      or_circ->is_first_hop ?\n                                        END_STREAM_REASON_TORPROTOCOL :\n                                        END_STREAM_REASON_MISC,\n                                      NULL);\n        tor_free(address);\n        return 0;\n      }\n    }\n  } else if (rh.command == RELAY_COMMAND_BEGIN_DIR) {\n    if (!directory_permits_begindir_requests(options) ||\n        circ->purpose != CIRCUIT_PURPOSE_OR) {\n      relay_send_end_cell_from_edge(rh.stream_id, circ,\n                                  END_STREAM_REASON_NOTDIRECTORY, layer_hint);\n      return 0;\n    }\n    /* Make sure to get the 'real' address of the previous hop: the\n     * caller might want to know whether the remote IP address has changed,\n     * and we might already have corrected base_.addr[ess] for the relay's\n     * canonical IP address. */\n    if (or_circ && or_circ->p_chan)\n      address = tor_strdup(channel_get_actual_remote_address(or_circ->p_chan));\n    else\n      address = tor_strdup(\"127.0.0.1\");\n    port = 1; /* XXXX This value is never actually used anywhere, and there\n               * isn't \"really\" a connection here.  But we\n               * need to set it to something nonzero. */\n  } else {\n    log_warn(LD_BUG, \"Got an unexpected command %d\", (int)rh.command);\n    relay_send_end_cell_from_edge(rh.stream_id, circ,\n                                  END_STREAM_REASON_INTERNAL, layer_hint);\n    return 0;\n  }\n\n  if (! options->IPv6Exit) {\n    /* I don't care if you prefer IPv6; I can't give you any. */\n    bcell.flags &= ~BEGIN_FLAG_IPV6_PREFERRED;\n    /* If you don't want IPv4, I can't help. */\n    if (bcell.flags & BEGIN_FLAG_IPV4_NOT_OK) {\n      tor_free(address);\n      relay_send_end_cell_from_edge(rh.stream_id, circ,\n                                    END_STREAM_REASON_EXITPOLICY, layer_hint);\n      return 0;\n    }\n  }\n\n  log_debug(LD_EXIT,\"Creating new exit connection.\");\n  /* The 'AF_INET' here is temporary; we might need to change it later in\n   * connection_exit_connect(). */\n  n_stream = edge_connection_new(CONN_TYPE_EXIT, AF_INET);\n\n  /* Remember the tunneled request ID in the new edge connection, so that\n   * we can measure download times. */\n  n_stream->dirreq_id = circ->dirreq_id;\n\n  n_stream->base_.purpose = EXIT_PURPOSE_CONNECT;\n  n_stream->begincell_flags = bcell.flags;\n  n_stream->stream_id = rh.stream_id;\n  n_stream->base_.port = port;\n  /* leave n_stream->s at -1, because it's not yet valid */\n  n_stream->package_window = STREAMWINDOW_START;\n  n_stream->deliver_window = STREAMWINDOW_START;\n\n  if (circ->purpose == CIRCUIT_PURPOSE_S_REND_JOINED) {\n    tor_assert(origin_circ);\n    log_info(LD_REND,\"begin is for rendezvous. configuring stream.\");\n    n_stream->base_.address = tor_strdup(\"(rendezvous)\");\n    n_stream->base_.state = EXIT_CONN_STATE_CONNECTING;\n    n_stream->rend_data = rend_data_dup(origin_circ->rend_data);\n    tor_assert(connection_edge_is_rendezvous_stream(n_stream));\n    assert_circuit_ok(circ);\n\n    const int r = rend_service_set_connection_addr_port(n_stream, origin_circ);\n    if (r < 0) {\n      log_info(LD_REND,\"Didn't find rendezvous service (port %d)\",\n               n_stream->base_.port);\n      /* Send back reason DONE because we want to make hidden service port\n       * scanning harder thus instead of returning that the exit policy\n       * didn't match, which makes it obvious that the port is closed,\n       * return DONE and kill the circuit. That way, a user (malicious or\n       * not) needs one circuit per bad port unless it matches the policy of\n       * the hidden service. */\n      relay_send_end_cell_from_edge(rh.stream_id, circ,\n                                    END_STREAM_REASON_DONE,\n                                    layer_hint);\n      connection_free(TO_CONN(n_stream));\n      tor_free(address);\n\n      /* Drop the circuit here since it might be someone deliberately\n       * scanning the hidden service ports. Note that this mitigates port\n       * scanning by adding more work on the attacker side to successfully\n       * scan but does not fully solve it. */\n      if (r < -1)\n        return END_CIRC_AT_ORIGIN;\n      else\n        return 0;\n    }\n    assert_circuit_ok(circ);\n    log_debug(LD_REND,\"Finished assigning addr/port\");\n    n_stream->cpath_layer = origin_circ->cpath->prev; /* link it */\n\n    /* add it into the linked list of p_streams on this circuit */\n    n_stream->next_stream = origin_circ->p_streams;\n    n_stream->on_circuit = circ;\n    origin_circ->p_streams = n_stream;\n    assert_circuit_ok(circ);\n\n    origin_circ->rend_data->nr_streams++;\n\n    connection_exit_connect(n_stream);\n\n    /* For path bias: This circuit was used successfully */\n    pathbias_mark_use_success(origin_circ);\n\n    tor_free(address);\n    return 0;\n  }\n  tor_strlower(address);\n  n_stream->base_.address = address;\n  n_stream->base_.state = EXIT_CONN_STATE_RESOLVEFAILED;\n  /* default to failed, change in dns_resolve if it turns out not to fail */\n\n  if (we_are_hibernating()) {\n    relay_send_end_cell_from_edge(rh.stream_id, circ,\n                                  END_STREAM_REASON_HIBERNATING, NULL);\n    connection_free(TO_CONN(n_stream));\n    return 0;\n  }\n\n  n_stream->on_circuit = circ;\n\n  if (rh.command == RELAY_COMMAND_BEGIN_DIR) {\n    tor_addr_t tmp_addr;\n    tor_assert(or_circ);\n    if (or_circ->p_chan &&\n        channel_get_addr_if_possible(or_circ->p_chan, &tmp_addr)) {\n      tor_addr_copy(&n_stream->base_.addr, &tmp_addr);\n    }\n    return connection_exit_connect_dir(n_stream);\n  }\n\n  log_debug(LD_EXIT,\"about to start the dns_resolve().\");\n\n  /* send it off to the gethostbyname farm */\n  switch (dns_resolve(n_stream)) {\n    case 1: /* resolve worked; now n_stream is attached to circ. */\n      assert_circuit_ok(circ);\n      log_debug(LD_EXIT,\"about to call connection_exit_connect().\");\n      connection_exit_connect(n_stream);\n      return 0;\n    case -1: /* resolve failed */\n      relay_send_end_cell_from_edge(rh.stream_id, circ,\n                                    END_STREAM_REASON_RESOLVEFAILED, NULL);\n      /* n_stream got freed. don't touch it. */\n      break;\n    case 0: /* resolve added to pending list */\n      assert_circuit_ok(circ);\n      break;\n  }\n  return 0;\n}", "target": 2, "idx": 10183}
{"commit_id": "3b84ffcbacf144ce35650df958432f472b6483f8", "project": "gpac", "func": "void gf_isom_cenc_get_default_info_internal(GF_TrackBox *trak, u32 sampleDescriptionIndex, u32 *container_type, Bool *default_IsEncrypted, u8 *crypt_byte_block, u8 *skip_byte_block, const u8 **key_info, u32 *key_info_size)\n{\n\tGF_ProtectionSchemeInfoBox *sinf;\n\n\n\t//setup all default as not encrypted\n\tif (default_IsEncrypted) *default_IsEncrypted = GF_FALSE;\n\tif (crypt_byte_block) *crypt_byte_block = 0;\n\tif (skip_byte_block) *skip_byte_block = 0;\n\tif (container_type) *container_type = 0;\n\tif (key_info) *key_info = NULL;\n\tif (key_info_size) *key_info_size = 0;\n\n\tsinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CENC_SCHEME, NULL);\n\tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CBC_SCHEME, NULL);\n\tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CENS_SCHEME, NULL);\n\tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CBCS_SCHEME, NULL);\n\tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_PIFF_SCHEME, NULL);\n\n\tif (!sinf) {\n\t\tu32 i, nb_stsd = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\t\tfor (i=0; i<nb_stsd; i++) {\n\t\t\tGF_ProtectionSchemeInfoBox *a_sinf;\n\t\t\tGF_SampleEntryBox *sentry=NULL;\n\t\t\tif (i+1==sampleDescriptionIndex) continue;\n\t\t\tsentry = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, i);\n\t\t\ta_sinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(sentry->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\t\t\tif (!a_sinf) continue;\n\t\t\t//signal default (not encrypted)\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (sinf && sinf->info && sinf->info->tenc) {\n\t\tif (default_IsEncrypted) *default_IsEncrypted = sinf->info->tenc->isProtected;\n\t\tif (crypt_byte_block) *crypt_byte_block = sinf->info->tenc->crypt_byte_block;\n\t\tif (skip_byte_block) *skip_byte_block = sinf->info->tenc->skip_byte_block;\n\t\tif (key_info) *key_info = sinf->info->tenc->key_info;\n\t\tif (key_info_size) {\n\t\t\t*key_info_size = 20;\n\t\t\tif (!sinf->info->tenc->key_info[3])\n\t\t\t\t*key_info_size += 1 + sinf->info->tenc->key_info[20];\n\t\t}\n\n\t\t//set default value, overwritten below\n\t\tif (container_type) *container_type = GF_ISOM_BOX_TYPE_SENC;\n\t} else if (sinf && sinf->info && sinf->info->piff_tenc) {\n\t\tif (default_IsEncrypted) *default_IsEncrypted = GF_TRUE;\n\t\tif (key_info) *key_info = sinf->info->piff_tenc->key_info;\n\t\tif (key_info_size) *key_info_size = 19;\n\t\t//set default value, overwritten below\n\t\tif (container_type) *container_type = GF_ISOM_BOX_UUID_PSEC;\n\t} else {\n\t\tu32 i, count = 0;\n\t\tGF_CENCSampleEncryptionGroupEntry *seig_entry = NULL;\n\n\t\tif (!trak->moov->mov->is_smooth)\n\t\t\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription);\n\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_SampleGroupDescriptionBox *sgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, i);\n\t\t\tif (sgdesc->grouping_type!=GF_ISOM_SAMPLE_GROUP_SEIG) continue;\n\t\t\tif (sgdesc->default_description_index)\n\t\t\t\tseig_entry = gf_list_get(sgdesc->group_descriptions, sgdesc->default_description_index-1);\n\t\t\telse\n\t\t\t\tseig_entry = gf_list_get(sgdesc->group_descriptions, 0);\n\t\t\tif (seig_entry && !seig_entry->key_info[0])\n\t\t\t\tseig_entry = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (seig_entry) {\n\t\t\tif (default_IsEncrypted) *default_IsEncrypted = seig_entry->IsProtected;\n\t\t\tif (crypt_byte_block) *crypt_byte_block = seig_entry->crypt_byte_block;\n\t\t\tif (skip_byte_block) *skip_byte_block = seig_entry->skip_byte_block;\n\t\t\tif (key_info) *key_info = seig_entry->key_info;\n\t\t\tif (key_info_size) *key_info_size = seig_entry->key_info_size;\n\t\t\tif (container_type) *container_type = GF_ISOM_BOX_TYPE_SENC;\n\t\t} else {\n\t\t\tif (! trak->moov->mov->is_smooth ) {\n\t\t\t\ttrak->moov->mov->is_smooth = GF_TRUE;\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] senc box without tenc, assuming MS smooth+piff\\n\"));\n\t\t\t}\n\t\t\tif (default_IsEncrypted) *default_IsEncrypted = GF_TRUE;\n\t\t\t//set default value, overwritten below\n\t\t\tif (container_type) *container_type = GF_ISOM_BOX_UUID_PSEC;\n\t\t}\n\t}\n\n\tif (container_type && trak->sample_encryption) {\n\t\tif (trak->sample_encryption->type == GF_ISOM_BOX_TYPE_SENC) *container_type = GF_ISOM_BOX_TYPE_SENC;\n\t\telse if (trak->sample_encryption->type == GF_ISOM_BOX_TYPE_UUID) *container_type = ((GF_UUIDBox*)trak->sample_encryption)->internal_4cc;\n\t}\n}", "target": 1, "idx": 10184}
{"commit_id": "c00fc9d3003eb06226b58b6a48555f1456ee2475", "project": "facebook/hhvm", "func": "static String HHVM_FUNCTION(bcadd, const String& left, const String& right,\n                            int64_t scale /* = -1 */) {\n  scale = adjust_scale(scale);\n  bc_num first, second, result;\n  bc_init_num(&first);\n  bc_init_num(&second);\n  bc_init_num(&result);\n  php_str2num(&first, (char*)left.data());\n  php_str2num(&second, (char*)right.data());\n  bc_add(first, second, &result, scale);\n  if (result->n_scale > scale) {\n    result->n_scale = scale;\n  }\n  String ret(bc_num2str(result), AttachString);\n  bc_free_num(&first);\n  bc_free_num(&second);\n  bc_free_num(&result);\n  return ret;\n}", "target": 3, "idx": 10185}
{"commit_id": "760322a71ac9033e122ef1f4b1c62813021e5938", "project": "tensorflow", "func": "Status ImportGenericFunction(\n    GraphFuncOp func_op, const FunctionDef& func,\n    llvm::StringMap<llvm::StringMap<SmallVector<Value, 1>>>& values_map,\n    OpBuilder& builder) {\n  const OpDef& signature = func.signature();\n  Location unknown_loc = builder.getUnknownLoc();\n  MLIRContext* context = builder.getContext();\n\n  NamedAttrList attrs;\n  DictionaryAttr func_attrs = builder.getDictionaryAttr({});\n  if (signature.name().empty())\n    return InvalidArgument(\"generic function without a name\");\n  attrs.append(\"sym_name\", builder.getStringAttr(signature.name()));\n  attrs.append(\"generic\", builder.getUnitAttr());\n  if (!signature.description().empty())\n    attrs.append(\"description\", builder.getStringAttr(signature.description()));\n  if (signature.is_stateful())\n    attrs.append(\"is_stateful\", builder.getUnitAttr());\n  if (signature.control_output_size()) {\n    SmallVector<Attribute> control_outputs;\n    for (const std::string& output : signature.control_output())\n      control_outputs.push_back(builder.getStringAttr(output));\n    attrs.append(\"control_output\", builder.getArrayAttr(control_outputs));\n  }\n  {\n    NamedAttrList attr_defs;\n    for (const OpDef_AttrDef& attr : signature.attr()) {\n      NamedAttrList attr_def;\n      if (attr.name().empty())\n        return InvalidArgument(\"Missing name for function attribute\");\n      if (!attr.type().empty())\n        attr_def.append(builder.getNamedAttr(\n            \"function_type\", builder.getStringAttr(attr.type())));\n      if (attr.has_default_value()) {\n        TF_ASSIGN_OR_RETURN(Attribute attr, ConvertAttributeValue(\n                                                attr.default_value(), builder));\n        attr_def.append(builder.getNamedAttr(\"default_value\", attr));\n      }\n      if (!attr.description().empty())\n        attr_def.append(builder.getNamedAttr(\n            \"description\", builder.getStringAttr(attr.description())));\n      if (attr.has_minimum() || attr.minimum())\n        attr_def.append(builder.getNamedAttr(\n            \"minimum\", builder.getI32IntegerAttr(attr.minimum())));\n      if (attr.has_allowed_values()) {\n        TF_ASSIGN_OR_RETURN(\n            Attribute attr,\n            ConvertAttributeValue(attr.allowed_values(), builder));\n        attr_def.append(builder.getNamedAttr(\"allowed_values\", attr));\n      }\n      attr_defs.append(builder.getNamedAttr(\n          attr.name(), attr_def.getDictionary(builder.getContext())));\n    }\n    if (!attr_defs.empty()) {\n      func_attrs = attr_defs.getDictionary(builder.getContext());\n      attrs.append(\"tfg.func_attrs\", func_attrs);\n    }\n  }\n\n  // The resource_arg_unique_id is a list of `pair<int, int>`, we import it\n  // as two arrays of integer right now.\n  if (func.resource_arg_unique_id_size()) {\n    SmallVector<int32_t> resource_arg_unique_ids_keys;\n    SmallVector<int32_t> resource_arg_unique_ids_values;\n    for (const auto& unique_id : func.resource_arg_unique_id()) {\n      resource_arg_unique_ids_keys.push_back(unique_id.first);\n      resource_arg_unique_ids_values.push_back(unique_id.second);\n    }\n    attrs.append(\"resource_arg_unique_ids_keys\",\n                 builder.getI32TensorAttr(resource_arg_unique_ids_keys));\n    attrs.append(\"resource_arg_unique_ids_values\",\n                 builder.getI32TensorAttr(resource_arg_unique_ids_values));\n  }\n\n  // Import the function attributes with a `tf.` prefix to match the current\n  // infrastructure expectations.\n  for (const auto& namedAttr : func.attr()) {\n    if (namedAttr.first.empty())\n      return InvalidArgument(\"Invalid function attribute name\");\n    const std::string& name = \"tf.\" + namedAttr.first;\n    const AttrValue& tf_attr = namedAttr.second;\n    TF_ASSIGN_OR_RETURN(Attribute attr,\n                        ConvertAttributeValue(tf_attr, builder));\n    attrs.append(name, attr);\n  }\n  SmallString<8> arg_or_res_attr_name;\n  SmallString<8> sub_arg_attr_name;\n  // Iterate of the input in the signature. Each input will correspond to\n  // potentially multiple arguments because of how the OpDef allows repeated\n  // arguments controlled by `number_attr` for example.\n  // We populate the `arg_names` vector with the name of each input at each\n  // position, and `arg_types` with the matching type.\n  int arg_num = 0;\n  SmallVector<StringRef> arg_names;\n  SmallVector<Type> arg_types;\n  SmallVector<Attribute> args_attrs;\n  SmallVector<Attribute> res_attrs;\n  for (const auto& enumerated_input : llvm::enumerate(signature.input_arg())) {\n    const OpDef::ArgDef& input = enumerated_input.value();\n    TF_ASSIGN_OR_RETURN(NamedAttrList input_attrs,\n                        ConvertArgDefAttributes(input, builder));\n    auto it = func.arg_attr().find(enumerated_input.index());\n    if (it != func.arg_attr().end()) {\n      NamedAttrList arg_attr;\n      for (const auto& named_attr : it->second.attr()) {\n        TF_ASSIGN_OR_RETURN(Attribute attr,\n                            ConvertAttributeValue(named_attr.second, builder));\n        arg_attr.append(named_attr.first, attr);\n      }\n      input_attrs.append(\"tfg.arg_attrs\",\n                         arg_attr.getDictionary(builder.getContext()));\n    }\n    arg_names.push_back(builder.getStringAttr(input.name()).getValue());\n    arg_types.push_back(OpaqueTensorType::get(context));\n    args_attrs.push_back(input_attrs.getDictionary(context));\n    args_attrs.push_back(NamedAttrList{}.getDictionary(context));\n    arg_num++;\n  }\n  attrs.push_back(builder.getNamedAttr(func_op.getArgAttrsAttrName(),\n                                       builder.getArrayAttr(args_attrs)));\n\n  // Process the results attributes now.\n  int res_num = 0;\n  for (const OpDef::ArgDef& output : signature.output_arg()) {\n    TF_ASSIGN_OR_RETURN(NamedAttrList output_attrs,\n                        ConvertArgDefAttributes(output, builder));\n    res_attrs.push_back(output_attrs.getDictionary(context));\n    ++res_num;\n  }\n  // Process the control output metadata and store them as attributes.\n  for (const std::string& output : signature.control_output()) {\n    NamedAttrList output_attrs;\n    output_attrs.append(\"tfg.name\", builder.getStringAttr(output));\n    res_attrs.push_back(output_attrs.getDictionary(context));\n    ++res_num;\n  }\n  attrs.push_back(builder.getNamedAttr(func_op.getResAttrsAttrName(),\n                                       builder.getArrayAttr(res_attrs)));\n\n  values_map.clear();\n  Block* body = new Block();\n  func_op.getBody().push_back(body);\n  Type control_ty = ControlType::get(context);\n  // Create the block arguments and populate the `values_map` with the matching\n  // input names.\n  for (auto type_and_name : llvm::zip(arg_types, arg_names)) {\n    Value arg = body->addArgument(std::get<0>(type_and_name), unknown_loc);\n    llvm::StringMap<SmallVector<Value, 1>>& values =\n        values_map[std::get<1>(type_and_name)];\n    Value ctl = body->addArgument(control_ty, unknown_loc);\n    values[\"\"].push_back(arg);\n    values[\"^\"].push_back(ctl);\n  }\n\n  // Pre-populate the nodes_map with the needed slots for the return.\n  OpBuilder body_builder = OpBuilder::atBlockEnd(body);\n  // We use placeholders during the import to create \"fake\" operations to break\n  // cycles: we need operands to feed to the users.\n  OperationName mlir_placeholder(\"tfg.__mlir_placeholder\", context);\n  Type placeholder_ty = OpaqueTensorType::get(context);\n  ValueMapManager value_manager(values_map, body_builder, mlir_placeholder,\n                                placeholder_ty, control_ty, unknown_loc);\n\n  // Import the function body here, after this we have a function with all\n  // the nodes, and the nodes_map contains the mapping from node_name to actual\n  // MLIR Operations.\n  TF_RETURN_WITH_CONTEXT_IF_ERROR(\n      ImportNodes(value_manager, func.node_def(), body_builder),\n      \" when importing function \", func.signature().name());\n\n  // After the body, the final part is to setup the return. It comes in two\n  // parts: the `ret` field from the FunctionDef for the regular output and the\n  // `control_ret` field for the control output.\n  //\n  // Because `ret` and `control_ret` aren't ordered, there is an indirection to\n  // the FunctionDef signature to retrieve the position of each `ret` and\n  // `control_ret` entry by name. We compute this mapping from the name of an\n  // output to the position in the result array first.\n  res_num = 0;\n  llvm::StringMap<int> output_name_to_position;\n  for (const OpDef::ArgDef& output : signature.output_arg()) {\n    if (output_name_to_position.count(output.name()))\n      return InvalidArgument(\"Duplicated output_arg entry\", output.name());\n    output_name_to_position[output.name()] = res_num;\n    ++res_num;\n  }\n  res_num = 0;\n  llvm::StringMap<int> control_output_to_position;\n  for (const std::string& output : signature.control_output()) {\n    if (control_output_to_position.count(output))\n      return InvalidArgument(\"Duplicated control_output entry\", output);\n    control_output_to_position[output] = res_num;\n    ++res_num;\n  }\n\n  // We pre-allocate the array of operands and populate it using the\n  // `output_name_to_position` and `control_output_to_position` populated\n  // previously.\n  SmallVector<Value> ret_vals(func.ret_size() + func.control_ret_size(),\n                              Value());\n  for (const auto& ret_val : func.ret()) {\n    auto position = output_name_to_position.find(ret_val.first);\n    if (position == output_name_to_position.end()) {\n      return InvalidArgument(\n          \"Can't import function, returned value references unknown output \"\n          \"argument \",\n          ret_val.first);\n    }\n    if (ret_val.second.empty()) {\n      return InvalidArgument(\"Function '\", func.signature().name(),\n                             \"' has empty result name\");\n    }\n    TF_ASSIGN_OR_RETURN(\n        ret_vals[position->second],\n        value_manager.GetValueOrCreatePlaceholder(ret_val.second));\n  }\n  for (const auto& ret_val : func.control_ret()) {\n    auto position = control_output_to_position.find(ret_val.first);\n    if (position == control_output_to_position.end()) {\n      return InvalidArgument(\n          \"Can't import function, returned value references unknown output \"\n          \"argument \",\n          ret_val.first);\n    }\n    if (ret_val.second.empty()) {\n      return InvalidArgument(\"Function '\", func.signature().name(),\n                             \"' has empty control result name\");\n    }\n    TF_ASSIGN_OR_RETURN(Value result, value_manager.GetValueOrCreatePlaceholder(\n                                          (Twine(\"^\") + ret_val.second).str()));\n    if (!result.getType().isa<ControlType>())\n      return InvalidArgument(\"failed to map returned value \", ret_val.second,\n                             \", isn't a control output\");\n    ret_vals[func.ret_size() + position->second] = result;\n  }\n  // Check that all the of the return operands have been populated.\n  for (auto& indexed_val : llvm::enumerate(ret_vals)) {\n    if (indexed_val.value()) continue;\n    return InvalidArgument(\n        \"Failed to import function, missing output for position \",\n        indexed_val.index());\n  }\n  MutableArrayRef<Value> operands = ret_vals;\n  ReturnOp ret_op = body_builder.create<ReturnOp>(\n      unknown_loc, operands.slice(0, func.ret_size()),\n      operands.slice(func.ret_size()));\n\n  // Now that we have all the types, set the function signature as the\n  // \"function_type\" attribute.\n  {\n    SmallVector<Type> arg_types_with_ctl;\n    for (Type type : arg_types) {\n      arg_types_with_ctl.push_back(type);\n      arg_types_with_ctl.push_back(control_ty);\n    }\n    attrs.append(\"function_type\",\n                 TypeAttr::get(builder.getFunctionType(\n                     arg_types_with_ctl, ret_op.getOperandTypes())));\n  }\n  func_op->setAttrs(attrs);\n  return ::tensorflow::OkStatus();\n}", "target": 2, "idx": 10186}
{"commit_id": "e92c466f5c324b429ce1a8aa1b40d208574c778a", "project": "sddm", "func": "void Auth::Private::dataPending() {\n        Auth *auth = qobject_cast<Auth*>(parent());\n        Msg m = MSG_UNKNOWN;\n        SafeDataStream str(socket);\n        str.receive();\n        str >> m;\n        switch (m) {\n            case ERROR: {\n                QString message;\n                Error type = ERROR_NONE;\n                str >> message >> type;\n                Q_EMIT auth->error(message, type);\n                break;\n            }\n            case INFO: {\n                QString message;\n                Info type = INFO_NONE;\n                str >> message >> type;\n                Q_EMIT auth->info(message, type);\n                break;\n            }\n            case REQUEST: {\n                Request r;\n                str >> r;\n                request->setRequest(&r);\n                break;\n            }\n            case AUTHENTICATED: {\n                QString user;\n                str >> user;\n                if (!user.isEmpty()) {\n                    auth->setUser(user);\n                    Q_EMIT auth->authentication(user, true);\n                    str.reset();\n                    str << AUTHENTICATED << environment << cookie;\n                    str.send();\n                }\n                else {\n                    Q_EMIT auth->authentication(user, false);\n                }\n                break;\n            }\n            case SESSION_STATUS: {\n                bool status;\n                str >> status;\n                Q_EMIT auth->session(status);\n                str.reset();\n                str << SESSION_STATUS;\n                str.send();\n                break;\n            }\n            default: {\n                Q_EMIT auth->error(QString(\"Auth: Unexpected value received: %1\").arg(m), ERROR_INTERNAL);\n            }\n        }\n    }", "target": 2, "idx": 10187}
{"commit_id": "9c6ba456711687b794dcf285856fc14e2c76074f", "project": "torvalds/linux", "func": "static int powermate_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev (intf);\n\tstruct usb_host_interface *interface;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tstruct powermate_device *pm;\n\tstruct input_dev *input_dev;\n\tint pipe, maxp;\n\tint error = -ENOMEM;\n\n\tinterface = intf->cur_altsetting;\n\tif (interface->desc.bNumEndpoints < 1)\n\t\treturn -EINVAL;\n\n\tendpoint = &interface->endpoint[0].desc;\n\tif (!usb_endpoint_is_int_in(endpoint))\n\t\treturn -EIO;\n\n\tusb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t0x0a, USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t0, interface->desc.bInterfaceNumber, NULL, 0,\n\t\tUSB_CTRL_SET_TIMEOUT);\n\n\tpm = kzalloc(sizeof(struct powermate_device), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!pm || !input_dev)\n\t\tgoto fail1;\n\n\tif (powermate_alloc_buffers(udev, pm))\n\t\tgoto fail2;\n\n\tpm->irq = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!pm->irq)\n\t\tgoto fail2;\n\n\tpm->config = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!pm->config)\n\t\tgoto fail3;\n\n\tpm->udev = udev;\n\tpm->intf = intf;\n\tpm->input = input_dev;\n\n\tusb_make_path(udev, pm->phys, sizeof(pm->phys));\n\tstrlcat(pm->phys, \"/input0\", sizeof(pm->phys));\n\n\tspin_lock_init(&pm->lock);\n\n\tswitch (le16_to_cpu(udev->descriptor.idProduct)) {\n\tcase POWERMATE_PRODUCT_NEW:\n\t\tinput_dev->name = pm_name_powermate;\n\t\tbreak;\n\tcase POWERMATE_PRODUCT_OLD:\n\t\tinput_dev->name = pm_name_soundknob;\n\t\tbreak;\n\tdefault:\n\t\tinput_dev->name = pm_name_soundknob;\n\t\tprintk(KERN_WARNING \"powermate: unknown product id %04x\\n\",\n\t\t       le16_to_cpu(udev->descriptor.idProduct));\n\t}\n\n\tinput_dev->phys = pm->phys;\n\tusb_to_input_id(udev, &input_dev->id);\n\tinput_dev->dev.parent = &intf->dev;\n\n\tinput_set_drvdata(input_dev, pm);\n\n\tinput_dev->event = powermate_input_event;\n\n\tinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REL) |\n\t\tBIT_MASK(EV_MSC);\n\tinput_dev->keybit[BIT_WORD(BTN_0)] = BIT_MASK(BTN_0);\n\tinput_dev->relbit[BIT_WORD(REL_DIAL)] = BIT_MASK(REL_DIAL);\n\tinput_dev->mscbit[BIT_WORD(MSC_PULSELED)] = BIT_MASK(MSC_PULSELED);\n\n\t/* get a handle to the interrupt data pipe */\n\tpipe = usb_rcvintpipe(udev, endpoint->bEndpointAddress);\n\tmaxp = usb_maxpacket(udev, pipe, usb_pipeout(pipe));\n\n\tif (maxp < POWERMATE_PAYLOAD_SIZE_MIN || maxp > POWERMATE_PAYLOAD_SIZE_MAX) {\n\t\tprintk(KERN_WARNING \"powermate: Expected payload of %d--%d bytes, found %d bytes!\\n\",\n\t\t\tPOWERMATE_PAYLOAD_SIZE_MIN, POWERMATE_PAYLOAD_SIZE_MAX, maxp);\n\t\tmaxp = POWERMATE_PAYLOAD_SIZE_MAX;\n\t}\n\n\tusb_fill_int_urb(pm->irq, udev, pipe, pm->data,\n\t\t\t maxp, powermate_irq,\n\t\t\t pm, endpoint->bInterval);\n\tpm->irq->transfer_dma = pm->data_dma;\n\tpm->irq->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\t/* register our interrupt URB with the USB system */\n\tif (usb_submit_urb(pm->irq, GFP_KERNEL)) {\n\t\terror = -EIO;\n\t\tgoto fail4;\n\t}\n\n\terror = input_register_device(pm->input);\n\tif (error)\n\t\tgoto fail5;\n\n\n\t/* force an update of everything */\n\tpm->requires_update = UPDATE_PULSE_ASLEEP | UPDATE_PULSE_AWAKE | UPDATE_PULSE_MODE | UPDATE_STATIC_BRIGHTNESS;\n\tpowermate_pulse_led(pm, 0x80, 255, 0, 1, 0); // set default pulse parameters\n\n\tusb_set_intfdata(intf, pm);\n\treturn 0;\n\n fail5:\tusb_kill_urb(pm->irq);\n fail4:\tusb_free_urb(pm->config);\n fail3:\tusb_free_urb(pm->irq);\n fail2:\tpowermate_free_buffers(udev, pm);\n fail1:\tinput_free_device(input_dev);\n\tkfree(pm);\n\treturn error;\n}", "target": 1, "idx": 10188}
{"commit_id": "f8ac003bbfe11956578dd2189827686c27374d06", "project": "RIOT-OS/RIOT", "func": "static inline size_t base64_estimate_decode_size(size_t base64_in_size)\n{\n    return (((base64_in_size + 3) / 4) * 3);\n}", "target": 3, "idx": 10189}
{"commit_id": "347f071f1b9180563c28b0f3d0627b91eb456c72", "project": "wireshark", "func": "static guint32\nparse_wbxml_tag_defined (proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, guint32 offset,\n\t\t\t guint32 str_tbl, guint8 *level, guint8 *codepage_stag, guint8 *codepage_attr,\n\t\t\t const wbxml_decoding *map)\n{\n\tguint32      tvb_len  = tvb_reported_length (tvb);\n\tguint32      off      = offset;\n\tguint32      len;\n\tguint        str_len;\n\tguint32      ent;\n\tguint32      idx;\n\tguint8       peek;\n\tguint32      tag_len;                     /* Length of the index (uintvar) from a LITERAL tag */\n\tguint8       tag_save_known      = 0;     /* Will contain peek & 0x3F (tag identity) */\n\tguint8       tag_new_known       = 0;     /* Will contain peek & 0x3F (tag identity) */\n\tconst char  *tag_save_literal    = NULL;  /* Will contain the LITERAL tag identity */\n\tconst char  *tag_new_literal;             /* Will contain the LITERAL tag identity */\n\tconst gchar *str;\n\tguint8       parsing_tag_content = FALSE; /* Are we parsing content from a\n\t\t\t\t\t\t     tag with content: <x>Content</x>\n\n\t\t\t\t\t\t     The initial state is FALSE.\n\t\t\t\t\t\t     This state will trigger recursion. */\n\n\tif (*level == 255) {\n\t\tproto_tree_add_expert(tree, pinfo, &ei_wbxml_too_much_recursion, tvb, offset, tvb_captured_length_remaining(tvb, offset));\n\t\treturn tvb_len;\n\t}\n\tDebugLog((\"parse_wbxml_tag_defined (level = %u, offset = %u)\\n\", *level, offset));\n\twhile (off < tvb_len) {\n\t\tpeek = tvb_get_guint8 (tvb, off);\n\t\tDebugLog((\"STAG: (top of while) level = %3u, peek = 0x%02X, off = %u, tvb_len = %u\\n\", *level, peek, off, tvb_len));\n\t\tif ((peek & 0x3F) < 4) switch (peek) { /* Global tokens in state = STAG\n\t\t\t\t\t\t\t  but not the LITERAL tokens */\n\t\tcase 0x00: /* SWITCH_PAGE */\n\t\t\t*codepage_stag = tvb_get_guint8 (tvb, off+1);\n\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_switch_page, tvb, off, 2, *codepage_stag,\n\t\t\t\t\t     \"      | Tag   | T -->%3d | SWITCH_PAGE (Tag code page)     |\",\n\t\t\t\t\t     *codepage_stag);\n\t\t\toff += 2;\n\t\t\tbreak;\n\t\tcase 0x01: /* END: only possible for Tag with Content */\n\t\t\tif (tag_save_known) { /* Known TAG */\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_end_known_tag, tvb, off, 1, tag_save_literal,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (Known Tag 0x%02X)            | %s</%s>\",\n\t\t\t\t\t\t     *level, *codepage_stag,\n\t\t\t\t\t\t     tag_save_known, Indent (*level),\n\t\t\t\t\t\t     tag_save_literal); /* We already looked it up! */\n\t\t\t} else { /* Literal TAG */\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_end_literal_tag, tvb, off, 1, tag_save_literal ? tag_save_literal : \"\",\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (Literal Tag)               | %s</%s>\",\n\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), tag_save_literal ? tag_save_literal : \"\");\n\t\t\t}\n\t\t\t(*level)--;\n\t\t\toff++;\n\t\t\t/* Reset code page: not needed as return from recursion */\n\t\t\tDebugLog((\"STAG: level = %u, Return: len = %u\\n\", *level, off - offset));\n\t\t\treturn (off - offset);\n\t\tcase 0x02: /* ENTITY */\n\t\t\tent = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_entity, tvb, off, 1+len, ent,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | ENTITY                          | %s'&#%u;'\",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level), ent);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x03: /* STR_I */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tstr = tvb_format_text (tvb, off+1, len-1);\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_i, tvb, off, 1+len, str,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | STR_I (Inline string)           | %s\\'%s\\'\",\n\t\t\t\t\t     *level, *codepage_stag, Indent(*level),\n\t\t\t\t\t     str);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x40: /* EXT_I_0 */\n\t\tcase 0x41: /* EXT_I_1 */\n\t\tcase 0x42: /* EXT_I_2 */\n\t\t\t/* Extension tokens */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tstr = tvb_format_text (tvb, off+1, len-1);\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_ext_i, tvb, off, 1+len, str,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | EXT_I_%1x    (Extension Token)    | %s(%s: \\'%s\\')\",\n\t\t\t\t\t     *level, *codepage_stag,\n\t\t\t\t\t     peek & 0x0f, Indent (*level),\n\t\t\t\t\t     ((map != NULL) ? map_token (map->global, 0, peek) : \"Inline string extension\"),\n\t\t\t\t\t     str);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x43: /* PI */\n\t\t\tproto_tree_add_none_format(tree, hf_wbxml_pi_xml, tvb, off, 1,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | PI (XML Processing Instruction) | %s<?xml\",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo, off,\n\t\t\t\t\t\t\t\t  str_tbl, *level, codepage_attr, map);\n\t\t\t/* Check that there is still room in packet */\n\t\t\toff += len;\n\t\t\tif (off >= tvb_len) {\n\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\", *level, off - offset));\n\t\t\t\t/*\n\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t */\n\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t}\n\t\t\tproto_tree_add_none_format(tree, hf_wbxml_end_pi, tvb, off-1, 1,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (PI)                        | %s?>\",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\tbreak;\n\t\tcase 0x80: /* EXT_T_0 */\n\t\tcase 0x81: /* EXT_T_1 */\n\t\tcase 0x82: /* EXT_T_2 */\n\t\t\t/* Extension tokens */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tif (map)\n\t\t\t\t{\n\t\t\t\t\tif (map->ext_t[peek & 0x03])\n\t\t\t\t\t\ts = (map->ext_t[peek & 0x03])(tvb, idx, str_tbl);\n\t\t\t\t\telse\n\t\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \"EXT_T_%1x (%s)\", peek & 0x03,\n\t\t\t\t\t\t\t        map_token (map->global, 0, peek));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \"(Extension Token, integer value: %u)\", idx);\n\t\t\t\t}\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_ext_t, tvb, off, 1+len, s,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | EXT_T_%1x    (Extension Token)    | %s%s\",\n\t\t\t\t\t\t     *level, *codepage_stag, peek & 0x0f, Indent (*level), s);\n\t\t\t}\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x83: /* STR_T */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\tstr = tvb_format_text (tvb, str_tbl+idx, str_len-1);\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_t, tvb, off, 1+len, str,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | STR_T (Tableref string)         | %s\\'%s\\'\",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level), str);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0xC0: /* EXT_0 */\n\t\tcase 0xC1: /* EXT_1 */\n\t\tcase 0xC2: /* EXT_2 */\n\t\t\t/* Extension tokens */\n\t\t\tstr = (map != NULL) ? map_token (map->global, 0, peek) : \"Single-byte extension\";\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_extension_token, tvb, off, 1, str,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | EXT_%1x      (Extension Token)    | %s(%s)\",\n\t\t\t\t\t     *level, *codepage_stag, peek & 0x0f, Indent (*level), str);\n\t\t\toff++;\n\t\t\tbreak;\n\t\tcase 0xC3: /* OPAQUE - WBXML 1.1 and newer */\n\t\t\tif (tvb_get_guint8 (tvb, 0)) { /* WBXML 1.x (x > 0) */\n\t\t\t\tif (map != NULL)\n\t\t\t\t{\n\t\t\t\t\tchar *tmp_str;\n\t\t\t\t\tif (tag_save_known) { /* Knwon tag */\n\t\t\t\t\t\tif (map->opaque_binary_tag) {\n\t\t\t\t\t\t\ttmp_str = map->opaque_binary_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t     tag_save_known, *codepage_stag, &len, pinfo);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp_str = default_opaque_binary_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t\ttag_save_known, *codepage_stag, &len, pinfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { /* lITERAL tag */\n\t\t\t\t\t\tif (map->opaque_literal_tag) {\n\t\t\t\t\t\t\ttmp_str = map->opaque_literal_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t      tag_save_literal, *codepage_stag, &len, pinfo);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp_str = default_opaque_literal_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t\t tag_save_literal, *codepage_stag, &len, pinfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len, NULL,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | OPAQUE (Opaque data)            | %s%s\",\n\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), tmp_str);\n\t\t\t\t\toff += 1 + len;\n\t\t\t\t} else {\n\t\t\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len + idx, NULL,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | OPAQUE (Opaque data)            | %s(%u bytes of opaque data)\",\n\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), idx);\n\t\t\t\t\toff += 1+len+idx;\n\t\t\t\t}\n\t\t\t} else { /* WBXML 1.0 - RESERVED_2 token (invalid) */\n\t\t\t\tproto_tree_add_none_format(tree, hf_wbxml_reserved_2, tvb, off, 1,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | RESERVED_2     (Invalid Token!) | WBXML 1.0 parsing stops here.\",\n\t\t\t\t\t\t     *level, *codepage_stag);\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t\tDebugLog((\"STAG: level = %u, Return: len = %u\\n\", *level, off - offset));\n\t\t\t\treturn (off - offset);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\t/* No default clause, as all cases have been treated */\n\t\t} else { /* LITERAL or Known TAG */\n\t\t\t/* We must store the initial tag, and also retrieve the new tag.\n\t\t\t * For efficiency reasons, we store the literal tag representation\n\t\t\t * for known tags too, so we can easily close the tag without the\n\t\t\t * need of a new lookup and avoiding storage of token codepage.\n\t\t\t *\n\t\t\t * There are 4 possibilities:\n\t\t\t *\n\t\t\t *  1. Known tag followed by a known tag\n\t\t\t *  2. Known tag followed by a LITERAL tag\n\t\t\t *  3. LITERAL tag followed by Known tag\n\t\t\t *  4. LITERAL tag followed by LITERAL tag\n\t\t\t */\n\n\t\t\t/* Store the new tag */\n\t\t\ttag_len = 0;\n\t\t\tif ((peek & 0x3F) == 4) { /* LITERAL */\n\t\t\t\tDebugLog((\"STAG: LITERAL tag (peek = 0x%02X, off = %u) - TableRef follows!\\n\", peek, off));\n\t\t\t\tidx = tvb_get_guintvar (tvb, off+1, &tag_len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\t\ttag_new_literal = (const gchar*)tvb_get_ptr (tvb, str_tbl+idx, str_len);\n\t\t\t\ttag_new_known = 0; /* invalidate known tag_new */\n\t\t\t} else { /* Known tag */\n\t\t\t\ttag_new_known = peek & 0x3F;\n\t\t\t\tif (map != NULL) {\n\t\t\t\t\ttag_new_literal = map_token (map->tags, *codepage_stag,\n\t\t\t\t\t\t\t     tag_new_known);\n\t\t\t\t} else {\n\t\t\t\t\ttag_new_literal = wmem_strdup_printf(wmem_packet_scope(), \"Tag_0x%02X\",\n\t\t\t\t\t\t\ttag_new_known);\n\t\t\t\t}\n\t\t\t\t/* Stored looked up tag name string */\n\t\t\t}\n\n\t\t\t/* Parsing of TAG starts HERE */\n\t\t\tif (peek & 0x40) { /* Content present */\n\t\t\t\t/* Content follows\n\t\t\t\t * [!] An explicit END token is expected in these cases!\n\t\t\t\t * ==> Recursion possible if we encounter a tag with content;\n\t\t\t\t *     recursion will return at the explicit END token.\n\t\t\t\t */\n\t\t\t\tif (parsing_tag_content) { /* Recurse */\n\t\t\t\t\tDebugLog((\"STAG: Tag in Tag - RECURSE! (off = %u)\\n\", off));\n\t\t\t\t\t/* Do not process the attribute list:\n\t\t\t\t\t * recursion will take care of it */\n\t\t\t\t\t(*level)++;\n\t\t\t\t\tlen = parse_wbxml_tag_defined (tree, tvb, pinfo, off, str_tbl,\n\t\t\t\t\t\t\t\t       level, codepage_stag, codepage_attr, map);\n\t\t\t\t\toff += len;\n\t\t\t\t} else { /* Now we will have content to parse */\n\t\t\t\t\t/* Save the start tag so we can properly close it later. */\n\t\t\t\t\tif ((peek & 0x3F) == 4) { /* Literal tag */\n\t\t\t\t\t\ttag_save_literal = tag_new_literal;\n\t\t\t\t\t\ttag_save_known = 0;\n\t\t\t\t\t} else { /* Known tag */\n\t\t\t\t\t\ttag_save_known = tag_new_known;\n\t\t\t\t\t\ttag_save_literal = tag_new_literal;\n\t\t\t\t\t\t/* The last statement avoids needless lookups */\n\t\t\t\t\t}\n\t\t\t\t\t/* Process the attribute list if present */\n\t\t\t\t\tif (peek & 0x80) { /* Content and Attribute list present */\n\t\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    |   Known Tag 0x%02X           (AC) | %s<%s\",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\t\toff++;\n\t\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal_ac, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | LITERAL_AC (Literal tag)   (AC) | %s<%s\",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), tag_new_literal);\n\t\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo,\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, *level, codepage_attr, map);\n\t\t\t\t\t\t/* Check that there is still room in packet */\n\t\t\t\t\t\toff += len;\n\t\t\t\t\t\tif (off >= tvb_len) {\n\t\t\t\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\",\n\t\t\t\t\t\t\t\t  *level, off - offset));\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tproto_tree_add_none_format(tree, hf_wbxml_end_attribute_list, tvb, off-1, 1,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (attribute list)            | %s>\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\t\t\t} else { /* Content, no Attribute list */\n\t\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    |   Known Tag 0x%02X           (.C) | %s<%s>\",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\t\toff++;\n\t\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal_c, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | LITERAL_C  (Literal Tag)   (.C) | %s<%s>\",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), tag_new_literal);\n\t\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/* The data that follows in the parsing process\n\t\t\t\t\t * represents content for the opening tag\n\t\t\t\t\t * we've just processed in the lines above.\n\t\t\t\t\t * Next time we encounter a tag with content: recurse\n\t\t\t\t\t */\n\t\t\t\t\tparsing_tag_content = TRUE;\n\t\t\t\t\tDebugLog((\"Tag in Tag - No recursion this time! (off = %u)\\n\", off));\n\t\t\t\t}\n\t\t\t} else { /* No Content */\n\t\t\t\tDebugLog((\"<Tag/> in Tag - No recursion! (off = %u)\\n\", off));\n\t\t\t\t(*level)++;\n\t\t\t\tif (peek & 0x80) { /* No Content, Attribute list present */\n\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    |   Known Tag 0x%02X           (A.) | %s<%s\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\toff++;\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo,\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, *level, codepage_attr, map);\n\t\t\t\t\t\t/* Check that there is still room in packet */\n\t\t\t\t\t\toff += len;\n\t\t\t\t\t\tif (off > tvb_len) {\n\t\t\t\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\", *level, off - offset));\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_end_known_tag_uint, tvb, off-1, 1, *codepage_stag,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (Known Tag)                 | %s/>\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal_a, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | LITERAL_A  (Literal Tag)   (A.) | %s<%s\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), tag_new_literal);\n\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo,\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, *level, codepage_attr, map);\n\t\t\t\t\t\t/* Check that there is still room in packet */\n\t\t\t\t\t\toff += len;\n\t\t\t\t\t\tif (off >= tvb_len) {\n\t\t\t\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\", *level, off - offset));\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_end_literal_tag, tvb, off-1, 1, \"\",\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (Literal Tag)               | %s/>\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\t\t\t}\n\t\t\t\t} else { /* No Content, No Attribute list */\n\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    |   Known Tag 0x%02x           (..) | %s<%s />\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\toff++;\n\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | LITERAL    (Literal Tag)   (..) | %s<%s />\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level),\n\t\t\t\t\t\t\t\t     tag_new_literal);\n\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t(*level)--;\n\t\t\t\t/* TODO: Do I have to reset code page here? */\n\t\t\t}\n\t\t} /* if (tag & 0x3F) >= 5 */\n\t} /* while */\n\tDebugLog((\"STAG: level = %u, Return: len = %u (end of function body)\\n\", *level, off - offset));\n\treturn (off - offset);\n}", "target": 1, "idx": 10190}
{"commit_id": "cf70b79d2662c0d3c6af74583641e345fc939467", "project": "tensorflow", "func": "Status SparseTensorFromContext(OpKernelContext* ctx, const int32_t base_index,\n                               const bool validate_indices,\n                               sparse::SparseTensor* tensor) {\n  // Assume row-major order.\n  TensorShape shape;\n  const Tensor& shape_tensor = ctx->input(base_index + 2);\n  if (shape_tensor.dims() != 1) {\n    return errors::InvalidArgument(\"Shape must be a 1D tensor.\");\n  }\n  TF_RETURN_IF_ERROR(\n      TensorShape::BuildTensorShape(shape_tensor.vec<int64_t>(), &shape));\n  CheckRankAtLeast2(ctx, shape);\n  std::vector<int64_t> order(shape.dims());\n  std::iota(order.begin(), order.end(), 0);\n\n  Status status = sparse::SparseTensor::Create(\n      ctx->input(base_index), ctx->input(base_index + 1), shape, order, tensor);\n\n  if (!validate_indices || !status.ok()) return status;\n  return tensor->IndicesValid();\n}", "target": 1, "idx": 10191}
{"commit_id": "e7719a0dfac7a20cb7da5529e09773d8271bb78b", "project": "xen-project/xen", "func": "int pirq_guest_unmask(struct domain *d)\n{\n    unsigned int pirq = 0, n, i;\n    struct pirq *pirqs[16];\n\n    do {\n        n = radix_tree_gang_lookup(&d->pirq_tree, (void **)pirqs, pirq,\n                                   ARRAY_SIZE(pirqs));\n        for ( i = 0; i < n; ++i )\n        {\n            pirq = pirqs[i]->pirq;\n            if ( pirqs[i]->masked &&\n                 !evtchn_port_is_masked(d, pirqs[i]->evtchn) )\n                pirq_guest_eoi(pirqs[i]);\n        }\n    } while ( ++pirq < d->nr_pirqs && n == ARRAY_SIZE(pirqs) );\n\n    return 0;\n}", "target": 3, "idx": 10192}
{"commit_id": "93ce93587d36493f2f86921fa79921b3cba63fbb", "project": "torvalds/linux", "func": "bool cachefiles_set_volume_xattr(struct cachefiles_volume *volume)\n{\n\tstruct cachefiles_vol_xattr *buf;\n\tunsigned int len = volume->vcookie->coherency_len;\n\tconst void *p = volume->vcookie->coherency;\n\tstruct dentry *dentry = volume->dentry;\n\tint ret;\n\n\t_enter(\"%x,#%d\", volume->vcookie->debug_id, len);\n\n\tlen += sizeof(*buf);\n\tbuf = kmalloc(len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn false;\n\tbuf->reserved = cpu_to_be32(0);\n\tmemcpy(buf->data, p, len);\n\n\tret = cachefiles_inject_write_error();\n\tif (ret == 0)\n\t\tret = vfs_setxattr(&init_user_ns, dentry, cachefiles_xattr_cache,\n\t\t\t\t   buf, len, 0);\n\tif (ret < 0) {\n\t\ttrace_cachefiles_vfs_error(NULL, d_inode(dentry), ret,\n\t\t\t\t\t   cachefiles_trace_setxattr_error);\n\t\ttrace_cachefiles_vol_coherency(volume, d_inode(dentry)->i_ino,\n\t\t\t\t\t       cachefiles_coherency_vol_set_fail);\n\t\tif (ret != -ENOMEM)\n\t\t\tcachefiles_io_error(\n\t\t\t\tvolume->cache, \"Failed to set xattr with error %d\", ret);\n\t} else {\n\t\ttrace_cachefiles_vol_coherency(volume, d_inode(dentry)->i_ino,\n\t\t\t\t\t       cachefiles_coherency_vol_set_ok);\n\t}\n\n\tkfree(buf);\n\t_leave(\" = %d\", ret);\n\treturn ret == 0;\n}", "target": 2, "idx": 10193}
{"commit_id": "557b84becbfe9f6d10c281bb0b2dbb75403a497f", "project": "chromium", "func": "void* Zone::New(size_t size) {\n  // Round up the requested size to fit the alignment.\n  size = RoundUp(size, kAlignment);\n\n  // If the allocation size is divisible by 8 then we return an 8-byte aligned\n  // address.\n  if (kPointerSize == 4 && kAlignment == 4) {\n    position_ += ((~size) & 4) & (reinterpret_cast<intptr_t>(position_) & 4);\n  } else {\n    DCHECK(kAlignment >= kPointerSize);\n  }\n\n  // Check if the requested size is available without expanding.\n  Address result = position_;\n\n  const size_t size_with_redzone = size + kASanRedzoneBytes;\n  const uintptr_t limit = reinterpret_cast<uintptr_t>(limit_);\n  const uintptr_t position = reinterpret_cast<uintptr_t>(position_);\n  // position_ > limit_ can be true after the alignment correction above.\n  if (limit < position || size_with_redzone > limit - position) {\n    result = NewExpand(size_with_redzone);\n  } else {\n    position_ += size_with_redzone;\n  }\n\n  Address redzone_position = result + size;\n  DCHECK(redzone_position + kASanRedzoneBytes == position_);\n  ASAN_POISON_MEMORY_REGION(redzone_position, kASanRedzoneBytes);\n\n  // Check that the result has the proper alignment and return it.\n  DCHECK(IsAddressAligned(result, kAlignment, 0));\n  allocation_size_ += size;\n  return reinterpret_cast<void*>(result);\n}", "target": 2, "idx": 10194}
{"commit_id": "3450121997ce872eb7f1248417225827ea249710", "project": "torvalds/linux", "func": "int line6_init_pcm(struct usb_line6 *line6,\n\t\t   struct line6_pcm_properties *properties)\n{\n\tint i, err;\n\tunsigned ep_read = line6->properties->ep_audio_r;\n\tunsigned ep_write = line6->properties->ep_audio_w;\n\tstruct snd_pcm *pcm;\n\tstruct snd_line6_pcm *line6pcm;\n\n\tif (!(line6->properties->capabilities & LINE6_CAP_PCM))\n\t\treturn 0;\t/* skip PCM initialization and report success */\n\n\terr = snd_line6_new_pcm(line6, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tline6pcm = kzalloc(sizeof(*line6pcm), GFP_KERNEL);\n\tif (!line6pcm)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&line6pcm->state_mutex);\n\tline6pcm->pcm = pcm;\n\tline6pcm->properties = properties;\n\tline6pcm->volume_playback[0] = line6pcm->volume_playback[1] = 255;\n\tline6pcm->volume_monitor = 255;\n\tline6pcm->line6 = line6;\n\n\tline6pcm->max_packet_size_in =\n\t\tusb_maxpacket(line6->usbdev,\n\t\t\tusb_rcvisocpipe(line6->usbdev, ep_read), 0);\n\tline6pcm->max_packet_size_out =\n\t\tusb_maxpacket(line6->usbdev,\n\t\t\tusb_sndisocpipe(line6->usbdev, ep_write), 1);\n\tif (!line6pcm->max_packet_size_in || !line6pcm->max_packet_size_out) {\n\t\tdev_err(line6pcm->line6->ifcdev,\n\t\t\t\"cannot get proper max packet size\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_init(&line6pcm->out.lock);\n\tspin_lock_init(&line6pcm->in.lock);\n\tline6pcm->impulse_period = LINE6_IMPULSE_DEFAULT_PERIOD;\n\n\tline6->line6pcm = line6pcm;\n\n\tpcm->private_data = line6pcm;\n\tpcm->private_free = line6_cleanup_pcm;\n\n\terr = line6_create_audio_out_urbs(line6pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = line6_create_audio_in_urbs(line6pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\t/* mixer: */\n\tfor (i = 0; i < ARRAY_SIZE(line6_controls); i++) {\n\t\terr = snd_ctl_add(line6->card,\n\t\t\t\t  snd_ctl_new1(&line6_controls[i], line6pcm));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}", "target": 1, "idx": 10195}
{"commit_id": "a0d1cbdacff5df4ded16b753b38fdd9da6092968", "project": "qemu", "func": "static ssize_t eth_rx(NetClientState *nc, const uint8_t *buf, size_t size)\n{\n    struct xlx_ethlite *s = qemu_get_nic_opaque(nc);\n    unsigned int rxbase = s->rxbuf * (0x800 / 4);\n\n    /* DA filter.  */\n    if (!(buf[0] & 0x80) && memcmp(&s->conf.macaddr.a[0], buf, 6))\n        return size;\n\n    if (s->regs[rxbase + R_RX_CTRL0] & CTRL_S) {\n        D(qemu_log(\"ethlite lost packet %x\\n\", s->regs[R_RX_CTRL0]));\n        return -1;\n    }\n\n    D(qemu_log(\"%s %zd rxbase=%x\\n\", __func__, size, rxbase));\n    if (size > (R_MAX - R_RX_BUF0 - rxbase) * 4) {\n        D(qemu_log(\"ethlite packet is too big, size=%x\\n\", size));\n        return -1;\n    }\n    memcpy(&s->regs[rxbase + R_RX_BUF0], buf, size);\n\n    s->regs[rxbase + R_RX_CTRL0] |= CTRL_S;\n    if (s->regs[R_RX_CTRL0] & CTRL_I) {\n        eth_pulse_irq(s);\n    }\n\n    /* If c_rx_pingpong was set flip buffers.  */\n    s->rxbuf ^= s->c_rx_pingpong;\n    return size;\n}", "target": 3, "idx": 10196}
{"commit_id": "d7fc532c42f0e9bf427923bab85433282b3e5117", "project": "containers/bubblewrap", "func": "int\nmain (int    argc,\n      char **argv)\n{\n  mode_t old_umask;\n  cleanup_free char *base_path = NULL;\n  int clone_flags;\n  char *old_cwd = NULL;\n  pid_t pid;\n  int event_fd = -1;\n  int child_wait_fd = -1;\n  const char *new_cwd;\n  uid_t ns_uid;\n  gid_t ns_gid;\n  struct stat sbuf;\n  uint64_t val;\n  int res UNUSED;\n\n  real_uid = getuid ();\n  real_gid = getgid ();\n\n  /* Get the (optional) privileges we need */\n  acquire_privs ();\n\n  /* Never gain any more privs during exec */\n  if (prctl (PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) < 0)\n    die_with_error (\"prctl(PR_SET_NO_NEW_CAPS) failed\");\n\n  /* The initial code is run with high permissions\n     (i.e. CAP_SYS_ADMIN), so take lots of care. */\n\n  read_overflowids ();\n\n  argv0 = argv[0];\n\n  if (isatty (1))\n    host_tty_dev = ttyname (1);\n\n  argv++;\n  argc--;\n\n  if (argc == 0)\n    usage (EXIT_FAILURE, stderr);\n\n  parse_args (&argc, &argv);\n\n  /* We have to do this if we weren't installed setuid (and we're not\n   * root), so let's just DWIM */\n  if (!is_privileged && getuid () != 0)\n    opt_unshare_user = TRUE;\n\n  if (opt_unshare_user_try &&\n      stat (\"/proc/self/ns/user\", &sbuf) == 0)\n    {\n      bool disabled = FALSE;\n\n      /* RHEL7 has a kernel module parameter that lets you enable user namespaces */\n      if (stat (\"/sys/module/user_namespace/parameters/enable\", &sbuf) == 0)\n        {\n          cleanup_free char *enable = NULL;\n          enable = load_file_at (AT_FDCWD, \"/sys/module/user_namespace/parameters/enable\");\n          if (enable != NULL && enable[0] == 'N')\n            disabled = TRUE;\n        }\n\n      /* Debian lets you disable *unprivileged* user namespaces. However this is not\n         a problem if we're privileged, and if we're not opt_unshare_user is TRUE\n         already, and there is not much we can do, its just a non-working setup. */\n\n      if (!disabled)\n        opt_unshare_user = TRUE;\n    }\n\n  if (argc == 0)\n    usage (EXIT_FAILURE, stderr);\n\n  __debug__ ((\"Creating root mount point\\n\"));\n\n  if (opt_sandbox_uid == -1)\n    opt_sandbox_uid = real_uid;\n  if (opt_sandbox_gid == -1)\n    opt_sandbox_gid = real_gid;\n\n  if (!opt_unshare_user && opt_sandbox_uid != real_uid)\n    die (\"Specifying --uid requires --unshare-user\");\n\n  if (!opt_unshare_user && opt_sandbox_gid != real_gid)\n    die (\"Specifying --gid requires --unshare-user\");\n\n  if (!opt_unshare_uts && opt_sandbox_hostname != NULL)\n    die (\"Specifying --hostname requires --unshare-uts\");\n\n  /* We need to read stuff from proc during the pivot_root dance, etc.\n     Lets keep a fd to it open */\n  proc_fd = open (\"/proc\", O_RDONLY | O_PATH);\n  if (proc_fd == -1)\n    die_with_error (\"Can't open /proc\");\n\n  /* We need *some* mountpoint where we can mount the root tmpfs.\n     We first try in /run, and if that fails, try in /tmp. */\n  base_path = xasprintf (\"/run/user/%d/.bubblewrap\", real_uid);\n  if (mkdir (base_path, 0755) && errno != EEXIST)\n    {\n      free (base_path);\n      base_path = xasprintf (\"/tmp/.bubblewrap-%d\", real_uid);\n      if (mkdir (base_path, 0755) && errno != EEXIST)\n        die_with_error (\"Creating root mountpoint failed\");\n    }\n\n  __debug__ ((\"creating new namespace\\n\"));\n\n  if (opt_unshare_pid)\n    {\n      event_fd = eventfd (0, EFD_CLOEXEC | EFD_NONBLOCK);\n      if (event_fd == -1)\n        die_with_error (\"eventfd()\");\n    }\n\n  /* We block sigchild here so that we can use signalfd in the monitor. */\n  block_sigchild ();\n\n  clone_flags = SIGCHLD | CLONE_NEWNS;\n  if (opt_unshare_user)\n    clone_flags |= CLONE_NEWUSER;\n  if (opt_unshare_pid)\n    clone_flags |= CLONE_NEWPID;\n  if (opt_unshare_net)\n    clone_flags |= CLONE_NEWNET;\n  if (opt_unshare_ipc)\n    clone_flags |= CLONE_NEWIPC;\n  if (opt_unshare_uts)\n    clone_flags |= CLONE_NEWUTS;\n  if (opt_unshare_cgroup)\n    {\n      if (stat (\"/proc/self/ns/cgroup\", &sbuf))\n        {\n          if (errno == ENOENT)\n            die (\"Cannot create new cgroup namespace because the kernel does not support it\");\n          else\n            die_with_error (\"stat on /proc/self/ns/cgroup failed\");\n        }\n      clone_flags |= CLONE_NEWCGROUP;\n    }\n  if (opt_unshare_cgroup_try)\n    if (!stat (\"/proc/self/ns/cgroup\", &sbuf))\n      clone_flags |= CLONE_NEWCGROUP;\n\n  child_wait_fd = eventfd (0, EFD_CLOEXEC);\n  if (child_wait_fd == -1)\n    die_with_error (\"eventfd()\");\n\n  pid = raw_clone (clone_flags, NULL);\n  if (pid == -1)\n    {\n      if (opt_unshare_user)\n        {\n          if (errno == EINVAL)\n            die (\"Creating new namespace failed, likely because the kernel does not support user namespaces.  bwrap must be installed setuid on such systems.\");\n          else if (errno == EPERM && !is_privileged)\n            die (\"No permissions to creating new namespace, likely because the kernel does not allow non-privileged user namespaces. On e.g. debian this can be enabled with 'sysctl kernel.unprivileged_userns_clone=1'.\");\n        }\n\n      die_with_error (\"Creating new namespace failed\");\n    }\n\n  ns_uid = opt_sandbox_uid;\n  ns_gid = opt_sandbox_gid;\n\n  if (pid != 0)\n    {\n      /* Parent, outside sandbox, privileged (initially) */\n\n      if (is_privileged && opt_unshare_user)\n        {\n          /* We're running as euid 0, but the uid we want to map is\n           * not 0. This means we're not allowed to write this from\n           * the child user namespace, so we do it from the parent.\n           *\n           * Also, we map uid/gid 0 in the namespace (to overflowuid)\n           * if opt_needs_devpts is true, because otherwise the mount\n           * of devpts fails due to root not being mapped.\n           */\n          write_uid_gid_map (ns_uid, real_uid,\n                             ns_gid, real_gid,\n                             pid, TRUE, opt_needs_devpts);\n        }\n\n      /* Initial launched process, wait for exec:ed command to exit */\n\n      /* We don't need any privileges in the launcher, drop them immediately. */\n      drop_privs ();\n\n      /* Let child run now that the uid maps are set up */\n      val = 1;\n      res = write (child_wait_fd, &val, 8);\n      /* Ignore res, if e.g. the child died and closed child_wait_fd we don't want to error out here */\n      close (child_wait_fd);\n\n      if (opt_info_fd != -1)\n        {\n          cleanup_free char *output = xasprintf (\"{\\n    \\\"child-pid\\\": %i\\n}\\n\", pid);\n          size_t len = strlen (output);\n          if (write (opt_info_fd, output, len) != len)\n            die_with_error (\"Write to info_fd\");\n          close (opt_info_fd);\n        }\n\n      monitor_child (event_fd);\n      exit (0); /* Should not be reached, but better safe... */\n    }\n\n  /* Child, in sandbox, privileged in the parent or in the user namespace (if --unshare-user).\n   *\n   * Note that for user namespaces we run as euid 0 during clone(), so\n   * the child user namespace is owned by euid 0., This means that the\n   * regular user namespace parent (with uid != 0) doesn't have any\n   * capabilities in it, which is nice as we can't exploit those. In\n   * particular the parent user namespace doesn't have CAP_PTRACE\n   * which would otherwise allow the parent to hijack of the child\n   * after this point.\n   *\n   * Unfortunately this also means you can't ptrace the final\n   * sandboxed process from outside the sandbox either.\n   */\n\n  if (opt_info_fd != -1)\n    close (opt_info_fd);\n\n  /* Wait for the parent to init uid/gid maps and drop caps */\n  res = read (child_wait_fd, &val, 8);\n  close (child_wait_fd);\n\n  /* At this point we can completely drop root uid, but retain the\n   * required permitted caps. This allow us to do full setup as\n   * the user uid, which makes e.g. fuse access work.\n   */\n  switch_to_user_with_privs ();\n\n  if (opt_unshare_net && loopback_setup () != 0)\n    die (\"Can't create loopback device\");\n\n  ns_uid = opt_sandbox_uid;\n  ns_gid = opt_sandbox_gid;\n  if (!is_privileged && opt_unshare_user)\n    {\n      /* In the unprivileged case we have to write the uid/gid maps in\n       * the child, because we have no caps in the parent */\n\n      if (opt_needs_devpts)\n        {\n          /* This is a bit hacky, but we need to first map the real uid/gid to\n             0, otherwise we can't mount the devpts filesystem because root is\n             not mapped. Later we will create another child user namespace and\n             map back to the real uid */\n          ns_uid = 0;\n          ns_gid = 0;\n        }\n\n      write_uid_gid_map (ns_uid, real_uid,\n                         ns_gid, real_gid,\n                         -1, TRUE, FALSE);\n    }\n\n  old_umask = umask (0);\n\n  /* Need to do this before the chroot, but after we're the real uid */\n  resolve_symlinks_in_ops ();\n\n  /* Mark everything as slave, so that we still\n   * receive mounts from the real root, but don't\n   * propagate mounts to the real root. */\n  if (mount (NULL, \"/\", NULL, MS_SLAVE | MS_REC, NULL) < 0)\n    die_with_error (\"Failed to make / slave\");\n\n  /* Create a tmpfs which we will use as / in the namespace */\n  if (mount (\"\", base_path, \"tmpfs\", MS_NODEV | MS_NOSUID, NULL) != 0)\n    die_with_error (\"Failed to mount tmpfs\");\n\n  old_cwd = get_current_dir_name ();\n\n  /* Chdir to the new root tmpfs mount. This will be the CWD during\n     the entire setup. Access old or new root via \"oldroot\" and \"newroot\". */\n  if (chdir (base_path) != 0)\n    die_with_error (\"chdir base_path\");\n\n  /* We create a subdir \"$base_path/newroot\" for the new root, that\n   * way we can pivot_root to base_path, and put the old root at\n   * \"$base_path/oldroot\". This avoids problems accessing the oldroot\n   * dir if the user requested to bind mount something over / */\n\n  if (mkdir (\"newroot\", 0755))\n    die_with_error (\"Creating newroot failed\");\n\n  if (mkdir (\"oldroot\", 0755))\n    die_with_error (\"Creating oldroot failed\");\n\n  if (pivot_root (base_path, \"oldroot\"))\n    die_with_error (\"pivot_root\");\n\n  if (chdir (\"/\") != 0)\n    die_with_error (\"chdir / (base path)\");\n\n  if (is_privileged)\n    {\n      pid_t child;\n      int privsep_sockets[2];\n\n      if (socketpair (AF_UNIX, SOCK_SEQPACKET | SOCK_CLOEXEC, 0, privsep_sockets) != 0)\n        die_with_error (\"Can't create privsep socket\");\n\n      child = fork ();\n      if (child == -1)\n        die_with_error (\"Can't fork unprivileged helper\");\n\n      if (child == 0)\n        {\n          /* Unprivileged setup process */\n          drop_privs ();\n          close (privsep_sockets[0]);\n          setup_newroot (opt_unshare_pid, privsep_sockets[1]);\n          exit (0);\n        }\n      else\n        {\n          int status;\n          uint32_t buffer[2048];  /* 8k, but is int32 to guarantee nice alignment */\n          uint32_t op, flags;\n          const char *arg1, *arg2;\n          cleanup_fd int unpriv_socket = -1;\n\n          unpriv_socket = privsep_sockets[0];\n          close (privsep_sockets[1]);\n\n          do\n            {\n              op = read_priv_sec_op (unpriv_socket, buffer, sizeof (buffer),\n                                     &flags, &arg1, &arg2);\n              privileged_op (-1, op, flags, arg1, arg2);\n              if (write (unpriv_socket, buffer, 1) != 1)\n                die (\"Can't write to op_socket\");\n            }\n          while (op != PRIV_SEP_OP_DONE);\n\n          waitpid (child, &status, 0);\n          /* Continue post setup */\n        }\n    }\n  else\n    {\n      setup_newroot (opt_unshare_pid, -1);\n    }\n\n  /* The old root better be rprivate or we will send unmount events to the parent namespace */\n  if (mount (\"oldroot\", \"oldroot\", NULL, MS_REC | MS_PRIVATE, NULL) != 0)\n    die_with_error (\"Failed to make old root rprivate\");\n\n  if (umount2 (\"oldroot\", MNT_DETACH))\n    die_with_error (\"unmount old root\");\n\n  if (opt_unshare_user &&\n      (ns_uid != opt_sandbox_uid || ns_gid != opt_sandbox_gid))\n    {\n      /* Now that devpts is mounted and we've no need for mount\n         permissions we can create a new userspace and map our uid\n         1:1 */\n\n      if (unshare (CLONE_NEWUSER))\n        die_with_error (\"unshare user ns\");\n\n      write_uid_gid_map (opt_sandbox_uid, ns_uid,\n                         opt_sandbox_gid, ns_gid,\n                         -1, FALSE, FALSE);\n    }\n\n  /* Now make /newroot the real root */\n  if (chdir (\"/newroot\") != 0)\n    die_with_error (\"chdir newroot\");\n  if (chroot (\"/newroot\") != 0)\n    die_with_error (\"chroot /newroot\");\n  if (chdir (\"/\") != 0)\n    die_with_error (\"chdir /\");\n\n  /* All privileged ops are done now, so drop it */\n  drop_privs ();\n\n  if (opt_block_fd != -1)\n    {\n      char b[1];\n      read (opt_block_fd, b, 1);\n      close (opt_block_fd);\n    }\n\n  if (opt_seccomp_fd != -1)\n    {\n      cleanup_free char *seccomp_data = NULL;\n      size_t seccomp_len;\n      struct sock_fprog prog;\n\n      seccomp_data = load_file_data (opt_seccomp_fd, &seccomp_len);\n      if (seccomp_data == NULL)\n        die_with_error (\"Can't read seccomp data\");\n\n      if (seccomp_len % 8 != 0)\n        die (\"Invalid seccomp data, must be multiple of 8\");\n\n      prog.len = seccomp_len / 8;\n      prog.filter = (struct sock_filter *) seccomp_data;\n\n      close (opt_seccomp_fd);\n\n      if (prctl (PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog) != 0)\n        die_with_error (\"prctl(PR_SET_SECCOMP)\");\n    }\n\n  umask (old_umask);\n\n  new_cwd = \"/\";\n  if (opt_chdir_path)\n    {\n      if (chdir (opt_chdir_path))\n        die_with_error (\"Can't chdir to %s\", opt_chdir_path);\n      new_cwd = opt_chdir_path;\n    }\n  else if (chdir (old_cwd) == 0)\n    {\n      /* If the old cwd is mapped in the sandbox, go there */\n      new_cwd = old_cwd;\n    }\n  else\n    {\n      /* If the old cwd is not mapped, go to home */\n      const char *home = getenv (\"HOME\");\n      if (home != NULL &&\n          chdir (home) == 0)\n        new_cwd = home;\n    }\n  xsetenv (\"PWD\", new_cwd, 1);\n  free (old_cwd);\n\n  __debug__ ((\"forking for child\\n\"));\n\n  if (opt_unshare_pid || lock_files != NULL || opt_sync_fd != -1)\n    {\n      /* We have to have a pid 1 in the pid namespace, because\n       * otherwise we'll get a bunch of zombies as nothing reaps\n       * them. Alternatively if we're using sync_fd or lock_files we\n       * need some process to own these.\n       */\n\n      pid = fork ();\n      if (pid == -1)\n        die_with_error (\"Can't fork for pid 1\");\n\n      if (pid != 0)\n        {\n          /* Close fds in pid 1, except stdio and optionally event_fd\n             (for syncing pid 2 lifetime with monitor_child) and\n             opt_sync_fd (for syncing sandbox lifetime with outside\n             process).\n             Any other fds will been passed on to the child though. */\n          {\n            int dont_close[3];\n            int j = 0;\n            if (event_fd != -1)\n              dont_close[j++] = event_fd;\n            if (opt_sync_fd != -1)\n              dont_close[j++] = opt_sync_fd;\n            dont_close[j++] = -1;\n            fdwalk (proc_fd, close_extra_fds, dont_close);\n          }\n\n          return do_init (event_fd, pid);\n        }\n    }\n\n  __debug__ ((\"launch executable %s\\n\", argv[0]));\n\n  if (proc_fd != -1)\n    close (proc_fd);\n\n  if (opt_sync_fd != -1)\n    close (opt_sync_fd);\n\n  /* We want sigchild in the child */\n  unblock_sigchild ();\n\n  if (setsid () == (pid_t) -1)\n    die_with_error (\"setsid\");\n\n  if (label_exec (opt_exec_label) == -1)\n    die_with_error (\"label_exec %s\", argv[0]);\n\n  if (execvp (argv[0], argv) == -1)\n    die_with_error (\"execvp %s\", argv[0]);\n\n  return 0;\n}", "target": 3, "idx": 10197}
{"commit_id": "4f663d4b8f0bec1b48da6fa091a7d29609980fa4", "project": "tensorflow", "func": "ImmutableConstantOp::ImmutableConstantOp(OpKernelConstruction* context)\n    : OpKernel(context) {\n  OP_REQUIRES_OK(context,\n                 context->GetAttr(kMemoryRegionNameAttr, &region_name_));\n  OP_REQUIRES_OK(context, context->GetAttr(kDTypeAttr, &dtype_));\n  OP_REQUIRES(context, dtype_ != DT_RESOURCE && dtype_ != DT_VARIANT,\n              errors::InvalidArgument(\n                  \"Resource and variant dtypes are invalid for this op.\"));\n  OP_REQUIRES_OK(context, context->GetAttr(kShapeAttr, &shape_));\n}", "target": 0, "idx": 10198}
{"commit_id": "94fbc54b6c9309912fe3d53e7b63408bbe9a1b0d", "project": "h2o", "func": "static h2o_http2_conn_t *create_conn(h2o_context_t *ctx, h2o_hostconf_t **hosts, h2o_socket_t *sock, struct timeval connected_at)\n{\n    static const h2o_conn_callbacks_t callbacks = {\n        .get_sockname = get_sockname,\n        .get_peername = get_peername,\n        .get_ptls = get_ptls,\n        .skip_tracing = skip_tracing,\n        .get_req_id = get_req_id,\n        .push_path = push_path,\n        .get_debug_state = h2o_http2_get_debug_state,\n        .close_idle_connection = close_idle_connection,\n        .foreach_request = foreach_request,\n        .request_shutdown = initiate_graceful_shutdown,\n        .get_rtt = get_rtt,\n        .log_ = {{\n            .transport =\n                {\n                    .cc_name = log_tcp_congestion_controller,\n                    .delivery_rate = log_tcp_delivery_rate,\n                },\n            .ssl =\n                {\n                    .protocol_version = log_ssl_protocol_version,\n                    .session_reused = log_ssl_session_reused,\n                    .cipher = log_ssl_cipher,\n                    .cipher_bits = log_ssl_cipher_bits,\n                    .session_id = log_ssl_session_id,\n                    .server_name = log_ssl_server_name,\n                    .negotiated_protocol = log_ssl_negotiated_protocol,\n                    .ech_config_id = log_ssl_ech_config_id,\n                    .ech_kem = log_ssl_ech_kem,\n                    .ech_cipher = log_ssl_ech_cipher,\n                    .ech_cipher_bits = log_ssl_ech_cipher_bits,\n                    .backend = log_ssl_backend,\n                },\n            .http2 =\n                {\n                    .stream_id = log_stream_id,\n                    .priority_received = log_priority_received,\n                    .priority_received_exclusive = log_priority_received_exclusive,\n                    .priority_received_parent = log_priority_received_parent,\n                    .priority_received_weight = log_priority_received_weight,\n                    .priority_actual = log_priority_actual,\n                    .priority_actual_parent = log_priority_actual_parent,\n                    .priority_actual_weight = log_priority_actual_weight,\n                },\n        }},\n    };\n\n    h2o_http2_conn_t *conn = (void *)h2o_create_connection(sizeof(*conn), ctx, hosts, connected_at, &callbacks);\n\n    memset((char *)conn + sizeof(conn->super), 0, sizeof(*conn) - sizeof(conn->super));\n    conn->sock = sock;\n    conn->peer_settings = H2O_HTTP2_SETTINGS_DEFAULT;\n    conn->streams = kh_init(h2o_http2_stream_t);\n    h2o_http2_scheduler_init(&conn->scheduler);\n    conn->state = H2O_HTTP2_CONN_STATE_OPEN;\n    conn->_read_expect = expect_preface;\n    conn->_input_header_table.hpack_capacity = conn->_input_header_table.hpack_max_capacity =\n        H2O_HTTP2_SETTINGS_DEFAULT.header_table_size;\n    h2o_http2_window_init(&conn->_input_window, H2O_HTTP2_SETTINGS_HOST_CONNECTION_WINDOW_SIZE);\n    conn->_output_header_table.hpack_capacity = H2O_HTTP2_SETTINGS_DEFAULT.header_table_size;\n    h2o_linklist_init_anchor(&conn->_pending_reqs);\n    h2o_buffer_init(&conn->_write.buf, &h2o_http2_wbuf_buffer_prototype);\n    h2o_linklist_init_anchor(&conn->_write.streams_to_proceed);\n    conn->_write.timeout_entry.cb = emit_writereq;\n    h2o_http2_window_init(&conn->_write.window, conn->peer_settings.initial_window_size);\n    h2o_linklist_init_anchor(&conn->early_data.blocked_streams);\n    conn->is_chromium_dependency_tree = 1; /* initially assume the client is Chromium until proven otherwise */\n    conn->received_any_request = 0;\n    conn->dos_mitigation.process_delay.cb = on_dos_process_delay;\n    conn->dos_mitigation.reset_budget = conn->super.ctx->globalconf->http2.max_concurrent_requests_per_connection;\n\n    return conn;\n}", "target": 2, "idx": 10199}
{"commit_id": "f432de31058b5a94874d47405216d07910c18a9a", "project": "liblouis", "func": "char *EXPORT_CALL\nlou_setDataPath(const char *path) {\n\tstatic char dataPath[MAXSTRING];\n\tdataPathPtr = NULL;\n\tif (path == NULL || strlen(path) >= MAXSTRING) return NULL;\n\tstrcpy(dataPath, path);\n\tdataPathPtr = dataPath;\n\treturn dataPathPtr;\n}", "target": 2, "idx": 10200}
{"commit_id": "8dfbcc4351a0b6d2f2d77f367552f48ffefafe18", "project": "torvalds/linux", "func": "static int xc2028_set_config(struct dvb_frontend *fe, void *priv_cfg)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tstruct xc2028_ctrl *p    = priv_cfg;\n\tint                 rc   = 0;\n\n\ttuner_dbg(\"%s called\\n\", __func__);\n\n\tmutex_lock(&priv->lock);\n\n\t/*\n\t * Copy the config data.\n\t * For the firmware name, keep a local copy of the string,\n\t * in order to avoid troubles during device release.\n\t */\n\tkfree(priv->ctrl.fname);\n\tpriv->ctrl.fname = NULL;\n\tmemcpy(&priv->ctrl, p, sizeof(priv->ctrl));\n\tif (p->fname) {\n\t\tpriv->ctrl.fname = kstrdup(p->fname, GFP_KERNEL);\n\t\tif (priv->ctrl.fname == NULL)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * If firmware name changed, frees firmware. As free_firmware will\n\t * reset the status to NO_FIRMWARE, this forces a new request_firmware\n\t */\n\tif (!firmware_name[0] && p->fname &&\n\t    priv->fname && strcmp(p->fname, priv->fname))\n\t\tfree_firmware(priv);\n\n\tif (priv->ctrl.max_len < 9)\n\t\tpriv->ctrl.max_len = 13;\n\n\tif (priv->state == XC2028_NO_FIRMWARE) {\n\t\tif (!firmware_name[0])\n\t\t\tpriv->fname = priv->ctrl.fname;\n\t\telse\n\t\t\tpriv->fname = firmware_name;\n\n\t\trc = request_firmware_nowait(THIS_MODULE, 1,\n\t\t\t\t\t     priv->fname,\n\t\t\t\t\t     priv->i2c_props.adap->dev.parent,\n\t\t\t\t\t     GFP_KERNEL,\n\t\t\t\t\t     fe, load_firmware_cb);\n\t\tif (rc < 0) {\n\t\t\ttuner_err(\"Failed to request firmware %s\\n\",\n\t\t\t\t  priv->fname);\n\t\t\tpriv->state = XC2028_NODEV;\n\t\t} else\n\t\t\tpriv->state = XC2028_WAITING_FIRMWARE;\n\t}\n\tmutex_unlock(&priv->lock);\n\n\treturn rc;\n}", "target": 2, "idx": 10201}
{"commit_id": "f7c7c3fad6d2135d558f3b36d0d1a943118aeb5e", "project": "vim", "func": "int\nparse_cmd_address(exarg_T *eap, char **errormsg, int silent)\n{\n    int\t\taddress_count = 1;\n    linenr_T\tlnum;\n    int\t\tneed_check_cursor = FALSE;\n    int\t\tret = FAIL;\n\n    // Repeat for all ',' or ';' separated addresses.\n    for (;;)\n    {\n\teap->line1 = eap->line2;\n\teap->line2 = default_address(eap);\n\teap->cmd = skipwhite(eap->cmd);\n\tlnum = get_address(eap, &eap->cmd, eap->addr_type, eap->skip, silent,\n\t\t\t\t\teap->addr_count == 0, address_count++);\n\tif (eap->cmd == NULL)\t// error detected\n\t    goto theend;\n\tif (lnum == MAXLNUM)\n\t{\n\t    if (*eap->cmd == '%')   // '%' - all lines\n\t    {\n\t\t++eap->cmd;\n\t\tswitch (eap->addr_type)\n\t\t{\n\t\t    case ADDR_LINES:\n\t\t    case ADDR_OTHER:\n\t\t\teap->line1 = 1;\n\t\t\teap->line2 = curbuf->b_ml.ml_line_count;\n\t\t\tbreak;\n\t\t    case ADDR_LOADED_BUFFERS:\n\t\t\t{\n\t\t\t    buf_T\t*buf = firstbuf;\n\n\t\t\t    while (buf->b_next != NULL\n\t\t\t\t\t\t  && buf->b_ml.ml_mfp == NULL)\n\t\t\t\tbuf = buf->b_next;\n\t\t\t    eap->line1 = buf->b_fnum;\n\t\t\t    buf = lastbuf;\n\t\t\t    while (buf->b_prev != NULL\n\t\t\t\t\t\t  && buf->b_ml.ml_mfp == NULL)\n\t\t\t\tbuf = buf->b_prev;\n\t\t\t    eap->line2 = buf->b_fnum;\n\t\t\t    break;\n\t\t\t}\n\t\t    case ADDR_BUFFERS:\n\t\t\teap->line1 = firstbuf->b_fnum;\n\t\t\teap->line2 = lastbuf->b_fnum;\n\t\t\tbreak;\n\t\t    case ADDR_WINDOWS:\n\t\t    case ADDR_TABS:\n\t\t\tif (IS_USER_CMDIDX(eap->cmdidx))\n\t\t\t{\n\t\t\t    eap->line1 = 1;\n\t\t\t    eap->line2 = eap->addr_type == ADDR_WINDOWS\n\t\t\t\t\t\t  ? LAST_WIN_NR : LAST_TAB_NR;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // there is no Vim command which uses '%' and\n\t\t\t    // ADDR_WINDOWS or ADDR_TABS\n\t\t\t    *errormsg = _(e_invalid_range);\n\t\t\t    goto theend;\n\t\t\t}\n\t\t\tbreak;\n\t\t    case ADDR_TABS_RELATIVE:\n\t\t    case ADDR_UNSIGNED:\n\t\t    case ADDR_QUICKFIX:\n\t\t\t*errormsg = _(e_invalid_range);\n\t\t\tgoto theend;\n\t\t    case ADDR_ARGUMENTS:\n\t\t\tif (ARGCOUNT == 0)\n\t\t\t    eap->line1 = eap->line2 = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t    eap->line1 = 1;\n\t\t\t    eap->line2 = ARGCOUNT;\n\t\t\t}\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t\t\teap->line1 = 1;\n\t\t\teap->line2 = qf_get_valid_size(eap);\n\t\t\tif (eap->line2 == 0)\n\t\t\t    eap->line2 = 1;\n#endif\n\t\t\tbreak;\n\t\t    case ADDR_NONE:\n\t\t\t// Will give an error later if a range is found.\n\t\t\tbreak;\n\t\t}\n\t\t++eap->addr_count;\n\t    }\n\t    else if (*eap->cmd == '*' && vim_strchr(p_cpo, CPO_STAR) == NULL)\n\t    {\n\t\tpos_T\t    *fp;\n\n\t\t// '*' - visual area\n\t\tif (eap->addr_type != ADDR_LINES)\n\t\t{\n\t\t    *errormsg = _(e_invalid_range);\n\t\t    goto theend;\n\t\t}\n\n\t\t++eap->cmd;\n\t\tif (!eap->skip)\n\t\t{\n\t\t    fp = getmark('<', FALSE);\n\t\t    if (check_mark(fp) == FAIL)\n\t\t\tgoto theend;\n\t\t    eap->line1 = fp->lnum;\n\t\t    fp = getmark('>', FALSE);\n\t\t    if (check_mark(fp) == FAIL)\n\t\t\tgoto theend;\n\t\t    eap->line2 = fp->lnum;\n\t\t    ++eap->addr_count;\n\t\t}\n\t    }\n\t}\n\telse\n\t    eap->line2 = lnum;\n\teap->addr_count++;\n\n\tif (*eap->cmd == ';')\n\t{\n\t    if (!eap->skip)\n\t    {\n\t\tcurwin->w_cursor.lnum = eap->line2;\n\n\t\t// Don't leave the cursor on an illegal line or column, but do\n\t\t// accept zero as address, so 0;/PATTERN/ works correctly\n\t\t// (where zero usually means to use the first line).\n\t\t// Check the cursor position before returning.\n\t\tif (eap->line2 > 0)\n\t\t    check_cursor();\n\t\telse\n\t\t    check_cursor_col();\n\t\tneed_check_cursor = TRUE;\n\t    }\n\t}\n\telse if (*eap->cmd != ',')\n\t    break;\n\t++eap->cmd;\n    }\n\n    // One address given: set start and end lines.\n    if (eap->addr_count == 1)\n    {\n\teap->line1 = eap->line2;\n\t// ... but only implicit: really no address given\n\tif (lnum == MAXLNUM)\n\t    eap->addr_count = 0;\n    }\n    ret = OK;\n\ntheend:\n    if (need_check_cursor)\n\tcheck_cursor();\n    return ret;\n}", "target": 2, "idx": 10202}
{"commit_id": "ff82911cd3f69f028f2537825c9720ff78bc3f19", "project": "qemu", "func": "ssize_t nbd_wr_syncv(QIOChannel *ioc,\n                     struct iovec *iov,\n                     size_t niov,\n                     size_t length,\n                     bool do_read)\n{\n    ssize_t done = 0;\n    Error *local_err = NULL;\n    struct iovec *local_iov = g_new(struct iovec, niov);\n    struct iovec *local_iov_head = local_iov;\n    unsigned int nlocal_iov = niov;\n\n    nlocal_iov = iov_copy(local_iov, nlocal_iov, iov, niov, 0, length);\n\n    while (nlocal_iov > 0) {\n        ssize_t len;\n        if (do_read) {\n            len = qio_channel_readv(ioc, local_iov, nlocal_iov, &local_err);\n        } else {\n            len = qio_channel_writev(ioc, local_iov, nlocal_iov, &local_err);\n        }\n        if (len == QIO_CHANNEL_ERR_BLOCK) {\n            if (qemu_in_coroutine()) {\n                qio_channel_yield(ioc, do_read ? G_IO_IN : G_IO_OUT);\n            } else {\n                return -EAGAIN;\n            }\n            continue;\n        }\n        if (len < 0) {\n            TRACE(\"I/O error: %s\", error_get_pretty(local_err));\n            error_free(local_err);\n            /* XXX handle Error objects */\n            done = -EIO;\n            goto cleanup;\n        }\n\n        if (do_read && len == 0) {\n            break;\n        }\n\n        iov_discard_front(&local_iov, &nlocal_iov, len);\n        done += len;\n    }\n\n cleanup:\n    g_free(local_iov_head);\n    return done;\n}", "target": 1, "idx": 10203}
{"commit_id": "89a5367d49b2556a2635dbb6d48d6a6b182a2c6c", "project": "poppler", "func": "void JPXStream::init()\n{\n  Object oLen, cspace, smaskInData;\n  if (getDict()) {\n    oLen = getDict()->lookup(\"Length\");\n    cspace = getDict()->lookup(\"ColorSpace\");\n    smaskInData = getDict()->lookup(\"SMaskInData\");\n  }\n\n  int bufSize = BUFFER_INITIAL_SIZE;\n  if (oLen.isInt()) bufSize = oLen.getInt();\n\n  bool indexed = false;\n  if (cspace.isArray() && cspace.arrayGetLength() > 0) {\n    const Object cstype = cspace.arrayGet(0);\n    if (cstype.isName(\"Indexed\")) indexed = true;\n  }\n\n  priv->smaskInData = 0;\n  if (smaskInData.isInt()) priv->smaskInData = smaskInData.getInt();\n\n  int length = 0;\n  unsigned char *buf = str->toUnsignedChars(&length, bufSize);\n  priv->init2(OPJ_CODEC_JP2, buf, length, indexed);\n  gfree(buf);\n\n  if (priv->image) {\n    int numComps = (priv->image) ? priv->image->numcomps : 1;\n    int alpha = 0;\n    if (priv->image) {\n      if (priv->image->color_space == OPJ_CLRSPC_SRGB && numComps == 4) { numComps = 3; alpha = 1; }\n      else if (priv->image->color_space == OPJ_CLRSPC_SYCC && numComps == 4) { numComps = 3; alpha = 1; }\n      else if (numComps == 2) { numComps = 1; alpha = 1; }\n      else if (numComps > 4) { numComps = 4; alpha = 1; }\n      else { alpha = 0; }\n    }\n    priv->npixels = priv->image->comps[0].w * priv->image->comps[0].h;\n    priv->ncomps = priv->image->numcomps;\n    if (alpha == 1 && priv->smaskInData == 0) priv->ncomps--;\n    for (int component = 0; component < priv->ncomps; component++) {\n      if (priv->image->comps[component].data == nullptr) {\n        close();\n        break;\n      }\n      const int componentPixels = priv->image->comps[component].w * priv->image->comps[component].h;\n      if (componentPixels != priv->npixels) {\n        error(errSyntaxWarning, -1, \"Component {0:d} has different WxH than component 0\", component);\n        close();\n        break;\n      }\n      unsigned char *cdata = (unsigned char *)priv->image->comps[component].data;\n      int adjust = 0;\n      int depth = priv->image->comps[component].prec;\n      if (priv->image->comps[component].prec > 8)\n\tadjust = priv->image->comps[component].prec - 8;\n      int sgndcorr = 0;\n      if (priv->image->comps[component].sgnd)\n\tsgndcorr = 1 << (priv->image->comps[0].prec - 1);\n      for (int i = 0; i < priv->npixels; i++) {\n\tint r = priv->image->comps[component].data[i];\n\t*(cdata++) = adjustComp(r, adjust, depth, sgndcorr, indexed);\n      }\n    }\n  } else {\n    priv->npixels = 0;\n  }\n\n  priv->counter = 0;\n  priv->ccounter = 0;\n  priv->inited = true;\n}", "target": 2, "idx": 10204}
{"commit_id": "ce87eac0325581b600b3093fcd75080df14ccfda", "project": "wireshark", "func": "static int\ndissect_xra_tlv_ms_info(tvbuff_t * tvb, proto_tree * tree, void* data _U_, guint16 tlv_length) {\n  proto_item *it;\n  proto_tree *xra_tlv_ms_info_tree;\n\n  it = proto_tree_add_item (tree, hf_xra_tlv_ms_info, tvb, 0, tlv_length, ENC_NA);\n  xra_tlv_ms_info_tree = proto_item_add_subtree (it, ett_xra_tlv_ms_info);\n\n  unsigned tlv_index = 0;\n  while (tlv_index < tlv_length) {\n    guint8 type = tvb_get_guint8 (tvb, tlv_index);\n    ++tlv_index;\n    guint8 length = tvb_get_guint8 (tvb, tlv_index);\n    ++tlv_index;\n    switch (type) {\n      case XRA_TLV_MINISLOT_INFO_START_MINISLOT_ID:\n        proto_tree_add_item (xra_tlv_ms_info_tree, hf_xra_tlv_start_minislot_id_abs, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_TLV_MINISLOT_INFO_REL_START_MINISLOT:\n        proto_tree_add_item (xra_tlv_ms_info_tree, hf_xra_tlv_start_minislot_id_rel, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_TLV_MINISLOT_INFO_REL_STOP_MINISLOT:\n        proto_tree_add_item (xra_tlv_ms_info_tree, hf_xra_tlv_stop_minislot_id_rel, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      default:\n        proto_tree_add_item (xra_tlv_ms_info_tree, hf_xra_unknown, tvb, tlv_index, length, ENC_NA);\n        break;\n    }\n    tlv_index+=length;\n  }\n\n  return tvb_captured_length(tvb);\n}", "target": 1, "idx": 10205}
{"commit_id": "6c44312f465014eb409d766a9828b7f101f6251c", "project": "wireshark", "func": "static gint\ndissect_prefixed_bencode(tvbuff_t *tvb, gint offset, packet_info *pinfo,\n                         proto_tree *tree)\n{\n    guint32     plen;\n    proto_tree *prefixed_bencode_tree;\n    proto_item *ti;\n    tvbuff_t *subtvb;\n\n    plen = tvb_get_ntohl(tvb, offset);\n\n    ti = proto_tree_add_item(tree, hf_bzr_prefixed_bencode, tvb, offset, -1,\n                             ENC_NA);\n    prefixed_bencode_tree = proto_item_add_subtree(ti, ett_prefixed_bencode);\n\n    proto_tree_add_item(prefixed_bencode_tree, hf_bzr_prefixed_bencode_len,\n                        tvb, offset, 4, ENC_BIG_ENDIAN);\n\n    subtvb = tvb_new_subset_length(tvb, offset+4, plen);\n    call_dissector(bencode_handle, subtvb, pinfo, prefixed_bencode_tree);\n\n    proto_item_set_len(ti, 4 + plen);\n\n    return 4 + plen;\n}", "target": 2, "idx": 10206}
{"commit_id": "30721cf564cb029d34535446d6a5a6357bebc8e7", "project": "tensorflow", "func": "void Compute(OpKernelContext* ctx) override {\n    const Tensor* hypothesis_indices;\n    const Tensor* hypothesis_values;\n    const Tensor* hypothesis_shape;\n    const Tensor* truth_indices;\n    const Tensor* truth_values;\n    const Tensor* truth_shape;\n    OP_REQUIRES_OK(ctx, ctx->input(\"hypothesis_indices\", &hypothesis_indices));\n    OP_REQUIRES_OK(ctx, ctx->input(\"hypothesis_values\", &hypothesis_values));\n    OP_REQUIRES_OK(ctx, ctx->input(\"hypothesis_shape\", &hypothesis_shape));\n    OP_REQUIRES_OK(ctx, ctx->input(\"truth_indices\", &truth_indices));\n    OP_REQUIRES_OK(ctx, ctx->input(\"truth_values\", &truth_values));\n    OP_REQUIRES_OK(ctx, ctx->input(\"truth_shape\", &truth_shape));\n\n    OP_REQUIRES_OK(\n        ctx, ValidateShapes(ctx, *hypothesis_indices, *hypothesis_values,\n                            *hypothesis_shape, *truth_indices, *truth_values,\n                            *truth_shape));\n\n    TensorShape hypothesis_st_shape;\n    OP_REQUIRES_OK(ctx,\n                   TensorShapeUtils::MakeShape(\n                       hypothesis_shape->vec<int64_t>().data(),\n                       hypothesis_shape->NumElements(), &hypothesis_st_shape));\n    TensorShape truth_st_shape;\n    OP_REQUIRES_OK(ctx, TensorShapeUtils::MakeShape(\n                            truth_shape->vec<int64_t>().data(),\n                            truth_shape->NumElements(), &truth_st_shape));\n\n    // Assume indices are sorted in row-major order.\n    std::vector<int64_t> sorted_order(truth_st_shape.dims());\n    std::iota(sorted_order.begin(), sorted_order.end(), 0);\n\n    sparse::SparseTensor hypothesis;\n    OP_REQUIRES_OK(ctx, sparse::SparseTensor::Create(\n                            *hypothesis_indices, *hypothesis_values,\n                            hypothesis_st_shape, sorted_order, &hypothesis));\n\n    sparse::SparseTensor truth;\n    OP_REQUIRES_OK(ctx, sparse::SparseTensor::Create(\n                            *truth_indices, *truth_values, truth_st_shape,\n                            sorted_order, &truth));\n\n    // Group dims 0, 1, ..., RANK - 1.  The very last dim is assumed\n    // to store the variable length sequences.\n    std::vector<int64_t> group_dims(truth_st_shape.dims() - 1);\n    std::iota(group_dims.begin(), group_dims.end(), 0);\n\n    TensorShape output_shape;\n    for (int d = 0; d < static_cast<int>(group_dims.size()); ++d) {\n      output_shape.AddDim(std::max(hypothesis_st_shape.dim_size(d),\n                                   truth_st_shape.dim_size(d)));\n    }\n    const auto output_elements = output_shape.num_elements();\n    OP_REQUIRES(\n        ctx, output_elements > 0,\n        errors::InvalidArgument(\"Got output shape \", output_shape.DebugString(),\n                                \" which has 0 elements\"));\n\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(\"output\", output_shape, &output));\n    auto output_t = output->flat<float>();\n    output_t.setZero();\n\n    std::vector<int64_t> output_strides(output_shape.dims());\n    output_strides[output_shape.dims() - 1] = 1;\n    for (int d = output_shape.dims() - 2; d >= 0; --d) {\n      output_strides[d] = output_strides[d + 1] * output_shape.dim_size(d + 1);\n    }\n\n    auto hypothesis_grouper = hypothesis.group(group_dims);\n    auto truth_grouper = truth.group(group_dims);\n\n    auto hypothesis_iter = hypothesis_grouper.begin();\n    auto truth_iter = truth_grouper.begin();\n\n    auto cmp = std::equal_to<T>();\n\n    while (hypothesis_iter != hypothesis_grouper.end() &&\n           truth_iter != truth_grouper.end()) {\n      sparse::Group truth_i = *truth_iter;\n      sparse::Group hypothesis_j = *hypothesis_iter;\n      std::vector<int64_t> g_truth = truth_i.group();\n      std::vector<int64_t> g_hypothesis = hypothesis_j.group();\n      auto truth_seq = truth_i.values<T>();\n      auto hypothesis_seq = hypothesis_j.values<T>();\n\n      if (g_truth == g_hypothesis) {\n        auto loc = std::inner_product(g_truth.begin(), g_truth.end(),\n                                      output_strides.begin(), int64_t{0});\n        OP_REQUIRES(\n            ctx, 0 <= loc && loc < output_elements,\n            errors::Internal(\"Got an inner product \", loc,\n                             \" which would require writing to outside of \"\n                             \"the buffer for the output tensor (max elements \",\n                             output_elements, \")\"));\n        output_t(loc) =\n            gtl::LevenshteinDistance<T>(truth_seq, hypothesis_seq, cmp);\n        if (normalize_) output_t(loc) /= truth_seq.size();\n\n        ++hypothesis_iter;\n        ++truth_iter;\n      } else if (g_truth > g_hypothesis) {  // zero-length truth\n        auto loc = std::inner_product(g_hypothesis.begin(), g_hypothesis.end(),\n                                      output_strides.begin(), int64_t{0});\n        OP_REQUIRES(\n            ctx, 0 <= loc && loc < output_elements,\n            errors::Internal(\"Got an inner product \", loc,\n                             \" which would require writing to outside of \"\n                             \"the buffer for the output tensor (max elements \",\n                             output_elements, \")\"));\n        output_t(loc) = hypothesis_seq.size();\n        if (normalize_ && output_t(loc) != 0.0f) {\n          output_t(loc) = std::numeric_limits<float>::infinity();\n        }\n        ++hypothesis_iter;\n      } else {  // zero-length hypothesis\n        auto loc = std::inner_product(g_truth.begin(), g_truth.end(),\n                                      output_strides.begin(), int64_t{0});\n        OP_REQUIRES(\n            ctx, 0 <= loc && loc < output_elements,\n            errors::Internal(\"Got an inner product \", loc,\n                             \" which would require writing to outside of \"\n                             \"the buffer for the output tensor (max elements \",\n                             output_elements, \")\"));\n        output_t(loc) = (normalize_) ? 1.0 : truth_seq.size();\n        ++truth_iter;\n      }\n    }\n    while (hypothesis_iter != hypothesis_grouper.end()) {  // zero-length truths\n      sparse::Group hypothesis_j = *hypothesis_iter;\n      std::vector<int64_t> g_hypothesis = hypothesis_j.group();\n      auto hypothesis_seq = hypothesis_j.values<T>();\n      auto loc = std::inner_product(g_hypothesis.begin(), g_hypothesis.end(),\n                                    output_strides.begin(), int64_t{0});\n      OP_REQUIRES(\n          ctx, 0 <= loc && loc < output_elements,\n          errors::Internal(\"Got an inner product \", loc,\n                           \" which would require writing to outside of the \"\n                           \"buffer for the output tensor (max elements \",\n                           output_elements, \")\"));\n      output_t(loc) = hypothesis_seq.size();\n      if (normalize_ && output_t(loc) != 0.0f) {\n        output_t(loc) = std::numeric_limits<float>::infinity();\n      }\n      ++hypothesis_iter;\n    }\n    while (truth_iter != truth_grouper.end()) {  // missing hypotheses\n      sparse::Group truth_i = *truth_iter;\n      std::vector<int64_t> g_truth = truth_i.group();\n      auto truth_seq = truth_i.values<T>();\n      auto loc = std::inner_product(g_truth.begin(), g_truth.end(),\n                                    output_strides.begin(), int64_t{0});\n      OP_REQUIRES(\n          ctx, 0 <= loc && loc < output_elements,\n          errors::Internal(\"Got an inner product \", loc,\n                           \" which would require writing to outside of the \"\n                           \"buffer for the output tensor (max elements \",\n                           output_elements, \")\"));\n      output_t(loc) = (normalize_) ? 1.0 : truth_seq.size();\n      ++truth_iter;\n    }\n  }", "target": 2, "idx": 10207}
{"commit_id": "eb6bbf7b30da5bae87932514d54d0e3c68b23757", "project": "xen-project/xen", "func": "int xenmem_add_to_physmap_one(\n    struct domain *d,\n    unsigned int space,\n    union add_to_physmap_extra extra,\n    unsigned long idx,\n    gfn_t gfn)\n{\n    mfn_t mfn = INVALID_MFN;\n    int rc;\n    p2m_type_t t;\n    struct page_info *page = NULL;\n\n    switch ( space )\n    {\n    case XENMAPSPACE_grant_table:\n        rc = gnttab_map_frame(d, idx, gfn, &mfn);\n        if ( rc )\n            return rc;\n\n        /* Need to take care of the reference obtained in gnttab_map_frame(). */\n        page = mfn_to_page(mfn);\n        t = p2m_ram_rw;\n\n        break;\n    case XENMAPSPACE_shared_info:\n        if ( idx != 0 )\n            return -EINVAL;\n\n        mfn = virt_to_mfn(d->shared_info);\n        t = p2m_ram_rw;\n\n        break;\n    case XENMAPSPACE_gmfn_foreign:\n    {\n        struct domain *od;\n        p2m_type_t p2mt;\n\n        od = get_pg_owner(extra.foreign_domid);\n        if ( od == NULL )\n            return -ESRCH;\n\n        if ( od == d )\n        {\n            put_pg_owner(od);\n            return -EINVAL;\n        }\n\n        rc = xsm_map_gmfn_foreign(XSM_TARGET, d, od);\n        if ( rc )\n        {\n            put_pg_owner(od);\n            return rc;\n        }\n\n        /* Take reference to the foreign domain page.\n         * Reference will be released in XENMEM_remove_from_physmap */\n        page = get_page_from_gfn(od, idx, &p2mt, P2M_ALLOC);\n        if ( !page )\n        {\n            put_pg_owner(od);\n            return -EINVAL;\n        }\n\n        if ( p2m_is_ram(p2mt) )\n            t = (p2mt == p2m_ram_rw) ? p2m_map_foreign_rw : p2m_map_foreign_ro;\n        else\n        {\n            put_page(page);\n            put_pg_owner(od);\n            return -EINVAL;\n        }\n\n        mfn = page_to_mfn(page);\n\n        put_pg_owner(od);\n        break;\n    }\n    case XENMAPSPACE_dev_mmio:\n        rc = map_dev_mmio_region(d, gfn, 1, _mfn(idx));\n        return rc;\n\n    default:\n        return -ENOSYS;\n    }\n\n    /* Map at new location. */\n    rc = guest_physmap_add_entry(d, gfn, mfn, 0, t);\n\n    /*\n     * For XENMAPSPACE_gmfn_foreign if we failed to add the mapping, we need\n     * to drop the reference we took earlier. In all other cases we need to\n     * drop any reference we took earlier (perhaps indirectly).\n     */\n    if ( space == XENMAPSPACE_gmfn_foreign ? rc : page != NULL )\n    {\n        ASSERT(page != NULL);\n        put_page(page);\n    }\n\n    return rc;\n}", "target": 2, "idx": 10208}
{"commit_id": "49c68f5f892d8c2be00e0a89ff2a035422c03b59", "project": "oracle/linux-uek", "func": "static void binder_deferred_fd_close(int fd)\n{\n\tstruct binder_task_work_cb *twcb;\n\n\ttwcb = kzalloc(sizeof(*twcb), GFP_KERNEL);\n\tif (!twcb)\n\t\treturn;\n\tinit_task_work(&twcb->twork, binder_do_fd_close);\n\t__close_fd_get_file(fd, &twcb->file);\n\tif (twcb->file) {\n\t\tfilp_close(twcb->file, current->files);\n\t\ttask_work_add(current, &twcb->twork, TWA_RESUME);\n\t} else {\n\t\tkfree(twcb);\n\t}\n}", "target": 1, "idx": 10209}
{"commit_id": "4ab3a086d10eeec1424f2e8a968827a6336203df", "project": "torvalds/linux", "func": "static void asus_kbd_backlight_set(struct led_classdev *led_cdev,\n\t\t\t\t   enum led_brightness brightness)\n{\n\tstruct asus_kbd_leds *led = container_of(led_cdev, struct asus_kbd_leds,\n\t\t\t\t\t\t cdev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&led->lock, flags);\n\tled->brightness = brightness;\n\tspin_unlock_irqrestore(&led->lock, flags);\n\n\tasus_schedule_work(led);\n}", "target": 1, "idx": 10210}
{"commit_id": "ab128218225d3542596ca3a02aee80d55494bef8", "project": "xen-project/xen", "func": "int domain_adjust_node_perms(struct connection *conn, struct node *node)\n{\n\tunsigned int i;\n\tint ret;\n\n\tret = chk_domain_generation(node->perms.p[0].id, node->generation);\n\n\t/* If the owner doesn't exist any longer give it to priv domain. */\n\tif (!ret) {\n\t\t/*\n\t\t * In theory we'd need to update the number of dom0 nodes here,\n\t\t * but we could be called for a read of the node. So better\n\t\t * avoid the risk to overflow the node count of dom0.\n\t\t */\n\t\tnode->perms.p[0].id = priv_domid;\n\t}\n\n\tfor (i = 1; i < node->perms.num; i++) {\n\t\tif (node->perms.p[i].perms & XS_PERM_IGNORE)\n\t\t\tcontinue;\n\t\tret = chk_domain_generation(node->perms.p[i].id,\n\t\t\t\t\t    node->generation);\n\t\tif (!ret)\n\t\t\tnode->perms.p[i].perms |= XS_PERM_IGNORE;\n\t}\n\n\treturn 0;\n}", "target": 2, "idx": 10211}
{"commit_id": "086491555022b3b0ec59d26c6442a302171666ba", "project": "php/php-src", "func": "static int dynamicGetbuf (gdIOCtxPtr ctx, void *buf, int len)\n{\n\tint rlen, remain;\n\tdpIOCtxPtr dctx;\n\tdynamicPtr *dp;\n\n\tdctx = (dpIOCtxPtr) ctx;\n\tdp = dctx->dp;\n\n\tremain = dp->logicalSize - dp->pos;\n\tif (remain >= len) {\n\t\trlen = len;\n\t} else {\n\t\tif (remain <= 0) {\n\t\t\treturn EOF;\n\t\t}\n\t\trlen = remain;\n\t}\n\n\tmemcpy(buf, (void *) ((char *) dp->data + dp->pos), rlen);\n\tdp->pos += rlen;\n\n\treturn rlen;\n}", "target": 3, "idx": 10212}
{"commit_id": "aaa28a9d39158ca1033bbd3372cf423abbf4f202", "project": "wireshark", "func": "static int\ndissect_diameter_base_framed_ipv6_prefix(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void *data)\n{\n\tdiam_sub_dis_t *diam_sub_dis = (diam_sub_dis_t*)data;\n\tguint8 prefix_len, prefix_len_bytes;\n\tproto_item *pi;\n\n\tproto_tree_add_item(tree, hf_framed_ipv6_prefix_reserved, tvb, 0, 1, ENC_BIG_ENDIAN);\n\tpi = proto_tree_add_item(tree, hf_framed_ipv6_prefix_length, tvb, 1, 1, ENC_BIG_ENDIAN);\n\n\tprefix_len = tvb_get_guint8(tvb, 1);\n\tif (prefix_len > 128) {\n\t\texpert_add_info(pinfo, pi, &ei_diameter_invalid_ipv6_prefix_len);\n\t}\n\tprefix_len_bytes = prefix_len / 8;\n\tif (prefix_len % 8)\n\t\tprefix_len_bytes++;\n\n\tproto_tree_add_item(tree, hf_framed_ipv6_prefix_bytes, tvb, 2, prefix_len_bytes, ENC_NA);\n\n\t/* If we have a fully IPv6 address, display it as such */\n\tif (prefix_len_bytes == 16) {\n\t\tproto_tree_add_item(tree, hf_framed_ipv6_prefix_ipv6, tvb, 2, prefix_len_bytes, ENC_NA);\n\t} else if (prefix_len_bytes < 16) {\n\t\tstruct e_in6_addr value;\n\t\taddress addr;\n\n\t\tmemset(&value.bytes, 0, sizeof(value));\n\t\ttvb_memcpy(tvb, (guint8 *)&value.bytes, 2, prefix_len_bytes);\n\t\tvalue.bytes[prefix_len_bytes] = value.bytes[prefix_len_bytes] & (0xff<<(prefix_len % 8));\n\t\tproto_tree_add_ipv6(tree, hf_framed_ipv6_prefix_ipv6, tvb, 2, prefix_len_bytes, &value);\n\t\tset_address(&addr, AT_IPv6, 16, value.bytes);\n\t\tdiam_sub_dis->avp_str = wmem_strdup_printf(wmem_packet_scope(), \"%s/%u\", address_to_str(wmem_packet_scope(), &addr), prefix_len);\n\t}\n\n\treturn(prefix_len_bytes+2);\n}", "target": 1, "idx": 10213}
{"commit_id": "c44496df2f090a56d3bf75df930592dac6bba46f", "project": "glibc", "func": "static time_t\naddgetnetgrentX (struct database_dyn *db, int fd, request_header *req,\n\t\t const char *key, uid_t uid, struct hashentry *he,\n\t\t struct datahead *dh, struct dataset **resultp)\n{\n  if (__glibc_unlikely (debug_level > 0))\n    {\n      if (he == NULL)\n\tdbg_log (_(\"Haven't found \\\"%s\\\" in netgroup cache!\"), key);\n      else\n\tdbg_log (_(\"Reloading \\\"%s\\\" in netgroup cache!\"), key);\n    }\n\n  static service_user *netgroup_database;\n  time_t timeout;\n  struct dataset *dataset;\n  bool cacheable = false;\n  ssize_t total;\n  bool found = false;\n\n  char *key_copy = NULL;\n  struct __netgrent data;\n  size_t buflen = MAX (1024, sizeof (*dataset) + req->key_len);\n  size_t buffilled = sizeof (*dataset);\n  char *buffer = NULL;\n  size_t nentries = 0;\n  size_t group_len = strlen (key) + 1;\n  union\n  {\n    struct name_list elem;\n    char mem[sizeof (struct name_list) + group_len];\n  } first_needed;\n\n  if (netgroup_database == NULL\n      && __nss_database_lookup (\"netgroup\", NULL, NULL, &netgroup_database))\n    {\n      /* No such service.  */\n      cacheable = do_notfound (db, fd, req, key, &dataset, &total, &timeout,\n\t\t\t       &key_copy);\n      goto writeout;\n    }\n\n  memset (&data, '\\0', sizeof (data));\n  buffer = xmalloc (buflen);\n  first_needed.elem.next = &first_needed.elem;\n  memcpy (first_needed.elem.name, key, group_len);\n  data.needed_groups = &first_needed.elem;\n\n  while (data.needed_groups != NULL)\n    {\n      /* Add the next group to the list of those which are known.  */\n      struct name_list *this_group = data.needed_groups->next;\n      if (this_group == data.needed_groups)\n\tdata.needed_groups = NULL;\n      else\n\tdata.needed_groups->next = this_group->next;\n      this_group->next = data.known_groups;\n      data.known_groups = this_group;\n\n      union\n      {\n\tenum nss_status (*f) (const char *, struct __netgrent *);\n\tvoid *ptr;\n      } setfct;\n\n      service_user *nip = netgroup_database;\n      int no_more = __nss_lookup (&nip, \"setnetgrent\", NULL, &setfct.ptr);\n      while (!no_more)\n\t{\n\t  enum nss_status status\n\t    = DL_CALL_FCT (*setfct.f, (data.known_groups->name, &data));\n\n\t  if (status == NSS_STATUS_SUCCESS)\n\t    {\n\t      found = true;\n\t      union\n\t      {\n\t\tenum nss_status (*f) (struct __netgrent *, char *, size_t,\n\t\t\t\t      int *);\n\t\tvoid *ptr;\n\t      } getfct;\n\t      getfct.ptr = __nss_lookup_function (nip, \"getnetgrent_r\");\n\t      if (getfct.f != NULL)\n\t\twhile (1)\n\t\t  {\n\t\t    int e;\n\t\t    status = getfct.f (&data, buffer + buffilled,\n\t\t\t\t       buflen - buffilled - req->key_len, &e);\n\t\t    if (status == NSS_STATUS_RETURN\n\t\t\t|| status == NSS_STATUS_NOTFOUND)\n\t\t      /* This was either the last one for this group or the\n\t\t\t group was empty.  Look at next group if available.  */\n\t\t      break;\n\t\t    if (status == NSS_STATUS_SUCCESS)\n\t\t      {\n\t\t\tif (data.type == triple_val)\n\t\t\t  {\n\t\t\t    const char *nhost = data.val.triple.host;\n\t\t\t    const char *nuser = data.val.triple.user;\n\t\t\t    const char *ndomain = data.val.triple.domain;\n\n\t\t\t    if (nhost == NULL || nuser == NULL || ndomain == NULL\n\t\t\t\t|| nhost > nuser || nuser > ndomain)\n\t\t\t      {\n\t\t\t\tconst char *last = nhost;\n\t\t\t\tif (last == NULL\n\t\t\t\t    || (nuser != NULL && nuser > last))\n\t\t\t\t  last = nuser;\n\t\t\t\tif (last == NULL\n\t\t\t\t    || (ndomain != NULL && ndomain > last))\n\t\t\t\t  last = ndomain;\n\n\t\t\t\tsize_t bufused\n\t\t\t\t  = (last == NULL\n\t\t\t\t     ? buffilled\n\t\t\t\t     : last + strlen (last) + 1 - buffer);\n\n\t\t\t\t/* We have to make temporary copies.  */\n\t\t\t\tsize_t hostlen = strlen (nhost ?: \"\") + 1;\n\t\t\t\tsize_t userlen = strlen (nuser ?: \"\") + 1;\n\t\t\t\tsize_t domainlen = strlen (ndomain ?: \"\") + 1;\n\t\t\t\tsize_t needed = hostlen + userlen + domainlen;\n\n\t\t\t\tif (buflen - req->key_len - bufused < needed)\n\t\t\t\t  {\n\t\t\t\t    buflen += MAX (buflen, 2 * needed);\n\t\t\t\t    /* Save offset in the old buffer.  We don't\n\t\t\t\t       bother with the NULL check here since\n\t\t\t\t       we'll do that later anyway.  */\n\t\t\t\t    size_t nhostdiff = nhost - buffer;\n\t\t\t\t    size_t nuserdiff = nuser - buffer;\n\t\t\t\t    size_t ndomaindiff = ndomain - buffer;\n\n\t\t\t\t    char *newbuf = xrealloc (buffer, buflen);\n\t\t\t\t    /* Fix up the triplet pointers into the new\n\t\t\t\t       buffer.  */\n\t\t\t\t    nhost = (nhost ? newbuf + nhostdiff\n\t\t\t\t\t     : NULL);\n\t\t\t\t    nuser = (nuser ? newbuf + nuserdiff\n\t\t\t\t\t     : NULL);\n\t\t\t\t    ndomain = (ndomain ? newbuf + ndomaindiff\n\t\t\t\t\t       : NULL);\n\t\t\t\t    buffer = newbuf;\n\t\t\t\t  }\n\n\t\t\t\tnhost = memcpy (buffer + bufused,\n\t\t\t\t\t\tnhost ?: \"\", hostlen);\n\t\t\t\tnuser = memcpy ((char *) nhost + hostlen,\n\t\t\t\t\t\tnuser ?: \"\", userlen);\n\t\t\t\tndomain = memcpy ((char *) nuser + userlen,\n\t\t\t\t\t\t  ndomain ?: \"\", domainlen);\n\t\t\t      }\n\n\t\t\t    char *wp = buffer + buffilled;\n\t\t\t    wp = stpcpy (wp, nhost) + 1;\n\t\t\t    wp = stpcpy (wp, nuser) + 1;\n\t\t\t    wp = stpcpy (wp, ndomain) + 1;\n\t\t\t    buffilled = wp - buffer;\n\t\t\t    ++nentries;\n\t\t\t  }\n\t\t\telse\n\t\t\t  {\n\t\t\t    /* Check that the group has not been\n\t\t\t       requested before.  */\n\t\t\t    struct name_list *runp = data.needed_groups;\n\t\t\t    if (runp != NULL)\n\t\t\t      while (1)\n\t\t\t\t{\n\t\t\t\t  if (strcmp (runp->name, data.val.group) == 0)\n\t\t\t\t    break;\n\n\t\t\t\t  runp = runp->next;\n\t\t\t\t  if (runp == data.needed_groups)\n\t\t\t\t    {\n\t\t\t\t      runp = NULL;\n\t\t\t\t      break;\n\t\t\t\t    }\n\t\t\t\t}\n\n\t\t\t    if (runp == NULL)\n\t\t\t      {\n\t\t\t\trunp = data.known_groups;\n\t\t\t\twhile (runp != NULL)\n\t\t\t\t  if (strcmp (runp->name, data.val.group) == 0)\n\t\t\t\t    break;\n\t\t\t\t  else\n\t\t\t\t    runp = runp->next;\n\t\t\t\t}\n\n\t\t\t    if (runp == NULL)\n\t\t\t      {\n\t\t\t\t/* A new group is requested.  */\n\t\t\t\tsize_t namelen = strlen (data.val.group) + 1;\n\t\t\t\tstruct name_list *newg = alloca (sizeof (*newg)\n\t\t\t\t\t\t\t\t + namelen);\n\t\t\t\tmemcpy (newg->name, data.val.group, namelen);\n\t\t\t\tif (data.needed_groups == NULL)\n\t\t\t\t  data.needed_groups = newg->next = newg;\n\t\t\t\telse\n\t\t\t\t  {\n\t\t\t\t    newg->next = data.needed_groups->next;\n\t\t\t\t    data.needed_groups->next = newg;\n\t\t\t\t    data.needed_groups = newg;\n\t\t\t\t  }\n\t\t\t      }\n\t\t\t  }\n\t\t      }\n\t\t    else if (status == NSS_STATUS_UNAVAIL && e == ERANGE)\n\t\t      {\n\t\t\tbuflen *= 2;\n\t\t\tbuffer = xrealloc (buffer, buflen);\n\t\t      }\n\t\t  }\n\n\t      enum nss_status (*endfct) (struct __netgrent *);\n\t      endfct = __nss_lookup_function (nip, \"endnetgrent\");\n\t      if (endfct != NULL)\n\t\t(void) DL_CALL_FCT (*endfct, (&data));\n\n\t      break;\n\t    }\n\n\t  no_more = __nss_next2 (&nip, \"setnetgrent\", NULL, &setfct.ptr,\n\t\t\t\t status, 0);\n\t}\n    }\n\n  /* No results.  Return a failure and write out a notfound record in the\n     cache.  */\n  if (!found)\n    {\n      cacheable = do_notfound (db, fd, req, key, &dataset, &total, &timeout,\n\t\t\t       &key_copy);\n      goto writeout;\n    }\n\n  total = buffilled;\n\n  /* Fill in the dataset.  */\n  dataset = (struct dataset *) buffer;\n  dataset->head.allocsize = total + req->key_len;\n  dataset->head.recsize = total - offsetof (struct dataset, resp);\n  dataset->head.notfound = false;\n  dataset->head.nreloads = he == NULL ? 0 : (dh->nreloads + 1);\n  dataset->head.usable = true;\n  dataset->head.ttl = db->postimeout;\n  timeout = dataset->head.timeout = time (NULL) + dataset->head.ttl;\n\n  dataset->resp.version = NSCD_VERSION;\n  dataset->resp.found = 1;\n  dataset->resp.nresults = nentries;\n  dataset->resp.result_len = buffilled - sizeof (*dataset);\n\n  assert (buflen - buffilled >= req->key_len);\n  key_copy = memcpy (buffer + buffilled, key, req->key_len);\n  buffilled += req->key_len;\n\n  /* Now we can determine whether on refill we have to create a new\n     record or not.  */\n  if (he != NULL)\n    {\n      assert (fd == -1);\n\n      if (dataset->head.allocsize == dh->allocsize\n\t  && dataset->head.recsize == dh->recsize\n\t  && memcmp (&dataset->resp, dh->data,\n\t\t     dh->allocsize - offsetof (struct dataset, resp)) == 0)\n\t{\n\t  /* The data has not changed.  We will just bump the timeout\n\t     value.  Note that the new record has been allocated on\n\t     the stack and need not be freed.  */\n\t  dh->timeout = dataset->head.timeout;\n\t  dh->ttl = dataset->head.ttl;\n\t  ++dh->nreloads;\n\t  dataset = (struct dataset *) dh;\n\n\t  goto out;\n\t}\n    }\n\n  {\n    struct dataset *newp\n      = (struct dataset *) mempool_alloc (db, total + req->key_len, 1);\n    if (__glibc_likely (newp != NULL))\n      {\n\t/* Adjust pointer into the memory block.  */\n\tkey_copy = (char *) newp + (key_copy - buffer);\n\n\tdataset = memcpy (newp, dataset, total + req->key_len);\n\tcacheable = true;\n\n\tif (he != NULL)\n\t  /* Mark the old record as obsolete.  */\n\t  dh->usable = false;\n      }\n  }\n\n  if (he == NULL && fd != -1)\n    {\n      /* We write the dataset before inserting it to the database\n\t since while inserting this thread might block and so would\n\t unnecessarily let the receiver wait.  */\n    writeout:\n#ifdef HAVE_SENDFILE\n      if (__builtin_expect (db->mmap_used, 1) && cacheable)\n\t{\n\t  assert (db->wr_fd != -1);\n\t  assert ((char *) &dataset->resp > (char *) db->data);\n\t  assert ((char *) dataset - (char *) db->head + total\n\t\t  <= (sizeof (struct database_pers_head)\n\t\t      + db->head->module * sizeof (ref_t)\n\t\t      + db->head->data_size));\n# ifndef __ASSUME_SENDFILE\n\t  ssize_t written =\n# endif\n\t    sendfileall (fd, db->wr_fd, (char *) &dataset->resp\n\t\t\t - (char *) db->head, dataset->head.recsize);\n# ifndef __ASSUME_SENDFILE\n\t  if (written == -1 && errno == ENOSYS)\n\t    goto use_write;\n# endif\n\t}\n      else\n#endif\n\t{\n#if defined HAVE_SENDFILE && !defined __ASSUME_SENDFILE\n\tuse_write:\n#endif\n\t  writeall (fd, &dataset->resp, dataset->head.recsize);\n\t}\n    }\n\n  if (cacheable)\n    {\n      /* If necessary, we also propagate the data to disk.  */\n      if (db->persistent)\n\t{\n\t  // XXX async OK?\n\t  uintptr_t pval = (uintptr_t) dataset & ~pagesize_m1;\n\t  msync ((void *) pval,\n\t\t ((uintptr_t) dataset & pagesize_m1) + total + req->key_len,\n\t\t MS_ASYNC);\n\t}\n\n      (void) cache_add (req->type, key_copy, req->key_len, &dataset->head,\n\t\t\ttrue, db, uid, he == NULL);\n\n      pthread_rwlock_unlock (&db->lock);\n\n      /* Mark the old entry as obsolete.  */\n      if (dh != NULL)\n\tdh->usable = false;\n    }\n\n out:\n  free (buffer);\n\n  *resultp = dataset;\n\n  return timeout;\n}", "target": 3, "idx": 10214}
{"commit_id": "d00d8da5869a2608e97cfede094dfc5e11462a46", "project": "torvalds/linux", "func": "static void control_work_handler(struct work_struct *work)\n{\n\tstruct ports_device *portdev;\n\tstruct virtqueue *vq;\n\tstruct port_buffer *buf;\n\tunsigned int len;\n\n\tportdev = container_of(work, struct ports_device, control_work);\n\tvq = portdev->c_ivq;\n\n\tspin_lock(&portdev->c_ivq_lock);\n\twhile ((buf = virtqueue_get_buf(vq, &len))) {\n\t\tspin_unlock(&portdev->c_ivq_lock);\n\n\t\tbuf->len = min_t(size_t, len, buf->size);\n\t\tbuf->offset = 0;\n\n\t\thandle_control_message(vq->vdev, portdev, buf);\n\n\t\tspin_lock(&portdev->c_ivq_lock);\n\t\tif (add_inbuf(portdev->c_ivq, buf) < 0) {\n\t\t\tdev_warn(&portdev->vdev->dev,\n\t\t\t\t \"Error adding buffer to queue\\n\");\n\t\t\tfree_buf(buf, false);\n\t\t}\n\t}\n\tspin_unlock(&portdev->c_ivq_lock);\n}", "target": 2, "idx": 10215}
{"commit_id": "a2530f740d67d41908e84434bb5ec99480c2ac2e", "project": "wireshark", "func": "static int\ndissect_wg(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\n{\n    proto_item *ti;\n    proto_tree *wg_tree;\n    guint32     message_type;\n    const char *message_type_str;\n    wg_packet_info_t *wg_pinfo;\n\n    message_type = tvb_get_guint8(tvb, 0);\n    message_type_str = try_val_to_str(message_type, wg_type_names);\n    if (!message_type_str)\n        return 0;\n\n    if (!wg_is_valid_message_length(message_type, tvb_reported_length(tvb))) {\n        return 0;\n    }\n\n    /* Special case: zero-length data message is a Keepalive message. */\n    if (message_type == WG_TYPE_TRANSPORT_DATA && tvb_reported_length(tvb) == 32) {\n        message_type_str = \"Keepalive\";\n    }\n\n    col_set_str(pinfo->cinfo, COL_PROTOCOL, \"WireGuard\");\n    col_set_str(pinfo->cinfo, COL_INFO, message_type_str);\n\n    ti = proto_tree_add_item(tree, proto_wg, tvb, 0, -1, ENC_NA);\n    wg_tree = proto_item_add_subtree(ti, ett_wg);\n\n    proto_tree_add_item(wg_tree, hf_wg_type, tvb, 0, 1, ENC_NA);\n    proto_tree_add_item(wg_tree, hf_wg_reserved, tvb, 1, 3, ENC_NA);\n\n    if (!PINFO_FD_VISITED(pinfo)) {\n        wg_pinfo = wmem_new0(wmem_file_scope(), wg_packet_info_t);\n        p_add_proto_data(wmem_file_scope(), pinfo, proto_wg, 0, wg_pinfo);\n    } else {\n        /*\n         * Note: this may be NULL if the heuristics dissector sets a\n         * conversation dissector later in the stream, for example due to a new\n         * Handshake Initiation message. Previous messages are potentially\n         * Transport Data messages which might not be detected through\n         * heuristics.\n         */\n        wg_pinfo = (wg_packet_info_t *)p_get_proto_data(wmem_file_scope(), pinfo, proto_wg, 0);\n    }\n\n    switch ((wg_message_type)message_type) {\n    case WG_TYPE_HANDSHAKE_INITIATION:\n        return wg_dissect_handshake_initiation(tvb, pinfo, wg_tree, wg_pinfo);\n    case WG_TYPE_HANDSHAKE_RESPONSE:\n        return wg_dissect_handshake_response(tvb, pinfo, wg_tree, wg_pinfo);\n    case WG_TYPE_COOKIE_REPLY:\n        return wg_dissect_handshake_cookie(tvb, pinfo, wg_tree, wg_pinfo);\n    case WG_TYPE_TRANSPORT_DATA:\n        return wg_dissect_data(tvb, pinfo, wg_tree, wg_pinfo);\n    }\n\n    DISSECTOR_ASSERT_NOT_REACHED();\n}", "target": 2, "idx": 10216}
{"commit_id": "ca8c013b5e97b1373b3bb1c97ea655e69f31a575", "project": "tensorflow", "func": "void operator()(OpKernelContext* ctx, const CPUDevice& d, int64 num_batches,\n                  int64 samples_per_batch, int64 num_elements,\n                  typename TTypes<T>::ConstFlat means,\n                  typename TTypes<T>::ConstFlat stddevs,\n                  typename TTypes<T>::ConstFlat minvals,\n                  typename TTypes<T>::ConstFlat maxvals,\n                  const random::PhiloxRandom& gen,\n                  typename TTypes<T>::Flat output) {\n    // The randn rejection sampling is used when the mean and at least this many\n    // standard deviations are inside the bounds.\n    // The uniform proposal samplers become less efficient as the bounds are\n    // further from the mean, the reverse is true for the randn sampler.\n    // This number was chosen by empirical benchmarking. If modified, the\n    // benchmarks in parameterized_truncated_normal_op_test should also be\n    // changed.\n    const T kStdDevsInsideBoundsToUseRandnSampler = T(1.3);\n    auto worker_threads = *(ctx->device()->tensorflow_cpu_worker_threads());\n\n    auto do_work = [samples_per_batch, num_elements, &ctx, &means, &stddevs,\n                    &minvals, &maxvals, &gen, &output,\n                    kStdDevsInsideBoundsToUseRandnSampler](int64 start_batch,\n                                                           int64 limit_batch) {\n      // Capturing \"gen\" by-value would only make a copy for the _shared_\n      // lambda.  Since we want to let each worker have its own copy, we pass\n      // \"gen\" by reference and explicitly do a copy assignment here.\n      random::PhiloxRandom gen_copy = gen;\n      // Skip takes units of 128 bytes.  +3 is so rounding doesn't lead to\n      // us using the same state in different batches.\n      // The sample from each iteration uses 2 random numbers.\n      gen_copy.Skip(start_batch * 2 * kMaxIterations * (samples_per_batch + 3) /\n                    4);\n      using Uniform = random::UniformDistribution<random::PhiloxRandom, T>;\n      Uniform dist;\n      using Normal = random::NormalDistribution<random::PhiloxRandom, T>;\n      Normal normal_dist;\n\n      // Vectorized intermediate calculations for uniform rejection sampling.\n      // We always generate at most 4 samples.\n      Eigen::array<T, 4> z;\n      Eigen::array<T, 4> g;\n\n      for (int64 b = start_batch; b < limit_batch; ++b) {\n        // We are passed a flat array for each of the parameter tensors.\n        // The input is either a scalar broadcasted to all batches or a vector\n        // with length num_batches, but the scalar becomes an array of length 1.\n        T mean = means((means.dimension(0) == 1) ? 0 : b);\n        T stddev = stddevs((stddevs.dimension(0) == 1) ? 0 : b);\n        T minval = minvals((minvals.dimension(0) == 1) ? 0 : b);\n        T maxval = maxvals((maxvals.dimension(0) == 1) ? 0 : b);\n\n        // The last batch can be short, if we adjusted num_batches and\n        // samples_per_batch.\n        const int64 limit_sample =\n            std::min((b + 1) * samples_per_batch, num_elements);\n        int64 sample = b * samples_per_batch;\n\n        // On GPU, this check will just fill samples with NAN if it fails.\n        OP_REQUIRES(ctx,\n                    stddev > T(0) && minval < maxval &&\n                        (Eigen::numext::isfinite(minval) ||\n                         Eigen::numext::isfinite(maxval)),\n                    errors::InvalidArgument(\"Invalid parameters\"));\n\n        int num_iterations = 0;\n\n        // If possible, make one-sided bound be the lower bound, or make both\n        // bounds positive. Otherwise, the bounds are on either side of the\n        // mean.\n        if ((Eigen::numext::isinf(minval) && minval < T(0)) || maxval < mean) {\n          // Reverse all calculations. normMin and normMax will be flipped.\n          std::swap(minval, maxval);\n          stddev = -stddev;\n        }\n\n        // Calculate normalized samples, then convert them.\n        const T normMin = (minval - mean) / stddev;\n        const T normMax = (maxval - mean) / stddev;\n\n        // Determine the method to use.\n        const T sqrtFactor = Eigen::numext::sqrt((normMin * normMin) + T(4));\n        const T cutoff =\n            T(2) *\n            Eigen::numext::exp(T(0.5) +\n                               (normMin * (normMin - sqrtFactor)) / T(4)) /\n            (normMin + sqrtFactor);\n        const T diff = normMax - normMin;\n\n        if (((normMin < -kStdDevsInsideBoundsToUseRandnSampler) &&\n             (normMax >= T(0.))) ||\n            ((normMax > kStdDevsInsideBoundsToUseRandnSampler) &&\n             (normMin <= T(0.)))) {\n          // If the bounds are a least 3 standard deviations from the mean\n          // on at least one side then we rejection sample by sampling\n          // from the normal distribution and rejecting samples outside\n          // the bounds.\n          // Under this condition the acceptance rate per iteration should\n          // always be ~ 50%. This sampler is more efficient (and more\n          // numerically stable when one or both bounds is far from the mean).\n\n          while (sample < limit_sample) {\n            const auto randn_sample = normal_dist(&gen_copy);\n            const int size = randn_sample.size();\n\n            for (int i = 0; i < size; i++) {\n              if ((randn_sample[i] >= normMin) &&\n                  (randn_sample[i] <= normMax)) {\n                output(sample) = randn_sample[i] * stddev + mean;\n                sample++;\n                if (sample >= limit_sample) {\n                  break;\n                }\n                num_iterations = 0;\n              } else {\n                num_iterations++;\n                if (num_iterations > kMaxIterations) {\n                  // This should never occur because this sampler should\n                  // (by the selection criteria above) be used if at least 3\n                  // standard deviations of one side of the distribution\n                  // is within the limits (so acceptance probability per\n                  // iterations >~ 1/2 per iteration).\n                  LOG(ERROR) << \"TruncatedNormal randn rejection sampler \"\n                             << \"exceeded maximum iterations for \"\n                             << \"normMin=\" << normMin << \" normMax=\" << normMax\n                             << \" kMaxIterations=\" << kMaxIterations;\n                  ctx->SetStatus(errors::Internal(\n                      \"TruncatedNormal randn rejection sampler failed to accept\"\n                      \" a sample.\"));\n                  return;\n                }\n              }\n            }\n          }\n        } else if (diff < cutoff) {\n          // Sample from a uniform distribution on [normMin, normMax].\n\n          const T plusFactor = (normMin < T(0)) ? T(0) : normMin * normMin;\n\n          while (sample < limit_sample) {\n            const auto rand = dist(&gen_copy);\n            const int size = rand.size();\n            // NOTE(ringwalt): These loops seem to only generate packed AVX\n            // instructions for float32.\n            for (int i = 0; i < size; i++) {\n              z[i] = rand[i] * diff + normMin;\n            }\n            for (int i = 0; i < size; i++) {\n              g[i] = (plusFactor - z[i] * z[i]) / T(2.0);\n            }\n\n            const auto u = dist(&gen_copy);\n            for (int i = 0; i < size; i++) {\n              auto accept = u[i] <= Eigen::numext::exp(g[i]);\n              if (accept || num_iterations + 1 >= kMaxIterations) {\n                // Accept the sample z.\n                // If we run out of iterations, just use the current uniform\n                // sample, but emit a warning.\n                // TODO(jjhunt) For small entropies (relative to the bounds),\n                // this sampler is poor and may take many iterations since\n                // the proposal distribution is the uniform distribution\n                // U(lower_bound, upper_bound).\n                if (!accept) {\n                  LOG(ERROR) << \"TruncatedNormal uniform rejection sampler \"\n                             << \"exceeded max iterations. Sample may contain \"\n                             << \"outliers.\";\n                  ctx->SetStatus(errors::Internal(\n                      \"TruncatedNormal uniform rejection sampler failed to \"\n                      \" accept a sample.\"));\n                  return;\n                }\n                output(sample) = z[i] * stddev + mean;\n                sample++;\n                if (sample >= limit_sample) {\n                  break;\n                }\n                num_iterations = 0;\n              } else {\n                num_iterations++;\n              }\n            }\n          }\n        } else {\n          // Sample from an exponential distribution with alpha maximizing\n          // acceptance probability, offset by normMin from the origin.\n          // Accept only if less than normMax.\n          const T alpha =\n              (normMin + Eigen::numext::sqrt((normMin * normMin) + T(4))) /\n              T(2);\n          while (sample < limit_sample) {\n            auto rand = dist(&gen_copy);\n            const int size = rand.size();\n            int i = 0;\n            while (i < size) {\n              const T z = -Eigen::numext::log(rand[i]) / alpha + normMin;\n              i++;\n              const T x = normMin < alpha ? alpha - z : normMin - alpha;\n              const T g = Eigen::numext::exp(-x * x / T(2.0));\n              const T u = rand[i];\n              i++;\n              auto accept = (u <= g && z < normMax);\n              if (accept || num_iterations + 1 >= kMaxIterations) {\n                if (!accept) {\n                  LOG(ERROR) << \"TruncatedNormal exponential distribution \"\n                             << \"rejection sampler exceeds max iterations. \"\n                             << \"Sample may contain outliers.\";\n                  ctx->SetStatus(errors::Internal(\n                      \"TruncatedNormal exponential distribution rejection\"\n                      \" sampler failed to accept a sample.\"));\n                  return;\n                }\n                output(sample) = z * stddev + mean;\n                sample++;\n                if (sample >= limit_sample) {\n                  break;\n                }\n                num_iterations = 0;\n              } else {\n                num_iterations++;\n              }\n            }\n          }\n        }\n      }\n    };\n    // The cost of the initial calculations for the batch.\n    const int64 batchInitCost =\n        // normMin, normMax\n        (Eigen::TensorOpCost::AddCost<T>() +\n         Eigen::TensorOpCost::MulCost<T>()) *\n            2\n        // sqrtFactor\n        + Eigen::TensorOpCost::AddCost<T>() +\n        Eigen::TensorOpCost::MulCost<T>() +\n        Eigen::internal::functor_traits<\n            Eigen::internal::scalar_sqrt_op<T>>::Cost\n        // cutoff\n        + Eigen::TensorOpCost::MulCost<T>() * 4 +\n        Eigen::internal::functor_traits<Eigen::internal::scalar_exp_op<T>>::Cost\n        // diff\n        + Eigen::TensorOpCost::AddCost<T>();\n    const int64 uniformSampleCost =\n        random::PhiloxRandom::kElementCost +\n        random::UniformDistribution<random::PhiloxRandom, T>::kElementCost;\n    // The cost of a single uniform sampling round.\n    const int64 uniformRejectionSamplingCost =\n        uniformSampleCost + Eigen::TensorOpCost::MulCost<T>() +\n        Eigen::TensorOpCost::AddCost<T>() +\n        Eigen::TensorOpCost::MulCost<T>() * 2 +\n        Eigen::TensorOpCost::AddCost<T>() + uniformSampleCost +\n        Eigen::internal::functor_traits<\n            Eigen::internal::scalar_exp_op<T>>::Cost +\n        Eigen::TensorOpCost::MulCost<T>() + Eigen::TensorOpCost::AddCost<T>();\n    // Estimate the cost for an entire batch.\n    // Assume we use uniform sampling, and accept the 2nd sample on average.\n    const int64 batchCost =\n        batchInitCost + uniformRejectionSamplingCost * 2 * samples_per_batch;\n    Shard(worker_threads.num_threads, worker_threads.workers, num_batches,\n          batchCost, do_work);\n  }", "target": 3, "idx": 10217}
{"commit_id": "668bbca29797728004d88db4c9b69102f3939008", "project": "android", "func": "BT_HDR* avdt_msg_asmbl(AvdtpCcb* p_ccb, BT_HDR* p_buf) {\n  uint8_t* p;\n  uint8_t pkt_type;\n  BT_HDR* p_ret;\n\n  /* parse the message header */\n  p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n\n  /* Check if is valid length */\n  if (p_buf->len < 1) {\n    android_errorWriteLog(0x534e4554, \"78287084\");\n    osi_free(p_buf);\n    p_ret = NULL;\n    return p_ret;\n  }\n  AVDT_MSG_PRS_PKT_TYPE(p, pkt_type);\n\n  /* quick sanity check on length */\n  if (p_buf->len < avdt_msg_pkt_type_len[pkt_type]) {\n    osi_free(p_buf);\n    AVDT_TRACE_WARNING(\"Bad length during reassembly\");\n    p_ret = NULL;\n  }\n  /* single packet */\n  else if (pkt_type == AVDT_PKT_TYPE_SINGLE) {\n    /* if reassembly in progress drop message and process new single */\n    if (p_ccb->p_rx_msg != NULL)\n      AVDT_TRACE_WARNING(\"Got single during reassembly\");\n\n    osi_free_and_reset((void**)&p_ccb->p_rx_msg);\n\n    p_ret = p_buf;\n  }\n  /* start packet */\n  else if (pkt_type == AVDT_PKT_TYPE_START) {\n    /* if reassembly in progress drop message and process new single */\n    if (p_ccb->p_rx_msg != NULL)\n      AVDT_TRACE_WARNING(\"Got start during reassembly\");\n\n    osi_free_and_reset((void**)&p_ccb->p_rx_msg);\n\n    /*\n     * Allocate bigger buffer for reassembly. As lower layers are\n     * not aware of possible packet size after reassembly, they\n     * would have allocated smaller buffer.\n     */\n    if (sizeof(BT_HDR) + p_buf->offset + p_buf->len > BT_DEFAULT_BUFFER_SIZE) {\n      android_errorWriteLog(0x534e4554, \"232023771\");\n      osi_free(p_buf);\n      p_ret = NULL;\n      return p_ret;\n    }\n    p_ccb->p_rx_msg = (BT_HDR*)osi_malloc(BT_DEFAULT_BUFFER_SIZE);\n    memcpy(p_ccb->p_rx_msg, p_buf, sizeof(BT_HDR) + p_buf->offset + p_buf->len);\n\n    /* Free original buffer */\n    osi_free(p_buf);\n\n    /* update p to point to new buffer */\n    p = (uint8_t*)(p_ccb->p_rx_msg + 1) + p_ccb->p_rx_msg->offset;\n\n    /* copy first header byte over nosp */\n    *(p + 1) = *p;\n\n    /* set offset to point to where to copy next */\n    p_ccb->p_rx_msg->offset += p_ccb->p_rx_msg->len;\n\n    /* adjust length for packet header */\n    p_ccb->p_rx_msg->len -= 1;\n\n    p_ret = NULL;\n  }\n  /* continue or end */\n  else {\n    /* if no reassembly in progress drop message */\n    if (p_ccb->p_rx_msg == NULL) {\n      osi_free(p_buf);\n      AVDT_TRACE_WARNING(\"Pkt type=%d out of order\", pkt_type);\n      p_ret = NULL;\n    } else {\n      /* get size of buffer holding assembled message */\n      /*\n       * NOTE: The buffer is allocated above at the beginning of the\n       * reassembly, and is always of size BT_DEFAULT_BUFFER_SIZE.\n       */\n      size_t buf_len = BT_DEFAULT_BUFFER_SIZE - sizeof(BT_HDR);\n\n      /* adjust offset and len of fragment for header byte */\n      p_buf->offset += AVDT_LEN_TYPE_CONT;\n      p_buf->len -= AVDT_LEN_TYPE_CONT;\n\n      /* verify length */\n      if (((size_t) p_ccb->p_rx_msg->offset + (size_t) p_buf->len) > buf_len) {\n        /* won't fit; free everything */\n        AVDT_TRACE_WARNING(\"%s: Fragmented message too big!\", __func__);\n        osi_free_and_reset((void**)&p_ccb->p_rx_msg);\n        osi_free(p_buf);\n        p_ret = NULL;\n      } else {\n        /* copy contents of p_buf to p_rx_msg */\n        memcpy((uint8_t*)(p_ccb->p_rx_msg + 1) + p_ccb->p_rx_msg->offset,\n               (uint8_t*)(p_buf + 1) + p_buf->offset, p_buf->len);\n\n        if (pkt_type == AVDT_PKT_TYPE_END) {\n          p_ccb->p_rx_msg->offset -= p_ccb->p_rx_msg->len;\n          p_ccb->p_rx_msg->len += p_buf->len;\n          p_ret = p_ccb->p_rx_msg;\n          p_ccb->p_rx_msg = NULL;\n        } else {\n          p_ccb->p_rx_msg->offset += p_buf->len;\n          p_ccb->p_rx_msg->len += p_buf->len;\n          p_ret = NULL;\n        }\n        osi_free(p_buf);\n      }\n    }\n  }\n  return p_ret;\n}", "target": 2, "idx": 10218}
{"commit_id": "55f0fc7a02de8f12757f4937143d8d5091b2e40b", "project": "torvalds/linux", "func": "static void ipv6_select_ident(struct frag_hdr *fhdr, struct rt6_info *rt)\n{\n\tstatic u32 ip6_idents_hashrnd __read_mostly;\n\tstatic u32 ip6_idents_hashrnd_extra __read_mostly;\n\tu32 hash, id;\n\n\tnet_get_random_once(&ip6_idents_hashrnd, sizeof(ip6_idents_hashrnd));\n\tnet_get_random_once(&ip6_idents_hashrnd_extra, sizeof(ip6_idents_hashrnd_extra));\n\n\thash = __ipv6_addr_jhash(&rt->rt6i_dst.addr, ip6_idents_hashrnd);\n\thash = __ipv6_addr_jhash(&rt->rt6i_src.addr, hash);\n\thash = jhash_1word(hash, ip6_idents_hashrnd_extra);\n\n\tid = ip_idents_reserve(hash, 1);\n\tfhdr->identification = htonl(id);\n}", "target": 1, "idx": 10219}
{"commit_id": "1db88374", "project": "OpenSC", "func": "static int\nsc_oberthur_read_file(struct sc_pkcs15_card *p15card, const char *in_path,\n\t\tunsigned char **out, size_t *out_len,\n\t\tint verify_pin)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_card *card = p15card->card;\n\tstruct sc_file *file = NULL;\n\tstruct sc_path path;\n\tsize_t sz;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (!in_path || !out || !out_len)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Cannot read oberthur file\");\n\n\tsc_log(ctx, \"read file '%s'; verify_pin:%i\", in_path, verify_pin);\n\n\t*out = NULL;\n\t*out_len = 0;\n\n\tsc_format_path(in_path, &path);\n\trv = sc_select_file(card, &path, &file);\n\tif (rv != SC_SUCCESS) {\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, rv, \"Cannot select oberthur file to read\");\n\t}\n\n\tif (file->ef_structure == SC_FILE_EF_TRANSPARENT)\n\t\tsz = file->size;\n\telse\n\t\tsz = (file->record_length + 2) * file->record_count;\n\n\t*out = calloc(sz, 1);\n\tif (*out == NULL) {\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, \"Cannot read oberthur file\");\n\t}\n\n\tif (file->ef_structure == SC_FILE_EF_TRANSPARENT)   {\n\t\trv = sc_read_binary(card, 0, *out, sz, 0);\n\t}\n\telse\t{\n\t\tsize_t rec;\n\t\tsize_t offs = 0;\n\t\tsize_t rec_len = file->record_length;\n\n\t\tfor (rec = 1; ; rec++)   {\n\t\t\tif (rec > file->record_count) {\n\t\t\t\trv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trv = sc_read_record(card, rec, *out + offs + 2, rec_len, SC_RECORD_BY_REC_NR);\n\t\t\tif (rv == SC_ERROR_RECORD_NOT_FOUND)   {\n\t\t\t\trv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (rv < 0)   {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trec_len = rv;\n\n\t\t\t*(*out + offs) = 'R';\n\t\t\t*(*out + offs + 1) = rv;\n\n\t\t\toffs += rv + 2;\n\t\t}\n\n\t\tsz = offs;\n\t}\n\n\tsc_log(ctx, \"read oberthur file result %i\", rv);\n\tif (verify_pin && rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)   {\n\t\tstruct sc_pkcs15_object *objs[0x10], *pin_obj = NULL;\n\t\tconst struct sc_acl_entry *acl = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n\t\tint ii, nobjs;\n\n\t\tif (acl == NULL) {\n\t\t\tsc_file_free(file);\n\t\t\tfree(*out);\n\t\t\t*out = NULL;\n\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_DATA);\n\t\t}\n\n\t\tnobjs = sc_pkcs15_get_objects(p15card, SC_PKCS15_TYPE_AUTH_PIN, objs, 0x10);\n\t\tif (nobjs < 1) {\n\t\t\tsc_file_free(file);\n\t\t\tfree(*out);\n\t\t\t*out = NULL;\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_DATA_OBJECT_NOT_FOUND,\n\t\t\t\t\"Cannot read oberthur file: get AUTH objects error\");\n\t\t}\n\n\t\tfor (ii = 0; ii < nobjs; ii++) {\n\t\t\tstruct sc_pkcs15_auth_info *auth_info = (struct sc_pkcs15_auth_info *) objs[ii]->data;\n\t\t\tsc_log(ctx, \"compare PIN/ACL refs:%i/%i, method:%i/%i\",\n\t\t\t\tauth_info->attrs.pin.reference, acl->key_ref, auth_info->auth_method, acl->method);\n\t\t\tif (auth_info->attrs.pin.reference == (int)acl->key_ref && auth_info->auth_method == (unsigned)acl->method)   {\n\t\t\t\tpin_obj = objs[ii];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!pin_obj || !pin_obj->content.value)    {\n\t\t\trv = SC_ERROR_SECURITY_STATUS_NOT_SATISFIED;\n\t\t}\n\t\telse    {\n\t\t\trv = sc_pkcs15_verify_pin(p15card, pin_obj, pin_obj->content.value, pin_obj->content.len);\n\t\t\tif (!rv)\n\t\t\t\trv = sc_oberthur_read_file(p15card, in_path, out, out_len, 0);\n\t\t}\n\t}\n\n\tsc_file_free(file);\n\n\tif (rv < 0)   {\n\t\tfree(*out);\n\t\t*out = NULL;\n\t\t*out_len = 0;\n\t}\n\n\t*out_len = sz;\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}", "target": 1, "idx": 10220}
{"commit_id": "97574866cbab026acb1bbd735201f790091b9400", "project": "libtiff", "func": "int\nTIFFMergeFieldInfo(TIFF* tif, const TIFFFieldInfo info[], uint32_t n)\n{\n\tstatic const char module[] = \"TIFFMergeFieldInfo\";\n\tstatic const char reason[] = \"for fields array\";\n\tTIFFField *tp;\n\tsize_t nfields;\n\tuint32_t i;\n\n\tif (tif->tif_nfieldscompat > 0) {\n\t\ttif->tif_fieldscompat = (TIFFFieldArray *)\n\t\t\t_TIFFCheckRealloc(tif, tif->tif_fieldscompat,\n\t\t\t\t\t  tif->tif_nfieldscompat + 1,\n\t\t\t\t\t  sizeof(TIFFFieldArray), reason);\n\t} else {\n\t\ttif->tif_fieldscompat = (TIFFFieldArray *)\n\t\t\t_TIFFCheckMalloc(tif, 1, sizeof(TIFFFieldArray),\n\t\t\t\t\t reason);\n\t}\n\tif (!tif->tif_fieldscompat) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"Failed to allocate fields array\");\n\t\treturn -1;\n\t}\n\tnfields = tif->tif_nfieldscompat++;\n\n\ttif->tif_fieldscompat[nfields].type = tfiatOther;\n\ttif->tif_fieldscompat[nfields].allocated_size = n;\n\ttif->tif_fieldscompat[nfields].count = n;\n\ttif->tif_fieldscompat[nfields].fields =\n\t\t(TIFFField *)_TIFFCheckMalloc(tif, n, sizeof(TIFFField),\n\t\t\t\t\t      reason);\n\tif (!tif->tif_fieldscompat[nfields].fields) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"Failed to allocate fields array\");\n\t\treturn -1;\n\t}\n\n\ttp = tif->tif_fieldscompat[nfields].fields;\n\tfor (i = 0; i < n; i++) {\n\t\ttp->field_tag = info[i].field_tag;\n\t\ttp->field_readcount = info[i].field_readcount;\n\t\ttp->field_writecount = info[i].field_writecount;\n\t\ttp->field_type = info[i].field_type;\n\t\ttp->field_anonymous = 0;\n\t\ttp->set_field_type =\n\t\t     _TIFFSetGetType(info[i].field_type,\n\t\t\t\tinfo[i].field_readcount,\n\t\t\t\tinfo[i].field_passcount);\n\t\ttp->get_field_type =\n\t\t     _TIFFSetGetType(info[i].field_type,\n\t\t\t\tinfo[i].field_readcount,\n\t\t\t\tinfo[i].field_passcount);\n\t\ttp->field_bit = info[i].field_bit;\n\t\ttp->field_oktochange = info[i].field_oktochange;\n\t\ttp->field_passcount = info[i].field_passcount;\n\t\tif (info[i].field_name == NULL) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\"Field_name of %d.th allocation tag %d is NULL\", i, info[i].field_tag);\n\t\t\treturn -1;\n\t\t}\n\t\ttp->field_name = info[i].field_name;\n\t\ttp->field_subfields = NULL;\n\t\ttp++;\n\t}\n\n\tif (!_TIFFMergeFields(tif, tif->tif_fieldscompat[nfields].fields, n)) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"Setting up field info failed\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}", "target": 1, "idx": 10221}
{"commit_id": "e673ae41a998d1391bd562edb2ed6d49db7cc716", "project": "nginx/njs", "func": "static njs_int_t\nnjs_array_prototype_concat(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    double       idx;\n    int64_t      k, len, length;\n    njs_int_t    ret;\n    njs_uint_t   i;\n    njs_value_t  this, retval, *e;\n    njs_array_t  *array, *keys;\n\n    ret = njs_value_to_object(vm, &args[0]);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    /* TODO: ArraySpeciesCreate(). */\n\n    array = njs_array_alloc(vm, 0, 0, NJS_ARRAY_SPARE);\n    if (njs_slow_path(array == NULL)) {\n        return NJS_ERROR;\n    }\n\n    njs_set_array(&this, array);\n\n    len = 0;\n    length = 0;\n\n    for (i = 0; i < nargs; i++) {\n        e = njs_argument(args, i);\n\n        ret = njs_is_concat_spreadable(vm, e);\n        if (njs_slow_path(ret == NJS_ERROR)) {\n            return NJS_ERROR;\n        }\n\n        if (ret == NJS_OK) {\n            ret = njs_object_length(vm, e, &len);\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                return ret;\n            }\n\n            if (njs_slow_path((length + len) > NJS_MAX_LENGTH)) {\n                njs_type_error(vm, \"Invalid length\");\n                return NJS_ERROR;\n            }\n\n            if (njs_is_fast_array(e) || njs_fast_object(len)) {\n                for (k = 0; k < len; k++, length++) {\n                    ret = njs_value_property_i64(vm, e, k, &retval);\n                    if (njs_slow_path(ret != NJS_OK)) {\n                        if (ret == NJS_ERROR) {\n                            return NJS_ERROR;\n                        }\n\n                        njs_set_invalid(&retval);\n                    }\n\n                    ret = njs_value_property_i64_set(vm, &this, length,\n                                                     &retval);\n                    if (njs_slow_path(ret == NJS_ERROR)) {\n                        return ret;\n                    }\n                }\n\n                continue;\n            }\n\n            keys = njs_array_indices(vm, e);\n            if (njs_slow_path(keys == NULL)) {\n                return NJS_ERROR;\n            }\n\n            for (k = 0; k < keys->length; k++) {\n                ret = njs_value_property(vm, e, &keys->start[k], &retval);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    return ret;\n                }\n\n                if (ret == NJS_OK) {\n                    idx = njs_string_to_index(&keys->start[k]) + length;\n\n                    ret = njs_value_property_i64_set(vm, &this, idx, &retval);\n                    if (njs_slow_path(ret == NJS_ERROR)) {\n                        njs_array_destroy(vm, keys);\n                        return ret;\n                    }\n                }\n            }\n\n            njs_array_destroy(vm, keys);\n\n            length += len;\n\n            continue;\n        }\n\n        if (njs_slow_path((length + len) >= NJS_MAX_LENGTH)) {\n            njs_type_error(vm, \"Invalid length\");\n            return NJS_ERROR;\n        }\n\n        ret = njs_value_property_i64_set(vm, &this, length, e);\n        if (njs_slow_path(ret == NJS_ERROR)) {\n            return ret;\n        }\n\n        length++;\n    }\n\n    ret = njs_object_length_set(vm, &this, length);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return NJS_ERROR;\n    }\n\n    vm->retval = this;\n\n    return NJS_OK;\n}", "target": 2, "idx": 10222}
{"commit_id": "d30a8bd191f17b61938fc87890bffc80049b0774", "project": "chromium", "func": "void TabHelper::OnReenableComplete(int install_id,\n                                   int return_route_id,\n                                   const std::string& extension_id,\n                                   ExtensionReenabler::ReenableResult result) {\n  // Map the re-enable results to webstore-install results.\n  webstore_install::Result webstore_result = webstore_install::SUCCESS;\n  std::string error;\n  switch (result) {\n    case ExtensionReenabler::REENABLE_SUCCESS:\n      break;  // already set\n    case ExtensionReenabler::USER_CANCELED:\n      webstore_result = webstore_install::USER_CANCELLED;\n      error = \"User canceled install.\";\n      break;\n    case ExtensionReenabler::NOT_ALLOWED:\n      webstore_result = webstore_install::NOT_PERMITTED;\n      error = \"Install not permitted.\";\n      break;\n    case ExtensionReenabler::ABORTED:\n      webstore_result = webstore_install::ABORTED;\n      error = \"Aborted due to tab closing.\";\n      break;\n  }\n\n  OnInlineInstallComplete(install_id, return_route_id, extension_id,\n                          result == ExtensionReenabler::REENABLE_SUCCESS, error,\n                          webstore_result);\n  // Note: ExtensionReenabler contained the callback with the curried-in\n  // |extension_id|; delete it last.\n  extension_reenabler_.reset();\n}", "target": 2, "idx": 10223}
{"commit_id": "96a2bd8ae8c25e2acbe63319011cbb829b59e3df", "project": "chromium", "func": "MaybeHandle<JSArray> Fast_ArrayConcat(Isolate* isolate, Arguments* args) {\n  int n_arguments = args->length();\n  int result_len = 0;\n  {\n    DisallowHeapAllocation no_gc;\n    // Iterate through all the arguments performing checks\n    // and calculating total length.\n    for (int i = 0; i < n_arguments; i++) {\n      Object* arg = (*args)[i];\n      if (!arg->IsJSArray()) return MaybeHandle<JSArray>();\n      if (!HasOnlySimpleReceiverElements(isolate, JSObject::cast(arg))) {\n        return MaybeHandle<JSArray>();\n      }\n      // TODO(cbruni): support fast concatenation of DICTIONARY_ELEMENTS.\n      if (!JSObject::cast(arg)->HasFastElements()) {\n        return MaybeHandle<JSArray>();\n      }\n      Handle<JSArray> array(JSArray::cast(arg), isolate);\n      if (HasConcatSpreadableModifier(isolate, array)) {\n        return MaybeHandle<JSArray>();\n      }\n      int len = Smi::cast(array->length())->value();\n\n      // We shouldn't overflow when adding another len.\n      const int kHalfOfMaxInt = 1 << (kBitsPerInt - 2);\n      STATIC_ASSERT(FixedArray::kMaxLength < kHalfOfMaxInt);\n      USE(kHalfOfMaxInt);\n      result_len += len;\n      DCHECK(result_len >= 0);\n      // Throw an Error if we overflow the FixedArray limits\n      if (FixedArray::kMaxLength < result_len) {\n        THROW_NEW_ERROR(isolate,\n                        NewRangeError(MessageTemplate::kInvalidArrayLength),\n                        JSArray);\n      }\n    }\n  }\n  return ElementsAccessor::Concat(isolate, args, n_arguments);\n}", "target": 2, "idx": 10224}
{"commit_id": "bab062bde40b2ae8a91eecd522e84d8b993bab58", "project": "samboy/MaraDNS", "func": "int decomp_get_rddata(js_string *compressed, js_string *out,\n                      unsigned int compressed_offset, int type, int rdlength) {\n\n    char *desc;\n    int subtype, total, len;\n\n    desc = decomp_get_rrdesc(type);\n\n    if(desc == 0) { /* Unknown RR type */\n        if(rdlength == 0) {\n            return JS_SUCCESS;\n            }\n        if(decomp_append_bytes(compressed,out,compressed_offset,\n                               rdlength) != JS_SUCCESS) {\n            return JS_ERROR;\n            }\n        else {\n            return JS_SUCCESS;\n            }\n        }\n    else {\n        subtype = *desc;\n        total = 0;\n        /* Handle the various types of data we can get in the RR RDDATA */\n        while(subtype != 0) {\n            /* Fix-length data fields */\n            if(subtype > 0 && subtype < 64) {\n                if(decomp_append_bytes(compressed,out,\n                   compressed_offset,subtype) != JS_SUCCESS) {\n                       return JS_ERROR;\n                       }\n                total += subtype;\n                compressed_offset += subtype;\n                }\n            /* Dlabels (which may be compressed) */\n            else if(subtype == RRSUB_DLABEL) {\n                len = decomp_append_dlabel(compressed,out,\n                        compressed_offset);\n                if(len == JS_ERROR) {\n                    return JS_ERROR;\n                    }\n                total += len;\n                compressed_offset += len;\n                }\n            /* Text data fields */\n            else if(subtype == RRSUB_TEXT) {\n                /* Data abstraction violation */\n                len = *(compressed->string + compressed_offset);\n                len += 1; /* To account for the one byte which\n                             describes the length */\n                if(len < 0 || len > 256) {\n                    return JS_ERROR;\n                    }\n                if(decomp_append_bytes(compressed,out,\n                                       compressed_offset,len) !=\n                   JS_SUCCESS) {\n                    return JS_ERROR;\n                    }\n                total += len;\n                compressed_offset += len;\n                }\n            /* Variable length data (length determined by rdlength) */\n            else if(subtype == RRSUB_VARIABLE) {\n                len = rdlength - total;\n                if(len <= 0) {\n                    break;\n                    }\n                if(decomp_append_bytes(compressed,out,\n                                       compressed_offset,len) != JS_SUCCESS) {\n                    return JS_ERROR;\n                    }\n                total += len;\n                compressed_offset += len;\n                }\n            else { /* Should never happen */\n                return JS_ERROR;\n                }\n            desc++;\n            /* RRSUB_VARIABLE must be the last subtype */\n            if(subtype != RRSUB_VARIABLE)\n                subtype = *desc;\n            else\n                subtype = 0; /* break the loop */\n            }\n        /* Sanity check; make sure that rdlength panned out */\n        if(rdlength != total) {\n            return JS_ERROR;\n            }\n        }\n\n    /* The record's rddata was sucessfully decompressed */\n    return JS_SUCCESS;\n    }", "target": 2, "idx": 10225}
{"commit_id": "a51919f7e1ca9c535390a746fbf6e28c8402dc61", "project": "GNOME/librsvg", "func": "static cairo_surface_t *\nrsvg_filter_primitive_image_render_in (RsvgFilterPrimitive * self, RsvgFilterContext * context)\n{\n    RsvgDrawingCtx *ctx;\n    RsvgFilterPrimitiveImage *upself;\n    RsvgNode *drawable;\n    cairo_surface_t *result;\n\n    ctx = context->ctx;\n\n    upself = (RsvgFilterPrimitiveImage *) self;\n\n    if (!upself->href)\n        return NULL;\n\n    drawable = rsvg_acquire_node (ctx, upself->href->str);\n    if (!drawable)\n        return NULL;\n\n    rsvg_current_state (ctx)->affine = context->paffine;\n\n    result = rsvg_get_surface_of_node (ctx, drawable, context->width, context->height);\n\n    rsvg_release_node (ctx, drawable);\n\n    return result;\n}", "target": 2, "idx": 10226}
{"commit_id": "2c055153d401b8c49422971e3a0159869652d3da", "project": "gpac", "func": "void gf_filter_pid_detach_task(GF_FSTask *task)\n{\n\tu32 i, count;\n\tGF_Filter *filter = task->filter;\n\tGF_FilterPid *pid = task->pid->pid;\n\tGF_FilterPidInst *pidinst=NULL;\n\tGF_Filter *new_chain_input = task->udta;\n\n\t//we may have concurrent reset (due to play/stop/seek) and caps renegotiation\n\t//wait for the pid to be reset before detaching\n\tif (pid->filter->stream_reset_pending) {\n\t\tTASK_REQUEUE(task)\n\t\treturn;\n\t}\n\tif (new_chain_input->in_pid_connection_pending) {\n\t\tTASK_REQUEUE(task)\n\t\treturn;\n\t}\n\n\tcount = pid->num_destinations;\n\tfor (i=0; i<count; i++) {\n\t\tpidinst = gf_list_get(pid->destinations, i);\n\t\tif (pidinst->filter==filter) {\n\t\t\tbreak;\n\t\t}\n\t\tpidinst=NULL;\n\t}\n\t//flush any packets dispatched before detaching\n\tif (pidinst && gf_fq_count(pidinst->packets)) {\n\t\tBool in_process = filter->in_process;\n\t\tfilter->in_process = GF_FALSE;\n\t\t//prevent pid_would_block calls\n\t\tfilter->in_force_flush = GF_TRUE;\n\t\tpidinst->force_flush = GF_TRUE;\n\t\tgf_filter_process_inline(filter);\n\t\tpidinst->force_flush = GF_FALSE;\n\t\tfilter->in_force_flush = GF_FALSE;\n\t\tfilter->in_process = in_process;\n\t\tTASK_REQUEUE(task)\n\t\treturn;\n\t}\n\n\tassert(filter->freg->configure_pid);\n\tGF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (\"Filter %s pid %s detach from %s\\n\", task->pid->pid->filter->name, task->pid->pid->name, task->filter->name));\n\tassert(pid->filter->detach_pid_tasks_pending);\n\tsafe_int_dec(&pid->filter->detach_pid_tasks_pending);\n\n\t//first connection of this PID to this filter\n\tif (!pidinst) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Trying to detach PID %s not present in filter %s inputs\\n\",  pid->name, filter->name));\n\t\t//when swaping encoder, we may have swap_pidinst_dst not NULL so only check swap_pidinst_src\n\t\tassert(!new_chain_input->swap_pidinst_src);\n\t\tnew_chain_input->swap_needs_init = GF_FALSE;\n\t\treturn;\n\t}\n\n\t//detach props\n\tif (pidinst->props) {\n\t\tassert(pidinst->props->reference_count);\n\t\tif (safe_int_dec(& pidinst->props->reference_count) == 0) {\n\t\t\t//see \\ref gf_filter_pid_merge_properties_internal for mutex\n\t\t\tgf_mx_p(pidinst->pid->filter->tasks_mx);\n\t\t\tgf_list_del_item(pidinst->pid->properties, pidinst->props);\n\t\t\tgf_mx_v(pidinst->pid->filter->tasks_mx);\n\t\t\tgf_props_del(pidinst->props);\n\t\t}\n\t}\n\tpidinst->props = NULL;\n\n\tgf_mx_p(filter->tasks_mx);\n\t//detach pid - remove all packets in our pid instance and also update filter pending_packets\n\tcount = gf_fq_count(pidinst->packets);\n\tassert(count <= filter->pending_packets);\n\tsafe_int_sub(&filter->pending_packets, (s32) count);\n\tgf_filter_pid_inst_reset(pidinst);\n\tpidinst->pid = NULL;\n\tgf_list_del_item(pid->destinations, pidinst);\n\tpid->num_destinations = gf_list_count(pid->destinations);\n\tgf_list_del_item(filter->input_pids, pidinst);\n\tfilter->num_input_pids = gf_list_count(filter->input_pids);\n\tif (!filter->num_input_pids)\n\t\tfilter->single_source = NULL;\n\tgf_mx_v(filter->tasks_mx);\n\n\tif (!filter->detached_pid_inst) {\n\t\tfilter->detached_pid_inst = gf_list_new();\n\t}\n\tif (gf_list_find(filter->detached_pid_inst, pidinst)<0)\n\t\tgf_list_add(filter->detached_pid_inst, pidinst);\n\n\t//we are done, reset filter swap instance so that connection can take place\n\tif (new_chain_input->swap_needs_init) {\n\t\tnew_chain_input->swap_pidinst_dst = NULL;\n\t\tnew_chain_input->swap_pidinst_src = NULL;\n\t\tnew_chain_input->swap_needs_init = GF_FALSE;\n\t}\n\tassert(new_chain_input->detach_pid_tasks_pending);\n\tsafe_int_dec(&new_chain_input->detach_pid_tasks_pending);\n}", "target": 2, "idx": 10227}
{"commit_id": "874998af095c0e72dc041a2c9836dc3ef5afad87", "project": "tats/w3m", "func": "static void\nprint_internal_information(struct html_feed_environ *henv)\n{\n    int i;\n    Str s;\n    TextLineList *tl = newTextLineList();\n\n    s = Strnew_charp(\"<internal>\");\n    pushTextLine(tl, newTextLine(s, 0));\n    if (henv->title) {\n\ts = Strnew_m_charp(\"<title_alt title=\\\"\",\n\t\t\t   html_quote(henv->title), \"\\\">\", NULL);\n\tpushTextLine(tl, newTextLine(s, 0));\n    }\n#if 0\n    if (form_max >= 0) {\n\tFormList *fp;\n\tfor (i = 0; i <= form_max; i++) {\n\t    if (forms[i] == NULL)\n\t\tcontinue;\n\t    fp = forms[i];\n\t    s = Sprintf(\"<form_int fid=\\\"%d\\\" action=\\\"%s\\\" method=\\\"%s\\\"\",\n\t\t\ti, html_quote(fp->action->ptr),\n\t\t\t(fp->method == FORM_METHOD_POST) ? \"post\"\n\t\t\t: ((fp->method ==\n\t\t\t    FORM_METHOD_INTERNAL) ? \"internal\" : \"get\"));\n\t    if (fp->target)\n\t\tStrcat(s, Sprintf(\" target=\\\"%s\\\"\", html_quote(fp->target)));\n\t    if (fp->enctype == FORM_ENCTYPE_MULTIPART)\n\t\tStrcat_charp(s, \" enctype=\\\"multipart/form-data\\\"\");\n#ifdef USE_M17N\n\t    if (fp->charset)\n\t\tStrcat(s, Sprintf(\" accept-charset=\\\"%s\\\"\",\n\t\t\t\t  html_quote(fp->charset)));\n#endif\n\t    Strcat_charp(s, \">\");\n\t    pushTextLine(tl, newTextLine(s, 0));\n\t}\n    }\n#endif\n#ifdef MENU_SELECT\n    if (n_select > 0) {\n\tFormSelectOptionItem *ip;\n\tfor (i = 0; i < n_select; i++) {\n\t    s = Sprintf(\"<select_int selectnumber=%d>\", i);\n\t    pushTextLine(tl, newTextLine(s, 0));\n\t    for (ip = select_option[i].first; ip; ip = ip->next) {\n\t\ts = Sprintf(\"<option_int value=\\\"%s\\\" label=\\\"%s\\\"%s>\",\n\t\t\t    html_quote(ip->value ? ip->value->ptr :\n\t\t\t\t       ip->label->ptr),\n\t\t\t    html_quote(ip->label->ptr),\n\t\t\t    ip->checked ? \" selected\" : \"\");\n\t\tpushTextLine(tl, newTextLine(s, 0));\n\t    }\n\t    s = Strnew_charp(\"</select_int>\");\n\t    pushTextLine(tl, newTextLine(s, 0));\n\t}\n    }\n#endif\t\t\t\t/* MENU_SELECT */\n    if (n_textarea > 0) {\n\tfor (i = 0; i < n_textarea; i++) {\n\t    s = Sprintf(\"<textarea_int textareanumber=%d>\", i);\n\t    pushTextLine(tl, newTextLine(s, 0));\n\t    s = Strnew_charp(html_quote(textarea_str[i]->ptr));\n\t    Strcat_charp(s, \"</textarea_int>\");\n\t    pushTextLine(tl, newTextLine(s, 0));\n\t}\n    }\n    s = Strnew_charp(\"</internal>\");\n    pushTextLine(tl, newTextLine(s, 0));\n\n    if (henv->buf)\n\tappendTextLineList(henv->buf, tl);\n    else if (henv->f) {\n\tTextLineListItem *p;\n\tfor (p = tl->first; p; p = p->next)\n\t    fprintf(henv->f, \"%s\\n\", Str_conv_to_halfdump(p->ptr->line)->ptr);\n    }\n}", "target": 1, "idx": 10228}
{"commit_id": "545a5a90fa13a7915580ee0b061c5e8d41119d64", "project": "appneta/tcpreplay", "func": "int\nrewrite_packets(tcpedit_t *tcpedit, pcap_t *pin, pcap_dumper_t *pout)\n{\n    tcpr_dir_t cache_result = TCPR_DIR_C2S;     /* default to primary */\n    struct pcap_pkthdr pkthdr, *pkthdr_ptr;     /* packet header */\n    const u_char *pktconst = NULL;              /* packet from libpcap */\n    u_char **pktdata = NULL;\n    static u_char *pktdata_buff;\n    static char *frag = NULL;\n    COUNTER packetnum = 0;\n    int rcode;\n#ifdef ENABLE_FRAGROUTE\n    int frag_len, i, proto;\n#endif\n\n    pkthdr_ptr = &pkthdr;\n\n    if (pktdata_buff == NULL)\n        pktdata_buff = (u_char *)safe_malloc(MAXPACKET);\n\n    pktdata = &pktdata_buff;\n\n    if (frag == NULL)\n        frag = (char *)safe_malloc(MAXPACKET);\n\n    /* MAIN LOOP \n     * Keep sending while we have packets or until\n     * we've sent enough packets\n     */\n    while ((pktconst = pcap_next(pin, pkthdr_ptr)) != NULL) {\n        packetnum++;\n        dbgx(2, \"packet \" COUNTER_SPEC \" caplen %d\", packetnum, pkthdr.caplen);\n\n        if (pkthdr.caplen > MAXPACKET)\n            errx(-1, \"Frame too big, caplen %d exceeds %d\", pkthdr.caplen, MAXPACKET);\n        /* \n         * copy over the packet so we can pad it out if necessary and\n         * because pcap_next() returns a const ptr\n         */\n        memcpy(*pktdata, pktconst, pkthdr.caplen);\n\n#ifdef ENABLE_VERBOSE\n        if (options.verbose)\n            tcpdump_print(&tcpdump, pkthdr_ptr, *pktdata);\n#endif\n\n        /* Dual nic processing? */\n        if (options.cachedata != NULL) {\n            cache_result = check_cache(options.cachedata, packetnum);\n        }\n\n        /* sometimes we should not send the packet, in such cases\n         * no point in editing this packet at all, just write it to the\n         * output file (note, we can't just remove it, or the tcpprep cache\n         * file will loose it's indexing\n         */\n\n        if (cache_result == TCPR_DIR_NOSEND)\n            goto WRITE_PACKET; /* still need to write it so cache stays in sync */\n\n        if ((rcode = tcpedit_packet(tcpedit, &pkthdr_ptr, pktdata, cache_result)) == TCPEDIT_ERROR) {\n            return -1;\n        } else if ((rcode == TCPEDIT_SOFT_ERROR) && HAVE_OPT(SKIP_SOFT_ERRORS)) {\n            /* don't write packet */\n            dbgx(1, \"Packet \" COUNTER_SPEC \" is suppressed from being written due to soft errors\", packetnum);\n            continue;\n        }\n\n\nWRITE_PACKET:\n#ifdef ENABLE_FRAGROUTE\n        if (options.frag_ctx == NULL) {\n            /* write the packet when there's no fragrouting to be done */\n            pcap_dump((u_char *)pout, pkthdr_ptr, *pktdata);\n        } else {\n            /* get the L3 protocol of the packet */\n            proto = tcpedit_l3proto(tcpedit, AFTER_PROCESS, *pktdata, pkthdr_ptr->caplen);\n\n            /* packet is IPv4/IPv6 AND needs to be fragmented */\n            if ((proto ==  ETHERTYPE_IP || proto == ETHERTYPE_IP6) &&\n                ((options.fragroute_dir == FRAGROUTE_DIR_BOTH) ||\n                 (cache_result == TCPR_DIR_C2S && options.fragroute_dir == FRAGROUTE_DIR_C2S) ||\n                 (cache_result == TCPR_DIR_S2C && options.fragroute_dir == FRAGROUTE_DIR_S2C))) {\n\n                if (fragroute_process(options.frag_ctx, *pktdata, pkthdr_ptr->caplen) < 0)\n                    errx(-1, \"Error processing packet via fragroute: %s\", options.frag_ctx->errbuf);\n\n                i = 0;\n                while ((frag_len = fragroute_getfragment(options.frag_ctx, &frag)) > 0) {\n                    /* frags get the same timestamp as the original packet */\n                    dbgx(1, \"processing packet \" COUNTER_SPEC \" frag: %u (%d)\", packetnum, i++, frag_len);\n                    pkthdr_ptr->caplen = frag_len;\n                    pkthdr_ptr->len = frag_len;\n                    pcap_dump((u_char *)pout, pkthdr_ptr, (u_char *)frag);\n                }\n            } else {\n                /* write the packet without fragroute */\n                pcap_dump((u_char *)pout, pkthdr_ptr, *pktdata);\n            }\n        }\n#else\n    /* write the packet when there's no fragrouting to be done */\n    pcap_dump((u_char *)pout, pkthdr_ptr, *pktdata);\n\n#endif\n    } /* while() */\n    return 0;\n}", "target": 2, "idx": 10229}
{"commit_id": "688e8128b7a92df982709a4137ea4588d16f24aa", "project": "torvalds/linux", "func": "static ssize_t\nshow_transport_handle(struct device *dev, struct device_attribute *attr,\n\t\t      char *buf)\n{\n\tstruct iscsi_internal *priv = dev_to_iscsi_internal(dev);\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\treturn sprintf(buf, \"%llu\\n\", (unsigned long long)iscsi_handle(priv->iscsi_transport));\n}", "target": 1, "idx": 10230}
{"commit_id": "b359c90c84b770d1d39c15aa4662478c7c09d745", "project": "AcademySoftwareFoundation/OpenImageIO", "func": "bool\nGIFInput::read_subimage_data()\n{\n    GifColorType* colormap = NULL;\n    int colormap_count;\n    if (m_gif_file->Image.ColorMap) {  // local colormap\n        colormap = m_gif_file->Image.ColorMap->Colors;\n        colormap_count = m_gif_file->Image.ColorMap->ColorCount;\n    } else if (m_gif_file->SColorMap) {  // global colormap\n        colormap = m_gif_file->SColorMap->Colors;\n        colormap_count = m_gif_file->SColorMap->ColorCount;\n    } else {\n        errorf(\"Neither local nor global colormap present.\");\n        return false;\n    }\n\n    if (m_subimage == 0 || m_previous_disposal_method == DISPOSE_BACKGROUND) {\n        // make whole canvas transparent\n        std::fill(m_canvas.begin(), m_canvas.end(), 0x00);\n    }\n\n    // decode scanline index if image is interlaced\n    bool interlacing = m_spec.get_int_attribute(\"gif:Interlacing\") != 0;\n\n    // get subimage dimensions and draw it on canvas\n    int window_height = m_gif_file->Image.Height;\n    int window_width  = m_gif_file->Image.Width;\n    int window_top    = m_gif_file->Image.Top;\n    int window_left   = m_gif_file->Image.Left;\n    std::unique_ptr<unsigned char[]> fscanline(new unsigned char[window_width]);\n    for (int wy = 0; wy < window_height; wy++) {\n        if (DGifGetLine(m_gif_file, &fscanline[0], window_width) == GIF_ERROR) {\n            report_last_error();\n            return false;\n        }\n        int y = window_top\n                + (interlacing ? decode_line_number(wy, window_height) : wy);\n        if (0 <= y && y < m_spec.height) {\n            for (int wx = 0; wx < window_width; wx++) {\n                if (fscanline[wx] >= colormap_count) {\n                    errorfmt(\"Possible corruption: Encoded value {:d} @ ({},{}) exceeds palette size {}\\n\",\n                             fscanline[wx], wx, y, colormap_count);\n                    return false;\n                }\n                int x   = window_left + wx;\n                int idx = m_spec.nchannels * (y * m_spec.width + x);\n                if (0 <= x && x < m_spec.width\n                    && fscanline[wx] != m_transparent_color) {\n                    m_canvas[idx]     = colormap[fscanline[wx]].Red;\n                    m_canvas[idx + 1] = colormap[fscanline[wx]].Green;\n                    m_canvas[idx + 2] = colormap[fscanline[wx]].Blue;\n                    m_canvas[idx + 3] = 0xff;\n                }\n            }\n        }\n    }\n\n    return true;\n}", "target": 3, "idx": 10231}
{"commit_id": "b4c7cefb154dcd8777e62196e2ca5fceb71a2dcb", "project": "mz-automation/libiec61850", "func": "MmsValue*\nMmsValue_decodeMmsData(uint8_t* buffer, int bufPos, int bufferLength, int* endBufPos)\n{\n    MmsValue* value = NULL;\n\n    int dataEndBufPos = bufferLength;\n\n    uint8_t tag = buffer[bufPos++];\n\n    int dataLength;\n\n    bufPos = BerDecoder_decodeLength(buffer, &dataLength, bufPos, dataEndBufPos);\n\n    if (bufPos < 0)\n        goto exit_with_error;\n\n    switch (tag) {\n\n    case 0xa1: /* MMS_ARRAY */\n    case 0xa2: /* MMS_STRUCTURE */\n    {\n        int elementCount = getNumberOfElements(buffer, bufPos, dataLength);\n\n        if (elementCount < 0)\n            goto exit_with_error;\n\n        if (tag == 0xa1)\n            value = MmsValue_createEmptyArray(elementCount);\n        else\n            value = MmsValue_createEmptyStructure(elementCount);\n\n        int i;\n\n        for (i = 0; i < elementCount; i++) {\n\n            int elementLength;\n\n            int newBufPos = BerDecoder_decodeLength(buffer, &elementLength, bufPos + 1, dataEndBufPos);\n\n            if (newBufPos < 0)\n                goto exit_with_error;\n\n            int elementBufLength = newBufPos - bufPos + elementLength;\n\n            MmsValue* elementValue = MmsValue_decodeMmsData(buffer, bufPos, bufPos + elementBufLength, NULL);\n\n            if (elementValue == NULL)\n                goto exit_with_error;\n\n            MmsValue_setElement(value, i, elementValue);\n\n            bufPos = newBufPos + elementLength;\n        }\n\n        if (value == NULL)\n            goto exit_with_error;\n    }\n\n        break;\n\n    case 0x80: /* MMS_DATA_ACCESS_ERROR */\n        value = MmsValue_newDataAccessError((MmsDataAccessError) BerDecoder_decodeUint32(buffer, dataLength, bufPos));\n        bufPos += dataLength;\n        break;\n\n    case 0x83: /* MMS_BOOLEAN */\n        value = MmsValue_newBoolean(BerDecoder_decodeBoolean(buffer, bufPos));\n        bufPos += dataLength;\n        break;\n\n    case 0x84: /* MMS_BIT_STRING */\n    {\n        int padding = buffer[bufPos];\n\n        if (padding > 7)\n            goto exit_with_error;\n\n        int bitStringLength = (8 * (dataLength - 1)) - padding;\n        value = MmsValue_newBitString(bitStringLength);\n        memcpy(value->value.bitString.buf, buffer + bufPos + 1, dataLength - 1);\n        bufPos += dataLength;\n    }\n        break;\n\n    case 0x85: /* MMS_INTEGER */\n        if (dataLength > 8)\n            goto exit_with_error;\n\n        value = MmsValue_newInteger(dataLength * 8);\n        memcpy(value->value.integer->octets, buffer + bufPos, dataLength);\n        value->value.integer->size = dataLength;\n        bufPos += dataLength;\n        break;\n\n    case 0x86: /* MMS_UNSIGNED */\n        if (dataLength > 8)\n            goto exit_with_error;\n\n        value = MmsValue_newUnsigned(dataLength * 8);\n        memcpy(value->value.integer->octets, buffer + bufPos, dataLength);\n        value->value.integer->size = dataLength;\n        bufPos += dataLength;\n        break;\n\n    case 0x87: /* MMS_FLOAT */\n        if (dataLength == 9)\n            value = MmsValue_newDouble(BerDecoder_decodeDouble(buffer, bufPos));\n        else if (dataLength == 5)\n            value = MmsValue_newFloat(BerDecoder_decodeFloat(buffer, bufPos));\n        bufPos += dataLength;\n        break;\n\n    case 0x89: /* MMS_OCTET_STRING */\n        value = MmsValue_newOctetString(dataLength, dataLength);\n        memcpy(value->value.octetString.buf, buffer + bufPos, dataLength);\n        bufPos += dataLength;\n        break;\n\n    case 0x8a: /* MMS_VISIBLE_STRING */\n        value = MmsValue_newVisibleStringFromByteArray(buffer + bufPos, dataLength);\n        bufPos += dataLength;\n        break;\n\n    case 0x8c: /* MMS_BINARY_TIME */\n        if (dataLength == 4)\n            value = MmsValue_newBinaryTime(true);\n        else if (dataLength == 6)\n            value = MmsValue_newBinaryTime(false);\n\n        if ((dataLength == 4) || (dataLength == 6))\n            memcpy(value->value.binaryTime.buf, buffer + bufPos, dataLength);\n\n        bufPos += dataLength;\n\n        break;\n\n    case 0x90: /* MMS_STRING */\n        value = MmsValue_newVisibleStringFromByteArray(buffer + bufPos, dataLength);\n        value->type = MMS_STRING;\n        bufPos += dataLength;\n\n        break;\n\n    case 0x91: /* MMS_UTC_TIME */\n        if (dataLength == 8) {\n            value = MmsValue_newUtcTime(0);\n            MmsValue_setUtcTimeByBuffer(value, buffer + bufPos);\n            bufPos += dataLength;\n        }\n        else\n            goto exit_with_error;\n\n        break;\n\n    default: /* unknown tag -> decoding error */\n        goto exit_with_error;\n    }\n\n    if (endBufPos != NULL)\n        *endBufPos = bufPos;\n\n    return value;\n\nexit_with_error:\n\n    if (value != NULL)\n        MmsValue_delete(value);\n\n    return NULL;\n}", "target": 2, "idx": 10232}
{"commit_id": "79f52a0dbd484aad111e4bf4a4f7047c7ceb6137", "project": "ffmpeg", "func": "static int decode_block(AVCodecContext *avctx, void *tdata,\n                        int jobnr, int threadnr)\n{\n    EXRContext *s = avctx->priv_data;\n    AVFrame *const p = s->picture;\n    EXRThreadData *td = &s->thread_data[threadnr];\n    const uint8_t *channel_buffer[4] = { 0 };\n    const uint8_t *buf = s->buf;\n    uint64_t line_offset, uncompressed_size;\n    uint16_t *ptr_x;\n    uint8_t *ptr;\n    uint32_t data_size;\n    uint64_t line, col = 0;\n    uint64_t tileX, tileY, tileLevelX, tileLevelY;\n    const uint8_t *src;\n    int axmax = (avctx->width - (s->xmax + 1)) * 2 * s->desc->nb_components; /* nb pixel to add at the right of the datawindow */\n    int bxmin = s->xmin * 2 * s->desc->nb_components; /* nb pixel to add at the left of the datawindow */\n    int i, x, buf_size = s->buf_size;\n    float one_gamma = 1.0f / s->gamma;\n    avpriv_trc_function trc_func = avpriv_get_trc_function_from_trc(s->apply_trc_type);\n    int ret;\n\n    line_offset = AV_RL64(s->gb.buffer + jobnr * 8);\n\n    if (s->is_tile) {\n        if (line_offset > buf_size - 20)\n            return AVERROR_INVALIDDATA;\n\n        src  = buf + line_offset + 20;\n\n        tileX = AV_RL32(src - 20);\n        tileY = AV_RL32(src - 16);\n        tileLevelX = AV_RL32(src - 12);\n        tileLevelY = AV_RL32(src - 8);\n\n        data_size = AV_RL32(src - 4);\n        if (data_size <= 0 || data_size > buf_size)\n            return AVERROR_INVALIDDATA;\n\n        if (tileLevelX || tileLevelY) { /* tile level, is not the full res level */\n            avpriv_report_missing_feature(s->avctx, \"Subres tile before full res tile\");\n            return AVERROR_PATCHWELCOME;\n        }\n\n        if (s->xmin || s->ymin) {\n            avpriv_report_missing_feature(s->avctx, \"Tiles with xmin/ymin\");\n            return AVERROR_PATCHWELCOME;\n        }\n\n        line = s->tile_attr.ySize * tileY;\n        col = s->tile_attr.xSize * tileX;\n\n        if (line < s->ymin || line > s->ymax ||\n            col  < s->xmin || col  > s->xmax)\n            return AVERROR_INVALIDDATA;\n\n        td->ysize = FFMIN(s->tile_attr.ySize, s->ydelta - tileY * s->tile_attr.ySize);\n        td->xsize = FFMIN(s->tile_attr.xSize, s->xdelta - tileX * s->tile_attr.xSize);\n\n        if (col) { /* not the first tile of the line */\n            bxmin = 0; /* doesn't add pixel at the left of the datawindow */\n        }\n\n        if ((col + td->xsize) != s->xdelta)/* not the last tile of the line */\n            axmax = 0; /* doesn't add pixel at the right of the datawindow */\n\n        td->channel_line_size = td->xsize * s->current_channel_offset;/* uncompress size of one line */\n        uncompressed_size = td->channel_line_size * (uint64_t)td->ysize;/* uncompress size of the block */\n    } else {\n        if (line_offset > buf_size - 8)\n            return AVERROR_INVALIDDATA;\n\n        src  = buf + line_offset + 8;\n        line = AV_RL32(src - 8);\n\n        if (line < s->ymin || line > s->ymax)\n            return AVERROR_INVALIDDATA;\n\n        data_size = AV_RL32(src - 4);\n        if (data_size <= 0 || data_size > buf_size)\n            return AVERROR_INVALIDDATA;\n\n        td->ysize          = FFMIN(s->scan_lines_per_block, s->ymax - line + 1); /* s->ydelta - line ?? */\n        td->xsize          = s->xdelta;\n\n        td->channel_line_size = td->xsize * s->current_channel_offset;/* uncompress size of one line */\n        uncompressed_size = td->channel_line_size * (uint64_t)td->ysize;/* uncompress size of the block */\n\n        if ((s->compression == EXR_RAW && (data_size != uncompressed_size ||\n                                           line_offset > buf_size - uncompressed_size)) ||\n            (s->compression != EXR_RAW && (data_size > uncompressed_size ||\n                                           line_offset > buf_size - data_size))) {\n            return AVERROR_INVALIDDATA;\n        }\n    }\n\n    if (data_size < uncompressed_size || s->is_tile) { /* td->tmp is use for tile reorganization */\n        av_fast_padded_malloc(&td->tmp, &td->tmp_size, uncompressed_size);\n        if (!td->tmp)\n            return AVERROR(ENOMEM);\n    }\n\n    if (data_size < uncompressed_size) {\n        av_fast_padded_malloc(&td->uncompressed_data,\n                              &td->uncompressed_size, uncompressed_size);\n\n        if (!td->uncompressed_data)\n            return AVERROR(ENOMEM);\n\n        ret = AVERROR_INVALIDDATA;\n        switch (s->compression) {\n        case EXR_ZIP1:\n        case EXR_ZIP16:\n            ret = zip_uncompress(src, data_size, uncompressed_size, td);\n            break;\n        case EXR_PIZ:\n            ret = piz_uncompress(s, src, data_size, uncompressed_size, td);\n            break;\n        case EXR_PXR24:\n            ret = pxr24_uncompress(s, src, data_size, uncompressed_size, td);\n            break;\n        case EXR_RLE:\n            ret = rle_uncompress(src, data_size, uncompressed_size, td);\n            break;\n        case EXR_B44:\n        case EXR_B44A:\n            ret = b44_uncompress(s, src, data_size, uncompressed_size, td);\n            break;\n        }\n        if (ret < 0) {\n            av_log(avctx, AV_LOG_ERROR, \"decode_block() failed.\\n\");\n            return ret;\n        }\n        src = td->uncompressed_data;\n    }\n\n    channel_buffer[0] = src + td->xsize * s->channel_offsets[0];\n    channel_buffer[1] = src + td->xsize * s->channel_offsets[1];\n    channel_buffer[2] = src + td->xsize * s->channel_offsets[2];\n    if (s->channel_offsets[3] >= 0)\n        channel_buffer[3] = src + td->xsize * s->channel_offsets[3];\n\n    ptr = p->data[0] + line * p->linesize[0] + (col * s->desc->nb_components * 2);\n\n    for (i = 0;\n         i < td->ysize; i++, ptr += p->linesize[0]) {\n\n        const uint8_t *r, *g, *b, *a;\n\n        r = channel_buffer[0];\n        g = channel_buffer[1];\n        b = channel_buffer[2];\n        if (channel_buffer[3])\n            a = channel_buffer[3];\n\n        ptr_x = (uint16_t *) ptr;\n\n        // Zero out the start if xmin is not 0\n        memset(ptr_x, 0, bxmin);\n        ptr_x += s->xmin * s->desc->nb_components;\n\n        if (s->pixel_type == EXR_FLOAT) {\n            // 32-bit\n            if (trc_func) {\n                for (x = 0; x < td->xsize; x++) {\n                    union av_intfloat32 t;\n                    t.i = bytestream_get_le32(&r);\n                    t.f = trc_func(t.f);\n                    *ptr_x++ = exr_flt2uint(t.i);\n\n                    t.i = bytestream_get_le32(&g);\n                    t.f = trc_func(t.f);\n                    *ptr_x++ = exr_flt2uint(t.i);\n\n                    t.i = bytestream_get_le32(&b);\n                    t.f = trc_func(t.f);\n                    *ptr_x++ = exr_flt2uint(t.i);\n                    if (channel_buffer[3])\n                        *ptr_x++ = exr_flt2uint(bytestream_get_le32(&a));\n                }\n            } else {\n                for (x = 0; x < td->xsize; x++) {\n                    union av_intfloat32 t;\n                    t.i = bytestream_get_le32(&r);\n                    if (t.f > 0.0f)  /* avoid negative values */\n                        t.f = powf(t.f, one_gamma);\n                    *ptr_x++ = exr_flt2uint(t.i);\n\n                    t.i = bytestream_get_le32(&g);\n                    if (t.f > 0.0f)\n                        t.f = powf(t.f, one_gamma);\n                    *ptr_x++ = exr_flt2uint(t.i);\n\n                    t.i = bytestream_get_le32(&b);\n                    if (t.f > 0.0f)\n                        t.f = powf(t.f, one_gamma);\n                    *ptr_x++ = exr_flt2uint(t.i);\n                    if (channel_buffer[3])\n                        *ptr_x++ = exr_flt2uint(bytestream_get_le32(&a));\n                }\n            }\n        } else {\n            // 16-bit\n            for (x = 0; x < td->xsize; x++) {\n                *ptr_x++ = s->gamma_table[bytestream_get_le16(&r)];\n                *ptr_x++ = s->gamma_table[bytestream_get_le16(&g)];\n                *ptr_x++ = s->gamma_table[bytestream_get_le16(&b)];\n                if (channel_buffer[3])\n                    *ptr_x++ = exr_halflt2uint(bytestream_get_le16(&a));\n            }\n        }\n\n        // Zero out the end if xmax+1 is not w\n        memset(ptr_x, 0, axmax);\n\n        channel_buffer[0] += td->channel_line_size;\n        channel_buffer[1] += td->channel_line_size;\n        channel_buffer[2] += td->channel_line_size;\n        if (channel_buffer[3])\n            channel_buffer[3] += td->channel_line_size;\n    }\n\n    return 0;\n}", "target": 2, "idx": 10233}
{"commit_id": "16d51a590a8ce3befb1308e0e7ab77f3b661af33", "project": "torvalds/linux", "func": "void task_numa_free(struct task_struct *p, bool final)\n{\n\tstruct numa_group *grp = p->numa_group;\n\tunsigned long *numa_faults = p->numa_faults;\n\tunsigned long flags;\n\tint i;\n\n\tif (!numa_faults)\n\t\treturn;\n\n\tif (grp) {\n\t\tspin_lock_irqsave(&grp->lock, flags);\n\t\tfor (i = 0; i < NR_NUMA_HINT_FAULT_STATS * nr_node_ids; i++)\n\t\t\tgrp->faults[i] -= p->numa_faults[i];\n\t\tgrp->total_faults -= p->total_numa_faults;\n\n\t\tgrp->nr_tasks--;\n\t\tspin_unlock_irqrestore(&grp->lock, flags);\n\t\tRCU_INIT_POINTER(p->numa_group, NULL);\n\t\tput_numa_group(grp);\n\t}\n\n\tif (final) {\n\t\tp->numa_faults = NULL;\n\t\tkfree(numa_faults);\n\t} else {\n\t\tp->total_numa_faults = 0;\n\t\tfor (i = 0; i < NR_NUMA_HINT_FAULT_STATS * nr_node_ids; i++)\n\t\t\tnuma_faults[i] = 0;\n\t}\n}", "target": 1, "idx": 10234}
{"commit_id": "a4bcdcb1f8df4f7427e208201501a9d8e41e386b", "project": "chromium", "func": "bool FrameLoader::prepareForCommit()\n{\n    PluginScriptForbiddenScope forbidPluginDestructorScripting;\n    RefPtrWillBeRawPtr<DocumentLoader> pdl = m_provisionalDocumentLoader;\n\n    if (m_frame->document()) {\n        unsigned totalNodeCount = InstanceCounters::counterValue(InstanceCounters::NodeCounter);\n        int nodeCount = static_cast<int>(totalNodeCount);\n        for (Document* document : Document::liveDocumentSet()) {\n            if (document != m_frame->document())\n                nodeCount -= document->nodeCount();\n        }\n        ASSERT(nodeCount >= 0);\n        float ratio = static_cast<float>(nodeCount) / totalNodeCount;\n        ThreadState::current()->schedulePageNavigationGCIfNeeded(ratio);\n    }\n\n    // Don't allow any new child frames to load in this frame: attaching a new\n    // child frame during or after detaching children results in an attached\n    // frame on a detached DOM tree, which is bad.\n    SubframeLoadingDisabler disabler(m_frame->document());\n    if (m_documentLoader) {\n        client()->dispatchWillClose();\n        dispatchUnloadEvent();\n    }\n    m_frame->detachChildren();\n    // The previous calls to dispatchUnloadEvent() and detachChildren() can\n    // execute arbitrary script via things like unload events. If the executed\n    // script intiates a new load or causes the current frame to be detached,\n    // we need to abandon the current load.\n    if (pdl != m_provisionalDocumentLoader)\n        return false;\n    if (m_documentLoader) {\n        FrameNavigationDisabler navigationDisabler(*m_frame);\n        detachDocumentLoader(m_documentLoader);\n    }\n    // detachFromFrame() will abort XHRs that haven't completed, which can\n    // trigger event listeners for 'abort'. These event listeners might detach\n    // the frame.\n    // TODO(dcheng): Investigate if this can be moved above the check that\n    // m_provisionalDocumentLoader hasn't changed.\n    if (!m_frame->client())\n        return false;\n    // No more events will be dispatched so detach the Document.\n    // TODO(yoav): Should we also be nullifying domWindow's document (or domWindow) since the doc is now detached?\n    if (m_frame->document())\n        m_frame->document()->detach();\n    m_documentLoader = m_provisionalDocumentLoader.release();\n\n    return true;\n}", "target": 2, "idx": 10235}
{"commit_id": "45af1d7aae7d5520d2858f8517a1342646f015db", "project": "torvalds/linux", "func": "static ssize_t module_gzip_decompress(struct load_info *info,\n\t\t\t\t      const void *buf, size_t size)\n{\n\tstruct z_stream_s s = { 0 };\n\tsize_t new_size = 0;\n\tsize_t gzip_hdr_len;\n\tssize_t retval;\n\tint rc;\n\n\tgzip_hdr_len = module_gzip_header_len(buf, size);\n\tif (!gzip_hdr_len) {\n\t\tpr_err(\"not a gzip compressed module\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ts.next_in = buf + gzip_hdr_len;\n\ts.avail_in = size - gzip_hdr_len;\n\n\ts.workspace = kmalloc(zlib_inflate_workspacesize(), GFP_KERNEL);\n\tif (!s.workspace)\n\t\treturn -ENOMEM;\n\n\trc = zlib_inflateInit2(&s, -MAX_WBITS);\n\tif (rc != Z_OK) {\n\t\tpr_err(\"failed to initialize decompressor: %d\\n\", rc);\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdo {\n\t\tstruct page *page = module_get_next_page(info);\n\n\t\tif (IS_ERR(page)) {\n\t\t\tretval = PTR_ERR(page);\n\t\t\tgoto out_inflate_end;\n\t\t}\n\n\t\ts.next_out = kmap_local_page(page);\n\t\ts.avail_out = PAGE_SIZE;\n\t\trc = zlib_inflate(&s, 0);\n\t\tkunmap_local(s.next_out);\n\n\t\tnew_size += PAGE_SIZE - s.avail_out;\n\t} while (rc == Z_OK);\n\n\tif (rc != Z_STREAM_END) {\n\t\tpr_err(\"decompression failed with status %d\\n\", rc);\n\t\tretval = -EINVAL;\n\t\tgoto out_inflate_end;\n\t}\n\n\tretval = new_size;\n\nout_inflate_end:\n\tzlib_inflateEnd(&s);\nout:\n\tkfree(s.workspace);\n\treturn retval;\n}", "target": 1, "idx": 10236}
{"commit_id": "319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12", "project": "xen-project/xen", "func": "int iommu_do_dt_domctl(struct xen_domctl *domctl, struct domain *d,\n                       XEN_GUEST_HANDLE_PARAM(xen_domctl_t) u_domctl)\n{\n    int ret;\n    struct dt_device_node *dev;\n\n    switch ( domctl->cmd )\n    {\n    case XEN_DOMCTL_assign_device:\n        ASSERT(d);\n        /* fall through */\n    case XEN_DOMCTL_test_assign_device:\n        ret = -ENODEV;\n        if ( domctl->u.assign_device.dev != XEN_DOMCTL_DEV_DT )\n            break;\n\n        ret = -EINVAL;\n        if ( (d && d->is_dying) || domctl->u.assign_device.flags )\n            break;\n\n        ret = dt_find_node_by_gpath(domctl->u.assign_device.u.dt.path,\n                                    domctl->u.assign_device.u.dt.size,\n                                    &dev);\n        if ( ret )\n            break;\n\n        ret = xsm_assign_dtdevice(XSM_HOOK, d, dt_node_full_name(dev));\n        if ( ret )\n            break;\n\n        if ( domctl->cmd == XEN_DOMCTL_test_assign_device )\n        {\n            if ( iommu_dt_device_is_assigned(dev) )\n            {\n                printk(XENLOG_G_ERR \"%s already assigned.\\n\",\n                       dt_node_full_name(dev));\n                ret = -EINVAL;\n            }\n            break;\n        }\n\n        if ( d == dom_io )\n            return -EINVAL;\n\n        ret = iommu_add_dt_device(dev);\n        /*\n         * Ignore \"-EEXIST\" error code as it would mean that the device is\n         * already added to the IOMMU (positive result). Such happens after\n         * re-creating guest domain.\n         */\n        if ( ret < 0 && ret != -EEXIST )\n        {\n            printk(XENLOG_G_ERR \"Failed to add %s to the IOMMU\\n\",\n                   dt_node_full_name(dev));\n            break;\n        }\n\n        ret = iommu_assign_dt_device(d, dev);\n\n        if ( ret )\n            printk(XENLOG_G_ERR \"XEN_DOMCTL_assign_dt_device: assign \\\"%s\\\"\"\n                   \" to dom%u failed (%d)\\n\",\n                   dt_node_full_name(dev), d->domain_id, ret);\n        break;\n\n    case XEN_DOMCTL_deassign_device:\n        ret = -ENODEV;\n        if ( domctl->u.assign_device.dev != XEN_DOMCTL_DEV_DT )\n            break;\n\n        ret = -EINVAL;\n        if ( domctl->u.assign_device.flags )\n            break;\n\n        ret = dt_find_node_by_gpath(domctl->u.assign_device.u.dt.path,\n                                    domctl->u.assign_device.u.dt.size,\n                                    &dev);\n        if ( ret )\n            break;\n\n        ret = xsm_deassign_dtdevice(XSM_HOOK, d, dt_node_full_name(dev));\n\n        if ( d == dom_io )\n            return -EINVAL;\n\n        ret = iommu_deassign_dt_device(d, dev);\n\n        if ( ret )\n            printk(XENLOG_G_ERR \"XEN_DOMCTL_assign_dt_device: assign \\\"%s\\\"\"\n                   \" to dom%u failed (%d)\\n\",\n                   dt_node_full_name(dev), d->domain_id, ret);\n        break;\n\n    default:\n        ret = -ENOSYS;\n        break;\n    }\n\n    return ret;\n}", "target": 1, "idx": 10237}
{"commit_id": "af368027a49a751d6ff4ee9e3f9961f35bb4fede", "project": "torvalds/linux", "func": "static int snd_timer_user_open(struct inode *inode, struct file *file)\n{\n\tstruct snd_timer_user *tu;\n\tint err;\n\n\terr = nonseekable_open(inode, file);\n\tif (err < 0)\n\t\treturn err;\n\n\ttu = kzalloc(sizeof(*tu), GFP_KERNEL);\n\tif (tu == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&tu->qlock);\n\tinit_waitqueue_head(&tu->qchange_sleep);\n\tmutex_init(&tu->ioctl_lock);\n\ttu->ticks = 1;\n\ttu->queue_size = 128;\n\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t    GFP_KERNEL);\n\tif (tu->queue == NULL) {\n\t\tkfree(tu);\n\t\treturn -ENOMEM;\n\t}\n\tfile->private_data = tu;\n\treturn 0;\n}", "target": 1, "idx": 10238}
{"commit_id": "9fee4ae076b1ec97b97efb79ece08d1dab4df29a", "project": "FreeRDP", "func": "static BOOL region16_simplify_bands(REGION16* region)\n{\n\t/** Simplify consecutive bands that touch and have the same items\n\t *\n\t *  ====================          ====================\n\t *     | 1 |  | 2   |               |   |  |     |\n\t *  ====================            |   |  |     |\n\t *     | 1 |  | 2   |\t   ====>    | 1 |  |  2  |\n\t *  ====================            |   |  |     |\n\t *     | 1 |  | 2   |               |   |  |     |\n\t *  ====================          ====================\n\t *\n\t */\n\tRECTANGLE_16* band1, *band2, *endPtr, *endBand, *tmp;\n\tint nbRects, finalNbRects;\n\tint bandItems, toMove;\n\tfinalNbRects = nbRects = region16_n_rects(region);\n\n\tif (nbRects < 2)\n\t\treturn TRUE;\n\n\tband1 = region16_rects_noconst(region);\n\tendPtr = band1 + nbRects;\n\n\tdo\n\t{\n\t\tband2 = next_band(band1, endPtr, &bandItems);\n\n\t\tif (band2 == endPtr)\n\t\t\tbreak;\n\n\t\tif ((band1->bottom == band2->top) && band_match(band1, band2, endPtr))\n\t\t{\n\t\t\t/* adjust the bottom of band1 items */\n\t\t\ttmp = band1;\n\n\t\t\twhile (tmp < band2)\n\t\t\t{\n\t\t\t\ttmp->bottom = band2->bottom;\n\t\t\t\ttmp++;\n\t\t\t}\n\n\t\t\t/* override band2, we don't move band1 pointer as the band after band2\n\t\t\t * may be merged too */\n\t\t\tendBand = band2 + bandItems;\n\t\t\ttoMove = (endPtr - endBand) * sizeof(RECTANGLE_16);\n\n\t\t\tif (toMove)\n\t\t\t\tMoveMemory(band2, endBand, toMove);\n\n\t\t\tfinalNbRects -= bandItems;\n\t\t\tendPtr -= bandItems;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tband1 = band2;\n\t\t}\n\t}\n\twhile (TRUE);\n\n\tif (finalNbRects != nbRects)\n\t{\n\t\tREGION16_DATA* data;\n\t\tsize_t allocSize = sizeof(REGION16_DATA) + (finalNbRects * sizeof(RECTANGLE_16));\n\t\tdata = realloc(region->data, allocSize);\n\t\tif (!data)\n\t\t\tfree(region->data);\n\t\tregion->data = data;\n\n\t\tif (!region->data)\n\t\t{\n\t\t\tregion->data = &empty_region;\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tregion->data->nbRects = finalNbRects;\n\t\tregion->data->size = allocSize;\n\t}\n\n\treturn TRUE;\n}", "target": 2, "idx": 10239}
{"commit_id": "96ec957e281220f8e137a2d5eb23b83a6377d556", "project": "rpm-software-management/rpm", "func": "static int fsmMkdir(int dirfd, const char *path, mode_t mode)\n{\n    int rc = mkdirat(dirfd, path, (mode & 07777));\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%d %s, 0%04o) %s\\n\", __func__,\n\t       dirfd, path, (unsigned)(mode & 07777),\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\trc = RPMERR_MKDIR_FAILED;\n    return rc;\n}", "target": 1, "idx": 10240}
{"commit_id": "68ba2a19472da0a3de28c41b7a2e222438dca359", "project": "facebook/tac_plus", "func": "static char *\nlookup(char *sym, struct author_data *data)\n{\n    static char buf[5];\n\n    if (STREQ(sym, \"user\")) {\n       if (is_valid_name(data->id->username)) {\n          return(tac_strdup(data->id->username));\n       }\n    }\n    if (STREQ(sym, \"name\")) {\n       if (is_valid_name(data->id->NAS_name)) {\n          return(tac_strdup(data->id->username));\n       }\n    }\n    if (STREQ(sym, \"ip\")) {\n\treturn(tac_strdup(data->id->NAS_ip));\n    }\n    if (STREQ(sym, \"port\")) {\n\treturn(tac_strdup(data->id->NAS_port));\n    }\n    if (STREQ(sym, \"address\")) {\n       if (is_valid_name(data->id->NAC_address)) {\n          return(tac_strdup(data->id->NAC_address));\n       }\n    }\n    if (STREQ(sym, \"priv\")) {\n\tsnprintf(buf, sizeof(buf), \"%d\", data->id->priv_lvl);\n\treturn(tac_strdup(buf));\n    }\n    if (STREQ(sym, \"method\")) {\n\tsnprintf(buf, sizeof(buf), \"%d\", data->authen_method);\n\treturn(tac_strdup(buf));\n    }\n    if (STREQ(sym, \"type\")) {\n\tsnprintf(buf, sizeof(buf), \"%d\", data->authen_type);\n\treturn(tac_strdup(buf));\n    }\n    if (STREQ(sym, \"service\")) {\n\tsnprintf(buf, sizeof(buf), \"%d\", data->service);\n\treturn(tac_strdup(buf));\n    }\n    if (STREQ(sym, \"status\")) {\n\tswitch (data->status) {\n\tdefault:\n\t    return(tac_strdup(\"unknown\"));\n\tcase AUTHOR_STATUS_PASS_ADD:\n\tcase AUTHOR_STATUS_PASS_REPL:\n\t    return(tac_strdup(\"pass\"));\n\tcase AUTHOR_STATUS_FAIL:\n\t    return(tac_strdup(\"fail\"));\n\tcase AUTHOR_STATUS_ERROR:\n\t    return(tac_strdup(\"error\"));\n\t}\n    }\n\n    return(tac_strdup(\"unknown\"));\n}", "target": 3, "idx": 10241}
{"commit_id": "727ba748e110b4de50d142edca9d6a9b7e6111d8", "project": "torvalds/linux", "func": "static int handle_vmon(struct kvm_vcpu *vcpu)\n{\n\tint ret;\n\tgpa_t vmptr;\n\tstruct page *page;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tconst u64 VMXON_NEEDED_FEATURES = FEATURE_CONTROL_LOCKED\n\t\t| FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX;\n\n\t/*\n\t * The Intel VMX Instruction Reference lists a bunch of bits that are\n\t * prerequisite to running VMXON, most notably cr4.VMXE must be set to\n\t * 1 (see vmx_set_cr4() for when we allow the guest to set this).\n\t * Otherwise, we should fail with #UD.  But most faulting conditions\n\t * have already been checked by hardware, prior to the VM-exit for\n\t * VMXON.  We do test guest cr4.VMXE because processor CR4 always has\n\t * that bit set to 1 in non-root mode.\n\t */\n\tif (!kvm_read_cr4_bits(vcpu, X86_CR4_VMXE)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\t/* CPL=0 must be checked manually. */\n\tif (vmx_get_cpl(vcpu)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (vmx->nested.vmxon) {\n\t\tnested_vmx_failValid(vcpu, VMXERR_VMXON_IN_VMX_ROOT_OPERATION);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\n\tif ((vmx->msr_ia32_feature_control & VMXON_NEEDED_FEATURES)\n\t\t\t!= VMXON_NEEDED_FEATURES) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\n\tif (nested_vmx_get_vmptr(vcpu, &vmptr))\n\t\treturn 1;\n\n\t/*\n\t * SDM 3: 24.11.5\n\t * The first 4 bytes of VMXON region contain the supported\n\t * VMCS revision identifier\n\t *\n\t * Note - IA32_VMX_BASIC[48] will never be 1 for the nested case;\n\t * which replaces physical address width with 32\n\t */\n\tif (!PAGE_ALIGNED(vmptr) || (vmptr >> cpuid_maxphyaddr(vcpu))) {\n\t\tnested_vmx_failInvalid(vcpu);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\n\tpage = kvm_vcpu_gpa_to_page(vcpu, vmptr);\n\tif (is_error_page(page)) {\n\t\tnested_vmx_failInvalid(vcpu);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\tif (*(u32 *)kmap(page) != VMCS12_REVISION) {\n\t\tkunmap(page);\n\t\tkvm_release_page_clean(page);\n\t\tnested_vmx_failInvalid(vcpu);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\tkunmap(page);\n\tkvm_release_page_clean(page);\n\n\tvmx->nested.vmxon_ptr = vmptr;\n\tret = enter_vmx_operation(vcpu);\n\tif (ret)\n\t\treturn ret;\n\n\tnested_vmx_succeed(vcpu);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}", "target": 1, "idx": 10242}
{"commit_id": "995a4283d8ed2d0d2c1ceb1a577b993df2f0e014", "project": "strukturag/libheif", "func": "Error HeifContext::interpret_heif_file()\n{\n  m_all_images.clear();\n  m_top_level_images.clear();\n  m_primary_image.reset();\n\n\n  // --- reference all non-hidden images\n\n  std::vector<heif_item_id> image_IDs = m_heif_file->get_item_IDs();\n\n  bool primary_is_grid = false;\n  for (heif_item_id id : image_IDs) {\n    auto infe_box = m_heif_file->get_infe_box(id);\n    if (!infe_box) {\n      // TODO(farindk): Should we return an error instead of skipping the invalid id?\n      continue;\n    }\n\n    if (item_type_is_image(infe_box->get_item_type())) {\n      auto image = std::make_shared<Image>(this, id);\n      m_all_images.insert(std::make_pair(id, image));\n\n      if (!infe_box->is_hidden_item()) {\n        if (id==m_heif_file->get_primary_image_ID()) {\n          image->set_primary(true);\n          m_primary_image = image;\n          primary_is_grid = infe_box->get_item_type() == \"grid\";\n        }\n\n        m_top_level_images.push_back(image);\n      }\n    }\n  }\n\n\n  if (!m_primary_image) {\n    return Error(heif_error_Invalid_input,\n                 heif_suberror_Nonexisting_item_referenced,\n                 \"'pitm' box references a non-existing image\");\n  }\n\n\n  // --- remove thumbnails from top-level images and assign to their respective image\n\n  auto iref_box = m_heif_file->get_iref_box();\n  if (iref_box) {\n    // m_top_level_images.clear();\n\n    for (auto& pair : m_all_images) {\n      auto& image = pair.second;\n\n      std::vector<Box_iref::Reference> references = iref_box->get_references_from(image->get_id());\n\n      for (const Box_iref::Reference& ref : references) {\n        uint32_t type = ref.header.get_short_type();\n\n        if (type==fourcc(\"thmb\")) {\n          // --- this is a thumbnail image, attach to the main image\n\n          std::vector<heif_item_id> refs = ref.to_item_ID;\n          if (refs.size() != 1) {\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Unspecified,\n                         \"Too many thumbnail references\");\n          }\n\n          image->set_is_thumbnail_of(refs[0]);\n\n          auto master_iter = m_all_images.find(refs[0]);\n          if (master_iter == m_all_images.end()) {\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Nonexisting_item_referenced,\n                         \"Thumbnail references a non-existing image\");\n          }\n\n          if (master_iter->second->is_thumbnail()) {\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Nonexisting_item_referenced,\n                         \"Thumbnail references another thumbnail\");\n          }\n\n          if (image.get() == master_iter->second.get()) {\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Nonexisting_item_referenced,\n                         \"Recursive thumbnail image detected\");\n          }\n          master_iter->second->add_thumbnail(image);\n\n          remove_top_level_image(image);\n        }\n        else if (type==fourcc(\"auxl\")) {\n\n          // --- this is an auxiliary image\n          //     check whether it is an alpha channel and attach to the main image if yes\n\n          std::vector<Box_ipco::Property> properties;\n          Error err = m_heif_file->get_properties(image->get_id(), properties);\n          if (err) {\n            return err;\n          }\n\n          std::shared_ptr<Box_auxC> auxC_property;\n          for (const auto& property : properties) {\n            auto auxC = std::dynamic_pointer_cast<Box_auxC>(property.property);\n            if (auxC) {\n              auxC_property = auxC;\n            }\n          }\n\n          if (!auxC_property) {\n            std::stringstream sstr;\n            sstr << \"No auxC property for image \" << image->get_id();\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Auxiliary_image_type_unspecified,\n                         sstr.str());\n          }\n\n          std::vector<heif_item_id> refs = ref.to_item_ID;\n          if (refs.size() != 1) {\n            return Error(heif_error_Invalid_input,\n                         heif_suberror_Unspecified,\n                         \"Too many auxiliary image references\");\n          }\n\n\n          // alpha channel\n\n          if (auxC_property->get_aux_type() == \"urn:mpeg:avc:2015:auxid:1\" ||\n              auxC_property->get_aux_type() == \"urn:mpeg:hevc:2015:auxid:1\") {\n            image->set_is_alpha_channel_of(refs[0]);\n\n            auto master_iter = m_all_images.find(refs[0]);\n            if (master_iter == m_all_images.end()) {\n              return Error(heif_error_Invalid_input,\n                           heif_suberror_Nonexisting_item_referenced,\n                           \"Non-existing alpha image referenced\");\n            }\n            if (image.get() == master_iter->second.get()) {\n              return Error(heif_error_Invalid_input,\n                           heif_suberror_Nonexisting_item_referenced,\n                           \"Recursive alpha image detected\");\n            }\n            master_iter->second->set_alpha_channel(image);\n          }\n\n\n          // depth channel\n\n          if (auxC_property->get_aux_type() == \"urn:mpeg:hevc:2015:auxid:2\") {\n            image->set_is_depth_channel_of(refs[0]);\n\n            auto master_iter = m_all_images.find(refs[0]);\n            if (image.get() == master_iter->second.get()) {\n              return Error(heif_error_Invalid_input,\n                           heif_suberror_Nonexisting_item_referenced,\n                           \"Recursive depth image detected\");\n            }\n            master_iter->second->set_depth_channel(image);\n\n            auto subtypes = auxC_property->get_subtypes();\n\n            std::vector<std::shared_ptr<SEIMessage>> sei_messages;\n            Error err = decode_hevc_aux_sei_messages(subtypes, sei_messages);\n\n            for (auto& msg : sei_messages) {\n              auto depth_msg = std::dynamic_pointer_cast<SEIMessage_depth_representation_info>(msg);\n              if (depth_msg) {\n                image->set_depth_representation_info(*depth_msg);\n              }\n            }\n          }\n\n          remove_top_level_image(image);\n        }\n        else {\n          // 'image' is a normal image, keep it as a top-level image\n        }\n      }\n    }\n  }\n\n\n  // --- check that HEVC images have an hvcC property\n\n  for (auto& pair : m_all_images) {\n    auto& image = pair.second;\n\n    std::shared_ptr<Box_infe> infe = m_heif_file->get_infe_box(image->get_id());\n    if (infe->get_item_type() == \"hvc1\") {\n\n      auto ipma = m_heif_file->get_ipma_box();\n      auto ipco = m_heif_file->get_ipco_box();\n\n      if (!ipco->get_property_for_item_ID(image->get_id(), ipma, fourcc(\"hvcC\"))) {\n        return Error(heif_error_Invalid_input,\n                     heif_suberror_No_hvcC_box,\n                     \"No hvcC property in hvc1 type image\");\n      }\n    }\n  }\n\n\n  // --- read through properties for each image and extract image resolutions\n\n  for (auto& pair : m_all_images) {\n    auto& image = pair.second;\n\n    std::vector<Box_ipco::Property> properties;\n\n    Error err = m_heif_file->get_properties(pair.first, properties);\n    if (err) {\n      return err;\n    }\n\n    bool ispe_read = false;\n    bool primary_colr_set = false;\n    for (const auto& prop : properties) {\n      auto ispe = std::dynamic_pointer_cast<Box_ispe>(prop.property);\n      if (ispe) {\n        uint32_t width = ispe->get_width();\n        uint32_t height = ispe->get_height();\n\n\n        // --- check whether the image size is \"too large\"\n\n        if (width  >= static_cast<uint32_t>(MAX_IMAGE_WIDTH) ||\n            height >= static_cast<uint32_t>(MAX_IMAGE_HEIGHT)) {\n          std::stringstream sstr;\n          sstr << \"Image size \" << width << \"x\" << height << \" exceeds the maximum image size \"\n               << MAX_IMAGE_WIDTH << \"x\" << MAX_IMAGE_HEIGHT << \"\\n\";\n\n          return Error(heif_error_Memory_allocation_error,\n                       heif_suberror_Security_limit_exceeded,\n                       sstr.str());\n        }\n\n        image->set_resolution(width, height);\n        image->set_ispe_resolution(width, height);\n        ispe_read = true;\n      }\n\n      if (ispe_read) {\n        auto clap = std::dynamic_pointer_cast<Box_clap>(prop.property);\n        if (clap) {\n          image->set_resolution( clap->get_width_rounded(),\n                                 clap->get_height_rounded() );\n        }\n\n        auto irot = std::dynamic_pointer_cast<Box_irot>(prop.property);\n        if (irot) {\n          if (irot->get_rotation()==90 ||\n              irot->get_rotation()==270) {\n            // swap width and height\n            image->set_resolution( image->get_height(),\n                                   image->get_width() );\n          }\n        }\n      }\n\n      auto colr = std::dynamic_pointer_cast<Box_colr>(prop.property);\n      if (colr) {\n        auto profile = colr->get_color_profile();\n\n        image->set_color_profile(profile);\n\n        // if this is a grid item we assign the first one's color profile\n        // to the main image which is supposed to be a grid\n\n        // TODO: this condition is not correct. It would also classify a secondary image as a 'grid item'.\n        // We have to set the grid-image color profile in another way...\n        const bool is_grid_item = !image->is_primary() && !image->is_alpha_channel() && !image->is_depth_channel();\n\n        if (primary_is_grid &&\n            !primary_colr_set &&\n            is_grid_item) {\n          m_primary_image->set_color_profile(profile);\n          primary_colr_set = true;\n        }\n      }\n    }\n  }\n\n\n  // --- read metadata and assign to image\n\n  for (heif_item_id id : image_IDs) {\n    std::string item_type    = m_heif_file->get_item_type(id);\n    std::string content_type = m_heif_file->get_content_type(id);\n    if (item_type == \"Exif\" ||\n        (item_type==\"mime\" && content_type==\"application/rdf+xml\")) {\n      std::shared_ptr<ImageMetadata> metadata = std::make_shared<ImageMetadata>();\n      metadata->item_id = id;\n      metadata->item_type = item_type;\n      metadata->content_type = content_type;\n\n      Error err = m_heif_file->get_compressed_image_data(id, &(metadata->m_data));\n      if (err) {\n        return err;\n      }\n\n      //std::cerr.write((const char*)data.data(), data.size());\n\n\n      // --- assign metadata to the image\n\n      if (iref_box) {\n        std::vector<Box_iref::Reference> references = iref_box->get_references_from(id);\n        for (const auto& ref : references) {\n          if (ref.header.get_short_type() == fourcc(\"cdsc\")) {\n            std::vector<uint32_t> refs = ref.to_item_ID;\n            if (refs.size() != 1) {\n              return Error(heif_error_Invalid_input,\n                           heif_suberror_Unspecified,\n                           \"Exif data not correctly assigned to image\");\n            }\n\n            uint32_t exif_image_id = refs[0];\n            auto img_iter = m_all_images.find(exif_image_id);\n            if (img_iter == m_all_images.end()) {\n              return Error(heif_error_Invalid_input,\n                           heif_suberror_Nonexisting_item_referenced,\n                           \"Exif data assigned to non-existing image\");\n            }\n\n            img_iter->second->add_metadata(metadata);\n          }\n        }\n      }\n    }\n  }\n\n  return Error::Ok;\n}", "target": 2, "idx": 10243}
{"commit_id": "64d591a6c70737604ca3f5791736fc462cbe8a3c", "project": "strukturag/libde265", "func": "de265_error read_scaling_list(bitreader* br, const seq_parameter_set* sps,\n                              scaling_list_data* sclist, bool inPPS)\n{\n  int dc_coeff[4][6];\n\n  for (int sizeId=0;sizeId<4;sizeId++) {\n    //int n = ((sizeId==3) ? 2 : 6);\n    uint8_t scaling_list[6][32*32];\n\n    // Note: we use a different matrixId for the second matrix of size 3 (we use '3' instead of '1').\n    for (int matrixId=0 ; matrixId<6 ; matrixId += (sizeId==3 ? 3 : 1)) {\n      uint8_t* curr_scaling_list = scaling_list[matrixId];\n      int scaling_list_dc_coef;\n\n\n      //printf(\"----- matrix %d\\n\",matrixId);\n\n      char scaling_list_pred_mode_flag = get_bits(br,1);\n      if (!scaling_list_pred_mode_flag) {\n        int scaling_list_pred_matrix_id_delta = get_uvlc(br);\n\n\tif (sizeId==3) {\n\t  // adapt to our changed matrixId for size 3\n\t  scaling_list_pred_matrix_id_delta *= 3;\n\t}\n\t\n        if (scaling_list_pred_matrix_id_delta == UVLC_ERROR ||\n            scaling_list_pred_matrix_id_delta > matrixId) {\n          return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n        }\n\n        //printf(\"scaling_list_pred_matrix_id_delta=%d\\n\", scaling_list_pred_matrix_id_delta);\n\n        dc_coeff[sizeId][matrixId] = 16;\n        scaling_list_dc_coef       = 16;\n\n        if (scaling_list_pred_matrix_id_delta==0) {\n          if (sizeId==0) {\n            memcpy(curr_scaling_list, default_ScalingList_4x4, 16);\n          }\n          else {\n            if (matrixId<3)\n              { memcpy(curr_scaling_list, default_ScalingList_8x8_intra,64); }\n            else\n              { memcpy(curr_scaling_list, default_ScalingList_8x8_inter,64); }\n          }\n        }\n        else {\n          if (sizeId==3) { assert(scaling_list_pred_matrix_id_delta==3); }\n\n          int mID = matrixId - scaling_list_pred_matrix_id_delta;\n\n          int len = (sizeId == 0 ? 16 : 64);\n          memcpy(curr_scaling_list, scaling_list[mID], len);\n\n          scaling_list_dc_coef       = dc_coeff[sizeId][mID];\n          dc_coeff[sizeId][matrixId] = dc_coeff[sizeId][mID];\n        }\n      }\n      else {\n        int nextCoef=8;\n        int coefNum = (sizeId==0 ? 16 : 64);\n        if (sizeId>1) {\n          scaling_list_dc_coef = get_svlc(br);\n          if (scaling_list_dc_coef < -7 ||\n              scaling_list_dc_coef > 247) {\n            return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n          }\n\n          scaling_list_dc_coef += 8;\n          nextCoef=scaling_list_dc_coef;\n          dc_coeff[sizeId][matrixId] = scaling_list_dc_coef;\n        }\n        else {\n          scaling_list_dc_coef = 16;\n        }\n        //printf(\"DC = %d\\n\",scaling_list_dc_coef);\n\n        for (int i=0;i<coefNum;i++) {\n          int scaling_list_delta_coef = get_svlc(br);\n          if (scaling_list_delta_coef < -128 ||\n              scaling_list_delta_coef >  127) {\n            return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n          }\n\n          nextCoef = (nextCoef + scaling_list_delta_coef + 256) % 256;\n          curr_scaling_list[i] = nextCoef;\n          //printf(\"curr %d = %d\\n\",i,nextCoef);\n        }\n      }\n\n\n      // --- generate ScalingFactor arrays ---\n\n      switch (sizeId) {\n      case 0:\n        fill_scaling_factor(&sclist->ScalingFactor_Size0[matrixId][0][0], curr_scaling_list, 0);\n        break;\n\n      case 1:\n        fill_scaling_factor(&sclist->ScalingFactor_Size1[matrixId][0][0], curr_scaling_list, 1);\n        break;\n\n      case 2:\n        fill_scaling_factor(&sclist->ScalingFactor_Size2[matrixId][0][0], curr_scaling_list, 2);\n        sclist->ScalingFactor_Size2[matrixId][0][0] = scaling_list_dc_coef;\n        //printf(\"DC coeff: %d\\n\", scaling_list_dc_coef);\n        break;\n\n      case 3:\n        fill_scaling_factor(&sclist->ScalingFactor_Size3[matrixId][0][0], curr_scaling_list, 3);\n        sclist->ScalingFactor_Size3[matrixId][0][0] = scaling_list_dc_coef;\n        //printf(\"DC coeff: %d\\n\", scaling_list_dc_coef);\n        break;\n      }\n    }\n  }\n\n\n  // --- fill 32x32 matrices for chroma\n\n  const position* scan = get_scan_order(3, 0 /* diag */);\n\t\n  for (int matrixId=0;matrixId<6;matrixId++)\n    if (matrixId!=0 && matrixId!=3) {\n      for (int i=0;i<64;i++) {\n\tint x = scan[i].x;\n\tint y = scan[i].y;\n\tint v = sclist->ScalingFactor_Size1[matrixId][y][x];\n\n\tfor (int dy=0;dy<4;dy++)\n\t  for (int dx=0;dx<4;dx++) {\n\t    sclist->ScalingFactor_Size3[matrixId][4*y+dy][4*x+dx] = v;\n\t  }\n      }\n\n      sclist->ScalingFactor_Size3[matrixId][0][0] = sclist->ScalingFactor_Size1[matrixId][0][0];\n    }\n  \n  return DE265_OK;\n}", "target": 2, "idx": 10244}
{"commit_id": "da5c0f119203ad9728920456a0f52a6d850c01cd", "project": "torvalds/linux", "func": "int nfc_disable_se(struct nfc_dev *dev, u32 se_idx)\n{\n\tstruct nfc_se *se;\n\tint rc;\n\n\tpr_debug(\"%s se index %d\\n\", dev_name(&dev->dev), se_idx);\n\n\tdevice_lock(&dev->dev);\n\n\tif (dev->shutting_down) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (!dev->dev_up) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (!dev->ops->enable_se || !dev->ops->disable_se) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto error;\n\t}\n\n\tse = nfc_find_se(dev, se_idx);\n\tif (!se) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tif (se->state == NFC_SE_DISABLED) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\n\trc = dev->ops->disable_se(dev, se_idx);\n\tif (rc >= 0)\n\t\tse->state = NFC_SE_DISABLED;\n\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1, "idx": 10245}
{"commit_id": "7bc29a9d5cd697290aa056e94ecee6253d3425f8", "project": "openbsd/src", "func": "static void\nprocess_add_smartcard_key(SocketEntry *e)\n{\n\tchar *provider = NULL, *pin = NULL, canonical_provider[PATH_MAX];\n\tchar **comments = NULL;\n\tint r, i, count = 0, success = 0, confirm = 0;\n\tu_int seconds = 0;\n\ttime_t death = 0;\n\tstruct sshkey **keys = NULL, *k;\n\tIdentity *id;\n\tstruct dest_constraint *dest_constraints = NULL;\n\tsize_t ndest_constraints = 0;\n\n\tdebug2_f(\"entering\");\n\tif ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0) {\n\t\terror_fr(r, \"parse\");\n\t\tgoto send;\n\t}\n\tif (parse_key_constraints(e->request, NULL, &death, &seconds, &confirm,\n\t    NULL, &dest_constraints, &ndest_constraints) != 0) {\n\t\terror_f(\"failed to parse constraints\");\n\t\tgoto send;\n\t}\n\tif (e->nsession_ids != 0 && !remote_add_provider) {\n\t\tverbose(\"failed PKCS#11 add of \\\"%.100s\\\": remote addition of \"\n\t\t    \"providers is disabled\", provider);\n\t\tgoto send;\n\t}\n\tif (realpath(provider, canonical_provider) == NULL) {\n\t\tverbose(\"failed PKCS#11 add of \\\"%.100s\\\": realpath: %s\",\n\t\t    provider, strerror(errno));\n\t\tgoto send;\n\t}\n\tif (match_pattern_list(canonical_provider, allowed_providers, 0) != 1) {\n\t\tverbose(\"refusing PKCS#11 add of \\\"%.100s\\\": \"\n\t\t    \"provider not allowed\", canonical_provider);\n\t\tgoto send;\n\t}\n\tdebug_f(\"add %.100s\", canonical_provider);\n\tif (lifetime && !death)\n\t\tdeath = monotime() + lifetime;\n\n\tcount = pkcs11_add_provider(canonical_provider, pin, &keys, &comments);\n\tfor (i = 0; i < count; i++) {\n\t\tk = keys[i];\n\t\tif (lookup_identity(k) == NULL) {\n\t\t\tid = xcalloc(1, sizeof(Identity));\n\t\t\tid->key = k;\n\t\t\tkeys[i] = NULL; /* transferred */\n\t\t\tid->provider = xstrdup(canonical_provider);\n\t\t\tif (*comments[i] != '\\0') {\n\t\t\t\tid->comment = comments[i];\n\t\t\t\tcomments[i] = NULL; /* transferred */\n\t\t\t} else {\n\t\t\t\tid->comment = xstrdup(canonical_provider);\n\t\t\t}\n\t\t\tid->death = death;\n\t\t\tid->confirm = confirm;\n\t\t\tid->dest_constraints = dest_constraints;\n\t\t\tid->ndest_constraints = ndest_constraints;\n\t\t\tdest_constraints = NULL; /* transferred */\n\t\t\tndest_constraints = 0;\n\t\t\tTAILQ_INSERT_TAIL(&idtab->idlist, id, next);\n\t\t\tidtab->nentries++;\n\t\t\tsuccess = 1;\n\t\t}\n\t\t/* XXX update constraints for existing keys */\n\t\tsshkey_free(keys[i]);\n\t\tfree(comments[i]);\n\t}\nsend:\n\tfree(pin);\n\tfree(provider);\n\tfree(keys);\n\tfree(comments);\n\tfree_dest_constraints(dest_constraints, ndest_constraints);\n\tsend_status(e, success);\n}", "target": 3, "idx": 10246}
{"commit_id": "5d069dbe8aaf2a197142558b6fb2978189ba3454", "project": "torvalds/linux", "func": "static const char *fuse_get_link(struct dentry *dentry, struct inode *inode,\n\t\t\t\t struct delayed_call *callback)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct page *page;\n\tint err;\n\n\terr = -EIO;\n\tif (fuse_is_bad(inode))\n\t\tgoto out_err;\n\n\tif (fc->cache_symlinks)\n\t\treturn page_get_link(dentry, inode, callback);\n\n\terr = -ECHILD;\n\tif (!dentry)\n\t\tgoto out_err;\n\n\tpage = alloc_page(GFP_KERNEL);\n\terr = -ENOMEM;\n\tif (!page)\n\t\tgoto out_err;\n\n\terr = fuse_readlink_page(inode, page);\n\tif (err) {\n\t\t__free_page(page);\n\t\tgoto out_err;\n\t}\n\n\tset_delayed_call(callback, page_put_link, page);\n\n\treturn page_address(page);\n\nout_err:\n\treturn ERR_PTR(err);\n}", "target": 1, "idx": 10247}
{"commit_id": "3558afe9e9e904cabb8475392d859f2d2fc21041", "project": "vim", "func": "char_u *\ncompile_redir(char_u *line, exarg_T *eap, cctx_T *cctx)\n{\n    char_u  *arg = eap->arg;\n    lhs_T   *lhs = &cctx->ctx_redir_lhs;\n\n    if (lhs->lhs_name != NULL)\n    {\n\tif (STRNCMP(arg, \"END\", 3) == 0)\n\t{\n\t    if (cctx->ctx_skip != SKIP_YES)\n\t    {\n\t\tif (lhs->lhs_append)\n\t\t{\n\t\t    // First load the current variable value.\n\t\t    if (compile_load_lhs_with_index(lhs, lhs->lhs_whole,\n\t\t\t\t\t\t\t\t cctx) == FAIL)\n\t\t\treturn NULL;\n\t\t}\n\n\t\t// Gets the redirected text and put it on the stack, then store\n\t\t// it in the variable.\n\t\tgenerate_instr_type(cctx, ISN_REDIREND, &t_string);\n\n\t\tif (lhs->lhs_append)\n\t\t    generate_CONCAT(cctx, 2);\n\n\t\tif (lhs->lhs_has_index)\n\t\t{\n\t\t    // Use the info in \"lhs\" to store the value at the index in\n\t\t    // the list or dict.\n\t\t    if (compile_assign_unlet(lhs->lhs_whole, lhs, TRUE,\n\t\t\t\t\t\t      &t_string, cctx) == FAIL)\n\t\t\treturn NULL;\n\t\t}\n\t\telse if (generate_store_lhs(cctx, lhs, -1, FALSE) == FAIL)\n\t\t    return NULL;\n\n\t\tVIM_CLEAR(lhs->lhs_name);\n\t\tVIM_CLEAR(lhs->lhs_whole);\n\t    }\n\t    return arg + 3;\n\t}\n\temsg(_(e_cannot_nest_redir));\n\treturn NULL;\n    }\n\n    if (arg[0] == '=' && arg[1] == '>')\n    {\n\tint\t    append = FALSE;\n\n\t// redirect to a variable is compiled\n\targ += 2;\n\tif (*arg == '>')\n\t{\n\t    ++arg;\n\t    append = TRUE;\n\t}\n\targ = skipwhite(arg);\n\n\tif (compile_assign_lhs(arg, lhs, CMD_redir,\n\t\t\t\t\t FALSE, FALSE, FALSE, 1, cctx) == FAIL)\n\t    return NULL;\n\tif (need_type(&t_string, lhs->lhs_member_type,\n\t\t\t\t\t    -1, 0, cctx, FALSE, FALSE) == FAIL)\n\t    return NULL;\n\tif (cctx->ctx_skip == SKIP_YES)\n\t{\n\t    VIM_CLEAR(lhs->lhs_name);\n\t}\n\telse\n\t{\n\t    generate_instr(cctx, ISN_REDIRSTART);\n\t    lhs->lhs_append = append;\n\t    if (lhs->lhs_has_index)\n\t    {\n\t\tlhs->lhs_whole = vim_strnsave(arg, lhs->lhs_varlen_total);\n\t\tif (lhs->lhs_whole == NULL)\n\t\t    return NULL;\n\t    }\n\t}\n\n\treturn arg + lhs->lhs_varlen_total;\n    }\n\n    // other redirects are handled like at script level\n    return compile_exec(line, eap, cctx);\n}", "target": 2, "idx": 10248}
{"commit_id": "f4616202e5578e65746cf7e7ceeba63bee1b094b", "project": "gpac", "func": "static void mp4_report(GF_SceneLoader *load, GF_Err e, char *format, ...)\n{\n#ifndef GPAC_DISABLE_LOG\n\tif (gf_log_tool_level_on(GF_LOG_PARSER, e ? GF_LOG_ERROR : GF_LOG_WARNING)) {\n\t\tchar szMsg[1024];\n\t\tva_list args;\n\t\tva_start(args, format);\n\t\tvsnprintf(szMsg, 1024, format, args);\n\t\tva_end(args);\n\t\tGF_LOG((u32) (e ? GF_LOG_ERROR : GF_LOG_WARNING), GF_LOG_PARSER, (\"[MP4 Loading] %s\\n\", szMsg) );\n\t}\n#endif\n}", "target": 2, "idx": 10249}
{"commit_id": "8e05648d6b4459facbc783025c5c42d301fef5c3", "project": "gpac", "func": "GF_Err abst_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;\n\tint i;\n\tu32 tmp_strsize;\n\tchar *tmp_str;\n\tGF_Err e;\n\n\tISOM_DECREASE_SIZE(ptr, 25)\n\tptr->bootstrapinfo_version = gf_bs_read_u32(bs);\n\tptr->profile = gf_bs_read_int(bs, 2);\n\tptr->live = gf_bs_read_int(bs, 1);\n\tptr->update = gf_bs_read_int(bs, 1);\n\tptr->reserved = gf_bs_read_int(bs, 4);\n\tptr->time_scale = gf_bs_read_u32(bs);\n\tptr->current_media_time = gf_bs_read_u64(bs);\n\tptr->smpte_time_code_offset = gf_bs_read_u64(bs);\n\n\ti=0;\n\tif (ptr->size<8) return GF_ISOM_INVALID_FILE;\n\ttmp_strsize =(u32)ptr->size;\n\ttmp_str = gf_malloc(sizeof(char)*tmp_strsize);\n\tif (!tmp_str) return GF_OUT_OF_MEM;\n\tmemset(tmp_str, 0, sizeof(char)*tmp_strsize);\n\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i) {\n\t\tptr->movie_identifier = gf_strdup(tmp_str);\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->server_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->server_entry_count; i++) {\n\t\tint j=0;\n\t\ttmp_strsize=(u32)ptr->size;\n\t\twhile (tmp_strsize) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j])\n\t\t\t\tbreak;\n\t\t\tj++;\n\t\t}\n\t\tif (j) {\n\t\t\tgf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);\n\t\t}\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->quality_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tint j=0;\n\t\ttmp_strsize=(u32)ptr->size;\n\t\twhile (tmp_strsize) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j])\n\t\t\t\tbreak;\n\t\t\tj++;\n\t\t}\n\n\t\tif (j) {\n\t\t\tgf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);\n\t\t}\n\t}\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size;\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i) {\n\t\tptr->drm_data = gf_strdup(tmp_str);\n\t}\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size;\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i) {\n\t\tptr->meta_data = gf_strdup(tmp_str);\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->segment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->segment_run_table_count; i++) {\n\t\tGF_AdobeSegmentRunTableBox *asrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&asrt, bs);\n\t\tif (e) {\n\t\t\tif (asrt) gf_isom_box_del((GF_Box*)asrt);\n\t\t\tgf_free(tmp_str);\n\t\t\treturn e;\n\t\t}\n\t\tgf_list_add(ptr->segment_run_table_entries, asrt);\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->fragment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->fragment_run_table_count; i++) {\n\t\tGF_AdobeFragmentRunTableBox *afrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&afrt, bs);\n\t\tif (e) {\n\t\t\tif (afrt) gf_isom_box_del((GF_Box*)afrt);\n\t\t\tgf_free(tmp_str);\n\t\t\treturn e;\n\t\t}\n\t\tgf_list_add(ptr->fragment_run_table_entries, afrt);\n\t}\n\n\tgf_free(tmp_str);\n\n\treturn GF_OK;\n}", "target": 2, "idx": 10250}
{"commit_id": "9c87439d9afa14a365ff13e73adc809cb2c3d97b", "project": "sparklemotion/nokogiri", "func": "static VALUE read_memory(int argc, VALUE *argv, VALUE klass)\n{\n  VALUE content;\n  VALUE parse_options;\n  xmlRelaxNGParserCtxtPtr ctx;\n  xmlRelaxNGPtr schema;\n  VALUE errors;\n  VALUE rb_schema;\n  int scanned_args = 0;\n\n  scanned_args = rb_scan_args(argc, argv, \"11\", &content, &parse_options);\n  if (scanned_args == 1) {\n    parse_options = rb_const_get(rb_const_get(mNokogiriXml, rb_intern(\"ParseOptions\")), rb_intern(\"DEFAULT_SCHEMA\"));\n  }\n\n  ctx = xmlRelaxNGNewMemParserCtxt((const char *)StringValuePtr(content), (int)RSTRING_LEN(content));\n\n  errors = rb_ary_new();\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n\n#ifdef HAVE_XMLRELAXNGSETPARSERSTRUCTUREDERRORS\n  xmlRelaxNGSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n\n  schema = xmlRelaxNGParse(ctx);\n\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlRelaxNGFreeParserCtxt(ctx);\n\n  if(NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if(error)\n      Nokogiri_error_raise(NULL, error);\n    else\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n\n    return Qnil;\n  }\n\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n  rb_iv_set(rb_schema, \"@parse_options\", parse_options);\n\n  return rb_schema;\n}", "target": 0, "idx": 10251}
{"commit_id": "78911a01b67d", "project": "ArtifexSoftware/ghostpdl", "func": "static int\nz2restore(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    check_type(*op, t_save);\n\n    while (gs_gstate_saved(gs_gstate_saved(igs))) {\n        if (restore_page_device(igs, gs_gstate_saved(igs)))\n            return push_callout(i_ctx_p, \"%restore1pagedevice\");\n        gs_grestore(igs);\n    }\n    if (restore_page_device(igs, gs_gstate_saved(igs)))\n        return push_callout(i_ctx_p, \"%restorepagedevice\");\n    return zrestore(i_ctx_p);\n}", "target": 2, "idx": 10252}
{"commit_id": "a15378861368a4267c2c2c73b90db2849f943ebd", "project": "redis/hiredis", "func": "static int redisAeAttach(aeEventLoop *loop, redisAsyncContext *ac) {\n    redisContext *c = &(ac->c);\n    redisAeEvents *e;\n\n    /* Nothing should be attached when something is already attached */\n    if (ac->ev.data != NULL)\n        return REDIS_ERR;\n\n    /* Create container for context and r/w events */\n    e = (redisAeEvents*)hi_malloc(sizeof(*e));\n    e->context = ac;\n    e->loop = loop;\n    e->fd = c->fd;\n    e->reading = e->writing = 0;\n\n    /* Register functions to start/stop listening for events */\n    ac->ev.addRead = redisAeAddRead;\n    ac->ev.delRead = redisAeDelRead;\n    ac->ev.addWrite = redisAeAddWrite;\n    ac->ev.delWrite = redisAeDelWrite;\n    ac->ev.cleanup = redisAeCleanup;\n    ac->ev.data = e;\n\n    return REDIS_OK;\n}", "target": 2, "idx": 10253}
{"commit_id": "6709d4b7bc2e079241fdef15d1160581c5261c10", "project": "torvalds/linux", "func": "static int nfc_genl_llc_set_params(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tstruct nfc_llcp_local *local;\n\tu8 rw = 0;\n\tu16 miux = 0;\n\tu32 idx;\n\tint rc = 0;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    (!info->attrs[NFC_ATTR_LLC_PARAM_LTO] &&\n\t     !info->attrs[NFC_ATTR_LLC_PARAM_RW] &&\n\t     !info->attrs[NFC_ATTR_LLC_PARAM_MIUX]))\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_RW]) {\n\t\trw = nla_get_u8(info->attrs[NFC_ATTR_LLC_PARAM_RW]);\n\n\t\tif (rw > LLCP_MAX_RW)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_MIUX]) {\n\t\tmiux = nla_get_u16(info->attrs[NFC_ATTR_LLC_PARAM_MIUX]);\n\n\t\tif (miux > LLCP_MAX_MIUX)\n\t\t\treturn -EINVAL;\n\t}\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tdevice_lock(&dev->dev);\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (!local) {\n\t\trc = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_LTO]) {\n\t\tif (dev->dep_link_up) {\n\t\t\trc = -EINPROGRESS;\n\t\t\tgoto put_local;\n\t\t}\n\n\t\tlocal->lto = nla_get_u8(info->attrs[NFC_ATTR_LLC_PARAM_LTO]);\n\t}\n\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_RW])\n\t\tlocal->rw = rw;\n\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_MIUX])\n\t\tlocal->miux = cpu_to_be16(miux);\n\nput_local:\n\tnfc_llcp_local_put(local);\n\nexit:\n\tdevice_unlock(&dev->dev);\n\n\tnfc_put_device(dev);\n\n\treturn rc;\n}", "target": 1, "idx": 10254}
{"commit_id": "7d267278a9ece963d77eefec61630223fce08c6c", "project": "torvalds/linux", "func": "static struct sock *unix_create1(struct net *net, struct socket *sock, int kern)\n{\n\tstruct sock *sk = NULL;\n\tstruct unix_sock *u;\n\n\tatomic_long_inc(&unix_nr_socks);\n\tif (atomic_long_read(&unix_nr_socks) > 2 * get_max_files())\n\t\tgoto out;\n\n\tsk = sk_alloc(net, PF_UNIX, GFP_KERNEL, &unix_proto, kern);\n\tif (!sk)\n\t\tgoto out;\n\n\tsock_init_data(sock, sk);\n\tlockdep_set_class(&sk->sk_receive_queue.lock,\n\t\t\t\t&af_unix_sk_receive_queue_lock_key);\n\n\tsk->sk_write_space\t= unix_write_space;\n\tsk->sk_max_ack_backlog\t= net->unx.sysctl_max_dgram_qlen;\n\tsk->sk_destruct\t\t= unix_sock_destructor;\n\tu\t  = unix_sk(sk);\n\tu->path.dentry = NULL;\n\tu->path.mnt = NULL;\n\tspin_lock_init(&u->lock);\n\tatomic_long_set(&u->inflight, 0);\n\tINIT_LIST_HEAD(&u->link);\n\tmutex_init(&u->readlock); /* single task reading lock */\n\tinit_waitqueue_head(&u->peer_wait);\n\tinit_waitqueue_func_entry(&u->peer_wake, unix_dgram_peer_wake_relay);\n\tunix_insert_socket(unix_sockets_unbound(sk), sk);\nout:\n\tif (sk == NULL)\n\t\tatomic_long_dec(&unix_nr_socks);\n\telse {\n\t\tlocal_bh_disable();\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, 1);\n\t\tlocal_bh_enable();\n\t}\n\treturn sk;\n}", "target": 1, "idx": 10255}
{"commit_id": "bab0b99f376dac9170ac81382a5ed526938d595a", "project": "php/php-src", "func": "static inline char *parse_ip_address_ex(const char *str, size_t str_len, int *portno, int get_err, zend_string **err)\n{\n\tchar *colon;\n\tchar *host = NULL;\n\n#ifdef HAVE_IPV6\n\tif (*(str) == '[' && str_len > 1) {\n\t\t/* IPV6 notation to specify raw address with port (i.e. [fe80::1]:80) */\n\t\tchar *p = memchr(str + 1, ']', str_len - 2), *e = NULL;\n\t\tif (!p || *(p + 1) != ':') {\n\t\t\tif (get_err) {\n\t\t\t\t*err = strpprintf(0, \"Failed to parse IPv6 address \\\"%s\\\"\", str);\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t\t*portno = strtol(p + 2, &e, 10);\n\t\tif (e && *e) {\n\t\t\tif (get_err) {\n\t\t\t\t*err = strpprintf(0, \"Failed to parse address \\\"%s\\\"\", str);\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t\treturn estrndup(str + 1, p - str - 1);\n\t}\n#endif\n\n\tif (str_len) {\n\t\tcolon = memchr(str, ':', str_len - 1);\n\t} else {\n\t\tcolon = NULL;\n\t}\n\n\tif (colon) {\n\t\tchar *e = NULL;\n\t\t*portno = strtol(colon + 1, &e, 10);\n\t\tif (!e || !*e) {\n\t\t\treturn estrndup(str, colon - str);\n\t\t}\n\t}\n\n\tif (get_err) {\n\t\t*err = strpprintf(0, \"Failed to parse address \\\"%s\\\"\", str);\n\t}\n\treturn NULL;\n}", "target": 2, "idx": 10256}
{"commit_id": "c84b7232626badd075caf3ae29661b609164bac6", "project": "radareorg/radare2", "func": "static cache_accel_t *read_cache_accel(RBuffer *cache_buf, cache_hdr_t *hdr, cache_map_t *maps, int n_maps) {\n\tif (!cache_buf || !hdr || !hdr->accelerateInfoSize || !hdr->accelerateInfoAddr) {\n\t\treturn NULL;\n\t}\n\tsize_t mc = R_MIN (hdr->mappingCount, n_maps);\n\tut64 offset = va2pa (hdr->accelerateInfoAddr, mc, maps, cache_buf, 0, NULL, NULL);\n\tif (!offset) {\n\t\treturn NULL;\n\t}\n\n\tut64 size = sizeof (cache_accel_t);\n\tcache_accel_t *accel = R_NEW0 (cache_accel_t);\n\tif (!accel) {\n\t\treturn NULL;\n\t}\n\n\tif (r_buf_fread_at (cache_buf, offset, (ut8*) accel, \"16il\", 1) != size) {\n\t\tR_FREE (accel);\n\t\treturn NULL;\n\t}\n\n\taccel->imagesExtrasOffset += offset;\n\taccel->bottomUpListOffset += offset;\n\taccel->dylibTrieOffset += offset;\n\taccel->initializersOffset += offset;\n\taccel->dofSectionsOffset += offset;\n\taccel->reExportListOffset += offset;\n\taccel->depListOffset += offset;\n\taccel->rangeTableOffset += offset;\n\n\treturn accel;\n}", "target": 2, "idx": 10257}
{"commit_id": "135aa9a4a6a9b49b60aa730ebc3bcc6247d75c45", "project": "Moddable-OpenSource/moddable", "func": "void fx_TypedArray(txMachine* the)\n{\n\ttxSlot* instance = fxConstructTypedArray(the);\n\ttxSlot* dispatch = instance->next;\n\ttxSlot* view = dispatch->next;\n\ttxSlot* buffer = view->next;\n\ttxSlot* data = C_NULL;\n\ttxU2 shift = dispatch->value.typedArray.dispatch->shift;\n\ttxSlot* slot;\n\tif ((mxArgc > 0) && (mxArgv(0)->kind == XS_REFERENCE_KIND)) {\n\t\tslot = mxArgv(0)->value.reference->next;\n\t\tif (slot && ((slot->kind == XS_ARRAY_BUFFER_KIND) || (slot->kind == XS_HOST_KIND))) {\n\t\t\ttxInteger offset = fxArgToByteLength(the, 1, 0);\n\t\t\ttxInteger size;\n\t\t\ttxSlot* info;\n\t\t\tif (offset & ((1 << shift) - 1))\n\t\t\t\tmxRangeError(\"invalid byteOffset %ld\", offset);\n\t\t\tsize = fxArgToByteLength(the, 2, -1);\n\t\t\tinfo = fxGetBufferInfo(the, mxArgv(0));\n\t\t\tif (size >= 0) {\n\t\t\t\ttxInteger delta = size << shift;\n\t\t\t\ttxInteger end = offset + delta;\n\t\t\t\tif ((info->value.bufferInfo.length < end) || (end < offset))\n\t\t\t\t\tmxRangeError(\"out of range length %ld\", size);\n\t\t\t\tsize = delta;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (info->value.bufferInfo.length & ((1 << shift) - 1))\n\t\t\t\t\tmxRangeError(\"invalid byteLength %ld\", info->value.bufferInfo.length);\n\t\t\t\tsize = info->value.bufferInfo.length - offset;\n\t\t\t\tif (size < 0)\n\t\t\t\t\tmxRangeError(\"out of range byteLength %ld\", size);\n\t\t\t\tif (info->value.bufferInfo.maxLength >= 0)\n\t\t\t\t\tsize = -1;\n\t\t\t}\n\t\t\tview->value.dataView.offset = offset;\n\t\t\tview->value.dataView.size = size;\n\t\t\tbuffer->kind = XS_REFERENCE_KIND;\n\t\t\tbuffer->value.reference = mxArgv(0)->value.reference;\n\t\t}\n\t\telse if (slot && (slot->kind == XS_TYPED_ARRAY_KIND)) {\n\t\t\ttxSlot* sourceDispatch = slot;\n\t\t\ttxSlot* sourceView = sourceDispatch->next;\n\t\t\ttxSlot* sourceBuffer = sourceView->next;\n\t\t\ttxU2 sourceShift = sourceDispatch->value.typedArray.dispatch->shift;\n\t\t\ttxInteger sourceLength = fxCheckDataViewSize(the, sourceView, sourceBuffer, XS_IMMUTABLE) >> sourceShift;\n\t\t\ttxSlot* sourceData = sourceBuffer->value.reference->next;\n\t\t\ttxInteger sourceDelta = sourceDispatch->value.typedArray.dispatch->size;\n\t\t\ttxInteger sourceOffset = sourceView->value.dataView.offset;\n\t\t\ttxInteger offset = 0;\n\t\t\ttxInteger size = sourceLength << shift;\n\t\t\t/* THIS */\n\t\t\tmxPushUninitialized();\t\n\t\t\t/* FUNCTION */\n\t\t\tmxPush(mxArrayBufferConstructor);\n\t\t\t/* TARGET */\n\t\t\tif (sourceData->kind == XS_ARRAY_BUFFER_KIND) {\n\t\t\t\tmxPushSlot(sourceBuffer);\n\t\t\t\tmxGetID(mxID(_constructor));\n\t\t\t\tfxToSpeciesConstructor(the, &mxArrayBufferConstructor);\n\t\t\t}\n\t\t\telse\n\t\t\t\tmxPush(mxArrayBufferConstructor);\n\t\t\t/* RESULT */\n\t\t\tmxPushUndefined();\t\n\t\t\tmxPushUninitialized();\t\n\t\t\tmxPushUninitialized();\t\n\t\t\t/* ARGUMENTS */\n\t\t\tsourceLength = fxGetDataViewSize(the, sourceView, sourceBuffer) >> sourceShift;\n\t\t\tsize = sourceLength << shift;\n\t\t\tmxPushInteger(size);\n\t\t\tmxRunCount(1);\n\t\t\tmxPullSlot(buffer);\n\t\t\tsourceLength = fxCheckDataViewSize(the, sourceView, sourceBuffer, XS_IMMUTABLE) >> sourceShift;\n\t\t\tsize = sourceLength << shift;\n\t\t\t\n\t\t\tdata = fxCheckArrayBufferDetached(the, buffer, XS_MUTABLE);\n\t\t\tview->value.dataView.offset = offset;\n\t\t\tview->value.dataView.size = size;\n\t\t\tif (dispatch == sourceDispatch)\n\t\t\t\tc_memcpy(data->value.arrayBuffer.address + offset, sourceData->value.arrayBuffer.address + sourceOffset, size);\n\t\t\telse {\n\t\t\t\ttxBoolean contentType = (dispatch->value.typedArray.dispatch->constructorID == _BigInt64Array)\n\t\t\t\t\t\t|| (dispatch->value.typedArray.dispatch->constructorID == _BigUint64Array);\n\t\t\t\ttxBoolean sourceContentType = (sourceDispatch->value.typedArray.dispatch->constructorID == _BigInt64Array)\n\t\t\t\t\t\t|| (sourceDispatch->value.typedArray.dispatch->constructorID == _BigUint64Array);\n\t\t\t\tif (contentType != sourceContentType)\n\t\t\t\t\tmxTypeError(\"incompatible content type\");\n\t\t\t\tmxPushUndefined();\n\t\t\t\twhile (offset < size) {\n\t\t\t\t\t(*sourceDispatch->value.typedArray.dispatch->getter)(the, sourceData, sourceOffset, the->stack, EndianNative);\n\t\t\t\t\t(*dispatch->value.typedArray.dispatch->coerce)(the, the->stack);\n\t\t\t\t\t(*dispatch->value.typedArray.dispatch->setter)(the, data, offset, the->stack, EndianNative);\n\t\t\t\t\tsourceOffset += sourceDelta;\n\t\t\t\t\toffset += 1 << shift;\n\t\t\t\t}\n\t\t\t\tmxPop();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfx_TypedArray_from_object(the, instance, C_NULL, C_NULL);\n\t\t}\n\t}\n\telse {\n        txInteger length = fxArgToByteLength(the, 0, 0);\n        if (length & (((1 << shift) - 1) << (32 - shift)))\n\t\t\tmxRangeError(\"out of range byteLength\");\n        length <<= shift;\n\t\tmxPush(mxArrayBufferConstructor);\n\t\tmxNew();\n\t\tmxPushInteger(length);\n\t\tmxRunCount(1);\n\t\tmxPullSlot(buffer);\n        view->value.dataView.offset = 0;\n        view->value.dataView.size = length;\n\t}\n}", "target": 2, "idx": 10258}
{"commit_id": "8d55d10ac0d112c586eaceb92e75bd9b80aadcc4", "project": "binutils-gdb", "func": "const char *\n_bfd_elf_get_symbol_version_string (bfd *abfd, asymbol *symbol,\n\t\t\t\t    bfd_boolean base_p,\n\t\t\t\t    bfd_boolean *hidden)\n{\n  const char *version_string = NULL;\n  if (elf_dynversym (abfd) != 0\n      && (elf_dynverdef (abfd) != 0 || elf_dynverref (abfd) != 0))\n    {\n      unsigned int vernum = ((elf_symbol_type *) symbol)->version;\n\n      *hidden = (vernum & VERSYM_HIDDEN) != 0;\n      vernum &= VERSYM_VERSION;\n\n      if (vernum == 0)\n\tversion_string = \"\";\n      else if (vernum == 1\n\t       && (vernum > elf_tdata (abfd)->cverdefs\n\t\t   || (elf_tdata (abfd)->verdef[0].vd_flags\n\t\t       == VER_FLG_BASE)))\n\tversion_string = base_p ? \"Base\" : \"\";\n      else if (vernum <= elf_tdata (abfd)->cverdefs)\n\t{\n\t  const char *nodename\n\t    = elf_tdata (abfd)->verdef[vernum - 1].vd_nodename;\n\t  version_string = \"\";\n\t  if (base_p\n\t      || nodename == NULL\n\t      || symbol->name == NULL\n\t      || strcmp (symbol->name, nodename) != 0)\n\t    version_string = nodename;\n\t}\n      else\n\t{\n\t  Elf_Internal_Verneed *t;\n\n\t  version_string = _(\"<corrupt>\");\n\t  for (t = elf_tdata (abfd)->verref;\n\t       t != NULL;\n\t       t = t->vn_nextref)\n\t    {\n\t      Elf_Internal_Vernaux *a;\n\n\t      for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)\n\t\t{\n\t\t  if (a->vna_other == vernum)\n\t\t    {\n\t\t      version_string = a->vna_nodename;\n\t\t      break;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n  return version_string;\n}", "target": 1, "idx": 10259}
{"commit_id": "b418f351f348d8273282f3fec6425b6b4e1d91da", "project": "saitoha/libsixel", "func": "static unsigned char *\npnm_get_line(unsigned char *p, unsigned char *end, unsigned char *line)\n{\n    int n;\n\n    do {\n        /* read the line */\n        for (n = 0 ; p < end && *p >= ' '; p++) {\n            if (n < 255) {\n                line[n++] = *p;\n            }\n        }\n\n        /* skip invald characters */\n        if (p < end && *p < ' ') {\n            p++;\n        }\n\n        line[n] = '\\0';\n\n    } while (line[0] == '#');\n\n    return p;\n}", "target": 1, "idx": 10260}
{"commit_id": "f843ee6dd019bcece3e74e76ad9df0155655d0df", "project": "torvalds/linux", "func": "static inline int xfrm_replay_verify_len(struct xfrm_replay_state_esn *replay_esn,\n\t\t\t\t\t struct nlattr *rp)\n{\n\tstruct xfrm_replay_state_esn *up;\n\tint ulen;\n\n\tif (!replay_esn || !rp)\n\t\treturn 0;\n\n\tup = nla_data(rp);\n\tulen = xfrm_replay_state_esn_len(up);\n\n\t/* Check the overall length and the internal bitmap length to avoid\n\t * potential overflow. */\n\tif (nla_len(rp) < ulen ||\n\t    xfrm_replay_state_esn_len(replay_esn) != ulen ||\n\t    replay_esn->bmp_len != up->bmp_len)\n\t\treturn -EINVAL;\n\n\tif (up->replay_window > up->bmp_len * sizeof(__u32) * 8)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}", "target": 2, "idx": 10261}
{"commit_id": "5b7cc2500d514717a64675fcf631939494c074ce", "project": "axiomatic-systems/Bento4", "func": "AP4_UnknownUuidAtom::AP4_UnknownUuidAtom(AP4_UI64 size, AP4_ByteStream& stream) : \n    AP4_UuidAtom(size, false, stream)\n{\n    // store the data\n    AP4_Size header_size = GetHeaderSize();\n    if (size > header_size) {\n        m_Data.SetDataSize((AP4_Size)size-GetHeaderSize());\n        stream.Read(m_Data.UseData(), m_Data.GetDataSize());\n    }\n}", "target": 1, "idx": 10262}
{"commit_id": "3984ef0b72831da8b3ece4745cac4f8575b19098", "project": "openssl", "func": "static int generate_key(DH *dh)\n{\n    int ok = 0;\n    int generate_new_key = 0;\n    unsigned l;\n    BN_CTX *ctx = NULL;\n    BN_MONT_CTX *mont = NULL;\n    BIGNUM *pub_key = NULL, *priv_key = NULL;\n\n    if (BN_num_bits(dh->p) > OPENSSL_DH_MAX_MODULUS_BITS) {\n        DHerr(DH_F_GENERATE_KEY, DH_R_MODULUS_TOO_LARGE);\n        return 0;\n    }\n\n    ctx = BN_CTX_new();\n    if (ctx == NULL)\n        goto err;\n\n    if (dh->priv_key == NULL) {\n        priv_key = BN_new();\n        if (priv_key == NULL)\n            goto err;\n        generate_new_key = 1;\n    } else\n        priv_key = dh->priv_key;\n\n    if (dh->pub_key == NULL) {\n        pub_key = BN_new();\n        if (pub_key == NULL)\n            goto err;\n    } else\n        pub_key = dh->pub_key;\n\n    if (dh->flags & DH_FLAG_CACHE_MONT_P) {\n        mont = BN_MONT_CTX_set_locked(&dh->method_mont_p,\n                                      CRYPTO_LOCK_DH, dh->p, ctx);\n        if (!mont)\n            goto err;\n    }\n\n    if (generate_new_key) {\n        if (dh->q) {\n            do {\n                if (!BN_rand_range(priv_key, dh->q))\n                    goto err;\n            }\n            while (BN_is_zero(priv_key) || BN_is_one(priv_key));\n        } else {\n            /* secret exponent length */\n            l = dh->length ? dh->length : BN_num_bits(dh->p) - 1;\n            if (!BN_rand(priv_key, l, 0, 0))\n                goto err;\n        }\n    }\n\n    {\n        BIGNUM local_prk;\n        BIGNUM *prk;\n\n        if ((dh->flags & DH_FLAG_NO_EXP_CONSTTIME) == 0) {\n            BN_init(&local_prk);\n            prk = &local_prk;\n            BN_with_flags(prk, priv_key, BN_FLG_CONSTTIME);\n        } else\n            prk = priv_key;\n\n        if (!dh->meth->bn_mod_exp(dh, pub_key, dh->g, prk, dh->p, ctx, mont))\n            goto err;\n    }\n\n    dh->pub_key = pub_key;\n    dh->priv_key = priv_key;\n    ok = 1;\n err:\n    if (ok != 1)\n        DHerr(DH_F_GENERATE_KEY, ERR_R_BN_LIB);\n\n    if ((pub_key != NULL) && (dh->pub_key == NULL))\n        BN_free(pub_key);\n    if ((priv_key != NULL) && (dh->priv_key == NULL))\n        BN_free(priv_key);\n    BN_CTX_free(ctx);\n    return (ok);\n}", "target": 2, "idx": 10263}
{"commit_id": "e6db8a95174d0a63ba95504fbb1804b9a551bafd", "project": "vim", "func": "void\nscroll_cursor_bot(int min_scroll, int set_topbot)\n{\n    int\t\tused;\n    int\t\tscrolled = 0;\n    int\t\textra = 0;\n    int\t\ti;\n    linenr_T\tline_count;\n    linenr_T\told_topline = curwin->w_topline;\n    int\t\told_skipcol = curwin->w_skipcol;\n    lineoff_T\tloff;\n    lineoff_T\tboff;\n#ifdef FEAT_DIFF\n    int\t\told_topfill = curwin->w_topfill;\n    int\t\tfill_below_window;\n#endif\n    linenr_T\told_botline = curwin->w_botline;\n    linenr_T\told_valid = curwin->w_valid;\n    int\t\told_empty_rows = curwin->w_empty_rows;\n    linenr_T\tcln;\t\t    // Cursor Line Number\n    long\tso = get_scrolloff_value();\n    int\t\tdo_sms = curwin->w_p_wrap && curwin->w_p_sms;\n\n    cln = curwin->w_cursor.lnum;\n    if (set_topbot)\n    {\n\tint set_skipcol = FALSE;\n\n\tused = 0;\n\tcurwin->w_botline = cln + 1;\n#ifdef FEAT_DIFF\n\tloff.fill = 0;\n#endif\n\tfor (curwin->w_topline = curwin->w_botline;\n\t\tcurwin->w_topline > 1;\n\t\tcurwin->w_topline = loff.lnum)\n\t{\n\t    loff.lnum = curwin->w_topline;\n\t    topline_back_winheight(&loff, FALSE);\n\t    if (loff.height == MAXCOL)\n\t\tbreak;\n\t    if (used + loff.height > curwin->w_height)\n\t    {\n\t\tif (do_sms)\n\t\t{\n\t\t    // 'smoothscroll' and 'wrap' are set.  The above line is\n\t\t    // too long to show in its entirety, so we show just a part\n\t\t    // of it.\n\t\t    if (used < curwin->w_height)\n\t\t    {\n\t\t\tint plines_offset = used + loff.height\n\t\t\t\t\t\t\t    - curwin->w_height;\n\t\t\tused = curwin->w_height;\n#ifdef FEAT_DIFF\n\t\t\tcurwin->w_topfill = loff.fill;\n#endif\n\t\t\tcurwin->w_topline = loff.lnum;\n\t\t\tcurwin->w_skipcol = skipcol_from_plines(\n\t\t\t\t\t\t\tcurwin, plines_offset);\n\t\t\tset_skipcol = TRUE;\n\t\t    }\n\t\t}\n\t\tbreak;\n\t    }\n\t    used += loff.height;\n#ifdef FEAT_DIFF\n\t    curwin->w_topfill = loff.fill;\n#endif\n\t}\n\tset_empty_rows(curwin, used);\n\tcurwin->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;\n\tif (curwin->w_topline != old_topline\n#ifdef FEAT_DIFF\n\t\t|| curwin->w_topfill != old_topfill\n#endif\n\t\t|| set_skipcol\n\t\t|| curwin->w_skipcol != 0)\n\t{\n\t    curwin->w_valid &= ~(VALID_WROW|VALID_CROW);\n\t    if (set_skipcol)\n\t\tredraw_later(UPD_NOT_VALID);\n\t    else\n\t\treset_skipcol();\n\t}\n    }\n    else\n\tvalidate_botline();\n\n    // The lines of the cursor line itself are always used.\n#ifdef FEAT_DIFF\n    used = plines_nofill(cln);\n#else\n    validate_cheight();\n    used = curwin->w_cline_height;\n#endif\n\n    // If the cursor is on or below botline, we will at least scroll by the\n    // height of the cursor line, which is \"used\".  Correct for empty lines,\n    // which are really part of botline.\n    if (cln >= curwin->w_botline)\n    {\n\tscrolled = used;\n\tif (cln == curwin->w_botline)\n\t    scrolled -= curwin->w_empty_rows;\n\tif (do_sms)\n\t{\n\t    // 'smoothscroll' and 'wrap' are set.\n\t    // Calculate how many screen lines the current top line of window\n\t    // occupies. If it is occupying more than the entire window, we\n\t    // need to scroll the additional clipped lines to scroll past the\n\t    // top line before we can move on to the other lines.\n\t    int top_plines =\n#ifdef FEAT_DIFF\n\t\t\t    plines_win_nofill\n#else\n\t\t\t    plines_win\n#endif\n\t\t\t\t\t(curwin, curwin->w_topline, FALSE);\n\t    int skip_lines = 0;\n\t    int width1 = curwin->w_width - curwin_col_off();\n\t    if (width1 > 0)\n\t    {\n\t\tint width2 = width1 + curwin_col_off2();\n\t\t// similar formula is used in curs_columns()\n\t\tif (curwin->w_skipcol > width1)\n\t\t    skip_lines += (curwin->w_skipcol - width1) / width2 + 1;\n\t\telse if (curwin->w_skipcol > 0)\n\t\t    skip_lines = 1;\n\n\t\ttop_plines -= skip_lines;\n\t\tif (top_plines > curwin->w_height)\n\t\t{\n\t\t    scrolled += (top_plines - curwin->w_height);\n\t\t}\n\t    }\n\t}\n    }\n\n    /*\n     * Stop counting lines to scroll when\n     * - hitting start of the file\n     * - scrolled nothing or at least 'sj' lines\n     * - at least 'scrolloff' lines below the cursor\n     * - lines between botline and cursor have been counted\n     */\n#ifdef FEAT_FOLDING\n    if (!hasFolding(curwin->w_cursor.lnum, &loff.lnum, &boff.lnum))\n#endif\n    {\n\tloff.lnum = cln;\n\tboff.lnum = cln;\n    }\n#ifdef FEAT_DIFF\n    loff.fill = 0;\n    boff.fill = 0;\n    fill_below_window = diff_check_fill(curwin, curwin->w_botline)\n\t\t\t\t\t\t      - curwin->w_filler_rows;\n#endif\n\n    while (loff.lnum > 1)\n    {\n\t// Stop when scrolled nothing or at least \"min_scroll\", found \"extra\"\n\t// context for 'scrolloff' and counted all lines below the window.\n\tif ((((scrolled <= 0 || scrolled >= min_scroll)\n\t\t    && extra >= (mouse_dragging > 0 ? mouse_dragging - 1 : so))\n\t\t    || boff.lnum + 1 > curbuf->b_ml.ml_line_count)\n\t\t&& loff.lnum <= curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t&& (loff.lnum < curwin->w_botline\n\t\t    || loff.fill >= fill_below_window)\n#endif\n\t\t)\n\t    break;\n\n\t// Add one line above\n\ttopline_back(&loff);\n\tif (loff.height == MAXCOL)\n\t    used = MAXCOL;\n\telse\n\t    used += loff.height;\n\tif (used > curwin->w_height)\n\t    break;\n\tif (loff.lnum >= curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t&& (loff.lnum > curwin->w_botline\n\t\t    || loff.fill <= fill_below_window)\n#endif\n\t\t)\n\t{\n\t    // Count screen lines that are below the window.\n\t    scrolled += loff.height;\n\t    if (loff.lnum == curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t\t    && loff.fill == 0\n#endif\n\t\t    )\n\t\tscrolled -= curwin->w_empty_rows;\n\t}\n\n\tif (boff.lnum < curbuf->b_ml.ml_line_count)\n\t{\n\t    // Add one line below\n\t    botline_forw(&boff);\n\t    used += boff.height;\n\t    if (used > curwin->w_height)\n\t\tbreak;\n\t    if (extra < ( mouse_dragging > 0 ? mouse_dragging - 1 : so)\n\t\t    || scrolled < min_scroll)\n\t    {\n\t\textra += boff.height;\n\t\tif (boff.lnum >= curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t\t|| (boff.lnum + 1 == curwin->w_botline\n\t\t\t    && boff.fill > curwin->w_filler_rows)\n#endif\n\t\t   )\n\t\t{\n\t\t    // Count screen lines that are below the window.\n\t\t    scrolled += boff.height;\n\t\t    if (boff.lnum == curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t\t    && boff.fill == 0\n#endif\n\t\t\t    )\n\t\t\tscrolled -= curwin->w_empty_rows;\n\t\t}\n\t    }\n\t}\n    }\n\n    // curwin->w_empty_rows is larger, no need to scroll\n    if (scrolled <= 0)\n\tline_count = 0;\n    // more than a screenfull, don't scroll but redraw\n    else if (used > curwin->w_height)\n\tline_count = used;\n    // scroll minimal number of lines\n    else\n    {\n\tline_count = 0;\n#ifdef FEAT_DIFF\n\tboff.fill = curwin->w_topfill;\n#endif\n\tboff.lnum = curwin->w_topline - 1;\n\tfor (i = 0; i < scrolled && boff.lnum < curwin->w_botline; )\n\t{\n\t    botline_forw(&boff);\n\t    i += boff.height;\n\t    ++line_count;\n\t}\n\tif (i < scrolled)\t// below curwin->w_botline, don't scroll\n\t    line_count = 9999;\n    }\n\n    /*\n     * Scroll up if the cursor is off the bottom of the screen a bit.\n     * Otherwise put it at 1/2 of the screen.\n     */\n    if (line_count >= curwin->w_height && line_count > min_scroll)\n\tscroll_cursor_halfway(FALSE, TRUE);\n    else if (line_count > 0)\n    {\n\tif (do_sms)\n\t    scrollup(scrolled, TRUE);  // TODO\n\telse\n\t    scrollup(line_count, TRUE);\n    }\n\n    /*\n     * If topline didn't change we need to restore w_botline and w_empty_rows\n     * (we changed them).\n     * If topline did change, update_screen() will set botline.\n     */\n    if (curwin->w_topline == old_topline\n\t    && curwin->w_skipcol == old_skipcol\n\t    && set_topbot)\n    {\n\tcurwin->w_botline = old_botline;\n\tcurwin->w_empty_rows = old_empty_rows;\n\tcurwin->w_valid = old_valid;\n    }\n    curwin->w_valid |= VALID_TOPLINE;\n}", "target": 2, "idx": 10264}
{"commit_id": "07b5e062f2d4a00403ff031302cb18dfa58e3805", "project": "radareorg/radare2", "func": "static bool r_egg_Cfile_parseCompiled(const char *file) {\n\tchar *fileExt = r_str_newf (\"%s.tmp\", file);\n\tchar *buffer = r_file_slurp (fileExt, NULL);\n\tif (!buffer) {\n\t\teprintf (\"Could not open '%s'.\\n\", fileExt);\n\t\tgoto fail;\n\t}\n\n\tbuffer = r_str_replace (buffer, \"rdata\", \"text\", false);\n\tbuffer = r_str_replace (buffer, \"rodata\", \"text\", false);\n\tbuffer = r_str_replace (buffer, \"get_pc_thunk.bx\", \"__getesp__\", true);\n\n\tconst char *words[] = {\".cstring\", \"size\", \"___main\", \"section\", \"__alloca\", \"zero\", \"cfi\"};\n\tsize_t i;\n\tfor (i = 0; i < 7; i++) {\n\t\tr_str_stripLine (buffer, words[i]);\n\t}\n\n\tfree (fileExt);\n\tfileExt = r_str_newf (\"%s.s\", file);\n\tif (!r_file_dump (fileExt, (const ut8*) buffer, strlen (buffer), true)) {\n\t\teprintf (\"Error while opening %s.s\\n\", file);\n\t\tgoto fail;\n\t}\n\n\tfree (buffer);\n\tfree (fileExt);\n\treturn true;\n\nfail:\n\tfree (buffer);\n\tfree (fileExt);\n\treturn false;\n}", "target": 2, "idx": 10265}
{"commit_id": "d8f8f4d637ce43f8699ba94c9b7648beda0ca174", "project": "GNOME/glib", "func": "static gboolean\nfile_copy_fallback (GFile                  *source,\n                    GFile                  *destination,\n                    GFileCopyFlags          flags,\n                    GCancellable           *cancellable,\n                    GFileProgressCallback   progress_callback,\n                    gpointer                progress_callback_data,\n                    GError                **error)\n{\n  gboolean ret = FALSE;\n  GFileInputStream *file_in = NULL;\n  GInputStream *in = NULL;\n  GOutputStream *out = NULL;\n  GFileInfo *info = NULL;\n  const char *target;\n  char *attrs_to_read;\n  gboolean do_set_attributes = FALSE;\n\n  /* need to know the file type */\n  info = g_file_query_info (source,\n                            G_FILE_ATTRIBUTE_STANDARD_TYPE \",\" G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET,\n                            G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                            cancellable,\n                            error);\n  if (!info)\n    goto out;\n\n  /* Maybe copy the symlink? */\n  if ((flags & G_FILE_COPY_NOFOLLOW_SYMLINKS) &&\n      g_file_info_get_file_type (info) == G_FILE_TYPE_SYMBOLIC_LINK)\n    {\n      target = g_file_info_get_symlink_target (info);\n      if (target)\n        {\n          if (!copy_symlink (destination, flags, cancellable, target, error))\n            goto out;\n\n          ret = TRUE;\n          goto out;\n        }\n        /* ... else fall back on a regular file copy */\n    }\n  /* Handle \"special\" files (pipes, device nodes, ...)? */\n  else if (g_file_info_get_file_type (info) == G_FILE_TYPE_SPECIAL)\n    {\n      /* FIXME: could try to recreate device nodes and others? */\n      g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,\n                           _(\"Can\u2019t copy special file\"));\n      goto out;\n    }\n\n  /* Everything else should just fall back on a regular copy. */\n\n  file_in = open_source_for_copy (source, destination, flags, cancellable, error);\n  if (!file_in)\n    goto out;\n  in = G_INPUT_STREAM (file_in);\n\n  if (!build_attribute_list_for_copy (destination, flags, &attrs_to_read,\n                                      cancellable, error))\n    goto out;\n\n  if (attrs_to_read != NULL)\n    {\n      GError *tmp_error = NULL;\n\n      /* Ok, ditch the previous lightweight info (on Unix we just\n       * called lstat()); at this point we gather all the information\n       * we need about the source from the opened file descriptor.\n       */\n      g_object_unref (info);\n\n      info = g_file_input_stream_query_info (file_in, attrs_to_read,\n                                             cancellable, &tmp_error);\n      if (!info)\n        {\n          /* Not all gvfs backends implement query_info_on_read(), we\n           * can just fall back to the pathname again.\n           * https://bugzilla.gnome.org/706254\n           */\n          if (g_error_matches (tmp_error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED))\n            {\n              g_clear_error (&tmp_error);\n              info = g_file_query_info (source, attrs_to_read, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                        cancellable, error);\n            }\n          else\n            {\n              g_free (attrs_to_read);\n              g_propagate_error (error, tmp_error);\n              goto out;\n            }\n        }\n      g_free (attrs_to_read);\n      if (!info)\n        goto out;\n\n      do_set_attributes = TRUE;\n    }\n\n  /* In the local file path, we pass down the source info which\n   * includes things like unix::mode, to ensure that the target file\n   * is not created with different permissions from the source file.\n   *\n   * If a future API like g_file_replace_with_info() is added, switch\n   * this code to use that.\n   */\n  if (G_IS_LOCAL_FILE (destination))\n    {\n      if (flags & G_FILE_COPY_OVERWRITE)\n        out = (GOutputStream*)_g_local_file_output_stream_replace (_g_local_file_get_filename (G_LOCAL_FILE (destination)),\n                                                                   FALSE, NULL,\n                                                                   flags & G_FILE_COPY_BACKUP,\n                                                                   G_FILE_CREATE_REPLACE_DESTINATION |\n                                                                   G_FILE_CREATE_PRIVATE, info,\n                                                                   cancellable, error);\n      else\n        out = (GOutputStream*)_g_local_file_output_stream_create (_g_local_file_get_filename (G_LOCAL_FILE (destination)),\n                                                                  FALSE, G_FILE_CREATE_PRIVATE, info,\n                                                                  cancellable, error);\n    }\n  else if (flags & G_FILE_COPY_OVERWRITE)\n    {\n      out = (GOutputStream *)g_file_replace (destination,\n                                             NULL,\n                                             flags & G_FILE_COPY_BACKUP,\n                                             G_FILE_CREATE_REPLACE_DESTINATION |\n                                             G_FILE_CREATE_PRIVATE,\n                                             cancellable, error);\n    }\n  else\n    {\n      out = (GOutputStream *)g_file_create (destination, G_FILE_CREATE_PRIVATE, cancellable, error);\n    }\n\n  if (!out)\n    goto out;\n\n#ifdef __linux__\n  if (G_IS_FILE_DESCRIPTOR_BASED (in) && G_IS_FILE_DESCRIPTOR_BASED (out))\n    {\n      GError *reflink_err = NULL;\n\n      if (!btrfs_reflink_with_progress (in, out, info, cancellable,\n                                        progress_callback, progress_callback_data,\n                                        &reflink_err))\n        {\n          if (g_error_matches (reflink_err, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED))\n            {\n              g_clear_error (&reflink_err);\n            }\n          else\n            {\n              g_propagate_error (error, reflink_err);\n              goto out;\n            }\n        }\n      else\n        {\n          ret = TRUE;\n          goto out;\n        }\n    }\n#endif\n\n#ifdef HAVE_SPLICE\n  if (G_IS_FILE_DESCRIPTOR_BASED (in) && G_IS_FILE_DESCRIPTOR_BASED (out))\n    {\n      GError *splice_err = NULL;\n\n      if (!splice_stream_with_progress (in, out, cancellable,\n                                        progress_callback, progress_callback_data,\n                                        &splice_err))\n        {\n          if (g_error_matches (splice_err, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED))\n            {\n              g_clear_error (&splice_err);\n            }\n          else\n            {\n              g_propagate_error (error, splice_err);\n              goto out;\n            }\n        }\n      else\n        {\n          ret = TRUE;\n          goto out;\n        }\n    }\n\n#endif\n\n  /* A plain read/write loop */\n  if (!copy_stream_with_progress (in, out, source, cancellable,\n                                  progress_callback, progress_callback_data,\n                                  error))\n    goto out;\n\n  ret = TRUE;\n out:\n  if (in)\n    {\n      /* Don't care about errors in source here */\n      (void) g_input_stream_close (in, cancellable, NULL);\n      g_object_unref (in);\n    }\n\n  if (out)\n    {\n      /* But write errors on close are bad! */\n      if (!g_output_stream_close (out, cancellable, ret ? error : NULL))\n        ret = FALSE;\n      g_object_unref (out);\n    }\n\n  /* Ignore errors here. Failure to copy metadata is not a hard error */\n  /* TODO: set these attributes /before/ we do the rename() on Unix */\n  if (ret && do_set_attributes)\n    {\n      g_file_set_attributes_from_info (destination,\n                                       info,\n                                       G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                       cancellable,\n                                       NULL);\n    }\n\n  g_clear_object (&info);\n\n  return ret;\n}", "target": 3, "idx": 10266}
{"commit_id": "4f94258c65a918ee3d8670e93916d15bf879e6ec", "project": "openbsd/src", "func": "static int\nx509_verify_ctx_add_chain(struct x509_verify_ctx *ctx,\n    struct x509_verify_chain *chain, char *name)\n{\n\tsize_t depth;\n\tX509 *last = x509_verify_chain_last(chain);\n\tX509 *leaf = x509_verify_chain_leaf(chain);\n\n\tdepth = sk_X509_num(chain->certs);\n\tif (depth > 0)\n\t\tdepth--;\n\n\tif (ctx->chains_count >= ctx->max_chains)\n\t\treturn x509_verify_cert_error(ctx, last, depth,\n\t\t    X509_V_ERR_CERT_CHAIN_TOO_LONG, 0);\n\n\t/* Clear a get issuer failure for a root certificate. */\n\tif (chain->cert_errors[depth] ==\n\t    X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY)\n\t\tchain->cert_errors[depth] = X509_V_OK;\n\n\tif (!x509_verify_ctx_validate_legacy_chain(ctx, chain, depth))\n\t\treturn 0;\n\n\t/* Verify the leaf certificate and store any resulting error. */\n\tif (!x509_verify_cert_valid(ctx, leaf, NULL))\n\t\treturn 0;\n\tif (!x509_verify_cert_hostname(ctx, leaf, name))\n\t\treturn 0;\n\tif (ctx->error_depth == 0 &&\n\t    ctx->error != X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY)\n\t\tchain->cert_errors[0] = ctx->error;\n\n\t/*\n\t * In the non-legacy code, extensions and purpose are dealt\n\t * with as the chain is built.\n\t *\n\t * The non-legacy api returns multiple chains but does not do\n\t * any revocation checking (it must be done by the caller on\n\t * any chain they wish to use)\n\t */\n\n\tif ((ctx->chains[ctx->chains_count] = x509_verify_chain_dup(chain)) ==\n\t    NULL) {\n\t\treturn x509_verify_cert_error(ctx, last, depth,\n\t\t    X509_V_ERR_OUT_OF_MEM, 0);\n\t}\n\tctx->chains_count++;\n\n\tctx->error = X509_V_OK;\n\tctx->error_depth = depth;\n\n\treturn 1;\n}", "target": 1, "idx": 10267}
{"commit_id": "b860822ad233304fceefc4644bd353087a5309ec", "project": "mhammond/pywin32", "func": "PyObject *PyACL::AddAuditAccessObjectAce(PyObject *self, PyObject *args)\n{\n    DWORD accessmask, acerevision, aceflags;\n    BOOL bAuditSuccess, bAuditFailure;\n    PyObject *obSID;\n    GUID ObjectTypeGuid, InheritedObjectTypeGuid;\n    GUID *pObjectTypeGuid = NULL, *pInheritedObjectTypeGuid = NULL;\n    PyObject *obObjectTypeGuid, *obInheritedObjectTypeGuid;\n    BOOL bsuccess;\n    PSID psid;\n    PACL psacl;\n    PyACL *This = (PyACL *)self;\n    psacl = This->GetACL();\n    PACL psacl_padded = NULL;\n    if (addauditaccessobjectace == NULL)\n        return PyErr_Format(PyExc_NotImplementedError,\n                            \"AddAuditAccessObjectAce not supported by this version of Windows\");\n\n    // @pyparm int|dwAceRevision||Revision of ACL: Must be at least ACL_REVISION_DS\n    // @pyparm int|AceFlags||Combination of\n    // FAILED_ACCESS_ACE_FLAG,SUCCESSFUL_ACCESS_ACE_FLAG,CONTAINER_INHERIT_ACE,INHERIT_ONLY_ACE,INHERITED_ACE,NO_PROPAGATE_INHERIT_ACE\n    // and OBJECT_INHERIT_ACE\n    // @pyparm int|dwAccessMask||Bitmask of access types to be audited\n    // @pyparm <o PyIID>|ObjectTypeGuid||GUID of object type or property set to which ace applies, can be None\n    // @pyparm <o PyIID>|InheritedObjectTypeGuid||GUID of object type or property that will inherit ACE, can be None\n    // @pyparm <o PySID>|sid||SID for whom system audit messages will be generated\n    // @pyparm int|bAuditSuccess||Set to 1 if access success should be audited, else 0\n    // @pyparm int|bAuditFailure||Set to 1 if access failure should be audited, else 0\n\n    if (!PyArg_ParseTuple(args, \"lllOOOii:AddAuditAccessObjectAce\", &acerevision, &aceflags, &accessmask,\n                          &obObjectTypeGuid, &obInheritedObjectTypeGuid, &obSID, &bAuditSuccess, &bAuditFailure))\n        return NULL;\n    if (obObjectTypeGuid != Py_None) {\n        if (!PyWinObject_AsIID(obObjectTypeGuid, &ObjectTypeGuid))\n            return NULL;\n        pObjectTypeGuid = &ObjectTypeGuid;\n    }\n    if (obInheritedObjectTypeGuid != Py_None) {\n        if (!PyWinObject_AsIID(obInheritedObjectTypeGuid, &InheritedObjectTypeGuid))\n            return NULL;\n        pInheritedObjectTypeGuid = &InheritedObjectTypeGuid;\n    }\n    if (!PyWinObject_AsSID(obSID, &psid, FALSE))\n        return NULL;\n\n    bsuccess = (*addauditaccessobjectace)(psacl, acerevision, aceflags, accessmask, pObjectTypeGuid,\n                                          pInheritedObjectTypeGuid, psid, bAuditSuccess, bAuditFailure);\n    if (!bsuccess) {\n        DWORD err = GetLastError();\n        if (err != ERROR_ALLOTTED_SPACE_EXCEEDED)\n            return PyWin_SetAPIError(\"AddAuditAccessObjectAce\", err);\n        // resize if acl too small\n       unsigned int required_size = psacl->AclSize + sizeof(SYSTEM_AUDIT_OBJECT_ACE) + GetLengthSid(psid);\n        // max ACL size is USHRT_MAX\n        if (required_size > USHRT_MAX)\n            return PyErr_Format(PyExc_OverflowError, \"%s: adding ACE would put ACL over size limit\", __FUNCTION__ );\n        psacl_padded = (ACL *)malloc(required_size);\n        if (psacl_padded == NULL)\n            return PyErr_Format(PyExc_MemoryError, \"AddAuditAccessObjectAce: unable to allocated %d bytes\",\n                                required_size);\n\n        ZeroMemory(psacl_padded, required_size);\n        memcpy(psacl_padded, psacl, psacl->AclSize);\n        psacl_padded->AclSize = (unsigned short)required_size;\n        bsuccess = (*addauditaccessobjectace)(psacl_padded, acerevision, aceflags, accessmask, pObjectTypeGuid,\n                                              pInheritedObjectTypeGuid, psid, bAuditSuccess, bAuditFailure);\n        if (bsuccess)\n            bsuccess = This->SetACL(psacl_padded);\n        else\n            PyWin_SetAPIError(\"AddAuditAccessObjectAce\");\n    }\n    if (psacl_padded)\n        free(psacl_padded);\n    if (bsuccess) {\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n    return NULL;\n}", "target": 1, "idx": 10268}
{"commit_id": "5b597a2e5b28e2d5a52fc1be13f425f08f47cb62", "project": "php/php-src", "func": "static void php_mb_regex_free_cache(php_mb_regex_t **pre)\n{\n\tonig_free(*pre);\n}", "target": 3, "idx": 10269}
{"commit_id": "31dbf4aa069c5bb39a7926d86036ce3b04312b51", "project": "openNDS", "func": "void client_reset(t_client *client)\n{\n\tchar *hash;\n\tchar *msg;\n\tchar *cidinfo;\n\n\tdebug(LOG_DEBUG, \"Resetting client [%s]\", client->mac);\n\t// Reset traffic counters\n\tclient->counters.incoming = 0;\n\tclient->counters.outgoing = 0;\n\tclient->counters.last_updated = time(NULL);\n\n\t// Reset session time\n\tclient->session_start = 0;\n\tclient->session_end = 0;\n\n\t// Reset token and hid\n\thash = safe_calloc(STATUS_BUF);\n\tclient->token = safe_calloc(STATUS_BUF);\n\tsafe_snprintf(client->token, STATUS_BUF, \"%04hx%04hx\", rand16(), rand16());\n\thash_str(hash, STATUS_BUF, client->token);\n\tclient->hid = safe_strdup(hash);\n\tfree(hash);\n\n\t// Reset custom, client_type and cpi_query\n\tclient->custom = safe_calloc(MID_BUF);\n\tclient->client_type = safe_calloc(STATUS_BUF);\n\n\tif (!client->cpi_query) {\n\t\tclient->cpi_query = safe_calloc(STATUS_BUF);\n\t}\n\n\t//Reset cid and remove cidfile using rmcid\n\tif (client->cid) {\n\n\t\tif (strlen(client->cid) > 0) {\n\t\t\tmsg = safe_calloc(SMALL_BUF);\n\t\t\tcidinfo = safe_calloc(MID_BUF);\n\t\t\tsafe_snprintf(cidinfo, MID_BUF, \"cid=\\\"%s\\\"\", client->cid);\n\t\t\twrite_client_info(msg, SMALL_BUF, \"rmcid\", client->cid, cidinfo);\n\t\t\tfree(msg);\n\t\t\tfree(cidinfo);\n\t\t}\n\t}\n\n\tclient->cid = safe_calloc(SMALL_BUF);\n\n}", "target": 2, "idx": 10270}
{"commit_id": "dac48f148538c706c446e5105d84ebcb54587528", "project": "wireshark", "func": "void\nproto_register_lwapp(void)\n{\n    static hf_register_info hf[] = {\n        { &hf_lwapp_version,\n          { \"Version\", \"lwapp.version\", FT_UINT8, BASE_DEC, NULL, 0x00,\n            NULL, HFILL }},\n        { &hf_lwapp_slotid,\n          { \"slotId\",\"lwapp.slotId\", FT_UINT24, BASE_DEC, NULL, 0x0,\n            NULL, HFILL }},\n        { &hf_lwapp_flags,\n          { \"Flags\", \"lwapp.flags\", FT_UINT8, BASE_HEX,\n            NULL, 0x0, NULL, HFILL }},\n        { &hf_lwapp_flags_type,\n          { \"Type\", \"lwapp.flags.type\", FT_BOOLEAN, 8,\n            TFS(&lwapp_flags_type), LWAPP_FLAGS_T, NULL, HFILL }},\n        { &hf_lwapp_flags_fragment,\n          { \"Fragment\", \"lwapp.flags.fragment\", FT_BOOLEAN, 8,\n            TFS(&tfs_set_notset), LWAPP_FLAGS_F,\n            NULL, HFILL }},\n        { &hf_lwapp_flags_fragment_type,\n          { \"Fragment Type\", \"lwapp.flags.fragmentType\", FT_BOOLEAN, 8,\n            TFS(&tfs_set_notset), LWAPP_FLAGS_FT,\n            NULL, HFILL }},\n        { &hf_lwapp_fragment_id,\n          { \"Fragment Id\",\"lwapp.fragmentId\", FT_UINT8, BASE_HEX,\n            NULL, 0x0, NULL, HFILL }},\n        { &hf_lwapp_length,\n          { \"Length\",\"lwapp.Length\", FT_UINT16, BASE_DEC,\n            NULL, 0x0, NULL, HFILL }},\n        { &hf_lwapp_rssi,\n          { \"RSSI\",\"lwapp.rssi\", FT_UINT8, BASE_HEX,\n            NULL, 0x0, NULL, HFILL }},\n        { &hf_lwapp_snr,\n          { \"SNR\",\"lwapp.snr\", FT_UINT8, BASE_HEX,\n            NULL, 0x0, NULL, HFILL }},\n#if 0\n        { &hf_lwapp_control,\n          { \"Control Data (not dissected yet)\",\"lwapp.control\", FT_BYTES, BASE_NONE,\n            NULL, 0x0, NULL, HFILL }},\n#endif\n        { &hf_lwapp_control_mac,\n          { \"AP Identity\", \"lwapp.apid\", FT_ETHER, BASE_NONE, NULL, 0x0,\n              \"Access Point Identity\", HFILL }},\n        { &hf_lwapp_control_type,\n          { \"Control Type\", \"lwapp.control.type\", FT_UINT8, BASE_DEC|BASE_EXT_STRING, &control_msg_vals_ext, 0x00,\n            NULL, HFILL }},\n        { &hf_lwapp_control_seq_no,\n          { \"Control Sequence Number\", \"lwapp.control.seqno\", FT_UINT8, BASE_DEC, NULL, 0x00,\n            NULL, HFILL }},\n        { &hf_lwapp_control_length,\n          { \"Control Length\",\"lwapp.control.length\", FT_UINT16, BASE_DEC,\n            NULL, 0x0, NULL, HFILL }},\n    };\n    static gint *ett[] = {\n        &ett_lwapp_l3,\n        &ett_lwapp,\n        &ett_lwapp_control,\n        &ett_lwapp_flags\n    };\n    static ei_register_info ei[] = {\n        { &ei_lwapp_too_many_encap, { \"lwapp.too_many_encap\", PI_UNDECODED, PI_WARN, \"Too many LWAPP encapsulation levels\", EXPFILL }}\n    };\n    module_t *lwapp_module;\n    expert_module_t* expert_lwapp;\n\n    proto_lwapp = proto_register_protocol (\"LWAPP Encapsulated Packet\",\n                                         \"LWAPP\", \"lwapp\");\n\n    proto_lwapp_l3 = proto_register_protocol (\"LWAPP Layer 3 Packet\",\n                                         \"LWAPP-L3\", \"lwapp-l3\");\n\n    proto_lwapp_control = proto_register_protocol (\"LWAPP Control Message\",\n                                         \"LWAPP-CNTL\", \"lwapp-cntl\");\n    proto_register_field_array(proto_lwapp, hf, array_length(hf));\n    proto_register_subtree_array(ett, array_length(ett));\n    expert_lwapp = expert_register_protocol(proto_lwapp);\n    expert_register_field_array(expert_lwapp, ei, array_length(ei));\n\n    lwapp_module = prefs_register_protocol(proto_lwapp, NULL);\n\n    prefs_register_bool_preference(lwapp_module,\"swap_fc\",\"Swap Frame Control\",\n                                   \"Swap frame control bytes (needed for some APs\",\n                                   &swap_frame_control);\n\n}", "target": 2, "idx": 10271}
{"commit_id": "a00d237346894c6067a594983be6634f4168c9ad", "project": "facebook/hermes", "func": "CallResult<HermesValue> copyDataPropertiesSlowPath_RJS(\n    Runtime &runtime,\n    Handle<JSObject> target,\n    Handle<JSObject> from,\n    Handle<JSObject> excludedItems) {\n  // 5. Let keys be ? from.[[OwnPropertyKeys]]().\n  auto cr = JSObject::getOwnPropertyKeys(\n      from,\n      runtime,\n      OwnKeysFlags()\n          .plusIncludeSymbols()\n          .plusIncludeNonSymbols()\n          .plusIncludeNonEnumerable());\n  if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto keys = *cr;\n\n  MutableHandle<> nextKeyHandle{runtime};\n  MutableHandle<> propValueHandle{runtime};\n  MutableHandle<SymbolID> tmpSymbolStorage{runtime};\n  GCScopeMarkerRAII marker{runtime};\n  // 6. For each element nextKey of keys in List order, do\n  for (uint32_t nextKeyIdx = 0, endIdx = keys->getEndIndex();\n       nextKeyIdx < endIdx;\n       ++nextKeyIdx) {\n    marker.flush();\n    nextKeyHandle = keys->at(runtime, nextKeyIdx).unboxToHV(runtime);\n    if (nextKeyHandle->isNumber()) {\n      CallResult<PseudoHandle<StringPrimitive>> strRes =\n          toString_RJS(runtime, nextKeyHandle);\n      if (LLVM_UNLIKELY(strRes == ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      nextKeyHandle = strRes->getHermesValue();\n    }\n\n    // b. For each element e of excludedItems in List order, do\n    //   i. If SameValue(e, nextKey) is true, then\n    //     1. Set excluded to true.\n    if (excludedItems) {\n      assert(\n          !excludedItems->isProxyObject() &&\n          \"internal excludedItems object is a proxy\");\n      ComputedPropertyDescriptor desc;\n      CallResult<bool> cr = JSObject::getOwnComputedPrimitiveDescriptor(\n          excludedItems,\n          runtime,\n          nextKeyHandle,\n          JSObject::IgnoreProxy::Yes,\n          tmpSymbolStorage,\n          desc);\n      if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION))\n        return ExecutionStatus::EXCEPTION;\n      if (*cr)\n        continue;\n    }\n\n    //   i. Let desc be ? from.[[GetOwnProperty]](nextKey).\n    ComputedPropertyDescriptor desc;\n    CallResult<bool> crb = JSObject::getOwnComputedDescriptor(\n        from, runtime, nextKeyHandle, tmpSymbolStorage, desc);\n    if (LLVM_UNLIKELY(crb == ExecutionStatus::EXCEPTION))\n      return ExecutionStatus::EXCEPTION;\n    //   ii. If desc is not undefined and desc.[[Enumerable]] is true, then\n    // TODO(T141997867), move this special case behavior for host objects to\n    // getOwnComputedDescriptor.\n    if ((*crb && desc.flags.enumerable) || from->isHostObject()) {\n      //     1. Let propValue be ? Get(from, nextKey).\n      CallResult<PseudoHandle<>> crv =\n          JSObject::getComputed_RJS(from, runtime, nextKeyHandle);\n      if (LLVM_UNLIKELY(crv == ExecutionStatus::EXCEPTION))\n        return ExecutionStatus::EXCEPTION;\n      propValueHandle = std::move(*crv);\n      //     2. Perform ! CreateDataProperty(target, nextKey, propValue).\n      crb = JSObject::defineOwnComputed(\n          target,\n          runtime,\n          nextKeyHandle,\n          DefinePropertyFlags::getDefaultNewPropertyFlags(),\n          propValueHandle);\n      if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION))\n        return ExecutionStatus::EXCEPTION;\n      assert(\n          crb != ExecutionStatus::EXCEPTION && *crb &&\n          \"CreateDataProperty failed\");\n    }\n  }\n  return target.getHermesValue();\n}", "target": 3, "idx": 10272}
{"commit_id": "34a08bec755670ea0490cb53bbc68058cafc69b6", "project": "OP-TEE/optee_os", "func": "TEE_Result syscall_authenc_init(unsigned long state, const void *nonce,\n\t\t\tsize_t nonce_len, size_t tag_len,\n\t\t\tsize_t aad_len, size_t payload_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\tstruct tee_cryp_obj_secret *key;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)nonce, nonce_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx), cs->key1, &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tkey = o->attr;\n\tres = crypto_authenc_init(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t  (uint8_t *)(key + 1), key->key_size,\n\t\t\t\t  nonce, nonce_len, tag_len, aad_len,\n\t\t\t\t  payload_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tcs->ctx_finalize = (tee_cryp_ctx_finalize_func_t)crypto_authenc_final;\n\tcs->state = CRYP_STATE_INITIALIZED;\n\n\treturn TEE_SUCCESS;\n}", "target": 3, "idx": 10273}
{"commit_id": "9bbce9634cba1128aa4b96d590be578ae3ce80b3", "project": "gpac", "func": "static GF_Err gf_sm_load_run_isom(GF_SceneLoader *load)\n{\n\tGF_Err e;\n\tFILE *logs;\n\tu32 i, j, di, nbBifs, nbLaser, nb_samp, samp_done, init_offset;\n\tGF_StreamContext *sc;\n\tGF_ESD *esd;\n\tGF_ODCodec *od_dec;\n#ifndef GPAC_DISABLE_BIFS\n\tGF_BifsDecoder *bifs_dec;\n#endif\n#ifndef GPAC_DISABLE_LASER\n\tGF_LASeRCodec *lsr_dec;\n#endif\n\n\tif (!load || !load->isom) return GF_BAD_PARAM;\n\n\tnbBifs = nbLaser = 0;\n\te = GF_OK;\n#ifndef GPAC_DISABLE_BIFS\n\tbifs_dec = gf_bifs_decoder_new(load->scene_graph, 1);\n#endif\n\tod_dec = gf_odf_codec_new();\n\tlogs = NULL;\n#ifndef GPAC_DISABLE_LASER\n\tlsr_dec = gf_laser_decoder_new(load->scene_graph);\n#endif\n\tesd = NULL;\n\t/*load each stream*/\n\tnb_samp = 0;\n\tfor (i=0; i<gf_isom_get_track_count(load->isom); i++) {\n\t\tu32 type = gf_isom_get_media_type(load->isom, i+1);\n\t\tu32 subtype = gf_isom_get_mpeg4_subtype(load->isom, i+1, 1);\n\t\tswitch (type) {\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\tcase GF_ISOM_MEDIA_OD:\n\t\t\tnb_samp += gf_isom_get_sample_count(load->isom, i+1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (subtype==GF_ISOM_SUBTYPE_MP4S) {\n\t\t\t\tnb_samp += gf_isom_get_sample_count(load->isom, i+1);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tsamp_done = 1;\n\tgf_isom_text_set_streaming_mode(load->isom, 1);\n\n\tfor (i=0; i<gf_isom_get_track_count(load->isom); i++) {\n\t\tu32 type = gf_isom_get_media_type(load->isom, i+1);\n\t\tu32 subtype = gf_isom_get_mpeg4_subtype(load->isom, i+1, 1);\n\t\tswitch (type) {\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\tcase GF_ISOM_MEDIA_OD:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (subtype!=GF_ISOM_SUBTYPE_MP4S)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\t\tesd = gf_isom_get_esd(load->isom, i+1, 1);\n\t\tif (!esd) continue;\n\t\tif (!esd->decoderConfig || (esd->decoderConfig->objectTypeIndication==GF_CODECID_TEXT_MPEG4)) {\n\t\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t\t\tesd = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((esd->decoderConfig->objectTypeIndication == GF_CODECID_AFX) ||\n\t\t        (esd->decoderConfig->objectTypeIndication == GF_CODECID_SYNTHESIZED_TEXTURE)\n\t\t   ) {\n\t\t\tnb_samp += gf_isom_get_sample_count(load->isom, i+1);\n\t\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t\t\tesd = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tsc = gf_sm_stream_new(load->ctx, esd->ESID, esd->decoderConfig->streamType, esd->decoderConfig->objectTypeIndication);\n\t\tsc->streamType = esd->decoderConfig->streamType;\n\t\tsc->ESID = esd->ESID;\n\t\tsc->codec_id = esd->decoderConfig->objectTypeIndication;\n\t\tsc->timeScale = gf_isom_get_media_timescale(load->isom, i+1);\n\n\t\t/*we still need to reconfig the BIFS*/\n\t\tif (esd->decoderConfig->streamType==GF_STREAM_SCENE) {\n#ifndef GPAC_DISABLE_BIFS\n\t\t\t/*BIFS*/\n\t\t\tif (esd->decoderConfig->objectTypeIndication<=2) {\n\t\t\t\tif (!esd->dependsOnESID && nbBifs && !i)\n\t\t\t\t\tmp4_report(load, GF_OK, \"several scene namespaces used or improper scene dependencies in file - import may be incorrect\");\n\t\t\t\tif (!esd->decoderConfig->decoderSpecificInfo) {\n\t\t\t\t\t/* Hack for T-DMB non compliant streams */\n\t\t\t\t\te = gf_bifs_decoder_configure_stream(bifs_dec, esd->ESID, NULL, 0, esd->decoderConfig->objectTypeIndication);\n\t\t\t\t} else {\n\t\t\t\t\te = gf_bifs_decoder_configure_stream(bifs_dec, esd->ESID, esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, esd->decoderConfig->objectTypeIndication);\n\t\t\t\t}\n\t\t\t\tif (e) goto exit;\n\t\t\t\tnbBifs++;\n\t\t\t}\n#endif\n\n#ifndef GPAC_DISABLE_LASER\n\t\t\t/*LASER*/\n\t\t\tif (esd->decoderConfig->objectTypeIndication==0x09) {\n\t\t\t\tif (!esd->dependsOnESID && nbBifs && !i)\n\t\t\t\t\tmp4_report(load, GF_OK, \"several scene namespaces used or improper scene dependencies in file - import may be incorrect\");\n\n\t\t\t\tif (!esd->decoderConfig->decoderSpecificInfo)\n\t\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\telse\n\t\t\t\t\te = gf_laser_decoder_configure_stream(lsr_dec, esd->ESID, esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength);\n\n\t\t\t\tif (e) goto exit;\n\t\t\t\tnbLaser++;\n\t\t\t}\n#endif\n\t\t}\n\n\t\tinit_offset = 0;\n\t\t/*dump all AUs*/\n\t\tfor (j=0; j<gf_isom_get_sample_count(load->isom, i+1); j++) {\n\t\t\tGF_AUContext *au;\n\t\t\tGF_ISOSample *samp = gf_isom_get_sample(load->isom, i+1, j+1, &di);\n\t\t\tif (!samp) {\n\t\t\t\tmp4_report(load, gf_isom_last_error(load->isom), \"Unable to fetch sample %d from track ID %d - aborting track import\", j+1, gf_isom_get_track_id(load->isom, i+1));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*check if track has initial offset*/\n\t\t\tif (!j && gf_isom_get_edits_count(load->isom, i+1)) {\n\t\t\t\tu64 EditTime, dur, mtime;\n\t\t\t\tGF_ISOEditType mode;\n\t\t\t\tgf_isom_get_edit(load->isom, i+1, 1, &EditTime, &dur, &mtime, &mode);\n\t\t\t\tif (mode==GF_ISOM_EDIT_EMPTY) {\n\t\t\t\t\tinit_offset = (u32) (dur * sc->timeScale / gf_isom_get_timescale(load->isom) );\n\t\t\t\t}\n\t\t\t}\n\t\t\tsamp->DTS += init_offset;\n\n\t\t\tau = gf_sm_stream_au_new(sc, samp->DTS, ((Double)(s64) samp->DTS) / sc->timeScale, (samp->IsRAP==RAP) ? 1 : 0);\n\n\t\t\tif (esd->decoderConfig->streamType==GF_STREAM_SCENE) {\n#ifndef GPAC_DISABLE_BIFS\n\t\t\t\tif (esd->decoderConfig->objectTypeIndication<=2)\n\t\t\t\t\te = gf_bifs_decode_command_list(bifs_dec, esd->ESID, samp->data, samp->dataLength, au->commands);\n#endif\n#ifndef GPAC_DISABLE_LASER\n\t\t\t\tif (esd->decoderConfig->objectTypeIndication==0x09)\n\t\t\t\t\te = gf_laser_decode_command_list(lsr_dec, esd->ESID, samp->data, samp->dataLength, au->commands);\n#endif\n\t\t\t} else {\n\t\t\t\te = gf_odf_codec_set_au(od_dec, samp->data, samp->dataLength);\n\t\t\t\tif (!e) e = gf_odf_codec_decode(od_dec);\n\t\t\t\tif (!e) {\n\t\t\t\t\twhile (1) {\n\t\t\t\t\t\tGF_ODCom *odc = gf_odf_codec_get_com(od_dec);\n\t\t\t\t\t\tif (!odc) break;\n\t\t\t\t\t\t/*update ESDs if any*/\n\t\t\t\t\t\tUpdateODCommand(load->isom, odc);\n\t\t\t\t\t\tgf_list_add(au->commands, odc);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_isom_sample_del(&samp);\n\t\t\tif (e) {\n\t\t\t\tmp4_report(load, gf_isom_last_error(load->isom), \"decoding sample %d from track ID %d failed\", j+1, gf_isom_get_track_id(load->isom, i+1));\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tsamp_done++;\n\t\t\tgf_set_progress(\"MP4 Loading\", samp_done, nb_samp);\n\t\t}\n\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t\tesd = NULL;\n\t}\n\tgf_isom_text_set_streaming_mode(load->isom, 0);\n\nexit:\n#ifndef GPAC_DISABLE_BIFS\n\tgf_bifs_decoder_del(bifs_dec);\n#endif\n\tgf_odf_codec_del(od_dec);\n#ifndef GPAC_DISABLE_LASER\n\tgf_laser_decoder_del(lsr_dec);\n#endif\n\tif (esd) gf_odf_desc_del((GF_Descriptor *) esd);\n\tif (logs) gf_fclose(logs);\n\treturn e;\n}", "target": 1, "idx": 10274}
{"commit_id": "2639e878336ccd138e0ab20a3daea375998c3a81", "project": "chromium", "func": "WebstoreInlineInstaller::WebstoreInlineInstaller(\n    content::WebContents* web_contents,\n    content::RenderFrameHost* host,\n    const std::string& webstore_item_id,\n    const GURL& requestor_url,\n    const Callback& callback)\n    : WebstoreStandaloneInstaller(\n          webstore_item_id,\n          Profile::FromBrowserContext(web_contents->GetBrowserContext()),\n          callback),\n      content::WebContentsObserver(web_contents),\n      host_(host),\n      requestor_url_(requestor_url) {}", "target": 1, "idx": 10275}
{"commit_id": "6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91", "project": "torvalds/linux", "func": "static int\ncheck_entry_size_and_hooks(struct ipt_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct ipt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ipt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct ipt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_err(\"Underflows must be unconditional and \"\n\t\t\t\t       \"use the STANDARD target with \"\n\t\t\t\t       \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 2, "idx": 10276}
{"commit_id": "19a9cd607de73947fcfb104682f203ffe4e1f4e5", "project": "xorg/lib/libXi", "func": "XDevice *\nXOpenDevice(\n    register Display\t*dpy,\n    register XID\t id)\n{\n    register long rlen;\t/* raw length */\n    xOpenDeviceReq *req;\n    xOpenDeviceReply rep;\n    XDevice *dev;\n    XExtDisplayInfo *info = XInput_find_display(dpy);\n\n    LockDisplay(dpy);\n    if (_XiCheckExtInit(dpy, XInput_Initial_Release, info) == -1)\n        return NULL;\n\n    GetReq(OpenDevice, req);\n    req->reqType = info->codes->major_opcode;\n    req->ReqType = X_OpenDevice;\n    req->deviceid = id;\n\n    if (!_XReply(dpy, (xReply *) & rep, 0, xFalse)) {\n\tUnlockDisplay(dpy);\n\tSyncHandle();\n\treturn (XDevice *) NULL;\n    }\n\n    if (rep.length < INT_MAX >> 2 &&\n\t(rep.length << 2) >= rep.num_classes * sizeof(xInputClassInfo)) {\n\trlen = rep.length << 2;\n\tdev = (XDevice *) Xmalloc(sizeof(XDevice) + rep.num_classes *\n\t\t\t\t  sizeof(XInputClassInfo));\n    } else {\n\trlen = 0;\n\tdev = NULL;\n    }\n    if (dev) {\n\tint dlen;\t/* data length */\n\n\tdev->device_id = req->deviceid;\n\tdev->num_classes = rep.num_classes;\n\tdev->classes = (XInputClassInfo *) ((char *)dev + sizeof(XDevice));\n\tdlen = rep.num_classes * sizeof(xInputClassInfo);\n\t_XRead(dpy, (char *)dev->classes, dlen);\n\t/* could be padding that we still need to eat (yummy!) */\n\tif (rlen - dlen > 0)\n\t    _XEatData(dpy, (unsigned long)rlen - dlen);\n    } else\n\t_XEatDataWords(dpy, rep.length);\n\n    UnlockDisplay(dpy);\n    SyncHandle();\n    return (dev);\n}", "target": 2, "idx": 10277}
{"commit_id": "5b7cc2500d514717a64675fcf631939494c074ce", "project": "axiomatic-systems/Bento4", "func": "AP4_UnknownUuidAtom::AP4_UnknownUuidAtom(AP4_UI64 size, AP4_ByteStream& stream) : \n    AP4_UuidAtom(size, false, stream)\n{\n    // store the data\n    AP4_Size header_size = GetHeaderSize();\n    if (size > header_size) {\n        m_Data.SetDataSize((AP4_Size)size-GetHeaderSize());\n        stream.Read(m_Data.UseData(), m_Data.GetDataSize());\n    }\n}", "target": 1, "idx": 10278}
{"commit_id": "f634481e940421020e52f511c1fb34aac1db4b2f", "project": "android", "func": "WORD32 ih264d_start_of_pic(dec_struct_t *ps_dec,\n                         WORD32 i4_poc,\n                         pocstruct_t *ps_temp_poc,\n                         UWORD16 u2_frame_num,\n                         dec_pic_params_t *ps_pps)\n{\n    pocstruct_t *ps_prev_poc = &ps_dec->s_cur_pic_poc;\n    pocstruct_t *ps_cur_poc = ps_temp_poc;\n\n    pic_buffer_t *pic_buf;\n\n    ivd_video_decode_op_t * ps_dec_output =\n                    (ivd_video_decode_op_t *)ps_dec->pv_dec_out;\n    dec_slice_params_t *ps_cur_slice = ps_dec->ps_cur_slice;\n    dec_seq_params_t *ps_seq = ps_pps->ps_sps;\n    UWORD8 u1_bottom_field_flag = ps_cur_slice->u1_bottom_field_flag;\n    UWORD8 u1_field_pic_flag = ps_cur_slice->u1_field_pic_flag;\n    /* high profile related declarations */\n    high_profile_tools_t s_high_profile;\n    WORD32 ret;\n\n    H264_MUTEX_LOCK(&ps_dec->process_disp_mutex);\n\n    ps_prev_poc->i4_pic_order_cnt_lsb = ps_cur_poc->i4_pic_order_cnt_lsb;\n    ps_prev_poc->i4_pic_order_cnt_msb = ps_cur_poc->i4_pic_order_cnt_msb;\n    ps_prev_poc->i4_delta_pic_order_cnt_bottom =\n                    ps_cur_poc->i4_delta_pic_order_cnt_bottom;\n    ps_prev_poc->i4_delta_pic_order_cnt[0] =\n                    ps_cur_poc->i4_delta_pic_order_cnt[0];\n    ps_prev_poc->i4_delta_pic_order_cnt[1] =\n                    ps_cur_poc->i4_delta_pic_order_cnt[1];\n    ps_prev_poc->u1_bot_field = ps_dec->ps_cur_slice->u1_bottom_field_flag;\n    ps_prev_poc->i4_prev_frame_num_ofst = ps_cur_poc->i4_prev_frame_num_ofst;\n    ps_prev_poc->u2_frame_num = u2_frame_num;\n    ps_dec->i1_prev_mb_qp_delta = 0;\n    ps_dec->i1_next_ctxt_idx = 0;\n\n\n    ps_dec->u4_nmb_deblk = 0;\n    if(ps_dec->u4_num_cores == 1)\n       ps_dec->u4_nmb_deblk = 1;\n\n\n\n    if(ps_seq->u1_mb_aff_flag == 1)\n    {\n        ps_dec->u4_nmb_deblk = 0;\n        if(ps_dec->u4_num_cores > 2)\n            ps_dec->u4_num_cores = 2;\n    }\n\n        ps_dec->u4_use_intrapred_line_copy = 0;\n\n\n\n    if (ps_seq->u1_mb_aff_flag == 0)\n    {\n        ps_dec->u4_use_intrapred_line_copy = 1;\n    }\n\n    ps_dec->u4_app_disable_deblk_frm = 0;\n    /* If degrade is enabled, set the degrade flags appropriately */\n    if(ps_dec->i4_degrade_type && ps_dec->i4_degrade_pics)\n    {\n        WORD32 degrade_pic;\n        ps_dec->i4_degrade_pic_cnt++;\n        degrade_pic = 0;\n\n        /* If degrade is to be done in all frames, then do not check further */\n        switch(ps_dec->i4_degrade_pics)\n        {\n            case 4:\n            {\n                degrade_pic = 1;\n                break;\n            }\n            case 3:\n            {\n                if(ps_cur_slice->u1_slice_type != I_SLICE)\n                    degrade_pic = 1;\n\n                break;\n            }\n            case 2:\n            {\n\n                /* If pic count hits non-degrade interval or it is an islice, then do not degrade */\n                if((ps_cur_slice->u1_slice_type != I_SLICE)\n                                && (ps_dec->i4_degrade_pic_cnt\n                                                != ps_dec->i4_nondegrade_interval))\n                    degrade_pic = 1;\n\n                break;\n            }\n            case 1:\n            {\n                /* Check if the current picture is non-ref */\n                if(0 == ps_cur_slice->u1_nal_ref_idc)\n                {\n                    degrade_pic = 1;\n                }\n                break;\n            }\n\n        }\n        if(degrade_pic)\n        {\n            if(ps_dec->i4_degrade_type & 0x2)\n                ps_dec->u4_app_disable_deblk_frm = 1;\n\n            /* MC degrading is done only for non-ref pictures */\n            if(0 == ps_cur_slice->u1_nal_ref_idc)\n            {\n                if(ps_dec->i4_degrade_type & 0x4)\n                    ps_dec->i4_mv_frac_mask = 0;\n\n                if(ps_dec->i4_degrade_type & 0x8)\n                    ps_dec->i4_mv_frac_mask = 0;\n            }\n        }\n        else\n            ps_dec->i4_degrade_pic_cnt = 0;\n    }\n\n    {\n        dec_err_status_t * ps_err = ps_dec->ps_dec_err_status;\n        if(ps_dec->u1_sl_typ_5_9\n                        && ((ps_cur_slice->u1_slice_type == I_SLICE)\n                                        || (ps_cur_slice->u1_slice_type\n                                                        == SI_SLICE)))\n            ps_err->u1_cur_pic_type = PIC_TYPE_I;\n        else\n            ps_err->u1_cur_pic_type = PIC_TYPE_UNKNOWN;\n\n        if(ps_err->u1_pic_aud_i == PIC_TYPE_I)\n        {\n            ps_err->u1_cur_pic_type = PIC_TYPE_I;\n            ps_err->u1_pic_aud_i = PIC_TYPE_UNKNOWN;\n        }\n\n        if(ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL)\n        {\n            if(ps_err->u1_err_flag)\n                ih264d_reset_ref_bufs(ps_dec->ps_dpb_mgr);\n            ps_err->u1_err_flag = ACCEPT_ALL_PICS;\n        }\n    }\n\n    if(ps_dec->u1_init_dec_flag && ps_dec->s_prev_seq_params.u1_eoseq_pending)\n    {\n        /* Reset the decoder picture buffers */\n        WORD32 j;\n        for(j = 0; j < MAX_DISP_BUFS_NEW; j++)\n        {\n\n            ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                  j,\n                                  BUF_MGR_REF);\n            ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,\n                                  ps_dec->au1_pic_buf_id_mv_buf_id_map[j],\n                                  BUF_MGR_REF);\n            ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                  j,\n                                  BUF_MGR_IO);\n        }\n\n        /* reset the decoder structure parameters related to buffer handling */\n        ps_dec->u1_second_field = 0;\n        ps_dec->i4_cur_display_seq = 0;\n\n        /********************************************************************/\n        /* indicate in the decoder output i4_status that some frames are being */\n        /* dropped, so that it resets timestamp and wait for a new sequence */\n        /********************************************************************/\n\n        ps_dec->s_prev_seq_params.u1_eoseq_pending = 0;\n    }\n    ret = ih264d_init_pic(ps_dec, u2_frame_num, i4_poc, ps_pps);\n    if(ret != OK)\n        return ret;\n\n    ps_dec->pv_parse_tu_coeff_data = ps_dec->pv_pic_tu_coeff_data;\n    ps_dec->pv_proc_tu_coeff_data  = ps_dec->pv_pic_tu_coeff_data;\n    ps_dec->ps_nmb_info = ps_dec->ps_frm_mb_info;\n    if(ps_dec->u1_separate_parse)\n    {\n        UWORD16 pic_wd = ps_dec->u4_width_at_init;\n        UWORD16 pic_ht = ps_dec->u4_height_at_init;\n        UWORD32 num_mbs;\n\n        if((NULL != ps_dec->ps_cur_sps) && (1 == (ps_dec->ps_cur_sps->u1_is_valid)))\n        {\n            pic_wd = ps_dec->u2_pic_wd;\n            pic_ht = ps_dec->u2_pic_ht;\n        }\n        num_mbs = (pic_wd * pic_ht) >> 8;\n\n        if(ps_dec->pu1_dec_mb_map)\n        {\n            memset((void *)ps_dec->pu1_dec_mb_map, 0, num_mbs);\n        }\n\n        if(ps_dec->pu1_recon_mb_map)\n        {\n\n            memset((void *)ps_dec->pu1_recon_mb_map, 0, num_mbs);\n        }\n\n        if(ps_dec->pu2_slice_num_map)\n        {\n            memset((void *)ps_dec->pu2_slice_num_map, 0,\n                   (num_mbs * sizeof(UWORD16)));\n        }\n\n    }\n\n    ps_dec->ps_parse_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);\n    ps_dec->ps_decode_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);\n    ps_dec->ps_computebs_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);\n    ps_dec->u2_cur_slice_num = 0;\n\n    /* Initialize all the HP toolsets to zero */\n    ps_dec->s_high_profile.u1_scaling_present = 0;\n    ps_dec->s_high_profile.u1_transform8x8_present = 0;\n\n    /* Get Next Free Picture */\n    if(1 == ps_dec->u4_share_disp_buf)\n    {\n        UWORD32 i;\n        /* Free any buffer that is in the queue to be freed */\n        for(i = 0; i < MAX_DISP_BUFS_NEW; i++)\n        {\n            if(0 == ps_dec->u4_disp_buf_to_be_freed[i])\n                continue;\n            ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr, i,\n            BUF_MGR_IO);\n            ps_dec->u4_disp_buf_to_be_freed[i] = 0;\n            ps_dec->u4_disp_buf_mapping[i] = 0;\n\n        }\n    }\n    if(!(u1_field_pic_flag && 0 != ps_dec->u1_top_bottom_decoded)) //ps_dec->u1_second_field))\n    {\n        pic_buffer_t *ps_cur_pic;\n        WORD32 cur_pic_buf_id, cur_mv_buf_id;\n        col_mv_buf_t *ps_col_mv;\n        while(1)\n        {\n            ps_cur_pic = (pic_buffer_t *)ih264_buf_mgr_get_next_free(\n                            (buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                            &cur_pic_buf_id);\n            if(ps_cur_pic == NULL)\n            {\n                ps_dec->i4_error_code = ERROR_UNAVAIL_PICBUF_T;\n                return ERROR_UNAVAIL_PICBUF_T;\n            }\n            if(0 == ps_dec->u4_disp_buf_mapping[cur_pic_buf_id])\n            {\n                break;\n            }\n\n        }\n        ps_col_mv = (col_mv_buf_t *)ih264_buf_mgr_get_next_free((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,\n                                                               &cur_mv_buf_id);\n        if(ps_col_mv == NULL)\n        {\n            ps_dec->i4_error_code = ERROR_UNAVAIL_MVBUF_T;\n            return ERROR_UNAVAIL_MVBUF_T;\n        }\n\n        ps_dec->ps_cur_pic = ps_cur_pic;\n        ps_dec->u1_pic_buf_id = cur_pic_buf_id;\n        ps_cur_pic->u4_ts = ps_dec->u4_ts;\n\n\n        ps_cur_pic->u1_mv_buf_id = cur_mv_buf_id;\n        ps_dec->au1_pic_buf_id_mv_buf_id_map[cur_pic_buf_id] = cur_mv_buf_id;\n\n        ps_cur_pic->pu1_col_zero_flag = (UWORD8 *)ps_col_mv->pv_col_zero_flag;\n        ps_cur_pic->ps_mv = (mv_pred_t *)ps_col_mv->pv_mv;\n        ps_dec->au1_pic_buf_ref_flag[cur_pic_buf_id] = 0;\n\n        {\n            /*make first entry of list0 point to cur pic,so that if first Islice is in error, ref pic struct will have valid entries*/\n            ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_init_dpb[0];\n            *(ps_dec->ps_dpb_mgr->ps_init_dpb[0][0]) = *ps_cur_pic;\n            /* Initialize for field reference as well */\n            *(ps_dec->ps_dpb_mgr->ps_init_dpb[0][MAX_REF_BUFS]) = *ps_cur_pic;\n        }\n\n        if(!ps_dec->ps_cur_pic)\n        {\n            WORD32 j;\n            H264_DEC_DEBUG_PRINT(\"------- Display Buffers Reset --------\\n\");\n            for(j = 0; j < MAX_DISP_BUFS_NEW; j++)\n            {\n\n                ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                      j,\n                                      BUF_MGR_REF);\n                ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,\n                                      ps_dec->au1_pic_buf_id_mv_buf_id_map[j],\n                                      BUF_MGR_REF);\n                ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                      j,\n                                      BUF_MGR_IO);\n            }\n\n            ps_dec->i4_cur_display_seq = 0;\n            ps_dec->i4_prev_max_display_seq = 0;\n            ps_dec->i4_max_poc = 0;\n\n            ps_cur_pic = (pic_buffer_t *)ih264_buf_mgr_get_next_free(\n                            (buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                            &cur_pic_buf_id);\n            if(ps_cur_pic == NULL)\n            {\n                ps_dec->i4_error_code = ERROR_UNAVAIL_PICBUF_T;\n                return ERROR_UNAVAIL_PICBUF_T;\n            }\n\n            ps_col_mv = (col_mv_buf_t *)ih264_buf_mgr_get_next_free((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,\n                                                                   &cur_mv_buf_id);\n            if(ps_col_mv == NULL)\n            {\n                ps_dec->i4_error_code = ERROR_UNAVAIL_MVBUF_T;\n                return ERROR_UNAVAIL_MVBUF_T;\n            }\n\n            ps_dec->ps_cur_pic = ps_cur_pic;\n            ps_dec->u1_pic_buf_id = cur_pic_buf_id;\n            ps_cur_pic->u4_ts = ps_dec->u4_ts;\n            ps_dec->apv_buf_id_pic_buf_map[cur_pic_buf_id] = (void *)ps_cur_pic;\n\n            ps_cur_pic->u1_mv_buf_id = cur_mv_buf_id;\n            ps_dec->au1_pic_buf_id_mv_buf_id_map[cur_pic_buf_id] = cur_mv_buf_id;\n\n            ps_cur_pic->pu1_col_zero_flag = (UWORD8 *)ps_col_mv->pv_col_zero_flag;\n            ps_cur_pic->ps_mv = (mv_pred_t *)ps_col_mv->pv_mv;\n            ps_dec->au1_pic_buf_ref_flag[cur_pic_buf_id] = 0;\n\n        }\n\n        ps_dec->ps_cur_pic->u1_picturetype = u1_field_pic_flag;\n        ps_dec->ps_cur_pic->u4_pack_slc_typ = SKIP_NONE;\n        H264_DEC_DEBUG_PRINT(\"got a buffer\\n\");\n    }\n    else\n    {\n        H264_DEC_DEBUG_PRINT(\"did not get a buffer\\n\");\n    }\n\n    ps_dec->u4_pic_buf_got = 1;\n\n    ps_dec->ps_cur_pic->i4_poc = i4_poc;\n    ps_dec->ps_cur_pic->i4_frame_num = u2_frame_num;\n    ps_dec->ps_cur_pic->i4_pic_num = u2_frame_num;\n    ps_dec->ps_cur_pic->i4_top_field_order_cnt = ps_pps->i4_top_field_order_cnt;\n    ps_dec->ps_cur_pic->i4_bottom_field_order_cnt =\n                    ps_pps->i4_bottom_field_order_cnt;\n    ps_dec->ps_cur_pic->i4_avg_poc = ps_pps->i4_avg_poc;\n    ps_dec->ps_cur_pic->u4_time_stamp = ps_dec->u4_pts;\n\n    ps_dec->s_cur_pic = *(ps_dec->ps_cur_pic);\n    if(u1_field_pic_flag && u1_bottom_field_flag)\n    {\n        WORD32 i4_temp_poc;\n        WORD32 i4_top_field_order_poc, i4_bot_field_order_poc;\n        /* Point to odd lines, since it's bottom field */\n        ps_dec->s_cur_pic.pu1_buf1 += ps_dec->s_cur_pic.u2_frm_wd_y;\n        ps_dec->s_cur_pic.pu1_buf2 += ps_dec->s_cur_pic.u2_frm_wd_uv;\n        ps_dec->s_cur_pic.pu1_buf3 += ps_dec->s_cur_pic.u2_frm_wd_uv;\n        ps_dec->s_cur_pic.ps_mv +=\n                        ((ps_dec->u2_pic_ht * ps_dec->u2_pic_wd) >> 5);\n        ps_dec->s_cur_pic.pu1_col_zero_flag += ((ps_dec->u2_pic_ht\n                        * ps_dec->u2_pic_wd) >> 5);\n        ps_dec->ps_cur_pic->u1_picturetype |= BOT_FLD;\n        i4_top_field_order_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;\n        i4_bot_field_order_poc = ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;\n        i4_temp_poc = MIN(i4_top_field_order_poc,\n                                 i4_bot_field_order_poc);\n        ps_dec->ps_cur_pic->i4_avg_poc = i4_temp_poc;\n    }\n\n    ps_cur_slice->u1_mbaff_frame_flag = ps_seq->u1_mb_aff_flag\n                    && (!u1_field_pic_flag);\n\n    ps_dec->ps_cur_pic->u1_picturetype |= (ps_cur_slice->u1_mbaff_frame_flag\n                    << 2);\n\n    ps_dec->ps_cur_mb_row = ps_dec->ps_nbr_mb_row; //[0];\n    ps_dec->ps_cur_mb_row++; //Increment by 1 ,so that left mb will always be valid\n    ps_dec->ps_top_mb_row =\n                    ps_dec->ps_nbr_mb_row\n                                    + ((ps_dec->u2_frm_wd_in_mbs + 1)\n                                                    << (1\n                                                                    - ps_dec->ps_cur_sps->u1_frame_mbs_only_flag));\n    ps_dec->ps_top_mb_row++; //Increment by 1 ,so that left mb will always be valid\n\n    ps_dec->pu1_y = ps_dec->pu1_y_scratch[0];\n    ps_dec->pu1_u = ps_dec->pu1_u_scratch[0];\n    ps_dec->pu1_v = ps_dec->pu1_v_scratch[0];\n    ps_dec->u1_yuv_scratch_idx = 0;\n    /* CHANGED CODE */\n    ps_dec->ps_mv_cur = ps_dec->s_cur_pic.ps_mv;\n    ps_dec->ps_mv_top = ps_dec->ps_mv_top_p[0];\n    /* CHANGED CODE */\n    ps_dec->u1_mv_top_p = 0;\n    ps_dec->u1_mb_idx = 0;\n    /* CHANGED CODE */\n    ps_dec->ps_mv_left = ps_dec->s_cur_pic.ps_mv;\n    ps_dec->pu1_yleft = 0;\n    ps_dec->pu1_uleft = 0;\n    ps_dec->pu1_vleft = 0;\n    ps_dec->u1_not_wait_rec = 2;\n    ps_dec->u2_total_mbs_coded = 0;\n    ps_dec->i4_submb_ofst = -(SUB_BLK_SIZE);\n    ps_dec->u4_pred_info_idx = 0;\n    ps_dec->u4_pred_info_pkd_idx = 0;\n    ps_dec->u4_dma_buf_idx = 0;\n    ps_dec->ps_mv = ps_dec->s_cur_pic.ps_mv;\n    ps_dec->ps_mv_bank_cur = ps_dec->s_cur_pic.ps_mv;\n    ps_dec->pu1_col_zero_flag = ps_dec->s_cur_pic.pu1_col_zero_flag;\n    ps_dec->ps_part = ps_dec->ps_parse_part_params;\n    ps_dec->i2_prev_slice_mbx = -1;\n    ps_dec->i2_prev_slice_mby = 0;\n    ps_dec->u2_mv_2mb[0] = 0;\n    ps_dec->u2_mv_2mb[1] = 0;\n    ps_dec->u1_last_pic_not_decoded = 0;\n\n    ps_dec->u2_cur_slice_num_dec_thread = 0;\n    ps_dec->u2_cur_slice_num_bs = 0;\n    ps_dec->u4_intra_pred_line_ofst = 0;\n    ps_dec->pu1_cur_y_intra_pred_line = ps_dec->pu1_y_intra_pred_line;\n    ps_dec->pu1_cur_u_intra_pred_line = ps_dec->pu1_u_intra_pred_line;\n    ps_dec->pu1_cur_v_intra_pred_line = ps_dec->pu1_v_intra_pred_line;\n\n    ps_dec->pu1_cur_y_intra_pred_line_base = ps_dec->pu1_y_intra_pred_line;\n    ps_dec->pu1_cur_u_intra_pred_line_base = ps_dec->pu1_u_intra_pred_line;\n    ps_dec->pu1_cur_v_intra_pred_line_base = ps_dec->pu1_v_intra_pred_line;\n\n\n\n\n\n    ps_dec->pu1_prev_y_intra_pred_line = ps_dec->pu1_y_intra_pred_line\n                    + (ps_dec->u2_frm_wd_in_mbs * MB_SIZE);\n\n    ps_dec->pu1_prev_u_intra_pred_line = ps_dec->pu1_u_intra_pred_line\n                    + ps_dec->u2_frm_wd_in_mbs * BLK8x8SIZE * YUV420SP_FACTOR;\n    ps_dec->pu1_prev_v_intra_pred_line = ps_dec->pu1_v_intra_pred_line\n                    + ps_dec->u2_frm_wd_in_mbs * BLK8x8SIZE;\n\n    ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic;\n    ps_dec->ps_deblk_mbn_curr = ps_dec->ps_deblk_mbn;\n    ps_dec->ps_deblk_mbn_prev = ps_dec->ps_deblk_mbn + ps_dec->u1_recon_mb_grp;\n    /* Initialize The Function Pointer Depending Upon the Entropy and MbAff Flag */\n    {\n        if(ps_cur_slice->u1_mbaff_frame_flag)\n        {\n            ps_dec->pf_compute_bs = ih264d_compute_bs_mbaff;\n            ps_dec->pf_mvpred = ih264d_mvpred_mbaff;\n        }\n        else\n        {\n            ps_dec->pf_compute_bs = ih264d_compute_bs_non_mbaff;\n            ps_dec->u1_cur_mb_fld_dec_flag = ps_cur_slice->u1_field_pic_flag;\n        }\n    }\n    /* Set up the Parameter for DMA transfer */\n    {\n        UWORD8 u1_field_pic_flag = ps_dec->ps_cur_slice->u1_field_pic_flag;\n\n        UWORD8 u1_mbaff = ps_cur_slice->u1_mbaff_frame_flag;\n\n        UWORD8 uc_lastmbs = (((ps_dec->u2_pic_wd) >> 4)\n                        % (ps_dec->u1_recon_mb_grp >> u1_mbaff));\n        UWORD16 ui16_lastmbs_widthY =\n                        (uc_lastmbs ? (uc_lastmbs << 4) : ((ps_dec->u1_recon_mb_grp\n                                        >> u1_mbaff) << 4));\n        UWORD16 ui16_lastmbs_widthUV =\n                        uc_lastmbs ? (uc_lastmbs << 3) : ((ps_dec->u1_recon_mb_grp\n                                        >> u1_mbaff) << 3);\n\n        ps_dec->s_tran_addrecon.pu1_dest_y = ps_dec->s_cur_pic.pu1_buf1;\n        ps_dec->s_tran_addrecon.pu1_dest_u = ps_dec->s_cur_pic.pu1_buf2;\n        ps_dec->s_tran_addrecon.pu1_dest_v = ps_dec->s_cur_pic.pu1_buf3;\n\n        ps_dec->s_tran_addrecon.u2_frm_wd_y = ps_dec->u2_frm_wd_y\n                        << u1_field_pic_flag;\n        ps_dec->s_tran_addrecon.u2_frm_wd_uv = ps_dec->u2_frm_wd_uv\n                        << u1_field_pic_flag;\n\n        if(u1_field_pic_flag)\n        {\n            ui16_lastmbs_widthY += ps_dec->u2_frm_wd_y;\n            ui16_lastmbs_widthUV += ps_dec->u2_frm_wd_uv;\n        }\n\n        /* Normal Increment of Pointer */\n        ps_dec->s_tran_addrecon.u4_inc_y[0] = ((ps_dec->u1_recon_mb_grp << 4)\n                        >> u1_mbaff);\n        ps_dec->s_tran_addrecon.u4_inc_uv[0] = ((ps_dec->u1_recon_mb_grp << 4)\n                        >> u1_mbaff);\n\n        /* End of Row Increment */\n        ps_dec->s_tran_addrecon.u4_inc_y[1] = (ui16_lastmbs_widthY\n                        + (PAD_LEN_Y_H << 1)\n                        + ps_dec->s_tran_addrecon.u2_frm_wd_y\n                                        * ((15 << u1_mbaff) + u1_mbaff));\n        ps_dec->s_tran_addrecon.u4_inc_uv[1] = (ui16_lastmbs_widthUV\n                        + (PAD_LEN_UV_H << 2)\n                        + ps_dec->s_tran_addrecon.u2_frm_wd_uv\n                                        * ((15 << u1_mbaff) + u1_mbaff));\n\n        /* Assign picture numbers to each frame/field  */\n        /* only once per picture.                      */\n        ih264d_assign_pic_num(ps_dec);\n        ps_dec->s_tran_addrecon.u2_mv_top_left_inc = (ps_dec->u1_recon_mb_grp\n                        << 2) - 1 - (u1_mbaff << 2);\n        ps_dec->s_tran_addrecon.u2_mv_left_inc = ((ps_dec->u1_recon_mb_grp\n                        >> u1_mbaff) - 1) << (4 + u1_mbaff);\n    }\n    /**********************************************************************/\n    /* High profile related initialization at pictrue level               */\n    /**********************************************************************/\n    if(ps_seq->u1_profile_idc == HIGH_PROFILE_IDC)\n    {\n        if((ps_seq->i4_seq_scaling_matrix_present_flag)\n                        || (ps_pps->i4_pic_scaling_matrix_present_flag))\n        {\n            ih264d_form_scaling_matrix_picture(ps_seq, ps_pps, ps_dec);\n            ps_dec->s_high_profile.u1_scaling_present = 1;\n        }\n        else\n        {\n            ih264d_form_default_scaling_matrix(ps_dec);\n        }\n\n        if(ps_pps->i4_transform_8x8_mode_flag)\n        {\n            ps_dec->s_high_profile.u1_transform8x8_present = 1;\n        }\n    }\n    else\n    {\n        ih264d_form_default_scaling_matrix(ps_dec);\n    }\n\n    /* required while reading the transform_size_8x8 u4_flag */\n    ps_dec->s_high_profile.u1_direct_8x8_inference_flag =\n                    ps_seq->u1_direct_8x8_inference_flag;\n    ps_dec->s_high_profile.s_cavlc_ctxt = ps_dec->s_cavlc_ctxt;\n\n    ps_dec->i1_recon_in_thread3_flag = 1;\n    ps_dec->ps_frame_buf_ip_recon = &ps_dec->s_tran_addrecon;\n    if(ps_dec->u1_separate_parse)\n    {\n        memcpy(&ps_dec->s_tran_addrecon_parse, &ps_dec->s_tran_addrecon,\n               sizeof(tfr_ctxt_t));\n        if(ps_dec->u4_num_cores >= 3 && ps_dec->i1_recon_in_thread3_flag)\n        {\n            memcpy(&ps_dec->s_tran_iprecon, &ps_dec->s_tran_addrecon,\n                   sizeof(tfr_ctxt_t));\n            ps_dec->ps_frame_buf_ip_recon = &ps_dec->s_tran_iprecon;\n        }\n    }\n\n\n    ih264d_init_deblk_tfr_ctxt(ps_dec,&(ps_dec->s_pad_mgr), &(ps_dec->s_tran_addrecon),\n                               ps_dec->u2_frm_wd_in_mbs, 0);\n\n    ps_dec->ps_cur_deblk_mb = ps_dec->ps_deblk_pic;\n    ps_dec->u4_cur_deblk_mb_num = 0;\n\n    ps_dec->u4_deblk_mb_x = 0;\n    ps_dec->u4_deblk_mb_y = 0;\n    ps_dec->pu4_wt_ofsts = ps_dec->pu4_wts_ofsts_mat;\n\n    H264_MUTEX_UNLOCK(&ps_dec->process_disp_mutex);\n    return OK;\n}", "target": 2, "idx": 10279}
{"commit_id": "b5ed738f8060266bf4ae521f7e3ed145aa4498a3", "project": "ImageMagick", "func": "MagickExport MagickBooleanType SetQuantumDepth(const Image *image,\n  QuantumInfo *quantum_info,const size_t depth)\n{\n  size_t\n    extent,\n    quantum;\n\n  /*\n    Allocate the quantum pixel buffer.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickSignature);\n  quantum_info->depth=depth;\n  if (quantum_info->format == FloatingPointQuantumFormat)\n    {\n      if (quantum_info->depth > 32)\n        quantum_info->depth=64;\n      else\n        if (quantum_info->depth > 16)\n          quantum_info->depth=32;\n        else\n          quantum_info->depth=16;\n    }\n  if (quantum_info->pixels != (unsigned char **) NULL)\n    DestroyQuantumPixels(quantum_info);\n  quantum=(quantum_info->pad+6)*(quantum_info->depth+7)/8;\n  extent=image->columns*quantum;\n  if ((image->columns != 0) && (quantum != (extent/image->columns)))\n    return(MagickFalse);\n  return(AcquireQuantumPixels(quantum_info,extent));\n}", "target": 1, "idx": 10280}
{"commit_id": "3bcd6c7eaa53", "project": "torvalds/linux", "func": "void rxrpc_put_bundle(struct rxrpc_bundle *bundle)\n{\n\tunsigned int d = bundle->debug_id;\n\tbool dead;\n\tint r;\n\n\tdead = __refcount_dec_and_test(&bundle->ref, &r);\n\n\t_debug(\"PUT B=%x %d\", d, r - 1);\n\tif (dead)\n\t\trxrpc_free_bundle(bundle);\n}", "target": 2, "idx": 10281}
{"commit_id": "419782d3d16e88cfa0695aa0b86c956352846712", "project": "memononen/nanosvg", "func": "static unsigned int nsvg__parseColorHex(const char* str)\n{\n\tunsigned int r=0, g=0, b=0;\n\tif (sscanf(str, \"#%2x%2x%2x\", &r, &g, &b) == 3 )\t\t// 2 digit hex\n\t\treturn NSVG_RGB(r, g, b);\n\tif (sscanf(str, \"#%1x%1x%1x\", &r, &g, &b) == 3 )\t\t// 1 digit hex, e.g. #abc -> 0xccbbaa\n\t\treturn NSVG_RGB(r*17, g*17, b*17);\t\t\t// same effect as (r<<4|r), (g<<4|g), ..\n\treturn NSVG_RGB(128, 128, 128);\n}", "target": 1, "idx": 10282}
{"commit_id": "f6c5c618236709f5b76425d9cd407a27dc49f4ba", "project": "justdan96/tsMuxer", "func": "int HevcVpsUnit::deserialize()\n{\n    int rez = HevcUnit::deserialize();\n    if (rez)\n        return rez;\n\n    if (m_reader.getBitsLeft() < 128)\n        return NOT_ENOUGH_BUFFER;\n\n    try\n    {\n        vps_id = m_reader.getBits(4);\n        m_reader.skipBits(2);  // reserved\n        vps_max_layers = m_reader.getBits(6) + 1;\n        vps_max_sub_layers = m_reader.getBits(3) + 1;\n        int vps_temporal_id_nesting_flag = m_reader.getBit();\n        m_reader.skipBits(16);  // reserved\n        profile_tier_level(vps_max_sub_layers);\n\n        bool vps_sub_layer_ordering_info_present_flag = m_reader.getBit();\n        for (int i = (vps_sub_layer_ordering_info_present_flag ? 0 : vps_max_sub_layers - 1);\n             i <= vps_max_sub_layers - 1; i++)\n        {\n            unsigned vps_max_dec_pic_buffering_minus1 = extractUEGolombCode();\n            unsigned vps_max_num_reorder_pics = extractUEGolombCode();\n            if (vps_max_num_reorder_pics > vps_max_dec_pic_buffering_minus1)\n                return 1;\n            unsigned vps_max_latency_increase_plus1 = extractUEGolombCode();\n            if (vps_max_latency_increase_plus1 == 0xffffffff)\n                return 1;\n        }\n        int vps_max_layer_id = m_reader.getBits(6);\n        unsigned vps_num_layer_sets_minus1 = extractUEGolombCode();\n        if (vps_num_layer_sets_minus1 > 1023)\n            return 1;\n        for (size_t i = 1; i <= vps_num_layer_sets_minus1; i++)\n        {\n            for (int j = 0; j <= vps_max_layer_id; j++) m_reader.skipBit();  // layer_id_included_flag[ i ][ j ] u(1)\n        }\n        bool vps_timing_info_present_flag = m_reader.getBit();\n        if (vps_timing_info_present_flag)\n        {\n            num_units_in_tick_bit_pos = m_reader.getBitsCount();\n            num_units_in_tick = m_reader.getBits(32);\n            time_scale = m_reader.getBits(32);\n        }\n\n        return rez;\n    }\n    catch (VodCoreException& e)\n    {\n        return NOT_ENOUGH_BUFFER;\n    }\n}", "target": 1, "idx": 10283}
{"commit_id": "03a8c630f015f63268639d3ed3bf82cff6fa77d8", "project": "zherczeg/jerryscript", "func": "static void\nlexer_process_char_literal (parser_context_t *context_p, /**< context */\n                            const uint8_t *char_p, /**< characters */\n                            size_t length, /**< length of string */\n                            uint8_t literal_type, /**< final literal type */\n                            bool has_escape) /**< has escape sequences */\n{\n  parser_list_iterator_t literal_iterator;\n  lexer_literal_t *literal_p;\n  uint32_t literal_index = 0;\n\n  JERRY_ASSERT (literal_type == LEXER_IDENT_LITERAL\n                || literal_type == LEXER_STRING_LITERAL);\n\n  JERRY_ASSERT (literal_type != LEXER_IDENT_LITERAL || length <= PARSER_MAXIMUM_IDENT_LENGTH);\n  JERRY_ASSERT (literal_type != LEXER_STRING_LITERAL || length <= PARSER_MAXIMUM_STRING_LENGTH);\n\n  parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);\n\n  while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)) != NULL)\n  {\n    if (literal_p->type == literal_type\n        && literal_p->prop.length == length\n        && memcmp (literal_p->u.char_p, char_p, length) == 0)\n    {\n      context_p->lit_object.literal_p = literal_p;\n      context_p->lit_object.index = (uint16_t) literal_index;\n      literal_p->status_flags = (uint8_t) (literal_p->status_flags & ~LEXER_FLAG_UNUSED_IDENT);\n      return;\n    }\n\n    literal_index++;\n  }\n\n  JERRY_ASSERT (literal_index == context_p->literal_count);\n\n  if (literal_index >= PARSER_MAXIMUM_NUMBER_OF_LITERALS)\n  {\n    parser_raise_error (context_p, PARSER_ERR_LITERAL_LIMIT_REACHED);\n  }\n\n  if (length == 0)\n  {\n    has_escape = false;\n  }\n\n  literal_p = (lexer_literal_t *) parser_list_append (context_p, &context_p->literal_pool);\n  literal_p->prop.length = (uint16_t) length;\n  literal_p->type = literal_type;\n  literal_p->status_flags = has_escape ? 0 : LEXER_FLAG_SOURCE_PTR;\n\n  if (has_escape)\n  {\n    literal_p->u.char_p = (uint8_t *) jmem_heap_alloc_block (length);\n    memcpy ((uint8_t *) literal_p->u.char_p, char_p, length);\n  }\n  else\n  {\n    literal_p->u.char_p = char_p;\n  }\n\n  context_p->lit_object.literal_p = literal_p;\n  context_p->lit_object.index = (uint16_t) literal_index;\n  context_p->literal_count++;\n}", "target": 2, "idx": 10284}
{"commit_id": "7142d2c37d58cf024595a7549f0fb0d3946682f8", "project": "libreswan", "func": "void send_v2N_spi_response_from_state(struct ike_sa *ike,\n\t\t\t\t      struct msg_digest *md,\n\t\t\t\t      enum ikev2_sec_proto_id protoid,\n\t\t\t\t      ipsec_spi_t *spi,\n\t\t\t\t      v2_notification_t ntype,\n\t\t\t\t      const chunk_t *ndata /* optional */)\n{\n\tpassert(v2_msg_role(md) == MESSAGE_REQUEST); /* always responding */\n\tconst char *const notify_name = enum_short_name(&ikev2_notify_names, ntype);\n\n\tenum isakmp_xchg_types exchange_type = md->hdr.isa_xchg;\n\tconst char *const exchange_name = enum_short_name(&ikev2_exchange_names, exchange_type);\n\n\tif (!IS_IKE_SA_ESTABLISHED(md->st)) { /* XXX Andrew? how to dig into ike_sa ike ? */\n\t\tloglog(RC_LOG_SERIOUS, \"unable to respond to exchange type %s message with encrypted notification because there is no established IKE SA\",\n\t\t\texchange_name);\n\t\treturn;\n\t}\n\t/*\n\t * For encrypted messages, the EXCHANGE TYPE can't be SA_INIT.\n\t * And the IKE SA must have been established\n\t */\n\tswitch (exchange_type) {\n\tcase ISAKMP_v2_IKE_SA_INIT:\n\tcase ISAKMP_v2_IKE_AUTH:\n\t\tloglog(RC_LOG_SERIOUS, \"exchange type %s invalid for encrypted notification\",\n\t\t\t    exchange_name);\n\t\treturn;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tipstr_buf b;\n\tlibreswan_log(\"responding to %s message (ID %u) from %s:%u with encrypted notification %s\",\n\t\t      exchange_name, md->hdr.isa_msgid,\n\t\t      sensitive_ipstr(&ike->sa.st_remoteaddr, &b),\n\t\t      ike->sa.st_remoteport,\n\t\t      notify_name);\n\n\tuint8_t buf[MIN_OUTPUT_UDP_SIZE];\n\tpb_stream reply = open_out_pbs(\"encrypted notification\",\n\t\t\t\t       buf, sizeof(buf));\n\n\tpb_stream rbody = open_v2_message(&reply, ike,\n\t\t\t\t\t  md /* response */,\n\t\t\t\t\t  exchange_type);\n\tif (!pbs_ok(&rbody)) {\n\t\tlibreswan_log(\"error initializing hdr for encrypted notification\");\n\t\treturn;\n\t}\n\n\tv2SK_payload_t sk = open_v2SK_payload(&rbody, ike);\n\tif (!pbs_ok(&sk.pbs)) {\n\t\treturn;\n\t}\n\n\t/* actual data */\n\n\t/*\n\t * 3.10.  Notify Payload: Of the notifications defined in this\n\t * document, the SPI is included only with INVALID_SELECTORS,\n\t * REKEY_SA, and CHILD_SA_NOT_FOUND.\n\t*/\n\tswitch (ntype) {\n\tcase v2N_INVALID_SELECTORS:\n\t\t/*\n\t\t * MAY be sent in an IKE INFORMATIONAL exchange when a\n\t\t * node receives an ESP or AH packet whose selectors\n\t\t * do not match those of the SA on which it was\n\t\t * delivered (and that caused the packet to be\n\t\t * dropped).  The Notification Data contains the start\n\t\t * of the offending packet (as in ICMP messages) and\n\t\t * the SPI field of the notification is set to match\n\t\t * the SPI of the Child SA.\n\t\t*/\n\t\tPEXPECT_LOG(\"trying to send unimplemented %s notification\",\n\t\t\t    notify_name);\n\t\treturn;\n\tcase v2N_REKEY_SA:\n\t\tPEXPECT_LOG(\"%s notification cannot be part of a response\",\n\t\t\t    notify_name);\n\t\treturn;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tpb_stream n_pbs;\n\tif (!emit_v2Nsa_pl(ntype, protoid, spi, &sk.pbs, &n_pbs) ||\n\t    (ndata != NULL && !out_chunk(*ndata, &n_pbs, \"Notify data\"))) {\n\t\treturn;\n\t}\n\tclose_output_pbs(&n_pbs);\n\n\tif (!close_v2SK_payload(&sk)) {\n\t\treturn;\n\t}\n\tclose_output_pbs(&rbody);\n\tclose_output_pbs(&reply);\n\n\tstf_status ret = encrypt_v2SK_payload(&sk);\n\tif (ret != STF_OK) {\n\t\tlibreswan_log(\"error encrypting notify message\");\n\t\treturn;\n\t}\n\n\t/*\n\t * The notification is piggybacked on the existing parent\n\t * state.  This notification is fire-and-forget (not a proper\n\t * exchange, one with retrying).  So we need not preserve the\n\t * packet we are sending.\n\t *\n\t * XXX: this sounds wrong!  Integrity has been established so\n\t * the outgoing packet should be retained and message counters\n\t * updated.  If ST is going to be 'deleted', then, wouldn't it\n\t * be better to have it linger a little so it can handle\n\t * duplicates cleanly.\n\t */\n\tsend_chunk_using_state(&ike->sa, \"v2 notify\", same_out_pbs_as_chunk(&reply));\n\tpstat(ikev2_sent_notifies_e, ntype);\n}", "target": 2, "idx": 10285}
{"commit_id": "321ba1de287016b0036bf4a56ce774ad11763384", "project": "ArtifexSoftware/mupdf", "func": "void pdf_set_signature_appearance(fz_context *ctx, pdf_document *doc, pdf_annot *annot, char *name, const char *dn, char *date)\n{\n\tpdf_obj *obj = annot->obj;\n\tpdf_obj *dr = pdf_dict_getl(ctx, pdf_trailer(ctx, doc), PDF_NAME_Root, PDF_NAME_AcroForm, PDF_NAME_DR, NULL);\n\tfz_display_list *dlist = NULL;\n\tfz_device *dev = NULL;\n\tfont_info font_rec;\n\tfz_text *text = NULL;\n\tfz_path *path = NULL;\n\tfz_buffer *fzbuf = NULL;\n\tfz_matrix page_ctm;\n\n\tpdf_page_transform(ctx, annot->page, NULL, &page_ctm);\n\n\tif (!dr)\n\t\tpdf_dict_putl_drop(ctx, pdf_trailer(ctx, doc), pdf_new_dict(ctx, doc, 1), PDF_NAME_Root, PDF_NAME_AcroForm, PDF_NAME_DR, NULL);\n\n\tmemset(&font_rec, 0, sizeof(font_rec));\n\n\tfz_var(path);\n\tfz_var(dlist);\n\tfz_var(dev);\n\tfz_var(text);\n\tfz_var(fzbuf);\n\tfz_try(ctx)\n\t{\n\t\tchar *da = pdf_to_str_buf(ctx, pdf_dict_get(ctx, obj, PDF_NAME_DA));\n\t\tfz_rect annot_rect;\n\t\tfz_rect logo_bounds;\n\t\tfz_matrix logo_tm;\n\t\tfz_rect rect;\n\t\tfz_colorspace *cs = fz_device_rgb(ctx); /* Borrowed reference */\n\n\t\tpdf_to_rect(ctx, pdf_dict_get(ctx, annot->obj, PDF_NAME_Rect), &annot_rect);\n\t\trect = annot_rect;\n\n\t\tdlist = fz_new_display_list(ctx, NULL);\n\t\tdev = fz_new_list_device(ctx, dlist);\n\n\t\tpath = fz_new_path(ctx);\n\t\tdraw_logo(ctx, path);\n\t\tfz_bound_path(ctx, path, NULL, &fz_identity, &logo_bounds);\n\t\tcenter_rect_within_rect(&logo_bounds, &rect, &logo_tm);\n\t\tfz_concat(&logo_tm, &logo_tm, &page_ctm);\n\t\tfz_fill_path(ctx, dev, path, 0, &logo_tm, cs, logo_color, 1.0f, NULL);\n\n\t\tget_font_info(ctx, doc, dr, da, &font_rec);\n\n\t\tswitch (font_rec.da_rec.col_size)\n\t\t{\n\t\tcase 1: cs = fz_device_gray(ctx); break;\n\t\tcase 3: cs = fz_device_rgb(ctx); break;\n\t\tcase 4: cs = fz_device_cmyk(ctx); break;\n\t\t}\n\n\t\t/* Display the name in the left-hand half of the form field */\n\t\trect.x1 = (rect.x0 + rect.x1)/2.0f;\n\t\ttext = fit_text(ctx, &font_rec, name, &rect);\n\t\tfz_fill_text(ctx, dev, text, &page_ctm, cs, font_rec.da_rec.col, 1.0f, NULL);\n\t\tfz_drop_text(ctx, text);\n\t\ttext = NULL;\n\n\t\t/* Display the distinguished name in the right-hand half */\n\t\tfzbuf = fz_new_buffer(ctx, 256);\n\t\tfz_append_printf(ctx, fzbuf, \"Digitally signed by %s\", name);\n\t\tfz_append_printf(ctx, fzbuf, \"\\nDN: %s\", dn);\n\t\tif (date)\n\t\t\tfz_append_printf(ctx, fzbuf, \"\\nDate: %s\", date);\n\t\trect = annot_rect;\n\t\trect.x0 = (rect.x0 + rect.x1)/2.0f;\n\t\ttext = fit_text(ctx, &font_rec, fz_string_from_buffer(ctx, fzbuf), &rect);\n\t\tfz_fill_text(ctx, dev, text, &page_ctm, cs, font_rec.da_rec.col, 1.0f, NULL);\n\n\t\tfz_close_device(ctx, dev);\n\n\t\trect = annot_rect;\n\t\tfz_transform_rect(&rect, &page_ctm);\n\t\tpdf_set_annot_appearance(ctx, doc, annot, &rect, dlist);\n\n\t\t/* Drop the cached xobject from the annotation structure to\n\t\t * force a redraw on next pdf_update_page call */\n\t\tpdf_drop_xobject(ctx, annot->ap);\n\t\tannot->ap = NULL;\n\n\t\tinsert_signature_appearance_layers(ctx, doc, annot);\n\t}\n\tfz_always(ctx)\n\t{\n\t\tfz_drop_device(ctx, dev);\n\t\tfz_drop_display_list(ctx, dlist);\n\t\tfont_info_fin(ctx, &font_rec);\n\t\tfz_drop_path(ctx, path);\n\t\tfz_drop_text(ctx, text);\n\t\tfz_drop_buffer(ctx, fzbuf);\n\t}\n\tfz_catch(ctx)\n\t{\n\t\tfz_rethrow(ctx);\n\t}\n}", "target": 2, "idx": 10286}
{"commit_id": "701b518d5c56a1449825a3a37a716c58e05e1c3e", "project": "qpdf", "func": "PointerHolder<QPDFObject>\nQPDF::resolve(int objid, int generation)\n{\n    // Check object cache before checking xref table.  This allows us\n    // to insert things into the object cache that don't actually\n    // exist in the file.\n    QPDFObjGen og(objid, generation);\n    if (this->resolving.count(og))\n    {\n        // This can happen if an object references itself directly or\n        // indirectly in some key that has to be resolved during\n        // object parsing, such as stream length.\n\tQTC::TC(\"qpdf\", \"QPDF recursion loop in resolve\");\n\twarn(QPDFExc(qpdf_e_damaged_pdf, this->file->getName(),\n\t\t     \"\", this->file->getLastOffset(),\n\t\t     \"loop detected resolving object \" +\n\t\t     QUtil::int_to_string(objid) + \" \" +\n\t\t     QUtil::int_to_string(generation)));\n        return new QPDF_Null;\n    }\n    ResolveRecorder rr(this, og);\n\n    if (! this->obj_cache.count(og))\n    {\n\tif (! this->xref_table.count(og))\n\t{\n\t    // PDF spec says unknown objects resolve to the null object.\n\t    return new QPDF_Null;\n\t}\n\n\tQPDFXRefEntry const& entry = this->xref_table[og];\n\tswitch (entry.getType())\n\t{\n\t  case 1:\n\t    {\n\t\tqpdf_offset_t offset = entry.getOffset();\n\t\t// Object stored in cache by readObjectAtOffset\n\t\tint aobjid;\n\t\tint ageneration;\n\t\tQPDFObjectHandle oh =\n\t\t    readObjectAtOffset(true, offset, \"\", objid, generation,\n\t\t\t\t       aobjid, ageneration);\n\t    }\n\t    break;\n\n\t  case 2:\n\t    resolveObjectsInStream(entry.getObjStreamNumber());\n\t    break;\n\n\t  default:\n\t    throw QPDFExc(qpdf_e_damaged_pdf, this->file->getName(), \"\", 0,\n\t\t\t  \"object \" +\n\t\t\t  QUtil::int_to_string(objid) + \"/\" +\n\t\t\t  QUtil::int_to_string(generation) +\n\t\t\t  \" has unexpected xref entry type\");\n\t}\n    }\n\n    return this->obj_cache[og].object;\n}", "target": 1, "idx": 10287}
{"commit_id": "73c5fff899f253c44a72657048aec7db6edee571", "project": "wireshark", "func": "static int\nwg_dissect_handshake_response(tvbuff_t *tvb, packet_info *pinfo, proto_tree *wg_tree, wg_packet_info_t *wg_pinfo)\n{\n    guint32 sender_id, receiver_id;\n    proto_item *ti;\n    wg_session_t *session;\n\n#ifdef WG_DECRYPTION_SUPPORTED\n    wg_keylog_read();\n    const wg_skey_t *skey_i = wg_mac1_key_probe(tvb, FALSE);\n#endif /* WG_DECRYPTION_SUPPORTED */\n\n    proto_tree_add_item_ret_uint(wg_tree, hf_wg_sender, tvb, 4, 4, ENC_LITTLE_ENDIAN, &sender_id);\n    col_append_fstr(pinfo->cinfo, COL_INFO, \", sender=0x%08X\", sender_id);\n    proto_tree_add_item_ret_uint(wg_tree, hf_wg_receiver, tvb, 8, 4, ENC_LITTLE_ENDIAN, &receiver_id);\n    col_append_fstr(pinfo->cinfo, COL_INFO, \", receiver=0x%08X\", receiver_id);\n\n    if (!PINFO_FD_VISITED(pinfo)) {\n        session = wg_sessions_lookup_initiation(pinfo, receiver_id);\n#ifdef WG_DECRYPTION_SUPPORTED\n        if (session && session->hs) {\n            wg_prepare_handshake_responder_keys(session->hs, tvb);\n            wg_process_response(tvb, session->hs);\n        }\n#endif /* WG_DECRYPTION_SUPPORTED */\n    } else {\n        session = wg_pinfo ? wg_pinfo->session : NULL;\n    }\n\n    wg_dissect_pubkey(wg_tree, tvb, 12, TRUE);\n    proto_tree_add_item(wg_tree, hf_wg_encrypted_empty, tvb, 44, 16, ENC_NA);\n#ifdef WG_DECRYPTION_SUPPORTED\n    if (session && session->hs) {\n        ti = proto_tree_add_boolean(wg_tree, hf_wg_handshake_ok, tvb, 0, 0, !!session->hs->empty_ok);\n        proto_item_set_generated(ti);\n    }\n#endif /* WG_DECRYPTION_SUPPORTED */\n    proto_tree_add_item(wg_tree, hf_wg_mac1, tvb, 60, 16, ENC_NA);\n#ifdef WG_DECRYPTION_SUPPORTED\n    wg_dissect_mac1_pubkey(wg_tree, tvb, skey_i);\n#endif /* WG_DECRYPTION_SUPPORTED */\n    proto_tree_add_item(wg_tree, hf_wg_mac2, tvb, 76, 16, ENC_NA);\n\n    if (!PINFO_FD_VISITED(pinfo)) {\n        /* XXX should probably check whether decryption succeeds before linking\n         * and somehow mark that this response is related but not correct. */\n        if (session) {\n            session->response_frame = pinfo->num;\n            wg_session_update_address(session, pinfo, FALSE);\n            wg_sessions_insert(sender_id, session);\n            wg_pinfo->session = session;\n        }\n    }\n    if (session) {\n        ti = proto_tree_add_uint(wg_tree, hf_wg_stream, tvb, 0, 0, session->stream);\n        proto_item_set_generated(ti);\n        ti = proto_tree_add_uint(wg_tree, hf_wg_response_to, tvb, 0, 0, session->initiator_frame);\n        proto_item_set_generated(ti);\n    }\n\n    return 92;\n}", "target": 2, "idx": 10288}
{"commit_id": "6b67d7f05918f7a1ee8fc6ff21355d7e8736aa10", "project": "ffmpeg", "func": "static int flv_write_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    AVIOContext *pb      = s->pb;\n    AVCodecParameters *par = s->streams[pkt->stream_index]->codecpar;\n    FLVContext *flv      = s->priv_data;\n    FLVStreamContext *sc = s->streams[pkt->stream_index]->priv_data;\n    unsigned ts;\n    int size = pkt->size;\n    uint8_t *data = NULL;\n    int flags = -1, flags_size, ret;\n    int64_t cur_offset = avio_tell(pb);\n\n    if (par->codec_type == AVMEDIA_TYPE_AUDIO && !pkt->size) {\n        av_log(s, AV_LOG_WARNING, \"Empty audio Packet\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    if (par->codec_id == AV_CODEC_ID_VP6F || par->codec_id == AV_CODEC_ID_VP6A ||\n        par->codec_id == AV_CODEC_ID_VP6  || par->codec_id == AV_CODEC_ID_AAC)\n        flags_size = 2;\n    else if (par->codec_id == AV_CODEC_ID_H264 || par->codec_id == AV_CODEC_ID_MPEG4)\n        flags_size = 5;\n    else\n        flags_size = 1;\n\n    if (par->codec_id == AV_CODEC_ID_AAC || par->codec_id == AV_CODEC_ID_H264\n            || par->codec_id == AV_CODEC_ID_MPEG4) {\n        int side_size = 0;\n        uint8_t *side = av_packet_get_side_data(pkt, AV_PKT_DATA_NEW_EXTRADATA, &side_size);\n        if (side && side_size > 0 && (side_size != par->extradata_size || memcmp(side, par->extradata, side_size))) {\n            av_free(par->extradata);\n            par->extradata = av_mallocz(side_size + AV_INPUT_BUFFER_PADDING_SIZE);\n            if (!par->extradata) {\n                par->extradata_size = 0;\n                return AVERROR(ENOMEM);\n            }\n            memcpy(par->extradata, side, side_size);\n            par->extradata_size = side_size;\n            flv_write_codec_header(s, par, pkt->dts);\n        }\n    }\n\n    if (flv->delay == AV_NOPTS_VALUE)\n        flv->delay = -pkt->dts;\n\n    if (pkt->dts < -flv->delay) {\n        av_log(s, AV_LOG_WARNING,\n               \"Packets are not in the proper order with respect to DTS\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    ts = pkt->dts;\n\n    if (s->event_flags & AVSTREAM_EVENT_FLAG_METADATA_UPDATED) {\n        write_metadata(s, ts);\n        s->event_flags &= ~AVSTREAM_EVENT_FLAG_METADATA_UPDATED;\n    }\n\n    avio_write_marker(pb, av_rescale(ts, AV_TIME_BASE, 1000),\n                      pkt->flags & AV_PKT_FLAG_KEY && (flv->video_par ? par->codec_type == AVMEDIA_TYPE_VIDEO : 1) ? AVIO_DATA_MARKER_SYNC_POINT : AVIO_DATA_MARKER_BOUNDARY_POINT);\n\n    switch (par->codec_type) {\n    case AVMEDIA_TYPE_VIDEO:\n        avio_w8(pb, FLV_TAG_TYPE_VIDEO);\n\n        flags = ff_codec_get_tag(flv_video_codec_ids, par->codec_id);\n\n        flags |= pkt->flags & AV_PKT_FLAG_KEY ? FLV_FRAME_KEY : FLV_FRAME_INTER;\n        break;\n    case AVMEDIA_TYPE_AUDIO:\n        flags = get_audio_flags(s, par);\n\n        av_assert0(size);\n\n        avio_w8(pb, FLV_TAG_TYPE_AUDIO);\n        break;\n    case AVMEDIA_TYPE_SUBTITLE:\n    case AVMEDIA_TYPE_DATA:\n        avio_w8(pb, FLV_TAG_TYPE_META);\n        break;\n    default:\n        return AVERROR(EINVAL);\n    }\n\n    if (par->codec_id == AV_CODEC_ID_H264 || par->codec_id == AV_CODEC_ID_MPEG4) {\n        /* check if extradata looks like mp4 formatted */\n        if (par->extradata_size > 0 && *(uint8_t*)par->extradata != 1)\n            if ((ret = ff_avc_parse_nal_units_buf(pkt->data, &data, &size)) < 0)\n                return ret;\n    } else if (par->codec_id == AV_CODEC_ID_AAC && pkt->size > 2 &&\n               (AV_RB16(pkt->data) & 0xfff0) == 0xfff0) {\n        if (!s->streams[pkt->stream_index]->nb_frames) {\n        av_log(s, AV_LOG_ERROR, \"Malformed AAC bitstream detected: \"\n               \"use the audio bitstream filter 'aac_adtstoasc' to fix it \"\n               \"('-bsf:a aac_adtstoasc' option with ffmpeg)\\n\");\n        return AVERROR_INVALIDDATA;\n        }\n        av_log(s, AV_LOG_WARNING, \"aac bitstream error\\n\");\n    }\n\n    /* check Speex packet duration */\n    if (par->codec_id == AV_CODEC_ID_SPEEX && ts - sc->last_ts > 160)\n        av_log(s, AV_LOG_WARNING, \"Warning: Speex stream has more than \"\n                                  \"8 frames per packet. Adobe Flash \"\n                                  \"Player cannot handle this!\\n\");\n\n    if (sc->last_ts < ts)\n        sc->last_ts = ts;\n\n    if (size + flags_size >= 1<<24) {\n        av_log(s, AV_LOG_ERROR, \"Too large packet with size %u >= %u\\n\",\n               size + flags_size, 1<<24);\n        return AVERROR(EINVAL);\n    }\n\n    avio_wb24(pb, size + flags_size);\n    put_timestamp(pb, ts);\n    avio_wb24(pb, flv->reserved);\n\n    if (par->codec_type == AVMEDIA_TYPE_DATA ||\n        par->codec_type == AVMEDIA_TYPE_SUBTITLE ) {\n        int data_size;\n        int64_t metadata_size_pos = avio_tell(pb);\n        if (par->codec_id == AV_CODEC_ID_TEXT) {\n            // legacy FFmpeg magic?\n            avio_w8(pb, AMF_DATA_TYPE_STRING);\n            put_amf_string(pb, \"onTextData\");\n            avio_w8(pb, AMF_DATA_TYPE_MIXEDARRAY);\n            avio_wb32(pb, 2);\n            put_amf_string(pb, \"type\");\n            avio_w8(pb, AMF_DATA_TYPE_STRING);\n            put_amf_string(pb, \"Text\");\n            put_amf_string(pb, \"text\");\n            avio_w8(pb, AMF_DATA_TYPE_STRING);\n            put_amf_string(pb, pkt->data);\n            put_amf_string(pb, \"\");\n            avio_w8(pb, AMF_END_OF_OBJECT);\n        } else {\n            // just pass the metadata through\n            avio_write(pb, data ? data : pkt->data, size);\n        }\n        /* write total size of tag */\n        data_size = avio_tell(pb) - metadata_size_pos;\n        avio_seek(pb, metadata_size_pos - 10, SEEK_SET);\n        avio_wb24(pb, data_size);\n        avio_seek(pb, data_size + 10 - 3, SEEK_CUR);\n        avio_wb32(pb, data_size + 11);\n    } else {\n        av_assert1(flags>=0);\n        avio_w8(pb,flags);\n        if (par->codec_id == AV_CODEC_ID_VP6)\n            avio_w8(pb,0);\n        if (par->codec_id == AV_CODEC_ID_VP6F || par->codec_id == AV_CODEC_ID_VP6A) {\n            if (par->extradata_size)\n                avio_w8(pb, par->extradata[0]);\n            else\n                avio_w8(pb, ((FFALIGN(par->width,  16) - par->width) << 4) |\n                             (FFALIGN(par->height, 16) - par->height));\n        } else if (par->codec_id == AV_CODEC_ID_AAC)\n            avio_w8(pb, 1); // AAC raw\n        else if (par->codec_id == AV_CODEC_ID_H264 || par->codec_id == AV_CODEC_ID_MPEG4) {\n            avio_w8(pb, 1); // AVC NALU\n            avio_wb24(pb, pkt->pts - pkt->dts);\n        }\n\n        avio_write(pb, data ? data : pkt->data, size);\n\n        avio_wb32(pb, size + flags_size + 11); // previous tag size\n        flv->duration = FFMAX(flv->duration,\n                              pkt->pts + flv->delay + pkt->duration);\n    }\n\n    if (flv->flags & FLV_ADD_KEYFRAME_INDEX) {\n        switch (par->codec_type) {\n            case AVMEDIA_TYPE_VIDEO:\n                flv->videosize += (avio_tell(pb) - cur_offset);\n                flv->lasttimestamp = flv->acurframeindex / flv->framerate;\n                if (pkt->flags & AV_PKT_FLAG_KEY) {\n                    double ts = flv->acurframeindex / flv->framerate;\n                    int64_t pos = cur_offset;\n\n                    flv->lastkeyframetimestamp = flv->acurframeindex / flv->framerate;\n                    flv->lastkeyframelocation = pos;\n                    flv_append_keyframe_info(s, flv, ts, pos);\n                }\n                flv->acurframeindex++;\n                break;\n\n            case AVMEDIA_TYPE_AUDIO:\n                flv->audiosize += (avio_tell(pb) - cur_offset);\n                break;\n\n            default:\n                av_log(s, AV_LOG_WARNING, \"par->codec_type is type = [%d]\\n\", par->codec_type);\n                break;\n        }\n    }\n\n    av_free(data);\n\n    return pb->error;\n}", "target": 2, "idx": 10289}
{"commit_id": "df7c4ef77136b5aeb07e5ddde1699decc6029951", "project": "justdan96/tsMuxer", "func": "int HevcUnit::deserialize()\n{\n    m_reader.setBuffer(m_nalBuffer, m_nalBuffer + m_nalBufferLen);\n    try\n    {\n        m_reader.skipBit();\n        nal_unit_type = m_reader.getBits(6);\n        nuh_layer_id = m_reader.getBits(6);\n        nuh_temporal_id_plus1 = m_reader.getBits(3);\n        if (nuh_temporal_id_plus1 == 0 || (nuh_temporal_id_plus1 != 1 && (nal_unit_type == 32 || nal_unit_type == 33 ||\n                                                                          nal_unit_type == 36 || nal_unit_type == 37)))\n            return 1;\n        return 0;\n    }\n    catch (BitStreamException& e)\n    {\n        return NOT_ENOUGH_BUFFER;\n    }\n}", "target": 3, "idx": 10290}
{"commit_id": "e2f0ccf939d9f82931d085acb6df8e9a182a4261", "project": "nanopb", "func": "static bool pb_release_union_field(pb_istream_t *stream, pb_field_iter_t *field)\n{\n    pb_field_iter_t old_field = *field;\n    pb_size_t old_tag = *(pb_size_t*)field->pSize; /* Previous which_ value */\n    pb_size_t new_tag = field->tag; /* New which_ value */\n\n    if (old_tag == 0)\n        return true; /* Ok, no old data in union */\n\n    if (old_tag == new_tag)\n        return true; /* Ok, old data is of same type => merge */\n\n    /* Release old data. The find can fail if the message struct contains\n     * invalid data. */\n    if (!pb_field_iter_find(&old_field, old_tag))\n        PB_RETURN_ERROR(stream, \"invalid union tag\");\n\n    pb_release_single_field(&old_field);\n\n    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)\n    {\n        /* Initialize the pointer to NULL to make sure it is valid\n         * even in case of error return. */\n        *(void**)field->pField = NULL;\n        field->pData = NULL;\n    }\n\n    return true;\n}", "target": 2, "idx": 10291}
{"commit_id": "c8d32dd6e615b7b76c8e89d36f6ccf8786102180", "project": "chromium", "func": "bool get(unsigned index) const\n    {\n        RELEASE_ASSERT(index < arraySize);\n        return !!(m_data[index / 8] & (1 << (index & 7)));\n    }", "target": 2, "idx": 10292}
{"commit_id": "9dcfda045474d8903224d175907bfc29761dcb45", "project": "openbsd/src", "func": "static int\nsmtp_mailaddr(struct mailaddr *maddr, char *line, int mailfrom, char **args,\n    const char *domain)\n{\n\tchar   *p, *e;\n\n\tif (line == NULL)\n\t\treturn (0);\n\n\tif (*line != '<')\n\t\treturn (0);\n\n\te = strchr(line, '>');\n\tif (e == NULL)\n\t\treturn (0);\n\t*e++ = '\\0';\n\twhile (*e == ' ')\n\t\te++;\n\t*args = e;\n\n\tif (!text_to_mailaddr(maddr, line + 1))\n\t\treturn (0);\n\n\tp = strchr(maddr->user, ':');\n\tif (p != NULL) {\n\t\tp++;\n\t\tmemmove(maddr->user, p, strlen(p) + 1);\n\t}\n\n\t/* accept empty return-path in MAIL FROM, required for bounces */\n\tif (mailfrom && maddr->user[0] == '\\0' && maddr->domain[0] == '\\0')\n\t\treturn (1);\n\n\t/* no or invalid user-part, reject */\n\tif (maddr->user[0] == '\\0' || !valid_localpart(maddr->user))\n\t\treturn (0);\n\n\t/* no domain part, local user */\n\tif (maddr->domain[0] == '\\0') {\n\t\t(void)strlcpy(maddr->domain, domain,\n\t\t\tsizeof(maddr->domain));\n\t}\n\n\tif (!valid_domainpart(maddr->domain))\n\t\treturn (0);\n\n\treturn (1);\n}", "target": 3, "idx": 10293}
{"commit_id": "02a79a793f56e86e2014a606647b158b246811e3", "project": "PierreLvx/qpress", "func": "void decompress_directory(string extract_dir, bool std_out)\n{\n    char c;\n    string curdir;\n    size_t r = 0;\n    unsigned int chunk_size;\n\n    curdir = string(extract_dir);\n\n    for(;;)\n    {\n        r = aread(&c, 1);\n        if (r == 0)\n            return;\n\n        if(c == 'D')\n        {\n\t\t\t// read directory name, append it to current path and create the directory\n            chunk_size = fread32();\n\t\t\tif(NAME_BUFFER_SIZE < chunk_size + 1)\n            {\n                abort(\"File path string is bigger than buffer size\");\n            }\n            try_aread(tmp, chunk_size + 1);\n            curdir = curdir + DELIM_STR + tmp;\n            PRINT(FILES_PROCESSED, \"%s%s%s\\n\", BLANK_LINE, remove_leading_curdir(curdir).c_str(), DELIM_STR);\n\t\t\t/* RDS security fix: https://rds-jira.amazon.com/browse/MMCP-231\n\t \t\tNeed to check if we try to decompress file or directory outside working directory\n\t \t\t*/\n\t        if(true == check_if_path_has_dir_traversal(tmp)) \n            {\n\t            abort(\"Directory path contains directory traversal which is not allowed.\");\n\t        }\n\t        /* End of RDS security fix*/\n            if(!std_out)\n            {\n#ifdef WINDOWS\n                CreateDirectory(curdir.c_str(), 0);\n#else\n                mkdir(curdir.c_str(), 509);\n#endif\n            }\n        }\n        else if(c == 'U')\n            curdir = curdir.substr(0, curdir.find_last_of(DELIM_STR)); // remove last sub dir from current path\n        else if(c == 'F')\n        {\n            chunk_size = fread32(); // read length of file name\n            if(NAME_BUFFER_SIZE < chunk_size + 1)\n\t             {\n\t                 abort(\"File path string is bigger than buffer size\");\n\t             }\n\t             try_aread(tmp, chunk_size + 1); // read file name to 'tmp' with size 'chunk_size + 1'\n\t         /* RDS security fix: https://rds-jira.amazon.com/browse/MMCP-231\n\t \t\t   Need to check if we try to decompress file or directory outside working directory\n\t \t\t*/\n\t         if(true == check_if_path_has_dir_traversal(tmp)) \n\t         {\n\t             abort(\"File path contains directory traversal which is not allowed.\");\n\t         }\n\t         /* End of RDS security fix*/\n            string buf2 = curdir + DELIM_STR + tmp;\n            PRINT(FILES_PROCESSED, \"%s    %s\\n\", BLANK_LINE, tmp);\n            if(!std_out)\n            {\n                if(exists(buf2) && !force_flag)\n                    abort(\"Destination file '%s' already exists - aborted\", buf2.c_str());\n                else\n                    decompress_file(buf2);\n            }\n            else\n                decompress_file(\"<stdout>\");\n        }\n        else\n            abort(\"Source file is corrupted - try the -R flag to recover\");\n    }\n}", "target": 1, "idx": 10294}
{"commit_id": "2c8ca9ad09281d4138ae363566051e45afd0838c", "project": "chromium", "func": "Maybe<bool> Object::SetPropertyInternal(LookupIterator* it,\n                                        Handle<Object> value,\n                                        LanguageMode language_mode,\n                                        StoreFromKeyed store_mode,\n                                        bool* found) {\n  it->UpdateProtector();\n  DCHECK(it->IsFound());\n  ShouldThrow should_throw =\n      is_sloppy(language_mode) ? DONT_THROW : THROW_ON_ERROR;\n\n  // Make sure that the top context does not change when doing callbacks or\n  // interceptor calls.\n  AssertNoContextChange ncc(it->isolate());\n\n  do {\n    switch (it->state()) {\n      case LookupIterator::NOT_FOUND:\n        UNREACHABLE();\n\n      case LookupIterator::ACCESS_CHECK:\n        if (it->HasAccess()) break;\n        // Check whether it makes sense to reuse the lookup iterator. Here it\n        // might still call into setters up the prototype chain.\n        return JSObject::SetPropertyWithFailedAccessCheck(it, value,\n                                                          should_throw);\n\n      case LookupIterator::JSPROXY:\n        return JSProxy::SetProperty(it->GetHolder<JSProxy>(), it->GetName(),\n                                    value, it->GetReceiver(), language_mode);\n\n      case LookupIterator::INTERCEPTOR: {\n        Handle<Map> store_target_map =\n            handle(it->GetStoreTarget()->map(), it->isolate());\n        if (it->HolderIsReceiverOrHiddenPrototype()) {\n          Maybe<bool> result =\n              JSObject::SetPropertyWithInterceptor(it, should_throw, value);\n          if (result.IsNothing() || result.FromJust()) return result;\n          // Interceptor modified the store target but failed to set the\n          // property.\n          Utils::ApiCheck(*store_target_map == it->GetStoreTarget()->map(),\n                          it->IsElement() ? \"v8::IndexedPropertySetterCallback\"\n                                          : \"v8::NamedPropertySetterCallback\",\n                          \"Interceptor silently changed store target.\");\n        } else {\n          Maybe<PropertyAttributes> maybe_attributes =\n              JSObject::GetPropertyAttributesWithInterceptor(it);\n          if (!maybe_attributes.IsJust()) return Nothing<bool>();\n          if ((maybe_attributes.FromJust() & READ_ONLY) != 0) {\n            return WriteToReadOnlyProperty(it, value, should_throw);\n          }\n          // Interceptor modified the store target but failed to set the\n          // property.\n          Utils::ApiCheck(*store_target_map == it->GetStoreTarget()->map(),\n                          it->IsElement() ? \"v8::IndexedPropertySetterCallback\"\n                                          : \"v8::NamedPropertySetterCallback\",\n                          \"Interceptor silently changed store target.\");\n          if (maybe_attributes.FromJust() == ABSENT) break;\n          *found = false;\n          return Nothing<bool>();\n        }\n        break;\n      }\n\n      case LookupIterator::ACCESSOR: {\n        if (it->IsReadOnly()) {\n          return WriteToReadOnlyProperty(it, value, should_throw);\n        }\n        Handle<Object> accessors = it->GetAccessors();\n        if (accessors->IsAccessorInfo() &&\n            !it->HolderIsReceiverOrHiddenPrototype() &&\n            AccessorInfo::cast(*accessors)->is_special_data_property()) {\n          *found = false;\n          return Nothing<bool>();\n        }\n        return SetPropertyWithAccessor(it, value, should_throw);\n      }\n      case LookupIterator::INTEGER_INDEXED_EXOTIC:\n        // TODO(verwaest): We should throw an exception if holder is receiver.\n        return Just(true);\n\n      case LookupIterator::DATA:\n        if (it->IsReadOnly()) {\n          return WriteToReadOnlyProperty(it, value, should_throw);\n        }\n        if (it->HolderIsReceiverOrHiddenPrototype()) {\n          return SetDataProperty(it, value);\n        }\n      // Fall through.\n      case LookupIterator::TRANSITION:\n        *found = false;\n        return Nothing<bool>();\n    }\n    it->Next();\n  } while (it->IsFound());\n\n  *found = false;\n  return Nothing<bool>();\n}", "target": 2, "idx": 10295}
{"commit_id": "c1d1f7121194036608bf555f08d3062a36fd344b", "project": "GNOME/libxml2", "func": "xmlXPathObjectPtr\nxmlXPtrNewRange(xmlNodePtr start, int startindex,\n\t        xmlNodePtr end, int endindex) {\n    xmlXPathObjectPtr ret;\n\n    if (start == NULL)\n\treturn(NULL);\n    if (end == NULL)\n\treturn(NULL);\n    if (startindex < 0)\n\treturn(NULL);\n    if (endindex < 0)\n\treturn(NULL);\n\n    ret = xmlXPtrNewRangeInternal(start, startindex, end, endindex);\n    xmlXPtrRangeCheckOrder(ret);\n    return(ret);\n}", "target": 3, "idx": 10296}
{"commit_id": "8d444b41d09a700c7ee6f9182a649f3f2d325abb", "project": "nbdkit/libnbd", "func": "static bool\nfile_asynch_zero (struct rw *rw, struct command *command,\n                  nbd_completion_callback cb, bool allocate)\n{\n  int dummy = 0;\n\n  if (!file_synch_zero (rw, command->offset, command->slice.len, allocate))\n    return false;\n  cb.callback (cb.user_data, &dummy);\n  return true;\n}", "target": 1, "idx": 10297}
{"commit_id": "469873ee6ce96ef475baa9993f56aa1893456ae0", "project": "mity/md4c", "func": "static int\nmd_is_link_label(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg,\n                 OFF* p_end, int* p_beg_line_index, int* p_end_line_index,\n                 OFF* p_contents_beg, OFF* p_contents_end)\n{\n    OFF off = beg;\n    OFF contents_beg = 0;\n    OFF contents_end = 0;\n    int line_index = 0;\n    int len = 0;\n\n    if(CH(off) != _T('['))\n        return FALSE;\n    off++;\n\n    while(1) {\n        OFF line_end = lines[line_index].end;\n\n        while(off < line_end) {\n            if(CH(off) == _T('\\\\')  &&  off+1 < ctx->size  &&  (ISPUNCT(off+1) || ISNEWLINE(off+1))) {\n                if(contents_end == 0) {\n                    contents_beg = off;\n                    *p_beg_line_index = line_index;\n                }\n                contents_end = off + 2;\n                off += 2;\n            } else if(CH(off) == _T('[')) {\n                return FALSE;\n            } else if(CH(off) == _T(']')) {\n                if(contents_beg < contents_end) {\n                    /* Success. */\n                    *p_contents_beg = contents_beg;\n                    *p_contents_end = contents_end;\n                    *p_end = off+1;\n                    *p_end_line_index = line_index;\n                    return TRUE;\n                } else {\n                    /* Link label must have some non-whitespace contents. */\n                    return FALSE;\n                }\n            } else {\n                int codepoint;\n                SZ char_size;\n\n                codepoint = md_decode_unicode(ctx->text, off, ctx->size, &char_size);\n                if(!ISUNICODEWHITESPACE_(codepoint)) {\n                    if(contents_end == 0) {\n                        contents_beg = off;\n                        *p_beg_line_index = line_index;\n                    }\n                    contents_end = off + char_size;\n                }\n\n                off += char_size;\n            }\n\n            len++;\n            if(len > 999)\n                return FALSE;\n        }\n\n        line_index++;\n        len++;\n        if(line_index < n_lines)\n            off = lines[line_index].beg;\n        else\n            break;\n    }\n\n    return FALSE;\n}", "target": 3, "idx": 10298}
{"commit_id": "0c9acb1af77a3cb8707e43f45b72c95266903cee", "project": "kernel/git/gregkh/tty", "func": "static ssize_t\nvcs_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct vc_data *vc;\n\tlong pos;\n\tlong attr, size, written;\n\tchar *con_buf0;\n\tint col, maxcol, viewed;\n\tu16 *org0 = NULL, *org = NULL;\n\tsize_t ret;\n\tchar *con_buf;\n\n\tif (use_unicode(inode))\n\t\treturn -EOPNOTSUPP;\n\n\tcon_buf = (char *) __get_free_page(GFP_KERNEL);\n\tif (!con_buf)\n\t\treturn -ENOMEM;\n\n\tpos = *ppos;\n\n\t/* Select the proper current console and verify\n\t * sanity of the situation under the console lock.\n\t */\n\tconsole_lock();\n\n\tattr = use_attributes(inode);\n\tret = -ENXIO;\n\tvc = vcs_vc(inode, &viewed);\n\tif (!vc)\n\t\tgoto unlock_out;\n\n\tsize = vcs_size(inode);\n\tret = -EINVAL;\n\tif (pos < 0 || pos > size)\n\t\tgoto unlock_out;\n\tif (count > size - pos)\n\t\tcount = size - pos;\n\twritten = 0;\n\twhile (count) {\n\t\tlong this_round = count;\n\t\tsize_t orig_count;\n\t\tlong p;\n\n\t\tif (this_round > CON_BUF_SIZE)\n\t\t\tthis_round = CON_BUF_SIZE;\n\n\t\t/* Temporarily drop the console lock so that we can read\n\t\t * in the write data from userspace safely.\n\t\t */\n\t\tconsole_unlock();\n\t\tret = copy_from_user(con_buf, buf, this_round);\n\t\tconsole_lock();\n\n\t\tif (ret) {\n\t\t\tthis_round -= ret;\n\t\t\tif (!this_round) {\n\t\t\t\t/* Abort loop if no data were copied. Otherwise\n\t\t\t\t * fail with -EFAULT.\n\t\t\t\t */\n\t\t\t\tif (written)\n\t\t\t\t\tbreak;\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto unlock_out;\n\t\t\t}\n\t\t}\n\n\t\t/* The vcs_size might have changed while we slept to grab\n\t\t * the user buffer, so recheck.\n\t\t * Return data written up to now on failure.\n\t\t */\n\t\tsize = vcs_size(inode);\n\t\tif (size < 0) {\n\t\t\tif (written)\n\t\t\t\tbreak;\n\t\t\tret = size;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tif (pos >= size)\n\t\t\tbreak;\n\t\tif (this_round > size - pos)\n\t\t\tthis_round = size - pos;\n\n\t\t/* OK, now actually push the write to the console\n\t\t * under the lock using the local kernel buffer.\n\t\t */\n\n\t\tcon_buf0 = con_buf;\n\t\torig_count = this_round;\n\t\tmaxcol = vc->vc_cols;\n\t\tp = pos;\n\t\tif (!attr) {\n\t\t\torg0 = org = screen_pos(vc, p, viewed);\n\t\t\tcol = p % maxcol;\n\t\t\tp += maxcol - col;\n\n\t\t\twhile (this_round > 0) {\n\t\t\t\tunsigned char c = *con_buf0++;\n\n\t\t\t\tthis_round--;\n\t\t\t\tvcs_scr_writew(vc,\n\t\t\t\t\t       (vcs_scr_readw(vc, org) & 0xff00) | c, org);\n\t\t\t\torg++;\n\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\torg = screen_pos(vc, p, viewed);\n\t\t\t\t\tcol = 0;\n\t\t\t\t\tp += maxcol;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (p < HEADER_SIZE) {\n\t\t\t\tchar header[HEADER_SIZE];\n\n\t\t\t\tgetconsxy(vc, header + 2);\n\t\t\t\twhile (p < HEADER_SIZE && this_round > 0) {\n\t\t\t\t\tthis_round--;\n\t\t\t\t\theader[p++] = *con_buf0++;\n\t\t\t\t}\n\t\t\t\tif (!viewed)\n\t\t\t\t\tputconsxy(vc, header + 2);\n\t\t\t}\n\t\t\tp -= HEADER_SIZE;\n\t\t\tcol = (p/2) % maxcol;\n\t\t\tif (this_round > 0) {\n\t\t\t\torg0 = org = screen_pos(vc, p/2, viewed);\n\t\t\t\tif ((p & 1) && this_round > 0) {\n\t\t\t\t\tchar c;\n\n\t\t\t\t\tthis_round--;\n\t\t\t\t\tc = *con_buf0++;\n#ifdef __BIG_ENDIAN\n\t\t\t\t\tvcs_scr_writew(vc, c |\n\t\t\t\t\t     (vcs_scr_readw(vc, org) & 0xff00), org);\n#else\n\t\t\t\t\tvcs_scr_writew(vc, (c << 8) |\n\t\t\t\t\t     (vcs_scr_readw(vc, org) & 0xff), org);\n#endif\n\t\t\t\t\torg++;\n\t\t\t\t\tp++;\n\t\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\t\torg = screen_pos(vc, p/2, viewed);\n\t\t\t\t\t\tcol = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp /= 2;\n\t\t\t\tp += maxcol - col;\n\t\t\t}\n\t\t\twhile (this_round > 1) {\n\t\t\t\tunsigned short w;\n\n\t\t\t\tw = get_unaligned(((unsigned short *)con_buf0));\n\t\t\t\tvcs_scr_writew(vc, w, org++);\n\t\t\t\tcon_buf0 += 2;\n\t\t\t\tthis_round -= 2;\n\t\t\t\tif (++col == maxcol) {\n\t\t\t\t\torg = screen_pos(vc, p, viewed);\n\t\t\t\t\tcol = 0;\n\t\t\t\t\tp += maxcol;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this_round > 0) {\n\t\t\t\tunsigned char c;\n\n\t\t\t\tc = *con_buf0++;\n#ifdef __BIG_ENDIAN\n\t\t\t\tvcs_scr_writew(vc, (vcs_scr_readw(vc, org) & 0xff) | (c << 8), org);\n#else\n\t\t\t\tvcs_scr_writew(vc, (vcs_scr_readw(vc, org) & 0xff00) | c, org);\n#endif\n\t\t\t}\n\t\t}\n\t\tcount -= orig_count;\n\t\twritten += orig_count;\n\t\tbuf += orig_count;\n\t\tpos += orig_count;\n\t\tif (org0)\n\t\t\tupdate_region(vc, (unsigned long)(org0), org - org0);\n\t}\n\t*ppos += written;\n\tret = written;\n\tif (written)\n\t\tvcs_scr_updated(vc);\n\nunlock_out:\n\tconsole_unlock();\n\tfree_page((unsigned long) con_buf);\n\treturn ret;\n}", "target": 2, "idx": 10299}
{"commit_id": "a40a3b7ef7420c8df0a7d9411ab1fc267ca86c49", "project": "gpac", "func": "GF_Err ctts_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tu32 sampleCount;\n\tGF_CompositionOffsetBox *ptr = (GF_CompositionOffsetBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\n\tif (ptr->nb_entries > ptr->size / 8 || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(GF_DttsEntry) ) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in ctts\\n\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->alloc_size = ptr->nb_entries;\n\tptr->entries = (GF_DttsEntry *)gf_malloc(sizeof(GF_DttsEntry)*ptr->alloc_size);\n\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\tsampleCount = 0;\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->entries[i].sampleCount = gf_bs_read_u32(bs);\n\t\tif (ptr->version)\n\t\t\tptr->entries[i].decodingOffset = gf_bs_read_int(bs, 32);\n\t\telse {\n\t\t\tptr->entries[i].decodingOffset = (s32) gf_bs_read_u32(bs);\n\n\t\t\tif (ptr->entries[i].decodingOffset <= INT32_MIN) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid decodingOffset (%d) in entry #%i - defaulting to 0.\\n\", ptr->entries[i].decodingOffset, i));\n\t\t\t\tptr->entries[i].decodingOffset = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (ptr->max_cts_delta <= ABS(ptr->entries[i].decodingOffset)) {\n\t\t\tptr->max_cts_delta = ABS(ptr->entries[i].decodingOffset);\n\t\t\t//ptr->sample_num_max_cts_delta = sampleCount;\n\t\t}\n\t\tsampleCount += ptr->entries[i].sampleCount;\n\t}\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tptr->w_LastSampleNumber = sampleCount;\n#endif\n\treturn GF_OK;\n}", "target": 1, "idx": 10300}
{"commit_id": "353050be4c19e102178ccc05988101887c25ae53", "project": "kernel/git/bpf/bpf", "func": "static void bpf_map_mmap_open(struct vm_area_struct *vma)\n{\n\tstruct bpf_map *map = vma->vm_file->private_data;\n\n\tif (vma->vm_flags & VM_MAYWRITE)\n\t\tbpf_map_write_active_inc(map);\n}", "target": 1, "idx": 10301}
{"commit_id": "211845aba4794720ae265c782cdffddae54a3e7a", "project": "wireshark", "func": "void\ncfile_open_failure_message(const char *progname, const char *filename,\n                           int err, gchar *err_info)\n{\n    if (err < 0) {\n        /* Get a string that describes what we're opening */\n        char *file_description = input_file_description(filename);\n\n        /* Wiretap error. */\n        switch (err) {\n\n        case WTAP_ERR_NOT_REGULAR_FILE:\n            cmdarg_err(\"The %s is a \\\"special file\\\" or socket or other non-regular file.\",\n                       file_description);\n            break;\n\n        case WTAP_ERR_RANDOM_OPEN_PIPE:\n            cmdarg_err(\"The %s is a pipe or FIFO; %s can't read pipe or FIFO files in two-pass mode.\",\n                       file_description, progname);\n            break;\n\n        case WTAP_ERR_FILE_UNKNOWN_FORMAT:\n            cmdarg_err(\"The %s isn't a capture file in a format %s understands.\",\n                       file_description, progname);\n            break;\n\n        case WTAP_ERR_UNSUPPORTED:\n            cmdarg_err(\"The %s contains record data that %s doesn't support.\\n\"\n                       \"(%s)\",\n                       file_description, progname,\n                       err_info != NULL ? err_info : \"no information supplied\");\n            g_free(err_info);\n            break;\n\n        case WTAP_ERR_ENCAP_PER_PACKET_UNSUPPORTED:\n            cmdarg_err(\"The %s is a capture for a network type that %s doesn't support.\",\n                       file_description, progname);\n            break;\n\n        case WTAP_ERR_BAD_FILE:\n            cmdarg_err(\"The %s appears to be damaged or corrupt.\\n\"\n                       \"(%s)\",\n                       file_description,\n                       err_info != NULL ? err_info : \"no information supplied\");\n            g_free(err_info);\n            break;\n\n        case WTAP_ERR_CANT_OPEN:\n            cmdarg_err(\"The %s could not be opened for some unknown reason.\",\n                       file_description);\n            break;\n\n        case WTAP_ERR_SHORT_READ:\n            cmdarg_err(\"The %s appears to have been cut short in the middle of a packet or other data.\",\n                       file_description);\n            break;\n\n        case WTAP_ERR_DECOMPRESS:\n            cmdarg_err(\"The %s cannot be decompressed; it may be damaged or corrupt.\"\n                       \"(%s)\",\n                       file_description,\n                       err_info != NULL ? err_info : \"no information supplied\");\n            g_free(err_info);\n            break;\n\n        default:\n            cmdarg_err(\"The %s could not be opened: %s.\",\n                       file_description,\n                       wtap_strerror(err));\n            break;\n        }\n        g_free(file_description);\n    } else\n        cmdarg_err(file_open_error_message(err, FALSE), filename);\n}", "target": 2, "idx": 10302}
{"commit_id": "e49d45594002d4d3fbc1f03488e6dfc0a0a65836", "project": "keepkey/keepkey-firmware", "func": "uint8_t ethereum_extractThorchainData(const EthereumSignTx *msg,\n                                          char *buffer) {\n  // Swap data begins 164 chars into data buffer:\n  // offset = deposit function hash + address + address + uint256\n  uint16_t offset = 4 + (5 * 32);\n  int16_t len = msg->data_length - offset;\n  if (msg->has_data_length && len > 0 && len < 256) {\n    memcpy(buffer, msg->data_initial_chunk.bytes + offset, len);\n    // String length must be < 255 characters\n    return (uint8_t)len;\n  }\n  return 0;\n}", "target": 2, "idx": 10303}
{"commit_id": "4733fb11f6bec6524bb8518c5e1a699288c26bac", "project": "roehling/postsrsd", "func": "int\nsrs_timestamp_check(srs_t *srs, const char *stamp)\n{\n\tconst char\t*sp;\n\tchar\t\t*bp;\n\tint\t\t\t off;\n\ttime_t\t\t now;\n\ttime_t\t\t then;\n\n\tif (strlen(stamp) != 2) return SRS_ETIMESTAMPOUTOFDATE;\n\t/* We had better go around this loop exactly twice! */\n\tthen = 0;\n\tfor (sp = stamp; *sp; sp++) {\n\t\tbp = strchr(SRS_TIME_BASECHARS, toupper(*sp));\n\t\tif (bp == NULL)\n\t\t\treturn SRS_EBADTIMESTAMPCHAR;\n\t\toff = bp - SRS_TIME_BASECHARS;\n\t\tthen = (then << SRS_TIME_BASEBITS) | off;\n\t}\n\n\ttime(&now);\n\tnow = (now / SRS_TIME_PRECISION) % SRS_TIME_SLOTS;\n\twhile (now < then)\n\t\tnow = now + SRS_TIME_SLOTS;\n\n\tif (now <= then + srs->maxage)\n\t\treturn SRS_SUCCESS;\n\treturn SRS_ETIMESTAMPOUTOFDATE;\n}", "target": 2, "idx": 10304}
{"commit_id": "8d2e02ae650f00c4a53deb625211a0527126c605", "project": "xorg/lib/libX11", "func": "int\nXSetIconName (\n    register Display *dpy,\n    Window w,\n    _Xconst char *icon_name)\n{\n    if (strlen(icon_name) >= USHRT_MAX)\n        return 0;\n    return XChangeProperty(dpy, w, XA_WM_ICON_NAME, XA_STRING, 8,\n                           PropModeReplace, (_Xconst unsigned char *)icon_name,\n\t\t\t   icon_name ? (int) strlen(icon_name) : 0);\n}", "target": 3, "idx": 10305}
{"commit_id": "e7f0090b161ce6344f6bd35009816a925c070b09", "project": "zeromq/libzmq", "func": "zmq::ws_engine_t::ws_engine_t (fd_t fd_,\n                               const options_t &options_,\n                               const endpoint_uri_pair_t &endpoint_uri_pair_,\n                               const ws_address_t &address_,\n                               bool client_) :\n    stream_engine_base_t (fd_, options_, endpoint_uri_pair_, true),\n    _client (client_),\n    _address (address_),\n    _client_handshake_state (client_handshake_initial),\n    _server_handshake_state (handshake_initial),\n    _header_name_position (0),\n    _header_value_position (0),\n    _header_upgrade_websocket (false),\n    _header_connection_upgrade (false),\n    _heartbeat_timeout (0)\n{\n    memset (_websocket_key, 0, MAX_HEADER_VALUE_LENGTH + 1);\n    memset (_websocket_accept, 0, MAX_HEADER_VALUE_LENGTH + 1);\n    memset (_websocket_protocol, 0, 256);\n\n    _next_msg = &ws_engine_t::next_handshake_command;\n    _process_msg = &ws_engine_t::process_handshake_command;\n    _close_msg.init ();\n\n    if (_options.heartbeat_interval > 0) {\n        _heartbeat_timeout = _options.heartbeat_timeout;\n        if (_heartbeat_timeout == -1)\n            _heartbeat_timeout = _options.heartbeat_interval;\n    }\n}", "target": 2, "idx": 10306}
{"commit_id": "cf6771c857eb9a290e2c19ddacfdd3ed98b27618", "project": "gpac", "func": "static s32 avc_parse_slice(GF_BitStream *bs, AVCState *avc, Bool svc_idr_flag, AVCSliceInfo *si)\n{\n\ts32 pps_id, num_ref_idx_l0_active_minus1 = 0, num_ref_idx_l1_active_minus1 = 0;\n\n\t/*s->current_picture.reference= h->nal_ref_idc != 0;*/\n\tgf_bs_read_ue_log(bs, \"first_mb_in_slice\");\n\tsi->slice_type = gf_bs_read_ue_log(bs, \"slice_type\");\n\tif (si->slice_type > 9) return -1;\n\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\tif ((pps_id<0) || (pps_id > 255)) return -1;\n\tsi->pps = &avc->pps[pps_id];\n\tif (!si->pps->slice_group_count) return -2;\n\tsi->sps = &avc->sps[si->pps->sps_id];\n\tif (!si->sps->log2_max_frame_num) return -2;\n\tavc->sps_active_idx = si->pps->sps_id;\n\tavc->pps_active_idx = pps_id;\n\n\tsi->frame_num = gf_bs_read_int_log(bs, si->sps->log2_max_frame_num, \"frame_num\");\n\n\tsi->field_pic_flag = 0;\n\tsi->bottom_field_flag = 0;\n\tif (!si->sps->frame_mbs_only_flag) {\n\t\tsi->field_pic_flag = gf_bs_read_int_log(bs, 1, \"field_pic_flag\");\n\t\tif (si->field_pic_flag)\n\t\t\tsi->bottom_field_flag = gf_bs_read_int_log(bs, 1, \"bottom_field_flag\");\n\t}\n\n\tif ((si->nal_unit_type == GF_AVC_NALU_IDR_SLICE) || svc_idr_flag)\n\t\tsi->idr_pic_id = gf_bs_read_ue_log(bs, \"idr_pic_id\");\n\n\tif (si->sps->poc_type == 0) {\n\t\tsi->poc_lsb = gf_bs_read_int_log(bs, si->sps->log2_max_poc_lsb, \"poc_lsb\");\n\t\tif (si->pps->pic_order_present && !si->field_pic_flag) {\n\t\t\tsi->delta_poc_bottom = gf_bs_read_se_log(bs, \"poc_lsb\");\n\t\t}\n\t}\n\telse if ((si->sps->poc_type == 1) && !si->sps->delta_pic_order_always_zero_flag) {\n\t\tsi->delta_poc[0] = gf_bs_read_se_log(bs, \"delta_poc0\");\n\t\tif ((si->pps->pic_order_present == 1) && !si->field_pic_flag)\n\t\t\tsi->delta_poc[1] = gf_bs_read_se_log(bs, \"delta_poc1\");\n\t}\n\n\tif (si->pps->redundant_pic_cnt_present) {\n\t\tsi->redundant_pic_cnt = gf_bs_read_ue_log(bs, \"redundant_pic_cnt\");\n\t}\n\n\tif (si->slice_type % 5 == GF_AVC_TYPE_B) {\n\t\tgf_bs_read_int_log(bs, 1, \"direct_spatial_mv_pred_flag\");\n\t}\n\n\tnum_ref_idx_l0_active_minus1 = si->pps->num_ref_idx_l0_default_active_minus1;\n\tnum_ref_idx_l1_active_minus1 = si->pps->num_ref_idx_l1_default_active_minus1;\n\n\tif (si->slice_type % 5 == GF_AVC_TYPE_P || si->slice_type % 5 == GF_AVC_TYPE_SP || si->slice_type % 5 == GF_AVC_TYPE_B) {\n\t\tBool num_ref_idx_active_override_flag = gf_bs_read_int_log(bs, 1, \"num_ref_idx_active_override_flag\");\n\t\tif (num_ref_idx_active_override_flag) {\n\t\t\tnum_ref_idx_l0_active_minus1 = gf_bs_read_ue_log(bs, \"num_ref_idx_l0_active_minus1\");\n\t\t\tif (si->slice_type % 5 == GF_AVC_TYPE_B) {\n\t\t\t\tnum_ref_idx_l1_active_minus1 = gf_bs_read_ue_log(bs, \"num_ref_idx_l1_active_minus1\");\n\t\t\t}\n\t\t}\n\t}\n\n\tif (si->nal_unit_type == 20 || si->nal_unit_type == 21) {\n\t\t//ref_pic_list_mvc_modification(); /* specified in Annex H */\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[avc-h264] unimplemented ref_pic_list_mvc_modification() in slide header\\n\"));\n\t\tassert(0);\n\t\treturn -1;\n\t}\n\telse {\n\t\tref_pic_list_modification(bs, si->slice_type);\n\t}\n\n\tif ((si->pps->weighted_pred_flag && (si->slice_type % 5 == GF_AVC_TYPE_P || si->slice_type % 5 == GF_AVC_TYPE_SP))\n\t\t|| (si->pps->weighted_bipred_idc == 1 && si->slice_type % 5 == GF_AVC_TYPE_B)) {\n\t\tpred_weight_table(bs, si->slice_type, si->sps->ChromaArrayType, num_ref_idx_l0_active_minus1, num_ref_idx_l1_active_minus1);\n\t}\n\n\tif (si->nal_ref_idc != 0) {\n\t\tdec_ref_pic_marking(bs, (si->nal_unit_type == GF_AVC_NALU_IDR_SLICE));\n\t}\n\n\tif (si->pps->entropy_coding_mode_flag && si->slice_type % 5 != GF_AVC_TYPE_I && si->slice_type % 5 != GF_AVC_TYPE_SI) {\n\t\tgf_bs_read_ue_log(bs, \"cabac_init_idc\");\n\t}\n\n\t/*slice_qp_delta = */gf_bs_read_se(bs);\n\tif (si->slice_type % 5 == GF_AVC_TYPE_SP || si->slice_type % 5 == GF_AVC_TYPE_SI) {\n\t\tif (si->slice_type % 5 == GF_AVC_TYPE_SP) {\n\t\t\tgf_bs_read_int_log(bs, 1, \"sp_for_switch_flag\");\n\t\t}\n\t\tgf_bs_read_se_log(bs, \"slice_qs_delta\");\n\t}\n\n\tif (si->pps->deblocking_filter_control_present_flag) {\n\t\tif (gf_bs_read_ue_log(bs, \"disable_deblocking_filter_idc\") != 1) {\n\t\t\tgf_bs_read_se_log(bs, \"slice_alpha_c0_offset_div2\");\n\t\t\tgf_bs_read_se_log(bs, \"slice_beta_offset_div2\");\n\t\t}\n\t}\n\n\tif (si->pps->slice_group_count > 1 && si->pps->mb_slice_group_map_type >= 3 && si->pps->mb_slice_group_map_type <= 5) {\n\t\tgf_bs_read_int_log(bs, (u32)ceil(log1p((si->pps->pic_size_in_map_units_minus1 + 1) / (si->pps->slice_group_change_rate_minus1 + 1) ) / log(2)), \"slice_group_change_cycle\");\n\t}\n\treturn 0;\n}", "target": 1, "idx": 10307}
{"commit_id": "88aaf40eeff771c546ad3bbb02000171648a89f7", "project": "xen-project/xen", "func": "static lpae_t *p2m_get_root_pointer(struct p2m_domain *p2m,\n                                    gfn_t gfn)\n{\n    unsigned long root_table;\n\n    /*\n     * While the root table index is the offset from the previous level,\n     * we can't use (P2M_ROOT_LEVEL - 1) because the root level might be\n     * 0. Yet we still want to check if all the unused bits are zeroed.\n     */\n    root_table = gfn_x(gfn) >> (level_orders[P2M_ROOT_LEVEL] + LPAE_SHIFT);\n    if ( root_table >= P2M_ROOT_PAGES )\n        return NULL;\n\n    return __map_domain_page(p2m->root + root_table);\n}", "target": 2, "idx": 10308}
{"commit_id": "b78ba88705cb799426204d2ffd6b8cc558d0d3b7", "project": "chromium", "func": "bool RenderFrameHostImpl::OnMessageReceived(const IPC::Message &msg) {\n  // Only process messages if the RenderFrame is alive.\n  if (!render_frame_created_)\n    return false;\n\n  // Filter out most IPC messages if this frame is swapped out.\n  // We still want to handle certain ACKs to keep our state consistent.\n  if (is_swapped_out()) {\n    if (!SwappedOutMessages::CanHandleWhileSwappedOut(msg)) {\n      // If this is a synchronous message and we decided not to handle it,\n      // we must send an error reply, or else the renderer will be stuck\n      // and won't respond to future requests.\n      if (msg.is_sync()) {\n        IPC::Message* reply = IPC::SyncMessage::GenerateReply(&msg);\n        reply->set_reply_error();\n        Send(reply);\n      }\n      // Don't continue looking for someone to handle it.\n      return true;\n    }\n  }\n\n  // This message map is for handling internal IPC messages which should not\n  // be dispatched to other objects.\n  bool handled = true;\n  IPC_BEGIN_MESSAGE_MAP(RenderFrameHostImpl, msg)\n    // This message is synthetic and doesn't come from RenderFrame, but from\n    // RenderProcessHost.\n    IPC_MESSAGE_HANDLER(FrameHostMsg_RenderProcessGone, OnRenderProcessGone)\n    IPC_MESSAGE_UNHANDLED(handled = false)\n  IPC_END_MESSAGE_MAP()\n\n  // Internal IPCs should not be leaked outside of this object, so return\n  // early.\n  if (handled)\n    return true;\n\n  if (delegate_->OnMessageReceived(this, msg))\n    return true;\n\n  RenderFrameProxyHost* proxy =\n      frame_tree_node_->render_manager()->GetProxyToParent();\n  if (proxy && proxy->cross_process_frame_connector() &&\n      proxy->cross_process_frame_connector()->OnMessageReceived(msg))\n    return true;\n\n  handled = true;\n  IPC_BEGIN_MESSAGE_MAP(RenderFrameHostImpl, msg)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_AddMessageToConsole, OnAddMessageToConsole)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_Detach, OnDetach)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_FrameFocused, OnFrameFocused)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidStartProvisionalLoad,\n                        OnDidStartProvisionalLoad)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidFailProvisionalLoadWithError,\n                        OnDidFailProvisionalLoadWithError)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidFailLoadWithError,\n                        OnDidFailLoadWithError)\n    IPC_MESSAGE_HANDLER_GENERIC(FrameHostMsg_DidCommitProvisionalLoad,\n                                OnDidCommitProvisionalLoad(msg))\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidDropNavigation, OnDidDropNavigation)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_UpdateState, OnUpdateState)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_OpenURL, OnOpenURL)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DocumentOnLoadCompleted,\n                        OnDocumentOnLoadCompleted)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_BeforeUnload_ACK, OnBeforeUnloadACK)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_SwapOut_ACK, OnSwapOutACK)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_ContextMenu, OnContextMenu)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_JavaScriptExecuteResponse,\n                        OnJavaScriptExecuteResponse)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_VisualStateResponse,\n                        OnVisualStateResponse)\n    IPC_MESSAGE_HANDLER_DELAY_REPLY(FrameHostMsg_RunJavaScriptMessage,\n                                    OnRunJavaScriptMessage)\n    IPC_MESSAGE_HANDLER_DELAY_REPLY(FrameHostMsg_RunBeforeUnloadConfirm,\n                                    OnRunBeforeUnloadConfirm)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidAccessInitialDocument,\n                        OnDidAccessInitialDocument)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidChangeOpener, OnDidChangeOpener)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidChangeName, OnDidChangeName)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_EnforceStrictMixedContentChecking,\n                        OnEnforceStrictMixedContentChecking)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidAssignPageId, OnDidAssignPageId)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidChangeSandboxFlags,\n                        OnDidChangeSandboxFlags)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidChangeFrameOwnerProperties,\n                        OnDidChangeFrameOwnerProperties)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_UpdateTitle, OnUpdateTitle)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_UpdateEncoding, OnUpdateEncoding)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_BeginNavigation,\n                        OnBeginNavigation)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DispatchLoad, OnDispatchLoad)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_TextSurroundingSelectionResponse,\n                        OnTextSurroundingSelectionResponse)\n    IPC_MESSAGE_HANDLER(AccessibilityHostMsg_Events, OnAccessibilityEvents)\n    IPC_MESSAGE_HANDLER(AccessibilityHostMsg_LocationChanges,\n                        OnAccessibilityLocationChanges)\n    IPC_MESSAGE_HANDLER(AccessibilityHostMsg_FindInPageResult,\n                        OnAccessibilityFindInPageResult)\n    IPC_MESSAGE_HANDLER(AccessibilityHostMsg_SnapshotResponse,\n                        OnAccessibilitySnapshotResponse)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_ToggleFullscreen, OnToggleFullscreen)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidStartLoading, OnDidStartLoading)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidStopLoading, OnDidStopLoading)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidChangeLoadProgress,\n                        OnDidChangeLoadProgress)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_SerializeAsMHTMLResponse,\n                        OnSerializeAsMHTMLResponse)\n#if defined(OS_MACOSX) || defined(OS_ANDROID)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_ShowPopup, OnShowPopup)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_HidePopup, OnHidePopup)\n#endif\n  IPC_END_MESSAGE_MAP()\n\n  // No further actions here, since we may have been deleted.\n  return handled;\n}", "target": 2, "idx": 10309}
{"commit_id": "d563131ef23cbc756026f839a82598c8445bc45f", "project": "torvalds/linux", "func": "static int rsi_send_beacon(struct rsi_common *common)\n{\n\tstruct sk_buff *skb = NULL;\n\tu8 dword_align_bytes = 0;\n\n\tskb = dev_alloc_skb(MAX_MGMT_PKT_SIZE);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tmemset(skb->data, 0, MAX_MGMT_PKT_SIZE);\n\n\tdword_align_bytes = ((unsigned long)skb->data & 0x3f);\n\tif (dword_align_bytes)\n\t\tskb_pull(skb, (64 - dword_align_bytes));\n\tif (rsi_prepare_beacon(common, skb)) {\n\t\trsi_dbg(ERR_ZONE, \"Failed to prepare beacon\\n\");\n\t\tdev_kfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\tskb_queue_tail(&common->tx_queue[MGMT_BEACON_Q], skb);\n\trsi_set_event(&common->tx_thread.event);\n\trsi_dbg(DATA_TX_ZONE, \"%s: Added to beacon queue\\n\", __func__);\n\n\treturn 0;\n}", "target": 2, "idx": 10310}
{"commit_id": "962282327f3a28ffb1138f3ad3fb0438b57ae6b1", "project": "ImageMagick", "func": "static Image *ReadAVSImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MemoryInfo\n    *pixel_info;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    x;\n\n  register unsigned char\n    *p;\n\n  size_t\n    height,\n    length,\n    width;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read AVS X image.\n  */\n  width=ReadBlobMSBLong(image);\n  height=ReadBlobMSBLong(image);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if ((width == 0UL) || (height == 0UL))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  do\n  {\n    /*\n      Convert AVS raster image to pixel packets.\n    */\n    image->columns=width;\n    image->rows=height;\n    image->depth=8;\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    pixel_info=AcquireVirtualMemory(image->columns,4*sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    length=(size_t) 4*image->columns;\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      count=ReadBlob(image,length,pixels);\n      if ((size_t) count != length)\n        {\n          pixel_info=RelinquishVirtualMemory(pixel_info);\n          ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n        }\n      p=pixels;\n      q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n      if (q == (Quantum *) NULL)\n        break;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);\n        SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n        SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n        SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n        if (GetPixelAlpha(image,q) != OpaqueAlpha)\n          image->alpha_trait=BlendPixelTrait;\n        q+=GetPixelChannels(image);\n      }\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    width=ReadBlobMSBLong(image);\n    height=ReadBlobMSBLong(image);\n    if ((width != 0UL) && (height != 0UL))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((width != 0UL) && (height != 0UL));\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}", "target": 1, "idx": 10311}
{"commit_id": "6b485b146a1b9d6ce72dfd7b5f36456c166e7a16", "project": "FreeRDP", "func": "BOOL nego_process_negotiation_request(rdpNego* nego, wStream* s)\n{\n\tBYTE flags;\n\tUINT16 length;\n\n\tif (Stream_GetRemainingLength(s) < 7)\n\t\treturn FALSE;\n\tStream_Read_UINT8(s, flags);\n\tStream_Read_UINT16(s, length);\n\tStream_Read_UINT32(s, nego->RequestedProtocols);\n\tWLog_DBG(TAG, \"RDP_NEG_REQ: RequestedProtocol: 0x%08\" PRIX32 \"\", nego->RequestedProtocols);\n\tnego->state = NEGO_STATE_FINAL;\n\treturn TRUE;\n}", "target": 0, "idx": 10312}
{"commit_id": "b761c9b652af2107cfbc33efd19be0ce41daa33e", "project": "tensorflow", "func": "void CalculateOutputIndexValueRowID(\n      OpKernelContext* context, const RowPartitionTensor& value_rowids,\n      const vector<INDEX_TYPE>& parent_output_index,\n      INDEX_TYPE output_index_multiplier, INDEX_TYPE output_size,\n      vector<INDEX_TYPE>* result) {\n    const INDEX_TYPE index_size = value_rowids.size();\n    result->reserve(index_size);\n    if (index_size == 0) {\n      return;\n    }\n\n    INDEX_TYPE current_output_column = 0;\n    INDEX_TYPE current_value_rowid = value_rowids(0);\n    DCHECK_LT(current_value_rowid, parent_output_index.size());\n    INDEX_TYPE current_output_index = parent_output_index[current_value_rowid];\n    result->push_back(current_output_index);\n    for (INDEX_TYPE i = 1; i < index_size; ++i) {\n      INDEX_TYPE next_value_rowid = value_rowids(i);\n      if (next_value_rowid == current_value_rowid) {\n        if (current_output_index >= 0) {\n          ++current_output_column;\n          if (current_output_column < output_size) {\n            current_output_index += output_index_multiplier;\n          } else {\n            current_output_index = -1;\n          }\n        }\n      } else {\n        current_output_column = 0;\n        current_value_rowid = next_value_rowid;\n        DCHECK_LT(next_value_rowid, parent_output_index.size());\n        current_output_index = parent_output_index[next_value_rowid];\n      }\n      result->push_back(current_output_index);\n    }\n    OP_REQUIRES(context, result->size() == value_rowids.size(),\n                errors::InvalidArgument(\"Invalid row ids.\"));\n  }", "target": 1, "idx": 10313}
{"commit_id": "00e53c362677ba9363e89e859a54027581c60cf2", "project": "marcobambini/gravity", "func": "static bool list_exec (gravity_vm *vm, gravity_value_t *args, uint16_t nargs, uint32_t rindex) {\n    if ((nargs != 2) || (!VALUE_ISA_INT(GET_VALUE(1)))) RETURN_ERROR(\"An Int value is expected as argument of List allocate.\");\n    \n    uint32_t n = (uint32_t)VALUE_AS_INT(GET_VALUE(1));\n    gravity_list_t *list = gravity_list_new(vm, n);\n    if (!list) RETURN_ERROR(\"Maximum List allocation size reached (%d).\", MAX_ALLOCATION);\n    \n    for (uint32_t i=0; i<n; ++i) marray_push(gravity_value_t, list->array, VALUE_FROM_NULL);\n    \n    RETURN_VALUE(VALUE_FROM_OBJECT(list), rindex);\n}", "target": 3, "idx": 10314}
{"commit_id": "0558f33c06bb910e2879e355192227a8e8f0219d", "project": "torvalds/linux", "func": "int sas_discover_sata(struct domain_device *dev)\n{\n\tint res;\n\n\tif (dev->dev_type == SAS_SATA_PM)\n\t\treturn -ENODEV;\n\n\tdev->sata_dev.class = sas_get_ata_command_set(dev);\n\tsas_fill_in_rphy(dev, dev->rphy);\n\n\tres = sas_notify_lldd_dev_found(dev);\n\tif (res)\n\t\treturn res;\n\n\treturn 0;\n}", "target": 1, "idx": 10315}
{"commit_id": "5d3505a67ffe2e003ae907e31ec7bddad19537dd", "project": "syoyo/tinyexr", "func": "int LoadEXR(float **out_rgba, int *width, int *height, const char *filename,\n            const char **err) {\n  if (out_rgba == NULL) {\n    tinyexr::SetErrorMessage(\"Invalid argument for LoadEXR()\", err);\n    return TINYEXR_ERROR_INVALID_ARGUMENT;\n  }\n\n  EXRVersion exr_version;\n  EXRImage exr_image;\n  EXRHeader exr_header;\n  InitEXRHeader(&exr_header);\n  InitEXRImage(&exr_image);\n\n  {\n    int ret = ParseEXRVersionFromFile(&exr_version, filename);\n    if (ret != TINYEXR_SUCCESS) {\n      return ret;\n    }\n\n    if (exr_version.multipart || exr_version.non_image) {\n      tinyexr::SetErrorMessage(\"Loading multipart or DeepImage is not supported  in LoadEXR() API\", err);\n      return TINYEXR_ERROR_INVALID_DATA;  // @fixme.\n    }\n  }\n\n  {\n    int ret = ParseEXRHeaderFromFile(&exr_header, &exr_version, filename, err);\n    if (ret != TINYEXR_SUCCESS) {\n      FreeEXRHeader(&exr_header);\n      return ret;\n    }\n  }\n\n  // Read HALF channel as FLOAT.\n  for (int i = 0; i < exr_header.num_channels; i++) {\n    if (exr_header.pixel_types[i] == TINYEXR_PIXELTYPE_HALF) {\n      exr_header.requested_pixel_types[i] = TINYEXR_PIXELTYPE_FLOAT;\n    }\n  }\n\n  {\n    int ret = LoadEXRImageFromFile(&exr_image, &exr_header, filename, err);\n    if (ret != TINYEXR_SUCCESS) {\n      FreeEXRHeader(&exr_header);\n      return ret;\n    }\n  }\n\n  // RGBA\n  int idxR = -1;\n  int idxG = -1;\n  int idxB = -1;\n  int idxA = -1;\n  for (int c = 0; c < exr_header.num_channels; c++) {\n    if (strcmp(exr_header.channels[c].name, \"R\") == 0) {\n      idxR = c;\n    } else if (strcmp(exr_header.channels[c].name, \"G\") == 0) {\n      idxG = c;\n    } else if (strcmp(exr_header.channels[c].name, \"B\") == 0) {\n      idxB = c;\n    } else if (strcmp(exr_header.channels[c].name, \"A\") == 0) {\n      idxA = c;\n    }\n  }\n\n  if ((idxA == 0) && (idxR == -1) && (idxG == -1) && (idxB == -1)) {\n    // Alpha channel only.\n\n    if (exr_header.tiled) {\n      // todo.implement this\n    }\n    (*out_rgba) = reinterpret_cast<float *>(\n        malloc(4 * sizeof(float) * static_cast<size_t>(exr_image.width) *\n               static_cast<size_t>(exr_image.height)));\n    for (int i = 0; i < exr_image.width * exr_image.height; i++) {\n      const float val = reinterpret_cast<float **>(exr_image.images)[0][i];\n      (*out_rgba)[4 * i + 0] = val;\n      (*out_rgba)[4 * i + 1] = val;\n      (*out_rgba)[4 * i + 2] = val;\n      (*out_rgba)[4 * i + 3] = val;\n    }\n  } else {\n    // Assume RGB(A)\n\n    if (idxR == -1) {\n      tinyexr::SetErrorMessage(\"R channel not found\", err);\n\n      // @todo { free exr_image }\n      FreeEXRHeader(&exr_header);\n      return TINYEXR_ERROR_INVALID_DATA;\n    }\n\n    if (idxG == -1) {\n      tinyexr::SetErrorMessage(\"G channel not found\", err);\n      // @todo { free exr_image }\n      FreeEXRHeader(&exr_header);\n      return TINYEXR_ERROR_INVALID_DATA;\n    }\n\n    if (idxB == -1) {\n      tinyexr::SetErrorMessage(\"B channel not found\", err);\n      // @todo { free exr_image }\n      FreeEXRHeader(&exr_header);\n      return TINYEXR_ERROR_INVALID_DATA;\n    }\n\n    (*out_rgba) = reinterpret_cast<float *>(\n        malloc(4 * sizeof(float) * static_cast<size_t>(exr_image.width) *\n               static_cast<size_t>(exr_image.height)));\n    if (exr_header.tiled) {\n      for (int it = 0; it < exr_image.num_tiles; it++) {\n        for (int j = 0; j < exr_header.tile_size_y; j++)\n          for (int i = 0; i < exr_header.tile_size_x; i++) {\n            const int ii =\n                exr_image.tiles[it].offset_x * exr_header.tile_size_x + i;\n            const int jj =\n                exr_image.tiles[it].offset_y * exr_header.tile_size_y + j;\n            const int idx = ii + jj * exr_image.width;\n\n            // out of region check.\n            if (ii >= exr_image.width) {\n              continue;\n            }\n            if (jj >= exr_image.height) {\n              continue;\n            }\n            const int srcIdx = i + j * exr_header.tile_size_x;\n            unsigned char **src = exr_image.tiles[it].images;\n            (*out_rgba)[4 * idx + 0] =\n                reinterpret_cast<float **>(src)[idxR][srcIdx];\n            (*out_rgba)[4 * idx + 1] =\n                reinterpret_cast<float **>(src)[idxG][srcIdx];\n            (*out_rgba)[4 * idx + 2] =\n                reinterpret_cast<float **>(src)[idxB][srcIdx];\n            if (idxA != -1) {\n              (*out_rgba)[4 * idx + 3] =\n                  reinterpret_cast<float **>(src)[idxA][srcIdx];\n            } else {\n              (*out_rgba)[4 * idx + 3] = 1.0;\n            }\n          }\n      }\n    } else {\n      for (int i = 0; i < exr_image.width * exr_image.height; i++) {\n        (*out_rgba)[4 * i + 0] =\n            reinterpret_cast<float **>(exr_image.images)[idxR][i];\n        (*out_rgba)[4 * i + 1] =\n            reinterpret_cast<float **>(exr_image.images)[idxG][i];\n        (*out_rgba)[4 * i + 2] =\n            reinterpret_cast<float **>(exr_image.images)[idxB][i];\n        if (idxA != -1) {\n          (*out_rgba)[4 * i + 3] =\n              reinterpret_cast<float **>(exr_image.images)[idxA][i];\n        } else {\n          (*out_rgba)[4 * i + 3] = 1.0;\n        }\n      }\n    }\n  }\n\n  (*width) = exr_image.width;\n  (*height) = exr_image.height;\n\n  FreeEXRHeader(&exr_header);\n  FreeEXRImage(&exr_image);\n\n  return TINYEXR_SUCCESS;\n}", "target": 2, "idx": 10316}
{"commit_id": "67d760ab775dae4efe803b5944b0439aa3c0b04a", "project": "ArtifexSoftware/ghostpdl", "func": "static int\nzset_outputintent(i_ctx_t * i_ctx_p)\n{\n    os_ptr                  op = osp;\n    int                     code = 0;\n    gx_device *dev = gs_currentdevice(igs);\n    cmm_dev_profile_t       *dev_profile;\n    stream *                s = 0L;\n    ref *                   pnval;\n    ref *                   pstrmval;\n    int                     ncomps, dev_comps;\n    cmm_profile_t           *picc_profile;\n    int                     expected = 0;\n    gs_color_space_index    index;\n    gsicc_manager_t         *icc_manager = igs->icc_manager;\n    cmm_profile_t           *source_profile = NULL;\n\n    check_type(*op, t_dictionary);\n    check_dict_read(*op);\n    if_debug0m(gs_debug_flag_icc, imemory, \"[icc] Using OutputIntent\\n\");\n\n    /* Get the device structure */\n    code = dev_proc(dev, get_profile)(dev,  &dev_profile);\n    if (code < 0)\n        return code;\n\n    if (dev_profile == NULL) {\n        code = gsicc_init_device_profile_struct(dev, NULL, 0);\n        if (code < 0)\n            return code;\n        code = dev_proc(dev, get_profile)(dev,  &dev_profile);\n        if (code < 0)\n            return code;\n    }\n    if (dev_profile->oi_profile != NULL) {\n        return 0;  /* Allow only one setting of this object */\n    }\n    code = dict_find_string(op, \"N\", &pnval);\n    if (code < 0)\n        return code;\n    if (code == 0)\n        return_error(gs_error_undefined);\n    if (r_type(pnval) != t_integer)\n        return gs_note_error(gs_error_typecheck);\n    ncomps = pnval->value.intval;\n\n    /* verify the DataSource entry. Creat profile from stream */\n    if (dict_find_string(op, \"DataSource\", &pstrmval) <= 0)\n        return_error(gs_error_undefined);\n    check_read_file(i_ctx_p, s, pstrmval);\n\n    picc_profile = gsicc_profile_new(s, gs_gstate_memory(igs), NULL, 0);\n    if (picc_profile == NULL)\n        return gs_throw(gs_error_VMerror, \"Creation of ICC profile failed\");\n    picc_profile->num_comps = ncomps;\n    picc_profile->profile_handle =\n        gsicc_get_profile_handle_buffer(picc_profile->buffer,\n                                        picc_profile->buffer_size,\n                                        gs_gstate_memory(igs));\n    if (picc_profile->profile_handle == NULL) {\n        rc_decrement(picc_profile,\"zset_outputintent\");\n        return -1;\n    }\n    picc_profile->data_cs =\n        gscms_get_profile_data_space(picc_profile->profile_handle,\n            picc_profile->memory);\n    switch (picc_profile->data_cs) {\n        case gsCIEXYZ:\n        case gsCIELAB:\n        case gsRGB:\n            expected = 3;\n            source_profile = icc_manager->default_rgb;\n            break;\n        case gsGRAY:\n            expected = 1;\n            source_profile = icc_manager->default_gray;\n            break;\n        case gsCMYK:\n            expected = 4;\n            source_profile = icc_manager->default_cmyk;\n            break;\n        case gsNCHANNEL:\n            expected = 0;\n            break;\n        case gsNAMED:\n        case gsUNDEFINED:\n            break;\n    }\n    if (expected && ncomps != expected) {\n        rc_decrement(picc_profile,\"zset_outputintent\");\n        return_error(gs_error_rangecheck);\n    }\n    gsicc_init_hash_cs(picc_profile, igs);\n\n    /* All is well with the profile.  Lets set the stuff that needs to be set */\n    dev_profile->oi_profile = picc_profile;\n    picc_profile->name = (char *) gs_alloc_bytes(picc_profile->memory,\n                                                 MAX_DEFAULT_ICC_LENGTH,\n                                                 \"zset_outputintent\");\n    strncpy(picc_profile->name, OI_PROFILE, strlen(OI_PROFILE));\n    picc_profile->name[strlen(OI_PROFILE)] = 0;\n    picc_profile->name_length = strlen(OI_PROFILE);\n    /* Set the range of the profile */\n    gsicc_set_icc_range(&picc_profile);\n\n    /* If the output device has a different number of componenets, then we are\n       going to set the output intent as the proofing profile, unless the\n       proofing profile has already been set.\n\n       If the device has the same number of components (and color model) then as\n       the profile we will use this as the output profile, unless someone has\n       explicitly set the output profile.\n\n       Finally, we will use the output intent profile for the default profile\n       of the proper Device profile in the icc manager, again, unless someone\n       has explicitly set this default profile. */\n\n    dev_comps = dev_profile->device_profile[0]->num_comps;\n    index = gsicc_get_default_type(dev_profile->device_profile[0]);\n    if (ncomps == dev_comps && index < gs_color_space_index_DevicePixel) {\n        /* The OI profile is the same type as the profile for the device and a\n           \"default\" profile for the device was not externally set. So we go\n           ahead and use the OI profile as the device profile.  Care needs to be\n           taken here to keep from screwing up any device parameters.   We will\n           use a keyword of OIProfile for the user/device parameter to indicate\n           its usage.  Also, note conflicts if one is setting object dependent\n           color management */\n        rc_assign(dev_profile->device_profile[0], picc_profile,\n                  \"zset_outputintent\");\n        if_debug0m(gs_debug_flag_icc, imemory, \"[icc] OutputIntent used for device profile\\n\");\n    } else {\n        if (dev_profile->proof_profile == NULL) {\n            /* This means that we should use the OI profile as the proofing\n               profile.  Note that if someone already has specified a\n               proofing profile it is unclear what they are trying to do\n               with the output intent.  In this case, we will use it\n               just for the source data below */\n            dev_profile->proof_profile = picc_profile;\n            rc_increment(picc_profile);\n            if_debug0m(gs_debug_flag_icc, imemory, \"[icc] OutputIntent used for proof profile\\n\");\n        }\n    }\n    /* Now the source colors.  See which source color space needs to use the\n       output intent ICC profile */\n    index = gsicc_get_default_type(source_profile);\n    if (index < gs_color_space_index_DevicePixel) {\n        /* source_profile is currently the default.  Set it to the OI profile */\n        switch (picc_profile->data_cs) {\n            case gsGRAY:\n                if_debug0m(gs_debug_flag_icc, imemory, \"[icc] OutputIntent used source Gray\\n\");\n                rc_assign(icc_manager->default_gray, picc_profile,\n                          \"zset_outputintent\");\n                break;\n            case gsRGB:\n                if_debug0m(gs_debug_flag_icc, imemory, \"[icc] OutputIntent used source RGB\\n\");\n                rc_assign(icc_manager->default_rgb, picc_profile,\n                          \"zset_outputintent\");\n                break;\n            case gsCMYK:\n                if_debug0m(gs_debug_flag_icc, imemory, \"[icc] OutputIntent used source CMYK\\n\");\n                rc_assign(icc_manager->default_cmyk, picc_profile,\n                          \"zset_outputintent\");\n                break;\n            default:\n                break;\n        }\n    }\n    /* Remove the output intent dict from the stack */\n    pop(1);\n    return code;\n}", "target": 2, "idx": 10317}
{"commit_id": "50fe4074f188c2d4da0c421e96553acea8378db2", "project": "krb5", "func": "static krb5_error_code\ncrypto_retrieve_X509_sans(krb5_context context,\n                          pkinit_plg_crypto_context plgctx,\n                          pkinit_req_crypto_context reqctx,\n                          X509 *cert,\n                          krb5_principal **princs_ret,\n                          krb5_principal **upn_ret,\n                          unsigned char ***dns_ret)\n{\n    krb5_error_code retval = EINVAL;\n    char buf[DN_BUF_LEN];\n    int p = 0, u = 0, d = 0, ret = 0, l;\n    krb5_principal *princs = NULL;\n    krb5_principal *upns = NULL;\n    unsigned char **dnss = NULL;\n    unsigned int i, num_found = 0, num_sans = 0;\n    X509_EXTENSION *ext = NULL;\n    GENERAL_NAMES *ialt = NULL;\n    GENERAL_NAME *gen = NULL;\n\n    if (princs_ret != NULL)\n        *princs_ret = NULL;\n    if (upn_ret != NULL)\n        *upn_ret = NULL;\n    if (dns_ret != NULL)\n        *dns_ret = NULL;\n\n    if (princs_ret == NULL && upn_ret == NULL && dns_ret == NULL) {\n        pkiDebug(\"%s: nowhere to return any values!\\n\", __FUNCTION__);\n        return retval;\n    }\n\n    if (cert == NULL) {\n        pkiDebug(\"%s: no certificate!\\n\", __FUNCTION__);\n        return retval;\n    }\n\n    X509_NAME_oneline(X509_get_subject_name(cert),\n                      buf, sizeof(buf));\n    pkiDebug(\"%s: looking for SANs in cert = %s\\n\", __FUNCTION__, buf);\n\n    l = X509_get_ext_by_NID(cert, NID_subject_alt_name, -1);\n    if (l < 0)\n        return 0;\n\n    if (!(ext = X509_get_ext(cert, l)) || !(ialt = X509V3_EXT_d2i(ext))) {\n        pkiDebug(\"%s: found no subject alt name extensions\\n\", __FUNCTION__);\n        goto cleanup;\n    }\n    num_sans = sk_GENERAL_NAME_num(ialt);\n\n    pkiDebug(\"%s: found %d subject alt name extension(s)\\n\", __FUNCTION__,\n             num_sans);\n\n    /* OK, we're likely returning something. Allocate return values */\n    if (princs_ret != NULL) {\n        princs = calloc(num_sans + 1, sizeof(krb5_principal));\n        if (princs == NULL) {\n            retval = ENOMEM;\n            goto cleanup;\n        }\n    }\n    if (upn_ret != NULL) {\n        upns = calloc(num_sans + 1, sizeof(krb5_principal));\n        if (upns == NULL) {\n            retval = ENOMEM;\n            goto cleanup;\n        }\n    }\n    if (dns_ret != NULL) {\n        dnss = calloc(num_sans + 1, sizeof(*dnss));\n        if (dnss == NULL) {\n            retval = ENOMEM;\n            goto cleanup;\n        }\n    }\n\n    for (i = 0; i < num_sans; i++) {\n        krb5_data name = { 0, 0, NULL };\n\n        gen = sk_GENERAL_NAME_value(ialt, i);\n        switch (gen->type) {\n        case GEN_OTHERNAME:\n            name.length = gen->d.otherName->value->value.sequence->length;\n            name.data = (char *)gen->d.otherName->value->value.sequence->data;\n            if (princs != NULL &&\n                OBJ_cmp(plgctx->id_pkinit_san,\n                        gen->d.otherName->type_id) == 0) {\n#ifdef DEBUG_ASN1\n                print_buffer_bin((unsigned char *)name.data, name.length,\n                                 \"/tmp/pkinit_san\");\n#endif\n                ret = k5int_decode_krb5_principal_name(&name, &princs[p]);\n                if (ret) {\n                    pkiDebug(\"%s: failed decoding pkinit san value\\n\",\n                             __FUNCTION__);\n                } else {\n                    p++;\n                    num_found++;\n                }\n            } else if (upns != NULL &&\n                       OBJ_cmp(plgctx->id_ms_san_upn,\n                               gen->d.otherName->type_id) == 0) {\n                /* Prevent abuse of embedded null characters. */\n                if (memchr(name.data, '\\0', name.length))\n                    break;\n                ret = krb5_parse_name_flags(context, name.data,\n                                            KRB5_PRINCIPAL_PARSE_ENTERPRISE,\n                                            &upns[u]);\n                if (ret) {\n                    pkiDebug(\"%s: failed parsing ms-upn san value\\n\",\n                             __FUNCTION__);\n                } else {\n                    u++;\n                    num_found++;\n                }\n            } else {\n                pkiDebug(\"%s: unrecognized othername oid in SAN\\n\",\n                         __FUNCTION__);\n                continue;\n            }\n\n            break;\n        case GEN_DNS:\n            if (dnss != NULL) {\n                /* Prevent abuse of embedded null characters. */\n                if (memchr(gen->d.dNSName->data, '\\0', gen->d.dNSName->length))\n                    break;\n                pkiDebug(\"%s: found dns name = %s\\n\", __FUNCTION__,\n                         gen->d.dNSName->data);\n                dnss[d] = (unsigned char *)\n                    strdup((char *)gen->d.dNSName->data);\n                if (dnss[d] == NULL) {\n                    pkiDebug(\"%s: failed to duplicate dns name\\n\",\n                             __FUNCTION__);\n                } else {\n                    d++;\n                    num_found++;\n                }\n            }\n            break;\n        default:\n            pkiDebug(\"%s: SAN type = %d expecting %d\\n\", __FUNCTION__,\n                     gen->type, GEN_OTHERNAME);\n        }\n    }\n    sk_GENERAL_NAME_pop_free(ialt, GENERAL_NAME_free);\n\n    retval = 0;\n    if (princs != NULL && *princs != NULL) {\n        *princs_ret = princs;\n        princs = NULL;\n    }\n    if (upns != NULL && *upns != NULL) {\n        *upn_ret = upns;\n        upns = NULL;\n    }\n    if (dnss != NULL && *dnss != NULL) {\n        *dns_ret = dnss;\n        dnss = NULL;\n    }\n\ncleanup:\n    for (i = 0; princs != NULL && princs[i] != NULL; i++)\n        krb5_free_principal(context, princs[i]);\n    free(princs);\n    for (i = 0; upns != NULL && upns[i] != NULL; i++)\n        krb5_free_principal(context, upns[i]);\n    free(upns);\n    for (i = 0; dnss != NULL && dnss[i] != NULL; i++)\n        free(dnss[i]);\n    free(dnss);\n    return retval;\n}", "target": 1, "idx": 10318}
{"commit_id": "e5428348c4d96e506f52614a4d37c158ac839678", "project": "chromium", "func": "int WebContentsImpl::DownloadImage(\n    const GURL& url,\n    bool is_favicon,\n    uint32_t max_bitmap_size,\n    bool bypass_cache,\n    const WebContents::ImageDownloadCallback& callback) {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n  static int next_image_download_id = 0;\n  const image_downloader::ImageDownloaderPtr& mojo_image_downloader =\n      GetMainFrame()->GetMojoImageDownloader();\n  const int download_id = ++next_image_download_id;\n  if (!mojo_image_downloader) {\n    // If the renderer process is dead (i.e. crash, or memory pressure on\n    // Android), the downloader service will be invalid. Pre-Mojo, this would\n    // hang the callback indefinetly since the IPC would be dropped. Now,\n    // respond with a 400 HTTP error code to indicate that something went wrong.\n    image_downloader::DownloadResultPtr result =\n        image_downloader::DownloadResult::New();\n    result->http_status_code = 400;\n    BrowserThread::PostTask(\n        BrowserThread::UI, FROM_HERE,\n        base::Bind(&WebContentsImpl::OnDidDownloadImage,\n                   weak_factory_.GetWeakPtr(), callback, download_id, url,\n                   base::Passed(&result)));\n    return download_id;\n  }\n\n  image_downloader::DownloadRequestPtr req =\n      image_downloader::DownloadRequest::New();\n\n  req->url = mojo::String::From(url);\n  req->is_favicon = is_favicon;\n  req->max_bitmap_size = max_bitmap_size;\n  req->bypass_cache = bypass_cache;\n\n  mojo_image_downloader->DownloadImage(\n      std::move(req), base::Bind(&WebContentsImpl::OnDidDownloadImage,\n                                 weak_factory_.GetWeakPtr(), callback,\n                                 download_id, url));\n  return download_id;\n}", "target": 2, "idx": 10319}
{"commit_id": "1d1c75b6316d21933069a9d201f966d84099f6ca", "project": "swaywm/swaylock", "func": "static void handle_global(void *data, struct wl_registry *registry,\n\t\tuint32_t name, const char *interface, uint32_t version) {\n\tstruct swaylock_state *state = data;\n\tif (strcmp(interface, wl_compositor_interface.name) == 0) {\n\t\tstate->compositor = wl_registry_bind(registry, name,\n\t\t\t\t&wl_compositor_interface, 4);\n\t} else if (strcmp(interface, wl_subcompositor_interface.name) == 0) {\n\t\tstate->subcompositor = wl_registry_bind(registry, name,\n\t\t\t\t&wl_subcompositor_interface, 1);\n\t} else if (strcmp(interface, wl_shm_interface.name) == 0) {\n\t\tstate->shm = wl_registry_bind(registry, name,\n\t\t\t\t&wl_shm_interface, 1);\n\t} else if (strcmp(interface, wl_seat_interface.name) == 0) {\n\t\tstruct wl_seat *seat = wl_registry_bind(\n\t\t\t\tregistry, name, &wl_seat_interface, 4);\n\t\tstruct swaylock_seat *swaylock_seat =\n\t\t\tcalloc(1, sizeof(struct swaylock_seat));\n\t\tswaylock_seat->state = state;\n\t\twl_seat_add_listener(seat, &seat_listener, swaylock_seat);\n\t} else if (strcmp(interface, zwlr_layer_shell_v1_interface.name) == 0) {\n\t\tstate->layer_shell = wl_registry_bind(\n\t\t\t\tregistry, name, &zwlr_layer_shell_v1_interface, 1);\n\t} else if (strcmp(interface, zwlr_input_inhibit_manager_v1_interface.name) == 0) {\n\t\tstate->input_inhibit_manager = wl_registry_bind(\n\t\t\t\tregistry, name, &zwlr_input_inhibit_manager_v1_interface, 1);\n\t} else if (strcmp(interface, zxdg_output_manager_v1_interface.name) == 0) {\n\t\tstate->zxdg_output_manager = wl_registry_bind(\n\t\t\t\tregistry, name, &zxdg_output_manager_v1_interface, 2);\n\t} else if (strcmp(interface, wl_output_interface.name) == 0) {\n\t\tstruct swaylock_surface *surface =\n\t\t\tcalloc(1, sizeof(struct swaylock_surface));\n\t\tsurface->state = state;\n\t\tsurface->output = wl_registry_bind(registry, name,\n\t\t\t\t&wl_output_interface, 3);\n\t\tsurface->output_global_name = name;\n\t\twl_output_add_listener(surface->output, &_wl_output_listener, surface);\n\t\twl_list_insert(&state->surfaces, &surface->link);\n\n\t\tif (state->run_display) {\n\t\t\tcreate_surface(surface);\n\t\t\twl_display_roundtrip(state->display);\n\t\t}\n\t} else if (strcmp(interface, ext_session_lock_manager_v1_interface.name) == 0) {\n\t\tstate->ext_session_lock_manager_v1 = wl_registry_bind(registry, name,\n\t\t\t\t&ext_session_lock_manager_v1_interface, 1);\n\t}\n}", "target": 3, "idx": 10320}
{"commit_id": "4a524d3a8ae9aa20c36430008e6bd429443f8f1d", "project": "android", "func": "WORD32 ih264d_parse_inter_slice_data_cavlc(dec_struct_t * ps_dec,\n                                           dec_slice_params_t * ps_slice,\n                                           UWORD16 u2_first_mb_in_slice)\n{\n    UWORD32 uc_more_data_flag;\n    WORD32 i2_cur_mb_addr;\n    UWORD32 u1_num_mbs, u1_num_mbsNby2, u1_mb_idx;\n    UWORD32 i2_mb_skip_run;\n    UWORD32 u1_read_mb_type;\n\n    UWORD32 u1_mbaff;\n    UWORD32 u1_num_mbs_next, u1_end_of_row;\n    const UWORD32 i2_pic_wdin_mbs = ps_dec->u2_frm_wd_in_mbs;\n    UWORD32 u1_slice_end = 0;\n    UWORD32 u1_tfr_n_mb = 0;\n    UWORD32 u1_decode_nmb = 0;\n\n    dec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;\n    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;\n    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;\n    deblk_mb_t *ps_cur_deblk_mb;\n    dec_mb_info_t *ps_cur_mb_info;\n    parse_pmbarams_t *ps_parse_mb_data = ps_dec->ps_parse_mb_data;\n    UWORD32 u1_inter_mb_type;\n    UWORD32 u1_deblk_mb_type;\n    UWORD32 u1_mb_threshold;\n    WORD32 ret = OK;\n\n    /******************************************************/\n    /* Initialisations specific to B or P slice           */\n    /******************************************************/\n\n    if(ps_slice->u1_slice_type == P_SLICE)\n    {\n        u1_inter_mb_type = P_MB;\n        u1_deblk_mb_type = D_INTER_MB;\n        u1_mb_threshold = 5;\n    }\n    else // B_SLICE\n    {\n        u1_inter_mb_type = B_MB;\n        u1_deblk_mb_type = D_B_SLICE;\n        u1_mb_threshold = 23;\n    }\n    /******************************************************/\n    /* Slice Level Initialisations                        */\n    /******************************************************/\n    ps_dec->u1_qp = ps_slice->u1_slice_qp;\n    ih264d_update_qp(ps_dec, 0);\n    u1_mb_idx = ps_dec->u1_mb_idx;\n    u1_num_mbs = u1_mb_idx;\n\n    u1_num_mbsNby2 = 0;\n    u1_mbaff = ps_slice->u1_mbaff_frame_flag;\n    i2_cur_mb_addr = u2_first_mb_in_slice << u1_mbaff;\n    i2_mb_skip_run = 0;\n    uc_more_data_flag = 1;\n    u1_read_mb_type = 0;\n\n    while(!u1_slice_end)\n    {\n        UWORD8 u1_mb_type;\n\n        ps_dec->pv_prev_mb_parse_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;\n\n        if(i2_cur_mb_addr > ps_dec->ps_cur_sps->u2_max_mb_addr)\n        {\n            ret = ERROR_MB_ADDRESS_T;\n            break;\n        }\n\n\n        ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs;\n        ps_dec->u4_num_mbs_cur_nmb = u1_num_mbs;\n\n        ps_cur_mb_info->u1_Mux = 0;\n        ps_dec->u4_num_pmbair = (u1_num_mbs >> u1_mbaff);\n        ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_num_mbs;\n\n        ps_cur_mb_info->u1_end_of_slice = 0;\n\n        /* Storing Default partition info */\n        ps_parse_mb_data->u1_num_part = 1;\n        ps_parse_mb_data->u1_isI_mb = 0;\n\n        if((!i2_mb_skip_run) && (!u1_read_mb_type))\n        {\n\n            //Inlined ih264d_uev\n            UWORD32 u4_bitstream_offset = *pu4_bitstrm_ofst;\n            UWORD32 u4_word, u4_ldz;\n\n            /***************************************************************/\n            /* Find leading zeros in next 32 bits                          */\n            /***************************************************************/\n            NEXTBITS_32(u4_word, u4_bitstream_offset, pu4_bitstrm_buf);\n\n            u4_ldz = CLZ(u4_word);\n\n            /* Flush the ps_bitstrm */\n            u4_bitstream_offset += (u4_ldz + 1);\n            /* Read the suffix from the ps_bitstrm */\n            u4_word = 0;\n            if(u4_ldz)\n            {\n                GETBITS(u4_word, u4_bitstream_offset, pu4_bitstrm_buf,\n                        u4_ldz);\n            }\n            *pu4_bitstrm_ofst = u4_bitstream_offset;\n            i2_mb_skip_run = ((1 << u4_ldz) + u4_word - 1);\n            //Inlined ih264d_uev\n            COPYTHECONTEXT(\"mb_skip_run\", i2_mb_skip_run);\n            uc_more_data_flag = MORE_RBSP_DATA(ps_bitstrm);\n            u1_read_mb_type = uc_more_data_flag;\n        }\n\n        /***************************************************************/\n        /* Get the required information for decoding of MB                  */\n        /* mb_x, mb_y , neighbour availablity,                              */\n        /***************************************************************/\n        ps_dec->pf_get_mb_info(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);\n\n        /***************************************************************/\n        /* Set the deblocking parameters for this MB                   */\n        /***************************************************************/\n        if(ps_dec->u4_app_disable_deblk_frm == 0)\n            ih264d_set_deblocking_parameters(ps_cur_deblk_mb, ps_slice,\n                                             ps_dec->u1_mb_ngbr_availablity,\n                                             ps_dec->u1_cur_mb_fld_dec_flag);\n\n        if(i2_mb_skip_run)\n        {\n            /* Set appropriate flags in ps_cur_mb_info and ps_dec */\n            ps_dec->i1_prev_mb_qp_delta = 0;\n            ps_dec->u1_sub_mb_num = 0;\n            ps_cur_mb_info->u1_mb_type = MB_SKIP;\n            ps_cur_mb_info->u1_mb_mc_mode = PRED_16x16;\n            ps_cur_mb_info->u1_cbp = 0;\n\n            {\n                /* Storing Skip partition info */\n                parse_part_params_t *ps_part_info = ps_dec->ps_part;\n                ps_part_info->u1_is_direct = PART_DIRECT_16x16;\n                ps_part_info->u1_sub_mb_num = 0;\n                ps_dec->ps_part++;\n            }\n\n            /* Update Nnzs */\n            ih264d_update_nnz_for_skipmb(ps_dec, ps_cur_mb_info, CAVLC);\n\n            ps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;\n            ps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;\n\n            i2_mb_skip_run--;\n        }\n        else\n        {\n            u1_read_mb_type = 0;\n            /**************************************************************/\n            /* Macroblock Layer Begins, Decode the u1_mb_type                */\n            /**************************************************************/\n            {\n                UWORD32 u4_bitstream_offset = *pu4_bitstrm_ofst;\n                UWORD32 u4_word, u4_ldz, u4_temp;\n\n\n                //Inlined ih264d_uev\n                /***************************************************************/\n                /* Find leading zeros in next 32 bits                          */\n                /***************************************************************/\n                NEXTBITS_32(u4_word, u4_bitstream_offset, pu4_bitstrm_buf);\n                u4_ldz = CLZ(u4_word);\n                /* Flush the ps_bitstrm */\n                u4_bitstream_offset += (u4_ldz + 1);\n                /* Read the suffix from the ps_bitstrm */\n                u4_word = 0;\n                if(u4_ldz)\n                    GETBITS(u4_word, u4_bitstream_offset, pu4_bitstrm_buf,\n                            u4_ldz);\n                *pu4_bitstrm_ofst = u4_bitstream_offset;\n                u4_temp = ((1 << u4_ldz) + u4_word - 1);\n                //Inlined ih264d_uev\n                if(u4_temp > (UWORD32)(25 + u1_mb_threshold))\n                    return ERROR_MB_TYPE;\n                u1_mb_type = u4_temp;\n                COPYTHECONTEXT(\"u1_mb_type\", u1_mb_type);\n            }\n            ps_cur_mb_info->u1_mb_type = u1_mb_type;\n\n            /**************************************************************/\n            /* Parse Macroblock data                                      */\n            /**************************************************************/\n            if(u1_mb_type < u1_mb_threshold)\n            {\n                ps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;\n\n                ret = ps_dec->pf_parse_inter_mb(ps_dec, ps_cur_mb_info, u1_num_mbs,\n                                          u1_num_mbsNby2);\n                if(ret != OK)\n                    return ret;\n                ps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;\n            }\n            else\n            {\n                /* Storing Intra partition info */\n                ps_parse_mb_data->u1_num_part = 0;\n                ps_parse_mb_data->u1_isI_mb = 1;\n\n                if((25 + u1_mb_threshold) == u1_mb_type)\n                {\n                    /* I_PCM_MB */\n                    ps_cur_mb_info->ps_curmb->u1_mb_type = I_PCM_MB;\n                    ret = ih264d_parse_ipcm_mb(ps_dec, ps_cur_mb_info, u1_num_mbs);\n                    if(ret != OK)\n                         return ret;\n                    ps_dec->u1_qp = 0;\n                }\n                else\n                {\n                    ret = ih264d_parse_imb_cavlc(\n                                    ps_dec, ps_cur_mb_info, u1_num_mbs,\n                                    (UWORD8)(u1_mb_type - u1_mb_threshold));\n                    if(ret != OK)\n                        return ret;\n                }\n\n                ps_cur_deblk_mb->u1_mb_type |= D_INTRA_MB;\n            }\n            uc_more_data_flag = MORE_RBSP_DATA(ps_bitstrm);\n        }\n        ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;\n\n        if(u1_mbaff)\n        {\n            ih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info);\n        }\n        /**************************************************************/\n        /* Get next Macroblock address                                */\n        /**************************************************************/\n        i2_cur_mb_addr++;\n\n        u1_num_mbs++;\n        u1_num_mbsNby2++;\n        ps_parse_mb_data++;\n\n        /****************************************************************/\n        /* Check for End Of Row and other flags that determine when to  */\n        /* do DMA setup for N/2-Mb, Decode for N-Mb, and Transfer for   */\n        /* N-Mb                                                         */\n        /****************************************************************/\n        u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;\n        u1_end_of_row = (!u1_num_mbs_next) && (!(u1_mbaff && (u1_num_mbs & 0x01)));\n        u1_slice_end = (!(uc_more_data_flag || i2_mb_skip_run));\n        u1_tfr_n_mb = (u1_num_mbs == ps_dec->u1_recon_mb_grp) || u1_end_of_row\n                        || u1_slice_end;\n        u1_decode_nmb = u1_tfr_n_mb || u1_slice_end;\n        ps_cur_mb_info->u1_end_of_slice = u1_slice_end;\n\n        /*u1_dma_nby2mb   = u1_decode_nmb ||\n         (u1_num_mbsNby2 == ps_dec->u1_recon_mb_grp_pair);*/\n\n//if(u1_dma_nby2mb)\n        if(u1_decode_nmb)\n        {\n            ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx, u1_num_mbs);\n            u1_num_mbsNby2 = 0;\n\n            {\n                ps_parse_mb_data = ps_dec->ps_parse_mb_data;\n                ps_dec->ps_part = ps_dec->ps_parse_part_params;\n            }\n        }\n\n        /*H264_DEC_DEBUG_PRINT(\"Pic: %d Mb_X=%d Mb_Y=%d\",\n         ps_slice->i4_poc >> ps_slice->u1_field_pic_flag,\n         ps_dec->u2_mbx,ps_dec->u2_mby + (1 - ps_cur_mb_info->u1_topmb));\n         H264_DEC_DEBUG_PRINT(\"u1_decode_nmb: %d\", u1_decode_nmb);*/\n        if(u1_decode_nmb)\n        {\n\n\n\n            if(ps_dec->u1_separate_parse)\n            {\n                ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                                     u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n                ps_dec->ps_nmb_info +=  u1_num_mbs;\n            }\n            else\n            {\n                ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                                            u1_num_mbs_next, u1_tfr_n_mb,\n                                            u1_end_of_row);\n            }\n            ps_dec->u2_total_mbs_coded += u1_num_mbs;\n            if(u1_tfr_n_mb)\n                u1_num_mbs = 0;\n            u1_mb_idx = u1_num_mbs;\n            ps_dec->u1_mb_idx = u1_num_mbs;\n\n        }\n//ps_dec->ps_pred++;\n    }\n\n    ps_dec->u4_num_mbs_cur_nmb = 0;\n    ps_dec->ps_cur_slice->u4_mbs_in_slice = i2_cur_mb_addr\n                        - (u2_first_mb_in_slice << u1_mbaff);\n\n\n    return ret;\n}", "target": 3, "idx": 10321}
{"commit_id": "45ef78e037f578b15fc58938a3a3251655e71d6f", "project": "lurcher/unixODBC", "func": "BOOL SQLWriteFileDSN(\t\t\tLPCSTR\tpszFileName,\n\t\t\t\t\t\t\t\tLPCSTR\tpszAppName,\n\t\t\t\t\t\t\t\tLPCSTR\tpszKeyName,\n\t\t\t\t\t\t\t\tLPCSTR\tpszString )\n{\n\tHINI\thIni;\n\tchar\tszFileName[ODBC_FILENAME_MAX+1];\n\n\tif ( pszFileName[0] == '/' )\n\t{\n\t\tstrncpy( szFileName, pszFileName, sizeof(szFileName) - 5 );\n\t}\n\telse\n\t{\t\n\t\tchar szPath[ODBC_FILENAME_MAX+1];\n\t\t*szPath = '\\0';\n\t\t_odbcinst_FileINI( szPath );\n\t\tsnprintf( szFileName, sizeof(szFileName) - 5, \"%s/%s\", szPath, pszFileName );\n\t}\n\n    if ( strlen( szFileName ) < 4 || strcmp( szFileName + strlen( szFileName ) - 4, \".dsn\" ))\n    {\n        strcat( szFileName, \".dsn\" );\n    }\n\n#ifdef __OS2__\n\tif ( iniOpen( &hIni, szFileName, \"#;\", '[', ']', '=', TRUE, 0L ) != INI_SUCCESS )\n#else\n\tif ( iniOpen( &hIni, szFileName, \"#;\", '[', ']', '=', TRUE ) != INI_SUCCESS )\n#endif\n\t{\n       \tinst_logPushMsg( __FILE__, __FILE__, __LINE__, LOG_CRITICAL, ODBC_ERROR_INVALID_PATH, \"\" );\n\t\treturn FALSE;\n\t}\n\n\t/* delete section */\n\tif ( pszString == NULL && pszKeyName == NULL )\n\t{\n\t\tif ( iniObjectSeek( hIni, (char *)pszAppName ) == INI_SUCCESS )\n        {\n\t\t\tiniObjectDelete( hIni );\n        }\n\t}\n\t/* delete entry */\n\telse if\t( pszString == NULL )\n\t{\n\t\tif ( iniPropertySeek( hIni, (char *)pszAppName, (char *)pszKeyName, \"\" ) == INI_SUCCESS )\n        {\n\t\t\tiniPropertyDelete( hIni );\n        }\n\t}\n\telse\n\t{\n\t\t/* add section */\n\t\tif ( iniObjectSeek( hIni, (char *)pszAppName ) != INI_SUCCESS )\n        {\n\t\t\tiniObjectInsert( hIni, (char *)pszAppName );\n        }\n\t\t/* update entry */\n\t\tif ( iniPropertySeek( hIni, (char *)pszAppName, (char *)pszKeyName, \"\" ) == INI_SUCCESS )\n\t\t{\n\t\t\tiniObjectSeek( hIni, (char *)pszAppName );\n\t\t\tiniPropertyUpdate( hIni, (char *)pszKeyName, (char *)pszString );\n\t\t}\n\t\t/* add entry */\n\t\telse\n\t\t{\n\t\t\tiniObjectSeek( hIni, (char *)pszAppName );\n\t\t\tiniPropertyInsert( hIni, (char *)pszKeyName, (char *)pszString );\n\t\t}\n\t}\n\n\tif ( iniCommit( hIni ) != INI_SUCCESS )\n\t{\n\t\tiniClose( hIni );\n        inst_logPushMsg( __FILE__, __FILE__, __LINE__, LOG_CRITICAL, ODBC_ERROR_REQUEST_FAILED, \"\" );\n\t\treturn FALSE;\n\t}\n\n\tiniClose( hIni );\n\n\treturn TRUE;\n}", "target": 3, "idx": 10322}
{"commit_id": "87fb7909c49e6a4510ba86ace1ffc83459c7e1b9", "project": "android", "func": "WORD32 ihevcd_decode(iv_obj_t *ps_codec_obj, void *pv_api_ip, void *pv_api_op)\n{\n    WORD32 ret = IV_SUCCESS;\n    codec_t *ps_codec = (codec_t *)(ps_codec_obj->pv_codec_handle);\n    ivd_video_decode_ip_t *ps_dec_ip;\n    ivd_video_decode_op_t *ps_dec_op;\n\n    WORD32 proc_idx = 0;\n    WORD32 prev_proc_idx = 0;\n\n    /* Initialize error code */\n    ps_codec->i4_error_code = 0;\n\n    ps_dec_ip = (ivd_video_decode_ip_t *)pv_api_ip;\n    ps_dec_op = (ivd_video_decode_op_t *)pv_api_op;\n\n    {\n        UWORD32 u4_size = ps_dec_op->u4_size;\n        memset(ps_dec_op, 0, sizeof(ivd_video_decode_op_t));\n        ps_dec_op->u4_size = u4_size; //Restore size field\n    }\n    if(ps_codec->i4_init_done != 1)\n    {\n        ps_dec_op->u4_error_code |= 1 << IVD_FATALERROR;\n        ps_dec_op->u4_error_code |= IHEVCD_INIT_NOT_DONE;\n        return IV_FAIL;\n    }\n\n    if(ps_codec->u4_pic_cnt >= NUM_FRAMES_LIMIT)\n    {\n        ps_dec_op->u4_error_code |= 1 << IVD_FATALERROR;\n        ps_dec_op->u4_error_code |= IHEVCD_NUM_FRAMES_LIMIT_REACHED;\n        return IV_FAIL;\n    }\n\n    /* If reset flag is set, flush the existing buffers */\n    if(ps_codec->i4_reset_flag)\n    {\n        ps_codec->i4_flush_mode = 1;\n    }\n\n    /*Data memory barries instruction,so that bitstream write by the application is complete*/\n    //arm_dsb();\n    /* In case the decoder is not in flush mode check for input buffer validity */\n    if(0 == ps_codec->i4_flush_mode)\n    {\n        if(ps_dec_ip->pv_stream_buffer == NULL)\n        {\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL;\n            return IV_FAIL;\n        }\n        if(ps_dec_ip->u4_num_Bytes <= MIN_START_CODE_LEN)\n        {\n            if((WORD32)ps_dec_ip->u4_num_Bytes > 0)\n                ps_dec_op->u4_num_bytes_consumed = ps_dec_ip->u4_num_Bytes;\n            else\n                ps_dec_op->u4_num_bytes_consumed = 0;\n\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DEC_NUMBYTES_INV;\n            return IV_FAIL;\n\n        }\n    }\n\n#ifdef APPLY_CONCEALMENT\n    {\n        WORD32 num_mbs;\n\n        num_mbs = (ps_codec->i4_wd * ps_codec->i4_ht + 255) >> 8;\n        /* Reset MB Count at the beginning of every process call */\n        ps_codec->mb_count = 0;\n        memset(ps_codec->mb_map, 0, ((num_mbs + 7) >> 3));\n    }\n#endif\n\n    if(0 == ps_codec->i4_share_disp_buf && ps_codec->i4_header_mode == 0)\n    {\n        UWORD32 i;\n        if(ps_dec_ip->s_out_buffer.u4_num_bufs == 0)\n        {\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS;\n            return IV_FAIL;\n        }\n\n        for(i = 0; i < ps_dec_ip->s_out_buffer.u4_num_bufs; i++)\n        {\n            if(ps_dec_ip->s_out_buffer.pu1_bufs[i] == NULL)\n            {\n                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n                ps_dec_op->u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL;\n                return IV_FAIL;\n            }\n\n            if(ps_dec_ip->s_out_buffer.u4_min_out_buf_size[i] == 0)\n            {\n                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n                ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUF_SIZE;\n                return IV_FAIL;\n            }\n        }\n    }\n\n    ps_codec->ps_out_buffer = &ps_dec_ip->s_out_buffer;\n    ps_codec->u4_ts = ps_dec_ip->u4_ts;\n    if(ps_codec->i4_flush_mode)\n    {\n\n        ps_dec_op->u4_pic_wd = ps_codec->i4_disp_wd;\n        ps_dec_op->u4_pic_ht = ps_codec->i4_disp_ht;\n\n        ps_dec_op->u4_new_seq = 0;\n\n        ps_codec->ps_disp_buf = (pic_buf_t *)ihevc_disp_mgr_get(\n                        (disp_mgr_t *)ps_codec->pv_disp_buf_mgr, &ps_codec->i4_disp_buf_id);\n        /* In case of non-shared mode, then convert/copy the frame to output buffer */\n        /* Only if the codec is in non-shared mode or in shared mode but needs 420P output */\n        if((ps_codec->ps_disp_buf)\n                        && ((0 == ps_codec->i4_share_disp_buf)\n                                        || (IV_YUV_420P\n                                                        == ps_codec->e_chroma_fmt)))\n        {\n\n            process_ctxt_t *ps_proc = &ps_codec->as_process[prev_proc_idx];\n            if(0 == ps_proc->i4_init_done)\n            {\n                ihevcd_init_proc_ctxt(ps_proc, 0);\n            }\n\n            /* Output buffer check */\n            ret = ihevcd_check_out_buf_size(ps_codec);\n            RETURN_IF((ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS), ret);\n\n            /* Set remaining number of rows to be processed */\n            ret = ihevcd_fmt_conv(ps_codec, &ps_codec->as_process[prev_proc_idx],\n                                  ps_dec_ip->s_out_buffer.pu1_bufs[0],\n                                  ps_dec_ip->s_out_buffer.pu1_bufs[1],\n                                  ps_dec_ip->s_out_buffer.pu1_bufs[2], 0,\n                                  ps_codec->i4_disp_ht);\n\n            ihevc_buf_mgr_release((buf_mgr_t *)ps_codec->pv_pic_buf_mgr,\n                                  ps_codec->i4_disp_buf_id, BUF_MGR_DISP);\n        }\n\n        ihevcd_fill_outargs(ps_codec, ps_dec_ip, ps_dec_op);\n\n        if(1 == ps_dec_op->u4_output_present)\n        {\n            WORD32 xpos = ps_codec->i4_disp_wd - 32 - LOGO_WD;\n            WORD32 ypos = ps_codec->i4_disp_ht - 32 - LOGO_HT;\n\n            if(ypos < 0)\n                ypos = 0;\n\n            if(xpos < 0)\n                xpos = 0;\n\n            INSERT_LOGO(ps_dec_ip->s_out_buffer.pu1_bufs[0],\n                        ps_dec_ip->s_out_buffer.pu1_bufs[1],\n                        ps_dec_ip->s_out_buffer.pu1_bufs[2], ps_codec->i4_disp_strd,\n                        xpos,\n                        ypos,\n                        ps_codec->e_chroma_fmt,\n                        ps_codec->i4_disp_wd,\n                        ps_codec->i4_disp_ht);\n        }\n\n\n        if(NULL == ps_codec->ps_disp_buf)\n        {\n            /* If in flush mode and there are no more buffers to flush,\n             * check for the reset flag and reset the decoder */\n            if(ps_codec->i4_reset_flag)\n            {\n                ihevcd_init(ps_codec);\n            }\n            return (IV_FAIL);\n        }\n\n        return (IV_SUCCESS);\n\n    }\n    /* In case of shared mode, check if there is a free buffer for reconstruction */\n    if((0 == ps_codec->i4_header_mode) && (1 == ps_codec->i4_share_disp_buf))\n    {\n        WORD32 buf_status;\n        buf_status = 1;\n        if(ps_codec->pv_pic_buf_mgr)\n            buf_status = ihevc_buf_mgr_check_free((buf_mgr_t *)ps_codec->pv_pic_buf_mgr);\n\n        /* If there is no free buffer, then return with an error code */\n        if(0 == buf_status)\n        {\n            ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;\n            ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\n            return IV_FAIL;\n        }\n    }\n    ps_codec->i4_bytes_remaining = ps_dec_ip->u4_num_Bytes;\n    ps_codec->pu1_inp_bitsbuf = (UWORD8 *)ps_dec_ip->pv_stream_buffer;\n    ps_codec->s_parse.i4_end_of_frame = 0;\n\n    ps_codec->i4_pic_present = 0;\n    ps_codec->i4_slice_error = 0;\n    ps_codec->ps_disp_buf = NULL;\n\n    if(ps_codec->i4_num_cores > 1)\n    {\n        ithread_set_affinity(0);\n    }\n    while(MIN_START_CODE_LEN < ps_codec->i4_bytes_remaining)\n    {\n        WORD32 nal_len;\n        WORD32 nal_ofst;\n        WORD32 bits_len;\n\n        if(ps_codec->i4_slice_error)\n        {\n            slice_header_t *ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1));\n            WORD32 next_slice_addr = ps_slice_hdr_next->i2_ctb_x +\n                            ps_slice_hdr_next->i2_ctb_y * ps_codec->s_parse.ps_sps->i2_pic_wd_in_ctb;\n            if(ps_codec->s_parse.i4_next_ctb_indx == next_slice_addr)\n                ps_codec->i4_slice_error = 0;\n        }\n\n        if(ps_codec->pu1_bitsbuf_dynamic)\n        {\n            ps_codec->pu1_bitsbuf = ps_codec->pu1_bitsbuf_dynamic;\n            ps_codec->u4_bitsbuf_size = ps_codec->u4_bitsbuf_size_dynamic;\n        }\n        else\n        {\n            ps_codec->pu1_bitsbuf = ps_codec->pu1_bitsbuf_static;\n            ps_codec->u4_bitsbuf_size = ps_codec->u4_bitsbuf_size_static;\n        }\n\n        nal_ofst = ihevcd_nal_search_start_code(ps_codec->pu1_inp_bitsbuf,\n                                                ps_codec->i4_bytes_remaining);\n\n        ps_codec->i4_nal_ofst = nal_ofst;\n        {\n            WORD32 bytes_remaining = ps_codec->i4_bytes_remaining - nal_ofst;\n\n            bytes_remaining = MIN((UWORD32)bytes_remaining, ps_codec->u4_bitsbuf_size);\n            ihevcd_nal_remv_emuln_bytes(ps_codec->pu1_inp_bitsbuf + nal_ofst,\n                                        ps_codec->pu1_bitsbuf,\n                                        bytes_remaining,\n                                        &nal_len, &bits_len);\n\n            /* Decoder may read upto 8 extra bytes at the end of frame */\n            /* These are not used, but still set them to zero to avoid uninitialized reads */\n            if(bits_len < (WORD32)(ps_codec->u4_bitsbuf_size - 8))\n            {\n                memset(ps_codec->pu1_bitsbuf + bits_len, 0, 2 * sizeof(UWORD32));\n            }\n        }\n        /* This may be used to update the offsets for tiles and entropy sync row offsets */\n        ps_codec->i4_num_emln_bytes = nal_len - bits_len;\n        ps_codec->i4_nal_len = nal_len;\n\n        ihevcd_bits_init(&ps_codec->s_parse.s_bitstrm, ps_codec->pu1_bitsbuf,\n                         bits_len);\n\n        ret = ihevcd_nal_unit(ps_codec);\n\n        /* If the frame is incomplete and\n         * the bytes remaining is zero or a header is received,\n         * complete the frame treating it to be in error */\n        if(ps_codec->i4_pic_present &&\n                        (ps_codec->s_parse.i4_next_ctb_indx != ps_codec->s_parse.ps_sps->i4_pic_size_in_ctb))\n        {\n            if((ps_codec->i4_bytes_remaining - (nal_len + nal_ofst) <= MIN_START_CODE_LEN) ||\n                            (ps_codec->i4_header_in_slice_mode))\n            {\n                slice_header_t *ps_slice_hdr_next;\n\n                ps_codec->s_parse.i4_cur_slice_idx--;\n                if(ps_codec->s_parse.i4_cur_slice_idx < 0)\n                    ps_codec->s_parse.i4_cur_slice_idx = 0;\n\n                ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + ((ps_codec->s_parse.i4_cur_slice_idx + 1) & (MAX_SLICE_HDR_CNT - 1));\n                ps_slice_hdr_next->i2_ctb_x = 0;\n                ps_slice_hdr_next->i2_ctb_y = ps_codec->s_parse.ps_sps->i2_pic_ht_in_ctb;\n                ps_codec->i4_slice_error = 1;\n                continue;\n            }\n        }\n\n        if(IHEVCD_IGNORE_SLICE == ret)\n        {\n            ps_codec->pu1_inp_bitsbuf += (nal_ofst + nal_len);\n            ps_codec->i4_bytes_remaining -= (nal_ofst + nal_len);\n\n            continue;\n        }\n\n        if((IVD_RES_CHANGED == ret) ||\n           (IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED == ret))\n        {\n            break;\n        }\n\n        /* Update bytes remaining and bytes consumed and input bitstream pointer */\n        /* Do not consume the NAL in the following cases */\n        /* Slice header reached during header decode mode */\n        /* TODO: Next picture's slice reached */\n        if(ret != IHEVCD_SLICE_IN_HEADER_MODE)\n        {\n            if((0 == ps_codec->i4_slice_error) ||\n                            (ps_codec->i4_bytes_remaining - (nal_len + nal_ofst) <= MIN_START_CODE_LEN))\n            {\n                ps_codec->pu1_inp_bitsbuf += (nal_ofst + nal_len);\n                ps_codec->i4_bytes_remaining -= (nal_ofst + nal_len);\n            }\n            if(ret != IHEVCD_SUCCESS)\n                break;\n\n            if(ps_codec->s_parse.i4_end_of_frame)\n                break;\n        }\n        else\n        {\n            ret = IHEVCD_SUCCESS;\n            break;\n        }\n\n        /* Allocate dynamic bitstream buffer once SPS is decoded */\n        if((ps_codec->u4_allocate_dynamic_done == 0) && ps_codec->i4_sps_done)\n        {\n            WORD32 ret;\n            ret = ihevcd_allocate_dynamic_bufs(ps_codec);\n            if(ret != IV_SUCCESS)\n            {\n                /* Free any dynamic buffers that are allocated */\n                ihevcd_free_dynamic_bufs(ps_codec);\n                ps_codec->i4_error_code = IVD_MEM_ALLOC_FAILED;\n                ps_dec_op->u4_error_code |= 1 << IVD_FATALERROR;\n                ps_dec_op->u4_error_code |= IVD_MEM_ALLOC_FAILED;\n\n                return IV_FAIL;\n            }\n        }\n\n        BREAK_AFTER_SLICE_NAL();\n    }\n\n    if((ps_codec->u4_pic_cnt == 0) && (ret != IHEVCD_SUCCESS))\n    {\n        ps_codec->i4_error_code = ret;\n\n        ihevcd_fill_outargs(ps_codec, ps_dec_ip, ps_dec_op);\n        return IV_FAIL;\n    }\n\n    if(1 == ps_codec->i4_pic_present)\n    {\n        WORD32 i;\n        sps_t *ps_sps = ps_codec->s_parse.ps_sps;\n        ps_codec->i4_first_pic_done = 1;\n\n        /*TODO temporary fix: end_of_frame is checked before adding format conversion to job queue         */\n        if(ps_codec->i4_num_cores > 1 && ps_codec->s_parse.i4_end_of_frame)\n        {\n\n            /* Add job queue for format conversion / frame copy for each ctb row */\n            /* Only if the codec is in non-shared mode or in shared mode but needs 420P output */\n            process_ctxt_t *ps_proc;\n\n            /* i4_num_cores - 1 contexts are currently being used by other threads */\n            ps_proc = &ps_codec->as_process[ps_codec->i4_num_cores - 1];\n\n            if((ps_codec->ps_disp_buf) &&\n               ((0 == ps_codec->i4_share_disp_buf) || (IV_YUV_420P == ps_codec->e_chroma_fmt)))\n            {\n                /* If format conversion jobs were not issued in pic_init() add them here */\n                if((0 == ps_codec->u4_enable_fmt_conv_ahead) ||\n                                (ps_codec->i4_disp_buf_id == ps_proc->i4_cur_pic_buf_id))\n                    for(i = 0; i < ps_sps->i2_pic_ht_in_ctb; i++)\n                    {\n                        proc_job_t s_job;\n                        IHEVCD_ERROR_T ret;\n                        s_job.i4_cmd = CMD_FMTCONV;\n                        s_job.i2_ctb_cnt = 0;\n                        s_job.i2_ctb_x = 0;\n                        s_job.i2_ctb_y = i;\n                        s_job.i2_slice_idx = 0;\n                        s_job.i4_tu_coeff_data_ofst = 0;\n                        ret = ihevcd_jobq_queue((jobq_t *)ps_codec->s_parse.pv_proc_jobq,\n                                                &s_job, sizeof(proc_job_t), 1);\n                        if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)\n                            return (WORD32)ret;\n                    }\n            }\n            /* Reached end of frame : Signal terminate */\n            /* The terminate flag is checked only after all the jobs are dequeued */\n            ret = ihevcd_jobq_terminate((jobq_t *)ps_codec->s_parse.pv_proc_jobq);\n\n            while(1)\n            {\n                IHEVCD_ERROR_T ret;\n                proc_job_t s_job;\n                process_ctxt_t *ps_proc;\n\n                /* i4_num_cores - 1 contexts are currently being used by other threads */\n                ps_proc = &ps_codec->as_process[ps_codec->i4_num_cores - 1];\n\n                ret = ihevcd_jobq_dequeue((jobq_t *)ps_proc->pv_proc_jobq, &s_job,\n                                          sizeof(proc_job_t), 1);\n                if((IHEVCD_ERROR_T)IHEVCD_SUCCESS != ret)\n                    break;\n\n                ps_proc->i4_ctb_cnt = s_job.i2_ctb_cnt;\n                ps_proc->i4_ctb_x = s_job.i2_ctb_x;\n                ps_proc->i4_ctb_y = s_job.i2_ctb_y;\n                ps_proc->i4_cur_slice_idx = s_job.i2_slice_idx;\n\n                if(CMD_PROCESS == s_job.i4_cmd)\n                {\n                    ihevcd_init_proc_ctxt(ps_proc, s_job.i4_tu_coeff_data_ofst);\n\n                    ihevcd_process(ps_proc);\n                }\n                else if(CMD_FMTCONV == s_job.i4_cmd)\n                {\n                    sps_t *ps_sps = ps_codec->s_parse.ps_sps;\n                    WORD32 num_rows = 1 << ps_sps->i1_log2_ctb_size;\n                    if(0 == ps_proc->i4_init_done)\n                    {\n                        ihevcd_init_proc_ctxt(ps_proc, 0);\n                    }\n\n                    num_rows = MIN(num_rows, (ps_codec->i4_disp_ht - (s_job.i2_ctb_y << ps_sps->i1_log2_ctb_size)));\n                    if(num_rows < 0)\n                        num_rows = 0;\n\n                    ihevcd_fmt_conv(ps_codec, ps_proc,\n                                    ps_dec_ip->s_out_buffer.pu1_bufs[0],\n                                    ps_dec_ip->s_out_buffer.pu1_bufs[1],\n                                    ps_dec_ip->s_out_buffer.pu1_bufs[2],\n                                    s_job.i2_ctb_y << ps_sps->i1_log2_ctb_size,\n                                    num_rows);\n                }\n            }\n        }\n        /* In case of non-shared mode and while running in single core mode, then convert/copy the frame to output buffer */\n        /* Only if the codec is in non-shared mode or in shared mode but needs 420P output */\n        else if((ps_codec->ps_disp_buf) && ((0 == ps_codec->i4_share_disp_buf) ||\n                                            (IV_YUV_420P == ps_codec->e_chroma_fmt)) &&\n                        (ps_codec->s_parse.i4_end_of_frame))\n        {\n            process_ctxt_t *ps_proc = &ps_codec->as_process[proc_idx];\n            /* Set remaining number of rows to be processed */\n            ps_codec->s_fmt_conv.i4_num_rows = ps_codec->i4_disp_ht\n                            - ps_codec->s_fmt_conv.i4_cur_row;\n            if(0 == ps_proc->i4_init_done)\n            {\n                ihevcd_init_proc_ctxt(ps_proc, 0);\n            }\n\n            if(ps_codec->s_fmt_conv.i4_num_rows < 0)\n                ps_codec->s_fmt_conv.i4_num_rows = 0;\n\n            ret = ihevcd_fmt_conv(ps_codec, ps_proc,\n                                  ps_dec_ip->s_out_buffer.pu1_bufs[0],\n                                  ps_dec_ip->s_out_buffer.pu1_bufs[1],\n                                  ps_dec_ip->s_out_buffer.pu1_bufs[2],\n                                  ps_codec->s_fmt_conv.i4_cur_row,\n                                  ps_codec->s_fmt_conv.i4_num_rows);\n            ps_codec->s_fmt_conv.i4_cur_row += ps_codec->s_fmt_conv.i4_num_rows;\n\n        }\n\n\n        DEBUG_DUMP_MV_MAP(ps_codec);\n\n        /* Mark MV Buf as needed for reference */\n        ihevc_buf_mgr_set_status((buf_mgr_t *)ps_codec->pv_mv_buf_mgr,\n                                 ps_codec->as_process[proc_idx].i4_cur_mv_bank_buf_id,\n                                 BUF_MGR_REF);\n\n        /* Mark pic buf as needed for reference */\n        ihevc_buf_mgr_set_status((buf_mgr_t *)ps_codec->pv_pic_buf_mgr,\n                                 ps_codec->as_process[proc_idx].i4_cur_pic_buf_id,\n                                 BUF_MGR_REF);\n\n        /* Mark pic buf as needed for display */\n        ihevc_buf_mgr_set_status((buf_mgr_t *)ps_codec->pv_pic_buf_mgr,\n                                 ps_codec->as_process[proc_idx].i4_cur_pic_buf_id,\n                                 BUF_MGR_DISP);\n\n        /* Insert the current picture as short term reference */\n        ihevc_dpb_mgr_insert_ref((dpb_mgr_t *)ps_codec->pv_dpb_mgr,\n                                 ps_codec->as_process[proc_idx].ps_cur_pic,\n                                 ps_codec->as_process[proc_idx].i4_cur_pic_buf_id);\n\n        /* If a frame was displayed (in non-shared mode), then release it from display manager */\n        if((0 == ps_codec->i4_share_disp_buf) && (ps_codec->ps_disp_buf))\n            ihevc_buf_mgr_release((buf_mgr_t *)ps_codec->pv_pic_buf_mgr,\n                                  ps_codec->i4_disp_buf_id, BUF_MGR_DISP);\n\n        /* Wait for threads */\n        for(i = 0; i < (ps_codec->i4_num_cores - 1); i++)\n        {\n            if(ps_codec->ai4_process_thread_created[i])\n            {\n                ithread_join(ps_codec->apv_process_thread_handle[i], NULL);\n                ps_codec->ai4_process_thread_created[i] = 0;\n            }\n        }\n\n        DEBUG_VALIDATE_PADDED_REGION(&ps_codec->as_process[proc_idx]);\n        if(ps_codec->u4_pic_cnt > 0)\n        {\n            DEBUG_DUMP_PIC_PU(ps_codec);\n        }\n        DEBUG_DUMP_PIC_BUFFERS(ps_codec);\n\n        /* Increment the number of pictures decoded */\n        ps_codec->u4_pic_cnt++;\n    }\n    ihevcd_fill_outargs(ps_codec, ps_dec_ip, ps_dec_op);\n\n    if(1 == ps_dec_op->u4_output_present)\n    {\n        WORD32 xpos = ps_codec->i4_disp_wd - 32 - LOGO_WD;\n        WORD32 ypos = ps_codec->i4_disp_ht - 32 - LOGO_HT;\n\n        if(ypos < 0)\n            ypos = 0;\n\n        if(xpos < 0)\n            xpos = 0;\n\n        INSERT_LOGO(ps_dec_ip->s_out_buffer.pu1_bufs[0],\n                    ps_dec_ip->s_out_buffer.pu1_bufs[1],\n                    ps_dec_ip->s_out_buffer.pu1_bufs[2], ps_codec->i4_disp_strd,\n                    xpos,\n                    ypos,\n                    ps_codec->e_chroma_fmt,\n                    ps_codec->i4_disp_wd,\n                    ps_codec->i4_disp_ht);\n    }\n\n\n    return ret;\n}", "target": 2, "idx": 10323}
{"commit_id": "64c5833e55d7672d6136a3fbfeae24bd012d36a5", "project": "autotrace", "func": "at_bitmap input_bmp_reader(gchar * filename, at_input_opts_type * opts, at_msg_func msg_func, gpointer msg_data, gpointer user_data)\n{\n  FILE *fd;\n  unsigned char buffer[64];\n  int ColormapSize, rowbytes, Maps, Grey;\n  unsigned char ColorMap[256][3];\n  at_bitmap image = at_bitmap_init(0, 0, 0, 1);\n  unsigned char *image_storage;\n  at_exception_type exp = at_exception_new(msg_func, msg_data);\n\n  fd = fopen(filename, \"rb\");\n\n  if (!fd) {\n    LOG(\"Can't open \\\"%s\\\"\\n\", filename);\n    at_exception_fatal(&exp, \"bmp: cannot open input file\");\n    return image;\n  }\n\n  /* It is a File. Now is it a Bitmap? Read the shortest possible header. */\n\n  if (!ReadOK(fd, buffer, 18) || (strncmp((const char *)buffer, \"BM\", 2))) {\n    LOG(\"Not a valid BMP file %s\\n\", filename);\n    at_exception_fatal(&exp, \"bmp: invalid input file\");\n    goto cleanup;\n  }\n\n  /* bring them to the right byteorder. Not too nice, but it should work */\n\n  Bitmap_File_Head.bfSize = ToL(&buffer[0x02]);\n  Bitmap_File_Head.zzHotX = ToS(&buffer[0x06]);\n  Bitmap_File_Head.zzHotY = ToS(&buffer[0x08]);\n  Bitmap_File_Head.bfOffs = ToL(&buffer[0x0a]);\n  Bitmap_File_Head.biSize = ToL(&buffer[0x0e]);\n\n  /* What kind of bitmap is it? */\n\n  if (Bitmap_File_Head.biSize == 12) {  /* OS/2 1.x ? */\n    if (!ReadOK(fd, buffer, 8)) {\n      LOG(\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n\n    Bitmap_Head.biWidth = ToS(&buffer[0x00]); /* 12 */\n    Bitmap_Head.biHeight = ToS(&buffer[0x02]);  /* 14 */\n    Bitmap_Head.biPlanes = ToS(&buffer[0x04]);  /* 16 */\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x06]);  /* 18 */\n    Bitmap_Head.biCompr = 0;\n    Bitmap_Head.biSizeIm = 0;\n    Bitmap_Head.biXPels = Bitmap_Head.biYPels = 0;\n    Bitmap_Head.biClrUsed = 0;\n    Maps = 3;\n  } else if (Bitmap_File_Head.biSize == 40) { /* Windows 3.x */\n    if (!ReadOK(fd, buffer, Bitmap_File_Head.biSize - 4)) {\n      LOG(\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); /* 12 */\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  /* 16 */\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  /* 1A */\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  /* 1C */\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); /* 1E */\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  /* 22 */\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); /* 26 */\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); /* 2A */\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); /* 2E */\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  /* 32 */\n    /* 36 */\n    Maps = 4;\n  } else if (Bitmap_File_Head.biSize >= 40 && Bitmap_File_Head.biSize <= 64) {  /* Probably OS/2 2.x */\n    if (!ReadOK(fd, buffer, Bitmap_File_Head.biSize - 4)) {\n      LOG(\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); /* 12 */\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  /* 16 */\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  /* 1A */\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  /* 1C */\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); /* 1E */\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  /* 22 */\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); /* 26 */\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); /* 2A */\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); /* 2E */\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  /* 32 */\n    /* 36 */\n    Maps = 3;\n  } else {\n    LOG(\"Error reading BMP file header\\n\");\n    at_exception_fatal(&exp, \"Error reading BMP file header\");\n    goto cleanup;\n  }\n\n  /* Valid options 1, 4, 8, 16, 24, 32 */\n  /* 16 is awful, we should probably shoot whoever invented it */\n\n  /* There should be some colors used! */\n\n  ColormapSize = (Bitmap_File_Head.bfOffs - Bitmap_File_Head.biSize - 14) / Maps;\n\n  if ((Bitmap_Head.biClrUsed == 0) && (Bitmap_Head.biBitCnt <= 8))\n    Bitmap_Head.biClrUsed = ColormapSize;\n\n  /* Sanity checks */\n\n  if ((Bitmap_Head.biHeight == 0 || Bitmap_Head.biWidth == 0)\n      || (Bitmap_Head.biPlanes != 1)\n      || (ColormapSize > 256 || Bitmap_Head.biClrUsed > 256)) {\n    LOG(\"Error reading BMP file header\\n\");\n    at_exception_fatal(&exp, \"Error reading BMP file header\");\n    goto cleanup;\n  }\n\n  /* Windows and OS/2 declare filler so that rows are a multiple of\n   * word length (32 bits == 4 bytes)\n   */\n   \n  unsigned long overflowTest = Bitmap_Head.biWidth * Bitmap_Head.biBitCnt;\n  if (overflowTest / Bitmap_Head.biWidth != Bitmap_Head.biBitCnt) {\n    LOG(\"Error reading BMP file header. Width is too large\\n\");\n    at_exception_fatal(&exp, \"Error reading BMP file header. Width is too large\");\n    goto cleanup;\n  }\n\n  rowbytes = ((Bitmap_Head.biWidth * Bitmap_Head.biBitCnt - 1) / 32) * 4 + 4;\n\n#ifdef DEBUG\n  printf(\"\\nSize: %u, Colors: %u, Bits: %u, Width: %u, Height: %u, Comp: %u, Zeile: %u\\n\", Bitmap_File_Head.bfSize, Bitmap_Head.biClrUsed, Bitmap_Head.biBitCnt, Bitmap_Head.biWidth, Bitmap_Head.biHeight, Bitmap_Head.biCompr, rowbytes);\n#endif\n\n  /* Get the Colormap */\n  ReadColorMap(fd, ColorMap, ColormapSize, Maps, &Grey, &exp);\n  if (at_exception_got_fatal(&exp))\n    goto cleanup;\n\n#ifdef DEBUG\n  printf(\"Colormap read\\n\");\n#endif\n\n  /* Get the Image and return the ID or -1 on error */\n  image_storage = ReadImage(fd, Bitmap_Head.biWidth, Bitmap_Head.biHeight, ColorMap, Bitmap_Head.biBitCnt, Bitmap_Head.biCompr, rowbytes, Grey);\n  image = at_bitmap_init(image_storage, (unsigned short)Bitmap_Head.biWidth, (unsigned short)Bitmap_Head.biHeight, Grey ? 1 : 3);\ncleanup:\n  fclose(fd);\n  return (image);\n}", "target": 0, "idx": 10324}
{"commit_id": "148de954ed3585d8b4298b424aa24916d0de6136", "project": "envoyproxy/envoy", "func": "void FilterManager::maybeEndEncode(bool end_stream) {\n  if (end_stream) {\n    ASSERT(!state_.remote_encode_complete_);\n    state_.remote_encode_complete_ = true;\n    filter_manager_callbacks_.endStream();\n  }\n}", "target": 1, "idx": 10325}
{"commit_id": "7578e1c04ee280dda50c4c2813e7d55f539c6501", "project": "the-tcpdump-group/tcpdump", "func": "static inline void\narista_print_date_hms_time(netdissect_options *ndo, uint32_t seconds,\n\t\tuint32_t nanoseconds)\n{\n\ttime_t ts;\n\tchar buf[sizeof(\"-yyyyyyyyyy-mm-dd hh:mm:ss\")];\n\n\tts = seconds + (nanoseconds / 1000000000);\n\tnanoseconds %= 1000000000;\n\tND_PRINT(\"%s.%09u\",\n\t    nd_format_time(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\",\n\t       gmtime(&ts)), nanoseconds);\n}", "target": 1, "idx": 10326}
{"commit_id": "035cb12f392860113dce96116a5150e2fde6f0cc", "project": "android", "func": "status_t SoundTriggerHwService::Module::loadSoundModel(const sp<IMemory>& modelMemory,\n                                sound_model_handle_t *handle)\n{\n    ALOGV(\"loadSoundModel() handle\");\n    if (!captureHotwordAllowed()) {\n        return PERMISSION_DENIED;\n    }\n\n    if (modelMemory == 0 || modelMemory->pointer() == NULL) {\n        ALOGE(\"loadSoundModel() modelMemory is 0 or has NULL pointer()\");\n        return BAD_VALUE;\n    }\n    struct sound_trigger_sound_model *sound_model =\n            (struct sound_trigger_sound_model *)modelMemory->pointer();\n\n    size_t structSize;\n    if (sound_model->type == SOUND_MODEL_TYPE_KEYPHRASE) {\n        structSize = sizeof(struct sound_trigger_phrase_sound_model);\n    } else {\n        structSize = sizeof(struct sound_trigger_sound_model);\n    }\n\n    if (sound_model->data_offset < structSize ||\n           sound_model->data_size > (UINT_MAX - sound_model->data_offset) ||\n           modelMemory->size() < sound_model->data_offset ||\n           sound_model->data_size > (modelMemory->size() - sound_model->data_offset)) {\n        android_errorWriteLog(0x534e4554, \"30148546\");\n        ALOGE(\"loadSoundModel() data_size is too big\");\n        return BAD_VALUE;\n    }\n\n    AutoMutex lock(mLock);\n\n    if (mModels.size() >= mDescriptor.properties.max_sound_models) {\n        ALOGW(\"loadSoundModel(): Not loading, max number of models (%d) would be exceeded\",\n              mDescriptor.properties.max_sound_models);\n        return INVALID_OPERATION;\n    }\n\n    status_t status = mHwDevice->load_sound_model(mHwDevice, sound_model,\n                                                  SoundTriggerHwService::soundModelCallback,\n                                                  this, handle);\n\n    if (status != NO_ERROR) {\n        return status;\n    }\n    audio_session_t session;\n    audio_io_handle_t ioHandle;\n    audio_devices_t device;\n\n    status = AudioSystem::acquireSoundTriggerSession(&session, &ioHandle, &device);\n    if (status != NO_ERROR) {\n        return status;\n    }\n\n    sp<Model> model = new Model(*handle, session, ioHandle, device, sound_model->type);\n    mModels.replaceValueFor(*handle, model);\n\n    return status;\n}", "target": 2, "idx": 10327}
{"commit_id": "6d248026b04d69e5c5049709c17ea671328ea4ea", "project": "apache/trafficserver", "func": "TSReturnCode\nTSHttpTxnConfigFind(const char *name, int length, TSOverridableConfigKey *conf, TSRecordDataType *type)\n{\n  sdk_assert(sdk_sanity_check_null_ptr((void *)name) == TS_SUCCESS);\n  sdk_assert(sdk_sanity_check_null_ptr((void *)conf) == TS_SUCCESS);\n\n  TSOverridableConfigKey cnf = TS_CONFIG_NULL;\n  TSRecordDataType typ       = TS_RECORDDATATYPE_INT;\n\n  if (length == -1) {\n    length = strlen(name);\n  }\n  // Lots of string comparisons here, but we avoid quite a few by checking lengths\n  switch (length) {\n  case 24:\n    if (!strncmp(name, \"proxy.config.srv_enabled\", length)) {\n      cnf = TS_CONFIG_SRV_ENABLED;\n    }\n    break;\n  case 28:\n    if (!strncmp(name, \"proxy.config.http.cache.http\", length)) {\n      cnf = TS_CONFIG_HTTP_CACHE_HTTP;\n    }\n    break;\n\n  case 29:\n    if (!strncmp(name, \"proxy.config.ssl.hsts_max_age\", length)) {\n      cnf = TS_CONFIG_SSL_HSTS_MAX_AGE;\n    }\n    break;\n\n  case 30:\n    if (!strncmp(name, \"proxy.config.http.normalize_ae\", length)) {\n      cnf = TS_CONFIG_HTTP_NORMALIZE_AE;\n    }\n    break;\n\n  case 31:\n    if (!strncmp(name, \"proxy.config.http.chunking.size\", length)) {\n      cnf = TS_CONFIG_HTTP_CHUNKING_SIZE;\n    }\n    break;\n\n  case 33:\n    if (!strncmp(name, \"proxy.config.ssl.client.cert.path\", length)) {\n      cnf = TS_CONFIG_SSL_CERT_FILEPATH;\n      typ = TS_RECORDDATATYPE_STRING;\n    }\n    break;\n\n  case 34:\n    if (!strncmp(name, \"proxy.config.http.chunking_enabled\", length)) {\n      cnf = TS_CONFIG_HTTP_CHUNKING_ENABLED;\n    } else if (!strncmp(name, \"proxy.config.http.cache.generation\", length)) {\n      cnf = TS_CONFIG_HTTP_CACHE_GENERATION;\n    } else if (!strncmp(name, \"proxy.config.http.insert_client_ip\", length)) {\n      cnf = TS_CONFIG_HTTP_ANONYMIZE_INSERT_CLIENT_IP;\n    } else if (!strncmp(name, \"proxy.config.http.insert_forwarded\", length)) {\n      cnf = TS_CONFIG_HTTP_INSERT_FORWARDED;\n      typ = TS_RECORDDATATYPE_STRING;\n    }\n    break;\n\n  case 35:\n    if (!strncmp(name, \"proxy.config.http.cache.range.write\", length)) {\n      cnf = TS_CONFIG_HTTP_CACHE_RANGE_WRITE;\n    } else if (!strncmp(name, \"proxy.config.http.allow_multi_range\", length)) {\n      cnf = TS_CONFIG_HTTP_ALLOW_MULTI_RANGE;\n    }\n    break;\n\n  case 36:\n    switch (name[length - 1]) {\n    case 'p':\n      if (!strncmp(name, \"proxy.config.http.cache.range.lookup\", length)) {\n        cnf = TS_CONFIG_HTTP_CACHE_RANGE_LOOKUP;\n      }\n      break;\n    case 't':\n      if (!strncmp(name, \"proxy.config.net.sock_packet_tos_out\", length)) {\n        cnf = TS_CONFIG_NET_SOCK_PACKET_TOS_OUT;\n      }\n      break;\n    case 'd':\n      if (!strncmp(name, \"proxy.config.http.slow.log.threshold\", length)) {\n        cnf = TS_CONFIG_HTTP_SLOW_LOG_THRESHOLD;\n      }\n      break;\n    }\n    break;\n\n  case 37:\n    switch (name[length - 1]) {\n    case 'e':\n      if (!strncmp(name, \"proxy.config.http.cache.max_stale_age\", length)) {\n        cnf = TS_CONFIG_HTTP_CACHE_MAX_STALE_AGE;\n      } else if (!strncmp(name, \"proxy.config.http.default_buffer_size\", length)) {\n        cnf = TS_CONFIG_HTTP_DEFAULT_BUFFER_SIZE;\n      } else if (!strncmp(name, \"proxy.config.ssl.client.cert.filename\", length)) {\n        cnf = TS_CONFIG_SSL_CERT_FILENAME;\n        typ = TS_RECORDDATATYPE_STRING;\n      }\n      break;\n\n    case 'r':\n      if (!strncmp(name, \"proxy.config.http.response_server_str\", length)) {\n        cnf = TS_CONFIG_HTTP_RESPONSE_SERVER_STR;\n        typ = TS_RECORDDATATYPE_STRING;\n      } else if (!strncmp(name, \"proxy.config.ssl.client.verify.server\", length)) {\n        cnf = TS_CONFIG_SSL_CLIENT_VERIFY_SERVER;\n      }\n      break;\n    case 't':\n      if (!strncmp(name, \"proxy.config.http.keep_alive_post_out\", length)) {\n        cnf = TS_CONFIG_HTTP_KEEP_ALIVE_POST_OUT;\n      } else if (!strncmp(name, \"proxy.config.net.sock_option_flag_out\", length)) {\n        cnf = TS_CONFIG_NET_SOCK_OPTION_FLAG_OUT;\n      } else if (!strncmp(name, \"proxy.config.net.sock_packet_mark_out\", length)) {\n        cnf = TS_CONFIG_NET_SOCK_PACKET_MARK_OUT;\n      } else if (!strncmp(name, \"proxy.config.websocket.active_timeout\", length)) {\n        cnf = TS_CONFIG_WEBSOCKET_ACTIVE_TIMEOUT;\n      }\n      break;\n    }\n    break;\n\n  case 38:\n    switch (name[length - 1]) {\n    case 'd':\n      if (!strncmp(name, \"proxy.config.http.server_tcp_init_cwnd\", length)) {\n        cnf = TS_CONFIG_HTTP_SERVER_TCP_INIT_CWND;\n      } else if (!strncmp(name, \"proxy.config.http.flow_control.enabled\", length)) {\n        cnf = TS_CONFIG_HTTP_FLOW_CONTROL_ENABLED;\n      }\n      break;\n    case 's':\n      if (!strncmp(name, \"proxy.config.http.send_http11_requests\", length)) {\n        cnf = TS_CONFIG_HTTP_SEND_HTTP11_REQUESTS;\n      }\n      break;\n    }\n    break;\n\n  case 39:\n    switch (name[length - 1]) {\n    case 'e':\n      if (!strncmp(name, \"proxy.config.body_factory.template_base\", length)) {\n        cnf = TS_CONFIG_BODY_FACTORY_TEMPLATE_BASE;\n        typ = TS_RECORDDATATYPE_STRING;\n      }\n      break;\n    case 'm':\n      if (!strncmp(name, \"proxy.config.http.anonymize_remove_from\", length)) {\n        cnf = TS_CONFIG_HTTP_ANONYMIZE_REMOVE_FROM;\n      }\n      break;\n    case 'n':\n      if (!strncmp(name, \"proxy.config.http.keep_alive_enabled_in\", length)) {\n        cnf = TS_CONFIG_HTTP_KEEP_ALIVE_ENABLED_IN;\n      }\n      break;\n    case 's':\n      if (!strncmp(name, \"proxy.config.http.doc_in_cache_skip_dns\", length)) {\n        cnf = TS_CONFIG_HTTP_DOC_IN_CACHE_SKIP_DNS;\n      }\n      break;\n    }\n    break;\n\n  case 40:\n    switch (name[length - 1]) {\n    case 'd':\n      if (!strncmp(name, \"proxy.config.http.forward_connect_method\", length)) {\n        cnf = TS_CONFIG_HTTP_FORWARD_CONNECT_METHOD;\n      }\n      break;\n    case 'e':\n      if (!strncmp(name, \"proxy.config.http.down_server.cache_time\", length)) {\n        cnf = TS_CONFIG_HTTP_DOWN_SERVER_CACHE_TIME;\n      } else if (!strncmp(name, \"proxy.config.http.insert_age_in_response\", length)) {\n        cnf = TS_CONFIG_HTTP_INSERT_AGE_IN_RESPONSE;\n      }\n      break;\n    case 'r':\n      if (!strncmp(name, \"proxy.config.url_remap.pristine_host_hdr\", length)) {\n        cnf = TS_CONFIG_URL_REMAP_PRISTINE_HOST_HDR;\n      } else if (!strncmp(name, \"proxy.config.http.insert_request_via_str\", length)) {\n        cnf = TS_CONFIG_HTTP_INSERT_REQUEST_VIA_STR;\n      } else if (!strncmp(name, \"proxy.config.http.flow_control.low_water\", length)) {\n        cnf = TS_CONFIG_HTTP_FLOW_CONTROL_LOW_WATER_MARK;\n      }\n      break;\n    case 's':\n      if (!strncmp(name, \"proxy.config.http.origin_max_connections\", length)) {\n        cnf = TS_CONFIG_HTTP_ORIGIN_MAX_CONNECTIONS;\n      } else if (!strncmp(name, \"proxy.config.http.cache.required_headers\", length)) {\n        cnf = TS_CONFIG_HTTP_CACHE_REQUIRED_HEADERS;\n      } else if (!strncmp(name, \"proxy.config.ssl.hsts_include_subdomains\", length)) {\n        cnf = TS_CONFIG_SSL_HSTS_INCLUDE_SUBDOMAINS;\n      } else if (!strncmp(name, \"proxy.config.http.number_of_redirections\", length)) {\n        cnf = TS_CONFIG_HTTP_NUMBER_OF_REDIRECTIONS;\n      }\n      break;\n    case 't':\n      if (!strncmp(name, \"proxy.config.http.keep_alive_enabled_out\", length)) {\n        cnf = TS_CONFIG_HTTP_KEEP_ALIVE_ENABLED_OUT;\n      }\n      break;\n    }\n    break;\n\n  case 41:\n    switch (name[length - 1]) {\n    case 'd':\n      if (!strncmp(name, \"proxy.config.http.response_server_enabled\", length)) {\n        cnf = TS_CONFIG_HTTP_RESPONSE_SERVER_ENABLED;\n      }\n      break;\n    case 'e':\n      if (!strncmp(name, \"proxy.config.http.anonymize_remove_cookie\", length)) {\n        cnf = TS_CONFIG_HTTP_ANONYMIZE_REMOVE_COOKIE;\n      } else if (!strncmp(name, \"proxy.config.http.request_header_max_size\", length)) {\n        cnf = TS_CONFIG_HTTP_REQUEST_HEADER_MAX_SIZE;\n      } else if (!strncmp(name, \"proxy.config.http.parent_proxy.retry_time\", length)) {\n        cnf = TS_CONFIG_HTTP_PARENT_PROXY_RETRY_TIME;\n      }\n      break;\n    case 'r':\n      if (!strncmp(name, \"proxy.config.http.insert_response_via_str\", length)) {\n        cnf = TS_CONFIG_HTTP_INSERT_RESPONSE_VIA_STR;\n      } else if (!strncmp(name, \"proxy.config.http.flow_control.high_water\", length)) {\n        cnf = TS_CONFIG_HTTP_FLOW_CONTROL_HIGH_WATER_MARK;\n      }\n      break;\n    case 't':\n      if (!strncmp(name, \"proxy.config.http.cache.vary_default_text\", length)) {\n        cnf = TS_CONFIG_HTTP_CACHE_VARY_DEFAULT_TEXT;\n        typ = TS_RECORDDATATYPE_STRING;\n      }\n      break;\n    }\n    break;\n\n  case 42:\n    switch (name[length - 1]) {\n    case 'd':\n      if (!strncmp(name, \"proxy.config.http.negative_caching_enabled\", length)) {\n        cnf = TS_CONFIG_HTTP_NEGATIVE_CACHING_ENABLED;\n      }\n      break;\n    case 'e':\n      if (!strncmp(name, \"proxy.config.http.cache.when_to_revalidate\", length)) {\n        cnf = TS_CONFIG_HTTP_CACHE_WHEN_TO_REVALIDATE;\n      } else if (!strncmp(name, \"proxy.config.http.response_header_max_size\", length)) {\n        cnf = TS_CONFIG_HTTP_RESPONSE_HEADER_MAX_SIZE;\n      }\n      break;\n    case 'r':\n      if (!strncmp(name, \"proxy.config.http.anonymize_remove_referer\", length)) {\n        cnf = TS_CONFIG_HTTP_ANONYMIZE_REMOVE_REFERER;\n      } else if (!strncmp(name, \"proxy.config.http.global_user_agent_header\", length)) {\n        cnf = TS_CONFIG_HTTP_GLOBAL_USER_AGENT_HEADER;\n        typ = TS_RECORDDATATYPE_STRING;\n      } else if (!strncmp(name, \"proxy.config.http.cache.vary_default_other\", length)) {\n        cnf = TS_CONFIG_HTTP_CACHE_VARY_DEFAULT_OTHER;\n        typ = TS_RECORDDATATYPE_STRING;\n      }\n      break;\n    case 't':\n      if (!strncmp(name, \"proxy.config.net.sock_recv_buffer_size_out\", length)) {\n        cnf = TS_CONFIG_NET_SOCK_RECV_BUFFER_SIZE_OUT;\n      } else if (!strncmp(name, \"proxy.config.net.sock_send_buffer_size_out\", length)) {\n        cnf = TS_CONFIG_NET_SOCK_SEND_BUFFER_SIZE_OUT;\n      } else if (!strncmp(name, \"proxy.config.http.connect_attempts_timeout\", length)) {\n        cnf = TS_CONFIG_HTTP_CONNECT_ATTEMPTS_TIMEOUT;\n      } else if (!strncmp(name, \"proxy.config.websocket.no_activity_timeout\", length)) {\n        cnf = TS_CONFIG_WEBSOCKET_NO_ACTIVITY_TIMEOUT;\n      }\n      break;\n    }\n    break;\n\n  case 43:\n    switch (name[length - 1]) {\n    case 'e':\n      if (!strncmp(name, \"proxy.config.http.negative_caching_lifetime\", length)) {\n        cnf = TS_CONFIG_HTTP_NEGATIVE_CACHING_LIFETIME;\n      }\n      break;\n    case 'k':\n      if (!strncmp(name, \"proxy.config.http.default_buffer_water_mark\", length)) {\n        cnf = TS_CONFIG_HTTP_DEFAULT_BUFFER_WATER_MARK;\n      }\n      break;\n    case 'r':\n      if (!strncmp(name, \"proxy.config.http.cache.heuristic_lm_factor\", length)) {\n        typ = TS_RECORDDATATYPE_FLOAT;\n        cnf = TS_CONFIG_HTTP_CACHE_HEURISTIC_LM_FACTOR;\n      }\n      break;\n    case 's':\n      if (!strncmp(name, \"proxy.config.http.cache.vary_default_images\", length)) {\n        cnf = TS_CONFIG_HTTP_CACHE_VARY_DEFAULT_IMAGES;\n        typ = TS_RECORDDATATYPE_STRING;\n      }\n      break;\n    }\n    break;\n\n  case 44:\n    switch (name[length - 1]) {\n    case 'p':\n      if (!strncmp(name, \"proxy.config.http.anonymize_remove_client_ip\", length)) {\n        cnf = TS_CONFIG_HTTP_ANONYMIZE_REMOVE_CLIENT_IP;\n      }\n      break;\n    case 'e':\n      if (!strncmp(name, \"proxy.config.http.cache.open_read_retry_time\", length)) {\n        cnf = TS_CONFIG_HTTP_CACHE_OPEN_READ_RETRY_TIME;\n      }\n      break;\n    }\n    break;\n\n  case 45:\n    switch (name[length - 1]) {\n    case 'd':\n      if (!strncmp(name, \"proxy.config.http.down_server.abort_threshold\", length)) {\n        cnf = TS_CONFIG_HTTP_DOWN_SERVER_ABORT_THRESHOLD;\n      } else if (!strncmp(name, \"proxy.config.http.parent_proxy.fail_threshold\", length)) {\n        cnf = TS_CONFIG_HTTP_PARENT_PROXY_FAIL_THRESHOLD;\n      }\n      break;\n    case 'n':\n      if (!strncmp(name, \"proxy.config.http.cache.ignore_authentication\", length)) {\n        cnf = TS_CONFIG_HTTP_CACHE_IGNORE_AUTHENTICATION;\n      }\n      break;\n    case 't':\n      if (!strncmp(name, \"proxy.config.http.anonymize_remove_user_agent\", length)) {\n        cnf = TS_CONFIG_HTTP_ANONYMIZE_REMOVE_USER_AGENT;\n      }\n      break;\n    case 's':\n      if (!strncmp(name, \"proxy.config.http.connect_attempts_rr_retries\", length)) {\n        cnf = TS_CONFIG_HTTP_CONNECT_ATTEMPTS_RR_RETRIES;\n      } else if (!strncmp(name, \"proxy.config.http.cache.max_open_read_retries\", length)) {\n        cnf = TS_CONFIG_HTTP_CACHE_MAX_OPEN_READ_RETRIES;\n      }\n      break;\n    case 'e':\n      if (0 == strncmp(name, \"proxy.config.http.auth_server_session_private\", length)) {\n        cnf = TS_CONFIG_HTTP_AUTH_SERVER_SESSION_PRIVATE;\n      }\n      break;\n    case 'y':\n      if (!strncmp(name, \"proxy.config.http.redirect_use_orig_cache_key\", length)) {\n        cnf = TS_CONFIG_HTTP_REDIRECT_USE_ORIG_CACHE_KEY;\n      }\n      break;\n    }\n    break;\n\n  case 46:\n    switch (name[length - 1]) {\n    case 'e':\n      if (!strncmp(name, \"proxy.config.http.cache.ignore_client_no_cache\", length)) {\n        cnf = TS_CONFIG_HTTP_CACHE_IGNORE_CLIENT_NO_CACHE;\n      } else if (!strncmp(name, \"proxy.config.http.cache.ims_on_client_no_cache\", length)) {\n        cnf = TS_CONFIG_HTTP_CACHE_IMS_ON_CLIENT_NO_CACHE;\n      } else if (!strncmp(name, \"proxy.config.http.cache.ignore_server_no_cache\", length)) {\n        cnf = TS_CONFIG_HTTP_CACHE_IGNORE_SERVER_NO_CACHE;\n      } else if (!strncmp(name, \"proxy.config.http.cache.heuristic_min_lifetime\", length)) {\n        cnf = TS_CONFIG_HTTP_CACHE_HEURISTIC_MIN_LIFETIME;\n      } else if (!strncmp(name, \"proxy.config.http.cache.heuristic_max_lifetime\", length)) {\n        cnf = TS_CONFIG_HTTP_CACHE_HEURISTIC_MAX_LIFETIME;\n      } else if (!strncmp(name, \"proxy.config.http.origin_max_connections_queue\", length)) {\n        cnf = TS_CONFIG_HTTP_ORIGIN_MAX_CONNECTIONS_QUEUE;\n      }\n      break;\n    case 'h':\n      if (0 == strncmp(name, \"proxy.config.http.server_session_sharing.match\", length)) {\n        cnf = TS_CONFIG_HTTP_SERVER_SESSION_SHARING_MATCH;\n      } else if (!strncmp(name, \"proxy.config.http.cache.ignore_accept_mismatch\", length)) {\n        cnf = TS_CONFIG_HTTP_CACHE_IGNORE_ACCEPT_MISMATCH;\n      }\n      break;\n    case 'n':\n      if (!strncmp(name, \"proxy.config.http.cache.open_write_fail_action\", length)) {\n        cnf = TS_CONFIG_HTTP_CACHE_OPEN_WRITE_FAIL_ACTION;\n      }\n      break;\n    case 'r':\n      if (!strncmp(name, \"proxy.config.http.insert_squid_x_forwarded_for\", length)) {\n        cnf = TS_CONFIG_HTTP_INSERT_SQUID_X_FORWARDED_FOR;\n      }\n      break;\n    case 's':\n      if (!strncmp(name, \"proxy.config.http.connect_attempts_max_retries\", length)) {\n        cnf = TS_CONFIG_HTTP_CONNECT_ATTEMPTS_MAX_RETRIES;\n      } else if (!strncmp(name, \"proxy.config.http.cache.max_open_write_retries\", length)) {\n        cnf = TS_CONFIG_HTTP_CACHE_MAX_OPEN_WRITE_RETRIES;\n      }\n      break;\n    case 't':\n      if (!strncmp(name, \"proxy.config.http.forward.proxy_auth_to_parent\", length)) {\n        cnf = TS_CONFIG_HTTP_FORWARD_PROXY_AUTH_TO_PARENT;\n      }\n      break;\n    }\n    break;\n\n  case 47:\n    switch (name[length - 1]) {\n    case 'b':\n      if (!strncmp(name, \"proxy.config.http.parent_proxy.mark_down_hostdb\", length)) {\n        cnf = TS_CONFIG_PARENT_FAILURES_UPDATE_HOSTDB;\n      }\n      break;\n    case 'd':\n      if (!strncmp(name, \"proxy.config.http.negative_revalidating_enabled\", length)) {\n        cnf = TS_CONFIG_HTTP_NEGATIVE_REVALIDATING_ENABLED;\n      }\n      break;\n    case 'e':\n      if (!strncmp(name, \"proxy.config.http.cache.guaranteed_min_lifetime\", length)) {\n        cnf = TS_CONFIG_HTTP_CACHE_GUARANTEED_MIN_LIFETIME;\n      } else if (!strncmp(name, \"proxy.config.http.cache.guaranteed_max_lifetime\", length)) {\n        cnf = TS_CONFIG_HTTP_CACHE_GUARANTEED_MAX_LIFETIME;\n      }\n      break;\n    case 'n':\n      if (!strncmp(name, \"proxy.config.http.transaction_active_timeout_in\", length)) {\n        cnf = TS_CONFIG_HTTP_TRANSACTION_ACTIVE_TIMEOUT_IN;\n      }\n      break;\n    case 't':\n      if (!strncmp(name, \"proxy.config.http.post_connect_attempts_timeout\", length)) {\n        cnf = TS_CONFIG_HTTP_POST_CONNECT_ATTEMPTS_TIMEOUT;\n      }\n      break;\n    }\n    break;\n\n  case 48:\n    switch (name[length - 1]) {\n    case 'e':\n      if (!strncmp(name, \"proxy.config.http.cache.ignore_client_cc_max_age\", length)) {\n        cnf = TS_CONFIG_HTTP_CACHE_IGNORE_CLIENT_CC_MAX_AGE;\n      } else if (!strncmp(name, \"proxy.config.http.negative_revalidating_lifetime\", length)) {\n        cnf = TS_CONFIG_HTTP_NEGATIVE_REVALIDATING_LIFETIME;\n      }\n      break;\n    case 't':\n      switch (name[length - 4]) {\n      case '_':\n        if (!strncmp(name, \"proxy.config.http.transaction_active_timeout_out\", length)) {\n          cnf = TS_CONFIG_HTTP_TRANSACTION_ACTIVE_TIMEOUT_OUT;\n        }\n        break;\n      case 'e':\n        if (!strncmp(name, \"proxy.config.http.background_fill_active_timeout\", length)) {\n          cnf = TS_CONFIG_HTTP_BACKGROUND_FILL_ACTIVE_TIMEOUT;\n        }\n        break;\n      }\n      break;\n    }\n    break;\n\n  case 49:\n    if (!strncmp(name, \"proxy.config.http.attach_server_session_to_client\", length)) {\n      cnf = TS_CONFIG_HTTP_ATTACH_SERVER_SESSION_TO_CLIENT;\n    }\n    break;\n\n  case 50:\n    if (!strncmp(name, \"proxy.config.http.cache.cache_responses_to_cookies\", length)) {\n      cnf = TS_CONFIG_HTTP_CACHE_CACHE_RESPONSES_TO_COOKIES;\n    }\n    break;\n\n  case 51:\n    switch (name[length - 1]) {\n    case 'n':\n      if (!strncmp(name, \"proxy.config.http.keep_alive_no_activity_timeout_in\", length)) {\n        cnf = TS_CONFIG_HTTP_KEEP_ALIVE_NO_ACTIVITY_TIMEOUT_IN;\n      }\n      break;\n    case 'd':\n      if (!strncmp(name, \"proxy.config.http.post.check.content_length.enabled\", length)) {\n        cnf = TS_CONFIG_HTTP_POST_CHECK_CONTENT_LENGTH_ENABLED;\n      }\n      break;\n    case 's':\n      if (!strncmp(name, \"proxy.config.http.cache.enable_default_vary_headers\", length)) {\n        cnf = TS_CONFIG_HTTP_CACHE_ENABLE_DEFAULT_VARY_HEADER;\n      }\n      break;\n    }\n    break;\n\n  case 52:\n    switch (name[length - 1]) {\n    case 'c':\n      if (!strncmp(name, \"proxy.config.http.cache.cache_urls_that_look_dynamic\", length)) {\n        cnf = TS_CONFIG_HTTP_CACHE_CACHE_URLS_THAT_LOOK_DYNAMIC;\n      }\n      break;\n    case 'n':\n      if (!strncmp(name, \"proxy.config.http.transaction_no_activity_timeout_in\", length)) {\n        cnf = TS_CONFIG_HTTP_TRANSACTION_NO_ACTIVITY_TIMEOUT_IN;\n      }\n      break;\n    case 't':\n      if (!strncmp(name, \"proxy.config.http.keep_alive_no_activity_timeout_out\", length)) {\n        cnf = TS_CONFIG_HTTP_KEEP_ALIVE_NO_ACTIVITY_TIMEOUT_OUT;\n      } else if (!strncmp(name, \"proxy.config.http.uncacheable_requests_bypass_parent\", length)) {\n        cnf = TS_CONFIG_HTTP_UNCACHEABLE_REQUESTS_BYPASS_PARENT;\n      }\n      break;\n    }\n    break;\n\n  case 53:\n    switch (name[length - 1]) {\n    case 't':\n      if (!strncmp(name, \"proxy.config.http.transaction_no_activity_timeout_out\", length)) {\n        cnf = TS_CONFIG_HTTP_TRANSACTION_NO_ACTIVITY_TIMEOUT_OUT;\n      }\n      break;\n    case 'd':\n      if (!strncmp(name, \"proxy.config.http.background_fill_completed_threshold\", length)) {\n        typ = TS_RECORDDATATYPE_FLOAT;\n        cnf = TS_CONFIG_HTTP_BACKGROUND_FILL_COMPLETED_THRESHOLD;\n      }\n      break;\n    case 's':\n      if (!strncmp(name, \"proxy.config.http.parent_proxy.total_connect_attempts\", length)) {\n        cnf = TS_CONFIG_HTTP_PARENT_PROXY_TOTAL_CONNECT_ATTEMPTS;\n      }\n      break;\n    }\n    break;\n\n  case 54:\n    if (!strncmp(name, \"proxy.config.http.cache.ignore_accept_charset_mismatch\", length)) {\n      cnf = TS_CONFIG_HTTP_CACHE_IGNORE_ACCEPT_CHARSET_MISMATCH;\n    }\n    break;\n\n  case 55:\n    if (!strncmp(name, \"proxy.config.http.cache.ignore_accept_language_mismatch\", length)) {\n      cnf = TS_CONFIG_HTTP_CACHE_IGNORE_ACCEPT_LANGUAGE_MISMATCH;\n    } else if (!strncmp(name, \"proxy.config.http.cache.ignore_accept_encoding_mismatch\", length)) {\n      cnf = TS_CONFIG_HTTP_CACHE_IGNORE_ACCEPT_ENCODING_MISMATCH;\n    } else if (!strncmp(name, \"proxy.config.http.parent_proxy.connect_attempts_timeout\", length)) {\n      cnf = TS_CONFIG_HTTP_PARENT_CONNECT_ATTEMPT_TIMEOUT;\n    }\n    break;\n\n  case 58:\n    if (!strncmp(name, \"proxy.config.http.connect_attempts_max_retries_dead_server\", length)) {\n      cnf = TS_CONFIG_HTTP_CONNECT_ATTEMPTS_MAX_RETRIES_DEAD_SERVER;\n    } else if (!strncmp(name, \"proxy.config.http.parent_proxy.per_parent_connect_attempts\", length)) {\n      cnf = TS_CONFIG_HTTP_PER_PARENT_CONNECT_ATTEMPTS;\n    }\n    break;\n  }\n\n  *conf = cnf;\n  if (type) {\n    *type = typ;\n  }\n\n  return ((cnf != TS_CONFIG_NULL) ? TS_SUCCESS : TS_ERROR);\n}", "target": 1, "idx": 10328}
{"commit_id": "98d8d5dadacc3cd07c738b3772f56317a7a306e7", "project": "sass/libsass", "func": "Supports_Condition_Obj Parser::parse_supports_condition_in_parens(bool parens_required)\n  {\n    Supports_Condition_Obj interp = parse_supports_interpolation();\n    if (interp != 0) return interp;\n\n    if (!lex < exactly <'('> >()) {\n      if (parens_required) {\n        css_error(\"Invalid CSS\", \" after \", \": expected @supports condition (e.g. (display: flexbox)), was \", /*trim=*/false);\n      } else {\n        return {};\n      }\n    }\n    lex < css_whitespace >();\n\n    Supports_Condition_Obj cond = parse_supports_condition(/*top_level=*/false);\n    if (cond.isNull()) cond = parse_supports_declaration();\n    if (!lex < exactly <')'> >()) error(\"unclosed parenthesis in @supports declaration\");\n\n    lex < css_whitespace >();\n    return cond;\n  }", "target": 1, "idx": 10329}
{"commit_id": "beba892bc0d4e4ded4d667ab1d2a94f4d75109a9", "project": "libtom/libtommath", "func": "mp_err mp_2expt(mp_int *a, int b)\n{\n   mp_err    err;\n\n   if (b < 0) {\n      return MP_VAL;\n   }\n\n   /* zero a as per default */\n   mp_zero(a);\n\n   /* grow a to accomodate the single bit */\n   if ((err = mp_grow(a, (b / MP_DIGIT_BIT) + 1)) != MP_OKAY) {\n      return err;\n   }\n\n   /* set the used count of where the bit will go */\n   a->used = (b / MP_DIGIT_BIT) + 1;\n\n   /* put the single bit in its place */\n   a->dp[b / MP_DIGIT_BIT] = (mp_digit)1 << (mp_digit)(b % MP_DIGIT_BIT);\n\n   return MP_OKAY;\n}", "target": 3, "idx": 10330}
{"commit_id": "946e51f2bf37f1656916eb75bd0742ba33983c28", "project": "torvalds/linux", "func": "static int instance_rmdir(struct inode *inode, struct dentry *dentry)\n{\n\tstruct dentry *parent;\n\tint ret;\n\n\t/* Paranoid: Make sure the parent is the \"instances\" directory */\n\tparent = hlist_entry(inode->i_dentry.first, struct dentry, d_u.d_alias);\n\tif (WARN_ON_ONCE(parent != trace_instance_dir))\n\t\treturn -ENOENT;\n\n\t/* The caller did a dget() on dentry */\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\n\t/*\n\t * The inode mutex is locked, but debugfs_create_dir() will also\n\t * take the mutex. As the instances directory can not be destroyed\n\t * or changed in any other way, it is safe to unlock it, and\n\t * let the dentry try. If two users try to make the same dir at\n\t * the same time, then the instance_delete() will determine the\n\t * winner.\n\t */\n\tmutex_unlock(&inode->i_mutex);\n\n\tret = instance_delete(dentry->d_iname);\n\n\tmutex_lock_nested(&inode->i_mutex, I_MUTEX_PARENT);\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\n\treturn ret;\n}", "target": 1, "idx": 10331}
{"commit_id": "b7a0650e061b5418ab4a8f72c6e4b00317aff623", "project": "wireshark", "func": "static int vvalue_tvb_vector_internal(tvbuff_t *tvb, int offset, struct vt_vector *val, struct vtype_data *type, guint num)\n{\n\tconst int offset_in = offset;\n\tconst gboolean varsize = (type->size == -1);\n\tconst guint elsize = varsize ? (guint)sizeof(struct data_blob) : (guint)type->size;\n\tguint8 *data;\n\tint len;\n\tguint i;\n\n\t/*\n\t * Make sure we actually *have* the data we're going to fetch\n\t * here, before making a possibly-doomed attempt to allocate\n\t * memory for it.\n\t *\n\t * First, check for sane values.\n\t */\n\tif (num > MAX_VT_VECTOR_SIZE) {\n\t\tTHROW(ReportedBoundsError);\n\t}\n\n\t/*\n\t * No huge numbers from the wire; now make sure we at least have that data.\n\t */\n\ttvb_ensure_bytes_exist(tvb, offset, elsize * num);\n\n\t/*\n\t * OK, it exists; allocate a buffer into which to fetch it.\n\t */\n\tdata = (guint8*)wmem_alloc(wmem_packet_scope(), elsize * num);\n\n\tval->len = num;\n\tval->u.vt_ui1 = data;\n\tDISSECTOR_ASSERT((void*)&val->u == ((void*)&val->u.vt_ui1));\n\n\tfor (i=0; i<num; i++) {\n\t\tDISSECTOR_ASSERT_HINT(type->tvb_get != 0,\n\t\t\t\t      \"type that we don't know yet how to handle, please submit a bug with trace\");\n\t\tlen = type->tvb_get(tvb, offset, data);\n\t\tdata += elsize;\n\t\toffset += len;\n\t\tif (varsize && (offset % 4) ) { /* at begin or end of loop ??? */\n\t\t\tint padding = 4 - (offset % 4);\n\t\t\toffset += padding;\n\t\t}\n\t}\n\treturn offset - offset_in;\n}", "target": 1, "idx": 10332}
{"commit_id": "6c0b2b70eeee588591680f5b7d5d38175fd7cdf6", "project": "tensorflow", "func": "TfLiteStatus EvalFloat(TfLiteContext* context, TfLiteNode* node,\n                       TfLiteFullyConnectedParams* params, OpData* data,\n                       const TfLiteTensor* input, const TfLiteTensor* filter,\n                       const TfLiteTensor* bias, TfLiteTensor* output) {\n  float output_activation_min, output_activation_max;\n  CalculateActivationRange(params->activation, &output_activation_min,\n                           &output_activation_max);\n  if (kernel_type == kReference) {\n    FullyConnectedParams op_params;\n    op_params.float_activation_min = output_activation_min;\n    op_params.float_activation_max = output_activation_max;\n    if (filter->sparsity != nullptr) {\n      const auto& sparsity = *filter->sparsity;\n      reference_ops::FullyConnectedSparseWeight(\n          sparsity, op_params, GetTensorShape(input),\n          GetTensorData<float>(input), GetTensorShape(filter),\n          GetTensorData<float>(filter), GetTensorShape(bias),\n          GetTensorData<float>(bias), GetTensorShape(output),\n          GetTensorData<float>(output));\n    } else {\n      reference_ops::FullyConnected(\n          op_params, GetTensorShape(input), GetTensorData<float>(input),\n          GetTensorShape(filter), GetTensorData<float>(filter),\n          GetTensorShape(bias), GetTensorData<float>(bias),\n          GetTensorShape(output), GetTensorData<float>(output));\n    }\n  } else if (kernel_type == kLegacyPie) {\n    return EvalPie(context, node, params, data, input, filter, bias, output);\n  } else {\n    FullyConnectedParams op_params;\n    op_params.float_activation_min = output_activation_min;\n    op_params.float_activation_max = output_activation_max;\n    if (filter->sparsity != nullptr) {\n      const auto& sparsity = *filter->sparsity;\n      if (!SupportedSparsityFormat(sparsity)) {\n        TF_LITE_KERNEL_LOG(context,\n                           \"Unsupported sparse fully-connected weight format.\");\n        return kTfLiteError;\n      }\n      const auto& input_shape = GetTensorShape(input);\n      const auto& filter_shape = GetTensorShape(filter);\n      const auto& output_shape = GetTensorShape(output);\n      const auto& bias_shape = GetTensorShape(bias);\n      if (!VerifySparsity(filter_shape, input_shape, output_shape, &sparsity)) {\n        TF_LITE_KERNEL_LOG(context, \"Invalid sparse fully-connected format.\");\n        return kTfLiteError;\n      }\n\n      if (sparsity.dim_metadata_size == kDimMetadataSizeRandomSparse) {\n        // Random sparse.\n        optimized_ops::FullyConnectedSparseWeight(\n            sparsity, op_params,                         // Disable formatting\n            input_shape, GetTensorData<float>(input),    // Disable formatting\n            filter_shape, GetTensorData<float>(filter),  // Disable formatting\n            bias_shape, GetTensorData<float>(bias),      // Disable formatting\n            output_shape, GetTensorData<float>(output));\n      } else if (sparsity.dim_metadata_size == kDimMetadataSizeBlockSparse &&\n                 sparsity.dim_metadata[2].dense_size == 4) {\n        // Block sparse with block size of 1x4.\n        optimized_ops::FullyConnectedSparseWeight1x4(\n            sparsity, op_params,                         // Disable formatting\n            input_shape, GetTensorData<float>(input),    // Disable formatting\n            filter_shape, GetTensorData<float>(filter),  // Disable formatting\n            bias_shape, GetTensorData<float>(bias),      // Disable formatting\n            output_shape, GetTensorData<float>(output),\n            CpuBackendContext::GetFromContext(context));\n      } else {\n        TF_LITE_KERNEL_LOG(context,\n                           \"Unsupported sparse fully-connected weight format.\");\n        return kTfLiteError;\n      }\n\n    } else {\n      op_params.lhs_cacheable = IsConstantTensor(filter);\n      op_params.rhs_cacheable = IsConstantTensor(input);\n      optimized_ops::FullyConnected(\n          op_params, GetTensorShape(input), GetTensorData<float>(input),\n          GetTensorShape(filter), GetTensorData<float>(filter),\n          GetTensorShape(bias), GetTensorData<float>(bias),\n          GetTensorShape(output), GetTensorData<float>(output),\n          CpuBackendContext::GetFromContext(context));\n    }\n  }\n\n  return kTfLiteOk;\n}", "target": 2, "idx": 10333}
{"commit_id": "c5a65115ebab55cfd5ce0a855c2256e01cab6449", "project": "wireshark", "func": "int\ndissect_dcom_BSTR(tvbuff_t *tvb, gint offset, packet_info *pinfo,\n\t\t       proto_tree *tree, dcerpc_info *di, guint8 *drep, int hfindex,\n\t\t\t\t\t   gchar *pszStr, guint32 u32MaxStr)\n{\n\tguint32 u32MaxCount;\n\tguint32 u32ArraySize;\n\tgint strStart, subStart, realOffset;\n\tproto_item *sub_item;\n\tproto_tree *sub_tree;\n\tguint32 u32ByteLength;\n\tgboolean isPrintable;\n\n\t/* alignment of 4 needed */\n\tif (offset % 4) {\n\t\toffset += 4 - (offset % 4);\n\t}\n\n\t/* add subtree item */\n\tsub_item = proto_tree_add_string(tree, hfindex, tvb, offset, 0, \"\");\n\tsub_tree = proto_item_add_subtree(sub_item, ett_dcom_lpwstr);\n\tsubStart = offset;\n\n\toffset = dissect_dcom_DWORD(tvb, offset, pinfo, sub_tree, di, drep,\n\t\t\thf_dcom_max_count, &u32MaxCount);\n\toffset = dissect_dcom_DWORD(tvb, offset, pinfo, sub_tree, di, drep,\n\t\t\thf_dcom_byte_length, &u32ByteLength);\n\toffset = dissect_dcom_dcerpc_array_size(tvb, offset, pinfo, sub_tree, di, drep,\n\t\t\t&u32ArraySize);\n\n\tif ((guint32)offset + u32ArraySize*2 > G_MAXINT) {\n\t\tpszStr[0] = 0;\n\t\treturn offset;\n\t}\n\n\trealOffset = offset + u32ArraySize*2;\n\n\tstrStart = offset;\n\toffset = dcom_tvb_get_nwstringz0(tvb, offset, u32ArraySize*2, pszStr, u32MaxStr, &isPrintable);\n\n\tproto_tree_add_string(sub_tree, hfindex, tvb, strStart, offset - strStart, pszStr);\n\n\t/* update subtree header */\n\tproto_item_append_text(sub_item, \"%s%s%s\",\n\tisPrintable ? \"\\\"\" : \"\", pszStr, isPrintable ? \"\\\"\" : \"\");\n\tif (realOffset <= subStart) {\n\t\t/* XXX - expert info */\n\t\treturn offset;\n\t}\n\tproto_item_set_len(sub_item, realOffset - subStart);\n\n\treturn realOffset;\n}", "target": 1, "idx": 10334}
{"commit_id": "4d3c75c0695b73de8df9dbd2158ebda258937d46", "project": "pts/sam2p", "func": "Image::SampledInfo::~SampledInfo() {\n  delete img;\n  if (imgs!=NULLP) { Image::Indexed::delete_separated(imgs); delete [] imgs; }\n}", "target": 2, "idx": 10335}
{"commit_id": "53a70289c2712808e6d4e88927e03cac01b470dd", "project": "vim", "func": "static int\nfind_next_quote(\n    char_u\t*line,\n    int\t\tcol,\n    int\t\tquotechar,\n    char_u\t*escape)\t// escape characters, can be NULL\n{\n    int\t\tc;\n\n    for (;;)\n    {\n\tc = line[col];\n\tif (c == NUL)\n\t    return -1;\n\telse if (escape != NULL && vim_strchr(escape, c))\n\t{\n\t    ++col;\n\t    if (line[col] == NUL)\n\t\treturn -1;\n\t}\n\telse if (c == quotechar)\n\t    break;\n\tif (has_mbyte)\n\t    col += (*mb_ptr2len)(line + col);\n\telse\n\t    ++col;\n    }\n    return col;\n}", "target": 2, "idx": 10336}
{"commit_id": "d800a65967b115c6e1aa6c3ba08861a304383088", "project": "chromium", "func": "FixedArrayBase* Heap::LeftTrimFixedArray(FixedArrayBase* object,\n                                         int elements_to_trim) {\n  DCHECK(!object->IsFixedTypedArrayBase());\n  DCHECK(!object->IsByteArray());\n  const int element_size = object->IsFixedArray() ? kPointerSize : kDoubleSize;\n  const int bytes_to_trim = elements_to_trim * element_size;\n  Map* map = object->map();\n\n  // For now this trick is only applied to objects in new and paged space.\n  // In large object space the object's start must coincide with chunk\n  // and thus the trick is just not applicable.\n  DCHECK(!lo_space()->Contains(object));\n  DCHECK(object->map() != fixed_cow_array_map());\n\n  STATIC_ASSERT(FixedArrayBase::kMapOffset == 0);\n  STATIC_ASSERT(FixedArrayBase::kLengthOffset == kPointerSize);\n  STATIC_ASSERT(FixedArrayBase::kHeaderSize == 2 * kPointerSize);\n\n  const int len = object->length();\n  DCHECK(elements_to_trim <= len);\n\n  // Calculate location of new array start.\n  Address new_start = object->address() + bytes_to_trim;\n\n  // Technically in new space this write might be omitted (except for\n  // debug mode which iterates through the heap), but to play safer\n  // we still do it.\n  CreateFillerObjectAt(object->address(), bytes_to_trim,\n                       ClearRecordedSlots::kYes);\n  // Initialize header of the trimmed array. Since left trimming is only\n  // performed on pages which are not concurrently swept creating a filler\n  // object does not require synchronization.\n  DCHECK(CanMoveObjectStart(object));\n  Object** former_start = HeapObject::RawField(object, 0);\n  int new_start_index = elements_to_trim * (element_size / kPointerSize);\n  former_start[new_start_index] = map;\n  former_start[new_start_index + 1] = Smi::FromInt(len - elements_to_trim);\n  FixedArrayBase* new_object =\n      FixedArrayBase::cast(HeapObject::FromAddress(new_start));\n\n  // Remove recorded slots for the new map and length offset.\n  ClearRecordedSlot(new_object, HeapObject::RawField(new_object, 0));\n  ClearRecordedSlot(new_object, HeapObject::RawField(\n                                    new_object, FixedArrayBase::kLengthOffset));\n\n  // Maintain consistency of live bytes during incremental marking\n  Marking::TransferMark(this, object->address(), new_start);\n  AdjustLiveBytes(new_object, -bytes_to_trim, Heap::CONCURRENT_TO_SWEEPER);\n\n  // Notify the heap profiler of change in object layout.\n  OnMoveEvent(new_object, object, new_object->Size());\n  return new_object;\n}", "target": 2, "idx": 10337}
{"commit_id": "37f2c716f2c6ab14c3ba557a539c3ee3224931b5", "project": "acpica", "func": "ACPI_STATUS\nAcpiNsEvaluate (\n    ACPI_EVALUATE_INFO      *Info)\n{\n    ACPI_STATUS             Status;\n\n\n    ACPI_FUNCTION_TRACE (NsEvaluate);\n\n\n    if (!Info)\n    {\n        return_ACPI_STATUS (AE_BAD_PARAMETER);\n    }\n\n    if (!Info->Node)\n    {\n        /*\n         * Get the actual namespace node for the target object if we\n         * need to. Handles these cases:\n         *\n         * 1) Null node, valid pathname from root (absolute path)\n         * 2) Node and valid pathname (path relative to Node)\n         * 3) Node, Null pathname\n         */\n        Status = AcpiNsGetNode (Info->PrefixNode, Info->RelativePathname,\n            ACPI_NS_NO_UPSEARCH, &Info->Node);\n        if (ACPI_FAILURE (Status))\n        {\n            return_ACPI_STATUS (Status);\n        }\n    }\n\n    /*\n     * For a method alias, we must grab the actual method node so that\n     * proper scoping context will be established before execution.\n     */\n    if (AcpiNsGetType (Info->Node) == ACPI_TYPE_LOCAL_METHOD_ALIAS)\n    {\n        Info->Node = ACPI_CAST_PTR (\n            ACPI_NAMESPACE_NODE, Info->Node->Object);\n    }\n\n    /* Complete the info block initialization */\n\n    Info->ReturnObject = NULL;\n    Info->NodeFlags = Info->Node->Flags;\n    Info->ObjDesc = AcpiNsGetAttachedObject (Info->Node);\n\n    ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, \"%s [%p] Value %p\\n\",\n        Info->RelativePathname, Info->Node,\n        AcpiNsGetAttachedObject (Info->Node)));\n\n    /* Get info if we have a predefined name (_HID, etc.) */\n\n    Info->Predefined = AcpiUtMatchPredefinedMethod (Info->Node->Name.Ascii);\n\n    /* Get the full pathname to the object, for use in warning messages */\n\n    Info->FullPathname = AcpiNsGetNormalizedPathname (Info->Node, TRUE);\n    if (!Info->FullPathname)\n    {\n        return_ACPI_STATUS (AE_NO_MEMORY);\n    }\n\n    /* Count the number of arguments being passed in */\n\n    Info->ParamCount = 0;\n    if (Info->Parameters)\n    {\n        while (Info->Parameters[Info->ParamCount])\n        {\n            Info->ParamCount++;\n        }\n\n        /* Warn on impossible argument count */\n\n        if (Info->ParamCount > ACPI_METHOD_NUM_ARGS)\n        {\n            ACPI_WARN_PREDEFINED ((AE_INFO, Info->FullPathname, ACPI_WARN_ALWAYS,\n                \"Excess arguments (%u) - using only %u\",\n                Info->ParamCount, ACPI_METHOD_NUM_ARGS));\n\n            Info->ParamCount = ACPI_METHOD_NUM_ARGS;\n        }\n    }\n\n    /*\n     * For predefined names: Check that the declared argument count\n     * matches the ACPI spec -- otherwise this is a BIOS error.\n     */\n    AcpiNsCheckAcpiCompliance (Info->FullPathname, Info->Node,\n        Info->Predefined);\n\n    /*\n     * For all names: Check that the incoming argument count for\n     * this method/object matches the actual ASL/AML definition.\n     */\n    AcpiNsCheckArgumentCount (Info->FullPathname, Info->Node,\n        Info->ParamCount, Info->Predefined);\n\n    /* For predefined names: Typecheck all incoming arguments */\n\n    AcpiNsCheckArgumentTypes (Info);\n\n    /*\n     * Three major evaluation cases:\n     *\n     * 1) Object types that cannot be evaluated by definition\n     * 2) The object is a control method -- execute it\n     * 3) The object is not a method -- just return it's current value\n     */\n    switch (AcpiNsGetType (Info->Node))\n    {\n    case ACPI_TYPE_DEVICE:\n    case ACPI_TYPE_EVENT:\n    case ACPI_TYPE_MUTEX:\n    case ACPI_TYPE_REGION:\n    case ACPI_TYPE_THERMAL:\n    case ACPI_TYPE_LOCAL_SCOPE:\n        /*\n         * 1) Disallow evaluation of certain object types. For these,\n         *    object evaluation is undefined and not supported.\n         */\n        ACPI_ERROR ((AE_INFO,\n            \"%s: Evaluation of object type [%s] is not supported\",\n            Info->FullPathname,\n            AcpiUtGetTypeName (Info->Node->Type)));\n\n        Status = AE_TYPE;\n        goto Cleanup;\n\n    case ACPI_TYPE_METHOD:\n        /*\n         * 2) Object is a control method - execute it\n         */\n\n        /* Verify that there is a method object associated with this node */\n\n        if (!Info->ObjDesc)\n        {\n            ACPI_ERROR ((AE_INFO, \"%s: Method has no attached sub-object\",\n                Info->FullPathname));\n            Status = AE_NULL_OBJECT;\n            goto Cleanup;\n        }\n\n        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,\n            \"**** Execute method [%s] at AML address %p length %X\\n\",\n            Info->FullPathname,\n            Info->ObjDesc->Method.AmlStart + 1,\n            Info->ObjDesc->Method.AmlLength - 1));\n\n        /*\n         * Any namespace deletion must acquire both the namespace and\n         * interpreter locks to ensure that no thread is using the portion of\n         * the namespace that is being deleted.\n         *\n         * Execute the method via the interpreter. The interpreter is locked\n         * here before calling into the AML parser\n         */\n        AcpiExEnterInterpreter ();\n        Status = AcpiPsExecuteMethod (Info);\n        AcpiExExitInterpreter ();\n        break;\n\n    default:\n        /*\n         * 3) All other non-method objects -- get the current object value\n         */\n\n        /*\n         * Some objects require additional resolution steps (e.g., the Node\n         * may be a field that must be read, etc.) -- we can't just grab\n         * the object out of the node.\n         *\n         * Use ResolveNodeToValue() to get the associated value.\n         *\n         * NOTE: we can get away with passing in NULL for a walk state because\n         * the Node is guaranteed to not be a reference to either a method\n         * local or a method argument (because this interface is never called\n         * from a running method.)\n         *\n         * Even though we do not directly invoke the interpreter for object\n         * resolution, we must lock it because we could access an OpRegion.\n         * The OpRegion access code assumes that the interpreter is locked.\n         */\n        AcpiExEnterInterpreter ();\n\n        /* TBD: ResolveNodeToValue has a strange interface, fix */\n\n        Info->ReturnObject = ACPI_CAST_PTR (ACPI_OPERAND_OBJECT, Info->Node);\n\n        Status = AcpiExResolveNodeToValue (ACPI_CAST_INDIRECT_PTR (\n            ACPI_NAMESPACE_NODE, &Info->ReturnObject), NULL);\n        AcpiExExitInterpreter ();\n\n        if (ACPI_FAILURE (Status))\n        {\n            Info->ReturnObject = NULL;\n            goto Cleanup;\n        }\n\n        ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, \"Returned object %p [%s]\\n\",\n            Info->ReturnObject,\n            AcpiUtGetObjectTypeName (Info->ReturnObject)));\n\n        Status = AE_CTRL_RETURN_VALUE; /* Always has a \"return value\" */\n        break;\n    }\n\n    /*\n     * For predefined names, check the return value against the ACPI\n     * specification. Some incorrect return value types are repaired.\n     */\n    (void) AcpiNsCheckReturnValue (Info->Node, Info, Info->ParamCount,\n        Status, &Info->ReturnObject);\n\n    /* Check if there is a return value that must be dealt with */\n\n    if (Status == AE_CTRL_RETURN_VALUE)\n    {\n        /* If caller does not want the return value, delete it */\n\n        if (Info->Flags & ACPI_IGNORE_RETURN_VALUE)\n        {\n            AcpiUtRemoveReference (Info->ReturnObject);\n            Info->ReturnObject = NULL;\n        }\n\n        /* Map AE_CTRL_RETURN_VALUE to AE_OK, we are done with it */\n\n        Status = AE_OK;\n    }\n    else if (ACPI_FAILURE(Status)) \n    {\n        /* If ReturnObject exists, delete it */\n\n        if (Info->ReturnObject) \n        {\n            AcpiUtRemoveReference (Info->ReturnObject);\n            Info->ReturnObject = NULL;\n        }\n    }\n\n    ACPI_DEBUG_PRINT ((ACPI_DB_NAMES,\n        \"*** Completed evaluation of object %s ***\\n\",\n        Info->RelativePathname));\n\nCleanup:\n    /*\n     * Namespace was unlocked by the handling AcpiNs* function, so we\n     * just free the pathname and return\n     */\n    ACPI_FREE (Info->FullPathname);\n    Info->FullPathname = NULL;\n    return_ACPI_STATUS (Status);\n}", "target": 1, "idx": 10338}
{"commit_id": "d88934406c5375d88f8f1b65331c9f0cab68cc6c", "project": "vim", "func": "static void\nappend_command(char_u *cmd)\n{\n    char_u *s = cmd;\n    char_u *d;\n\n    STRCAT(IObuff, \": \");\n    d = IObuff + STRLEN(IObuff);\n    while (*s != NUL && d - IObuff + 5 < IOSIZE)\n    {\n\tif (enc_utf8 ? (s[0] == 0xc2 && s[1] == 0xa0) : *s == 0xa0)\n\t{\n\t    s += enc_utf8 ? 2 : 1;\n\t    STRCPY(d, \"<a0>\");\n\t    d += 4;\n\t}\n\telse if (d - IObuff + (*mb_ptr2len)(s) + 1 >= IOSIZE)\n\t    break;\n\telse\n\t    MB_COPY_CHAR(s, d);\n    }\n    *d = NUL;\n}", "target": 2, "idx": 10339}
{"commit_id": "2eb0d1dab6a6de76cf3556130a2d52af101077db", "project": "GNS3/ubridge", "func": "int parse_config(char *filename, bridge_t **bridges)\n{\n    dictionary *ubridge_config = NULL;\n    const char *value;\n    const char *bridge_name;\n    int i, nsec;\n\n    if ((ubridge_config = iniparser_load(filename, HIDE_ERRORED_LINE_CONTENT)) == NULL) {\n       return FALSE;\n    }\n\n    nsec = iniparser_getnsec(ubridge_config);\n    for (i = 0; i < nsec; i++) {\n        bridge_t *bridge;\n        nio_t *source_nio = NULL;\n        nio_t *destination_nio = NULL;\n\n        bridge_name = iniparser_getsecname(ubridge_config, i);\n        printf(\"Parsing %s\\n\", bridge_name);\n        if (getstr(ubridge_config, bridge_name, \"source_udp\", &value))\n           source_nio = create_udp_tunnel(value);\n        else if (getstr(ubridge_config, bridge_name, \"source_unix\", &value))\n           source_nio = create_unix_socket(value);\n        else if (getstr(ubridge_config, bridge_name, \"source_ethernet\", &value))\n           source_nio = open_ethernet_device(value);\n        else if (getstr(ubridge_config, bridge_name, \"source_tap\", &value))\n           source_nio = open_tap_device(value);\n#ifdef LINUX_RAW\n        else if (getstr(ubridge_config, bridge_name, \"source_linux_raw\", &value))\n           source_nio = open_linux_raw(value);\n#endif\n#ifdef __APPLE__\n        else if (getstr(ubridge_config, bridge_name, \"source_fusion_vmnet\", &value))\n           source_nio = open_fusion_vmnet(value);\n#endif\n        else\n           fprintf(stderr, \"source NIO not found\\n\");\n\n        if (getstr(ubridge_config, bridge_name, \"destination_udp\", &value))\n           destination_nio = create_udp_tunnel(value);\n        else if (getstr(ubridge_config, bridge_name, \"destination_unix\", &value))\n           destination_nio = create_unix_socket(value);\n        else if (getstr(ubridge_config, bridge_name, \"destination_ethernet\", &value))\n           destination_nio = open_ethernet_device(value);\n        else if (getstr(ubridge_config, bridge_name, \"destination_tap\", &value))\n           destination_nio = open_tap_device(value);\n#ifdef LINUX_RAW\n        else if (getstr(ubridge_config, bridge_name, \"destination_linux_raw\", &value))\n           source_nio = open_linux_raw(value);\n#endif\n#ifdef __APPLE__\n        else if (getstr(ubridge_config, bridge_name, \"destination_fusion_vmnet\", &value))\n           destination_nio = open_fusion_vmnet(value);\n#endif\n        else\n           fprintf(stderr, \"destination NIO not found\\n\");\n\n        if (source_nio && destination_nio) {\n           bridge = add_bridge(bridges);\n           bridge->source_nio = source_nio;\n           bridge->destination_nio = destination_nio;\n           if (!(bridge->name = strdup(bridge_name))) {\n              fprintf(stderr, \"bridge creation: insufficient memory\\n\");\n              return FALSE;\n           }\n           parse_capture(ubridge_config, bridge_name, bridge);\n           parse_filter(ubridge_config, bridge_name, bridge);\n        }\n        else if (source_nio != NULL)\n           free_nio(source_nio);\n        else if (destination_nio != NULL)\n           free_nio(destination_nio);\n    }\n    iniparser_freedict(ubridge_config);\n    return TRUE;\n}", "target": 1, "idx": 10340}
{"commit_id": "df4bf28f9f104ca3ef78ed94b497859f15b004e5", "project": "php/php-src", "func": "static inline int process_nested_data(UNSERIALIZE_PARAMETER, HashTable *ht, long elements, int objprops)\n{\n\twhile (elements-- > 0) {\n\t\tzval *key, *data, **old_data;\n\n\t\tALLOC_INIT_ZVAL(key);\n\n\t\tif (!php_var_unserialize(&key, p, max, NULL TSRMLS_CC)) {\n            var_push_dtor_no_addref(var_hash, &key);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (Z_TYPE_P(key) != IS_LONG && Z_TYPE_P(key) != IS_STRING) {\n            var_push_dtor_no_addref(var_hash, &key);\n\t\t\treturn 0;\n\t\t}\n\n\t\tALLOC_INIT_ZVAL(data);\n\n\t\tif (!php_var_unserialize(&data, p, max, var_hash TSRMLS_CC)) {\n            var_push_dtor_no_addref(var_hash, &key);\n            var_push_dtor_no_addref(var_hash, &data);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!objprops) {\n\t\t\tswitch (Z_TYPE_P(key)) {\n\t\t\tcase IS_LONG:\n\t\t\t\tif (zend_hash_index_find(ht, Z_LVAL_P(key), (void **)&old_data)==SUCCESS) {\n\t\t\t\t\tvar_push_dtor(var_hash, old_data);\n\t\t\t\t}\n\t\t\t\tzend_hash_index_update(ht, Z_LVAL_P(key), &data, sizeof(data), NULL);\n\t\t\t\tbreak;\n\t\t\tcase IS_STRING:\n\t\t\t\tif (zend_symtable_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) {\n\t\t\t\t\tvar_push_dtor(var_hash, old_data);\n\t\t\t\t}\n\t\t\t\tzend_symtable_update(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, &data, sizeof(data), NULL);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t/* object properties should include no integers */\n\t\t\tconvert_to_string(key);\n\t\t\tif (zend_hash_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) {\n\t\t\t\tvar_push_dtor(var_hash, old_data);\n\t\t\t}\n\t\t\tzend_hash_update(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, &data,\n\t\t\t\t\tsizeof data, NULL);\n\t\t}\n\t\tvar_push_dtor(var_hash, &data);\n        var_push_dtor_no_addref(var_hash, &key);\n\n\t\tif (elements && *(*p-1) != ';' && *(*p-1) != '}') {\n\t\t\t(*p)--;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}", "target": 3, "idx": 10341}
{"commit_id": "cc080e9e9be16ccf26135d366d7d2b65209f1d56", "project": "torvalds/linux", "func": "static int fuse_dev_fasync(int fd, struct file *file, int on)\n{\n\tstruct fuse_dev *fud = fuse_get_dev(file);\n\n\tif (!fud)\n\t\treturn -EPERM;\n\n\t/* No locking - fasync_helper does its own locking */\n\treturn fasync_helper(fd, file, on, &fud->fc->iq.fasync);\n}", "target": 1, "idx": 10342}
{"commit_id": "2b09d5d364986f724f17001ccfe4126b9b43a0be", "project": "torvalds/linux", "func": "static int fbcon_set_font(struct vc_data *vc, struct console_font *font,\n\t\t\t  unsigned int flags)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tunsigned charcount = font->charcount;\n\tint w = font->width;\n\tint h = font->height;\n\tint size;\n\tint i, csum;\n\tu8 *new_data, *data = font->data;\n\tint pitch = PITCH(font->width);\n\n\t/* Is there a reason why fbconsole couldn't handle any charcount >256?\n\t * If not this check should be changed to charcount < 256 */\n\tif (charcount != 256 && charcount != 512)\n\t\treturn -EINVAL;\n\n\t/* font bigger than screen resolution ? */\n\tif (w > FBCON_SWAP(info->var.rotate, info->var.xres, info->var.yres) ||\n\t    h > FBCON_SWAP(info->var.rotate, info->var.yres, info->var.xres))\n\t\treturn -EINVAL;\n\n\tif (font->width > 32 || font->height > 32)\n\t\treturn -EINVAL;\n\n\t/* Make sure drawing engine can handle the font */\n\tif (!(info->pixmap.blit_x & BIT(font->width - 1)) ||\n\t    !(info->pixmap.blit_y & BIT(font->height - 1)))\n\t\treturn -EINVAL;\n\n\t/* Make sure driver can handle the font length */\n\tif (fbcon_invalid_charcount(info, charcount))\n\t\treturn -EINVAL;\n\n\tsize = CALC_FONTSZ(h, pitch, charcount);\n\n\tnew_data = kmalloc(FONT_EXTRA_WORDS * sizeof(int) + size, GFP_USER);\n\n\tif (!new_data)\n\t\treturn -ENOMEM;\n\n\tmemset(new_data, 0, FONT_EXTRA_WORDS * sizeof(int));\n\n\tnew_data += FONT_EXTRA_WORDS * sizeof(int);\n\tFNTSIZE(new_data) = size;\n\tREFCOUNT(new_data) = 0;\t/* usage counter */\n\tfor (i=0; i< charcount; i++) {\n\t\tmemcpy(new_data + i*h*pitch, data +  i*32*pitch, h*pitch);\n\t}\n\n\t/* Since linux has a nice crc32 function use it for counting font\n\t * checksums. */\n\tcsum = crc32(0, new_data, size);\n\n\tFNTSUM(new_data) = csum;\n\t/* Check if the same font is on some other console already */\n\tfor (i = first_fb_vc; i <= last_fb_vc; i++) {\n\t\tstruct vc_data *tmp = vc_cons[i].d;\n\t\t\n\t\tif (fb_display[i].userfont &&\n\t\t    fb_display[i].fontdata &&\n\t\t    FNTSUM(fb_display[i].fontdata) == csum &&\n\t\t    FNTSIZE(fb_display[i].fontdata) == size &&\n\t\t    tmp->vc_font.width == w &&\n\t\t    !memcmp(fb_display[i].fontdata, new_data, size)) {\n\t\t\tkfree(new_data - FONT_EXTRA_WORDS * sizeof(int));\n\t\t\tnew_data = (u8 *)fb_display[i].fontdata;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn fbcon_do_set_font(vc, font->width, font->height, charcount, new_data, 1);\n}", "target": 1, "idx": 10343}
{"commit_id": "6a1580e84f492b5671d23be98192267bb73de250", "project": "poppler", "func": "SplashError Splash::blitTransparent(SplashBitmap *src, int xSrc, int ySrc,\n\t\t\t\t    int xDest, int yDest, int w, int h) {\n  SplashColorPtr p, sp;\n  unsigned char *q;\n  int x, y, mask, srcMask, width = w, height = h;\n\n  if (src->mode != bitmap->mode) {\n    return splashErrModeMismatch;\n  }\n\n  if (unlikely(!bitmap->data)) {\n    return splashErrZeroImage;\n  }\n\n  if (src->getWidth() - xSrc < width)\n    width = src->getWidth() - xSrc;\n\n  if (src->getHeight() - ySrc < height)\n    height = src->getHeight() - ySrc;\n\n  if (bitmap->getWidth() - xDest < width)\n    width = bitmap->getWidth() - xDest;\n\n  if (bitmap->getHeight() - yDest < height)\n    height = bitmap->getHeight() - yDest;\n\n  if (width < 0)\n    width = 0;\n\n  if (height < 0)\n    height = 0;\n\n  switch (bitmap->mode) {\n  case splashModeMono1:\n    for (y = 0; y < height; ++y) {\n      p = &bitmap->data[(yDest + y) * bitmap->rowSize + (xDest >> 3)];\n      mask = 0x80 >> (xDest & 7);\n      sp = &src->data[(ySrc + y) * src->rowSize + (xSrc >> 3)];\n      srcMask = 0x80 >> (xSrc & 7);\n      for (x = 0; x < width; ++x) {\n\tif (*sp & srcMask) {\n\t  *p |= mask;\n\t} else {\n\t  *p &= ~mask;\n\t}\n\tif (!(mask >>= 1)) {\n\t  mask = 0x80;\n\t  ++p;\n\t}\n\tif (!(srcMask >>= 1)) {\n\t  srcMask = 0x80;\n\t  ++sp;\n\t}\n      }\n    }\n    break;\n  case splashModeMono8:\n    for (y = 0; y < height; ++y) {\n      p = &bitmap->data[(yDest + y) * bitmap->rowSize + xDest];\n      sp = &src->data[(ySrc + y) * bitmap->rowSize + xSrc];\n      for (x = 0; x < width; ++x) {\n\t*p++ = *sp++;\n      }\n    }\n    break;\n  case splashModeRGB8:\n  case splashModeBGR8:\n    for (y = 0; y < height; ++y) {\n      p = &bitmap->data[(yDest + y) * bitmap->rowSize + 3 * xDest];\n      sp = &src->data[(ySrc + y) * src->rowSize + 3 * xSrc];\n      for (x = 0; x < width; ++x) {\n\t*p++ = *sp++;\n\t*p++ = *sp++;\n\t*p++ = *sp++;\n      }\n    }\n    break;\n  case splashModeXBGR8:\n    for (y = 0; y < height; ++y) {\n      p = &bitmap->data[(yDest + y) * bitmap->rowSize + 4 * xDest];\n      sp = &src->data[(ySrc + y) * src->rowSize + 4 * xSrc];\n      for (x = 0; x < width; ++x) {\n\t*p++ = *sp++;\n\t*p++ = *sp++;\n\t*p++ = *sp++;\n\t*p++ = 255;\n\tsp++;\n      }\n    }\n    break;\n#ifdef SPLASH_CMYK\n  case splashModeCMYK8:\n    for (y = 0; y < height; ++y) {\n      p = &bitmap->data[(yDest + y) * bitmap->rowSize + 4 * xDest];\n      sp = &src->data[(ySrc + y) * src->rowSize + 4 * xSrc];\n      for (x = 0; x < width; ++x) {\n\t*p++ = *sp++;\n\t*p++ = *sp++;\n\t*p++ = *sp++;\n\t*p++ = *sp++;\n      }\n    }\n    break;\n  case splashModeDeviceN8:\n    for (y = 0; y < height; ++y) {\n      p = &bitmap->data[(yDest + y) * bitmap->rowSize + (SPOT_NCOMPS+4) * xDest];\n      sp = &src->data[(ySrc + y) * src->rowSize + (SPOT_NCOMPS+4) * xSrc];\n      for (x = 0; x < width; ++x) {\n        for (int cp=0; cp < SPOT_NCOMPS+4; cp++)\n          *p++ = *sp++;\n      }\n    }\n    break;\n#endif\n  }\n\n  if (bitmap->alpha) {\n    for (y = 0; y < height; ++y) {\n      q = &bitmap->alpha[(yDest + y) * bitmap->width + xDest];\n      memset(q, 0x00, width);\n    }\n  }\n\n  return splashOk;\n}", "target": 2, "idx": 10344}
{"commit_id": "f28015671a4b04785859d1b4b1327b367b6a10e9", "project": "acassen/keepalived", "func": "int extract_status_code(char *buffer, size_t size)\n{\n\tchar *end = buffer + size;\n\tunsigned long code;\n\n\t/* Status-Code extraction */\n\twhile (buffer < end && *buffer != ' ' && *buffer != '\\r')\n\t\tbuffer++;\n\tbuffer++;\n\tif (buffer + 3 >= end || *buffer == ' ' || buffer[3] != ' ')\n\t\treturn 0;\n\tcode = strtoul(buffer, &end, 10);\n\tif (buffer + 3 != end)\n\t\treturn 0;\n\treturn code;\n}", "target": 3, "idx": 10345}
{"commit_id": "b327645e648d46c8730be80730a171cf74cfe338", "project": "upx", "func": "Elf64_Sym const *PackLinuxElf64::elf_lookup(char const *name) const\n{\n    if (hashtab && dynsym && dynstr) {\n        unsigned const nbucket = get_te32(&hashtab[0]);\n        unsigned const *const buckets = &hashtab[2];\n        unsigned const *const chains = &buckets[nbucket];\n        unsigned const m = elf_hash(name) % nbucket;\n        if ((unsigned)(file_size - ((char const *)buckets - (char const *)(void const *)file_image))\n                <= sizeof(unsigned)*nbucket ) {\n            char msg[80]; snprintf(msg, sizeof(msg),\n                \"bad nbucket %#x\\n\", nbucket);\n            throwCantPack(msg);\n        }\n        unsigned si;\n        for (si= get_te32(&buckets[m]); 0!=si; si= get_te32(&chains[si])) {\n            char const *const p= get_dynsym_name(si, (unsigned)-1);\n            if (0==strcmp(name, p)) {\n                return &dynsym[si];\n            }\n        }\n    }\n    if (gashtab && dynsym && dynstr) {\n        unsigned const n_bucket = get_te32(&gashtab[0]);\n        unsigned const symbias  = get_te32(&gashtab[1]);\n        unsigned const n_bitmask = get_te32(&gashtab[2]);\n        unsigned const gnu_shift = get_te32(&gashtab[3]);\n        upx_uint64_t const *const bitmask = (upx_uint64_t const *)(void const *)&gashtab[4];\n        unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask];\n        unsigned     const *const hasharr = &buckets[n_bucket];\n        if ((unsigned)(file_size - ((char const *)bitmask - (char const *)(void const *)file_image))\n                <= sizeof(unsigned)*n_bitmask ) {\n            char msg[80]; snprintf(msg, sizeof(msg),\n                \"bad n_bitmask %#x\\n\", n_bitmask);\n            throwCantPack(msg);\n        }\n\n        unsigned const h = gnu_hash(name);\n        unsigned const hbit1 = 077& h;\n        unsigned const hbit2 = 077& (h>>gnu_shift);\n        upx_uint64_t const w = get_te64(&bitmask[(n_bitmask -1) & (h>>6)]);\n\n        if (1& (w>>hbit1) & (w>>hbit2)) {\n            unsigned bucket = get_te32(&buckets[h % n_bucket]);\n            if (n_bucket <= bucket) {\n                char msg[80]; snprintf(msg, sizeof(msg),\n                        \"bad DT_GNU_HASH n_bucket{%#x} <= buckets[%d]{%#x}\\n\",\n                        n_bucket, h % n_bucket, bucket);\n                throwCantPack(msg);\n            }\n            if (0!=bucket) {\n                Elf64_Sym const *dsp = &dynsym[bucket];\n                unsigned const *hp = &hasharr[bucket - symbias];\n\n                do if (0==((h ^ get_te32(hp))>>1)) {\n                    unsigned st_name = get_te32(&dsp->st_name);\n                    char const *const p = get_str_name(st_name, (unsigned)-1);\n                    if (0==strcmp(name, p)) {\n                        return dsp;\n                    }\n                } while (++dsp,\n                        (char const *)hp < (char const *)&file_image[file_size]\n                    &&  0==(1u& get_te32(hp++)));\n            }\n        }\n    }\n    return 0;\n\n}", "target": 2, "idx": 10346}
{"commit_id": "203214568f5bc237603dbab6e1fd389f1572f5c9", "project": "tensorflow", "func": "void Compute(OpKernelContext* ctx) override {\n    try {\n      const Tensor& input = ctx->input(kInputTensorIndex);\n      OP_REQUIRES(\n          ctx, input.dims() == 4,\n          errors::InvalidArgument(\"Current RequantizePerChannel operator\"\n                                  \"supports 4D tensors only.\"));\n\n      const Tensor& input_min_vec = ctx->input(kInputMinVecIndex);\n      size_t depth = input_min_vec.NumElements();\n      float* input_min_vec_data = (float*)const_cast<void*>(\n          static_cast<const void*>(input_min_vec.flat<float>().data()));\n\n      const Tensor& input_max_vec = ctx->input(kInputMaxVecIndex);\n      OP_REQUIRES(\n          ctx, input_max_vec.NumElements() == depth,\n          errors::InvalidArgument(\"input_max has incorrect size, expected \",\n                                  depth, \" was \", input_max_vec.NumElements()));\n      float* input_max_vec_data = (float*)const_cast<void*>(\n          static_cast<const void*>(input_max_vec.flat<float>().data()));\n\n      const Tensor& input_requested_min = ctx->input(this->kRequestMinIndex);\n      OP_REQUIRES(\n          ctx, input_requested_min.NumElements() == 1,\n          errors::InvalidArgument(\"requested_output_min must be a scalar\"));\n      const float input_requested_min_float =\n          input_requested_min.flat<float>()(0);\n\n      const Tensor& input_requested_max = ctx->input(this->kRequestMaxIndex);\n      OP_REQUIRES(\n          ctx, input_requested_min.NumElements() == 1,\n          errors::InvalidArgument(\"requested_output_max must be a scalar\"));\n      const float input_requested_max_float =\n          input_requested_max.flat<float>()(0);\n\n      if (out_type_ == DT_QINT8) {\n        OP_REQUIRES(ctx, input_requested_min_float < 0.0f,\n                    errors::InvalidArgument(\n                        \"If out_type is QINT8, requested_output_max must be \"\n                        \"non negative, got \",\n                        input_requested_min_float));\n      }\n\n      const float factor = (out_type_ == DT_QINT8) ? 127.0f : 255.0f;\n      const float requested_min_max =\n          std::max(std::abs(input_requested_min_float),\n                   std::abs(input_requested_max_float));\n      Tensor* output = nullptr;\n      OP_REQUIRES_OK(ctx, ctx->allocate_output(kOutputTensorIndex,\n                                               input.shape(), &output));\n\n      std::vector<float> scales(depth);\n      for (int i = 0; i < depth; ++i) {\n        float min_max_from_vec = std::max(std::abs(input_min_vec_data[i]),\n                                          std::abs(input_max_vec_data[i]));\n        scales[i] = factor * (min_max_from_vec / requested_min_max /\n                              static_cast<float>(1L << 31));\n      }\n\n      mkldnn::primitive_attr reorder_attr;\n      reorder_attr.set_output_scales(2, scales);\n\n      memory::dims dims_mkl_order =\n          TFShapeToMklDnnDimsInNCHW(input.shape(), FORMAT_NHWC);\n      memory::desc input_md = memory::desc(dims_mkl_order, MklDnnType<qint32>(),\n                                           memory::format_tag::nhwc);\n      memory::desc output_md =\n          (out_type_ == DT_QINT8)\n              ? memory::desc(dims_mkl_order, MklDnnType<qint8>(),\n                             memory::format_tag::nhwc)\n              : memory::desc(dims_mkl_order, MklDnnType<quint8>(),\n                             memory::format_tag::nhwc);\n\n      void* input_buf =\n          static_cast<void*>(const_cast<qint32*>(input.flat<qint32>().data()));\n      void* output_buf;\n      if (out_type_ == DT_QINT8) {\n        output_buf = static_cast<void*>(\n            const_cast<qint8*>(output->flat<qint8>().data()));\n      } else {\n        output_buf = static_cast<void*>(\n            const_cast<quint8*>(output->flat<quint8>().data()));\n      }\n\n      std::unique_ptr<memory> input_mem_prim(\n          new memory(input_md, cpu_engine_, input_buf));\n      std::unique_ptr<memory> output_mem_prim(\n          new memory(output_md, cpu_engine_, output_buf));\n\n      mkldnn::reorder::primitive_desc reorder_pd =\n          ReorderPd(cpu_engine_, input_mem_prim->get_desc(), cpu_engine_,\n                    output_mem_prim->get_desc(), reorder_attr);\n      std::shared_ptr<stream> reorder_stream;\n      MklDnnThreadPool eigen_tp(ctx);\n      reorder_stream.reset(CreateStream(&eigen_tp, cpu_engine_));\n      std::unordered_map<int, mkldnn::memory> reorder_args = {\n          {MKLDNN_ARG_FROM, *input_mem_prim},\n          {MKLDNN_ARG_TO, *output_mem_prim}};\n      std::unique_ptr<mkldnn::primitive> reorder_prim(\n          new mkldnn::reorder(reorder_pd));\n      reorder_prim->execute(*reorder_stream, reorder_args);\n\n      Tensor* output_min = nullptr;\n      Tensor* output_max = nullptr;\n      OP_REQUIRES_OK(ctx,\n                     ctx->allocate_output(kOutputMinIndex, {}, &output_min));\n      OP_REQUIRES_OK(ctx,\n                     ctx->allocate_output(kOutputMaxIndex, {}, &output_max));\n\n      output_min->flat<float>()(0) = input_requested_min_float;\n      output_max->flat<float>()(0) = input_requested_max_float;\n    } catch (mkldnn::error& e) {\n      string error_msg = \"Status: \" + std::to_string(e.status) +\n                         \", message: \" + std::string(e.message) + \", in file \" +\n                         std::string(__FILE__) + \":\" + std::to_string(__LINE__);\n      OP_REQUIRES_OK(\n          ctx, errors::Aborted(\"Operation received an exception:\", error_msg));\n    }\n  }", "target": 2, "idx": 10347}
{"commit_id": "f595a1985233c399a05c0c37cc41de16a90dd025", "project": "ImageMagick", "func": "MagickExport MagickBooleanType AnnotateImage(Image *image,\n  const DrawInfo *draw_info,ExceptionInfo *exception)\n{\n  char\n    *p,\n    primitive[MagickPathExtent],\n    *text,\n    **textlist;\n\n  DrawInfo\n    *annotate,\n    *annotate_info;\n\n  GeometryInfo\n    geometry_info;\n\n  MagickBooleanType\n    status;\n\n  PointInfo\n    offset;\n\n  RectangleInfo\n    geometry;\n\n  register ssize_t\n    i;\n\n  TypeMetric\n    metrics;\n\n  size_t\n    height,\n    number_lines;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(draw_info != (DrawInfo *) NULL);\n  assert(draw_info->signature == MagickCoreSignature);\n  if (draw_info->text == (char *) NULL)\n    return(MagickFalse);\n  if (*draw_info->text == '\\0')\n    return(MagickTrue);\n  annotate=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  text=annotate->text;\n  annotate->text=(char *) NULL;\n  annotate_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  number_lines=1;\n  for (p=text; *p != '\\0'; p++)\n    if (*p == '\\n')\n      number_lines++;\n  textlist=AcquireQuantumMemory(number_lines+1,sizeof(*textlist));\n  if (textlist == (char **) NULL)\n    {\n      annotate_info=DestroyDrawInfo(annotate_info);\n      annotate=DestroyDrawInfo(annotate);\n      return(MagickFalse);\n    }\n  p=text;\n  for (i=0; i < number_lines; i++)\n  {\n    char\n      *q;\n\n    textlist[i]=p;\n    for (q=p; *q != '\\0'; q++)\n      if ((*q == '\\r') || (*q == '\\n'))\n        break;\n    if (*q == '\\r')\n      {\n        *q='\\0';\n        q++;\n      }\n    *q='\\0';\n    p=q+1;\n  }\n  textlist[i]=(char *) NULL;\n  SetGeometry(image,&geometry);\n  SetGeometryInfo(&geometry_info);\n  if (annotate_info->geometry != (char *) NULL)\n    {\n      (void) ParsePageGeometry(image,annotate_info->geometry,&geometry,\n        exception);\n      (void) ParseGeometry(annotate_info->geometry,&geometry_info);\n    }\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    {\n      annotate_info=DestroyDrawInfo(annotate_info);\n      annotate=DestroyDrawInfo(annotate);\n      textlist=(char **) RelinquishMagickMemory(textlist);\n      return(MagickFalse);\n    }\n  if (IsGrayColorspace(image->colorspace) != MagickFalse)\n    (void) SetImageColorspace(image,sRGBColorspace,exception);\n  status=MagickTrue;\n  (void) memset(&metrics,0,sizeof(metrics));\n  for (i=0; textlist[i] != (char *) NULL; i++)\n  {\n    if (*textlist[i] == '\\0')\n      continue;\n    /*\n      Position text relative to image.\n    */\n    annotate_info->affine.tx=geometry_info.xi-image->page.x;\n    annotate_info->affine.ty=geometry_info.psi-image->page.y;\n    (void) CloneString(&annotate->text,textlist[i]);\n    if ((metrics.width == 0) || (annotate->gravity != NorthWestGravity))\n      (void) GetTypeMetrics(image,annotate,&metrics,exception);\n    height=(ssize_t) (metrics.ascent-metrics.descent+\n      draw_info->interline_spacing+0.5);\n    switch (annotate->gravity)\n    {\n      case UndefinedGravity:\n      default:\n      {\n        offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height;\n        offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height;\n        break;\n      }\n      case NorthWestGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+i*\n          annotate_info->affine.ry*height+annotate_info->affine.ry*\n          (metrics.ascent+metrics.descent);\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+i*\n          annotate_info->affine.sy*height+annotate_info->affine.sy*\n          metrics.ascent;\n        break;\n      }\n      case NorthGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+\n          geometry.width/2.0+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width/2.0+annotate_info->affine.ry*\n          (metrics.ascent+metrics.descent);\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+i*\n          annotate_info->affine.sy*height+annotate_info->affine.sy*\n          metrics.ascent-annotate_info->affine.rx*metrics.width/2.0;\n        break;\n      }\n      case NorthEastGravity:\n      {\n        offset.x=(geometry.width == 0 ? 1.0 : -1.0)*annotate_info->affine.tx+\n          geometry.width+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width+annotate_info->affine.ry*\n          (metrics.ascent+metrics.descent)-1.0;\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+i*\n          annotate_info->affine.sy*height+annotate_info->affine.sy*\n          metrics.ascent-annotate_info->affine.rx*metrics.width;\n        break;\n      }\n      case WestGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+i*\n          annotate_info->affine.ry*height+annotate_info->affine.ry*\n          (metrics.ascent+metrics.descent-(number_lines-1.0)*height)/2.0;\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+\n          geometry.height/2.0+i*annotate_info->affine.sy*height+\n          annotate_info->affine.sy*(metrics.ascent+metrics.descent-\n          (number_lines-1.0)*height)/2.0;\n        break;\n      }\n      case CenterGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+\n          geometry.width/2.0+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width/2.0+annotate_info->affine.ry*\n          (metrics.ascent+metrics.descent-(number_lines-1.0)*height)/2.0;\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+\n          geometry.height/2.0+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width/2.0+annotate_info->affine.sy*\n          (metrics.ascent+metrics.descent-(number_lines-1.0)*height)/2.0;\n        break;\n      }\n      case EastGravity:\n      {\n        offset.x=(geometry.width == 0 ? 1.0 : -1.0)*annotate_info->affine.tx+\n          geometry.width+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width+\n          annotate_info->affine.ry*(metrics.ascent+metrics.descent-\n          (number_lines-1.0)*height)/2.0-1.0;\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+\n          geometry.height/2.0+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width+\n          annotate_info->affine.sy*(metrics.ascent+metrics.descent-\n          (number_lines-1.0)*height)/2.0;\n        break;\n      }\n      case SouthWestGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+i*\n          annotate_info->affine.ry*height-annotate_info->affine.ry*\n          (number_lines-1.0)*height;\n        offset.y=(geometry.height == 0 ? 1.0 : -1.0)*annotate_info->affine.ty+\n          geometry.height+i*annotate_info->affine.sy*height-\n          annotate_info->affine.sy*(number_lines-1.0)*height+metrics.descent;\n        break;\n      }\n      case SouthGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+\n          geometry.width/2.0+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width/2.0-\n          annotate_info->affine.ry*(number_lines-1.0)*height/2.0;\n        offset.y=(geometry.height == 0 ? 1.0 : -1.0)*annotate_info->affine.ty+\n          geometry.height+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width/2.0-\n          annotate_info->affine.sy*(number_lines-1.0)*height+metrics.descent;\n        break;\n      }\n      case SouthEastGravity:\n      {\n        offset.x=(geometry.width == 0 ? 1.0 : -1.0)*annotate_info->affine.tx+\n          geometry.width+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width-\n          annotate_info->affine.ry*(number_lines-1.0)*height-1.0;\n        offset.y=(geometry.height == 0 ? 1.0 : -1.0)*annotate_info->affine.ty+\n          geometry.height+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width-\n          annotate_info->affine.sy*(number_lines-1.0)*height+metrics.descent;\n        break;\n      }\n    }\n    switch (annotate->align)\n    {\n      case LeftAlign:\n      {\n        offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height;\n        offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height;\n        break;\n      }\n      case CenterAlign:\n      {\n        offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width/2.0;\n        offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width/2.0;\n        break;\n      }\n      case RightAlign:\n      {\n        offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width;\n        offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width;\n        break;\n      }\n      default:\n        break;\n    }\n    if (draw_info->undercolor.alpha != TransparentAlpha)\n      {\n        DrawInfo\n          *undercolor_info;\n\n        /*\n          Text box.\n        */\n        undercolor_info=CloneDrawInfo((ImageInfo *) NULL,(DrawInfo *) NULL);\n        undercolor_info->fill=draw_info->undercolor;\n        undercolor_info->affine=draw_info->affine;\n        undercolor_info->affine.tx=offset.x-draw_info->affine.ry*metrics.ascent;\n        undercolor_info->affine.ty=offset.y-draw_info->affine.sy*metrics.ascent;\n        (void) FormatLocaleString(primitive,MagickPathExtent,\n          \"rectangle 0.0,0.0 %g,%g\",metrics.origin.x,(double) height);\n        (void) CloneString(&undercolor_info->primitive,primitive);\n        (void) DrawImage(image,undercolor_info,exception);\n        (void) DestroyDrawInfo(undercolor_info);\n      }\n    annotate_info->affine.tx=offset.x;\n    annotate_info->affine.ty=offset.y;\n    (void) FormatLocaleString(primitive,MagickPathExtent,\"stroke-width %g \"\n      \"line 0,0 %g,0\",metrics.underline_thickness,metrics.width);\n    if (annotate->decorate == OverlineDecoration)\n      {\n        annotate_info->affine.ty-=(draw_info->affine.sy*(metrics.ascent+\n          metrics.descent-metrics.underline_position));\n        (void) CloneString(&annotate_info->primitive,primitive);\n        (void) DrawImage(image,annotate_info,exception);\n      }\n    else\n      if (annotate->decorate == UnderlineDecoration)\n        {\n          annotate_info->affine.ty-=(draw_info->affine.sy*\n            metrics.underline_position);\n          (void) CloneString(&annotate_info->primitive,primitive);\n          (void) DrawImage(image,annotate_info,exception);\n        }\n    /*\n      Annotate image with text.\n    */\n    status=RenderType(image,annotate,&offset,&metrics,exception);\n    if (status == MagickFalse)\n      break;\n    if (annotate->decorate == LineThroughDecoration)\n      {\n        annotate_info->affine.ty-=(draw_info->affine.sy*(height+\n          metrics.underline_position+metrics.descent)/2.0);\n        (void) CloneString(&annotate_info->primitive,primitive);\n        (void) DrawImage(image,annotate_info,exception);\n      }\n  }\n  /*\n    Relinquish resources.\n  */\n  annotate_info=DestroyDrawInfo(annotate_info);\n  annotate=DestroyDrawInfo(annotate);\n  textlist=(char **) RelinquishMagickMemory(textlist);\n  return(status);\n}", "target": 1, "idx": 10348}
{"commit_id": "ed4c8d79153baab7f26562afb8930652dfbf853b", "project": "android", "func": "static uint32_t readU16(const uint8_t* data, size_t offset) {\n    return ((uint32_t)data[offset]) << 8 | ((uint32_t)data[offset + 1]);\n}", "target": 1, "idx": 10349}
{"commit_id": "eb921122119a6b6e470ee98b89e65d721663179d", "project": "tensorflow", "func": "TfLiteStatus GatherStrings(TfLiteContext* context, const TfLiteTensor* input,\n                           const TfLiteTensor* positions,\n                           TfLiteTensor* output) {\n  DynamicBuffer buffer;\n\n  const PositionT* indexes = GetTensorData<PositionT>(positions);\n  bool indices_has_only_positive_elements = true;\n  const size_t num_indices = positions->bytes / sizeof(PositionT);\n  for (size_t i = 0; i < num_indices; i++) {\n    if (indexes[i] < 0) {\n      indices_has_only_positive_elements = false;\n      break;\n    }\n  }\n  TF_LITE_ENSURE(context, indices_has_only_positive_elements);\n\n  const PositionT num_strings = GetStringCount(input);\n  const int num_indexes = NumElements(positions);\n\n  for (int i = 0; i < num_indexes; ++i) {\n    const PositionT pos = indexes[i];\n    TF_LITE_ENSURE(context, pos < num_strings);\n    const auto string_ref = GetString(input, pos);\n    buffer.AddString(string_ref.str, string_ref.len);\n  }\n  buffer.WriteToTensor(output, /*new_shape=*/nullptr);\n  return kTfLiteOk;\n}", "target": 1, "idx": 10350}
{"commit_id": "e06b95c1d44ab80da255219fc9f1e2fc423edcb6", "project": "xen-project/xen", "func": "int arch_domain_create(struct domain *d,\n                       struct xen_domctl_createdomain *config,\n                       unsigned int flags)\n{\n    bool paging_initialised = false;\n    uint32_t emflags;\n    int rc;\n\n    INIT_PAGE_LIST_HEAD(&d->arch.relmem_list);\n\n    spin_lock_init(&d->arch.e820_lock);\n\n    /* Minimal initialisation for the idle domain. */\n    if ( unlikely(is_idle_domain(d)) )\n    {\n        static const struct arch_csw idle_csw = {\n            .from = paravirt_ctxt_switch_from,\n            .to   = paravirt_ctxt_switch_to,\n            .tail = idle_loop,\n        };\n\n        d->arch.ctxt_switch = &idle_csw;\n\n        d->arch.cpuid = ZERO_BLOCK_PTR; /* Catch stray misuses. */\n        d->arch.msr = ZERO_BLOCK_PTR;\n\n        return 0;\n    }\n\n    if ( !config )\n    {\n        /* Only IDLE is allowed with no config. */\n        ASSERT_UNREACHABLE();\n        return -EINVAL;\n    }\n\n    if ( d->domain_id && cpu_has_amd_erratum(&boot_cpu_data, AMD_ERRATUM_121) )\n    {\n        if ( !opt_allow_unsafe )\n        {\n            printk(XENLOG_G_ERR \"Xen does not allow DomU creation on this CPU\"\n                   \" for security reasons.\\n\");\n            return -EPERM;\n        }\n        printk(XENLOG_G_WARNING\n               \"Dom%d may compromise security on this CPU.\\n\",\n               d->domain_id);\n    }\n\n    emflags = config->arch.emulation_flags;\n\n    if ( is_hardware_domain(d) && is_pv_domain(d) )\n        emflags |= XEN_X86_EMU_PIT;\n\n    if ( emflags & ~XEN_X86_EMU_ALL )\n    {\n        printk(XENLOG_G_ERR \"d%d: Invalid emulation bitmap: %#x\\n\",\n               d->domain_id, emflags);\n        return -EINVAL;\n    }\n\n    if ( !emulation_flags_ok(d, emflags) )\n    {\n        printk(XENLOG_G_ERR \"d%d: Xen does not allow %s domain creation \"\n               \"with the current selection of emulators: %#x\\n\",\n               d->domain_id, is_hvm_domain(d) ? \"HVM\" : \"PV\", emflags);\n        return -EOPNOTSUPP;\n    }\n    d->arch.emulation_flags = emflags;\n\n#ifdef CONFIG_PV32\n    HYPERVISOR_COMPAT_VIRT_START(d) =\n        is_pv_domain(d) ? __HYPERVISOR_COMPAT_VIRT_START : ~0u;\n#endif\n\n    if ( (rc = paging_domain_init(d)) != 0 )\n        goto fail;\n    paging_initialised = true;\n\n    if ( (rc = init_domain_cpuid_policy(d)) )\n        goto fail;\n\n    if ( (rc = init_domain_msr_policy(d)) )\n        goto fail;\n\n    d->arch.ioport_caps =\n        rangeset_new(d, \"I/O Ports\", RANGESETF_prettyprint_hex);\n    rc = -ENOMEM;\n    if ( d->arch.ioport_caps == NULL )\n        goto fail;\n\n    /*\n     * The shared_info machine address must fit in a 32-bit field within a\n     * 32-bit guest's start_info structure. Hence we specify MEMF_bits(32).\n     */\n    if ( (d->shared_info = alloc_xenheap_pages(0, MEMF_bits(32))) == NULL )\n        goto fail;\n\n    clear_page(d->shared_info);\n    share_xen_page_with_guest(virt_to_page(d->shared_info), d, SHARE_rw);\n\n    if ( (rc = init_domain_irq_mapping(d)) != 0 )\n        goto fail;\n\n    if ( (rc = iommu_domain_init(d, config->iommu_opts)) != 0 )\n        goto fail;\n\n    psr_domain_init(d);\n\n    if ( is_hvm_domain(d) )\n    {\n        if ( (rc = hvm_domain_initialise(d)) != 0 )\n            goto fail;\n    }\n    else if ( is_pv_domain(d) )\n    {\n        mapcache_domain_init(d);\n\n        if ( (rc = pv_domain_initialise(d)) != 0 )\n            goto fail;\n    }\n    else\n        ASSERT_UNREACHABLE(); /* Not HVM and not PV? */\n\n    if ( (rc = tsc_set_info(d, TSC_MODE_DEFAULT, 0, 0, 0)) != 0 )\n    {\n        ASSERT_UNREACHABLE();\n        goto fail;\n    }\n\n    /* PV/PVH guests get an emulated PIT too for video BIOSes to use. */\n    pit_init(d, cpu_khz);\n\n    /*\n     * If the FPU does not save FCS/FDS then we can always\n     * save/restore the 64-bit FIP/FDP and ignore the selectors.\n     */\n    d->arch.x87_fip_width = cpu_has_fpu_sel ? 0 : 8;\n\n    domain_cpu_policy_changed(d);\n\n    d->arch.msr_relaxed = config->arch.misc_flags & XEN_X86_MSR_RELAXED;\n\n    spec_ctrl_init_domain(d);\n\n    return 0;\n\n fail:\n    d->is_dying = DOMDYING_dead;\n    psr_domain_free(d);\n    iommu_domain_destroy(d);\n    cleanup_domain_irq_mapping(d);\n    free_xenheap_page(d->shared_info);\n    xfree(d->arch.cpuid);\n    xfree(d->arch.msr);\n    if ( paging_initialised )\n        paging_final_teardown(d);\n    free_perdomain_mappings(d);\n\n    return rc;\n}", "target": 2, "idx": 10351}
{"commit_id": "b25e84b7399bd91605596b67d761d3464dbe8a6e", "project": "ffmpeg", "func": "static int decode_nal_unit(HEVCContext *s, const uint8_t *nal, int length)\n{\n    HEVCLocalContext *lc = &s->HEVClc;\n    GetBitContext *gb    = &lc->gb;\n    int ctb_addr_ts, ret;\n\n    ret = init_get_bits8(gb, nal, length);\n    if (ret < 0)\n        return ret;\n\n    ret = hls_nal_unit(s);\n    if (ret < 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Invalid NAL unit %d, skipping.\\n\",\n               s->nal_unit_type);\n        if (s->avctx->err_recognition & AV_EF_EXPLODE)\n            return ret;\n        return 0;\n    } else if (!ret)\n        return 0;\n\n    switch (s->nal_unit_type) {\n    case NAL_VPS:\n        ret = ff_hevc_decode_nal_vps(s);\n        if (ret < 0)\n            return ret;\n        break;\n    case NAL_SPS:\n        ret = ff_hevc_decode_nal_sps(s);\n        if (ret < 0)\n            return ret;\n        break;\n    case NAL_PPS:\n        ret = ff_hevc_decode_nal_pps(s);\n        if (ret < 0)\n            return ret;\n        break;\n    case NAL_SEI_PREFIX:\n    case NAL_SEI_SUFFIX:\n        ret = ff_hevc_decode_nal_sei(s);\n        if (ret < 0)\n            return ret;\n        break;\n    case NAL_TRAIL_R:\n    case NAL_TRAIL_N:\n    case NAL_TSA_N:\n    case NAL_TSA_R:\n    case NAL_STSA_N:\n    case NAL_STSA_R:\n    case NAL_BLA_W_LP:\n    case NAL_BLA_W_RADL:\n    case NAL_BLA_N_LP:\n    case NAL_IDR_W_RADL:\n    case NAL_IDR_N_LP:\n    case NAL_CRA_NUT:\n    case NAL_RADL_N:\n    case NAL_RADL_R:\n    case NAL_RASL_N:\n    case NAL_RASL_R:\n        ret = hls_slice_header(s);\n        if (ret < 0)\n            return ret;\n\n        if (s->max_ra == INT_MAX) {\n            if (s->nal_unit_type == NAL_CRA_NUT || IS_BLA(s)) {\n                s->max_ra = s->poc;\n            } else {\n                if (IS_IDR(s))\n                    s->max_ra = INT_MIN;\n            }\n        }\n\n        if ((s->nal_unit_type == NAL_RASL_R || s->nal_unit_type == NAL_RASL_N) &&\n            s->poc <= s->max_ra) {\n            s->is_decoded = 0;\n            break;\n        } else {\n            if (s->nal_unit_type == NAL_RASL_R && s->poc > s->max_ra)\n                s->max_ra = INT_MIN;\n        }\n\n        if (s->sh.first_slice_in_pic_flag) {\n            ret = hevc_frame_start(s);\n            if (ret < 0)\n                return ret;\n        } else if (!s->ref) {\n            av_log(s->avctx, AV_LOG_ERROR, \"First slice in a frame missing.\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (s->nal_unit_type != s->first_nal_type) {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"Non-matching NAL types of the VCL NALUs: %d %d\\n\",\n                   s->first_nal_type, s->nal_unit_type);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (!s->sh.dependent_slice_segment_flag &&\n            s->sh.slice_type != I_SLICE) {\n            ret = ff_hevc_slice_rpl(s);\n            if (ret < 0) {\n                av_log(s->avctx, AV_LOG_WARNING,\n                       \"Error constructing the reference lists for the current slice.\\n\");\n                if (s->avctx->err_recognition & AV_EF_EXPLODE)\n                    return ret;\n            }\n        }\n\n        ctb_addr_ts = hls_slice_data(s);\n        if (ctb_addr_ts >= (s->sps->ctb_width * s->sps->ctb_height)) {\n            s->is_decoded = 1;\n            if ((s->pps->transquant_bypass_enable_flag ||\n                 (s->sps->pcm.loop_filter_disable_flag && s->sps->pcm_enabled_flag)) &&\n                s->sps->sao_enabled)\n                restore_tqb_pixels(s);\n        }\n\n        if (ctb_addr_ts < 0)\n            return ctb_addr_ts;\n        break;\n    case NAL_EOS_NUT:\n    case NAL_EOB_NUT:\n        s->seq_decode = (s->seq_decode + 1) & 0xff;\n        s->max_ra     = INT_MAX;\n        break;\n    case NAL_AUD:\n    case NAL_FD_NUT:\n        break;\n    default:\n        av_log(s->avctx, AV_LOG_INFO,\n               \"Skipping NAL unit %d\\n\", s->nal_unit_type);\n    }\n\n    return 0;\n}", "target": 1, "idx": 10352}
{"commit_id": "f301cff2c1ddd880d9a2c77b22602a137519867b", "project": "android", "func": "IMPEG2D_ERROR_CODES_T impeg2d_dec_seq_hdr(dec_state_t *ps_dec)\n{\n    stream_t *ps_stream;\n    ps_stream = &ps_dec->s_bit_stream;\n    UWORD16 u2_height;\n    UWORD16 u2_width;\n\n    if (impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != SEQUENCE_HEADER_CODE)\n    {\n        impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n        return IMPEG2D_FRM_HDR_START_CODE_NOT_FOUND;\n\n    }\n    impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n\n    u2_width    = impeg2d_bit_stream_get(ps_stream,12);\n    u2_height   = impeg2d_bit_stream_get(ps_stream,12);\n\n    if ((u2_width != ps_dec->u2_horizontal_size)\n                    || (u2_height != ps_dec->u2_vertical_size))\n    {\n        if (0 == ps_dec->u2_header_done)\n        {\n            /* This is the first time we are reading the resolution */\n            ps_dec->u2_horizontal_size = u2_width;\n            ps_dec->u2_vertical_size = u2_height;\n            if (0 == ps_dec->u4_frm_buf_stride)\n            {\n                ps_dec->u4_frm_buf_stride  = (UWORD32) ALIGN16(u2_width);\n            }\n        }\n        else\n        {\n            if((u2_width > ps_dec->u2_create_max_width)\n                            || (u2_height > ps_dec->u2_create_max_height))\n            {\n                IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS;\n\n                ps_dec->u2_reinit_max_height   = u2_height;\n                ps_dec->u2_reinit_max_width    = u2_width;\n\n                return e_error;\n            }\n            else\n            {\n                /* The resolution has changed */\n                return (IMPEG2D_ERROR_CODES_T)IVD_RES_CHANGED;\n            }\n        }\n    }\n\n    if((ps_dec->u2_horizontal_size > ps_dec->u2_create_max_width)\n                    || (ps_dec->u2_vertical_size > ps_dec->u2_create_max_height))\n    {\n        IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS;\n        return SET_IVD_FATAL_ERROR(e_error);\n    }\n\n\n    /*------------------------------------------------------------------------*/\n    /* Flush the following as they are not being used                         */\n    /* aspect_ratio_info (4 bits)                                             */\n    /*------------------------------------------------------------------------*/\n    ps_dec->u2_aspect_ratio_info = impeg2d_bit_stream_get(ps_stream,4);\n\n    /*------------------------------------------------------------------------*/\n    /* Frame rate code(4 bits)                                                */\n    /*------------------------------------------------------------------------*/\n    ps_dec->u2_frame_rate_code = impeg2d_bit_stream_get(ps_stream,4);\n    if (ps_dec->u2_frame_rate_code > MPEG2_MAX_FRAME_RATE_CODE)\n    {\n        return IMPEG2D_FRM_HDR_DECODE_ERR;\n    }\n    /*------------------------------------------------------------------------*/\n    /* Flush the following as they are not being used                         */\n    /* bit_rate_value (18 bits)                                               */\n    /*------------------------------------------------------------------------*/\n    impeg2d_bit_stream_flush(ps_stream,18);\n    GET_MARKER_BIT(ps_dec,ps_stream);\n    /*------------------------------------------------------------------------*/\n    /* Flush the following as they are not being used                         */\n    /* vbv_buffer_size_value(10 bits), constrained_parameter_flag (1 bit)     */\n    /*------------------------------------------------------------------------*/\n    impeg2d_bit_stream_flush(ps_stream,11);\n\n    /*------------------------------------------------------------------------*/\n    /* Quantization matrix for the intra blocks                               */\n    /*------------------------------------------------------------------------*/\n    if(impeg2d_bit_stream_get_bit(ps_stream) == 1)\n    {\n        UWORD16 i;\n        for(i = 0; i < NUM_PELS_IN_BLOCK; i++)\n        {\n            ps_dec->au1_intra_quant_matrix[gau1_impeg2_inv_scan_zig_zag[i]] =  (UWORD8)impeg2d_bit_stream_get(ps_stream,8);\n        }\n\n    }\n    else\n    {\n        memcpy(ps_dec->au1_intra_quant_matrix,gau1_impeg2_intra_quant_matrix_default,\n                NUM_PELS_IN_BLOCK);\n    }\n\n    /*------------------------------------------------------------------------*/\n    /* Quantization matrix for the inter blocks                               */\n    /*------------------------------------------------------------------------*/\n    if(impeg2d_bit_stream_get_bit(ps_stream) == 1)\n    {\n        UWORD16 i;\n        for(i = 0; i < NUM_PELS_IN_BLOCK; i++)\n        {\n            ps_dec->au1_inter_quant_matrix[gau1_impeg2_inv_scan_zig_zag[i]] =   (UWORD8)impeg2d_bit_stream_get(ps_stream,8);\n        }\n    }\n    else\n    {\n        memcpy(ps_dec->au1_inter_quant_matrix,gau1_impeg2_inter_quant_matrix_default,\n            NUM_PELS_IN_BLOCK);\n    }\n    impeg2d_next_start_code(ps_dec);\n\n    return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;\n}", "target": 1, "idx": 10353}
{"commit_id": "d8cb11f12c2e196d1d81c4036e60b6f5d74af0a4", "project": "livecode", "func": "void MCFilesEvalShell(MCExecContext& ctxt, MCStringRef p_command, MCStringRef& r_output)\n{\n\tif (MCsecuremode & MC_SECUREMODE_PROCESS)\n\t{\n\t\tMCeerror->add(EE_SHELL_NOPERM, 0, 0, p_command);\n\t\tctxt . Throw();\n\t\treturn;\n\t}\n\n\tif (MCStringIsEmpty(MCshellcmd))\n\t{\n\t\tMCeerror->add(EE_SHELL_BADCOMMAND, 0, 0, \"no shell\");\n\t\tctxt . Throw();\n\t\treturn;\n\t}\n\n\tif (MCS_runcmd(p_command, r_output) != IO_NORMAL)\n\t{\n\t\tMCeerror->add(EE_SHELL_BADCOMMAND, 0, 0, p_command);\n\t\tctxt . Throw();\n\t\treturn;\n\t}\n}", "target": 2, "idx": 10354}
{"commit_id": "cabfb3680f78981d26c078a26e5c748531257ebb", "project": "torvalds/linux", "func": "void build_ntlmssp_negotiate_blob(unsigned char *pbuffer,\n\t\t\t\t\t struct cifs_ses *ses)\n{\n\tNEGOTIATE_MESSAGE *sec_blob = (NEGOTIATE_MESSAGE *)pbuffer;\n\t__u32 flags;\n\n\tmemset(pbuffer, 0, sizeof(NEGOTIATE_MESSAGE));\n\tmemcpy(sec_blob->Signature, NTLMSSP_SIGNATURE, 8);\n\tsec_blob->MessageType = NtLmNegotiate;\n\n\t/* BB is NTLMV2 session security format easier to use here? */\n\tflags = NTLMSSP_NEGOTIATE_56 |\tNTLMSSP_REQUEST_TARGET |\n\t\tNTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |\n\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC |\n\t\tNTLMSSP_NEGOTIATE_SEAL;\n\tif (ses->server->sign)\n\t\tflags |= NTLMSSP_NEGOTIATE_SIGN;\n\tif (!ses->server->session_estab || ses->ntlmssp->sesskey_per_smbsess)\n\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n\n\tsec_blob->NegotiateFlags = cpu_to_le32(flags);\n\n\tsec_blob->WorkstationName.BufferOffset = 0;\n\tsec_blob->WorkstationName.Length = 0;\n\tsec_blob->WorkstationName.MaximumLength = 0;\n\n\t/* Domain name is sent on the Challenge not Negotiate NTLMSSP request */\n\tsec_blob->DomainName.BufferOffset = 0;\n\tsec_blob->DomainName.Length = 0;\n\tsec_blob->DomainName.MaximumLength = 0;\n}", "target": 1, "idx": 10355}
{"commit_id": "6f34307bff645eb2935d82deee0119ec89866118", "project": "gobby", "func": "void Gobby::EditCommands::on_sync_complete()\n{\n\tif (!m_current_view) {\n\t\tg_warning(\"No current view exists.\");\n\t\treturn;\n\t}\n\n\tInfTextSession* session = m_current_view->get_session();\n\n\tInfAdoptedAlgorithm* algorithm = inf_adopted_session_get_algorithm(\n\t\tINF_ADOPTED_SESSION(session));\n\n\tm_can_undo_changed_handler = g_signal_connect(\n\t\tG_OBJECT(algorithm), \"can-undo-changed\",\n\t\tG_CALLBACK(&on_can_undo_changed_static), this);\n\n\tm_can_redo_changed_handler = g_signal_connect(\n\t\tG_OBJECT(algorithm), \"can-redo-changed\",\n\t\tG_CALLBACK(&on_can_redo_changed_static), this);\n\n\tif(m_synchronization_complete_handler != 0)\n\t{\n\t\tg_signal_handler_disconnect(\n\t\t\tG_OBJECT(session),\n\t\t\tm_synchronization_complete_handler);\n\t\tm_synchronization_complete_handler = 0;\n\t}\n}", "target": 2, "idx": 10356}
{"commit_id": "7dac4a1726a9c64a517d595c40e95e2d0d135f6f", "project": "kernel/git/tytso/ext4", "func": "struct buffer_head *\next4_read_block_bitmap_nowait(struct super_block *sb, ext4_group_t block_group)\n{\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct buffer_head *bh;\n\text4_fsblk_t bitmap_blk;\n\tint err;\n\n\tdesc = ext4_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\tbitmap_blk = ext4_block_bitmap(sb, desc);\n\tif ((bitmap_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||\n\t    (bitmap_blk >= ext4_blocks_count(sbi->s_es))) {\n\t\text4_error(sb, \"Invalid block bitmap block %llu in \"\n\t\t\t   \"block_group %u\", bitmap_blk, block_group);\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\t}\n\tbh = sb_getblk(sb, bitmap_blk);\n\tif (unlikely(!bh)) {\n\t\text4_error(sb, \"Cannot get buffer for block bitmap - \"\n\t\t\t   \"block_group = %u, block_bitmap = %llu\",\n\t\t\t   block_group, bitmap_blk);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tif (bitmap_uptodate(bh))\n\t\tgoto verify;\n\n\tlock_buffer(bh);\n\tif (bitmap_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\tgoto verify;\n\t}\n\text4_lock_group(sb, block_group);\n\tif (desc->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {\n\t\terr = ext4_init_block_bitmap(sb, bh, block_group, desc);\n\t\tset_bitmap_uptodate(bh);\n\t\tset_buffer_uptodate(bh);\n\t\tset_buffer_verified(bh);\n\t\text4_unlock_group(sb, block_group);\n\t\tunlock_buffer(bh);\n\t\tif (err) {\n\t\t\text4_error(sb, \"Failed to init block bitmap for group \"\n\t\t\t\t   \"%u: %d\", block_group, err);\n\t\t\tgoto out;\n\t\t}\n\t\tgoto verify;\n\t}\n\text4_unlock_group(sb, block_group);\n\tif (buffer_uptodate(bh)) {\n\t\t/*\n\t\t * if not uninit if bh is uptodate,\n\t\t * bitmap is also uptodate\n\t\t */\n\t\tset_bitmap_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\tgoto verify;\n\t}\n\t/*\n\t * submit the buffer_head for reading\n\t */\n\tset_buffer_new(bh);\n\ttrace_ext4_read_block_bitmap_load(sb, block_group);\n\tbh->b_end_io = ext4_end_bitmap_read;\n\tget_bh(bh);\n\tsubmit_bh(REQ_OP_READ, REQ_META | REQ_PRIO, bh);\n\treturn bh;\nverify:\n\terr = ext4_validate_block_bitmap(sb, desc, block_group, bh);\n\tif (err)\n\t\tgoto out;\n\treturn bh;\nout:\n\tput_bh(bh);\n\treturn ERR_PTR(err);\n}", "target": 1, "idx": 10357}
{"commit_id": "246d8ae0cef27377e5dfe9ee3ad87e864d6b6266", "project": "owntone/owntone-server", "func": "int\nnet_bind(short unsigned *port, int type, const char *log_service_name)\n{\n  struct addrinfo hints = { 0 };\n  struct addrinfo *servinfo;\n  struct addrinfo *ptr;\n  union net_sockaddr naddr = { 0 };\n  socklen_t naddr_len = sizeof(naddr);\n  const char *cfgaddr;\n  char addr[INET6_ADDRSTRLEN];\n  char strport[8];\n  int yes = 1;\n  int no = 0;\n  int fd;\n  int ret;\n\n  cfgaddr = cfg_getstr(cfg_getsec(cfg, \"general\"), \"bind_address\");\n\n  hints.ai_socktype = (type & (SOCK_STREAM | SOCK_DGRAM)); // filter since type can be SOCK_STREAM | SOCK_NONBLOCK\n  hints.ai_family = (cfg_getbool(cfg_getsec(cfg, \"general\"), \"ipv6\")) ? AF_INET6 : AF_INET;\n  hints.ai_flags = cfgaddr ? 0 : AI_PASSIVE;\n\n  snprintf(strport, sizeof(strport), \"%hu\", *port);\n  ret = getaddrinfo(cfgaddr, strport, &hints, &servinfo);\n  if (ret < 0)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Failure creating '%s' service, could not resolve '%s' (port %s): %s\\n\", log_service_name, cfgaddr ? cfgaddr : \"(ANY)\", strport, gai_strerror(ret));\n      return -1;\n    }\n\n  for (ptr = servinfo, fd = -1; ptr != NULL; ptr = ptr->ai_next)\n    {\n      if (fd >= 0)\n\tclose(fd);\n\n      fd = socket(ptr->ai_family, type | SOCK_CLOEXEC, ptr->ai_protocol);\n      if (fd < 0)\n\tcontinue;\n\n      // TODO libevent sets this, we do the same?\n      ret = setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &yes, sizeof(yes));\n      if (ret < 0)\n\tcontinue;\n\n      ret = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));\n      if (ret < 0)\n\tcontinue;\n\n      if (ptr->ai_family == AF_INET6)\n\t{\n\t  // We want to be sure the service is dual stack\n\t  ret = setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &no, sizeof(no));\n\t  if (ret < 0)\n\t    continue;\n\t}\n\n      ret = bind(fd, ptr->ai_addr, ptr->ai_addrlen);\n      if (ret < 0)\n\tcontinue;\n\n      break;\n    }\n\n  freeaddrinfo(servinfo);\n\n  if (!ptr)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Could not create service '%s' with address %s, port %hu: %s\\n\", log_service_name, cfgaddr ? cfgaddr : \"(ANY)\", *port, strerror(errno));\n      goto error;\n    }\n\n  // Get our address (as string) and the port that was assigned (necessary when\n  // caller didn't specify a port)\n  ret = getsockname(fd, &naddr.sa, &naddr_len);\n  if (ret < 0)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Error finding address of service '%s': %s\\n\", log_service_name, strerror(errno));\n      goto error;\n    }\n  else if (naddr_len > sizeof(naddr))\n    {\n      DPRINTF(E_LOG, L_MISC, \"Unexpected address length of service '%s'\\n\", log_service_name);\n      goto error;\n    }\n\n  net_port_get(port, &naddr);\n  net_address_get(addr, sizeof(addr), &naddr);\n\n  DPRINTF(E_DBG, L_MISC, \"Service '%s' bound to %s, port %hu, socket %d\\n\", log_service_name, addr, *port, fd);\n\n  return fd;\n\n error:\n  close(fd);\n  return -1;\n}", "target": 3, "idx": 10358}
{"commit_id": "a37fb6a0e7daf30134dbbf357c9a518a1026aa02", "project": "google/asylo", "func": "int32_t *enc_untrusted_create_wait_queue() {\n  MessageWriter input;\n  MessageReader output;\n  input.Push<uint64_t>(sizeof(int32_t));\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kLocalLifetimeAllocHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_create_wait_queue\",\n                           2);\n  int32_t *queue = reinterpret_cast<int32_t *>(output.next<uintptr_t>());\n  if (!TrustedPrimitives::IsOutsideEnclave(queue, sizeof(int32_t))) {\n    TrustedPrimitives::BestEffortAbort(\n        \"enc_untrusted_create_wait_queue: queue should be in untrusted memory\");\n  }\n  int klinux_errno = output.next<int>();\n  if (queue == nullptr) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n  }\n  enc_untrusted_disable_waiting(queue);\n  return queue;\n}", "target": 0, "idx": 10359}
{"commit_id": "2217022b7d1142738656d891e00b3d2d9179b796", "project": "nih-at/libzip", "func": "zip_int64_t\n_zip_dirent_read(zip_dirent_t *zde, zip_source_t *src, zip_buffer_t *buffer, bool local, zip_error_t *error)\n{\n    zip_uint8_t buf[CDENTRYSIZE];\n    zip_uint16_t dostime, dosdate;\n    zip_uint32_t size, variable_size;\n    zip_uint16_t filename_len, comment_len, ef_len;\n\n    bool from_buffer = (buffer != NULL);\n\n    size = local ? LENTRYSIZE : CDENTRYSIZE;\n\n    if (buffer) {\n        if (_zip_buffer_left(buffer) < size) {\n            zip_error_set(error, ZIP_ER_NOZIP, 0);\n            return -1;\n        }\n    }\n    else {\n        if ((buffer = _zip_buffer_new_from_source(src, size, buf, error)) == NULL) {\n            return -1;\n        }\n    }\n\n    if (memcmp(_zip_buffer_get(buffer, 4), (local ? LOCAL_MAGIC : CENTRAL_MAGIC), 4) != 0) {\n\tzip_error_set(error, ZIP_ER_NOZIP, 0);\n        if (!from_buffer) {\n            _zip_buffer_free(buffer);\n        }\n\treturn -1;\n    }\n\n    /* convert buffercontents to zip_dirent */\n\n    _zip_dirent_init(zde);\n    if (!local)\n\tzde->version_madeby = _zip_buffer_get_16(buffer);\n    else\n\tzde->version_madeby = 0;\n    zde->version_needed = _zip_buffer_get_16(buffer);\n    zde->bitflags = _zip_buffer_get_16(buffer);\n    zde->comp_method = _zip_buffer_get_16(buffer);\n\n    /* convert to time_t */\n    dostime = _zip_buffer_get_16(buffer);\n    dosdate = _zip_buffer_get_16(buffer);\n    zde->last_mod = _zip_d2u_time(dostime, dosdate);\n\n    zde->crc = _zip_buffer_get_32(buffer);\n    zde->comp_size = _zip_buffer_get_32(buffer);\n    zde->uncomp_size = _zip_buffer_get_32(buffer);\n\n    filename_len = _zip_buffer_get_16(buffer);\n    ef_len = _zip_buffer_get_16(buffer);\n\n    if (local) {\n\tcomment_len = 0;\n\tzde->disk_number = 0;\n\tzde->int_attrib = 0;\n\tzde->ext_attrib = 0;\n\tzde->offset = 0;\n    } else {\n\tcomment_len = _zip_buffer_get_16(buffer);\n\tzde->disk_number = _zip_buffer_get_16(buffer);\n\tzde->int_attrib = _zip_buffer_get_16(buffer);\n\tzde->ext_attrib = _zip_buffer_get_32(buffer);\n\tzde->offset = _zip_buffer_get_32(buffer);\n    }\n\n    if (!_zip_buffer_ok(buffer)) {\n        zip_error_set(error, ZIP_ER_INTERNAL, 0);\n        if (!from_buffer) {\n            _zip_buffer_free(buffer);\n        }\n        return -1;\n    }\n\n    if (zde->bitflags & ZIP_GPBF_ENCRYPTED) {\n\tif (zde->bitflags & ZIP_GPBF_STRONG_ENCRYPTION) {\n\t    /* TODO */\n\t    zde->encryption_method = ZIP_EM_UNKNOWN;\n\t}\n\telse {\n\t    zde->encryption_method = ZIP_EM_TRAD_PKWARE;\n\t}\n    }\n    else {\n\tzde->encryption_method = ZIP_EM_NONE;\n    }\n\n    zde->filename = NULL;\n    zde->extra_fields = NULL;\n    zde->comment = NULL;\n\n    variable_size = (zip_uint32_t)filename_len+(zip_uint32_t)ef_len+(zip_uint32_t)comment_len;\n\n    if (from_buffer) {\n        if (_zip_buffer_left(buffer) < variable_size) {\n            zip_error_set(error, ZIP_ER_INCONS, 0);\n            return -1;\n        }\n    }\n    else {\n        _zip_buffer_free(buffer);\n\n        if ((buffer = _zip_buffer_new_from_source(src, variable_size, NULL, error)) == NULL) {\n            return -1;\n        }\n    }\n\n    if (filename_len) {\n\tzde->filename = _zip_read_string(buffer, src, filename_len, 1, error);\n        if (!zde->filename) {\n            if (zip_error_code_zip(error) == ZIP_ER_EOF) {\n                zip_error_set(error, ZIP_ER_INCONS, 0);\n            }\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n        }\n\n\tif (zde->bitflags & ZIP_GPBF_ENCODING_UTF_8) {\n\t    if (_zip_guess_encoding(zde->filename, ZIP_ENCODING_UTF8_KNOWN) == ZIP_ENCODING_ERROR) {\n\t\tzip_error_set(error, ZIP_ER_INCONS, 0);\n                if (!from_buffer) {\n                    _zip_buffer_free(buffer);\n                }\n\t\treturn -1;\n\t    }\n\t}\n    }\n\n    if (ef_len) {\n\tzip_uint8_t *ef = _zip_read_data(buffer, src, ef_len, 0, error);\n\n        if (ef == NULL) {\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n        }\n        if (!_zip_ef_parse(ef, ef_len, local ? ZIP_EF_LOCAL : ZIP_EF_CENTRAL, &zde->extra_fields, error)) {\n\t    free(ef);\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n\t}\n\tfree(ef);\n\tif (local)\n\t    zde->local_extra_fields_read = 1;\n    }\n\n    if (comment_len) {\n\tzde->comment = _zip_read_string(buffer, src, comment_len, 0, error);\n        if (!zde->comment) {\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n        }\n\tif (zde->bitflags & ZIP_GPBF_ENCODING_UTF_8) {\n\t    if (_zip_guess_encoding(zde->comment, ZIP_ENCODING_UTF8_KNOWN) == ZIP_ENCODING_ERROR) {\n\t\tzip_error_set(error, ZIP_ER_INCONS, 0);\n                if (!from_buffer) {\n                    _zip_buffer_free(buffer);\n                }\n\t\treturn -1;\n\t    }\n\t}\n    }\n\n    zde->filename = _zip_dirent_process_ef_utf_8(zde, ZIP_EF_UTF_8_NAME, zde->filename);\n    zde->comment = _zip_dirent_process_ef_utf_8(zde, ZIP_EF_UTF_8_COMMENT, zde->comment);\n\n    /* Zip64 */\n\n    if (zde->uncomp_size == ZIP_UINT32_MAX || zde->comp_size == ZIP_UINT32_MAX || zde->offset == ZIP_UINT32_MAX) {\n\tzip_uint16_t got_len;\n        zip_buffer_t *ef_buffer;\n\tconst zip_uint8_t *ef = _zip_ef_get_by_id(zde->extra_fields, &got_len, ZIP_EF_ZIP64, 0, local ? ZIP_EF_LOCAL : ZIP_EF_CENTRAL, error);\n\t/* TODO: if got_len == 0 && !ZIP64_EOCD: no error, 0xffffffff is valid value */\n        if (ef == NULL) {\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n        }\n\n        if ((ef_buffer = _zip_buffer_new((zip_uint8_t *)ef, got_len)) == NULL) {\n            zip_error_set(error, ZIP_ER_MEMORY, 0);\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n            return -1;\n        }\n\n\tif (zde->uncomp_size == ZIP_UINT32_MAX)\n\t    zde->uncomp_size = _zip_buffer_get_64(ef_buffer);\n\telse if (local) {\n\t    /* From appnote.txt: This entry in the Local header MUST\n\t       include BOTH original and compressed file size fields. */\n            (void)_zip_buffer_skip(ef_buffer, 8); /* error is caught by _zip_buffer_eof() call */\n\t}\n\tif (zde->comp_size == ZIP_UINT32_MAX)\n\t    zde->comp_size = _zip_buffer_get_64(ef_buffer);\n\tif (!local) {\n\t    if (zde->offset == ZIP_UINT32_MAX)\n\t\tzde->offset = _zip_buffer_get_64(ef_buffer);\n\t    if (zde->disk_number == ZIP_UINT16_MAX)\n\t\tzde->disk_number = _zip_buffer_get_32(buffer);\n\t}\n\n        if (!_zip_buffer_eof(ef_buffer)) {\n            zip_error_set(error, ZIP_ER_INCONS, 0);\n            _zip_buffer_free(ef_buffer);\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n            return -1;\n        }\n        _zip_buffer_free(ef_buffer);\n    }\n\n    if (!_zip_buffer_ok(buffer)) {\n        zip_error_set(error, ZIP_ER_INTERNAL, 0);\n        if (!from_buffer) {\n            _zip_buffer_free(buffer);\n        }\n        return -1;\n    }\n    if (!from_buffer) {\n        _zip_buffer_free(buffer);\n    }\n\n    /* zip_source_seek / zip_source_tell don't support values > ZIP_INT64_MAX */\n    if (zde->offset > ZIP_INT64_MAX) {\n\tzip_error_set(error, ZIP_ER_SEEK, EFBIG);\n\treturn -1;\n    }\n\n    if (!_zip_dirent_process_winzip_aes(zde, error)) {\n\treturn -1;\n    }\n\n    zde->extra_fields = _zip_ef_remove_internal(zde->extra_fields);\n\n    return (zip_int64_t)(size + variable_size);\n}", "target": 3, "idx": 10360}
{"commit_id": "3c7fd0cdc93c1a1be1ccdc394b5bd8d8aef7a303", "project": "RIOT-OS/RIOT", "func": "int base64url_encode(const void *data_in, size_t data_in_size,\n                     void *base64_out, size_t *base64_out_size)\n{\n    return base64_encode_base(data_in, data_in_size, base64_out, base64_out_size, true);\n}", "target": 3, "idx": 10361}
{"commit_id": "6890a04072e664c25447a297fe663b45ecfd6398", "project": "xen-project/xen", "func": "static inline void _write_unlock(rwlock_t *lock)\n{\n    ASSERT(_is_write_locked_by_me(atomic_read(&lock->cnts)));\n    arch_lock_release_barrier();\n    atomic_and(~(_QW_CPUMASK | _QW_WMASK), &lock->cnts);\n    preempt_enable();\n}", "target": 2, "idx": 10362}
{"commit_id": "f44d04e696feaf13d192d942c4f14ad2e117065a", "project": "torvalds/linux", "func": "static ssize_t rbd_config_info_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct rbd_device *rbd_dev = dev_to_rbd_dev(dev);\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\treturn sprintf(buf, \"%s\\n\", rbd_dev->config_info);\n}", "target": 1, "idx": 10363}
{"commit_id": "9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca", "project": "torvalds/linux", "func": "int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t       struct inode *new_dir, struct dentry *new_dentry,\n\t       struct inode **delegated_inode, unsigned int flags)\n{\n\tint error;\n\tbool is_dir = d_is_dir(old_dentry);\n\tconst unsigned char *old_name;\n\tstruct inode *source = old_dentry->d_inode;\n\tstruct inode *target = new_dentry->d_inode;\n\tbool new_is_dir = false;\n\tunsigned max_links = new_dir->i_sb->s_max_links;\n\n\t/*\n\t * Check source == target.\n\t * On overlayfs need to look at underlying inodes.\n\t */\n\tif (vfs_select_inode(old_dentry, 0) == vfs_select_inode(new_dentry, 0))\n\t\treturn 0;\n\n\terror = may_delete(old_dir, old_dentry, is_dir);\n\tif (error)\n\t\treturn error;\n\n\tif (!target) {\n\t\terror = may_create(new_dir, new_dentry);\n\t} else {\n\t\tnew_is_dir = d_is_dir(new_dentry);\n\n\t\tif (!(flags & RENAME_EXCHANGE))\n\t\t\terror = may_delete(new_dir, new_dentry, is_dir);\n\t\telse\n\t\t\terror = may_delete(new_dir, new_dentry, new_is_dir);\n\t}\n\tif (error)\n\t\treturn error;\n\n\tif (!old_dir->i_op->rename && !old_dir->i_op->rename2)\n\t\treturn -EPERM;\n\n\tif (flags && !old_dir->i_op->rename2)\n\t\treturn -EINVAL;\n\n\t/*\n\t * If we are going to change the parent - check write permissions,\n\t * we'll need to flip '..'.\n\t */\n\tif (new_dir != old_dir) {\n\t\tif (is_dir) {\n\t\t\terror = inode_permission(source, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\tif ((flags & RENAME_EXCHANGE) && new_is_dir) {\n\t\t\terror = inode_permission(target, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\terror = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry,\n\t\t\t\t      flags);\n\tif (error)\n\t\treturn error;\n\n\told_name = fsnotify_oldname_init(old_dentry->d_name.name);\n\tdget(new_dentry);\n\tif (!is_dir || (flags & RENAME_EXCHANGE))\n\t\tlock_two_nondirectories(source, target);\n\telse if (target)\n\t\tinode_lock(target);\n\n\terror = -EBUSY;\n\tif (is_local_mountpoint(old_dentry) || is_local_mountpoint(new_dentry))\n\t\tgoto out;\n\n\tif (max_links && new_dir != old_dir) {\n\t\terror = -EMLINK;\n\t\tif (is_dir && !new_is_dir && new_dir->i_nlink >= max_links)\n\t\t\tgoto out;\n\t\tif ((flags & RENAME_EXCHANGE) && !is_dir && new_is_dir &&\n\t\t    old_dir->i_nlink >= max_links)\n\t\t\tgoto out;\n\t}\n\tif (is_dir && !(flags & RENAME_EXCHANGE) && target)\n\t\tshrink_dcache_parent(new_dentry);\n\tif (!is_dir) {\n\t\terror = try_break_deleg(source, delegated_inode);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tif (target && !new_is_dir) {\n\t\terror = try_break_deleg(target, delegated_inode);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tif (!old_dir->i_op->rename2) {\n\t\terror = old_dir->i_op->rename(old_dir, old_dentry,\n\t\t\t\t\t      new_dir, new_dentry);\n\t} else {\n\t\tWARN_ON(old_dir->i_op->rename != NULL);\n\t\terror = old_dir->i_op->rename2(old_dir, old_dentry,\n\t\t\t\t\t       new_dir, new_dentry, flags);\n\t}\n\tif (error)\n\t\tgoto out;\n\n\tif (!(flags & RENAME_EXCHANGE) && target) {\n\t\tif (is_dir)\n\t\t\ttarget->i_flags |= S_DEAD;\n\t\tdont_mount(new_dentry);\n\t\tdetach_mounts(new_dentry);\n\t}\n\tif (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE)) {\n\t\tif (!(flags & RENAME_EXCHANGE))\n\t\t\td_move(old_dentry, new_dentry);\n\t\telse\n\t\t\td_exchange(old_dentry, new_dentry);\n\t}\nout:\n\tif (!is_dir || (flags & RENAME_EXCHANGE))\n\t\tunlock_two_nondirectories(source, target);\n\telse if (target)\n\t\tinode_unlock(target);\n\tdput(new_dentry);\n\tif (!error) {\n\t\tfsnotify_move(old_dir, new_dir, old_name, is_dir,\n\t\t\t      !(flags & RENAME_EXCHANGE) ? target : NULL, old_dentry);\n\t\tif (flags & RENAME_EXCHANGE) {\n\t\t\tfsnotify_move(new_dir, old_dir, old_dentry->d_name.name,\n\t\t\t\t      new_is_dir, NULL, new_dentry);\n\t\t}\n\t}\n\tfsnotify_oldname_free(old_name);\n\n\treturn error;\n}", "target": 1, "idx": 10364}
{"commit_id": "bc3aaf4223fdb70d52d470dae65c5a7923ea2a49", "project": "LibRaw", "func": "char *LibRaw_buffer_datastream::gets(char *s, int sz)\n{\n  if(sz<1) return NULL;\n  unsigned char *psrc, *pdest, *str;\n  str = (unsigned char *)s;\n  psrc = buf + streampos;\n  pdest = str;\n  if(streampos >= streamsize) return NULL;\n  while ((size_t(psrc - buf) < streamsize) && ((pdest - str) < (sz-1)))\n  {\n    *pdest = *psrc;\n    if (*psrc == '\\n')\n      break;\n    psrc++;\n    pdest++;\n  }\n  if (size_t(psrc - buf) < streamsize)\n    psrc++;\n  if ((pdest - str) < sz-1)\n    *(++pdest) = 0;\n  else\n    s[sz - 1] = 0; // ensure trailing zero\n\n  streampos = psrc - buf;\n  return s;\n}", "target": 2, "idx": 10365}
{"commit_id": "7340f67b9860ea0531c1450e5aa261c50f67165d", "project": "tar", "func": "void\nextract_archive (void)\n{\n  char typeflag;\n  tar_extractor_t fun;\n  bool skip_dotdot_name;\n\n  fatal_exit_hook = extract_finish;\n\n  set_next_block_after (current_header);\n\n  skip_dotdot_name = (!absolute_names_option\n\t\t      && contains_dot_dot (current_stat_info.orig_file_name));\n  if (skip_dotdot_name)\n    ERROR ((0, 0, _(\"%s: Member name contains '..'\"),\n\t    quotearg_colon (current_stat_info.orig_file_name)));\n\n  if (!current_stat_info.file_name[0]\n      || skip_dotdot_name\n      || (interactive_option\n\t  && !confirm (\"extract\", current_stat_info.file_name)))\n    {\n      skip_member ();\n      return;\n    }\n\n  /* Print the block from current_header and current_stat.  */\n  if (verbose_option)\n    print_header (&current_stat_info, current_header, -1);\n\n  /* Restore stats for all non-ancestor directories, unless\n     it is an incremental archive.\n     (see NOTICE in the comment to delay_set_stat above) */\n  if (!delay_directory_restore_option)\n    {\n      int dir = chdir_current;\n      apply_nonancestor_delayed_set_stat (current_stat_info.file_name, 0);\n      chdir_do (dir);\n    }\n\n  /* Take a safety backup of a previously existing file.  */\n\n  if (backup_option)\n    if (!maybe_backup_file (current_stat_info.file_name, 0))\n      {\n\tint e = errno;\n\tERROR ((0, e, _(\"%s: Was unable to backup this file\"),\n\t\tquotearg_colon (current_stat_info.file_name)));\n\tskip_member ();\n\treturn;\n      }\n\n  /* Extract the archive entry according to its type.  */\n  /* KLUDGE */\n  typeflag = sparse_member_p (&current_stat_info) ?\n                  GNUTYPE_SPARSE : current_header->header.typeflag;\n\n  if (prepare_to_extract (current_stat_info.file_name, typeflag, &fun))\n    {\n      if (fun && (*fun) (current_stat_info.file_name, typeflag)\n\t  && backup_option)\n\tundo_last_backup ();\n    }\n  else\n    skip_member ();\n\n}", "target": 2, "idx": 10366}
{"commit_id": "49305319496965ecf18963a81bf8a5a69df0d97e", "project": "nextcloud/desktop", "func": "int main(int argc, char **argv)\n{\n#ifdef Q_OS_WIN\n    SetDllDirectory(L\"\");\n#endif\n    QCoreApplication app(argc, argv);\n\n#ifdef Q_OS_WIN\n    // Ensure OpenSSL config file is only loaded from app directory\n    QString opensslConf = QCoreApplication::applicationDirPath() + QString(\"/openssl.cnf\");\n    qputenv(\"OPENSSL_CONF\", opensslConf.toLocal8Bit());\n#endif\n\n    CmdOptions options;\n    options.silent = false;\n    options.trustSSL = false;\n    options.useNetrc = false;\n    options.interactive = true;\n    options.ignoreHiddenFiles = false; // Default is to sync hidden files\n    options.restartTimes = 3;\n    options.uplimit = 0;\n    options.downlimit = 0;\n\n    parseOptions(app.arguments(), &options);\n\n    if (options.silent) {\n        qInstallMessageHandler(nullMessageHandler);\n    } else {\n        qSetMessagePattern(\"%{time MM-dd hh:mm:ss:zzz} [ %{type} %{category} ]%{if-debug}\\t[ %{function} ]%{endif}:\\t%{message}\");\n    }\n\n    AccountPtr account = Account::create();\n\n    if (!account) {\n        qFatal(\"Could not initialize account!\");\n        return EXIT_FAILURE;\n    }\n\n    if (options.target_url.contains(\"/webdav\", Qt::CaseInsensitive) || options.target_url.contains(\"/dav\", Qt::CaseInsensitive)) {\n        qWarning(\"Dav or webdav in server URL.\");\n        std::cerr << \"Error! Please specify only the base URL of your host with username and password. Example:\" << std::endl\n                  << \"http(s)://username:password@cloud.example.com\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    QUrl hostUrl = QUrl::fromUserInput((options.target_url.endsWith(QLatin1Char('/')) || options.target_url.endsWith(QLatin1Char('\\\\'))) ? options.target_url.chopped(1) : options.target_url);\n\n    // Order of retrieval attempt (later attempts override earlier ones):\n    // 1. From URL\n    // 2. From options\n    // 3. From netrc (if enabled)\n    // 4. From prompt (if interactive)\n\n    QString user = hostUrl.userName();\n    QString password = hostUrl.password();\n\n    if (!options.user.isEmpty()) {\n        user = options.user;\n    }\n\n    if (!options.password.isEmpty()) {\n        password = options.password;\n    }\n\n    if (options.useNetrc) {\n        NetrcParser parser;\n        if (parser.parse()) {\n            NetrcParser::LoginPair pair = parser.find(hostUrl.host());\n            user = pair.first;\n            password = pair.second;\n        }\n    }\n\n    if (options.interactive) {\n        if (user.isEmpty()) {\n            std::cout << \"Please enter username: \";\n            std::string s;\n            std::getline(std::cin, s);\n            user = QString::fromStdString(s);\n        }\n        if (password.isEmpty()) {\n            password = queryPassword(user);\n        }\n    }\n\n    // Find the folder and the original owncloud url\n\n    hostUrl.setScheme(hostUrl.scheme().replace(\"owncloud\", \"http\"));\n\n    QUrl credentialFreeUrl = hostUrl;\n    credentialFreeUrl.setUserName(QString());\n    credentialFreeUrl.setPassword(QString());\n\n    const QString folder = options.remotePath;\n\n    if (!options.proxy.isNull()) {\n        QString host;\n        int port = 0;\n        bool ok = false;\n\n        QStringList pList = options.proxy.split(':');\n        if (pList.count() == 3) {\n            // http: //192.168.178.23 : 8080\n            //  0            1            2\n            host = pList.at(1);\n            if (host.startsWith(\"//\"))\n                host.remove(0, 2);\n\n            port = pList.at(2).toInt(&ok);\n\n            QNetworkProxyFactory::setUseSystemConfiguration(false);\n            QNetworkProxy::setApplicationProxy(QNetworkProxy(QNetworkProxy::HttpProxy, host, port));\n        } else {\n            qFatal(\"Could not read httpproxy. The proxy should have the format \\\"http://hostname:port\\\".\");\n        }\n    }\n\n    auto *sslErrorHandler = new SimpleSslErrorHandler;\n\n#ifdef TOKEN_AUTH_ONLY\n    auto *cred = new TokenCredentials(user, password, \"\");\n    account->setCredentials(cred);\n#else\n    auto *cred = new HttpCredentialsText(user, password);\n    account->setCredentials(cred);\n    if (options.trustSSL) {\n        cred->setSSLTrusted(true);\n    }\n#endif\n\n    account->setUrl(hostUrl);\n    account->setSslErrorHandler(sslErrorHandler);\n    account->setTrustCertificates(options.trustSSL);\n\n    QEventLoop loop;\n    auto *job = new JsonApiJob(account, QLatin1String(\"ocs/v1.php/cloud/capabilities\"));\n    QObject::connect(job, &JsonApiJob::jsonReceived, [&](const QJsonDocument &json) {\n        auto caps = json.object().value(\"ocs\").toObject().value(\"data\").toObject().value(\"capabilities\").toObject();\n        qDebug() << \"Server capabilities\" << caps;\n        account->setCapabilities(caps.toVariantMap());\n        account->setServerVersion(caps[\"core\"].toObject()[\"status\"].toObject()[\"version\"].toString());\n        loop.quit();\n    });\n    job->start();\n    loop.exec();\n\n    if (job->reply()->error() != QNetworkReply::NoError){\n        std::cout<<\"Error connecting to server\\n\";\n        return EXIT_FAILURE;\n    }\n\n    job = new JsonApiJob(account, QLatin1String(\"ocs/v1.php/cloud/user\"));\n    QObject::connect(job, &JsonApiJob::jsonReceived, [&](const QJsonDocument &json) {\n        const QJsonObject data = json.object().value(\"ocs\").toObject().value(\"data\").toObject();\n        account->setDavUser(data.value(\"id\").toString());\n        account->setDavDisplayName(data.value(\"display-name\").toString());\n        loop.quit();\n    });\n    job->start();\n    loop.exec();\n\n    // much lower age than the default since this utility is usually made to be run right after a change in the tests\n    SyncEngine::minimumFileAgeForUpload = std::chrono::milliseconds(0);\n\n    int restartCount = 0;\nrestart_sync:\n\n    opts = &options;\n\n    QStringList selectiveSyncList;\n    if (!options.unsyncedfolders.isEmpty()) {\n        QFile f(options.unsyncedfolders);\n        if (!f.open(QFile::ReadOnly)) {\n            qCritical() << \"Could not open file containing the list of unsynced folders: \" << options.unsyncedfolders;\n        } else {\n            // filter out empty lines and comments\n            selectiveSyncList = QString::fromUtf8(f.readAll()).split('\\n').filter(QRegularExpression(\"\\\\S+\")).filter(QRegularExpression(\"^[^#]\"));\n\n            for (int i = 0; i < selectiveSyncList.count(); ++i) {\n                if (!selectiveSyncList.at(i).endsWith(QLatin1Char('/'))) {\n                    selectiveSyncList[i].append(QLatin1Char('/'));\n                }\n            }\n        }\n    }\n\n    Cmd cmd;\n    QString dbPath = options.source_dir + SyncJournalDb::makeDbName(options.source_dir, credentialFreeUrl, folder, user);\n    SyncJournalDb db(dbPath);\n\n    if (!selectiveSyncList.empty()) {\n        selectiveSyncFixup(&db, selectiveSyncList);\n    }\n\n    SyncOptions opt;\n    opt.fillFromEnvironmentVariables();\n    opt.verifyChunkSizes();\n    SyncEngine engine(account, options.source_dir, opt, folder, &db);\n    engine.setIgnoreHiddenFiles(options.ignoreHiddenFiles);\n    engine.setNetworkLimits(options.uplimit, options.downlimit);\n    QObject::connect(&engine, &SyncEngine::finished,\n        [&app](bool result) { app.exit(result ? EXIT_SUCCESS : EXIT_FAILURE); });\n    QObject::connect(&engine, &SyncEngine::transmissionProgress, &cmd, &Cmd::transmissionProgressSlot);\n    QObject::connect(&engine, &SyncEngine::syncError,\n        [](const QString &error) { qWarning() << \"Sync error:\" << error; });\n\n\n    // Exclude lists\n\n    bool hasUserExcludeFile = !options.exclude.isEmpty();\n    QString systemExcludeFile = ConfigFile::excludeFileFromSystem();\n\n    // Always try to load the user-provided exclude list if one is specified\n    if (hasUserExcludeFile) {\n        engine.excludedFiles().addExcludeFilePath(options.exclude);\n    }\n    // Load the system list if available, or if there's no user-provided list\n    if (!hasUserExcludeFile || QFile::exists(systemExcludeFile)) {\n        engine.excludedFiles().addExcludeFilePath(systemExcludeFile);\n    }\n\n    if (!engine.excludedFiles().reloadExcludeFiles()) {\n        qFatal(\"Cannot load system exclude list or list supplied via --exclude\");\n        return EXIT_FAILURE;\n    }\n\n\n    // Have to be done async, else, an error before exec() does not terminate the event loop.\n    QMetaObject::invokeMethod(&engine, \"startSync\", Qt::QueuedConnection);\n\n    int resultCode = app.exec();\n\n    if (engine.isAnotherSyncNeeded() != NoFollowUpSync) {\n        if (restartCount < options.restartTimes) {\n            restartCount++;\n            qDebug() << \"Restarting Sync, because another sync is needed\" << restartCount;\n            goto restart_sync;\n        }\n        qWarning() << \"Another sync is needed, but not done because restart count is exceeded\" << restartCount;\n    }\n\n    return resultCode;\n}", "target": 0, "idx": 10367}
{"commit_id": "0f2122045b946241a9e549c2a76cea54fa58a7ff", "project": "torvalds/linux", "func": "static void io_req_free_batch(struct req_batch *rb, struct io_kiocb *req)\n{\n\tif (unlikely(io_is_fallback_req(req))) {\n\t\tio_free_req(req);\n\t\treturn;\n\t}\n\tif (req->flags & REQ_F_LINK_HEAD)\n\t\tio_queue_next(req);\n\n\tif (req->task != rb->task) {\n\t\tif (rb->task) {\n\t\t\tatomic_long_add(rb->task_refs, &rb->task->io_uring->req_complete);\n\t\t\tput_task_struct_many(rb->task, rb->task_refs);\n\t\t}\n\t\trb->task = req->task;\n\t\trb->task_refs = 0;\n\t}\n\trb->task_refs++;\n\n\tWARN_ON_ONCE(io_dismantle_req(req));\n\trb->reqs[rb->to_free++] = req;\n\tif (unlikely(rb->to_free == ARRAY_SIZE(rb->reqs)))\n\t\t__io_req_free_batch_flush(req->ctx, rb);\n}", "target": 2, "idx": 10368}
{"commit_id": "401e7e88d4ef80188ffa07095ac00456f901b8c4", "project": "torvalds/linux", "func": "int ipmi_si_mem_setup(struct si_sm_io *io)\n{\n\tunsigned long addr = io->addr_data;\n\tint           mapsize, idx;\n\n\tif (!addr)\n\t\treturn -ENODEV;\n\n\t/*\n\t * Figure out the actual readb/readw/readl/etc routine to use based\n\t * upon the register size.\n\t */\n\tswitch (io->regsize) {\n\tcase 1:\n\t\tio->inputb = intf_mem_inb;\n\t\tio->outputb = intf_mem_outb;\n\t\tbreak;\n\tcase 2:\n\t\tio->inputb = intf_mem_inw;\n\t\tio->outputb = intf_mem_outw;\n\t\tbreak;\n\tcase 4:\n\t\tio->inputb = intf_mem_inl;\n\t\tio->outputb = intf_mem_outl;\n\t\tbreak;\n#ifdef readq\n\tcase 8:\n\t\tio->inputb = mem_inq;\n\t\tio->outputb = mem_outq;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tdev_warn(io->dev, \"Invalid register size: %d\\n\",\n\t\t\t io->regsize);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Some BIOSes reserve disjoint memory regions in their ACPI\n\t * tables.  This causes problems when trying to request the\n\t * entire region.  Therefore we must request each register\n\t * separately.\n\t */\n\tfor (idx = 0; idx < io->io_size; idx++) {\n\t\tif (request_mem_region(addr + idx * io->regspacing,\n\t\t\t\t       io->regsize, DEVICE_NAME) == NULL) {\n\t\t\t/* Undo allocations */\n\t\t\tmem_region_cleanup(io, idx);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\t/*\n\t * Calculate the total amount of memory to claim.  This is an\n\t * unusual looking calculation, but it avoids claiming any\n\t * more memory than it has to.  It will claim everything\n\t * between the first address to the end of the last full\n\t * register.\n\t */\n\tmapsize = ((io->io_size * io->regspacing)\n\t\t   - (io->regspacing - io->regsize));\n\tio->addr = ioremap(addr, mapsize);\n\tif (io->addr == NULL) {\n\t\tmem_region_cleanup(io, io->io_size);\n\t\treturn -EIO;\n\t}\n\n\tio->io_cleanup = mem_cleanup;\n\n\treturn 0;\n}", "target": 2, "idx": 10369}
{"commit_id": "4ef1b2869447411ad3ef91ad7d4891a83c1a509a", "project": "torvalds/linux", "func": "void __sock_recv_timestamp(struct msghdr *msg, struct sock *sk,\n\tstruct sk_buff *skb)\n{\n\tint need_software_tstamp = sock_flag(sk, SOCK_RCVTSTAMP);\n\tstruct scm_timestamping tss;\n\tint empty = 1;\n\tstruct skb_shared_hwtstamps *shhwtstamps =\n\t\tskb_hwtstamps(skb);\n\n\t/* Race occurred between timestamp enabling and packet\n\t   receiving.  Fill in the current time for now. */\n\tif (need_software_tstamp && skb->tstamp == 0)\n\t\t__net_timestamp(skb);\n\n\tif (need_software_tstamp) {\n\t\tif (!sock_flag(sk, SOCK_RCVTSTAMPNS)) {\n\t\t\tstruct timeval tv;\n\t\t\tskb_get_timestamp(skb, &tv);\n\t\t\tput_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMP,\n\t\t\t\t sizeof(tv), &tv);\n\t\t} else {\n\t\t\tstruct timespec ts;\n\t\t\tskb_get_timestampns(skb, &ts);\n\t\t\tput_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMPNS,\n\t\t\t\t sizeof(ts), &ts);\n\t\t}\n\t}\n\n\tmemset(&tss, 0, sizeof(tss));\n\tif ((sk->sk_tsflags & SOF_TIMESTAMPING_SOFTWARE) &&\n\t    ktime_to_timespec_cond(skb->tstamp, tss.ts + 0))\n\t\tempty = 0;\n\tif (shhwtstamps &&\n\t    (sk->sk_tsflags & SOF_TIMESTAMPING_RAW_HARDWARE) &&\n\t    ktime_to_timespec_cond(shhwtstamps->hwtstamp, tss.ts + 2))\n\t\tempty = 0;\n\tif (!empty) {\n\t\tput_cmsg(msg, SOL_SOCKET,\n\t\t\t SCM_TIMESTAMPING, sizeof(tss), &tss);\n\n\t\tif (skb_is_err_queue(skb) && skb->len &&\n\t\t    SKB_EXT_ERR(skb)->opt_stats)\n\t\t\tput_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMPING_OPT_STATS,\n\t\t\t\t skb->len, skb->data);\n\t}\n}", "target": 2, "idx": 10370}
{"commit_id": "da2311a6385c3b499da2ed5d9be59ce331fa93e9", "project": "torvalds/linux", "func": "static int kvaser_usb_leaf_flush_queue(struct kvaser_usb_net_priv *priv)\n{\n\tstruct kvaser_cmd *cmd;\n\tint rc;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->id = CMD_FLUSH_QUEUE;\n\tcmd->len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_flush_queue);\n\tcmd->u.flush_queue.channel = priv->channel;\n\tcmd->u.flush_queue.flags = 0x00;\n\n\trc = kvaser_usb_send_cmd(priv->dev, cmd, cmd->len);\n\n\tkfree(cmd);\n\treturn rc;\n}", "target": 1, "idx": 10371}
{"commit_id": "f57bd745b4cbed577ea654fad4701bea4d38b44c", "project": "moonlight-stream/moonlight-common-c", "func": "int LiSendMouseButtonEvent(char action, int button) {\n    PPACKET_HOLDER holder;\n    int err;\n\n    if (!initialized) {\n        return -2;\n    }\n\n    holder = malloc(sizeof(*holder));\n    if (holder == NULL) {\n        return -1;\n    }\n\n    holder->packetLength = sizeof(NV_MOUSE_BUTTON_PACKET);\n    holder->packet.mouseButton.header.packetType = htonl(PACKET_TYPE_MOUSE_BUTTON);\n    holder->packet.mouseButton.action = action;\n    if (AppVersionQuad[0] >= 5) {\n        holder->packet.mouseButton.action++;\n    }\n    holder->packet.mouseButton.button = htonl(button);\n\n    err = LbqOfferQueueItem(&packetQueue, holder, &holder->entry);\n    if (err != LBQ_SUCCESS) {\n        free(holder);\n    }\n\n    return err;\n}", "target": 2, "idx": 10372}
{"commit_id": "a3691602960e0a479565b439645e6b883a11a273", "project": "cesanta/mongoose", "func": "struct mg_str *mg_get_http_header(struct http_message *hm, const char *name) {\n  size_t i, len = strlen(name);\n\n  for (i = 0; i < MG_MAX_HTTP_HEADERS && hm->header_names[i].len > 0; i++) {\n    struct mg_str *h = &hm->header_names[i], *v = &hm->header_values[i];\n    if (h->p != NULL && h->len == len && !mg_ncasecmp(h->p, name, len))\n      return v;\n  }\n\n  return NULL;\n}", "target": 3, "idx": 10373}
{"commit_id": "fb24771faf72a2fd62b3b6287af3c610c3ec9cf1", "project": "kernel/git/klassert/ipsec-next", "func": "void __fscache_invalidate(struct fscache_cookie *cookie,\n\t\t\t  const void *aux_data, loff_t new_size,\n\t\t\t  unsigned int flags)\n{\n\tbool is_caching;\n\n\t_enter(\"c=%x\", cookie->debug_id);\n\n\tfscache_stat(&fscache_n_invalidates);\n\n\tif (WARN(test_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags),\n\t\t \"Trying to invalidate relinquished cookie\\n\"))\n\t\treturn;\n\n\tif ((flags & FSCACHE_INVAL_DIO_WRITE) &&\n\t    test_and_set_bit(FSCACHE_COOKIE_DISABLED, &cookie->flags))\n\t\treturn;\n\n\tspin_lock(&cookie->lock);\n\tset_bit(FSCACHE_COOKIE_NO_DATA_TO_READ, &cookie->flags);\n\tfscache_update_aux(cookie, aux_data, &new_size);\n\tcookie->inval_counter++;\n\ttrace_fscache_invalidate(cookie, new_size);\n\n\tswitch (cookie->state) {\n\tcase FSCACHE_COOKIE_STATE_INVALIDATING: /* is_still_valid will catch it */\n\tdefault:\n\t\tspin_unlock(&cookie->lock);\n\t\t_leave(\" [no %u]\", cookie->state);\n\t\treturn;\n\n\tcase FSCACHE_COOKIE_STATE_LOOKING_UP:\n\t\tif (!test_and_set_bit(FSCACHE_COOKIE_DO_INVALIDATE, &cookie->flags))\n\t\t\t__fscache_begin_cookie_access(cookie, fscache_access_invalidate_cookie);\n\t\tfallthrough;\n\tcase FSCACHE_COOKIE_STATE_CREATING:\n\t\tspin_unlock(&cookie->lock);\n\t\t_leave(\" [look %x]\", cookie->inval_counter);\n\t\treturn;\n\n\tcase FSCACHE_COOKIE_STATE_ACTIVE:\n\t\tis_caching = fscache_begin_cookie_access(\n\t\t\tcookie, fscache_access_invalidate_cookie);\n\t\tif (is_caching)\n\t\t\t__fscache_set_cookie_state(cookie, FSCACHE_COOKIE_STATE_INVALIDATING);\n\t\tspin_unlock(&cookie->lock);\n\t\twake_up_cookie_state(cookie);\n\n\t\tif (is_caching)\n\t\t\tfscache_queue_cookie(cookie, fscache_cookie_get_inval_work);\n\t\t_leave(\" [inv]\");\n\t\treturn;\n\t}\n}", "target": 1, "idx": 10374}
{"commit_id": "d28fbc7197ba0e021a43f873eff90b05dcdcff6a", "project": "binutils-gdb", "func": "static bool\nscan_unit_for_symbols (struct comp_unit *unit)\n{\n  bfd *abfd = unit->abfd;\n  bfd_byte *info_ptr = unit->first_child_die_ptr;\n  bfd_byte *info_ptr_end = unit->end_ptr;\n  int nesting_level = 0;\n  struct nest_funcinfo\n  {\n    struct funcinfo *func;\n  } *nested_funcs;\n  int nested_funcs_size;\n  struct funcinfo *last_func;\n  struct varinfo *last_var;\n  \n  /* Maintain a stack of in-scope functions and inlined functions, which we\n     can use to set the caller_func field.  */\n  nested_funcs_size = 32;\n  nested_funcs = (struct nest_funcinfo *)\n    bfd_malloc (nested_funcs_size * sizeof (*nested_funcs));\n  if (nested_funcs == NULL)\n    return false;\n  nested_funcs[nesting_level].func = 0;\n\n  /* PR 27484: We must scan the DIEs twice.  The first time we look for\n     function and variable tags and accumulate them into their respective\n     tables.  The second time through we process the attributes of the\n     functions/variables and augment the table entries.  */\n  while (nesting_level >= 0)\n    {\n      unsigned int abbrev_number, i;\n      struct abbrev_info *abbrev;\n      struct funcinfo *func;\n      struct varinfo *var;\n      uint64_t current_offset;\n\n      /* PR 17512: file: 9f405d9d.  */\n      if (info_ptr >= info_ptr_end)\n\tgoto fail;\n\n      current_offset = info_ptr - unit->info_ptr_unit;\n      abbrev_number = _bfd_safe_read_leb128 (abfd, &info_ptr,\n\t\t\t\t\t     false, info_ptr_end);\n      if (abbrev_number == 0)\n\t{\n\t  nesting_level--;\n\t  continue;\n\t}\n\n      abbrev = lookup_abbrev (abbrev_number, unit->abbrevs);\n      if (! abbrev)\n\t{\n\t  static unsigned int previous_failed_abbrev = -1U;\n\n\t  /* Avoid multiple reports of the same missing abbrev.  */\n\t  if (abbrev_number != previous_failed_abbrev)\n\t    {\n\t      _bfd_error_handler\n\t\t(_(\"DWARF error: could not find abbrev number %u\"),\n\t\t abbrev_number);\n\t      previous_failed_abbrev = abbrev_number;\n\t    }\n\t  bfd_set_error (bfd_error_bad_value);\n\t  goto fail;\n\t}\n\n      if (abbrev->tag == DW_TAG_subprogram\n\t  || abbrev->tag == DW_TAG_entry_point\n\t  || abbrev->tag == DW_TAG_inlined_subroutine)\n\t{\n\t  size_t amt = sizeof (struct funcinfo);\n\n\t  var = NULL;\n\t  func = (struct funcinfo *) bfd_zalloc (abfd, amt);\n\t  if (func == NULL)\n\t    goto fail;\n\t  func->tag = abbrev->tag;\n\t  func->prev_func = unit->function_table;\n\t  func->unit_offset = current_offset;\n\t  unit->function_table = func;\n\t  unit->number_of_functions++;\n\t  BFD_ASSERT (!unit->cached);\n\n\t  if (func->tag == DW_TAG_inlined_subroutine)\n\t    for (i = nesting_level; i-- != 0; )\n\t      if (nested_funcs[i].func)\n\t\t{\n\t\t  func->caller_func = nested_funcs[i].func;\n\t\t  break;\n\t\t}\n\t  nested_funcs[nesting_level].func = func;\n\t}\n      else\n\t{\n\t  func = NULL;\n\t  if (abbrev->tag == DW_TAG_variable\n\t      || abbrev->tag == DW_TAG_member)\n\t    {\n\t      size_t amt = sizeof (struct varinfo);\n\n\t      var = (struct varinfo *) bfd_zalloc (abfd, amt);\n\t      if (var == NULL)\n\t\tgoto fail;\n\t      var->tag = abbrev->tag;\n\t      var->stack = true;\n\t      var->prev_var = unit->variable_table;\n\t      unit->variable_table = var;\n\t      var->unit_offset = current_offset;\n\t      /* PR 18205: Missing debug information can cause this\n\t\t var to be attached to an already cached unit.  */\n\t    }\n\t  else\n\t    var = NULL;\n\n\t  /* No inline function in scope at this nesting level.  */\n\t  nested_funcs[nesting_level].func = 0;\n\t}\n\n      for (i = 0; i < abbrev->num_attrs; ++i)\n\t{\n\t  struct attribute attr;\n\n\t  info_ptr = read_attribute (&attr, &abbrev->attrs[i],\n\t\t\t\t     unit, info_ptr, info_ptr_end);\n\t  if (info_ptr == NULL)\n\t    goto fail;\n\t}\n\n      if (abbrev->has_children)\n\t{\n\t  nesting_level++;\n\n\t  if (nesting_level >= nested_funcs_size)\n\t    {\n\t      struct nest_funcinfo *tmp;\n\n\t      nested_funcs_size *= 2;\n\t      tmp = (struct nest_funcinfo *)\n\t\tbfd_realloc (nested_funcs,\n\t\t\t     nested_funcs_size * sizeof (*nested_funcs));\n\t      if (tmp == NULL)\n\t\tgoto fail;\n\t      nested_funcs = tmp;\n\t    }\n\t  nested_funcs[nesting_level].func = 0;\n\t}\n    }\n\n  unit->function_table = reverse_funcinfo_list (unit->function_table);\n  unit->variable_table = reverse_varinfo_list (unit->variable_table);\n\n  /* This is the second pass over the abbrevs.  */      \n  info_ptr = unit->first_child_die_ptr;\n  nesting_level = 0;\n  \n  last_func = NULL;\n  last_var = NULL;\n\n  while (nesting_level >= 0)\n    {\n      unsigned int abbrev_number, i;\n      struct abbrev_info *abbrev;\n      struct attribute attr;\n      struct funcinfo *func;\n      struct varinfo *var;\n      bfd_vma low_pc = 0;\n      bfd_vma high_pc = 0;\n      bool high_pc_relative = false;\n      uint64_t current_offset;\n\n      /* PR 17512: file: 9f405d9d.  */\n      if (info_ptr >= info_ptr_end)\n\tgoto fail;\n\n      current_offset = info_ptr - unit->info_ptr_unit;\n      abbrev_number = _bfd_safe_read_leb128 (abfd, &info_ptr,\n\t\t\t\t\t     false, info_ptr_end);\n      if (! abbrev_number)\n\t{\n\t  nesting_level--;\n\t  continue;\n\t}\n\n      abbrev = lookup_abbrev (abbrev_number, unit->abbrevs);\n      /* This should have been handled above.  */\n      BFD_ASSERT (abbrev != NULL);\n\n      func = NULL;\n      var = NULL;\n      if (abbrev->tag == DW_TAG_subprogram\n\t  || abbrev->tag == DW_TAG_entry_point\n\t  || abbrev->tag == DW_TAG_inlined_subroutine)\n\t{\n\t  if (last_func\n\t      && last_func->prev_func\n\t      && last_func->prev_func->unit_offset == current_offset)\n\t    func = last_func->prev_func;\n\t  else\n\t    func = lookup_func_by_offset (current_offset, unit->function_table);\n\n\t  if (func == NULL)\n\t    goto fail;\n\n\t  last_func = func;\n\t}\n      else if (abbrev->tag == DW_TAG_variable\n\t       || abbrev->tag == DW_TAG_member)\n\t{\n\t  if (last_var\n\t      && last_var->prev_var\n\t      && last_var->prev_var->unit_offset == current_offset)\n\t    var = last_var->prev_var;\n\t  else\n\t    var = lookup_var_by_offset (current_offset, unit->variable_table);\n\n\t  if (var == NULL)\n\t    goto fail;\n\n\t  last_var = var;\n\t}\n\n      for (i = 0; i < abbrev->num_attrs; ++i)\n\t{\n\t  info_ptr = read_attribute (&attr, &abbrev->attrs[i],\n\t\t\t\t     unit, info_ptr, info_ptr_end);\n\t  if (info_ptr == NULL)\n\t    goto fail;\n\n\t  if (func)\n\t    {\n\t      switch (attr.name)\n\t\t{\n\t\tcase DW_AT_call_file:\n\t\t  if (is_int_form (&attr))\n\t\t    func->caller_file = concat_filename (unit->line_table,\n\t\t\t\t\t\t\t attr.u.val);\n\t\t  break;\n\n\t\tcase DW_AT_call_line:\n\t\t  if (is_int_form (&attr))\n\t\t    func->caller_line = attr.u.val;\n\t\t  break;\n\n\t\tcase DW_AT_abstract_origin:\n\t\tcase DW_AT_specification:\n\t\t  if (is_int_form (&attr)\n\t\t      && !find_abstract_instance (unit, &attr, 0,\n\t\t\t\t\t\t  &func->name,\n\t\t\t\t\t\t  &func->is_linkage,\n\t\t\t\t\t\t  &func->file,\n\t\t\t\t\t\t  &func->line))\n\t\t    goto fail;\n\t\t  break;\n\n\t\tcase DW_AT_name:\n\t\t  /* Prefer DW_AT_MIPS_linkage_name or DW_AT_linkage_name\n\t\t     over DW_AT_name.  */\n\t\t  if (func->name == NULL && is_str_form (&attr))\n\t\t    {\n\t\t      func->name = attr.u.str;\n\t\t      if (mangle_style (unit->lang) == 0)\n\t\t\tfunc->is_linkage = true;\n\t\t    }\n\t\t  break;\n\n\t\tcase DW_AT_linkage_name:\n\t\tcase DW_AT_MIPS_linkage_name:\n\t\t  /* PR 16949:  Corrupt debug info can place\n\t\t     non-string forms into these attributes.  */\n\t\t  if (is_str_form (&attr))\n\t\t    {\n\t\t      func->name = attr.u.str;\n\t\t      func->is_linkage = true;\n\t\t    }\n\t\t  break;\n\n\t\tcase DW_AT_low_pc:\n\t\t  if (is_int_form (&attr))\n\t\t    low_pc = attr.u.val;\n\t\t  break;\n\n\t\tcase DW_AT_high_pc:\n\t\t  if (is_int_form (&attr))\n\t\t    {\n\t\t      high_pc = attr.u.val;\n\t\t      high_pc_relative = attr.form != DW_FORM_addr;\n\t\t    }\n\t\t  break;\n\n\t\tcase DW_AT_ranges:\n\t\t  if (is_int_form (&attr)\n\t\t      && !read_rangelist (unit, &func->arange,\n\t\t\t\t\t  &unit->file->trie_root, attr.u.val))\n\t\t    goto fail;\n\t\t  break;\n\n\t\tcase DW_AT_decl_file:\n\t\t  if (is_int_form (&attr))\n\t\t    {\n\t\t      free (func->file);\n\t\t      func->file = concat_filename (unit->line_table,\n\t\t\t\t\t\t    attr.u.val);\n\t\t    }\n\t\t  break;\n\n\t\tcase DW_AT_decl_line:\n\t\t  if (is_int_form (&attr))\n\t\t    func->line = attr.u.val;\n\t\t  break;\n\n\t\tdefault:\n\t\t  break;\n\t\t}\n\t    }\n\t  else if (var)\n\t    {\n\t      switch (attr.name)\n\t\t{\n\t\tcase DW_AT_specification:\n\t\t  if (is_int_form (&attr) && attr.u.val)\n\t\t    {\n\t\t      bool is_linkage;\n\t\t      if (!find_abstract_instance (unit, &attr, 0,\n\t\t\t\t\t\t   &var->name,\n\t\t\t\t\t\t   &is_linkage,\n\t\t\t\t\t\t   &var->file,\n\t\t\t\t\t\t   &var->line))\n\t\t\t{\n\t\t\t  _bfd_error_handler (_(\"DWARF error: could not find \"\n\t\t\t\t\t\t\"variable specification \"\n\t\t\t\t\t\t\"at offset 0x%lx\"),\n\t\t\t\t\t      (unsigned long) attr.u.val);\n\t\t\t  break;\n\t\t\t}\n\t\t    }\n\t\t  break;\n\n\t\tcase DW_AT_name:\n\t\t  if (is_str_form (&attr))\n\t\t    var->name = attr.u.str;\n\t\t  break;\n\n\t\tcase DW_AT_decl_file:\n\t\t  if (is_int_form (&attr))\n\t\t    {\n\t\t      free (var->file);\n\t\t      var->file = concat_filename (unit->line_table,\n\t\t\t\t\t\t   attr.u.val);\n\t\t    }\n\t\t  break;\n\n\t\tcase DW_AT_decl_line:\n\t\t  if (is_int_form (&attr))\n\t\t    var->line = attr.u.val;\n\t\t  break;\n\n\t\tcase DW_AT_external:\n\t\t  if (is_int_form (&attr) && attr.u.val != 0)\n\t\t    var->stack = false;\n\t\t  break;\n\n\t\tcase DW_AT_location:\n\t\t  switch (attr.form)\n\t\t    {\n\t\t    case DW_FORM_block:\n\t\t    case DW_FORM_block1:\n\t\t    case DW_FORM_block2:\n\t\t    case DW_FORM_block4:\n\t\t    case DW_FORM_exprloc:\n\t\t      if (attr.u.blk->data != NULL\n\t\t\t  && *attr.u.blk->data == DW_OP_addr)\n\t\t\t{\n\t\t\t  var->stack = false;\n\n\t\t\t  /* Verify that DW_OP_addr is the only opcode in the\n\t\t\t     location, in which case the block size will be 1\n\t\t\t     plus the address size.  */\n\t\t\t  /* ??? For TLS variables, gcc can emit\n\t\t\t     DW_OP_addr <addr> DW_OP_GNU_push_tls_address\n\t\t\t     which we don't handle here yet.  */\n\t\t\t  if (attr.u.blk->size == unit->addr_size + 1U)\n\t\t\t    var->addr = bfd_get (unit->addr_size * 8,\n\t\t\t\t\t\t unit->abfd,\n\t\t\t\t\t\t attr.u.blk->data + 1);\n\t\t\t}\n\t\t      break;\n\n\t\t    default:\n\t\t      break;\n\t\t    }\n\t\t  break;\n\n\t\tdefault:\n\t\t  break;\n\t\t}\n\t    }\n\t}\n\n      if (abbrev->has_children)\n\tnesting_level++;\n\n      if (high_pc_relative)\n\thigh_pc += low_pc;\n\n      if (func && high_pc != 0)\n\t{\n\t  if (!arange_add (unit, &func->arange, &unit->file->trie_root,\n\t\t\t   low_pc, high_pc))\n\t    goto fail;\n\t}\n    }\n\n  unit->function_table = reverse_funcinfo_list (unit->function_table);\n  unit->variable_table = reverse_varinfo_list (unit->variable_table);\n\n  free (nested_funcs);\n  return true;\n\n fail:\n  free (nested_funcs);\n  return false;\n}", "target": 1, "idx": 10375}
{"commit_id": "961e5ac5788b52304e64b9a509781beaf5201fb0", "project": "android", "func": "void  SkippedMBMotionComp(\n    VideoDecData *video\n)\n{\n    Vop *prev = video->prevVop;\n    Vop *comp;\n    int ypos, xpos;\n    PIXEL *c_comp, *c_prev;\n    PIXEL *cu_comp, *cu_prev;\n    PIXEL *cv_comp, *cv_prev;\n    int width, width_uv;\n    int32 offset;\n#ifdef PV_POSTPROC_ON // 2/14/2001      \n    int imv;\n    int32 size = (int32) video->nTotalMB << 8;\n    uint8 *pp_dec_y, *pp_dec_u;\n    uint8 *pp_prev1;\n    int mvwidth = video->nMBPerRow << 1;\n#endif\n\n    width = video->width;\n    width_uv  = width >> 1;\n    ypos = video->mbnum_row << 4 ;\n    xpos = video->mbnum_col << 4 ;\n    offset = (int32)ypos * width + xpos;\n\n\n    /* zero motion compensation for previous frame */\n    /*mby*width + mbx;*/\n    c_prev  = prev->yChan;\n    if (!c_prev) {\n        ALOGE(\"b/35269635\");\n        android_errorWriteLog(0x534e4554, \"35269635\");\n        return;\n    }\n    c_prev += offset;\n\n    /*by*width_uv + bx;*/\n    cu_prev = prev->uChan + (offset >> 2) + (xpos >> 2);\n    /*by*width_uv + bx;*/\n    cv_prev = prev->vChan + (offset >> 2) + (xpos >> 2);\n\n    comp = video->currVop;\n\n    c_comp  = comp->yChan + offset;\n    cu_comp = comp->uChan + (offset >> 2) + (xpos >> 2);\n    cv_comp = comp->vChan + (offset >> 2) + (xpos >> 2);\n\n\n    /* Copy previous reconstructed frame into the current frame */\n    PutSKIPPED_MB(c_comp,  c_prev, width);\n    PutSKIPPED_B(cu_comp, cu_prev, width_uv);\n    PutSKIPPED_B(cv_comp, cv_prev, width_uv);\n\n    /*  10/24/2000 post_processing semaphore generation */\n#ifdef PV_POSTPROC_ON // 2/14/2001\n    if (video->postFilterType != PV_NO_POST_PROC)\n    {\n        imv = (offset >> 6) - (xpos >> 6) + (xpos >> 3);\n        /* Post-processing mode (copy previous MB) */\n        pp_prev1 = video->pstprcTypPrv + imv;\n        pp_dec_y = video->pstprcTypCur + imv;\n        *pp_dec_y = *pp_prev1;\n        *(pp_dec_y + 1) = *(pp_prev1 + 1);\n        *(pp_dec_y + mvwidth) = *(pp_prev1 + mvwidth);\n        *(pp_dec_y + mvwidth + 1) = *(pp_prev1 + mvwidth + 1);\n\n        /* chrominance */\n        /*4*MB_in_width*MB_in_height*/\n        pp_prev1 = video->pstprcTypPrv + (size >> 6) +\n                   ((imv + (xpos >> 3)) >> 2);\n        pp_dec_u = video->pstprcTypCur + (size >> 6) +\n                   ((imv + (xpos >> 3)) >> 2);\n        *pp_dec_u = *pp_prev1;\n        pp_dec_u[size>>8] = pp_prev1[size>>8];\n    }\n#endif\n    /*----------------------------------------------------------------------------\n    ; Return nothing or data or data pointer\n    ----------------------------------------------------------------------------*/\n\n    return;\n}", "target": 1, "idx": 10376}
{"commit_id": "1ae3f2f178087711f9591350abad133525ba93f2", "project": "qemu", "func": "static void ehci_advance_state(EHCIState *ehci, int async)\n{\n    EHCIQueue *q = NULL;\n    int itd_count = 0;\n    int again;\n\n    do {\n        switch(ehci_get_state(ehci, async)) {\n        case EST_WAITLISTHEAD:\n            again = ehci_state_waitlisthead(ehci, async);\n            break;\n\n        case EST_FETCHENTRY:\n            again = ehci_state_fetchentry(ehci, async);\n            break;\n\n        case EST_FETCHQH:\n            q = ehci_state_fetchqh(ehci, async);\n            if (q != NULL) {\n                assert(q->async == async);\n                again = 1;\n            } else {\n                again = 0;\n            }\n            break;\n\n        case EST_FETCHITD:\n            again = ehci_state_fetchitd(ehci, async);\n            itd_count++;\n            break;\n\n        case EST_FETCHSITD:\n            again = ehci_state_fetchsitd(ehci, async);\n            itd_count++;\n            break;\n\n        case EST_ADVANCEQUEUE:\n            assert(q != NULL);\n            again = ehci_state_advqueue(q);\n            break;\n\n        case EST_FETCHQTD:\n            assert(q != NULL);\n            again = ehci_state_fetchqtd(q);\n            break;\n\n        case EST_HORIZONTALQH:\n            assert(q != NULL);\n            again = ehci_state_horizqh(q);\n            break;\n\n        case EST_EXECUTE:\n            assert(q != NULL);\n            again = ehci_state_execute(q);\n            if (async) {\n                ehci->async_stepdown = 0;\n            }\n            break;\n\n        case EST_EXECUTING:\n            assert(q != NULL);\n            if (async) {\n                ehci->async_stepdown = 0;\n            }\n            again = ehci_state_executing(q);\n            break;\n\n        case EST_WRITEBACK:\n            assert(q != NULL);\n            again = ehci_state_writeback(q);\n            if (!async) {\n                ehci->periodic_sched_active = PERIODIC_ACTIVE;\n            }\n            break;\n\n        default:\n            fprintf(stderr, \"Bad state!\\n\");\n            again = -1;\n            g_assert_not_reached();\n            break;\n        }\n\n        if (again < 0 || itd_count > 16) {\n            /* TODO: notify guest (raise HSE irq?) */\n            fprintf(stderr, \"processing error - resetting ehci HC\\n\");\n            ehci_reset(ehci);\n            again = 0;\n        }\n    }\n    while (again);\n}", "target": 1, "idx": 10377}
{"commit_id": "1ebc60b20fbe9a02436d5cbbf8951714e749ddb1", "project": "npat-efault/picocom", "func": "int\ndo_command (unsigned char c)\n{\n\tstatic int dtr_up = 0;\n\tint newbaud, newflow, newparity, newbits;\n\tconst char *xfr_cmd;\n\tchar *fname;\n\tint r;\n\n\tswitch (c) {\n\tcase KEY_EXIT:\n\t\treturn 1;\n\tcase KEY_QUIT:\n\t\tterm_set_hupcl(tty_fd, 0);\n\t\tterm_flush(tty_fd);\n\t\tterm_apply(tty_fd);\n\t\tterm_erase(tty_fd);\n\t\treturn 1;\n\tcase KEY_STATUS:\n\t\tshow_status(dtr_up);\n\t\tbreak;\n\tcase KEY_PULSE:\n\t\tfd_printf(STO, \"\\r\\n*** pulse DTR ***\\r\\n\");\n\t\tif ( term_pulse_dtr(tty_fd) < 0 )\n\t\t\tfd_printf(STO, \"*** FAILED\\r\\n\");\n\t\tbreak;\n\tcase KEY_TOGGLE:\n\t\tif ( dtr_up )\n\t\t\tr = term_lower_dtr(tty_fd);\n\t\telse\n\t\t\tr = term_raise_dtr(tty_fd);\n\t\tif ( r >= 0 ) dtr_up = ! dtr_up;\n\t\tfd_printf(STO, \"\\r\\n*** DTR: %s ***\\r\\n\", \n\t\t\t\t  dtr_up ? \"up\" : \"down\");\n\t\tbreak;\n\tcase KEY_BAUD_UP:\n\tcase KEY_BAUD_DN:\n\t\tif (c == KEY_BAUD_UP)\n\t\t\topts.baud = baud_up(opts.baud);\n\t\telse \n\t\t\topts.baud = baud_down(opts.baud);\n\t\tterm_set_baudrate(tty_fd, opts.baud);\n\t\ttty_q.len = 0; term_flush(tty_fd);\n\t\tterm_apply(tty_fd);\n\t\tnewbaud = term_get_baudrate(tty_fd, NULL);\n\t\tif ( opts.baud != newbaud ) {\n\t\t\tfd_printf(STO, \"\\r\\n*** baud: %d (%d) ***\\r\\n\", \n\t\t\t\t\t  opts.baud, newbaud);\n\t\t} else {\n\t\t\tfd_printf(STO, \"\\r\\n*** baud: %d ***\\r\\n\", opts.baud);\n\t\t}\n\t\tset_tty_write_sz(newbaud);\n\t\tbreak;\n\tcase KEY_FLOW:\n\t\topts.flow = flow_next(opts.flow);\n\t\tterm_set_flowcntrl(tty_fd, opts.flow);\n\t\ttty_q.len = 0; term_flush(tty_fd);\n\t\tterm_apply(tty_fd);\n\t\tnewflow = term_get_flowcntrl(tty_fd);\n\t\tif ( opts.flow != newflow ) {\n\t\t\tfd_printf(STO, \"\\r\\n*** flow: %s (%s) ***\\r\\n\", \n\t\t\t\t\t  flow_str[opts.flow], flow_str[newflow]);\n\t\t} else {\n\t\t\tfd_printf(STO, \"\\r\\n*** flow: %s ***\\r\\n\", \n\t\t\t\t\t  flow_str[opts.flow]);\n\t\t}\n\t\tbreak;\n\tcase KEY_PARITY:\n\t\topts.parity = parity_next(opts.parity);\n\t\tterm_set_parity(tty_fd, opts.parity);\n\t\ttty_q.len = 0; term_flush(tty_fd);\n\t\tterm_apply(tty_fd);\n\t\tnewparity = term_get_parity(tty_fd);\n\t\tif (opts.parity != newparity ) {\n\t\t\tfd_printf(STO, \"\\r\\n*** parity: %s (%s) ***\\r\\n\",\n\t\t\t\t\t  parity_str[opts.parity], \n\t\t\t\t\t  parity_str[newparity]);\n\t\t} else {\n\t\t\tfd_printf(STO, \"\\r\\n*** parity: %s ***\\r\\n\", \n\t\t\t\t\t  parity_str[opts.parity]);\n\t\t}\n\t\tbreak;\n\tcase KEY_BITS:\n\t\topts.databits = bits_next(opts.databits);\n\t\tterm_set_databits(tty_fd, opts.databits);\n\t\ttty_q.len = 0; term_flush(tty_fd);\n\t\tterm_apply(tty_fd);\n\t\tnewbits = term_get_databits(tty_fd);\n\t\tif (opts.databits != newbits ) {\n\t\t\tfd_printf(STO, \"\\r\\n*** databits: %d (%d) ***\\r\\n\",\n\t\t\t\t\t  opts.databits, newbits);\n\t\t} else {\n\t\t\tfd_printf(STO, \"\\r\\n*** databits: %d ***\\r\\n\", \n\t\t\t\t\t  opts.databits);\n\t\t}\n\t\tbreak;\n\tcase KEY_LECHO:\n\t\topts.lecho = ! opts.lecho;\n\t\tfd_printf(STO, \"\\r\\n*** local echo: %s ***\\r\\n\", \n\t\t\t\t  opts.lecho ? \"yes\" : \"no\");\n\t\tbreak;\n\tcase KEY_SEND:\n\tcase KEY_RECEIVE:\n\t\txfr_cmd = (c == KEY_SEND) ? opts.send_cmd : opts.receive_cmd;\n\t\tif ( xfr_cmd[0] == '\\0' ) {\n\t\t\tfd_printf(STO, \"\\r\\n*** command disabled ***\\r\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tfname = read_filename();\n\t\tif (fname == NULL) {\n\t\t\tfd_printf(STO, \"*** cannot read filename ***\\r\\n\");\n\t\t\tbreak;\n\t\t}\n\t\trun_cmd(tty_fd, xfr_cmd, fname);\n\t\tfree(fname);\n\t\tbreak;\n\tcase KEY_BREAK:\n\t\tterm_break(tty_fd);\n\t\tfd_printf(STO, \"\\r\\n*** break sent ***\\r\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}", "target": 3, "idx": 10378}
{"commit_id": "32c231164b762dddefa13af5a0101032c70b50ef", "project": "torvalds/linux", "func": "static int l2tp_ip6_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sockaddr_l2tpip6 *addr = (struct sockaddr_l2tpip6 *) uaddr;\n\tstruct net *net = sock_net(sk);\n\t__be32 v4addr = 0;\n\tint addr_type;\n\tint err;\n\n\tif (addr->l2tp_family != AF_INET6)\n\t\treturn -EINVAL;\n\tif (addr_len < sizeof(*addr))\n\t\treturn -EINVAL;\n\n\taddr_type = ipv6_addr_type(&addr->l2tp_addr);\n\n\t/* l2tp_ip6 sockets are IPv6 only */\n\tif (addr_type == IPV6_ADDR_MAPPED)\n\t\treturn -EADDRNOTAVAIL;\n\n\t/* L2TP is point-point, not multicast */\n\tif (addr_type & IPV6_ADDR_MULTICAST)\n\t\treturn -EADDRNOTAVAIL;\n\n\terr = -EADDRINUSE;\n\tread_lock_bh(&l2tp_ip6_lock);\n\tif (__l2tp_ip6_bind_lookup(net, &addr->l2tp_addr,\n\t\t\t\t   sk->sk_bound_dev_if, addr->l2tp_conn_id))\n\t\tgoto out_in_use;\n\tread_unlock_bh(&l2tp_ip6_lock);\n\n\tlock_sock(sk);\n\n\terr = -EINVAL;\n\tif (!sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out_unlock;\n\n\tif (sk->sk_state != TCP_CLOSE)\n\t\tgoto out_unlock;\n\n\t/* Check if the address belongs to the host. */\n\trcu_read_lock();\n\tif (addr_type != IPV6_ADDR_ANY) {\n\t\tstruct net_device *dev = NULL;\n\n\t\tif (addr_type & IPV6_ADDR_LINKLOCAL) {\n\t\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t\t    addr->l2tp_scope_id) {\n\t\t\t\t/* Override any existing binding, if another\n\t\t\t\t * one is supplied by user.\n\t\t\t\t */\n\t\t\t\tsk->sk_bound_dev_if = addr->l2tp_scope_id;\n\t\t\t}\n\n\t\t\t/* Binding to link-local address requires an\n\t\t\t   interface */\n\t\t\tif (!sk->sk_bound_dev_if)\n\t\t\t\tgoto out_unlock_rcu;\n\n\t\t\terr = -ENODEV;\n\t\t\tdev = dev_get_by_index_rcu(sock_net(sk),\n\t\t\t\t\t\t   sk->sk_bound_dev_if);\n\t\t\tif (!dev)\n\t\t\t\tgoto out_unlock_rcu;\n\t\t}\n\n\t\t/* ipv4 addr of the socket is invalid.  Only the\n\t\t * unspecified and mapped address have a v4 equivalent.\n\t\t */\n\t\tv4addr = LOOPBACK4_IPV6;\n\t\terr = -EADDRNOTAVAIL;\n\t\tif (!ipv6_chk_addr(sock_net(sk), &addr->l2tp_addr, dev, 0))\n\t\t\tgoto out_unlock_rcu;\n\t}\n\trcu_read_unlock();\n\n\tinet->inet_rcv_saddr = inet->inet_saddr = v4addr;\n\tsk->sk_v6_rcv_saddr = addr->l2tp_addr;\n\tnp->saddr = addr->l2tp_addr;\n\n\tl2tp_ip6_sk(sk)->conn_id = addr->l2tp_conn_id;\n\n\twrite_lock_bh(&l2tp_ip6_lock);\n\tsk_add_bind_node(sk, &l2tp_ip6_bind_table);\n\tsk_del_node_init(sk);\n\twrite_unlock_bh(&l2tp_ip6_lock);\n\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\trelease_sock(sk);\n\treturn 0;\n\nout_unlock_rcu:\n\trcu_read_unlock();\nout_unlock:\n\trelease_sock(sk);\n\treturn err;\n\nout_in_use:\n\tread_unlock_bh(&l2tp_ip6_lock);\n\treturn err;\n}", "target": 2, "idx": 10379}
{"commit_id": "2423496af35d94a87156b063ea5cedffc10a70a1", "project": "torvalds/linux", "func": "static struct sk_buff *udp6_ufo_fragment(struct sk_buff *skb,\n\t\t\t\t\t netdev_features_t features)\n{\n\tstruct sk_buff *segs = ERR_PTR(-EINVAL);\n\tunsigned int mss;\n\tunsigned int unfrag_ip6hlen, unfrag_len;\n\tstruct frag_hdr *fptr;\n\tu8 *packet_start, *prevhdr;\n\tu8 nexthdr;\n\tu8 frag_hdr_sz = sizeof(struct frag_hdr);\n\t__wsum csum;\n\tint tnl_hlen;\n\n\tmss = skb_shinfo(skb)->gso_size;\n\tif (unlikely(skb->len <= mss))\n\t\tgoto out;\n\n\tif (skb_gso_ok(skb, features | NETIF_F_GSO_ROBUST)) {\n\t\t/* Packet is from an untrusted source, reset gso_segs. */\n\n\t\tskb_shinfo(skb)->gso_segs = DIV_ROUND_UP(skb->len, mss);\n\n\t\t/* Set the IPv6 fragment id if not set yet */\n\t\tif (!skb_shinfo(skb)->ip6_frag_id)\n\t\t\tipv6_proxy_select_ident(dev_net(skb->dev), skb);\n\n\t\tsegs = NULL;\n\t\tgoto out;\n\t}\n\n\tif (skb->encapsulation && skb_shinfo(skb)->gso_type &\n\t    (SKB_GSO_UDP_TUNNEL|SKB_GSO_UDP_TUNNEL_CSUM))\n\t\tsegs = skb_udp_tunnel_segment(skb, features, true);\n\telse {\n\t\tconst struct ipv6hdr *ipv6h;\n\t\tstruct udphdr *uh;\n\n\t\tif (!pskb_may_pull(skb, sizeof(struct udphdr)))\n\t\t\tgoto out;\n\n\t\t/* Do software UFO. Complete and fill in the UDP checksum as HW cannot\n\t\t * do checksum of UDP packets sent as multiple IP fragments.\n\t\t */\n\n\t\tuh = udp_hdr(skb);\n\t\tipv6h = ipv6_hdr(skb);\n\n\t\tuh->check = 0;\n\t\tcsum = skb_checksum(skb, 0, skb->len, 0);\n\t\tuh->check = udp_v6_check(skb->len, &ipv6h->saddr,\n\t\t\t\t\t  &ipv6h->daddr, csum);\n\t\tif (uh->check == 0)\n\t\t\tuh->check = CSUM_MANGLED_0;\n\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\n\t\t/* If there is no outer header we can fake a checksum offload\n\t\t * due to the fact that we have already done the checksum in\n\t\t * software prior to segmenting the frame.\n\t\t */\n\t\tif (!skb->encap_hdr_csum)\n\t\t\tfeatures |= NETIF_F_HW_CSUM;\n\n\t\t/* Check if there is enough headroom to insert fragment header. */\n\t\ttnl_hlen = skb_tnl_header_len(skb);\n\t\tif (skb->mac_header < (tnl_hlen + frag_hdr_sz)) {\n\t\t\tif (gso_pskb_expand_head(skb, tnl_hlen + frag_hdr_sz))\n\t\t\t\tgoto out;\n\t\t}\n\n\t\t/* Find the unfragmentable header and shift it left by frag_hdr_sz\n\t\t * bytes to insert fragment header.\n\t\t */\n\t\tunfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);\n\t\tif (unfrag_ip6hlen < 0)\n\t\t\treturn ERR_PTR(unfrag_ip6hlen);\n\t\tnexthdr = *prevhdr;\n\t\t*prevhdr = NEXTHDR_FRAGMENT;\n\t\tunfrag_len = (skb_network_header(skb) - skb_mac_header(skb)) +\n\t\t\t     unfrag_ip6hlen + tnl_hlen;\n\t\tpacket_start = (u8 *) skb->head + SKB_GSO_CB(skb)->mac_offset;\n\t\tmemmove(packet_start-frag_hdr_sz, packet_start, unfrag_len);\n\n\t\tSKB_GSO_CB(skb)->mac_offset -= frag_hdr_sz;\n\t\tskb->mac_header -= frag_hdr_sz;\n\t\tskb->network_header -= frag_hdr_sz;\n\n\t\tfptr = (struct frag_hdr *)(skb_network_header(skb) + unfrag_ip6hlen);\n\t\tfptr->nexthdr = nexthdr;\n\t\tfptr->reserved = 0;\n\t\tif (!skb_shinfo(skb)->ip6_frag_id)\n\t\t\tipv6_proxy_select_ident(dev_net(skb->dev), skb);\n\t\tfptr->identification = skb_shinfo(skb)->ip6_frag_id;\n\n\t\t/* Fragment the skb. ipv6 header and the remaining fields of the\n\t\t * fragment header are updated in ipv6_gso_segment()\n\t\t */\n\t\tsegs = skb_segment(skb, features);\n\t}\n\nout:\n\treturn segs;\n}", "target": 2, "idx": 10380}
{"commit_id": "ead349e99868303b37f5e6e9d9d680c9dc71ff8d", "project": "libgd", "func": "int read_image_tga( gdIOCtx *ctx, oTga *tga )\n{\n\tint pixel_block_size = (tga->bits / 8);\n\tint image_block_size = (tga->width * tga->height) * pixel_block_size;\n\tuint8_t* decompression_buffer = NULL;\n\tunsigned char* conversion_buffer = NULL;\n\tint buffer_caret = 0;\n\tint bitmap_caret = 0;\n\tint i = 0;\n\tint j = 0;\n\tuint8_t encoded_pixels;\n\n\tif(overflow2(tga->width, tga->height)) {\n\t\treturn -1;\n\t}\n\n\tif(overflow2(tga->width * tga->height, pixel_block_size)) {\n\t\treturn -1;\n\t}\n\n\tif(overflow2(image_block_size, sizeof(int))) {\n\t\treturn -1;\n\t}\n\n\t/*! \\todo Add more image type support.\n\t */\n\tif (tga->imagetype != TGA_TYPE_RGB && tga->imagetype != TGA_TYPE_RGB_RLE)\n\t\treturn -1;\n\n\t/*!\t\\brief Allocate memmory for image block\n\t *  Allocate a chunk of memory for the image block to be passed into.\n\t */\n\ttga->bitmap = (int *) gdMalloc(image_block_size * sizeof(int));\n\tif (tga->bitmap == NULL)\n\t\treturn -1;\n\n\tswitch (tga->imagetype) {\n\tcase TGA_TYPE_RGB:\n\t\t/*! \\brief Read in uncompressed RGB TGA\n\t\t *  Chunk load the pixel data from an uncompressed RGB type TGA.\n\t\t */\n\t\tconversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));\n\t\tif (conversion_buffer == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (gdGetBuf(conversion_buffer, image_block_size, ctx) != image_block_size) {\n\t\t\tgd_error(\"gd-tga: premature end of image data\\n\");\n\t\t\tgdFree(conversion_buffer);\n\t\t\treturn -1;\n\t\t}\n\n\t\twhile (buffer_caret < image_block_size) {\n\t\t\ttga->bitmap[buffer_caret] = (int) conversion_buffer[buffer_caret];\n\t\t\tbuffer_caret++;\n\t\t}\n\n\t\tgdFree(conversion_buffer);\n\t\tbreak;\n\n\tcase TGA_TYPE_RGB_RLE:\n\t\t/*! \\brief Read in RLE compressed RGB TGA\n\t\t *  Chunk load the pixel data from an RLE compressed RGB type TGA.\n\t\t */\n\t\tdecompression_buffer = (uint8_t*) gdMalloc(image_block_size * sizeof(uint8_t));\n\t\tif (decompression_buffer == NULL) {\n\t\t\treturn -1;\n\t\t}\n\t\tconversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));\n\t\tif (conversion_buffer == NULL) {\n\t\t\tgd_error(\"gd-tga: premature end of image data\\n\");\n\t\t\tgdFree( decompression_buffer );\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (gdGetBuf(conversion_buffer, image_block_size, ctx) != image_block_size) {\n\t\t\tgdFree(conversion_buffer);\n\t\t\tgdFree(decompression_buffer);\n\t\t\treturn -1;\n\t\t}\n\n\t\tbuffer_caret = 0;\n\n\t\twhile( buffer_caret < image_block_size) {\n\t\t\tdecompression_buffer[buffer_caret] = (int)conversion_buffer[buffer_caret];\n\t\t\tbuffer_caret++;\n\t\t}\n\n\t\tbuffer_caret = 0;\n\n\t\twhile( bitmap_caret < image_block_size ) {\n\n\t\t\tif ((decompression_buffer[buffer_caret] & TGA_RLE_FLAG) == TGA_RLE_FLAG) {\n\t\t\t\tencoded_pixels = ( ( decompression_buffer[ buffer_caret ] & 127 ) + 1 );\n\t\t\t\tbuffer_caret++;\n\n\t\t\t\tfor (i = 0; i < encoded_pixels; i++) {\n\t\t\t\t\tfor (j = 0; j < pixel_block_size; j++, bitmap_caret++) {\n\t\t\t\t\t\ttga->bitmap[ bitmap_caret ] = decompression_buffer[ buffer_caret + j ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbuffer_caret += pixel_block_size;\n\t\t\t} else {\n\t\t\t\tencoded_pixels = decompression_buffer[ buffer_caret ] + 1;\n\t\t\t\tbuffer_caret++;\n\n\t\t\t\tfor (i = 0; i < encoded_pixels; i++) {\n\t\t\t\t\tfor( j = 0; j < pixel_block_size; j++, bitmap_caret++ ) {\n\t\t\t\t\t\ttga->bitmap[ bitmap_caret ] = decompression_buffer[ buffer_caret + j ];\n\t\t\t\t\t}\n\t\t\t\t\tbuffer_caret += pixel_block_size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgdFree( decompression_buffer );\n\t\tgdFree( conversion_buffer );\n\t\tbreak;\n\t}\n\n\treturn 1;\n}", "target": 1, "idx": 10381}
{"commit_id": "1b0fe00e2704b5e20334a16d3c9099d1ba2ef1be", "project": "openssl", "func": "static RAND_DRBG *rand_drbg_new(int secure,\n                                int type,\n                                unsigned int flags,\n                                RAND_DRBG *parent)\n{\n    RAND_DRBG *drbg = secure ? OPENSSL_secure_zalloc(sizeof(*drbg))\n                             : OPENSSL_zalloc(sizeof(*drbg));\n\n    if (drbg == NULL) {\n        RANDerr(RAND_F_RAND_DRBG_NEW, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n\n    drbg->secure = secure && CRYPTO_secure_allocated(drbg);\n    drbg->fork_id = openssl_get_fork_id();\n    drbg->parent = parent;\n\n    if (parent == NULL) {\n        drbg->get_entropy = rand_drbg_get_entropy;\n        drbg->cleanup_entropy = rand_drbg_cleanup_entropy;\n#ifndef RAND_DRBG_GET_RANDOM_NONCE\n        drbg->get_nonce = rand_drbg_get_nonce;\n        drbg->cleanup_nonce = rand_drbg_cleanup_nonce;\n#endif\n\n        drbg->reseed_interval = master_reseed_interval;\n        drbg->reseed_time_interval = master_reseed_time_interval;\n    } else {\n        drbg->get_entropy = rand_drbg_get_entropy;\n        drbg->cleanup_entropy = rand_drbg_cleanup_entropy;\n        /*\n         * Do not provide nonce callbacks, the child DRBGs will\n         * obtain their nonce using random bits from the parent.\n         */\n\n        drbg->reseed_interval = slave_reseed_interval;\n        drbg->reseed_time_interval = slave_reseed_time_interval;\n    }\n\n    if (RAND_DRBG_set(drbg, type, flags) == 0)\n        goto err;\n\n    if (parent != NULL) {\n        rand_drbg_lock(parent);\n        if (drbg->strength > parent->strength) {\n            /*\n             * We currently don't support the algorithm from NIST SP 800-90C\n             * 10.1.2 to use a weaker DRBG as source\n             */\n            rand_drbg_unlock(parent);\n            RANDerr(RAND_F_RAND_DRBG_NEW, RAND_R_PARENT_STRENGTH_TOO_WEAK);\n            goto err;\n        }\n        rand_drbg_unlock(parent);\n    }\n\n    return drbg;\n\n err:\n    RAND_DRBG_free(drbg);\n\n    return NULL;\n}", "target": 1, "idx": 10382}
{"commit_id": "a096da74c2c753b83daa61c1c807ec43de287917", "project": "jerryscript-project/jerryscript", "func": "ecma_value_t\necma_proxy_object_set (ecma_object_t *obj_p, /**< proxy object */\n                       ecma_string_t *prop_name_p, /**< property name */\n                       ecma_value_t value, /**< value to set */\n                       ecma_value_t receiver) /**< receiver to invoke setter function */\n{\n  JERRY_ASSERT (ECMA_OBJECT_IS_PROXY (obj_p));\n  ECMA_CHECK_STACK_USAGE ();\n\n  ecma_proxy_object_t *proxy_obj_p = (ecma_proxy_object_t *) obj_p;\n\n  /* 2. */\n  ecma_value_t handler = proxy_obj_p->handler;\n\n  /* 3-6. */\n  ecma_value_t trap = ecma_validate_proxy_object (handler, LIT_MAGIC_STRING_SET);\n\n  /* 7. */\n  if (ECMA_IS_VALUE_ERROR (trap))\n  {\n    return trap;\n  }\n\n  ecma_value_t target = proxy_obj_p->target;\n  ecma_object_t *target_obj_p = ecma_get_object_from_value (target);\n\n  /* 8. */\n  if (ecma_is_value_undefined (trap))\n  {\n    return ecma_op_object_put_with_receiver (target_obj_p, prop_name_p, value, receiver, false);\n  }\n\n  ecma_object_t *func_obj_p = ecma_get_object_from_value (trap);\n  ecma_value_t prop_name_value = ecma_make_prop_name_value (prop_name_p);\n  ecma_value_t args[] = { target, prop_name_value, value, receiver };\n\n  /* 9. */\n  ecma_value_t trap_result = ecma_op_function_call (func_obj_p, handler, args, 4);\n\n  ecma_deref_object (func_obj_p);\n\n  /* 10. */\n  if (ECMA_IS_VALUE_ERROR (trap_result))\n  {\n    return trap_result;\n  }\n\n  bool boolean_trap_result = ecma_op_to_boolean (trap_result);\n\n  ecma_free_value (trap_result);\n\n  /* 11. */\n  if (!boolean_trap_result)\n  {\n    return ECMA_VALUE_FALSE;\n  }\n\n  /* 12. */\n  ecma_property_descriptor_t target_desc;\n\n  ecma_value_t status = ecma_op_object_get_own_property_descriptor (target_obj_p, prop_name_p, &target_desc);\n\n  /* 13. */\n  if (ECMA_IS_VALUE_ERROR (status))\n  {\n    return status;\n  }\n\n  /* 14. */\n  if (ecma_is_value_true (status))\n  {\n    ecma_value_t ret_value = ECMA_VALUE_EMPTY;\n\n    if ((target_desc.flags & ECMA_PROP_IS_VALUE_DEFINED)\n        && !(target_desc.flags & ECMA_PROP_IS_CONFIGURABLE)\n        && !(target_desc.flags & ECMA_PROP_IS_WRITABLE)\n        && !ecma_op_same_value (value, target_desc.value))\n    {\n      ret_value = ecma_raise_type_error (ECMA_ERR_MSG (\"The property exists in the proxy target as a\"\n                                                       \" non-configurable and non-writable data property\"\n                                                       \" with a different value.\"));\n    }\n    else if (!(target_desc.flags & ECMA_PROP_IS_CONFIGURABLE)\n            && (target_desc.flags & (ECMA_PROP_IS_GET_DEFINED | ECMA_PROP_IS_SET_DEFINED))\n            && target_desc.set_p == NULL)\n    {\n      ret_value = ecma_raise_type_error (ECMA_ERR_MSG (\"The property exists in the proxy target as a\"\n                                                       \" non-configurable accessor property whitout a setter.\"));\n    }\n\n    ecma_free_property_descriptor (&target_desc);\n\n    if (ECMA_IS_VALUE_ERROR (ret_value))\n    {\n      return ret_value;\n    }\n  }\n\n  /* 15. */\n  return ECMA_VALUE_TRUE;\n}", "target": 2, "idx": 10383}
{"commit_id": "76d56d4ab4f2a9e4f085c7d77172194ddaccf7d2", "project": "torvalds/linux", "func": "static bool sanity_check_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\n\tif (f2fs_sb_has_flexible_inline_xattr(sbi->sb)\n\t\t\t&& !f2fs_has_extra_attr(inode)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t\"%s: corrupted inode ino=%lx, run fsck to fix.\",\n\t\t\t__func__, inode->i_ino);\n\t\treturn false;\n\t}\n\n\tif (f2fs_has_extra_attr(inode) &&\n\t\t\t!f2fs_sb_has_extra_attr(sbi->sb)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t\"%s: inode (ino=%lx) is with extra_attr, \"\n\t\t\t\"but extra_attr feature is off\",\n\t\t\t__func__, inode->i_ino);\n\t\treturn false;\n\t}\n\treturn true;\n}", "target": 1, "idx": 10384}
{"commit_id": "319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12", "project": "xen-project/xen", "func": "static int amd_iommu_assign_device(struct domain *d, u8 devfn,\n                                   struct pci_dev *pdev,\n                                   u32 flag)\n{\n    struct ivrs_mappings *ivrs_mappings = get_ivrs_mappings(pdev->seg);\n    int bdf = PCI_BDF2(pdev->bus, devfn);\n    int req_id = get_dma_requestor_id(pdev->seg, bdf);\n\n    if ( ivrs_mappings[req_id].unity_map_enable )\n    {\n        amd_iommu_reserve_domain_unity_map(\n            d,\n            ivrs_mappings[req_id].addr_range_start,\n            ivrs_mappings[req_id].addr_range_length,\n            ivrs_mappings[req_id].write_permission,\n            ivrs_mappings[req_id].read_permission);\n    }\n\n    return reassign_device(pdev->domain, d, devfn, pdev);\n}", "target": 1, "idx": 10385}
{"commit_id": "9528ce73156e2b6a5e96e371068b24a5975f4bcd", "project": "php/php-src", "func": "static void php_wddx_push_element(void *user_data, const XML_Char *name, const XML_Char **atts)\n{\n\tst_entry ent;\n\twddx_stack *stack = (wddx_stack *)user_data;\n\tif (!strcmp((char *)name, EL_PACKET)) {\n\t\tint i;\n\n\t\tif (atts) for (i=0; atts[i]; i++) {\n\t\t\tif (!strcmp((char *)atts[i], EL_VERSION)) {\n\t\t\t\t/* nothing for now */\n\t\t\t}\n\t\t}\n\t} else if (!strcmp((char *)name, EL_STRING)) {\n\t\tent.type = ST_STRING;\n\t\tSET_STACK_VARNAME;\n\n\t\tZVAL_STR(&ent.data, ZSTR_EMPTY_ALLOC());\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp((char *)name, EL_BINARY)) {\n\t\tent.type = ST_BINARY;\n\t\tSET_STACK_VARNAME;\n\n\t\tZVAL_STR(&ent.data, ZSTR_EMPTY_ALLOC());\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp((char *)name, EL_CHAR)) {\n\t\tint i;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp((char *)atts[i], EL_CHAR_CODE) && atts[i+1] && atts[i+1][0]) {\n\t\t\t\tchar tmp_buf[2];\n\n\t\t\t\tsnprintf(tmp_buf, sizeof(tmp_buf), \"%c\", (char)strtol((char *)atts[i+1], NULL, 16));\n\t\t\t\tphp_wddx_process_data(user_data, (XML_Char *) tmp_buf, strlen(tmp_buf));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (!strcmp((char *)name, EL_NUMBER)) {\n\t\tent.type = ST_NUMBER;\n\t\tSET_STACK_VARNAME;\n\n\t\tZVAL_LONG(&ent.data, 0);\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp((char *)name, EL_BOOLEAN)) {\n\t\tint i;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp((char *)atts[i], EL_VALUE) && atts[i+1] && atts[i+1][0]) {\n\t\t\t\tent.type = ST_BOOLEAN;\n\t\t\t\tSET_STACK_VARNAME;\n\n\t\t\t\tZVAL_TRUE(&ent.data);\n\t\t\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t\t\t\tphp_wddx_process_data(user_data, atts[i+1], strlen((char *)atts[i+1]));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (!strcmp((char *)name, EL_NULL)) {\n\t\tent.type = ST_NULL;\n\t\tSET_STACK_VARNAME;\n\n\t\tZVAL_NULL(&ent.data);\n\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp((char *)name, EL_ARRAY)) {\n\t\tent.type = ST_ARRAY;\n\t\tSET_STACK_VARNAME;\n\n\t\tarray_init(&ent.data);\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp((char *)name, EL_STRUCT)) {\n\t\tent.type = ST_STRUCT;\n\t\tSET_STACK_VARNAME;\n\t\tarray_init(&ent.data);\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp((char *)name, EL_VAR)) {\n\t\tint i;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp((char *)atts[i], EL_NAME) && atts[i+1] && atts[i+1][0]) {\n\t\t\t\tif (stack->varname) efree(stack->varname);\n\t\t\t\tstack->varname = estrdup((char *)atts[i+1]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (!strcmp((char *)name, EL_RECORDSET)) {\n\t\tint i;\n\n\t\tent.type = ST_RECORDSET;\n\t\tSET_STACK_VARNAME;\n\t\tarray_init(&ent.data);\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp((char *)atts[i], \"fieldNames\") && atts[i+1] && atts[i+1][0]) {\n\t\t\t\tzval tmp;\n\t\t\t\tchar *key;\n\t\t\t\tconst char *p1, *p2, *endp;\n\n\t\t\t\ti++;\n\t\t\t\tendp = (char *)atts[i] + strlen((char *)atts[i]);\n\t\t\t\tp1 = (char *)atts[i];\n\t\t\t\twhile ((p2 = php_memnstr(p1, \",\", sizeof(\",\")-1, endp)) != NULL) {\n\t\t\t\t\tkey = estrndup(p1, p2 - p1);\n\t\t\t\t\tarray_init(&tmp);\n\t\t\t\t\tadd_assoc_zval_ex(&ent.data, key, p2 - p1, &tmp);\n\t\t\t\t\tp1 = p2 + sizeof(\",\")-1;\n\t\t\t\t\tefree(key);\n\t\t\t\t}\n\n\t\t\t\tif (p1 <= endp) {\n\t\t\t\t\tarray_init(&tmp);\n\t\t\t\t\tadd_assoc_zval_ex(&ent.data, p1, endp - p1, &tmp);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp((char *)name, EL_FIELD)) {\n\t\tint i;\n\t\tst_entry ent;\n\n\t\tent.type = ST_FIELD;\n\t\tent.varname = NULL;\n\t\tZVAL_UNDEF(&ent.data);\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp((char *)atts[i], EL_NAME) && atts[i+1] && atts[i+1][0]) {\n\t\t\t\tst_entry *recordset;\n\t\t\t\tzval *field;\n\n\t\t\t\tif (wddx_stack_top(stack, (void**)&recordset) == SUCCESS &&\n\t\t\t\t\trecordset->type == ST_RECORDSET &&\n\t\t\t\t\t(field = zend_hash_str_find(Z_ARRVAL(recordset->data), (char*)atts[i+1], strlen((char *)atts[i+1]))) != NULL) {\n\t\t\t\t\tZVAL_COPY_VALUE(&ent.data, field);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp((char *)name, EL_DATETIME)) {\n\t\tent.type = ST_DATETIME;\n\t\tSET_STACK_VARNAME;\n\n\t\tZVAL_LONG(&ent.data, 0);\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t}\n}", "target": 2, "idx": 10386}
{"commit_id": "7634712307110325630eb41188cec77bc4a91233", "project": "libjxl", "func": "Status ModularFrameDecoder::DecodeGroup(const Rect& rect, BitReader* reader,\n                                        int minShift, int maxShift,\n                                        const ModularStreamId& stream,\n                                        bool zerofill,\n                                        PassesDecoderState* dec_state,\n                                        ImageBundle* output) {\n  JXL_DASSERT(stream.kind == ModularStreamId::kModularDC ||\n              stream.kind == ModularStreamId::kModularAC);\n  const size_t xsize = rect.xsize();\n  const size_t ysize = rect.ysize();\n  Image gi(xsize, ysize, full_image.bitdepth, 0);\n  // start at the first bigger-than-groupsize non-metachannel\n  size_t c = full_image.nb_meta_channels;\n  for (; c < full_image.channel.size(); c++) {\n    Channel& fc = full_image.channel[c];\n    if (fc.w > frame_dim.group_dim || fc.h > frame_dim.group_dim) break;\n  }\n  size_t beginc = c;\n  for (; c < full_image.channel.size(); c++) {\n    Channel& fc = full_image.channel[c];\n    int shift = std::min(fc.hshift, fc.vshift);\n    if (shift > maxShift) continue;\n    if (shift < minShift) continue;\n    Rect r(rect.x0() >> fc.hshift, rect.y0() >> fc.vshift,\n           rect.xsize() >> fc.hshift, rect.ysize() >> fc.vshift, fc.w, fc.h);\n    if (r.xsize() == 0 || r.ysize() == 0) continue;\n    if (zerofill && use_full_image) {\n      for (size_t y = 0; y < r.ysize(); ++y) {\n        pixel_type* const JXL_RESTRICT row_out = r.Row(&fc.plane, y);\n        memset(row_out, 0, r.xsize() * sizeof(*row_out));\n      }\n    } else {\n      Channel gc(r.xsize(), r.ysize());\n      if (zerofill) ZeroFillImage(&gc.plane);\n      gc.hshift = fc.hshift;\n      gc.vshift = fc.vshift;\n      gi.channel.emplace_back(std::move(gc));\n    }\n  }\n  if (zerofill && use_full_image) return true;\n  ModularOptions options;\n  if (!zerofill) {\n    if (!ModularGenericDecompress(\n            reader, gi, /*header=*/nullptr, stream.ID(frame_dim), &options,\n            /*undo_transforms=*/-1, &tree, &code, &context_map)) {\n      return JXL_FAILURE(\"Failed to decode modular group\");\n    }\n  }\n  // Undo global transforms that have been pushed to the group level\n  if (!use_full_image) {\n    for (auto t : global_transform) {\n      JXL_RETURN_IF_ERROR(t.Inverse(gi, global_header.wp_header));\n    }\n    JXL_RETURN_IF_ERROR(ModularImageToDecodedRect(\n        gi, dec_state, nullptr, output, rect.Crop(dec_state->decoded)));\n    return true;\n  }\n  int gic = 0;\n  for (c = beginc; c < full_image.channel.size(); c++) {\n    Channel& fc = full_image.channel[c];\n    int shift = std::min(fc.hshift, fc.vshift);\n    if (shift > maxShift) continue;\n    if (shift < minShift) continue;\n    Rect r(rect.x0() >> fc.hshift, rect.y0() >> fc.vshift,\n           rect.xsize() >> fc.hshift, rect.ysize() >> fc.vshift, fc.w, fc.h);\n    if (r.xsize() == 0 || r.ysize() == 0) continue;\n    JXL_ASSERT(use_full_image);\n    CopyImageTo(/*rect_from=*/Rect(0, 0, r.xsize(), r.ysize()),\n                /*from=*/gi.channel[gic].plane,\n                /*rect_to=*/r, /*to=*/&fc.plane);\n    gic++;\n  }\n  return true;\n}", "target": 1, "idx": 10387}
{"commit_id": "9002fd07327a91f35ba6c1307e71fa6fd4409b7f", "project": "openssl", "func": "int DH_check(const DH *dh, int *ret)\n{\n#ifdef FIPS_MODULE\n    return DH_check_params(dh, ret);\n#else\n    int ok = 0, r, q_good = 0;\n    BN_CTX *ctx = NULL;\n    BIGNUM *t1 = NULL, *t2 = NULL;\n    int nid = DH_get_nid((DH *)dh);\n\n    *ret = 0;\n    if (nid != NID_undef)\n        return 1;\n\n    /* Don't do any checks at all with an excessively large modulus */\n    if (BN_num_bits(dh->params.p) > OPENSSL_DH_CHECK_MAX_MODULUS_BITS) {\n        ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_LARGE);\n        *ret = DH_MODULUS_TOO_LARGE | DH_CHECK_P_NOT_PRIME;\n        return 0;\n    }\n\n    if (!DH_check_params(dh, ret))\n        return 0;\n\n    ctx = BN_CTX_new_ex(dh->libctx);\n    if (ctx == NULL)\n        goto err;\n    BN_CTX_start(ctx);\n    t1 = BN_CTX_get(ctx);\n    t2 = BN_CTX_get(ctx);\n    if (t2 == NULL)\n        goto err;\n\n    if (dh->params.q != NULL) {\n        if (BN_ucmp(dh->params.p, dh->params.q) > 0)\n            q_good = 1;\n        else\n            *ret |= DH_CHECK_INVALID_Q_VALUE;\n    }\n\n    if (q_good) {\n        if (BN_cmp(dh->params.g, BN_value_one()) <= 0)\n            *ret |= DH_NOT_SUITABLE_GENERATOR;\n        else if (BN_cmp(dh->params.g, dh->params.p) >= 0)\n            *ret |= DH_NOT_SUITABLE_GENERATOR;\n        else {\n            /* Check g^q == 1 mod p */\n            if (!BN_mod_exp(t1, dh->params.g, dh->params.q, dh->params.p, ctx))\n                goto err;\n            if (!BN_is_one(t1))\n                *ret |= DH_NOT_SUITABLE_GENERATOR;\n        }\n        r = BN_check_prime(dh->params.q, ctx, NULL);\n        if (r < 0)\n            goto err;\n        if (!r)\n            *ret |= DH_CHECK_Q_NOT_PRIME;\n        /* Check p == 1 mod q  i.e. q divides p - 1 */\n        if (!BN_div(t1, t2, dh->params.p, dh->params.q, ctx))\n            goto err;\n        if (!BN_is_one(t2))\n            *ret |= DH_CHECK_INVALID_Q_VALUE;\n        if (dh->params.j != NULL\n            && BN_cmp(dh->params.j, t1))\n            *ret |= DH_CHECK_INVALID_J_VALUE;\n    }\n\n    r = BN_check_prime(dh->params.p, ctx, NULL);\n    if (r < 0)\n        goto err;\n    if (!r)\n        *ret |= DH_CHECK_P_NOT_PRIME;\n    else if (dh->params.q == NULL) {\n        if (!BN_rshift1(t1, dh->params.p))\n            goto err;\n        r = BN_check_prime(t1, ctx, NULL);\n        if (r < 0)\n            goto err;\n        if (!r)\n            *ret |= DH_CHECK_P_NOT_SAFE_PRIME;\n    }\n    ok = 1;\n err:\n    BN_CTX_end(ctx);\n    BN_CTX_free(ctx);\n    return ok;\n#endif /* FIPS_MODULE */\n}", "target": 1, "idx": 10388}
{"commit_id": "b6ff2bcb1e4e6976d61e316175c6d7c99860fe20", "project": "iortcw", "func": "void CL_Init( void ) {\n\tCom_Printf( \"----- Client Initialization -----\\n\" );\n\n\tCon_Init();\n\n\tif(!com_fullyInitialized)\n\t{\n\t\tCL_ClearState();\n\t\tclc.state = CA_DISCONNECTED;\t// no longer CA_UNINITIALIZED\n\t\tcl_oldGameSet = qfalse;\n\t}\n\n\tcls.realtime = 0;\n\n\tCL_InitInput();\n\n\t//\n\t// register our variables\n\t//\n\tcl_noprint = Cvar_Get( \"cl_noprint\", \"0\", 0 );\n#ifdef UPDATE_SERVER_NAME\n\tcl_motd = Cvar_Get( \"cl_motd\", \"1\", 0 );\n#endif\n\tcl_autoupdate = Cvar_Get( \"cl_autoupdate\", \"0\", CVAR_ARCHIVE );\n\n\tcl_timeout = Cvar_Get( \"cl_timeout\", \"200\", 0 );\n\n\tcl_wavefilerecord = Cvar_Get( \"cl_wavefilerecord\", \"0\", CVAR_TEMP );\n\n\tcl_timeNudge = Cvar_Get( \"cl_timeNudge\", \"0\", CVAR_TEMP );\n\tcl_shownet = Cvar_Get( \"cl_shownet\", \"0\", CVAR_TEMP );\n\tcl_shownuments = Cvar_Get( \"cl_shownuments\", \"0\", CVAR_TEMP );\n\tcl_visibleClients = Cvar_Get( \"cl_visibleClients\", \"0\", CVAR_TEMP );\n\tcl_showServerCommands = Cvar_Get( \"cl_showServerCommands\", \"0\", 0 );\n\tcl_showSend = Cvar_Get( \"cl_showSend\", \"0\", CVAR_TEMP );\n\tcl_showTimeDelta = Cvar_Get( \"cl_showTimeDelta\", \"0\", CVAR_TEMP );\n\tcl_freezeDemo = Cvar_Get( \"cl_freezeDemo\", \"0\", CVAR_TEMP );\n\trcon_client_password = Cvar_Get( \"rconPassword\", \"\", CVAR_TEMP );\n\tcl_activeAction = Cvar_Get( \"activeAction\", \"\", CVAR_TEMP );\n\n\tcl_timedemo = Cvar_Get( \"timedemo\", \"0\", 0 );\n\tcl_timedemoLog = Cvar_Get (\"cl_timedemoLog\", \"\", CVAR_ARCHIVE);\n\tcl_autoRecordDemo = Cvar_Get (\"cl_autoRecordDemo\", \"0\", CVAR_ARCHIVE);\n\tcl_aviFrameRate = Cvar_Get (\"cl_aviFrameRate\", \"25\", CVAR_ARCHIVE);\n\tcl_aviMotionJpeg = Cvar_Get (\"cl_aviMotionJpeg\", \"1\", CVAR_ARCHIVE);\n\tcl_avidemo = Cvar_Get( \"cl_avidemo\", \"0\", 0 );\n\tcl_forceavidemo = Cvar_Get( \"cl_forceavidemo\", \"0\", 0 );\n\n\trconAddress = Cvar_Get( \"rconAddress\", \"\", 0 );\n\n\tcl_yawspeed = Cvar_Get( \"cl_yawspeed\", \"140\", CVAR_ARCHIVE );\n\tcl_pitchspeed = Cvar_Get( \"cl_pitchspeed\", \"140\", CVAR_ARCHIVE );\n\tcl_anglespeedkey = Cvar_Get( \"cl_anglespeedkey\", \"1.5\", 0 );\n\n\tcl_maxpackets = Cvar_Get( \"cl_maxpackets\", \"38\", CVAR_ARCHIVE );\n\tcl_packetdup = Cvar_Get( \"cl_packetdup\", \"1\", CVAR_ARCHIVE );\n\n\tcl_showPing = Cvar_Get( \"cl_showPing\", \"0\", CVAR_ARCHIVE );\n\n\tcl_run = Cvar_Get( \"cl_run\", \"1\", CVAR_ARCHIVE );\n\tcl_sensitivity = Cvar_Get( \"sensitivity\", \"5\", CVAR_ARCHIVE );\n\tcl_mouseAccel = Cvar_Get( \"cl_mouseAccel\", \"0\", CVAR_ARCHIVE );\n\tcl_freelook = Cvar_Get( \"cl_freelook\", \"1\", CVAR_ARCHIVE );\n\n\t// 0: legacy mouse acceleration\n\t// 1: new implementation\n\tcl_mouseAccelStyle = Cvar_Get( \"cl_mouseAccelStyle\", \"0\", CVAR_ARCHIVE );\n\t// offset for the power function (for style 1, ignored otherwise)\n\t// this should be set to the max rate value\n\tcl_mouseAccelOffset = Cvar_Get( \"cl_mouseAccelOffset\", \"5\", CVAR_ARCHIVE );\n\tCvar_CheckRange(cl_mouseAccelOffset, 0.001f, 50000.0f, qfalse);\n\n\tcl_showMouseRate = Cvar_Get( \"cl_showmouserate\", \"0\", 0 );\n\n\tcl_allowDownload = Cvar_Get( \"cl_allowDownload\", \"1\", CVAR_ARCHIVE );\n#ifdef USE_CURL_DLOPEN\n\tcl_cURLLib = Cvar_Get(\"cl_cURLLib\", DEFAULT_CURL_LIB, CVAR_ARCHIVE | CVAR_PROTECTED);\n#endif\n\n\t// init autoswitch so the ui will have it correctly even\n\t// if the cgame hasn't been started\n\t// -NERVE - SMF - disabled autoswitch by default\n\tCvar_Get( \"cg_autoswitch\", \"0\", CVAR_ARCHIVE );\n\n\t// Rafael - particle switch\n\tCvar_Get( \"cg_wolfparticles\", \"1\", CVAR_ARCHIVE );\n\t// done\n\n\tcl_conXOffset = Cvar_Get( \"cl_conXOffset\", \"0\", 0 );\n\tcl_inGameVideo = Cvar_Get( \"r_inGameVideo\", \"1\", CVAR_ARCHIVE );\n\n\tcl_serverStatusResendTime = Cvar_Get( \"cl_serverStatusResendTime\", \"750\", 0 );\n\n\t// RF\n\tcl_recoilPitch = Cvar_Get( \"cg_recoilPitch\", \"0\", CVAR_ROM );\n\n\tcl_bypassMouseInput = Cvar_Get( \"cl_bypassMouseInput\", \"0\", 0 ); //CVAR_ROM );\t\t\t// NERVE - SMF\n\n\tm_pitch = Cvar_Get( \"m_pitch\", \"0.022\", CVAR_ARCHIVE );\n\tm_yaw = Cvar_Get( \"m_yaw\", \"0.022\", CVAR_ARCHIVE );\n\tm_forward = Cvar_Get( \"m_forward\", \"0.25\", CVAR_ARCHIVE );\n\tm_side = Cvar_Get( \"m_side\", \"0.25\", CVAR_ARCHIVE );\n\tm_filter = Cvar_Get( \"m_filter\", \"0\", CVAR_ARCHIVE );\n\n\tj_pitch =        Cvar_Get (\"j_pitch\",        \"0.022\", CVAR_ARCHIVE);\n\tj_yaw =          Cvar_Get (\"j_yaw\",          \"-0.022\", CVAR_ARCHIVE);\n\tj_forward =      Cvar_Get (\"j_forward\",      \"-0.25\", CVAR_ARCHIVE);\n\tj_side =         Cvar_Get (\"j_side\",         \"0.25\", CVAR_ARCHIVE);\n\tj_up =           Cvar_Get (\"j_up\",           \"0\", CVAR_ARCHIVE);\n\n\tj_pitch_axis =   Cvar_Get (\"j_pitch_axis\",   \"3\", CVAR_ARCHIVE);\n\tj_yaw_axis =     Cvar_Get (\"j_yaw_axis\",     \"2\", CVAR_ARCHIVE);\n\tj_forward_axis = Cvar_Get (\"j_forward_axis\", \"1\", CVAR_ARCHIVE);\n\tj_side_axis =    Cvar_Get (\"j_side_axis\",    \"0\", CVAR_ARCHIVE);\n\tj_up_axis =      Cvar_Get (\"j_up_axis\",      \"4\", CVAR_ARCHIVE);\n\n\tCvar_CheckRange(j_pitch_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);\n\tCvar_CheckRange(j_yaw_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);\n\tCvar_CheckRange(j_forward_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);\n\tCvar_CheckRange(j_side_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);\n\tCvar_CheckRange(j_up_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);\n\n\tcl_motdString = Cvar_Get( \"cl_motdString\", \"\", CVAR_ROM );\n\n\tCvar_Get( \"cl_maxPing\", \"800\", CVAR_ARCHIVE );\n\n\tcl_lanForcePackets = Cvar_Get (\"cl_lanForcePackets\", \"1\", CVAR_ARCHIVE);\n\n\tcl_guid = Cvar_Get( \"cl_guid\", \"unknown\", CVAR_USERINFO | CVAR_ROM );\n\n\tcl_guidServerUniq = Cvar_Get (\"cl_guidServerUniq\", \"1\", CVAR_ARCHIVE);\n\n\t// ~ and `, as keys and characters\n\tcl_consoleKeys = Cvar_Get( \"cl_consoleKeys\", \"~ ` 0x7e 0x60\", CVAR_ARCHIVE);\n\n\t// NERVE - SMF\n\tCvar_Get( \"cg_drawCompass\", \"1\", CVAR_ARCHIVE );\n\tCvar_Get( \"cg_drawNotifyText\", \"1\", CVAR_ARCHIVE );\n\tCvar_Get( \"cg_quickMessageAlt\", \"1\", CVAR_ARCHIVE );\n\tCvar_Get( \"cg_popupLimboMenu\", \"1\", CVAR_ARCHIVE );\n\tCvar_Get( \"cg_descriptiveText\", \"1\", CVAR_ARCHIVE );\n\tCvar_Get( \"cg_drawTeamOverlay\", \"2\", CVAR_ARCHIVE );\n\tCvar_Get( \"cg_uselessNostalgia\", \"0\", CVAR_ARCHIVE ); // JPW NERVE\n\tCvar_Get( \"cg_drawGun\", \"1\", CVAR_ARCHIVE );\n\tCvar_Get( \"cg_cursorHints\", \"1\", CVAR_ARCHIVE );\n\tCvar_Get( \"cg_voiceSpriteTime\", \"6000\", CVAR_ARCHIVE );\n\tCvar_Get( \"cg_teamChatsOnly\", \"0\", CVAR_ARCHIVE );\n\tCvar_Get( \"cg_noVoiceChats\", \"0\", CVAR_ARCHIVE );\n\tCvar_Get( \"cg_noVoiceText\", \"0\", CVAR_ARCHIVE );\n\tCvar_Get( \"cg_crosshairSize\", \"48\", CVAR_ARCHIVE );\n\tCvar_Get( \"cg_drawCrosshair\", \"1\", CVAR_ARCHIVE );\n\tCvar_Get( \"cg_zoomDefaultSniper\", \"20\", CVAR_ARCHIVE );\n\tCvar_Get( \"cg_zoomstepsniper\", \"2\", CVAR_ARCHIVE );\n\n\tCvar_Get( \"mp_playerType\", \"0\", 0 );\n\tCvar_Get( \"mp_currentPlayerType\", \"0\", 0 );\n\tCvar_Get( \"mp_weapon\", \"0\", 0 );\n\tCvar_Get( \"mp_team\", \"0\", 0 );\n\tCvar_Get( \"mp_currentTeam\", \"0\", 0 );\n\t// -NERVE - SMF\n\n\t// userinfo\n\tCvar_Get( \"name\", \"WolfPlayer\", CVAR_USERINFO | CVAR_ARCHIVE );\n\tcl_rate = Cvar_Get( \"rate\", \"25000\", CVAR_USERINFO | CVAR_ARCHIVE );     // NERVE - SMF - changed from 3000\n\tCvar_Get( \"snaps\", \"20\", CVAR_USERINFO | CVAR_ARCHIVE );\n\tCvar_Get( \"model\", \"multi\", CVAR_USERINFO | CVAR_ARCHIVE );\n\tCvar_Get( \"head\", \"default\", CVAR_USERINFO | CVAR_ARCHIVE );\n\tCvar_Get( \"color\", \"4\", CVAR_USERINFO | CVAR_ARCHIVE );\n\tCvar_Get( \"handicap\", \"100\", CVAR_USERINFO | CVAR_ARCHIVE );\n\tCvar_Get( \"sex\", \"male\", CVAR_USERINFO | CVAR_ARCHIVE );\n\tCvar_Get( \"cl_anonymous\", \"0\", CVAR_USERINFO | CVAR_ARCHIVE );\n\n\tCvar_Get( \"password\", \"\", CVAR_USERINFO );\n\tCvar_Get( \"cg_predictItems\", \"1\", CVAR_USERINFO | CVAR_ARCHIVE );\n\n#ifdef USE_MUMBLE\n\tcl_useMumble = Cvar_Get (\"cl_useMumble\", \"0\", CVAR_ARCHIVE | CVAR_LATCH);\n\tcl_mumbleScale = Cvar_Get (\"cl_mumbleScale\", \"0.0254\", CVAR_ARCHIVE);\n#endif\n\n#ifdef USE_VOIP\n\tcl_voipSend = Cvar_Get (\"cl_voipSend\", \"0\", 0);\n\tcl_voipSendTarget = Cvar_Get (\"cl_voipSendTarget\", \"spatial\", 0);\n\tcl_voipGainDuringCapture = Cvar_Get (\"cl_voipGainDuringCapture\", \"0.2\", CVAR_ARCHIVE);\n\tcl_voipCaptureMult = Cvar_Get (\"cl_voipCaptureMult\", \"2.0\", CVAR_ARCHIVE);\n\tcl_voipUseVAD = Cvar_Get (\"cl_voipUseVAD\", \"0\", CVAR_ARCHIVE);\n\tcl_voipVADThreshold = Cvar_Get (\"cl_voipVADThreshold\", \"0.25\", CVAR_ARCHIVE);\n\tcl_voipShowMeter = Cvar_Get (\"cl_voipShowMeter\", \"1\", CVAR_ARCHIVE);\n\n\tcl_voip = Cvar_Get (\"cl_voip\", \"1\", CVAR_ARCHIVE);\n\tCvar_CheckRange( cl_voip, 0, 1, qtrue );\n\tcl_voipProtocol = Cvar_Get (\"cl_voipProtocol\", cl_voip->integer ? \"opus\" : \"\", CVAR_USERINFO | CVAR_ROM);\n#endif\n\n//----(SA) added\n\tCvar_Get( \"cg_autoactivate\", \"1\", CVAR_USERINFO | CVAR_ARCHIVE );\n//----(SA) end\n\n\t// cgame might not be initialized before menu is used\n\tCvar_Get( \"cg_viewsize\", \"100\", CVAR_ARCHIVE );\n\t// Make sure cg_stereoSeparation is zero as that variable is deprecated and should not be used anymore.\n\tCvar_Get (\"cg_stereoSeparation\", \"0\", CVAR_ROM);\n\n\tCvar_Get( \"cg_autoReload\", \"1\", CVAR_ARCHIVE | CVAR_USERINFO );\n\n\tcl_missionStats = Cvar_Get( \"g_missionStats\", \"0\", CVAR_ROM );\n\tcl_waitForFire = Cvar_Get( \"cl_waitForFire\", \"0\", CVAR_ROM );\n\n\t// NERVE - SMF - localization\n\tcl_language = Cvar_Get( \"cl_language\", \"0\", CVAR_ARCHIVE );\n\tcl_debugTranslation = Cvar_Get( \"cl_debugTranslation\", \"0\", 0 );\n\t// -NERVE - SMF\n\n\t// DHM - Nerve :: Auto-update\n\tcl_updateavailable = Cvar_Get( \"cl_updateavailable\", \"0\", CVAR_ROM );\n\tcl_updatefiles = Cvar_Get( \"cl_updatefiles\", \"\", CVAR_ROM );\n\n\tQ_strncpyz( cls.autoupdateServerNames[0], AUTOUPDATE_SERVER1_NAME, MAX_QPATH );\n\tQ_strncpyz( cls.autoupdateServerNames[1], AUTOUPDATE_SERVER2_NAME, MAX_QPATH );\n\tQ_strncpyz( cls.autoupdateServerNames[2], AUTOUPDATE_SERVER3_NAME, MAX_QPATH );\n\tQ_strncpyz( cls.autoupdateServerNames[3], AUTOUPDATE_SERVER4_NAME, MAX_QPATH );\n\tQ_strncpyz( cls.autoupdateServerNames[4], AUTOUPDATE_SERVER5_NAME, MAX_QPATH );\n\t// DHM - Nerve\n\n\t//\n\t// register our commands\n\t//\n\tCmd_AddCommand( \"cmd\", CL_ForwardToServer_f );\n\tCmd_AddCommand( \"configstrings\", CL_Configstrings_f );\n\tCmd_AddCommand( \"clientinfo\", CL_Clientinfo_f );\n\tCmd_AddCommand( \"snd_restart\", CL_Snd_Restart_f );\n\tCmd_AddCommand( \"vid_restart\", CL_Vid_Restart_f );\n\tCmd_AddCommand( \"ui_restart\", CL_UI_Restart_f );          // NERVE - SMF\n\tCmd_AddCommand( \"disconnect\", CL_Disconnect_f );\n\tCmd_AddCommand( \"record\", CL_Record_f );\n\tCmd_AddCommand( \"demo\", CL_PlayDemo_f );\n\tCmd_SetCommandCompletionFunc( \"demo\", CL_CompleteDemoName );\n\tCmd_AddCommand( \"cinematic\", CL_PlayCinematic_f );\n\tCmd_AddCommand( \"stoprecord\", CL_StopRecord_f );\n\tCmd_AddCommand( \"connect\", CL_Connect_f );\n\tCmd_AddCommand( \"reconnect\", CL_Reconnect_f );\n\tCmd_AddCommand( \"localservers\", CL_LocalServers_f );\n\tCmd_AddCommand( \"globalservers\", CL_GlobalServers_f );\n\tCmd_AddCommand( \"rcon\", CL_Rcon_f );\n\tCmd_SetCommandCompletionFunc( \"rcon\", CL_CompleteRcon );\n\tCmd_AddCommand( \"ping\", CL_Ping_f );\n\tCmd_AddCommand( \"serverstatus\", CL_ServerStatus_f );\n\tCmd_AddCommand( \"showip\", CL_ShowIP_f );\n\tCmd_AddCommand( \"fs_openedList\", CL_OpenedPK3List_f );\n\tCmd_AddCommand( \"fs_referencedList\", CL_ReferencedPK3List_f );\n\tCmd_AddCommand (\"video\", CL_Video_f );\n\tCmd_AddCommand (\"stopvideo\", CL_StopVideo_f );\n\n\t// Ridah, startup-caching system\n\tCmd_AddCommand( \"cache_startgather\", CL_Cache_StartGather_f );\n\tCmd_AddCommand( \"cache_usedfile\", CL_Cache_UsedFile_f );\n\tCmd_AddCommand( \"cache_setindex\", CL_Cache_SetIndex_f );\n\tCmd_AddCommand( \"cache_mapchange\", CL_Cache_MapChange_f );\n\tCmd_AddCommand( \"cache_endgather\", CL_Cache_EndGather_f );\n\n\tCmd_AddCommand( \"updatehunkusage\", CL_UpdateLevelHunkUsage );\n\tCmd_AddCommand( \"updatescreen\", SCR_UpdateScreen );\n\t// done.\n\tCmd_AddCommand( \"SaveTranslations\", CL_SaveTranslations_f );     // NERVE - SMF - localization\n\tCmd_AddCommand( \"SaveNewTranslations\", CL_SaveNewTranslations_f );   // NERVE - SMF - localization\n\tCmd_AddCommand( \"LoadTranslations\", CL_LoadTranslations_f );     // NERVE - SMF - localization\n\t// NERVE - SMF - don't do this in multiplayer\n\t// RF, add this command so clients can't bind a key to send client damage commands to the server\n//\tCmd_AddCommand( \"cld\", CL_ClientDamageCommand );\n\n\tCmd_AddCommand( \"startSingleplayer\", CL_startSingleplayer_f );      // NERVE - SMF\n\n\tCmd_AddCommand( \"setRecommended\", CL_SetRecommended_f );\n\n\tCL_InitRef();\n\n\tSCR_Init();\n\n//\tCbuf_Execute();\n\n\tCvar_Set( \"cl_running\", \"1\" );\n\n\t// DHM - Nerve\n\tautoupdateChecked = qfalse;\n\tautoupdateStarted = qfalse;\n\n\tCL_InitTranslation();   // NERVE - SMF - localization\n\n\tCL_GenerateQKey();\n\tCL_UpdateGUID( NULL, 0 );\n\n\tCom_Printf( \"----- Client Initialization Complete -----\\n\" );\n}", "target": 2, "idx": 10389}
{"commit_id": "44491a4b0fdb2d2bd87a151fd169da3343954edd", "project": "WebAssembly/wabt", "func": "Token WastLexer::GetToken() {\n  while (true) {\n    token_start_ = cursor_;\n    switch (PeekChar()) {\n      case kEof:\n        return BareToken(TokenType::Eof);\n\n      case '(':\n        if (MatchString(\"(;\")) {\n          if (ReadBlockComment()) {\n            continue;\n          }\n          return BareToken(TokenType::Eof);\n        } else if (MatchString(\"(@\")) {\n          GetIdChars();\n          // offset=2 to skip the \"(@\" prefix\n          return TextToken(TokenType::LparAnn, 2);\n        } else {\n          ReadChar();\n          return BareToken(TokenType::Lpar);\n        }\n        break;\n\n      case ')':\n        ReadChar();\n        return BareToken(TokenType::Rpar);\n\n      case ';':\n        if (MatchString(\";;\")) {\n          if (ReadLineComment()) {\n            continue;\n          }\n          return BareToken(TokenType::Eof);\n        } else {\n          ReadChar();\n          ERROR(\"unexpected char\");\n          continue;\n        }\n        break;\n\n      case ' ':\n      case '\\t':\n      case '\\r':\n      case '\\n':\n        ReadWhitespace();\n        continue;\n\n      case '\"':\n        return GetStringToken();\n\n      case '+':\n      case '-':\n        ReadChar();\n        switch (PeekChar()) {\n          case 'i':\n            return GetInfToken();\n\n          case 'n':\n            return GetNanToken();\n\n          case '0':\n            return MatchString(\"0x\") ? GetHexNumberToken(TokenType::Int)\n                                     : GetNumberToken(TokenType::Int);\n          case '1':\n          case '2':\n          case '3':\n          case '4':\n          case '5':\n          case '6':\n          case '7':\n          case '8':\n          case '9':\n            return GetNumberToken(TokenType::Int);\n\n          default:\n            return GetReservedToken();\n        }\n        break;\n\n      case '0':\n        return MatchString(\"0x\") ? GetHexNumberToken(TokenType::Nat)\n                                 : GetNumberToken(TokenType::Nat);\n\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n        return GetNumberToken(TokenType::Nat);\n\n      case '$':\n        return GetIdChars();  // Initial $ is idchar, so this produces id token\n\n      case 'a':\n        return GetNameEqNumToken(\"align=\", TokenType::AlignEqNat);\n\n      case 'i':\n        return GetInfToken();\n\n      case 'n':\n        return GetNanToken();\n\n      case 'o':\n        return GetNameEqNumToken(\"offset=\", TokenType::OffsetEqNat);\n\n      default:\n        if (IsKeyword(PeekChar())) {\n          return GetKeywordToken();\n        } else if (IsIdChar(PeekChar())) {\n          return GetReservedToken();\n        } else {\n          ReadChar();\n          ERROR(\"unexpected char\");\n          continue;\n        }\n    }\n  }\n}", "target": 1, "idx": 10390}
{"commit_id": "d4305208955c5cdd9fe96dfa61e7c1e14e176a14", "project": "muttmua/mutt", "func": "ADDRESS *rfc822_parse_adrlist (ADDRESS *top, const char *s)\n{\n  int ws_pending, nl, in_group = 0;\n#ifdef EXACT_ADDRESS\n  const char *begin;\n#endif\n  const char *ps;\n  char comment[LONG_STRING], phrase[LONG_STRING];\n  size_t phraselen = 0, commentlen = 0;\n  ADDRESS *cur, *last = NULL;\n\n  RFC822Error = 0;\n\n  last = top;\n  while (last && last->next)\n    last = last->next;\n\n  ws_pending = is_email_wsp (*s);\n  if ((nl = mutt_strlen (s)))\n    nl = s[nl - 1] == '\\n';\n\n  s = skip_email_wsp(s);\n#ifdef EXACT_ADDRESS\n  begin = s;\n#endif\n  while (*s)\n  {\n    if (*s == ',')\n    {\n      if (phraselen)\n      {\n\tterminate_buffer (phrase, phraselen);\n\tadd_addrspec (&top, &last, phrase, comment, &commentlen, sizeof (comment) - 1);\n      }\n      else if (commentlen && last && !last->personal)\n      {\n\tterminate_buffer (comment, commentlen);\n\tlast->personal = safe_strdup (comment);\n      }\n\n#ifdef EXACT_ADDRESS\n      if (last && !last->val)\n\tlast->val = mutt_substrdup (begin, s);\n#endif\n      commentlen = 0;\n      phraselen = 0;\n      s++;\n#ifdef EXACT_ADDRESS\n      begin = skip_email_wsp(s);\n#endif\n    }\n    else if (*s == '(')\n    {\n      if (commentlen && commentlen < sizeof (comment) - 1)\n\tcomment[commentlen++] = ' ';\n      if ((ps = next_token (s, comment, &commentlen, sizeof (comment) - 1)) == NULL)\n      {\n\trfc822_free_address (&top);\n\treturn NULL;\n      }\n      s = ps;\n    }\n    else if (*s == '\"')\n    {\n      if (phraselen && phraselen < sizeof (phrase) - 1)\n        phrase[phraselen++] = ' ';\n      if ((ps = parse_quote (s + 1, phrase, &phraselen, sizeof (phrase) - 1)) == NULL)\n      {\n        rfc822_free_address (&top);\n        return NULL;\n      }\n      s = ps;\n    }\n    else if (*s == '[')\n    {\n      if (phraselen && phraselen < sizeof (phrase) - 1 && ws_pending)\n\tphrase[phraselen++] = ' ';\n      if (phraselen < sizeof (phrase) - 1)\n        phrase[phraselen++] = '[';\n      if ((ps = parse_literal (s + 1, phrase, &phraselen, sizeof (phrase) - 1)) == NULL)\n      {\n        rfc822_free_address (&top);\n        return NULL;\n      }\n      s = ps;\n    }\n    else if (*s == ':')\n    {\n      cur = rfc822_new_address ();\n      terminate_buffer (phrase, phraselen);\n      cur->mailbox = safe_strdup (phrase);\n      cur->group = 1;\n      in_group = 1;\n\n      if (last)\n\tlast->next = cur;\n      else\n\ttop = cur;\n      last = cur;\n\n#ifdef EXACT_ADDRESS\n      last->val = mutt_substrdup (begin, s);\n#endif\n\n      phraselen = 0;\n      commentlen = 0;\n      s++;\n#ifdef EXACT_ADDRESS\n      begin = skip_email_wsp(s);\n#endif\n    }\n    else if (*s == ';')\n    {\n      if (phraselen)\n      {\n\tterminate_buffer (phrase, phraselen);\n\tadd_addrspec (&top, &last, phrase, comment, &commentlen, sizeof (comment) - 1);\n      }\n      else if (commentlen && last && !last->personal)\n      {\n\tterminate_buffer (comment, commentlen);\n\tlast->personal = safe_strdup (comment);\n      }\n#ifdef EXACT_ADDRESS\n      if (last && !last->val)\n\tlast->val = mutt_substrdup (begin, s);\n#endif\n\n      /* add group terminator */\n      if (last && in_group)\n      {\n\tlast->next = rfc822_new_address ();\n\tlast = last->next;\n      }\n      in_group = 0;\n\n      phraselen = 0;\n      commentlen = 0;\n#ifdef EXACT_ADDRESS\n      begin = s;\n#endif\n      s++;\n    }\n    else if (*s == '<')\n    {\n      terminate_buffer (phrase, phraselen);\n      cur = rfc822_new_address ();\n      if (phraselen)\n\tcur->personal = safe_strdup (phrase);\n      if ((ps = parse_route_addr (s + 1, comment, &commentlen, sizeof (comment) - 1, cur)) == NULL)\n      {\n\trfc822_free_address (&top);\n\trfc822_free_address (&cur);\n\treturn NULL;\n      }\n\n      if (last)\n\tlast->next = cur;\n      else\n\ttop = cur;\n      last = cur;\n\n      phraselen = 0;\n      commentlen = 0;\n      s = ps;\n    }\n    else\n    {\n      if (phraselen && phraselen < sizeof (phrase) - 1 && ws_pending)\n\tphrase[phraselen++] = ' ';\n      if ((ps = next_token (s, phrase, &phraselen, sizeof (phrase) - 1)) == NULL)\n      {\n\trfc822_free_address (&top);\n\treturn NULL;\n      }\n      s = ps;\n    }\n    ws_pending = is_email_wsp(*s);\n    s = skip_email_wsp(s);\n  }\n\n  if (phraselen)\n  {\n    terminate_buffer (phrase, phraselen);\n    terminate_buffer (comment, commentlen);\n    add_addrspec (&top, &last, phrase, comment, &commentlen, sizeof (comment) - 1);\n  }\n  else if (commentlen && last && !last->personal)\n  {\n    terminate_buffer (comment, commentlen);\n    last->personal = safe_strdup (comment);\n  }\n#ifdef EXACT_ADDRESS\n  if (last && !last->val)\n    last->val = mutt_substrdup (begin, s - nl < begin ? begin : s - nl);\n#endif\n\n  /* add group terminator, if it was left off */\n  if (last && in_group)\n    last->next = rfc822_new_address ();\n\n  return top;\n}", "target": 1, "idx": 10391}
{"commit_id": "dea460d86957bf1425a8a1572626099ac3f165a8", "project": "xen-project/xen", "func": "int guest_remove_page(struct domain *d, unsigned long gmfn)\n{\n    struct page_info *page;\n#ifdef CONFIG_X86\n    p2m_type_t p2mt;\n#endif\n    mfn_t mfn;\n    bool *dont_flush_p, dont_flush;\n    int rc;\n\n#ifdef CONFIG_X86\n    mfn = get_gfn_query(d, gmfn, &p2mt);\n    if ( unlikely(p2mt == p2m_invalid) || unlikely(p2mt == p2m_mmio_dm) )\n    {\n        put_gfn(d, gmfn);\n\n        return -ENOENT;\n    }\n\n    if ( unlikely(p2m_is_paging(p2mt)) )\n    {\n        /*\n         * If the page hasn't yet been paged out, there is an\n         * actual page that needs to be released.\n         */\n        if ( p2mt == p2m_ram_paging_out )\n        {\n            ASSERT(mfn_valid(mfn));\n            goto obtain_page;\n        }\n\n        rc = guest_physmap_remove_page(d, _gfn(gmfn), mfn, 0);\n        if ( rc )\n            goto out_put_gfn;\n\n        put_gfn(d, gmfn);\n\n        p2m_mem_paging_drop_page(d, _gfn(gmfn), p2mt);\n\n        return 0;\n    }\n    if ( p2mt == p2m_mmio_direct )\n    {\n        rc = clear_mmio_p2m_entry(d, gmfn, mfn, PAGE_ORDER_4K);\n        goto out_put_gfn;\n    }\n#else\n    mfn = gfn_to_mfn(d, _gfn(gmfn));\n#endif\n    if ( unlikely(!mfn_valid(mfn)) )\n    {\n#ifdef CONFIG_X86\n        put_gfn(d, gmfn);\n#endif\n        gdprintk(XENLOG_INFO, \"Domain %u page number %lx invalid\\n\",\n                d->domain_id, gmfn);\n\n        return -EINVAL;\n    }\n            \n#ifdef CONFIG_X86\n    if ( p2m_is_shared(p2mt) )\n    {\n        /*\n         * Unshare the page, bail out on error. We unshare because we\n         * might be the only one using this shared page, and we need to\n         * trigger proper cleanup. Once done, this is like any other page.\n         */\n        rc = mem_sharing_unshare_page(d, gmfn);\n        if ( rc )\n        {\n            mem_sharing_notify_enomem(d, gmfn, false);\n            goto out_put_gfn;\n        }\n        /* Maybe the mfn changed */\n        mfn = get_gfn_query_unlocked(d, gmfn, &p2mt);\n        ASSERT(!p2m_is_shared(p2mt));\n    }\n#endif /* CONFIG_X86 */\n\n obtain_page: __maybe_unused;\n    page = mfn_to_page(mfn);\n    if ( unlikely(!get_page(page, d)) )\n    {\n#ifdef CONFIG_X86\n        put_gfn(d, gmfn);\n        if ( !p2m_is_paging(p2mt) )\n#endif\n            gdprintk(XENLOG_INFO, \"Bad page free for Dom%u GFN %lx\\n\",\n                     d->domain_id, gmfn);\n\n        return -ENXIO;\n    }\n\n    /*\n     * Since we're likely to free the page below, we need to suspend\n     * xenmem_add_to_physmap()'s suppressing of IOMMU TLB flushes.\n     */\n    dont_flush_p = &this_cpu(iommu_dont_flush_iotlb);\n    dont_flush = *dont_flush_p;\n    *dont_flush_p = false;\n\n    rc = guest_physmap_remove_page(d, _gfn(gmfn), mfn, 0);\n\n    *dont_flush_p = dont_flush;\n\n    /*\n     * With the lack of an IOMMU on some platforms, domains with DMA-capable\n     * device must retrieve the same pfn when the hypercall populate_physmap\n     * is called.\n     *\n     * For this purpose (and to match populate_physmap() behavior), the page\n     * is kept allocated.\n     */\n    if ( !rc && !is_domain_direct_mapped(d) )\n        put_page_alloc_ref(page);\n\n    put_page(page);\n\n#ifdef CONFIG_X86\n out_put_gfn:\n    put_gfn(d, gmfn);\n#endif\n\n    /*\n     * Filter out -ENOENT return values that aren't a result of an empty p2m\n     * entry.\n     */\n    return rc != -ENOENT ? rc : -EINVAL;\n}", "target": 2, "idx": 10392}
{"commit_id": "863d31ae775d56b785dc5b0105b6d251515d81d5", "project": "bash", "func": "static char *\nstub_charset ()\n{\n  char *locale, *s, *t;\n\n  locale = get_locale_var (\"LC_CTYPE\");\n  if (locale == 0 || *locale == 0)\n    {\n      strcpy (charsetbuf, \"ASCII\");\n      return charsetbuf;\n    }\n  s = strrchr (locale, '.');\n  if (s)\n    {\n      strcpy (charsetbuf, s+1);\n      t = strchr (charsetbuf, '@');\n      if (t)\n\t*t = 0;\n      return charsetbuf;\n    }\n  strcpy (charsetbuf, locale);\n  return charsetbuf;\n}", "target": 2, "idx": 10393}
{"commit_id": "afb9ff7982971aba6e42472de0db4c1bedfc641b", "project": "wireshark", "func": "static void\nmbim_dissect_phonebook_read_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gint offset)\n{\n    proto_tree *subtree;\n    gint base_offset;\n    guint32 i, element_count;\n    wmem_array_t *pair_list;\n    struct mbim_pair_list pair_list_item, *p_pair_list_item;\n\n    base_offset = offset;\n    proto_tree_add_item_ret_uint(tree, hf_mbim_phonebook_read_info_element_count, tvb, offset, 4, ENC_LITTLE_ENDIAN, &element_count);\n    offset += 4;\n    if (element_count) {\n        pair_list = wmem_array_new(wmem_packet_scope(), sizeof(struct mbim_pair_list));\n        subtree = proto_tree_add_subtree(tree, tvb, offset, 8*element_count, ett_mbim_pair_list, NULL, \"Phonebook Ref List\");\n        for (i = 0; i < element_count; i++) {\n            proto_tree_add_item_ret_uint(subtree, hf_mbim_phonebook_read_info_phonebook_offset,\n                                tvb, offset, 4, ENC_LITTLE_ENDIAN, &pair_list_item.offset);\n            offset += 4;\n            proto_tree_add_item_ret_uint(subtree, hf_mbim_phonebook_read_info_phonebook_size,\n                                tvb, offset, 4, ENC_LITTLE_ENDIAN, &pair_list_item.size);\n            offset += 4;\n            wmem_array_append_one(pair_list, pair_list_item);\n        }\n        for (i = 0; i < element_count; i++) {\n            p_pair_list_item = (struct mbim_pair_list*)wmem_array_index(pair_list, i);\n            if (p_pair_list_item->offset && p_pair_list_item->size) {\n                subtree = proto_tree_add_subtree_format(tree, tvb, base_offset + p_pair_list_item->offset,\n                                         p_pair_list_item->size, ett_mbim_pair_list, NULL, \"Phonebook Element #%u\", i+1);\n                mbim_dissect_phonebook_entry(tvb, pinfo, subtree, base_offset + p_pair_list_item->offset);\n            }\n        }\n    }\n}", "target": 2, "idx": 10394}
{"commit_id": "5777a3742d88ff1c0ebc626ceb4fd47f9b3dc6d5", "project": "xen-project/xen", "func": "static int xenmem_add_to_physmap_batch(struct domain *d,\n                                       struct xen_add_to_physmap_batch *xatpb,\n                                       unsigned int extent)\n{\n    union add_to_physmap_extra extra = {};\n\n    if ( unlikely(xatpb->size < extent) )\n        return -EILSEQ;\n\n    if ( unlikely(xatpb->size == extent) )\n        return extent ? -EILSEQ : 0;\n\n    if ( !guest_handle_subrange_okay(xatpb->idxs, extent, xatpb->size - 1) ||\n         !guest_handle_subrange_okay(xatpb->gpfns, extent, xatpb->size - 1) ||\n         !guest_handle_subrange_okay(xatpb->errs, extent, xatpb->size - 1) )\n        return -EFAULT;\n\n    switch ( xatpb->space )\n    {\n    case XENMAPSPACE_dev_mmio:\n        /* res0 is reserved for future use. */\n        if ( xatpb->u.res0 )\n            return -EOPNOTSUPP;\n        break;\n\n    case XENMAPSPACE_gmfn_foreign:\n        extra.foreign_domid = xatpb->u.foreign_domid;\n        break;\n    }\n\n    while ( xatpb->size > extent )\n    {\n        xen_ulong_t idx;\n        xen_pfn_t gpfn;\n        int rc;\n\n        if ( unlikely(__copy_from_guest_offset(&idx, xatpb->idxs,\n                                               extent, 1)) ||\n             unlikely(__copy_from_guest_offset(&gpfn, xatpb->gpfns,\n                                               extent, 1)) )\n            return -EFAULT;\n\n        rc = xenmem_add_to_physmap_one(d, xatpb->space, extra,\n                                       idx, _gfn(gpfn));\n\n        if ( unlikely(__copy_to_guest_offset(xatpb->errs, extent, &rc, 1)) )\n            return -EFAULT;\n\n        /* Check for continuation if it's not the last iteration. */\n        if ( xatpb->size > ++extent && hypercall_preempt_check() )\n            return extent;\n    }\n\n    return 0;\n}", "target": 2, "idx": 10395}
{"commit_id": "e139b87835994d007fbd64eead6c1455d7b8cf4e", "project": "gpg/boa", "func": "char *strstr(char *s1, char *s2)\n{                               /* from libiberty */\n    char *p;\n    int len = strlen(s2);\n\n    if (*s2 == '\\0')            /* everything matches empty string */\n        return s1;\n    for (p = s1; (p = strchr(p, *s2)) != NULL; p++) {\n        if (strncmp(p, s2, len) == 0)\n            return (p);\n    }\n    return NULL;\n}", "target": 3, "idx": 10396}
{"commit_id": "d3ae9c19125c8704b4866381f7a064ca2cbdc006", "project": "ImageMagick", "func": "static void SVGEndElement(void *context,const xmlChar *name)\n{\n  SVGInfo\n    *svg_info;\n\n  /*\n    Called when the end of an element has been detected.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.endElement(%s)\",name);\n  svg_info=(SVGInfo *) context;\n  if (strchr((char *) name,':') != (char *) NULL)\n    {\n      /*\n        Skip over namespace.\n      */\n      for ( ; *name != ':'; name++) ;\n      name++;\n    }\n  switch (*name)\n  {\n    case 'C':\n    case 'c':\n    {\n      if (LocaleCompare((const char *) name,\"circle\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"class \\\"circle\\\"\\n\");\n          (void) FormatLocaleFile(svg_info->file,\"circle %g,%g %g,%g\\n\",\n            svg_info->element.cx,svg_info->element.cy,svg_info->element.cx,\n            svg_info->element.cy+svg_info->element.minor);\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"clipPath\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop clip-path\\n\");\n          break;\n        }\n      break;\n    }\n    case 'D':\n    case 'd':\n    {\n      if (LocaleCompare((const char *) name,\"defs\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop defs\\n\");\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"desc\") == 0)\n        {\n          register char\n            *p;\n\n          if (*svg_info->text == '\\0')\n            break;\n          (void) fputc('#',svg_info->file);\n          for (p=svg_info->text; *p != '\\0'; p++)\n          {\n            (void) fputc(*p,svg_info->file);\n            if (*p == '\\n')\n              (void) fputc('#',svg_info->file);\n          }\n          (void) fputc('\\n',svg_info->file);\n          *svg_info->text='\\0';\n          break;\n        }\n      break;\n    }\n    case 'E':\n    case 'e':\n    {\n      if (LocaleCompare((const char *) name,\"ellipse\") == 0)\n        {\n          double\n            angle;\n\n          (void) FormatLocaleFile(svg_info->file,\"class \\\"ellipse\\\"\\n\");\n          angle=svg_info->element.angle;\n          (void) FormatLocaleFile(svg_info->file,\"ellipse %g,%g %g,%g 0,360\\n\",\n            svg_info->element.cx,svg_info->element.cy,\n            angle == 0.0 ? svg_info->element.major : svg_info->element.minor,\n            angle == 0.0 ? svg_info->element.minor : svg_info->element.major);\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      break;\n    }\n    case 'F':\n    case 'f':\n    {\n      if (LocaleCompare((const char *) name,\"foreignObject\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      break;\n    }\n    case 'G':\n    case 'g':\n    {\n      if (LocaleCompare((const char *) name,\"g\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      break;\n    }\n    case 'I':\n    case 'i':\n    {\n      if (LocaleCompare((const char *) name,\"image\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\n            \"image Over %g,%g %g,%g \\\"%s\\\"\\n\",svg_info->bounds.x,\n            svg_info->bounds.y,svg_info->bounds.width,svg_info->bounds.height,\n            svg_info->url);\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      break;\n    }\n    case 'L':\n    case 'l':\n    {\n      if (LocaleCompare((const char *) name,\"line\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"class \\\"line\\\"\\n\");\n          (void) FormatLocaleFile(svg_info->file,\"line %g,%g %g,%g\\n\",\n            svg_info->segment.x1,svg_info->segment.y1,svg_info->segment.x2,\n            svg_info->segment.y2);\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"linearGradient\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop gradient\\n\");\n          break;\n        }\n      break;\n    }\n    case 'M':\n    case 'm':\n    {\n      if (LocaleCompare((const char *) name,\"mask\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop mask\\n\");\n          break;\n        }\n      break;\n    }\n    case 'P':\n    case 'p':\n    {\n      if (LocaleCompare((const char *) name,\"pattern\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop pattern\\n\");\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"path\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"class \\\"path\\\"\\n\");\n          (void) FormatLocaleFile(svg_info->file,\"path \\\"%s\\\"\\n\",\n            svg_info->vertices);\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"polygon\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"class \\\"polygon\\\"\\n\");\n          (void) FormatLocaleFile(svg_info->file,\"polygon %s\\n\",\n            svg_info->vertices);\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"polyline\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"class \\\"polyline\\\"\\n\");\n          (void) FormatLocaleFile(svg_info->file,\"polyline %s\\n\",\n            svg_info->vertices);\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      break;\n    }\n    case 'R':\n    case 'r':\n    {\n      if (LocaleCompare((const char *) name,\"radialGradient\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop gradient\\n\");\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"rect\") == 0)\n        {\n          if ((svg_info->radius.x == 0.0) && (svg_info->radius.y == 0.0))\n            {\n              (void) FormatLocaleFile(svg_info->file,\"class \\\"rect\\\"\\n\");\n              if ((fabs(svg_info->bounds.width-1.0) < MagickEpsilon) &&\n                  (fabs(svg_info->bounds.height-1.0) < MagickEpsilon))\n                (void) FormatLocaleFile(svg_info->file,\"point %g,%g\\n\",\n                  svg_info->bounds.x,svg_info->bounds.y);\n              else\n                (void) FormatLocaleFile(svg_info->file,\n                  \"rectangle %g,%g %g,%g\\n\",svg_info->bounds.x,\n                  svg_info->bounds.y,svg_info->bounds.x+svg_info->bounds.width,\n                  svg_info->bounds.y+svg_info->bounds.height);\n              (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n              break;\n            }\n          if (svg_info->radius.x == 0.0)\n            svg_info->radius.x=svg_info->radius.y;\n          if (svg_info->radius.y == 0.0)\n            svg_info->radius.y=svg_info->radius.x;\n          (void) FormatLocaleFile(svg_info->file,\n            \"roundRectangle %g,%g %g,%g %g,%g\\n\",\n            svg_info->bounds.x,svg_info->bounds.y,svg_info->bounds.x+\n            svg_info->bounds.width,svg_info->bounds.y+svg_info->bounds.height,\n            svg_info->radius.x,svg_info->radius.y);\n          svg_info->radius.x=0.0;\n          svg_info->radius.y=0.0;\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      break;\n    }\n    case 'S':\n    case 's':\n    {\n      if (LocaleCompare((const char *) name,\"stop\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"stop-color \\\"%s\\\" %s\\n\",\n            svg_info->stop_color,svg_info->offset);\n          break;\n        }\n      if (LocaleCompare((char *) name,\"style\") == 0)\n        {\n          char\n            *keyword,\n            **tokens,\n            *value;\n\n          register ssize_t\n            j;\n\n          size_t\n            number_tokens;\n\n          /*\n            Find style definitions in svg_info->text.\n          */\n          tokens=SVGKeyValuePairs(context,'{','}',svg_info->text,\n            &number_tokens);\n          if (tokens == (char **) NULL)\n            break;\n          for (j=0; j < (ssize_t) (number_tokens-1); j+=2)\n          {\n            keyword=(char *) tokens[j];\n            value=(char *) tokens[j+1];\n            (void) FormatLocaleFile(svg_info->file,\"push class \\\"%s\\\"\\n\",\n              *keyword == '.' ? keyword+1 : keyword);\n            SVGProcessStyleElement(context,name,value);\n            (void) FormatLocaleFile(svg_info->file,\"pop class\\n\");\n          }\n          for (j=0; tokens[j] != (char *) NULL; j++)\n            tokens[j]=DestroyString(tokens[j]);\n          tokens=(char **) RelinquishMagickMemory(tokens);\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"svg\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          svg_info->svgDepth--;\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"symbol\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop symbol\\n\");\n          break;\n        }\n      break;\n    }\n    case 'T':\n    case 't':\n    {\n      if (LocaleCompare((const char *) name,\"text\") == 0)\n        {\n          if (*svg_info->text != '\\0')\n            {\n              char\n                *text;\n\n              SVGStripString(MagickTrue,svg_info->text);\n              text=EscapeString(svg_info->text,'\\\"');\n              (void) FormatLocaleFile(svg_info->file,\"text 0,0 \\\"%s\\\"\\n\",text);\n              text=DestroyString(text);\n              *svg_info->text='\\0';\n              svg_info->center.x=0.0;\n              svg_info->center.y=0.0;\n            }\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"tspan\") == 0)\n        {\n          if (*svg_info->text != '\\0')\n            {\n              char\n                *text;\n\n              (void) FormatLocaleFile(svg_info->file,\"class \\\"tspan\\\"\\n\");\n              text=EscapeString(svg_info->text,'\\\"');\n              (void) FormatLocaleFile(svg_info->file,\"text %g,%g \\\"%s\\\"\\n\",\n                svg_info->bounds.x-svg_info->center.x,svg_info->bounds.y-\n                svg_info->center.y,text);\n              text=DestroyString(text);\n              *svg_info->text='\\0';\n            }\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"title\") == 0)\n        {\n          if (*svg_info->text == '\\0')\n            break;\n          (void) CloneString(&svg_info->title,svg_info->text);\n          *svg_info->text='\\0';\n          break;\n        }\n      break;\n    }\n    case 'U':\n    case 'u':\n    {\n      if (LocaleCompare((char *) name,\"use\") == 0)\n        {\n          if ((svg_info->bounds.x != 0.0) || (svg_info->bounds.y != 0.0))\n            (void) FormatLocaleFile(svg_info->file,\"translate %g,%g\\n\",\n              svg_info->bounds.x,svg_info->bounds.y);\n          (void) FormatLocaleFile(svg_info->file,\"use \\\"url(%s)\\\"\\n\",\n            svg_info->url);\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      break;\n    }\n    default:\n      break;\n  }\n  *svg_info->text='\\0';\n  (void) memset(&svg_info->element,0,sizeof(svg_info->element));\n  (void) memset(&svg_info->segment,0,sizeof(svg_info->segment));\n  svg_info->n--;\n}", "target": 1, "idx": 10397}
{"commit_id": "a54ee9431e4632469786c013b9714265e1183457", "project": "openssh/openssh-portable", "func": "static int\nuserauth_passwd(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = (Authctxt *)ssh->authctxt;\n\tauthctxt->is_trivial_auth = 0;\n\tchar *password, *prompt = NULL;\n\tconst char *host = options.host_key_alias ?  options.host_key_alias :\n\t    authctxt->host;\n\tint r;\n\n\tif (authctxt->attempt_passwd++ >= options.number_of_password_prompts)\n\t\treturn 0;\n\n\tif (authctxt->attempt_passwd != 1)\n\t\terror(\"Permission denied, please try again.\");\n\n\txasprintf(&prompt, \"%s@%s's password: \", authctxt->server_user, host);\n\tpassword = read_passphrase(prompt, 0);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->server_user)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->service)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->method->name)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, 0)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, password)) != 0 ||\n\t    (r = sshpkt_add_padding(ssh, 64)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal_fr(r, \"send packet\");\n\n\tfree(prompt);\n\tif (password != NULL)\n\t\tfreezero(password, strlen(password));\n\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ,\n\t    &input_userauth_passwd_changereq);\n\treturn 1;\n}", "target": 0, "idx": 10398}
{"commit_id": "ececa12b2c4c8e4433e4f9be83f5c668ae36fe08", "project": "xen-project/xen", "func": "int vcpu_destroy_pagetables(struct vcpu *v)\n{\n    unsigned long mfn = pagetable_get_pfn(v->arch.guest_table);\n    struct page_info *page = NULL;\n    int rc = put_old_guest_table(v);\n    bool put_guest_table_user = false;\n\n    if ( rc )\n        return rc;\n\n    v->arch.cr3 = 0;\n\n    /*\n     * Get the top-level guest page; either the guest_table itself, for\n     * 64-bit, or the top-level l4 entry for 32-bit.  Either way, remove\n     * the reference to that page.\n     */\n    if ( is_pv_32bit_vcpu(v) )\n    {\n        l4_pgentry_t *l4tab = map_domain_page(_mfn(mfn));\n\n        mfn = l4e_get_pfn(*l4tab);\n        l4e_write(l4tab, l4e_empty());\n        unmap_domain_page(l4tab);\n    }\n    else\n    {\n        v->arch.guest_table = pagetable_null();\n        put_guest_table_user = true;\n    }\n\n    /* Free that page if non-zero */\n    do {\n        if ( mfn )\n        {\n            page = mfn_to_page(_mfn(mfn));\n            if ( paging_mode_refcounts(v->domain) )\n                put_page(page);\n            else\n                rc = put_page_and_type_preemptible(page);\n            mfn = 0;\n        }\n\n        if ( !rc && put_guest_table_user )\n        {\n            /* Drop ref to guest_table_user (from MMUEXT_NEW_USER_BASEPTR) */\n            mfn = pagetable_get_pfn(v->arch.guest_table_user);\n            v->arch.guest_table_user = pagetable_null();\n            put_guest_table_user = false;\n        }\n    } while ( mfn );\n\n    /*\n     * If a \"put\" operation was interrupted, finish things off in\n     * put_old_guest_table() when the operation is restarted.\n     */\n    switch ( rc )\n    {\n    case -EINTR:\n    case -ERESTART:\n        v->arch.old_guest_ptpg = NULL;\n        v->arch.old_guest_table = page;\n        v->arch.old_guest_table_partial = (rc == -ERESTART);\n        rc = -ERESTART;\n        break;\n    default:\n        /*\n         * Failure to 'put' a page may cause it to leak, but that's\n         * less bad than a crash.\n         */\n        ASSERT(rc == 0);\n        break;\n    }\n\n    return rc;\n}", "target": 1, "idx": 10399}
{"commit_id": "fe5f4b85e6b1b54d3b4588a77133c06ade46d891", "project": "ImageMagick", "func": "static MagickOffsetType TIFFSeekCustomStream(const MagickOffsetType offset,\n  const int whence,void *user_data)\n{\n  PhotoshopProfile\n    *profile;\n\n  profile=(PhotoshopProfile *) user_data;\n  switch (whence)\n  {\n    case SEEK_SET:\n    default:\n    {\n      if (offset < 0)\n        return(-1);\n      profile->offset=offset;\n      break;\n    }\n    case SEEK_CUR:\n    {\n      if (((offset > 0) && (profile->offset > (SSIZE_MAX-offset))) ||\n          ((offset < 0) && (profile->offset < (-SSIZE_MAX-offset))))\n        {\n          errno=EOVERFLOW;\n          return(-1);\n        }\n      if ((profile->offset+offset) < 0)\n        return(-1);\n      profile->offset+=offset;\n      break;\n    }\n    case SEEK_END:\n    {\n      if (((MagickOffsetType) profile->length+offset) < 0)\n        return(-1);\n      profile->offset=profile->length+offset;\n      break;\n    }\n  }\n\n  return(profile->offset);\n}", "target": 2, "idx": 10400}
{"commit_id": "25be9ac20db51044e1b09ca67906355e4f328d48", "project": "android", "func": "virtual status_t configureVideoTunnelMode(\n            node_id node, OMX_U32 portIndex, OMX_BOOL tunneled,\n            OMX_U32 audioHwSync, native_handle_t **sidebandHandle ) {\n        Parcel data, reply;\n        data.writeInterfaceToken(IOMX::getInterfaceDescriptor());\n        data.writeInt32((int32_t)node);\n        data.writeInt32(portIndex);\n        data.writeInt32((int32_t)tunneled);\n        data.writeInt32(audioHwSync);\n        remote()->transact(CONFIGURE_VIDEO_TUNNEL_MODE, data, &reply);\n\n        status_t err = reply.readInt32();\n        if (err == OK && sidebandHandle) {\n            *sidebandHandle = (native_handle_t *)reply.readNativeHandle();\n        }\n        return err;\n    }", "target": 2, "idx": 10401}
{"commit_id": "e310c4f91d229a072507f80c73811489b4cdff27", "project": "cloudendpoints/esp", "func": "utils::Status NgxEspRequest::AddHeaderToBackend(const std::string &key,\n                                                const std::string &value,\n                                                bool changeAllOccurrence) {\n  std::vector<ngx_table_elt_t *> headers;\n  for (auto &h_in : r_->headers_in) {\n    if (key.size() == h_in.key.len &&\n        strncasecmp(key.c_str(), reinterpret_cast<const char *>(h_in.key.data),\n                    h_in.key.len) == 0) {\n      headers.push_back(&h_in);\n      if (!changeAllOccurrence) {\n        break;\n      }\n    }\n  }\n  if (headers.empty()) {\n    ngx_table_elt_t *h = reinterpret_cast<ngx_table_elt_t *>(\n        ngx_list_push(&r_->headers_in.headers));\n    if (h == nullptr) {\n      return utils::Status(Code::INTERNAL, \"Out of memory\");\n    }\n\n    h->lowcase_key =\n        reinterpret_cast<u_char *>(ngx_pcalloc(r_->pool, key.size()));\n    if (h->lowcase_key == nullptr) {\n      return utils::Status(Code::INTERNAL, \"Out of memory\");\n    }\n    h->hash = ngx_hash_strlow(\n        h->lowcase_key,\n        reinterpret_cast<u_char *>(const_cast<char *>(key.c_str())),\n        key.size());\n    headers.push_back(h);\n  }\n\n  for (size_t i = 0; i < headers.size(); ++i) {\n    ngx_table_elt_t *it = headers[i];\n    if (ngx_str_copy_from_std(r_->pool, key, &it->key) != NGX_OK ||\n        ngx_str_copy_from_std(r_->pool, value, &it->value) != NGX_OK) {\n      return utils::Status(Code::INTERNAL, \"Out of memory\");\n    }\n  }\n\n  ngx_log_debug3(\n      NGX_LOG_DEBUG_HTTP, r_->connection->log, 0,\n      \"updates header to backend, changeAllOccurrence: '%t', \\\"%V: %V\\\"\",\n      changeAllOccurrence, &h->key, &h->value);\n  return utils::Status::OK;\n}", "target": 1, "idx": 10402}
{"commit_id": "c3e2219216c92919a6bd1711f340f5faa98695e6", "project": "torvalds/linux", "func": "static void blk_mq_sched_tags_teardown(struct request_queue *q)\n{\n\tstruct blk_mq_hw_ctx *hctx;\n\tint i;\n\n\tqueue_for_each_hw_ctx(q, hctx, i) {\n\t\tif (hctx->sched_tags) {\n\t\t\tblk_mq_free_rq_map(hctx->sched_tags);\n\t\t\thctx->sched_tags = NULL;\n\t\t}\n\t}\n}", "target": 2, "idx": 10403}
{"commit_id": "dccb5f7d776e93863ae10bbff56a45c523c6eeb0", "project": "TigerVNC/tigervnc", "func": "CConnection::CConnection()\n  : csecurity(0), is(0), os(0), reader_(0), writer_(0),\n    shared(false),\n    state_(RFBSTATE_UNINITIALISED), useProtocol3_3(false),\n    framebuffer(NULL), decoder(this)\n{\n}", "target": 2, "idx": 10404}
{"commit_id": "3ac426b2c04004422c290425259082281e090116", "project": "Exiv2/exiv2", "func": "void CrwMap::encode0x080a(const Image&      image,\n                              const CrwMapping* pCrwMapping,\n                                    CiffHeader* pHead)\n    {\n        assert(pCrwMapping != 0);\n        assert(pHead != 0);\n\n        const ExifKey k1(\"Exif.Image.Make\");\n        const ExifKey k2(\"Exif.Image.Model\");\n        const ExifData::const_iterator ed1 = image.exifData().findKey(k1);\n        const ExifData::const_iterator ed2 = image.exifData().findKey(k2);\n        const ExifData::const_iterator edEnd = image.exifData().end();\n\n        long size = 0;\n        if (ed1 != edEnd) size += ed1->size();\n        if (ed2 != edEnd) size += ed2->size();\n        if (size != 0) {\n            DataBuf buf(size);\n            long pos = 0;\n            if (ed1 != edEnd) {\n                ed1->copy(buf.pData_, pHead->byteOrder());\n                pos += ed1->size();\n            }\n            if (ed2 != edEnd) {\n                ed2->copy(buf.pData_ + pos, pHead->byteOrder());\n                pos += ed2->size();\n            }\n            assert(pos == size);\n            pHead->add(pCrwMapping->crwTagId_, pCrwMapping->crwDir_, buf);\n        }\n        else {\n            pHead->remove(pCrwMapping->crwTagId_, pCrwMapping->crwDir_);\n        }\n    }", "target": 1, "idx": 10405}
{"commit_id": "bb7e5feece68ccfd8660caee93da25c5c39a4707", "project": "pocoproject/poco", "func": "int ZipStreamBuf::readFromDevice(char* buffer, std::streamsize length)\n{\n\tif (!_ptrBuf) return 0; // directory entry\n\t_ptrBuf->read(buffer, length);\n\tint cnt = static_cast<int>(_ptrBuf->gcount());\n\tif (cnt > 0)\n\t{\n\t\t_crc32.update(buffer, cnt);\n\t}\n\telse\n\t{\n\t\tif (_crc32.checksum() != _expectedCrc32)\n\t\t{\n\t\t\tif (_checkCRC)\n\t\t\t\tthrow ZipException(\"CRC failure\");\n\t\t\telse\n\t\t\t{\n\t\t\t\t// the CRC value is written directly after the data block\n\t\t\t\t// parse it directly from the input stream\n\t\t\t\tZipDataInfo nfo(*_pIstr, false);\n\t\t\t\t// now push back the header to the stream, so that the ZipLocalFileHeader can read it\n\t\t\t\tPoco::Int32 size = static_cast<Poco::Int32>(nfo.getFullHeaderSize());\n\t\t\t\t_expectedCrc32 = nfo.getCRC32();\n\t\t\t\t_pIstr->seekg(-size, std::ios::cur);\n\t\t\t\tif (!_pIstr->good()) throw Poco::IOException(\"Failed to seek on input stream\");\n\t\t\t\tif (!crcValid())\n\t\t\t\t\tthrow ZipException(\"CRC failure\");\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}", "target": 1, "idx": 10406}
{"commit_id": "6709d4b7bc2e079241fdef15d1160581c5261c10", "project": "torvalds/linux", "func": "struct nfc_llcp_local *nfc_llcp_find_local(struct nfc_dev *dev)\n{\n\tstruct nfc_llcp_local *local;\n\tstruct nfc_llcp_local *res = NULL;\n\n\tspin_lock(&llcp_devices_lock);\n\tlist_for_each_entry(local, &llcp_devices, list)\n\t\tif (local->dev == dev) {\n\t\t\tres = nfc_llcp_local_get(local);\n\t\t\tbreak;\n\t\t}\n\tspin_unlock(&llcp_devices_lock);\n\n\treturn res;\n}", "target": 1, "idx": 10407}
{"commit_id": "b0cf030b30a9b63e678fee294321642beb42b724", "project": "wireshark", "func": "static gint rtps_util_add_rti_service_request(proto_tree * tree, packet_info *pinfo, tvbuff_t * tvb,\n        gint offset, const guint encoding, guint32 service_id) {\n  switch (service_id) {\n    case RTI_SERVICE_REQUEST_ID_TOPIC_QUERY:\n      offset = rtps_util_add_rti_topic_query_service_request(tree, tvb, offset + 4,\n                  encoding);\n      break;\n    case RTI_SERVICE_REQUEST_ID_LOCATOR_REACHABILITY:\n      offset = rtps_util_add_rti_locator_reachability_service_request(tree, pinfo, tvb, offset + 4,\n                  encoding);\n      break;\n    case RTI_SERVICE_REQUEST_ID_UNKNOWN: {\n      guint32 seq_length;\n      seq_length = tvb_get_guint32(tvb, offset, encoding);\n      proto_tree_add_item(tree, hf_rtps_srm_request_body,\n                    tvb, offset + 4, seq_length, ENC_NA);\n      offset = check_offset_addition(offset, seq_length, tree, NULL, tvb);\n      offset = check_offset_addition(offset, 4, tree, NULL, tvb);\n      break;\n    }\n  }\n  return offset;\n}", "target": 1, "idx": 10408}
{"commit_id": "1a4f14bab1868b443f0dd3c55b689a478f82e72e", "project": "kernel/git/netdev/net", "func": "static void tcp_data_queue_ofo(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct rb_node **p, *parent;\n\tstruct sk_buff *skb1;\n\tu32 seq, end_seq;\n\tbool fragstolen;\n\n\ttcp_ecn_check_ce(sk, skb);\n\n\tif (unlikely(tcp_try_rmem_schedule(sk, skb, skb->truesize))) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPOFODROP);\n\t\ttcp_drop(sk, skb);\n\t\treturn;\n\t}\n\n\t/* Disable header prediction. */\n\ttp->pred_flags = 0;\n\tinet_csk_schedule_ack(sk);\n\n\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPOFOQUEUE);\n\tseq = TCP_SKB_CB(skb)->seq;\n\tend_seq = TCP_SKB_CB(skb)->end_seq;\n\tSOCK_DEBUG(sk, \"out of order segment: rcv_next %X seq %X - %X\\n\",\n\t\t   tp->rcv_nxt, seq, end_seq);\n\n\tp = &tp->out_of_order_queue.rb_node;\n\tif (RB_EMPTY_ROOT(&tp->out_of_order_queue)) {\n\t\t/* Initial out of order segment, build 1 SACK. */\n\t\tif (tcp_is_sack(tp)) {\n\t\t\ttp->rx_opt.num_sacks = 1;\n\t\t\ttp->selective_acks[0].start_seq = seq;\n\t\t\ttp->selective_acks[0].end_seq = end_seq;\n\t\t}\n\t\trb_link_node(&skb->rbnode, NULL, p);\n\t\trb_insert_color(&skb->rbnode, &tp->out_of_order_queue);\n\t\ttp->ooo_last_skb = skb;\n\t\tgoto end;\n\t}\n\n\t/* In the typical case, we are adding an skb to the end of the list.\n\t * Use of ooo_last_skb avoids the O(Log(N)) rbtree lookup.\n\t */\n\tif (tcp_ooo_try_coalesce(sk, tp->ooo_last_skb,\n\t\t\t\t skb, &fragstolen)) {\ncoalesce_done:\n\t\ttcp_grow_window(sk, skb);\n\t\tkfree_skb_partial(skb, fragstolen);\n\t\tskb = NULL;\n\t\tgoto add_sack;\n\t}\n\t/* Can avoid an rbtree lookup if we are adding skb after ooo_last_skb */\n\tif (!before(seq, TCP_SKB_CB(tp->ooo_last_skb)->end_seq)) {\n\t\tparent = &tp->ooo_last_skb->rbnode;\n\t\tp = &parent->rb_right;\n\t\tgoto insert;\n\t}\n\n\t/* Find place to insert this segment. Handle overlaps on the way. */\n\tparent = NULL;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tskb1 = rb_to_skb(parent);\n\t\tif (before(seq, TCP_SKB_CB(skb1)->seq)) {\n\t\t\tp = &parent->rb_left;\n\t\t\tcontinue;\n\t\t}\n\t\tif (before(seq, TCP_SKB_CB(skb1)->end_seq)) {\n\t\t\tif (!after(end_seq, TCP_SKB_CB(skb1)->end_seq)) {\n\t\t\t\t/* All the bits are present. Drop. */\n\t\t\t\tNET_INC_STATS(sock_net(sk),\n\t\t\t\t\t      LINUX_MIB_TCPOFOMERGE);\n\t\t\t\ttcp_drop(sk, skb);\n\t\t\t\tskb = NULL;\n\t\t\t\ttcp_dsack_set(sk, seq, end_seq);\n\t\t\t\tgoto add_sack;\n\t\t\t}\n\t\t\tif (after(seq, TCP_SKB_CB(skb1)->seq)) {\n\t\t\t\t/* Partial overlap. */\n\t\t\t\ttcp_dsack_set(sk, seq, TCP_SKB_CB(skb1)->end_seq);\n\t\t\t} else {\n\t\t\t\t/* skb's seq == skb1's seq and skb covers skb1.\n\t\t\t\t * Replace skb1 with skb.\n\t\t\t\t */\n\t\t\t\trb_replace_node(&skb1->rbnode, &skb->rbnode,\n\t\t\t\t\t\t&tp->out_of_order_queue);\n\t\t\t\ttcp_dsack_extend(sk,\n\t\t\t\t\t\t TCP_SKB_CB(skb1)->seq,\n\t\t\t\t\t\t TCP_SKB_CB(skb1)->end_seq);\n\t\t\t\tNET_INC_STATS(sock_net(sk),\n\t\t\t\t\t      LINUX_MIB_TCPOFOMERGE);\n\t\t\t\ttcp_drop(sk, skb1);\n\t\t\t\tgoto merge_right;\n\t\t\t}\n\t\t} else if (tcp_ooo_try_coalesce(sk, skb1,\n\t\t\t\t\t\tskb, &fragstolen)) {\n\t\t\tgoto coalesce_done;\n\t\t}\n\t\tp = &parent->rb_right;\n\t}\ninsert:\n\t/* Insert segment into RB tree. */\n\trb_link_node(&skb->rbnode, parent, p);\n\trb_insert_color(&skb->rbnode, &tp->out_of_order_queue);\n\nmerge_right:\n\t/* Remove other segments covered by skb. */\n\twhile ((skb1 = skb_rb_next(skb)) != NULL) {\n\t\tif (!after(end_seq, TCP_SKB_CB(skb1)->seq))\n\t\t\tbreak;\n\t\tif (before(end_seq, TCP_SKB_CB(skb1)->end_seq)) {\n\t\t\ttcp_dsack_extend(sk, TCP_SKB_CB(skb1)->seq,\n\t\t\t\t\t end_seq);\n\t\t\tbreak;\n\t\t}\n\t\trb_erase(&skb1->rbnode, &tp->out_of_order_queue);\n\t\ttcp_dsack_extend(sk, TCP_SKB_CB(skb1)->seq,\n\t\t\t\t TCP_SKB_CB(skb1)->end_seq);\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPOFOMERGE);\n\t\ttcp_drop(sk, skb1);\n\t}\n\t/* If there is no skb after us, we are the last_skb ! */\n\tif (!skb1)\n\t\ttp->ooo_last_skb = skb;\n\nadd_sack:\n\tif (tcp_is_sack(tp))\n\t\ttcp_sack_new_ofo_skb(sk, seq, end_seq);\nend:\n\tif (skb) {\n\t\ttcp_grow_window(sk, skb);\n\t\tskb_condense(skb);\n\t\tskb_set_owner_r(skb, sk);\n\t}\n}", "target": 2, "idx": 10409}
{"commit_id": "0f6fc2d5bf8f500820c3dbcf0d23ee14f2d9f734", "project": "ImageMagick", "func": "static Image *ReadICONImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  IconFile\n    icon_file;\n\n  IconInfo\n    icon_info;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bit,\n    byte,\n    bytes_per_line,\n    one,\n    scanline_pad;\n\n  ssize_t\n    count,\n    offset,\n    y;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"%s\",image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  icon_file.reserved=(short) ReadBlobLSBShort(image);\n  icon_file.resource_type=(short) ReadBlobLSBShort(image);\n  icon_file.count=(short) ReadBlobLSBShort(image);\n  if ((icon_file.reserved != 0) ||\n      ((icon_file.resource_type != 1) && (icon_file.resource_type != 2)) ||\n      (icon_file.count > MaxIcons))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  for (i=0; i < icon_file.count; i++)\n  {\n    icon_file.directory[i].width=(unsigned char) ReadBlobByte(image);\n    icon_file.directory[i].height=(unsigned char) ReadBlobByte(image);\n    icon_file.directory[i].colors=(unsigned char) ReadBlobByte(image);\n    icon_file.directory[i].reserved=(unsigned char) ReadBlobByte(image);\n    icon_file.directory[i].planes=(unsigned short) ReadBlobLSBShort(image);\n    icon_file.directory[i].bits_per_pixel=(unsigned short)\n      ReadBlobLSBShort(image);\n    icon_file.directory[i].size=ReadBlobLSBLong(image);\n    icon_file.directory[i].offset=ReadBlobLSBLong(image);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n  }\n  one=1;\n  for (i=0; i < icon_file.count; i++)\n  {\n    /*\n      Verify Icon identifier.\n    */\n    offset=(ssize_t) SeekBlob(image,(MagickOffsetType)\n      icon_file.directory[i].offset,SEEK_SET);\n    if (offset < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    icon_info.size=ReadBlobLSBLong(image);\n    icon_info.width=(unsigned char) ((int) ReadBlobLSBLong(image));\n    icon_info.height=(unsigned char) ((int) ReadBlobLSBLong(image)/2);\n    icon_info.planes=ReadBlobLSBShort(image);\n    icon_info.bits_per_pixel=ReadBlobLSBShort(image);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    if (((icon_info.planes == 18505) && (icon_info.bits_per_pixel == 21060)) || \n        (icon_info.size == 0x474e5089))\n      {\n        Image\n          *icon_image;\n\n        ImageInfo\n          *read_info;\n\n        size_t\n          length;\n\n        unsigned char\n          *png;\n\n        /*\n          Icon image encoded as a compressed PNG image.\n        */\n        length=icon_file.directory[i].size;\n        if (~length < 16)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        png=(unsigned char *) AcquireQuantumMemory(length+16,sizeof(*png));\n        if (png == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) CopyMagickMemory(png,\"\\211PNG\\r\\n\\032\\n\\000\\000\\000\\015\",12);\n        png[12]=(unsigned char) icon_info.planes;\n        png[13]=(unsigned char) (icon_info.planes >> 8);\n        png[14]=(unsigned char) icon_info.bits_per_pixel;\n        png[15]=(unsigned char) (icon_info.bits_per_pixel >> 8);\n        count=ReadBlob(image,length-16,png+16);\n        icon_image=(Image *) NULL;\n        if (count > 0)\n          {\n            read_info=CloneImageInfo(image_info);\n            (void) CopyMagickString(read_info->magick,\"PNG\",MagickPathExtent);\n            icon_image=BlobToImage(read_info,png,length+16,exception);\n            read_info=DestroyImageInfo(read_info);\n          }\n        png=(unsigned char *) RelinquishMagickMemory(png);\n        if (icon_image == (Image *) NULL)\n          {\n            if (count != (ssize_t) (length-16))\n              ThrowReaderException(CorruptImageError,\n                \"InsufficientImageDataInFile\");\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        DestroyBlob(icon_image);\n        icon_image->blob=ReferenceBlob(image->blob);\n        ReplaceImageInList(&image,icon_image);\n      }\n    else\n      {\n        if (icon_info.bits_per_pixel > 32)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        icon_info.compression=ReadBlobLSBLong(image);\n        icon_info.image_size=ReadBlobLSBLong(image);\n        icon_info.x_pixels=ReadBlobLSBLong(image);\n        icon_info.y_pixels=ReadBlobLSBLong(image);\n        icon_info.number_colors=ReadBlobLSBLong(image);\n        icon_info.colors_important=ReadBlobLSBLong(image);\n        image->alpha_trait=BlendPixelTrait;\n        image->columns=(size_t) icon_file.directory[i].width;\n        if ((ssize_t) image->columns > icon_info.width)\n          image->columns=(size_t) icon_info.width;\n        if (image->columns == 0)\n          image->columns=256;\n        image->rows=(size_t) icon_file.directory[i].height;\n        if ((ssize_t) image->rows > icon_info.height)\n          image->rows=(size_t) icon_info.height;\n        if (image->rows == 0)\n          image->rows=256;\n        image->depth=icon_info.bits_per_pixel;\n        if (image->debug != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \" scene    = %.20g\",(double) i);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   size   = %.20g\",(double) icon_info.size);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   width  = %.20g\",(double) icon_file.directory[i].width);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   height = %.20g\",(double) icon_file.directory[i].height);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   colors = %.20g\",(double ) icon_info.number_colors);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   planes = %.20g\",(double) icon_info.planes);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   bpp    = %.20g\",(double) icon_info.bits_per_pixel);\n          }\n      if ((icon_info.number_colors != 0) || (icon_info.bits_per_pixel <= 16U))\n        {\n          image->storage_class=PseudoClass;\n          image->colors=icon_info.number_colors;\n          if (image->colors == 0)\n            image->colors=one << icon_info.bits_per_pixel;\n        }\n      if (image->storage_class == PseudoClass)\n        {\n          register ssize_t\n            i;\n\n          unsigned char\n            *icon_colormap;\n\n          /*\n            Read Icon raster colormap.\n          */\n          if (AcquireImageColormap(image,image->colors,exception) ==\n              MagickFalse)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          icon_colormap=(unsigned char *) AcquireQuantumMemory((size_t)\n            image->colors,4UL*sizeof(*icon_colormap));\n          if (icon_colormap == (unsigned char *) NULL)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          count=ReadBlob(image,(size_t) (4*image->colors),icon_colormap);\n          if (count != (ssize_t) (4*image->colors))\n            ThrowReaderException(CorruptImageError,\n              \"InsufficientImageDataInFile\");\n          p=icon_colormap;\n          for (i=0; i < (ssize_t) image->colors; i++)\n          {\n            image->colormap[i].blue=(Quantum) ScaleCharToQuantum(*p++);\n            image->colormap[i].green=(Quantum) ScaleCharToQuantum(*p++);\n            image->colormap[i].red=(Quantum) ScaleCharToQuantum(*p++);\n            p++;\n          }\n          icon_colormap=(unsigned char *) RelinquishMagickMemory(icon_colormap);\n        }\n        /*\n          Convert Icon raster image to pixel packets.\n        */\n        if ((image_info->ping != MagickFalse) &&\n            (image_info->number_scenes != 0))\n          if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n            break;\n        status=SetImageExtent(image,image->columns,image->rows,exception);\n        if (status == MagickFalse)\n          return(DestroyImageList(image));\n        bytes_per_line=(((image->columns*icon_info.bits_per_pixel)+31) &\n          ~31) >> 3;\n        (void) bytes_per_line;\n        scanline_pad=((((image->columns*icon_info.bits_per_pixel)+31) & ~31)-\n          (image->columns*icon_info.bits_per_pixel)) >> 3;\n        switch (icon_info.bits_per_pixel)\n        {\n          case 1:\n          {\n            /*\n              Convert bitmap scanline.\n            */\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) (image->columns-7); x+=8)\n              {\n                byte=(size_t) ReadBlobByte(image);\n                for (bit=0; bit < 8; bit++)\n                {\n                  SetPixelIndex(image,((byte & (0x80 >> bit)) != 0 ? 0x01 :\n                    0x00),q);\n                  q+=GetPixelChannels(image);\n                }\n              }\n              if ((image->columns % 8) != 0)\n                {\n                  byte=(size_t) ReadBlobByte(image);\n                  for (bit=0; bit < (image->columns % 8); bit++)\n                  {\n                    SetPixelIndex(image,((byte & (0x80 >> bit)) != 0 ? 0x01 :\n                      0x00),q);\n                    q+=GetPixelChannels(image);\n                  }\n                }\n              for (x=0; x < (ssize_t) scanline_pad; x++)\n                (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n                    image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          case 4:\n          {\n            /*\n              Read 4-bit Icon scanline.\n            */\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n              {\n                byte=(size_t) ReadBlobByte(image);\n                SetPixelIndex(image,((byte >> 4) & 0xf),q);\n                q+=GetPixelChannels(image);\n                SetPixelIndex(image,((byte) & 0xf),q);\n                q+=GetPixelChannels(image);\n              }\n              if ((image->columns % 2) != 0)\n                {\n                  byte=(size_t) ReadBlobByte(image);\n                  SetPixelIndex(image,((byte >> 4) & 0xf),q);\n                  q+=GetPixelChannels(image);\n                }\n              for (x=0; x < (ssize_t) scanline_pad; x++)\n                (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n                    image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          case 8:\n          {\n            /*\n              Convert PseudoColor scanline.\n            */\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                byte=(size_t) ReadBlobByte(image);\n                SetPixelIndex(image,byte,q);\n                q+=GetPixelChannels(image);\n              }\n              for (x=0; x < (ssize_t) scanline_pad; x++)\n                (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n                    image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          case 16:\n          {\n            /*\n              Convert PseudoColor scanline.\n            */\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                byte=(size_t) ReadBlobByte(image);\n                byte|=(size_t) (ReadBlobByte(image) << 8);\n                SetPixelIndex(image,byte,q);\n                q+=GetPixelChannels(image);\n              }\n              for (x=0; x < (ssize_t) scanline_pad; x++)\n                (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n                    image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          case 24:\n          case 32:\n          {\n            /*\n              Convert DirectColor scanline.\n            */\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n                  ReadBlobByte(image)),q);\n                SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n                  ReadBlobByte(image)),q);\n                SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n                  ReadBlobByte(image)),q);\n                if (icon_info.bits_per_pixel == 32)\n                  SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image)),q);\n                q+=GetPixelChannels(image);\n              }\n              if (icon_info.bits_per_pixel == 24)\n                for (x=0; x < (ssize_t) scanline_pad; x++)\n                  (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n                    image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          default:\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        }\n        if (image_info->ping == MagickFalse)\n          (void) SyncImage(image,exception);\n        if (icon_info.bits_per_pixel != 32)\n          {\n            /*\n              Read the ICON alpha mask.\n            */\n            image->storage_class=DirectClass;\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n              {\n                byte=(size_t) ReadBlobByte(image);\n                for (bit=0; bit < 8; bit++)\n                {\n                  SetPixelAlpha(image,(((byte & (0x80 >> bit)) != 0) ?\n                    TransparentAlpha : OpaqueAlpha),q);\n                  q+=GetPixelChannels(image);\n                }\n              }\n              if ((image->columns % 8) != 0)\n                {\n                  byte=(size_t) ReadBlobByte(image);\n                  for (bit=0; bit < (image->columns % 8); bit++)\n                  {\n                    SetPixelAlpha(image,(((byte & (0x80 >> bit)) != 0) ?\n                      TransparentAlpha : OpaqueAlpha),q);\n                    q+=GetPixelChannels(image);\n                  }\n                }\n              if ((image->columns % 32) != 0)\n                for (x=0; x < (ssize_t) ((32-(image->columns % 32))/8); x++)\n                  (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n            }\n          }\n        if (EOFBlob(image) != MagickFalse)\n          {\n            ThrowFileException(exception,CorruptImageError,\n              \"UnexpectedEndOfFile\",image->filename);\n            break;\n          }\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (i < (ssize_t) (icon_file.count-1))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}", "target": 2, "idx": 10410}
{"commit_id": "3689dc1db36037436b1616715f9a3f888fc9a0f6", "project": "wireshark", "func": "static void\nsave_request(packet_info *pinfo, guint8 opcode, union request_parameters_union parameters,\n        bluetooth_data_t *bluetooth_data)\n{\n    wmem_tree_key_t  key[5];\n    guint32          frame_number, curr_layer_num;\n    request_data_t  *request_data;\n\n    frame_number = pinfo->num;\n    curr_layer_num = pinfo->curr_layer_num;\n\n    key[0].length = 1;\n    key[0].key    = &bluetooth_data->interface_id;\n    key[1].length = 1;\n    key[1].key    = &bluetooth_data->adapter_id;\n    key[2].length = 1;\n    key[2].key    = &curr_layer_num;\n    key[3].length = 1;\n    key[3].key    = &frame_number;\n    key[4].length = 0;\n    key[4].key    = NULL;\n\n    request_data = wmem_new(wmem_file_scope(), request_data_t);\n    request_data->opcode = opcode;\n    request_data->request_in_frame = frame_number;\n    request_data->response_in_frame = 0;\n\n    request_data->parameters = parameters;\n\n    wmem_tree_insert32_array(requests, key, request_data);\n}", "target": 2, "idx": 10411}
{"commit_id": "f428fe4a04cc339166c8bbd489789760de3a0cee", "project": "torvalds/linux", "func": "static struct net *get_target_net(struct sock *sk, int netnsid)\n{\n\tstruct net *net;\n\n\tnet = get_net_ns_by_id(sock_net(sk), netnsid);\n\tif (!net)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* For now, the caller is required to have CAP_NET_ADMIN in\n\t * the user namespace owning the target net ns.\n\t */\n\tif (!sk_ns_capable(sk, net->user_ns, CAP_NET_ADMIN)) {\n\t\tput_net(net);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\treturn net;\n}", "target": 1, "idx": 10412}
{"commit_id": "55667441c84fa5e0911a0aac44fb059c15ba6da2", "project": "torvalds/linux", "func": "static int sfq_change(struct Qdisc *sch, struct nlattr *opt)\n{\n\tstruct sfq_sched_data *q = qdisc_priv(sch);\n\tstruct tc_sfq_qopt *ctl = nla_data(opt);\n\tstruct tc_sfq_qopt_v1 *ctl_v1 = NULL;\n\tunsigned int qlen, dropped = 0;\n\tstruct red_parms *p = NULL;\n\tstruct sk_buff *to_free = NULL;\n\tstruct sk_buff *tail = NULL;\n\n\tif (opt->nla_len < nla_attr_size(sizeof(*ctl)))\n\t\treturn -EINVAL;\n\tif (opt->nla_len >= nla_attr_size(sizeof(*ctl_v1)))\n\t\tctl_v1 = nla_data(opt);\n\tif (ctl->divisor &&\n\t    (!is_power_of_2(ctl->divisor) || ctl->divisor > 65536))\n\t\treturn -EINVAL;\n\tif (ctl_v1 && !red_check_params(ctl_v1->qth_min, ctl_v1->qth_max,\n\t\t\t\t\tctl_v1->Wlog))\n\t\treturn -EINVAL;\n\tif (ctl_v1 && ctl_v1->qth_min) {\n\t\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t}\n\tsch_tree_lock(sch);\n\tif (ctl->quantum) {\n\t\tq->quantum = ctl->quantum;\n\t\tq->scaled_quantum = SFQ_ALLOT_SIZE(q->quantum);\n\t}\n\tq->perturb_period = ctl->perturb_period * HZ;\n\tif (ctl->flows)\n\t\tq->maxflows = min_t(u32, ctl->flows, SFQ_MAX_FLOWS);\n\tif (ctl->divisor) {\n\t\tq->divisor = ctl->divisor;\n\t\tq->maxflows = min_t(u32, q->maxflows, q->divisor);\n\t}\n\tif (ctl_v1) {\n\t\tif (ctl_v1->depth)\n\t\t\tq->maxdepth = min_t(u32, ctl_v1->depth, SFQ_MAX_DEPTH);\n\t\tif (p) {\n\t\t\tswap(q->red_parms, p);\n\t\t\tred_set_parms(q->red_parms,\n\t\t\t\t      ctl_v1->qth_min, ctl_v1->qth_max,\n\t\t\t\t      ctl_v1->Wlog,\n\t\t\t\t      ctl_v1->Plog, ctl_v1->Scell_log,\n\t\t\t\t      NULL,\n\t\t\t\t      ctl_v1->max_P);\n\t\t}\n\t\tq->flags = ctl_v1->flags;\n\t\tq->headdrop = ctl_v1->headdrop;\n\t}\n\tif (ctl->limit) {\n\t\tq->limit = min_t(u32, ctl->limit, q->maxdepth * q->maxflows);\n\t\tq->maxflows = min_t(u32, q->maxflows, q->limit);\n\t}\n\n\tqlen = sch->q.qlen;\n\twhile (sch->q.qlen > q->limit) {\n\t\tdropped += sfq_drop(sch, &to_free);\n\t\tif (!tail)\n\t\t\ttail = to_free;\n\t}\n\n\trtnl_kfree_skbs(to_free, tail);\n\tqdisc_tree_reduce_backlog(sch, qlen - sch->q.qlen, dropped);\n\n\tdel_timer(&q->perturb_timer);\n\tif (q->perturb_period) {\n\t\tmod_timer(&q->perturb_timer, jiffies + q->perturb_period);\n\t\tget_random_bytes(&q->perturbation, sizeof(q->perturbation));\n\t}\n\tsch_tree_unlock(sch);\n\tkfree(p);\n\treturn 0;\n}", "target": 1, "idx": 10413}
{"commit_id": "44491a4b0fdb2d2bd87a151fd169da3343954edd", "project": "WebAssembly/wabt", "func": "Result WastParser::ParseCodeMetadataAnnotation(ExprList* exprs) {\n  WABT_TRACE(ParseCodeMetadataAnnotation);\n  Token tk = Consume();\n  std::string_view name = tk.text();\n  name.remove_prefix(sizeof(\"metadata.code.\") - 1);\n  std::string data_text;\n  CHECK_RESULT(ParseQuotedText(&data_text, false));\n  std::vector<uint8_t> data(data_text.begin(), data_text.end());\n  exprs->push_back(std::make_unique<CodeMetadataExpr>(name, std::move(data)));\n  EXPECT(Rpar);\n  return Result::Ok;\n}", "target": 1, "idx": 10414}
{"commit_id": "362fc486b5c0eea04f26793d5623f6a9272bd85a", "project": "gpac", "func": "void vwid_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGF_ViewIdentifierBox *ptr = (GF_ViewIdentifierBox *) s;\n\tif (ptr->views) {\n\t\tfor (i=0; i<ptr->num_views; i++) {\n\t\t\tif (ptr->views[i].view_refs)\n\t\t\t\tgf_free(ptr->views[i].view_refs);\n\t\t}\n\t\tgf_free(ptr->views);\n\t}\n\tgf_free(ptr);\n}", "target": 1, "idx": 10415}
{"commit_id": "fba01dc76d6ea940ad7c8392e8f39f9647241d8e", "project": "CrowCpp/Crow", "func": "static int on_message_begin(http_parser* self_)\n        {\n            HTTPParser* self = static_cast<HTTPParser*>(self_);\n            return 0;\n        }", "target": 3, "idx": 10416}
{"commit_id": "a9bf2520ab5abb69f9328906e406fbebfb36159a", "project": "galkahana/HummusJS", "func": "IByteReader*  DecryptionHelper::CreateDecryptionFilterForStream(PDFStreamInput* inStream, IByteReader* inToWrapStream, const std::string& inCryptName) {\n\t// note that here the original stream is returned instead of null\n\tif (!IsEncrypted() || !CanDecryptDocument())\n\t\treturn inToWrapStream;\n\n\tIDeletable* savedEcnryptionKey = inStream->GetMetadata(scEcnryptionKeyMetadataKey);\n\tif (!savedEcnryptionKey) {\n\t\t// sign for no encryption here\n\t\treturn inToWrapStream;\n\t}\n\tXCryptionCommon* xcryption = GetFilterForName(mXcrypts, inCryptName);\n\n\tif (xcryption && savedEcnryptionKey) {\n\t\treturn CreateDecryptionReader(inToWrapStream, *(((Deletable<ByteList>*)savedEcnryptionKey)->GetPtr()), xcryption->IsUsingAES());\n\t}\n\telse\n\t\treturn inToWrapStream;\n\n}", "target": 2, "idx": 10417}
{"commit_id": "2eda98790c5c2741d76d23cc1e74b0dc4f4b391a", "project": "openssl", "func": "static int ocsp_verify_signer(X509 *signer, int response,\n                              X509_STORE *st, unsigned long flags,\n                              STACK_OF(X509) *untrusted, STACK_OF(X509) **chain)\n{\n    X509_STORE_CTX *ctx = X509_STORE_CTX_new();\n    X509_VERIFY_PARAM *vp;\n    int ret = -1;\n\n    if (ctx == NULL) {\n        ERR_raise(ERR_LIB_OCSP, ERR_R_MALLOC_FAILURE);\n        goto end;\n    }\n    if (!X509_STORE_CTX_init(ctx, st, signer, untrusted)) {\n        ERR_raise(ERR_LIB_OCSP, ERR_R_X509_LIB);\n        goto end;\n    }\n    if ((vp = X509_STORE_CTX_get0_param(ctx)) == NULL)\n        goto end;\n    if ((flags & OCSP_PARTIAL_CHAIN) != 0)\n        X509_VERIFY_PARAM_set_flags(vp, X509_V_FLAG_PARTIAL_CHAIN);\n    if (response\n            && X509_get_ext_by_NID(signer, NID_id_pkix_OCSP_noCheck, -1) >= 0)\n        /*\n         * Locally disable revocation status checking for OCSP responder cert.\n         * Done here for CRLs; should be done also for OCSP-based checks.\n         */\n        X509_VERIFY_PARAM_clear_flags(vp, X509_V_FLAG_CRL_CHECK);\n    X509_STORE_CTX_set_purpose(ctx, X509_PURPOSE_OCSP_HELPER);\n    X509_STORE_CTX_set_trust(ctx, X509_TRUST_OCSP_REQUEST);\n\n    ret = X509_verify_cert(ctx);\n    if (ret <= 0) {\n        int err = X509_STORE_CTX_get_error(ctx);\n\n        ERR_raise_data(ERR_LIB_OCSP, OCSP_R_CERTIFICATE_VERIFY_ERROR,\n                       \"Verify error: %s\", X509_verify_cert_error_string(err));\n        goto end;\n    }\n    if (chain != NULL)\n        *chain = X509_STORE_CTX_get1_chain(ctx);\n\n end:\n    X509_STORE_CTX_free(ctx);\n    return ret;\n}", "target": 1, "idx": 10418}
{"commit_id": "89f58f1aa95b3482cadf6977da49457194ee5358", "project": "ArtifexSoftware/ghostpdl", "func": "static int\nepsc_print_page(gx_device_printer * pdev, gp_file * prn_stream)\n{\n    static int graphics_modes_9[5] = { -1, 0 /*60 */ , 1 /*120 */ , -1, DD + 3  /*240 */\n    };\n    static int graphics_modes_24[7] =\n        { -1, 32 /*60 */ , 33 /*120 */ , 39 /*180 */ ,\n        -1, -1, DD + 40         /*360 */\n    };\n    int y_24pin = pdev->y_pixels_per_inch > 72;\n    int y_mult = (y_24pin ? 3 : 1);\n    int line_size = (pdev->width + 7) >> 3;     /* always mono */\n    int in_size = line_size * (8 * y_mult);\n    int out_size = ((pdev->width + 7) & -8) * y_mult;\n    byte *in;\n    byte *out;\n    int x_dpi = (int)pdev->x_pixels_per_inch;\n\n    char start_graphics;\n    int first_pass;\n    int last_pass;\n    int dots_per_space; \n    int bytes_per_space;\n    int skip = 0, lnum = 0, pass;\n\n    byte *color_in;\n    int color_line_size, color_in_size;\n    int spare_bits;\n    int whole_bits;\n\n    int max_dpi = 60 * (\n            (y_24pin) ?\n            sizeof(graphics_modes_24) / sizeof(graphics_modes_24[0])\n            :\n            sizeof(graphics_modes_9) / sizeof(graphics_modes_9[0])\n            )\n            - 1;\n    if (x_dpi > max_dpi) {\n        return_error(gs_error_rangecheck);\n    }\n    \n    in =\n        (byte *) gs_malloc(pdev->memory, in_size + 1, 1,\n                           \"epsc_print_page(in)\");\n    out =\n        (byte *) gs_malloc(pdev->memory, out_size + 1, 1,\n                           \"epsc_print_page(out)\");\n\n    start_graphics = (char)\n        ((y_24pin ? graphics_modes_24 : graphics_modes_9)[x_dpi / 60]);\n    first_pass = (start_graphics & DD ? 1 : 0);\n    last_pass = first_pass * 2;\n    dots_per_space = x_dpi / 10;    /* pica space = 1/10\" */\n    bytes_per_space = dots_per_space * y_mult;\n\n    /* declare color buffer and related vars */\n    spare_bits = (pdev->width % 8); /* left over bits to go to margin */\n    whole_bits = pdev->width - spare_bits;\n\n    /* Check allocations */\n    if (in == 0 || out == 0) {\n        if (in)\n            gs_free(pdev->memory, (char *)in, in_size + 1, 1,\n                    \"epsc_print_page(in)\");\n        if (out)\n            gs_free(pdev->memory, (char *)out, out_size + 1, 1,\n                    \"epsc_print_page(out)\");\n        return -1;\n    }\n\n    /* Initialize the printer and reset the margins. */\n    gp_fwrite(\"\\033@\\033P\\033l\\000\\033Q\\377\\033U\\001\\r\", 1, 14, prn_stream);\n\n    /* Create color buffer */\n    if (gx_device_has_color(pdev)) {\n        color_line_size = gdev_mem_bytes_per_scan_line((gx_device *) pdev);\n        color_in_size = color_line_size * (8 * y_mult);\n        if ((color_in = (byte *) gs_malloc(pdev->memory, color_in_size + 1, 1,\n                                           \"epsc_print_page(color)\")) == 0) {\n            gs_free(pdev->memory, (char *)in, in_size + 1, 1,\n                    \"epsc_print_page(in)\");\n            gs_free(pdev->memory, (char *)out, out_size + 1, 1,\n                    \"epsc_print_page(out)\");\n            return (-1);\n        }\n    } else {\n        color_in = in;\n        color_in_size = in_size;\n        color_line_size = line_size;\n    }\n\n    /* Print lines of graphics */\n    while (lnum < pdev->height) {\n        int lcnt;\n        byte *nextcolor = NULL; /* position where next color appears */\n        byte *nextmono = NULL;  /* position to map next color */\n\n        /* Copy 1 scan line and test for all zero. */\n        gdev_prn_copy_scan_lines(pdev, lnum, color_in, color_line_size);\n\n        if (color_in[0] == 0 &&\n            !memcmp((char *)color_in, (char *)color_in + 1,\n                    color_line_size - 1)\n            ) {\n            lnum++;\n            skip += 3 / y_mult;\n            continue;\n        }\n\n        /* Vertical tab to the appropriate position. */\n        while (skip > 255) {\n            gp_fputs(\"\\033J\\377\", prn_stream);\n            skip -= 255;\n        }\n        if (skip)\n            gp_fprintf(prn_stream, \"\\033J%c\", skip);\n\n        /* Copy the rest of the scan lines. */\n        lcnt = 1 + gdev_prn_copy_scan_lines(pdev, lnum + 1,\n                                            color_in + color_line_size,\n                                            color_in_size - color_line_size);\n\n        if (lcnt < 8 * y_mult) {\n            memset((char *)(color_in + lcnt * color_line_size), 0,\n                   color_in_size - lcnt * color_line_size);\n            if (gx_device_has_color(pdev))      /* clear the work buffer */\n                memset((char *)(in + lcnt * line_size), 0,\n                       in_size - lcnt * line_size);\n        }\n\n        /*\n        ** We need to create a normal epson scan line from our color scan line\n        ** We do this by setting a bit in the \"in\" buffer if the pixel byte is set\n        ** to any color.  We then search for any more pixels of that color, setting\n        ** \"in\" accordingly.  If any other color is found, we save it for the next\n        ** pass.  There may be up to 7 passes.\n        ** In the future, we should make the passes so as to maximize the\n        ** life of the color ribbon (i.e. go lightest to darkest).\n        */\n        do {\n            byte *inp = in;\n            byte *in_end = in + line_size;\n            byte *out_end = out;\n            byte *out_blk;\n            register byte *outp;\n\n            if (gx_device_has_color(pdev)) {\n                register int i, j;\n                register byte *outbuf, *realbuf;\n                byte current_color;\n                int end_next_bits = whole_bits;\n                int lastbits;\n\n                /* Move to the point in the scanline that has a new color */\n                if (nextcolor) {\n                    realbuf = nextcolor;\n                    outbuf = nextmono;\n                    memset((char *)in, 0, (nextmono - in));\n                    i = nextcolor - color_in;\n                    nextcolor = NULL;\n                    end_next_bits = (i / color_line_size) * color_line_size\n                        + whole_bits;\n                } else {\n                    i = 0;\n                    realbuf = color_in;\n                    outbuf = in;\n                    nextcolor = NULL;\n                }\n                /* move thru the color buffer, turning on the appropriate\n                ** bit in the \"mono\" buffer\", setting pointers to the next\n                ** color and changing the color output of the epson\n                */\n                for (current_color = 0; i <= color_in_size && outbuf < in + in_size; outbuf++) {\n                    /* Remember, line_size is rounded up to next whole byte\n                    ** whereas color_line_size is the proper length\n                    ** We only want to set the proper bits in the last line_size byte.\n                    */\n                    if (spare_bits && i == end_next_bits) {\n                        end_next_bits = whole_bits + i + spare_bits;\n                        lastbits = 8 - spare_bits;\n                    } else\n                        lastbits = 0;\n\n                    for (*outbuf = 0, j = 8;\n                         --j >= lastbits && i <= color_in_size;\n                         realbuf++, i++) {\n                        if (*realbuf) {\n                            if (current_color > 0) {\n                                if (*realbuf == current_color) {\n                                    *outbuf |= 1 << j;\n                                    *realbuf = 0;       /* throw this byte away */\n                                }\n                                /* save this location for next pass */\n                                else if (nextcolor == NULL) {\n                                    nextcolor = realbuf - (7 - j);\n                                    nextmono = outbuf;\n                                }\n                            } else {\n                                *outbuf |= 1 << j;\n                                current_color = *realbuf;       /* set color */\n                                *realbuf = 0;\n                            }\n                        }\n                    }\n                }\n                *outbuf = 0;    /* zero the end, for safe keeping */\n               /* Change color on the EPSON, current_color must be set\n               ** but lets check anyway\n               */\n                if (current_color)\n                    gp_fprintf(prn_stream, \"\\033r%c\", current_color ^ 7);\n            }\n\n            /* We have to 'transpose' blocks of 8 pixels x 8 lines, */\n            /* because that's how the printer wants the data. */\n            /* If we are in a 24-pin mode, we have to transpose */\n            /* groups of 3 lines at a time. */\n\n            if (y_24pin) {\n                for (; inp < in_end; inp++, out_end += 24) {\n                    gdev_prn_transpose_8x8(inp, line_size, out_end, 3);\n                    gdev_prn_transpose_8x8(inp + line_size * 8, line_size,\n                                           out_end + 1, 3);\n                    gdev_prn_transpose_8x8(inp + line_size * 16, line_size,\n                                           out_end + 2, 3);\n                }\n                /* Remove trailing 0s. */\n                while (out_end > out && out_end[-1] == 0 &&\n                       out_end[-2] == 0 && out_end[-3] == 0)\n                    out_end -= 3;\n            } else {\n                for (; inp < in_end; inp++, out_end += 8) {\n                    gdev_prn_transpose_8x8(inp, line_size, out_end, 1);\n                }\n                /* Remove trailing 0s. */\n                while (out_end > out && out_end[-1] == 0)\n                    out_end--;\n            }\n\n            for (pass = first_pass; pass <= last_pass; pass++) {\n                for (out_blk = outp = out; outp < out_end;) {   /* Skip a run of leading 0s. */\n                    /* At least 10 are needed to make tabbing worth it. */\n                    /* We do everything by 3's to avoid having to make */\n                    /* different cases for 9- and 24-pin. */\n\n                    if (*outp == 0 && outp + 12 <= out_end &&\n                        outp[1] == 0 && outp[2] == 0 &&\n                        (outp[3] | outp[4] | outp[5]) == 0 &&\n                        (outp[6] | outp[7] | outp[8]) == 0 &&\n                        (outp[9] | outp[10] | outp[11]) == 0) {\n                        byte *zp = outp;\n                        int tpos;\n                        byte *newp;\n\n                        outp += 12;\n                        while (outp + 3 <= out_end && *outp == 0 &&\n                               outp[1] == 0 && outp[2] == 0)\n                            outp += 3;\n                        tpos = (outp - out) / bytes_per_space;\n                        newp = out + tpos * bytes_per_space;\n                        if (newp > zp + 10) {   /* Output preceding bit data. */\n                            if (zp > out_blk)\n                                /* only false at */\n                                /* beginning of line */\n                                epsc_output_run(out_blk, (int)(zp - out_blk),\n                                                y_mult, start_graphics,\n                                                prn_stream, pass);\n                            /* Tab over to the appropriate position. */\n                            gp_fprintf(prn_stream, \"\\033D%c%c\\t\", tpos, 0);\n                            out_blk = outp = newp;\n                        }\n                    } else\n                        outp += y_mult;\n                }\n                if (outp > out_blk)\n                    epsc_output_run(out_blk, (int)(outp - out_blk),\n                                    y_mult, start_graphics, prn_stream, pass);\n\n                gp_fputc('\\r', prn_stream);\n            }\n        } while (nextcolor);\n        skip = 24;\n        lnum += 8 * y_mult;\n    }\n\n    /* Eject the page and reinitialize the printer */\n    gp_fputs(\"\\f\\033@\", prn_stream);\n\n    gs_free(pdev->memory, (char *)out, out_size + 1, 1,\n            \"epsc_print_page(out)\");\n    gs_free(pdev->memory, (char *)in, in_size + 1, 1, \"epsc_print_page(in)\");\n    if (gx_device_has_color(pdev))\n        gs_free(pdev->memory, (char *)color_in, color_in_size + 1, 1,\n                \"epsc_print_page(rin)\");\n    return 0;\n}", "target": 1, "idx": 10419}
{"commit_id": "114b8b13ab4fd5c83eb42986946b0051fdd10127", "project": "chromium", "func": "bool FrameFetchContext::canRequest(Resource::Type type, const ResourceRequest& resourceRequest, const KURL& url, const ResourceLoaderOptions& options, bool forPreload, FetchRequest::OriginRestriction originRestriction) const\n{\n    // As of CSP2, for requests that are the results of redirects, the match\n    // algorithm should ignore the path component of the URL.\n    ContentSecurityPolicy::RedirectStatus redirectStatus = resourceRequest.followedRedirect() ? ContentSecurityPolicy::DidRedirect : ContentSecurityPolicy::DidNotRedirect;\n\n    ResourceRequestBlockedReason reason = canRequestInternal(type, resourceRequest, url, options, forPreload, originRestriction, redirectStatus);\n    if (reason != ResourceRequestBlockedReasonNone) {\n        if (!forPreload)\n            InspectorInstrumentation::didBlockRequest(frame(), resourceRequest, ensureLoaderForNotifications(), options.initiatorInfo, reason);\n        return false;\n    }\n    return true;\n}", "target": 1, "idx": 10420}
{"commit_id": "2421876859008ac498de722511f3b105b496ac56", "project": "OP-TEE/optee_os", "func": "void mpa_exp_mod(mpanum dest,\n\t\t const mpanum op1,\n\t\t const mpanum op2,\n\t\t const mpanum n,\n\t\t const mpanum r_modn,\n\t\t const mpanum r2_modn,\n\t\t const mpa_word_t n_inv, mpa_scratch_mem pool)\n{\n\tmpanum A;\n\tmpanum tmp_a;\n\tmpanum xtilde;\n\tmpanum tmp_xtilde;\n\tmpanum *ptr_a;\n\tmpanum *ptr_tmp_a;\n\tmpanum *ptr_xtilde;\n\tmpanum *ptr_tmp_xtilde;\n\tint idx;\n\n\tmpa_alloc_static_temp_var(&A, pool);\n\tmpa_alloc_static_temp_var(&tmp_a, pool);\n\tmpa_alloc_static_temp_var(&xtilde, pool);\n\tmpa_alloc_static_temp_var(&tmp_xtilde, pool);\n\n\t/*\n\t * Transform the base (op1) into Montgomery space. Use internal version\n\t * since xtilde is big enough.\n\t */\n\t__mpa_montgomery_mul(xtilde, op1, r2_modn, n, n_inv);\n\n\tmpa_copy(A, r_modn);\n\n\tptr_a = &A;\n\tptr_tmp_a = &tmp_a;\n\tptr_xtilde = &xtilde;\n\tptr_tmp_xtilde = &tmp_xtilde;\n\n\t__mpa_set_unused_digits_to_zero(A);\n\t__mpa_set_unused_digits_to_zero(xtilde);\n\n\tfor (idx = mpa_highest_bit_index(op2); idx >= 0; idx--) {\n\t\tif (mpa_get_bit(op2, idx) == 0) {\n\t\t\t/* x' = A*x' */\n\t\t\t__mpa_montgomery_mul(*ptr_tmp_xtilde, *ptr_a,\n\t\t\t\t\t     *ptr_xtilde, n, n_inv);\n\n\t\t\t/* A = A^2 */\n\t\t\t__mpa_montgomery_mul(*ptr_tmp_a, *ptr_a, *ptr_a, n,\n\t\t\t\t\t     n_inv);\n\t\t} else {\n\t\t\t/* A = A*x' */\n\t\t\t__mpa_montgomery_mul(*ptr_tmp_a, *ptr_a, *ptr_xtilde, n,\n\t\t\t\t\t     n_inv);\n\n\t\t\t/* x' = x'^2 */\n\t\t\t__mpa_montgomery_mul(*ptr_tmp_xtilde, *ptr_xtilde,\n\t\t\t\t\t     *ptr_xtilde, n, n_inv);\n\t\t}\n\n\t\t/*\n\t\t * The simple reason for swapping here is to avoid copy\n\t\t * intermediate results, instead we're just moving the pointers.\n\t\t */\n\t\tswp(&ptr_tmp_a, &ptr_a);\n\t\tswp(&ptr_tmp_xtilde, &ptr_xtilde);\n\t}\n\n\t/* Transform back from Montgomery space */\n\t__mpa_montgomery_mul(*ptr_tmp_a, (const mpanum)&const_one, *ptr_a,\n\t\t\t     n, n_inv);\n\n\tmpa_copy(dest, *ptr_tmp_a);\n\n\tmpa_free_static_temp_var(&A, pool);\n\tmpa_free_static_temp_var(&tmp_a, pool);\n\tmpa_free_static_temp_var(&xtilde, pool);\n\tmpa_free_static_temp_var(&tmp_xtilde, pool);\n}", "target": 2, "idx": 10421}
{"commit_id": "5d069dbe8aaf2a197142558b6fb2978189ba3454", "project": "torvalds/linux", "func": "int fuse_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\tint err;\n\n\tif (fuse_is_bad(inode))\n\t\treturn -EIO;\n\n\tmutex_lock(&ff->readdir.lock);\n\n\terr = UNCACHED;\n\tif (ff->open_flags & FOPEN_CACHE_DIR)\n\t\terr = fuse_readdir_cached(file, ctx);\n\tif (err == UNCACHED)\n\t\terr = fuse_readdir_uncached(file, ctx);\n\n\tmutex_unlock(&ff->readdir.lock);\n\n\treturn err;\n}", "target": 1, "idx": 10422}
{"commit_id": "c37e9e013469521d9adb932d17a1795c139b36db", "project": "torvalds/linux", "func": "static int __ext4_get_inode_loc(struct inode *inode,\n\t\t\t\tstruct ext4_iloc *iloc, int in_mem)\n{\n\tstruct ext4_group_desc\t*gdp;\n\tstruct buffer_head\t*bh;\n\tstruct super_block\t*sb = inode->i_sb;\n\text4_fsblk_t\t\tblock;\n\tint\t\t\tinodes_per_block, inode_offset;\n\n\tiloc->bh = NULL;\n\tif (inode->i_ino < EXT4_ROOT_INO ||\n\t    inode->i_ino > le32_to_cpu(EXT4_SB(sb)->s_es->s_inodes_count))\n\t\treturn -EFSCORRUPTED;\n\n\tiloc->block_group = (inode->i_ino - 1) / EXT4_INODES_PER_GROUP(sb);\n\tgdp = ext4_get_group_desc(sb, iloc->block_group, NULL);\n\tif (!gdp)\n\t\treturn -EIO;\n\n\t/*\n\t * Figure out the offset within the block group inode table\n\t */\n\tinodes_per_block = EXT4_SB(sb)->s_inodes_per_block;\n\tinode_offset = ((inode->i_ino - 1) %\n\t\t\tEXT4_INODES_PER_GROUP(sb));\n\tblock = ext4_inode_table(sb, gdp) + (inode_offset / inodes_per_block);\n\tiloc->offset = (inode_offset % inodes_per_block) * EXT4_INODE_SIZE(sb);\n\n\tbh = sb_getblk(sb, block);\n\tif (unlikely(!bh))\n\t\treturn -ENOMEM;\n\tif (!buffer_uptodate(bh)) {\n\t\tlock_buffer(bh);\n\n\t\t/*\n\t\t * If the buffer has the write error flag, we have failed\n\t\t * to write out another inode in the same block.  In this\n\t\t * case, we don't have to read the block because we may\n\t\t * read the old inode data successfully.\n\t\t */\n\t\tif (buffer_write_io_error(bh) && !buffer_uptodate(bh))\n\t\t\tset_buffer_uptodate(bh);\n\n\t\tif (buffer_uptodate(bh)) {\n\t\t\t/* someone brought it uptodate while we waited */\n\t\t\tunlock_buffer(bh);\n\t\t\tgoto has_buffer;\n\t\t}\n\n\t\t/*\n\t\t * If we have all information of the inode in memory and this\n\t\t * is the only valid inode in the block, we need not read the\n\t\t * block.\n\t\t */\n\t\tif (in_mem) {\n\t\t\tstruct buffer_head *bitmap_bh;\n\t\t\tint i, start;\n\n\t\t\tstart = inode_offset & ~(inodes_per_block - 1);\n\n\t\t\t/* Is the inode bitmap in cache? */\n\t\t\tbitmap_bh = sb_getblk(sb, ext4_inode_bitmap(sb, gdp));\n\t\t\tif (unlikely(!bitmap_bh))\n\t\t\t\tgoto make_io;\n\n\t\t\t/*\n\t\t\t * If the inode bitmap isn't in cache then the\n\t\t\t * optimisation may end up performing two reads instead\n\t\t\t * of one, so skip it.\n\t\t\t */\n\t\t\tif (!buffer_uptodate(bitmap_bh)) {\n\t\t\t\tbrelse(bitmap_bh);\n\t\t\t\tgoto make_io;\n\t\t\t}\n\t\t\tfor (i = start; i < start + inodes_per_block; i++) {\n\t\t\t\tif (i == inode_offset)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ext4_test_bit(i, bitmap_bh->b_data))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbrelse(bitmap_bh);\n\t\t\tif (i == start + inodes_per_block) {\n\t\t\t\t/* all other inodes are free, so skip I/O */\n\t\t\t\tmemset(bh->b_data, 0, bh->b_size);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tgoto has_buffer;\n\t\t\t}\n\t\t}\n\nmake_io:\n\t\t/*\n\t\t * If we need to do any I/O, try to pre-readahead extra\n\t\t * blocks from the inode table.\n\t\t */\n\t\tif (EXT4_SB(sb)->s_inode_readahead_blks) {\n\t\t\text4_fsblk_t b, end, table;\n\t\t\tunsigned num;\n\t\t\t__u32 ra_blks = EXT4_SB(sb)->s_inode_readahead_blks;\n\n\t\t\ttable = ext4_inode_table(sb, gdp);\n\t\t\t/* s_inode_readahead_blks is always a power of 2 */\n\t\t\tb = block & ~((ext4_fsblk_t) ra_blks - 1);\n\t\t\tif (table > b)\n\t\t\t\tb = table;\n\t\t\tend = b + ra_blks;\n\t\t\tnum = EXT4_INODES_PER_GROUP(sb);\n\t\t\tif (ext4_has_group_desc_csum(sb))\n\t\t\t\tnum -= ext4_itable_unused_count(sb, gdp);\n\t\t\ttable += num / inodes_per_block;\n\t\t\tif (end > table)\n\t\t\t\tend = table;\n\t\t\twhile (b <= end)\n\t\t\t\tsb_breadahead(sb, b++);\n\t\t}\n\n\t\t/*\n\t\t * There are other valid inodes in the buffer, this inode\n\t\t * has in-inode xattrs, or we don't have this inode in memory.\n\t\t * Read the block from disk.\n\t\t */\n\t\ttrace_ext4_load_inode(inode);\n\t\tget_bh(bh);\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(REQ_OP_READ, REQ_META | REQ_PRIO, bh);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\tEXT4_ERROR_INODE_BLOCK(inode, block,\n\t\t\t\t\t       \"unable to read itable block\");\n\t\t\tbrelse(bh);\n\t\t\treturn -EIO;\n\t\t}\n\t}\nhas_buffer:\n\tiloc->bh = bh;\n\treturn 0;\n}", "target": 1, "idx": 10423}
{"commit_id": "92742544a56bcbcd9ec99ca15f898b31797e39e2", "project": "LINBIT/csync2", "func": "int conn_activate_ssl(int server_role)\n{\n\tgnutls_alert_description_t alrt;\n\tchar *ssl_keyfile;\n\tchar *ssl_certfile;\n\tint err;\n\tint handshake_repeat = 0;\n\n\tif (csync_conn_usessl)\n\t\treturn 0;\n\n\tASPRINTF(&ssl_keyfile, \"%s/csync2_ssl_key.pem\", systemdir);\n\tASPRINTF(&ssl_certfile, \"%s/csync2_ssl_cert.pem\", systemdir);\n\n\tgnutls_global_init();\n\tgnutls_global_set_log_function(ssl_log);\n\tgnutls_global_set_log_level(10);\n\n\tgnutls_certificate_allocate_credentials(&conn_x509_cred);\n\n\terr = gnutls_certificate_set_x509_key_file(conn_x509_cred, ssl_certfile, ssl_keyfile, GNUTLS_X509_FMT_PEM);\n\tif(err != GNUTLS_E_SUCCESS) {\n\t\tgnutls_certificate_free_credentials(conn_x509_cred);\n\t\tgnutls_global_deinit();\n\n\t\tcsync_fatal(\n\t\t\t\"SSL: failed to use key file %s and/or certificate file %s: %s (%s)\\n\",\n\t\t\tssl_keyfile,\n\t\t\tssl_certfile,\n\t\t\tgnutls_strerror(err),\n\t\t\tgnutls_strerror_name(err)\n\t\t);\n\t}\n\n\tif(server_role) {\n\t\tgnutls_certificate_free_cas(conn_x509_cred);\n\n\t\tif(gnutls_certificate_set_x509_trust_file(conn_x509_cred, ssl_certfile, GNUTLS_X509_FMT_PEM) < 1) {\n\t\t\tgnutls_certificate_free_credentials(conn_x509_cred);\n\t\t\tgnutls_global_deinit();\n\n\t\t\tcsync_fatal(\n\t\t\t\t\"SSL: failed to use certificate file %s as CA.\\n\",\n\t\t\t\tssl_certfile\n\t\t\t);\n\t\t}\n\t} else\n\t\tgnutls_certificate_free_ca_names(conn_x509_cred);\n\n\tgnutls_init(&conn_tls_session, (server_role ? GNUTLS_SERVER : GNUTLS_CLIENT));\n\tgnutls_priority_set_direct(conn_tls_session, \"PERFORMANCE\", NULL);\n\tgnutls_credentials_set(conn_tls_session, GNUTLS_CRD_CERTIFICATE, conn_x509_cred);\n\n\tif(server_role) {\n\t\tgnutls_certificate_send_x509_rdn_sequence(conn_tls_session, 0);\n\t\tgnutls_certificate_server_set_request(conn_tls_session, GNUTLS_CERT_REQUIRE);\n\t}\n\n\tgnutls_transport_set_ptr2(\n\t\tconn_tls_session,\n\t\t(gnutls_transport_ptr_t)(long)conn_fd_in,\n\t\t(gnutls_transport_ptr_t)(long)conn_fd_out\n\t);\n\n\n\tdo {\n\t\thandshake_repeat = 0;\n\t\terr = gnutls_handshake(conn_tls_session);\n\t\tswitch(err) {\n\t\tcase GNUTLS_E_SUCCESS:\n\t\t\tbreak;\n\n\t\tcase GNUTLS_E_WARNING_ALERT_RECEIVED:\n\t\t\talrt = gnutls_alert_get(conn_tls_session);\n\t\t\tfprintf(\n\t\t\t\tcsync_debug_out,\n\t\t\t\t\"SSL: warning alert received from peer: %d (%s).\\n\",\n\t\t\t\talrt, gnutls_alert_get_name(alrt)\n\t\t\t);\n\t\t\thandshake_repeat = 1;\n\t\t\tbreak;\n\n\t\tcase GNUTLS_E_FATAL_ALERT_RECEIVED:\n\t\t\talrt = gnutls_alert_get(conn_tls_session);\n\t\t\tfprintf(\n\t\t\t\tcsync_debug_out,\n\t\t\t\t\"SSL: fatal alert received from peer: %d (%s).\\n\",\n\t\t\t\talrt, gnutls_alert_get_name(alrt)\n\t\t\t);\n\t\t\t// fall-through!\n\n\t\tdefault:\n\t\t\tgnutls_bye(conn_tls_session, GNUTLS_SHUT_RDWR);\n\t\t\tgnutls_deinit(conn_tls_session);\n\t\t\tgnutls_certificate_free_credentials(conn_x509_cred);\n\t\t\tgnutls_global_deinit();\n\n\t\t\tcsync_fatal(\n\t\t\t\t\"SSL: handshake failed: %s (%s)\\n\",\n\t\t\t\tgnutls_strerror(err),\n\t\t\t\tgnutls_strerror_name(err)\n\t\t\t);\n\t\t}\n\t} while (handshake_repeat);\n\n\tcsync_conn_usessl = 1;\n\n\treturn 0;\n}", "target": 1, "idx": 10424}
{"commit_id": "11855d8a1f11b102a702ab76e95b22082cccf2f8", "project": "binutils-gdb", "func": "static bfd_boolean\nscan_unit_for_symbols (struct comp_unit *unit)\n{\n  bfd *abfd = unit->abfd;\n  bfd_byte *info_ptr = unit->first_child_die_ptr;\n  bfd_byte *info_ptr_end = unit->stash->info_ptr_end;\n  int nesting_level = 0;\n  struct nest_funcinfo {\n    struct funcinfo *func;\n  } *nested_funcs;\n  int nested_funcs_size;\n\n  /* Maintain a stack of in-scope functions and inlined functions, which we\n     can use to set the caller_func field.  */\n  nested_funcs_size = 32;\n  nested_funcs = (struct nest_funcinfo *)\n    bfd_malloc (nested_funcs_size * sizeof (*nested_funcs));\n  if (nested_funcs == NULL)\n    return FALSE;\n  nested_funcs[nesting_level].func = 0;\n\n  while (nesting_level >= 0)\n    {\n      unsigned int abbrev_number, bytes_read, i;\n      struct abbrev_info *abbrev;\n      struct attribute attr;\n      struct funcinfo *func;\n      struct varinfo *var;\n      bfd_vma low_pc = 0;\n      bfd_vma high_pc = 0;\n      bfd_boolean high_pc_relative = FALSE;\n\n      /* PR 17512: file: 9f405d9d.  */\n      if (info_ptr >= info_ptr_end)\n\tgoto fail;\n\n      abbrev_number = _bfd_safe_read_leb128 (abfd, info_ptr, &bytes_read,\n\t\t\t\t\t     FALSE, info_ptr_end);\n      info_ptr += bytes_read;\n\n      if (! abbrev_number)\n\t{\n\t  nesting_level--;\n\t  continue;\n\t}\n\n      abbrev = lookup_abbrev (abbrev_number, unit->abbrevs);\n      if (! abbrev)\n\t{\n\t  static unsigned int previous_failed_abbrev = -1U;\n\n\t  /* Avoid multiple reports of the same missing abbrev.  */\n\t  if (abbrev_number != previous_failed_abbrev)\n\t    {\n\t      _bfd_error_handler\n\t\t(_(\"Dwarf Error: Could not find abbrev number %u.\"),\n\t\t abbrev_number);\n\t      previous_failed_abbrev = abbrev_number;\n\t    }\n\t  bfd_set_error (bfd_error_bad_value);\n\t  goto fail;\n\t}\n\n      var = NULL;\n      if (abbrev->tag == DW_TAG_subprogram\n\t  || abbrev->tag == DW_TAG_entry_point\n\t  || abbrev->tag == DW_TAG_inlined_subroutine)\n\t{\n\t  bfd_size_type amt = sizeof (struct funcinfo);\n\t  func = (struct funcinfo *) bfd_zalloc (abfd, amt);\n\t  if (func == NULL)\n\t    goto fail;\n\t  func->tag = abbrev->tag;\n\t  func->prev_func = unit->function_table;\n\t  unit->function_table = func;\n\t  unit->number_of_functions++;\n\t  BFD_ASSERT (!unit->cached);\n\n\t  if (func->tag == DW_TAG_inlined_subroutine)\n\t    for (i = nesting_level; i-- != 0; )\n\t      if (nested_funcs[i].func)\n\t\t{\n\t\t  func->caller_func = nested_funcs[i].func;\n\t\t  break;\n\t\t}\n\t  nested_funcs[nesting_level].func = func;\n\t}\n      else\n\t{\n\t  func = NULL;\n\t  if (abbrev->tag == DW_TAG_variable)\n\t    {\n\t      bfd_size_type amt = sizeof (struct varinfo);\n\t      var = (struct varinfo *) bfd_zalloc (abfd, amt);\n\t      if (var == NULL)\n\t\tgoto fail;\n\t      var->tag = abbrev->tag;\n\t      var->stack = 1;\n\t      var->prev_var = unit->variable_table;\n\t      unit->variable_table = var;\n\t      /* PR 18205: Missing debug information can cause this\n\t\t var to be attached to an already cached unit.  */\n\t    }\n\n\t  /* No inline function in scope at this nesting level.  */\n\t  nested_funcs[nesting_level].func = 0;\n\t}\n\n      for (i = 0; i < abbrev->num_attrs; ++i)\n\t{\n\t  info_ptr = read_attribute (&attr, &abbrev->attrs[i],\n\t\t\t\t     unit, info_ptr, info_ptr_end);\n\t  if (info_ptr == NULL)\n\t    goto fail;\n\n\t  if (func)\n\t    {\n\t      switch (attr.name)\n\t\t{\n\t\tcase DW_AT_call_file:\n\t\t  func->caller_file = concat_filename (unit->line_table,\n\t\t\t\t\t\t       attr.u.val);\n\t\t  break;\n\n\t\tcase DW_AT_call_line:\n\t\t  func->caller_line = attr.u.val;\n\t\t  break;\n\n\t\tcase DW_AT_abstract_origin:\n\t\tcase DW_AT_specification:\n\t\t  if (!find_abstract_instance_name (unit, info_ptr, &attr,\n\t\t\t\t\t\t    &func->name,\n\t\t\t\t\t\t    &func->is_linkage))\n\t\t    goto fail;\n\t\t  break;\n\n\t\tcase DW_AT_name:\n\t\t  /* Prefer DW_AT_MIPS_linkage_name or DW_AT_linkage_name\n\t\t     over DW_AT_name.  */\n\t\t  if (func->name == NULL && is_str_attr (attr.form))\n\t\t    {\n\t\t      func->name = attr.u.str;\n\t\t      if (non_mangled (unit->lang))\n\t\t\tfunc->is_linkage = TRUE;\n\t\t    }\n\t\t  break;\n\n\t\tcase DW_AT_linkage_name:\n\t\tcase DW_AT_MIPS_linkage_name:\n\t\t  /* PR 16949:  Corrupt debug info can place\n\t\t     non-string forms into these attributes.  */\n\t\t  if (is_str_attr (attr.form))\n\t\t    {\n\t\t      func->name = attr.u.str;\n\t\t      func->is_linkage = TRUE;\n\t\t    }\n\t\t  break;\n\n\t\tcase DW_AT_low_pc:\n\t\t  low_pc = attr.u.val;\n\t\t  break;\n\n\t\tcase DW_AT_high_pc:\n\t\t  high_pc = attr.u.val;\n\t\t  high_pc_relative = attr.form != DW_FORM_addr;\n\t\t  break;\n\n\t\tcase DW_AT_ranges:\n\t\t  if (!read_rangelist (unit, &func->arange, attr.u.val))\n\t\t    goto fail;\n\t\t  break;\n\n\t\tcase DW_AT_decl_file:\n\t\t  func->file = concat_filename (unit->line_table,\n\t\t\t\t\t\tattr.u.val);\n\t\t  break;\n\n\t\tcase DW_AT_decl_line:\n\t\t  func->line = attr.u.val;\n\t\t  break;\n\n\t\tdefault:\n\t\t  break;\n\t\t}\n\t    }\n\t  else if (var)\n\t    {\n\t      switch (attr.name)\n\t\t{\n\t\tcase DW_AT_name:\n\t\t  if (is_str_attr (attr.form))\n\t\t    var->name = attr.u.str;\n\t\t  break;\n\n\t\tcase DW_AT_decl_file:\n\t\t  var->file = concat_filename (unit->line_table,\n\t\t\t\t\t       attr.u.val);\n\t\t  break;\n\n\t\tcase DW_AT_decl_line:\n\t\t  var->line = attr.u.val;\n\t\t  break;\n\n\t\tcase DW_AT_external:\n\t\t  if (attr.u.val != 0)\n\t\t    var->stack = 0;\n\t\t  break;\n\n\t\tcase DW_AT_location:\n\t\t  switch (attr.form)\n\t\t    {\n\t\t    case DW_FORM_block:\n\t\t    case DW_FORM_block1:\n\t\t    case DW_FORM_block2:\n\t\t    case DW_FORM_block4:\n\t\t    case DW_FORM_exprloc:\n\t\t      if (attr.u.blk->data != NULL\n\t\t\t  && *attr.u.blk->data == DW_OP_addr)\n\t\t\t{\n\t\t\t  var->stack = 0;\n\n\t\t\t  /* Verify that DW_OP_addr is the only opcode in the\n\t\t\t     location, in which case the block size will be 1\n\t\t\t     plus the address size.  */\n\t\t\t  /* ??? For TLS variables, gcc can emit\n\t\t\t     DW_OP_addr <addr> DW_OP_GNU_push_tls_address\n\t\t\t     which we don't handle here yet.  */\n\t\t\t  if (attr.u.blk->size == unit->addr_size + 1U)\n\t\t\t    var->addr = bfd_get (unit->addr_size * 8,\n\t\t\t\t\t\t unit->abfd,\n\t\t\t\t\t\t attr.u.blk->data + 1);\n\t\t\t}\n\t\t      break;\n\n\t\t    default:\n\t\t      break;\n\t\t    }\n\t\t  break;\n\n\t\tdefault:\n\t\t  break;\n\t\t}\n\t    }\n\t}\n\n      if (high_pc_relative)\n\thigh_pc += low_pc;\n\n      if (func && high_pc != 0)\n\t{\n\t  if (!arange_add (unit, &func->arange, low_pc, high_pc))\n\t    goto fail;\n\t}\n\n      if (abbrev->has_children)\n\t{\n\t  nesting_level++;\n\n\t  if (nesting_level >= nested_funcs_size)\n\t    {\n\t      struct nest_funcinfo *tmp;\n\n\t      nested_funcs_size *= 2;\n\t      tmp = (struct nest_funcinfo *)\n\t\tbfd_realloc (nested_funcs,\n\t\t\t     nested_funcs_size * sizeof (*nested_funcs));\n\t      if (tmp == NULL)\n\t\tgoto fail;\n\t      nested_funcs = tmp;\n\t    }\n\t  nested_funcs[nesting_level].func = 0;\n\t}\n    }\n\n  free (nested_funcs);\n  return TRUE;\n\n fail:\n  free (nested_funcs);\n  return FALSE;\n}", "target": 1, "idx": 10425}
{"commit_id": "04f25edb48c441fc278ecc154c270f16966cbb90", "project": "torvalds/linux", "func": "static int hclge_tm_schd_mode_vnet_base_cfg(struct hclge_vport *vport)\n{\n\tstruct hnae3_knic_private_info *kinfo = &vport->nic.kinfo;\n\tstruct hclge_dev *hdev = vport->back;\n\tint ret;\n\tu8 i;\n\n\tif (vport->vport_id >= HNAE3_MAX_TC)\n\t\treturn -EINVAL;\n\n\tret = hclge_tm_pri_schd_mode_cfg(hdev, vport->vport_id);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < kinfo->num_tc; i++) {\n\t\tu8 sch_mode = hdev->tm_info.tc_info[i].tc_sch_mode;\n\n\t\tret = hclge_tm_qs_schd_mode_cfg(hdev, vport->qs_offset + i,\n\t\t\t\t\t\tsch_mode);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "target": 2, "idx": 10426}
{"commit_id": "afb9ff7982971aba6e42472de0db4c1bedfc641b", "project": "wireshark", "func": "static void\nmbim_dissect_sms_read_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gint offset,\n                           struct mbim_conv_info *mbim_conv)\n{\n    proto_tree *subtree;\n    gint base_offset;\n    guint32 i, format, element_count;\n    wmem_array_t *pair_list;\n    struct mbim_pair_list pair_list_item, *p_pair_list_item;\n\n    base_offset = offset;\n    proto_tree_add_item_ret_uint(tree, hf_mbim_sms_read_info_format, tvb, offset, 4, ENC_LITTLE_ENDIAN, &format);\n    offset += 4;\n    proto_tree_add_item_ret_uint(tree, hf_mbim_sms_read_info_element_count, tvb, offset, 4, ENC_LITTLE_ENDIAN, &element_count);\n    offset += 4;\n    if (element_count) {\n        pair_list = wmem_array_new(wmem_packet_scope(), sizeof(struct mbim_pair_list));\n        subtree = proto_tree_add_subtree(tree, tvb, offset, 8*element_count, ett_mbim_pair_list, NULL, \"SMS Ref List\");\n        for (i = 0; i < element_count; i++) {\n            proto_tree_add_item_ret_uint(subtree, hf_mbim_sms_read_info_sms_offset,\n                                tvb, offset, 4, ENC_LITTLE_ENDIAN, &pair_list_item.offset);\n            offset += 4;\n            proto_tree_add_item_ret_uint(subtree, hf_mbim_sms_read_info_sms_size,\n                                tvb, offset, 4, ENC_LITTLE_ENDIAN, &pair_list_item.size);\n            offset += 4;\n            wmem_array_append_one(pair_list, pair_list_item);\n        }\n        for (i = 0; i < element_count; i++) {\n            p_pair_list_item = (struct mbim_pair_list*)wmem_array_index(pair_list, i);\n            if (p_pair_list_item->offset && p_pair_list_item->size) {\n                subtree = proto_tree_add_subtree_format(tree, tvb, base_offset + p_pair_list_item->offset,\n                                         p_pair_list_item->size, ett_mbim_pair_list, NULL, \"SMS Element #%u\", i+1);\n                if (format == MBIM_SMS_FORMAT_PDU) {\n                    mbim_dissect_sms_pdu_record(tvb, pinfo, subtree, base_offset + p_pair_list_item->offset, mbim_conv);\n                } else if (format == MBIM_SMS_FORMAT_CDMA) {\n                    mbim_dissect_sms_cdma_record(tvb, pinfo, subtree, base_offset + p_pair_list_item->offset);\n                } else {\n                    proto_tree_add_expert(subtree, pinfo, &ei_mbim_unknown_sms_format, tvb,\n                                          base_offset + p_pair_list_item->offset, p_pair_list_item->size);\n                }\n            }\n        }\n    }\n}", "target": 2, "idx": 10427}
{"commit_id": "7dac4a1726a9c64a517d595c40e95e2d0d135f6f", "project": "kernel/git/tytso/ext4", "func": "static ext4_fsblk_t ext4_valid_block_bitmap(struct super_block *sb,\n\t\t\t\t\t    struct ext4_group_desc *desc,\n\t\t\t\t\t    ext4_group_t block_group,\n\t\t\t\t\t    struct buffer_head *bh)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_grpblk_t offset;\n\text4_grpblk_t next_zero_bit;\n\text4_fsblk_t blk;\n\text4_fsblk_t group_first_block;\n\n\tif (ext4_has_feature_flex_bg(sb)) {\n\t\t/* with FLEX_BG, the inode/block bitmaps and itable\n\t\t * blocks may not be in the group at all\n\t\t * so the bitmap validation will be skipped for those groups\n\t\t * or it has to also read the block group where the bitmaps\n\t\t * are located to verify they are set.\n\t\t */\n\t\treturn 0;\n\t}\n\tgroup_first_block = ext4_group_first_block_no(sb, block_group);\n\n\t/* check whether block bitmap block number is set */\n\tblk = ext4_block_bitmap(sb, desc);\n\toffset = blk - group_first_block;\n\tif (offset < 0 || EXT4_B2C(sbi, offset) >= sb->s_blocksize ||\n\t    !ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n\t\t/* bad block bitmap */\n\t\treturn blk;\n\n\t/* check whether the inode bitmap block number is set */\n\tblk = ext4_inode_bitmap(sb, desc);\n\toffset = blk - group_first_block;\n\tif (offset < 0 || EXT4_B2C(sbi, offset) >= sb->s_blocksize ||\n\t    !ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n\t\t/* bad block bitmap */\n\t\treturn blk;\n\n\t/* check whether the inode table block number is set */\n\tblk = ext4_inode_table(sb, desc);\n\toffset = blk - group_first_block;\n\tif (offset < 0 || EXT4_B2C(sbi, offset) >= sb->s_blocksize ||\n\t    EXT4_B2C(sbi, offset + sbi->s_itb_per_group) >= sb->s_blocksize)\n\t\treturn blk;\n\tnext_zero_bit = ext4_find_next_zero_bit(bh->b_data,\n\t\t\tEXT4_B2C(sbi, offset + sbi->s_itb_per_group),\n\t\t\tEXT4_B2C(sbi, offset));\n\tif (next_zero_bit <\n\t    EXT4_B2C(sbi, offset + sbi->s_itb_per_group))\n\t\t/* bad bitmap for inode tables */\n\t\treturn blk;\n\treturn 0;\n}", "target": 1, "idx": 10428}
{"commit_id": "769714fcb569e7a4faff9530a2d9ac1f9d6e5680", "project": "keepkey/keepkey-firmware", "func": "void recovery_character(const char *character)\n{\n    if (!awaiting_character || !recovery_started) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_UnexpectedMessage, \"Not in Recovery mode\");\n        layoutHome();\n        return;\n    }\n\n    if (strlen(mnemonic) + 1 > MNEMONIC_BUF - 1) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_UnexpectedMessage,\n                        \"Too many characters attempted during recovery\");\n        layoutHome();\n        return;\n    }\n\n    char *pos = strchr(cipher, character[0]);\n\n    // If not a space and not a legitmate cipher character, send failure.\n    if (character[0] != ' ' && pos == NULL) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_SyntaxError, \"Character must be from a to z\");\n        layoutHome();\n        return;\n    }\n\n    // Count of words we think the user has entered without using the cipher:\n    static int uncyphered_word_count = 0;\n    static bool definitely_using_cipher = false;\n    static CONFIDENTIAL char coded_word[12];\n    static CONFIDENTIAL char decoded_word[12];\n\n    if (!mnemonic[0]) {\n        uncyphered_word_count = 0;\n        definitely_using_cipher = false;\n        memzero(coded_word, sizeof(coded_word));\n        memzero(decoded_word, sizeof(decoded_word));\n    }\n\n    char decoded_character[2] = \" \";\n    if (character[0] != ' ') {\n        // Decode character using cipher if not space\n        decoded_character[0] = english_alphabet[(int)(pos - cipher)];\n\n        strlcat(coded_word, character, sizeof(coded_word));\n        strlcat(decoded_word, decoded_character, sizeof(decoded_word));\n\n        if (enforce_wordlist && 4 <= strlen(coded_word)) {\n            // Check & bail if the user is entering their seed without using the\n            // cipher. Note that for each word, this can give false positives about\n            // ~0.4% of the time (2048/26^4).\n\n            bool maybe_not_using_cipher = attempt_auto_complete(coded_word);\n            bool maybe_using_cipher = attempt_auto_complete(decoded_word);\n\n            if (!maybe_not_using_cipher && maybe_using_cipher) {\n                // Decrease the overall false positive rate by detecting that a\n                // user has entered a word which is definitely using the\n                // cipher.\n                definitely_using_cipher = true;\n            } else if (maybe_not_using_cipher && !definitely_using_cipher &&\n                       MAX_UNCYPHERED_WORDS < uncyphered_word_count++) {\n                recovery_abort();\n                fsm_sendFailure(FailureType_Failure_SyntaxError,\n                                \"Words were not entered correctly. Make sure you are using the substition cipher.\");\n                layoutHome();\n                return;\n            }\n        }\n    } else {\n        memzero(coded_word, sizeof(coded_word));\n        memzero(decoded_word, sizeof(decoded_word));\n    }\n\n    // concat to mnemonic\n    strlcat(mnemonic, decoded_character, MNEMONIC_BUF);\n\n    next_character();\n}", "target": 2, "idx": 10429}
{"commit_id": "76ca8da989c7d97a7f76c75d475fe95a584439d7", "project": "torvalds/linux", "func": "static void bigben_set_led(struct led_classdev *led,\n\tenum led_brightness value)\n{\n\tstruct device *dev = led->dev->parent;\n\tstruct hid_device *hid = to_hid_device(dev);\n\tstruct bigben_device *bigben = hid_get_drvdata(hid);\n\tint n;\n\tbool work;\n\tunsigned long flags;\n\n\tif (!bigben) {\n\t\thid_err(hid, \"no device data\\n\");\n\t\treturn;\n\t}\n\n\tfor (n = 0; n < NUM_LEDS; n++) {\n\t\tif (led == bigben->leds[n]) {\n\t\t\tspin_lock_irqsave(&bigben->lock, flags);\n\t\t\tif (value == LED_OFF) {\n\t\t\t\twork = (bigben->led_state & BIT(n));\n\t\t\t\tbigben->led_state &= ~BIT(n);\n\t\t\t} else {\n\t\t\t\twork = !(bigben->led_state & BIT(n));\n\t\t\t\tbigben->led_state |= BIT(n);\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&bigben->lock, flags);\n\n\t\t\tif (work) {\n\t\t\t\tbigben->work_led = true;\n\t\t\t\tbigben_schedule_work(bigben);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n}", "target": 1, "idx": 10430}
{"commit_id": "527cbd4a104cb93bf3994b3dd3619a6299a78b13", "project": "sqlite", "func": "int sqlite3CheckObjectName(\n  Parse *pParse,            /* Parsing context */\n  const char *zName,        /* Name of the object to check */\n  const char *zType,        /* Type of this object */\n  const char *zTblName      /* Parent table name for triggers and indexes */\n){\n  sqlite3 *db = pParse->db;\n  if( sqlite3WritableSchema(db) || db->init.imposterTable ){\n    /* Skip these error checks for writable_schema=ON */\n    return SQLITE_OK;\n  }\n  if( db->init.busy ){\n    if( sqlite3_stricmp(zType, db->init.azInit[0])\n     || sqlite3_stricmp(zName, db->init.azInit[1])\n     || sqlite3_stricmp(zTblName, db->init.azInit[2])\n    ){\n      if( sqlite3Config.bExtraSchemaChecks ){\n        sqlite3ErrorMsg(pParse, \"\"); /* corruptSchema() will supply the error */\n        return SQLITE_ERROR;\n      }\n    }\n  }else{\n    if( (pParse->nested==0 && 0==sqlite3StrNICmp(zName, \"sqlite_\", 7))\n     || (sqlite3ReadOnlyShadowTables(db) && sqlite3ShadowTableName(db, zName))\n    ){\n      sqlite3ErrorMsg(pParse, \"object name reserved for internal use: %s\",\n                      zName);\n      return SQLITE_ERROR;\n    }\n\n  }\n  return SQLITE_OK;\n}", "target": 2, "idx": 10431}
{"commit_id": "3ce424e45411cf5a13105e0386b6ecf6eeb4f66f", "project": "torvalds/linux", "func": "static void vmx_refresh_apicv_exec_ctrl(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tvmcs_write32(PIN_BASED_VM_EXEC_CONTROL, vmx_pin_based_exec_ctrl(vmx));\n\tif (cpu_has_secondary_exec_ctrls()) {\n\t\tif (kvm_vcpu_apicv_active(vcpu))\n\t\t\tvmcs_set_bits(SECONDARY_VM_EXEC_CONTROL,\n\t\t\t\t      SECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\t\t      SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n\t\telse\n\t\t\tvmcs_clear_bits(SECONDARY_VM_EXEC_CONTROL,\n\t\t\t\t\tSECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\t\t\tSECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n\t}\n\n\tif (cpu_has_vmx_msr_bitmap())\n\t\tvmx_set_msr_bitmap(vcpu);\n}", "target": 2, "idx": 10432}
{"commit_id": "dd64d3c41a2d15139c3a35d22d4cb6b78f4c5c59", "project": "xen-project/xen", "func": "static char *qemu_disk_scsi_drive_string(libxl__gc *gc, const char *target_path,\n                                         int unit, const char *format,\n                                         const libxl_device_disk *disk,\n                                         int colo_mode, const char **id_ptr)\n{\n    char *drive = NULL;\n    char *common = GCSPRINTF(\"if=none,readonly=%s,cache=writeback\",\n                             disk->readwrite ? \"off\" : \"on\");\n    const char *exportname = disk->colo_export;\n    const char *active_disk = disk->active_disk;\n    const char *hidden_disk = disk->hidden_disk;\n    const char *id;\n\n    switch (colo_mode) {\n    case LIBXL__COLO_NONE:\n        id = GCSPRINTF(\"scsi0-hd%d\", unit);\n        drive = GCSPRINTF(\"file=%s,id=%s,format=%s,%s\",\n                          target_path, id, format, common);\n        break;\n    case LIBXL__COLO_PRIMARY:\n        id = exportname;\n        drive = GCSPRINTF(\n            \"%s,id=%s,driver=quorum,\"\n            \"children.0.file.filename=%s,\"\n            \"children.0.driver=%s,\"\n            \"read-pattern=fifo,\"\n            \"vote-threshold=1\",\n            common, id, target_path, format);\n        break;\n    case LIBXL__COLO_SECONDARY:\n        id = \"top-colo\";\n        drive = GCSPRINTF(\n            \"%s,id=%s,driver=replication,\"\n            \"mode=secondary,\"\n            \"top-id=top-colo,\"\n            \"file.driver=qcow2,\"\n            \"file.file.filename=%s,\"\n            \"file.backing.driver=qcow2,\"\n            \"file.backing.file.filename=%s,\"\n            \"file.backing.backing=%s\",\n            common, id, active_disk, hidden_disk, exportname);\n        break;\n    default:\n        abort();\n    }\n\n    *id_ptr = id;\n\n    return drive;\n}", "target": 3, "idx": 10433}
{"commit_id": "ade71fb544391b2e33e1859645726bfee0d5eaaf", "project": "GNOME/glib", "func": "GVariant *\ng_variant_get_child_value (GVariant *value,\n                           gsize     index_)\n{\n  g_return_val_if_fail (index_ < g_variant_n_children (value), NULL);\n  g_return_val_if_fail (value->depth < G_MAXSIZE, NULL);\n\n  if (~g_atomic_int_get (&value->state) & STATE_SERIALISED)\n    {\n      g_variant_lock (value);\n\n      if (~value->state & STATE_SERIALISED)\n        {\n          GVariant *child;\n\n          child = g_variant_ref (value->contents.tree.children[index_]);\n          g_variant_unlock (value);\n\n          return child;\n        }\n\n      g_variant_unlock (value);\n    }\n\n  {\n    GVariantSerialised serialised = g_variant_to_serialised (value);\n    GVariantSerialised s_child;\n    GVariant *child;\n\n    /* get the serializer to extract the serialized data for the child\n     * from the serialized data for the container\n     */\n    s_child = g_variant_serialised_get_child (serialised, index_);\n\n    /* Check whether this would cause nesting too deep. If so, return a fake\n     * child. The only situation we expect this to happen in is with a variant,\n     * as all other deeply-nested types have a static type, and hence should\n     * have been rejected earlier. In the case of a variant whose nesting plus\n     * the depth of its child is too great, return a unit variant () instead of\n     * the real child. */\n    if (!(value->state & STATE_TRUSTED) &&\n        g_variant_type_info_query_depth (s_child.type_info) >=\n        G_VARIANT_MAX_RECURSION_DEPTH - value->depth)\n      {\n        g_assert (g_variant_is_of_type (value, G_VARIANT_TYPE_VARIANT));\n        return g_variant_new_tuple (NULL, 0);\n      }\n\n    /* create a new serialized instance out of it */\n    child = g_slice_new (GVariant);\n    child->type_info = s_child.type_info;\n    child->state = (value->state & STATE_TRUSTED) |\n                   STATE_SERIALISED;\n    child->size = s_child.size;\n    g_atomic_ref_count_init (&child->ref_count);\n    child->depth = value->depth + 1;\n    child->contents.serialised.bytes =\n      g_bytes_ref (value->contents.serialised.bytes);\n    child->contents.serialised.data = s_child.data;\n    child->contents.serialised.ordered_offsets_up_to = s_child.ordered_offsets_up_to;\n\n    return child;\n  }\n}", "target": 1, "idx": 10434}
{"commit_id": "01ca88bb6c5bdd44e071f8effebe12f1d7da9853", "project": "android", "func": "WORD32 ihevcd_parse_transform_tree(codec_t *ps_codec,\n                                   WORD32 x0, WORD32 y0,\n                                   WORD32 cu_x_base, WORD32 cu_y_base,\n                                   WORD32 log2_trafo_size,\n                                   WORD32 trafo_depth,\n                                   WORD32 blk_idx,\n                                   WORD32 intra_pred_mode)\n{\n    IHEVCD_ERROR_T ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;\n    sps_t *ps_sps;\n    pps_t *ps_pps;\n    WORD32 value;\n    WORD32 x1, y1;\n    WORD32 max_trafo_depth;\n\n    bitstrm_t *ps_bitstrm = &ps_codec->s_parse.s_bitstrm;\n    WORD32 intra_split_flag;\n    WORD32 split_transform_flag;\n    WORD32 ctxt_idx;\n    cab_ctxt_t *ps_cabac = &ps_codec->s_parse.s_cabac;\n\n    max_trafo_depth = ps_codec->s_parse.s_cu.i4_max_trafo_depth;\n    ps_sps = ps_codec->s_parse.ps_sps;\n    ps_pps = ps_codec->s_parse.ps_pps;\n    intra_split_flag = ps_codec->s_parse.s_cu.i4_intra_split_flag;\n\n    {\n        split_transform_flag = 0;\n        if((log2_trafo_size <= ps_sps->i1_log2_max_transform_block_size) &&\n                        (log2_trafo_size > ps_sps->i1_log2_min_transform_block_size) &&\n                        (trafo_depth < max_trafo_depth) &&\n                        !(intra_split_flag && (trafo_depth == 0)))\n        {\n            /* encode the split transform flag, context derived as per Table9-37 */\n            ctxt_idx = IHEVC_CAB_SPLIT_TFM + (5 - log2_trafo_size);\n\n            TRACE_CABAC_CTXT(\"split_transform_flag\", ps_cabac->u4_range, ctxt_idx);\n            split_transform_flag = ihevcd_cabac_decode_bin(ps_cabac, ps_bitstrm, ctxt_idx);\n            AEV_TRACE(\"split_transform_flag\", split_transform_flag,\n                      ps_cabac->u4_range);\n\n        }\n        else\n        {\n            WORD32 inter_split_flag = 0;\n\n            if((0 == ps_sps->i1_max_transform_hierarchy_depth_inter) &&\n                            (PRED_MODE_INTER == ps_codec->s_parse.s_cu.i4_pred_mode) &&\n                            (PART_2Nx2N != ps_codec->s_parse.s_cu.i4_part_mode) &&\n                            (0 == trafo_depth))\n            {\n                inter_split_flag = 1;\n            }\n\n            if((log2_trafo_size > ps_sps->i1_log2_max_transform_block_size) ||\n                            ((1 == intra_split_flag) && (0 == trafo_depth)) ||\n                            (1 == inter_split_flag))\n            {\n                split_transform_flag = 1;\n            }\n        }\n\n        if(0 == trafo_depth)\n        {\n            ps_codec->s_parse.s_cu.ai1_cbf_cr[trafo_depth] = 0;\n            ps_codec->s_parse.s_cu.ai1_cbf_cb[trafo_depth] = 0;\n        }\n        else\n        {\n            ps_codec->s_parse.s_cu.ai1_cbf_cb[trafo_depth] = ps_codec->s_parse.s_cu.ai1_cbf_cb[trafo_depth - 1];\n            ps_codec->s_parse.s_cu.ai1_cbf_cr[trafo_depth] = ps_codec->s_parse.s_cu.ai1_cbf_cr[trafo_depth - 1];\n        }\n        if(trafo_depth == 0 || log2_trafo_size > 2)\n        {\n            ctxt_idx = IHEVC_CAB_CBCR_IDX + trafo_depth;\n            /* CBF for Cb/Cr is sent only if the parent CBF for Cb/Cr is non-zero */\n            if((trafo_depth == 0) || ps_codec->s_parse.s_cu.ai1_cbf_cb[trafo_depth - 1])\n            {\n                TRACE_CABAC_CTXT(\"cbf_cb\", ps_cabac->u4_range, ctxt_idx);\n                value = ihevcd_cabac_decode_bin(ps_cabac, ps_bitstrm, ctxt_idx);\n                AEV_TRACE(\"cbf_cb\", value, ps_cabac->u4_range);\n                ps_codec->s_parse.s_cu.ai1_cbf_cb[trafo_depth] = value;\n            }\n\n            if((trafo_depth == 0) || ps_codec->s_parse.s_cu.ai1_cbf_cr[trafo_depth - 1])\n            {\n                TRACE_CABAC_CTXT(\"cbf_cr\", ps_cabac->u4_range, ctxt_idx);\n                value = ihevcd_cabac_decode_bin(ps_cabac, ps_bitstrm, ctxt_idx);\n                AEV_TRACE(\"cbf_cr\", value, ps_cabac->u4_range);\n                ps_codec->s_parse.s_cu.ai1_cbf_cr[trafo_depth] = value;\n            }\n        }\n        if(split_transform_flag)\n        {\n            WORD32 intra_pred_mode_tmp;\n            x1 = x0 + ((1 << log2_trafo_size) >> 1);\n            y1 = y0 + ((1 << log2_trafo_size) >> 1);\n\n            /* For transform depth of zero, intra pred mode as decoded at CU */\n            /* level is sent to the transform tree nodes */\n            /* When depth is non-zero intra pred mode of parent node is sent */\n            /* This takes care of passing correct mode to all the child nodes */\n            intra_pred_mode_tmp = trafo_depth ? intra_pred_mode : ps_codec->s_parse.s_cu.ai4_intra_luma_pred_mode[0];\n            ihevcd_parse_transform_tree(ps_codec, x0, y0, x0, y0, log2_trafo_size - 1, trafo_depth + 1, 0, intra_pred_mode_tmp);\n\n            intra_pred_mode_tmp = trafo_depth ? intra_pred_mode : ps_codec->s_parse.s_cu.ai4_intra_luma_pred_mode[1];\n            ihevcd_parse_transform_tree(ps_codec, x1, y0, x0, y0, log2_trafo_size - 1, trafo_depth + 1, 1, intra_pred_mode_tmp);\n\n            intra_pred_mode_tmp = trafo_depth ? intra_pred_mode : ps_codec->s_parse.s_cu.ai4_intra_luma_pred_mode[2];\n            ihevcd_parse_transform_tree(ps_codec, x0, y1, x0, y0, log2_trafo_size - 1, trafo_depth + 1, 2, intra_pred_mode_tmp);\n\n            intra_pred_mode_tmp = trafo_depth ? intra_pred_mode : ps_codec->s_parse.s_cu.ai4_intra_luma_pred_mode[3];\n            ihevcd_parse_transform_tree(ps_codec, x1, y1, x0, y0, log2_trafo_size - 1, trafo_depth + 1, 3, intra_pred_mode_tmp);\n\n        }\n        else\n        {\n            WORD32 ctb_x_base;\n            WORD32 ctb_y_base;\n            WORD32 cu_qp_delta_abs;\n\n\n\n            tu_t *ps_tu = ps_codec->s_parse.ps_tu;\n            cu_qp_delta_abs = 0;\n            ctb_x_base = ps_codec->s_parse.i4_ctb_x << ps_sps->i1_log2_ctb_size;\n            ctb_y_base = ps_codec->s_parse.i4_ctb_y << ps_sps->i1_log2_ctb_size;\n\n            if((ps_codec->s_parse.s_cu.i4_pred_mode == PRED_MODE_INTRA) ||\n                            (trafo_depth != 0) ||\n                            (ps_codec->s_parse.s_cu.ai1_cbf_cb[trafo_depth]) ||\n                            (ps_codec->s_parse.s_cu.ai1_cbf_cr[trafo_depth]))\n            {\n                ctxt_idx = IHEVC_CAB_CBF_LUMA_IDX;\n                ctxt_idx += (trafo_depth == 0) ? 1 : 0;\n\n                TRACE_CABAC_CTXT(\"cbf_luma\", ps_cabac->u4_range, ctxt_idx);\n                value = ihevcd_cabac_decode_bin(ps_cabac, ps_bitstrm, ctxt_idx);\n                AEV_TRACE(\"cbf_luma\", value, ps_cabac->u4_range);\n\n                ps_codec->s_parse.s_cu.i1_cbf_luma = value;\n            }\n            else\n            {\n                ps_codec->s_parse.s_cu.i1_cbf_luma = 1;\n            }\n\n            /* Initialize ps_tu to default values */\n            /* If required change this to WORD32 packed write */\n            ps_tu->b1_cb_cbf = 0;\n            ps_tu->b1_cr_cbf = 0;\n            ps_tu->b1_y_cbf = 0;\n            ps_tu->b4_pos_x = ((x0 - ctb_x_base) >> 2);\n            ps_tu->b4_pos_y = ((y0 - ctb_y_base) >> 2);\n            ps_tu->b1_transquant_bypass = ps_codec->s_parse.s_cu.i4_cu_transquant_bypass;\n            ps_tu->b3_size = (log2_trafo_size - 2);\n            ps_tu->b7_qp = ps_codec->s_parse.u4_qp;\n\n            ps_tu->b6_luma_intra_mode = intra_pred_mode;\n            ps_tu->b3_chroma_intra_mode_idx = ps_codec->s_parse.s_cu.i4_intra_chroma_pred_mode_idx;\n\n            /* Section:7.3.12  Transform unit syntax inlined here */\n            if(ps_codec->s_parse.s_cu.i1_cbf_luma ||\n                            ps_codec->s_parse.s_cu.ai1_cbf_cb[trafo_depth] ||\n                            ps_codec->s_parse.s_cu.ai1_cbf_cr[trafo_depth])\n            {\n                WORD32 intra_pred_mode_chroma;\n                if(ps_pps->i1_cu_qp_delta_enabled_flag && !ps_codec->s_parse.i4_is_cu_qp_delta_coded)\n                {\n\n\n                    WORD32 c_max        = TU_MAX_QP_DELTA_ABS;\n                    WORD32 ctxt_inc     = IHEVC_CAB_QP_DELTA_ABS;\n                    WORD32 ctxt_inc_max = CTXT_MAX_QP_DELTA_ABS;\n\n                    TRACE_CABAC_CTXT(\"cu_qp_delta_abs\", ps_cabac->u4_range, ctxt_inc);\n                    /* qp_delta_abs is coded as combination of tunary and eg0 code  */\n                    /* See Table 9-32 and Table 9-37 for details on cu_qp_delta_abs */\n                    cu_qp_delta_abs = ihevcd_cabac_decode_bins_tunary(ps_cabac,\n                                                                      ps_bitstrm,\n                                                                      c_max,\n                                                                      ctxt_inc,\n                                                                      0,\n                                                                      ctxt_inc_max);\n                    if(cu_qp_delta_abs >= c_max)\n                    {\n                        value = ihevcd_cabac_decode_bypass_bins_egk(ps_cabac, ps_bitstrm, 0);\n                        cu_qp_delta_abs += value;\n                    }\n                    AEV_TRACE(\"cu_qp_delta_abs\", cu_qp_delta_abs, ps_cabac->u4_range);\n\n                    ps_codec->s_parse.i4_is_cu_qp_delta_coded = 1;\n\n\n                    if(cu_qp_delta_abs)\n                    {\n                        value = ihevcd_cabac_decode_bypass_bin(ps_cabac, ps_bitstrm);\n                        AEV_TRACE(\"cu_qp_delta_sign\", value, ps_cabac->u4_range);\n\n                        if(value)\n                            cu_qp_delta_abs = -cu_qp_delta_abs;\n\n                    }\n\n                    if (cu_qp_delta_abs < MIN_CU_QP_DELTA_ABS(ps_sps->i1_bit_depth_luma_minus8)\n                                    || cu_qp_delta_abs > MAX_CU_QP_DELTA_ABS(ps_sps->i1_bit_depth_luma_minus8))\n                    {\n                        return IHEVCD_INVALID_PARAMETER;\n                    }\n\n                    ps_codec->s_parse.s_cu.i4_cu_qp_delta = cu_qp_delta_abs;\n\n                }\n\n                if(ps_codec->s_parse.s_cu.i1_cbf_luma)\n                {\n                    ps_tu->b1_y_cbf = 1;\n                    ihevcd_parse_residual_coding(ps_codec, x0, y0, log2_trafo_size, 0, intra_pred_mode);\n                }\n\n                if(4 == ps_codec->s_parse.s_cu.i4_intra_chroma_pred_mode_idx)\n                    intra_pred_mode_chroma = ps_codec->s_parse.s_cu.ai4_intra_luma_pred_mode[0];\n                else\n                {\n                    intra_pred_mode_chroma = gau1_intra_pred_chroma_modes[ps_codec->s_parse.s_cu.i4_intra_chroma_pred_mode_idx];\n\n                    if(intra_pred_mode_chroma ==\n                                    ps_codec->s_parse.s_cu.ai4_intra_luma_pred_mode[0])\n                    {\n                        intra_pred_mode_chroma = INTRA_ANGULAR(34);\n                    }\n\n                }\n                if(log2_trafo_size > 2)\n                {\n                    if(ps_codec->s_parse.s_cu.ai1_cbf_cb[trafo_depth])\n                    {\n                        ps_tu->b1_cb_cbf = 1;\n                        ihevcd_parse_residual_coding(ps_codec, x0, y0, log2_trafo_size - 1, 1, intra_pred_mode_chroma);\n                    }\n\n                    if(ps_codec->s_parse.s_cu.ai1_cbf_cr[trafo_depth])\n                    {\n                        ps_tu->b1_cr_cbf = 1;\n                        ihevcd_parse_residual_coding(ps_codec, x0, y0, log2_trafo_size - 1, 2, intra_pred_mode_chroma);\n                    }\n                }\n                else if(blk_idx == 3)\n                {\n                    if(ps_codec->s_parse.s_cu.ai1_cbf_cb[trafo_depth])\n                    {\n                        ps_tu->b1_cb_cbf = 1;\n                        ihevcd_parse_residual_coding(ps_codec, cu_x_base, cu_y_base, log2_trafo_size, 1, intra_pred_mode_chroma);\n                    }\n\n                    if(ps_codec->s_parse.s_cu.ai1_cbf_cr[trafo_depth])\n                    {\n                        ps_tu->b1_cr_cbf = 1;\n                        ihevcd_parse_residual_coding(ps_codec, cu_x_base, cu_y_base, log2_trafo_size, 2, intra_pred_mode_chroma);\n                    }\n                }\n                else\n                {\n                    //ps_tu->b1_chroma_present = 0;\n                    ps_tu->b3_chroma_intra_mode_idx = INTRA_PRED_CHROMA_IDX_NONE;\n                }\n            }\n            else\n            {\n                if((3 != blk_idx) && (2 == log2_trafo_size))\n                {\n                    ps_tu->b3_chroma_intra_mode_idx = INTRA_PRED_CHROMA_IDX_NONE;\n                }\n            }\n\n            /* Set the first TU in CU flag */\n            {\n                if((ps_codec->s_parse.s_cu.i4_pos_x << 3) == (ps_tu->b4_pos_x << 2) &&\n                                (ps_codec->s_parse.s_cu.i4_pos_y << 3) == (ps_tu->b4_pos_y << 2))\n                {\n                    ps_tu->b1_first_tu_in_cu = 1;\n                }\n                else\n                {\n                    ps_tu->b1_first_tu_in_cu = 0;\n                }\n            }\n            ps_codec->s_parse.ps_tu++;\n            ps_codec->s_parse.s_cu.i4_tu_cnt++;\n            ps_codec->s_parse.i4_pic_tu_idx++;\n        }\n    }\n    return ret;\n}", "target": 2, "idx": 10435}
{"commit_id": "d6a86b5e69e46cc283b1e06c92343319beb42e21", "project": "rpm-software-management/rpm", "func": "static\nrpmTagVal headerMergeLegacySigs(Header h, Header sigh, char **msg)\n{\n    const struct taglate_s *xl;\n    struct rpmtd_s td;\n\n    rpmtdReset(&td);\n    for (xl = xlateTags; xl->stag; xl++) {\n\t/* There mustn't be one in the main header */\n\tif (headerIsEntry(h, xl->xtag))\n\t    break;\n\tif (headerGet(sigh, xl->stag, &td, HEADERGET_RAW|HEADERGET_MINMEM)) {\n\t    /* Translate legacy tags */\n\t    if (xl->stag != xl->xtag)\n\t\ttd.tag = xl->xtag;\n\t    /* Ensure type and tag size match expectations */\n\t    if (td.type != rpmTagGetTagType(td.tag))\n\t\tbreak;\n\t    if (td.count < 1 || td.count > 16*1024*1024)\n\t\tbreak;\n\t    if (xl->count && td.count != xl->count)\n\t\tbreak;\n\t    if (!headerPut(h, &td, HEADERPUT_DEFAULT))\n\t\tbreak;\n\t    rpmtdFreeData(&td);\n\t}\n    }\n    rpmtdFreeData(&td);\n\n    if (xl->stag) {\n\trasprintf(msg, \"invalid signature tag %s (%d)\",\n\t\t\trpmTagGetName(xl->xtag), xl->xtag);\n    }\n\n    return xl->stag;\n}", "target": 2, "idx": 10436}
{"commit_id": "4f38b1ac8e42727e18a2f0bde06d3bee8e77b250", "project": "tensorflow", "func": "Status GetInitOp(const string& export_dir, const MetaGraphDef& meta_graph_def,\n                 string* init_op_name) {\n  const auto& sig_def_map = meta_graph_def.signature_def();\n  const auto& init_op_sig_it =\n      meta_graph_def.signature_def().find(kSavedModelInitOpSignatureKey);\n  if (init_op_sig_it != sig_def_map.end()) {\n    const auto& sig_def_outputs = init_op_sig_it->second.outputs();\n    const auto& sig_def_outputs_it =\n        sig_def_outputs.find(kSavedModelInitOpSignatureKey);\n    if (sig_def_outputs_it == sig_def_outputs.end()) {\n      return errors::FailedPrecondition(\"Could not find output \",\n                                        kSavedModelInitOpSignatureKey);\n    }\n    *init_op_name = sig_def_outputs_it->second.name();\n    return Status::OK();\n  }\n\n  const auto& collection_def_map = meta_graph_def.collection_def();\n  string init_op_collection_key;\n  if (collection_def_map.find(kSavedModelMainOpKey) !=\n      collection_def_map.end()) {\n    init_op_collection_key = kSavedModelMainOpKey;\n  } else {\n    init_op_collection_key = kSavedModelLegacyInitOpKey;\n  }\n\n  const auto init_op_it = collection_def_map.find(init_op_collection_key);\n  if (init_op_it != collection_def_map.end()) {\n    if (init_op_it->second.node_list().value_size() != 1) {\n      return errors::FailedPrecondition(\n          strings::StrCat(\"Expected exactly one main op in : \", export_dir));\n    }\n    *init_op_name = init_op_it->second.node_list().value(0);\n  }\n  return Status::OK();\n}", "target": 1, "idx": 10437}
{"commit_id": "bce3717eaef4f769019fd18e990464ca4a2efeea", "project": "tensorflow", "func": "void Compute(OpKernelContext* ctx) override {\n    const Tensor& sorted_inputs_t = ctx->input(0);\n    const Tensor& values_t = ctx->input(1);\n\n    // inputs must be at least a matrix\n    OP_REQUIRES(\n        ctx, sorted_inputs_t.shape().dims() >= 2,\n        errors::InvalidArgument(\"sorted input argument must be a matrix\"));\n    // must have same batch dim_size for both\n    OP_REQUIRES(ctx, sorted_inputs_t.dim_size(0) == values_t.dim_size(0),\n                Status(error::INVALID_ARGUMENT,\n                       \"Leading dim_size of both tensors must match.\"));\n\n    // this is required because we do indexing in int32 on the GPU\n    OP_REQUIRES(ctx, values_t.NumElements() < std::numeric_limits<int>::max(),\n                Status(error::INVALID_ARGUMENT,\n                       \"values tensor size must less than INT_MAX\"));\n\n    Tensor* output_t;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, values_t.shape(), &output_t));\n\n    if (output_t->dtype() == DT_INT32) {\n      OP_REQUIRES(ctx,\n                  FastBoundsCheck(sorted_inputs_t.dim_size(1),\n                                  std::numeric_limits<int>::max()),\n                  errors::InvalidArgument(\"trailing dim_size must less than \"\n                                          \"INT_MAX for int32 output type, was \",\n                                          sorted_inputs_t.dim_size(1)));\n    }\n\n    auto output = output_t->template flat<OutType>();\n    const auto sorted_inputs = sorted_inputs_t.template flat<T>();\n    const auto values = values_t.template flat<T>();\n\n    // For empty inputs, all values will be placed at the zeroth position.\n    if (sorted_inputs.size() == 0) {\n      functor::SetZeroFunctor<Device, OutType> set_zero;\n      set_zero(ctx->eigen_device<Device>(), output);\n      return;\n    }\n\n    OP_REQUIRES_OK(\n        ctx, functor::LowerBoundFunctor<Device, T, OutType>::Compute(\n                 ctx, sorted_inputs, values, sorted_inputs_t.dim_size(0),\n                 sorted_inputs_t.dim_size(1), values_t.dim_size(1), &output));\n  }", "target": 1, "idx": 10438}
{"commit_id": "ef85b67385436ddc1998f45f1d6a210f935b3388", "project": "torvalds/linux", "func": "static void vmx_complete_atomic_exit(struct vcpu_vmx *vmx)\n{\n\tu32 exit_intr_info;\n\n\tif (!(vmx->exit_reason == EXIT_REASON_MCE_DURING_VMENTRY\n\t      || vmx->exit_reason == EXIT_REASON_EXCEPTION_NMI))\n\t\treturn;\n\n\tvmx->exit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\texit_intr_info = vmx->exit_intr_info;\n\n\t/* Handle machine checks before interrupts are enabled */\n\tif (is_machine_check(exit_intr_info))\n\t\tkvm_machine_check();\n\n\t/* We need to handle NMIs before interrupts are enabled */\n\tif (is_nmi(exit_intr_info)) {\n\t\tkvm_before_handle_nmi(&vmx->vcpu);\n\t\tasm(\"int $2\");\n\t\tkvm_after_handle_nmi(&vmx->vcpu);\n\t}\n}", "target": 1, "idx": 10439}
{"commit_id": "b2b4d629f100eaee9f5942a106b1ccefe85b8808", "project": "gost-engine/engine", "func": "int pkey_gost_decrypt(EVP_PKEY_CTX *pctx, unsigned char *key,\n                      size_t *key_len, const unsigned char *in, size_t in_len)\n{\n    struct gost_pmeth_data *gctx = EVP_PKEY_CTX_get_data(pctx);\n\n    if (key == NULL) {\n        *key_len = 32;\n        return 1;\n    }\n\n    if (key != NULL && *key_len < 32) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, GOST_R_INVALID_BUFFER_SIZE);\n        return 0;\n    }\n\n    switch (gctx->cipher_nid)\n    {\n        case NID_id_Gost28147_89:\n        case NID_undef: /* FIXME */\n            return pkey_GOST_ECcp_decrypt(pctx, key, key_len, in, in_len);\n        case NID_kuznyechik_ctr:\n        case NID_magma_ctr:\n            return pkey_gost2018_decrypt(pctx, key, key_len, in, in_len);\n        default:\n      GOSTerr(GOST_F_PKEY_GOST_DECRYPT, ERR_R_INTERNAL_ERROR);\n      return -1;\n    }\n}", "target": 1, "idx": 10440}
{"commit_id": "415e3d3e90ce9e18727e8843ae343eda5a58fad6", "project": "torvalds/linux", "func": "struct scm_fp_list *scm_fp_dup(struct scm_fp_list *fpl)\n{\n\tstruct scm_fp_list *new_fpl;\n\tint i;\n\n\tif (!fpl)\n\t\treturn NULL;\n\n\tnew_fpl = kmemdup(fpl, offsetof(struct scm_fp_list, fp[fpl->count]),\n\t\t\t  GFP_KERNEL);\n\tif (new_fpl) {\n\t\tfor (i = 0; i < fpl->count; i++)\n\t\t\tget_file(fpl->fp[i]);\n\t\tnew_fpl->max = new_fpl->count;\n\t\tnew_fpl->user = get_uid(fpl->user);\n\t}\n\treturn new_fpl;\n}", "target": 1, "idx": 10441}
{"commit_id": "2785b2a9e04abc148e1c5259f4faee708ea356f4", "project": "xen-project/xen", "func": "int domain_soft_reset(struct domain *d, bool resuming)\n{\n    struct vcpu *v;\n    int rc;\n\n    spin_lock(&d->shutdown_lock);\n    for_each_vcpu ( d, v )\n        if ( !v->paused_for_shutdown )\n        {\n            spin_unlock(&d->shutdown_lock);\n            return -EINVAL;\n        }\n    spin_unlock(&d->shutdown_lock);\n\n    rc = evtchn_reset(d, resuming);\n    if ( rc )\n        return rc;\n\n    grant_table_warn_active_grants(d);\n\n    argo_soft_reset(d);\n\n    for_each_vcpu ( d, v )\n    {\n        set_xen_guest_handle(runstate_guest(v), NULL);\n        unmap_vcpu_info(v);\n    }\n\n    rc = arch_domain_soft_reset(d);\n    if ( !rc )\n        domain_resume(d);\n    else\n        domain_crash(d);\n\n    return rc;\n}", "target": 1, "idx": 10442}
{"commit_id": "b0cf030b30a9b63e678fee294321642beb42b724", "project": "wireshark", "func": "static void rtps_util_add_type_element_array(proto_tree *tree,\n        tvbuff_t * tvb, gint offset, const guint encoding, dissection_info * info _U_) {\n  proto_tree * bound_tree;\n  guint32 member_id = 0, member_length = 0;\n  guint32 long_number, i;\n  gint zero_alignment, offset_tmp;\n  offset = rtps_util_add_type_library_type(tree, tvb, offset, encoding, info);\n\n  /* Dissect Collection Type */\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n  zero_alignment = offset;\n  rtps_util_add_type_id(tree, tvb, offset, encoding, zero_alignment, -1, NULL, &(info->base_type_id));\n  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n  proto_tree_add_item(tree, hf_rtps_type_object_element_shared, tvb, offset, 1, encoding);\n  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n\n  /* dissect Bound sequence */\n\n  offset_tmp = offset;\n  long_number = tvb_get_guint32(tvb, offset_tmp, encoding);\n  bound_tree = proto_tree_add_subtree_format(tree, tvb, offset_tmp, member_length,\n              ett_rtps_type_bound_list, NULL, \"Bounds (%d elements)\",\n              long_number);\n  offset_tmp += 4;\n  for (i = 0; i < long_number ; i++) {\n    proto_tree_add_item(bound_tree, hf_rtps_type_object_bound, tvb, offset_tmp, 4, encoding);\n    if (info) info->bound = tvb_get_gint32(tvb, offset_tmp, encoding);\n    if (info) info->num_elements = tvb_get_gint32(tvb, offset_tmp, encoding);\n\n    offset_tmp += 4;\n  }\n}", "target": 1, "idx": 10443}
{"commit_id": "ee70db46f81afa582c96b887b73bcd2a86feda00", "project": "domoticz", "func": "void CWebServer::GetFloorplanImage(WebEmSession & session, const request& req, reply & rep)\n\t\t{\n\t\t\tstd::string idx = request::findValue(&req, \"idx\");\n\t\t\tif (idx == \"\") {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tstd::vector<std::vector<std::string> > result;\n\t\t\tresult = m_sql.safe_queryBlob(\"SELECT Image FROM Floorplans WHERE ID=%d\", atol(idx.c_str()));\n\t\t\tif (result.empty())\n\t\t\t\treturn;\n\t\t\treply::set_content(&rep, result[0][0].begin(), result[0][0].end());\n\t\t\tstd::string oname = \"floorplan\";\n\t\t\tif (result[0][0].size() > 10)\n\t\t\t{\n\t\t\t\tif (result[0][0][0] == 'P')\n\t\t\t\t\toname += \".png\";\n\t\t\t\telse if (result[0][0][0] == -1)\n\t\t\t\t\toname += \".jpg\";\n\t\t\t\telse if (result[0][0][0] == 'B')\n\t\t\t\t\toname += \".bmp\";\n\t\t\t\telse if (result[0][0][0] == 'G')\n\t\t\t\t\toname += \".gif\";\n\t\t\t}\n\t\t\treply::add_header_attachment(&rep, oname);\n\t\t}", "target": 3, "idx": 10444}
{"commit_id": "08fadc32ce6239dc75fd5e869590e29bc62bbc28", "project": "kernel/git/tip/tip", "func": "static void slc_bump(struct slcan *sl)\n{\n\tstruct sk_buff *skb;\n\tstruct can_frame cf;\n\tint i, tmp;\n\tu32 tmpid;\n\tchar *cmd = sl->rbuff;\n\n\tmemset(&cf, 0, sizeof(cf));\n\n\tswitch (*cmd) {\n\tcase 'r':\n\t\tcf.can_id = CAN_RTR_FLAG;\n\t\t/* fallthrough */\n\tcase 't':\n\t\t/* store dlc ASCII value and terminate SFF CAN ID string */\n\t\tcf.can_dlc = sl->rbuff[SLC_CMD_LEN + SLC_SFF_ID_LEN];\n\t\tsl->rbuff[SLC_CMD_LEN + SLC_SFF_ID_LEN] = 0;\n\t\t/* point to payload data behind the dlc */\n\t\tcmd += SLC_CMD_LEN + SLC_SFF_ID_LEN + 1;\n\t\tbreak;\n\tcase 'R':\n\t\tcf.can_id = CAN_RTR_FLAG;\n\t\t/* fallthrough */\n\tcase 'T':\n\t\tcf.can_id |= CAN_EFF_FLAG;\n\t\t/* store dlc ASCII value and terminate EFF CAN ID string */\n\t\tcf.can_dlc = sl->rbuff[SLC_CMD_LEN + SLC_EFF_ID_LEN];\n\t\tsl->rbuff[SLC_CMD_LEN + SLC_EFF_ID_LEN] = 0;\n\t\t/* point to payload data behind the dlc */\n\t\tcmd += SLC_CMD_LEN + SLC_EFF_ID_LEN + 1;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (kstrtou32(sl->rbuff + SLC_CMD_LEN, 16, &tmpid))\n\t\treturn;\n\n\tcf.can_id |= tmpid;\n\n\t/* get can_dlc from sanitized ASCII value */\n\tif (cf.can_dlc >= '0' && cf.can_dlc < '9')\n\t\tcf.can_dlc -= '0';\n\telse\n\t\treturn;\n\n\t/* RTR frames may have a dlc > 0 but they never have any data bytes */\n\tif (!(cf.can_id & CAN_RTR_FLAG)) {\n\t\tfor (i = 0; i < cf.can_dlc; i++) {\n\t\t\ttmp = hex_to_bin(*cmd++);\n\t\t\tif (tmp < 0)\n\t\t\t\treturn;\n\t\t\tcf.data[i] = (tmp << 4);\n\t\t\ttmp = hex_to_bin(*cmd++);\n\t\t\tif (tmp < 0)\n\t\t\t\treturn;\n\t\t\tcf.data[i] |= tmp;\n\t\t}\n\t}\n\n\tskb = dev_alloc_skb(sizeof(struct can_frame) +\n\t\t\t    sizeof(struct can_skb_priv));\n\tif (!skb)\n\t\treturn;\n\n\tskb->dev = sl->dev;\n\tskb->protocol = htons(ETH_P_CAN);\n\tskb->pkt_type = PACKET_BROADCAST;\n\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n\tcan_skb_reserve(skb);\n\tcan_skb_prv(skb)->ifindex = sl->dev->ifindex;\n\n\tmemcpy(skb_put(skb, sizeof(struct can_frame)),\n\t       &cf, sizeof(struct can_frame));\n\tnetif_rx_ni(skb);\n\n\tsl->dev->stats.rx_packets++;\n\tsl->dev->stats.rx_bytes += cf.can_dlc;\n}", "target": 1, "idx": 10445}
{"commit_id": "cab1c3b3708eead315e033359d07049b23b147a3", "project": "php/php-src", "func": "PHP_SNMP_BOOL_PROPERTY_WRITER_FUNCTION(oid_increasing_check)\n\n/* {{{ */\nstatic int php_snmp_write_oid_output_format(php_snmp_object *snmp_object, zval *newval TSRMLS_DC)\n{\n\tzval ztmp;\n\tint ret = SUCCESS;\n\tif (Z_TYPE_P(newval) != IS_LONG) {\n\t\tztmp = *newval;\n\t\tzval_copy_ctor(&ztmp);\n\t\tconvert_to_long(&ztmp);\n\t\tnewval = &ztmp;\n\t}\n\n\tswitch(Z_LVAL_P(newval)) {\n\t\tcase NETSNMP_OID_OUTPUT_SUFFIX:\n\t\tcase NETSNMP_OID_OUTPUT_MODULE:\n\t\tcase NETSNMP_OID_OUTPUT_FULL:\n\t\tcase NETSNMP_OID_OUTPUT_NUMERIC:\n\t\tcase NETSNMP_OID_OUTPUT_UCD:\n\t\tcase NETSNMP_OID_OUTPUT_NONE:\n\t\t\tsnmp_object->oid_output_format = Z_LVAL_P(newval);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown SNMP output print format '%ld'\", Z_LVAL_P(newval));\n\t\t\tret = FAILURE;\n\t\t\tbreak;\n\t}\n\n\tif (newval == &ztmp) {\n\t\tzval_dtor(newval);\n\t}\n\treturn ret;\n}", "target": 3, "idx": 10446}
{"commit_id": "45a0eaf77022963d639d6d19871dbab7b79703fc", "project": "binutils-gdb", "func": "bfd_boolean\n_bfd_add_merge_section (bfd *abfd, void **psinfo, asection *sec,\n\t\t\tvoid **psecinfo)\n{\n  struct sec_merge_info *sinfo;\n  struct sec_merge_sec_info *secinfo;\n  unsigned int align;\n  bfd_size_type amt;\n  bfd_byte *contents;\n\n  if ((abfd->flags & DYNAMIC) != 0\n      || (sec->flags & SEC_MERGE) == 0)\n    abort ();\n\n  if (sec->size == 0\n      || (sec->flags & SEC_EXCLUDE) != 0\n      || sec->entsize == 0)\n    return TRUE;\n\n  if (sec->size % sec->entsize != 0)\n    return TRUE;\n\n  if ((sec->flags & SEC_RELOC) != 0)\n    {\n      /* We aren't prepared to handle relocations in merged sections.  */\n      return TRUE;\n    }\n\n#ifndef CHAR_BIT\n#define CHAR_BIT 8\n#endif\n  if (sec->alignment_power >= sizeof (align) * CHAR_BIT)\n    return TRUE;\n\n  align = 1u << sec->alignment_power;\n  if ((sec->entsize < align\n       && ((sec->entsize & (sec->entsize - 1))\n\t   || !(sec->flags & SEC_STRINGS)))\n      || (sec->entsize > align\n\t  && (sec->entsize & (align - 1))))\n    {\n      /* Sanity check.  If string character size is smaller than\n\t alignment, then we require character size to be a power\n\t of 2, otherwise character size must be integer multiple\n\t of alignment.  For non-string constants, alignment must\n\t be smaller than or equal to entity size and entity size\n\t must be integer multiple of alignment.  */\n      return TRUE;\n    }\n\n  for (sinfo = (struct sec_merge_info *) *psinfo; sinfo; sinfo = sinfo->next)\n    if ((secinfo = sinfo->chain)\n\t&& ! ((secinfo->sec->flags ^ sec->flags) & (SEC_MERGE | SEC_STRINGS))\n\t&& secinfo->sec->entsize == sec->entsize\n\t&& secinfo->sec->alignment_power == sec->alignment_power\n\t&& secinfo->sec->output_section == sec->output_section)\n      break;\n\n  if (sinfo == NULL)\n    {\n      /* Initialize the information we need to keep track of.  */\n      sinfo = (struct sec_merge_info *)\n\t  bfd_alloc (abfd, sizeof (struct sec_merge_info));\n      if (sinfo == NULL)\n\tgoto error_return;\n      sinfo->next = (struct sec_merge_info *) *psinfo;\n      sinfo->chain = NULL;\n      *psinfo = sinfo;\n      sinfo->htab = sec_merge_init (sec->entsize, (sec->flags & SEC_STRINGS));\n      if (sinfo->htab == NULL)\n\tgoto error_return;\n    }\n\n  /* Read the section from abfd.  */\n\n  amt = sizeof (struct sec_merge_sec_info) - 1 + sec->size;\n  if (sec->flags & SEC_STRINGS)\n    /* Some versions of gcc may emit a string without a zero terminator.\n       See http://gcc.gnu.org/ml/gcc-patches/2006-06/msg01004.html\n       Allocate space for an extra zero.  */\n    amt += sec->entsize;\n  *psecinfo = bfd_alloc (abfd, amt);\n  if (*psecinfo == NULL)\n    goto error_return;\n\n  secinfo = (struct sec_merge_sec_info *) *psecinfo;\n  if (sinfo->chain)\n    {\n      secinfo->next = sinfo->chain->next;\n      sinfo->chain->next = secinfo;\n    }\n  else\n    secinfo->next = secinfo;\n  sinfo->chain = secinfo;\n  secinfo->sec = sec;\n  secinfo->psecinfo = psecinfo;\n  secinfo->htab = sinfo->htab;\n  secinfo->first_str = NULL;\n\n  sec->rawsize = sec->size;\n  if (sec->flags & SEC_STRINGS)\n    memset (secinfo->contents + sec->size, 0, sec->entsize);\n  contents = secinfo->contents;\n  if (! bfd_get_full_section_contents (sec->owner, sec, &contents))\n    goto error_return;\n\n  return TRUE;\n\n error_return:\n  *psecinfo = NULL;\n  return FALSE;\n}", "target": 1, "idx": 10447}
{"commit_id": "99253eb750fda6a644d5188fb26c43bad8d5a745", "project": "torvalds/linux", "func": "int ip6_mroute_getsockopt(struct sock *sk, int optname, char __user *optval,\n\t\t\t  int __user *optlen)\n{\n\tint olr;\n\tint val;\n\tstruct net *net = sock_net(sk);\n\tstruct mr6_table *mrt;\n\n\tif (sk->sk_type != SOCK_RAW ||\n\t    inet_sk(sk)->inet_num != IPPROTO_ICMPV6)\n\t\treturn -EOPNOTSUPP;\n\n\tmrt = ip6mr_get_table(net, raw6_sk(sk)->ip6mr_table ? : RT6_TABLE_DFLT);\n\tif (!mrt)\n\t\treturn -ENOENT;\n\n\tswitch (optname) {\n\tcase MRT6_VERSION:\n\t\tval = 0x0305;\n\t\tbreak;\n#ifdef CONFIG_IPV6_PIMSM_V2\n\tcase MRT6_PIM:\n\t\tval = mrt->mroute_do_pim;\n\t\tbreak;\n#endif\n\tcase MRT6_ASSERT:\n\t\tval = mrt->mroute_do_assert;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\tif (get_user(olr, optlen))\n\t\treturn -EFAULT;\n\n\tolr = min_t(int, olr, sizeof(int));\n\tif (olr < 0)\n\t\treturn -EINVAL;\n\n\tif (put_user(olr, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, olr))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 2, "idx": 10448}
{"commit_id": "53625a846a7b4273982157d7a1db5947371757ef", "project": "android", "func": "static enum pkvm_page_state guest_get_page_state(kvm_pte_t pte, u64 addr)\n{\n\tif (!kvm_pte_valid(pte))\n\t\treturn PKVM_NOPAGE;\n\n\treturn pkvm_getstate(kvm_pgtable_stage2_pte_prot(pte));\n}", "target": 1, "idx": 10449}
{"commit_id": "c796c76341ee846cfb897ed645bac211d7d0a932", "project": "abrt", "func": "static gboolean key_value_ok(gchar *key, gchar *value)\n{\n    char *i;\n\n    /* check key, it has to be valid filename and will end up in the\n     * bugzilla */\n    for (i = key; *i != 0; i++)\n    {\n        if (!isalpha(*i) && (*i != '-') && (*i != '_') && (*i != ' '))\n            return FALSE;\n    }\n\n    /* check value of 'basename', it has to be valid non-hidden directory\n     * name */\n    if (strcmp(key, \"basename\") == 0\n     || strcmp(key, FILENAME_TYPE) == 0\n    )\n    {\n        if (!str_is_correct_filename(value))\n        {\n            error_msg(\"Value of '%s' ('%s') is not a valid directory name\",\n                      key, value);\n            return FALSE;\n        }\n    }\n\n    return TRUE;\n}", "target": 2, "idx": 10450}
{"commit_id": "1ca1130ec62da7638497478539c0f55ffbbf9a5e", "project": "android", "func": "static void\nbinder_free_buf(struct binder_proc *proc,\n\t\tstruct binder_thread *thread,\n\t\tstruct binder_buffer *buffer, bool is_failure)\n{\n\tbinder_inner_proc_lock(proc);\n\tif (buffer->transaction) {\n\t\tbuffer->transaction->buffer = NULL;\n\t\tbuffer->transaction = NULL;\n\t}\n\tbinder_inner_proc_unlock(proc);\n\tif (buffer->async_transaction && buffer->target_node) {\n\t\tstruct binder_node *buf_node;\n\t\tstruct binder_work *w;\n\n\t\tbuf_node = buffer->target_node;\n\t\tbinder_node_inner_lock(buf_node);\n\t\tBUG_ON(!buf_node->has_async_transaction);\n\t\tBUG_ON(buf_node->proc != proc);\n\t\tw = binder_dequeue_work_head_ilocked(\n\t\t\t\t&buf_node->async_todo);\n\t\tif (!w) {\n\t\t\tbuf_node->has_async_transaction = false;\n\t\t} else {\n\t\t\tbinder_enqueue_work_ilocked(\n\t\t\t\t\tw, &proc->todo);\n\t\t\tbinder_wakeup_proc_ilocked(proc);\n\t\t}\n\t\tbinder_node_inner_unlock(buf_node);\n\t}\n\ttrace_binder_transaction_buffer_release(buffer);\n\tbinder_release_entire_buffer(proc, thread, buffer, is_failure);\n\tbinder_alloc_free_buf(&proc->alloc, buffer);\n}", "target": 2, "idx": 10451}
{"commit_id": "50f06b3efb638efb0abd95dc62dca05ae67882c2", "project": "GNOME/libxml2", "func": "static void\nxmlHTMLEncodeSend(void) {\n    char *result;\n\n    /*\n     * xmlEncodeEntitiesReentrant assumes valid UTF-8, but the buffer might\n     * end with a truncated UTF-8 sequence. This is a hack to at least avoid\n     * an out-of-bounds read.\n     */\n    memset(&buffer[sizeof(buffer)-4], 0, 4);\n    result = (char *) xmlEncodeEntitiesReentrant(NULL, BAD_CAST buffer);\n    if (result) {\n\txmlGenericError(xmlGenericErrorContext, \"%s\", result);\n\txmlFree(result);\n    }\n    buffer[0] = 0;\n}", "target": 1, "idx": 10452}
{"commit_id": "8788a3cf255b647fd14e6b5e2585abaaedb28153", "project": "istio/envoy", "func": "Http::FilterMetadataStatus Context::onRequestMetadata() {\n  if (!in_vm_context_created_ || !wasm_->onRequestMetadata_) {\n    return Http::FilterMetadataStatus::Continue;\n  }\n  if (wasm_->onRequestMetadata_(this, id_).u64_ == 0) {\n    return Http::FilterMetadataStatus::Continue;\n  }\n  return Http::FilterMetadataStatus::Continue; // This is currently the only return code.\n}", "target": 2, "idx": 10453}
{"commit_id": "a3727a8bac0a9e77c70820655fd8715523ba3db7", "project": "torvalds/linux", "func": "static int selinux_ptrace_traceme(struct task_struct *parent)\n{\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    task_sid_obj(parent), task_sid_obj(current),\n\t\t\t    SECCLASS_PROCESS, PROCESS__PTRACE, NULL);\n}", "target": 2, "idx": 10454}
{"commit_id": "45cb2ac23213861749d82ad3524f46e347d308a3", "project": "appneta/tcpreplay", "func": "int \ndlt_jnpr_ether_post_init(tcpeditdlt_t *ctx)\n{\n    jnpr_ether_config_t *config;\n    \n    /* do nothing if we're not the decoder */\n    if (ctx->decoder->dlt != dlt_value)\n        return TCPEDIT_OK;\n    \n    /* init our subcontext & decoder of en10mb */\n    config = (jnpr_ether_config_t *)ctx->encoder->config;\n    if (config->subctx == NULL)\n        config->subctx = tcpedit_dlt_init(ctx->tcpedit, DLT_EN10MB);\n        \n    return TCPEDIT_OK;\n}", "target": 2, "idx": 10455}
{"commit_id": "4317db7498eaa5a37068052bb0310fbc6a5f78e4", "project": "SerenityOS/serenity", "func": "bool read(ReadonlyBytes buffer)\n    {\n        auto fields_size = sizeof(LocalFileHeader) - (sizeof(u8*) * 3);\n        if (buffer.size() < sizeof(local_file_header_signature) + fields_size)\n            return false;\n        if (memcmp(buffer.data(), local_file_header_signature, sizeof(local_file_header_signature)) != 0)\n            return false;\n        memcpy(reinterpret_cast<void*>(&minimum_version), buffer.data() + sizeof(local_file_header_signature), fields_size);\n        if (buffer.size() < sizeof(end_of_central_directory_signature) + fields_size + name_length + extra_data_length + compressed_size)\n            return false;\n        name = buffer.data() + sizeof(local_file_header_signature) + fields_size;\n        extra_data = name + name_length;\n        compressed_data = extra_data + extra_data_length;\n        return true;\n    }", "target": 3, "idx": 10456}
{"commit_id": "e73e81975f2447e6f556100cada64a18ec631cbb", "project": "linux-audit/audit-kernel", "func": "static void sched_feat_disable(int i)\n{\n\tstatic_key_disable_cpuslocked(&sched_feat_keys[i]);\n}", "target": 1, "idx": 10457}
{"commit_id": "2c2cfbd2b771ac888bc5c4a6d922f749d3822538", "project": "the-tcpdump-group/tcpdump", "func": "static void\nip_optprint(netdissect_options *ndo,\n            register const u_char *cp, u_int length)\n{\n\tregister u_int option_len;\n\tconst char *sep = \"\";\n\n\tfor (; length > 0; cp += option_len, length -= option_len) {\n\t\tu_int option_code;\n\n\t\tND_PRINT((ndo, \"%s\", sep));\n\t\tsep = \",\";\n\n\t\tND_TCHECK(*cp);\n\t\toption_code = *cp;\n\n\t\tND_PRINT((ndo, \"%s\",\n\t\t          tok2str(ip_option_values,\"unknown %u\",option_code)));\n\n\t\tif (option_code == IPOPT_NOP ||\n                    option_code == IPOPT_EOL)\n\t\t\toption_len = 1;\n\n\t\telse {\n\t\t\tND_TCHECK(cp[1]);\n\t\t\toption_len = cp[1];\n\t\t\tif (option_len < 2) {\n\t\t\t\tND_PRINT((ndo, \" [bad length %u]\", option_len));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (option_len > length) {\n\t\t\tND_PRINT((ndo, \" [bad length %u]\", option_len));\n\t\t\treturn;\n\t\t}\n\n\t\tND_TCHECK2(*cp, option_len);\n\n\t\tswitch (option_code) {\n\t\tcase IPOPT_EOL:\n\t\t\treturn;\n\n\t\tcase IPOPT_TS:\n\t\t\tif (ip_printts(ndo, cp, option_len) == -1)\n\t\t\t\tgoto trunc;\n\t\t\tbreak;\n\n\t\tcase IPOPT_RR:       /* fall through */\n\t\tcase IPOPT_SSRR:\n\t\tcase IPOPT_LSRR:\n\t\t\tif (ip_printroute(ndo, cp, option_len) == -1)\n\t\t\t\tgoto trunc;\n\t\t\tbreak;\n\n\t\tcase IPOPT_RA:\n\t\t\tif (option_len < 4) {\n\t\t\t\tND_PRINT((ndo, \" [bad length %u]\", option_len));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tND_TCHECK(cp[3]);\n\t\t\tif (EXTRACT_16BITS(&cp[2]) != 0)\n\t\t\t\tND_PRINT((ndo, \" value %u\", EXTRACT_16BITS(&cp[2])));\n\t\t\tbreak;\n\n\t\tcase IPOPT_NOP:       /* nothing to print - fall through */\n\t\tcase IPOPT_SECURITY:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \"%s\", tstr));\n}", "target": 3, "idx": 10458}
{"commit_id": "c8d613ef497058fe653c467fc84c70a62a4a71b2", "project": "libtiff", "func": "static int\ngtTileContig(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint32 col, row, y, rowstoread;\n    tmsize_t pos;\n    uint32 tw, th;\n    unsigned char* buf = NULL;\n    int32 fromskew, toskew;\n    uint32 nrow;\n    int ret = 1, flip;\n    uint32 this_tw, tocol;\n    int32 this_toskew, leftmost_toskew;\n    int32 leftmost_fromskew;\n    uint32 leftmost_tw;\n    tmsize_t bufsize;\n\n    bufsize = TIFFTileSize(tif);\n    if (bufsize == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"%s\", \"No space for tile buffer\");\n        return (0);\n    }\n\n    TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tw);\n    TIFFGetField(tif, TIFFTAG_TILELENGTH, &th);\n\n    flip = setorientation(img);\n    if (flip & FLIP_VERTICALLY) {\n        if ((tw + w) > INT_MAX) {\n            TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"%s\", \"unsupported tile size (too wide)\");\n            return (0);\n        }\n        y = h - 1;\n        toskew = -(int32)(tw + w);\n    }\n    else {\n        if (tw > (INT_MAX + w)) {\n            TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"%s\", \"unsupported tile size (too wide)\");\n            return (0);\n        }\n        y = 0;\n        toskew = -(int32)(tw - w);\n    }\n     \n    /*\n     *\tLeftmost tile is clipped on left side if col_offset > 0.\n     */\n    leftmost_fromskew = img->col_offset % tw;\n    leftmost_tw = tw - leftmost_fromskew;\n    leftmost_toskew = toskew + leftmost_fromskew;\n    for (row = 0; ret != 0 && row < h; row += nrow)\n    {\n        rowstoread = th - (row + img->row_offset) % th;\n    \tnrow = (row + rowstoread > h ? h - row : rowstoread);\n\tfromskew = leftmost_fromskew;\n\tthis_tw = leftmost_tw;\n\tthis_toskew = leftmost_toskew;\n\ttocol = 0;\n\tcol = img->col_offset;\n\twhile (tocol < w)\n        {\n\t    if (_TIFFReadTileAndAllocBuffer(tif, (void**) &buf, bufsize, col,\n\t\t\t     row+img->row_offset, 0, 0)==(tmsize_t)(-1) &&\n                (buf == NULL || img->stoponerr))\n            {\n                ret = 0;\n                break;\n            }\n            pos = ((row+img->row_offset) % th) * TIFFTileRowSize(tif) + \\\n\t\t   ((tmsize_t) fromskew * img->samplesperpixel);\n\t    if (tocol + this_tw > w) \n\t    {\n\t\t/*\n\t\t * Rightmost tile is clipped on right side.\n\t\t */\n\t\tfromskew = tw - (w - tocol);\n\t\tthis_tw = tw - fromskew;\n\t\tthis_toskew = toskew + fromskew;\n\t    }\n\t    (*put)(img, raster+y*w+tocol, tocol, y, this_tw, nrow, fromskew, this_toskew, buf + pos);\n\t    tocol += this_tw;\n\t    col += this_tw;\n\t    /*\n\t     * After the leftmost tile, tiles are no longer clipped on left side.\n\t     */\n\t    fromskew = 0;\n\t    this_tw = tw;\n\t    this_toskew = toskew;\n\t}\n\n        y += ((flip & FLIP_VERTICALLY) ? -(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n\n    if (flip & FLIP_HORIZONTALLY) {\n\t    uint32 line;\n\n\t    for (line = 0; line < h; line++) {\n\t\t    uint32 *left = raster + (line * w);\n\t\t    uint32 *right = left + w - 1;\n\t\t    \n\t\t    while ( left < right ) {\n\t\t\t    uint32 temp = *left;\n\t\t\t    *left = *right;\n\t\t\t    *right = temp;\n\t\t\t    left++;\n\t\t\t\tright--;\n\t\t    }\n\t    }\n    }\n\n    return (ret);\n}", "target": 2, "idx": 10459}
{"commit_id": "1f3e2e97c003f80c4b087092b225c8787ff91e4d", "project": "torvalds/linux", "func": "int detach_capi_ctr(struct capi_ctr *ctr)\n{\n\tint err = 0;\n\n\tmutex_lock(&capi_controller_lock);\n\n\tctr_down(ctr, CAPI_CTR_DETACHED);\n\n\tif (ctr->cnr < 1 || ctr->cnr - 1 >= CAPI_MAXCONTR) {\n\t\terr = -EINVAL;\n\t\tgoto unlock_out;\n\t}\n\n\tif (capi_controller[ctr->cnr - 1] != ctr) {\n\t\terr = -EINVAL;\n\t\tgoto unlock_out;\n\t}\n\tcapi_controller[ctr->cnr - 1] = NULL;\n\tncontrollers--;\n\n\tif (ctr->procent)\n\t\tremove_proc_entry(ctr->procfn, NULL);\n\n\tprintk(KERN_NOTICE \"kcapi: controller [%03d]: %s unregistered\\n\",\n\t       ctr->cnr, ctr->name);\n\nunlock_out:\n\tmutex_unlock(&capi_controller_lock);\n\n\treturn err;\n}", "target": 1, "idx": 10460}
{"commit_id": "ed4c8d79153baab7f26562afb8930652dfbf853b", "project": "android", "func": "static uint32_t readU32(const uint8_t* data, size_t offset) {\n    return ((uint32_t)data[offset]) << 24 | ((uint32_t)data[offset + 1]) << 16 |\n        ((uint32_t)data[offset + 2]) << 8 | ((uint32_t)data[offset + 3]);\n}", "target": 1, "idx": 10461}
{"commit_id": "afc39bea36fd436e54262f150c009e8d72db5014", "project": "envoyproxy/envoy", "func": "void HeaderMapImpl::addCopy(const LowerCaseString& key, uint64_t value) {\n  auto* entry = getExistingInline(key.get());\n  if (entry != nullptr) {\n    char buf[32];\n    StringUtil::itoa(buf, sizeof(buf), value);\n    const uint64_t added_size = appendToHeader(entry->value(), buf);\n    addSize(added_size);\n    return;\n  }\n  HeaderString new_key;\n  new_key.setCopy(key.get().c_str(), key.get().size());\n  HeaderString new_value;\n  new_value.setInteger(value);\n  insertByKey(std::move(new_key), std::move(new_value));\n  ASSERT(new_key.empty());   // NOLINT(bugprone-use-after-move)\n  ASSERT(new_value.empty()); // NOLINT(bugprone-use-after-move)\n}", "target": 2, "idx": 10462}
{"commit_id": "7a6f636db3360bb16d18078d51e8c596f31302a1", "project": "gpac", "func": "static GF_Err mp4_mux_done(GF_MP4MuxCtx *ctx, Bool is_final)\n{\n\tGF_Err e = GF_OK;\n\tu32 i, count;\n\tGF_PropertyEntry *pe=NULL;\n\n\tcount = gf_list_count(ctx->tracks);\n\tfor (i=0; i<count; i++) {\n\t\tu32 ctts_mode = ctx->ctmode;\n\t\tconst GF_PropertyValue *p;\n\t\tBool has_bframes = GF_FALSE;\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ISOM_FORCE_NEGCTTS);\n\t\tif (p && p->value.boolean) ctts_mode = MP4MX_CT_NEGCTTS;\n\n\t\tif (tkw->min_neg_ctts<0) {\n\t\t\t//use ctts v1 negative offsets\n\t\t\tif (ctts_mode==MP4MX_CT_NEGCTTS) {\n\t\t\t\tgf_isom_set_ctts_v1(ctx->file, tkw->track_num, (u32) -tkw->min_neg_ctts);\n\t\t\t}\n\t\t\t//ctts v0\n\t\t\telse {\n\t\t\t\tgf_isom_set_cts_packing(ctx->file, tkw->track_num, GF_TRUE);\n\t\t\t\tgf_isom_shift_cts_offset(ctx->file, tkw->track_num, (s32) tkw->min_neg_ctts);\n\t\t\t\tgf_isom_set_cts_packing(ctx->file, tkw->track_num, GF_FALSE);\n\t\t\t\tgf_isom_set_composition_offset_mode(ctx->file, tkw->track_num, GF_FALSE);\n\n\t\t\t\tmp4_mux_update_edit_list_for_bframes(ctx, tkw, ctts_mode);\n\t\t\t}\n\t\t\thas_bframes = GF_TRUE;\n\t\t} else if (tkw->has_ctts && (tkw->stream_type==GF_STREAM_VISUAL)) {\n\t\t\tmp4_mux_update_edit_list_for_bframes(ctx, tkw, ctts_mode);\n\n\t\t\thas_bframes = GF_TRUE;\n\t\t} else if (tkw->ts_delay || tkw->empty_init_dur) {\n\t\t\tgf_isom_update_edit_list_duration(ctx->file, tkw->track_num);\n\t\t}\n\n\t\tif (tkw->min_ts_seek_plus_one) {\n\t\t\tu64 min_ts = tkw->min_ts_seek_plus_one - 1;\n\t\t\tu64 mdur = gf_isom_get_media_duration(ctx->file, tkw->track_num);\n\t\t\tu32 delay = 0;\n\t\t\tif (tkw->clamp_ts_plus_one) {\n\t\t\t\tmdur = tkw->max_cts - tkw->min_cts;\n\t\t\t\tmdur += tkw->max_cts_samp_dur;\n\t\t\t}\n\t\t\tif (mdur > min_ts)\n\t\t\t\tmdur -= min_ts;\n\t\t\telse\n\t\t\t\tmdur = 0;\n\n\t\t\tif ((ctts_mode != MP4MX_CT_NEGCTTS) && (tkw->ts_delay<0) && (tkw->stream_type==GF_STREAM_VISUAL)) {\n\t\t\t\tdelay = (u32) -tkw->ts_delay;\n\t\t\t}\n\n\t\t\tif (tkw->src_timescale != tkw->tk_timescale) {\n\t\t\t\tmin_ts = gf_timestamp_rescale(min_ts, tkw->src_timescale, tkw->tk_timescale);\n\t\t\t\tdelay = (u32) gf_timestamp_rescale(delay, tkw->src_timescale, tkw->tk_timescale);\n\t\t\t}\n\t\t\tmdur += delay;\n\n\t\t\tif (ctx->moovts != tkw->tk_timescale) {\n\t\t\t\tmdur = gf_timestamp_rescale(mdur, tkw->tk_timescale, ctx->moovts);\n\t\t\t}\n\t\t\tgf_isom_remove_edits(ctx->file, tkw->track_num);\n\t\t\tif (tkw->empty_init_dur)\n\t\t\t\tgf_isom_set_edit(ctx->file, tkw->track_num, 0, tkw->empty_init_dur, 0, GF_ISOM_EDIT_EMPTY);\n\t\t\tgf_isom_set_edit(ctx->file, tkw->track_num, tkw->empty_init_dur, mdur, min_ts, GF_ISOM_EDIT_NORMAL);\n\t\t}\n\n\t\tif (tkw->force_ctts) {\n\t\t\tGF_Err gf_isom_force_ctts(GF_ISOFile *file, u32 track);\n\t\t\tgf_isom_force_ctts(ctx->file, tkw->track_num);\n\t\t}\n\n\t\tgf_isom_purge_track_reference(ctx->file, tkw->track_num);\n\n\t\tif (ctx->importer && ctx->dur.num && ctx->dur.den) {\n\t\t\tu64 mdur = gf_isom_get_media_duration(ctx->file, tkw->track_num);\n\t\t\tu64 pdur = gf_isom_get_track_duration(ctx->file, tkw->track_num);\n\t\t\tif (pdur==mdur) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[MP4Mux] Imported %d frames - duration %g\\n\", tkw->nb_samples, ((Double)mdur)/tkw->tk_timescale ));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[MP4Mux] Imported %d frames - media duration %g - track duration %g\\n\", tkw->nb_samples, ((Double)mdur)/tkw->tk_timescale, ((Double)pdur)/ctx->moovts ));\n\t\t\t}\n\t\t}\n\n\t\t/*this is plain ugly but since some encoders (divx) don't use the video PL correctly\n\t\t we force the system video_pl to ASP@L5 since we have I, P, B in base layer*/\n\t\tif (tkw->codecid == GF_CODECID_MPEG4_PART2) {\n\t\t\tBool force_rewrite = GF_FALSE;\n\t\t\tu32 PL = tkw->media_profile_level;\n\t\t\tif (!PL) PL = 0x01;\n\n\t\t\tif (ctx->importer) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"Indicated Profile: %s\\n\", gf_m4v_get_profile_name((u8) PL) ));\n\t\t\t}\n\n\t\t\tif (has_bframes && (tkw->media_profile_level <= 3)) {\n\t\t\t\tPL = 0xF5;\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Indicated profile doesn't include B-VOPs - forcing %s\\n\", gf_m4v_get_profile_name((u8) PL) ));\n\t\t\t\tforce_rewrite = GF_TRUE;\n\t\t\t}\n\t\t\tif (PL != tkw->media_profile_level) {\n\t\t\t\tif (force_rewrite) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\tGF_ESD *esd = gf_isom_get_esd(ctx->file, tkw->track_num, tkw->stsd_idx);\n\t\t\t\t\tassert(esd);\n\t\t\t\t\tgf_m4v_rewrite_pl(&esd->decoderConfig->decoderSpecificInfo->data, &esd->decoderConfig->decoderSpecificInfo->dataLength, (u8) PL);\n\t\t\t\t\tgf_isom_change_mpeg4_description(ctx->file, tkw->track_num, tkw->stsd_idx, esd);\n\t\t\t\t\tgf_odf_desc_del((GF_Descriptor*)esd);\n#endif\n\n\t\t\t\t}\n\t\t\t\tif (!ctx->make_qt)\n\t\t\t\t\tgf_isom_set_pl_indication(ctx->file, GF_ISOM_PL_VISUAL, PL);\n\t\t\t}\n\t\t}\n\n\n\t\tif (tkw->has_append)\n\t\t\tgf_isom_refresh_size_info(ctx->file, tkw->track_num);\n\n\t\tif ((tkw->nb_samples == 1) && (ctx->dur.num>0) && ctx->dur.den) {\n\t\t\tu32 dur = (u32) gf_timestamp_rescale(ctx->dur.num, ctx->dur.den, tkw->tk_timescale);\n\t\t\tgf_isom_set_last_sample_duration(ctx->file, tkw->track_num, dur);\n\t\t}\n\n\t\tif (tkw->has_open_gop) {\n\t\t\tif (ctx->importer) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"OpenGOP detected - adjusting file brand\\n\"));\n\t\t\t}\n\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISO6, GF_TRUE);\n\t\t}\n\n\t\tmp4_mux_set_hevc_groups(ctx, tkw);\n\n\t\tp = gf_filter_pid_get_info_str(tkw->ipid, \"ttxt:rem_last\", &pe);\n\t\tif (p && p->value.boolean)\n\t\t\tgf_isom_remove_sample(ctx->file, tkw->track_num, tkw->nb_samples);\n\n\t\tp = gf_filter_pid_get_info_str(tkw->ipid, \"ttxt:last_dur\", &pe);\n\t\tif (p) {\n\t\t\tu64 val = p->value.uint;\n\t\t\tif (tkw->src_timescale != tkw->tk_timescale) {\n\t\t\t\tval = gf_timestamp_rescale(val, tkw->src_timescale, tkw->tk_timescale);\n\t\t\t}\n\t\t\tgf_isom_set_last_sample_duration(ctx->file, tkw->track_num, (u32) val);\n\t\t}\n\t\tp = gf_filter_pid_get_info(tkw->ipid, GF_PROP_PID_FORCED_SUB, &pe);\n\t\tif (p) {\n\t\t\tgf_isom_set_forced_text(ctx->file, tkw->track_num, tkw->stsd_idx, p->value.uint);\n\t\t}\n\n\t\tif (tkw->is_nalu && ctx->pack_nal && (gf_isom_get_mode(ctx->file)!=GF_ISOM_OPEN_WRITE)) {\n\t\t\tu32 msize = 0;\n\t\t\tBool do_rewrite = GF_FALSE;\n\t\t\tu32 j, stsd_count = gf_isom_get_sample_description_count(ctx->file, tkw->track_num);\n\t\t\tp = gf_filter_pid_get_info(tkw->ipid, GF_PROP_PID_MAX_NALU_SIZE, &pe);\n\t\t\tmsize = gf_get_bit_size(p->value.uint);\n\t\t\tif (msize<8) msize = 8;\n\t\t\telse if (msize<16) msize = 16;\n\t\t\telse msize = 32;\n\n\t\t\tif (msize<=0xFFFF) {\n\t\t\t\tfor (j=0; j<stsd_count; j++) {\n\t\t\t\t\tu32 k = 8 * gf_isom_get_nalu_length_field(ctx->file, tkw->track_num, j+1);\n\t\t\t\t\tif (k > msize) {\n\t\t\t\t\t\tdo_rewrite = GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (do_rewrite) {\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[MP4Mux] Adjusting NALU SizeLength to %d bits\\n\", msize ));\n\t\t\t\t\tgf_media_nal_rewrite_samples(ctx->file, tkw->track_num, msize);\n\t\t\t\t\tmsize /= 8;\n\t\t\t\t\tfor (j=0; j<stsd_count; j++) {\n\t\t\t\t\t\tgf_isom_set_nalu_length_field(ctx->file, tkw->track_num, j+1, msize);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//don't update bitrate info for single sample tracks, unless MPEG-4 Systems - compatibility with old arch\n\t\tif (ctx->btrt && !tkw->skip_bitrate_update && ((tkw->nb_samples>1) || ctx->m4sys) )\n\t\t\tgf_media_update_bitrate(ctx->file, tkw->track_num);\n\n\t\tif (!tkw->box_patched) {\n\t\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"boxpatch\");\n\t\t\tif (p && p->value.string) {\n\t\t\t\te = gf_isom_apply_box_patch(ctx->file, tkw->track_id ? tkw->track_id : tkw->item_id, p->value.string, GF_FALSE);\n\t\t\t\tif (e) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Unable to apply box patch %s to track %d: %s\\n\",\n\t\t\t\t\t\tp->value.string, tkw->track_id, gf_error_to_string(e) ));\n\t\t\t\t}\n\t\t\t}\n\t\t\ttkw->box_patched = GF_TRUE;\n\t\t}\n\t}\n\n\tgf_filter_release_property(pe);\n\n\tif (ctx->boxpatch && !ctx->box_patched) {\n\t\te = gf_isom_apply_box_patch(ctx->file, 0, ctx->boxpatch, GF_FALSE);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Unable to apply box patch %s: %s\\n\", ctx->boxpatch, gf_error_to_string(e) ));\n\t\t}\n\t\tctx->box_patched = GF_TRUE;\n\t}\n\n\n\tif (ctx->owns_mov) {\n\t\tif (ctx->moovpad)\n\t\t\tgf_isom_set_inplace_padding(ctx->file, ctx->moovpad);\n\n\t\tswitch (ctx->store) {\n\t\tcase MP4MX_MODE_INTER:\n\t\t\tif (ctx->cdur.num==0) {\n\t\t\t\te = gf_isom_set_storage_mode(ctx->file, GF_ISOM_STORE_STREAMABLE);\n\t\t\t} else {\n\t\t\t\tif (ctx->cdur.num < 0) ctx->cdur.num = 1000;\n\t\t\t\te = gf_isom_make_interleave_ex(ctx->file, &ctx->cdur);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MP4MX_MODE_FLAT:\n\t\t\te = gf_isom_set_storage_mode(ctx->file, GF_ISOM_STORE_FLAT);\n\t\t\tbreak;\n\t\tcase MP4MX_MODE_FASTSTART:\n\t\t\te = gf_isom_set_storage_mode(ctx->file, GF_ISOM_STORE_FASTSTART);\n\t\t\tbreak;\n\t\tcase MP4MX_MODE_TIGHT:\n\t\t\te = gf_isom_set_storage_mode(ctx->file, GF_ISOM_STORE_TIGHT);\n\t\t\tbreak;\n\t\t}\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set storage mode: %s\\n\", gf_error_to_string(e) ));\n\t\t\tgf_isom_delete(ctx->file);\n\t\t} else {\n\t\t\te = gf_isom_close(ctx->file);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to write file: %s\\n\", gf_error_to_string(e) ));\n\t\t\t}\n\t\t}\n\t\tctx->file = NULL;\n\t\tif (is_final)\n\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t} else {\n\t\tctx->file = NULL;\n\t}\n\treturn e;\n}", "target": 1, "idx": 10463}
{"commit_id": "918eeaa29d99d257282fafec931b4bda0e3bae12", "project": "android", "func": "bool SoftAVC::setDecodeArgs(\n        ivd_video_decode_ip_t *ps_dec_ip,\n        ivd_video_decode_op_t *ps_dec_op,\n        OMX_BUFFERHEADERTYPE *inHeader,\n        OMX_BUFFERHEADERTYPE *outHeader,\n        size_t timeStampIx) {\n    size_t sizeY = outputBufferWidth() * outputBufferHeight();\n    size_t sizeUV;\n\n    ps_dec_ip->u4_size = sizeof(ivd_video_decode_ip_t);\n    ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);\n\n    ps_dec_ip->e_cmd = IVD_CMD_VIDEO_DECODE;\n\n    /* When in flush and after EOS with zero byte input,\n     * inHeader is set to zero. Hence check for non-null */\n    if (inHeader) {\n        ps_dec_ip->u4_ts = timeStampIx;\n        ps_dec_ip->pv_stream_buffer =\n            inHeader->pBuffer + inHeader->nOffset;\n        ps_dec_ip->u4_num_Bytes = inHeader->nFilledLen;\n    } else {\n        ps_dec_ip->u4_ts = 0;\n        ps_dec_ip->pv_stream_buffer = NULL;\n        ps_dec_ip->u4_num_Bytes = 0;\n    }\n\n    sizeUV = sizeY / 4;\n    ps_dec_ip->s_out_buffer.u4_min_out_buf_size[0] = sizeY;\n    ps_dec_ip->s_out_buffer.u4_min_out_buf_size[1] = sizeUV;\n    ps_dec_ip->s_out_buffer.u4_min_out_buf_size[2] = sizeUV;\n\n    uint8_t *pBuf;\n    if (outHeader) {\n        if (outHeader->nAllocLen < sizeY + (sizeUV * 2)) {\n            android_errorWriteLog(0x534e4554, \"27569635\");\n            return false;\n        }\n        pBuf = outHeader->pBuffer;\n    } else {\n        // mFlushOutBuffer always has the right size.\n        pBuf = mFlushOutBuffer;\n    }\n\n    ps_dec_ip->s_out_buffer.pu1_bufs[0] = pBuf;\n    ps_dec_ip->s_out_buffer.pu1_bufs[1] = pBuf + sizeY;\n    ps_dec_ip->s_out_buffer.pu1_bufs[2] = pBuf + sizeY + sizeUV;\n    ps_dec_ip->s_out_buffer.u4_num_bufs = 3;\n    return true;\n}", "target": 2, "idx": 10464}
{"commit_id": "118a46090c50829dc543179019e6140e1235f909", "project": "kohler/gifsicle", "func": "static Gif_Stream *\nread_gif(Gif_Reader *grr, int read_flags,\n\t const char* landmark, Gif_ReadErrorHandler handler)\n{\n  Gif_Stream *gfs;\n  Gif_Image *gfi;\n  Gif_Context gfc;\n  int unknown_block_type = 0;\n\n  if (gifgetc(grr) != 'G' ||\n      gifgetc(grr) != 'I' ||\n      gifgetc(grr) != 'F')\n    return 0;\n  (void)gifgetc(grr);\n  (void)gifgetc(grr);\n  (void)gifgetc(grr);\n\n  gfs = Gif_NewStream();\n  gfi = Gif_NewImage();\n\n  gfc.stream = gfs;\n  gfc.prefix = Gif_NewArray(Gif_Code, GIF_MAX_CODE);\n  gfc.suffix = Gif_NewArray(uint8_t, GIF_MAX_CODE);\n  gfc.length = Gif_NewArray(uint16_t, GIF_MAX_CODE);\n  gfc.handler = handler;\n  gfc.gfi = gfi;\n  gfc.errors[0] = gfc.errors[1] = 0;\n\n  if (!gfs || !gfi || !gfc.prefix || !gfc.suffix || !gfc.length)\n    goto done;\n  gfs->landmark = landmark;\n\n  GIF_DEBUG((\"\\nGIF \"));\n  if (!read_logical_screen_descriptor(gfs, grr))\n    goto done;\n  GIF_DEBUG((\"logscrdesc \"));\n\n  while (!gifeof(grr)) {\n\n    uint8_t block = gifgetbyte(grr);\n\n    switch (block) {\n\n     case ',': /* image block */\n      GIF_DEBUG((\"imageread %d \", gfs->nimages));\n\n      gfi->identifier = last_name;\n      last_name = 0;\n      if (!Gif_AddImage(gfs, gfi))\n          goto done;\n      else if (!read_image(grr, &gfc, gfi, read_flags)) {\n          Gif_RemoveImage(gfs, gfs->nimages - 1);\n          gfi = 0;\n          goto done;\n      }\n\n      gfc.gfi = gfi = Gif_NewImage();\n      if (!gfi)\n          goto done;\n      break;\n\n     case ';': /* terminator */\n      GIF_DEBUG((\"term\\n\"));\n      goto done;\n\n     case '!': /* extension */\n      block = gifgetbyte(grr);\n      GIF_DEBUG((\"ext(0x%02X) \", block));\n      switch (block) {\n\n       case 0xF9:\n\tread_graphic_control_extension(&gfc, gfi, grr);\n\tbreak;\n\n       case 0xCE:\n\tlast_name = suck_data(last_name, 0, grr);\n\tbreak;\n\n       case 0xFE:\n\tif (!read_comment_extension(gfi, grr)) goto done;\n\tbreak;\n\n       case 0xFF:\n\tread_application_extension(&gfc, grr);\n\tbreak;\n\n       default:\n        read_unknown_extension(&gfc, grr, block, 0, 0);\n\tbreak;\n\n      }\n      break;\n\n     default:\n       if (!unknown_block_type) {\n\t char buf[256];\n\t sprintf(buf, \"unknown block type %d at file offset %u\", block, grr->pos - 1);\n\t gif_read_error(&gfc, 1, buf);\n\t unknown_block_type = 1;\n       }\n       break;\n\n    }\n\n  }\n\n done:\n\n  /* Move comments and extensions after last image into stream. */\n  if (gfs && gfi) {\n      Gif_Extension* gfex;\n      gfs->end_comment = gfi->comment;\n      gfi->comment = 0;\n      gfs->end_extension_list = gfi->extension_list;\n      gfi->extension_list = 0;\n      for (gfex = gfs->end_extension_list; gfex; gfex = gfex->next)\n          gfex->image = NULL;\n  }\n\n  Gif_DeleteImage(gfi);\n  Gif_DeleteArray(last_name);\n  Gif_DeleteArray(gfc.prefix);\n  Gif_DeleteArray(gfc.suffix);\n  Gif_DeleteArray(gfc.length);\n  gfc.gfi = 0;\n  last_name = 0;\n\n  if (gfs)\n    gfs->errors = gfc.errors[1];\n  if (gfs && gfc.errors[1] == 0\n      && !(read_flags & GIF_READ_TRAILING_GARBAGE_OK)\n      && !grr->eofer(grr))\n      gif_read_error(&gfc, 0, \"trailing garbage after GIF ignored\");\n  /* finally, export last message */\n  gif_read_error(&gfc, -1, 0);\n\n  return gfs;\n}", "target": 2, "idx": 10465}
{"commit_id": "ab4d641e395b09c7bb86acfe243a8b986609d72c", "project": "axiomatic-systems/Bento4", "func": "AP4_Result\nAP4_StszAtom::SetSampleSize(AP4_Ordinal sample, AP4_Size sample_size)\n{\n    // check the sample index\n    if (sample > m_SampleCount || sample == 0) {\n        return AP4_ERROR_OUT_OF_RANGE;\n    } else {\n        if (m_Entries.ItemCount() == 0) {\n            // all samples must have the same size\n            if (sample_size != m_SampleSize) {\n                // not the same\n                if (sample == 1 && sample_size != 0) {\n                    // if this is the first sample, update the global size\n                    m_SampleSize = sample_size;\n                    return AP4_SUCCESS;\n                } else {\n                    // can't have different sizes\n                    return AP4_ERROR_INVALID_PARAMETERS;\n                }\n            }\n        } else {\n            // each sample has a different size\n            if (sample > m_Entries.ItemCount()) {\n                return AP4_ERROR_OUT_OF_RANGE;\n            }\n            m_Entries[sample - 1] = sample_size;\n        }\n\n        return AP4_SUCCESS;\n    }\n}", "target": 2, "idx": 10466}
{"commit_id": "4a59cfaf9ab3d48fca4a15c0d2674bf7138e3d1a", "project": "jasper-software/jasper", "func": "void jpc_qmfb_split_colgrp(jpc_fix_t *a, int numrows, int stride,\n  int parity)\n{\n\n\tint bufsize = JPC_CEILDIVPOW2(numrows, 1);\n\tjpc_fix_t splitbuf[QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE];\n\tjpc_fix_t *buf = splitbuf;\n\tjpc_fix_t *srcptr;\n\tjpc_fix_t *dstptr;\n\tregister jpc_fix_t *srcptr2;\n\tregister jpc_fix_t *dstptr2;\n\tregister int n;\n\tregister int i;\n\tint m;\n\tint hstartrow;\n\n\t/* Get a buffer. */\n\tif (bufsize > QMFB_SPLITBUFSIZE) {\n\t\tif (!(buf = jas_alloc3(bufsize, JPC_QMFB_COLGRPSIZE,\n\t\t  sizeof(jpc_fix_t)))) {\n\t\t\t/* We have no choice but to commit suicide in this case. */\n\t\t\tabort();\n\t\t}\n\t}\n\n\tif (numrows >= 2) {\n\t\thstartrow = (numrows + 1 - parity) >> 1;\n\t\t// ORIGINAL (WRONG): m = (parity) ? hstartrow : (numrows - hstartrow);\n\t\tm = numrows - hstartrow;\n\n\t\t/* Save the samples destined for the highpass channel. */\n\t\tn = m;\n\t\tdstptr = buf;\n\t\tsrcptr = &a[(1 - parity) * stride];\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += JPC_QMFB_COLGRPSIZE;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\t/* Copy the appropriate samples into the lowpass channel. */\n\t\tdstptr = &a[(1 - parity) * stride];\n\t\tsrcptr = &a[(2 - parity) * stride];\n\t\tn = numrows - m - (!parity);\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\t/* Copy the saved samples into the highpass channel. */\n\t\tdstptr = &a[hstartrow * stride];\n\t\tsrcptr = buf;\n\t\tn = m;\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += JPC_QMFB_COLGRPSIZE;\n\t\t}\n\t}\n\n\t/* If the split buffer was allocated on the heap, free this memory. */\n\tif (buf != splitbuf) {\n\t\tjas_free(buf);\n\t}\n\n}", "target": 2, "idx": 10467}
{"commit_id": "766ff5108464161887dbcd209033c303bcff432c", "project": "WebAssembly/binaryen", "func": "void WasmBinaryBuilder::visitBlock(Block* curr) {\n  if (debug) std::cerr << \"zz node: Block\" << std::endl;\n  // special-case Block and de-recurse nested blocks in their first position, as that is\n  // a common pattern that can be very highly nested.\n  std::vector<Block*> stack;\n  while (1) {\n    curr->type = getType();\n    curr->name = getNextLabel();\n    breakStack.push_back({curr->name, curr->type != none});\n    stack.push_back(curr);\n    if (more() && input[pos] == BinaryConsts::Block) {\n      // a recursion\n      readNextDebugLocation();\n      curr = allocator.alloc<Block>();\n      pos++;\n      if (debugLocation.size()) {\n        currFunction->debugLocations[curr] = *debugLocation.begin();\n      }\n      continue;\n    } else {\n      // end of recursion\n      break;\n    }\n  }\n  Block* last = nullptr;\n  while (stack.size() > 0) {\n    curr = stack.back();\n    stack.pop_back();\n    size_t start = expressionStack.size(); // everything after this, that is left when we see the marker, is ours\n    if (last) {\n      // the previous block is our first-position element\n      expressionStack.push_back(last);\n    }\n    last = curr;\n    processExpressions();\n    size_t end = expressionStack.size();\n    if (end < start) {\n      throwError(\"block cannot pop from outside\");\n    }\n    pushBlockElements(curr, start, end);\n    curr->finalize(curr->type, breakTargetNames.find(curr->name) != breakTargetNames.end() /* hasBreak */);\n    breakStack.pop_back();\n    breakTargetNames.erase(curr->name);\n  }\n}", "target": 1, "idx": 10468}
{"commit_id": "ade71fb544391b2e33e1859645726bfee0d5eaaf", "project": "GNOME/glib", "func": "static gboolean\ngvs_tuple_is_normal (GVariantSerialised value)\n{\n  guint offset_size;\n  gsize offset_ptr;\n  gsize length;\n  gsize offset;\n  gsize i;\n\n  /* as per the comment in gvs_tuple_get_child() */\n  if G_UNLIKELY (value.data == NULL && value.size != 0)\n    return FALSE;\n\n  offset_size = gvs_get_offset_size (value.size);\n  length = g_variant_type_info_n_members (value.type_info);\n  offset_ptr = value.size;\n  offset = 0;\n\n  for (i = 0; i < length; i++)\n    {\n      const GVariantMemberInfo *member_info;\n      GVariantSerialised child = { 0, };\n      gsize fixed_size;\n      guint alignment;\n      gsize end;\n\n      member_info = g_variant_type_info_member_info (value.type_info, i);\n      child.type_info = member_info->type_info;\n      child.depth = value.depth + 1;\n\n      g_variant_type_info_query (child.type_info, &alignment, &fixed_size);\n\n      while (offset & alignment)\n        {\n          if (offset > value.size || value.data[offset] != '\\0')\n            return FALSE;\n          offset++;\n        }\n\n      child.data = value.data + offset;\n\n      switch (member_info->ending_type)\n        {\n        case G_VARIANT_MEMBER_ENDING_FIXED:\n          end = offset + fixed_size;\n          break;\n\n        case G_VARIANT_MEMBER_ENDING_LAST:\n          end = offset_ptr;\n          break;\n\n        case G_VARIANT_MEMBER_ENDING_OFFSET:\n          if (offset_ptr < offset_size)\n            return FALSE;\n\n          offset_ptr -= offset_size;\n\n          if (offset_ptr < offset)\n            return FALSE;\n\n          end = gvs_read_unaligned_le (value.data + offset_ptr, offset_size);\n          break;\n\n        default:\n          g_assert_not_reached ();\n        }\n\n      if (end < offset || end > offset_ptr)\n        return FALSE;\n\n      child.size = end - offset;\n\n      if (child.size == 0)\n        child.data = NULL;\n\n      if (!g_variant_serialised_is_normal (child))\n        return FALSE;\n\n      offset = end;\n    }\n\n  /* All element bounds have been checked above. */\n  value.ordered_offsets_up_to = G_MAXSIZE;\n\n  {\n    gsize fixed_size;\n    guint alignment;\n\n    g_variant_type_info_query (value.type_info, &alignment, &fixed_size);\n\n    if (fixed_size)\n      {\n        g_assert (fixed_size == value.size);\n        g_assert (offset_ptr == value.size);\n\n        if (i == 0)\n          {\n            if (value.data[offset++] != '\\0')\n              return FALSE;\n          }\n        else\n          {\n            while (offset & alignment)\n              if (value.data[offset++] != '\\0')\n                return FALSE;\n          }\n\n        g_assert (offset == value.size);\n      }\n  }\n\n  return offset_ptr == offset;\n}", "target": 1, "idx": 10469}
{"commit_id": "93aa42b85ae0084ba7b749d0e990c94fbf0c17e3", "project": "xen-project/xen", "func": "static int hvm_load_segment_selector(\n    enum x86_segment seg, uint16_t sel, unsigned int eflags)\n{\n    struct segment_register desctab, cs, segr;\n    struct desc_struct *pdesc, desc;\n    u8 dpl, rpl, cpl;\n    bool_t writable;\n    int fault_type = TRAP_invalid_tss;\n    struct vcpu *v = current;\n\n    if ( eflags & X86_EFLAGS_VM )\n    {\n        segr.sel = sel;\n        segr.base = (uint32_t)sel << 4;\n        segr.limit = 0xffffu;\n        segr.attr.bytes = 0xf3;\n        hvm_set_segment_register(v, seg, &segr);\n        return 0;\n    }\n\n    /* NULL selector? */\n    if ( (sel & 0xfffc) == 0 )\n    {\n        if ( (seg == x86_seg_cs) || (seg == x86_seg_ss) )\n            goto fail;\n        memset(&segr, 0, sizeof(segr));\n        segr.sel = sel;\n        hvm_set_segment_register(v, seg, &segr);\n        return 0;\n    }\n\n    /* LDT descriptor must be in the GDT. */\n    if ( (seg == x86_seg_ldtr) && (sel & 4) )\n        goto fail;\n\n    hvm_get_segment_register(v, x86_seg_cs, &cs);\n    hvm_get_segment_register(\n        v, (sel & 4) ? x86_seg_ldtr : x86_seg_gdtr, &desctab);\n\n    /* Segment not valid for use (cooked meaning of .p)? */\n    if ( !desctab.attr.fields.p )\n        goto fail;\n\n    /* Check against descriptor table limit. */\n    if ( ((sel & 0xfff8) + 7) > desctab.limit )\n        goto fail;\n\n    pdesc = hvm_map_entry(desctab.base + (sel & 0xfff8), &writable);\n    if ( pdesc == NULL )\n        goto hvm_map_fail;\n\n    do {\n        desc = *pdesc;\n\n        /* LDT descriptor is a system segment. All others are code/data. */\n        if ( (desc.b & (1u<<12)) == ((seg == x86_seg_ldtr) << 12) )\n            goto unmap_and_fail;\n\n        dpl = (desc.b >> 13) & 3;\n        rpl = sel & 3;\n        cpl = cs.sel & 3;\n\n        switch ( seg )\n        {\n        case x86_seg_cs:\n            /* Code segment? */\n            if ( !(desc.b & _SEGMENT_CODE) )\n                goto unmap_and_fail;\n            /* Non-conforming segment: check DPL against RPL. */\n            if ( !(desc.b & _SEGMENT_EC) && (dpl != rpl) )\n                goto unmap_and_fail;\n            break;\n        case x86_seg_ss:\n            /* Writable data segment? */\n            if ( (desc.b & (_SEGMENT_CODE|_SEGMENT_WR)) != _SEGMENT_WR )\n                goto unmap_and_fail;\n            if ( (dpl != cpl) || (dpl != rpl) )\n                goto unmap_and_fail;\n            break;\n        case x86_seg_ldtr:\n            /* LDT system segment? */\n            if ( (desc.b & _SEGMENT_TYPE) != (2u<<8) )\n                goto unmap_and_fail;\n            goto skip_accessed_flag;\n        default:\n            /* Readable code or data segment? */\n            if ( (desc.b & (_SEGMENT_CODE|_SEGMENT_WR)) == _SEGMENT_CODE )\n                goto unmap_and_fail;\n            /*\n             * Data or non-conforming code segment:\n             * check DPL against RPL and CPL.\n             */\n            if ( ((desc.b & (_SEGMENT_EC|_SEGMENT_CODE)) !=\n                  (_SEGMENT_EC|_SEGMENT_CODE))\n                 && ((dpl < cpl) || (dpl < rpl)) )\n                goto unmap_and_fail;\n            break;\n        }\n\n        /* Segment present in memory? */\n        if ( !(desc.b & _SEGMENT_P) )\n        {\n            fault_type = (seg != x86_seg_ss) ? TRAP_no_segment\n                                             : TRAP_stack_error;\n            goto unmap_and_fail;\n        }\n    } while ( !(desc.b & 0x100) && /* Ensure Accessed flag is set */\n              writable && /* except if we are to discard writes */\n              (cmpxchg(&pdesc->b, desc.b, desc.b | 0x100) != desc.b) );\n\n    /* Force the Accessed flag in our local copy. */\n    desc.b |= 0x100;\n\n skip_accessed_flag:\n    hvm_unmap_entry(pdesc);\n\n    segr.base = (((desc.b <<  0) & 0xff000000u) |\n                 ((desc.b << 16) & 0x00ff0000u) |\n                 ((desc.a >> 16) & 0x0000ffffu));\n    segr.attr.bytes = (((desc.b >>  8) & 0x00ffu) |\n                       ((desc.b >> 12) & 0x0f00u));\n    segr.limit = (desc.b & 0x000f0000u) | (desc.a & 0x0000ffffu);\n    if ( segr.attr.fields.g )\n        segr.limit = (segr.limit << 12) | 0xfffu;\n    segr.sel = sel;\n    hvm_set_segment_register(v, seg, &segr);\n\n    return 0;\n\n unmap_and_fail:\n    hvm_unmap_entry(pdesc);\n fail:\n    hvm_inject_hw_exception(fault_type, sel & 0xfffc);\n hvm_map_fail:\n    return 1;\n}", "target": 2, "idx": 10470}
{"commit_id": "d59e55b018cfb79d0c4f794041aff4fe1cd0d570", "project": "xen-project/xen", "func": "int hvm_unmap_io_range_from_ioreq_server(struct domain *d, ioservid_t id,\n                                         uint32_t type, uint64_t start,\n                                         uint64_t end)\n{\n    struct hvm_ioreq_server *s;\n    int rc;\n\n    if ( start > end )\n        return -EINVAL;\n\n    spin_lock_recursive(&d->arch.hvm_domain.ioreq_server.lock);\n\n    rc = -ENOENT;\n    list_for_each_entry ( s,\n                          &d->arch.hvm_domain.ioreq_server.list,\n                          list_entry )\n    {\n        if ( s == d->arch.hvm_domain.default_ioreq_server )\n            continue;\n\n        if ( s->id == id )\n        {\n            struct rangeset *r;\n\n            switch ( type )\n            {\n            case XEN_DMOP_IO_RANGE_PORT:\n            case XEN_DMOP_IO_RANGE_MEMORY:\n            case XEN_DMOP_IO_RANGE_PCI:\n                r = s->range[type];\n                break;\n\n            default:\n                r = NULL;\n                break;\n            }\n\n            rc = -EINVAL;\n            if ( !r )\n                break;\n\n            rc = -ENOENT;\n            if ( !rangeset_contains_range(r, start, end) )\n                break;\n\n            rc = rangeset_remove_range(r, start, end);\n            break;\n        }\n    }\n\n    spin_unlock_recursive(&d->arch.hvm_domain.ioreq_server.lock);\n\n    return rc;\n}", "target": 1, "idx": 10471}
{"commit_id": "1c88bbd728da6bff8f4533bcfdb0dfef4ed8038b", "project": "wernsey/bitmap", "func": "void bm_poly(Bitmap *b, BmPoint points[], unsigned int n) {\n    unsigned int i;\n\tassert(b);\n    if(n < 2) return;\n    for(i = 0; i < n - 1; i++) {\n        bm_line(b, points[i].x, points[i].y, points[i+1].x, points[i+1].y);\n    }\n    bm_line(b, points[0].x, points[0].y, points[i].x, points[i].y);\n}", "target": 2, "idx": 10472}
{"commit_id": "eb2980683e6472aff35a3117587c4f814515c74d", "project": "GNOME/gimp", "func": "static gint\nread_creator_block (FILE     *f,\n                    gint      image_ID,\n                    guint     total_len,\n                    PSPimage *ia)\n{\n  long          data_start;\n  guchar        buf[4];\n  guint16       keyword;\n  guint32       length;\n  gchar        *string;\n  gchar        *title = NULL, *artist = NULL, *copyright = NULL, *description = NULL;\n  guint32       dword;\n  guint32       __attribute__((unused))cdate = 0;\n  guint32       __attribute__((unused))mdate = 0;\n  guint32       __attribute__((unused))appid;\n  guint32       __attribute__((unused))appver;\n  GString      *comment;\n  GimpParasite *comment_parasite;\n\n  data_start = ftell (f);\n  comment = g_string_new (NULL);\n\n  while (ftell (f) < data_start + total_len)\n    {\n      if (fread (buf, 4, 1, f) < 1\n          || fread (&keyword, 2, 1, f) < 1\n          || fread (&length, 4, 1, f) < 1)\n        {\n          g_message (\"Error reading creator keyword chunk\");\n          return -1;\n        }\n      if (memcmp (buf, \"~FL\\0\", 4) != 0)\n        {\n          g_message (\"Invalid keyword chunk header\");\n          return -1;\n        }\n      keyword = GUINT16_FROM_LE (keyword);\n      length = GUINT32_FROM_LE (length);\n      switch (keyword)\n        {\n        case PSP_CRTR_FLD_TITLE:\n        case PSP_CRTR_FLD_ARTIST:\n        case PSP_CRTR_FLD_CPYRGHT:\n        case PSP_CRTR_FLD_DESC:\n          string = g_malloc (length + 1);\n          if (fread (string, length, 1, f) < 1)\n            {\n              g_message (\"Error reading creator keyword data\");\n              g_free (string);\n              return -1;\n            }\n          if (string[length - 1] != '\\0')\n            {\n              g_message (\"Creator keyword data not nul-terminated\");\n              g_free (string);\n              return -1;\n            }\n          switch (keyword)\n            {\n            case PSP_CRTR_FLD_TITLE:\n              g_free (title); title = string; break;\n            case PSP_CRTR_FLD_ARTIST:\n              g_free (artist); artist = string; break;\n            case PSP_CRTR_FLD_CPYRGHT:\n              g_free (copyright); copyright = string; break;\n            case PSP_CRTR_FLD_DESC:\n              g_free (description); description = string; break;\n            default:\n              g_free (string);\n            }\n          break;\n        case PSP_CRTR_FLD_CRT_DATE:\n        case PSP_CRTR_FLD_MOD_DATE:\n        case PSP_CRTR_FLD_APP_ID:\n        case PSP_CRTR_FLD_APP_VER:\n          if (fread (&dword, 4, 1, f) < 1)\n            {\n              g_message (\"Error reading creator keyword data\");\n              return -1;\n            }\n          switch (keyword)\n            {\n            case PSP_CRTR_FLD_CRT_DATE:\n              cdate = dword; break;\n            case PSP_CRTR_FLD_MOD_DATE:\n              mdate = dword; break;\n            case PSP_CRTR_FLD_APP_ID:\n              appid = dword; break;\n            case PSP_CRTR_FLD_APP_VER:\n              appver = dword; break;\n            }\n          break;\n        default:\n          if (try_fseek (f, length, SEEK_CUR) < 0)\n            {\n              return -1;\n            }\n          break;\n        }\n    }\n\n  if (title)\n    {\n      g_string_append (comment, title);\n      g_free (title);\n      g_string_append (comment, \"\\n\");\n    }\n  if (artist)\n    {\n      g_string_append (comment, artist);\n      g_free (artist);\n      g_string_append (comment, \"\\n\");\n    }\n  if (copyright)\n    {\n      g_string_append (comment, \"Copyright \");\n      g_string_append (comment, copyright);\n      g_free (copyright);\n      g_string_append (comment, \"\\n\");\n    }\n  if (description)\n    {\n      g_string_append (comment, description);\n      g_free (description);\n      g_string_append (comment, \"\\n\");\n    }\n  if (comment->len > 0)\n    {\n      comment_parasite = gimp_parasite_new (\"gimp-comment\",\n                                            GIMP_PARASITE_PERSISTENT,\n                                            strlen (comment->str) + 1,\n                                            comment->str);\n      gimp_image_attach_parasite (image_ID, comment_parasite);\n      gimp_parasite_free (comment_parasite);\n    }\n\n  g_string_free (comment, FALSE);\n\n  return 0;\n}", "target": 2, "idx": 10473}
{"commit_id": "073d0552ead5bfc7a3a9c01de590e924f11b5dd2", "project": "torvalds/linux", "func": "static int set_evtchn_to_irq(evtchn_port_t evtchn, unsigned int irq)\n{\n\tunsigned row;\n\tunsigned col;\n\n\tif (evtchn >= xen_evtchn_max_channels())\n\t\treturn -EINVAL;\n\n\trow = EVTCHN_ROW(evtchn);\n\tcol = EVTCHN_COL(evtchn);\n\n\tif (evtchn_to_irq[row] == NULL) {\n\t\t/* Unallocated irq entries return -1 anyway */\n\t\tif (irq == -1)\n\t\t\treturn 0;\n\n\t\tevtchn_to_irq[row] = (int *)get_zeroed_page(GFP_KERNEL);\n\t\tif (evtchn_to_irq[row] == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tclear_evtchn_to_irq_row(row);\n\t}\n\n\tWRITE_ONCE(evtchn_to_irq[row][col], irq);\n\treturn 0;\n}", "target": 1, "idx": 10474}
{"commit_id": "94f11ca5cf011ef123bd222cabeaef6f424d76ac", "project": "xorg/xserver", "func": "char *\nXkbVModMaskText(XkbDescPtr xkb,\n                unsigned modMask, unsigned mask, unsigned format)\n{\n    register int i, bit;\n    int len;\n    char *mm, *rtrn;\n    char *str, buf[VMOD_BUFFER_SIZE];\n\n    if ((modMask == 0) && (mask == 0)) {\n        rtrn = tbGetBuffer(5);\n        if (format == XkbCFile)\n            sprintf(rtrn, \"0\");\n        else\n            sprintf(rtrn, \"none\");\n        return rtrn;\n    }\n    if (modMask != 0)\n        mm = XkbModMaskText(modMask, format);\n    else\n        mm = NULL;\n\n    str = buf;\n    buf[0] = '\\0';\n    if (mask) {\n        char *tmp;\n\n        for (i = 0, bit = 1; i < XkbNumVirtualMods; i++, bit <<= 1) {\n            if (mask & bit) {\n                tmp = XkbVModIndexText(xkb, i, format);\n                len = strlen(tmp) + 1 + (str == buf ? 0 : 1);\n                if (format == XkbCFile)\n                    len += 4;\n                if ((str - (buf + len)) <= VMOD_BUFFER_SIZE) {\n                    if (str != buf) {\n                        if (format == XkbCFile)\n                            *str++ = '|';\n                        else\n                            *str++ = '+';\n                        len--;\n                    }\n                }\n                if (format == XkbCFile)\n                    sprintf(str, \"%sMask\", tmp);\n                else\n                    strcpy(str, tmp);\n                str = &str[len - 1];\n            }\n        }\n        str = buf;\n    }\n    else\n        str = NULL;\n    if (mm)\n        len = strlen(mm);\n    else\n        len = 0;\n    if (str)\n        len += strlen(str) + (mm == NULL ? 0 : 1);\n    rtrn = tbGetBuffer(len + 1);\n    rtrn[0] = '\\0';\n\n    if (mm != NULL) {\n        i = strlen(mm);\n        if (i > len)\n            i = len;\n        strcpy(rtrn, mm);\n    }\n    else {\n        i = 0;\n    }\n    if (str != NULL) {\n        if (mm != NULL) {\n            if (format == XkbCFile)\n                strcat(rtrn, \"|\");\n            else\n                strcat(rtrn, \"+\");\n        }\n        strncat(rtrn, str, len - i);\n    }\n    rtrn[len] = '\\0';\n    return rtrn;\n}", "target": 2, "idx": 10475}
{"commit_id": "3d89911481ba6ebe8c88c1c0b595412121e6c645", "project": "tensorflow", "func": "Status BuildInputArgIndex(const OpDef::ArgDef& arg_def, AttrSlice attr_values,\n                            const FunctionDef::ArgAttrs* arg_attrs,\n                            bool ints_on_device,\n                            int64_t resource_arg_unique_id) {\n    bool is_type_list;\n    DataTypeVector dtypes;\n    TF_RETURN_IF_ERROR(\n        ArgNumType(attr_values, arg_def, &is_type_list, &dtypes));\n    if (dtypes.size() < size_t{1}) {\n      return errors::Internal(\"Expected a list of at least one dtype\");\n    }\n    int arg_index = result_.nodes.size();\n    TF_RETURN_IF_ERROR(\n        AddItem(arg_def.name(), {true, arg_index, 0, is_type_list, dtypes}));\n    // Creates dtypes.size() nodes in the graph.\n    for (size_t i = 0; i < dtypes.size(); ++i) {\n      TF_RETURN_IF_ERROR(AddItem(strings::StrCat(arg_def.name(), \":\", i),\n                                 {true, arg_index, 0, false, {dtypes[i]}}));\n      DCHECK_EQ(arg_index, result_.nodes.size());\n      string name = arg_def.name();\n      if (dtypes.size() > 1) {\n        strings::StrAppend(&name, \"_\", i);\n      }\n      NodeDef* gnode = AddNode(name);\n      if (ints_on_device && dtypes[i] == DataType::DT_INT32) {\n        gnode->set_op(FunctionLibraryDefinition::kDeviceArgOp);\n      } else {\n        gnode->set_op(FunctionLibraryDefinition::kArgOp);\n      }\n      DataType dtype = arg_def.is_ref() ? MakeRefType(dtypes[i]) : dtypes[i];\n      AddAttr(\"T\", dtype, gnode);\n      AddAttr(\"index\", arg_index, gnode);\n      if (resource_arg_unique_id >= 0) {\n        AddAttr(\"_resource_arg_unique_id\", resource_arg_unique_id, gnode);\n      }\n      if (arg_attrs) {\n        for (const auto& arg_attr : arg_attrs->attr()) {\n          AddAttr(arg_attr.first, arg_attr.second, gnode->mutable_attr());\n        }\n      }\n      result_.arg_types.push_back(dtypes[i]);\n      ++arg_index;\n    }\n    return Status::OK();\n  }", "target": 1, "idx": 10476}
{"commit_id": "bd87b8892c260753af5672b6f865684036f157dc", "project": "signalwire/freeswitch", "func": "void sofia_handle_sip_i_reinvite(switch_core_session_t *session,\n\t\t\t\t\t\t\t\t nua_t *nua, sofia_profile_t *profile, nua_handle_t *nh, sofia_private_t *sofia_private, sip_t const *sip,\n\t\t\t\t\t\t\t\tsofia_dispatch_event_t *de,\n\t\t\t\t\t\t\t\t tagi_t tags[])\n{\n\tchar *call_info = NULL;\n\tswitch_channel_t *channel = NULL;\n\tprivate_object_t *tech_pvt = NULL;\n\n\tnua_respond(nh, SIP_100_TRYING, TAG_END());\n\n\tif (session) {\n\t\tchannel = switch_core_session_get_channel(session);\n\t\ttech_pvt = switch_core_session_get_private(session);\n\n\n\t\tif (sip && sip->sip_payload && sip->sip_payload->pl_data) {\n\t\t\ttech_pvt->mparams.last_sdp_str = switch_core_session_strdup(session, sip->sip_payload->pl_data);\n\t\t}\n\t}\n\n\tif (session && profile && sip && sofia_test_pflag(profile, PFLAG_TRACK_CALLS)) {\n\t\tswitch_channel_t *channel = switch_core_session_get_channel(session);\n\t\tprivate_object_t *tech_pvt = (private_object_t *) switch_core_session_get_private(session);\n\t\tchar network_ip[80] = \"\";\n\t\tint network_port = 0;\n\t\tchar via_space[2048];\n\t\tchar branch[16] = \"\";\n\n\t\tsofia_glue_store_session_id(session, profile, sip, 0);\n\n\t\tsofia_clear_flag(tech_pvt, TFLAG_GOT_ACK);\n\n\t\tsofia_glue_get_addr(de->data->e_msg, network_ip, sizeof(network_ip), &network_port);\n\t\tswitch_stun_random_string(branch, sizeof(branch) - 1, \"0123456789abcdef\");\n\n\t\tswitch_snprintf(via_space, sizeof(via_space), \"SIP/2.0/UDP %s;rport=%d;branch=%s\", network_ip, network_port, branch);\n\t\tswitch_channel_set_variable(channel, \"sip_full_via\", via_space);\n\t\tswitch_channel_set_variable_printf(channel, \"sip_network_port\", \"%d\", network_port);\n\t\tswitch_channel_set_variable_printf(channel, \"sip_recieved_port\", \"%d\", network_port);\n\t\tswitch_channel_set_variable_printf(channel, \"sip_via_rport\", \"%d\", network_port);\n\n\t\tswitch_core_recovery_track(session);\n\t}\n\n\tif (profile && sofia_test_pflag(profile, PFLAG_MANAGE_SHARED_APPEARANCE)) {\n\t\tif (channel && sip && sip->sip_call_info) {\n\t\t\tchar *p;\n\t\t\tif ((call_info = sip_header_as_string(nua_handle_home(nh), (void *) sip->sip_call_info))) {\n\t\t\t\tif (switch_stristr(\"appearance\", call_info)) {\n\t\t\t\t\tswitch_channel_set_variable(channel, \"presence_call_info_full\", call_info);\n\t\t\t\t\tif ((p = strchr(call_info, ';'))) {\n\t\t\t\t\t\tswitch_channel_set_variable(channel, \"presence_call_info\", p + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsu_free(nua_handle_home(nh), call_info);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (channel) {\n\t\tif (tech_pvt->mparams.last_sdp_str) {\n\t\t\ttech_pvt->mparams.prev_sdp_str = tech_pvt->mparams.last_sdp_str;\n\t\t}\n\t\ttech_pvt->mparams.last_sdp_str = NULL;\n\n\t\tif (sip && sip->sip_payload && sip->sip_payload->pl_data) {\n\t\t\tif (!zstr(tech_pvt->mparams.prev_sdp_str) && strcmp(tech_pvt->mparams.prev_sdp_str, sip->sip_payload->pl_data)) {\n\t\t\t\tswitch_channel_set_variable(channel, \"sip_reinvite_sdp\", sip->sip_payload->pl_data);\n\t\t\t\ttech_pvt->mparams.last_sdp_str = switch_core_session_strdup(session, sip->sip_payload->pl_data);\n\t\t\t} else {\n\t\t\t\ttech_pvt->mparams.last_sdp_str = tech_pvt->mparams.prev_sdp_str;\n\t\t\t}\n\t\t}\n\n\t\tswitch_channel_execute_on(channel, \"execute_on_sip_reinvite\");\n\t}\n\n}", "target": 2, "idx": 10477}
{"commit_id": "565ac66ec0c187ffb442226487de3db376702958", "project": "liblouis", "func": "void EXPORT_CALL\nlou_logFile(const char *fileName) {\n\tif (logFile) {\n\t\tfclose(logFile);\n\t\tlogFile = NULL;\n\t}\n\tif (fileName == NULL || fileName[0] == 0 || strlen(fileName) >= 256) return;\n\tif (initialLogFileName[0] == 0) strcpy(initialLogFileName, fileName);\n\tlogFile = fopen(fileName, \"a\");\n\tif (logFile == NULL && initialLogFileName[0] != 0)\n\t\tlogFile = fopen(initialLogFileName, \"a\");\n\tif (logFile == NULL) {\n\t\tfprintf(stderr, \"Cannot open log file %s\\n\", fileName);\n\t\tlogFile = stderr;\n\t}\n}", "target": 2, "idx": 10478}
{"commit_id": "3ebba796fa251d042be42b929a2d916ee5c34a49", "project": "torvalds/linux", "func": "static int io_register_enable_rings(struct io_ring_ctx *ctx)\n{\n\tif (!(ctx->flags & IORING_SETUP_R_DISABLED))\n\t\treturn -EBADFD;\n\n\tif (ctx->restrictions.registered)\n\t\tctx->restricted = 1;\n\n\tio_sq_offload_start(ctx);\n\treturn 0;\n}", "target": 1, "idx": 10479}
{"commit_id": "d2390e54c4f1ab5c33a0e35e7b9264b36284fa91", "project": "sass/libsass", "func": "Expression* Eval::operator()(Binary_Expression* b_in)\n  {\n\n    Expression_Obj lhs = b_in->left();\n    Expression_Obj rhs = b_in->right();\n    enum Sass_OP op_type = b_in->optype();\n\n    if (op_type == Sass_OP::AND) {\n      // LOCAL_FLAG(force, true);\n      lhs = lhs->perform(this);\n      if (!*lhs) return lhs.detach();\n      return rhs->perform(this);\n    }\n    else if (op_type == Sass_OP::OR) {\n      // LOCAL_FLAG(force, true);\n      lhs = lhs->perform(this);\n      if (*lhs) return lhs.detach();\n      return rhs->perform(this);\n    }\n\n    // Evaluate variables as early o\n    while (Variable* l_v = Cast<Variable>(lhs)) {\n      lhs = operator()(l_v);\n    }\n    while (Variable* r_v = Cast<Variable>(rhs)) {\n      rhs = operator()(r_v);\n    }\n\n    Binary_Expression_Obj b = b_in;\n\n    // Evaluate sub-expressions early on\n    while (Binary_Expression* l_b = Cast<Binary_Expression>(lhs)) {\n      if (!force && l_b->is_delayed()) break;\n      lhs = operator()(l_b);\n    }\n    while (Binary_Expression* r_b = Cast<Binary_Expression>(rhs)) {\n      if (!force && r_b->is_delayed()) break;\n      rhs = operator()(r_b);\n    }\n\n    // don't eval delayed expressions (the '/' when used as a separator)\n    if (!force && op_type == Sass_OP::DIV && b->is_delayed()) {\n      b->right(b->right()->perform(this));\n      b->left(b->left()->perform(this));\n      return b.detach();\n    }\n\n    // specific types we know are final\n    // handle them early to avoid overhead\n    if (Number* l_n = Cast<Number>(lhs)) {\n      // lhs is number and rhs is number\n      if (Number* r_n = Cast<Number>(rhs)) {\n        try {\n          switch (op_type) {\n            case Sass_OP::EQ: return *l_n == *r_n ? bool_true : bool_false;\n            case Sass_OP::NEQ: return *l_n == *r_n ? bool_false : bool_true;\n            case Sass_OP::LT: return *l_n < *r_n ? bool_true : bool_false;\n            case Sass_OP::GTE: return *l_n < *r_n ? bool_false : bool_true;\n            case Sass_OP::LTE: return *l_n < *r_n || *l_n == *r_n ? bool_true : bool_false;\n            case Sass_OP::GT: return *l_n < *r_n || *l_n == *r_n ? bool_false : bool_true;\n            case Sass_OP::ADD: case Sass_OP::SUB: case Sass_OP::MUL: case Sass_OP::DIV: case Sass_OP::MOD:\n              return Operators::op_numbers(op_type, *l_n, *r_n, options(), b_in->pstate());\n            default: break;\n          }\n        }\n        catch (Exception::OperationError& err)\n        {\n          traces.push_back(Backtrace(b_in->pstate()));\n          throw Exception::SassValueError(traces, b_in->pstate(), err);\n        }\n      }\n      // lhs is number and rhs is color\n      // Todo: allow to work with HSLA colors\n      else if (Color* r_col = Cast<Color>(rhs)) {\n        Color_RGBA_Obj r_c = r_col->toRGBA();\n        try {\n          switch (op_type) {\n            case Sass_OP::EQ: return *l_n == *r_c ? bool_true : bool_false;\n            case Sass_OP::NEQ: return *l_n == *r_c ? bool_false : bool_true;\n            case Sass_OP::ADD: case Sass_OP::SUB: case Sass_OP::MUL: case Sass_OP::DIV: case Sass_OP::MOD:\n              return Operators::op_number_color(op_type, *l_n, *r_c, options(), b_in->pstate());\n            default: break;\n          }\n        }\n        catch (Exception::OperationError& err)\n        {\n          traces.push_back(Backtrace(b_in->pstate()));\n          throw Exception::SassValueError(traces, b_in->pstate(), err);\n        }\n      }\n    }\n    else if (Color* l_col = Cast<Color>(lhs)) {\n      Color_RGBA_Obj l_c = l_col->toRGBA();\n      // lhs is color and rhs is color\n      if (Color* r_col = Cast<Color>(rhs)) {\n        Color_RGBA_Obj r_c = r_col->toRGBA();\n        try {\n          switch (op_type) {\n            case Sass_OP::EQ: return *l_c == *r_c ? bool_true : bool_false;\n            case Sass_OP::NEQ: return *l_c == *r_c ? bool_false : bool_true;\n            case Sass_OP::LT: return *l_c < *r_c ? bool_true : bool_false;\n            case Sass_OP::GTE: return *l_c < *r_c ? bool_false : bool_true;\n            case Sass_OP::LTE: return *l_c < *r_c || *l_c == *r_c ? bool_true : bool_false;\n            case Sass_OP::GT: return *l_c < *r_c || *l_c == *r_c ? bool_false : bool_true;\n            case Sass_OP::ADD: case Sass_OP::SUB: case Sass_OP::MUL: case Sass_OP::DIV: case Sass_OP::MOD:\n              return Operators::op_colors(op_type, *l_c, *r_c, options(), b_in->pstate());\n            default: break;\n          }\n        }\n        catch (Exception::OperationError& err)\n        {\n          traces.push_back(Backtrace(b_in->pstate()));\n          throw Exception::SassValueError(traces, b_in->pstate(), err);\n        }\n      }\n      // lhs is color and rhs is number\n      else if (Number* r_n = Cast<Number>(rhs)) {\n        try {\n          switch (op_type) {\n            case Sass_OP::EQ: return *l_c == *r_n ? bool_true : bool_false;\n            case Sass_OP::NEQ: return *l_c == *r_n ? bool_false : bool_true;\n            case Sass_OP::ADD: case Sass_OP::SUB: case Sass_OP::MUL: case Sass_OP::DIV: case Sass_OP::MOD:\n              return Operators::op_color_number(op_type, *l_c, *r_n, options(), b_in->pstate());\n            default: break;\n          }\n        }\n        catch (Exception::OperationError& err)\n        {\n          traces.push_back(Backtrace(b_in->pstate()));\n          throw Exception::SassValueError(traces, b_in->pstate(), err);\n        }\n      }\n    }\n\n    String_Schema_Obj ret_schema;\n\n    // only the last item will be used to eval the binary expression\n    if (String_Schema* s_l = Cast<String_Schema>(b->left())) {\n      if (!s_l->has_interpolant() && (!s_l->is_right_interpolant())) {\n        ret_schema = SASS_MEMORY_NEW(String_Schema, b->pstate());\n        Binary_Expression_Obj bin_ex = SASS_MEMORY_NEW(Binary_Expression, b->pstate(),\n                                                    b->op(), s_l->last(), b->right());\n        bin_ex->is_delayed(b->left()->is_delayed() || b->right()->is_delayed()); // unverified\n        for (size_t i = 0; i < s_l->length() - 1; ++i) {\n          ret_schema->append(s_l->at(i)->perform(this));\n        }\n        ret_schema->append(bin_ex->perform(this));\n        return ret_schema->perform(this);\n      }\n    }\n    if (String_Schema* s_r = Cast<String_Schema>(b->right())) {\n\n      if (!s_r->has_interpolant() && (!s_r->is_left_interpolant() || op_type == Sass_OP::DIV)) {\n        ret_schema = SASS_MEMORY_NEW(String_Schema, b->pstate());\n        Binary_Expression_Obj bin_ex = SASS_MEMORY_NEW(Binary_Expression, b->pstate(),\n                                                    b->op(), b->left(), s_r->first());\n        bin_ex->is_delayed(b->left()->is_delayed() || b->right()->is_delayed()); // verified\n        ret_schema->append(bin_ex->perform(this));\n        for (size_t i = 1; i < s_r->length(); ++i) {\n          ret_schema->append(s_r->at(i)->perform(this));\n        }\n        return ret_schema->perform(this);\n      }\n    }\n\n    // fully evaluate their values\n    if (op_type == Sass_OP::EQ ||\n        op_type == Sass_OP::NEQ ||\n        op_type == Sass_OP::GT ||\n        op_type == Sass_OP::GTE ||\n        op_type == Sass_OP::LT ||\n        op_type == Sass_OP::LTE)\n    {\n      LOCAL_FLAG(force, true);\n      lhs->is_expanded(false);\n      lhs->set_delayed(false);\n      lhs = lhs->perform(this);\n      rhs->is_expanded(false);\n      rhs->set_delayed(false);\n      rhs = rhs->perform(this);\n    }\n    else {\n      lhs = lhs->perform(this);\n    }\n\n    // not a logical connective, so go ahead and eval the rhs\n    rhs = rhs->perform(this);\n    AST_Node_Obj lu = lhs;\n    AST_Node_Obj ru = rhs;\n\n    Expression::Type l_type;\n    Expression::Type r_type;\n\n    // Is one of the operands an interpolant?\n    String_Schema_Obj s1 = Cast<String_Schema>(b->left());\n    String_Schema_Obj s2 = Cast<String_Schema>(b->right());\n    Binary_Expression_Obj b1 = Cast<Binary_Expression>(b->left());\n    Binary_Expression_Obj b2 = Cast<Binary_Expression>(b->right());\n\n    bool schema_op = false;\n\n    bool force_delay = (s2 && s2->is_left_interpolant()) ||\n                       (s1 && s1->is_right_interpolant()) ||\n                       (b1 && b1->is_right_interpolant()) ||\n                       (b2 && b2->is_left_interpolant());\n\n    if ((s1 && s1->has_interpolants()) || (s2 && s2->has_interpolants()) || force_delay)\n    {\n      if (op_type == Sass_OP::DIV || op_type == Sass_OP::MUL || op_type == Sass_OP::MOD || op_type == Sass_OP::ADD || op_type == Sass_OP::SUB ||\n          op_type == Sass_OP::EQ) {\n        // If possible upgrade LHS to a number (for number to string compare)\n        if (String_Constant* str = Cast<String_Constant>(lhs)) {\n          std::string value(str->value());\n          const char* start = value.c_str();\n          if (Prelexer::sequence < Prelexer::dimension, Prelexer::end_of_file >(start) != 0) {\n            lhs = Parser::lexed_dimension(b->pstate(), str->value());\n          }\n        }\n        // If possible upgrade RHS to a number (for string to number compare)\n        if (String_Constant* str = Cast<String_Constant>(rhs)) {\n          std::string value(str->value());\n          const char* start = value.c_str();\n          if (Prelexer::sequence < Prelexer::dimension, Prelexer::number >(start) != 0) {\n            rhs = Parser::lexed_dimension(b->pstate(), str->value());\n          }\n        }\n      }\n\n      To_Value to_value(ctx);\n      Value_Obj v_l = Cast<Value>(lhs->perform(&to_value));\n      Value_Obj v_r = Cast<Value>(rhs->perform(&to_value));\n\n      if (force_delay) {\n        std::string str(\"\");\n        str += v_l->to_string(options());\n        if (b->op().ws_before) str += \" \";\n        str += b->separator();\n        if (b->op().ws_after) str += \" \";\n        str += v_r->to_string(options());\n        String_Constant* val = SASS_MEMORY_NEW(String_Constant, b->pstate(), str);\n        val->is_interpolant(b->left()->has_interpolant());\n        return val;\n      }\n    }\n\n    // see if it's a relational expression\n    try {\n      switch(op_type) {\n        case Sass_OP::EQ:  return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::eq(lhs, rhs));\n        case Sass_OP::NEQ: return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::neq(lhs, rhs));\n        case Sass_OP::GT:  return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::gt(lhs, rhs));\n        case Sass_OP::GTE: return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::gte(lhs, rhs));\n        case Sass_OP::LT:  return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::lt(lhs, rhs));\n        case Sass_OP::LTE: return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::lte(lhs, rhs));\n        default: break;\n      }\n    }\n    catch (Exception::OperationError& err)\n    {\n      traces.push_back(Backtrace(b->pstate()));\n      throw Exception::SassValueError(traces, b->pstate(), err);\n    }\n\n    l_type = lhs->concrete_type();\n    r_type = rhs->concrete_type();\n\n    // ToDo: throw error in op functions\n    // ToDo: then catch and re-throw them\n    Expression_Obj rv;\n    try {\n      ParserState pstate(b->pstate());\n      if (l_type == Expression::NUMBER && r_type == Expression::NUMBER) {\n        Number* l_n = Cast<Number>(lhs);\n        Number* r_n = Cast<Number>(rhs);\n        l_n->reduce(); r_n->reduce();\n        rv = Operators::op_numbers(op_type, *l_n, *r_n, options(), pstate);\n      }\n      else if (l_type == Expression::NUMBER && r_type == Expression::COLOR) {\n        Number* l_n = Cast<Number>(lhs);\n        Color_RGBA_Obj r_c = Cast<Color>(rhs)->toRGBA();\n        rv = Operators::op_number_color(op_type, *l_n, *r_c, options(), pstate);\n      }\n      else if (l_type == Expression::COLOR && r_type == Expression::NUMBER) {\n        Color_RGBA_Obj l_c = Cast<Color>(lhs)->toRGBA();\n        Number* r_n = Cast<Number>(rhs);\n        rv = Operators::op_color_number(op_type, *l_c, *r_n, options(), pstate);\n      }\n      else if (l_type == Expression::COLOR && r_type == Expression::COLOR) {\n        Color_RGBA_Obj l_c = Cast<Color>(lhs)->toRGBA();\n        Color_RGBA_Obj r_c = Cast<Color>(rhs)->toRGBA();\n        rv = Operators::op_colors(op_type, *l_c, *r_c, options(), pstate);\n      }\n      else {\n        To_Value to_value(ctx);\n        // this will leak if perform does not return a value!\n        Value_Obj v_l = Cast<Value>(lhs->perform(&to_value));\n        Value_Obj v_r = Cast<Value>(rhs->perform(&to_value));\n        bool interpolant = b->is_right_interpolant() ||\n                           b->is_left_interpolant() ||\n                           b->is_interpolant();\n        if (op_type == Sass_OP::SUB) interpolant = false;\n        // if (op_type == Sass_OP::DIV) interpolant = true;\n        // check for type violations\n        if (l_type == Expression::MAP || l_type == Expression::FUNCTION_VAL) {\n          traces.push_back(Backtrace(v_l->pstate()));\n          throw Exception::InvalidValue(traces, *v_l);\n        }\n        if (r_type == Expression::MAP || l_type == Expression::FUNCTION_VAL) {\n          traces.push_back(Backtrace(v_r->pstate()));\n          throw Exception::InvalidValue(traces, *v_r);\n        }\n        Value* ex = Operators::op_strings(b->op(), *v_l, *v_r, options(), pstate, !interpolant); // pass true to compress\n        if (String_Constant* str = Cast<String_Constant>(ex))\n        {\n          if (str->concrete_type() == Expression::STRING)\n          {\n            String_Constant* lstr = Cast<String_Constant>(lhs);\n            String_Constant* rstr = Cast<String_Constant>(rhs);\n            if (op_type != Sass_OP::SUB) {\n              if (String_Constant* org = lstr ? lstr : rstr)\n              { str->quote_mark(org->quote_mark()); }\n            }\n          }\n        }\n        ex->is_interpolant(b->is_interpolant());\n        rv = ex;\n      }\n    }\n    catch (Exception::OperationError& err)\n    {\n      traces.push_back(Backtrace(b->pstate()));\n      // throw Exception::Base(b->pstate(), err.what());\n      throw Exception::SassValueError(traces, b->pstate(), err);\n    }\n\n    if (rv) {\n      if (schema_op) {\n        // XXX: this is never hit via spec tests\n        (*s2)[0] = rv;\n        rv = s2->perform(this);\n      }\n    }\n\n    return rv.detach();\n\n  }", "target": 1, "idx": 10480}
{"commit_id": "23985bac83fd50c8e29431009302b5442f985096", "project": "openssl", "func": "int ossl_ffc_validate_public_key_partial(const FFC_PARAMS *params,\n                                         const BIGNUM *pub_key, int *ret)\n{\n    int ok = 0;\n    BIGNUM *tmp = NULL;\n    BN_CTX *ctx = NULL;\n\n    *ret = 0;\n    if (params == NULL || pub_key == NULL || params->p == NULL) {\n        *ret = FFC_ERROR_PASSED_NULL_PARAM;\n        return 0;\n    }\n\n    ctx = BN_CTX_new_ex(NULL);\n    if (ctx == NULL)\n        goto err;\n\n    BN_CTX_start(ctx);\n    tmp = BN_CTX_get(ctx);\n    /* Step(1): Verify pub_key >= 2 */\n    if (tmp == NULL\n        || !BN_set_word(tmp, 1))\n        goto err;\n    if (BN_cmp(pub_key, tmp) <= 0) {\n        *ret |= FFC_ERROR_PUBKEY_TOO_SMALL;\n        goto err;\n    }\n    /* Step(1): Verify pub_key <=  p-2 */\n    if (BN_copy(tmp, params->p) == NULL\n        || !BN_sub_word(tmp, 1))\n        goto err;\n    if (BN_cmp(pub_key, tmp) >= 0) {\n        *ret |= FFC_ERROR_PUBKEY_TOO_LARGE;\n        goto err;\n    }\n    ok = 1;\n err:\n    if (ctx != NULL) {\n        BN_CTX_end(ctx);\n        BN_CTX_free(ctx);\n    }\n    return ok;\n}", "target": 2, "idx": 10481}
{"commit_id": "5a15b72a270b514cd442872221a788a303bdaa88", "project": "chromium", "func": "LoadWatcher(content::RenderFrame* frame,\n              const base::Callback<void(bool)>& callback)\n      : content::RenderFrameObserver(frame), callback_(callback) {}", "target": 3, "idx": 10482}
{"commit_id": "d523a41aed4e321d4c8197b5cccb73be23c8dcc2", "project": "chromium", "func": "void SearchBoxExtensionWrapper::NavigateContentWindow(\n    const v8::FunctionCallbackInfo<v8::Value>& args) {\n  content::RenderView* render_view = GetRenderView();\n  if (!render_view) return;\n\n  if (!args.Length()) {\n    ThrowInvalidParameters(args);\n    return;\n  }\n\n  GURL destination_url;\n  bool is_most_visited_item_url = false;\n  // Check if the url is a rid\n  if (args[0]->IsNumber()) {\n    InstantMostVisitedItem item;\n    if (SearchBox::Get(render_view)->GetMostVisitedItemWithID(\n            args[0]->IntegerValue(), &item)) {\n      destination_url = item.url;\n      is_most_visited_item_url = true;\n    }\n  } else {\n    // Resolve the URL\n    const base::string16& possibly_relative_url = V8ValueToUTF16(args[0]);\n  GURL current_url = GetCurrentURL(render_view);\n    destination_url = internal::ResolveURL(current_url, possibly_relative_url);\n  }\n\n  DVLOG(1) << render_view << \" NavigateContentWindow: \" << destination_url;\n\n  // Navigate the main frame. Note that the security checks are enforced by the\n  // browser process in InstantService::IsValidURLForNavigation(), but some\n  // simple checks here are useful for avoiding unnecessary IPCs.\n  if (destination_url.is_valid() &&\n      !destination_url.SchemeIs(url::kJavaScriptScheme)) {\n    WindowOpenDisposition disposition = CURRENT_TAB;\n    if (args[1]->IsNumber()) {\n      disposition = (WindowOpenDisposition) args[1]->Uint32Value();\n    }\n    SearchBox::Get(render_view)->NavigateToURL(destination_url, disposition,\n                                               is_most_visited_item_url);\n  }\n}", "target": 1, "idx": 10483}
{"commit_id": "ade71fb544391b2e33e1859645726bfee0d5eaaf", "project": "GNOME/glib", "func": "static void\ng_variant_fill_gvs (GVariantSerialised *serialised,\n                    gpointer            data)\n{\n  GVariant *value = data;\n\n  g_variant_lock (value);\n  g_variant_ensure_size (value);\n  g_variant_unlock (value);\n\n  if (serialised->type_info == NULL)\n    serialised->type_info = value->type_info;\n  g_assert (serialised->type_info == value->type_info);\n\n  if (serialised->size == 0)\n    serialised->size = value->size;\n  g_assert (serialised->size == value->size);\n  serialised->depth = value->depth;\n\n  if (value->state & STATE_SERIALISED)\n    {\n      serialised->ordered_offsets_up_to = value->contents.serialised.ordered_offsets_up_to;\n    }\n  else\n    {\n      serialised->ordered_offsets_up_to = 0;\n    }\n\n  if (serialised->data)\n    /* g_variant_store() is a public API, so it\n     * it will reacquire the lock if it needs to.\n     */\n    g_variant_store (value, serialised->data);\n}", "target": 1, "idx": 10484}
{"commit_id": "d91f0b20e561e326ee91a09a76206257bde8438b", "project": "binutils-gdb", "func": "static bfd_boolean\nprocess_archive_index_and_symbols (struct archive_info *  arch,\n\t\t\t\t   unsigned int           sizeof_ar_index,\n\t\t\t\t   bfd_boolean            read_symbols)\n{\n  size_t got;\n  unsigned long size;\n  char fmag_save;\n\n  fmag_save = arch->arhdr.ar_fmag[0];\n  arch->arhdr.ar_fmag[0] = 0;\n  size = strtoul (arch->arhdr.ar_size, NULL, 10);\n  arch->arhdr.ar_fmag[0] = fmag_save;\n  /* PR 17531: file: 912bd7de.  */\n  if ((signed long) size < 0)\n    {\n      error (_(\"%s: invalid archive header size: %ld\\n\"),\n\t     arch->file_name, size);\n      return FALSE;\n    }\n\n  size = size + (size & 1);\n\n  arch->next_arhdr_offset += sizeof arch->arhdr + size;\n\n  if (! read_symbols)\n    {\n      if (fseek (arch->file, size, SEEK_CUR) != 0)\n\t{\n\t  error (_(\"%s: failed to skip archive symbol table\\n\"),\n\t\t arch->file_name);\n\t  return FALSE;\n\t}\n    }\n  else\n    {\n      unsigned long i;\n      /* A buffer used to hold numbers read in from an archive index.\n\t These are always SIZEOF_AR_INDEX bytes long and stored in\n\t big-endian format.  */\n      unsigned char integer_buffer[sizeof arch->index_num];\n      unsigned char * index_buffer;\n\n      assert (sizeof_ar_index <= sizeof integer_buffer);\n\n      /* Check the size of the archive index.  */\n      if (size < sizeof_ar_index)\n\t{\n\t  error (_(\"%s: the archive index is empty\\n\"), arch->file_name);\n\t  return FALSE;\n\t}\n\n      /* Read the number of entries in the archive index.  */\n      got = fread (integer_buffer, 1, sizeof_ar_index, arch->file);\n      if (got != sizeof_ar_index)\n\t{\n\t  error (_(\"%s: failed to read archive index\\n\"), arch->file_name);\n\t  return FALSE;\n\t}\n\n      arch->index_num = byte_get_big_endian (integer_buffer, sizeof_ar_index);\n      size -= sizeof_ar_index;\n\n      if (size < arch->index_num * sizeof_ar_index\n\t  /* PR 17531: file: 585515d1.  */\n\t  || size < arch->index_num)\n\t{\n\t  error (_(\"%s: the archive index is supposed to have 0x%lx entries of %d bytes, but the size is only 0x%lx\\n\"),\n\t\t arch->file_name, (long) arch->index_num, sizeof_ar_index, size);\n\t  return FALSE;\n\t}\n\n      /* Read in the archive index.  */\n      index_buffer = (unsigned char *)\n\tmalloc (arch->index_num * sizeof_ar_index);\n      if (index_buffer == NULL)\n\t{\n\t  error (_(\"Out of memory whilst trying to read archive symbol index\\n\"));\n\t  return FALSE;\n\t}\n\n      got = fread (index_buffer, sizeof_ar_index, arch->index_num, arch->file);\n      if (got != arch->index_num)\n\t{\n\t  free (index_buffer);\n\t  error (_(\"%s: failed to read archive index\\n\"), arch->file_name);\n\t  return FALSE;\n\t}\n\n      size -= arch->index_num * sizeof_ar_index;\n\n      /* Convert the index numbers into the host's numeric format.  */\n      arch->index_array = (elf_vma *)\n\tmalloc (arch->index_num * sizeof (* arch->index_array));\n      if (arch->index_array == NULL)\n\t{\n\t  free (index_buffer);\n\t  error (_(\"Out of memory whilst trying to convert the archive symbol index\\n\"));\n\t  return FALSE;\n\t}\n\n      for (i = 0; i < arch->index_num; i++)\n\tarch->index_array[i] =\n\t  byte_get_big_endian ((unsigned char *) (index_buffer + (i * sizeof_ar_index)),\n\t\t\t       sizeof_ar_index);\n      free (index_buffer);\n\n      /* The remaining space in the header is taken up by the symbol table.  */\n      if (size < 1)\n\t{\n\t  error (_(\"%s: the archive has an index but no symbols\\n\"),\n\t\t arch->file_name);\n\t  return FALSE;\n\t}\n\n      arch->sym_table = (char *) malloc (size);\n      if (arch->sym_table == NULL)\n\t{\n\t  error (_(\"Out of memory whilst trying to read archive index symbol table\\n\"));\n\t  return FALSE;\n\t}\n\n      arch->sym_size = size;\n      got = fread (arch->sym_table, 1, size, arch->file);\n      if (got != size)\n\t{\n\t  error (_(\"%s: failed to read archive index symbol table\\n\"),\n\t\t arch->file_name);\n\t  return FALSE;\n\t}\n    }\n\n  /* Read the next archive header.  */\n  got = fread (&arch->arhdr, 1, sizeof arch->arhdr, arch->file);\n  if (got != sizeof arch->arhdr && got != 0)\n    {\n      error (_(\"%s: failed to read archive header following archive index\\n\"),\n\t     arch->file_name);\n      return FALSE;\n    }\n\n  return TRUE;\n}", "target": 2, "idx": 10485}
{"commit_id": "3287aa12eb205cff95cdd00d6d6c5c9a4f8f0eca", "project": "abrt", "func": "static int run_post_create(const char *dirname)\n{\n    /* If doesn't start with \"g_settings_dump_location/\"... */\n    if (!dir_is_in_dump_location(dirname))\n    {\n        /* Then refuse to operate on it (someone is attacking us??) */\n        error_msg(\"Bad problem directory name '%s', should start with: '%s'\", dirname, g_settings_dump_location);\n        return 400; /* Bad Request */\n    }\n    if (!dir_has_correct_permissions(dirname))\n    {\n        error_msg(\"Problem directory '%s' isn't owned by root:abrt or others are not restricted from access\", dirname);\n        return 400; /*  */\n    }\n    if (g_settings_privatereports)\n    {\n        struct dump_dir *dd = dd_opendir(dirname, DD_OPEN_READONLY);\n        const bool complete = dd && problem_dump_dir_is_complete(dd);\n        dd_close(dd);\n        if (complete)\n        {\n            error_msg(\"Problem directory '%s' has already been processed\", dirname);\n            return 403;\n        }\n    }\n\n    int child_stdout_fd;\n    int child_pid = spawn_event_handler_child(dirname, \"post-create\", &child_stdout_fd);\n\n    char *dup_of_dir = NULL;\n    struct strbuf *cmd_output = strbuf_new();\n\n    bool child_is_post_create = 1; /* else it is a notify child */\n\n read_child_output:\n    //log(\"Reading from event fd %d\", child_stdout_fd);\n\n    /* Read streamed data and split lines */\n    for (;;)\n    {\n        char buf[250]; /* usually we get one line, no need to have big buf */\n        errno = 0;\n        int r = safe_read(child_stdout_fd, buf, sizeof(buf) - 1);\n        if (r <= 0)\n            break;\n        buf[r] = '\\0';\n\n        /* split lines in the current buffer */\n        char *raw = buf;\n        char *newline;\n        while ((newline = strchr(raw, '\\n')) != NULL)\n        {\n            *newline = '\\0';\n            strbuf_append_str(cmd_output, raw);\n            char *msg = cmd_output->buf;\n\n            /* Hmm, DUP_OF_DIR: ends up in syslog. move log() into 'else'? */\n            log(\"%s\", msg);\n\n            if (child_is_post_create\n             && prefixcmp(msg, \"DUP_OF_DIR: \") == 0\n            ) {\n                free(dup_of_dir);\n                dup_of_dir = xstrdup(msg + strlen(\"DUP_OF_DIR: \"));\n            }\n\n            strbuf_clear(cmd_output);\n            /* jump to next line */\n            raw = newline + 1;\n        }\n\n        /* beginning of next line. the line continues by next read */\n        strbuf_append_str(cmd_output, raw);\n    }\n\n    /* EOF/error */\n\n    /* Wait for child to actually exit, collect status */\n    int status = 0;\n    if (safe_waitpid(child_pid, &status, 0) <= 0)\n    /* should not happen */\n        perror_msg(\"waitpid(%d)\", child_pid);\n\n    /* If it was a \"notify[-dup]\" event, then we're done */\n    if (!child_is_post_create)\n        goto ret;\n\n    /* exit 0 means \"this is a good, non-dup dir\" */\n    /* exit with 1 + \"DUP_OF_DIR: dir\" string => dup */\n    if (status != 0)\n    {\n        if (WIFSIGNALED(status))\n        {\n            log(\"'post-create' on '%s' killed by signal %d\",\n                            dirname, WTERMSIG(status));\n            goto delete_bad_dir;\n        }\n        /* else: it is WIFEXITED(status) */\n        if (!dup_of_dir)\n        {\n            log(\"'post-create' on '%s' exited with %d\",\n                            dirname, WEXITSTATUS(status));\n            goto delete_bad_dir;\n        }\n    }\n\n    const char *work_dir = (dup_of_dir ? dup_of_dir : dirname);\n\n    /* Load problem_data (from the *first dir* if this one is a dup) */\n    struct dump_dir *dd = dd_opendir(work_dir, /*flags:*/ 0);\n    if (!dd)\n        /* dd_opendir already emitted error msg */\n        goto delete_bad_dir;\n\n    /* Update count */\n    char *count_str = dd_load_text_ext(dd, FILENAME_COUNT, DD_FAIL_QUIETLY_ENOENT);\n    unsigned long count = strtoul(count_str, NULL, 10);\n\n    /* Don't increase crash count if we are working with newly uploaded\n     * directory (remote crash) which already has its crash count set.\n     */\n    if ((status != 0 && dup_of_dir) || count == 0)\n    {\n        count++;\n        char new_count_str[sizeof(long)*3 + 2];\n        sprintf(new_count_str, \"%lu\", count);\n        dd_save_text(dd, FILENAME_COUNT, new_count_str);\n\n        /* This condition can be simplified to either\n         * (status * != 0 && * dup_of_dir) or (count == 1). But the\n         * chosen form is much more reliable and safe. We must not call\n         * dd_opendir() to locked dd otherwise we go into a deadlock.\n         */\n        if (strcmp(dd->dd_dirname, dirname) != 0)\n        {\n            /* Update the last occurrence file by the time file of the new problem */\n            struct dump_dir *new_dd = dd_opendir(dirname, DD_OPEN_READONLY);\n            char *last_ocr = NULL;\n            if (new_dd)\n            {\n                /* TIME must exists in a valid dump directory but we don't want to die\n                 * due to broken duplicated dump directory */\n                last_ocr = dd_load_text_ext(new_dd, FILENAME_TIME,\n                            DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE | DD_FAIL_QUIETLY_ENOENT);\n                dd_close(new_dd);\n            }\n            else\n            {   /* dd_opendir() already produced a message with good information about failure */\n                error_msg(\"Can't read the last occurrence file from the new dump directory.\");\n            }\n\n            if (!last_ocr)\n            {   /* the new dump directory may lie in the dump location for some time */\n                log(\"Using current time for the last occurrence file which may be incorrect.\");\n                time_t t = time(NULL);\n                last_ocr = xasprintf(\"%lu\", (long)t);\n            }\n\n            dd_save_text(dd, FILENAME_LAST_OCCURRENCE, last_ocr);\n\n            free(last_ocr);\n        }\n    }\n\n    /* Reset mode/uig/gid to correct values for all files created by event run */\n    dd_sanitize_mode_and_owner(dd);\n\n    dd_close(dd);\n\n    if (!dup_of_dir)\n        log_notice(\"New problem directory %s, processing\", work_dir);\n    else\n    {\n        log_warning(\"Deleting problem directory %s (dup of %s)\",\n                    strrchr(dirname, '/') + 1,\n                    strrchr(dup_of_dir, '/') + 1);\n        delete_dump_dir(dirname);\n    }\n\n    /* Run \"notify[-dup]\" event */\n    int fd;\n    child_pid = spawn_event_handler_child(\n                work_dir,\n                (dup_of_dir ? \"notify-dup\" : \"notify\"),\n                &fd\n    );\n    //log(\"Started notify, fd %d -> %d\", fd, child_stdout_fd);\n    xmove_fd(fd, child_stdout_fd);\n    child_is_post_create = 0;\n    strbuf_clear(cmd_output);\n    free(dup_of_dir);\n    dup_of_dir = NULL;\n    goto read_child_output;\n\n delete_bad_dir:\n    log_warning(\"Deleting problem directory '%s'\", dirname);\n    delete_dump_dir(dirname);\n\n ret:\n    strbuf_free(cmd_output);\n    free(dup_of_dir);\n    close(child_stdout_fd);\n    return 0;\n}", "target": 2, "idx": 10486}
{"commit_id": "826bfe4bbd7594188e3d74d2539d9707b1c6a14b", "project": "vim", "func": "static void\nwin_redr_status(win_T *wp, int ignore_pum UNUSED)\n{\n    int\t\trow;\n    char_u\t*p;\n    int\t\tlen;\n    int\t\tfillchar;\n    int\t\tattr;\n    int\t\tthis_ru_col;\n    static int  busy = FALSE;\n\n    // It's possible to get here recursively when 'statusline' (indirectly)\n    // invokes \":redrawstatus\".  Simply ignore the call then.\n    if (busy)\n\treturn;\n    busy = TRUE;\n\n    row = statusline_row(wp);\n\n    wp->w_redr_status = FALSE;\n    if (wp->w_status_height == 0)\n    {\n\t// no status line, can only be last window\n\tredraw_cmdline = TRUE;\n    }\n    else if (!redrawing()\n\t    // don't update status line when popup menu is visible and may be\n\t    // drawn over it, unless it will be redrawn later\n\t    || (!ignore_pum && pum_visible()))\n    {\n\t// Don't redraw right now, do it later.\n\twp->w_redr_status = TRUE;\n    }\n#ifdef FEAT_STL_OPT\n    else if (*p_stl != NUL || *wp->w_p_stl != NUL)\n    {\n\t// redraw custom status line\n\tredraw_custom_statusline(wp);\n    }\n#endif\n    else\n    {\n\tfillchar = fillchar_status(&attr, wp);\n\n\tget_trans_bufname(wp->w_buffer);\n\tp = NameBuff;\n\tlen = (int)STRLEN(p);\n\n\tif (bt_help(wp->w_buffer)\n#ifdef FEAT_QUICKFIX\n\t\t|| wp->w_p_pvw\n#endif\n\t\t|| bufIsChanged(wp->w_buffer)\n\t\t|| wp->w_buffer->b_p_ro)\n\t    *(p + len++) = ' ';\n\tif (bt_help(wp->w_buffer))\n\t{\n\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", _(\"[Help]\"));\n\t    len += (int)STRLEN(p + len);\n\t}\n#ifdef FEAT_QUICKFIX\n\tif (wp->w_p_pvw)\n\t{\n\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", _(\"[Preview]\"));\n\t    len += (int)STRLEN(p + len);\n\t}\n#endif\n\tif (bufIsChanged(wp->w_buffer)\n#ifdef FEAT_TERMINAL\n\t\t&& !bt_terminal(wp->w_buffer)\n#endif\n\t\t)\n\t{\n\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", \"[+]\");\n\t    len += (int)STRLEN(p + len);\n\t}\n\tif (wp->w_buffer->b_p_ro)\n\t{\n\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", _(\"[RO]\"));\n\t    len += (int)STRLEN(p + len);\n\t}\n\n\tthis_ru_col = ru_col - (Columns - wp->w_width);\n\tif (this_ru_col < (wp->w_width + 1) / 2)\n\t    this_ru_col = (wp->w_width + 1) / 2;\n\tif (this_ru_col <= 1)\n\t{\n\t    p = (char_u *)\"<\";\t\t// No room for file name!\n\t    len = 1;\n\t}\n\telse if (has_mbyte)\n\t{\n\t    int\tclen = 0, i;\n\n\t    // Count total number of display cells.\n\t    clen = mb_string2cells(p, -1);\n\n\t    // Find first character that will fit.\n\t    // Going from start to end is much faster for DBCS.\n\t    for (i = 0; p[i] != NUL && clen >= this_ru_col - 1;\n\t\t    i += (*mb_ptr2len)(p + i))\n\t\tclen -= (*mb_ptr2cells)(p + i);\n\t    len = clen;\n\t    if (i > 0)\n\t    {\n\t\tp = p + i - 1;\n\t\t*p = '<';\n\t\t++len;\n\t    }\n\n\t}\n\telse if (len > this_ru_col - 1)\n\t{\n\t    p += len - (this_ru_col - 1);\n\t    *p = '<';\n\t    len = this_ru_col - 1;\n\t}\n\n\tscreen_puts(p, row, wp->w_wincol, attr);\n\tscreen_fill(row, row + 1, len + wp->w_wincol,\n\t\t\tthis_ru_col + wp->w_wincol, fillchar, fillchar, attr);\n\n\tif (get_keymap_str(wp, (char_u *)\"<%s>\", NameBuff, MAXPATHL)\n\t\t&& (int)(this_ru_col - len) > (int)(STRLEN(NameBuff) + 1))\n\t    screen_puts(NameBuff, row, (int)(this_ru_col - STRLEN(NameBuff)\n\t\t\t\t\t\t   - 1 + wp->w_wincol), attr);\n\n#ifdef FEAT_CMDL_INFO\n\twin_redr_ruler(wp, TRUE, ignore_pum);\n#endif\n    }\n\n    /*\n     * May need to draw the character below the vertical separator.\n     */\n    if (wp->w_vsep_width != 0 && wp->w_status_height != 0 && redrawing())\n    {\n\tif (stl_connected(wp))\n\t    fillchar = fillchar_status(&attr, wp);\n\telse\n\t    fillchar = fillchar_vsep(&attr);\n\tscreen_putchar(fillchar, row, W_ENDCOL(wp), attr);\n    }\n    busy = FALSE;\n}", "target": 2, "idx": 10487}
{"commit_id": "b0f23dbc4d4713f65470272768ef79b7cb47db78", "project": "nginx/njs", "func": "static njs_ret_t\nnjs_array_prototype_unshift(njs_vm_t *vm, njs_value_t *args, nxt_uint_t nargs,\n    njs_index_t unused)\n{\n    njs_ret_t    ret;\n    nxt_uint_t   n;\n    njs_array_t  *array;\n\n    if (njs_is_array(&args[0])) {\n        array = args[0].data.u.array;\n        n = nargs - 1;\n\n        if (n != 0) {\n            ret = njs_array_expand(vm, array, n, 0);\n            if (nxt_slow_path(ret != NXT_OK)) {\n                return ret;\n            }\n\n            array->length += n;\n            n = nargs;\n\n            do {\n                n--;\n                /* GC: njs_retain(&args[n]); */\n                array->start--;\n                array->start[0] = args[n];\n            } while (n > 1);\n        }\n\n        njs_value_number_set(&vm->retval, array->length);\n    }\n\n    return NXT_OK;\n}", "target": 3, "idx": 10488}
{"commit_id": "5d45b69b590cabc5127282d1ade3bca1598e5f5c", "project": "wireshark", "func": "static gint\ndissect_wccp2_alternate_mask_value_set_element(tvbuff_t *tvb, int offset, gint length, guint el_index, packet_info *pinfo,\n                    proto_tree *info_tree, wccp_address_table* addr_table)\n{\n  proto_item *tl, *header;\n  proto_tree *element_tree, *value_tree;\n  guint number_of_elements;\n  gint new_length, total_length;\n  guint i;\n\n  element_tree = proto_tree_add_subtree_format(info_tree, tvb, offset, 0,\n                               ett_alternate_mask_value_set_element, &header,\n                               \"Alternate Mask/Value Set Element(%d)\", el_index);\n\n  total_length = 0;\n\n  new_length=dissect_wccp2_mask_element(tvb,offset,length,pinfo,element_tree);\n  total_length += length - new_length;\n  CHECK_LENGTH_ADVANCE_OFFSET(new_length);\n\n  if (length < 4)\n    return length - 4;\n\n  number_of_elements  = tvb_get_ntohl(tvb, offset);\n  tl = proto_tree_add_uint(element_tree, hf_alt_assignment_mask_value_set_element_num_wc_value_elements, tvb, offset, 4, number_of_elements);\n  value_tree = proto_item_add_subtree(tl, ett_alternate_mv_set_element_list);\n  total_length += 4;\n  EAT(4);\n\n  /* XXX Add a bounds check for number_of_elements? */\n  for (i=0; i < number_of_elements; i++) {\n    new_length=dissect_wccp2_web_cache_value_element(tvb, offset, length, pinfo, value_tree, addr_table);\n    total_length += length - new_length;\n    CHECK_LENGTH_ADVANCE_OFFSET(new_length);\n  }\n  proto_item_set_len(header, total_length);\n\n  return length;\n}", "target": 2, "idx": 10489}
{"commit_id": "04beafa8e6c66f5cd814c00e2d2b51cfbc41cb8a", "project": "xen-project/xen", "func": "static void svm_get_segment_register(struct vcpu *v, enum x86_segment seg,\n                                     struct segment_register *reg)\n{\n    struct vmcb_struct *vmcb = v->arch.hvm_svm.vmcb;\n\n    ASSERT((v == current) || !vcpu_runnable(v));\n\n    switch ( seg )\n    {\n    case x86_seg_cs:\n        memcpy(reg, &vmcb->cs, sizeof(*reg));\n        reg->attr.fields.p = 1;\n        reg->attr.fields.g = reg->limit > 0xFFFFF;\n        break;\n    case x86_seg_ds:\n        memcpy(reg, &vmcb->ds, sizeof(*reg));\n        if ( reg->attr.fields.type != 0 )\n            reg->attr.fields.type |= 0x1;\n        break;\n    case x86_seg_es:\n        memcpy(reg, &vmcb->es, sizeof(*reg));\n        if ( reg->attr.fields.type != 0 )\n            reg->attr.fields.type |= 0x1;\n        break;\n    case x86_seg_fs:\n        svm_sync_vmcb(v);\n        memcpy(reg, &vmcb->fs, sizeof(*reg));\n        if ( reg->attr.fields.type != 0 )\n            reg->attr.fields.type |= 0x1;\n        break;\n    case x86_seg_gs:\n        svm_sync_vmcb(v);\n        memcpy(reg, &vmcb->gs, sizeof(*reg));\n        if ( reg->attr.fields.type != 0 )\n            reg->attr.fields.type |= 0x1;\n        break;\n    case x86_seg_ss:\n        memcpy(reg, &vmcb->ss, sizeof(*reg));\n        reg->attr.fields.dpl = vmcb->_cpl;\n        if ( reg->attr.fields.type == 0 )\n            reg->attr.fields.db = 0;\n        break;\n    case x86_seg_tr:\n        svm_sync_vmcb(v);\n        memcpy(reg, &vmcb->tr, sizeof(*reg));\n        reg->attr.fields.p = 1;\n        reg->attr.fields.type |= 0x2;\n        break;\n    case x86_seg_gdtr:\n        memcpy(reg, &vmcb->gdtr, sizeof(*reg));\n        reg->attr.bytes = 0x80;\n        break;\n    case x86_seg_idtr:\n        memcpy(reg, &vmcb->idtr, sizeof(*reg));\n        reg->attr.bytes = 0x80;\n        break;\n    case x86_seg_ldtr:\n        svm_sync_vmcb(v);\n        memcpy(reg, &vmcb->ldtr, sizeof(*reg));\n        break;\n    default:\n        BUG();\n    }\n}", "target": 2, "idx": 10490}
{"commit_id": "017c73a34a661a861712f7cc1393a123e5b2208c", "project": "torvalds/linux", "func": "int ubi_attach_mtd_dev(struct mtd_info *mtd, int ubi_num,\n\t\t       int vid_hdr_offset, int max_beb_per1024, bool disable_fm)\n{\n\tstruct ubi_device *ubi;\n\tint i, err;\n\n\tif (max_beb_per1024 < 0 || max_beb_per1024 > MAX_MTD_UBI_BEB_LIMIT)\n\t\treturn -EINVAL;\n\n\tif (!max_beb_per1024)\n\t\tmax_beb_per1024 = CONFIG_MTD_UBI_BEB_LIMIT;\n\n\t/*\n\t * Check if we already have the same MTD device attached.\n\t *\n\t * Note, this function assumes that UBI devices creations and deletions\n\t * are serialized, so it does not take the &ubi_devices_lock.\n\t */\n\tfor (i = 0; i < UBI_MAX_DEVICES; i++) {\n\t\tubi = ubi_devices[i];\n\t\tif (ubi && mtd->index == ubi->mtd->index) {\n\t\t\tpr_err(\"ubi: mtd%d is already attached to ubi%d\\n\",\n\t\t\t\tmtd->index, i);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\t/*\n\t * Make sure this MTD device is not emulated on top of an UBI volume\n\t * already. Well, generally this recursion works fine, but there are\n\t * different problems like the UBI module takes a reference to itself\n\t * by attaching (and thus, opening) the emulated MTD device. This\n\t * results in inability to unload the module. And in general it makes\n\t * no sense to attach emulated MTD devices, so we prohibit this.\n\t */\n\tif (mtd->type == MTD_UBIVOLUME) {\n\t\tpr_err(\"ubi: refuse attaching mtd%d - it is already emulated on top of UBI\\n\",\n\t\t\tmtd->index);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Both UBI and UBIFS have been designed for SLC NAND and NOR flashes.\n\t * MLC NAND is different and needs special care, otherwise UBI or UBIFS\n\t * will die soon and you will lose all your data.\n\t * Relax this rule if the partition we're attaching to operates in SLC\n\t * mode.\n\t */\n\tif (mtd->type == MTD_MLCNANDFLASH &&\n\t    !(mtd->flags & MTD_SLC_ON_MLC_EMULATION)) {\n\t\tpr_err(\"ubi: refuse attaching mtd%d - MLC NAND is not supported\\n\",\n\t\t\tmtd->index);\n\t\treturn -EINVAL;\n\t}\n\n\t/* UBI cannot work on flashes with zero erasesize. */\n\tif (!mtd->erasesize) {\n\t\tpr_err(\"ubi: refuse attaching mtd%d - zero erasesize flash is not supported\\n\",\n\t\t\tmtd->index);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ubi_num == UBI_DEV_NUM_AUTO) {\n\t\t/* Search for an empty slot in the @ubi_devices array */\n\t\tfor (ubi_num = 0; ubi_num < UBI_MAX_DEVICES; ubi_num++)\n\t\t\tif (!ubi_devices[ubi_num])\n\t\t\t\tbreak;\n\t\tif (ubi_num == UBI_MAX_DEVICES) {\n\t\t\tpr_err(\"ubi: only %d UBI devices may be created\\n\",\n\t\t\t\tUBI_MAX_DEVICES);\n\t\t\treturn -ENFILE;\n\t\t}\n\t} else {\n\t\tif (ubi_num >= UBI_MAX_DEVICES)\n\t\t\treturn -EINVAL;\n\n\t\t/* Make sure ubi_num is not busy */\n\t\tif (ubi_devices[ubi_num]) {\n\t\t\tpr_err(\"ubi: ubi%i already exists\\n\", ubi_num);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\tubi = kzalloc(sizeof(struct ubi_device), GFP_KERNEL);\n\tif (!ubi)\n\t\treturn -ENOMEM;\n\n\tdevice_initialize(&ubi->dev);\n\tubi->dev.release = dev_release;\n\tubi->dev.class = &ubi_class;\n\tubi->dev.groups = ubi_dev_groups;\n\tubi->dev.parent = &mtd->dev;\n\n\tubi->mtd = mtd;\n\tubi->ubi_num = ubi_num;\n\tubi->vid_hdr_offset = vid_hdr_offset;\n\tubi->autoresize_vol_id = -1;\n\n#ifdef CONFIG_MTD_UBI_FASTMAP\n\tubi->fm_pool.used = ubi->fm_pool.size = 0;\n\tubi->fm_wl_pool.used = ubi->fm_wl_pool.size = 0;\n\n\t/*\n\t * fm_pool.max_size is 5% of the total number of PEBs but it's also\n\t * between UBI_FM_MAX_POOL_SIZE and UBI_FM_MIN_POOL_SIZE.\n\t */\n\tubi->fm_pool.max_size = min(((int)mtd_div_by_eb(ubi->mtd->size,\n\t\tubi->mtd) / 100) * 5, UBI_FM_MAX_POOL_SIZE);\n\tubi->fm_pool.max_size = max(ubi->fm_pool.max_size,\n\t\tUBI_FM_MIN_POOL_SIZE);\n\n\tubi->fm_wl_pool.max_size = ubi->fm_pool.max_size / 2;\n\tubi->fm_disabled = (!fm_autoconvert || disable_fm) ? 1 : 0;\n\tif (fm_debug)\n\t\tubi_enable_dbg_chk_fastmap(ubi);\n\n\tif (!ubi->fm_disabled && (int)mtd_div_by_eb(ubi->mtd->size, ubi->mtd)\n\t    <= UBI_FM_MAX_START) {\n\t\tubi_err(ubi, \"More than %i PEBs are needed for fastmap, sorry.\",\n\t\t\tUBI_FM_MAX_START);\n\t\tubi->fm_disabled = 1;\n\t}\n\n\tubi_msg(ubi, \"default fastmap pool size: %d\", ubi->fm_pool.max_size);\n\tubi_msg(ubi, \"default fastmap WL pool size: %d\",\n\t\tubi->fm_wl_pool.max_size);\n#else\n\tubi->fm_disabled = 1;\n#endif\n\tmutex_init(&ubi->buf_mutex);\n\tmutex_init(&ubi->ckvol_mutex);\n\tmutex_init(&ubi->device_mutex);\n\tspin_lock_init(&ubi->volumes_lock);\n\tinit_rwsem(&ubi->fm_protect);\n\tinit_rwsem(&ubi->fm_eba_sem);\n\n\tubi_msg(ubi, \"attaching mtd%d\", mtd->index);\n\n\terr = io_init(ubi, max_beb_per1024);\n\tif (err)\n\t\tgoto out_free;\n\n\terr = -ENOMEM;\n\tubi->peb_buf = vmalloc(ubi->peb_size);\n\tif (!ubi->peb_buf)\n\t\tgoto out_free;\n\n#ifdef CONFIG_MTD_UBI_FASTMAP\n\tubi->fm_size = ubi_calc_fm_size(ubi);\n\tubi->fm_buf = vzalloc(ubi->fm_size);\n\tif (!ubi->fm_buf)\n\t\tgoto out_free;\n#endif\n\terr = ubi_attach(ubi, disable_fm ? 1 : 0);\n\tif (err) {\n\t\tubi_err(ubi, \"failed to attach mtd%d, error %d\",\n\t\t\tmtd->index, err);\n\t\tgoto out_free;\n\t}\n\n\tif (ubi->autoresize_vol_id != -1) {\n\t\terr = autoresize(ubi, ubi->autoresize_vol_id);\n\t\tif (err)\n\t\t\tgoto out_detach;\n\t}\n\n\terr = uif_init(ubi);\n\tif (err)\n\t\tgoto out_detach;\n\n\terr = ubi_debugfs_init_dev(ubi);\n\tif (err)\n\t\tgoto out_uif;\n\n\tubi->bgt_thread = kthread_create(ubi_thread, ubi, \"%s\", ubi->bgt_name);\n\tif (IS_ERR(ubi->bgt_thread)) {\n\t\terr = PTR_ERR(ubi->bgt_thread);\n\t\tubi_err(ubi, \"cannot spawn \\\"%s\\\", error %d\",\n\t\t\tubi->bgt_name, err);\n\t\tgoto out_debugfs;\n\t}\n\n\tubi_msg(ubi, \"attached mtd%d (name \\\"%s\\\", size %llu MiB)\",\n\t\tmtd->index, mtd->name, ubi->flash_size >> 20);\n\tubi_msg(ubi, \"PEB size: %d bytes (%d KiB), LEB size: %d bytes\",\n\t\tubi->peb_size, ubi->peb_size >> 10, ubi->leb_size);\n\tubi_msg(ubi, \"min./max. I/O unit sizes: %d/%d, sub-page size %d\",\n\t\tubi->min_io_size, ubi->max_write_size, ubi->hdrs_min_io_size);\n\tubi_msg(ubi, \"VID header offset: %d (aligned %d), data offset: %d\",\n\t\tubi->vid_hdr_offset, ubi->vid_hdr_aloffset, ubi->leb_start);\n\tubi_msg(ubi, \"good PEBs: %d, bad PEBs: %d, corrupted PEBs: %d\",\n\t\tubi->good_peb_count, ubi->bad_peb_count, ubi->corr_peb_count);\n\tubi_msg(ubi, \"user volume: %d, internal volumes: %d, max. volumes count: %d\",\n\t\tubi->vol_count - UBI_INT_VOL_COUNT, UBI_INT_VOL_COUNT,\n\t\tubi->vtbl_slots);\n\tubi_msg(ubi, \"max/mean erase counter: %d/%d, WL threshold: %d, image sequence number: %u\",\n\t\tubi->max_ec, ubi->mean_ec, CONFIG_MTD_UBI_WL_THRESHOLD,\n\t\tubi->image_seq);\n\tubi_msg(ubi, \"available PEBs: %d, total reserved PEBs: %d, PEBs reserved for bad PEB handling: %d\",\n\t\tubi->avail_pebs, ubi->rsvd_pebs, ubi->beb_rsvd_pebs);\n\n\t/*\n\t * The below lock makes sure we do not race with 'ubi_thread()' which\n\t * checks @ubi->thread_enabled. Otherwise we may fail to wake it up.\n\t */\n\tspin_lock(&ubi->wl_lock);\n\tubi->thread_enabled = 1;\n\twake_up_process(ubi->bgt_thread);\n\tspin_unlock(&ubi->wl_lock);\n\n\tubi_devices[ubi_num] = ubi;\n\tubi_notify_all(ubi, UBI_VOLUME_ADDED, NULL);\n\treturn ubi_num;\n\nout_debugfs:\n\tubi_debugfs_exit_dev(ubi);\nout_uif:\n\tuif_close(ubi);\nout_detach:\n\tubi_wl_close(ubi);\n\tubi_free_all_volumes(ubi);\n\tvfree(ubi->vtbl);\nout_free:\n\tvfree(ubi->peb_buf);\n\tvfree(ubi->fm_buf);\n\tput_device(&ubi->dev);\n\treturn err;\n}", "target": 1, "idx": 10491}
{"commit_id": "b45cb1b665a14b0175b9cb1502ef7168e1fe0d5d", "project": "jsummers/imageworsener", "func": "static int get_exif_tag_dbl_value(struct iw_exif_state *e, unsigned int tag_pos,\n\tdouble *pv)\n{\n\tunsigned int field_type;\n\tunsigned int value_count;\n\tunsigned int value_pos;\n\tunsigned int numer, denom;\n\n\tfield_type = get_exif_ui16(e, tag_pos+2);\n\tvalue_count = get_exif_ui32(e, tag_pos+4);\n\n\tif(value_count!=1) return 0;\n\n\tif(field_type!=5) return 0; // 5=Rational (two uint32's)\n\n\t// A rational is 8 bytes. Since 8>4, it is stored indirectly. First, read\n\t// the location where it is stored.\n\n\tvalue_pos = get_exif_ui32(e, tag_pos+8);\n\tif(value_pos > e->d_len-8) return 0;\n\n\t// Read the actual value.\n\tnumer = get_exif_ui32(e, value_pos);\n\tdenom = get_exif_ui32(e, value_pos+4);\n\tif(denom==0) return 0;\n\n\t*pv = ((double)numer)/denom;\n\treturn 1;\n}", "target": 1, "idx": 10492}
{"commit_id": "01173bc8097391b2e46c4d56a080709c219fda53", "project": "redis", "func": "static void controloptions (lua_State *L, int opt, const char **fmt,\n                            Header *h) {\n  switch (opt) {\n    case  ' ': return;  /* ignore white spaces */\n    case '>': h->endian = BIG; return;\n    case '<': h->endian = LITTLE; return;\n    case '!': {\n      int a = getnum(L, fmt, MAXALIGN);\n      if (!isp2(a))\n        luaL_error(L, \"alignment %d is not a power of 2\", a);\n      h->align = a;\n      return;\n    }\n    default: {\n      const char *msg = lua_pushfstring(L, \"invalid format option '%c'\", opt);\n      luaL_argerror(L, 1, msg);\n    }\n  }\n}", "target": 2, "idx": 10493}
{"commit_id": "c26d5beb60a5a85f76259f50ed3e08c8169b0a0c", "project": "exempi", "func": "bool TIFF_MemoryReader::GetTag ( XMP_Uns8 ifd, XMP_Uns16 id, TagInfo* info ) const\n{\n\tconst TweakedIFDEntry* thisTag = this->FindTagInIFD ( ifd, id );\n\tif ( thisTag == 0 ) return false;\n\t\n\tXMP_Uns16 thisType = GetUns16AsIs ( &thisTag->type );\n\tXMP_Uns32 thisBytes = GetUns32AsIs ( &thisTag->bytes );\n\t\n\tif ( (thisType < kTIFF_ByteType) || (thisType > kTIFF_LastType) ) return false;\t// Bad type, skip this tag.\n\n\tif ( info != 0 ) {\n\n\t\tinfo->id = GetUns16AsIs ( &thisTag->id );\n\t\tinfo->type = thisType;\n\t\tinfo->count = thisBytes / (XMP_Uns32)kTIFF_TypeSizes[thisType];\n\t\tinfo->dataLen = thisBytes;\n\n\t\tinfo->dataPtr = this->GetDataPtr ( thisTag );\n\t\t// Here we know that if it is NULL, it is wrong. -- Hub\n\t\t// GetDataPtr will return NULL in case of overflow.\n\t\tif (info->dataPtr == NULL) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n\n}", "target": 2, "idx": 10494}
{"commit_id": "0d7967549751b7032f22b437106b41444aff0ba9", "project": "OpenSC", "func": "int main(int argc, char **argv)\n{\n\tsc_context_t *ctx = NULL;\n\tsc_context_param_t ctx_param;\n\tsc_card_t *card = NULL;\n\tint r;\n\n\t/* get options */\n\tdecode_options(argc, argv);\n\n\t/* connect to the card */\n\tmemset(&ctx_param, 0, sizeof(ctx_param));\n\tctx_param.ver      = 0;\n\tctx_param.app_name = app_name;\n\n\tr = sc_context_create(&ctx, &ctx_param);\n\tif (r) {\n\tfprintf(stderr, \"Failed to establish context: %s\\n\",\n\t\tsc_strerror(r));\n\t\treturn 1;\n\t}\n\tr = util_connect_card(ctx, &card, opt_reader, opt_wait, 0);\n\tif (r) {\n\t\tfprintf(stderr, \"Failed to connect to card: %s\\n\", sc_strerror(r));\n\t\tsc_release_context(ctx);\n\t\treturn 1;\n\t}\n\n\t/* Check card type */\n\tif (card->type == SC_CARD_TYPE_MCRD_ESTEID_V30)\n\t\tdo_esteid(card);\n\telse if (card->type == SC_CARD_TYPE_BELPIC_EID)\n\t\tdo_belpic(card);\n\telse {\n\t\tfprintf(stderr, \"Not an EstEID or Belpic card!\\n\");\n\t\tgoto out;\n\t}\n\n\tif (exec_program) {\n\t\tchar *const largv[] = {exec_program, NULL};\n\t\tsc_unlock(card);\n\t\tsc_disconnect_card(card);\n\t\tsc_release_context(ctx);\n\t\texecv(exec_program, largv);\n\t\t/* we should not get here */\n\t\tperror(\"execv()\");\n\t\texit(1);\n\t}\n\nout:\n\tsc_unlock(card);\n\tsc_disconnect_card(card);\n\tsc_release_context(ctx);\n\texit(exit_status);\n}", "target": 2, "idx": 10495}
{"commit_id": "7e112c1563632f57cfa1c4fa964987f823da17fa", "project": "chromium", "func": "void PasswordGenerationAgent::ShowGenerationPopup() {\n  if (!render_frame())\n    return;\n  Send(new AutofillHostMsg_ShowPasswordGenerationPopup(\n      routing_id(),\n      render_frame()->GetRenderView()->ElementBoundsInWindow(\n          generation_element_),\n      generation_element_.maxLength(),\n      generation_element_.nameForAutofill(),\n      is_manually_triggered_,\n      *generation_form_data_->form));\n  generation_popup_shown_ = true;\n}", "target": 2, "idx": 10496}
{"commit_id": "72ec933663f738d8e166979aa7fd5590b2104a07", "project": "gdraheim/zziplib", "func": "zzip_size_t\nzzip_disk_fread(void *ptr, zzip_size_t sized, zzip_size_t nmemb,\n                ZZIP_DISK_FILE * file)\n{\n    zzip_size_t size = sized * nmemb;\n    if (! ptr || ! sized || ! file)\n        return 0;\n    if (size > file->avail)\n        size = file->avail;\n    if (file->stored)\n    {\n        if (file->stored + size >= file->endbuf)\n        {\n            DBG1(\"try to read beyond end of file\");\n            return 0; /* ESPIPE */\n        }\n        DBG3(\"copy stored %p %i\", file->stored, (int)size);\n        memcpy(ptr, file->stored, size);\n        file->stored += size;\n        file->avail -= size;\n        return size;\n    }\n\n    file->zlib.avail_out = sized * nmemb;\n    file->zlib.next_out = ptr;\n    ___ zzip_size_t total_old = file->zlib.total_out;\n    ___ int err = inflate(&file->zlib, Z_NO_FLUSH);\n    if (err == Z_STREAM_END)\n        file->avail = 0;\n    else if (err == Z_OK)\n        file->avail -= file->zlib.total_out - total_old;\n    else\n        return 0;\n    return file->zlib.total_out - total_old;\n    ____;\n    ____;\n}", "target": 1, "idx": 10497}
{"commit_id": "b6aae4d8e7c8a6ddd21646f94fef1bf7f22c3f32", "project": "389ds/389-ds-base", "func": "int\nldbm_back_bind(Slapi_PBlock *pb)\n{\n    backend *be;\n    ldbm_instance *inst;\n    ber_tag_t method;\n    struct berval *cred;\n    struct ldbminfo *li;\n    struct backentry *e;\n    Slapi_Attr *attr;\n    Slapi_Value **bvals;\n    entry_address *addr;\n    back_txn txn = {NULL};\n    int rc = SLAPI_BIND_SUCCESS;\n    int result_sent = 0;\n\n    /* get parameters */\n    slapi_pblock_get(pb, SLAPI_BACKEND, &be);\n    slapi_pblock_get(pb, SLAPI_PLUGIN_PRIVATE, &li);\n    slapi_pblock_get(pb, SLAPI_TARGET_ADDRESS, &addr);\n    slapi_pblock_get(pb, SLAPI_BIND_METHOD, &method);\n    slapi_pblock_get(pb, SLAPI_BIND_CREDENTIALS, &cred);\n    slapi_pblock_get(pb, SLAPI_TXN, &txn.back_txn_txn);\n\n    if (!txn.back_txn_txn) {\n        dblayer_txn_init(li, &txn);\n        slapi_pblock_set(pb, SLAPI_TXN, txn.back_txn_txn);\n    }\n\n    inst = (ldbm_instance *)be->be_instance_info;\n    if (inst->inst_ref_count) {\n        slapi_counter_increment(inst->inst_ref_count);\n    } else {\n        slapi_log_err(SLAPI_LOG_ERR, \"ldbm_back_bind\",\n                      \"instance %s does not exist.\\n\", inst->inst_name);\n        return (SLAPI_BIND_FAIL);\n    }\n\n    /* always allow noauth simple binds (front end will send the result) */\n    if (method == LDAP_AUTH_SIMPLE && cred->bv_len == 0) {\n        rc = SLAPI_BIND_ANONYMOUS;\n        goto bail;\n    }\n\n    /*\n     * find the target entry.  find_entry() takes care of referrals\n     *   and sending errors if the entry does not exist.\n     */\n    if ((e = find_entry(pb, be, addr, &txn, &result_sent)) == NULL) {\n        rc = SLAPI_BIND_FAIL;\n        /* In the failure case, the result is supposed to be sent in the backend. */\n        if (!result_sent) {\n            slapi_send_ldap_result(pb, LDAP_INAPPROPRIATE_AUTH, NULL, NULL, 0, NULL);\n        }\n        goto bail;\n    }\n\n    switch (method) {\n    case LDAP_AUTH_SIMPLE: {\n        Slapi_Value cv;\n        if (slapi_entry_attr_find(e->ep_entry, \"userpassword\", &attr) != 0) {\n            slapi_pblock_set(pb, SLAPI_PB_RESULT_TEXT, \"Entry does not have userpassword set\");\n            slapi_send_ldap_result(pb, LDAP_INVALID_CREDENTIALS, NULL, NULL, 0, NULL);\n            CACHE_RETURN(&inst->inst_cache, &e);\n            rc = SLAPI_BIND_FAIL;\n            goto bail;\n        }\n        bvals = attr_get_present_values(attr);\n        slapi_value_init_berval(&cv, cred);\n        if (slapi_pw_find_sv(bvals, &cv) != 0) {\n            slapi_pblock_set(pb, SLAPI_PB_RESULT_TEXT, \"Invalid credentials\");\n            slapi_send_ldap_result(pb, LDAP_INVALID_CREDENTIALS, NULL, NULL, 0, NULL);\n            CACHE_RETURN(&inst->inst_cache, &e);\n            value_done(&cv);\n            rc = SLAPI_BIND_FAIL;\n            goto bail;\n        }\n        value_done(&cv);\n    } break;\n\n    default:\n        slapi_send_ldap_result(pb, LDAP_STRONG_AUTH_NOT_SUPPORTED, NULL,\n                               \"auth method not supported\", 0, NULL);\n        CACHE_RETURN(&inst->inst_cache, &e);\n        rc = SLAPI_BIND_FAIL;\n        goto bail;\n    }\n\n    CACHE_RETURN(&inst->inst_cache, &e);\nbail:\n    if (inst->inst_ref_count) {\n        slapi_counter_decrement(inst->inst_ref_count);\n    }\n    /* success:  front end will send result */\n    return rc;\n}", "target": 1, "idx": 10498}
{"commit_id": "233affe3fcdc851fa82cb058871bddd0046e1c87", "project": "leozide/leocad", "func": "bool lcPiecesLibrary::LoadTexture(lcTexture* Texture)\n{\n\tQMutexLocker Lock(&mTextureMutex);\n\tchar FileName[2*LC_MAXPATH];\n\n\tif (mZipFiles[static_cast<int>(lcZipFileType::Official)])\n\t{\n\t\tlcMemFile TextureFile;\n\n\t\tsprintf(FileName, \"parts/textures/%s.png\", Texture->mName);\n\n\t\tif (!mZipFiles[static_cast<int>(lcZipFileType::Unofficial)] || !mZipFiles[static_cast<int>(lcZipFileType::Unofficial)]->ExtractFile(FileName, TextureFile))\n\t\t{\n\t\t\tsprintf(FileName, \"ldraw/parts/textures/%s.png\", Texture->mName);\n\n\t\t\tif (!mZipFiles[static_cast<int>(lcZipFileType::Official)]->ExtractFile(FileName, TextureFile))\n\t\t\t\treturn false;\n\t\t}\n\n\t\treturn Texture->Load(TextureFile);\n\t}\n\telse\n\t\treturn Texture->Load(Texture->mFileName);\n}", "target": 1, "idx": 10499}
{"commit_id": "7db3386fcdb454e33a3ea30dcfb8e8960d4c3aa3", "project": "Yubico/pam-u2f", "func": "int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc,\n                        const char **argv) {\n\n  struct passwd *pw = NULL, pw_s;\n  const char *user = NULL;\n\n  cfg_t cfg_st;\n  cfg_t *cfg = &cfg_st;\n  char buffer[BUFSIZE];\n  char *buf = NULL;\n  char *authfile_dir;\n  size_t authfile_dir_len;\n  int pgu_ret, gpn_ret;\n  int retval = PAM_IGNORE;\n  device_t *devices = NULL;\n  unsigned n_devices = 0;\n  int openasuser = 0;\n  int should_free_origin = 0;\n  int should_free_appid = 0;\n  int should_free_auth_file = 0;\n  int should_free_authpending_file = 0;\n  PAM_MODUTIL_DEF_PRIVS(privs);\n\n  parse_cfg(flags, argc, argv, cfg);\n\n  if (!cfg->origin) {\n    strcpy(buffer, DEFAULT_ORIGIN_PREFIX);\n\n    if (gethostname(buffer + strlen(DEFAULT_ORIGIN_PREFIX),\n                    BUFSIZE - strlen(DEFAULT_ORIGIN_PREFIX)) == -1) {\n      DBG(\"Unable to get host name\");\n      goto done;\n    }\n    DBG(\"Origin not specified, using \\\"%s\\\"\", buffer);\n    cfg->origin = strdup(buffer);\n    if (!cfg->origin) {\n      DBG(\"Unable to allocate memory\");\n      goto done;\n    } else {\n      should_free_origin = 1;\n    }\n  }\n\n  if (!cfg->appid) {\n    DBG(\"Appid not specified, using the same value of origin (%s)\",\n         cfg->origin);\n    cfg->appid = strdup(cfg->origin);\n    if (!cfg->appid) {\n      DBG(\"Unable to allocate memory\")\n      goto done;\n    } else {\n      should_free_appid = 1;\n    }\n  }\n\n  if (cfg->max_devs == 0) {\n    DBG(\"Maximum devices number not set. Using default (%d)\", MAX_DEVS);\n    cfg->max_devs = MAX_DEVS;\n  }\n\n  devices = malloc(sizeof(device_t) * cfg->max_devs);\n  if (!devices) {\n    DBG(\"Unable to allocate memory\");\n    retval = PAM_IGNORE;\n    goto done;\n  }\n\n  pgu_ret = pam_get_user(pamh, &user, NULL);\n  if (pgu_ret != PAM_SUCCESS || user == NULL) {\n    DBG(\"Unable to access user %s\", user);\n    retval = PAM_CONV_ERR;\n    goto done;\n  }\n\n  DBG(\"Requesting authentication for user %s\", user);\n\n  gpn_ret = getpwnam_r(user, &pw_s, buffer, sizeof(buffer), &pw);\n  if (gpn_ret != 0 || pw == NULL || pw->pw_dir == NULL ||\n      pw->pw_dir[0] != '/') {\n    DBG(\"Unable to retrieve credentials for user %s, (%s)\", user,\n         strerror(errno));\n    retval = PAM_USER_UNKNOWN;\n    goto done;\n  }\n\n  DBG(\"Found user %s\", user);\n  DBG(\"Home directory for %s is %s\", user, pw->pw_dir);\n\n  if (!cfg->auth_file) {\n    buf = NULL;\n    authfile_dir = secure_getenv(DEFAULT_AUTHFILE_DIR_VAR);\n    if (!authfile_dir) {\n      DBG(\"Variable %s is not set. Using default value ($HOME/.config/)\",\n           DEFAULT_AUTHFILE_DIR_VAR);\n      authfile_dir_len =\n        strlen(pw->pw_dir) + strlen(\"/.config\") + strlen(DEFAULT_AUTHFILE) + 1;\n      buf = malloc(sizeof(char) * (authfile_dir_len));\n\n      if (!buf) {\n        DBG(\"Unable to allocate memory\");\n        retval = PAM_IGNORE;\n        goto done;\n      }\n\n      /* Opening a file in a users $HOME, need to drop privs for security */\n      openasuser = geteuid() == 0 ? 1 : 0;\n\n      snprintf(buf, authfile_dir_len,\n               \"%s/.config%s\", pw->pw_dir, DEFAULT_AUTHFILE);\n    } else {\n      DBG(\"Variable %s set to %s\", DEFAULT_AUTHFILE_DIR_VAR, authfile_dir);\n      authfile_dir_len = strlen(authfile_dir) + strlen(DEFAULT_AUTHFILE) + 1;\n      buf = malloc(sizeof(char) * (authfile_dir_len));\n\n      if (!buf) {\n        DBG(\"Unable to allocate memory\");\n        retval = PAM_IGNORE;\n        goto done;\n      }\n\n      snprintf(buf, authfile_dir_len,\n               \"%s%s\", authfile_dir, DEFAULT_AUTHFILE);\n\n      if (!openasuser) {\n\tDBG(\"WARNING: not dropping privileges when reading %s, please \"\n\t    \"consider setting openasuser=1 in the module configuration\", buf);\n      }\n    }\n\n    DBG(\"Using authentication file %s\", buf);\n\n    cfg->auth_file = buf; /* cfg takes ownership */\n    should_free_auth_file = 1;\n    buf = NULL;\n  } else {\n    DBG(\"Using authentication file %s\", cfg->auth_file);\n  }\n\n  if (!openasuser) {\n    openasuser = geteuid() == 0 && cfg->openasuser;\n  }\n  if (openasuser) {\n    DBG(\"Dropping privileges\");\n    if (pam_modutil_drop_priv(pamh, &privs, pw)) {\n      DBG(\"Unable to switch user to uid %i\", pw->pw_uid);\n      retval = PAM_IGNORE;\n      goto done;\n    }\n    DBG(\"Switched to uid %i\", pw->pw_uid);\n  }\n  retval = get_devices_from_authfile(cfg->auth_file, user, cfg->max_devs,\n                                     cfg->debug, cfg->debug_file,\n                                     devices, &n_devices);\n  if (openasuser) {\n    if (pam_modutil_regain_priv(pamh, &privs)) {\n      DBG(\"could not restore privileges\");\n      retval = PAM_IGNORE;\n      goto done;\n    }\n    DBG(\"Restored privileges\");\n  }\n\n  if (retval != 1) {\n    // for nouserok; make sure errors in get_devices_from_authfile don't\n    // result in valid devices\n    n_devices = 0;\n  }\n\n  if (n_devices == 0) {\n    if (cfg->nouserok) {\n      DBG(\"Found no devices but nouserok specified. Skipping authentication\");\n      retval = PAM_SUCCESS;\n      goto done;\n    } else if (retval != 1) {\n      DBG(\"Unable to get devices from file %s\", cfg->auth_file);\n      retval = PAM_AUTHINFO_UNAVAIL;\n      goto done;\n    } else {\n      DBG(\"Found no devices. Aborting.\");\n      retval = PAM_AUTHINFO_UNAVAIL;\n      goto done;\n    }\n  }\n\n  // Determine the full path for authpending_file in order to emit touch request notifications\n  if (!cfg->authpending_file) {\n    int actual_size = snprintf(buffer, BUFSIZE, DEFAULT_AUTHPENDING_FILE_PATH, getuid());\n    if (actual_size >= 0 && actual_size < BUFSIZE) {\n      cfg->authpending_file = strdup(buffer);\n    }\n    if (!cfg->authpending_file) {\n      DBG(\"Unable to allocate memory for the authpending_file, touch request notifications will not be emitted\");\n    } else {\n      should_free_authpending_file = 1;\n    }\n  } else {\n    if (strlen(cfg->authpending_file) == 0) {\n      DBG(\"authpending_file is set to an empty value, touch request notifications will be disabled\");\n      cfg->authpending_file = NULL;\n    }\n  }\n\n  int authpending_file_descriptor = -1;\n  if (cfg->authpending_file) {\n    DBG(\"Using file '%s' for emitting touch request notifications\", cfg->authpending_file);\n\n    // Open (or create) the authpending_file to indicate that we start waiting for a touch\n    authpending_file_descriptor =\n      open(cfg->authpending_file, O_RDONLY | O_CREAT | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY, 0664);\n    if (authpending_file_descriptor < 0) {\n      DBG(\"Unable to emit 'authentication started' notification by opening the file '%s', (%s)\",\n          cfg->authpending_file, strerror(errno));\n    }\n  }\n\n  if (cfg->manual == 0) {\n    if (cfg->interactive) {\n      converse(pamh, PAM_PROMPT_ECHO_ON,\n               cfg->prompt != NULL ? cfg->prompt : DEFAULT_PROMPT);\n    }\n\n    retval = do_authentication(cfg, devices, n_devices, pamh);\n  } else {\n    retval = do_manual_authentication(cfg, devices, n_devices, pamh);\n  }\n\n  // Close the authpending_file to indicate that we stop waiting for a touch\n  if (authpending_file_descriptor >= 0) {\n    if (close(authpending_file_descriptor) < 0) {\n      DBG(\"Unable to emit 'authentication stopped' notification by closing the file '%s', (%s)\",\n          cfg->authpending_file, strerror(errno));\n    }\n  }\n\n  if (retval != 1) {\n    DBG(\"do_authentication returned %d\", retval);\n    retval = PAM_AUTH_ERR;\n    goto done;\n  }\n\n  retval = PAM_SUCCESS;\n\ndone:\n  free_devices(devices, n_devices);\n\n  if (buf) {\n    free(buf);\n    buf = NULL;\n  }\n\n  if (should_free_origin) {\n    free((char *) cfg->origin);\n    cfg->origin = NULL;\n  }\n\n  if (should_free_appid) {\n    free((char *) cfg->appid);\n    cfg->appid = NULL;\n  }\n\n  if (should_free_auth_file) {\n    free((char *) cfg->auth_file);\n    cfg->auth_file = NULL;\n  }\n\n  if (should_free_authpending_file) {\n    free((char *) cfg->authpending_file);\n    cfg->authpending_file = NULL;\n  }\n\n  if (cfg->alwaysok && retval != PAM_SUCCESS) {\n    DBG(\"alwaysok needed (otherwise return with %d)\", retval);\n    retval = PAM_SUCCESS;\n  }\n  DBG(\"done. [%s]\", pam_strerror(pamh, retval));\n\n  if (cfg->is_custom_debug_file) {\n    fclose(cfg->debug_file);\n  }\n\n  return retval;\n}", "target": 2, "idx": 10500}
{"commit_id": "b7f6cbb9d43f7384e1f38f8764b9a48216c8a525", "project": "xen-project/xen", "func": "static void\n__gnttab_unmap_common(\n    struct gnttab_unmap_common *op)\n{\n    domid_t          dom;\n    struct domain   *ld, *rd;\n    struct grant_table *lgt, *rgt;\n    struct active_grant_entry *act;\n    s16              rc = 0;\n    struct grant_mapping *map;\n    bool put_handle = false;\n\n    ld = current->domain;\n    lgt = ld->grant_table;\n\n    op->frame = (unsigned long)(op->dev_bus_addr >> PAGE_SHIFT);\n\n    if ( unlikely(op->handle >= lgt->maptrack_limit) )\n    {\n        gdprintk(XENLOG_INFO, \"Bad handle %#x\\n\", op->handle);\n        op->status = GNTST_bad_handle;\n        return;\n    }\n\n    map = &maptrack_entry(lgt, op->handle);\n\n    grant_read_lock(lgt);\n\n    if ( unlikely(!read_atomic(&map->flags)) )\n    {\n        grant_read_unlock(lgt);\n        gdprintk(XENLOG_INFO, \"Zero flags for handle %#x\\n\", op->handle);\n        op->status = GNTST_bad_handle;\n        return;\n    }\n\n    dom = map->domid;\n    grant_read_unlock(lgt);\n\n    if ( unlikely((rd = rcu_lock_domain_by_id(dom)) == NULL) )\n    {\n        /* This can happen when a grant is implicitly unmapped. */\n        gdprintk(XENLOG_INFO, \"Could not find domain %d\\n\", dom);\n        domain_crash(ld); /* naughty... */\n        return;\n    }\n\n    rc = xsm_grant_unmapref(XSM_HOOK, ld, rd);\n    if ( rc )\n    {\n        rcu_unlock_domain(rd);\n        op->status = GNTST_permission_denied;\n        return;\n    }\n\n    TRACE_1D(TRC_MEM_PAGE_GRANT_UNMAP, dom);\n\n    rgt = rd->grant_table;\n\n    grant_read_lock(rgt);\n\n    op->rd = rd;\n    op->ref = map->ref;\n\n    /*\n     * We can't assume there was no racing unmap for this maptrack entry,\n     * and hence we can't assume map->ref is valid for rd. While the checks\n     * below (with the active entry lock held) will reject any such racing\n     * requests, we still need to make sure we don't attempt to acquire an\n     * invalid lock.\n     */\n    smp_rmb();\n    if ( unlikely(op->ref >= nr_grant_entries(rgt)) )\n    {\n        gdprintk(XENLOG_WARNING, \"Unstable handle %#x\\n\", op->handle);\n        rc = GNTST_bad_handle;\n        goto unlock_out;\n    }\n\n    act = active_entry_acquire(rgt, op->ref);\n\n    /*\n     * Note that we (ab)use the active entry lock here to protect against\n     * multiple unmaps of the same mapping here. We don't want to hold lgt's\n     * lock, and we only hold rgt's lock for reading (but the latter wouldn't\n     * be the right one anyway). Hence the easiest is to rely on a lock we\n     * hold anyway; see docs/misc/grant-tables.txt's \"Locking\" section.\n     */\n\n    op->flags = read_atomic(&map->flags);\n    smp_rmb();\n    if ( unlikely(!op->flags) || unlikely(map->domid != dom) ||\n         unlikely(map->ref != op->ref) )\n    {\n        gdprintk(XENLOG_WARNING, \"Unstable handle %#x\\n\", op->handle);\n        rc = GNTST_bad_handle;\n        goto act_release_out;\n    }\n\n    if ( op->frame == 0 )\n    {\n        op->frame = act->frame;\n    }\n    else\n    {\n        if ( unlikely(op->frame != act->frame) )\n            PIN_FAIL(act_release_out, GNTST_general_error,\n                     \"Bad frame number doesn't match gntref. (%lx != %lx)\\n\",\n                     op->frame, act->frame);\n\n        map->flags &= ~GNTMAP_device_map;\n    }\n\n    if ( (op->host_addr != 0) && (op->flags & GNTMAP_host_map) )\n    {\n        if ( (rc = replace_grant_host_mapping(op->host_addr,\n                                              op->frame, op->new_addr, \n                                              op->flags)) < 0 )\n            goto act_release_out;\n\n        map->flags &= ~GNTMAP_host_map;\n    }\n\n    if ( !(map->flags & (GNTMAP_device_map|GNTMAP_host_map)) )\n    {\n        map->flags = 0;\n        put_handle = true;\n    }\n\n act_release_out:\n    active_entry_release(act);\n unlock_out:\n    grant_read_unlock(rgt);\n\n    if ( put_handle )\n        put_maptrack_handle(lgt, op->handle);\n\n    if ( rc == GNTST_okay && gnttab_need_iommu_mapping(ld) )\n    {\n        unsigned int kind;\n        int err = 0;\n\n        double_gt_lock(lgt, rgt);\n\n        kind = mapkind(lgt, rd, op->frame);\n        if ( !kind )\n            err = iommu_unmap_page(ld, op->frame);\n        else if ( !(kind & MAPKIND_WRITE) )\n            err = iommu_map_page(ld, op->frame, op->frame, IOMMUF_readable);\n\n        double_gt_unlock(lgt, rgt);\n\n        if ( err )\n            rc = GNTST_general_error;\n    }\n\n    /* If just unmapped a writable mapping, mark as dirtied */\n    if ( rc == GNTST_okay && !(op->flags & GNTMAP_readonly) )\n         gnttab_mark_dirty(rd, op->frame);\n\n    op->status = rc;\n    rcu_unlock_domain(rd);\n}", "target": 3, "idx": 10501}
{"commit_id": "56f7b1bc95a2a3eeb420e069e7655fb181ade5cf", "project": "krb5", "func": "OM_uint32 KRB5_CALLCONV\ngss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t   gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n\t\t   int iov_count)\n{\n    OM_uint32 status;\n    gss_union_ctx_id_t ctx;\n    gss_mechanism mech;\n\n    status = val_unwrap_iov_args(minor_status, context_handle, NULL,\n\t\t\t\t qop_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn status;\n\n    /* Select the approprate underlying mechanism routine and call it. */\n    ctx = (gss_union_ctx_id_t)context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n    mech = gssint_get_mechanism(ctx->mech_type);\n    if (mech == NULL)\n\treturn GSS_S_BAD_MECH;\n    if (mech->gss_verify_mic_iov == NULL)\n\treturn GSS_S_UNAVAILABLE;\n    status = mech->gss_verify_mic_iov(minor_status, ctx->internal_ctx_id,\n\t\t\t\t      qop_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\tmap_error(minor_status, mech);\n    return status;\n}", "target": 3, "idx": 10502}
{"commit_id": "1e42736b95065c69a7481d0cf55247024f54b660", "project": "ffmpeg", "func": "static int cdxl_decode_frame(AVCodecContext *avctx, void *data,\n                             int *got_frame, AVPacket *pkt)\n{\n    CDXLVideoContext *c = avctx->priv_data;\n    AVFrame * const p = data;\n    int ret, w, h, encoding, aligned_width, buf_size = pkt->size;\n    const uint8_t *buf = pkt->data;\n\n    if (buf_size < 32)\n        return AVERROR_INVALIDDATA;\n    encoding        = buf[1] & 7;\n    c->format       = buf[1] & 0xE0;\n    w               = AV_RB16(&buf[14]);\n    h               = AV_RB16(&buf[16]);\n    c->bpp          = buf[19];\n    c->palette_size = AV_RB16(&buf[20]);\n    c->palette      = buf + 32;\n    c->video        = c->palette + c->palette_size;\n    c->video_size   = buf_size - c->palette_size - 32;\n\n    if (c->palette_size > 512)\n        return AVERROR_INVALIDDATA;\n    if (buf_size < c->palette_size + 32)\n        return AVERROR_INVALIDDATA;\n    if (c->bpp < 1)\n        return AVERROR_INVALIDDATA;\n    if (c->format != BIT_PLANAR && c->format != BIT_LINE && c->format != CHUNKY) {\n        avpriv_request_sample(avctx, \"Pixel format 0x%0x\", c->format);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    if ((ret = ff_set_dimensions(avctx, w, h)) < 0)\n        return ret;\n\n    if (c->format == CHUNKY)\n        aligned_width = avctx->width;\n    else\n        aligned_width = FFALIGN(c->avctx->width, 16);\n    c->padded_bits  = aligned_width - c->avctx->width;\n    if (c->video_size < aligned_width * avctx->height * (int64_t)c->bpp / 8)\n        return AVERROR_INVALIDDATA;\n    if (!encoding && c->palette_size && c->bpp <= 8 && c->format != CHUNKY) {\n        avctx->pix_fmt = AV_PIX_FMT_PAL8;\n    } else if (encoding == 1 && (c->bpp == 6 || c->bpp == 8) && c->format != CHUNKY) {\n        if (c->palette_size != (1 << (c->bpp - 1)))\n            return AVERROR_INVALIDDATA;\n        avctx->pix_fmt = AV_PIX_FMT_BGR24;\n    } else if (!encoding && c->bpp == 24 && c->format == CHUNKY &&\n               !c->palette_size) {\n        avctx->pix_fmt = AV_PIX_FMT_RGB24;\n    } else {\n        avpriv_request_sample(avctx, \"Encoding %d, bpp %d and format 0x%x\",\n                              encoding, c->bpp, c->format);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    if ((ret = ff_get_buffer(avctx, p, 0)) < 0)\n        return ret;\n    p->pict_type = AV_PICTURE_TYPE_I;\n\n    if (encoding) {\n        av_fast_padded_malloc(&c->new_video, &c->new_video_size,\n                              h * w + AV_INPUT_BUFFER_PADDING_SIZE);\n        if (!c->new_video)\n            return AVERROR(ENOMEM);\n        if (c->bpp == 8)\n            cdxl_decode_ham8(c, p);\n        else\n            cdxl_decode_ham6(c, p);\n    } else if (avctx->pix_fmt == AV_PIX_FMT_PAL8) {\n        cdxl_decode_rgb(c, p);\n    } else {\n        cdxl_decode_raw(c, p);\n    }\n    *got_frame = 1;\n\n    return buf_size;\n}", "target": 2, "idx": 10503}
{"commit_id": "4f6bc662909ab79e8fbe9822afb36e8a0eafc2b7", "project": "ArtifexSoftware/ghostpdl", "func": "static int\nlp8000_print_page(gx_device_printer *pdev, gp_file *prn_stream)\n{\n\n        int line_size = gdev_mem_bytes_per_scan_line((gx_device *)pdev);\n        int in_size = line_size;\n        unsigned int report_size;\n\n        byte *buf1 = (byte *)gs_malloc(pdev->memory, in_size, 1, \"lp8000_print_page(buf1)\");\n\n        /* Worst case for rle compression below is 3 bytes for each 2 bytes of\n        input, with extra final byte. */\n        byte *buf2 = (byte *)gs_malloc(pdev->memory, in_size * 3 / 2 + 2, 1, \"lp8000_print_page(buf2)\");\n        byte *in = buf1;\n        byte *out = buf2;\n\n        int lnum, top, bottom, left, width;\n        int count, left1, left2, left0;\n\n/* Check  memory allocations  */\n\n        if ( buf1 == 0 || buf2 == 0 )\n        {       if ( buf1 )\n                gs_free(pdev->memory, (char *)buf1, in_size, 1, \"lp8000_print_page(buf1)\");\n\n                if ( buf2 )\n                gs_free(pdev->memory, (char *)buf2, in_size, 1, \"lp8000_print_page(buf2)\");\n\n          return_error(gs_error_VMerror);\n        }\n\n/* Initialize the printer */\n\n        gp_fwrite(\"\\033\\001@EJL \\n\",1,8,prn_stream);\n        gp_fwrite(\"@EJL EN LA=ESC/PAGE\\n\",1,20,prn_stream);\n        gp_fwrite(\"\\035rhE\\033\\001@EJL \\n\",1,12,prn_stream);\n        gp_fwrite(\"@EJL SE LA=ESC/PAGE\\n\",1,20,prn_stream);\n        gp_fwrite(\"@EJL SET PU=1 PS=A4 ZO=OFF\\n\",1,27,prn_stream);\n        gp_fwrite(\"@EJL EN LA=ESC/PAGE\\n\",1,20,prn_stream);\n        gp_fwrite(\"\\0350;0.24muE\\0352;300;300drE\",1,23,prn_stream);\n        gp_fwrite(\"\\0350;300;300drE\\0351tsE\\0351mmE\",1,23,prn_stream);\n        gp_fwrite(\"\\0357isE\\0355iaF\\0355ipP\\03514psE\\0350poE\",1,26,prn_stream);\n        gp_fwrite(\"\\03560;60loE\\0350X\\0350Y\",1,15,prn_stream);\n        gp_fwrite(\"\\0350;0;2360;3388caE\",1,17,prn_stream);\n        gp_fwrite(\"\\0351cmE\\0350alfP\",1,11,prn_stream);\n        gp_fwrite(\"\\0350affP\\0350boP\\0350abP\",1,16,prn_stream);\n        gp_fwrite(\"\\0354ilG\\0350bcI\\0350sarG\",1,16,prn_stream);\n        gp_fwrite(\"\\0351;0;100spE\\0352owE\",1,16,prn_stream);\n\n/* Here the common part of the initialization string ends */\n\n/* Calculate the PRINTER_LEFT_MARGIN = device_left_margin - 60 adjusted to\nthe byte boundary. Save this value for future comparison and set the\nstarting X value of the printer line.\n*/\n        left1  =  (int) (L_MARGIN * pdev->x_pixels_per_inch) - 60;\n        left1 = (left1 >> 3) << 3;\n        left0 = left1;\n\n        gp_fwrite(\"\\035\",1,1,prn_stream);\n        gp_fprintf(prn_stream,\"%d\",left1);\n        gp_fwrite(\"X\",1,1,prn_stream);\n\n        /* Set the compressed data format */\n        gp_fwrite(\"\\0353bcI\",1,5,prn_stream);\n\n        top = T_MARGIN * pdev->y_pixels_per_inch;\n        bottom = pdev->height - B_MARGIN * pdev->y_pixels_per_inch;\n\n        left  = ( (int) (L_MARGIN * pdev->x_pixels_per_inch) ) >> 3 ;\n        width = ((pdev->width - (int)(R_MARGIN * pdev->x_pixels_per_inch)) >> 3) - left;\n\n        /*\n        ** Print the page:\n        */\n\n        for ( lnum = top; lnum < bottom ; )\n\n        {\n                byte *in_data;\n                byte *inp;\n                byte *in_end;\n                byte *outp;\n                register byte *p, *q;\n\n                /*\n                ** Check buffer for 0 data.\n                */\n\n                gdev_prn_get_bits(pdev, lnum, in, &in_data);\n                while ( in_data[0] == 0 &&\n                        !memcmp((char *)in_data, (char *)in_data + 1, line_size - 1) &&\n                        lnum < bottom )\n                {\n                        lnum++;\n                        gdev_prn_get_bits(pdev, lnum, in, &in_data);\n                }\n\n                if(lnum == bottom ) break;\n                /* finished with this page */\n\n                (void)gdev_prn_copy_scan_lines(pdev, lnum, in, in_size);\n\n                inp = in  + left;\n                in_end = inp + width;\n\n/* Remove trailing 0s form the scan line data */\n\n                while (in_end > inp &&  in_end[-1] == 0)\n                {\n                in_end--;\n                }\n\n/* Remove leading 0s form the scan line data */\n\n        for(left2 = 0; inp < in_end && inp[0] == 0; inp++,left2++);\n\n/* Recalculate starting X value */\n\n        left2 = left1 + (left2 << 3);\n\n/* Compress  non-zero data for this line*/\n\n                outp = out;\n\n for( p = inp, q = inp + 1 ; q < in_end ; )\n        {\n        if( *p != *q++ )\n          {\n          /*\n          Copy non-repeated bytes\n          to the output buffer\n          */\n          *outp++ = *p++;\n          }\n          else\n            {\n                for (count = 2; ( *p == *q ) && (q < in_end); q++, count++)\n                {}\n\n                /*\n                Copy repeated bytes and counts to the output buffer.\n                As long as count is <= 255, additional step is necessary\n                for a long repeated sequence\n                */\n\n                while (count > 257)\n                {\n                *outp++ = *p;\n                *outp++ = *p;\n                *outp++ = 255;\n                p += 257;\n                count -=257;\n                }\n                *outp++ = *p;\n                *outp++ = *p;\n                *outp++ = count - 2;\n                p += count;\n                q = p+1;\n            }\n        }\n\n/* The next line is necessary just in case of a single non-repeated byte at\nthe end of the input buffer */\n\nif (p == (in_end - 1)) *outp++ = *p;\n\n/* End of the compression procedure */\n\n/* Set a new value of the starting X point, if necessary  */\n\nif (left2 != left0)\n        {\n        left0 = left2;\n        gp_fwrite(\"\\035\",1,1,prn_stream);\n        gp_fprintf(prn_stream,\"%d\",left2);\n        gp_fwrite(\"X\",1,1,prn_stream);\n        }\n\n/* Output the data string to the printer.\nY coordinate of the printer equals (lnum - 60)\n*/\n\n        gp_fwrite(\"\\035\",1,1,prn_stream);\n        gp_fprintf(prn_stream,\"%d\",lnum-60);\n        gp_fwrite(\"Y\\035\",1,2,prn_stream);\n        report_size = outp - out;\n        gp_fprintf(prn_stream,\"%d;\",report_size);\n        report_size = (in_end - inp) << 3;\n        gp_fprintf(prn_stream,\"%d;\",report_size);\n        gp_fwrite(\"1;0bi{I\",1,7,prn_stream);\n        gp_fwrite(out,1,(outp - out),prn_stream);\n\n        lnum++;\n\n        }\n\n/* Send the termination string */\n\n        gp_fwrite(\"\\0350bcI\",1,5,prn_stream);\n        gp_fwrite(\"\\0351coO\",1,5,prn_stream);\n        gp_fwrite(\"\\035rhE\",1,4,prn_stream);\n\n        gp_fwrite(\"\\033\\001@EJL \\n\",1,8,prn_stream);\n        gp_fwrite(\"@EJL SE LA=ESC/PAGE\\n\",1,20,prn_stream);\n        gp_fwrite(\"@EJL SET PU=1 PS=A4 ZO=OFF\\n\",1,27,prn_stream);\n        gp_fwrite(\"@EJL EN LA=ESC/PAGE\\n\",1,20,prn_stream);\n        gp_fwrite(\"\\0350;0.24muE\\0352;300;300drE\",1,23,prn_stream);\n        gp_fwrite(\"\\0350;300;300drE\\0351tsE\\0351mmE\",1,23,prn_stream);\n        gp_fwrite(\"\\0357isE\\0355iaF\\0355ipP\\03514psE\\0350poE\",1,26,prn_stream);\n        gp_fwrite(\"\\03560;60loE\\0350X\\0350Y\",1,15,prn_stream);\n        gp_fwrite(\"\\0350;0;2360;3388caE\",1,17,prn_stream);\n        gp_fwrite(\"\\0351cmE\\0350alfP\",1,11,prn_stream);\n        gp_fwrite(\"\\0350affP\\0350boP\\0350abP\",1,16,prn_stream);\n        gp_fwrite(\"\\0354ilG\\0350bcI\\0350sarG\",1,16,prn_stream);\n        gp_fwrite(\"\\035rhE\",1,4,prn_stream);\n        gp_fwrite(\"\\033\\001@EJL \\n\",1,8,prn_stream);\n        gp_fwrite(\"\\033\\001@EJL \\n\",1,8,prn_stream);\n\n        gp_fflush(prn_stream);\n\n        gs_free(pdev->memory, (char *)buf2, in_size, 1, \"lp8000_print_page(buf2)\");\n        gs_free(pdev->memory, (char *)buf1, in_size, 1, \"lp8000_print_page(buf1)\");\n        return 0;\n}", "target": 2, "idx": 10504}
{"commit_id": "336a98feb0d56b9ac54e12736b18785c27f75090", "project": "nghttp2", "func": "const char *nghttp2_strerror(int error_code) {\n  switch (error_code) {\n  case 0:\n    return \"Success\";\n  case NGHTTP2_ERR_INVALID_ARGUMENT:\n    return \"Invalid argument\";\n  case NGHTTP2_ERR_BUFFER_ERROR:\n    return \"Out of buffer space\";\n  case NGHTTP2_ERR_UNSUPPORTED_VERSION:\n    return \"Unsupported SPDY version\";\n  case NGHTTP2_ERR_WOULDBLOCK:\n    return \"Operation would block\";\n  case NGHTTP2_ERR_PROTO:\n    return \"Protocol error\";\n  case NGHTTP2_ERR_INVALID_FRAME:\n    return \"Invalid frame octets\";\n  case NGHTTP2_ERR_EOF:\n    return \"EOF\";\n  case NGHTTP2_ERR_DEFERRED:\n    return \"Data transfer deferred\";\n  case NGHTTP2_ERR_STREAM_ID_NOT_AVAILABLE:\n    return \"No more Stream ID available\";\n  case NGHTTP2_ERR_STREAM_CLOSED:\n    return \"Stream was already closed or invalid\";\n  case NGHTTP2_ERR_STREAM_CLOSING:\n    return \"Stream is closing\";\n  case NGHTTP2_ERR_STREAM_SHUT_WR:\n    return \"The transmission is not allowed for this stream\";\n  case NGHTTP2_ERR_INVALID_STREAM_ID:\n    return \"Stream ID is invalid\";\n  case NGHTTP2_ERR_INVALID_STREAM_STATE:\n    return \"Invalid stream state\";\n  case NGHTTP2_ERR_DEFERRED_DATA_EXIST:\n    return \"Another DATA frame has already been deferred\";\n  case NGHTTP2_ERR_START_STREAM_NOT_ALLOWED:\n    return \"request HEADERS is not allowed\";\n  case NGHTTP2_ERR_GOAWAY_ALREADY_SENT:\n    return \"GOAWAY has already been sent\";\n  case NGHTTP2_ERR_INVALID_HEADER_BLOCK:\n    return \"Invalid header block\";\n  case NGHTTP2_ERR_INVALID_STATE:\n    return \"Invalid state\";\n  case NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE:\n    return \"The user callback function failed due to the temporal error\";\n  case NGHTTP2_ERR_FRAME_SIZE_ERROR:\n    return \"The length of the frame is invalid\";\n  case NGHTTP2_ERR_HEADER_COMP:\n    return \"Header compression/decompression error\";\n  case NGHTTP2_ERR_FLOW_CONTROL:\n    return \"Flow control error\";\n  case NGHTTP2_ERR_INSUFF_BUFSIZE:\n    return \"Insufficient buffer size given to function\";\n  case NGHTTP2_ERR_PAUSE:\n    return \"Callback was paused by the application\";\n  case NGHTTP2_ERR_TOO_MANY_INFLIGHT_SETTINGS:\n    return \"Too many inflight SETTINGS\";\n  case NGHTTP2_ERR_PUSH_DISABLED:\n    return \"Server push is disabled by peer\";\n  case NGHTTP2_ERR_DATA_EXIST:\n    return \"DATA or HEADERS frame has already been submitted for the stream\";\n  case NGHTTP2_ERR_SESSION_CLOSING:\n    return \"The current session is closing\";\n  case NGHTTP2_ERR_HTTP_HEADER:\n    return \"Invalid HTTP header field was received\";\n  case NGHTTP2_ERR_HTTP_MESSAGING:\n    return \"Violation in HTTP messaging rule\";\n  case NGHTTP2_ERR_REFUSED_STREAM:\n    return \"Stream was refused\";\n  case NGHTTP2_ERR_INTERNAL:\n    return \"Internal error\";\n  case NGHTTP2_ERR_CANCEL:\n    return \"Cancel\";\n  case NGHTTP2_ERR_SETTINGS_EXPECTED:\n    return \"When a local endpoint expects to receive SETTINGS frame, it \"\n           \"receives an other type of frame\";\n  case NGHTTP2_ERR_NOMEM:\n    return \"Out of memory\";\n  case NGHTTP2_ERR_CALLBACK_FAILURE:\n    return \"The user callback function failed\";\n  case NGHTTP2_ERR_BAD_CLIENT_MAGIC:\n    return \"Received bad client magic byte string\";\n  case NGHTTP2_ERR_FLOODED:\n    return \"Flooding was detected in this HTTP/2 session, and it must be \"\n           \"closed\";\n  case NGHTTP2_ERR_TOO_MANY_SETTINGS:\n    return \"SETTINGS frame contained more than the maximum allowed entries\";\n  default:\n    return \"Unknown error code\";\n  }\n}", "target": 0, "idx": 10505}
{"commit_id": "a964370a2f9b3dc8eabd8346407a4381f3e0610a", "project": "hfiref0x/LightFTP", "func": "int writelogentry(PFTPCONTEXT context, const char *logtext1, const char *logtext2)\n{\n\tchar\t\tcvbuf[32], _text[PATH_MAX*4];\n\ttime_t\t\titm = time(NULL);\n\tstruct tm\tltm;\n\n\tlocaltime_r(&itm, &ltm);\n\n\t_text[0] = 0;\n\n\tif ( ltm.tm_mday < 10 )\n\t\tstrcat(_text, \"0\");\n\tultostr(ltm.tm_mday, cvbuf);\n\tstrcat(_text, cvbuf);\n\tstrcat(_text, \"-\");\n\n\tif ( ltm.tm_mon+1 < 10 )\n\t\tstrcat(_text, \"0\");\n\tultostr(ltm.tm_mon+1, cvbuf);\n\tstrcat(_text, cvbuf);\n\tstrcat(_text, \"-\");\n\n\tultostr(ltm.tm_year+1900, cvbuf);\n\tstrcat(_text, cvbuf);\n\tstrcat(_text, \" \");\n\n\tif ( ltm.tm_hour < 10 )\n\t\tstrcat(_text, \"0\");\n\tultostr(ltm.tm_hour, cvbuf);\n\tstrcat(_text, cvbuf);\n\tstrcat(_text, \":\");\n\n\tif ( ltm.tm_min < 10 )\n\t\tstrcat(_text, \"0\");\n\tultostr(ltm.tm_min, cvbuf);\n\tstrcat(_text, cvbuf);\n\tstrcat(_text, \":\");\n\n\tif ( ltm.tm_sec < 10 )\n\t\tstrcat(_text, \"0\");\n\tultostr(ltm.tm_sec, cvbuf);\n\tstrcat(_text, cvbuf);\n\n\tif (context) {\n\t\tstrcat(_text, \" S-id=\");\n\t\tultostr(context->SessionID, cvbuf);\n\t\tstrcat(_text, cvbuf);\n\t}\n\tstrcat(_text, \": \");\n\n\tif (logtext1)\n\t\tstrcat(_text, logtext1);\n\n\tif (logtext2)\n\t\tstrcat(_text, logtext2);\n\n\tstrcat(_text, CRLF);\n\n\treturn writeconsolestr(_text);\n}", "target": 3, "idx": 10506}
{"commit_id": "5e4da714f00f6bfb2ccd6d73d61329c6f3a08429", "project": "GNOME/glib", "func": "static void\ng_keyfile_settings_backend_constructed (GObject *object)\n{\n  GKeyfileSettingsBackend *kfsb = G_KEYFILE_SETTINGS_BACKEND (object);\n\n  if (kfsb->file == NULL)\n    {\n      char *filename = g_build_filename (g_get_user_config_dir (),\n                                         \"glib-2.0\", \"settings\", \"keyfile\",\n                                         NULL);\n      kfsb->file = g_file_new_for_path (filename);\n      g_free (filename);\n    }\n\n  if (kfsb->prefix == NULL)\n    {\n      kfsb->prefix = g_strdup (\"/\");\n      kfsb->prefix_len = 1;\n    }\n  \n  kfsb->keyfile = g_key_file_new ();\n  kfsb->permission = g_simple_permission_new (TRUE);\n\n  kfsb->dir = g_file_get_parent (kfsb->file);\n  g_mkdir_with_parents (g_file_peek_path (kfsb->dir), 0700);\n\n  kfsb->file_monitor = g_file_monitor (kfsb->file, G_FILE_MONITOR_NONE, NULL, NULL);\n  kfsb->dir_monitor = g_file_monitor (kfsb->dir, G_FILE_MONITOR_NONE, NULL, NULL);\n\n  compute_checksum (kfsb->digest, NULL, 0);\n\n  g_signal_connect (kfsb->file_monitor, \"changed\",\n                    G_CALLBACK (file_changed), kfsb);\n  g_signal_connect (kfsb->dir_monitor, \"changed\",\n                    G_CALLBACK (dir_changed), kfsb);\n\n  g_keyfile_settings_backend_keyfile_writable (kfsb);\n  g_keyfile_settings_backend_keyfile_reload (kfsb);\n\n  load_system_settings (kfsb);\n}", "target": 2, "idx": 10507}
{"commit_id": "b863de7fbf080b15e347a736fdda0a82d42f4f6b", "project": "krb5", "func": "kadm5_ret_t\nkadm5_modify_principal(void *server_handle,\n                       kadm5_principal_ent_t entry, long mask)\n{\n    int                     ret, ret2, i;\n    kadm5_policy_ent_rec    pol;\n    krb5_boolean            have_pol = FALSE;\n    krb5_db_entry           *kdb;\n    krb5_tl_data            *tl_data_orig;\n    osa_princ_ent_rec       adb;\n    kadm5_server_handle_t handle = server_handle;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    if(entry == NULL)\n        return EINVAL;\n    if((mask & KADM5_PRINCIPAL) || (mask & KADM5_LAST_PWD_CHANGE) ||\n       (mask & KADM5_MOD_TIME) || (mask & KADM5_MOD_NAME) ||\n       (mask & KADM5_MKVNO) || (mask & KADM5_AUX_ATTRIBUTES) ||\n       (mask & KADM5_KEY_DATA) || (mask & KADM5_LAST_SUCCESS) ||\n       (mask & KADM5_LAST_FAILED))\n        return KADM5_BAD_MASK;\n    if((mask & ~ALL_PRINC_MASK))\n        return KADM5_BAD_MASK;\n    if((mask & KADM5_POLICY) && entry->policy == NULL)\n        return KADM5_BAD_MASK;\n    if((mask & KADM5_POLICY) && (mask & KADM5_POLICY_CLR))\n        return KADM5_BAD_MASK;\n    if (mask & KADM5_TL_DATA) {\n        tl_data_orig = entry->tl_data;\n        while (tl_data_orig) {\n            if (tl_data_orig->tl_data_type < 256)\n                return KADM5_BAD_TL_TYPE;\n            tl_data_orig = tl_data_orig->tl_data_next;\n        }\n    }\n\n    ret = kdb_get_entry(handle, entry->principal, &kdb, &adb);\n    if (ret)\n        return(ret);\n\n    /*\n     * This is pretty much the same as create ...\n     */\n\n    if ((mask & KADM5_POLICY)) {\n        ret = get_policy(handle, entry->policy, &pol, &have_pol);\n        if (ret)\n            goto done;\n\n        /* set us up to use the new policy */\n        adb.aux_attributes |= KADM5_POLICY;\n        if (adb.policy)\n            free(adb.policy);\n        adb.policy = strdup(entry->policy);\n    }\n    if (have_pol) {\n        /* set pw_max_life based on new policy */\n        if (pol.pw_max_life) {\n            ret = krb5_dbe_lookup_last_pwd_change(handle->context, kdb,\n                                                  &(kdb->pw_expiration));\n            if (ret)\n                goto done;\n            kdb->pw_expiration += pol.pw_max_life;\n        } else {\n            kdb->pw_expiration = 0;\n        }\n    }\n\n    if ((mask & KADM5_POLICY_CLR) && (adb.aux_attributes & KADM5_POLICY)) {\n        free(adb.policy);\n        adb.policy = NULL;\n        adb.aux_attributes &= ~KADM5_POLICY;\n        kdb->pw_expiration = 0;\n    }\n\n    if ((mask & KADM5_ATTRIBUTES))\n        kdb->attributes = entry->attributes;\n    if ((mask & KADM5_MAX_LIFE))\n        kdb->max_life = entry->max_life;\n    if ((mask & KADM5_PRINC_EXPIRE_TIME))\n        kdb->expiration = entry->princ_expire_time;\n    if (mask & KADM5_PW_EXPIRATION)\n        kdb->pw_expiration = entry->pw_expiration;\n    if (mask & KADM5_MAX_RLIFE)\n        kdb->max_renewable_life = entry->max_renewable_life;\n\n    if((mask & KADM5_KVNO)) {\n        for (i = 0; i < kdb->n_key_data; i++)\n            kdb->key_data[i].key_data_kvno = entry->kvno;\n    }\n\n    if (mask & KADM5_TL_DATA) {\n        krb5_tl_data *tl;\n\n        /* may have to change the version number of the API. Updates the list with the given tl_data rather than over-writting */\n\n        for (tl = entry->tl_data; tl;\n             tl = tl->tl_data_next)\n        {\n            ret = krb5_dbe_update_tl_data(handle->context, kdb, tl);\n            if( ret )\n            {\n                goto done;\n            }\n        }\n    }\n\n    /*\n     * Setting entry->fail_auth_count to 0 can be used to manually unlock\n     * an account. It is not possible to set fail_auth_count to any other\n     * value using kadmin.\n     */\n    if (mask & KADM5_FAIL_AUTH_COUNT) {\n        if (entry->fail_auth_count != 0) {\n            ret = KADM5_BAD_SERVER_PARAMS;\n            goto done;\n        }\n\n        kdb->fail_auth_count = 0;\n    }\n\n    /* let the mask propagate to the database provider */\n    kdb->mask = mask;\n\n    ret = k5_kadm5_hook_modify(handle->context, handle->hook_handles,\n                               KADM5_HOOK_STAGE_PRECOMMIT, entry, mask);\n    if (ret)\n        goto done;\n\n    ret = kdb_put_entry(handle, kdb, &adb);\n    if (ret) goto done;\n    (void) k5_kadm5_hook_modify(handle->context, handle->hook_handles,\n                                KADM5_HOOK_STAGE_POSTCOMMIT, entry, mask);\n\n    ret = KADM5_OK;\ndone:\n    if (have_pol) {\n        ret2 = kadm5_free_policy_ent(handle->lhandle, &pol);\n        ret = ret ? ret : ret2;\n    }\n    kdb_free_entry(handle, kdb, &adb);\n    return ret;\n}", "target": 2, "idx": 10508}
{"commit_id": "84d4b53122e0fa0280c7872350b89d5777dabbb2", "project": "wolfSSL/wolfMQTT", "func": "static int MqttClient_WaitType(MqttClient *client, void *packet_obj,\n    byte wait_type, word16 wait_packet_id, int timeout_ms)\n{\n    int rc;\n    word16 packet_id;\n    MqttPacketType packet_type;\n#ifdef WOLFMQTT_MULTITHREAD\n    MqttPendResp *pendResp;\n    int readLocked;\n#endif\n    MqttMsgStat* mms_stat;\n    int waitMatchFound;\n\n    if (client == NULL || packet_obj == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* all packet type structures must have MqttMsgStat at top */\n    mms_stat = (MqttMsgStat*)packet_obj;\n\nwait_again:\n\n    /* initialize variables */\n    packet_id = 0;\n    packet_type = MQTT_PACKET_TYPE_RESERVED;\n#ifdef WOLFMQTT_MULTITHREAD\n    pendResp = NULL;\n    readLocked = 0;\n#endif\n    waitMatchFound = 0;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_WaitType: Type %s (%d), ID %d\",\n        MqttPacket_TypeDesc((MqttPacketType)wait_type),\n            wait_type, wait_packet_id);\n#endif\n\n    switch ((int)*mms_stat)\n    {\n        case MQTT_MSG_BEGIN:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock recv socket mutex */\n            rc = wm_SemLock(&client->lockRecv);\n            if (rc != 0) {\n                PRINTF(\"MqttClient_WaitType: recv lock error!\");\n                return rc;\n            }\n            readLocked = 1;\n        #endif\n\n            /* reset the packet state */\n            client->packet.stat = MQTT_PK_BEGIN;\n        }\n        FALL_THROUGH;\n\n    #ifdef WOLFMQTT_V5\n        case MQTT_MSG_AUTH:\n    #endif\n        case MQTT_MSG_WAIT:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if packet type and id have already completed */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, (MqttPacketType)wait_type, \n                    wait_packet_id, &pendResp)) {\n                    if (pendResp->packetDone) {\n                        /* pending response is already done, so return */\n                        rc = pendResp->packet_ret;\n                    #ifdef WOLFMQTT_DEBUG_CLIENT\n                        PRINTF(\"PendResp already Done %p: Rc %d\", pendResp, rc);\n                    #endif\n                        MqttClient_RespList_Remove(client, pendResp);\n                        wm_SemUnlock(&client->lockClient);\n                        wm_SemUnlock(&client->lockRecv);\n                        return rc;\n                    }\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            *mms_stat = MQTT_MSG_WAIT;\n\n            /* Wait for packet */\n            rc = MqttPacket_Read(client, client->rx_buf, client->rx_buf_len,\n                    timeout_ms);\n            /* handle failure */\n            if (rc <= 0) {\n                break;\n            }\n\n            /* capture length read */\n            client->packet.buf_len = rc;\n\n            /* Decode Packet - get type and id */\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, NULL, &packet_type, NULL, &packet_id);\n            if (rc < 0) {\n                break;\n            }\n\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"Read Packet: Len %d, Type %d, ID %d\",\n                client->packet.buf_len, packet_type, packet_id);\n        #endif\n\n            *mms_stat = MQTT_MSG_READ;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_READ:\n        case MQTT_MSG_READ_PAYLOAD:\n        {\n            MqttPacketType use_packet_type;\n            void* use_packet_obj;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            readLocked = 1; /* if in this state read is locked */\n        #endif\n\n            /* read payload state only happens for publish messages */\n            if (*mms_stat == MQTT_MSG_READ_PAYLOAD) {\n                packet_type = MQTT_PACKET_TYPE_PUBLISH;\n            }\n\n            /* Determine if we received data for this request */\n            if ((wait_type == MQTT_PACKET_TYPE_ANY ||\n                 wait_type == packet_type ||\n                 (MqttIsPubRespPacket(packet_type) &&\n                  MqttIsPubRespPacket(wait_type))) &&\n                (wait_packet_id == 0 || wait_packet_id == packet_id))\n            {\n                use_packet_obj = packet_obj;\n                waitMatchFound = 1;\n            }\n            else {\n                /* use generic packet object */\n                use_packet_obj = &client->msg;\n            }\n            use_packet_type = packet_type;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if we have a pending response for this packet */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, packet_type, packet_id,\n                                                               &pendResp)) {\n                    /* we found packet match this incoming read packet */\n                    pendResp->packetProcessing = 1;\n                    use_packet_obj = pendResp->packet_obj;\n                    use_packet_type = pendResp->packet_type;\n                    /* req from another thread... not a match */\n                    waitMatchFound = 0;\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            /* Perform packet handling for publish callback and QoS */\n            rc = MqttClient_HandlePacket(client, use_packet_type,\n                use_packet_obj, timeout_ms);\n\n        #ifdef WOLFMQTT_NONBLOCK\n            if (rc == MQTT_CODE_CONTINUE) {\n                /* we have received some data, so keep the recv\n                    mutex lock active and return */\n                return rc;\n            }\n        #endif\n\n            /* handle success case */\n            if (rc >= 0) {\n                rc = MQTT_CODE_SUCCESS;\n            }\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (pendResp) {\n                /* Mark pending response entry done */\n                if (wm_SemLock(&client->lockClient) == 0) {\n                    pendResp->packetDone = 1;\n                    pendResp->packet_ret = rc;\n                #ifdef WOLFMQTT_DEBUG_CLIENT\n                    PRINTF(\"PendResp Done %p\", pendResp);\n                #endif\n                    pendResp = NULL;\n                    wm_SemUnlock(&client->lockClient);\n                }\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n            break;\n        }\n\n        case MQTT_MSG_WRITE:\n        case MQTT_MSG_WRITE_PAYLOAD:\n        default:\n        {\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_WaitType: Invalid state %d!\", *mms_stat);\n        #endif\n            rc = MQTT_CODE_ERROR_STAT;\n            break;\n        }\n    } /* switch (*mms_stat) */\n\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc != MQTT_CODE_CONTINUE)\n#endif\n    {\n        /* reset state */\n        *mms_stat = MQTT_MSG_BEGIN;\n    }\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (readLocked) {\n        wm_SemUnlock(&client->lockRecv);\n    }\n#endif\n    if (rc < 0) {\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_WaitType: Failure: %s (%d)\",\n            MqttClient_ReturnCodeToString(rc), rc);\n    #endif\n        return rc;\n    }\n\n    if (!waitMatchFound) {\n        /* if we get here, then the we are still waiting for a packet */\n        goto wait_again;\n    }\n\n    return rc;\n}", "target": 1, "idx": 10509}
{"commit_id": "5ce30801f9ccc372bbe9b7c98bb5324b15fb010a", "project": "CESNET/libyang", "func": "void\nlys_node_free(struct ly_ctx *ctx, struct lys_node *node,\n              void (*private_destructor)(const struct lys_node *node, void *priv), int shallow)\n{\n    struct lys_node *sub, *next;\n\n    if (!node) {\n        return;\n    }\n\n    /* remove private object */\n    if (node->priv && private_destructor) {\n        private_destructor(node, node->priv);\n    }\n\n    /* common part */\n    lydict_remove(ctx, node->name);\n    if (!(node->nodetype & (LYS_INPUT | LYS_OUTPUT))) {\n        lys_iffeature_free(ctx, node->iffeature, node->iffeature_size, shallow, private_destructor);\n        lydict_remove(ctx, node->dsc);\n        lydict_remove(ctx, node->ref);\n    }\n\n    if (!shallow && !(node->nodetype & (LYS_LEAF | LYS_LEAFLIST))) {\n        LY_TREE_FOR_SAFE(node->child, next, sub) {\n            lys_node_free(ctx, sub, private_destructor, 0);\n        }\n    }\n\n    lys_extension_instances_free(ctx, node->ext, node->ext_size, private_destructor);\n\n    /* specific part */\n    switch (node->nodetype) {\n    case LYS_CONTAINER:\n        lys_container_free(ctx, (struct lys_node_container *)node, private_destructor);\n        break;\n    case LYS_CHOICE:\n        lys_when_free(ctx, ((struct lys_node_choice *)node)->when, private_destructor);\n        break;\n    case LYS_LEAF:\n        lys_leaf_free(ctx, (struct lys_node_leaf *)node, private_destructor);\n        break;\n    case LYS_LEAFLIST:\n        lys_leaflist_free(ctx, (struct lys_node_leaflist *)node, private_destructor);\n        break;\n    case LYS_LIST:\n        lys_list_free(ctx, (struct lys_node_list *)node, private_destructor);\n        break;\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n        lys_anydata_free(ctx, (struct lys_node_anydata *)node, private_destructor);\n        break;\n    case LYS_USES:\n        lys_uses_free(ctx, (struct lys_node_uses *)node, private_destructor);\n        break;\n    case LYS_CASE:\n        lys_when_free(ctx, ((struct lys_node_case *)node)->when, private_destructor);\n        break;\n    case LYS_AUGMENT:\n        /* do nothing */\n        break;\n    case LYS_GROUPING:\n        lys_grp_free(ctx, (struct lys_node_grp *)node, private_destructor);\n        break;\n    case LYS_RPC:\n    case LYS_ACTION:\n        lys_rpc_action_free(ctx, (struct lys_node_rpc_action *)node, private_destructor);\n        break;\n    case LYS_NOTIF:\n        lys_notif_free(ctx, (struct lys_node_notif *)node, private_destructor);\n        break;\n    case LYS_INPUT:\n    case LYS_OUTPUT:\n        lys_inout_free(ctx, (struct lys_node_inout *)node, private_destructor);\n        break;\n    case LYS_EXT:\n    case LYS_UNKNOWN:\n        LOGINT(ctx);\n        break;\n    }\n\n    /* again common part */\n    lys_node_unlink(node);\n    free(node);\n}", "target": 2, "idx": 10510}
{"commit_id": "bb8334104baf4d5a4a442a8647fb9204738f2204", "project": "OpenRC/openrc", "func": "static char *clean_path(char *path)\n{\n\tchar *ch;\n\tchar *ch2;\n\tchar *str;\n\tstr = xmalloc(strlen(path) + 1);\n\tch = path;\n\tch2 = str;\n\twhile (true) {\n\t\t*ch2 = *ch;\n\t\tch++;\n\t\tch2++;\n\t\tif (!*(ch-1))\n\t\t\tbreak;\n\t\twhile (*(ch - 1) == '/' && *ch == '/')\n\t\t\tch++;\n\t}\n\t/* get rid of trailing / characters */\n\twhile ((ch = strrchr(str, '/'))) {\n\t\tif (ch == str)\n\t\t\tbreak;\n\t\tif (!*(ch+1))\n\t\t\t*ch = 0;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn str;\n}", "target": 2, "idx": 10511}
{"commit_id": "6976bdc8ee9dd2c2954f91066f7b0f643769a379", "project": "GNOME/gdk-pixbuf", "func": "GdkPixbuf*\ngdk_pixbuf_gif_anim_iter_get_pixbuf (GdkPixbufAnimationIter *anim_iter)\n{\n        GdkPixbufGifAnimIter *iter = GDK_PIXBUF_GIF_ANIM_ITER (anim_iter);\n        GdkPixbufGifAnim *anim = iter->gif_anim;\n        GdkPixbufFrame *requested_frame;\n        GList *link;\n\n        if (iter->current_frame != NULL)\n                requested_frame = iter->current_frame->data;\n        else\n                requested_frame = g_list_last (anim->frames)->data;\n\n        /* If the previously rendered frame is not before this one, then throw it away */\n        if (anim->last_frame != NULL) {\n                link = g_list_find (anim->frames, anim->last_frame);\n                while (link != NULL && link->data != requested_frame)\n                        link = link->next;\n                if (link == NULL)\n                        anim->last_frame = NULL;\n        }\n\n        /* If no rendered frame, render the first frame */\n        if (anim->last_frame == NULL) {\n                gsize len = 0;\n                if (anim->last_frame_data == NULL)\n                        anim->last_frame_data = gdk_pixbuf_new (GDK_COLORSPACE_RGB, TRUE, 8, anim->width, anim->height);\n                if (anim->last_frame_data == NULL)\n                        return NULL;\n                if (g_size_checked_mul (&len, gdk_pixbuf_get_rowstride (anim->last_frame_data), anim->height))\n                        memset (gdk_pixbuf_get_pixels (anim->last_frame_data), 0, len);\n                else\n                        return NULL;\n                composite_frame (anim, g_list_nth_data (anim->frames, 0));\n        }\n\n        /* If the requested frame is already rendered, then no action required */\n        if (requested_frame == anim->last_frame)\n                return anim->last_frame_data;\n\n        /* Starting from the last rendered frame, render to the current frame */\n        for (link = g_list_find (anim->frames, anim->last_frame); link->next != NULL && link->data != requested_frame; link = link->next) {\n                GdkPixbufFrame *frame = link->data;\n                guchar *pixels;\n                int y, x_end, y_end;\n\n                /* Remove last frame if required */\n                switch (frame->action) {\n                case GDK_PIXBUF_FRAME_RETAIN:\n                        break;\n                case GDK_PIXBUF_FRAME_DISPOSE:\n                        /* Replace previous area with background */\n                        pixels = gdk_pixbuf_get_pixels (anim->last_frame_data);\n                        x_end = MIN (anim->last_frame->x_offset + anim->last_frame->width, anim->width);\n                        y_end = MIN (anim->last_frame->y_offset + anim->last_frame->height, anim->height);\n                        for (y = anim->last_frame->y_offset; y < y_end; y++) {\n                                gsize offset;\n                                if (g_size_checked_mul (&offset, gdk_pixbuf_get_rowstride (anim->last_frame_data), y) &&\n                                    g_size_checked_add (&offset, offset, anim->last_frame->x_offset * 4)) {\n                                         memset (pixels + offset, 0, (x_end - anim->last_frame->x_offset) * 4);\n                                }\n                        }\n                        break;\n                case GDK_PIXBUF_FRAME_REVERT:\n                        /* Replace previous area with last retained area */\n                        if (anim->last_frame_revert_data != NULL)\n                                gdk_pixbuf_copy_area (anim->last_frame_revert_data,\n                                                      0, 0, anim->last_frame->width, anim->last_frame->height,\n                                                      anim->last_frame_data,\n                                                      anim->last_frame->x_offset, anim->last_frame->y_offset);\n                        break;\n                }\n\n                /* Render next frame */\n                composite_frame (anim, link->next->data);\n        }\n\n        return anim->last_frame_data;\n}", "target": 2, "idx": 10512}
{"commit_id": "4deb051cb0277d32ab402da4f941f6e502518388", "project": "fluent/fluent-bit", "func": "static void cb_mq_metrics(mk_mq_t *queue, void *data, size_t size)\n{\n    flb_sds_t out_data;\n    struct flb_hs_buf *buf;\n    struct mk_list *metrics_list = NULL;\n\n    metrics_list = pthread_getspecific(hs_metrics_key);\n    if (!metrics_list) {\n        metrics_list = flb_malloc(sizeof(struct mk_list));\n        if (!metrics_list) {\n            flb_errno();\n            return;\n        }\n        mk_list_init(metrics_list);\n        pthread_setspecific(hs_metrics_key, metrics_list);\n    }\n\n    /* Convert msgpack to JSON */\n    out_data = flb_msgpack_raw_to_json_sds(data, size);\n    if (!out_data) {\n        return;\n    }\n\n    buf = flb_malloc(sizeof(struct flb_hs_buf));\n    if (!buf) {\n        flb_errno();\n        flb_sds_destroy(out_data);\n        return;\n    }\n    buf->users = 0;\n    buf->data = out_data;\n\n    buf->raw_data = flb_malloc(size);\n    if (!buf->raw_data) {\n        flb_errno();\n        flb_sds_destroy(out_data);\n        flb_free(buf);\n        return;\n    }\n    memcpy(buf->raw_data, data, size);\n    buf->raw_size = size;\n\n    mk_list_add(&buf->_head, metrics_list);\n\n    cleanup_metrics();\n}", "target": 2, "idx": 10513}
{"commit_id": "c59c37e7b2d563967da813fa50fe20b21f4da683", "project": "tensorflow", "func": "TfLiteStatus ResizeOutput(TfLiteContext* context, const TfLiteTensor* input,\n                          const TfLiteTensor* axis, TfLiteTensor* output) {\n  int axis_value;\n  // Retrive all 8 bytes when axis type is kTfLiteInt64 to avoid data loss.\n  if (axis->type == kTfLiteInt64) {\n    axis_value = static_cast<int>(*GetTensorData<int64_t>(axis));\n  } else {\n    axis_value = *GetTensorData<int>(axis);\n  }\n  if (axis_value < 0) {\n    axis_value += NumDimensions(input);\n  }\n\n  TF_LITE_ENSURE(context, axis_value >= 0);\n  TF_LITE_ENSURE(context, axis_value < NumDimensions(input));\n\n  // Copy the input dimensions to output except the axis dimension.\n  TfLiteIntArray* output_dims = TfLiteIntArrayCreate(NumDimensions(input) - 1);\n  int j = 0;\n  for (int i = 0; i < NumDimensions(input); ++i) {\n    if (i != axis_value) {\n      output_dims->data[j] = SizeOfDimension(input, i);\n      ++j;\n    }\n  }\n  return context->ResizeTensor(context, output, output_dims);\n}", "target": 0, "idx": 10514}
{"commit_id": "7873f8334c8d31031f8cfa83bd97ac6029309e4f", "project": "sudo-project/sudo", "func": "int\nsudo_auth_init(const struct sudoers_context *ctx, struct passwd *pw,\n    unsigned int mode)\n{\n    sudo_auth *auth;\n    int status = AUTH_SUCCESS;\n    debug_decl(sudo_auth_init, SUDOERS_DEBUG_AUTH);\n\n    if (auth_switch[0].name == NULL)\n\tdebug_return_int(0);\n\n    /* Initialize auth methods and unconfigure the method if necessary. */\n    for (auth = auth_switch; auth->name; auth++) {\n\tif (ISSET(mode, MODE_NONINTERACTIVE))\n\t    SET(auth->flags, FLAG_NONINTERACTIVE);\n\tif (auth->init && !IS_DISABLED(auth)) {\n\t    /* Disable if it failed to init unless there was a fatal error. */\n\t    status = (auth->init)(ctx, pw, auth);\n\t    switch (status) {\n\t    case AUTH_SUCCESS:\n\t\tbreak;\n\t    case AUTH_FAILURE:\n\t\tSET(auth->flags, FLAG_DISABLED);\n\t\tbreak;\n\t    default:\n\t\t/* Assume error msg already printed. */\n\t\tdebug_return_int(-1);\n\t    }\n\t}\n    }\n\n    /*\n     * Make sure we haven't mixed standalone and shared auth methods.\n     * If there are multiple standalone methods, only use the first one.\n     */\n    if ((standalone = IS_STANDALONE(&auth_switch[0]))) {\n\tbool found = false;\n\tfor (auth = auth_switch; auth->name; auth++) {\n\t    if (IS_DISABLED(auth))\n\t\tcontinue;\n\t    if (!IS_STANDALONE(auth)) {\n\t\taudit_failure(ctx, ctx->runas.argv,\n\t\t    N_(\"invalid authentication methods\"));\n\t\tlog_warningx(ctx, SLOG_SEND_MAIL,\n\t\t    N_(\"Invalid authentication methods compiled into sudo!  \"\n\t\t    \"You may not mix standalone and non-standalone authentication.\"));\n\t\tdebug_return_int(-1);\n\t    }\n\t    if (!found) {\n\t\t/* Found first standalone method. */\n\t\tfound = true;\n\t\tcontinue;\n\t    }\n\t    /* Disable other standalone methods. */\n\t    SET(auth->flags, FLAG_DISABLED);\n\t}\n    }\n\n    /* Set FLAG_ONEANDONLY if there is only one auth method. */\n    for (auth = auth_switch; auth->name; auth++) {\n\t/* Find first enabled auth method. */\n\tif (!IS_DISABLED(auth)) {\n\t    sudo_auth *first = auth;\n\t    /* Check for others. */\n\t    for (; auth->name; auth++) {\n\t\tif (!IS_DISABLED(auth))\n\t\t    break;\n\t    }\n\t    if (auth->name == NULL)\n\t\tSET(first->flags, FLAG_ONEANDONLY);\n\t    break;\n\t}\n    }\n\n    debug_return_int(0);\n}", "target": 2, "idx": 10515}
{"commit_id": "f2cd18bc2e1cbca8c4b78bee9c392272bd5f42ac", "project": "rtcwcoop", "func": "void AICast_ScriptParse( cast_state_t *cs ) {\n\tgentity_t   *ent;\n\tchar        *pScript;\n\tchar        *token;\n\tqboolean wantName;\n\tqboolean inScript;\n\tint eventNum;\n\tint numEventItems;\n\tcast_script_event_t *curEvent;\n\tchar params[MAX_QPATH];\n\tcast_script_stack_action_t  *action;\n\tint i;\n\tint bracketLevel;\n\tqboolean buildScript;       //----(SA)\tadded\n\n\tif ( !level.scriptAI ) {\n\t\treturn;\n\t}\n\n\tent = &g_entities[cs->entityNum];\n\tif ( !ent->aiName ) {\n\t\treturn;\n\t}\n\n\tbuildScript = qtrue;\n\n\tpScript = level.scriptAI;\n\twantName = qtrue;\n\tinScript = qfalse;\n\tCOM_BeginParseSession( \"AICast_ScriptParse\" );\n\tbracketLevel = 0;\n\tnumEventItems = 0;\n\n\tmemset( cast_temp_events, 0, sizeof( cast_temp_events ) );\n\n\twhile ( 1 )\n\t{\n\t\ttoken = COM_Parse( &pScript );\n\n\t\tif ( !token[0] ) {\n\t\t\tif ( !wantName ) {\n\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): '}' expected, end of script found.\\n\", COM_GetCurrentParseLine() );\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t// end of script\n\t\tif ( token[0] == '}' ) {\n\t\t\tif ( inScript ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( wantName ) {\n\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): '}' found, but not expected.\\n\", COM_GetCurrentParseLine() );\n\t\t\t}\n\t\t\twantName = qtrue;\n\t\t} else if ( token[0] == '{' )    {\n\t\t\tif ( wantName ) {\n\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): '{' found, NAME expected.\\n\", COM_GetCurrentParseLine() );\n\t\t\t}\n\t\t} else if ( wantName )   {\n\t\t\tif ( !Q_strcasecmp( ent->aiName, token ) ) {\n\t\t\t\tinScript = qtrue;\n\t\t\t\tnumEventItems = 0;\n\t\t\t}\n\t\t\twantName = qfalse;\n\t\t} else if ( inScript )   {\n\t\t\tif ( !Q_strcasecmp( token, \"attributes\" ) ) {\n\t\t\t\t// read in all the attributes\n\t\t\t\tAICast_CheckLevelAttributes( cs, ent, &pScript );\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\teventNum = AICast_EventForString( token );\n\t\t\tif ( eventNum < 0 ) {\n\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): unknown event: %s.\\n\", COM_GetCurrentParseLine(), token );\n\t\t\t}\n\t\t\tif ( numEventItems >= MAX_SCRIPT_EVENTS ) {\n\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): MAX_SCRIPT_EVENTS reached (%d)\\n\", COM_GetCurrentParseLine(), MAX_SCRIPT_EVENTS );\n\t\t\t}\n\n\t\t\t// if this is a \"friendlysightcorpse\" event, then disable corpse vis sharing\n\t\t\tif ( !Q_stricmp( token, \"friendlysightcorpse\" ) ) {\n\t\t\t\tcs->aiFlags &= ~AIFL_CORPSESIGHTING;\n\t\t\t}\n\n\t\t\tcurEvent = &cast_temp_events[numEventItems];\n\t\t\tcurEvent->eventNum = eventNum;\n\t\t\tmemset( params, 0, sizeof( params ) );\n\n\t\t\t// parse any event params before the start of this event's actions\n\t\t\twhile ( ( token = COM_Parse( &pScript ) ) && ( token[0] != '{' ) )\n\t\t\t{\n\t\t\t\tif ( !token[0] ) {\n\t\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): '}' expected, end of script found.\\n\", COM_GetCurrentParseLine() );\n\t\t\t\t}\n\n\t\t\t\tif ( eventNum == 13 ) {   // statechange event, check params\n\t\t\t\t\tif ( strlen( token ) > 1 ) {\n\t\t\t\t\t\tif ( BG_IndexForString( token, animStateStr, qtrue ) < 0 ) {\n\t\t\t\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): unknown state type '%s'.\\n\", COM_GetCurrentParseLine(), token );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( strlen( params ) ) { // add a space between each param\n\t\t\t\t\tQ_strcat( params, sizeof( params ), \" \" );\n\t\t\t\t}\n\t\t\t\tQ_strcat( params, sizeof( params ), token );\n\t\t\t}\n\n\t\t\tif ( strlen( params ) ) { // copy the params into the event\n\t\t\t\tcurEvent->params = trap_Alloc( strlen( params ) + 1 );\n\t\t\t\tQ_strncpyz( curEvent->params, params, strlen( params ) + 1 );\n\t\t\t}\n\n\t\t\t// parse the actions for this event\n\t\t\twhile ( ( token = COM_Parse( &pScript ) ) && ( token[0] != '}' ) )\n\t\t\t{\n\t\t\t\tif ( !token[0] ) {\n\t\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): '}' expected, end of script found.\\n\", COM_GetCurrentParseLine() );\n\t\t\t\t}\n\n\t\t\t\taction = AICast_ActionForString( cs, token );\n\t\t\t\tif ( !action ) {\n\t\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): unknown action: %s.\\n\", COM_GetCurrentParseLine(), token );\n\t\t\t\t}\n\n\t\t\t\tcurEvent->stack.items[curEvent->stack.numItems].action = action;\n\n\t\t\t\tmemset( params, 0, sizeof( params ) );\n\t\t\t\ttoken = COM_ParseExt( &pScript, qfalse );\n\t\t\t\tfor ( i = 0; token[0]; i++ )\n\t\t\t\t{\n\t\t\t\t\tif ( strlen( params ) ) { // add a space between each param\n\t\t\t\t\t\tQ_strcat( params, sizeof( params ), \" \" );\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( i == 0 ) {\n\t\t\t\t\t\t// Special case: playsound's need to be cached on startup to prevent in-game pauses\n\t\t\t\t\t\tif ( !Q_stricmp( action->actionString, \"playsound\" ) ) {\n\t\t\t\t\t\t\tG_SoundIndex( token );\n\t\t\t\t\t\t}\n\n//----(SA)\tadded a bit more\n\t\t\t\t\t\tif (    buildScript && (\n\t\t\t\t\t\t\t\t\t!Q_stricmp( action->actionString, \"mu_start\" ) ||\n\t\t\t\t\t\t\t\t\t!Q_stricmp( action->actionString, \"mu_play\" ) ||\n\t\t\t\t\t\t\t\t\t!Q_stricmp( action->actionString, \"mu_queue\" ) ||\n\t\t\t\t\t\t\t\t\t!Q_stricmp( action->actionString, \"startcam\" ) ||\n\t\t\t\t\t\t\t\t\t!Q_stricmp( action->actionString, \"startcamblack\" ) )\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tif ( strlen( token ) ) { // we know there's a [0], but don't know if it's '0'\n\t\t\t\t\t\t\t\ttrap_SendServerCommand( cs->entityNum, va( \"addToBuild %s\\n\", token ) );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( !Q_stricmp( action->actionString, \"giveweapon\" ) ) { // register weapon for client pre-loading\n\t\t\t\t\t\t\tgitem_t *weap = BG_FindItem2( token );    // (SA) FIXME: rats, need to fix this for weapon names with spaces: 'mauser rifle'\n//\t\t\t\t\t\t\tif(weap)\n\t\t\t\t\t\t\tRegisterItem( weap );   // don't be nice, just do it.  if it can't find it, you'll bomb out to the error menu\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// need to get this for callvote nextmap\n\t\t\t\t\t\tif ( !Q_stricmp( action->actionString, \"changelevel\" ) ) {\n\t\t\t\t\t\t\tQ_strncpyz( level.nextMap, token, sizeof( level.nextMap ) );\n\t\t\t\t\t\t\ttrap_Cvar_Set( \"nextmap\", level.nextMap );\n\t\t\t\t\t\t}\n//----(SA)\tend\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( strrchr( token,' ' ) ) { // need to wrap this param in quotes since it has more than one word\n\t\t\t\t\t\tQ_strcat( params, sizeof( params ), \"\\\"\" );\n\t\t\t\t\t}\n\n\t\t\t\t\tQ_strcat( params, sizeof( params ), token );\n\n\t\t\t\t\tif ( strrchr( token,' ' ) ) { // need to wrap this param in quotes since it has more than one word\n\t\t\t\t\t\tQ_strcat( params, sizeof( params ), \"\\\"\" );\n\t\t\t\t\t}\n\n\t\t\t\t\ttoken = COM_ParseExt( &pScript, qfalse );\n\t\t\t\t}\n\n\t\t\t\tif ( strlen( params ) ) { // copy the params into the event\n\t\t\t\t\tcurEvent->stack.items[curEvent->stack.numItems].params = trap_Alloc( strlen( params ) + 1 );\n\t\t\t\t\tQ_strncpyz( curEvent->stack.items[curEvent->stack.numItems].params, params, strlen( params ) + 1 );\n\t\t\t\t}\n\n\t\t\t\tcurEvent->stack.numItems++;\n\n\t\t\t\tif ( curEvent->stack.numItems >= AICAST_MAX_SCRIPT_STACK_ITEMS ) {\n\t\t\t\t\tG_Error( \"AICast_ScriptParse(): script exceeded MAX_SCRIPT_ITEMS (%d), line %d\\n\", AICAST_MAX_SCRIPT_STACK_ITEMS, COM_GetCurrentParseLine() );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnumEventItems++;\n\t\t} else    // skip this character completely\n\t\t{\n\n\t\t\twhile ( ( token = COM_Parse( &pScript ) ) )\n\t\t\t{\n\t\t\t\tif ( !token[0] ) {\n\t\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): '}' expected, end of script found.\\n\", COM_GetCurrentParseLine() );\n\t\t\t\t} else if ( token[0] == '{' ) {\n\t\t\t\t\tbracketLevel++;\n\t\t\t\t} else if ( token[0] == '}' ) {\n\t\t\t\t\tif ( !--bracketLevel ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// alloc and copy the events into the cast_state_t for this cast\n\tif ( numEventItems > 0 ) {\n\t\tcs->castScriptEvents = trap_Alloc( sizeof( cast_script_event_t ) * numEventItems );\n\t\tmemcpy( cs->castScriptEvents, cast_temp_events, sizeof( cast_script_event_t ) * numEventItems );\n\t\tcs->numCastScriptEvents = numEventItems;\n\n\t\tcs->castScriptStatus.castScriptEventIndex = -1;\n\t}\n}", "target": 2, "idx": 10516}
{"commit_id": "096cdc6f52225835ff503f987a0d68ef770bb78e", "project": "torvalds/linux", "func": "static long ec_device_ioctl_xcmd(struct cros_ec_dev *ec, void __user *arg)\n{\n\tlong ret;\n\tstruct cros_ec_command u_cmd;\n\tstruct cros_ec_command *s_cmd;\n\n\tif (copy_from_user(&u_cmd, arg, sizeof(u_cmd)))\n\t\treturn -EFAULT;\n\n\tif ((u_cmd.outsize > EC_MAX_MSG_BYTES) ||\n\t    (u_cmd.insize > EC_MAX_MSG_BYTES))\n\t\treturn -EINVAL;\n\n\ts_cmd = kmalloc(sizeof(*s_cmd) + max(u_cmd.outsize, u_cmd.insize),\n\t\t\tGFP_KERNEL);\n\tif (!s_cmd)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(s_cmd, arg, sizeof(*s_cmd) + u_cmd.outsize)) {\n\t\tret = -EFAULT;\n\t\tgoto exit;\n\t}\n\n\tif (u_cmd.outsize != s_cmd->outsize ||\n\t    u_cmd.insize != s_cmd->insize) {\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\ts_cmd->command += ec->cmd_offset;\n\tret = cros_ec_cmd_xfer(ec->ec_dev, s_cmd);\n\t/* Only copy data to userland if data was received. */\n\tif (ret < 0)\n\t\tgoto exit;\n\n\tif (copy_to_user(arg, s_cmd, sizeof(*s_cmd) + s_cmd->insize))\n\t\tret = -EFAULT;\nexit:\n\tkfree(s_cmd);\n\treturn ret;\n}", "target": 1, "idx": 10517}
{"commit_id": "768d612f79822d30a1e7d132a4d4b05337ce42ec", "project": "torvalds/linux", "func": "void ext4_es_insert_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t   ext4_lblk_t len, ext4_fsblk_t pblk,\n\t\t\t   unsigned int status)\n{\n\tstruct extent_status newes;\n\text4_lblk_t end = lblk + len - 1;\n\tint err1 = 0;\n\tint err2 = 0;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct extent_status *es1 = NULL;\n\tstruct extent_status *es2 = NULL;\n\n\tif (EXT4_SB(inode->i_sb)->s_mount_state & EXT4_FC_REPLAY)\n\t\treturn;\n\n\tes_debug(\"add [%u/%u) %llu %x to extent status tree of inode %lu\\n\",\n\t\t lblk, len, pblk, status, inode->i_ino);\n\n\tif (!len)\n\t\treturn;\n\n\tBUG_ON(end < lblk);\n\n\tif ((status & EXTENT_STATUS_DELAYED) &&\n\t    (status & EXTENT_STATUS_WRITTEN)) {\n\t\text4_warning(inode->i_sb, \"Inserting extent [%u/%u] as \"\n\t\t\t\t\" delayed and written which can potentially \"\n\t\t\t\t\" cause data loss.\", lblk, len);\n\t\tWARN_ON(1);\n\t}\n\n\tnewes.es_lblk = lblk;\n\tnewes.es_len = len;\n\text4_es_store_pblock_status(&newes, pblk, status);\n\ttrace_ext4_es_insert_extent(inode, &newes);\n\n\text4_es_insert_extent_check(inode, &newes);\n\nretry:\n\tif (err1 && !es1)\n\t\tes1 = __es_alloc_extent(true);\n\tif ((err1 || err2) && !es2)\n\t\tes2 = __es_alloc_extent(true);\n\twrite_lock(&EXT4_I(inode)->i_es_lock);\n\n\terr1 = __es_remove_extent(inode, lblk, end, NULL, es1);\n\tif (err1 != 0)\n\t\tgoto error;\n\t/* Free preallocated extent if it didn't get used. */\n\tif (es1) {\n\t\tif (!es1->es_len)\n\t\t\t__es_free_extent(es1);\n\t\tes1 = NULL;\n\t}\n\n\terr2 = __es_insert_extent(inode, &newes, es2);\n\tif (err2 == -ENOMEM && !ext4_es_must_keep(&newes))\n\t\terr2 = 0;\n\tif (err2 != 0)\n\t\tgoto error;\n\t/* Free preallocated extent if it didn't get used. */\n\tif (es2) {\n\t\tif (!es2->es_len)\n\t\t\t__es_free_extent(es2);\n\t\tes2 = NULL;\n\t}\n\n\tif (sbi->s_cluster_ratio > 1 && test_opt(inode->i_sb, DELALLOC) &&\n\t    (status & EXTENT_STATUS_WRITTEN ||\n\t     status & EXTENT_STATUS_UNWRITTEN))\n\t\t__revise_pending(inode, lblk, len);\nerror:\n\twrite_unlock(&EXT4_I(inode)->i_es_lock);\n\tif (err1 || err2)\n\t\tgoto retry;\n\n\text4_es_print_tree(inode);\n\treturn;\n}", "target": 2, "idx": 10518}
{"commit_id": "b9882f4fbcc5f6a9cea49f5c2ec6b91aafac1032", "project": "pdfium", "func": "static void sycc422_to_rgb(opj_image_t* img) {\n  int prec = img->comps[0].prec;\n  int offset = 1 << (prec - 1);\n  int upb = (1 << prec) - 1;\n  OPJ_UINT32 maxw =\n      std::min(std::min(img->comps[0].w, img->comps[1].w), img->comps[2].w);\n  OPJ_UINT32 maxh =\n      std::min(std::min(img->comps[0].h, img->comps[1].h), img->comps[2].h);\n  FX_SAFE_SIZE_T max_size = maxw;\n  max_size *= maxh;\n  if (!max_size.IsValid())\n    return;\n\n  const int* y = img->comps[0].data;\n  const int* cb = img->comps[1].data;\n  const int* cr = img->comps[2].data;\n  int *d0, *d1, *d2, *r, *g, *b;\n  d0 = r = FX_Alloc(int, max_size.ValueOrDie());\n  d1 = g = FX_Alloc(int, max_size.ValueOrDie());\n  d2 = b = FX_Alloc(int, max_size.ValueOrDie());\n  for (uint32_t i = 0; i < maxh; ++i) {\n    OPJ_UINT32 j;\n    for (j = 0; j < (maxw & ~static_cast<OPJ_UINT32>(1)); j += 2) {\n      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n      ++y;\n      ++r;\n      ++g;\n      ++b;\n      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n      ++y;\n      ++r;\n      ++g;\n      ++b;\n      ++cb;\n      ++cr;\n    }\n    if (j < maxw) {\n      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n      ++y;\n      ++r;\n      ++g;\n      ++b;\n      ++cb;\n      ++cr;\n    }\n  }\n  FX_Free(img->comps[0].data);\n  img->comps[0].data = d0;\n  FX_Free(img->comps[1].data);\n  img->comps[1].data = d1;\n  FX_Free(img->comps[2].data);\n  img->comps[2].data = d2;\n  img->comps[1].w = maxw;\n  img->comps[1].h = maxh;\n  img->comps[2].w = maxw;\n  img->comps[2].h = maxh;\n  img->comps[1].dx = img->comps[0].dx;\n  img->comps[2].dx = img->comps[0].dx;\n  img->comps[1].dy = img->comps[0].dy;\n  img->comps[2].dy = img->comps[0].dy;\n}", "target": 2, "idx": 10519}
{"commit_id": "364f997b5cfe1db0d63a390fe7c801fa2b3115f6", "project": "torvalds/linux", "func": "int inet_dgram_connect(struct socket *sock, struct sockaddr *uaddr,\n\t\t       int addr_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tconst struct proto *prot;\n\tint err;\n\n\tif (addr_len < sizeof(uaddr->sa_family))\n\t\treturn -EINVAL;\n\n\t/* IPV6_ADDRFORM can change sk->sk_prot under us. */\n\tprot = READ_ONCE(sk->sk_prot);\n\n\tif (uaddr->sa_family == AF_UNSPEC)\n\t\treturn prot->disconnect(sk, flags);\n\n\tif (BPF_CGROUP_PRE_CONNECT_ENABLED(sk)) {\n\t\terr = prot->pre_connect(sk, uaddr, addr_len);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (data_race(!inet_sk(sk)->inet_num) && inet_autobind(sk))\n\t\treturn -EAGAIN;\n\treturn prot->connect(sk, uaddr, addr_len);\n}", "target": 1, "idx": 10520}
{"commit_id": "b8627c9d13884d48943d8a7a5381eaf0bb2c08d9", "project": "pdfium", "func": "CFX_PathData* CFX_Font::LoadGlyphPath(uint32_t glyph_index, int dest_width) {\n  if (!m_Face) {\n    return NULL;\n  }\n  FXFT_Set_Pixel_Sizes(m_Face, 0, 64);\n  FXFT_Matrix ft_matrix = {65536, 0, 0, 65536};\n  if (m_pSubstFont) {\n    if (m_pSubstFont->m_ItalicAngle) {\n      int skew = m_pSubstFont->m_ItalicAngle;\n      // |skew| is nonpositive so |-skew| is used as the index. We need to make\n      // sure |skew| != INT_MIN since -INT_MIN is undefined.\n      if (skew <= 0 && skew != std::numeric_limits<int>::min() &&\n          static_cast<size_t>(-skew) < ANGLESKEW_ARRAY_SIZE) {\n        skew = -g_AngleSkew[-skew];\n      } else {\n        skew = -58;\n      }\n      if (m_bVertical)\n        ft_matrix.yx += ft_matrix.yy * skew / 100;\n      else\n        ft_matrix.xy += -ft_matrix.xx * skew / 100;\n    }\n    if (m_pSubstFont->m_SubstFlags & FXFONT_SUBST_MM) {\n      AdjustMMParams(glyph_index, dest_width, m_pSubstFont->m_Weight);\n    }\n  }\n  ScopedFontTransform scoped_transform(m_Face, &ft_matrix);\n  int load_flags = FXFT_LOAD_NO_BITMAP;\n  if (!(m_Face->face_flags & FT_FACE_FLAG_SFNT) || !FT_IS_TRICKY(m_Face)) {\n    load_flags |= FT_LOAD_NO_HINTING;\n  }\n  if (FXFT_Load_Glyph(m_Face, glyph_index, load_flags))\n    return NULL;\n  if (m_pSubstFont && !(m_pSubstFont->m_SubstFlags & FXFONT_SUBST_MM) &&\n      m_pSubstFont->m_Weight > 400) {\n    uint32_t index = (m_pSubstFont->m_Weight - 400) / 10;\n    if (index >= WEIGHTPOW_ARRAY_SIZE)\n      index = WEIGHTPOW_ARRAY_SIZE - 1;\n    int level = 0;\n    if (m_pSubstFont->m_Charset == FXFONT_SHIFTJIS_CHARSET)\n      level = g_WeightPow_SHIFTJIS[index] * 2 * 65536 / 36655;\n    else\n      level = g_WeightPow[index] * 2;\n    FXFT_Outline_Embolden(FXFT_Get_Glyph_Outline(m_Face), level);\n  }\n  FXFT_Outline_Funcs funcs;\n  funcs.move_to = _Outline_MoveTo;\n  funcs.line_to = _Outline_LineTo;\n  funcs.conic_to = _Outline_ConicTo;\n  funcs.cubic_to = _Outline_CubicTo;\n  funcs.shift = 0;\n  funcs.delta = 0;\n  OUTLINE_PARAMS params;\n  params.m_bCount = TRUE;\n  params.m_PointCount = 0;\n  FXFT_Outline_Decompose(FXFT_Get_Glyph_Outline(m_Face), &funcs, &params);\n  if (params.m_PointCount == 0) {\n    return NULL;\n  }\n  CFX_PathData* pPath = new CFX_PathData;\n  pPath->SetPointCount(params.m_PointCount);\n  params.m_bCount = FALSE;\n  params.m_PointCount = 0;\n  params.m_pPoints = pPath->GetPoints();\n  params.m_CurX = params.m_CurY = 0;\n  params.m_CoordUnit = 64 * 64.0;\n  FXFT_Outline_Decompose(FXFT_Get_Glyph_Outline(m_Face), &funcs, &params);\n  _Outline_CheckEmptyContour(&params);\n  pPath->TrimPoints(params.m_PointCount);\n  if (params.m_PointCount) {\n    pPath->GetPoints()[params.m_PointCount - 1].m_Flag |= FXPT_CLOSEFIGURE;\n  }\n  return pPath;\n}", "target": 1, "idx": 10521}
{"commit_id": "e6340f0665d53716ef3197ada88936c2a5f7a2d3", "project": "tensorflow", "func": "Status TrySimplify(NodeDef* consumer, string* simplified_node_name) override {\n    NodeDef* producer;\n\n    if (consumer->input_size() < 1) {\n      return errors::FailedPrecondition(\"Node \", simplified_node_name,\n                                        \" lacks inputs\");\n    }\n\n    TF_RETURN_IF_ERROR(GetInputNode(consumer->input(0), &producer));\n    const bool producer_is_cast = IsCastLike(*producer);\n    const bool can_optimize =\n        !IsCheckNumerics(*producer) &&\n        ((producer_is_cast && IsValuePreserving(*consumer)) ||\n         (IsValuePreserving(*producer) && IsCastLike(*consumer)));\n    if (!can_optimize || IsControlFlow(*producer) ||\n        IsInPreserveSet(*producer) ||\n        producer->device() != consumer->device()) {\n      return Status::OK();\n    }\n\n    const NodeDef* cast_like_node = producer_is_cast ? producer : consumer;\n    const OpDef* cast_like_op_def = nullptr;\n    TF_RETURN_IF_ERROR(OpRegistry::Global()->LookUpOpDef(cast_like_node->op(),\n                                                         &cast_like_op_def));\n    DataType cast_src_type;\n    TF_RETURN_IF_ERROR(InputTypeForNode(*cast_like_node, *cast_like_op_def, 0,\n                                        &cast_src_type));\n    DataType cast_dst_type;\n    TF_RETURN_IF_ERROR(OutputTypeForNode(*cast_like_node, *cast_like_op_def, 0,\n                                         &cast_dst_type));\n    if (!IsFixedSizeType(cast_src_type) || !IsFixedSizeType(cast_dst_type)) {\n      return Status::OK();\n    } else if (producer_is_cast &&\n               DataTypeSize(cast_dst_type) <= DataTypeSize(cast_src_type)) {\n      return Status::OK();\n    } else if (!producer_is_cast &&\n               DataTypeSize(cast_dst_type) >= DataTypeSize(cast_src_type)) {\n      return Status::OK();\n    }\n\n    // Check that nodes were not already optimized.\n    const string optimized_producer_name = OptimizedNodeName(\n        ParseNodeScopeAndName(producer->name()), DataTypeString(cast_dst_type));\n    const string optimized_consumer_name = OptimizedNodeName(\n        ParseNodeScopeAndName(consumer->name()), DataTypeString(cast_src_type));\n    const bool is_already_optimized =\n        ctx().node_map->NodeExists(optimized_consumer_name) ||\n        ctx().node_map->NodeExists(optimized_producer_name);\n    if (is_already_optimized) {\n      return Status::OK();\n    }\n\n    // Add copies of consumer and producer in reverse order.\n    NodeDef* input;\n    TF_RETURN_IF_ERROR(GetInputNode(producer->input(0), &input));\n    // Create new producer node.\n    NodeDef* new_producer = AddCopyNode(optimized_consumer_name, consumer);\n    new_producer->set_input(0, producer->input(0));\n    ctx().node_map->AddOutput(input->name(), new_producer->name());\n\n    // Create new consumer node.\n    NodeDef* new_consumer = AddCopyNode(optimized_producer_name, producer);\n    new_consumer->set_input(0, new_producer->name());\n\n    NodeDef* new_value_preserving =\n        producer_is_cast ? new_producer : new_consumer;\n    const DataType new_input_type =\n        producer_is_cast ? cast_src_type : cast_dst_type;\n    // Update the input type of the value-preserving node. The input and\n    // output types of the cast-like nodes remain the same.\n    TF_RETURN_IF_ERROR(SetInputType(new_input_type, new_value_preserving));\n    // Make sure there is a kernel registered for the value preserving op\n    // with the new input type.\n    TF_RETURN_IF_ERROR(IsKernelRegisteredForNode(*new_value_preserving));\n    ctx().node_map->AddOutput(new_producer->name(), new_consumer->name());\n\n    AddToOptimizationQueue(new_producer);\n    *simplified_node_name = new_consumer->name();\n\n    return Status::OK();\n  }", "target": 0, "idx": 10522}
{"commit_id": "025e77fcb2f45b21689931ba3bf74eac153afa48", "project": "ImageMagick", "func": "static PixelChannels **AcquirePixelThreadSet(const Image *images)\n{\n  const Image\n    *next;\n\n  PixelChannels\n    **pixels;\n\n  register ssize_t\n    i;\n\n  size_t\n    columns,\n    rows;\n\n  rows=MagickMax(GetImageListLength(images),\n    (size_t) GetMagickResourceLimit(ThreadResource));\n  pixels=(PixelChannels **) AcquireQuantumMemory(rows,sizeof(*pixels));\n  if (pixels == (PixelChannels **) NULL)\n    return((PixelChannels **) NULL);\n  columns=MaxPixelChannels;\n  for (next=images; next != (Image *) NULL; next=next->next)\n    columns=MagickMax(next->columns,columns);\n  for (i=0; i < (ssize_t) rows; i++)\n  {\n    register ssize_t\n      j;\n\n    pixels[i]=(PixelChannels *) AcquireQuantumMemory(columns,sizeof(**pixels));\n    if (pixels[i] == (PixelChannels *) NULL)\n      return(DestroyPixelThreadSet(pixels));\n    for (j=0; j < (ssize_t) columns; j++)\n    {\n      register ssize_t\n        k;\n\n      for (k=0; k < MaxPixelChannels; k++)\n        pixels[i][j].channel[k]=0.0;\n    }\n  }\n  return(pixels);\n}", "target": 2, "idx": 10523}
{"commit_id": "5b397d455d25a391ba346863830c1949627b4d08", "project": "yhirose/cpp-httplib", "func": "inline Result ClientImpl::Delete(const std::string &path,\n                                 const Headers &headers, const char *body,\n                                 size_t content_length,\n                                 const std::string &content_type) {\n  Request req;\n  req.method = \"DELETE\";\n  req.headers = headers;\n  req.path = path;\n\n  if (!content_type.empty()) { req.set_header(\"Content-Type\", content_type); }\n  req.body.assign(body, content_length);\n\n  return send_(std::move(req));\n}", "target": 2, "idx": 10524}
{"commit_id": "73f45e5e96ccc13a131f7c0122cf8600ce5b930f", "project": "ruby", "func": "static void\nonig_reg_resize(regex_t *reg)\n{\n  do {\n    if (!reg->used) {\n      xfree(reg->p);\n      reg->alloc = 0;\n      reg->p = 0;\n    }\n    else if (reg->alloc > reg->used) {\n      unsigned char *new_ptr = xrealloc(reg->p, reg->used);\n      // Skip the right size optimization if memory allocation fails\n      if (new_ptr) {\n        reg->alloc = reg->used;\n        reg->p = new_ptr;\n      }\n    }\n  } while ((reg = reg->chain) != 0);\n}", "target": 3, "idx": 10525}
{"commit_id": "bf9272a92f3df1e4ccfaad434e123222ae5313f7", "project": "wireshark", "func": "void proto_register_p_mul (void)\n{\n  static hf_register_info hf[] = {\n    { &hf_length,\n      { \"Length of PDU\", \"p_mul.length\", FT_UINT16, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_priority,\n      { \"Priority\", \"p_mul.priority\", FT_UINT8, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_map_first,\n      { \"First\", \"p_mul.first\", FT_BOOLEAN, 8,\n        TFS (&no_yes), 0x80, NULL, HFILL } },\n    { &hf_map_last,\n      { \"Last\", \"p_mul.last\", FT_BOOLEAN, 8,\n        TFS (&no_yes), 0x40, NULL, HFILL } },\n    { &hf_map_unused,\n      { \"MAP unused\", \"p_mul.unused\", FT_UINT8, BASE_DEC,\n        NULL, 0xC0, NULL, HFILL } },\n    { &hf_pdu_type,\n      { \"PDU Type\", \"p_mul.pdu_type\", FT_UINT8, BASE_DEC,\n        VALS (pdu_vals), 0x3F, NULL, HFILL } },\n    { &hf_pdu_type_value,\n      { \"PDU Type\", \"p_mul.pdu_type_value\", FT_UINT8, BASE_DEC,\n        VALS (pdu_vals), 0x3F, NULL, HFILL } },\n    { &hf_no_pdus,\n      { \"Total Number of PDUs\", \"p_mul.no_pdus\", FT_UINT16, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_seq_no,\n      { \"Sequence Number of PDUs\", \"p_mul.seq_no\", FT_UINT16, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_unused8,\n      { \"Unused\", \"p_mul.unused\", FT_UINT8, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_unused16,\n      { \"Unused\", \"p_mul.unused\", FT_UINT16, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_checksum,\n      { \"Checksum\", \"p_mul.checksum\", FT_UINT16, BASE_HEX,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_checksum_good,\n      { \"Good\", \"p_mul.checksum_good\", FT_BOOLEAN, BASE_NONE,\n        NULL, 0x0, \"True: checksum matches packet content; False: doesn't match content or not checked\", HFILL } },\n    { &hf_checksum_bad,\n      { \"Bad\", \"p_mul.checksum_bad\", FT_BOOLEAN, BASE_NONE,\n        NULL, 0x0, \"True: checksum doesn't match packet content; False: matches content or not checked\", HFILL } },\n    { &hf_source_id_ack,\n      { \"Source ID of Ack Sender\", \"p_mul.source_id_ack\", FT_IPv4, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_source_id,\n      { \"Source ID\", \"p_mul.source_id\", FT_IPv4, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_message_id,\n      { \"Message ID (MSID)\", \"p_mul.message_id\", FT_UINT32, BASE_DEC,\n        NULL, 0x0, \"Message ID\", HFILL } },\n    { &hf_expiry_time,\n      { \"Expiry Time\", \"p_mul.expiry_time\", FT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_mc_group,\n      { \"Multicast Group\", \"p_mul.mc_group\", FT_UINT32, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_ann_mc_group,\n      { \"Announced Multicast Group\", \"p_mul.ann_mc_group\", FT_UINT32, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_fec_len,\n      { \"FEC Parameter Length\", \"p_mul.fec.length\", FT_UINT8, BASE_DEC,\n        NULL, 0x0, \"Forward Error Correction Parameter Length\", HFILL } },\n    { &hf_fec_id,\n      { \"FEC ID\", \"p_mul.fec.id\", FT_UINT8, BASE_HEX,\n        NULL, 0x0, \"Forward Error Correction ID\", HFILL } },\n    { &hf_fec_parameters,\n      { \"FEC Parameters\", \"p_mul.fec.parameters\", FT_NONE, BASE_NONE,\n        NULL, 0x0, \"Forward Error Correction Parameters\", HFILL } },\n    { &hf_count_of_dest,\n      { \"Count of Destination Entries\", \"p_mul.dest_count\", FT_UINT16,BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_length_of_res,\n      { \"Length of Reserved Field\", \"p_mul.reserved_length\",FT_UINT16,BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_ack_count,\n      { \"Count of Ack Info Entries\", \"p_mul.ack_count\", FT_UINT16, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_ack_entry,\n      { \"Ack Info Entry\", \"p_mul.ack_info_entry\", FT_NONE, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_ack_length,\n      { \"Length of Ack Info Entry\", \"p_mul.ack_length\", FT_UINT16, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_miss_seq_no,\n      { \"Missing Data PDU Seq Number\", \"p_mul.missing_seq_no\", FT_UINT16,\n        BASE_DEC, NULL, 0x0, NULL, HFILL } },\n    { &hf_miss_seq_range,\n      { \"Missing Data PDU Seq Range\", \"p_mul.missing_seq_range\", FT_BYTES,\n        BASE_NONE, NULL, 0x0, NULL, HFILL } },\n    { &hf_tot_miss_seq_no,\n      { \"Total Number of Missing Data PDU Sequence Numbers\",\n        \"p_mul.no_missing_seq_no\", FT_UINT16, BASE_DEC, NULL, 0x0,\n        NULL, HFILL } },\n    { &hf_timestamp_option,\n      { \"Timestamp\", \"p_mul.timestamp\", FT_UINT64, BASE_DEC,\n        NULL, 0x0, \"Timestamp Option (in units of 100ms)\", HFILL } },\n    { &hf_dest_entry,\n      { \"Destination Entry\", \"p_mul.dest_entry\", FT_NONE, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_dest_id,\n      { \"Destination ID\", \"p_mul.dest_id\", FT_IPv4, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_msg_seq_no,\n      { \"Message Sequence Number\", \"p_mul.msg_seq_no\", FT_UINT16, BASE_DEC,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_sym_key,\n      { \"Symmetric Key\", \"p_mul.sym_key\", FT_NONE, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_data_fragment,\n      { \"Fragment of Data\", \"p_mul.data_fragment\", FT_NONE, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n\n    /* Fragment entries */\n    { &hf_msg_fragments,\n      { \"Message fragments\", \"p_mul.fragments\", FT_NONE, BASE_NONE,\n        NULL, 0x00, NULL, HFILL } },\n    { &hf_msg_fragment,\n      { \"Message fragment\", \"p_mul.fragment\", FT_FRAMENUM, BASE_NONE,\n        NULL, 0x00, NULL, HFILL } },\n    { &hf_msg_fragment_overlap,\n      { \"Message fragment overlap\", \"p_mul.fragment.overlap\", FT_BOOLEAN,\n        BASE_NONE, NULL, 0x0, NULL, HFILL } },\n    { &hf_msg_fragment_overlap_conflicts,\n      { \"Message fragment overlapping with conflicting data\",\n        \"p_mul.fragment.overlap.conflicts\", FT_BOOLEAN, BASE_NONE, NULL,\n        0x0, NULL, HFILL } },\n    { &hf_msg_fragment_multiple_tails,\n      { \"Message has multiple tail fragments\",\n        \"p_mul.fragment.multiple_tails\", FT_BOOLEAN, BASE_NONE,\n        NULL, 0x0, NULL, HFILL } },\n    { &hf_msg_fragment_too_long_fragment,\n      { \"Message fragment too long\", \"p_mul.fragment.too_long_fragment\",\n        FT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL,\n        HFILL } },\n    { &hf_msg_fragment_error,\n      { \"Message defragmentation error\", \"p_mul.fragment.error\", FT_FRAMENUM,\n        BASE_NONE, NULL, 0x00, NULL, HFILL } },\n    { &hf_msg_fragment_count,\n      { \"Message fragment count\", \"p_mul.fragment.count\", FT_UINT32, BASE_DEC,\n        NULL, 0x00, NULL, HFILL } },\n    { &hf_msg_reassembled_in,\n      { \"Reassembled in\", \"p_mul.reassembled.in\", FT_FRAMENUM, BASE_NONE,\n        NULL, 0x00, NULL, HFILL } },\n    { &hf_msg_reassembled_length,\n      { \"Reassembled P_MUL length\", \"p_mul.reassembled.length\", FT_UINT32, BASE_DEC,\n        NULL, 0x00, NULL, HFILL } },\n\n    /*\n    ** Ack matching / Resend\n    */\n    { &hf_analysis_ack_time,\n      { \"Ack Time\", \"p_mul.analysis.ack_time\", FT_RELATIVE_TIME, BASE_NONE,\n        NULL, 0x0, \"The time between the Last PDU and the Ack\", HFILL } },\n    { &hf_analysis_trans_time,\n      { \"Transfer Time\", \"p_mul.analysis.trans_time\", FT_RELATIVE_TIME, BASE_NONE,\n        NULL, 0x0, \"The time between the first Address PDU and the Ack\", HFILL } },\n    { &hf_analysis_retrans_time,\n      { \"Retransmission Time\", \"p_mul.analysis.retrans_time\", FT_RELATIVE_TIME, BASE_NONE,\n        NULL, 0x0, \"The time between the last PDU and this PDU\", HFILL } },\n    { &hf_analysis_total_retrans_time,\n      { \"Total Retransmission Time\", \"p_mul.analysis.total_retrans_time\", FT_RELATIVE_TIME, BASE_NONE,\n        NULL, 0x0, \"The time between the first PDU and this PDU\", HFILL } },\n    { &hf_analysis_addr_pdu_time,\n      { \"Time since Address PDU\", \"p_mul.analysis.elapsed_time\", FT_RELATIVE_TIME, BASE_NONE,\n        NULL, 0x0, \"The time between the Address PDU and this PDU\", HFILL } },\n    { &hf_analysis_prev_pdu_time,\n      { \"PDU Delay\", \"p_mul.analysis.pdu_delay\", FT_RELATIVE_TIME, BASE_NONE,\n        NULL, 0x0, \"The time between the last PDU and this PDU\", HFILL } },\n    { &hf_analysis_last_pdu_num,\n      { \"Last Data PDU in\", \"p_mul.analysis.last_pdu_in\", FT_FRAMENUM, BASE_NONE,\n        NULL, 0x0, \"The last Data PDU found in this frame\", HFILL } },\n    { &hf_analysis_addr_pdu_num,\n      { \"Address PDU in\", \"p_mul.analysis.addr_pdu_in\", FT_FRAMENUM, BASE_NONE,\n        NULL, 0x0, \"The Address PDU is found in this frame\", HFILL } },\n    { &hf_analysis_acks_addr_pdu_num,\n      { \"This is an Ack to the Address PDU in\", \"p_mul.analysis.acks_addr_pdu_in\", FT_FRAMENUM, BASE_NONE,\n        FRAMENUM_TYPE(FT_FRAMENUM_ACK), 0x0, \"The Address PDU is found in this frame\", HFILL } },\n    { &hf_analysis_acks_acked_addr_pdu_num,\n      { \"This is an Ack-Ack to the Address PDU in\", \"p_mul.analysis.acks_acked_addr_pdu_in\", FT_FRAMENUM, BASE_NONE,\n        FRAMENUM_TYPE(FT_FRAMENUM_DUP_ACK), 0x0, \"The Address PDU is found in this frame\", HFILL } },\n    { &hf_analysis_prev_pdu_num,\n      { \"Previous PDU in\", \"p_mul.analysis.prev_pdu_in\", FT_FRAMENUM, BASE_NONE,\n        NULL, 0x0, \"The previous PDU is found in this frame\", HFILL } },\n    { &hf_analysis_ack_num,\n      { \"Ack PDU in\", \"p_mul.analysis.ack_in\", FT_FRAMENUM, BASE_NONE,\n        NULL, 0x0, \"This packet has an Ack in this frame\", HFILL } },\n    { &hf_analysis_ack_missing,\n      { \"Ack PDU missing\", \"p_mul.analysis.ack_missing\", FT_NONE, BASE_NONE,\n        NULL, 0x0, \"The acknowledgement for this packet is missing\", HFILL } },\n    { &hf_analysis_retrans_no,\n      { \"Retransmission #\", \"p_mul.analysis.retrans_no\", FT_UINT32, BASE_DEC,\n        NULL, 0x0, \"Retransmission count\", HFILL } },\n    { &hf_analysis_ack_dup_no,\n      { \"Duplicate ACK #\", \"p_mul.analysis.dup_ack_no\", FT_UINT32, BASE_DEC,\n        NULL, 0x0, \"Duplicate Ack count\", HFILL } },\n    { &hf_analysis_msg_resend_from,\n      { \"Retransmission of Message in\", \"p_mul.analysis.msg_first_in\",\n        FT_FRAMENUM, BASE_NONE,\n        NULL, 0x0, \"This Message was first sent in this frame\", HFILL } },\n    { &hf_analysis_ack_resend_from,\n      { \"Retransmission of Ack in\", \"p_mul.analysis.ack_first_in\",\n        FT_FRAMENUM, BASE_NONE,\n        NULL, 0x0, \"This Ack was first sent in this frame\", HFILL } },\n    { &hf_analysis_total_time,\n      { \"Total Time\", \"p_mul.analysis.total_time\", FT_RELATIVE_TIME, BASE_NONE,\n        NULL, 0x0, \"The time between the first and the last Address PDU\", HFILL } },\n  };\n\n  static gint *ett[] = {\n    &ett_p_mul,\n    &ett_pdu_type,\n    &ett_dest_entry,\n    &ett_ack_entry,\n    &ett_range_entry,\n    &ett_checksum,\n    &ett_seq_analysis,\n    &ett_ack_analysis,\n    &ett_seq_ack_analysis,\n    &ett_msg_fragment,\n    &ett_msg_fragments\n  };\n  static ei_register_info ei[] = {\n      { &ei_address_pdu_missing, { \"p_mul.analysis.addr_pdu_missing\", PI_SEQUENCE, PI_NOTE, \"Address PDU missing\", EXPFILL }},\n      { &ei_analysis_ack_missing, { \"p_mul.analysis.ack_missing.expert\", PI_SEQUENCE, PI_NOTE, \"Ack PDU missing\", EXPFILL }},\n      { &ei_analysis_ack_dup_no, { \"p_mul.analysis.dup_ack_no.expert\", PI_SEQUENCE, PI_NOTE, \"Dup ACK #\", EXPFILL }},\n      { &ei_analysis_prev_pdu_missing, { \"p_mul.analysis.prev_pdu_missing\", PI_SEQUENCE, PI_NOTE, \"Previous PDU missing\", EXPFILL }},\n      { &ei_analysis_retrans_no, { \"p_mul.analysis.retrans_no.expert\", PI_SEQUENCE, PI_NOTE, \"Retransmission #\", EXPFILL }},\n      { &ei_message_discarded, { \"p_mul.message_discarded\", PI_RESPONSE_CODE, PI_NOTE, \"Message discarded\", EXPFILL }},\n      { &ei_checksum_bad, { \"p_mul.checksum_bad.expert\", PI_CHECKSUM, PI_WARN, \"Bad checksum\", EXPFILL }},\n      { &ei_ack_length, { \"p_mul.ack_length.invalid\", PI_MALFORMED, PI_WARN, \"Invalid ack info length\", EXPFILL }},\n      { &ei_miss_seq_range, { \"p_mul.missing_seq_range.invalid\", PI_UNDECODED, PI_WARN, \"Invalid missing sequence range\", EXPFILL }},\n      { &ei_miss_seq_no, { \"p_mul.missing_seq_no.invalid\", PI_UNDECODED, PI_WARN, \"Invalid missing seq number\", EXPFILL }},\n      { &ei_tot_miss_seq_no, { \"p_mul.no_missing_seq_no.expert\", PI_RESPONSE_CODE, PI_NOTE, \"Missing seq numbers\", EXPFILL }},\n      { &ei_illegal_seq_no, { \"p_mul.seq_no.illegal\", PI_PROTOCOL, PI_WARN, \"Illegal seq number\", EXPFILL }},\n      { &ei_length, { \"p_mul.length.invalid\", PI_MALFORMED, PI_WARN, \"Incorrect length field\", EXPFILL }},\n      { &ei_more_data, { \"p_mul.more_data\", PI_MALFORMED, PI_WARN, \"More data in packet\", EXPFILL }},\n  };\n\n  module_t *p_mul_module;\n  expert_module_t* expert_p_mul;\n\n  proto_p_mul = proto_register_protocol (PNAME, PSNAME, PFNAME);\n\n  p_mul_handle = register_dissector(PFNAME, dissect_p_mul, proto_p_mul);\n\n  proto_register_field_array (proto_p_mul, hf, array_length (hf));\n  proto_register_subtree_array (ett, array_length (ett));\n  expert_p_mul = expert_register_protocol(proto_p_mul);\n  expert_register_field_array(expert_p_mul, ei, array_length(ei));\n  register_init_routine (&p_mul_init_routine);\n  reassembly_table_register (&p_mul_reassembly_table,\n                         &addresses_reassembly_table_functions);\n\n  p_mul_id_hash_table = wmem_map_new_autoreset(wmem_epan_scope(), wmem_file_scope(), p_mul_id_hash, p_mul_id_hash_equal);\n\n  /* Register our configuration options */\n  p_mul_module = prefs_register_protocol (proto_p_mul, NULL);\n\n  prefs_register_obsolete_preference (p_mul_module, \"tport\");\n  prefs_register_obsolete_preference (p_mul_module, \"rport\");\n  prefs_register_obsolete_preference (p_mul_module, \"dport\");\n  prefs_register_obsolete_preference (p_mul_module, \"aport\");\n\n  prefs_register_bool_preference (p_mul_module, \"reassemble\",\n                                  \"Reassemble fragmented P_Mul packets\",\n                                  \"Reassemble fragmented P_Mul packets\",\n                                  &p_mul_reassemble);\n  prefs_register_bool_preference (p_mul_module, \"relative_msgid\",\n                                  \"Use relative Message ID\",\n                                  \"Make the P_Mul dissector use relative\"\n                                  \" message id number instead of absolute\"\n                                  \" ones\", &use_relative_msgid);\n  prefs_register_bool_preference (p_mul_module, \"seq_ack_analysis\",\n                                  \"SEQ/ACK Analysis\",\n                                  \"Calculate sequence/acknowledgement analysis\",\n                                  &use_seq_ack_analysis);\n  prefs_register_enum_preference (p_mul_module, \"decode\",\n                                  \"Decode Data PDU as\",\n                                  \"Type of content in Data_PDU\",\n                                  &decode_option, decode_options, FALSE);\n}", "target": 1, "idx": 10526}
{"commit_id": "ed17aa92dc56b6d8883e4b7a8f1c6fbf5ed6cd29", "project": "torvalds/linux", "func": "static long sock_hash_delete_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_shtab *htab = container_of(map, struct bpf_shtab, map);\n\tu32 hash, key_size = map->key_size;\n\tstruct bpf_shtab_bucket *bucket;\n\tstruct bpf_shtab_elem *elem;\n\tint ret = -ENOENT;\n\tunsigned long flags;\n\n\thash = sock_hash_bucket_hash(key, key_size);\n\tbucket = sock_hash_select_bucket(htab, hash);\n\n\traw_spin_lock_irqsave(&bucket->lock, flags);\n\telem = sock_hash_lookup_elem_raw(&bucket->head, hash, key, key_size);\n\tif (elem) {\n\t\thlist_del_rcu(&elem->node);\n\t\tsock_map_unref(elem->sk, elem);\n\t\tsock_hash_free_elem(htab, elem);\n\t\tret = 0;\n\t}\n\traw_spin_unlock_irqrestore(&bucket->lock, flags);\n\treturn ret;\n}", "target": 1, "idx": 10527}
{"commit_id": "c784d551ad50864de1035ce54e72837301cf6aca", "project": "wireshark", "func": "void proto_register_thrift(void) {\n\n    static hf_register_info hf[] = {\n        { &hf_thrift_version,\n        { \"Version\", \"thrift.version\",\n        FT_UINT16, BASE_HEX, NULL, 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_mtype,\n        { \"Message type\", \"thrift.mtype\",\n        FT_UINT8, BASE_DEC, VALS(thrift_mtype_vals), 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_str_len,\n        { \"Length\", \"thrift.str_len\",\n        FT_UINT32, BASE_DEC, NULL, 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_method,\n        { \"Method\", \"thrift.method\",\n        FT_STRING, BASE_NONE, NULL, 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_seq_id,\n        { \"Sequence Id\", \"thrift.seq_id\",\n        FT_UINT32, BASE_DEC, NULL, 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_type,\n        { \"Type\", \"thrift.type\",\n        FT_UINT8, BASE_DEC, VALS(thrift_type_vals), 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_fid,\n        { \"Field Id\", \"thrift.fid\",\n        FT_UINT16, BASE_DEC, NULL, 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_i16,\n        { \"Integer16\", \"thrift.i16\",\n        FT_INT16, BASE_DEC, NULL, 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_i32,\n        { \"Integer32\", \"thrift.i32\",\n        FT_INT32, BASE_DEC, NULL, 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_utf7str,\n        { \"UTF7 String\", \"thrift.utf7str\",\n        FT_STRING, BASE_NONE, NULL, 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_num_list_item,\n        { \"Number of List Items\", \"thrift.num_list_item\",\n        FT_UINT32, BASE_DEC, NULL, 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_num_map_item,\n        { \"Number of Map Items\", \"thrift.num_map_item\",\n        FT_UINT32, BASE_DEC, NULL, 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_bool,\n        { \"Boolean\", \"thrift.bool\",\n        FT_UINT8, BASE_DEC, VALS(thrift_bool_vals), 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_byte,\n        { \"Byte\", \"thrift.byte\",\n        FT_UINT8, BASE_DEC, NULL, 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_i64,\n        { \"Integer64\", \"thrift.i64\",\n        FT_INT64, BASE_DEC, NULL, 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_u64,\n        { \"Integer64\", \"thrift.u64\",\n        FT_UINT64, BASE_DEC, NULL, 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_double,\n        { \"Double\", \"thrift.double\",\n        FT_DOUBLE, BASE_NONE, NULL, 0x0,\n        NULL, HFILL }\n        },\n    };\n\n\n    /* setup protocol subtree arrays */\n    static gint* ett[] = {\n        &ett_thrift,\n    };\n\n    static ei_register_info ei[] = {\n        { &ei_thrift_wrong_type,{ \"thrift.wrong_type\", PI_PROTOCOL, PI_ERROR, \"Type value not expected\", EXPFILL } }\n    };\n\n    expert_module_t* expert_thrift;\n\n    /* Register protocol name and description */\n    proto_thrift = proto_register_protocol(\"Thrift Protocol\", \"Thrift\", \"thrift\");\n\n    expert_thrift = expert_register_protocol(proto_thrift);\n    expert_register_field_array(expert_thrift, ei, array_length(ei));\n\n    /* register field array */\n    proto_register_field_array(proto_thrift, hf, array_length(hf));\n\n    /* register subtree array */\n    proto_register_subtree_array(ett, array_length(ett));\n\n    /* register dissector */\n    /*register_dissector(\"thrift\", dissect_thrift, proto_thrift); */\n}", "target": 2, "idx": 10528}
{"commit_id": "1ccf89b87a3969edd56956e2d447f896037c8be7", "project": "android", "func": "xmlAutomataStatePtr\nxmlAutomataNewCountTrans2(xmlAutomataPtr am, xmlAutomataStatePtr from,\n\t\t\t xmlAutomataStatePtr to, const xmlChar *token,\n\t\t\t const xmlChar *token2,\n\t\t\t int min, int max, void *data) {\n    xmlRegAtomPtr atom;\n    int counter;\n\n    if ((am == NULL) || (from == NULL) || (token == NULL))\n\treturn(NULL);\n    if (min < 0)\n\treturn(NULL);\n    if ((max < min) || (max < 1))\n\treturn(NULL);\n    atom = xmlRegNewAtom(am, XML_REGEXP_STRING);\n    if (atom == NULL)\n\treturn(NULL);\n    if ((token2 == NULL) || (*token2 == 0)) {\n\tatom->valuep = xmlStrdup(token);\n    } else {\n\tint lenn, lenp;\n\txmlChar *str;\n\n\tlenn = strlen((char *) token2);\n\tlenp = strlen((char *) token);\n\n\tstr = (xmlChar *) xmlMallocAtomic(lenn + lenp + 2);\n\tif (str == NULL) {\n\t    xmlRegFreeAtom(atom);\n\t    return(NULL);\n\t}\n\tmemcpy(&str[0], token, lenp);\n\tstr[lenp] = '|';\n\tmemcpy(&str[lenp + 1], token2, lenn);\n\tstr[lenn + lenp + 1] = 0;\n\n\tatom->valuep = str;\n    }\n    atom->data = data;\n    if (min == 0)\n\tatom->min = 1;\n    else\n\tatom->min = min;\n    atom->max = max;\n\n    /*\n     * associate a counter to the transition.\n     */\n    counter = xmlRegGetCounter(am);\n    if (counter < 0)\n        goto error;\n    am->counters[counter].min = min;\n    am->counters[counter].max = max;\n\n    /* xmlFAGenerateTransitions(am, from, to, atom); */\n    if (to == NULL) {\n        to = xmlRegNewState(am);\n\txmlRegStatePush(am, to);\n    }\n    xmlRegStateAddTrans(am, from, atom, to, counter, -1);\n    xmlRegAtomPush(am, atom);\n    am->state = to;\n\n    if (to == NULL)\n\tto = am->state;\n    if (to == NULL)\n\treturn(NULL);\n    if (min == 0)\n\txmlFAGenerateEpsilonTransition(am, from, to);\n    return(to);\n\nerror:\n    xmlRegFreeAtom(atom);\n    return(NULL);\n}", "target": 2, "idx": 10529}
{"commit_id": "d2b1d124d4055c2fcbe5126863487c52fd58cca1", "project": "ioquake/ioq3", "func": "void Huff_Compress(msg_t *mbuf, int offset) {\n\tint\t\t\ti, ch, size;\n\tbyte\t\tseq[65536];\n\tbyte*\t\tbuffer;\n\thuff_t\t\thuff;\n\n\tsize = mbuf->cursize - offset;\n\tbuffer = mbuf->data+ + offset;\n\n\tif (size<=0) {\n\t\treturn;\n\t}\n\n\tCom_Memset(&huff, 0, sizeof(huff_t));\n\t// Add the NYT (not yet transmitted) node into the tree/list */\n\thuff.tree = huff.lhead = huff.loc[NYT] =  &(huff.nodeList[huff.blocNode++]);\n\thuff.tree->symbol = NYT;\n\thuff.tree->weight = 0;\n\thuff.lhead->next = huff.lhead->prev = NULL;\n\thuff.tree->parent = huff.tree->left = huff.tree->right = NULL;\n\n\tseq[0] = (size>>8);\n\tseq[1] = size&0xff;\n\n\tbloc = 16;\n\n\tfor (i=0; i<size; i++ ) {\n\t\tch = buffer[i];\n\t\tHuff_transmit(&huff, ch, seq, size<<3);\t\t\t\t\t\t/* Transmit symbol */\n\t\tHuff_addRef(&huff, (byte)ch);\t\t\t\t\t\t\t\t/* Do update */\n\t}\n\n\tbloc += 8;\t\t\t\t\t\t\t\t\t\t\t\t// next byte\n\n\tmbuf->cursize = (bloc>>3) + offset;\n\tCom_Memcpy(mbuf->data+offset, seq, (bloc>>3));\n}", "target": 3, "idx": 10530}
{"commit_id": "cb56694d290530ac308f44b453c18120b1c1109d", "project": "OpenSIPS/opensips", "func": "static inline char* parse_to_param(char *buffer, char *end,\n\t\t\t\t\tstruct to_body *to_b,\n\t\t\t\t\tint *returned_status,\n\t\t\t\t\tint multi)\n{\n\tstruct to_param *param;\n\tint status;\n\tint saved_status;\n\tchar  *tmp;\n\n\tparam=0;\n\tstatus=E_PARA_VALUE;\n\tsaved_status=E_PARA_VALUE;\n\tfor( tmp=buffer; tmp<end; tmp++)\n\t{\n\t\tswitch(*tmp)\n\t\t{\n\t\t\tcase ' ':\n\t\t\tcase '\\t':\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase TAG3:\n\t\t\t\t\t\tparam->type=TAG_PARAM;\n\t\t\t\t\tcase PARA_NAME:\n\t\t\t\t\tcase TAG1:\n\t\t\t\t\tcase TAG2:\n\t\t\t\t\t\tparam->name.len = tmp-param->name.s;\n\t\t\t\t\t\tstatus = S_EQUAL;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PARA_VALUE_TOKEN:\n\t\t\t\t\t\tparam->value.len = tmp-param->value.s;\n\t\t\t\t\t\tstatus = E_PARA_VALUE;\n\t\t\t\t\t\tadd_param( param , to_b );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase F_CRLF:\n\t\t\t\t\tcase F_LF:\n\t\t\t\t\tcase F_CR:\n\t\t\t\t\t\t/*previous=crlf and now =' '*/\n\t\t\t\t\t\tstatus=saved_status;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '\\n':\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase S_PARA_NAME:\n\t\t\t\t\tcase S_EQUAL:\n\t\t\t\t\tcase S_PARA_VALUE:\n\t\t\t\t\tcase E_PARA_VALUE:\n\t\t\t\t\t\tsaved_status=status;\n\t\t\t\t\t\tstatus=F_LF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TAG3:\n\t\t\t\t\t\tparam->type=TAG_PARAM;\n\t\t\t\t\tcase PARA_NAME:\n\t\t\t\t\tcase TAG1:\n\t\t\t\t\tcase TAG2:\n\t\t\t\t\t\tparam->name.len = tmp-param->name.s;\n\t\t\t\t\t\tsaved_status = S_EQUAL;\n\t\t\t\t\t\tstatus = F_LF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PARA_VALUE_TOKEN:\n\t\t\t\t\t\tparam->value.len = tmp-param->value.s;\n\t\t\t\t\t\tsaved_status = E_PARA_VALUE;\n\t\t\t\t\t\tstatus = F_LF;\n\t\t\t\t\t\tadd_param( param , to_b );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase F_CR:\n\t\t\t\t\t\tstatus=F_CRLF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase F_CRLF:\n\t\t\t\t\tcase F_LF:\n\t\t\t\t\t\tstatus=saved_status;\n\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '\\r':\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase S_PARA_NAME:\n\t\t\t\t\tcase S_EQUAL:\n\t\t\t\t\tcase S_PARA_VALUE:\n\t\t\t\t\tcase E_PARA_VALUE:\n\t\t\t\t\t\tsaved_status=status;\n\t\t\t\t\t\tstatus=F_CR;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TAG3:\n\t\t\t\t\t\tparam->type=TAG_PARAM;\n\t\t\t\t\tcase PARA_NAME:\n\t\t\t\t\tcase TAG1:\n\t\t\t\t\tcase TAG2:\n\t\t\t\t\t\tparam->name.len = tmp-param->name.s;\n\t\t\t\t\t\tsaved_status = S_EQUAL;\n\t\t\t\t\t\tstatus = F_CR;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PARA_VALUE_TOKEN:\n\t\t\t\t\t\tparam->value.len = tmp-param->value.s;\n\t\t\t\t\t\tsaved_status = E_PARA_VALUE;\n\t\t\t\t\t\tstatus = F_CR;\n\t\t\t\t\t\tadd_param( param , to_b );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase F_CRLF:\n\t\t\t\t\tcase F_CR:\n\t\t\t\t\tcase F_LF:\n\t\t\t\t\t\tstatus=saved_status;\n\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase  0:\n\t\t\tcase ',':\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase PARA_VALUE_QUOTED:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PARA_NAME:\n\t\t\t\t\t\tparam->name.len = tmp-param->name.s;\n\t\t\t\t\tcase S_EQUAL:\n\t\t\t\t\tcase S_PARA_VALUE:\n\t\t\t\t\t\tif (param->type==TAG_PARAM)\n\t\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t\t\tparam->value.s = tmp;\n\t\t\t\t\tcase PARA_VALUE_TOKEN:\n\t\t\t\t\t\tstatus = E_PARA_VALUE;\n\t\t\t\t\t\tparam->value.len = tmp-param->value.s;\n\t\t\t\t\t\tadd_param( param , to_b );\n\t\t\t\t\tcase E_PARA_VALUE:\n\t\t\t\t\t\tsaved_status = status;\n\t\t\t\t\t\tif ( !multi && *tmp==',')\n\t\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase PARA_VALUE_QUOTED:\n\t\t\t\t\t\tif (tmp+1==end)\n\t\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t\t\tswitch (*(tmp+1))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase '\\r':\n\t\t\t\t\t\t\tcase '\\n':\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\ttmp++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '\"':\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase S_PARA_VALUE:\n\t\t\t\t\t\tparam->value.s = tmp+1;\n\t\t\t\t\t\tstatus = PARA_VALUE_QUOTED;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PARA_VALUE_QUOTED:\n\t\t\t\t\t\tparam->value.len=tmp-param->value.s ;\n\t\t\t\t\t\tadd_param( param , to_b );\n\t\t\t\t\t\tstatus = E_PARA_VALUE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase F_CRLF:\n\t\t\t\t\tcase F_LF:\n\t\t\t\t\tcase F_CR:\n\t\t\t\t\t\t/*previous=crlf and now !=' '*/\n\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ';' :\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase PARA_VALUE_QUOTED:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PARA_NAME:\n\t\t\t\t\t\tparam->name.len = tmp-param->name.s;\n\t\t\t\t\tcase S_EQUAL:\n\t\t\t\t\tcase S_PARA_VALUE:\n\t\t\t\t\t\tif (param->type==TAG_PARAM)\n\t\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t\t\tparam->value.s = tmp;\n\t\t\t\t\tcase PARA_VALUE_TOKEN:\n\t\t\t\t\t\tparam->value.len=tmp-param->value.s;\n\t\t\t\t\t\tadd_param(param,to_b);\n\t\t\t\t\tcase E_PARA_VALUE:\n\t\t\t\t\t\tparam = (struct to_param*)\n\t\t\t\t\t\t\tpkg_malloc(sizeof(struct to_param));\n\t\t\t\t\t\tif (!param){\n\t\t\t\t\t\t\tLM_ERR(\"out of pkg memory\\n\" );\n\t\t\t\t\t\t\tgoto error;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemset(param,0,sizeof(struct to_param));\n\t\t\t\t\t\tparam->type=GENERAL_PARAM;\n\t\t\t\t\t\tstatus = S_PARA_NAME;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase F_CRLF:\n\t\t\t\t\tcase F_LF:\n\t\t\t\t\tcase F_CR:\n\t\t\t\t\t\t/*previous=crlf and now !=' '*/\n\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'T':\n\t\t\tcase 't' :\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase PARA_VALUE_QUOTED:\n\t\t\t\t\tcase PARA_VALUE_TOKEN:\n\t\t\t\t\tcase PARA_NAME:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase S_PARA_NAME:\n\t\t\t\t\t\tparam->name.s = tmp;\n\t\t\t\t\t\tstatus = TAG1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase S_PARA_VALUE:\n\t\t\t\t\t\tparam->value.s = tmp;\n\t\t\t\t\t\tstatus = PARA_VALUE_TOKEN;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TAG1:\n\t\t\t\t\tcase TAG2:\n\t\t\t\t\tcase TAG3:\n\t\t\t\t\t\tstatus = PARA_NAME;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase F_CRLF:\n\t\t\t\t\tcase F_LF:\n\t\t\t\t\tcase F_CR:\n\t\t\t\t\t\t/*previous=crlf and now !=' '*/\n\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'A':\n\t\t\tcase 'a' :\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase PARA_VALUE_QUOTED:\n\t\t\t\t\tcase PARA_VALUE_TOKEN:\n\t\t\t\t\tcase PARA_NAME:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase S_PARA_NAME:\n\t\t\t\t\t\tparam->name.s = tmp;\n\t\t\t\t\t\tstatus = PARA_NAME;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase S_PARA_VALUE:\n\t\t\t\t\t\tparam->value.s = tmp;\n\t\t\t\t\t\tstatus = PARA_VALUE_TOKEN;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TAG1:\n\t\t\t\t\t\tstatus = TAG2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TAG2:\n\t\t\t\t\tcase TAG3:\n\t\t\t\t\t\tstatus = PARA_NAME;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase F_CRLF:\n\t\t\t\t\tcase F_LF:\n\t\t\t\t\tcase F_CR:\n\t\t\t\t\t\t/*previous=crlf and now !=' '*/\n\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'G':\n\t\t\tcase 'g' :\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase PARA_VALUE_QUOTED:\n\t\t\t\t\tcase PARA_VALUE_TOKEN:\n\t\t\t\t\tcase PARA_NAME:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase S_PARA_NAME:\n\t\t\t\t\t\tparam->name.s = tmp;\n\t\t\t\t\t\tstatus = PARA_NAME;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase S_PARA_VALUE:\n\t\t\t\t\t\tparam->value.s = tmp;\n\t\t\t\t\t\tstatus = PARA_VALUE_TOKEN;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TAG1:\n\t\t\t\t\tcase TAG3:\n\t\t\t\t\t\tstatus = PARA_NAME;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TAG2:\n\t\t\t\t\t\tstatus = TAG3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase F_CRLF:\n\t\t\t\t\tcase F_LF:\n\t\t\t\t\tcase F_CR:\n\t\t\t\t\t\t/*previous=crlf and now !=' '*/\n\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '=':\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase PARA_VALUE_QUOTED:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TAG3:\n\t\t\t\t\t\tparam->type=TAG_PARAM;\n\t\t\t\t\tcase PARA_NAME:\n\t\t\t\t\tcase TAG1:\n\t\t\t\t\tcase TAG2:\n\t\t\t\t\t\tparam->name.len = tmp-param->name.s;\n\t\t\t\t\t\tstatus = S_PARA_VALUE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase S_EQUAL:\n\t\t\t\t\t\tstatus = S_PARA_VALUE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase F_CRLF:\n\t\t\t\t\tcase F_LF:\n\t\t\t\t\tcase F_CR:\n\t\t\t\t\t\t/*previous=crlf and now !=' '*/\n\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto parse_error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tswitch (status)\n\t\t\t\t{\n\t\t\t\t\tcase TAG1:\n\t\t\t\t\tcase TAG2:\n\t\t\t\t\tcase TAG3:\n\t\t\t\t\t\tstatus = PARA_NAME;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PARA_VALUE_TOKEN:\n\t\t\t\t\tcase PARA_NAME:\n\t\t\t\t\tcase PARA_VALUE_QUOTED:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase S_PARA_NAME:\n\t\t\t\t\t\tparam->name.s = tmp;\n\t\t\t\t\t\tstatus = PARA_NAME;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase S_PARA_VALUE:\n\t\t\t\t\t\tparam->value.s = tmp;\n\t\t\t\t\t\tstatus = PARA_VALUE_TOKEN;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase F_CRLF:\n\t\t\t\t\tcase F_LF:\n\t\t\t\t\tcase F_CR:\n\t\t\t\t\t\t/*previous=crlf and now !=' '*/\n\t\t\t\t\t\tgoto endofheader;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tLM_ERR(\"spitting out [%c] in status %d\\n\",*tmp,status );\n\t\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t}/*switch*/\n\t}/*for*/\n\n\tif (status==PARA_VALUE_QUOTED) {\n\t\t\tLM_ERR(\"unexpected end of header in state %d\\n\", status);\n\t\t\tgoto parse_error;\n\t}\n\nendofheader:\n\tLM_DBG(\"end of header reached, state=%d\\n\", status);\n\tif (param) {\n\t\tif (saved_status==S_EQUAL||saved_status==S_PARA_VALUE) {\n\t\t\tsaved_status = E_PARA_VALUE;\n\t\t\tparam->value.s= 0;\n\t\t\tparam->value.len=0;\n\t\t\tif (param->type==TAG_PARAM)\n\t\t\t\tgoto parse_error;\n\t\t\tadd_param(param, to_b);\n\t\t} else {\n\t\t\tpkg_free(param);\n\t\t}\n\t}\n\t*returned_status=saved_status;\n\treturn tmp;\n\nparse_error:\n\tLM_ERR(\"unexpected char [%c] in status %d: <<%.*s>> .\\n\",\n\t\t*tmp,status, (int)(tmp-buffer), ZSW(buffer));\nerror:\n\tif (param) pkg_free(param);\n\tfree_to_params(to_b);\n\tto_b->error=PARSE_ERROR;\n\t*returned_status = status;\n\treturn tmp;\n}", "target": 2, "idx": 10531}
{"commit_id": "365abe807cab2d60dc9ec307292a06181f77a9c2", "project": "facebook/hhvm", "func": "static int php_mb_parse_encoding_list(const char *value, int value_length,\n                                      mbfl_encoding ***return_list,\n                                      int *return_size, int persistent) {\n  int n, l, size, bauto, ret = 1;\n  char *p, *p1, *p2, *endp, *tmpstr;\n  mbfl_encoding *encoding;\n  mbfl_no_encoding *src;\n  mbfl_encoding **entry, **list;\n\n  list = nullptr;\n  if (value == nullptr || value_length <= 0) {\n    if (return_list) {\n      *return_list = nullptr;\n    }\n    if (return_size) {\n      *return_size = 0;\n    }\n    return 0;\n  } else {\n    mbfl_no_encoding *identify_list;\n    int identify_list_size;\n\n    identify_list = MBSTRG(default_detect_order_list);\n    identify_list_size = MBSTRG(default_detect_order_list_size);\n\n    /* copy the value string for work */\n    if (value[0]=='\"' && value[value_length-1]=='\"' && value_length>2) {\n      tmpstr = req::strndup(value + 1, value_length - 2);\n      value_length -= 2;\n    } else {\n      tmpstr = req::strndup(value, value_length);\n    }\n    if (tmpstr == nullptr) {\n      return 0;\n    }\n    /* count the number of listed encoding names */\n    endp = tmpstr + value_length;\n    n = 1;\n    p1 = tmpstr;\n    while ((p2 = (char*)string_memnstr(p1, \",\", 1, endp)) != nullptr) {\n      p1 = p2 + 1;\n      n++;\n    }\n    size = n + identify_list_size;\n    /* make list */\n    list = (mbfl_encoding **)calloc(size, sizeof(mbfl_encoding*));\n    if (list != nullptr) {\n      entry = list;\n      n = 0;\n      bauto = 0;\n      p1 = tmpstr;\n      do {\n        p2 = p = (char*)string_memnstr(p1, \",\", 1, endp);\n        if (p == nullptr) {\n          p = endp;\n        }\n        *p = '\\0';\n        /* trim spaces */\n        while (p1 < p && (*p1 == ' ' || *p1 == '\\t')) {\n          p1++;\n        }\n        p--;\n        while (p > p1 && (*p == ' ' || *p == '\\t')) {\n          *p = '\\0';\n          p--;\n        }\n        /* convert to the encoding number and check encoding */\n        if (strcasecmp(p1, \"auto\") == 0) {\n          if (!bauto) {\n            bauto = 1;\n            l = identify_list_size;\n            src = identify_list;\n            for (int i = 0; i < l; i++) {\n              *entry++ = (mbfl_encoding*) mbfl_no2encoding(*src++);\n              n++;\n            }\n          }\n        } else {\n          encoding = (mbfl_encoding*) mbfl_name2encoding(p1);\n          if (encoding != nullptr) {\n            *entry++ = encoding;\n            n++;\n          } else {\n            ret = 0;\n          }\n        }\n        p1 = p2 + 1;\n      } while (n < size && p2 != nullptr);\n      if (n > 0) {\n        if (return_list) {\n          *return_list = list;\n        } else {\n          free(list);\n        }\n      } else {\n        free(list);\n        if (return_list) {\n          *return_list = nullptr;\n        }\n        ret = 0;\n      }\n      if (return_size) {\n        *return_size = n;\n      }\n    } else {\n      if (return_list) {\n        *return_list = nullptr;\n      }\n      if (return_size) {\n        *return_size = 0;\n      }\n      ret = 0;\n    }\n    req::free(tmpstr);\n  }\n\n  return ret;\n}", "target": 3, "idx": 10532}
{"commit_id": "453393369dc9806d2455151e329c599684762428", "project": "torvalds/linux", "func": "static void ttm_put_pages(struct page **pages, unsigned npages, int flags,\n\t\t\t  enum ttm_caching_state cstate)\n{\n\tstruct ttm_page_pool *pool = ttm_get_pool(flags, false, cstate);\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tstruct ttm_page_pool *huge = ttm_get_pool(flags, true, cstate);\n#endif\n\tunsigned long irq_flags;\n\tunsigned i;\n\n\tif (pool == NULL) {\n\t\t/* No pool for this memory type so free the pages */\n\t\ti = 0;\n\t\twhile (i < npages) {\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t\t\tstruct page *p = pages[i];\n#endif\n\t\t\tunsigned order = 0, j;\n\n\t\t\tif (!pages[i]) {\n\t\t\t\t++i;\n\t\t\t\tcontinue;\n\t\t\t}\n\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t\t\tif (!(flags & TTM_PAGE_FLAG_DMA32) &&\n\t\t\t    (npages - i) >= HPAGE_PMD_NR) {\n\t\t\t\tfor (j = 1; j < HPAGE_PMD_NR; ++j)\n\t\t\t\t\tif (++p != pages[i + j])\n\t\t\t\t\t    break;\n\n\t\t\t\tif (j == HPAGE_PMD_NR)\n\t\t\t\t\torder = HPAGE_PMD_ORDER;\n\t\t\t}\n#endif\n\n\t\t\tif (page_count(pages[i]) != 1)\n\t\t\t\tpr_err(\"Erroneous page count. Leaking pages.\\n\");\n\t\t\t__free_pages(pages[i], order);\n\n\t\t\tj = 1 << order;\n\t\t\twhile (j) {\n\t\t\t\tpages[i++] = NULL;\n\t\t\t\t--j;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\ti = 0;\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tif (huge) {\n\t\tunsigned max_size, n2free;\n\n\t\tspin_lock_irqsave(&huge->lock, irq_flags);\n\t\twhile ((npages - i) >= HPAGE_PMD_NR) {\n\t\t\tstruct page *p = pages[i];\n\t\t\tunsigned j;\n\n\t\t\tif (!p)\n\t\t\t\tbreak;\n\n\t\t\tfor (j = 1; j < HPAGE_PMD_NR; ++j)\n\t\t\t\tif (++p != pages[i + j])\n\t\t\t\t    break;\n\n\t\t\tif (j != HPAGE_PMD_NR)\n\t\t\t\tbreak;\n\n\t\t\tlist_add_tail(&pages[i]->lru, &huge->list);\n\n\t\t\tfor (j = 0; j < HPAGE_PMD_NR; ++j)\n\t\t\t\tpages[i++] = NULL;\n\t\t\thuge->npages++;\n\t\t}\n\n\t\t/* Check that we don't go over the pool limit */\n\t\tmax_size = _manager->options.max_size;\n\t\tmax_size /= HPAGE_PMD_NR;\n\t\tif (huge->npages > max_size)\n\t\t\tn2free = huge->npages - max_size;\n\t\telse\n\t\t\tn2free = 0;\n\t\tspin_unlock_irqrestore(&huge->lock, irq_flags);\n\t\tif (n2free)\n\t\t\tttm_page_pool_free(huge, n2free, false);\n\t}\n#endif\n\n\tspin_lock_irqsave(&pool->lock, irq_flags);\n\twhile (i < npages) {\n\t\tif (pages[i]) {\n\t\t\tif (page_count(pages[i]) != 1)\n\t\t\t\tpr_err(\"Erroneous page count. Leaking pages.\\n\");\n\t\t\tlist_add_tail(&pages[i]->lru, &pool->list);\n\t\t\tpages[i] = NULL;\n\t\t\tpool->npages++;\n\t\t}\n\t\t++i;\n\t}\n\t/* Check that we don't go over the pool limit */\n\tnpages = 0;\n\tif (pool->npages > _manager->options.max_size) {\n\t\tnpages = pool->npages - _manager->options.max_size;\n\t\t/* free at least NUM_PAGES_TO_ALLOC number of pages\n\t\t * to reduce calls to set_memory_wb */\n\t\tif (npages < NUM_PAGES_TO_ALLOC)\n\t\t\tnpages = NUM_PAGES_TO_ALLOC;\n\t}\n\tspin_unlock_irqrestore(&pool->lock, irq_flags);\n\tif (npages)\n\t\tttm_page_pool_free(pool, npages, false);\n}", "target": 1, "idx": 10533}
{"commit_id": "a0108a892f9ea3c2bb1e7a49b7d71376c2ecbff7", "project": "ImageMagick", "func": "static MagickBooleanType WriteRGFImage(const ImageInfo *image_info,Image *image)\n{\n  MagickBooleanType\n    status;\n\n  int\n    bit;\n\n  register const PixelPacket\n    *p;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    y;\n\n  unsigned char\n    byte;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) TransformImageColorspace(image,sRGBColorspace);\n  if((image->columns > 255L) || (image->rows > 255L))\n    ThrowWriterException(ImageError,\"Dimensions must be less than 255x255\");\n  /*\n    Write header (just the image dimensions)\n  */\n  (void) WriteBlobByte(image,image->columns & 0xff);\n  (void) WriteBlobByte(image,image->rows & 0xff);\n  /*\n    Convert MIFF to bit pixels.\n  */\n  (void) SetImageType(image,BilevelType);\n  x=0;\n  y=0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n    if (p == (const PixelPacket *) NULL)\n      break;\n    bit=0;\n    byte=0;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      byte>>=1;\n      if (GetPixelLuma(image,p) < (QuantumRange/2.0))\n        byte|=0x80;\n      bit++;\n      if (bit == 8)\n        {\n          /*\n            Write a bitmap byte to the image file.\n          */\n       \t  (void) WriteBlobByte(image,byte);\n          bit=0;\n          byte=0;\n        }\n      p++;\n    }\n    if (bit != 0)\n      (void) WriteBlobByte(image,byte);\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}", "target": 1, "idx": 10534}
{"commit_id": "5517e22250e935dc7f86f64ad414aeae3dbcb36a", "project": "gerbv", "func": "int\ngerbv_open_image(gerbv_project_t *gerbvProject, gchar const* filename, int idx, int reload,\n\t\tgerbv_HID_Attribute *fattr, int n_fattr, gboolean forceLoadFile)\n{\n    gerb_file_t *fd;\n    gerbv_image_t *parsed_image = NULL, *parsed_image2 = NULL;\n    gint retv = -1;\n    gboolean isPnpFile = FALSE, foundBinary;\n    gerbv_HID_Attribute *attr_list = NULL;\n    int n_attr = 0;\n    /* If we're reloading, we'll pass in our file format attribute list\n     * since this is our hook for letting the user override the fileformat.\n     */\n    if (reload)\n\t{\n\t    /* We're reloading so use the attribute list in memory */\n\t    attr_list =  gerbvProject->file[idx]->image->info->attr_list;\n\t    n_attr =  gerbvProject->file[idx]->image->info->n_attr;\n\t}\n    else\n\t{\n\t    /* We're not reloading so use the attribute list read from the \n\t     * project file if given or NULL otherwise.\n\t     */\n\t    attr_list = fattr;\n\t    n_attr = n_fattr;\n\t}\n    /* if we don't have enough spots, then grow the file list by 2 to account for the possible \n       loading of two images for PNP files */\n    if ((idx+1) >= gerbvProject->max_files) {\n\tgerbvProject->file = g_renew (gerbv_fileinfo_t *,\n\t\t\tgerbvProject->file, gerbvProject->max_files + 2);\n\n\tgerbvProject->file[gerbvProject->max_files] = NULL;\n\tgerbvProject->file[gerbvProject->max_files+1] = NULL;\n\tgerbvProject->max_files += 2;\n    }\n    \n    dprintf(\"In open_image, about to try opening filename = %s\\n\", filename);\n    \n    fd = gerb_fopen(filename);\n    if (fd == NULL) {\n\tGERB_COMPILE_ERROR(_(\"Trying to open \\\"%s\\\": %s\"),\n\t\t\tfilename, strerror(errno));\n\treturn -1;\n    }\n\n    dprintf(\"In open_image, successfully opened file.  Now check its type....\\n\");\n    /* Here's where we decide what file type we have */\n    /* Note: if the file has some invalid characters in it but still appears to\n       be a valid file, we check with the user if he wants to continue (only\n       if user opens the layer from the menu...if from the command line, we go\n       ahead and try to load it anyways) */\n\n    if (gerber_is_rs274x_p(fd, &foundBinary)) {\n\tdprintf(\"Found RS-274X file\\n\");\n\tif (!foundBinary || forceLoadFile) {\n\t\t/* figure out the directory path in case parse_gerb needs to\n\t\t * load any include files */\n\t\tgchar *currentLoadDirectory = g_path_get_dirname (filename);\n\t\tparsed_image = parse_gerb(fd, currentLoadDirectory);\n\t\tg_free (currentLoadDirectory);\n\t}\n    } else if(drill_file_p(fd, &foundBinary)) {\n\tdprintf(\"Found drill file\\n\");\n\tif (!foundBinary || forceLoadFile)\n\t    parsed_image = parse_drillfile(fd, attr_list, n_attr, reload);\n\t\n    } else if (pick_and_place_check_file_type(fd, &foundBinary)) {\n\tdprintf(\"Found pick-n-place file\\n\");\n\tif (!foundBinary || forceLoadFile) {\n\t\tif (!reload) {\n\t\t\tpick_and_place_parse_file_to_images(fd, &parsed_image, &parsed_image2);\n\t\t} else {\n\t\t\tswitch (gerbvProject->file[idx]->image->layertype) {\n\t\t\tcase GERBV_LAYERTYPE_PICKANDPLACE_TOP:\n\t\t\t\t/* Non NULL pointer is used as \"not to reload\" mark */\n\t\t\t\tparsed_image2 = (void *)!NULL;\n\t\t\t\tpick_and_place_parse_file_to_images(fd, &parsed_image, &parsed_image2);\n\t\t\t\tparsed_image2 = NULL;\n\t\t\t\tbreak;\n\t\t\tcase GERBV_LAYERTYPE_PICKANDPLACE_BOT:\n\t\t\t\t/* Non NULL pointer is used as \"not to reload\" mark */\n\t\t\t\tparsed_image2 = (void *)!NULL;\n\t\t\t\tpick_and_place_parse_file_to_images(fd, &parsed_image2, &parsed_image);\n\t\t\t\tparsed_image2 = NULL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tGERB_COMPILE_ERROR(_(\"%s: unknown pick-and-place board side to reload\"), filename);\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tisPnpFile = TRUE;\n\t}\n    } else if (gerber_is_rs274d_p(fd)) {\n\tgchar *str = g_strdup_printf(_(\"Most likely found a RS-274D file \"\n\t\t\t\"\\\"%s\\\" ... trying to open anyways\\n\"), filename);\n\tdprintf(\"%s\", str);\n\tg_warning(\"%s\", str);\n\tg_free (str);\n\n\tif (!foundBinary || forceLoadFile) {\n\t\t/* figure out the directory path in case parse_gerb needs to\n\t\t * load any include files */\n\t\tgchar *currentLoadDirectory = g_path_get_dirname (filename);\n\t\tparsed_image = parse_gerb(fd, currentLoadDirectory);\n\t\tg_free (currentLoadDirectory);\n\t}\n    } else {\n\t/* This is not a known file */\n\tdprintf(\"Unknown filetype\");\n\tGERB_COMPILE_ERROR(_(\"%s: Unknown file type.\"), filename);\n\tparsed_image = NULL;\n    }\n    \n    gerb_fclose(fd);\n    if (parsed_image == NULL) {\n\treturn -1;\n    }\n    \n    if (parsed_image) {\n\t/* strip the filename to the base */\n\tgchar *baseName = g_path_get_basename (filename);\n\tgchar *displayedName;\n\tif (isPnpFile)\n\t\tdisplayedName = g_strconcat (baseName, _(\" (top)\"), NULL);\n\telse\n\t\tdisplayedName = g_strdup (baseName);\n    \tretv = gerbv_add_parsed_image_to_project (gerbvProject, parsed_image, filename, displayedName, idx, reload);\n    \tg_free (baseName);\n    \tg_free (displayedName);\n    }\n\n    /* Set layer_dirty flag to FALSE */\n    gerbvProject->file[idx]->layer_dirty = FALSE;\n\n    /* for PNP place files, we may need to add a second image for the other\n       board side */\n    if (parsed_image2) {\n      /* strip the filename to the base */\n\tgchar *baseName = g_path_get_basename (filename);\n\tgchar *displayedName;\n\tdisplayedName = g_strconcat (baseName, _(\" (bottom)\"), NULL);\n    \tretv = gerbv_add_parsed_image_to_project (gerbvProject, parsed_image2, filename, displayedName, idx + 1, reload);\n    \tg_free (baseName);\n    \tg_free (displayedName);\n    }\n\n    return retv;\n}", "target": 1, "idx": 10535}
{"commit_id": "5408a6d93f45bf1f7acd9ae5d44e0ebd77379e98", "project": "pcmacdon/jsish", "func": "static Jsi_RC jsi_ArrayPushCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Obj *obj;\n    \n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {\n        Jsi_ValueMakeNumber(interp, ret, 0);\n        return JSI_OK;\n    }\n    obj = _this->d.obj;\n    \n    int argc = Jsi_ValueGetLength(interp, args);\n    int curlen = jsi_SizeOfArray(interp, obj);    \n    int i;\n    for (i = 0; i < argc; ++i) {\n        Jsi_Value *ov = Jsi_ValueArrayIndex(interp, args, i);\n        if (!ov) { Jsi_LogBug(\"Arguments Error\"); ov = Jsi_ValueNew(interp); }\n        Jsi_ValueInsertArray(interp, _this, curlen + i, ov, 0);\n    }\n    \n    Jsi_ValueMakeNumber(interp, ret, jsi_SizeOfArray(interp, obj));\n    return JSI_OK;\n}", "target": 3, "idx": 10536}
{"commit_id": "3a77395e651acd81eb41ffd8fbdbf711e1133d76", "project": "wireshark", "func": "static int\ndissect_rgmp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, void* data _U_)\n{\n    proto_tree *tree;\n    proto_item *item;\n    guint8 type;\n    int offset = 0;\n    guint32 dst = g_htonl(MC_RGMP);\n\n    /* Shouldn't be destined for us */\n    if ((pinfo->dst.type != AT_IPv4) || memcmp(pinfo->dst.data, &dst, 4))\n        return 0;\n\n    col_set_str(pinfo->cinfo, COL_PROTOCOL, \"RGMP\");\n    col_clear(pinfo->cinfo, COL_INFO);\n\n    item = proto_tree_add_item(parent_tree, proto_rgmp, tvb, offset, -1, ENC_NA);\n    tree = proto_item_add_subtree(item, ett_rgmp);\n\n    type = tvb_get_guint8(tvb, offset);\n    col_add_str(pinfo->cinfo, COL_INFO,\n                val_to_str(type, rgmp_types, \"Unknown Type: 0x%02x\"));\n    proto_tree_add_uint(tree, hf_type, tvb, offset, 1, type);\n    offset += 1;\n\n    /* reserved */\n    proto_tree_add_item(tree, hf_reserved, tvb, offset, 1, ENC_NA);\n    offset += 1;\n\n    igmp_checksum(tree, tvb, hf_checksum, hf_checksum_bad, pinfo, 0);\n    offset += 2;\n\n    proto_tree_add_item(tree, hf_maddr, tvb, offset, 4, ENC_BIG_ENDIAN);\n    offset += 4;\n\n    return offset;\n}", "target": 2, "idx": 10537}
{"commit_id": "f748277ed1fc7065ae8998d61ed78b9ab1e55fae", "project": "openbsd/src", "func": "static int\nascii_load_sockaddr(struct sockaddr_storage *ss, char *buf)\n{\n\tif (!strcmp(\"local\", buf)) {\n\t\tss->ss_family = AF_LOCAL;\n\t}\n\telse if (buf[0] == '[' && buf[strlen(buf)-1] == ']') {\n\t\tstruct addrinfo hints, *res0;\n\t\t\n\t\tbuf[strlen(buf)-1] = '\\0';\n\n\t\t/* getaddrinfo() is used to support scoped addresses. */\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\thints.ai_family = AF_INET6;\n\t\thints.ai_flags = AI_NUMERICHOST;\n\t\tif (getaddrinfo(buf+1, NULL, &hints, &res0) != 0)\n\t\t\treturn 0;\n\t\tmemcpy(ss, res0->ai_addr, res0->ai_addrlen);\n\t\tss->ss_len = res0->ai_addrlen;\n\t\tfreeaddrinfo(res0);\n\t}\n\telse {\n\t\tstruct sockaddr_in ssin;\n\n\t\tmemset(&ssin, 0, sizeof ssin);\n\t\tif (inet_pton(AF_INET, buf, &ssin.sin_addr) != 1)\n\t\t\treturn 0;\n\t\tssin.sin_family = AF_INET;\n\t\tmemcpy(ss, &ssin, sizeof(ssin));\n\t\tss->ss_len = sizeof(struct sockaddr_in);\n\t}\n\treturn 1;\n}", "target": 2, "idx": 10538}
{"commit_id": "29f31f431b18278b94c659452562e8a027436487", "project": "gpac", "func": "static void svg_node_start(void *sax_cbck, const char *name, const char *name_space, const GF_XMLAttribute *attributes, u32 nb_attributes)\n{\n#ifndef SKIP_ALL\n\tGF_SVG_Parser *parser = (GF_SVG_Parser *)sax_cbck;\n\tSVG_NodeStack *stack, *parent;\n\tSVG_Element *elt;\n\tSVG_Element *cond = NULL;\n\tu32 xmlns;\n\tBool has_ns;\n\n\tparent = (SVG_NodeStack *)gf_list_last(parser->node_stack);\n\n\t/*switch to conditional*/\n\tif (parent && parent->node->sgprivate->tag==TAG_LSR_conditional) {\n\t\tcond = parent->node;\n\t\tparent = NULL;\n\t}\n\n\t/* If the loader was created with the DIMS type and this is the root element, restore the stream and AU\n\tcontext - in DIMS? we only have one stream an dcommands are stacked in the last AU of the stream*/\n\tif (!parent && (parser->load->type == GF_SM_LOAD_DIMS) && parser->load->ctx) {\n\n\t\t/*if not created, do it now*/\n\t\tif (!gf_list_count(parser->load->ctx->streams)) {\n\t\t\tparser->laser_es = gf_sm_stream_new(parser->load->ctx, 1, GF_STREAM_SCENE, GF_CODECID_DIMS);\n\t\t\tif (!parser->laser_es) {\n\t\t\t\tsvg_report(parser, GF_OUT_OF_MEM, NULL);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tparser->laser_es->timeScale = 1000;\n\t\t\t/* Create a default AU to behave as other streams (LASeR, BIFS)\n\t\t\t   but it is left empty, there is no notion of REPLACE Scene or NEw Scene,\n\t\t\t   the RAP is the graph */\n\t\t\tparser->laser_au = gf_sm_stream_au_new(parser->laser_es, 0, 0, GF_TRUE);\n\t\t\tif (!parser->laser_au) {\n\t\t\t\tsvg_report(parser, GF_OUT_OF_MEM, NULL);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tparser->laser_es = gf_list_get(parser->load->ctx->streams, 0);\n\t\t\tparser->laser_au = gf_list_last(parser->laser_es->AUs);\n\t\t}\n\t}\n\n\t/*saf setup*/\n\tif ((!parent && (parser->load->type!=GF_SM_LOAD_SVG)) || cond) {\n\t\tu32 com_type;\n\n\t\thas_ns=GF_FALSE;\n\t\tsvg_check_namespace(parser, attributes, nb_attributes, &has_ns);\n\n\t\t/*nothing to do, the context is already created*/\n\t\tif (!strcmp(name, \"SAFSession\")) return;\n\t\t/*nothing to do, wait for the laser (or other) header before creating stream)*/\n\t\tif (!strcmp(name, \"sceneHeader\")) return;\n\t\t/*nothing to do, wait for the laser (or other) header before creating stream)*/\n\t\tif (!strcmp(name, \"LASeRHeader\")) {\n\t\t\tGF_ESD *esd;\n\n\t\t\tif (!parser->load->ctx) {\n\t\t\t\tsvg_report(parser, GF_BAD_PARAM, \"Invalid parser context\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tesd = lsr_parse_header(parser, name, name_space, attributes, nb_attributes);\n\t\t\tif (!esd) {\n\t\t\t\tsvg_report(parser, GF_BAD_PARAM, \"Invalid LASER Header\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/*TODO find a better way of assigning an ID to the laser stream...*/\n\t\t\tesd->ESID = 1;\n\t\t\tparser->laser_es = gf_sm_stream_new(parser->load->ctx, esd->ESID, esd->decoderConfig->streamType, esd->decoderConfig->objectTypeIndication);\n\t\t\tif (!parser->laser_es) {\n\t\t\t\tsvg_report(parser, GF_OUT_OF_MEM, NULL);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!parser->load->ctx->root_od) {\n\t\t\t\tparser->load->ctx->root_od = (GF_ObjectDescriptor *) gf_odf_desc_new(GF_ODF_IOD_TAG);\n\t\t\t\tif (!parser->load->ctx->root_od) {\n\t\t\t\t\tsvg_report(parser, GF_OUT_OF_MEM, NULL);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_list_add(parser->load->ctx->root_od->ESDescriptors, esd);\n\t\t\tparser->laser_es->timeScale = esd->slConfig->timestampResolution;\n\t\t\treturn;\n\t\t}\n\t\tif (!strcmp(name, \"sceneUnit\") ) {\n\t\t\tu32 time, i;\n\t\t\tBool rap;\n\t\t\ttime = 0;\n\t\t\trap =  GF_FALSE;\n\t\t\tif (!parser->laser_es) {\n\t\t\t\tsvg_report(parser, GF_BAD_PARAM, \"No LASER stream specified\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!gf_list_count(parser->laser_es->AUs)) rap = GF_TRUE;\n\t\t\tfor (i=0; i<nb_attributes; i++) {\n\t\t\t\tGF_XMLAttribute *att = (GF_XMLAttribute *) &attributes[i];\n\t\t\t\tif (!strcmp(att->name, \"time\")) time = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"rap\")) rap = !strcmp(att->value, \"yes\") ? GF_TRUE : GF_FALSE;\n\t\t\t}\n\t\t\t/*create new laser unit*/\n\t\t\tparser->laser_au = gf_sm_stream_au_new(parser->laser_es, time, 0, rap);\n\t\t\tif (!parser->laser_au) {\n\t\t\t\tsvg_report(parser, GF_OUT_OF_MEM, NULL);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (!strcmp(name, \"StreamHeader\") || !strcmp(name, \"RemoteStreamHeader\")\n\t\t        /*SAF & SAFML are just a pain ...*/\n\t\t        || !strcmp(name, \"mediaHeader\") || !strcmp(name, \"imageHeader\")\n\t\t   ) {\n\t\t\tchar *url = NULL;\n\t\t\tchar *src = NULL;\n\t\t\tconst char *ID = NULL;\n\t\t\tu32 time, codecid, ST, i, ts_res;\n\t\t\tGF_ODUpdate *odU;\n\t\t\tGF_ObjectDescriptor *od;\n\t\t\tSVG_SAFExternalStream*st;\n\t\t\t/*create a SAF stream*/\n\t\t\tif (!parser->saf_es && parser->load->ctx) {\n\t\t\t\tGF_ESD *esd = (GF_ESD*)gf_odf_desc_esd_new(2);\n\t\t\t\tesd->ESID = 0xFFFE;\n\t\t\t\tesd->decoderConfig->streamType = GF_STREAM_OD;\n\t\t\t\tesd->decoderConfig->objectTypeIndication = 1;\n\t\t\t\tparser->saf_es = gf_sm_stream_new(parser->load->ctx, esd->ESID, GF_STREAM_OD, GF_CODECID_OD_V1);\n\t\t\t\tif (!parser->saf_es) {\n\t\t\t\t\tsvg_report(parser, GF_OUT_OF_MEM, NULL);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!parser->load->ctx->root_od) {\n\t\t\t\t\tparser->load->ctx->root_od = (GF_ObjectDescriptor *) gf_odf_desc_new(GF_ODF_IOD_TAG);\n\t\t\t\t\tif (!parser->load->ctx->root_od) {\n\t\t\t\t\t\tsvg_report(parser, GF_OUT_OF_MEM, NULL);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tparser->saf_es->timeScale = 1000;\n\t\t\t\tgf_list_add(parser->load->ctx->root_od->ESDescriptors, esd);\n\t\t\t}\n\t\t\ttime = 0;\n\t\t\tts_res = 1000;\n\t\t\tcodecid = ST = 0;\n\t\t\tfor (i=0; i<nb_attributes; i++) {\n\t\t\t\tGF_XMLAttribute *att = (GF_XMLAttribute *) &attributes[i];\n\t\t\t\tif (!strcmp(att->name, \"time\")) time = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"rap\")) ;//rap = !strcmp(att->value, \"yes\") ? 1 : 0;\n\t\t\t\telse if (!strcmp(att->name, \"url\")) url = gf_strdup(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"streamID\")) ID = att->value;\n\t\t\t\telse if (!strcmp(att->name, \"objectTypeIndication\")) codecid = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"codecID\")) {\n\t\t\t\t\tcodecid = GF_4CC(att->value[0],att->value[1],att->value[2],att->value[3]);\n\t\t\t\t}\n\t\t\t\telse if (!strcmp(att->name, \"streamType\")) ST = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"timeStampResolution\")) ts_res = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"source\")) src = att->value;\n\n\t\t\t}\n\t\t\tif (!strcmp(name, \"imageHeader\")) ST = 4;\n\n\t\t\t/*create new SAF stream*/\n\t\t\tst = svg_saf_get_next_available_stream(parser);\n\t\t\tst->stream_name = ID ? gf_strdup(ID) : NULL;\n\n\t\t\t/*create new SAF unit*/\n\t\t\tparser->saf_au = gf_sm_stream_au_new(parser->saf_es, time, 0, GF_FALSE);\n\t\t\tif (!parser->saf_au) {\n\t\t\t\tsvg_report(parser, GF_OUT_OF_MEM, NULL);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\todU = (GF_ODUpdate *) gf_odf_com_new(GF_ODF_OD_UPDATE_TAG);\n\t\t\tif (!odU) {\n\t\t\t\tsvg_report(parser, GF_OUT_OF_MEM, NULL);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tgf_list_add(parser->saf_au->commands, odU);\n\t\t\tod = (GF_ObjectDescriptor *) gf_odf_desc_new(GF_ODF_OD_TAG);\n\t\t\tif (!od) {\n\t\t\t\tsvg_report(parser, GF_OUT_OF_MEM, NULL);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tgf_list_add(odU->objectDescriptors, od);\n\t\t\tod->objectDescriptorID = st->id;\n\n\t\t\tif (url) {\n\t\t\t\tod->URLString = url;\n\t\t\t} else {\n\t\t\t\tGF_MuxInfo *mux;\n\t\t\t\tGF_ESD *esd = (GF_ESD*)gf_odf_desc_esd_new(2);\n\t\t\t\tif (!esd) {\n\t\t\t\t\tsvg_report(parser, GF_OUT_OF_MEM, NULL);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tgf_list_add(od->ESDescriptors, esd);\n\t\t\t\tesd->decoderConfig->objectTypeIndication = codecid;\n\t\t\t\tesd->decoderConfig->streamType = ST;\n\t\t\t\tesd->ESID = st->id;\n\n\t\t\t\tmux = (GF_MuxInfo *)gf_odf_desc_new(GF_ODF_MUXINFO_TAG);\n\t\t\t\tif (!mux) {\n\t\t\t\t\tsvg_report(parser, GF_OUT_OF_MEM, NULL);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tgf_list_add(esd->extensionDescriptors, mux);\n\n\t\t\t\t/*global source for stream, don't use nhml dumping*/\n\t\t\t\tif (src) {\n\t\t\t\t\tmux->file_name = gf_strdup(src);\n\t\t\t\t\tst->nhml_info = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tFILE *nhml;\n\t\t\t\t\tchar szName[1024];\n\t\t\t\t\tif (parser->load->localPath) {\n\t\t\t\t\t\tstrcpy(szName, parser->load->localPath);\n\t\t\t\t\t\tstrcat(szName, \"/\");\n\t\t\t\t\t\tstrcat(szName, ID ? ID : \"\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstrcpy(szName, ID ? ID : \"\");\n\t\t\t\t\t}\n\t\t\t\t\tstrcat(szName, \"_temp.nhml\");\n\t\t\t\t\tmux->file_name = gf_strdup(szName);\n\t\t\t\t\tst->nhml_info = mux->file_name;\n\t\t\t\t\tnhml = gf_fopen(st->nhml_info, \"wt\");\n\t\t\t\t\tif (nhml) {\n\t\t\t\t\t\tgf_fprintf(nhml, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n\");\n\t\t\t\t\t\tgf_fprintf(nhml, \"<NHNTStream version=\\\"1.0\\\" timeScale=\\\"%d\\\" streamType=\\\"%d\\\" objectTypeIndication=\\\"%d\\\" inRootOD=\\\"no\\\" trackID=\\\"%d\\\">\\n\", ts_res, ST, codecid, st->id);\n\t\t\t\t\t\tgf_fclose(nhml);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[LASeR Parser] Error opening nhml file %s while preparing import\\n\", st->nhml_info));\n\t\t\t\t\t}\n\t\t\t\t\tmux->delete_file = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (!strcmp(name, \"mediaUnit\") || !strcmp(name, \"imageUnit\") ) {\n\t\t\tFILE *nhml;\n\t\t\tchar *id = NULL;\n\t\t\tchar *src = NULL;\n\t\t\tSVG_SAFExternalStream*st;\n\t\t\tu32 i, rap, time, offset, length;\n\t\t\trap = time = offset = length = 0;\n\t\t\tfor (i=0; i<nb_attributes; i++) {\n\t\t\t\tGF_XMLAttribute *att = (GF_XMLAttribute *) &attributes[i];\n\t\t\t\tif (!strcmp(att->name, \"time\")) time = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"source\")) src = att->value;\n\t\t\t\telse if (!strcmp(att->name, \"ref\")) id = att->value;\n\t\t\t\telse if (!strcmp(att->name, \"rap\")) rap = !strcmp(att->value, \"yes\") ? 1 : 0;\n\t\t\t\telse if (!strcmp(att->name, \"startOffset\")) offset = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"length\")) length = atoi(att->value);\n\t\t\t}\n\t\t\tst = svg_saf_get_stream(parser, 0, id);\n\t\t\tif (!st || !st->nhml_info) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tnhml = gf_fopen(st->nhml_info, \"a+t\");\n\t\t\tgf_fprintf(nhml, \"<NHNTSample \");\n\t\t\tif (time) gf_fprintf(nhml, \"DTS=\\\"%d\\\" \", time);\n\t\t\tif (length) gf_fprintf(nhml, \"dataLength=\\\"%d\\\" \", length);\n\t\t\tif (offset) gf_fprintf(nhml, \"mediaOffset=\\\"%d\\\" \", offset);\n\t\t\tif (rap) gf_fprintf(nhml, \"isRAP=\\\"yes\\\" \");\n\t\t\tif (src) gf_fprintf(nhml, \"mediaFile=\\\"%s\\\" \", src);\n\t\t\tgf_fprintf(nhml, \"/>\\n\");\n\t\t\tgf_fclose(nhml);\n\t\t\treturn;\n\t\t}\n\t\tif (!strcmp(name, \"endOfStream\") ) {\n\t\t\tFILE *nhml;\n\t\t\tchar *id = NULL;\n\t\t\tu32 i;\n\t\t\tSVG_SAFExternalStream*st;\n\t\t\tfor (i=0; i<nb_attributes; i++) {\n\t\t\t\tGF_XMLAttribute *att = (GF_XMLAttribute *) &attributes[i];\n\t\t\t\tif (!strcmp(att->name, \"ref\")) id = att->value;\n\t\t\t}\n\t\t\tst = svg_saf_get_stream(parser, 0, id);\n\t\t\tif (!st || !st->nhml_info) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tnhml = gf_fopen(st->nhml_info, \"a+t\");\n\t\t\tgf_fprintf(nhml, \"</NHNTStream>\\n\");\n\t\t\tgf_fclose(nhml);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!strcmp(name, \"endOfSAFSession\") ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ((parser->load->type==GF_SM_LOAD_XSR) && !parser->laser_au && !cond) {\n\t\t\tif (parser->load->flags & GF_SM_LOAD_CONTEXT_READY) {\n\t\t\t\tassert(parser->laser_es);\n\t\t\t\tparser->laser_au = gf_sm_stream_au_new(parser->laser_es, 0, 0, GF_FALSE);\n\t\t\t\tif (!parser->laser_au) {\n\t\t\t\t\tsvg_report(parser, GF_OUT_OF_MEM, NULL);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsvg_report(parser, GF_BAD_PARAM, \"LASeR sceneUnit not defined for command %s\", name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t/*command parsing*/\n\t\tcom_type = lsr_get_command_by_name(name);\n\t\tif (com_type != GF_SG_UNDEFINED) {\n\t\t\tSVG_NodeStack *top;\n\t\t\tGF_Err e;\n\t\t\tparser->command = gf_sg_command_new(parser->load->scene_graph, com_type);\n\t\t\tif (!parser->command) {\n\t\t\t\tsvg_report(parser, GF_OUT_OF_MEM, NULL);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*this is likely a conditional start - update unknown depth level*/\n\t\t\ttop = (SVG_NodeStack*)gf_list_last(parser->node_stack);\n\t\t\tif (top) {\n\t\t\t\ttop->unknown_depth ++;\n\t\t\t\tparser->command_depth++;\n\t\t\t}\n\n\t\t\te = lsr_parse_command(parser, attributes, nb_attributes);\n\t\t\tif (e!= GF_OK) {\n\t\t\t\tparser->command->node = NULL;\n\t\t\t\tgf_sg_command_del(parser->command);\n\t\t\t\tparser->command = NULL;\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[LASeR Parser] Error parsing %s command - skipping\\n\", (parser->load->type==GF_SM_LOAD_XSR) ? \"LASeR\" : \"DIMS\"));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (cond) {\n\t\t\t\tGF_DOMUpdates *up = cond->children ? (GF_DOMUpdates *)cond->children->node : NULL;\n\t\t\t\tif (!up) {\n\t\t\t\t\tup = gf_dom_add_updates_node((GF_Node*)cond);\n\n\t\t\t\t\tif (parser->load->flags & GF_SM_LOAD_FOR_PLAYBACK) {\n\t\t\t\t\t\tgf_node_set_callback_function((GF_Node*)up, xsr_exec_command_list);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_list_add(up->updates, parser->command);\n\t\t\t} else if (parser->laser_au) {\n\t\t\t\tgf_list_add(parser->laser_au->commands, parser->command);\n\t\t\t}\n\t\t\tswitch (com_type) {\n\t\t\tcase GF_SG_LSR_NEW_SCENE:\n\t\t\tcase GF_SG_LSR_REFRESH_SCENE:\n\t\t\t\tif (parser->laser_au) parser->laser_au->flags |= GF_SM_AU_RAP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tparser->current_ns = GF_XMLNS_SVG;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!parent && !parser->command && (parser->load->flags & GF_SM_LOAD_CONTEXT_STREAMING)) {\n\t\tgf_sg_reset(parser->load->scene_graph);\n\t\tparser->has_root = 0;\n\t}\n\n\t/*something not supported happened (bad command name, bad root, ...) */\n\tif ((parser->has_root==1) && !parent && !parser->command)\n\t\treturn;\n\n\txmlns = parser->current_ns;\n\thas_ns = GF_FALSE;\n\n\telt = svg_parse_element(parser, name, name_space, attributes, nb_attributes, parent, &has_ns);\n\tif (!elt) {\n\t\tif (parent) parent->unknown_depth++;\n\t\telse if (cond) parser->command_depth++;\n\t\treturn;\n\t}\n\tGF_SAFEALLOC(stack, SVG_NodeStack);\n\tif (!stack) {\n\t\tparser->last_error = GF_OUT_OF_MEM;\n\t\treturn;\n\t}\n\tstack->node = elt;\n\tstack->current_ns = xmlns;\n\tstack->has_ns = has_ns;\n\tgf_list_add(parser->node_stack, stack);\n\n\tif ( (gf_node_get_tag((GF_Node *)elt) == TAG_SVG_svg) &&\n\t        (!parser->has_root || (parser->command && !parser->command->node) )\n\t   ) {\n\n\t\tif (!parser->has_root) svg_init_root_element(parser, elt);\n\t\tif (parser->command) parser->command->node = (GF_Node*)elt;\n\t} else if (!parent && parser->has_root && parser->command) {\n\t\tGF_CommandField *field = (GF_CommandField *)gf_list_get(parser->command->command_fields, 0);\n\t\tif (field) {\n\t\t\t/*either not assigned or textContent*/\n\t\t\tif (field->new_node && (field->new_node->sgprivate->tag==TAG_DOMText)) {\n\t\t\t\tgf_node_unregister(field->new_node, NULL);\n\t\t\t\tfield->new_node = NULL;\n\t\t\t}\n\t\t\tif (field->new_node) {\n\t\t\t\tfield->field_ptr = &field->node_list;\n\t\t\t\tgf_node_list_add_child(& field->node_list, field->new_node);\n\t\t\t\tfield->new_node = NULL;\n\t\t\t\tgf_node_list_add_child( & field->node_list, (GF_Node*) elt);\n\t\t\t} else if (field->node_list) {\n\t\t\t\tgf_node_list_add_child(& field->node_list, (GF_Node*) elt);\n\t\t\t} else {\n\t\t\t\tfield->new_node = (GF_Node*)elt;\n\t\t\t\tfield->field_ptr = &field->new_node;\n\t\t\t}\n\t\t} else {\n\t\t\tassert(parser->command->tag==GF_SG_LSR_NEW_SCENE);\n\t\t\tassert(gf_node_get_tag((GF_Node *)elt) == TAG_SVG_svg);\n\t\t\tif(!parser->command->node)\n\t\t\t\tparser->command->node = (GF_Node *)elt;\n\t\t}\n\t} else if (!parser->has_root ) {\n\t\tgf_list_del_item(parser->node_stack, stack);\n\t\tgf_free(stack);\n\t\tgf_node_unregister((GF_Node *)elt, NULL);\n\t} else if ((parser->has_root==2) && !parser->fragment_root) {\n\t\tparser->fragment_root = (GF_Node *)elt;\n\t}\n#endif\n}", "target": 1, "idx": 10539}
{"commit_id": "f54be179aa4cbbd944728771d7d59ed588158a12", "project": "openssl", "func": "void EC_GROUP_free(EC_GROUP *group)\n\t{\n\tif (!group) return;\n\n\tif (group->meth->group_finish != 0)\n\t\tgroup->meth->group_finish(group);\n\n\tEC_EX_DATA_free_all_data(&group->extra_data);\n\n\tif (group->mont_data)\n\t\tBN_MONT_CTX_free(group->mont_data);\n\n\tif (group->generator != NULL)\n\t\tEC_POINT_free(group->generator);\n\tBN_free(&group->order);\n\tBN_free(&group->cofactor);\n\n\tif (group->seed)\n\t\tOPENSSL_free(group->seed);\n\n\tOPENSSL_free(group);\n\t}", "target": 1, "idx": 10540}
{"commit_id": "f2cd18bc2e1cbca8c4b78bee9c392272bd5f42ac", "project": "rtcwcoop", "func": "void AICast_ScriptLoad( void ) {\n\tchar filename[MAX_QPATH];\n\tvmCvar_t mapname;\n\tfileHandle_t f;\n\tint len;\n\n\tlevel.scriptAI = NULL;\n\n\ttrap_Cvar_VariableStringBuffer( \"ai_scriptName\", filename, sizeof( filename ) );\n\tif ( strlen( filename ) > 0 ) {\n\t\ttrap_Cvar_Register( &mapname, \"ai_scriptName\", \"\", CVAR_ROM );\n\t} else {\n\t\ttrap_Cvar_Register( &mapname, \"mapname\", \"\", CVAR_SERVERINFO | CVAR_ROM );\n\t}\n\tQ_strncpyz( filename, \"maps/\", sizeof( filename ) );\n\tQ_strcat( filename, sizeof( filename ), mapname.string );\n\tif ( g_gametype.integer <= GT_COOP ) {\n\t\tQ_strcat( filename, sizeof( filename ), \".coop.ai\" );\n\t} else {\n\t\tQ_strcat( filename, sizeof( filename ), \".ai\" );\n\t}\n\n\tlen = trap_FS_FOpenFile( filename, &f, FS_READ );\n\n\tG_Printf( \"Loading: %s\\n\", filename );\n\n\tif ( len < 0 ) {\n\t\treturn;\n\t}\n\n\tlevel.scriptAI = trap_Alloc( len );\n\ttrap_FS_Read( level.scriptAI, len, f );\n\n\ttrap_FS_FCloseFile( f );\n\n\treturn;\n}", "target": 2, "idx": 10541}
{"commit_id": "a6da1472c0c5e05ff249325f979531ad51533110", "project": "lua", "func": "static void youngcollection (lua_State *L, global_State *g) {\n  GCObject **psurvival;  /* to point to first non-dead survival object */\n  lua_assert(g->gcstate == GCSpropagate);\n  markold(g, g->allgc, g->reallyold);\n  markold(g, g->finobj, g->finobjrold);\n  atomic(L);\n\n  /* sweep nursery and get a pointer to its last live element */\n  g->gcstate = GCSswpallgc;\n  psurvival = sweepgen(L, g, &g->allgc, g->survival);\n  /* sweep 'survival' and 'old' */\n  sweepgen(L, g, psurvival, g->reallyold);\n  g->reallyold = g->old;\n  g->old = *psurvival;  /* 'survival' survivals are old now */\n  g->survival = g->allgc;  /* all news are survivals */\n\n  /* repeat for 'finobj' lists */\n  psurvival = sweepgen(L, g, &g->finobj, g->finobjsur);\n  /* sweep 'survival' and 'old' */\n  sweepgen(L, g, psurvival, g->finobjrold);\n  g->finobjrold = g->finobjold;\n  g->finobjold = *psurvival;  /* 'survival' survivals are old now */\n  g->finobjsur = g->finobj;  /* all news are survivals */\n\n  sweepgen(L, g, &g->tobefnz, NULL);\n\n  finishgencycle(L, g);\n}", "target": 1, "idx": 10542}
{"commit_id": "83e2cf607f3599d208b6b3129092fa7deb2e5292", "project": "jqlang/jq", "func": "static void jv_dump_term(struct dtoa_context* C, jv x, int flags, int indent, FILE* F, jv* S) {\n  char buf[JVP_DTOA_FMT_MAX_LEN];\n  const char* color = 0;\n  double refcnt = (flags & JV_PRINT_REFCOUNT) ? jv_get_refcnt(x) - 1 : -1;\n  if (flags & JV_PRINT_COLOR) {\n    for (unsigned i=0; i<sizeof(color_kinds)/sizeof(color_kinds[0]); i++) {\n      if (jv_get_kind(x) == color_kinds[i]) {\n        color = colors[i];\n        put_str(color, F, S, flags & JV_PRINT_ISATTY);\n        break;\n      }\n    }\n  }\n  if (indent > MAX_PRINT_DEPTH) {\n    put_str(\"<skipped: too deep>\", F, S, flags & JV_PRINT_ISATTY);\n  } else switch (jv_get_kind(x)) {\n  default:\n  case JV_KIND_INVALID:\n    if (flags & JV_PRINT_INVALID) {\n      jv msg = jv_invalid_get_msg(jv_copy(x));\n      if (jv_get_kind(msg) == JV_KIND_STRING) {\n        put_str(\"<invalid:\", F, S, flags & JV_PRINT_ISATTY);\n        jvp_dump_string(msg, flags | JV_PRINT_ASCII, F, S, flags & JV_PRINT_ISATTY);\n        put_str(\">\", F, S, flags & JV_PRINT_ISATTY);\n      } else {\n        put_str(\"<invalid>\", F, S, flags & JV_PRINT_ISATTY);\n      }\n    } else {\n      assert(0 && \"Invalid value\");\n    }\n    break;\n  case JV_KIND_NULL:\n    put_str(\"null\", F, S, flags & JV_PRINT_ISATTY);\n    break;\n  case JV_KIND_FALSE:\n    put_str(\"false\", F, S, flags & JV_PRINT_ISATTY);\n    break;\n  case JV_KIND_TRUE:\n    put_str(\"true\", F, S, flags & JV_PRINT_ISATTY);\n    break;\n  case JV_KIND_NUMBER: {\n    double d = jv_number_value(x);\n    if (d != d) {\n      // JSON doesn't have NaN, so we'll render it as \"null\"\n      put_str(\"null\", F, S, flags & JV_PRINT_ISATTY);\n    } else {\n      // Normalise infinities to something we can print in valid JSON\n      if (d > DBL_MAX) d = DBL_MAX;\n      if (d < -DBL_MAX) d = -DBL_MAX;\n      put_str(jvp_dtoa_fmt(C, buf, d), F, S, flags & JV_PRINT_ISATTY);\n    }\n    break;\n  }\n  case JV_KIND_STRING:\n    jvp_dump_string(x, flags & JV_PRINT_ASCII, F, S, flags & JV_PRINT_ISATTY);\n    if (flags & JV_PRINT_REFCOUNT)\n      put_refcnt(C, refcnt, F, S, flags & JV_PRINT_ISATTY);\n    break;\n  case JV_KIND_ARRAY: {\n    if (jv_array_length(jv_copy(x)) == 0) {\n      put_str(\"[]\", F, S, flags & JV_PRINT_ISATTY);\n      break;\n    }\n    put_str(\"[\", F, S, flags & JV_PRINT_ISATTY);\n    if (flags & JV_PRINT_PRETTY) {\n      put_char('\\n', F, S, flags & JV_PRINT_ISATTY);\n      put_indent(indent + 1, flags, F, S, flags & JV_PRINT_ISATTY);\n    }\n    jv_array_foreach(x, i, elem) {\n      if (i!=0) {\n        if (flags & JV_PRINT_PRETTY) {\n          put_str(\",\\n\", F, S, flags & JV_PRINT_ISATTY);\n          put_indent(indent + 1, flags, F, S, flags & JV_PRINT_ISATTY);\n        } else {\n          put_str(\",\", F, S, flags & JV_PRINT_ISATTY);\n        }\n      }\n      jv_dump_term(C, elem, flags, indent + 1, F, S);\n      if (color) put_str(color, F, S, flags & JV_PRINT_ISATTY);\n    }\n    if (flags & JV_PRINT_PRETTY) {\n      put_char('\\n', F, S, flags & JV_PRINT_ISATTY);\n      put_indent(indent, flags, F, S, flags & JV_PRINT_ISATTY);\n    }\n    if (color) put_str(color, F, S, flags & JV_PRINT_ISATTY);\n    put_char(']', F, S, flags & JV_PRINT_ISATTY);\n    if (flags & JV_PRINT_REFCOUNT)\n      put_refcnt(C, refcnt, F, S, flags & JV_PRINT_ISATTY);\n    break;\n  }\n  case JV_KIND_OBJECT: {\n    if (jv_object_length(jv_copy(x)) == 0) {\n      put_str(\"{}\", F, S, flags & JV_PRINT_ISATTY);\n      break;\n    }\n    put_char('{', F, S, flags & JV_PRINT_ISATTY);\n    if (flags & JV_PRINT_PRETTY) {\n      put_char('\\n', F, S, flags & JV_PRINT_ISATTY);\n      put_indent(indent + 1, flags, F, S, flags & JV_PRINT_ISATTY);\n    }\n    int first = 1;\n    int i = 0;\n    jv keyset = jv_null();\n    while (1) {\n      jv key, value;\n      if (flags & JV_PRINT_SORTED) {\n        if (first) {\n          keyset = jv_keys(jv_copy(x));\n          i = 0;\n        } else {\n          i++;\n        }\n        if (i >= jv_array_length(jv_copy(keyset))) {\n          jv_free(keyset);\n          break;\n        }\n        key = jv_array_get(jv_copy(keyset), i);\n        value = jv_object_get(jv_copy(x), jv_copy(key));\n      } else {\n        if (first) {\n          i = jv_object_iter(x);\n        } else {\n          i = jv_object_iter_next(x, i);\n        }\n        if (!jv_object_iter_valid(x, i)) break;\n        key = jv_object_iter_key(x, i);\n        value = jv_object_iter_value(x, i);\n      }\n\n      if (!first) {\n        if (flags & JV_PRINT_PRETTY){\n          put_str(\",\\n\", F, S, flags & JV_PRINT_ISATTY);\n          put_indent(indent + 1, flags, F, S, flags & JV_PRINT_ISATTY);\n        } else {\n          put_str(\",\", F, S, flags & JV_PRINT_ISATTY);\n        }\n      }\n      if (color) put_str(COLRESET, F, S, flags & JV_PRINT_ISATTY);\n\n      first = 0;\n      if (color) put_str(FIELD_COLOR, F, S, flags & JV_PRINT_ISATTY);\n      jvp_dump_string(key, flags & JV_PRINT_ASCII, F, S, flags & JV_PRINT_ISATTY);\n      jv_free(key);\n      if (color) put_str(COLRESET, F, S, flags & JV_PRINT_ISATTY);\n\n      if (color) put_str(color, F, S, flags & JV_PRINT_ISATTY);\n      put_str((flags & JV_PRINT_PRETTY) ? \": \" : \":\", F, S, flags & JV_PRINT_ISATTY);\n      if (color) put_str(COLRESET, F, S, flags & JV_PRINT_ISATTY);\n\n      jv_dump_term(C, value, flags, indent + 1, F, S);\n      if (color) put_str(color, F, S, flags & JV_PRINT_ISATTY);\n    }\n    if (flags & JV_PRINT_PRETTY) {\n      put_char('\\n', F, S, flags & JV_PRINT_ISATTY);\n      put_indent(indent, flags, F, S, flags & JV_PRINT_ISATTY);\n    }\n    if (color) put_str(color, F, S, flags & JV_PRINT_ISATTY);\n    put_char('}', F, S, flags & JV_PRINT_ISATTY);\n    if (flags & JV_PRINT_REFCOUNT)\n      put_refcnt(C, refcnt, F, S, flags & JV_PRINT_ISATTY);\n  }\n  }\n  jv_free(x);\n  if (color) {\n    put_str(COLRESET, F, S, flags & JV_PRINT_ISATTY);\n  }\n}", "target": 2, "idx": 10543}
{"commit_id": "9764697a3b21ea4c7c0d33ce4e3a83d2da620a1a", "project": "RIOT-OS/RIOT", "func": "int _option_parse(gnrc_tcp_tcb_t *tcb, tcp_hdr_t *hdr)\n{\n    /* Extract offset value. Return if no options are set */\n    uint8_t offset = GET_OFFSET(byteorder_ntohs(hdr->off_ctl));\n    if (offset <= TCP_HDR_OFFSET_MIN) {\n        return 0;\n    }\n\n    /* Get pointer to option field and field size */\n    uint8_t *opt_ptr = (uint8_t *) hdr + sizeof(tcp_hdr_t);\n    uint8_t opt_left = (offset - TCP_HDR_OFFSET_MIN) * 4;\n\n    /* Parse options via tcp_hdr_opt_t */\n    while (opt_left > 0) {\n        tcp_hdr_opt_t *option = (tcp_hdr_opt_t *) opt_ptr;\n\n        /* Examine current option */\n        switch (option->kind) {\n            case TCP_OPTION_KIND_EOL:\n                DEBUG(\"gnrc_tcp_option.c : _option_parse() : EOL option found\\n\");\n                return 0;\n\n            case TCP_OPTION_KIND_NOP:\n                DEBUG(\"gnrc_tcp_option.c : _option_parse() : NOP option found\\n\");\n                opt_ptr += 1;\n                opt_left -= 1;\n                continue;\n\n            case TCP_OPTION_KIND_MSS:\n                if (option->length != TCP_OPTION_LENGTH_MSS) {\n                    DEBUG(\"gnrc_tcp_option.c : _option_parse() : invalid MSS Option length.\\n\");\n                    return -1;\n                }\n                tcb->mss = (option->value[0] << 8) | option->value[1];\n                DEBUG(\"gnrc_tcp_option.c : _option_parse() : MSS option found. MSS=%\"PRIu16\"\\n\",\n                      tcb->mss);\n                break;\n\n            default:\n                DEBUG(\"gnrc_tcp_option.c : _option_parse() : Unknown option found.\\\n                      KIND=%\"PRIu8\", LENGTH=%\"PRIu8\"\\n\", option->kind, option->length);\n                return -1;\n        }\n\n        if (option->length > opt_left) {\n            DEBUG(\"gnrc_tcp_option.c : _option_parse() : invalid option length\\n\");\n            return 0;\n        }\n\n        opt_ptr += option->length;\n        opt_left -= option->length;\n    }\n    return 0;\n}", "target": 2, "idx": 10544}
{"commit_id": "c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb", "project": "pbatard/rufus", "func": "const char* WinPKIErrorString(void)\n{\n\tstatic char error_string[64];\n\tDWORD error_code = GetLastError();\n\n\tif (((error_code >> 16) != 0x8009) && ((error_code >> 16) != 0x800B))\n\t\treturn WindowsErrorString();\n\n\tswitch (error_code) {\n\tcase NTE_BAD_UID:\n\t\treturn \"Bad UID.\";\n\tcase CRYPT_E_MSG_ERROR:\n\t\treturn \"An error occurred while performing an operation on a cryptographic message.\";\n\tcase CRYPT_E_UNKNOWN_ALGO:\n\t\treturn \"Unknown cryptographic algorithm.\";\n\tcase CRYPT_E_INVALID_MSG_TYPE:\n\t\treturn \"Invalid cryptographic message type.\";\n\tcase CRYPT_E_HASH_VALUE:\n\t\treturn \"The hash value is not correct\";\n\tcase CRYPT_E_ISSUER_SERIALNUMBER:\n\t\treturn \"Invalid issuer and/or serial number.\";\n\tcase CRYPT_E_BAD_LEN:\n\t\treturn \"The length specified for the output data was insufficient.\";\n\tcase CRYPT_E_BAD_ENCODE:\n\t\treturn \"An error occurred during encode or decode operation.\";\n\tcase CRYPT_E_FILE_ERROR:\n\t\treturn \"An error occurred while reading or writing to a file.\";\n\tcase CRYPT_E_NOT_FOUND:\n\t\treturn \"Cannot find object or property.\";\n\tcase CRYPT_E_EXISTS:\n\t\treturn \"The object or property already exists.\";\n\tcase CRYPT_E_NO_PROVIDER:\n\t\treturn \"No provider was specified for the store or object.\";\n\tcase CRYPT_E_DELETED_PREV:\n\t\treturn \"The previous certificate or CRL context was deleted.\";\n\tcase CRYPT_E_NO_MATCH:\n\t\treturn \"Cannot find the requested object.\";\n\tcase CRYPT_E_UNEXPECTED_MSG_TYPE:\n\tcase CRYPT_E_NO_KEY_PROPERTY:\n\tcase CRYPT_E_NO_DECRYPT_CERT:\n\t\treturn \"Private key or certificate issue\";\n\tcase CRYPT_E_BAD_MSG:\n\t\treturn \"Not a cryptographic message.\";\n\tcase CRYPT_E_NO_SIGNER:\n\t\treturn \"The signed cryptographic message does not have a signer for the specified signer index.\";\n\tcase CRYPT_E_REVOKED:\n\t\treturn \"The certificate is revoked.\";\n\tcase CRYPT_E_NO_REVOCATION_DLL:\n\tcase CRYPT_E_NO_REVOCATION_CHECK:\n\tcase CRYPT_E_REVOCATION_OFFLINE:\n\tcase CRYPT_E_NOT_IN_REVOCATION_DATABASE:\n\t\treturn \"Cannot check certificate revocation.\";\n\tcase CRYPT_E_INVALID_NUMERIC_STRING:\n\tcase CRYPT_E_INVALID_PRINTABLE_STRING:\n\tcase CRYPT_E_INVALID_IA5_STRING:\n\tcase CRYPT_E_INVALID_X500_STRING:\n\tcase  CRYPT_E_NOT_CHAR_STRING:\n\t\treturn \"Invalid string.\";\n\tcase CRYPT_E_SECURITY_SETTINGS:\n\t\treturn \"The cryptographic operation failed due to a local security option setting.\";\n\tcase CRYPT_E_NO_VERIFY_USAGE_CHECK:\n\tcase CRYPT_E_VERIFY_USAGE_OFFLINE:\n\t\treturn \"Cannot complete usage check.\";\n\tcase CRYPT_E_NO_TRUSTED_SIGNER:\n\t\treturn \"None of the signers of the cryptographic message or certificate trust list is trusted.\";\n\tcase CERT_E_UNTRUSTEDROOT:\n\t\treturn \"The root certificate is not trusted.\";\n\tcase TRUST_E_NOSIGNATURE:\n\t\treturn \"Not digitally signed.\";\n\tcase TRUST_E_EXPLICIT_DISTRUST:\n\t\treturn \"One of the certificates used was marked as untrusted by the user.\";\n\tdefault:\n\t\tstatic_sprintf(error_string, \"Unknown PKI error 0x%08lX\", error_code);\n\t\treturn error_string;\n\t}\n}", "target": 2, "idx": 10545}
{"commit_id": "233affe3fcdc851fa82cb058871bddd0046e1c87", "project": "leozide/leocad", "func": "void lcTexture::CreateGridTexture()\n{\n\tconstexpr int NumLevels = 9;\n\tmImages.resize(NumLevels);\n\tquint8* Previous = nullptr;\n\n\tfor (int ImageLevel = 0; ImageLevel < NumLevels; ImageLevel++)\n\t{\n\t\tImage& GridImage = mImages[ImageLevel];\n\t\tconst int GridSize = 256 >> ImageLevel;\n\t\tGridImage.Allocate(GridSize, GridSize, LC_PIXEL_FORMAT_A8);\n\n\t\tif (Previous)\n\t\t{\n\t\t\tconst int PreviousGridSize = 2 * GridSize;\n\n\t\t\tfor (int y = 0; y < GridSize - 1; y++)\n\t\t\t{\n\t\t\t\tfor (int x = 0; x < GridSize - 1; x++)\n\t\t\t\t{\n\t\t\t\t\tconst quint8 a = Previous[x * 2 + y * 2 * PreviousGridSize] > 64 ? 255 : 0;\n\t\t\t\t\tconst quint8 b = Previous[x * 2 + 1 + y * 2 * PreviousGridSize] > 64 ? 255 : 0;\n\t\t\t\t\tconst quint8 c = Previous[x * 2 + (y * 2 + 1) * PreviousGridSize] > 64 ? 255 : 0;\n\t\t\t\t\tconst quint8 d = Previous[x * 2 + 1 + (y * 2 + 1) * PreviousGridSize] > 64 ? 255 : 0;\n\t\t\t\t\tGridImage.mData[x + y * GridSize] = (a + b + c + d) / 4;\n\t\t\t\t}\n\n\t\t\t\tint x = GridSize - 1;\n\t\t\t\tconst quint8 a = Previous[x * 2 + y * 2 * PreviousGridSize];\n\t\t\t\tconst quint8 c = Previous[x * 2 + (y * 2 + 1) * PreviousGridSize];\n\t\t\t\tGridImage.mData[x + y * GridSize] = (a + c) / 2;\n\t\t\t}\n\n\t\t\tint y = GridSize - 1;\n\t\t\tfor (int x = 0; x < GridSize - 1; x++)\n\t\t\t{\n\t\t\t\tconst quint8 a = Previous[x * 2 + y * 2 * PreviousGridSize];\n\t\t\t\tconst quint8 b = Previous[x * 2 + 1 + y * 2 * PreviousGridSize];\n\t\t\t\tGridImage.mData[x + y * GridSize] = (a + b) / 2;\n\t\t\t}\n\n\t\t\tint x = GridSize - 1;\n\t\t\tGridImage.mData[x + y * GridSize] = Previous[x + y * PreviousGridSize];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst float Radius1 = (80 >> ImageLevel) * (80 >> ImageLevel);\n\t\t\tconst float Radius2 = (72 >> ImageLevel) * (72 >> ImageLevel);\n\t\t\tquint8* TempBuffer = new quint8[GridSize * GridSize];\n\n\t\t\tfor (int y = 0; y < GridSize; y++)\n\t\t\t{\n\t\t\t\tquint8* Pixel = TempBuffer + y * GridSize;\n\t\t\t\tmemset(Pixel, 0, GridSize);\n\n\t\t\t\tconst float y2 = (y - GridSize / 2) * (y - GridSize / 2);\n\n\t\t\t\tif (Radius1 <= y2)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (Radius2 <= y2)\n\t\t\t\t{\n\t\t\t\t\tconst int x1 = sqrtf(Radius1 - y2);\n\n\t\t\t\t\tfor (int x = GridSize / 2 - x1; x < GridSize / 2 + x1; x++)\n\t\t\t\t\t\tPixel[x] = 255;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tconst int x1 = sqrtf(Radius1 - y2);\n\t\t\t\t\tconst int x2 = sqrtf(Radius2 - y2);\n\n\t\t\t\t\tfor (int x = GridSize / 2 - x1; x < GridSize / 2 - x2; x++)\n\t\t\t\t\t\tPixel[x] = 255;\n\n\t\t\t\t\tfor (int x = GridSize / 2 + x2; x < GridSize / 2 + x1; x++)\n\t\t\t\t\t\tPixel[x] = 255;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int y = 0; y < GridSize - 1; y++)\n\t\t\t{\n\t\t\t\tfor (int x = 0; x < GridSize - 1; x++)\n\t\t\t\t{\n\t\t\t\t\tconst quint8 a = TempBuffer[x + y * GridSize];\n\t\t\t\t\tconst quint8 b = TempBuffer[x + 1 + y * GridSize];\n\t\t\t\t\tconst quint8 c = TempBuffer[x + (y + 1) * GridSize];\n\t\t\t\t\tconst quint8 d = TempBuffer[x + 1 + (y + 1) * GridSize];\n\t\t\t\t\tGridImage.mData[x + y * GridSize] = (a + b + c + d) / 4;\n\t\t\t\t}\n\n\t\t\t\tint x = GridSize - 1;\n\t\t\t\tconst quint8 a = TempBuffer[x + y * GridSize];\n\t\t\t\tconst quint8 c = TempBuffer[x + (y + 1) * GridSize];\n\t\t\t\tGridImage.mData[x + y * GridSize] = (a + c) / 2;\n\t\t\t}\n\n\t\t\tint y = GridSize - 1;\n\t\t\tfor (int x = 0; x < GridSize - 1; x++)\n\t\t\t{\n\t\t\t\tconst quint8 a = TempBuffer[x + y * GridSize];\n\t\t\t\tconst quint8 b = TempBuffer[x + 1 + y * GridSize];\n\t\t\t\tGridImage.mData[x + y * GridSize] = (a + b) / 2;\n\t\t\t}\n\n\t\t\tint x = GridSize - 1;\n\t\t\tGridImage.mData[x + y * GridSize] = TempBuffer[x + y * GridSize];\n\t\t\tdelete[] TempBuffer;\n\t\t}\n\n\t\tPrevious = GridImage.mData;\n\t}\n\n\tmRefCount = 1;\n\tmFlags = LC_TEXTURE_WRAPU | LC_TEXTURE_WRAPV | LC_TEXTURE_MIPMAPS | LC_TEXTURE_ANISOTROPIC;\n\n\tlcContext* Context = lcContext::GetGlobalOffscreenContext();\n\tContext->MakeCurrent();\n\tUpload(Context);\n}", "target": 1, "idx": 10546}
{"commit_id": "f72315575f78a9a773adbce0ee7d3ec33434cb76", "project": "mruby", "func": "static void\ngen_assignment(codegen_scope *s, node *tree, node *rhs, int sp, int val)\n{\n  int idx;\n  int type = nint(tree->car);\n\n  switch (type) {\n  case NODE_GVAR:\n  case NODE_ARG:\n  case NODE_LVAR:\n  case NODE_IVAR:\n  case NODE_CVAR:\n  case NODE_CONST:\n  case NODE_NIL:\n  case NODE_MASGN:\n    if (rhs) {\n      codegen(s, rhs, VAL);\n      pop();\n      sp = cursp();\n    }\n    break;\n\n  case NODE_COLON2:\n  case NODE_CALL:\n  case NODE_SCALL:\n    /* keep evaluation order */\n    break;\n\n  case NODE_NVAR:\n    codegen_error(s, \"Can't assign to numbered parameter\");\n    break;\n\n  default:\n    codegen_error(s, \"unknown lhs\");\n    break;\n  }\n\n  tree = tree->cdr;\n  switch (type) {\n  case NODE_GVAR:\n    gen_setxv(s, OP_SETGV, sp, nsym(tree), val);\n    break;\n  case NODE_ARG:\n  case NODE_LVAR:\n    idx = lv_idx(s, nsym(tree));\n    if (idx > 0) {\n      if (idx != sp) {\n        gen_move(s, idx, sp, val);\n      }\n      break;\n    }\n    else {                      /* upvar */\n      gen_setupvar(s, sp, nsym(tree));\n    }\n    break;\n  case NODE_IVAR:\n    gen_setxv(s, OP_SETIV, sp, nsym(tree), val);\n    break;\n  case NODE_CVAR:\n    gen_setxv(s, OP_SETCV, sp, nsym(tree), val);\n    break;\n  case NODE_CONST:\n    gen_setxv(s, OP_SETCONST, sp, nsym(tree), val);\n    break;\n  case NODE_COLON2:\n    if (sp) {\n      gen_move(s, cursp(), sp, 0);\n    }\n    sp = cursp();\n    push();\n    codegen(s, tree->car, VAL);\n    if (rhs) {\n      codegen(s, rhs, VAL); pop();\n      gen_move(s, sp, cursp(), 0);\n    }\n    pop_n(2);\n    idx = new_sym(s, nsym(tree->cdr));\n    genop_2(s, OP_SETMCNST, sp, idx);\n    break;\n\n  case NODE_CALL:\n  case NODE_SCALL:\n    {\n      int noself = 0, safe = (type == NODE_SCALL), skip = 0, top, call, n = 0;\n      mrb_sym mid = nsym(tree->cdr->car);\n\n      top = cursp();\n      if (val || sp == cursp()) {\n        push();                   /* room for retval */\n      }\n      call = cursp();\n      if (!tree->car) {\n        noself = 1;\n        push();\n      }\n      else {\n        codegen(s, tree->car, VAL); /* receiver */\n      }\n      if (safe) {\n        int recv = cursp()-1;\n        gen_move(s, cursp(), recv, 1);\n        skip = genjmp2_0(s, OP_JMPNIL, cursp(), val);\n      }\n      tree = tree->cdr->cdr->car;\n      if (tree) {\n        if (tree->car) {            /* positional arguments */\n          n = gen_values(s, tree->car, VAL, (tree->cdr->car)?13:14);\n          if (n < 0) {              /* variable length */\n            n = 15;\n            push();\n          }\n        }\n        if (tree->cdr->car) {       /* keyword arguments */\n          if (n == 14) {\n            pop_n(n);\n            genop_2(s, OP_ARRAY, cursp(), n);\n            push();\n            n = 15;\n          }\n          gen_hash(s, tree->cdr->car->cdr, VAL, 0);\n          if (n < 14) {\n            n++;\n          }\n          else {\n            pop_n(2);\n            genop_2(s, OP_ARYPUSH, cursp(), 1);\n          }\n          push();\n        }\n      }\n      if (rhs) {\n        codegen(s, rhs, VAL);\n        pop();\n      }\n      else {\n        gen_move(s, cursp(), sp, 0);\n      }\n      if (val) {\n        gen_move(s, top, cursp(), 1);\n      }\n      if (n < 15) {\n        n++;\n        if (n == 15) {\n          pop_n(14);\n          genop_2(s, OP_ARRAY, cursp(), 15);\n        }\n      }\n      else {\n        pop();\n        genop_2(s, OP_ARYPUSH, cursp(), 1);\n      }\n      s->sp = call;\n      if (mid == MRB_OPSYM_2(s->mrb, aref) && n == 2) {\n        genop_1(s, OP_SETIDX, cursp());\n      }\n      else {\n        genop_3(s, noself ? OP_SSEND : OP_SEND, cursp(), new_sym(s, attrsym(s, mid)), n);\n      }\n      if (safe) {\n        dispatch(s, skip);\n      }\n      s->sp = top;\n    }\n    break;\n\n  case NODE_MASGN:\n    gen_vmassignment(s, tree->car, sp, val);\n    break;\n\n  /* splat without assignment */\n  case NODE_NIL:\n    break;\n\n  default:\n    codegen_error(s, \"unknown lhs\");\n    break;\n  }\n  if (val) push();\n}", "target": 3, "idx": 10547}
{"commit_id": "a15378861368a4267c2c2c73b90db2849f943ebd", "project": "redis/hiredis", "func": "static int _redisContextConnectTcp(redisContext *c, const char *addr, int port,\n                                   const struct timeval *timeout,\n                                   const char *source_addr) {\n    int s, rv, n;\n    char _port[6];  /* strlen(\"65535\"); */\n    struct addrinfo hints, *servinfo, *bservinfo, *p, *b;\n    int blocking = (c->flags & REDIS_BLOCK);\n    int reuseaddr = (c->flags & REDIS_REUSEADDR);\n    int reuses = 0;\n    long timeout_msec = -1;\n\n    servinfo = NULL;\n    c->connection_type = REDIS_CONN_TCP;\n    c->tcp.port = port;\n\n    /* We need to take possession of the passed parameters\n     * to make them reusable for a reconnect.\n     * We also carefully check we don't free data we already own,\n     * as in the case of the reconnect method.\n     *\n     * This is a bit ugly, but atleast it works and doesn't leak memory.\n     **/\n    if (c->tcp.host != addr) {\n        free(c->tcp.host);\n\n        c->tcp.host = hi_strdup(addr);\n    }\n\n    if (timeout) {\n        if (c->timeout != timeout) {\n            if (c->timeout == NULL)\n                c->timeout = hi_malloc(sizeof(struct timeval));\n\n            memcpy(c->timeout, timeout, sizeof(struct timeval));\n        }\n    } else {\n        free(c->timeout);\n        c->timeout = NULL;\n    }\n\n    if (redisContextTimeoutMsec(c, &timeout_msec) != REDIS_OK) {\n        __redisSetError(c, REDIS_ERR_IO, \"Invalid timeout specified\");\n        goto error;\n    }\n\n    if (source_addr == NULL) {\n        free(c->tcp.source_addr);\n        c->tcp.source_addr = NULL;\n    } else if (c->tcp.source_addr != source_addr) {\n        free(c->tcp.source_addr);\n        c->tcp.source_addr = hi_strdup(source_addr);\n    }\n\n    snprintf(_port, 6, \"%d\", port);\n    memset(&hints,0,sizeof(hints));\n    hints.ai_family = AF_INET;\n    hints.ai_socktype = SOCK_STREAM;\n\n    /* Try with IPv6 if no IPv4 address was found. We do it in this order since\n     * in a Redis client you can't afford to test if you have IPv6 connectivity\n     * as this would add latency to every connect. Otherwise a more sensible\n     * route could be: Use IPv6 if both addresses are available and there is IPv6\n     * connectivity. */\n    if ((rv = getaddrinfo(c->tcp.host,_port,&hints,&servinfo)) != 0) {\n         hints.ai_family = AF_INET6;\n         if ((rv = getaddrinfo(addr,_port,&hints,&servinfo)) != 0) {\n            __redisSetError(c,REDIS_ERR_OTHER,gai_strerror(rv));\n            return REDIS_ERR;\n        }\n    }\n    for (p = servinfo; p != NULL; p = p->ai_next) {\naddrretry:\n        if ((s = socket(p->ai_family,p->ai_socktype,p->ai_protocol)) == -1)\n            continue;\n\n        c->fd = s;\n        if (redisSetBlocking(c,0) != REDIS_OK)\n            goto error;\n        if (c->tcp.source_addr) {\n            int bound = 0;\n            /* Using getaddrinfo saves us from self-determining IPv4 vs IPv6 */\n            if ((rv = getaddrinfo(c->tcp.source_addr, NULL, &hints, &bservinfo)) != 0) {\n                char buf[128];\n                snprintf(buf,sizeof(buf),\"Can't get addr: %s\",gai_strerror(rv));\n                __redisSetError(c,REDIS_ERR_OTHER,buf);\n                goto error;\n            }\n\n            if (reuseaddr) {\n                n = 1;\n                if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (char*) &n,\n                               sizeof(n)) < 0) {\n                    freeaddrinfo(bservinfo);\n                    goto error;\n                }\n            }\n\n            for (b = bservinfo; b != NULL; b = b->ai_next) {\n                if (bind(s,b->ai_addr,b->ai_addrlen) != -1) {\n                    bound = 1;\n                    break;\n                }\n            }\n            freeaddrinfo(bservinfo);\n            if (!bound) {\n                char buf[128];\n                snprintf(buf,sizeof(buf),\"Can't bind socket: %s\",strerror(errno));\n                __redisSetError(c,REDIS_ERR_OTHER,buf);\n                goto error;\n            }\n        }\n        if (connect(s,p->ai_addr,p->ai_addrlen) == -1) {\n            if (errno == EHOSTUNREACH) {\n                redisContextCloseFd(c);\n                continue;\n            } else if (errno == EINPROGRESS && !blocking) {\n                /* This is ok. */\n            } else if (errno == EADDRNOTAVAIL && reuseaddr) {\n                if (++reuses >= REDIS_CONNECT_RETRIES) {\n                    goto error;\n                } else {\n                    redisContextCloseFd(c);\n                    goto addrretry;\n                }\n            } else {\n                if (redisContextWaitReady(c,timeout_msec) != REDIS_OK)\n                    goto error;\n            }\n        }\n        if (blocking && redisSetBlocking(c,1) != REDIS_OK)\n            goto error;\n        if (redisSetTcpNoDelay(c) != REDIS_OK)\n            goto error;\n\n        c->flags |= REDIS_CONNECTED;\n        rv = REDIS_OK;\n        goto end;\n    }\n    if (p == NULL) {\n        char buf[128];\n        snprintf(buf,sizeof(buf),\"Can't create socket: %s\",strerror(errno));\n        __redisSetError(c,REDIS_ERR_OTHER,buf);\n        goto error;\n    }\n\nerror:\n    rv = REDIS_ERR;\nend:\n    if(servinfo) {\n        freeaddrinfo(servinfo);\n    }\n\n    return rv;  // Need to return REDIS_OK if alright\n}", "target": 2, "idx": 10548}
{"commit_id": "de53fd7aedb100f03e5d2231cfce0e4993282425", "project": "torvalds/linux", "func": "static void __return_cfs_rq_runtime(struct cfs_rq *cfs_rq)\n{\n\tstruct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(cfs_rq->tg);\n\ts64 slack_runtime = cfs_rq->runtime_remaining - min_cfs_rq_runtime;\n\n\tif (slack_runtime <= 0)\n\t\treturn;\n\n\traw_spin_lock(&cfs_b->lock);\n\tif (cfs_b->quota != RUNTIME_INF) {\n\t\tcfs_b->runtime += slack_runtime;\n\n\t\t/* we are under rq->lock, defer unthrottling using a timer */\n\t\tif (cfs_b->runtime > sched_cfs_bandwidth_slice() &&\n\t\t    !list_empty(&cfs_b->throttled_cfs_rq))\n\t\t\tstart_cfs_slack_bandwidth(cfs_b);\n\t}\n\traw_spin_unlock(&cfs_b->lock);\n\n\t/* even if it's not valid for return we don't want to try again */\n\tcfs_rq->runtime_remaining -= slack_runtime;\n}", "target": 1, "idx": 10549}
{"commit_id": "943323f1d9d3dd5c2634deb26cbe72343ca6b3db", "project": "android", "func": "WORD32 ih264d_read_mmco_commands(struct _DecStruct * ps_dec)\n{\n    dec_bit_stream_t *ps_bitstrm = ps_dec->ps_bitstrm;\n    dpb_commands_t *ps_dpb_cmds = ps_dec->ps_dpb_cmds;\n    dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;\n    WORD32 j;\n    UWORD8 u1_buf_mode;\n    struct MMCParams *ps_mmc_params;\n    UWORD32 *pu4_bitstrm_buf = ps_dec->ps_bitstrm->pu4_buffer;\n    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;\n    UWORD32 u4_bit_ofst = ps_dec->ps_bitstrm->u4_ofst;\n\n    ps_slice->u1_mmco_equalto5 = 0;\n    {\n        if(ps_dec->u1_nal_unit_type == IDR_SLICE_NAL)\n        {\n            ps_slice->u1_no_output_of_prior_pics_flag =\n                            ih264d_get_bit_h264(ps_bitstrm);\n            COPYTHECONTEXT(\"SH: no_output_of_prior_pics_flag\",\n                            ps_slice->u1_no_output_of_prior_pics_flag);\n            ps_slice->u1_long_term_reference_flag = ih264d_get_bit_h264(\n                            ps_bitstrm);\n            COPYTHECONTEXT(\"SH: long_term_reference_flag\",\n                            ps_slice->u1_long_term_reference_flag);\n            ps_dpb_cmds->u1_idr_pic = 1;\n            ps_dpb_cmds->u1_no_output_of_prior_pics_flag =\n                            ps_slice->u1_no_output_of_prior_pics_flag;\n            ps_dpb_cmds->u1_long_term_reference_flag =\n                            ps_slice->u1_long_term_reference_flag;\n        }\n        else\n        {\n            u1_buf_mode = ih264d_get_bit_h264(ps_bitstrm); //0 - sliding window; 1 - arbitrary\n            COPYTHECONTEXT(\"SH: adaptive_ref_pic_buffering_flag\", u1_buf_mode);\n            ps_dpb_cmds->u1_buf_mode = u1_buf_mode;\n            j = 0;\n\n            if(u1_buf_mode == 1)\n            {\n                UWORD32 u4_mmco;\n                UWORD32 u4_diff_pic_num;\n                UWORD32 u4_lt_idx, u4_max_lt_idx;\n\n                u4_mmco = ih264d_uev(pu4_bitstrm_ofst,\n                                     pu4_bitstrm_buf);\n                while(u4_mmco != END_OF_MMCO)\n                {\n                    if (j >= MAX_REF_BUFS)\n                    {\n                        ALOGE(\"b/25818142\");\n                        android_errorWriteLog(0x534e4554, \"25818142\");\n                        ps_dpb_cmds->u1_num_of_commands = 0;\n                        return -1;\n                    }\n                    ps_mmc_params = &ps_dpb_cmds->as_mmc_params[j];\n                    ps_mmc_params->u4_mmco = u4_mmco;\n                    switch(u4_mmco)\n                    {\n                        case MARK_ST_PICNUM_AS_NONREF:\n                            u4_diff_pic_num = ih264d_uev(pu4_bitstrm_ofst,\n                                                         pu4_bitstrm_buf);\n                            //Get absDiffPicnumMinus1\n                            ps_mmc_params->u4_diff_pic_num = u4_diff_pic_num;\n                            break;\n\n                        case MARK_LT_INDEX_AS_NONREF:\n                            u4_lt_idx = ih264d_uev(pu4_bitstrm_ofst,\n                                                   pu4_bitstrm_buf);\n                            ps_mmc_params->u4_lt_idx = u4_lt_idx;\n                            break;\n\n                        case MARK_ST_PICNUM_AS_LT_INDEX:\n                            u4_diff_pic_num = ih264d_uev(pu4_bitstrm_ofst,\n                                                         pu4_bitstrm_buf);\n                            ps_mmc_params->u4_diff_pic_num = u4_diff_pic_num;\n                            u4_lt_idx = ih264d_uev(pu4_bitstrm_ofst,\n                                                   pu4_bitstrm_buf);\n                            ps_mmc_params->u4_lt_idx = u4_lt_idx;\n                            break;\n\n                        case SET_MAX_LT_INDEX:\n                        {\n                            u4_max_lt_idx = ih264d_uev(pu4_bitstrm_ofst,\n                                                       pu4_bitstrm_buf);\n                            ps_mmc_params->u4_max_lt_idx_plus1 = u4_max_lt_idx;\n                            break;\n                        }\n                        case RESET_REF_PICTURES:\n                        {\n                            ps_slice->u1_mmco_equalto5 = 1;\n                            break;\n                        }\n\n                        case SET_LT_INDEX:\n                            u4_lt_idx = ih264d_uev(pu4_bitstrm_ofst,\n                                                   pu4_bitstrm_buf);\n                            ps_mmc_params->u4_lt_idx = u4_lt_idx;\n                            break;\n\n                        default:\n                            break;\n                    }\n                    u4_mmco = ih264d_uev(pu4_bitstrm_ofst,\n                                         pu4_bitstrm_buf);\n\n                    j++;\n                }\n                ps_dpb_cmds->u1_num_of_commands = j;\n\n            }\n        }\n        ps_dpb_cmds->u1_dpb_commands_read = 1;\n        ps_dpb_cmds->u1_dpb_commands_read_slc = 1;\n\n    }\n    u4_bit_ofst = ps_dec->ps_bitstrm->u4_ofst - u4_bit_ofst;\n    return u4_bit_ofst;\n}", "target": 2, "idx": 10550}
{"commit_id": "43ea0649d4b70fdcf3e9fa5c03aee1bbba0b04bb", "project": "chromium", "func": "void TextDocumentParser::insertFakePreElement()\n{\n    // In principle, we should create a specialized tree builder for\n    // TextDocuments, but instead we re-use the existing HTMLTreeBuilder.\n    // We create a fake token and give it to the tree builder rather than\n    // sending fake bytes through the front-end of the parser to avoid\n    // distrubing the line/column number calculations.\n    Vector<Attribute> attributes;\n    attributes.append(Attribute(styleAttr, \"word-wrap: break-word; white-space: pre-wrap;\"));\n    AtomicHTMLToken fakePre(HTMLToken::StartTag, preTag.localName(), attributes);\n    treeBuilder()->constructTree(&fakePre);\n    if (isStopped())\n        return; // The document could have been detached by an extension while the tree was being constructed.\n\n    // Normally we would skip the first \\n after a <pre> element, but we don't\n    // want to skip the first \\n for text documents!\n    treeBuilder()->setShouldSkipLeadingNewline(false);\n\n    // Although Text Documents expose a \"pre\" element in their DOM, they\n    // act like a <plaintext> tag, so we have to force plaintext mode.\n    forcePlaintextForTextDocument();\n\n    m_haveInsertedFakePreElement = true;\n}", "target": 2, "idx": 10551}
{"commit_id": "b4f042236ae0bb6725b3e8dd40af5a2466a6f971", "project": "xen-project/xen", "func": "static int amd_iommu_domain_init(struct domain *d)\n{\n    struct domain_iommu *hd = dom_iommu(d);\n\n    /*\n     * Choose the number of levels for the IOMMU page tables.\n     * - PV needs 3 or 4, depending on whether there is RAM (including hotplug\n     *   RAM) above the 512G boundary.\n     * - HVM could in principle use 3 or 4 depending on how much guest\n     *   physical address space we give it, but this isn't known yet so use 4\n     *   unilaterally.\n     */\n    hd->arch.paging_mode = is_hvm_domain(d)\n        ? 4 : amd_iommu_get_paging_mode(get_upper_mfn_bound());\n\n    return 0;\n}", "target": 2, "idx": 10552}
{"commit_id": "7814554e0827ece778ca88fd90832bd4d05520b1", "project": "abrt", "func": "int for_each_problem_in_dir(const char *path,\n                        uid_t caller_uid,\n                        int (*callback)(struct dump_dir *dd, void *arg),\n                        void *arg)\n{\n    DIR *dp = opendir(path);\n    if (!dp)\n    {\n        /* We don't want to yell if, say, $XDG_CACHE_DIR/abrt/spool doesn't exist */\n        //perror_msg(\"Can't open directory '%s'\", path);\n        return 0;\n    }\n\n    int brk = 0;\n    struct dirent *dent;\n    while ((dent = readdir(dp)) != NULL)\n    {\n        if (dot_or_dotdot(dent->d_name))\n            continue; /* skip \".\" and \"..\" */\n\n        char *full_name = concat_path_file(path, dent->d_name);\n\n        int dir_fd = dd_openfd(full_name);\n        if (dir_fd < 0)\n        {\n            VERB2 perror_msg(\"can't open problem directory '%s'\", full_name);\n            continue;\n        }\n\n        if (caller_uid == -1 || fdump_dir_accessible_by_uid(dir_fd, caller_uid))\n        {\n            /* Silently ignore *any* errors, not only EACCES.\n             * We saw \"lock file is locked by process PID\" error\n             * when we raced with wizard.\n             */\n            int sv_logmode = logmode;\n            logmode = 0;\n            struct dump_dir *dd = dd_fdopendir(dir_fd, full_name, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES | DD_DONT_WAIT_FOR_LOCK);\n            logmode = sv_logmode;\n            if (dd)\n            {\n                brk = callback ? callback(dd, arg) : 0;\n                dd_close(dd);\n            }\n        }\n        else\n            close(dir_fd);\n\n        free(full_name);\n        if (brk)\n            break;\n    }\n    closedir(dp);\n\n    return brk;\n}", "target": 2, "idx": 10553}
{"commit_id": "22076557b07c12086eeb16b8ce2b0b735f7a27e7", "project": "torvalds/linux", "func": "struct bus_id_priv *get_busid_priv(const char *busid)\n{\n\tint idx;\n\tstruct bus_id_priv *bid = NULL;\n\n\tspin_lock(&busid_table_lock);\n\tidx = get_busid_idx(busid);\n\tif (idx >= 0) {\n\t\tbid = &(busid_table[idx]);\n\t\t/* get busid_lock before returning */\n\t\tspin_lock(&bid->busid_lock);\n\t}\n\tspin_unlock(&busid_table_lock);\n\n\treturn bid;\n}", "target": 2, "idx": 10554}
{"commit_id": "6cac99dafe6003c8a4bd5666341c217876536869", "project": "flatpak", "func": "static void\nprint_perm_line (int        idx,\n                 GPtrArray *items,\n                 int        cols)\n{\n  g_autoptr(GString) res = g_string_new (NULL);\n  g_autofree char *escaped_first_perm = NULL;\n  int i;\n\n  escaped_first_perm = flatpak_escape_string (items->pdata[0], FLATPAK_ESCAPE_DEFAULT);\n  g_string_append_printf (res, \"    [%d] %s\", idx, escaped_first_perm);\n\n  for (i = 1; i < items->len; i++)\n    {\n      g_autofree char *escaped = flatpak_escape_string (items->pdata[i],\n                                                        FLATPAK_ESCAPE_DEFAULT);\n      char *p;\n      int len;\n\n      p = strrchr (res->str, '\\n');\n      if (!p)\n        p = res->str;\n\n      len = (res->str + strlen (res->str)) - p;\n      if (len + strlen (escaped) + 2 >= cols)\n        g_string_append_printf (res, \",\\n        %s\", escaped);\n      else\n        g_string_append_printf (res, \", %s\", escaped);\n    }\n\n  g_print (\"%s\\n\", res->str);\n}", "target": 1, "idx": 10555}
{"commit_id": "cc16eecae687912238ee6efbff71ad31e2bc414e", "project": "torvalds/linux", "func": "void jbd2_journal_wait_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\n\twhile (1) {\n\t\t/*\n\t\t * Note that the running transaction can get freed under us if\n\t\t * this transaction is getting committed in\n\t\t * jbd2_journal_commit_transaction() ->\n\t\t * jbd2_journal_free_transaction(). This can only happen when we\n\t\t * release j_state_lock -> schedule() -> acquire j_state_lock.\n\t\t * Hence we should everytime retrieve new j_running_transaction\n\t\t * value (after j_state_lock release acquire cycle), else it may\n\t\t * lead to use-after-free of old freed transaction.\n\t\t */\n\t\ttransaction_t *transaction = journal->j_running_transaction;\n\n\t\tif (!transaction)\n\t\t\tbreak;\n\n\t\tspin_lock(&transaction->t_handle_lock);\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!atomic_read(&transaction->t_updates)) {\n\t\t\tspin_unlock(&transaction->t_handle_lock);\n\t\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n}", "target": 2, "idx": 10556}
{"commit_id": "959c59c7a0164117e7f8366466a32bb1f8d77ff1", "project": "openssl", "func": "X509_POLICY_NODE *ossl_policy_level_add_node(X509_POLICY_LEVEL *level,\n                                             X509_POLICY_DATA *data,\n                                             X509_POLICY_NODE *parent,\n                                             X509_POLICY_TREE *tree,\n                                             int extra_data)\n{\n    X509_POLICY_NODE *node;\n\n    /* Verify that the tree isn't too large.  This mitigates CVE-2023-0464 */\n    if (tree->node_maximum > 0 && tree->node_count >= tree->node_maximum)\n        return NULL;\n\n    node = OPENSSL_zalloc(sizeof(*node));\n    if (node == NULL) {\n        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n    node->data = data;\n    node->parent = parent;\n    if (level != NULL) {\n        if (OBJ_obj2nid(data->valid_policy) == NID_any_policy) {\n            if (level->anyPolicy)\n                goto node_error;\n            level->anyPolicy = node;\n        } else {\n\n            if (level->nodes == NULL)\n                level->nodes = ossl_policy_node_cmp_new();\n            if (level->nodes == NULL) {\n                ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);\n                goto node_error;\n            }\n            if (!sk_X509_POLICY_NODE_push(level->nodes, node)) {\n                ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);\n                goto node_error;\n            }\n        }\n    }\n\n    if (extra_data) {\n        if (tree->extra_data == NULL)\n            tree->extra_data = sk_X509_POLICY_DATA_new_null();\n        if (tree->extra_data == NULL){\n            ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);\n            goto node_error;\n        }\n        if (!sk_X509_POLICY_DATA_push(tree->extra_data, data)) {\n            ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);\n            goto node_error;\n        }\n    }\n\n    tree->node_count++;\n    if (parent)\n        parent->nchild++;\n\n    return node;\n\n node_error:\n    ossl_policy_node_free(node);\n    return NULL;\n}", "target": 2, "idx": 10557}
{"commit_id": "8fc52d77d6f66c438c98d536e2309b5fd13f90de", "project": "php/php-src", "func": "static void dom_load_html(INTERNAL_FUNCTION_PARAMETERS, int mode) /* {{{ */\n{\n\tzval *id;\n\txmlDoc *docp = NULL, *newdoc;\n\tdom_object *intern;\n\tdom_doc_propsptr doc_prop;\n\tchar *source;\n\tint source_len, refcount, ret;\n\tlong options = 0;\n\thtmlParserCtxtPtr ctxt;\n\n\tid = getThis();\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|l\", &source, &source_len, &options) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (!source_len) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Empty string supplied as input\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (mode == DOM_LOAD_FILE) {\n\t\tif (CHECK_NULL_PATH(source, source_len)) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid file source\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tctxt = htmlCreateFileParserCtxt(source, NULL);\n\t} else {\n\t\tsource_len = xmlStrlen(source);\n\t\tctxt = htmlCreateMemoryParserCtxt(source, source_len);\n\t}\n\n\tif (!ctxt) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (options) {\n\t\thtmlCtxtUseOptions(ctxt, options);\n\t}\n\n\tctxt->vctxt.error = php_libxml_ctx_error;\n\tctxt->vctxt.warning = php_libxml_ctx_warning;\n\tif (ctxt->sax != NULL) {\n\t\tctxt->sax->error = php_libxml_ctx_error;\n\t\tctxt->sax->warning = php_libxml_ctx_warning;\n\t}\n\thtmlParseDocument(ctxt);\n\tnewdoc = ctxt->myDoc;\n\thtmlFreeParserCtxt(ctxt);\n\n\tif (!newdoc)\n\t\tRETURN_FALSE;\n\n\tif (id != NULL && instanceof_function(Z_OBJCE_P(id), dom_document_class_entry TSRMLS_CC)) {\n\t\tintern = (dom_object *)zend_object_store_get_object(id TSRMLS_CC);\n\t\tif (intern != NULL) {\n\t\t\tdocp = (xmlDocPtr) dom_object_get_node(intern);\n\t\t\tdoc_prop = NULL;\n\t\t\tif (docp != NULL) {\n\t\t\t\tphp_libxml_decrement_node_ptr((php_libxml_node_object *) intern TSRMLS_CC);\n\t\t\t\tdoc_prop = intern->document->doc_props;\n\t\t\t\tintern->document->doc_props = NULL;\n\t\t\t\trefcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern TSRMLS_CC);\n\t\t\t\tif (refcount != 0) {\n\t\t\t\t\tdocp->_private = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tintern->document = NULL;\n\t\t\tif (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, newdoc TSRMLS_CC) == -1) {\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tintern->document->doc_props = doc_prop;\n\t\t}\n\n\t\tphp_libxml_increment_node_ptr((php_libxml_node_object *)intern, (xmlNodePtr)newdoc, (void *)intern TSRMLS_CC);\n\n\t\tRETURN_TRUE;\n\t} else {\n\t\tDOM_RET_OBJ((xmlNodePtr) newdoc, &ret, NULL);\n\t}\n}", "target": 1, "idx": 10558}
{"commit_id": "b67fbebd4cf980aecbcc750e1462128bffe8ae15", "project": "torvalds/linux", "func": "static inline void tlb_end_vma(struct mmu_gather *tlb, struct vm_area_struct *vma)\n{\n\tif (tlb->fullmm)\n\t\treturn;\n\n\t/*\n\t * VM_PFNMAP is more fragile because the core mm will not track the\n\t * page mapcount -- there might not be page-frames for these PFNs after\n\t * all. Force flush TLBs for such ranges to avoid munmap() vs\n\t * unmap_mapping_range() races.\n\t */\n\tif (tlb->vma_pfn || !IS_ENABLED(CONFIG_MMU_GATHER_MERGE_VMAS)) {\n\t\t/*\n\t\t * Do a TLB flush and reset the range at VMA boundaries; this avoids\n\t\t * the ranges growing with the unused space between consecutive VMAs.\n\t\t */\n\t\ttlb_flush_mmu_tlbonly(tlb);\n\t}\n}", "target": 1, "idx": 10559}
{"commit_id": "c0ddc8634845aba50774add6e4b73fdaffc82656", "project": "xen-project/xen", "func": "static unsigned long double_evtchn_lock(struct evtchn *lchn,\n                                        struct evtchn *rchn)\n{\n    unsigned long flags;\n\n    if ( lchn <= rchn )\n    {\n        spin_lock_irqsave(&lchn->lock, flags);\n        if ( lchn != rchn )\n            spin_lock(&rchn->lock);\n    }\n    else\n    {\n        spin_lock_irqsave(&rchn->lock, flags);\n        spin_lock(&lchn->lock);\n    }\n\n    return flags;\n}", "target": 2, "idx": 10560}
{"commit_id": "0e215b8d3de29dcec8b02ee9196ca3bfd5a8c653", "project": "nanomq/NanoNNG", "func": "int32_t\nconn_handler(uint8_t *packet, conn_param *cparam, size_t max)\n{\n\tuint32_t len, tmp, pos = 0, len_of_var = 0;\n\tint      len_of_str = 0;\n\tint32_t  rv         = 0;\n\n\tif (packet[pos] != CMD_CONNECT) {\n\t\treturn (-1);\n\t} else {\n\t\tpos++;\n\t}\n\n\t// remaining length\n\tlen = (uint32_t) get_var_integer(packet + pos, &len_of_var);\n\tpos += len_of_var;\n\t// protocol name\n\tcparam->pro_name.body =\n\t    (char *) copyn_utf8_str(packet, &pos, &len_of_str, max-pos);\n\tcparam->pro_name.len = len_of_str;\n\trv                   = len_of_str < 0 ? PROTOCOL_ERROR : 0;\n\tlog_trace(\"pro_name: %s\", cparam->pro_name.body);\n\t// protocol ver\n\tcparam->pro_ver = packet[pos];\n\tpos++;\n\t// connect flag\n\tcparam->con_flag    = packet[pos];\n\tcparam->clean_start = (cparam->con_flag & 0x02) >> 1;\n\tcparam->will_flag   = (cparam->con_flag & 0x04) >> 2;\n\tcparam->will_qos    = (cparam->con_flag & 0x18) >> 3;\n\tcparam->will_retain = (cparam->con_flag & 0x20) >> 5;\n\tlog_trace(\"conn flag:%x\", cparam->con_flag);\n\tpos++;\n\t// keepalive\n\tNNI_GET16(packet + pos, tmp);\n\tcparam->keepalive_mqtt = tmp;\n\tpos += 2;\n\t// properties\n\n\tif (cparam->pro_ver == MQTT_PROTOCOL_VERSION_v5) {\n\t\t// check length\n\t\tlog_trace(\"MQTT V5 Properties\");\n\t\tlen_of_var = 0;\n\t\tcparam->prop_len = (uint32_t) get_var_integer(packet + pos, &len_of_var);\n\t\tif (cparam->prop_len > (max - pos - 1 - cparam->will_flag*2 ))\n\t\t\treturn PROTOCOL_ERROR;\n\t\tlog_debug(\"remain len %d max len %d prop len %d pos %d\", len, max, cparam->prop_len, pos);\n\t\tcparam->properties = decode_buf_properties(\n\t\t    packet, len, &pos, &cparam->prop_len, true);\n\t\tif (cparam->properties) {\n\t\t\tconn_param_set_property(cparam, cparam->properties);\n\t\t\tif ((rv = check_properties(cparam->properties)) !=\n\t\t\t    SUCCESS) {\n\t\t\t\treturn rv;\n\t\t\t}\n\t\t}\n\t}\n\tlog_trace(\"pos after property: [%d]\", pos);\n\n\t// payload client_id\n\tcparam->clientid.body =\n\t    (char *) copyn_utf8_str(packet, &pos, &len_of_str, max-pos);\n\tcparam->clientid.len = len_of_str;\n\n\tif (len_of_str == 0) {\n\t\tchar clientid_r[20] = {0};\n\t\tsnprintf(clientid_r, 20, \"nanomq-%08x\", nni_random());\n\t\tclientid_r[19]        = '\\0';\n\t\tcparam->clientid.body = nng_strdup(clientid_r);\n\t\tcparam->clientid.len  = strlen(clientid_r);\n\t\tcparam->assignedid    = true;\n\t} else if (len_of_str < 0) {\n\t\treturn (PROTOCOL_ERROR);\n\t}\n\tlog_trace(\"clientid: [%s] [%d]\", cparam->clientid.body, len_of_str);\n\n\tif (cparam->pro_ver == MQTT_PROTOCOL_VERSION_v5 && cparam->assignedid) {\n\t\tproperty *assigned_cid =\n\t\t    property_set_value_str(ASSIGNED_CLIENT_IDENTIFIER,\n\t\t        cparam->clientid.body, cparam->clientid.len, false);\n\t\tif (cparam->properties == NULL) {\n\t\t\tcparam->properties = property_alloc();\n\t\t}\n\t\tproperty_append(cparam->properties, assigned_cid);\n\t}\n\t// will topic\n\tif (rv == 0 && cparam->will_flag != 0) {\n\t\tif (cparam->pro_ver == MQTT_PROTOCOL_VERSION_v5) {\n\t\t\tcparam->will_properties = decode_buf_properties(\n\t\t\t    packet, len, &pos, &cparam->will_prop_len, true);\n\t\t\tif (cparam->will_properties) {\n\t\t\t\tconn_param_set_will_property(\n\t\t\t\t    cparam, cparam->will_properties);\n\t\t\t\tif ((rv = check_properties(\n\t\t\t\t         cparam->will_properties)) !=\n\t\t\t\t    SUCCESS) {\n\t\t\t\t\treturn rv;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcparam->will_topic.body =\n\t\t    (char *) copyn_utf8_str(packet, &pos, &len_of_str, max-pos);\n\t\tcparam->will_topic.len = len_of_str;\n\t\trv                     = len_of_str < 0 ? 1 : 0;\n\t\tif (cparam->will_topic.body == NULL || rv != 0) {\n\t\t\trv = PROTOCOL_ERROR;\n\t\t\treturn rv;\n\t\t}\n\t\tlog_trace(\"will_topic: %s %d\", cparam->will_topic.body, rv);\n\t\t// will msg\n\t\tif (rv == 0) {\n\t\t\tif (cparam->payload_format_indicator == 0) {\n\t\t\t\tcparam->will_msg.body = (char *) copyn_str(\n\t\t\t\t    packet, &pos, &len_of_str, max - pos);\n\t\t\t} else if (rv == 0 &&\n\t\t\t    cparam->payload_format_indicator == 0x01) {\n\t\t\t\tcparam->will_msg.body =\n\t\t\t\t    (char *) copyn_utf8_str(\n\t\t\t\t        packet, &pos, &len_of_str, max - pos);\n\t\t\t}\n\t\t\tcparam->will_msg.len = len_of_str;\n\t\t\trv = len_of_str < 0 ? PAYLOAD_FORMAT_INVALID : 0;\n\t\t\tlog_trace(\n\t\t\t    \"will_msg: %s %d\", cparam->will_msg.body, rv);\n\t\t}\n\t}\n\n\t// username\n\tif (rv == 0 && (cparam->con_flag & 0x80) > 0) {\n\t\tcparam->username.body =\n\t\t    (char *) copyn_utf8_str(packet, &pos, &len_of_str, max-pos);\n\t\tcparam->username.len = len_of_str;\n\t\trv                   = len_of_str < 0 ? PAYLOAD_FORMAT_INVALID : 0;\n\t\tif (rv != 0) {\n\t\t\treturn rv;\n\t\t}\n\t\tlog_trace(\n\t\t    \"username: %s %d\", cparam->username.body, len_of_str);\n\t}\n\t// password\n\tif (rv == 0 && (cparam->con_flag & 0x40) > 0) {\n\t\tcparam->password.body =\n\t\t    copyn_utf8_str(packet, &pos, &len_of_str, max-pos);\n\t\tcparam->password.len = len_of_str;\n\t\trv                   = len_of_str < 0 ? PAYLOAD_FORMAT_INVALID : 0;\n\t\tif (rv != 0) {\n\t\t\treturn rv;\n\t\t}\n\t\tlog_trace(\n\t\t    \"password: %s %d\", cparam->password.body, len_of_str);\n\t}\n\tif (len + len_of_var + 1 != pos) {\n\t\tlog_error(\"in connect handler\");\n\t\trv = PROTOCOL_ERROR;\n\t}\n\treturn rv;\n}", "target": 2, "idx": 10561}
{"commit_id": "2dbd8f6e66b73ed43d9b81a45350922b80f75397", "project": "libgd", "func": "int\n_gdGetColors (gdIOCtx * in, gdImagePtr im, int gd2xFlag)\n{\n\tint i;\n\tif (gd2xFlag) {\n\t\tint trueColorFlag;\n\t\tif (!gdGetByte (&trueColorFlag, in)) {\n\t\t\tgoto fail1;\n\t\t}\n\t\t/* 2.0.12: detect bad truecolor .gd files created by pre-2.0.12.\n\t\t   Beginning in 2.0.12 truecolor is indicated by the initial 2-byte\n\t\t   signature. */\n\t\tif (trueColorFlag != im->trueColor) {\n\t\t\tgoto fail1;\n\t\t}\n\t\t/* This should have been a word all along */\n\t\tif (!im->trueColor) {\n\t\t\tif (!gdGetWord (&im->colorsTotal, in)) {\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t\tif (im->colorsTotal > gdMaxColors) {\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t}\n\t\t/* Int to accommodate truecolor single-color transparency */\n\t\tif (!gdGetInt (&im->transparent, in)) {\n\t\t\tgoto fail1;\n\t\t}\n\t} else {\n\t\tif (!gdGetByte (&im->colorsTotal, in)) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tif (!gdGetWord (&im->transparent, in)) {\n\t\t\tgoto fail1;\n\t\t}\n\t}\n\t/* Make sure transparent index is within bounds of the palette. */\n\tif (!(im->trueColor) && (im->transparent >= im->colorsTotal || im->transparent < 0)) {\n\t\tim->transparent = (-1);\n\t}\n\tGD2_DBG (printf\n\t         (\"Palette had %d colours (T=%d)\\n\", im->colorsTotal,\n\t          im->transparent));\n\tif (im->trueColor) {\n\t\treturn TRUE;\n\t}\n\tfor (i = 0; (i < gdMaxColors); i++) {\n\t\tif (!gdGetByte (&im->red[i], in)) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tif (!gdGetByte (&im->green[i], in)) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tif (!gdGetByte (&im->blue[i], in)) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tif (gd2xFlag) {\n\t\t\tif (!gdGetByte (&im->alpha[i], in)) {\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; (i < im->colorsTotal); i++) {\n\t\tim->open[i] = 0;\n\t};\n\n\treturn TRUE;\nfail1:\n\treturn FALSE;\n}", "target": 2, "idx": 10562}
{"commit_id": "9a47e9cff994f37f7f0dbd9ae23740d0f64f9fe6", "project": "torvalds/linux", "func": "static void snd_timer_user_ccallback(struct snd_timer_instance *timeri,\n\t\t\t\t     int event,\n\t\t\t\t     struct timespec *tstamp,\n\t\t\t\t     unsigned long resolution)\n{\n\tstruct snd_timer_user *tu = timeri->callback_data;\n\tstruct snd_timer_tread r1;\n\tunsigned long flags;\n\n\tif (event >= SNDRV_TIMER_EVENT_START &&\n\t    event <= SNDRV_TIMER_EVENT_PAUSE)\n\t\ttu->tstamp = *tstamp;\n\tif ((tu->filter & (1 << event)) == 0 || !tu->tread)\n\t\treturn;\n\tmemset(&r1, 0, sizeof(r1));\n\tr1.event = event;\n\tr1.tstamp = *tstamp;\n\tr1.val = resolution;\n\tspin_lock_irqsave(&tu->qlock, flags);\n\tsnd_timer_user_append_to_tqueue(tu, &r1);\n\tspin_unlock_irqrestore(&tu->qlock, flags);\n\tkill_fasync(&tu->fasync, SIGIO, POLL_IN);\n\twake_up(&tu->qchange_sleep);\n}", "target": 1, "idx": 10563}
{"commit_id": "e362c0a34c814bebb78f5ec2fc3747475d1ed259", "project": "pcmacdon/jsish", "func": "static Jsi_RC jsi_ArrayIndexSubCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr, int op) {\n    int istart = 0, n, i = 0, dir=1, idx=-1;\n    Jsi_Value *seq = Jsi_ValueArrayIndex(interp, args, 0),\n        *start = Jsi_ValueArrayIndex(interp, args, 1);\n    Jsi_Obj *obj = _this->d.obj;\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n\n    if (!seq) {\n        goto bail;\n    }\n    \n    n = jsi_SizeOfArray(interp, obj);    \n    if (n == 0) {\n        goto bail;\n    }\n    Jsi_Number nstart;\n    if (op == 2) {\n        istart = n-1;\n    }\n    if (start) {\n        if (Jsi_GetNumberFromValue(interp,start, &nstart)!=JSI_OK) return JSI_ERROR;\n        istart = (int)nstart;\n        if (istart > n)\n            goto bail;\n        if (istart < 0)\n            istart = (n+istart);\n        if (istart<0)\n            goto bail;\n    }\n    if (op == 2) {\n        istart = n-1;\n        dir = -1;\n    }\n    Jsi_ObjListifyArray(interp, obj);\n    for (i = istart; ; i+=dir)\n    {\n        if ((dir>0 && i>=n) || (dir<0 && i<0) || i>=(int)obj->arrCnt)\n            break;\n        if (obj->arr[i] && Jsi_ValueCmp(interp, obj->arr[i], seq, JSI_CMP_EXACT)==0) {\n            idx = i;\n            break;\n        }\n    }\nbail:\n    if (op == 3)\n        Jsi_ValueMakeBool(interp, ret, (idx!=-1));\n    else\n        Jsi_ValueMakeNumber(interp, ret, idx);\n    return JSI_OK;\n}", "target": 1, "idx": 10564}
{"commit_id": "1aa2c0e0fb60a1b0bf793e0d834073ffe50fb196", "project": "pjsip/pjproject", "func": "PJ_DEF(pj_status_t) pjmedia_vid_conf_remove_port( pjmedia_vid_conf *vid_conf,\n\t\t\t\t\t\t  unsigned slot)\n{\n    vconf_port *cport;\n\n    PJ_ASSERT_RETURN(vid_conf && slot<vid_conf->opt.max_slot_cnt, PJ_EINVAL);\n\n    pj_mutex_lock(vid_conf->mutex);\n\n    /* Port must be valid. */\n    cport = vid_conf->ports[slot];\n    if (cport == NULL) {\n\tpj_mutex_unlock(vid_conf->mutex);\n\treturn PJ_EINVAL;\n    }\n\n    /* Disconnect slot -> listeners */\n    while (cport->listener_cnt) {\n\tpjmedia_vid_conf_disconnect_port(vid_conf, slot,\n\t\t\t\t\t cport->listener_slots[0]);\n    }\n\n    /* Disconnect transmitters -> slot */\n    while (cport->transmitter_cnt) {\n\tpjmedia_vid_conf_disconnect_port(vid_conf,\n\t\t\t\t\t cport->transmitter_slots[0], slot);\n    }\n\n    /* Remove the port. */\n    vid_conf->ports[slot] = NULL;\n    --vid_conf->port_cnt;\n\n    PJ_LOG(4,(THIS_FILE,\"Removed port %d (%.*s)\",\n\t      slot, (int)cport->name.slen, cport->name.ptr));\n\n    /* Release pool */\n    pj_pool_safe_release(&cport->pool);\n\n    if (AUTO_STOP_CLOCK && vid_conf->connect_cnt == 0) {\n\tpj_status_t status;\n\n\t/* Warning: will stuck if this is called from the clock thread */\n\tstatus = pjmedia_clock_stop(vid_conf->clock);\n\tif (status != PJ_SUCCESS) {\n\t    PJ_PERROR(4, (THIS_FILE, status, \"Failed to stop clock\"));\n\t    pj_mutex_unlock(vid_conf->mutex);\n\t    return status;\n\t}\n    }\n\n    pj_mutex_unlock(vid_conf->mutex);\n\n    return PJ_SUCCESS;\n}", "target": 1, "idx": 10565}
{"commit_id": "faf99408e3f9f706fc3809dd400e831f989778d3", "project": "davea42/libdwarf-code", "func": "static int\nprint_actuals_and_locals(Dwarf_Debug dbg,\n    Dwarf_Line_Context line_context,\n    Dwarf_Unsigned bogus_bytes_count,\n    Dwarf_Small *bogus_bytes_ptr,\n    Dwarf_Small *orig_line_ptr,\n    Dwarf_Small *line_ptr,\n    Dwarf_Small *section_start,\n    Dwarf_Small *line_ptr_actuals,\n    Dwarf_Small *line_ptr_end,\n    Dwarf_Half   address_size,\n    int *        err_count_out,\n    Dwarf_Error *error)\n{\n    int res = 0;\n    dwarfstring m8;\n    Dwarf_Unsigned offset = 0;\n\n    dwarfstring_constructor(&m8);\n    if (bogus_bytes_count > 0) {\n        Dwarf_Unsigned wcount = bogus_bytes_count;\n        Dwarf_Unsigned boffset = bogus_bytes_ptr - section_start;\n\n        dwarfstring_append_printf_u(&m8,\n            \"*** DWARF CHECK: the line table prologue  header_length \"\n            \" is %\" DW_PR_DUu \" too high, we pretend it is smaller.\",\n            wcount);\n        dwarfstring_append_printf_u(&m8,\n            \"Section offset: 0x%\"\n            DW_PR_XZEROS DW_PR_DUx,\n            boffset);\n        dwarfstring_append_printf_u(&m8,\n            \" (%\" DW_PR_DUu \") ***\\n\",\n            boffset);\n        *err_count_out += 1;\n    }\n    offset = line_ptr - section_start;\n    dwarfstring_append_printf_u(&m8,\n        \"  statement prog offset in section: 0x%\"\n        DW_PR_XZEROS DW_PR_DUx,\n        offset);\n    dwarfstring_append_printf_u(&m8,\n        \" (%\" DW_PR_DUu \")\\n\",\n        offset);\n    _dwarf_printf(dbg,dwarfstring_string(&m8));\n    dwarfstring_reset(&m8);\n\n    {\n        Dwarf_Bool doaddrs = false;\n        Dwarf_Bool dolines = true;\n\n        if (!line_ptr_actuals) {\n            /* Normal single level line table. */\n\n            Dwarf_Bool is_single_table = true;\n            Dwarf_Bool is_actuals_table = false;\n            print_line_header(dbg, is_single_table, is_actuals_table);\n            res = read_line_table_program(dbg,\n                line_ptr, line_ptr_end, orig_line_ptr,\n                section_start,\n                line_context,\n                address_size, doaddrs, dolines,\n                is_single_table,\n                is_actuals_table,\n                error,\n                err_count_out);\n            if (res != DW_DLV_OK) {\n                dwarfstring_destructor(&m8);\n                dwarf_srclines_dealloc_b(line_context);\n                return res;\n            }\n        } else {\n            Dwarf_Bool is_single_table = false;\n            Dwarf_Bool is_actuals_table = false;\n            if (line_context->lc_version_number !=\n                EXPERIMENTAL_LINE_TABLES_VERSION) {\n                dwarf_srclines_dealloc_b(line_context);\n                dwarfstring_destructor(&m8);\n                _dwarf_error(dbg, error, DW_DLE_VERSION_STAMP_ERROR);\n                return (DW_DLV_ERROR);\n            }\n            /* Read Logicals */\n            print_line_header(dbg, is_single_table, is_actuals_table);\n            res = read_line_table_program(dbg,\n                line_ptr, line_ptr_actuals, orig_line_ptr,\n                section_start,\n                line_context,\n                address_size, doaddrs, dolines,\n                is_single_table,\n                is_actuals_table,\n                error,err_count_out);\n            if (res != DW_DLV_OK) {\n                dwarfstring_destructor(&m8);\n                dwarf_srclines_dealloc_b(line_context);\n                return res;\n            }\n            if (line_context->lc_actuals_table_offset > 0) {\n                is_actuals_table = true;\n                /* Read Actuals */\n\n                print_line_header(dbg, is_single_table,\n                    is_actuals_table);\n                res = read_line_table_program(dbg,\n                    line_ptr_actuals, line_ptr_end, orig_line_ptr,\n                    section_start,\n                    line_context,\n                    address_size, doaddrs, dolines,\n                    is_single_table,\n                    is_actuals_table,\n                    error,\n                    err_count_out);\n                if (res != DW_DLV_OK) {\n                    dwarfstring_destructor(&m8);\n                    dwarf_srclines_dealloc_b(line_context);\n                    return res;\n                }\n            }\n        }\n    }\n    dwarfstring_destructor(&m8);\n    dwarf_srclines_dealloc_b(line_context);\n    return DW_DLV_OK;\n}", "target": 1, "idx": 10566}
{"commit_id": "7872a831783e17dcc4d0aa70cffc256afb664f7a", "project": "ceph", "func": "int RGWCivetWeb::init_env(CephContext *cct)\n{\n  env.init(cct);\n  const struct mg_request_info* info = mg_get_request_info(conn);\n\n  if (! info) {\n    // request info is NULL; we have no info about the connection\n    return -EINVAL;\n  }\n\n  for (int i = 0; i < info->num_headers; i++) {\n    const struct mg_request_info::mg_header* header = &info->http_headers[i];\n\n    if (header->name == nullptr || header->value==nullptr) {\n      lderr(cct) << \"client supplied malformatted headers\" << dendl;\n      return -EINVAL;\n    }\n\n    const boost::string_ref name(header->name);\n    const auto& value = header->value;\n\n    if (boost::algorithm::iequals(name, \"content-length\")) {\n      env.set(\"CONTENT_LENGTH\", value);\n      continue;\n    }\n    if (boost::algorithm::iequals(name, \"content-type\")) {\n      env.set(\"CONTENT_TYPE\", value);\n      continue;\n    }\n    if (boost::algorithm::iequals(name, \"connection\")) {\n      explicit_keepalive = boost::algorithm::iequals(value, \"keep-alive\");\n      explicit_conn_close = boost::algorithm::iequals(value, \"close\");\n    }\n\n    static const boost::string_ref HTTP_{\"HTTP_\"};\n\n    char buf[name.size() + HTTP_.size() + 1];\n    auto dest = std::copy(std::begin(HTTP_), std::end(HTTP_), buf);\n    for (auto src = name.begin(); src != name.end(); ++src, ++dest) {\n      if (*src == '-') {\n        *dest = '_';\n      } else {\n        *dest = std::toupper(*src);\n      }\n    }\n    *dest = '\\0';\n\n    env.set(buf, value);\n  }\n\n  env.set(\"REMOTE_ADDR\", info->remote_addr);\n  env.set(\"REQUEST_METHOD\", info->request_method);\n  env.set(\"HTTP_VERSION\", info->http_version);\n  env.set(\"REQUEST_URI\", info->request_uri); // get the full uri, we anyway handle abs uris later\n  env.set(\"SCRIPT_URI\", info->uri); /* FIXME */\n  if (info->query_string) {\n    env.set(\"QUERY_STRING\", info->query_string);\n  }\n  if (info->remote_user) {\n    env.set(\"REMOTE_USER\", info->remote_user);\n  }\n\n  if (port <= 0)\n    lderr(cct) << \"init_env: bug: invalid port number\" << dendl;\n  char port_buf[16];\n  snprintf(port_buf, sizeof(port_buf), \"%d\", port);\n  env.set(\"SERVER_PORT\", port_buf);\n  if (info->is_ssl) {\n    env.set(\"SERVER_PORT_SECURE\", port_buf);\n  }\n  return 0;\n}", "target": 2, "idx": 10567}
{"commit_id": "30ca16ec87206294f4ad0e9688c88f32421b343e", "project": "llvm/llvm-project", "func": "static Type convertStructTypePacked(spirv::StructType type,\n                                    LLVMTypeConverter &converter) {\n  SmallVector<Type> elementsVector;\n  if (failed(converter.convertTypes(type.getElementTypes(), elementsVector)))\n    return nullptr;\n  return LLVM::LLVMStructType::getLiteral(type.getContext(), elementsVector,\n                                          /*isPacked=*/true);\n}", "target": 1, "idx": 10568}
{"commit_id": "fca9874a9b42a2134f907d2fb46ab774a831404a", "project": "tensorflow", "func": "Status ConvBackpropComputeDimensionsV2(\n    StringPiece label, int num_spatial_dims, const TensorShape& input_shape,\n    const TensorShape& filter_shape, const TensorShape& out_backprop_shape,\n    const gtl::ArraySlice<int32>& dilations, const std::vector<int32>& strides,\n    Padding padding, absl::Span<const int64> explicit_paddings,\n    TensorFormat data_format, ConvBackpropDimensions* dims) {\n  // The + 2 in the following line is for the batch and feature dimensions.\n  const int num_dims = num_spatial_dims + 2;\n  if (input_shape.dims() != num_dims) {\n    return errors::InvalidArgument(label, \": input must be \", num_dims,\n                                   \"-dimensional\");\n  }\n  if (filter_shape.dims() != num_dims) {\n    return errors::InvalidArgument(label, \": filter must be \", num_dims,\n                                   \"-dimensional\");\n  }\n  if (out_backprop_shape.dims() != num_dims) {\n    return errors::InvalidArgument(label, \": out_backprop must be \", num_dims,\n                                   \"-dimensional\");\n  }\n  int batch_dim = GetTensorBatchDimIndex(num_dims, data_format);\n  dims->batch_size = input_shape.dim_size(batch_dim);\n  if (dims->batch_size != out_backprop_shape.dim_size(batch_dim)) {\n    return errors::InvalidArgument(\n        label, \": input and out_backprop must have the same batch size.\",\n        \" Input batch: \", dims->batch_size,\n        \", outbackprop batch: \", out_backprop_shape.dim_size(batch_dim),\n        \", batch_dim: \", batch_dim);\n  }\n\n  int feature_dim = GetTensorFeatureDimIndex(num_dims, data_format);\n  dims->in_depth = input_shape.dim_size(feature_dim);\n  // The input and output feature dimensions are the second last and last\n  // dimensions of the filter Tensor.\n  VLOG(2) << \"input vs filter_in depth \" << dims->in_depth << \" \"\n          << filter_shape.dim_size(num_dims - 2);\n  if (filter_shape.dim_size(num_dims - 2) <= 0) {\n    return errors ::InvalidArgument(\n        label, \": filter depth must be strictly greated than zero\");\n  }\n  if (dims->in_depth % filter_shape.dim_size(num_dims - 2)) {\n    return errors::InvalidArgument(\n        label, \": input depth must be evenly divisible by filter depth\");\n  }\n  dims->out_depth = filter_shape.dim_size(num_dims - 1);\n  if (dims->out_depth != out_backprop_shape.dim_size(feature_dim)) {\n    return errors::InvalidArgument(\n        label, \": filter and out_backprop must have the same out_depth\");\n  }\n  dims->spatial_dims.resize(num_spatial_dims);\n  for (int i = 0; i < num_spatial_dims; ++i) {\n    int image_dim = GetTensorSpatialDimIndex(num_dims, data_format, i);\n    int64 padding_before = -1, padding_after = -1;\n    if (padding == EXPLICIT) {\n      padding_before = explicit_paddings[2 * image_dim];\n      padding_after = explicit_paddings[2 * image_dim + 1];\n    }\n    TF_RETURN_IF_ERROR(ConvBackpropExtractAndVerifyDimension(\n        label, input_shape, filter_shape, out_backprop_shape, dilations,\n        strides, padding, padding_before, padding_after, image_dim, i,\n        &dims->spatial_dims[i]));\n  }\n  return Status::OK();\n}", "target": 0, "idx": 10569}
{"commit_id": "bb6c11fb889e6c11b0ee122b828132ee763b5856", "project": "python-pillow/Pillow", "func": "int\nImagingFliDecode(Imaging im, ImagingCodecState state, UINT8 *buf, Py_ssize_t bytes) {\n    UINT8 *ptr;\n    int framesize;\n    int c, chunks, advance;\n    int l, lines;\n    int i, j, x = 0, y, ymax;\n\n    /* If not even the chunk size is present, we'd better leave */\n\n    if (bytes < 4) {\n        return 0;\n    }\n\n    /* We don't decode anything unless we have a full chunk in the\n       input buffer */\n\n    ptr = buf;\n\n    framesize = I32(ptr);\n    if (framesize < I32(ptr)) {\n        return 0;\n    }\n\n    /* Make sure this is a frame chunk.  The Python driver takes\n       case of other chunk types. */\n\n    if (bytes < 8) {\n        state->errcode = IMAGING_CODEC_OVERRUN;\n        return -1;\n    }\n    if (I16(ptr + 4) != 0xF1FA) {\n        state->errcode = IMAGING_CODEC_UNKNOWN;\n        return -1;\n    }\n\n    chunks = I16(ptr + 6);\n    ptr += 16;\n    bytes -= 16;\n\n    /* Process subchunks */\n    for (c = 0; c < chunks; c++) {\n        UINT8 *data;\n        if (bytes < 10) {\n            state->errcode = IMAGING_CODEC_OVERRUN;\n            return -1;\n        }\n        data = ptr + 6;\n        switch (I16(ptr + 4)) {\n            case 4:\n            case 11:\n                /* FLI COLOR chunk */\n                break; /* ignored; handled by Python code */\n            case 7:\n                /* FLI SS2 chunk (word delta) */\n                /* OOB ok, we've got 4 bytes min on entry */\n                lines = I16(data);\n                data += 2;\n                for (l = y = 0; l < lines && y < state->ysize; l++, y++) {\n                    UINT8 *local_buf = (UINT8 *)im->image[y];\n                    int p, packets;\n                    ERR_IF_DATA_OOB(2)\n                    packets = I16(data);\n                    data += 2;\n                    while (packets & 0x8000) {\n                        /* flag word */\n                        if (packets & 0x4000) {\n                            y += 65536 - packets; /* skip lines */\n                            if (y >= state->ysize) {\n                                state->errcode = IMAGING_CODEC_OVERRUN;\n                                return -1;\n                            }\n                            local_buf = (UINT8 *)im->image[y];\n                        } else {\n                            /* store last byte (used if line width is odd) */\n                            local_buf[state->xsize - 1] = (UINT8)packets;\n                        }\n                        ERR_IF_DATA_OOB(2)\n                        packets = I16(data);\n                        data += 2;\n                    }\n                    for (p = x = 0; p < packets; p++) {\n                        ERR_IF_DATA_OOB(2)\n                        x += data[0]; /* pixel skip */\n                        if (data[1] >= 128) {\n                            ERR_IF_DATA_OOB(4)\n                            i = 256 - data[1]; /* run */\n                            if (x + i + i > state->xsize) {\n                                break;\n                            }\n                            for (j = 0; j < i; j++) {\n                                local_buf[x++] = data[2];\n                                local_buf[x++] = data[3];\n                            }\n                            data += 2 + 2;\n                        } else {\n                            i = 2 * (int)data[1]; /* chunk */\n                            if (x + i > state->xsize) {\n                                break;\n                            }\n                            ERR_IF_DATA_OOB(2 + i)\n                            memcpy(local_buf + x, data + 2, i);\n                            data += 2 + i;\n                            x += i;\n                        }\n                    }\n                    if (p < packets) {\n                        break; /* didn't process all packets */\n                    }\n                }\n                if (l < lines) {\n                    /* didn't process all lines */\n                    state->errcode = IMAGING_CODEC_OVERRUN;\n                    return -1;\n                }\n                break;\n            case 12:\n                /* FLI LC chunk (byte delta) */\n                /* OOB Check ok, we have 4 bytes min here */\n                y = I16(data);\n                ymax = y + I16(data + 2);\n                data += 4;\n                for (; y < ymax && y < state->ysize; y++) {\n                    UINT8 *out = (UINT8 *)im->image[y];\n                    ERR_IF_DATA_OOB(1)\n                    int p, packets = *data++;\n                    for (p = x = 0; p < packets; p++, x += i) {\n                        ERR_IF_DATA_OOB(2)\n                        x += data[0]; /* skip pixels */\n                        if (data[1] & 0x80) {\n                            i = 256 - data[1]; /* run */\n                            if (x + i > state->xsize) {\n                                break;\n                            }\n                            ERR_IF_DATA_OOB(3)\n                            memset(out + x, data[2], i);\n                            data += 3;\n                        } else {\n                            i = data[1]; /* chunk */\n                            if (x + i > state->xsize) {\n                                break;\n                            }\n                            ERR_IF_DATA_OOB(2 + i)\n                            memcpy(out + x, data + 2, i);\n                            data += i + 2;\n                        }\n                    }\n                    if (p < packets) {\n                        break; /* didn't process all packets */\n                    }\n                }\n                if (y < ymax) {\n                    /* didn't process all lines */\n                    state->errcode = IMAGING_CODEC_OVERRUN;\n                    return -1;\n                }\n                break;\n            case 13:\n                /* FLI BLACK chunk */\n                for (y = 0; y < state->ysize; y++) {\n                    memset(im->image[y], 0, state->xsize);\n                }\n                break;\n            case 15:\n                /* FLI BRUN chunk */\n                /* OOB, ok, we've got 4 bytes min on entry */\n                for (y = 0; y < state->ysize; y++) {\n                    UINT8 *out = (UINT8 *)im->image[y];\n                    data += 1; /* ignore packetcount byte */\n                    for (x = 0; x < state->xsize; x += i) {\n                        ERR_IF_DATA_OOB(2)\n                        if (data[0] & 0x80) {\n                            i = 256 - data[0];\n                            if (x + i > state->xsize) {\n                                break; /* safety first */\n                            }\n                            ERR_IF_DATA_OOB(i + 1)\n                            memcpy(out + x, data + 1, i);\n                            data += i + 1;\n                        } else {\n                            i = data[0];\n                            if (x + i > state->xsize) {\n                                break; /* safety first */\n                            }\n                            memset(out + x, data[1], i);\n                            data += 2;\n                        }\n                    }\n                    if (x != state->xsize) {\n                        /* didn't unpack whole line */\n                        state->errcode = IMAGING_CODEC_OVERRUN;\n                        return -1;\n                    }\n                }\n                break;\n            case 16:\n                /* COPY chunk */\n                if (state->xsize > bytes / state->ysize) {\n                    /* not enough data for frame */\n                    return ptr - buf; /* bytes consumed */\n                }\n                for (y = 0; y < state->ysize; y++) {\n                    UINT8 *local_buf = (UINT8 *)im->image[y];\n                    memcpy(local_buf, data, state->xsize);\n                    data += state->xsize;\n                }\n                break;\n            case 18:\n                /* PSTAMP chunk */\n                break; /* ignored */\n            default:\n                /* unknown chunk */\n                /* printf(\"unknown FLI/FLC chunk: %d\\n\", I16(ptr+4)); */\n                state->errcode = IMAGING_CODEC_UNKNOWN;\n                return -1;\n        }\n        advance = I32(ptr);\n        if (advance == 0 ) {\n            // If there's no advance, we're in in infinite loop\n            state->errcode = IMAGING_CODEC_BROKEN;\n            return -1;\n        }\n        if (advance < 0 || advance > bytes) {\n            state->errcode = IMAGING_CODEC_OVERRUN;\n            return -1;\n        }\n        ptr += advance;\n        bytes -= advance;\n    }\n\n    return -1; /* end of frame */\n}", "target": 2, "idx": 10570}
{"commit_id": "4419d10d576adefa36b0e0a9425d2569f7c0189f", "project": "tensorflow", "func": "Status Compute(OpKernelContext* context, AsyncOpKernel::DoneCallback done) {\n    const Tensor& data_t = context->input(0);\n    const Tensor& batch_index_t = context->input(1);\n\n    if (batch_index_t.shape().dim_size(0) > data_t.shape().dim_size(0)) {\n      return errors::InvalidArgument(\n          \"Wrong shape for index tensor. Expected 0th dimension size to be no \"\n          \"greater than \",\n          data_t.shape().dim_size(0),\n          \"; Got: \", batch_index_t.shape().dim_size(0), \".\");\n    }\n    if (batch_index_t.shape().dim_size(1) != 3) {\n      return errors::InvalidArgument(\n          \"Wrong shape for index tensor. Expected 1st dimension size to be 3 ; \"\n          \"Got: \",\n          batch_index_t.shape().dim_size(1), \".\");\n    }\n\n    if (!TensorShapeUtils::IsScalar(context->input(2).shape())) {\n      return errors::InvalidArgument(\n          \"Input id should be scalar; \"\n          \"Got: \",\n          context->input(2).DebugString(), \".\");\n    }\n    const int64_t batch_key = context->input(2).scalar<int64_t>()();\n    const bool nonempty_input = batch_index_t.dim_size(0) > 0;\n\n    // If we have a non-empty tensor, slice it up.\n    // (It is important to do this outside of the critical section below.)\n    // The following variables are populated iff 'nonempty_input==true'.\n    std::vector<int64_t> sizes;\n    std::vector<int64_t> batch_keys;\n    std::vector<Tensor> split_inputs;\n    if (nonempty_input) {\n      auto batch_indices =\n          batch_index_t.shaped<int64_t, 2>({batch_index_t.dim_size(0), 3});\n      for (int i = 0; i < batch_index_t.dim_size(0); ++i) {\n        sizes.push_back(batch_indices(i, 2) - batch_indices(i, 1));\n        batch_keys.push_back(batch_indices(i, 0));\n      }\n\n      TF_RETURN_IF_ERROR(Split(context, data_t, sizes, &split_inputs));\n    }\n\n    // Critical section.\n    std::vector<AsyncOpKernel::DoneCallback> done_callbacks_to_call;\n    Status status = [&]() -> Status {\n      mutex_lock ml(mu_);\n\n      // Check to see whether the tensor we want is already ready.\n      auto tensor_it = waiting_tensors_.find(batch_key);\n      if (tensor_it != waiting_tensors_.end()) {\n        context->set_output(0, tensor_it->second.tensor);\n        waiting_tensors_.erase(tensor_it);\n        done_callbacks_to_call.push_back(done);\n        return OkStatus();\n      }\n\n      const uint64 deadline_micros =\n          Env::Default()->NowMicros() + timeout_micros_;\n\n      // Add ourselves to the waitlist for tensors.\n      if (!waiting_callbacks_\n               .emplace(batch_key,\n                        WaitingCallback{deadline_micros, context, done})\n               .second) {\n        return errors::AlreadyExists(\n            \"Multiple session runs with the same batch key.\");\n      }\n\n      // If we have a non-empty tensor, finish the waitlisted runs,\n      // and store any remaining pieces.\n      if (nonempty_input) {\n        for (size_t i = 0; i < batch_keys.size(); ++i) {\n          auto runs_it = waiting_callbacks_.find(batch_keys[i]);\n          if (runs_it != waiting_callbacks_.end()) {\n            runs_it->second.context->set_output(0, split_inputs[i]);\n            done_callbacks_to_call.push_back(runs_it->second.done);\n            waiting_callbacks_.erase(runs_it);\n          } else {\n            // Note: the deadline here is in case we are arriving late and the\n            // kernel that should rendezvous with this tensor has already waited\n            // and timed out.\n            if (!waiting_tensors_\n                     .emplace(batch_keys[i],\n                              WaitingTensor{deadline_micros, split_inputs[i]})\n                     .second) {\n              return errors::AlreadyExists(\n                  \"Multiple tensors returned for same batch key.\");\n            }\n          }\n        }\n      }\n\n      return OkStatus();\n    }();\n\n    for (const AsyncOpKernel::DoneCallback& done_callback :\n         done_callbacks_to_call) {\n      done_callback();\n    }\n\n    return status;\n  }", "target": 1, "idx": 10571}
{"commit_id": "e8d5f92b8d30bb4ade76494490c3c065e12411b1", "project": "torvalds/linux", "func": "static int\nprinter_open(struct inode *inode, struct file *fd)\n{\n\tstruct printer_dev\t*dev;\n\tunsigned long\t\tflags;\n\tint\t\t\tret = -EBUSY;\n\n\tdev = container_of(inode->i_cdev, struct printer_dev, printer_cdev);\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tif (dev->interface < 0) {\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\treturn -ENODEV;\n\t}\n\n\tif (!dev->printer_cdev_open) {\n\t\tdev->printer_cdev_open = 1;\n\t\tfd->private_data = dev;\n\t\tret = 0;\n\t\t/* Change the printer status to show that it's on-line. */\n\t\tdev->printer_status |= PRINTER_SELECTED;\n\t}\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tkref_get(&dev->kref);\n\tDBG(dev, \"printer_open returned %x\\n\", ret);\n\treturn ret;\n}", "target": 1, "idx": 10572}
{"commit_id": "bceb03fd2be95097a7b409ea59914f332fb6bc86", "project": "gpac", "func": "GF_Err tenc_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TrackEncryptionBox *ptr = (GF_TrackEncryptionBox*) a;\n\tif (!a) return GF_BAD_PARAM;\n\n\tgf_isom_box_dump_start(a, \"TrackEncryptionBox\", trace);\n\n\tfprintf(trace, \"isEncrypted=\\\"%d\\\"\", ptr->isProtected);\n\tif (ptr->Per_Sample_IV_Size)\n\t\tfprintf(trace, \" IV_size=\\\"%d\\\" KID=\\\"\", ptr->Per_Sample_IV_Size);\n\telse {\n\t\tfprintf(trace, \" constant_IV_size=\\\"%d\\\" constant_IV=\\\"\", ptr->constant_IV_size);\n\t\tdump_data_hex(trace, (char *) ptr->constant_IV, ptr->constant_IV_size);\n\t\tfprintf(trace, \"\\\"  KID=\\\"\");\n\t}\n\tdump_data_hex(trace, (char *) ptr->KID, 16);\n\tif (ptr->version)\n\t\tfprintf(trace, \"\\\" crypt_byte_block=\\\"%d\\\" skip_byte_block=\\\"%d\", ptr->crypt_byte_block, ptr->skip_byte_block);\n\tfprintf(trace, \"\\\">\\n\");\n\tgf_isom_box_dump_done(\"TrackEncryptionBox\", a, trace);\n\treturn GF_OK;\n}", "target": 3, "idx": 10573}
{"commit_id": "0b074ab7fc0d575247b9cc9f93bb7e007ca38840", "project": "torvalds/linux", "func": "static int toneport_init(struct usb_line6 *line6,\n\t\t\t const struct usb_device_id *id)\n{\n\tint err;\n\tstruct usb_line6_toneport *toneport =  (struct usb_line6_toneport *) line6;\n\n\ttoneport->type = id->driver_info;\n\n\tline6->disconnect = line6_toneport_disconnect;\n\tline6->startup = toneport_startup;\n\n\t/* initialize PCM subsystem: */\n\terr = line6_init_pcm(line6, &toneport_pcm_properties);\n\tif (err < 0)\n\t\treturn err;\n\n\t/* register monitor control: */\n\terr = snd_ctl_add(line6->card,\n\t\t\t  snd_ctl_new1(&toneport_control_monitor,\n\t\t\t\t       line6->line6pcm));\n\tif (err < 0)\n\t\treturn err;\n\n\t/* register source select control: */\n\tif (toneport_has_source_select(toneport)) {\n\t\terr =\n\t\t    snd_ctl_add(line6->card,\n\t\t\t\tsnd_ctl_new1(&toneport_control_source,\n\t\t\t\t\t     line6->line6pcm));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tline6_read_serial_number(line6, &toneport->serial_number);\n\tline6_read_data(line6, 0x80c2, &toneport->firmware_version, 1);\n\n\tif (toneport_has_led(toneport)) {\n\t\terr = toneport_init_leds(toneport);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\terr = toneport_setup(toneport);\n\tif (err)\n\t\treturn err;\n\n\t/* register audio system: */\n\treturn snd_card_register(line6->card);\n}", "target": 1, "idx": 10574}
{"commit_id": "8d2e02ae650f00c4a53deb625211a0527126c605", "project": "xorg/lib/libX11", "func": "int\nXSetStandardProperties (\n    \tDisplay *dpy,\n    \tWindow w,\t\t/* window to decorate */\n    \t_Xconst char *name,\t/* name of application */\n    \t_Xconst char *icon_string,/* name string for icon */\n\tPixmap icon_pixmap,\t/* pixmap to use as icon, or None */\n    \tchar **argv,\t\t/* command to be used to restart application */\n    \tint argc,\t\t/* count of arguments */\n    \tXSizeHints *hints)\t/* size hints for window in its normal state */\n{\n\tXWMHints phints;\n\tphints.flags = 0;\n\n\tif (name != NULL) XStoreName (dpy, w, name);\n\n        if (safestrlen(icon_string) >= USHRT_MAX)\n            return 1;\n\tif (icon_string != NULL) {\n\t    XChangeProperty (dpy, w, XA_WM_ICON_NAME, XA_STRING, 8,\n                             PropModeReplace,\n                             (_Xconst unsigned char *)icon_string,\n                             (int)safestrlen(icon_string));\n\t\t}\n\n\tif (icon_pixmap != None) {\n\t\tphints.icon_pixmap = icon_pixmap;\n\t\tphints.flags |= IconPixmapHint;\n\t\t}\n\tif (argv != NULL) XSetCommand(dpy, w, argv, argc);\n\n\tif (hints != NULL) XSetNormalHints(dpy, w, hints);\n\n\tif (phints.flags != 0) XSetWMHints(dpy, w, &phints);\n\n\treturn 1;\n}", "target": 3, "idx": 10575}
{"commit_id": "22c096c99d8c05833c3c19870e36efb2dd4e8013", "project": "xen-project/xen", "func": "enum mc_disposition arch_do_multicall_call(struct mc_state *state)\n{\n    struct vcpu *curr = current;\n    unsigned long op;\n\n    if ( !is_pv_32bit_vcpu(curr) )\n    {\n        struct multicall_entry *call = &state->call;\n\n        op = call->op;\n        if ( (op < ARRAY_SIZE(pv_hypercall_table)) &&\n             pv_hypercall_table[op].native )\n            call->result = pv_hypercall_table[op].native(\n                call->args[0], call->args[1], call->args[2],\n                call->args[3], call->args[4], call->args[5]);\n        else\n            call->result = -ENOSYS;\n    }\n#ifdef CONFIG_COMPAT\n    else\n    {\n        struct compat_multicall_entry *call = &state->compat_call;\n\n        op = call->op;\n        if ( (op < ARRAY_SIZE(pv_hypercall_table)) &&\n             pv_hypercall_table[op].compat )\n            call->result = pv_hypercall_table[op].compat(\n                call->args[0], call->args[1], call->args[2],\n                call->args[3], call->args[4], call->args[5]);\n        else\n            call->result = -ENOSYS;\n    }\n#endif\n\n    return unlikely(op == __HYPERVISOR_iret)\n           ? mc_exit\n           : likely(guest_kernel_mode(curr, guest_cpu_user_regs()))\n             ? mc_continue : mc_preempt;\n}", "target": 2, "idx": 10576}
{"commit_id": "d978659be437b6f6c47997ab748ce8d253627b16", "project": "fluent/fluent-bit", "func": "int mqtt_conn_del(struct mqtt_conn *conn)\n{\n    /* Unregister the file descriptior from the event-loop */\n    mk_event_del(conn->ctx->evl, &conn->event);\n\n    /* Release resources */\n    close(conn->fd);\n    mk_list_del(&conn->_head);\n    flb_free(conn);\n\n    return 0;\n}", "target": 2, "idx": 10577}
{"commit_id": "51cdb67ff7c5f1242ac58c5aa603ceaf1793b788", "project": "gpac", "func": "static s32 gf_avc_read_pps_bs_internal(GF_BitStream *bs, AVCState *avc, u32 nal_hdr)\n{\n\ts32 pps_id;\n\tAVC_PPS *pps;\n\n\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\n\tif (!nal_hdr) {\n\t\tgf_bs_read_int_log(bs, 1, \"forbidden_zero_bit\");\n\t\tgf_bs_read_int_log(bs, 2, \"nal_ref_idc\");\n\t\tgf_bs_read_int_log(bs, 5, \"nal_unit_type\");\n\t}\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\tif ((pps_id<0) || (pps_id >= 255)) {\n\t\treturn -1;\n\t}\n\tpps = &avc->pps[pps_id];\n\tpps->id = pps_id;\n\n\tif (!pps->status) pps->status = 1;\n\tpps->sps_id = gf_bs_read_ue_log(bs, \"sps_id\");\n\tif ((pps->sps_id<0) || (pps->sps_id >= 32)) {\n\t\tpps->sps_id = 0;\n\t\treturn -1;\n\t}\n\t/*sps_id may be refer to regular SPS or subseq sps, depending on the coded slice referring to the pps*/\n\tif (!avc->sps[pps->sps_id].state && !avc->sps[pps->sps_id + GF_SVC_SSPS_ID_SHIFT].state) {\n\t\treturn -1;\n\t}\n\tavc->pps_active_idx = pps->id; /*set active sps*/\n\tavc->sps_active_idx = pps->sps_id; /*set active sps*/\n\tpps->entropy_coding_mode_flag = gf_bs_read_int_log(bs, 1, \"entropy_coding_mode_flag\");\n\tpps->pic_order_present = gf_bs_read_int_log(bs, 1, \"pic_order_present\");\n\tpps->slice_group_count = gf_bs_read_ue_log(bs, \"slice_group_count_minus1\") + 1;\n\tif (pps->slice_group_count > 1) {\n\t\tu32 iGroup;\n\t\tpps->mb_slice_group_map_type = gf_bs_read_ue_log(bs, \"mb_slice_group_map_type\");\n\t\tif (pps->mb_slice_group_map_type == 0) {\n\t\t\tfor (iGroup = 0; iGroup <= pps->slice_group_count - 1; iGroup++)\n\t\t\t\tgf_bs_read_ue_log_idx(bs, \"run_length_minus1\", iGroup);\n\t\t}\n\t\telse if (pps->mb_slice_group_map_type == 2) {\n\t\t\tfor (iGroup = 0; iGroup < pps->slice_group_count - 1; iGroup++) {\n\t\t\t\tgf_bs_read_ue_log_idx(bs, \"top_left\", iGroup);\n\t\t\t\tgf_bs_read_ue_log_idx(bs, \"bottom_right\", iGroup);\n\t\t\t}\n\t\t}\n\t\telse if (pps->mb_slice_group_map_type == 3 || pps->mb_slice_group_map_type == 4 || pps->mb_slice_group_map_type == 5) {\n\t\t\tgf_bs_read_int_log(bs, 1, \"slice_group_change_direction_flag\");\n\t\t\tgf_bs_read_ue_log(bs, \"slice_group_change_rate_minus1\");\n\t\t}\n\t\telse if (pps->mb_slice_group_map_type == 6) {\n\t\t\tu32 i;\n\t\t\tpps->pic_size_in_map_units_minus1 = gf_bs_read_ue_log(bs, \"pic_size_in_map_units_minus1\");\n\t\t\tfor (i = 0; i <= pps->pic_size_in_map_units_minus1; i++) {\n\t\t\t\tgf_bs_read_int_log_idx(bs, (u32)ceil(log(pps->slice_group_count) / log(2)), \"slice_group_id\", i);\n\t\t\t}\n\t\t}\n\t}\n\tpps->num_ref_idx_l0_default_active_minus1 = gf_bs_read_ue_log(bs, \"num_ref_idx_l0_default_active_minus1\");\n\tpps->num_ref_idx_l1_default_active_minus1 = gf_bs_read_ue_log(bs, \"num_ref_idx_l1_default_active_minus1\");\n\n\t/*\n\tif ((pps->ref_count[0] > 32) || (pps->ref_count[1] > 32)) goto exit;\n\t*/\n\n\tpps->weighted_pred_flag = gf_bs_read_int_log(bs, 1, \"weighted_pred_flag\");\n\tgf_bs_read_int_log(bs, 2, \"weighted_bipred_idc\");\n\tgf_bs_read_se_log(bs, \"init_qp_minus26\");\n\tgf_bs_read_se_log(bs, \"init_qs_minus26\");\n\tgf_bs_read_se_log(bs, \"chroma_qp_index_offset\");\n\tpps->deblocking_filter_control_present_flag = gf_bs_read_int_log(bs, 1, \"deblocking_filter_control_present_flag\");\n\tgf_bs_read_int_log(bs, 1, \"constrained_intra_pred\");\n\tpps->redundant_pic_cnt_present = gf_bs_read_int_log(bs, 1, \"redundant_pic_cnt_present\");\n\n\treturn pps_id;\n}", "target": 1, "idx": 10578}
{"commit_id": "2485fa94bd8a723e5c977d55a3ce10b301b437f8", "project": "grpc", "func": "void Encode(Key, const Value& value) {\n      AddToSummary(Key::key(), EncodedSizeOfKey(Key(), value));\n    }", "target": 2, "idx": 10579}
{"commit_id": "bab1e603a1842898984e719af101dc34838b37a3", "project": "saitoha/libsixel", "func": "static int stbi__shiftsigned(int v, int shift, int bits)\n{\n   static unsigned int mul_table[9] = {\n      0,\n      0xff/*0b11111111*/, 0x55/*0b01010101*/, 0x49/*0b01001001*/, 0x11/*0b00010001*/,\n      0x21/*0b00100001*/, 0x41/*0b01000001*/, 0x81/*0b10000001*/, 0x01/*0b00000001*/,\n   };\n   static unsigned int shift_table[9] = {\n      0, 0,0,1,0,2,4,6,0,\n   };\n   if (bits < 0 || bits > 8) return (0);  /* error */\n   if (shift < 0)\n      v <<= -shift;\n   else\n      v >>= shift;\n   if (v >= 0 && v < 256) return (0);\n   v >>= (8-bits);\n   return (int) ((unsigned) v * mul_table[bits]) >> shift_table[bits];\n}", "target": 1, "idx": 10580}
{"commit_id": "c20b758c332d9a13afbbb276d30db1d183a85d43", "project": "libexpat", "func": "static enum XML_Error\nprocessInternalEntity(XML_Parser parser, ENTITY *entity, XML_Bool betweenDecl) {\n  const char *textStart, *textEnd;\n  const char *next;\n  enum XML_Error result;\n  OPEN_INTERNAL_ENTITY *openEntity;\n\n  if (parser->m_freeInternalEntities) {\n    openEntity = parser->m_freeInternalEntities;\n    parser->m_freeInternalEntities = openEntity->next;\n  } else {\n    openEntity\n        = (OPEN_INTERNAL_ENTITY *)MALLOC(parser, sizeof(OPEN_INTERNAL_ENTITY));\n    if (! openEntity)\n      return XML_ERROR_NO_MEMORY;\n  }\n  entity->open = XML_TRUE;\n  entity->processed = 0;\n  openEntity->next = parser->m_openInternalEntities;\n  parser->m_openInternalEntities = openEntity;\n  openEntity->entity = entity;\n  openEntity->startTagLevel = parser->m_tagLevel;\n  openEntity->betweenDecl = betweenDecl;\n  openEntity->internalEventPtr = NULL;\n  openEntity->internalEventEndPtr = NULL;\n  textStart = (char *)entity->textPtr;\n  textEnd = (char *)(entity->textPtr + entity->textLen);\n  /* Set a safe default value in case 'next' does not get set */\n  next = textStart;\n\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok\n        = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);\n    result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,\n                      tok, next, &next, XML_FALSE, XML_FALSE);\n  } else\n#endif /* XML_DTD */\n    result = doContent(parser, parser->m_tagLevel, parser->m_internalEncoding,\n                       textStart, textEnd, &next, XML_FALSE);\n\n  if (result == XML_ERROR_NONE) {\n    if (textEnd != next && parser->m_parsingStatus.parsing == XML_SUSPENDED) {\n      entity->processed = (int)(next - textStart);\n      parser->m_processor = internalEntityProcessor;\n    } else {\n      entity->open = XML_FALSE;\n      parser->m_openInternalEntities = openEntity->next;\n      /* put openEntity back in list of free instances */\n      openEntity->next = parser->m_freeInternalEntities;\n      parser->m_freeInternalEntities = openEntity;\n    }\n  }\n  return result;\n}", "target": 2, "idx": 10581}
{"commit_id": "799b62bf065b006e2bcb1c80044eab2b10412ecf", "project": "ccxvii/mujs", "func": "void jsP_dumplist(js_State *J, js_Ast *prog)\n{\n\tminify = 0;\n\tif (prog) {\n\t\tif (prog->type == AST_LIST)\n\t\t\tsblock(0, prog);\n\t\telse\n\t\t\tsnode(0, prog);\n\t\tnl();\n\t}\n}", "target": 1, "idx": 10582}
{"commit_id": "72cdc5048dead86bb1df7d21e0b9975e49cf2d97", "project": "gpac", "func": "GF_Err abst_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;\n\tint i;\n\tu32 tmp_strsize;\n\tchar *tmp_str;\n\tGF_Err e;\n\n\tptr->bootstrapinfo_version = gf_bs_read_u32(bs);\n\tptr->profile = gf_bs_read_int(bs, 2);\n\tptr->live = gf_bs_read_int(bs, 1);\n\tptr->update = gf_bs_read_int(bs, 1);\n\tptr->reserved = gf_bs_read_int(bs, 4);\n\tptr->time_scale = gf_bs_read_u32(bs);\n\tptr->current_media_time = gf_bs_read_u64(bs);\n\tptr->smpte_time_code_offset = gf_bs_read_u64(bs);\n\n\ti=0;\n\tif (ptr->size<8) return GF_ISOM_INVALID_FILE;\n\ttmp_strsize=(u32)ptr->size-8;\n\ttmp_str = gf_malloc(sizeof(char)*tmp_strsize);\n\n\twhile (tmp_strsize) {\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i)\n\t\tptr->movie_identifier = gf_strdup(tmp_str);\n\n\tptr->server_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->server_entry_count; i++) {\n\t\tint j=0;\n\t\ttmp_strsize=(u32)ptr->size-8;\n\t\twhile (tmp_strsize) {\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j])\n\t\t\t\tbreak;\n\t\t\tj++;\n\t\t}\n\t\tgf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);\n\t}\n\n\tptr->quality_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tint j=0;\n\t\ttmp_strsize=(u32)ptr->size-8;\n\t\twhile (tmp_strsize) {\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j])\n\t\t\t\tbreak;\n\t\t\tj++;\n\t\t}\n\t\tgf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);\n\t}\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size-8;\n\twhile (tmp_strsize) {\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i)\n\t\tptr->drm_data = gf_strdup(tmp_str);\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size-8;\n\twhile (tmp_strsize) {\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i)\n\t\tptr->meta_data = gf_strdup(tmp_str);\n\n\tptr->segment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->segment_run_table_count; i++) {\n\t\tGF_AdobeSegmentRunTableBox *asrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&asrt, bs);\n\t\tif (e) {\n\t\t\tif (asrt) gf_isom_box_del((GF_Box*)asrt);\n\t\t\tgf_free(tmp_str);\n\t\t\treturn e;\n\t\t}\n\t\tgf_list_insert(ptr->segment_run_table_entries, asrt, i);\n\t}\n\n\tptr->fragment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->fragment_run_table_count; i++) {\n\t\tGF_AdobeFragmentRunTableBox *afrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&afrt, bs);\n\t\tif (e) {\n\t\t\tif (afrt) gf_isom_box_del((GF_Box*)afrt);\n\t\t\tgf_free(tmp_str);\n\t\t\treturn e;\n\t\t}\n\t\tgf_list_insert(ptr->fragment_run_table_entries, afrt, i);\n\t}\n\n\tgf_free(tmp_str);\n\n\treturn GF_OK;\n}", "target": 1, "idx": 10583}
{"commit_id": "5b82f4f90c3d531313714df4b936f92fb0ff15cf", "project": "android", "func": "OMX_ERRORTYPE omx_vdec::free_input_buffer(OMX_BUFFERHEADERTYPE *bufferHdr)\n{\n    unsigned int index = 0;\n    if (bufferHdr == NULL || m_inp_mem_ptr == NULL) {\n        return OMX_ErrorBadParameter;\n    }\n\n    index = bufferHdr - m_inp_mem_ptr;\n    DEBUG_PRINT_LOW(\"Free Input Buffer index = %d\",index);\n\n    auto_lock l(buf_lock);\n    bufferHdr->pInputPortPrivate = NULL;\n\n    if (index < drv_ctx.ip_buf.actualcount && drv_ctx.ptr_inputbuffer) {\n        DEBUG_PRINT_LOW(\"Free Input Buffer index = %d\",index);\n        if (drv_ctx.ptr_inputbuffer[index].pmem_fd > 0) {\n            struct vdec_setbuffer_cmd setbuffers;\n            setbuffers.buffer_type = VDEC_BUFFER_TYPE_INPUT;\n            memcpy (&setbuffers.buffer,&drv_ctx.ptr_inputbuffer[index],\n                    sizeof (vdec_bufferpayload));\n            if (!secure_mode) {\n                DEBUG_PRINT_LOW(\"unmap the input buffer fd=%d\",\n                        drv_ctx.ptr_inputbuffer[index].pmem_fd);\n                DEBUG_PRINT_LOW(\"unmap the input buffer size=%u  address = %p\",\n                        (unsigned int)drv_ctx.ptr_inputbuffer[index].mmaped_size,\n                        drv_ctx.ptr_inputbuffer[index].bufferaddr);\n                munmap (drv_ctx.ptr_inputbuffer[index].bufferaddr,\n                        drv_ctx.ptr_inputbuffer[index].mmaped_size);\n            }\n            close (drv_ctx.ptr_inputbuffer[index].pmem_fd);\n            drv_ctx.ptr_inputbuffer[index].pmem_fd = -1;\n            if (m_desc_buffer_ptr && m_desc_buffer_ptr[index].buf_addr) {\n                free(m_desc_buffer_ptr[index].buf_addr);\n                m_desc_buffer_ptr[index].buf_addr = NULL;\n                m_desc_buffer_ptr[index].desc_data_size = 0;\n            }\n#ifdef USE_ION\n            free_ion_memory(&drv_ctx.ip_buf_ion_info[index]);\n#endif\n        }\n    }\n\n    return OMX_ErrorNone;\n}", "target": 2, "idx": 10584}
{"commit_id": "b7f8bd20b7fb5b72f003ae3fa647c1d75f4218b7", "project": "abrt", "func": "static int run_post_create(const char *dirname)\n{\n    /* If doesn't start with \"g_settings_dump_location/\"... */\n    if (!dir_is_in_dump_location(dirname))\n    {\n        /* Then refuse to operate on it (someone is attacking us??) */\n        error_msg(\"Bad problem directory name '%s', should start with: '%s'\", dirname, g_settings_dump_location);\n        return 400; /* Bad Request */\n    }\n    if (!dir_has_correct_permissions(dirname))\n    {\n        error_msg(\"Problem directory '%s' isn't owned by root:abrt or others are not restricted from access\", dirname);\n        return 400; /*  */\n    }\n    if (g_settings_privatereports)\n    {\n        struct dump_dir *dd = dd_opendir(dirname, DD_OPEN_READONLY);\n        const bool complete = dd && problem_dump_dir_is_complete(dd);\n        dd_close(dd);\n        if (complete)\n        {\n            error_msg(\"Problem directory '%s' has already been processed\", dirname);\n            return 403;\n        }\n    }\n    else if (!dump_dir_accessible_by_uid(dirname, client_uid))\n    {\n        if (errno == ENOTDIR)\n        {\n            error_msg(\"Path '%s' isn't problem directory\", dirname);\n            return 404; /* Not Found */\n        }\n        error_msg(\"Problem directory '%s' can't be accessed by user with uid %ld\", dirname, (long)client_uid);\n        return 403; /* Forbidden */\n    }\n\n    int child_stdout_fd;\n    int child_pid = spawn_event_handler_child(dirname, \"post-create\", &child_stdout_fd);\n\n    char *dup_of_dir = NULL;\n    struct strbuf *cmd_output = strbuf_new();\n\n    bool child_is_post_create = 1; /* else it is a notify child */\n\n read_child_output:\n    //log(\"Reading from event fd %d\", child_stdout_fd);\n\n    /* Read streamed data and split lines */\n    for (;;)\n    {\n        char buf[250]; /* usually we get one line, no need to have big buf */\n        errno = 0;\n        int r = safe_read(child_stdout_fd, buf, sizeof(buf) - 1);\n        if (r <= 0)\n            break;\n        buf[r] = '\\0';\n\n        /* split lines in the current buffer */\n        char *raw = buf;\n        char *newline;\n        while ((newline = strchr(raw, '\\n')) != NULL)\n        {\n            *newline = '\\0';\n            strbuf_append_str(cmd_output, raw);\n            char *msg = cmd_output->buf;\n\n            /* Hmm, DUP_OF_DIR: ends up in syslog. move log() into 'else'? */\n            log(\"%s\", msg);\n\n            if (child_is_post_create\n             && prefixcmp(msg, \"DUP_OF_DIR: \") == 0\n            ) {\n                free(dup_of_dir);\n                dup_of_dir = xstrdup(msg + strlen(\"DUP_OF_DIR: \"));\n            }\n\n            strbuf_clear(cmd_output);\n            /* jump to next line */\n            raw = newline + 1;\n        }\n\n        /* beginning of next line. the line continues by next read */\n        strbuf_append_str(cmd_output, raw);\n    }\n\n    /* EOF/error */\n\n    /* Wait for child to actually exit, collect status */\n    int status = 0;\n    if (safe_waitpid(child_pid, &status, 0) <= 0)\n    /* should not happen */\n        perror_msg(\"waitpid(%d)\", child_pid);\n\n    /* If it was a \"notify[-dup]\" event, then we're done */\n    if (!child_is_post_create)\n        goto ret;\n\n    /* exit 0 means \"this is a good, non-dup dir\" */\n    /* exit with 1 + \"DUP_OF_DIR: dir\" string => dup */\n    if (status != 0)\n    {\n        if (WIFSIGNALED(status))\n        {\n            log(\"'post-create' on '%s' killed by signal %d\",\n                            dirname, WTERMSIG(status));\n            goto delete_bad_dir;\n        }\n        /* else: it is WIFEXITED(status) */\n        if (!dup_of_dir)\n        {\n            log(\"'post-create' on '%s' exited with %d\",\n                            dirname, WEXITSTATUS(status));\n            goto delete_bad_dir;\n        }\n    }\n\n    const char *work_dir = (dup_of_dir ? dup_of_dir : dirname);\n\n    /* Load problem_data (from the *first dir* if this one is a dup) */\n    struct dump_dir *dd = dd_opendir(work_dir, /*flags:*/ 0);\n    if (!dd)\n        /* dd_opendir already emitted error msg */\n        goto delete_bad_dir;\n\n    /* Update count */\n    char *count_str = dd_load_text_ext(dd, FILENAME_COUNT, DD_FAIL_QUIETLY_ENOENT);\n    unsigned long count = strtoul(count_str, NULL, 10);\n\n    /* Don't increase crash count if we are working with newly uploaded\n     * directory (remote crash) which already has its crash count set.\n     */\n    if ((status != 0 && dup_of_dir) || count == 0)\n    {\n        count++;\n        char new_count_str[sizeof(long)*3 + 2];\n        sprintf(new_count_str, \"%lu\", count);\n        dd_save_text(dd, FILENAME_COUNT, new_count_str);\n\n        /* This condition can be simplified to either\n         * (status * != 0 && * dup_of_dir) or (count == 1). But the\n         * chosen form is much more reliable and safe. We must not call\n         * dd_opendir() to locked dd otherwise we go into a deadlock.\n         */\n        if (strcmp(dd->dd_dirname, dirname) != 0)\n        {\n            /* Update the last occurrence file by the time file of the new problem */\n            struct dump_dir *new_dd = dd_opendir(dirname, DD_OPEN_READONLY);\n            char *last_ocr = NULL;\n            if (new_dd)\n            {\n                /* TIME must exists in a valid dump directory but we don't want to die\n                 * due to broken duplicated dump directory */\n                last_ocr = dd_load_text_ext(new_dd, FILENAME_TIME,\n                            DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE | DD_FAIL_QUIETLY_ENOENT);\n                dd_close(new_dd);\n            }\n            else\n            {   /* dd_opendir() already produced a message with good information about failure */\n                error_msg(\"Can't read the last occurrence file from the new dump directory.\");\n            }\n\n            if (!last_ocr)\n            {   /* the new dump directory may lie in the dump location for some time */\n                log(\"Using current time for the last occurrence file which may be incorrect.\");\n                time_t t = time(NULL);\n                last_ocr = xasprintf(\"%lu\", (long)t);\n            }\n\n            dd_save_text(dd, FILENAME_LAST_OCCURRENCE, last_ocr);\n\n            free(last_ocr);\n        }\n    }\n\n    /* Reset mode/uig/gid to correct values for all files created by event run */\n    dd_sanitize_mode_and_owner(dd);\n\n    dd_close(dd);\n\n    if (!dup_of_dir)\n        log_notice(\"New problem directory %s, processing\", work_dir);\n    else\n    {\n        log_warning(\"Deleting problem directory %s (dup of %s)\",\n                    strrchr(dirname, '/') + 1,\n                    strrchr(dup_of_dir, '/') + 1);\n        delete_dump_dir(dirname);\n    }\n\n    /* Run \"notify[-dup]\" event */\n    int fd;\n    child_pid = spawn_event_handler_child(\n                work_dir,\n                (dup_of_dir ? \"notify-dup\" : \"notify\"),\n                &fd\n    );\n    //log(\"Started notify, fd %d -> %d\", fd, child_stdout_fd);\n    xmove_fd(fd, child_stdout_fd);\n    child_is_post_create = 0;\n    strbuf_clear(cmd_output);\n    free(dup_of_dir);\n    dup_of_dir = NULL;\n    goto read_child_output;\n\n delete_bad_dir:\n    log_warning(\"Deleting problem directory '%s'\", dirname);\n    delete_dump_dir(dirname);\n\n ret:\n    strbuf_free(cmd_output);\n    free(dup_of_dir);\n    close(child_stdout_fd);\n    return 0;\n}", "target": 2, "idx": 10585}
{"commit_id": "edbd58be15a957f6a760c4a514cd475217eb97fd", "project": "torvalds/linux", "func": "static int tpacket_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t       struct packet_type *pt, struct net_device *orig_dev)\n{\n\tstruct sock *sk;\n\tstruct packet_sock *po;\n\tstruct sockaddr_ll *sll;\n\tunion tpacket_uhdr h;\n\tu8 *skb_head = skb->data;\n\tint skb_len = skb->len;\n\tunsigned int snaplen, res;\n\tunsigned long status = TP_STATUS_USER;\n\tunsigned short macoff, netoff, hdrlen;\n\tstruct sk_buff *copy_skb = NULL;\n\tstruct timespec ts;\n\t__u32 ts_status;\n\tbool is_drop_n_account = false;\n\tbool do_vnet = false;\n\n\t/* struct tpacket{2,3}_hdr is aligned to a multiple of TPACKET_ALIGNMENT.\n\t * We may add members to them until current aligned size without forcing\n\t * userspace to call getsockopt(..., PACKET_HDRLEN, ...).\n\t */\n\tBUILD_BUG_ON(TPACKET_ALIGN(sizeof(*h.h2)) != 32);\n\tBUILD_BUG_ON(TPACKET_ALIGN(sizeof(*h.h3)) != 48);\n\n\tif (skb->pkt_type == PACKET_LOOPBACK)\n\t\tgoto drop;\n\n\tsk = pt->af_packet_priv;\n\tpo = pkt_sk(sk);\n\n\tif (!net_eq(dev_net(dev), sock_net(sk)))\n\t\tgoto drop;\n\n\tif (dev->header_ops) {\n\t\tif (sk->sk_type != SOCK_DGRAM)\n\t\t\tskb_push(skb, skb->data - skb_mac_header(skb));\n\t\telse if (skb->pkt_type == PACKET_OUTGOING) {\n\t\t\t/* Special case: outgoing packets have ll header at head */\n\t\t\tskb_pull(skb, skb_network_offset(skb));\n\t\t}\n\t}\n\n\tsnaplen = skb->len;\n\n\tres = run_filter(skb, sk, snaplen);\n\tif (!res)\n\t\tgoto drop_n_restore;\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL)\n\t\tstatus |= TP_STATUS_CSUMNOTREADY;\n\telse if (skb->pkt_type != PACKET_OUTGOING &&\n\t\t (skb->ip_summed == CHECKSUM_COMPLETE ||\n\t\t  skb_csum_unnecessary(skb)))\n\t\tstatus |= TP_STATUS_CSUM_VALID;\n\n\tif (snaplen > res)\n\t\tsnaplen = res;\n\n\tif (sk->sk_type == SOCK_DGRAM) {\n\t\tmacoff = netoff = TPACKET_ALIGN(po->tp_hdrlen) + 16 +\n\t\t\t\t  po->tp_reserve;\n\t} else {\n\t\tunsigned int maclen = skb_network_offset(skb);\n\t\tnetoff = TPACKET_ALIGN(po->tp_hdrlen +\n\t\t\t\t       (maclen < 16 ? 16 : maclen)) +\n\t\t\t\t       po->tp_reserve;\n\t\tif (po->has_vnet_hdr) {\n\t\t\tnetoff += sizeof(struct virtio_net_hdr);\n\t\t\tdo_vnet = true;\n\t\t}\n\t\tmacoff = netoff - maclen;\n\t}\n\tif (po->tp_version <= TPACKET_V2) {\n\t\tif (macoff + snaplen > po->rx_ring.frame_size) {\n\t\t\tif (po->copy_thresh &&\n\t\t\t    atomic_read(&sk->sk_rmem_alloc) < sk->sk_rcvbuf) {\n\t\t\t\tif (skb_shared(skb)) {\n\t\t\t\t\tcopy_skb = skb_clone(skb, GFP_ATOMIC);\n\t\t\t\t} else {\n\t\t\t\t\tcopy_skb = skb_get(skb);\n\t\t\t\t\tskb_head = skb->data;\n\t\t\t\t}\n\t\t\t\tif (copy_skb)\n\t\t\t\t\tskb_set_owner_r(copy_skb, sk);\n\t\t\t}\n\t\t\tsnaplen = po->rx_ring.frame_size - macoff;\n\t\t\tif ((int)snaplen < 0) {\n\t\t\t\tsnaplen = 0;\n\t\t\t\tdo_vnet = false;\n\t\t\t}\n\t\t}\n\t} else if (unlikely(macoff + snaplen >\n\t\t\t    GET_PBDQC_FROM_RB(&po->rx_ring)->max_frame_len)) {\n\t\tu32 nval;\n\n\t\tnval = GET_PBDQC_FROM_RB(&po->rx_ring)->max_frame_len - macoff;\n\t\tpr_err_once(\"tpacket_rcv: packet too big, clamped from %u to %u. macoff=%u\\n\",\n\t\t\t    snaplen, nval, macoff);\n\t\tsnaplen = nval;\n\t\tif (unlikely((int)snaplen < 0)) {\n\t\t\tsnaplen = 0;\n\t\t\tmacoff = GET_PBDQC_FROM_RB(&po->rx_ring)->max_frame_len;\n\t\t\tdo_vnet = false;\n\t\t}\n\t}\n\tspin_lock(&sk->sk_receive_queue.lock);\n\th.raw = packet_current_rx_frame(po, skb,\n\t\t\t\t\tTP_STATUS_KERNEL, (macoff+snaplen));\n\tif (!h.raw)\n\t\tgoto drop_n_account;\n\tif (po->tp_version <= TPACKET_V2) {\n\t\tpacket_increment_rx_head(po, &po->rx_ring);\n\t/*\n\t * LOSING will be reported till you read the stats,\n\t * because it's COR - Clear On Read.\n\t * Anyways, moving it for V1/V2 only as V3 doesn't need this\n\t * at packet level.\n\t */\n\t\tif (po->stats.stats1.tp_drops)\n\t\t\tstatus |= TP_STATUS_LOSING;\n\t}\n\tpo->stats.stats1.tp_packets++;\n\tif (copy_skb) {\n\t\tstatus |= TP_STATUS_COPY;\n\t\t__skb_queue_tail(&sk->sk_receive_queue, copy_skb);\n\t}\n\tspin_unlock(&sk->sk_receive_queue.lock);\n\n\tif (do_vnet) {\n\t\tif (virtio_net_hdr_from_skb(skb, h.raw + macoff -\n\t\t\t\t\t    sizeof(struct virtio_net_hdr),\n\t\t\t\t\t    vio_le(), true)) {\n\t\t\tspin_lock(&sk->sk_receive_queue.lock);\n\t\t\tgoto drop_n_account;\n\t\t}\n\t}\n\n\tskb_copy_bits(skb, 0, h.raw + macoff, snaplen);\n\n\tif (!(ts_status = tpacket_get_timestamp(skb, &ts, po->tp_tstamp)))\n\t\tgetnstimeofday(&ts);\n\n\tstatus |= ts_status;\n\n\tswitch (po->tp_version) {\n\tcase TPACKET_V1:\n\t\th.h1->tp_len = skb->len;\n\t\th.h1->tp_snaplen = snaplen;\n\t\th.h1->tp_mac = macoff;\n\t\th.h1->tp_net = netoff;\n\t\th.h1->tp_sec = ts.tv_sec;\n\t\th.h1->tp_usec = ts.tv_nsec / NSEC_PER_USEC;\n\t\thdrlen = sizeof(*h.h1);\n\t\tbreak;\n\tcase TPACKET_V2:\n\t\th.h2->tp_len = skb->len;\n\t\th.h2->tp_snaplen = snaplen;\n\t\th.h2->tp_mac = macoff;\n\t\th.h2->tp_net = netoff;\n\t\th.h2->tp_sec = ts.tv_sec;\n\t\th.h2->tp_nsec = ts.tv_nsec;\n\t\tif (skb_vlan_tag_present(skb)) {\n\t\t\th.h2->tp_vlan_tci = skb_vlan_tag_get(skb);\n\t\t\th.h2->tp_vlan_tpid = ntohs(skb->vlan_proto);\n\t\t\tstatus |= TP_STATUS_VLAN_VALID | TP_STATUS_VLAN_TPID_VALID;\n\t\t} else {\n\t\t\th.h2->tp_vlan_tci = 0;\n\t\t\th.h2->tp_vlan_tpid = 0;\n\t\t}\n\t\tmemset(h.h2->tp_padding, 0, sizeof(h.h2->tp_padding));\n\t\thdrlen = sizeof(*h.h2);\n\t\tbreak;\n\tcase TPACKET_V3:\n\t\t/* tp_nxt_offset,vlan are already populated above.\n\t\t * So DONT clear those fields here\n\t\t */\n\t\th.h3->tp_status |= status;\n\t\th.h3->tp_len = skb->len;\n\t\th.h3->tp_snaplen = snaplen;\n\t\th.h3->tp_mac = macoff;\n\t\th.h3->tp_net = netoff;\n\t\th.h3->tp_sec  = ts.tv_sec;\n\t\th.h3->tp_nsec = ts.tv_nsec;\n\t\tmemset(h.h3->tp_padding, 0, sizeof(h.h3->tp_padding));\n\t\thdrlen = sizeof(*h.h3);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tsll = h.raw + TPACKET_ALIGN(hdrlen);\n\tsll->sll_halen = dev_parse_header(skb, sll->sll_addr);\n\tsll->sll_family = AF_PACKET;\n\tsll->sll_hatype = dev->type;\n\tsll->sll_protocol = skb->protocol;\n\tsll->sll_pkttype = skb->pkt_type;\n\tif (unlikely(po->origdev))\n\t\tsll->sll_ifindex = orig_dev->ifindex;\n\telse\n\t\tsll->sll_ifindex = dev->ifindex;\n\n\tsmp_mb();\n\n#if ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE == 1\n\tif (po->tp_version <= TPACKET_V2) {\n\t\tu8 *start, *end;\n\n\t\tend = (u8 *) PAGE_ALIGN((unsigned long) h.raw +\n\t\t\t\t\tmacoff + snaplen);\n\n\t\tfor (start = h.raw; start < end; start += PAGE_SIZE)\n\t\t\tflush_dcache_page(pgv_to_page(start));\n\t}\n\tsmp_wmb();\n#endif\n\n\tif (po->tp_version <= TPACKET_V2) {\n\t\t__packet_set_status(po, h.raw, status);\n\t\tsk->sk_data_ready(sk);\n\t} else {\n\t\tprb_clear_blk_fill_status(&po->rx_ring);\n\t}\n\ndrop_n_restore:\n\tif (skb_head != skb->data && skb_shared(skb)) {\n\t\tskb->data = skb_head;\n\t\tskb->len = skb_len;\n\t}\ndrop:\n\tif (!is_drop_n_account)\n\t\tconsume_skb(skb);\n\telse\n\t\tkfree_skb(skb);\n\treturn 0;\n\ndrop_n_account:\n\tis_drop_n_account = true;\n\tpo->stats.stats1.tp_drops++;\n\tspin_unlock(&sk->sk_receive_queue.lock);\n\n\tsk->sk_data_ready(sk);\n\tkfree_skb(copy_skb);\n\tgoto drop_n_restore;\n}", "target": 2, "idx": 10586}
{"commit_id": "64f42c73efc58e88671ad76b6b6bc8e2b62713e1", "project": "php/php-src", "func": "int\nmbfl_strpos(\n    mbfl_string *haystack,\n    mbfl_string *needle,\n    int offset,\n    int reverse)\n{\n\tint result;\n\tmbfl_string _haystack_u8, _needle_u8;\n\tconst mbfl_string *haystack_u8, *needle_u8 = NULL;\n\tconst unsigned char *u8_tbl;\n\n\tif (haystack == NULL || haystack->val == NULL || needle == NULL || needle->val == NULL) {\n\t\treturn -8;\n\t}\n\n\t{\n\t\tconst mbfl_encoding *u8_enc;\n\t\tu8_enc = mbfl_no2encoding(mbfl_no_encoding_utf8);\n\t\tif (u8_enc == NULL || u8_enc->mblen_table == NULL) {\n\t\t\treturn -8;\n\t\t}\n\t\tu8_tbl = u8_enc->mblen_table;\n\t}\n\n\tif (haystack->no_encoding != mbfl_no_encoding_utf8) {\n\t\tmbfl_string_init(&_haystack_u8);\n\t\thaystack_u8 = mbfl_convert_encoding(haystack, &_haystack_u8, mbfl_no_encoding_utf8);\n\t\tif (haystack_u8 == NULL) {\n\t\t\tresult = -4;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\thaystack_u8 = haystack;\n\t}\n\n\tif (needle->no_encoding != mbfl_no_encoding_utf8) {\n\t\tmbfl_string_init(&_needle_u8);\n\t\tneedle_u8 = mbfl_convert_encoding(needle, &_needle_u8, mbfl_no_encoding_utf8);\n\t\tif (needle_u8 == NULL) {\n\t\t\tresult = -4;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tneedle_u8 = needle;\n\t}\n\n\tif (needle_u8->len < 1) {\n\t\tresult = -8;\n\t\tgoto out;\n\t}\n\n\tresult = -1;\n\tif (haystack_u8->len < needle_u8->len) {\n\t\tgoto out;\n\t}\n\n\tif (!reverse) {\n\t\tunsigned int jtbl[1 << (sizeof(unsigned char) * 8)];\n\t\tunsigned int needle_u8_len = needle_u8->len;\n\t\tunsigned int i;\n\t\tconst unsigned char *p, *q, *e;\n\t\tconst unsigned char *haystack_u8_val = haystack_u8->val,\n\t\t                    *needle_u8_val = needle_u8->val;\n\t\tfor (i = 0; i < sizeof(jtbl) / sizeof(*jtbl); ++i) {\n\t\t\tjtbl[i] = needle_u8_len + 1;\n\t\t}\n\t\tfor (i = 0; i < needle_u8_len - 1; ++i) {\n\t\t\tjtbl[needle_u8_val[i]] = needle_u8_len - i;\n\t\t}\n\t\te = haystack_u8_val + haystack_u8->len;\n\t\tp = haystack_u8_val;\n\t\twhile (--offset >= 0) {\n\t\t\tif (p >= e) {\n\t\t\t\tresult = -16;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tp += u8_tbl[*p];\n\t\t}\n\t\tp += needle_u8_len;\n\t\tif (p > e) {\n\t\t\tgoto out;\n\t\t}\n\t\twhile (p <= e) {\n\t\t\tconst unsigned char *pv = p;\n\t\t\tq = needle_u8_val + needle_u8_len;\n\t\t\tfor (;;) {\n\t\t\t\tif (q == needle_u8_val) {\n\t\t\t\t\tresult = 0;\n\t\t\t\t\twhile (p > haystack_u8_val) {\n\t\t\t\t\t\tunsigned char c = *--p;\n\t\t\t\t\t\tif (c < 0x80) {\n\t\t\t\t\t\t\t++result;\n\t\t\t\t\t\t} else if ((c & 0xc0) != 0x80) {\n\t\t\t\t\t\t\t++result;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (*--q != *--p) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp += jtbl[*p];\n\t\t\tif (p <= pv) {\n\t\t\t\tp = pv + 1;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tunsigned int jtbl[1 << (sizeof(unsigned char) * 8)];\n\t\tunsigned int needle_u8_len = needle_u8->len, needle_len = 0;\n\t\tunsigned int i;\n\t\tconst unsigned char *p, *e, *q, *qe;\n\t\tconst unsigned char *haystack_u8_val = haystack_u8->val,\n\t\t                    *needle_u8_val = needle_u8->val;\n\t\tfor (i = 0; i < sizeof(jtbl) / sizeof(*jtbl); ++i) {\n\t\t\tjtbl[i] = needle_u8_len;\n\t\t}\n\t\tfor (i = needle_u8_len - 1; i > 0; --i) {\n\t\t\tunsigned char c = needle_u8_val[i];\n\t\t\tjtbl[c] = i;\n\t\t\tif (c < 0x80) {\n\t\t\t\t++needle_len;\n\t\t\t} else if ((c & 0xc0) != 0x80) {\n\t\t\t\t++needle_len;\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tunsigned char c = needle_u8_val[0];\n\t\t\tif (c < 0x80) {\n\t\t\t\t++needle_len;\n\t\t\t} else if ((c & 0xc0) != 0x80) {\n\t\t\t\t++needle_len;\n\t\t\t}\n\t\t}\n\t\te = haystack_u8_val;\n\t\tp = e + haystack_u8->len;\n\t\tqe = needle_u8_val + needle_u8_len;\n\t\tif (offset < 0) {\n\t\t\tif (-offset > needle_len) {\n\t\t\t\toffset += needle_len;\n\t\t\t\twhile (offset < 0) {\n\t\t\t\t\tunsigned char c;\n\t\t\t\t\tif (p <= e) {\n\t\t\t\t\t\tresult = -16;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tc = *(--p);\n\t\t\t\t\tif (c < 0x80) {\n\t\t\t\t\t\t++offset;\n\t\t\t\t\t} else if ((c & 0xc0) != 0x80) {\n\t\t\t\t\t\t++offset;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconst unsigned char *ee = haystack_u8_val + haystack_u8->len;\n\t\t\twhile (--offset >= 0) {\n\t\t\t\tif (e >= ee) {\n\t\t\t\t\tresult = -16;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\te += u8_tbl[*e];\n\t\t\t}\n\t\t}\n\t\tif (p < e + needle_u8_len) {\n\t\t\tgoto out;\n\t\t}\n\t\tp -= needle_u8_len;\n\t\twhile (p >= e) {\n\t\t\tconst unsigned char *pv = p;\n\t\t\tq = needle_u8_val;\n\t\t\tfor (;;) {\n\t\t\t\tif (q == qe) {\n\t\t\t\t\tresult = 0;\n\t\t\t\t\tp -= needle_u8_len;\n\t\t\t\t\twhile (p > haystack_u8_val) {\n\t\t\t\t\t\tunsigned char c = *--p;\n\t\t\t\t\t\tif (c < 0x80) {\n\t\t\t\t\t\t\t++result;\n\t\t\t\t\t\t} else if ((c & 0xc0) != 0x80) {\n\t\t\t\t\t\t\t++result;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (*q != *p) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t++p, ++q;\n\t\t\t}\n\t\t\tp -= jtbl[*p];\n\t\t\tif (p >= pv) {\n\t\t\t\tp = pv - 1;\n\t\t\t}\n\t\t}\n\t}\nout:\n\tif (haystack_u8 == &_haystack_u8) {\n\t\tmbfl_string_clear(&_haystack_u8);\n\t}\n\tif (needle_u8 == &_needle_u8) {\n\t\tmbfl_string_clear(&_needle_u8);\n\t}\n\treturn result;\n}", "target": 3, "idx": 10587}
{"commit_id": "edb272e35ee57e7b89f3e127222c6981b6a1e730", "project": "wolfSSL/wolfssh", "func": "int wolfSSH_SFTP_RecvRMDIR(WOLFSSH* ssh, int reqId, byte* data, word32 maxSz)\n{\n    word32 sz;\n    int    ret = 0;\n    char*  dir;\n    word32 idx = 0;\n    byte*  out;\n    word32 outSz = 0;\n    byte   type;\n\n    char err[] = \"Remove Directory Error\";\n    char suc[] = \"Removed Directory\";\n    char* res  = NULL;\n\n    if (ssh == NULL) {\n        return WS_BAD_ARGUMENT;\n    }\n\n    WLOG(WS_LOG_SFTP, \"Receiving WOLFSSH_FTP_RMDIR\");\n\n    ato32(data + idx, &sz); idx += UINT32_SZ;\n    if (sz > maxSz - idx) {\n        return WS_BUFFER_E;\n    }\n\n    /* plus one to make sure is null terminated */\n    dir = (char*)WMALLOC(sz + 1, ssh->ctx->heap, DYNTYPE_BUFFER);\n    if (dir == NULL) {\n        return WS_MEMORY_E;\n    }\n    WMEMCPY(dir, data + idx, sz);\n    dir[sz] = '\\0';\n\n    if (wolfSSH_CleanPath(ssh, dir) < 0) {\n        ret = WS_FATAL_ERROR;\n    }\n\n    if (ret == 0) {\n    #ifndef USE_WINDOWS_API\n        ret = WRMDIR(ssh->fs, dir);\n    #else /* USE_WINDOWS_API */\n        ret = WS_RemoveDirectoryA(dir, ssh->ctx->heap) == 0;\n    #endif /* USE_WINDOWS_API */\n    }\n    WFREE(dir, ssh->ctx->heap, DYNTYPE_BUFFER);\n\n    res  = (ret != 0)? err : suc;\n    type = (ret != 0)? WOLFSSH_FTP_FAILURE : WOLFSSH_FTP_OK;\n    if (wolfSSH_SFTP_CreateStatus(ssh, type, reqId, res,\n                \"English\", NULL, &outSz) != WS_SIZE_ONLY) {\n        return WS_FATAL_ERROR;\n    }\n\n    out = (byte*)WMALLOC(outSz, ssh->ctx->heap, DYNTYPE_BUFFER);\n    if (out == NULL) {\n        return WS_MEMORY_E;\n    }\n\n    if (ret != 0) {\n        /* @TODO errno holds reason for rmdir failure. Status sent could be\n         * better if using errno value to send reason i.e. permissions .. */\n        WLOG(WS_LOG_SFTP, \"Error removing directory %s\", dir);\n        ret = WS_BAD_FILE_E;\n    }\n    else {\n        ret = WS_SUCCESS;\n    }\n\n    if (wolfSSH_SFTP_CreateStatus(ssh, type, reqId, res, \"English\", out,\n                &outSz) != WS_SUCCESS) {\n        WFREE(out, ssh->ctx->heap, DYNTYPE_BUFFER);\n        return WS_FATAL_ERROR;\n    }\n\n    /* set send out buffer, \"out\" is taken by ssh  */\n    wolfSSH_SFTP_RecvSetSend(ssh, out, outSz);\n    return ret;\n}", "target": 3, "idx": 10588}
{"commit_id": "a6807394bd94", "project": "ArtifexSoftware/ghostpdl", "func": "static int\ngs_call_interp(i_ctx_t **pi_ctx_p, ref * pref, int user_errors,\n               int *pexit_code, ref * perror_object)\n{\n    ref *epref = pref;\n    ref doref;\n    ref *perrordict;\n    ref error_name;\n    int code, ccode;\n    ref saref;\n    i_ctx_t *i_ctx_p = *pi_ctx_p;\n    int *gc_signal = &imemory_system->gs_lib_ctx->gcsignal;\n\n    *pexit_code = 0;\n    *gc_signal = 0;\n    ialloc_reset_requested(idmemory);\nagain:\n    /* Avoid a dangling error object that might get traced by a future GC. */\n    make_null(perror_object);\n    o_stack.requested = e_stack.requested = d_stack.requested = 0;\n    while (*gc_signal) { /* Some routine below triggered a GC. */\n        gs_gc_root_t epref_root;\n\n        *gc_signal = 0;\n        /* Make sure that doref will get relocated properly if */\n        /* a garbage collection happens with epref == &doref. */\n        gs_register_ref_root(imemory_system, &epref_root,\n                             (void **)&epref, \"gs_call_interp(epref)\");\n        code = interp_reclaim(pi_ctx_p, -1);\n        i_ctx_p = *pi_ctx_p;\n        gs_unregister_root(imemory_system, &epref_root,\n                           \"gs_call_interp(epref)\");\n        if (code < 0)\n            return code;\n    }\n    code = interp(pi_ctx_p, epref, perror_object);\n    i_ctx_p = *pi_ctx_p;\n    if (!r_has_type(&i_ctx_p->error_object, t__invalid)) {\n        *perror_object = i_ctx_p->error_object;\n        make_t(&i_ctx_p->error_object, t__invalid);\n    }\n    /* Prevent a dangling reference to the GC signal in ticks_left */\n    /* in the frame of interp, but be prepared to do a GC if */\n    /* an allocation in this routine asks for it. */\n    *gc_signal = 0;\n    set_gc_signal(i_ctx_p, 1);\n    if (esp < esbot)            /* popped guard entry */\n        esp = esbot;\n    switch (code) {\n        case gs_error_Fatal:\n            *pexit_code = 255;\n            return code;\n        case gs_error_Quit:\n            *perror_object = osp[-1];\n            *pexit_code = code = osp->value.intval;\n            osp -= 2;\n            return\n                (code == 0 ? gs_error_Quit :\n                 code < 0 && code > -100 ? code : gs_error_Fatal);\n        case gs_error_InterpreterExit:\n            return 0;\n        case gs_error_ExecStackUnderflow:\n/****** WRONG -- must keep mark blocks intact ******/\n            ref_stack_pop_block(&e_stack);\n            doref = *perror_object;\n            epref = &doref;\n            goto again;\n        case gs_error_VMreclaim:\n            /* Do the GC and continue. */\n            /* We ignore the return value here, if it fails here\n             * we'll call it again having jumped to the \"again\" label.\n             * Where, assuming it fails again, we'll handle the error.\n             */\n            (void)interp_reclaim(pi_ctx_p,\n                                  (osp->value.intval == 2 ?\n                                   avm_global : avm_local));\n            i_ctx_p = *pi_ctx_p;\n            make_oper(&doref, 0, zpop);\n            epref = &doref;\n            goto again;\n        case gs_error_NeedInput:\n        case gs_error_interrupt:\n            return code;\n    }\n    /* Adjust osp in case of operand stack underflow */\n    if (osp < osbot - 1)\n        osp = osbot - 1;\n    /* We have to handle stack over/underflow specially, because */\n    /* we might be able to recover by adding or removing a block. */\n    switch (code) {\n        case gs_error_dictstackoverflow:\n            /* We don't have to handle this specially: */\n            /* The only places that could generate it */\n            /* use check_dstack, which does a ref_stack_extend, */\n            /* so if` we get this error, it's a real one. */\n            if (osp >= ostop) {\n                if ((ccode = ref_stack_extend(&o_stack, 1)) < 0)\n                    return ccode;\n            }\n            /* Skip system dictionaries for CET 20-02-02 */\n            ccode = copy_stack(i_ctx_p, &d_stack, min_dstack_size, &saref);\n            if (ccode < 0)\n                return ccode;\n            ref_stack_pop_to(&d_stack, min_dstack_size);\n            dict_set_top();\n            *++osp = saref;\n            break;\n        case gs_error_dictstackunderflow:\n            if (ref_stack_pop_block(&d_stack) >= 0) {\n                dict_set_top();\n                doref = *perror_object;\n                epref = &doref;\n                goto again;\n            }\n            break;\n        case gs_error_execstackoverflow:\n            /* We don't have to handle this specially: */\n            /* The only places that could generate it */\n            /* use check_estack, which does a ref_stack_extend, */\n            /* so if we get this error, it's a real one. */\n            if (osp >= ostop) {\n                if ((ccode = ref_stack_extend(&o_stack, 1)) < 0)\n                    return ccode;\n            }\n            ccode = copy_stack(i_ctx_p, &e_stack, 0, &saref);\n            if (ccode < 0)\n                return ccode;\n            {\n                uint count = ref_stack_count(&e_stack);\n                uint limit = ref_stack_max_count(&e_stack) - ES_HEADROOM;\n\n                if (count > limit) {\n                    /*\n                     * If there is an e-stack mark within MIN_BLOCK_ESTACK of\n                     * the new top, cut the stack back to remove the mark.\n                     */\n                    int skip = count - limit;\n                    int i;\n\n                    for (i = skip; i < skip + MIN_BLOCK_ESTACK; ++i) {\n                        const ref *ep = ref_stack_index(&e_stack, i);\n\n                        if (r_has_type_attrs(ep, t_null, a_executable)) {\n                            skip = i + 1;\n                            break;\n                        }\n                    }\n                    pop_estack(i_ctx_p, skip);\n                }\n            }\n            *++osp = saref;\n            break;\n        case gs_error_stackoverflow:\n            if (ref_stack_extend(&o_stack, o_stack.requested) >= 0) {   /* We can't just re-execute the object, because */\n                /* it might be a procedure being pushed as a */\n                /* literal.  We check for this case specially. */\n                doref = *perror_object;\n                if (r_is_proc(&doref)) {\n                    *++osp = doref;\n                    make_null_proc(&doref);\n                }\n                epref = &doref;\n                goto again;\n            }\n            ccode = copy_stack(i_ctx_p, &o_stack, 0, &saref);\n            if (ccode < 0)\n                return ccode;\n            ref_stack_clear(&o_stack);\n            *++osp = saref;\n            break;\n        case gs_error_stackunderflow:\n            if (ref_stack_pop_block(&o_stack) >= 0) {\n                doref = *perror_object;\n                epref = &doref;\n                goto again;\n            }\n            break;\n    }\n    if (user_errors < 0)\n        return code;\n    if (gs_errorname(i_ctx_p, code, &error_name) < 0)\n        return code;            /* out-of-range error code! */\n\n    /*  We refer to gserrordict first, which is not accessible to Postcript jobs\n     *  If we're running with SAFERERRORS all the handlers are copied to gserrordict\n     *  so we'll always find the default one. If not SAFERERRORS, only gs specific\n     *  errors are in gserrordict.\n     */\n    if (dict_find_string(systemdict, \"gserrordict\", &perrordict) <= 0 ||\n        (dict_find(perrordict, &error_name, &epref) <= 0 &&\n         (dict_find_string(systemdict, \"errordict\", &perrordict) <= 0 ||\n          dict_find(perrordict, &error_name, &epref) <= 0))\n        )\n        return code;            /* error name not in errordict??? */\n\n    doref = *epref;\n    epref = &doref;\n    /* Push the error object on the operand stack if appropriate. */\n    if (!GS_ERROR_IS_INTERRUPT(code)) {\n        byte buf[260], *bufptr;\n        uint rlen;\n        /* Replace the error object if within an oparray or .errorexec. */\n        osp++;\n        if (osp >= ostop) {\n            *pexit_code = gs_error_Fatal;\n            return_error(gs_error_Fatal);\n        }\n        *osp = *perror_object;\n        errorexec_find(i_ctx_p, osp);\n\n        if (!r_has_type(osp, t_string) && !r_has_type(osp, t_name)) {\n            code = obj_cvs(imemory, osp, buf + 2, 256, &rlen, (const byte **)&bufptr);\n            if (code < 0) {\n                const char *unknownstr = \"--unknown--\";\n                rlen = strlen(unknownstr);\n                memcpy(buf, unknownstr, rlen);\n                bufptr = buf;\n            }\n            else {\n                ref *tobj;\n                bufptr[rlen] = '\\0';\n                /* Only pass a name object if the operator doesn't exist in systemdict\n                 * i.e. it's an internal operator we have hidden\n                 */\n                code = dict_find_string(systemdict, (const char *)bufptr, &tobj);\n                if (code < 0) {\n                    buf[0] = buf[1] = buf[rlen + 2] = buf[rlen + 3] = '-';\n                    rlen += 4;\n                    bufptr = buf;\n                }\n                else {\n                    bufptr = NULL;\n                }\n            }\n            if (bufptr) {\n                code = name_ref(imemory, buf, rlen, osp, 1);\n                if (code < 0)\n                    make_null(osp);\n            }\n        }\n    }\n    goto again;\n}", "target": 2, "idx": 10589}
{"commit_id": "6f34307bff645eb2935d82deee0119ec89866118", "project": "gobby", "func": "void Gobby::EditCommands::on_cut()\n{\n\tif (!m_current_view) {\n\t\tg_warning(\"No current view exists.\");\n\t\treturn;\n\t}\n\n\tg_assert(m_current_view->get_active_user() != NULL);\n\n\tgtk_text_buffer_cut_clipboard(\n\t\tGTK_TEXT_BUFFER(m_current_view->get_text_buffer()),\n\t\tgtk_clipboard_get(GDK_SELECTION_CLIPBOARD),\n\t\tTRUE);\n\n\tm_current_view->scroll_to_cursor_position(0.0);\n}", "target": 2, "idx": 10590}
{"commit_id": "0181fafb2134a177328443a60b5e29c4ee1041cb", "project": "wireshark", "func": "static gboolean\ncandump_write_packet(wtap_rec *rec, Buffer *buf, const msg_t *msg, int *err,\n                     gchar **err_info)\n{\n    static const char can_proto_name[]   = \"can-hostendian\";\n    static const char canfd_proto_name[] = \"canfd\";\n\n    /* Generate Exported PDU tags for the packet info */\n    ws_buffer_clean(buf);\n    if (msg->is_fd)\n    {\n        wtap_buffer_append_epdu_tag(buf, EXP_PDU_TAG_DISSECTOR_NAME, (const guint8 *)canfd_proto_name, sizeof canfd_proto_name - 1);\n    }\n    else\n    {\n        wtap_buffer_append_epdu_tag(buf, EXP_PDU_TAG_DISSECTOR_NAME, (const guint8 *)can_proto_name, sizeof can_proto_name - 1);\n    }\n    wtap_buffer_append_epdu_end(buf);\n\n    if (msg->is_fd)\n    {\n        canfd_frame_t canfd_frame = {0};\n\n        /*\n         * There's a maximum of CANFD_MAX_DLEN bytes in a CAN-FD frame.\n         */\n        if (msg->data.length > CANFD_MAX_DLEN) {\n            *err = WTAP_ERR_BAD_FILE;\n            if (err_info != NULL) {\n\t        *err_info = ws_strdup_printf(\"candump: File has %u-byte CAN FD packet, bigger than maximum of %u\",\n                                             msg->data.length, CANFD_MAX_DLEN);\n            }\n            return FALSE;\n        }\n\n        canfd_frame.can_id = msg->id;\n        canfd_frame.flags  = msg->flags;\n        canfd_frame.len    = msg->data.length;\n        memcpy(canfd_frame.data, msg->data.data, msg->data.length);\n\n        ws_buffer_append(buf, (guint8 *)&canfd_frame, sizeof(canfd_frame));\n    }\n    else\n    {\n        can_frame_t can_frame = {0};\n\n        /*\n         * There's a maximum of CAN_MAX_DLEN bytes in a CAN frame.\n         */\n        if (msg->data.length > CAN_MAX_DLEN) {\n            *err = WTAP_ERR_BAD_FILE;\n            if (err_info != NULL) {\n\t        *err_info = ws_strdup_printf(\"candump: File has %u-byte CAN packet, bigger than maximum of %u\",\n                                             msg->data.length, CAN_MAX_DLEN);\n            }\n            return FALSE;\n        }\n\n        can_frame.can_id  = msg->id;\n        can_frame.can_dlc = msg->data.length;\n        memcpy(can_frame.data, msg->data.data, msg->data.length);\n\n        ws_buffer_append(buf, (guint8 *)&can_frame, sizeof(can_frame));\n    }\n\n    rec->rec_type       = REC_TYPE_PACKET;\n    rec->block          = wtap_block_create(WTAP_BLOCK_PACKET);\n    rec->presence_flags = WTAP_HAS_TS;\n    rec->ts             = msg->ts;\n    rec->tsprec         = WTAP_TSPREC_USEC;\n\n    rec->rec_header.packet_header.caplen = (guint32)ws_buffer_length(buf);\n    rec->rec_header.packet_header.len    = (guint32)ws_buffer_length(buf);\n\n    return TRUE;\n}", "target": 1, "idx": 10591}
{"commit_id": "2ad0ea24a58d570634e09c2e58c3b314505eaa6a", "project": "nginx/njs", "func": "static njs_int_t\nnjs_json_parse(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    njs_int_t             ret;\n    njs_value_t           *text, value, lvalue, wrapper;\n    njs_object_t          *obj;\n    const u_char          *p, *end;\n    const njs_value_t     *reviver;\n    njs_string_prop_t     string;\n    njs_json_parse_ctx_t  ctx;\n\n    text = njs_lvalue_arg(&lvalue, args, nargs, 1);\n\n    if (njs_slow_path(!njs_is_string(text))) {\n        ret = njs_value_to_string(vm, text, text);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n    }\n\n    (void) njs_string_prop(&string, text);\n\n    p = string.start;\n    end = p + string.size;\n\n    ctx.vm = vm;\n    ctx.pool = vm->mem_pool;\n    ctx.depth = NJS_JSON_MAX_DEPTH;\n    ctx.start = string.start;\n    ctx.end = end;\n\n    p = njs_json_skip_space(p, end);\n    if (njs_slow_path(p == end)) {\n        njs_json_parse_exception(&ctx, \"Unexpected end of input\", p);\n        return NJS_ERROR;\n    }\n\n    p = njs_json_parse_value(&ctx, &value, p);\n    if (njs_slow_path(p == NULL)) {\n        return NJS_ERROR;\n    }\n\n    p = njs_json_skip_space(p, end);\n    if (njs_slow_path(p != end)) {\n        njs_json_parse_exception(&ctx, \"Unexpected token\", p);\n        return NJS_ERROR;\n    }\n\n    reviver = njs_arg(args, nargs, 2);\n\n    if (njs_slow_path(njs_is_function(reviver))) {\n        obj = njs_json_wrap_value(vm, &wrapper, &value);\n        if (njs_slow_path(obj == NULL)) {\n            return NJS_ERROR;\n        }\n\n        return njs_json_internalize_property(vm, njs_function(reviver),\n                                             &wrapper,\n                                             njs_value_arg(&njs_string_empty),\n                                             0, &vm->retval);\n    }\n\n    vm->retval = value;\n\n    return NJS_OK;\n}", "target": 3, "idx": 10592}
{"commit_id": "0181fafb2134a177328443a60b5e29c4ee1041cb", "project": "wireshark", "func": "static gboolean\ncandump_seek_read(wtap *wth , gint64 seek_off, wtap_rec *rec,\n                  Buffer *buf, int *err, gchar **err_info)\n{\n    msg_t msg;\n\n#ifdef CANDUMP_DEBUG\n    candump_debug_printf(\"%s: Read at offset %\" PRIi64 \"\\n\", G_STRFUNC, seek_off);\n#endif\n\n    if (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)\n    {\n        *err      = errno;\n        *err_info = g_strdup(g_strerror(errno));\n\n        return FALSE;\n    }\n\n    if (!candump_parse(wth->random_fh, &msg, NULL, err, err_info))\n        return FALSE;\n\n    return candump_write_packet(rec, buf, &msg, err, err_info);\n}", "target": 1, "idx": 10593}
{"commit_id": "bd36c5dc9fb6d90c46fbfed8c2d67516fc571ec8", "project": "rpm-software-management/rpm", "func": "int pgpPrtParams(const uint8_t * pkts, size_t pktlen, unsigned int pkttype,\n\t\t pgpDigParams * ret)\n{\n    const uint8_t *p = pkts;\n    const uint8_t *pend = pkts + pktlen;\n    pgpDigParams digp = NULL;\n    pgpDigParams selfsig = NULL;\n    int i = 0;\n    int alloced = 16; /* plenty for normal cases */\n    struct pgpPkt *all = xmalloc(alloced * sizeof(*all));\n    int rc = -1; /* assume failure */\n    int expect = 0;\n    int prevtag = 0;\n\n    while (p < pend) {\n\tstruct pgpPkt *pkt = &all[i];\n\tif (decodePkt(p, (pend - p), pkt))\n\t    break;\n\n\tif (digp == NULL) {\n\t    if (pkttype && pkt->tag != pkttype) {\n\t\tbreak;\n\t    } else {\n\t\tdigp = pgpDigParamsNew(pkt->tag);\n\t    }\n\t}\n\n\tif (expect) {\n\t    if (pkt->tag != expect)\n\t\tbreak;\n\t    selfsig = pgpDigParamsNew(pkt->tag);\n\t}\n\n\tif (pgpPrtPkt(pkt, selfsig ? selfsig : digp))\n\t    break;\n\n\tif (selfsig) {\n\t    /* subkeys must be followed by binding signature */\n\t    if (prevtag == PGPTAG_PUBLIC_SUBKEY) {\n\t\tif (selfsig->sigtype != PGPSIGTYPE_SUBKEY_BINDING)\n\t\t    break;\n\t    }\n\n\t    int xx = pgpVerifySelf(digp, selfsig, all, i);\n\n\t    selfsig = pgpDigParamsFree(selfsig);\n\t    if (xx)\n\t\tbreak;\n\t    expect = 0;\n\t}\n\n\tif (pkt->tag == PGPTAG_PUBLIC_SUBKEY)\n\t    expect = PGPTAG_SIGNATURE;\n\tprevtag = pkt->tag;\n\n\ti++;\n\tp += (pkt->body - pkt->head) + pkt->blen;\n\tif (pkttype == PGPTAG_SIGNATURE)\n\t    break;\n\n\tif (alloced <= i) {\n\t    alloced *= 2;\n\t    all = xrealloc(all, alloced * sizeof(*all));\n\t}\n    }\n\n    rc = (digp && (p == pend) && expect == 0) ? 0 : -1;\n\n    free(all);\n    if (ret && rc == 0) {\n\t*ret = digp;\n    } else {\n\tpgpDigParamsFree(digp);\n    }\n    return rc;\n}", "target": 1, "idx": 10594}
{"commit_id": "79462ad02e861803b3840cc782248c7359451cd9", "project": "torvalds/linux", "func": "static int inet_create(struct net *net, struct socket *sock, int protocol,\n\t\t       int kern)\n{\n\tstruct sock *sk;\n\tstruct inet_protosw *answer;\n\tstruct inet_sock *inet;\n\tstruct proto *answer_prot;\n\tunsigned char answer_flags;\n\tint try_loading_module = 0;\n\tint err;\n\n\tif (protocol < 0 || protocol >= IPPROTO_MAX)\n\t\treturn -EINVAL;\n\n\tsock->state = SS_UNCONNECTED;\n\n\t/* Look for the requested type/protocol pair. */\nlookup_protocol:\n\terr = -ESOCKTNOSUPPORT;\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(answer, &inetsw[sock->type], list) {\n\n\t\terr = 0;\n\t\t/* Check the non-wild match. */\n\t\tif (protocol == answer->protocol) {\n\t\t\tif (protocol != IPPROTO_IP)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t/* Check for the two wild cases. */\n\t\t\tif (IPPROTO_IP == protocol) {\n\t\t\t\tprotocol = answer->protocol;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (IPPROTO_IP == answer->protocol)\n\t\t\t\tbreak;\n\t\t}\n\t\terr = -EPROTONOSUPPORT;\n\t}\n\n\tif (unlikely(err)) {\n\t\tif (try_loading_module < 2) {\n\t\t\trcu_read_unlock();\n\t\t\t/*\n\t\t\t * Be more specific, e.g. net-pf-2-proto-132-type-1\n\t\t\t * (net-pf-PF_INET-proto-IPPROTO_SCTP-type-SOCK_STREAM)\n\t\t\t */\n\t\t\tif (++try_loading_module == 1)\n\t\t\t\trequest_module(\"net-pf-%d-proto-%d-type-%d\",\n\t\t\t\t\t       PF_INET, protocol, sock->type);\n\t\t\t/*\n\t\t\t * Fall back to generic, e.g. net-pf-2-proto-132\n\t\t\t * (net-pf-PF_INET-proto-IPPROTO_SCTP)\n\t\t\t */\n\t\t\telse\n\t\t\t\trequest_module(\"net-pf-%d-proto-%d\",\n\t\t\t\t\t       PF_INET, protocol);\n\t\t\tgoto lookup_protocol;\n\t\t} else\n\t\t\tgoto out_rcu_unlock;\n\t}\n\n\terr = -EPERM;\n\tif (sock->type == SOCK_RAW && !kern &&\n\t    !ns_capable(net->user_ns, CAP_NET_RAW))\n\t\tgoto out_rcu_unlock;\n\n\tsock->ops = answer->ops;\n\tanswer_prot = answer->prot;\n\tanswer_flags = answer->flags;\n\trcu_read_unlock();\n\n\tWARN_ON(!answer_prot->slab);\n\n\terr = -ENOBUFS;\n\tsk = sk_alloc(net, PF_INET, GFP_KERNEL, answer_prot, kern);\n\tif (!sk)\n\t\tgoto out;\n\n\terr = 0;\n\tif (INET_PROTOSW_REUSE & answer_flags)\n\t\tsk->sk_reuse = SK_CAN_REUSE;\n\n\tinet = inet_sk(sk);\n\tinet->is_icsk = (INET_PROTOSW_ICSK & answer_flags) != 0;\n\n\tinet->nodefrag = 0;\n\n\tif (SOCK_RAW == sock->type) {\n\t\tinet->inet_num = protocol;\n\t\tif (IPPROTO_RAW == protocol)\n\t\t\tinet->hdrincl = 1;\n\t}\n\n\tif (net->ipv4.sysctl_ip_no_pmtu_disc)\n\t\tinet->pmtudisc = IP_PMTUDISC_DONT;\n\telse\n\t\tinet->pmtudisc = IP_PMTUDISC_WANT;\n\n\tinet->inet_id = 0;\n\n\tsock_init_data(sock, sk);\n\n\tsk->sk_destruct\t   = inet_sock_destruct;\n\tsk->sk_protocol\t   = protocol;\n\tsk->sk_backlog_rcv = sk->sk_prot->backlog_rcv;\n\n\tinet->uc_ttl\t= -1;\n\tinet->mc_loop\t= 1;\n\tinet->mc_ttl\t= 1;\n\tinet->mc_all\t= 1;\n\tinet->mc_index\t= 0;\n\tinet->mc_list\t= NULL;\n\tinet->rcv_tos\t= 0;\n\n\tsk_refcnt_debug_inc(sk);\n\n\tif (inet->inet_num) {\n\t\t/* It assumes that any protocol which allows\n\t\t * the user to assign a number at socket\n\t\t * creation time automatically\n\t\t * shares.\n\t\t */\n\t\tinet->inet_sport = htons(inet->inet_num);\n\t\t/* Add to protocol hash chains. */\n\t\tsk->sk_prot->hash(sk);\n\t}\n\n\tif (sk->sk_prot->init) {\n\t\terr = sk->sk_prot->init(sk);\n\t\tif (err)\n\t\t\tsk_common_release(sk);\n\t}\nout:\n\treturn err;\nout_rcu_unlock:\n\trcu_read_unlock();\n\tgoto out;\n}", "target": 2, "idx": 10595}
{"commit_id": "0a557045476a2969c7079aec9eeb29d02f2809c6", "project": "radareorg/radare2", "func": "RList *r_bin_ne_get_entrypoints(r_bin_ne_obj_t *bin) {\n\tif (!bin->entry_table) {\n\t\treturn NULL;\n\t}\n\tRList *entries = r_list_newf (free);\n\tif (!entries) {\n\t\treturn NULL;\n\t}\n\tRList *segments = r_bin_ne_get_segments (bin);\n\tif (!segments) {\n\t\tr_list_free (entries);\n\t\treturn NULL;\n\t}\n\tif (bin->ne_header->csEntryPoint) {\n\t\tRBinAddr *entry = R_NEW0 (RBinAddr);\n\t\tif (!entry) {\n\t\t\tr_list_free (entries);\n\t\t\treturn NULL;\n\t\t}\n\t\tentry->bits = 16;\n\t\tut32 entry_cs = bin->ne_header->csEntryPoint;\n\t\tRBinSection *s = r_list_get_n (segments, entry_cs - 1);\n\t\tentry->paddr = bin->ne_header->ipEntryPoint + (s? s->paddr: 0);\n\n\t\tr_list_append (entries, entry);\n\t}\n\tint off = 0;\n\tsize_t tableat = bin->header_offset + bin->ne_header->EntryTableOffset;\n\twhile (off < bin->ne_header->EntryTableLength) {\n\t\tif (tableat + off >= r_buf_size (bin->buf)) {\n\t\t\tbreak;\n\t\t}\n\t\tut8 bundle_length = *(ut8 *)(bin->entry_table + off);\n\t\tif (!bundle_length) {\n\t\t\tbreak;\n\t\t}\n\t\toff++;\n\t\tut8 bundle_type = *(ut8 *)(bin->entry_table + off);\n\t\toff++;\n\t\tint i;\n\t\tfor (i = 0; i < bundle_length; i++) {\n\t\t\tif (tableat + off + 4 >= r_buf_size (bin->buf)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRBinAddr *entry = R_NEW0 (RBinAddr);\n\t\t\tif (!entry) {\n\t\t\t\tr_list_free (entries);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\toff++;\n\t\t\tif (!bundle_type) { // Skip\n\t\t\t\toff--;\n\t\t\t\tfree (entry);\n\t\t\t\tbreak;\n\t\t\t} else if (bundle_type == 0xff) { // moveable\n\t\t\t\toff += 2;\n\t\t\t\tut8 segnum = *(bin->entry_table + off);\n\t\t\t\toff++;\n\t\t\t\tif (off > bin->ne_header->EntryTableLength) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tut16 segoff = r_read_le16 (bin->entry_table + off);\n\t\t\t\tif (segnum > 0 && segnum < bin->ne_header->SegCount) {\n\t\t\t\t\tentry->paddr = (ut64)bin->segment_entries[segnum - 1].offset * bin->alignment + segoff;\n\t\t\t\t}\n\t\t\t} else { // Fixed\n\t\t\t\tif (off + 2 >= bin->ne_header->EntryTableLength) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tut16 delta = r_read_le16 (bin->entry_table + off);\n\t\t\t\tif (bundle_type < bin->ne_header->SegCount) {\n\t\t\t\t\tentry->paddr = (ut64)bin->segment_entries[bundle_type - 1].offset\n\t\t\t\t\t\t* bin->alignment + delta;\n\t\t\t\t}\n\t\t\t}\n\t\t\toff += 2;\n\t\t\tr_list_append (entries, entry);\n\t\t}\n\t}\n\tr_list_free (segments);\n\tbin->entries = entries;\n\treturn entries;\n}", "target": 3, "idx": 10596}
{"commit_id": "69818e2f2d246e6631ac2a2da692c3706b849c38", "project": "libtiff", "func": "static int createCroppedImage(struct image_data *image, struct crop_mask *crop,\n                              unsigned char **read_buff_ptr,\n                              unsigned char **crop_buff_ptr)\n{\n    tsize_t cropsize;\n    unsigned char *read_buff = NULL;\n    unsigned char *crop_buff = NULL;\n    unsigned char *new_buff = NULL;\n    static tsize_t prev_cropsize = 0;\n\n    read_buff = *read_buff_ptr;\n\n    /* process full image, no crop buffer needed */\n    crop_buff = read_buff;\n    *crop_buff_ptr = read_buff;\n    crop->combined_width = image->width;\n    crop->combined_length = image->length;\n\n    cropsize = crop->bufftotal;\n    crop_buff = *crop_buff_ptr;\n    if (!crop_buff)\n    {\n        crop_buff =\n            (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);\n        if (!crop_buff)\n        {\n            TIFFError(\"createCroppedImage\",\n                      \"Unable to allocate/reallocate crop buffer\");\n            return (-1);\n        }\n        _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n        prev_cropsize = cropsize;\n    }\n    else\n    {\n        if (prev_cropsize < cropsize)\n        {\n            new_buff =\n                _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n            if (!new_buff)\n            {\n                free(crop_buff);\n                crop_buff = (unsigned char *)limitMalloc(\n                    cropsize + NUM_BUFF_OVERSIZE_BYTES);\n            }\n            else\n                crop_buff = new_buff;\n            if (!crop_buff)\n            {\n                TIFFError(\"createCroppedImage\",\n                          \"Unable to allocate/reallocate crop buffer\");\n                return (-1);\n            }\n            _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);\n        }\n    }\n\n    *crop_buff_ptr = crop_buff;\n\n    if (crop->crop_mode & CROP_INVERT)\n    {\n        switch (crop->photometric)\n        {\n            /* Just change the interpretation */\n            case PHOTOMETRIC_MINISWHITE:\n            case PHOTOMETRIC_MINISBLACK:\n                image->photometric = crop->photometric;\n                break;\n            case INVERT_DATA_ONLY:\n            case INVERT_DATA_AND_TAG:\n                if (invertImage(image->photometric, image->spp, image->bps,\n                                crop->combined_width, crop->combined_length,\n                                crop_buff))\n                {\n                    TIFFError(\"createCroppedImage\",\n                              \"Failed to invert colorspace for image or \"\n                              \"cropped selection\");\n                    return (-1);\n                }\n                if (crop->photometric == INVERT_DATA_AND_TAG)\n                {\n                    switch (image->photometric)\n                    {\n                        case PHOTOMETRIC_MINISWHITE:\n                            image->photometric = PHOTOMETRIC_MINISBLACK;\n                            break;\n                        case PHOTOMETRIC_MINISBLACK:\n                            image->photometric = PHOTOMETRIC_MINISWHITE;\n                            break;\n                        default:\n                            break;\n                    }\n                }\n                break;\n            default:\n                break;\n        }\n    }\n\n    if (crop->crop_mode & CROP_MIRROR)\n    {\n        if (mirrorImage(image->spp, image->bps, crop->mirror,\n                        crop->combined_width, crop->combined_length, crop_buff))\n        {\n            TIFFError(\"createCroppedImage\",\n                      \"Failed to mirror image or cropped selection %s\",\n                      (crop->rotation == MIRROR_HORIZ) ? \"horizontally\"\n                                                       : \"vertically\");\n            return (-1);\n        }\n    }\n\n    if (crop->crop_mode &\n        CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n    {\n        if (rotateImage(crop->rotation, image, &crop->combined_width,\n                        &crop->combined_length, crop_buff_ptr, NULL, TRUE))\n        {\n            TIFFError(\"createCroppedImage\",\n                      \"Failed to rotate image or cropped selection by %\" PRIu16\n                      \" degrees\",\n                      crop->rotation);\n            return (-1);\n        }\n    }\n\n    if (crop_buff ==\n        read_buff)             /* we used the read buffer for the crop buffer */\n        *read_buff_ptr = NULL; /* so we don't try to free it later */\n\n    return (0);\n}", "target": 1, "idx": 10597}
{"commit_id": "c55aee1bf0e6b6feec8b2927b43f7a09a6d5f754", "project": "torvalds/linux", "func": "static int cypress_generic_port_probe(struct usb_serial_port *port)\n{\n\tstruct usb_serial *serial = port->serial;\n\tstruct cypress_private *priv;\n\n\tif (!port->interrupt_out_urb || !port->interrupt_in_urb) {\n\t\tdev_err(&port->dev, \"required endpoint is missing\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpriv = kzalloc(sizeof(struct cypress_private), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->comm_is_ok = !0;\n\tspin_lock_init(&priv->lock);\n\tif (kfifo_alloc(&priv->write_fifo, CYPRESS_BUF_SIZE, GFP_KERNEL)) {\n\t\tkfree(priv);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Skip reset for FRWD device. It is a workaound:\n\t   device hangs if it receives SET_CONFIGURE in Configured\n\t   state. */\n\tif (!is_frwd(serial->dev))\n\t\tusb_reset_configuration(serial->dev);\n\n\tpriv->cmd_ctrl = 0;\n\tpriv->line_control = 0;\n\tpriv->termios_initialized = 0;\n\tpriv->rx_flags = 0;\n\t/* Default packet format setting is determined by packet size.\n\t   Anything with a size larger then 9 must have a separate\n\t   count field since the 3 bit count field is otherwise too\n\t   small.  Otherwise we can use the slightly more compact\n\t   format.  This is in accordance with the cypress_m8 serial\n\t   converter app note. */\n\tif (port->interrupt_out_size > 9)\n\t\tpriv->pkt_fmt = packet_format_1;\n\telse\n\t\tpriv->pkt_fmt = packet_format_2;\n\n\tif (interval > 0) {\n\t\tpriv->write_urb_interval = interval;\n\t\tpriv->read_urb_interval = interval;\n\t\tdev_dbg(&port->dev, \"%s - read & write intervals forced to %d\\n\",\n\t\t\t__func__, interval);\n\t} else {\n\t\tpriv->write_urb_interval = port->interrupt_out_urb->interval;\n\t\tpriv->read_urb_interval = port->interrupt_in_urb->interval;\n\t\tdev_dbg(&port->dev, \"%s - intervals: read=%d write=%d\\n\",\n\t\t\t__func__, priv->read_urb_interval,\n\t\t\tpriv->write_urb_interval);\n\t}\n\tusb_set_serial_port_data(port, priv);\n\n\tport->port.drain_delay = 256;\n\n\treturn 0;\n}", "target": 1, "idx": 10598}
{"commit_id": "f0727df07c4d944d7d1c5002451cfbc9545d3288", "project": "uclouvain/openjpeg", "func": "int main(int argc, char *argv[])\n{\n    FILE *fout = NULL;\n\n    opj_dparameters_t parameters;           /* Decompression parameters */\n    opj_image_t* image = NULL;                  /* Image structure */\n    opj_codec_t* l_codec = NULL;                /* Handle to a decompressor */\n    opj_stream_t *l_stream = NULL;              /* Stream */\n    opj_codestream_info_v2_t* cstr_info = NULL;\n    opj_codestream_index_t* cstr_index = NULL;\n\n    OPJ_INT32 num_images, imageno;\n    img_fol_t img_fol;\n    dircnt_t *dirptr = NULL;\n\n    /* Set decoding parameters to default values */\n    opj_set_default_decoder_parameters(&parameters);\n\n    /* Initialize img_fol */\n    memset(&img_fol, 0, sizeof(img_fol_t));\n    img_fol.flag = OPJ_IMG_INFO | OPJ_J2K_MH_INFO | OPJ_J2K_MH_IND;\n\n    /* Parse input and get user encoding parameters */\n    if (parse_cmdline_decoder(argc, argv, &parameters, &img_fol) == 1) {\n        if (img_fol.imgdirpath) {\n            free(img_fol.imgdirpath);\n        }\n\n        return EXIT_FAILURE;\n    }\n\n    /* Initialize reading of directory */\n    if (img_fol.set_imgdir == 1) {\n        int it_image;\n        num_images = get_num_images(img_fol.imgdirpath);\n\n        dirptr = (dircnt_t*)malloc(sizeof(dircnt_t));\n        if (!dirptr) {\n            return EXIT_FAILURE;\n        }\n        /* Stores at max 10 image file names*/\n        dirptr->filename_buf = (char*) calloc((size_t) num_images,\n                                              OPJ_PATH_LEN * sizeof(char));\n        if (!dirptr->filename_buf) {\n            free(dirptr);\n            return EXIT_FAILURE;\n        }\n        dirptr->filename = (char**) calloc((size_t) num_images, sizeof(char*));\n\n        if (!dirptr->filename) {\n            goto fails;\n        }\n\n        for (it_image = 0; it_image < num_images; it_image++) {\n            dirptr->filename[it_image] = dirptr->filename_buf + it_image * OPJ_PATH_LEN;\n        }\n\n        if (load_images(dirptr, img_fol.imgdirpath) == 1) {\n            goto fails;\n        }\n\n        if (num_images == 0) {\n            fprintf(stdout, \"Folder is empty\\n\");\n            goto fails;\n        }\n    } else {\n        num_images = 1;\n    }\n\n    /* Try to open for writing the output file if necessary */\n    if (parameters.outfile[0] != 0) {\n        fout = fopen(parameters.outfile, \"w\");\n        if (!fout) {\n            fprintf(stderr, \"ERROR -> failed to open %s for writing\\n\", parameters.outfile);\n            goto fails;\n        }\n    } else {\n        fout = stdout;\n    }\n\n    /* Read the header of each image one by one */\n    for (imageno = 0; imageno < num_images ; imageno++) {\n\n        fprintf(stderr, \"\\n\");\n\n        if (img_fol.set_imgdir == 1) {\n            if (get_next_file(imageno, dirptr, &img_fol, &parameters)) {\n                fprintf(stderr, \"skipping file...\\n\");\n                continue;\n            }\n        }\n\n        /* Read the input file and put it in memory */\n        /* ---------------------------------------- */\n\n        l_stream = opj_stream_create_default_file_stream(parameters.infile, 1);\n        if (!l_stream) {\n            fprintf(stderr, \"ERROR -> failed to create the stream from the file %s\\n\",\n                    parameters.infile);\n            goto fails;\n        }\n\n        /* Read the JPEG2000 stream */\n        /* ------------------------ */\n\n        switch (parameters.decod_format) {\n        case J2K_CFMT: { /* JPEG-2000 codestream */\n            /* Get a decoder handle */\n            l_codec = opj_create_decompress(OPJ_CODEC_J2K);\n            break;\n        }\n        case JP2_CFMT: { /* JPEG 2000 compressed image data */\n            /* Get a decoder handle */\n            l_codec = opj_create_decompress(OPJ_CODEC_JP2);\n            break;\n        }\n        case JPT_CFMT: { /* JPEG 2000, JPIP */\n            /* Get a decoder handle */\n            l_codec = opj_create_decompress(OPJ_CODEC_JPT);\n            break;\n        }\n        default:\n            fprintf(stderr, \"skipping file..\\n\");\n            opj_stream_destroy(l_stream);\n            continue;\n        }\n\n        /* catch events using our callbacks and give a local context */\n        opj_set_info_handler(l_codec, info_callback, 00);\n        opj_set_warning_handler(l_codec, warning_callback, 00);\n        opj_set_error_handler(l_codec, error_callback, 00);\n\n        parameters.flags |= OPJ_DPARAMETERS_DUMP_FLAG;\n\n        /* Setup the decoder decoding parameters using user parameters */\n        if (!opj_setup_decoder(l_codec, &parameters)) {\n            fprintf(stderr, \"ERROR -> opj_dump: failed to setup the decoder\\n\");\n            opj_stream_destroy(l_stream);\n            opj_destroy_codec(l_codec);\n            fclose(fout);\n            goto fails;\n        }\n\n        /* Read the main header of the codestream and if necessary the JP2 boxes*/\n        if (! opj_read_header(l_stream, l_codec, &image)) {\n            fprintf(stderr, \"ERROR -> opj_dump: failed to read the header\\n\");\n            opj_stream_destroy(l_stream);\n            opj_destroy_codec(l_codec);\n            opj_image_destroy(image);\n            fclose(fout);\n            goto fails;\n        }\n\n        opj_dump_codec(l_codec, img_fol.flag, fout);\n\n        cstr_info = opj_get_cstr_info(l_codec);\n\n        cstr_index = opj_get_cstr_index(l_codec);\n\n        /* close the byte stream */\n        opj_stream_destroy(l_stream);\n\n        /* free remaining structures */\n        if (l_codec) {\n            opj_destroy_codec(l_codec);\n        }\n\n        /* destroy the image header */\n        opj_image_destroy(image);\n\n        /* destroy the codestream index */\n        opj_destroy_cstr_index(&cstr_index);\n\n        /* destroy the codestream info */\n        opj_destroy_cstr_info(&cstr_info);\n\n    }\n\n    /* Close the output file */\n    fclose(fout);\n\n    return EXIT_SUCCESS;\n\nfails:\n    if (dirptr) {\n        if (dirptr->filename) {\n            free(dirptr->filename);\n        }\n        if (dirptr->filename_buf) {\n            free(dirptr->filename_buf);\n        }\n        free(dirptr);\n    }\n    return EXIT_FAILURE;\n}", "target": 1, "idx": 10599}
{"commit_id": "01faddbe2711a4156180c4a92837e2f23683cc68", "project": "ImageMagick", "func": "MagickPrivate MagickBooleanType OpenModule(const char *module,\n  ExceptionInfo *exception)\n{\n  char\n    module_name[MagickPathExtent],\n    name[MagickPathExtent],\n    path[MagickPathExtent];\n\n  MagickBooleanType\n    status;\n\n  ModuleHandle\n    handle;\n\n  ModuleInfo\n    *module_info;\n\n  PolicyRights\n    rights;\n\n  const CoderInfo\n    *p;\n\n  size_t\n    signature;\n\n  /*\n    Assign module name from alias.\n  */\n  assert(module != (const char *) NULL);\n  module_info=(ModuleInfo *) GetModuleInfo(module,exception);\n  if (module_info != (ModuleInfo *) NULL)\n    return(MagickTrue);\n  (void) CopyMagickString(module_name,module,MagickPathExtent);\n  p=GetCoderInfo(module,exception);\n  if (p != (CoderInfo *) NULL)\n    (void) CopyMagickString(module_name,p->name,MagickPathExtent);\n  rights=ReadPolicyRights|WritePolicyRights;\n  if (IsRightsAuthorized(ModulePolicyDomain,rights,module_name) == MagickFalse)\n    {\n      errno=EPERM;\n      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n        \"NotAuthorized\",\"`%s'\",module);\n      return(MagickFalse);\n    }\n  if (GetValueFromSplayTree(module_list,module_name) != (void *) NULL)\n    return(MagickTrue);  /* module already opened, return */\n  /*\n    Locate module.\n  */\n  handle=(ModuleHandle) NULL;\n  TagToCoderModuleName(module_name,name);\n  (void) LogMagickEvent(ModuleEvent,GetMagickModule(),\n    \"Searching for module \\\"%s\\\" using filename \\\"%s\\\"\",module_name,name);\n  *path='\\0';\n  status=GetMagickModulePath(name,MagickImageCoderModule,path,exception);\n  if (status == MagickFalse)\n    return(MagickFalse);\n  /*\n    Load module\n  */\n  (void) LogMagickEvent(ModuleEvent,GetMagickModule(),\n    \"Opening module at path \\\"%s\\\"\",path);\n  handle=(ModuleHandle) lt_dlopen(path);\n  if (handle == (ModuleHandle) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ModuleError,\n        \"UnableToLoadModule\",\"'%s': %s\",path,lt_dlerror());\n      return(MagickFalse);\n    }\n  /*\n    Register module.\n  */\n  module_info=AcquireModuleInfo(path,module_name);\n  module_info->handle=handle;\n  if (RegisterModule(module_info,exception) == (ModuleInfo *) NULL)\n    return(MagickFalse);\n  /*\n    Define RegisterFORMATImage method.\n  */\n  TagToModuleName(module_name,\"Register%sImage\",name);\n  module_info->register_module=(size_t (*)(void)) lt_dlsym(handle,name);\n  if (module_info->register_module == (size_t (*)(void)) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ModuleError,\n        \"UnableToRegisterImageFormat\",\"'%s': %s\",module_name,lt_dlerror());\n      return(MagickFalse);\n    }\n  (void) LogMagickEvent(ModuleEvent,GetMagickModule(),\n    \"Method \\\"%s\\\" in module \\\"%s\\\" at address %p\",name,module_name,\n    (void *) module_info->register_module);\n  /*\n    Define UnregisterFORMATImage method.\n  */\n  TagToModuleName(module_name,\"Unregister%sImage\",name);\n  module_info->unregister_module=(void (*)(void)) lt_dlsym(handle,name);\n  if (module_info->unregister_module == (void (*)(void)) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ModuleError,\n        \"UnableToRegisterImageFormat\",\"'%s': %s\",module_name,lt_dlerror());\n      return(MagickFalse);\n    }\n  (void) LogMagickEvent(ModuleEvent,GetMagickModule(),\n    \"Method \\\"%s\\\" in module \\\"%s\\\" at address %p\",name,module_name,\n    (void *) module_info->unregister_module);\n  signature=module_info->register_module();\n  if (signature != MagickImageCoderSignature)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ModuleError,\n        \"ImageCoderSignatureMismatch\",\"'%s': %8lx != %8lx\",module_name,\n        (unsigned long) signature,(unsigned long) MagickImageCoderSignature);\n      return(MagickFalse);\n    }\n  return(MagickTrue);\n}", "target": 1, "idx": 10600}
{"commit_id": "52346bf187b5a7f1c0fe9075b328b7ad6abe78f6", "project": "flatpak", "func": "static void\nflatpak_proxy_client_init (FlatpakProxyClient *client)\n{\n  init_side (client, &client->client_side);\n  init_side (client, &client->bus_side);\n\n  client->auth_buffer = g_byte_array_new ();\n  client->rewrite_reply = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_object_unref);\n  client->get_owner_reply = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_free);\n  client->unique_id_policy = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n}", "target": 2, "idx": 10601}
{"commit_id": "840f3af31a5b8d2d395d9367c826ed756e380fb9", "project": "eclipse-openj9/openj9", "func": "static jclass\ngetClassAt(JNIEnv *env, jobject constantPoolOop, jint cpIndex, UDATA resolveFlags)\n{\n\tjclass returnValue = NULL;\n\tJ9VMThread *vmThread = (J9VMThread *) env;\n\tJ9InternalVMFunctions *vmFunctions = vmThread->javaVM->internalVMFunctions;\n\tSunReflectCPResult result = NULL_POINTER_EXCEPTION;\n\n\tif (NULL != constantPoolOop) {\n\t\tJ9Class *clazz = NULL;\n\t\tvmFunctions->internalEnterVMFromJNI(vmThread);\n\t\tresolveFlags |= (J9_RESOLVE_FLAG_NO_THROW_ON_FAIL | J9_RESOLVE_FLAG_NO_CLASS_INIT | J9_RESOLVE_FLAG_NO_CP_UPDATE);\n\t\tresult = getJ9ClassAt(vmThread, constantPoolOop, cpIndex, resolveFlags, &clazz);\n\t\tif (NULL != clazz) {\n\t\t\treturnValue = vmFunctions->j9jni_createLocalRef(env, J9VM_J9CLASS_TO_HEAPCLASS(clazz));\n\t\t}\n\t\tvmFunctions->internalExitVMToJNI(vmThread);\n\t}\n\n\tcheckResult(env, result);\n\n\treturn returnValue;\n}", "target": 1, "idx": 10602}
{"commit_id": "d1c5e4da5bae7f220bc30719888bb389c905c0c5", "project": "pjsip/pjproject", "func": "static pj_status_t parse_rr(pj_dns_parsed_rr *rr, pj_pool_t *pool,\n                            const pj_uint8_t *pkt,\n                            const pj_uint8_t *start, const pj_uint8_t *max,\n                            int *parsed_len)\n{\n    const pj_uint8_t *p = start;\n    int name_len, name_part_len;\n    pj_status_t status;\n\n    /* Get the length of the name */\n    status = get_name_len(0, pkt, start, max, &name_part_len, &name_len);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    /* Allocate memory for the name */\n    rr->name.ptr = (char*) pj_pool_alloc(pool, name_len+4);\n    rr->name.slen = 0;\n\n    /* Get the name */\n    status = get_name(0, pkt, start, max, &rr->name);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    p = (start + name_part_len);\n\n    /* Check the size can accomodate next few fields. */\n    if (p+10 > max)\n        return PJLIB_UTIL_EDNSINSIZE;\n\n    /* Get the type */\n    pj_memcpy(&rr->type, p, 2);\n    rr->type = pj_ntohs(rr->type);\n    p += 2;\n    \n    /* Get the class */\n    pj_memcpy(&rr->dnsclass, p, 2);\n    rr->dnsclass = pj_ntohs(rr->dnsclass);\n    p += 2;\n\n    /* Class MUST be IN */\n    if (rr->dnsclass != 1) {\n        /* Class is not IN, return error only if type is known (see #1889) */\n        if (rr->type == PJ_DNS_TYPE_A     || rr->type == PJ_DNS_TYPE_AAAA  ||\n            rr->type == PJ_DNS_TYPE_CNAME || rr->type == PJ_DNS_TYPE_NS    ||\n            rr->type == PJ_DNS_TYPE_PTR   || rr->type == PJ_DNS_TYPE_SRV)\n        {\n            return PJLIB_UTIL_EDNSINCLASS;\n        }\n    }\n\n    /* Get TTL */\n    pj_memcpy(&rr->ttl, p, 4);\n    rr->ttl = pj_ntohl(rr->ttl);\n    p += 4;\n\n    /* Get rdlength */\n    pj_memcpy(&rr->rdlength, p, 2);\n    rr->rdlength = pj_ntohs(rr->rdlength);\n    p += 2;\n\n    /* Check that length is valid */\n    if (p + rr->rdlength > max)\n        return PJLIB_UTIL_EDNSINSIZE;\n\n    /* Parse some well known records */\n    if (rr->type == PJ_DNS_TYPE_A) {\n        if (p + 4 > max)\n            return PJLIB_UTIL_EDNSINSIZE;\n        pj_memcpy(&rr->rdata.a.ip_addr, p, 4);\n        p += 4;\n\n    } else if (rr->type == PJ_DNS_TYPE_AAAA) {\n        if (p + 16 > max)\n            return PJLIB_UTIL_EDNSINSIZE;\n        pj_memcpy(&rr->rdata.aaaa.ip_addr, p, 16);\n        p += 16;\n\n    } else if (rr->type == PJ_DNS_TYPE_CNAME ||\n               rr->type == PJ_DNS_TYPE_NS ||\n               rr->type == PJ_DNS_TYPE_PTR) \n    {\n\n        /* Get the length of the target name */\n        status = get_name_len(0, pkt, p, max, &name_part_len, &name_len);\n        if (status != PJ_SUCCESS)\n            return status;\n\n        /* Allocate memory for the name */\n        rr->rdata.cname.name.ptr = (char*) pj_pool_alloc(pool, name_len);\n        rr->rdata.cname.name.slen = 0;\n\n        /* Get the name */\n        status = get_name(0, pkt, p, max, &rr->rdata.cname.name);\n        if (status != PJ_SUCCESS)\n            return status;\n\n        p += name_part_len;\n\n    } else if (rr->type == PJ_DNS_TYPE_SRV) {\n        if (p + 6 > max)\n            return PJLIB_UTIL_EDNSINSIZE;\n\n        /* Priority */\n        pj_memcpy(&rr->rdata.srv.prio, p, 2);\n        rr->rdata.srv.prio = pj_ntohs(rr->rdata.srv.prio);\n        p += 2;\n\n        /* Weight */\n        pj_memcpy(&rr->rdata.srv.weight, p, 2);\n        rr->rdata.srv.weight = pj_ntohs(rr->rdata.srv.weight);\n        p += 2;\n\n        /* Port */\n        pj_memcpy(&rr->rdata.srv.port, p, 2);\n        rr->rdata.srv.port = pj_ntohs(rr->rdata.srv.port);\n        p += 2;\n        \n        /* Get the length of the target name */\n        status = get_name_len(0, pkt, p, max, &name_part_len, &name_len);\n        if (status != PJ_SUCCESS)\n            return status;\n\n        /* Allocate memory for the name */\n        rr->rdata.srv.target.ptr = (char*) pj_pool_alloc(pool, name_len);\n        rr->rdata.srv.target.slen = 0;\n\n        /* Get the name */\n        status = get_name(0, pkt, p, max, &rr->rdata.srv.target);\n        if (status != PJ_SUCCESS)\n            return status;\n        p += name_part_len;\n\n    } else {\n        /* Copy the raw data */\n        rr->data = pj_pool_alloc(pool, rr->rdlength);\n        pj_memcpy(rr->data, p, rr->rdlength);\n\n        p += rr->rdlength;\n    }\n\n    *parsed_len = (int)(p - start);\n    return PJ_SUCCESS;\n}", "target": 2, "idx": 10603}
{"commit_id": "7872a831783e17dcc4d0aa70cffc256afb664f7a", "project": "ceph", "func": "int process_request(RGWRados* const store,\n                    RGWREST* const rest,\n                    RGWRequest* const req,\n                    const std::string& frontend_prefix,\n                    const rgw_auth_registry_t& auth_registry,\n                    RGWRestfulIO* const client_io,\n                    OpsLogSocket* const olog,\n                    int* http_ret)\n{\n  int ret = client_io->init(g_ceph_context);\n\n  req->log_init();\n\n  dout(1) << \"====== starting new request req=\" << hex << req << dec\n\t  << \" =====\" << dendl;\n  perfcounter->inc(l_rgw_req);\n\n  RGWEnv& rgw_env = client_io->get_env();\n\n  RGWUserInfo userinfo;\n\n  struct req_state rstate(g_ceph_context, &rgw_env, &userinfo);\n  struct req_state *s = &rstate;\n\n  RGWObjectCtx rados_ctx(store, s);\n  s->obj_ctx = &rados_ctx;\n\n  if (ret < 0) {\n    s->cio = client_io;\n    abort_early(s, nullptr, ret, nullptr);\n    return ret;\n  }\n\n  s->req_id = store->unique_id(req->id);\n  s->trans_id = store->unique_trans_id(req->id);\n  s->host_id = store->host_id;\n\n  req->log_format(s, \"initializing for trans_id = %s\", s->trans_id.c_str());\n\n  RGWOp* op = nullptr;\n  int init_error = 0;\n  bool should_log = false;\n  RGWRESTMgr *mgr;\n  RGWHandler_REST *handler = rest->get_handler(store, s,\n                                               auth_registry,\n                                               frontend_prefix,\n                                               client_io, &mgr, &init_error);\n  if (init_error != 0) {\n    abort_early(s, nullptr, init_error, nullptr);\n    goto done;\n  }\n  dout(10) << \"handler=\" << typeid(*handler).name() << dendl;\n\n  should_log = mgr->get_logging();\n\n  req->log_format(s, \"getting op %d\", s->op);\n  op = handler->get_op(store);\n  if (!op) {\n    abort_early(s, NULL, -ERR_METHOD_NOT_ALLOWED, handler);\n    goto done;\n  }\n\n  req->op = op;\n  dout(10) << \"op=\" << typeid(*op).name() << dendl;\n\n  s->op_type = op->get_type();\n\n  req->log(s, \"verifying requester\");\n  ret = op->verify_requester(auth_registry);\n  if (ret < 0) {\n    dout(10) << \"failed to authorize request\" << dendl;\n    abort_early(s, NULL, ret, handler);\n    goto done;\n  }\n\n  /* FIXME: remove this after switching all handlers to the new authentication\n   * infrastructure. */\n  if (nullptr == s->auth.identity) {\n    s->auth.identity = rgw::auth::transform_old_authinfo(s);\n  }\n\n  req->log(s, \"normalizing buckets and tenants\");\n  ret = handler->postauth_init();\n  if (ret < 0) {\n    dout(10) << \"failed to run post-auth init\" << dendl;\n    abort_early(s, op, ret, handler);\n    goto done;\n  }\n\n  if (s->user->suspended) {\n    dout(10) << \"user is suspended, uid=\" << s->user->user_id << dendl;\n    abort_early(s, op, -ERR_USER_SUSPENDED, handler);\n    goto done;\n  }\n\n  ret = rgw_process_authenticated(handler, op, req, s);\n  if (ret < 0) {\n    abort_early(s, op, ret, handler);\n    goto done;\n  }\ndone:\n  try {\n    client_io->complete_request();\n  } catch (rgw::io::Exception& e) {\n    dout(0) << \"ERROR: client_io->complete_request() returned \"\n            << e.what() << dendl;\n  }\n\n  if (should_log) {\n    rgw_log_op(store, rest, s, (op ? op->name() : \"unknown\"), olog);\n  }\n\n  if (http_ret != nullptr) {\n    *http_ret = s->err.http_ret;\n  }\n  int op_ret = 0;\n  if (op) {\n    op_ret = op->get_ret();\n  }\n\n  req->log_format(s, \"op status=%d\", op_ret);\n  req->log_format(s, \"http status=%d\", s->err.http_ret);\n\n  if (handler)\n    handler->put_op(op);\n  rest->put_handler(handler);\n\n  dout(1) << \"====== req done req=\" << hex << req << dec\n\t  << \" op status=\" << op_ret\n\t  << \" http_status=\" << s->err.http_ret\n\t  << \" ======\"\n\t  << dendl;\n\n  return (ret < 0 ? ret : s->err.ret);\n}", "target": 2, "idx": 10604}
{"commit_id": "9a0db453ba017ebcaccbee933ee6511a9ae4d1c8", "project": "openssl", "func": "int X509_verify_cert(X509_STORE_CTX *ctx)\n{\n    X509 *x, *xtmp, *xtmp2, *chain_ss = NULL;\n    int bad_chain = 0;\n    X509_VERIFY_PARAM *param = ctx->param;\n    int depth, i, ok = 0;\n    int num, j, retry;\n    int (*cb) (int xok, X509_STORE_CTX *xctx);\n    STACK_OF(X509) *sktmp = NULL;\n    if (ctx->cert == NULL) {\n        X509err(X509_F_X509_VERIFY_CERT, X509_R_NO_CERT_SET_FOR_US_TO_VERIFY);\n        return -1;\n    }\n\n    cb = ctx->verify_cb;\n\n    /*\n     * first we make sure the chain we are going to build is present and that\n     * the first entry is in place\n     */\n    if (ctx->chain == NULL) {\n        if (((ctx->chain = sk_X509_new_null()) == NULL) ||\n            (!sk_X509_push(ctx->chain, ctx->cert))) {\n            X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);\n            goto end;\n        }\n        CRYPTO_add(&ctx->cert->references, 1, CRYPTO_LOCK_X509);\n        ctx->last_untrusted = 1;\n    }\n\n    /* We use a temporary STACK so we can chop and hack at it */\n    if (ctx->untrusted != NULL\n        && (sktmp = sk_X509_dup(ctx->untrusted)) == NULL) {\n        X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);\n        goto end;\n    }\n\n    num = sk_X509_num(ctx->chain);\n    x = sk_X509_value(ctx->chain, num - 1);\n    depth = param->depth;\n\n    for (;;) {\n        /* If we have enough, we break */\n        if (depth < num)\n            break;              /* FIXME: If this happens, we should take\n                                 * note of it and, if appropriate, use the\n                                 * X509_V_ERR_CERT_CHAIN_TOO_LONG error code\n                                 * later. */\n\n        /* If we are self signed, we break */\n        if (ctx->check_issued(ctx, x, x))\n            break;\n\n        /* If we were passed a cert chain, use it first */\n        if (ctx->untrusted != NULL) {\n            xtmp = find_issuer(ctx, sktmp, x);\n            if (xtmp != NULL) {\n                if (!sk_X509_push(ctx->chain, xtmp)) {\n                    X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);\n                    goto end;\n                }\n                CRYPTO_add(&xtmp->references, 1, CRYPTO_LOCK_X509);\n                (void)sk_X509_delete_ptr(sktmp, xtmp);\n                ctx->last_untrusted++;\n                x = xtmp;\n                num++;\n                /*\n                 * reparse the full chain for the next one\n                 */\n                continue;\n            }\n        }\n        break;\n    }\n\n    /* Remember how many untrusted certs we have */\n    j = num;\n    /*\n     * at this point, chain should contain a list of untrusted certificates.\n     * We now need to add at least one trusted one, if possible, otherwise we\n     * complain.\n     */\n\n    do {\n        /*\n         * Examine last certificate in chain and see if it is self signed.\n         */\n        i = sk_X509_num(ctx->chain);\n        x = sk_X509_value(ctx->chain, i - 1);\n        if (ctx->check_issued(ctx, x, x)) {\n            /* we have a self signed certificate */\n            if (sk_X509_num(ctx->chain) == 1) {\n                /*\n                 * We have a single self signed certificate: see if we can\n                 * find it in the store. We must have an exact match to avoid\n                 * possible impersonation.\n                 */\n                ok = ctx->get_issuer(&xtmp, ctx, x);\n                if ((ok <= 0) || X509_cmp(x, xtmp)) {\n                    ctx->error = X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT;\n                    ctx->current_cert = x;\n                    ctx->error_depth = i - 1;\n                    if (ok == 1)\n                        X509_free(xtmp);\n                    bad_chain = 1;\n                    ok = cb(0, ctx);\n                    if (!ok)\n                        goto end;\n                } else {\n                    /*\n                     * We have a match: replace certificate with store\n                     * version so we get any trust settings.\n                     */\n                    X509_free(x);\n                    x = xtmp;\n                    (void)sk_X509_set(ctx->chain, i - 1, x);\n                    ctx->last_untrusted = 0;\n                }\n            } else {\n                /*\n                 * extract and save self signed certificate for later use\n                 */\n                chain_ss = sk_X509_pop(ctx->chain);\n                ctx->last_untrusted--;\n                num--;\n                j--;\n                x = sk_X509_value(ctx->chain, num - 1);\n            }\n        }\n        /* We now lookup certs from the certificate store */\n        for (;;) {\n            /* If we have enough, we break */\n            if (depth < num)\n                break;\n            /* If we are self signed, we break */\n            if (ctx->check_issued(ctx, x, x))\n                break;\n            ok = ctx->get_issuer(&xtmp, ctx, x);\n            if (ok < 0)\n                return ok;\n            if (ok == 0)\n                break;\n            x = xtmp;\n            if (!sk_X509_push(ctx->chain, x)) {\n                X509_free(xtmp);\n                X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);\n                return 0;\n            }\n            num++;\n        }\n\n        /*\n         * If we haven't got a least one certificate from our store then check\n         * if there is an alternative chain that could be used.  We only do this\n         * if the user hasn't switched off alternate chain checking\n         */\n        retry = 0;\n        if (j == ctx->last_untrusted &&\n            !(ctx->param->flags & X509_V_FLAG_NO_ALT_CHAINS)) {\n            while (j-- > 1) {\n                xtmp2 = sk_X509_value(ctx->chain, j - 1);\n                ok = ctx->get_issuer(&xtmp, ctx, xtmp2);\n                if (ok < 0)\n                    goto end;\n                /* Check if we found an alternate chain */\n                if (ok > 0) {\n                    /*\n                     * Free up the found cert we'll add it again later\n                     */\n                    X509_free(xtmp);\n\n                    /*\n                     * Dump all the certs above this point - we've found an\n                     * alternate chain\n                     */\n                    while (num > j) {\n                        xtmp = sk_X509_pop(ctx->chain);\n                        X509_free(xtmp);\n                        num--;\n                    }\n                    ctx->last_untrusted = sk_X509_num(ctx->chain);\n                    retry = 1;\n                    break;\n                }\n            }\n        }\n    } while (retry);\n\n    /* Is last certificate looked up self signed? */\n    if (!ctx->check_issued(ctx, x, x)) {\n        if ((chain_ss == NULL) || !ctx->check_issued(ctx, x, chain_ss)) {\n            if (ctx->last_untrusted >= num)\n                ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY;\n            else\n                ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT;\n            ctx->current_cert = x;\n        } else {\n\n            sk_X509_push(ctx->chain, chain_ss);\n            num++;\n            ctx->last_untrusted = num;\n            ctx->current_cert = chain_ss;\n            ctx->error = X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN;\n            chain_ss = NULL;\n        }\n\n        ctx->error_depth = num - 1;\n        bad_chain = 1;\n        ok = cb(0, ctx);\n        if (!ok)\n            goto end;\n    }\n\n    /* We have the chain complete: now we need to check its purpose */\n    ok = check_chain_extensions(ctx);\n\n    if (!ok)\n        goto end;\n\n    /* Check name constraints */\n\n    ok = check_name_constraints(ctx);\n\n    if (!ok)\n        goto end;\n\n    /* The chain extensions are OK: check trust */\n\n    if (param->trust > 0)\n        ok = check_trust(ctx);\n\n    if (!ok)\n        goto end;\n\n    /* We may as well copy down any DSA parameters that are required */\n    X509_get_pubkey_parameters(NULL, ctx->chain);\n\n    /*\n     * Check revocation status: we do this after copying parameters because\n     * they may be needed for CRL signature verification.\n     */\n\n    ok = ctx->check_revocation(ctx);\n    if (!ok)\n        goto end;\n\n    /* At this point, we have a chain and need to verify it */\n    if (ctx->verify != NULL)\n        ok = ctx->verify(ctx);\n    else\n        ok = internal_verify(ctx);\n    if (!ok)\n        goto end;\n\n#ifndef OPENSSL_NO_RFC3779\n    /* RFC 3779 path validation, now that CRL check has been done */\n    ok = v3_asid_validate_path(ctx);\n    if (!ok)\n        goto end;\n    ok = v3_addr_validate_path(ctx);\n    if (!ok)\n        goto end;\n#endif\n\n    /* If we get this far evaluate policies */\n    if (!bad_chain && (ctx->param->flags & X509_V_FLAG_POLICY_CHECK))\n        ok = ctx->check_policy(ctx);\n    if (!ok)\n        goto end;\n    if (0) {\n end:\n        X509_get_pubkey_parameters(NULL, ctx->chain);\n    }\n    if (sktmp != NULL)\n        sk_X509_free(sktmp);\n    if (chain_ss != NULL)\n        X509_free(chain_ss);\n    return ok;\n}", "target": 1, "idx": 10605}
{"commit_id": "4f10021e7ee527c1aa24853e2947e38e154d9ccb", "project": "michaelrsweet/pdfio", "func": "bool\t\t\t\t\t// O - `true` on success, `false` on failure\n_pdfioDictSetValue(\n    pdfio_dict_t   *dict,\t\t// I - Dictionary\n    const char     *key,\t\t// I - Key\n    _pdfio_value_t *value)\t\t// I - Value\n{\n  _pdfio_pair_t\t*pair;\t\t\t// Current pair\n\n\n  PDFIO_DEBUG(\"_pdfioDictSetValue(dict=%p, key=\\\"%s\\\", value=%p)\\n\", dict, key, (void *)value);\n\n  // See if the key is already set...\n  if (dict->num_pairs > 0)\n  {\n    _pdfio_pair_t\tpkey;\t\t// Search key\n\n    pkey.key = key;\n\n    if ((pair = (_pdfio_pair_t *)bsearch(&pkey, dict->pairs, dict->num_pairs, sizeof(_pdfio_pair_t), (int (*)(const void *, const void *))compare_pairs)) != NULL)\n    {\n      // Yes, replace the value...\n      PDFIO_DEBUG(\"_pdfioDictSetValue: Replacing existing value.\\n\");\n      if (pair->value.type == PDFIO_VALTYPE_BINARY)\n        free(pair->value.value.binary.data);\n      pair->value = *value;\n      return (true);\n    }\n  }\n\n  // Nope, add a pair...\n  if (dict->num_pairs >= dict->alloc_pairs)\n  {\n    // Expand the dictionary...\n    _pdfio_pair_t *temp = (_pdfio_pair_t *)realloc(dict->pairs, (dict->alloc_pairs + 8) * sizeof(_pdfio_pair_t));\n\n    if (!temp)\n    {\n      PDFIO_DEBUG(\"_pdfioDictSetValue: Out of memory.\\n\");\n      return (false);\n    }\n\n    dict->pairs       = temp;\n    dict->alloc_pairs += 8;\n  }\n\n  pair = dict->pairs + dict->num_pairs;\n  dict->num_pairs ++;\n\n  pair->key   = key;\n  pair->value = *value;\n\n  // Re-sort the dictionary and return...\n  if (dict->num_pairs > 1 && compare_pairs(pair - 1, pair) > 0)\n    qsort(dict->pairs, dict->num_pairs, sizeof(_pdfio_pair_t), (int (*)(const void *, const void *))compare_pairs);\n\n#ifdef DEBUG\n  PDFIO_DEBUG(\"_pdfioDictSetValue(%p): %lu pairs\\n\", (void *)dict, (unsigned long)dict->num_pairs);\n//  PDFIO_DEBUG(\"_pdfioDictSetValue(%p): \", (void *)dict);\n//  PDFIO_DEBUG_DICT(dict);\n//  PDFIO_DEBUG(\"\\n\");\n#endif // DEBUG\n\n  return (true);\n}", "target": 1, "idx": 10606}
{"commit_id": "feaa4e7f7399c51ee6f52deb84dc3f795b4035d6", "project": "radareorg/radare2", "func": "static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {\n\tRBuffer *fbuf = r_buf_ref (buf);\n\tstruct MACH0_(opts_t) opts;\n\tMACH0_(opts_set_default) (&opts, bf);\n\tstruct MACH0_(obj_t) *main_mach0 = MACH0_(new_buf) (fbuf, &opts);\n\tif (!main_mach0) {\n\t\treturn false;\n\t}\n\n\tRRebaseInfo *rebase_info = r_rebase_info_new_from_mach0 (fbuf, main_mach0);\n\tRKernelCacheObj *obj = NULL;\n\n\tRPrelinkRange *prelink_range = get_prelink_info_range_from_mach0 (main_mach0);\n\tif (!prelink_range) {\n\t\tgoto beach;\n\t}\n\n\tobj = R_NEW0 (RKernelCacheObj);\n\tif (!obj) {\n\t\tR_FREE (prelink_range);\n\t\tgoto beach;\n\t}\n\n\tRCFValueDict *prelink_info = NULL;\n\tif (main_mach0->hdr.filetype != MH_FILESET && prelink_range->range.size) {\n\t\tprelink_info = r_cf_value_dict_parse (fbuf, prelink_range->range.offset,\n\t\t\t\tprelink_range->range.size, R_CF_OPTION_SKIP_NSDATA);\n\t\tif (!prelink_info) {\n\t\t\tR_FREE (prelink_range);\n\t\t\tR_FREE (obj);\n\t\t\tgoto beach;\n\t\t}\n\t}\n\n\tif (!pending_bin_files) {\n\t\tpending_bin_files = r_list_new ();\n\t\tif (!pending_bin_files) {\n\t\t\tR_FREE (prelink_range);\n\t\t\tR_FREE (obj);\n\t\t\tR_FREE (prelink_info);\n\t\t\tgoto beach;\n\t\t}\n\t}\n\n\tobj->mach0 = main_mach0;\n\tobj->rebase_info = rebase_info;\n\tobj->prelink_info = prelink_info;\n\tobj->cache_buf = fbuf;\n\tobj->pa2va_exec = prelink_range->pa2va_exec;\n\tobj->pa2va_data = prelink_range->pa2va_data;\n\n\tR_FREE (prelink_range);\n\n\t*bin_obj = obj;\n\n\tr_list_push (pending_bin_files, bf);\n\n\tif (rebase_info || main_mach0->chained_starts) {\n\t\tRIO *io = bf->rbin->iob.io;\n\t\tswizzle_io_read (obj, io);\n\t}\n\n\treturn true;\n\nbeach:\n\tr_buf_free (fbuf);\n\tif (obj) {\n\t\tobj->cache_buf = NULL;\n\t}\n\tMACH0_(mach0_free) (main_mach0);\n\treturn false;\n}", "target": 1, "idx": 10607}
{"commit_id": "726c2768805c8c95e8ad8e5f09eddc5b16570365", "project": "libming", "func": "void\ndcinit()\n{\n\tstrsize = 1; // We start with empty string, i.e. \\0\n\tstrmaxsize=DCSTRSIZE;\n\tdcstr=calloc(DCSTRSIZE,1);\n\tdcptr=dcstr;\n}", "target": 1, "idx": 10608}
{"commit_id": "ded89912156b1a47d940a0c954c43afbabd0c42c", "project": "torvalds/linux", "func": "static s32\nbrcmf_cfg80211_start_ap(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\tstruct cfg80211_ap_settings *settings)\n{\n\ts32 ie_offset;\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tconst struct brcmf_tlv *ssid_ie;\n\tconst struct brcmf_tlv *country_ie;\n\tstruct brcmf_ssid_le ssid_le;\n\ts32 err = -EPERM;\n\tconst struct brcmf_tlv *rsn_ie;\n\tconst struct brcmf_vs_tlv *wpa_ie;\n\tstruct brcmf_join_params join_params;\n\tenum nl80211_iftype dev_role;\n\tstruct brcmf_fil_bss_enable_le bss_enable;\n\tu16 chanspec = chandef_to_chanspec(&cfg->d11inf, &settings->chandef);\n\tbool mbss;\n\tint is_11d;\n\n\tbrcmf_dbg(TRACE, \"ctrlchn=%d, center=%d, bw=%d, beacon_interval=%d, dtim_period=%d,\\n\",\n\t\t  settings->chandef.chan->hw_value,\n\t\t  settings->chandef.center_freq1, settings->chandef.width,\n\t\t  settings->beacon_interval, settings->dtim_period);\n\tbrcmf_dbg(TRACE, \"ssid=%s(%zu), auth_type=%d, inactivity_timeout=%d\\n\",\n\t\t  settings->ssid, settings->ssid_len, settings->auth_type,\n\t\t  settings->inactivity_timeout);\n\tdev_role = ifp->vif->wdev.iftype;\n\tmbss = ifp->vif->mbss;\n\n\t/* store current 11d setting */\n\tbrcmf_fil_cmd_int_get(ifp, BRCMF_C_GET_REGULATORY, &ifp->vif->is_11d);\n\tcountry_ie = brcmf_parse_tlvs((u8 *)settings->beacon.tail,\n\t\t\t\t      settings->beacon.tail_len,\n\t\t\t\t      WLAN_EID_COUNTRY);\n\tis_11d = country_ie ? 1 : 0;\n\n\tmemset(&ssid_le, 0, sizeof(ssid_le));\n\tif (settings->ssid == NULL || settings->ssid_len == 0) {\n\t\tie_offset = DOT11_MGMT_HDR_LEN + DOT11_BCN_PRB_FIXED_LEN;\n\t\tssid_ie = brcmf_parse_tlvs(\n\t\t\t\t(u8 *)&settings->beacon.head[ie_offset],\n\t\t\t\tsettings->beacon.head_len - ie_offset,\n\t\t\t\tWLAN_EID_SSID);\n\t\tif (!ssid_ie || ssid_ie->len > IEEE80211_MAX_SSID_LEN)\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(ssid_le.SSID, ssid_ie->data, ssid_ie->len);\n\t\tssid_le.SSID_len = cpu_to_le32(ssid_ie->len);\n\t\tbrcmf_dbg(TRACE, \"SSID is (%s) in Head\\n\", ssid_le.SSID);\n\t} else {\n\t\tmemcpy(ssid_le.SSID, settings->ssid, settings->ssid_len);\n\t\tssid_le.SSID_len = cpu_to_le32((u32)settings->ssid_len);\n\t}\n\n\tif (!mbss) {\n\t\tbrcmf_set_mpc(ifp, 0);\n\t\tbrcmf_configure_arp_nd_offload(ifp, false);\n\t}\n\n\t/* find the RSN_IE */\n\trsn_ie = brcmf_parse_tlvs((u8 *)settings->beacon.tail,\n\t\t\t\t  settings->beacon.tail_len, WLAN_EID_RSN);\n\n\t/* find the WPA_IE */\n\twpa_ie = brcmf_find_wpaie((u8 *)settings->beacon.tail,\n\t\t\t\t  settings->beacon.tail_len);\n\n\tif ((wpa_ie != NULL || rsn_ie != NULL)) {\n\t\tbrcmf_dbg(TRACE, \"WPA(2) IE is found\\n\");\n\t\tif (wpa_ie != NULL) {\n\t\t\t/* WPA IE */\n\t\t\terr = brcmf_configure_wpaie(ifp, wpa_ie, false);\n\t\t\tif (err < 0)\n\t\t\t\tgoto exit;\n\t\t} else {\n\t\t\tstruct brcmf_vs_tlv *tmp_ie;\n\n\t\t\ttmp_ie = (struct brcmf_vs_tlv *)rsn_ie;\n\n\t\t\t/* RSN IE */\n\t\t\terr = brcmf_configure_wpaie(ifp, tmp_ie, true);\n\t\t\tif (err < 0)\n\t\t\t\tgoto exit;\n\t\t}\n\t} else {\n\t\tbrcmf_dbg(TRACE, \"No WPA(2) IEs found\\n\");\n\t\tbrcmf_configure_opensecurity(ifp);\n\t}\n\n\tbrcmf_config_ap_mgmt_ie(ifp->vif, &settings->beacon);\n\n\t/* Parameters shared by all radio interfaces */\n\tif (!mbss) {\n\t\tif (is_11d != ifp->vif->is_11d) {\n\t\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_REGULATORY,\n\t\t\t\t\t\t    is_11d);\n\t\t\tif (err < 0) {\n\t\t\t\tbrcmf_err(\"Regulatory Set Error, %d\\n\", err);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tif (settings->beacon_interval) {\n\t\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_BCNPRD,\n\t\t\t\t\t\t    settings->beacon_interval);\n\t\t\tif (err < 0) {\n\t\t\t\tbrcmf_err(\"Beacon Interval Set Error, %d\\n\",\n\t\t\t\t\t  err);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tif (settings->dtim_period) {\n\t\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_DTIMPRD,\n\t\t\t\t\t\t    settings->dtim_period);\n\t\t\tif (err < 0) {\n\t\t\t\tbrcmf_err(\"DTIM Interval Set Error, %d\\n\", err);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\n\t\tif ((dev_role == NL80211_IFTYPE_AP) &&\n\t\t    ((ifp->ifidx == 0) ||\n\t\t     !brcmf_feat_is_enabled(ifp, BRCMF_FEAT_RSDB))) {\n\t\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_DOWN, 1);\n\t\t\tif (err < 0) {\n\t\t\t\tbrcmf_err(\"BRCMF_C_DOWN error %d\\n\", err);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tbrcmf_fil_iovar_int_set(ifp, \"apsta\", 0);\n\t\t}\n\n\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_INFRA, 1);\n\t\tif (err < 0) {\n\t\t\tbrcmf_err(\"SET INFRA error %d\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\t} else if (WARN_ON(is_11d != ifp->vif->is_11d)) {\n\t\t/* Multiple-BSS should use same 11d configuration */\n\t\terr = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\t/* Interface specific setup */\n\tif (dev_role == NL80211_IFTYPE_AP) {\n\t\tif ((brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MBSS)) && (!mbss))\n\t\t\tbrcmf_fil_iovar_int_set(ifp, \"mbss\", 1);\n\n\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_AP, 1);\n\t\tif (err < 0) {\n\t\t\tbrcmf_err(\"setting AP mode failed %d\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\t\tif (!mbss) {\n\t\t\t/* Firmware 10.x requires setting channel after enabling\n\t\t\t * AP and before bringing interface up.\n\t\t\t */\n\t\t\terr = brcmf_fil_iovar_int_set(ifp, \"chanspec\", chanspec);\n\t\t\tif (err < 0) {\n\t\t\t\tbrcmf_err(\"Set Channel failed: chspec=%d, %d\\n\",\n\t\t\t\t\t  chanspec, err);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_UP, 1);\n\t\tif (err < 0) {\n\t\t\tbrcmf_err(\"BRCMF_C_UP error (%d)\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\t\t/* On DOWN the firmware removes the WEP keys, reconfigure\n\t\t * them if they were set.\n\t\t */\n\t\tbrcmf_cfg80211_reconfigure_wep(ifp);\n\n\t\tmemset(&join_params, 0, sizeof(join_params));\n\t\t/* join parameters starts with ssid */\n\t\tmemcpy(&join_params.ssid_le, &ssid_le, sizeof(ssid_le));\n\t\t/* create softap */\n\t\terr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_SSID,\n\t\t\t\t\t     &join_params, sizeof(join_params));\n\t\tif (err < 0) {\n\t\t\tbrcmf_err(\"SET SSID error (%d)\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (settings->hidden_ssid) {\n\t\t\terr = brcmf_fil_iovar_int_set(ifp, \"closednet\", 1);\n\t\t\tif (err) {\n\t\t\t\tbrcmf_err(\"closednet error (%d)\\n\", err);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\n\t\tbrcmf_dbg(TRACE, \"AP mode configuration complete\\n\");\n\t} else if (dev_role == NL80211_IFTYPE_P2P_GO) {\n\t\terr = brcmf_fil_iovar_int_set(ifp, \"chanspec\", chanspec);\n\t\tif (err < 0) {\n\t\t\tbrcmf_err(\"Set Channel failed: chspec=%d, %d\\n\",\n\t\t\t\t  chanspec, err);\n\t\t\tgoto exit;\n\t\t}\n\t\terr = brcmf_fil_bsscfg_data_set(ifp, \"ssid\", &ssid_le,\n\t\t\t\t\t\tsizeof(ssid_le));\n\t\tif (err < 0) {\n\t\t\tbrcmf_err(\"setting ssid failed %d\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\t\tbss_enable.bsscfgidx = cpu_to_le32(ifp->bsscfgidx);\n\t\tbss_enable.enable = cpu_to_le32(1);\n\t\terr = brcmf_fil_iovar_data_set(ifp, \"bss\", &bss_enable,\n\t\t\t\t\t       sizeof(bss_enable));\n\t\tif (err < 0) {\n\t\t\tbrcmf_err(\"bss_enable config failed %d\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tbrcmf_dbg(TRACE, \"GO mode configuration complete\\n\");\n\t} else {\n\t\tWARN_ON(1);\n\t}\n\n\tset_bit(BRCMF_VIF_STATUS_AP_CREATED, &ifp->vif->sme_state);\n\tbrcmf_net_setcarrier(ifp, true);\n\nexit:\n\tif ((err) && (!mbss)) {\n\t\tbrcmf_set_mpc(ifp, 1);\n\t\tbrcmf_configure_arp_nd_offload(ifp, true);\n\t}\n\treturn err;\n}", "target": 1, "idx": 10609}
{"commit_id": "697af434fbeb2e3ba2ba9687cd283ed1a2734fa5", "project": "redis", "func": "void initServerConfig() {\n    server.port = REDIS_SERVERPORT;\n    server.bindaddr = NULL;\n    server.unixsocket = NULL;\n    server.ipfd = -1;\n    server.sofd = -1;\n    server.dbnum = REDIS_DEFAULT_DBNUM;\n    server.verbosity = REDIS_VERBOSE;\n    server.maxidletime = REDIS_MAXIDLETIME;\n    server.saveparams = NULL;\n    server.loading = 0;\n    server.logfile = NULL; /* NULL = log on standard output */\n    server.syslog_enabled = 0;\n    server.syslog_ident = zstrdup(\"redis\");\n    server.syslog_facility = LOG_LOCAL0;\n    server.glueoutputbuf = 1;\n    server.daemonize = 0;\n    server.appendonly = 0;\n    server.appendfsync = APPENDFSYNC_EVERYSEC;\n    server.no_appendfsync_on_rewrite = 0;\n    server.lastfsync = time(NULL);\n    server.appendfd = -1;\n    server.appendseldb = -1; /* Make sure the first time will not match */\n    server.pidfile = zstrdup(\"/var/run/redis.pid\");\n    server.dbfilename = zstrdup(\"dump.rdb\");\n    server.appendfilename = zstrdup(\"appendonly.aof\");\n    server.requirepass = NULL;\n    server.rdbcompression = 1;\n    server.activerehashing = 1;\n    server.maxclients = 0;\n    server.bpop_blocked_clients = 0;\n    server.maxmemory = 0;\n    server.maxmemory_policy = REDIS_MAXMEMORY_VOLATILE_LRU;\n    server.maxmemory_samples = 3;\n    server.ds_enabled = 0;\n    server.ds_path = zstrdup(\"/tmp/redis.ds\");\n    server.cache_max_memory = 64LL*1024*1024; /* 64 MB of RAM */\n    server.cache_blocked_clients = 0;\n    server.hash_max_zipmap_entries = REDIS_HASH_MAX_ZIPMAP_ENTRIES;\n    server.hash_max_zipmap_value = REDIS_HASH_MAX_ZIPMAP_VALUE;\n    server.list_max_ziplist_entries = REDIS_LIST_MAX_ZIPLIST_ENTRIES;\n    server.list_max_ziplist_value = REDIS_LIST_MAX_ZIPLIST_VALUE;\n    server.set_max_intset_entries = REDIS_SET_MAX_INTSET_ENTRIES;\n    server.shutdown_asap = 0;\n\n    updateLRUClock();\n    resetServerSaveParams();\n\n    appendServerSaveParams(60*60,1);  /* save after 1 hour and 1 change */\n    appendServerSaveParams(300,100);  /* save after 5 minutes and 100 changes */\n    appendServerSaveParams(60,10000); /* save after 1 minute and 10000 changes */\n    /* Replication related */\n    server.isslave = 0;\n    server.masterauth = NULL;\n    server.masterhost = NULL;\n    server.masterport = 6379;\n    server.master = NULL;\n    server.replstate = REDIS_REPL_NONE;\n    server.repl_serve_stale_data = 1;\n\n    /* Double constants initialization */\n    R_Zero = 0.0;\n    R_PosInf = 1.0/R_Zero;\n    R_NegInf = -1.0/R_Zero;\n    R_Nan = R_Zero/R_Zero;\n\n    /* Command table -- we intiialize it here as it is part of the\n     * initial configuration, since command names may be changed via\n     * redis.conf using the rename-command directive. */\n    server.commands = dictCreate(&commandTableDictType,NULL);\n    populateCommandTable();\n    server.delCommand = lookupCommandByCString(\"del\");\n    server.multiCommand = lookupCommandByCString(\"multi\");\n}", "target": 1, "idx": 10610}
{"commit_id": "18c020124ff1b2441f714da2017f63dba50720ba", "project": "TigerVNC/tigervnc", "func": "void ModifiablePixelBuffer::fillRect(const Rect& r, const void* pix)\n{\n  int stride;\n  U8 *buf;\n  int w, h, b;\n  Rect drect;\n\n  drect = r;\n  if (!drect.enclosed_by(getRect())) {\n    vlog.error(\"Destination rect %dx%d at %d,%d exceeds framebuffer %dx%d\",\n               drect.width(), drect.height(), drect.tl.x, drect.tl.y, width_, height_);\n    drect = drect.intersect(getRect());\n  }\n\n  if (drect.is_empty())\n    return;\n\n  w = drect.width();\n  h = drect.height();\n  b = format.bpp/8;\n\n  if (h == 0)\n    return;\n\n  buf = getBufferRW(drect, &stride);\n\n  if (b == 1) {\n    while (h--) {\n      memset(buf, *(const U8*)pix, w);\n      buf += stride * b;\n    }\n  } else {\n    U8 *start;\n    int w1;\n\n    start = buf;\n\n    w1 = w;\n    while (w1--) {\n      memcpy(buf, pix, b);\n      buf += b;\n    }\n    buf += (stride - w) * b;\n    h--;\n\n    while (h--) {\n      memcpy(buf, start, w * b);\n      buf += stride * b;\n    }\n  }\n\n  commitBufferRW(drect);\n}", "target": 3, "idx": 10611}
{"commit_id": "d8c9138bf240975848b1c54db648ec4cd516a48f", "project": "GNOME/gvfs", "func": "static gboolean\nhandle_get_connection (GVfsDBusDaemon *object,\n                       GDBusMethodInvocation *invocation,\n                       gpointer user_data)\n{\n  GVfsDaemon *daemon = G_VFS_DAEMON (user_data);\n  GDBusServer *server;\n  GError *error;\n  gchar *address1;\n  NewConnectionData *data;\n  char *socket_dir;\n  gchar *guid;\n  \n  generate_address (&address1, &socket_dir);\n\n  data = g_new (NewConnectionData, 1);\n  data->daemon = daemon;\n  data->socket_dir = socket_dir;\n  data->conn = NULL;\n\n  guid = g_dbus_generate_guid ();\n  error = NULL;\n  server = g_dbus_server_new_sync (address1,\n                                   G_DBUS_SERVER_FLAGS_NONE,\n                                   guid,\n                                   daemon->auth_observer,\n                                   NULL, /* GCancellable */\n                                   &error);\n  g_free (guid);\n\n  if (server == NULL)\n    {\n      g_dbus_method_invocation_return_gerror (invocation, error);\n      g_printerr (\"daemon: Error creating server at address %s: %s\\n\", address1, error->message);\n      g_error_free (error);\n      goto error_out;\n    }\n\n  g_dbus_server_start (server);\n  data->server = server;\n\n  g_signal_connect (server, \"new-connection\", G_CALLBACK (daemon_new_connection_func), data);\n  \n  gvfs_dbus_daemon_complete_get_connection (object,\n                                            invocation,\n                                            address1,\n                                            \"\");\n\n  g_free (address1);\n  return TRUE;\n\n error_out:\n  new_connection_data_free (data);\n  g_free (address1);\n  return TRUE;\n}", "target": 2, "idx": 10612}
{"commit_id": "8ee24e7949a203d234489f9da2c5bf45a7d5157d", "project": "tensorflow", "func": "inline int MatchingDim(const RuntimeShape& shape1, int index1,\n                       const RuntimeShape& shape2, int index2) {\n  TFLITE_DCHECK_EQ(shape1.Dims(index1), shape2.Dims(index2));\n  return std::min(shape1.Dims(index1), shape2.Dims(index2));\n}", "target": 2, "idx": 10613}
{"commit_id": "18f91b950e22c2a342a4fbc55e9ddf7534a707d2", "project": "xorg/xserver", "func": "int\nProcXkbGetKbdByName(ClientPtr client)\n{\n    DeviceIntPtr dev;\n    DeviceIntPtr tmpd;\n    DeviceIntPtr master;\n    xkbGetKbdByNameReply rep = { 0 };\n    xkbGetMapReply mrep = { 0 };\n    xkbGetCompatMapReply crep = { 0 };\n    xkbGetIndicatorMapReply irep = { 0 };\n    xkbGetNamesReply nrep = { 0 };\n    xkbGetGeometryReply grep = { 0 };\n    XkbComponentNamesRec names = { 0 };\n    XkbDescPtr xkb, new;\n    XkbEventCauseRec cause;\n    unsigned char *str;\n    char mapFile[PATH_MAX];\n    unsigned len;\n    unsigned fwant, fneed, reported;\n    int status;\n    Bool geom_changed;\n    XkbSrvLedInfoPtr old_sli;\n    XkbSrvLedInfoPtr sli;\n    Mask access_mode = DixGetAttrAccess | DixManageAccess;\n\n    REQUEST(xkbGetKbdByNameReq);\n    REQUEST_AT_LEAST_SIZE(xkbGetKbdByNameReq);\n\n    if (!(client->xkbClientFlags & _XkbClientInitialized))\n        return BadAccess;\n\n    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, access_mode);\n    master = GetMaster(dev, MASTER_KEYBOARD);\n\n    xkb = dev->key->xkbInfo->desc;\n    status = Success;\n    str = (unsigned char *) &stuff[1];\n    {\n        char *keymap = GetComponentSpec(&str, TRUE, &status);  /* keymap, unsupported */\n        if (keymap) {\n            free(keymap);\n            return BadMatch;\n        }\n    }\n    names.keycodes = GetComponentSpec(&str, TRUE, &status);\n    names.types = GetComponentSpec(&str, TRUE, &status);\n    names.compat = GetComponentSpec(&str, TRUE, &status);\n    names.symbols = GetComponentSpec(&str, TRUE, &status);\n    names.geometry = GetComponentSpec(&str, TRUE, &status);\n    if (status == Success) {\n        len = str - ((unsigned char *) stuff);\n        if ((XkbPaddedSize(len) / 4) != stuff->length)\n            status = BadLength;\n    }\n\n    if (status != Success) {\n        free(names.keycodes);\n        free(names.types);\n        free(names.compat);\n        free(names.symbols);\n        free(names.geometry);\n        return status;\n    }\n\n    CHK_MASK_LEGAL(0x01, stuff->want, XkbGBN_AllComponentsMask);\n    CHK_MASK_LEGAL(0x02, stuff->need, XkbGBN_AllComponentsMask);\n\n    if (stuff->load)\n        fwant = XkbGBN_AllComponentsMask;\n    else\n        fwant = stuff->want | stuff->need;\n    if ((!names.compat) &&\n        (fwant & (XkbGBN_CompatMapMask | XkbGBN_IndicatorMapMask))) {\n        names.compat = Xstrdup(\"%\");\n    }\n    if ((!names.types) && (fwant & (XkbGBN_TypesMask))) {\n        names.types = Xstrdup(\"%\");\n    }\n    if ((!names.symbols) && (fwant & XkbGBN_SymbolsMask)) {\n        names.symbols = Xstrdup(\"%\");\n    }\n    geom_changed = ((names.geometry != NULL) &&\n                    (strcmp(names.geometry, \"%\") != 0));\n    if ((!names.geometry) && (fwant & XkbGBN_GeometryMask)) {\n        names.geometry = Xstrdup(\"%\");\n        geom_changed = FALSE;\n    }\n\n    memset(mapFile, 0, PATH_MAX);\n    rep.type = X_Reply;\n    rep.deviceID = dev->id;\n    rep.sequenceNumber = client->sequence;\n    rep.length = 0;\n    rep.minKeyCode = xkb->min_key_code;\n    rep.maxKeyCode = xkb->max_key_code;\n    rep.loaded = FALSE;\n    fwant =\n        XkbConvertGetByNameComponents(TRUE, stuff->want) | XkmVirtualModsMask;\n    fneed = XkbConvertGetByNameComponents(TRUE, stuff->need);\n    rep.reported = XkbConvertGetByNameComponents(FALSE, fwant | fneed);\n    if (stuff->load) {\n        fneed |= XkmKeymapRequired;\n        fwant |= XkmKeymapLegal;\n    }\n    if ((fwant | fneed) & XkmSymbolsMask) {\n        fneed |= XkmKeyNamesIndex | XkmTypesIndex;\n        fwant |= XkmIndicatorsIndex;\n    }\n\n    /* We pass dev in here so we can get the old names out if needed. */\n    rep.found = XkbDDXLoadKeymapByNames(dev, &names, fwant, fneed, &new,\n                                        mapFile, PATH_MAX);\n    rep.newKeyboard = FALSE;\n    rep.pad1 = rep.pad2 = rep.pad3 = rep.pad4 = 0;\n\n    stuff->want |= stuff->need;\n    if (new == NULL)\n        rep.reported = 0;\n    else {\n        if (stuff->load)\n            rep.loaded = TRUE;\n        if (stuff->load ||\n            ((rep.reported & XkbGBN_SymbolsMask) && (new->compat))) {\n            XkbChangesRec changes;\n\n            memset(&changes, 0, sizeof(changes));\n            XkbUpdateDescActions(new,\n                                 new->min_key_code, XkbNumKeys(new), &changes);\n        }\n\n        if (new->map == NULL)\n            rep.reported &= ~(XkbGBN_SymbolsMask | XkbGBN_TypesMask);\n        else if (rep.reported & (XkbGBN_SymbolsMask | XkbGBN_TypesMask)) {\n            mrep.type = X_Reply;\n            mrep.deviceID = dev->id;\n            mrep.sequenceNumber = client->sequence;\n            mrep.length =\n                ((SIZEOF(xkbGetMapReply) - SIZEOF(xGenericReply)) >> 2);\n            mrep.minKeyCode = new->min_key_code;\n            mrep.maxKeyCode = new->max_key_code;\n            mrep.present = 0;\n            mrep.totalSyms = mrep.totalActs =\n                mrep.totalKeyBehaviors = mrep.totalKeyExplicit =\n                mrep.totalModMapKeys = mrep.totalVModMapKeys = 0;\n            if (rep.reported & (XkbGBN_TypesMask | XkbGBN_ClientSymbolsMask)) {\n                mrep.present |= XkbKeyTypesMask;\n                mrep.firstType = 0;\n                mrep.nTypes = mrep.totalTypes = new->map->num_types;\n            }\n            else {\n                mrep.firstType = mrep.nTypes = 0;\n                mrep.totalTypes = 0;\n            }\n            if (rep.reported & XkbGBN_ClientSymbolsMask) {\n                mrep.present |= (XkbKeySymsMask | XkbModifierMapMask);\n                mrep.firstKeySym = mrep.firstModMapKey = new->min_key_code;\n                mrep.nKeySyms = mrep.nModMapKeys = XkbNumKeys(new);\n            }\n            else {\n                mrep.firstKeySym = mrep.firstModMapKey = 0;\n                mrep.nKeySyms = mrep.nModMapKeys = 0;\n            }\n            if (rep.reported & XkbGBN_ServerSymbolsMask) {\n                mrep.present |= XkbAllServerInfoMask;\n                mrep.virtualMods = ~0;\n                mrep.firstKeyAct = mrep.firstKeyBehavior =\n                    mrep.firstKeyExplicit = new->min_key_code;\n                mrep.nKeyActs = mrep.nKeyBehaviors =\n                    mrep.nKeyExplicit = XkbNumKeys(new);\n                mrep.firstVModMapKey = new->min_key_code;\n                mrep.nVModMapKeys = XkbNumKeys(new);\n            }\n            else {\n                mrep.virtualMods = 0;\n                mrep.firstKeyAct = mrep.firstKeyBehavior =\n                    mrep.firstKeyExplicit = 0;\n                mrep.nKeyActs = mrep.nKeyBehaviors = mrep.nKeyExplicit = 0;\n            }\n            XkbComputeGetMapReplySize(new, &mrep);\n            rep.length += SIZEOF(xGenericReply) / 4 + mrep.length;\n        }\n        if (new->compat == NULL)\n            rep.reported &= ~XkbGBN_CompatMapMask;\n        else if (rep.reported & XkbGBN_CompatMapMask) {\n            crep.type = X_Reply;\n            crep.deviceID = dev->id;\n            crep.sequenceNumber = client->sequence;\n            crep.length = 0;\n            crep.groups = XkbAllGroupsMask;\n            crep.firstSI = 0;\n            crep.nSI = crep.nTotalSI = new->compat->num_si;\n            XkbComputeGetCompatMapReplySize(new->compat, &crep);\n            rep.length += SIZEOF(xGenericReply) / 4 + crep.length;\n        }\n        if (new->indicators == NULL)\n            rep.reported &= ~XkbGBN_IndicatorMapMask;\n        else if (rep.reported & XkbGBN_IndicatorMapMask) {\n            irep.type = X_Reply;\n            irep.deviceID = dev->id;\n            irep.sequenceNumber = client->sequence;\n            irep.length = 0;\n            irep.which = XkbAllIndicatorsMask;\n            XkbComputeGetIndicatorMapReplySize(new->indicators, &irep);\n            rep.length += SIZEOF(xGenericReply) / 4 + irep.length;\n        }\n        if (new->names == NULL)\n            rep.reported &= ~(XkbGBN_OtherNamesMask | XkbGBN_KeyNamesMask);\n        else if (rep.reported & (XkbGBN_OtherNamesMask | XkbGBN_KeyNamesMask)) {\n            nrep.type = X_Reply;\n            nrep.deviceID = dev->id;\n            nrep.sequenceNumber = client->sequence;\n            nrep.length = 0;\n            nrep.minKeyCode = new->min_key_code;\n            nrep.maxKeyCode = new->max_key_code;\n            if (rep.reported & XkbGBN_OtherNamesMask) {\n                nrep.which = XkbAllNamesMask;\n                if (new->map != NULL)\n                    nrep.nTypes = new->map->num_types;\n                else\n                    nrep.nTypes = 0;\n                nrep.nKTLevels = 0;\n                nrep.groupNames = XkbAllGroupsMask;\n                nrep.virtualMods = XkbAllVirtualModsMask;\n                nrep.indicators = XkbAllIndicatorsMask;\n                nrep.nRadioGroups = new->names->num_rg;\n            }\n            else {\n                nrep.which = 0;\n                nrep.nTypes = 0;\n                nrep.nKTLevels = 0;\n                nrep.groupNames = 0;\n                nrep.virtualMods = 0;\n                nrep.indicators = 0;\n                nrep.nRadioGroups = 0;\n            }\n            if (rep.reported & XkbGBN_KeyNamesMask) {\n                nrep.which |= XkbKeyNamesMask;\n                nrep.firstKey = new->min_key_code;\n                nrep.nKeys = XkbNumKeys(new);\n                nrep.nKeyAliases = new->names->num_key_aliases;\n                if (nrep.nKeyAliases)\n                    nrep.which |= XkbKeyAliasesMask;\n            }\n            else {\n                nrep.which &= ~(XkbKeyNamesMask | XkbKeyAliasesMask);\n                nrep.firstKey = nrep.nKeys = 0;\n                nrep.nKeyAliases = 0;\n            }\n            XkbComputeGetNamesReplySize(new, &nrep);\n            rep.length += SIZEOF(xGenericReply) / 4 + nrep.length;\n        }\n        if (new->geom == NULL)\n            rep.reported &= ~XkbGBN_GeometryMask;\n        else if (rep.reported & XkbGBN_GeometryMask) {\n            grep.type = X_Reply;\n            grep.deviceID = dev->id;\n            grep.sequenceNumber = client->sequence;\n            grep.length = 0;\n            grep.found = TRUE;\n            grep.pad = 0;\n            grep.widthMM = grep.heightMM = 0;\n            grep.nProperties = grep.nColors = grep.nShapes = 0;\n            grep.nSections = grep.nDoodads = 0;\n            grep.baseColorNdx = grep.labelColorNdx = 0;\n            XkbComputeGetGeometryReplySize(new->geom, &grep, None);\n            rep.length += SIZEOF(xGenericReply) / 4 + grep.length;\n        }\n    }\n\n    reported = rep.reported;\n    if (client->swapped) {\n        swaps(&rep.sequenceNumber);\n        swapl(&rep.length);\n        swaps(&rep.found);\n        swaps(&rep.reported);\n    }\n    WriteToClient(client, SIZEOF(xkbGetKbdByNameReply), &rep);\n    if (reported & (XkbGBN_SymbolsMask | XkbGBN_TypesMask))\n        XkbSendMap(client, new, &mrep);\n    if (reported & XkbGBN_CompatMapMask)\n        XkbSendCompatMap(client, new->compat, &crep);\n    if (reported & XkbGBN_IndicatorMapMask)\n        XkbSendIndicatorMap(client, new->indicators, &irep);\n    if (reported & (XkbGBN_KeyNamesMask | XkbGBN_OtherNamesMask))\n        XkbSendNames(client, new, &nrep);\n    if (reported & XkbGBN_GeometryMask)\n        XkbSendGeometry(client, new->geom, &grep, FALSE);\n    if (rep.loaded) {\n        XkbDescPtr old_xkb;\n        xkbNewKeyboardNotify nkn;\n\n        old_xkb = xkb;\n        xkb = new;\n        dev->key->xkbInfo->desc = xkb;\n        new = old_xkb;          /* so it'll get freed automatically */\n\n        XkbCopyControls(xkb, old_xkb);\n\n        nkn.deviceID = nkn.oldDeviceID = dev->id;\n        nkn.minKeyCode = new->min_key_code;\n        nkn.maxKeyCode = new->max_key_code;\n        nkn.oldMinKeyCode = xkb->min_key_code;\n        nkn.oldMaxKeyCode = xkb->max_key_code;\n        nkn.requestMajor = XkbReqCode;\n        nkn.requestMinor = X_kbGetKbdByName;\n        nkn.changed = XkbNKN_KeycodesMask;\n        if (geom_changed)\n            nkn.changed |= XkbNKN_GeometryMask;\n        XkbSendNewKeyboardNotify(dev, &nkn);\n\n        /* Update the map and LED info on the device itself, as well as\n         * any slaves if it's an MD, or its MD if it's an SD and was the\n         * last device used on that MD. */\n        for (tmpd = inputInfo.devices; tmpd; tmpd = tmpd->next) {\n            if (tmpd != dev && GetMaster(tmpd, MASTER_KEYBOARD) != dev &&\n                (tmpd != master || dev != master->lastSlave))\n                continue;\n\n            if (tmpd != dev)\n                XkbDeviceApplyKeymap(tmpd, xkb);\n\n            if (tmpd->kbdfeed && tmpd->kbdfeed->xkb_sli) {\n                old_sli = tmpd->kbdfeed->xkb_sli;\n                tmpd->kbdfeed->xkb_sli = NULL;\n                sli = XkbAllocSrvLedInfo(tmpd, tmpd->kbdfeed, NULL, 0);\n                if (sli) {\n                    sli->explicitState = old_sli->explicitState;\n                    sli->effectiveState = old_sli->effectiveState;\n                }\n                tmpd->kbdfeed->xkb_sli = sli;\n                XkbFreeSrvLedInfo(old_sli);\n            }\n        }\n    }\n    if ((new != NULL) && (new != xkb)) {\n        XkbFreeKeyboard(new, XkbAllComponentsMask, TRUE);\n        new = NULL;\n    }\n    XkbFreeComponentNames(&names, FALSE);\n    XkbSetCauseXkbReq(&cause, X_kbGetKbdByName, client);\n    XkbUpdateAllDeviceIndicators(NULL, &cause);\n\n    return Success;\n}", "target": 1, "idx": 10614}
{"commit_id": "fae7d5be8bb8b7a5b7005c4f3b812a47661a721e", "project": "xen-project/xen", "func": "int steal_page(\n    struct domain *d, struct page_info *page, unsigned int memflags)\n{\n    unsigned long x, y;\n    bool_t drop_dom_ref = 0;\n    const struct domain *owner = dom_xen;\n\n    if ( paging_mode_external(d) )\n        return -1;\n\n    spin_lock(&d->page_alloc_lock);\n\n    if ( is_xen_heap_page(page) || ((owner = page_get_owner(page)) != d) )\n        goto fail;\n\n    /*\n     * We require there is just one reference (PGC_allocated). We temporarily\n     * drop this reference now so that we can safely swizzle the owner.\n     */\n    y = page->count_info;\n    do {\n        x = y;\n        if ( (x & (PGC_count_mask|PGC_allocated)) != (1 | PGC_allocated) )\n            goto fail;\n        y = cmpxchg(&page->count_info, x, x & ~PGC_count_mask);\n    } while ( y != x );\n\n    /*\n     * With the sole reference dropped temporarily, no-one can update type\n     * information. Type count also needs to be zero in this case, but e.g.\n     * PGT_seg_desc_page may still have PGT_validated set, which we need to\n     * clear before transferring ownership (as validation criteria vary\n     * depending on domain type).\n     */\n    BUG_ON(page->u.inuse.type_info & (PGT_count_mask | PGT_locked |\n                                      PGT_pinned));\n    page->u.inuse.type_info = 0;\n\n    /* Swizzle the owner then reinstate the PGC_allocated reference. */\n    page_set_owner(page, NULL);\n    y = page->count_info;\n    do {\n        x = y;\n        BUG_ON((x & (PGC_count_mask|PGC_allocated)) != PGC_allocated);\n    } while ( (y = cmpxchg(&page->count_info, x, x | 1)) != x );\n\n    /* Unlink from original owner. */\n    if ( !(memflags & MEMF_no_refcount) && !domain_adjust_tot_pages(d, -1) )\n        drop_dom_ref = 1;\n    page_list_del(page, &d->page_list);\n\n    spin_unlock(&d->page_alloc_lock);\n    if ( unlikely(drop_dom_ref) )\n        put_domain(d);\n    return 0;\n\n fail:\n    spin_unlock(&d->page_alloc_lock);\n    gdprintk(XENLOG_WARNING, \"Bad steal mfn %\" PRI_mfn\n             \" from d%d (owner d%d) caf=%08lx taf=%\" PRtype_info \"\\n\",\n             page_to_mfn(page), d->domain_id,\n             owner ? owner->domain_id : DOMID_INVALID,\n             page->count_info, page->u.inuse.type_info);\n    return -1;\n}", "target": 3, "idx": 10615}
{"commit_id": "2563c9c6b8670400c48e562034b321a7cf3d9a85", "project": "qemu", "func": "static ssize_t drop_sync(QIOChannel *ioc, size_t size)\n{\n    ssize_t ret = 0;\n    char small[1024];\n    char *buffer;\n\n    buffer = sizeof(small) >= size ? small : g_malloc(MIN(65536, size));\n    while (size > 0) {\n        ssize_t count = read_sync(ioc, buffer, MIN(65536, size));\n\n        if (count <= 0) {\n            goto cleanup;\n        }\n        assert(count <= size);\n        size -= count;\n        ret += count;\n    }\n\n cleanup:\n    if (buffer != small) {\n        g_free(buffer);\n    }\n    return ret;\n}", "target": 1, "idx": 10616}
{"commit_id": "fba01dc76d6ea940ad7c8392e8f39f9647241d8e", "project": "CrowCpp/Crow", "func": "void clear()\n        {\n            req = crow::request();\n            header_field.clear();\n            header_value.clear();\n            header_building_state = 0;\n            qs_point = 0;\n            message_complete = false;\n            state = CROW_NEW_MESSAGE();\n        }", "target": 3, "idx": 10617}
{"commit_id": "d6b57f461b39fd1aa8c1b870f1b974aac3554955", "project": "tensorflow", "func": "bool L2NormalizeReduceAxis(Value sq_op, DenseElementsAttr axis) {\n  if (axis.getNumElements() == 0) {\n    return false;\n  }\n  if (sq_op.getType().cast<ShapedType>().getRank() - 1 ==\n          *axis.getValues<int>().begin() ||\n      *axis.getValues<int>().begin() == -1) {\n    return true;\n  }\n  if (sq_op.getType().cast<ShapedType>().getRank() != axis.getNumElements()) {\n    return false;\n  }\n  auto shape = sq_op.getType().cast<ShapedType>();\n  SmallVector<int, 4> elems{axis.getValues<int>().begin(),\n                            axis.getValues<int>().end()};\n  for (int i = 0; i < shape.getRank(); ++i) {\n    if (i != elems[i]) return false;\n  }\n  return true;\n}", "target": 2, "idx": 10618}
{"commit_id": "80fa26c74279fced8d778351cff19d1d8f44fe4e", "project": "GNUAspell/aspell", "func": "unsigned find_file(const StringList & sl, String & filename)\n  {\n    StringListEnumeration els = sl.elements_obj();\n    const char * dir;\n    String path;\n    while ( (dir = els.next()) != 0 ) \n    {\n      path = dir;\n      if (path.empty()) continue;\n      if (path.back() != '/') path += '/';\n      unsigned dir_len = path.size();\n      path += filename;\n      if (file_exists(path)) {\n        filename.swap(path);\n        return dir_len;\n      }\n    }\n    return 0;\n  }", "target": 3, "idx": 10619}
{"commit_id": "d8cc503575463ff3d81b22dad292665f2c88911e", "project": "pdfium", "func": "OPJ_BOOL opj_tcd_update_tile_data ( opj_tcd_t *p_tcd,\n                                    OPJ_BYTE * p_dest,\n                                    OPJ_UINT32 p_dest_length\n                                    )\n{\n        OPJ_UINT32 i,j,k,l_data_size = 0;\n        opj_image_comp_t * l_img_comp = 00;\n        opj_tcd_tilecomp_t * l_tilec = 00;\n        opj_tcd_resolution_t * l_res;\n        OPJ_UINT32 l_size_comp, l_remaining;\n        OPJ_UINT32 l_stride, l_width,l_height;\n\n        l_data_size = opj_tcd_get_decoded_tile_size(p_tcd);\n        if (l_data_size == (OPJ_UINT32)-1 || l_data_size > p_dest_length) {\n                return OPJ_FALSE;\n        }\n\n        l_tilec = p_tcd->tcd_image->tiles->comps;\n        l_img_comp = p_tcd->image->comps;\n\n        for (i=0;i<p_tcd->image->numcomps;++i) {\n                l_size_comp = l_img_comp->prec >> 3; /*(/ 8)*/\n                l_remaining = l_img_comp->prec & 7;  /* (%8) */\n                l_res = l_tilec->resolutions + l_img_comp->resno_decoded;\n                l_width = (OPJ_UINT32)(l_res->x1 - l_res->x0);\n                l_height = (OPJ_UINT32)(l_res->y1 - l_res->y0);\n                l_stride = (OPJ_UINT32)(l_tilec->x1 - l_tilec->x0) - l_width;\n\n                if (l_remaining) {\n                        ++l_size_comp;\n                }\n\n                if (l_size_comp == 3) {\n                        l_size_comp = 4;\n                }\n\n                switch (l_size_comp)\n                        {\n                        case 1:\n                                {\n                                        OPJ_CHAR * l_dest_ptr = (OPJ_CHAR *) p_dest;\n                                        const OPJ_INT32 * l_src_ptr = l_tilec->data;\n\n                                        if (l_img_comp->sgnd) {\n                                                for (j=0;j<l_height;++j) {\n                                                        for (k=0;k<l_width;++k) {\n                                                                *(l_dest_ptr++) = (OPJ_CHAR) (*(l_src_ptr++));\n                                                        }\n                                                        l_src_ptr += l_stride;\n                                                }\n                                        }\n                                        else {\n                                                for (j=0;j<l_height;++j) {\n                                                        for     (k=0;k<l_width;++k) {\n                                                                *(l_dest_ptr++) = (OPJ_CHAR) ((*(l_src_ptr++))&0xff);\n                                                        }\n                                                        l_src_ptr += l_stride;\n                                                }\n                                        }\n\n                                        p_dest = (OPJ_BYTE *)l_dest_ptr;\n                                }\n                                break;\n                        case 2:\n                                {\n                                        const OPJ_INT32 * l_src_ptr = l_tilec->data;\n                                        OPJ_INT16 * l_dest_ptr = (OPJ_INT16 *) p_dest;\n\n                                        if (l_img_comp->sgnd) {\n                                                for (j=0;j<l_height;++j) {\n                                                        for (k=0;k<l_width;++k) {\n                                                                *(l_dest_ptr++) = (OPJ_INT16) (*(l_src_ptr++));\n                                                        }\n                                                        l_src_ptr += l_stride;\n                                                }\n                                        }\n                                        else {\n                                                for (j=0;j<l_height;++j) {\n                                                        for (k=0;k<l_width;++k) {\n                                                                *(l_dest_ptr++) = (OPJ_INT16) ((*(l_src_ptr++))&0xffff);\n                                                        }\n                                                        l_src_ptr += l_stride;\n                                                }\n                                        }\n\n                                        p_dest = (OPJ_BYTE*) l_dest_ptr;\n                                }\n                                break;\n                        case 4:\n                                {\n                                        OPJ_INT32 * l_dest_ptr = (OPJ_INT32 *) p_dest;\n                                        OPJ_INT32 * l_src_ptr = l_tilec->data;\n\n                                        for (j=0;j<l_height;++j) {\n                                                for (k=0;k<l_width;++k) {\n                                                        *(l_dest_ptr++) = (*(l_src_ptr++));\n                                                }\n                                                l_src_ptr += l_stride;\n                                        }\n\n                                        p_dest = (OPJ_BYTE*) l_dest_ptr;\n                                }\n                                break;\n                }\n\n                ++l_img_comp;\n                ++l_tilec;\n        }\n\n        return OPJ_TRUE;\n}", "target": 2, "idx": 10620}
{"commit_id": "368ba06881c395f1c9a7ba22203cf8d78b4addc0", "project": "torvalds/linux", "func": "int ksmbd_conn_handler_loop(void *p)\n{\n\tstruct ksmbd_conn *conn = (struct ksmbd_conn *)p;\n\tstruct ksmbd_transport *t = conn->transport;\n\tunsigned int pdu_size, max_allowed_pdu_size;\n\tchar hdr_buf[4] = {0,};\n\tint size;\n\n\tmutex_init(&conn->srv_mutex);\n\t__module_get(THIS_MODULE);\n\n\tif (t->ops->prepare && t->ops->prepare(t))\n\t\tgoto out;\n\n\tconn->last_active = jiffies;\n\twhile (ksmbd_conn_alive(conn)) {\n\t\tif (try_to_freeze())\n\t\t\tcontinue;\n\n\t\tkvfree(conn->request_buf);\n\t\tconn->request_buf = NULL;\n\n\t\tsize = t->ops->read(t, hdr_buf, sizeof(hdr_buf), -1);\n\t\tif (size != sizeof(hdr_buf))\n\t\t\tbreak;\n\n\t\tpdu_size = get_rfc1002_len(hdr_buf);\n\t\tksmbd_debug(CONN, \"RFC1002 header %u bytes\\n\", pdu_size);\n\n\t\tif (ksmbd_conn_good(conn))\n\t\t\tmax_allowed_pdu_size =\n\t\t\t\tSMB3_MAX_MSGSIZE + conn->vals->max_write_size;\n\t\telse\n\t\t\tmax_allowed_pdu_size = SMB3_MAX_MSGSIZE;\n\n\t\tif (pdu_size > max_allowed_pdu_size) {\n\t\t\tpr_err_ratelimited(\"PDU length(%u) exceeded maximum allowed pdu size(%u) on connection(%d)\\n\",\n\t\t\t\t\tpdu_size, max_allowed_pdu_size,\n\t\t\t\t\tREAD_ONCE(conn->status));\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Check maximum pdu size(0x00FFFFFF).\n\t\t */\n\t\tif (pdu_size > MAX_STREAM_PROT_LEN)\n\t\t\tbreak;\n\n\t\tif (pdu_size < SMB1_MIN_SUPPORTED_HEADER_SIZE)\n\t\t\tbreak;\n\n\t\t/* 4 for rfc1002 length field */\n\t\t/* 1 for implied bcc[0] */\n\t\tsize = pdu_size + 4 + 1;\n\t\tconn->request_buf = kvmalloc(size, GFP_KERNEL);\n\t\tif (!conn->request_buf)\n\t\t\tbreak;\n\n\t\tmemcpy(conn->request_buf, hdr_buf, sizeof(hdr_buf));\n\t\tif (!ksmbd_smb_request(conn))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * We already read 4 bytes to find out PDU size, now\n\t\t * read in PDU\n\t\t */\n\t\tsize = t->ops->read(t, conn->request_buf + 4, pdu_size, 2);\n\t\tif (size < 0) {\n\t\t\tpr_err(\"sock_read failed: %d\\n\", size);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (size != pdu_size) {\n\t\t\tpr_err(\"PDU error. Read: %d, Expected: %d\\n\",\n\t\t\t       size, pdu_size);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (((struct smb2_hdr *)smb2_get_msg(conn->request_buf))->ProtocolId ==\n\t\t    SMB2_PROTO_NUMBER) {\n\t\t\tif (pdu_size < SMB2_MIN_SUPPORTED_HEADER_SIZE)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!default_conn_ops.process_fn) {\n\t\t\tpr_err(\"No connection request callback\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (default_conn_ops.process_fn(conn)) {\n\t\t\tpr_err(\"Cannot handle request\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tksmbd_conn_set_releasing(conn);\n\t/* Wait till all reference dropped to the Server object*/\n\twait_event(conn->r_count_q, atomic_read(&conn->r_count) == 0);\n\n\tif (IS_ENABLED(CONFIG_UNICODE))\n\t\tutf8_unload(conn->um);\n\tunload_nls(conn->local_nls);\n\tif (default_conn_ops.terminate_fn)\n\t\tdefault_conn_ops.terminate_fn(conn);\n\tt->ops->disconnect(t);\n\tmodule_put(THIS_MODULE);\n\treturn 0;\n}", "target": 3, "idx": 10621}
{"commit_id": "39181fc6429f4e9e71473284940e35857b42772a", "project": "kernel/git/will/kvmtool", "func": "static int vfio_pci_create_msix_table(struct kvm *kvm, struct vfio_device *vdev)\n{\n\tint ret;\n\tsize_t i;\n\tsize_t map_size;\n\tsize_t nr_entries;\n\tstruct vfio_pci_msi_entry *entries;\n\tstruct vfio_pci_device *pdev = &vdev->pci;\n\tstruct vfio_pci_msix_pba *pba = &pdev->msix_pba;\n\tstruct vfio_pci_msix_table *table = &pdev->msix_table;\n\tstruct msix_cap *msix = PCI_CAP(&pdev->hdr, pdev->msix.pos);\n\tstruct vfio_region_info info;\n\n\ttable->bar = msix->table_offset & PCI_MSIX_TABLE_BIR;\n\tpba->bar = msix->pba_offset & PCI_MSIX_TABLE_BIR;\n\n\tnr_entries = (msix->ctrl & PCI_MSIX_FLAGS_QSIZE) + 1;\n\n\t/* MSIX table and PBA must support QWORD accesses. */\n\ttable->size = ALIGN(nr_entries * PCI_MSIX_ENTRY_SIZE, 8);\n\tpba->size = ALIGN(DIV_ROUND_UP(nr_entries, 64), 8);\n\n\tentries = calloc(nr_entries, sizeof(struct vfio_pci_msi_entry));\n\tif (!entries)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < nr_entries; i++)\n\t\tentries[i].config.ctrl = PCI_MSIX_ENTRY_CTRL_MASKBIT;\n\n\tret = vfio_pci_get_region_info(vdev, table->bar, &info);\n\tif (ret)\n\t\treturn ret;\n\tif (!info.size)\n\t\treturn -EINVAL;\n\n\tmap_size = ALIGN(info.size, MAX_PAGE_SIZE);\n\ttable->guest_phys_addr = pci_get_mmio_block(map_size);\n\tif (!table->guest_phys_addr) {\n\t\tpr_err(\"cannot allocate MMIO space\");\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\t/*\n\t * We could map the physical PBA directly into the guest, but it's\n\t * likely smaller than a page, and we can only hand full pages to the\n\t * guest. Even though the PCI spec disallows sharing a page used for\n\t * MSI-X with any other resource, it allows to share the same page\n\t * between MSI-X table and PBA. For the sake of isolation, create a\n\t * virtual PBA.\n\t */\n\tif (table->bar == pba->bar) {\n\t\tu32 pba_bar_offset = msix->pba_offset & PCI_MSIX_PBA_OFFSET;\n\n\t\t/* Sanity checks. */\n\t\tif (table->size > pba_bar_offset)\n\t\t\tdie(\"MSIX table overlaps with PBA\");\n\t\tif (pba_bar_offset + pba->size > info.size)\n\t\t\tdie(\"PBA exceeds the size of the region\");\n\t\tpba->guest_phys_addr = table->guest_phys_addr + pba_bar_offset;\n\t} else {\n\t\tret = vfio_pci_get_region_info(vdev, pba->bar, &info);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (!info.size)\n\t\t\treturn -EINVAL;\n\n\t\tmap_size = ALIGN(info.size, MAX_PAGE_SIZE);\n\t\tpba->guest_phys_addr = pci_get_mmio_block(map_size);\n\t\tif (!pba->guest_phys_addr) {\n\t\t\tpr_err(\"cannot allocate MMIO space\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\tpdev->msix.entries = entries;\n\tpdev->msix.nr_entries = nr_entries;\n\n\treturn 0;\n\nout_free:\n\tfree(entries);\n\n\treturn ret;\n}", "target": 2, "idx": 10622}
{"commit_id": "c800e2987b10bb3af6ef644b515b5d6392f8861d", "project": "open62541", "func": "static status\nencodeJsonStructure(const void *src, const UA_DataType *type, CtxJson *ctx) {\n    /* Check the recursion limit */\n    if(ctx->depth >= UA_JSON_ENCODING_MAX_RECURSION)\n        return UA_STATUSCODE_BADENCODINGERROR;\n    ctx->depth++;\n\n    status ret = writeJsonObjStart(ctx);\n\n    uintptr_t ptr = (uintptr_t) src;\n    u8 membersSize = type->membersSize;\n    const UA_DataType * typelists[2] = {UA_TYPES, &type[-type->typeIndex]};\n    for(size_t i = 0; i < membersSize && ret == UA_STATUSCODE_GOOD; ++i) {\n        const UA_DataTypeMember *m = &type->members[i];\n        const UA_DataType *mt = &typelists[!m->namespaceZero][m->memberTypeIndex];\n\n        if(m->memberName != NULL && *m->memberName != 0)\n            ret |= writeJsonKey(ctx, m->memberName);\n\n        if(!m->isArray) {\n            ptr += m->padding;\n            size_t memSize = mt->memSize;\n            ret |= encodeJsonJumpTable[mt->typeKind]((const void*) ptr, mt, ctx);\n            ptr += memSize;\n        } else {\n            ptr += m->padding;\n            const size_t length = *((const size_t*) ptr);\n            ptr += sizeof (size_t);\n            ret |= encodeJsonArray(ctx, *(void * const *)ptr, length, mt);\n            ptr += sizeof (void*);\n        }\n    }\n\n    ret |= writeJsonObjEnd(ctx);\n\n    ctx->depth--;\n    return ret;\n}", "target": 1, "idx": 10623}
{"commit_id": "dfb4357da6ddbdf57d583ba64361c9d792b0e0b1", "project": "kernel/git/tip/tip", "func": "static void\nprint_timer(struct seq_file *m, struct hrtimer *taddr, struct hrtimer *timer,\n\t    int idx, u64 now)\n{\n\tSEQ_printf(m, \" #%d: \", idx);\n\tprint_name_offset(m, taddr);\n\tSEQ_printf(m, \", \");\n\tprint_name_offset(m, timer->function);\n\tSEQ_printf(m, \", S:%02x\", timer->state);\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \" # expires at %Lu-%Lu nsecs [in %Ld to %Ld nsecs]\\n\",\n\t\t(unsigned long long)ktime_to_ns(hrtimer_get_softexpires(timer)),\n\t\t(unsigned long long)ktime_to_ns(hrtimer_get_expires(timer)),\n\t\t(long long)(ktime_to_ns(hrtimer_get_softexpires(timer)) - now),\n\t\t(long long)(ktime_to_ns(hrtimer_get_expires(timer)) - now));\n}", "target": 1, "idx": 10624}
{"commit_id": "fc6080f1321fd21e86ef916195cc110b05d9effb", "project": "ImageMagick", "func": "MagickExport XMLTreeInfo *NewXMLTree(const char *xml,ExceptionInfo *exception)\n{\n  char\n    **attribute,\n    **attributes,\n    *tag,\n    *utf8;\n\n  int\n    c,\n    terminal;\n\n  MagickBooleanType\n    status;\n\n  register char\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    ignore_depth,\n    length;\n\n  ssize_t\n    j,\n    l;\n\n  XMLTreeRoot\n    *root;\n\n  /*\n    Convert xml-string to UTF8.\n  */\n  if ((xml == (const char *) NULL) || (strlen(xml) == 0))\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n        \"ParseError\",\"root tag missing\");\n      return((XMLTreeInfo *) NULL);\n    }\n  root=(XMLTreeRoot *) NewXMLTreeTag((char *) NULL);\n  length=strlen(xml);\n  utf8=ConvertUTF16ToUTF8(xml,&length);\n  if (utf8 == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n        \"ParseError\",\"UTF16 to UTF8 failed\");\n      return((XMLTreeInfo *) NULL);\n    }\n  terminal=utf8[length-1];\n  utf8[length-1]='\\0';\n  p=utf8;\n  while ((*p != '\\0') && (*p != '<'))\n    p++;\n  if (*p == '\\0')\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n        \"ParseError\",\"root tag missing\");\n      utf8=DestroyString(utf8);\n      return((XMLTreeInfo *) NULL);\n    }\n  attribute=(char **) NULL;\n  l=0;\n  ignore_depth=0;\n  for (p++; ; p++)\n  {\n    attributes=(char **) sentinel;\n    tag=p;\n    c=(*p);\n    if ((isalpha((int) ((unsigned char) *p)) !=0) || (*p == '_') ||\n        (*p == ':') || (c < '\\0'))\n      {\n        /*\n          Tag.\n        */\n        if (root->node == (XMLTreeInfo *) NULL)\n          {\n            (void) ThrowMagickException(exception,GetMagickModule(),\n              OptionWarning,\"ParseError\",\"root tag missing\");\n            utf8=DestroyString(utf8);\n            return(&root->root);\n          }\n        p+=strcspn(p,XMLWhitespace \"/>\");\n        while (isspace((int) ((unsigned char) *p)) != 0)\n          *p++='\\0';\n        if (ignore_depth == 0)\n          {\n            if ((*p != '\\0') && (*p != '/') && (*p != '>'))\n              {\n                /*\n                  Find tag in default attributes list.\n                */\n                i=0;\n                while ((root->attributes[i] != (char **) NULL) &&\n                       (strcmp(root->attributes[i][0],tag) != 0))\n                  i++;\n                attribute=root->attributes[i];\n              }\n            for (l=0; (*p != '\\0') && (*p != '/') && (*p != '>'); l+=2)\n            {\n              /*\n                Attribute.\n              */\n              if (l == 0)\n                attributes=(char **) AcquireQuantumMemory(4,\n                  sizeof(*attributes));\n              else\n                attributes=(char **) ResizeQuantumMemory(attributes,\n                  (size_t) (l+4),sizeof(*attributes));\n              if (attributes == (char **) NULL)\n                {\n                  (void) ThrowMagickException(exception,GetMagickModule(),\n                    ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n                  utf8=DestroyString(utf8);\n                  return(&root->root);\n                }\n              attributes[l+2]=(char *) NULL;\n              attributes[l+1]=(char *) NULL;\n              attributes[l]=p;\n              p+=strcspn(p,XMLWhitespace \"=/>\");\n              if ((*p != '=') && (isspace((int) ((unsigned char) *p)) == 0))\n                attributes[l]=ConstantString(\"\");\n              else\n                {\n                  *p++='\\0';\n                  p+=strspn(p,XMLWhitespace \"=\");\n                  c=(*p);\n                  if ((c == '\"') || (c == '\\''))\n                    {\n                      /*\n                        Attributes value.\n                      */\n                      p++;\n                      attributes[l+1]=p;\n                      while ((*p != '\\0') && (*p != c))\n                        p++;\n                      if (*p != '\\0')\n                        *p++='\\0';\n                      else\n                        {\n                          attributes[l]=ConstantString(\"\");\n                          attributes[l+1]=ConstantString(\"\");\n                          (void) DestroyXMLTreeAttributes(attributes);\n                          (void) ThrowMagickException(exception,\n                            GetMagickModule(),OptionWarning,\"ParseError\",\n                            \"missing %c\",c);\n                          utf8=DestroyString(utf8);\n                          return(&root->root);\n                        }\n                      j=1;\n                      while ((attribute != (char **) NULL) &&\n                             (attribute[j] != (char *) NULL) &&\n                             (strcmp(attribute[j],attributes[l]) != 0))\n                        j+=3;\n                      attributes[l+1]=ParseEntities(attributes[l+1],\n                        root->entities,(attribute != (char **) NULL) &&\n                        (attribute[j] != (char *) NULL) ? *attribute[j+2] :\n                        ' ');\n                    }\n                  attributes[l]=ConstantString(attributes[l]);\n                }\n              while (isspace((int) ((unsigned char) *p)) != 0)\n                p++;\n            }\n          }\n        else\n          {\n            while((*p != '\\0') && (*p != '/') && (*p != '>'))\n              p++;\n          }\n        if (*p == '/')\n          {\n            /*\n              Self closing tag.\n            */\n            *p++='\\0';\n            if (((*p != '\\0') && (*p != '>')) ||\n                ((*p == '\\0') && (terminal != '>')))\n              {\n                if (l != 0)\n                  (void) DestroyXMLTreeAttributes(attributes);\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  OptionWarning,\"ParseError\",\"missing >\");\n                utf8=DestroyString(utf8);\n                return(&root->root);\n              }\n            if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))\n              {\n                ParseOpenTag(root,tag,attributes);\n                (void) ParseCloseTag(root,tag,exception);\n              }\n          }\n        else\n          {\n            c=(*p);\n            if ((*p == '>') || ((*p == '\\0') && (terminal == '>')))\n              {\n                *p='\\0';\n                if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))\n                  ParseOpenTag(root,tag,attributes);\n                else\n                  {\n                    ignore_depth++;\n                    (void) DestroyXMLTreeAttributes(attributes);\n                  }\n                *p=c;\n              }\n            else\n              {\n                if (l != 0)\n                  (void) DestroyXMLTreeAttributes(attributes);\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  OptionWarning,\"ParseError\",\"missing >\");\n                utf8=DestroyString(utf8);\n                return(&root->root);\n              }\n          }\n      }\n    else\n      if (*p == '/')\n        {\n          /*\n            Close tag.\n          */\n          tag=p+1;\n          p+=strcspn(tag,XMLWhitespace \">\")+1;\n          c=(*p);\n          if ((c == '\\0') && (terminal != '>'))\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionWarning,\"ParseError\",\"missing >\");\n              utf8=DestroyString(utf8);\n              return(&root->root);\n            }\n          *p='\\0';\n          if (ignore_depth == 0 && ParseCloseTag(root,tag,exception) !=\n              (XMLTreeInfo *) NULL)\n            {\n              utf8=DestroyString(utf8);\n              return(&root->root);\n            }\n          if (ignore_depth > 0)\n            ignore_depth--;\n          *p=c;\n          if (isspace((int) ((unsigned char) *p)) != 0)\n            p+=strspn(p,XMLWhitespace);\n        }\n      else\n        if (strncmp(p,\"!--\",3) == 0)\n          {\n            /*\n              Comment.\n            */\n            p=strstr(p+3,\"--\");\n            if ((p == (char *) NULL) || ((*(p+=2) != '>') && (*p != '\\0')) ||\n                ((*p == '\\0') && (terminal != '>')))\n              {\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  OptionWarning,\"ParseError\",\"unclosed <!--\");\n                utf8=DestroyString(utf8);\n                return(&root->root);\n              }\n          }\n        else\n          if (strncmp(p,\"![CDATA[\",8) == 0)\n            {\n              /*\n                Cdata.\n              */\n              p=strstr(p,\"]]>\");\n              if (p != (char *) NULL)\n                {\n                  p+=2;\n                  if (ignore_depth == 0)\n                    ParseCharacterContent(root,tag+8,(size_t) (p-tag-10),'c');\n                }\n              else\n                {\n                  (void) ThrowMagickException(exception,GetMagickModule(),\n                    OptionWarning,\"ParseError\",\"unclosed <![CDATA[\");\n                  utf8=DestroyString(utf8);\n                  return(&root->root);\n                }\n            }\n          else\n            if (strncmp(p,\"!DOCTYPE\",8) == 0)\n              {\n                /*\n                  DTD.\n                */\n                for (l=0; (*p != '\\0') && (((l == 0) && (*p != '>')) ||\n                     ((l != 0) && ((*p != ']') ||\n                     (*(p+strspn(p+1,XMLWhitespace)+1) != '>'))));\n                  l=(ssize_t) ((*p == '[') ? 1 : l))\n                p+=strcspn(p+1,\"[]>\")+1;\n                if ((*p == '\\0') && (terminal != '>'))\n                  {\n                    (void) ThrowMagickException(exception,GetMagickModule(),\n                      OptionWarning,\"ParseError\",\"unclosed <!DOCTYPE\");\n                    utf8=DestroyString(utf8);\n                    return(&root->root);\n                  }\n                if (l != 0)\n                  tag=strchr(tag,'[')+1;\n                if (l != 0)\n                  {\n                    status=ParseInternalDoctype(root,tag,(size_t) (p-tag),\n                      exception);\n                    if (status == MagickFalse)\n                      {\n                        utf8=DestroyString(utf8);\n                        return(&root->root);\n                      }\n                    p++;\n                  }\n              }\n            else\n              if (*p == '?')\n                {\n                  /*\n                    Processing instructions.\n                  */\n                  do\n                  {\n                    p=strchr(p,'?');\n                    if (p == (char *) NULL)\n                      break;\n                    p++;\n                  } while ((*p != '\\0') && (*p != '>'));\n                  if ((p == (char *) NULL) || ((*p == '\\0') &&\n                      (terminal != '>')))\n                    {\n                      (void) ThrowMagickException(exception,GetMagickModule(),\n                        OptionWarning,\"ParseError\",\"unclosed <?\");\n                      utf8=DestroyString(utf8);\n                      return(&root->root);\n                    }\n                  ParseProcessingInstructions(root,tag+1,(size_t) (p-tag-2));\n                }\n              else\n                {\n                  (void) ThrowMagickException(exception,GetMagickModule(),\n                    OptionWarning,\"ParseError\",\"unexpected <\");\n                  utf8=DestroyString(utf8);\n                  return(&root->root);\n                }\n     if ((p == (char *) NULL) || (*p == '\\0'))\n       break;\n     *p++='\\0';\n     tag=p;\n     if ((*p != '\\0') && (*p != '<'))\n       {\n        /*\n          Tag character content.\n        */\n        while ((*p != '\\0') && (*p != '<'))\n          p++;\n        if (*p == '\\0')\n          break;\n        if (ignore_depth == 0)\n          ParseCharacterContent(root,tag,(size_t) (p-tag),'&');\n      }\n    else\n      if (*p == '\\0')\n        break;\n  }\n  utf8=DestroyString(utf8);\n  if (root->node == (XMLTreeInfo *) NULL)\n    return(&root->root);\n  if (root->node->tag == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n        \"ParseError\",\"root tag missing\");\n      return(&root->root);\n    }\n  (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n    \"ParseError\",\"unclosed tag: `%s'\",root->node->tag);\n  return(&root->root);\n}", "target": 1, "idx": 10625}
{"commit_id": "2e7eab81425ad6c875f2ed47c0ce01e78afc38a5", "project": "torvalds/linux", "func": "void vmx_vcpu_load_vmcs(struct kvm_vcpu *vcpu, int cpu,\n\t\t\tstruct loaded_vmcs *buddy)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tbool already_loaded = vmx->loaded_vmcs->cpu == cpu;\n\tstruct vmcs *prev;\n\n\tif (!already_loaded) {\n\t\tloaded_vmcs_clear(vmx->loaded_vmcs);\n\t\tlocal_irq_disable();\n\n\t\t/*\n\t\t * Ensure loaded_vmcs->cpu is read before adding loaded_vmcs to\n\t\t * this cpu's percpu list, otherwise it may not yet be deleted\n\t\t * from its previous cpu's percpu list.  Pairs with the\n\t\t * smb_wmb() in __loaded_vmcs_clear().\n\t\t */\n\t\tsmp_rmb();\n\n\t\tlist_add(&vmx->loaded_vmcs->loaded_vmcss_on_cpu_link,\n\t\t\t &per_cpu(loaded_vmcss_on_cpu, cpu));\n\t\tlocal_irq_enable();\n\t}\n\n\tprev = per_cpu(current_vmcs, cpu);\n\tif (prev != vmx->loaded_vmcs->vmcs) {\n\t\tper_cpu(current_vmcs, cpu) = vmx->loaded_vmcs->vmcs;\n\t\tvmcs_load(vmx->loaded_vmcs->vmcs);\n\n\t\t/*\n\t\t * No indirect branch prediction barrier needed when switching\n\t\t * the active VMCS within a vCPU, unless IBRS is advertised to\n\t\t * the vCPU.  To minimize the number of IBPBs executed, KVM\n\t\t * performs IBPB on nested VM-Exit (a single nested transition\n\t\t * may switch the active VMCS multiple times).\n\t\t */\n\t\tif (!buddy || WARN_ON_ONCE(buddy->vmcs != prev))\n\t\t\tindirect_branch_prediction_barrier();\n\t}\n\n\tif (!already_loaded) {\n\t\tvoid *gdt = get_current_gdt_ro();\n\n\t\t/*\n\t\t * Flush all EPTP/VPID contexts, the new pCPU may have stale\n\t\t * TLB entries from its previous association with the vCPU.\n\t\t */\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\n\t\t/*\n\t\t * Linux uses per-cpu TSS and GDT, so set these when switching\n\t\t * processors.  See 22.2.4.\n\t\t */\n\t\tvmcs_writel(HOST_TR_BASE,\n\t\t\t    (unsigned long)&get_cpu_entry_area(cpu)->tss.x86_tss);\n\t\tvmcs_writel(HOST_GDTR_BASE, (unsigned long)gdt);   /* 22.2.4 */\n\n\t\tif (IS_ENABLED(CONFIG_IA32_EMULATION) || IS_ENABLED(CONFIG_X86_32)) {\n\t\t\t/* 22.2.3 */\n\t\t\tvmcs_writel(HOST_IA32_SYSENTER_ESP,\n\t\t\t\t    (unsigned long)(cpu_entry_stack(cpu) + 1));\n\t\t}\n\n\t\tvmx->loaded_vmcs->cpu = cpu;\n\t}\n}", "target": 2, "idx": 10626}
{"commit_id": "7279fbd6ef4d0c8bdd6a90af4ada2899d786eec0", "project": "TeraTermProject/teraterm", "func": "static BOOL handle_SSH2_newkeys(PTInstVar pvar)\n{\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_NEWKEYS was received(DH key generation is completed).\");\n\n\t// \u30ed\u30b0\u63a1\u53d6\u306e\u7d42\u4e86 (2005.3.7 yutaka)\n\tif (LogLevel(pvar, LOG_LEVEL_SSHDUMP)) {\n\t\tsave_memdump(LOGDUMP);\n\t}\n\tfinish_memdump();\n\n\tpvar->kex_status |= KEX_FLAG_NEWKEYS_RECEIVED;\n\n\t// SSH2_MSG_NEWKEYS \u53d7\u4fe1\u5f8c\u306f\u76f8\u624b\u304b\u3089\u306e\u30d1\u30b1\u30c3\u30c8\u306f\u6697\u53f7\u5316\u3055\u308c\u3066\u304f\u308b\u306e\u3067\u3001\n\t// \u53d7\u4fe1\u65b9\u5411\u306e\u6697\u53f7\u5316(\u5fa9\u53f7)\u3092\u6709\u52b9\u306b\u3059\u308b\u3002\n\tssh2_set_newkeys(pvar, MODE_IN);\n\tif (!CRYPT_start_encryption(pvar, 0, 1)) {\n\t\t// TODO: error\n\t}\n\n\t// \u540c\u69d8\u306b\u3001MAC\u304a\u3088\u3073\u5727\u7e2e\u3092\u6709\u52b9\u306b\u3059\u308b\u3002\n\tpvar->ssh2_keys[MODE_IN].mac.enabled = 1;\n\tpvar->ssh2_keys[MODE_IN].comp.enabled = 1;\n\tenable_recv_compression(pvar);\n\n\tif (pvar->server_strict_kex) {\n\t\tpvar->ssh_state.receiver_sequence_number = 0;\n\t}\n\n\tSSH2_dispatch_add_message(SSH2_MSG_EXT_INFO);\n\n\t// SSH2_MSG_NEWKEYS \u3092\u65e2\u306b\u9001\u3063\u3066\u3044\u305f\u3089KEX\u306f\u5b8c\u4e86\u3002\u6b21\u306e\u51e6\u7406\u306b\u79fb\u308b\u3002\n\tif (pvar->kex_status & KEX_FLAG_NEWKEYS_SENT) {\n\t\tif (pvar->kex_status & KEX_FLAG_REKEYING) {\n\t\t\tint i;\n\t\t\tChannel_t *c;\n\n\t\t\tdo_SSH2_dispatch_setup_for_transfer(pvar);\n\n\t\t\t// \u9001\u3089\u305a\u30d0\u30c3\u30d5\u30a1\u306b\u4fdd\u5b58\u3057\u3066\u304a\u3044\u305f\u30c7\u30fc\u30bf\u3092\u9001\u308b\n\t\t\tfor (i = 0 ; i < CHANNEL_MAX ; i++) {\n\t\t\t\tc = &channels[i];\n\t\t\t\tif (c->used) {\n\t\t\t\t\tssh2_channel_retry_send_bufchain(pvar, c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// \u521d\u56de\u306e SSH2_MSG_NEWKEYS \u306e\u9001\u53d7\u4fe1\u304c\u5b8c\u4e86\u3057\u3001\u4ee5\u964d\u306e\u901a\u4fe1\u306f\u6697\u53f7\u5316\u3055\u308c\u305f\u72b6\u614b\u306b\u306a\u308b\n\t\t\tssh2_finish_encryption_setup(pvar);\n\n\t\t\t// \u521d\u56de\u306e\u9375\u4ea4\u63db\u5f8c\u306f\u30e6\u30fc\u30b6\u8a8d\u8a3c\u3092\u958b\u59cb\u3059\u308b\n\t\t\tssh2_prep_userauth(pvar);\n\t\t}\n\t\tpvar->kex_status = KEX_FLAG_KEXDONE;\n\t}\n\n\treturn TRUE;\n}", "target": 1, "idx": 10627}
{"commit_id": "3ba974f841c4aab920fefe345196437d52e3b8aa", "project": "MarlinFirmware/Marlin", "func": "const char* CardReader::diveToFile(SdFile*& curDir, const char * const path, const bool echo) {\n  SdFile myDir;\n  if (path[0] != '/') { curDir = &workDir; return path; }\n\n  curDir = &root;\n  const char *dirname_start = &path[1];\n  while (dirname_start) {\n    char * const dirname_end = strchr(dirname_start, '/');\n    const int8_t len = dirname_end - dirname_start;\n    if (len <= 0) break;\n    char dosSubdirname[len + 1];\n    strncpy(dosSubdirname, dirname_start, len);\n    dosSubdirname[len] = 0;\n\n    if (echo) SERIAL_ECHOLN(dosSubdirname);\n\n    if (!myDir.open(curDir, dosSubdirname, O_READ)) {\n      SERIAL_PROTOCOLPAIR(MSG_SD_OPEN_FILE_FAIL, dosSubdirname);\n      SERIAL_PROTOCOLCHAR('.');\n      SERIAL_EOL();\n      return NULL;\n    }\n    curDir = &myDir;\n    dirname_start = dirname_end + 1;\n  }\n  return dirname_start;\n}", "target": 3, "idx": 10628}
{"commit_id": "5ce30801f9ccc372bbe9b7c98bb5324b15fb010a", "project": "CESNET/libyang", "func": "static void\nmodule_free_common(struct lys_module *module, void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    struct ly_ctx *ctx;\n    struct lys_node *next, *iter;\n    unsigned int i;\n\n    assert(module->ctx);\n    ctx = module->ctx;\n\n    /* just free the import array, imported modules will stay in the context */\n    for (i = 0; i < module->imp_size; i++) {\n        lydict_remove(ctx, module->imp[i].prefix);\n        lydict_remove(ctx, module->imp[i].dsc);\n        lydict_remove(ctx, module->imp[i].ref);\n        lys_extension_instances_free(ctx, module->imp[i].ext, module->imp[i].ext_size, private_destructor);\n    }\n    free(module->imp);\n\n    /* submodules don't have data tree, the data nodes\n     * are placed in the main module altogether */\n    if (!module->type) {\n        LY_TREE_FOR_SAFE(module->data, next, iter) {\n            lys_node_free(ctx, iter, private_destructor, 0);\n        }\n    }\n\n    lydict_remove(ctx, module->dsc);\n    lydict_remove(ctx, module->ref);\n    lydict_remove(ctx, module->org);\n    lydict_remove(ctx, module->contact);\n    lydict_remove(ctx, module->filepath);\n\n    /* revisions */\n    for (i = 0; i < module->rev_size; i++) {\n        lys_extension_instances_free(ctx, module->rev[i].ext, module->rev[i].ext_size, private_destructor);\n        lydict_remove(ctx, module->rev[i].dsc);\n        lydict_remove(ctx, module->rev[i].ref);\n    }\n    free(module->rev);\n\n    /* identities */\n    for (i = 0; i < module->ident_size; i++) {\n        lys_ident_free(ctx, &module->ident[i], private_destructor);\n    }\n    module->ident_size = 0;\n    free(module->ident);\n\n    /* typedefs */\n    for (i = 0; i < module->tpdf_size; i++) {\n        lys_tpdf_free(ctx, &module->tpdf[i], private_destructor);\n    }\n    free(module->tpdf);\n\n    /* extension instances */\n    lys_extension_instances_free(ctx, module->ext, module->ext_size, private_destructor);\n\n    /* augment */\n    for (i = 0; i < module->augment_size; i++) {\n        lys_augment_free(ctx, &module->augment[i], private_destructor);\n    }\n    free(module->augment);\n\n    /* features */\n    for (i = 0; i < module->features_size; i++) {\n        lys_feature_free(ctx, &module->features[i], private_destructor);\n    }\n    free(module->features);\n\n    /* deviations */\n    for (i = 0; i < module->deviation_size; i++) {\n        lys_deviation_free(module, &module->deviation[i], private_destructor);\n    }\n    free(module->deviation);\n\n    /* extensions */\n    for (i = 0; i < module->extensions_size; i++) {\n        lys_extension_free(ctx, &module->extensions[i], private_destructor);\n    }\n    free(module->extensions);\n\n    lydict_remove(ctx, module->name);\n    lydict_remove(ctx, module->prefix);\n}", "target": 2, "idx": 10629}
{"commit_id": "a48aea18b6c7ee534cd21f7febfe253e31b33eda", "project": "mumble-voip/mumble", "func": "void Server::connectionClosed(QAbstractSocket::SocketError err, const QString &reason) {\n\tif (reason.contains(QLatin1String(\"140E0197\"))) {\n\t\t// A severe bug was introduced in qt/qtbase@93a803a6de27d9eb57931c431b5f3d074914f693.\n\t\t// q_SSL_shutdown() causes Qt to emit \"error()\" from unrelated QSslSocket(s), in addition to the correct one.\n\t\t// The issue causes this function to disconnect random authenticated clients.\n\t\t//\n\t\t// The workaround consists in ignoring a specific OpenSSL error:\n\t\t// \"Error while reading: error:140E0197:SSL routines:SSL_shutdown:shutdown while in init [20]\"\n\t\t//\n\t\t// Definitely not ideal, but it fixes a critical vulnerability.\n\t\tqWarning(\"Ignored OpenSSL error 140E0197 for %p\", sender());\n\t\treturn;\n\t}\n\n\tConnection *c = qobject_cast<Connection *>(sender());\n\tif (! c)\n\t\treturn;\n\tif (c->bDisconnectedEmitted)\n\t\treturn;\n\tc->bDisconnectedEmitted = true;\n\n\tServerUser *u = static_cast<ServerUser *>(c);\n\n\tlog(u, QString(\"Connection closed: %1 [%2]\").arg(reason).arg(err));\n\n\tif (u->sState == ServerUser::Authenticated) {\n\t\tMumbleProto::UserRemove mpur;\n\t\tmpur.set_session(u->uiSession);\n\t\tsendExcept(u, mpur);\n\n\t\temit userDisconnected(u);\n\t}\n\n\tChannel *old = u->cChannel;\n\n\t{\n\t\tQWriteLocker wl(&qrwlVoiceThread);\n\n\t\tqhUsers.remove(u->uiSession);\n\t\tqhHostUsers[u->haAddress].remove(u);\n\n\t\tquint16 port = (u->saiUdpAddress.ss_family == AF_INET6) ? (reinterpret_cast<sockaddr_in6 *>(&u->saiUdpAddress)->sin6_port) : (reinterpret_cast<sockaddr_in *>(&u->saiUdpAddress)->sin_port);\n\t\tconst QPair<HostAddress, quint16> &key = QPair<HostAddress, quint16>(u->haAddress, port);\n\t\tqhPeerUsers.remove(key);\n\n\t\tif (old)\n\t\t\told->removeUser(u);\n\t}\n\n\tif (old && old->bTemporary && old->qlUsers.isEmpty())\n\t\tQCoreApplication::instance()->postEvent(this, new ExecEvent(boost::bind(&Server::removeChannel, this, old->iId)));\n\n\tif (static_cast<int>(u->uiSession) < iMaxUsers * 2)\n\t\tqqIds.enqueue(u->uiSession); // Reinsert session id into pool\n\n\tif (u->sState == ServerUser::Authenticated) {\n\t\tclearTempGroups(u); // Also clears ACL cache\n\t\trecheckCodecVersions(); // Maybe can choose a better codec now\n\t}\n\n\tu->deleteLater();\n\n\tif (qhUsers.isEmpty())\n\t\tstopThread();\n}", "target": 2, "idx": 10630}
{"commit_id": "94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6", "project": "torvalds/linux", "func": "static int crypto_rng_init_tfm(struct crypto_tfm *tfm)\n{\n\treturn 0;\n}", "target": 1, "idx": 10631}
{"commit_id": "2117d5398c81554fbf803f5fd1dc55eb78216c0c", "project": "torvalds/linux", "func": "static int em_ret_far(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tunsigned long eip, cs;\n\tint cpl = ctxt->ops->cpl(ctxt);\n\tstruct desc_struct new_desc;\n\n\trc = emulate_pop(ctxt, &eip, ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = emulate_pop(ctxt, &cs, ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\t/* Outer-privilege level return is not implemented */\n\tif (ctxt->mode >= X86EMUL_MODE_PROT16 && (cs & 3) > cpl)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\trc = __load_segment_descriptor(ctxt, (u16)cs, VCPU_SREG_CS, cpl,\n\t\t\t\t       X86_TRANSFER_RET,\n\t\t\t\t       &new_desc);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = assign_eip_far(ctxt, eip, &new_desc);\n\t/* Error handling is not implemented. */\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\n\treturn rc;\n}", "target": 1, "idx": 10632}
{"commit_id": "ecddb7d63306e01d137d65bbbe7b78c1e779943c", "project": "nu774/fdkaac", "func": "static\nint caf_desc(caf_reader_t *reader, int64_t chunk_size)\n{\n    double mSampleRate;\n    uint32_t mFormatID, mFormatFlags, mBytesPerPacket, mFramesPerPacket,\n             mChannelsPerFrame, mBitsPerChannel;\n    pcm_sample_description_t *desc = &reader->sample_format;\n\n    ENSURE(chunk_size >= 32);\n    TRY_IO(pcm_scanb(&reader->io, \"QLLLLLL\", &mSampleRate, &mFormatID,\n                     &mFormatFlags, &mBytesPerPacket, &mFramesPerPacket,\n                     &mChannelsPerFrame, &mBitsPerChannel) != 7);\n\n    ENSURE(mFormatID == M4AF_FOURCC('l','p','c','m'));\n    ENSURE(mSampleRate && mBytesPerPacket &&\n           mChannelsPerFrame >= 1 && mChannelsPerFrame <= 8 &&\n           mBitsPerChannel > 0 && mBitsPerChannel < 256 &&\n           mFramesPerPacket == 1 &&\n           mBytesPerPacket % mChannelsPerFrame == 0 &&\n           mBytesPerPacket < 256 &&\n           mBytesPerPacket >= mChannelsPerFrame * ((mBitsPerChannel + 7) / 8));\n\n    desc->sample_rate        = mSampleRate;\n    desc->bits_per_channel   = mBitsPerChannel;\n    desc->bytes_per_frame    = mBytesPerPacket;\n    desc->channels_per_frame = mChannelsPerFrame;\n\n    switch (mFormatFlags) {\n    case 0: desc->sample_type = PCM_TYPE_SINT_BE;  break;\n    case 1: desc->sample_type = PCM_TYPE_FLOAT_BE; break;\n    case 2: desc->sample_type = PCM_TYPE_SINT;     break;\n    case 3: desc->sample_type = PCM_TYPE_FLOAT;    break;\n    default: goto FAIL;\n    }\n\n    TRY_IO(pcm_skip(&reader->io, chunk_size - 32));\n    return 0;\nFAIL:\n    return -1;\n}", "target": 2, "idx": 10633}
{"commit_id": "a2f12a1b0f95b13b6f8dc3d05d7b74b4386394e4", "project": "virglrenderer", "func": "static struct vrend_linked_shader_program *add_shader_program(struct vrend_context *ctx,\n                                                              struct vrend_shader *vs,\n                                                              struct vrend_shader *fs,\n                                                              struct vrend_shader *gs)\n{\n   struct vrend_linked_shader_program *sprog = CALLOC_STRUCT(vrend_linked_shader_program);\n   char name[16];\n   int i;\n   GLuint prog_id;\n   GLint lret;\n   int id;\n   int last_shader;\n   if (!sprog)\n      return NULL;\n\n   /* need to rewrite VS code to add interpolation params */\n   if ((gs && gs->compiled_fs_id != fs->id) ||\n       (!gs && vs->compiled_fs_id != fs->id)) {\n      bool ret;\n\n      if (gs)\n         vrend_patch_vertex_shader_interpolants(gs->glsl_prog,\n                                                &gs->sel->sinfo,\n                                                &fs->sel->sinfo, true, fs->key.flatshade);\n      else\n         vrend_patch_vertex_shader_interpolants(vs->glsl_prog,\n                                                &vs->sel->sinfo,\n                                                &fs->sel->sinfo, false, fs->key.flatshade);\n      ret = vrend_compile_shader(ctx, gs ? gs : vs);\n      if (ret == false) {\n         glDeleteShader(gs ? gs->id : vs->id);\n         free(sprog);\n         return NULL;\n      }\n      if (gs)\n         gs->compiled_fs_id = fs->id;\n      else\n         vs->compiled_fs_id = fs->id;\n   }\n\n   prog_id = glCreateProgram();\n   glAttachShader(prog_id, vs->id);\n   if (gs) {\n      if (gs->id > 0)\n         glAttachShader(prog_id, gs->id);\n      set_stream_out_varyings(prog_id, &gs->sel->sinfo);\n   }\n   else\n      set_stream_out_varyings(prog_id, &vs->sel->sinfo);\n   glAttachShader(prog_id, fs->id);\n\n   if (fs->sel->sinfo.num_outputs > 1) {\n      if (util_blend_state_is_dual(&ctx->sub->blend_state, 0)) {\n         glBindFragDataLocationIndexed(prog_id, 0, 0, \"fsout_c0\");\n         glBindFragDataLocationIndexed(prog_id, 0, 1, \"fsout_c1\");\n         sprog->dual_src_linked = true;\n      } else {\n         glBindFragDataLocationIndexed(prog_id, 0, 0, \"fsout_c0\");\n         glBindFragDataLocationIndexed(prog_id, 1, 0, \"fsout_c1\");\n         sprog->dual_src_linked = false;\n      }\n   } else\n      sprog->dual_src_linked = false;\n\n   if (vrend_state.have_vertex_attrib_binding) {\n      uint32_t mask = vs->sel->sinfo.attrib_input_mask;\n      while (mask) {\n         i = u_bit_scan(&mask);\n         snprintf(name, 10, \"in_%d\", i);\n         glBindAttribLocation(prog_id, i, name);\n      }\n   }\n\n   glLinkProgram(prog_id);\n\n   glGetProgramiv(prog_id, GL_LINK_STATUS, &lret);\n   if (lret == GL_FALSE) {\n      char infolog[65536];\n      int len;\n      glGetProgramInfoLog(prog_id, 65536, &len, infolog);\n      fprintf(stderr,\"got error linking\\n%s\\n\", infolog);\n      /* dump shaders */\n      report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_SHADER, 0);\n      fprintf(stderr,\"vert shader: %d GLSL\\n%s\\n\", vs->id, vs->glsl_prog);\n      if (gs)\n         fprintf(stderr,\"geom shader: %d GLSL\\n%s\\n\", gs->id, gs->glsl_prog);\n      fprintf(stderr,\"frag shader: %d GLSL\\n%s\\n\", fs->id, fs->glsl_prog);\n      glDeleteProgram(prog_id);\n      free(sprog);\n      return NULL;\n   }\n\n   sprog->ss[PIPE_SHADER_VERTEX] = vs;\n   sprog->ss[PIPE_SHADER_FRAGMENT] = fs;\n   sprog->ss[PIPE_SHADER_GEOMETRY] = gs;\n\n   list_add(&sprog->sl[PIPE_SHADER_VERTEX], &vs->programs);\n   list_add(&sprog->sl[PIPE_SHADER_FRAGMENT], &fs->programs);\n   if (gs)\n      list_add(&sprog->sl[PIPE_SHADER_GEOMETRY], &gs->programs);\n\n   last_shader = gs ? PIPE_SHADER_GEOMETRY : PIPE_SHADER_FRAGMENT;\n   sprog->id = prog_id;\n\n   list_addtail(&sprog->head, &ctx->sub->programs);\n\n   if (fs->key.pstipple_tex)\n      sprog->fs_stipple_loc = glGetUniformLocation(prog_id, \"pstipple_sampler\");\n   else\n      sprog->fs_stipple_loc = -1;\n   sprog->vs_ws_adjust_loc = glGetUniformLocation(prog_id, \"winsys_adjust\");\n   for (id = PIPE_SHADER_VERTEX; id <= last_shader; id++) {\n      if (sprog->ss[id]->sel->sinfo.samplers_used_mask) {\n         uint32_t mask = sprog->ss[id]->sel->sinfo.samplers_used_mask;\n         int nsamp = util_bitcount(sprog->ss[id]->sel->sinfo.samplers_used_mask);\n         int index;\n         sprog->shadow_samp_mask[id] = sprog->ss[id]->sel->sinfo.shadow_samp_mask;\n         if (sprog->ss[id]->sel->sinfo.shadow_samp_mask) {\n            sprog->shadow_samp_mask_locs[id] = calloc(nsamp, sizeof(uint32_t));\n            sprog->shadow_samp_add_locs[id] = calloc(nsamp, sizeof(uint32_t));\n         } else {\n            sprog->shadow_samp_mask_locs[id] = sprog->shadow_samp_add_locs[id] = NULL;\n         }\n         sprog->samp_locs[id] = calloc(nsamp, sizeof(uint32_t));\n         if (sprog->samp_locs[id]) {\n            const char *prefix = pipe_shader_to_prefix(id);\n            index = 0;\n            while(mask) {\n               i = u_bit_scan(&mask);\n               snprintf(name, 10, \"%ssamp%d\", prefix, i);\n               sprog->samp_locs[id][index] = glGetUniformLocation(prog_id, name);\n               if (sprog->ss[id]->sel->sinfo.shadow_samp_mask & (1 << i)) {\n                  snprintf(name, 14, \"%sshadmask%d\", prefix, i);\n                  sprog->shadow_samp_mask_locs[id][index] = glGetUniformLocation(prog_id, name);\n                  snprintf(name, 14, \"%sshadadd%d\", prefix, i);\n                  sprog->shadow_samp_add_locs[id][index] = glGetUniformLocation(prog_id, name);\n               }\n               index++;\n            }\n         }\n      } else {\n         sprog->samp_locs[id] = NULL;\n         sprog->shadow_samp_mask_locs[id] = NULL;\n         sprog->shadow_samp_add_locs[id] = NULL;\n         sprog->shadow_samp_mask[id] = 0;\n      }\n      sprog->samplers_used_mask[id] = sprog->ss[id]->sel->sinfo.samplers_used_mask;\n   }\n\n   for (id = PIPE_SHADER_VERTEX; id <= last_shader; id++) {\n      if (sprog->ss[id]->sel->sinfo.num_consts) {\n         sprog->const_locs[id] = calloc(sprog->ss[id]->sel->sinfo.num_consts, sizeof(uint32_t));\n         if (sprog->const_locs[id]) {\n            const char *prefix = pipe_shader_to_prefix(id);\n            for (i = 0; i < sprog->ss[id]->sel->sinfo.num_consts; i++) {\n               snprintf(name, 16, \"%sconst0[%d]\", prefix, i);\n               sprog->const_locs[id][i] = glGetUniformLocation(prog_id, name);\n            }\n         }\n      } else\n         sprog->const_locs[id] = NULL;\n   }\n\n   if (!vrend_state.have_vertex_attrib_binding) {\n      if (vs->sel->sinfo.num_inputs) {\n         sprog->attrib_locs = calloc(vs->sel->sinfo.num_inputs, sizeof(uint32_t));\n         if (sprog->attrib_locs) {\n            for (i = 0; i < vs->sel->sinfo.num_inputs; i++) {\n               snprintf(name, 10, \"in_%d\", i);\n               sprog->attrib_locs[i] = glGetAttribLocation(prog_id, name);\n            }\n         }\n      } else\n         sprog->attrib_locs = NULL;\n   }\n\n   for (id = PIPE_SHADER_VERTEX; id <= last_shader; id++) {\n      if (sprog->ss[id]->sel->sinfo.num_ubos) {\n         const char *prefix = pipe_shader_to_prefix(id);\n\n         sprog->ubo_locs[id] = calloc(sprog->ss[id]->sel->sinfo.num_ubos, sizeof(uint32_t));\n         for (i = 0; i < sprog->ss[id]->sel->sinfo.num_ubos; i++) {\n            snprintf(name, 16, \"%subo%d\", prefix, i + 1);\n            sprog->ubo_locs[id][i] = glGetUniformBlockIndex(prog_id, name);\n         }\n      } else\n         sprog->ubo_locs[id] = NULL;\n   }\n\n   if (vs->sel->sinfo.num_ucp) {\n      for (i = 0; i < vs->sel->sinfo.num_ucp; i++) {\n         snprintf(name, 10, \"clipp[%d]\", i);\n         sprog->clip_locs[i] = glGetUniformLocation(prog_id, name);\n      }\n   }\n   return sprog;\n}", "target": 1, "idx": 10634}
{"commit_id": "05bbd147caccc60162d6fba9baaaf24befa281cd", "project": "rizinorg/rizin", "func": "LuacBinInfo *luac_build_info(LuaProto *proto) {\n\tif (!proto) {\n\t\tRZ_LOG_ERROR(\"Invalid luac file\\n\");\n\t\treturn NULL;\n\t}\n\n\tLuacBinInfo *ret = RZ_NEW0(LuacBinInfo);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\n\tret->entry_list = rz_list_newf((RzListFree)free_rz_addr);\n\tret->symbol_list = rz_list_newf((RzListFree)rz_bin_symbol_free);\n\tret->section_list = rz_list_newf((RzListFree)free_rz_section);\n\tret->string_list = rz_list_newf((RzListFree)free_rz_string);\n\n\tif (!(ret->entry_list && ret->symbol_list && ret->section_list && ret->string_list)) {\n\t\trz_list_free(ret->entry_list);\n\t\trz_list_free(ret->symbol_list);\n\t\trz_list_free(ret->section_list);\n\t\trz_list_free(ret->string_list);\n\t}\n\n\t_luac_build_info(proto, ret);\n\n\t// add entry of main\n\tut64 main_entry_offset;\n\tmain_entry_offset = proto->code_offset + proto->code_skipped;\n\tluac_add_entry(ret->entry_list, main_entry_offset, RZ_BIN_ENTRY_TYPE_PROGRAM);\n\n\treturn ret;\n}", "target": 2, "idx": 10635}
{"commit_id": "e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3", "project": "torvalds/linux", "func": "static ssize_t qib_write(struct file *fp, const char __user *data,\n\t\t\t size_t count, loff_t *off)\n{\n\tconst struct qib_cmd __user *ucmd;\n\tstruct qib_ctxtdata *rcd;\n\tconst void __user *src;\n\tsize_t consumed, copy = 0;\n\tstruct qib_cmd cmd;\n\tssize_t ret = 0;\n\tvoid *dest;\n\n\tif (WARN_ON_ONCE(!ib_safe_file_access(fp)))\n\t\treturn -EACCES;\n\n\tif (count < sizeof(cmd.type)) {\n\t\tret = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tucmd = (const struct qib_cmd __user *) data;\n\n\tif (copy_from_user(&cmd.type, &ucmd->type, sizeof(cmd.type))) {\n\t\tret = -EFAULT;\n\t\tgoto bail;\n\t}\n\n\tconsumed = sizeof(cmd.type);\n\n\tswitch (cmd.type) {\n\tcase QIB_CMD_ASSIGN_CTXT:\n\tcase QIB_CMD_USER_INIT:\n\t\tcopy = sizeof(cmd.cmd.user_info);\n\t\tdest = &cmd.cmd.user_info;\n\t\tsrc = &ucmd->cmd.user_info;\n\t\tbreak;\n\n\tcase QIB_CMD_RECV_CTRL:\n\t\tcopy = sizeof(cmd.cmd.recv_ctrl);\n\t\tdest = &cmd.cmd.recv_ctrl;\n\t\tsrc = &ucmd->cmd.recv_ctrl;\n\t\tbreak;\n\n\tcase QIB_CMD_CTXT_INFO:\n\t\tcopy = sizeof(cmd.cmd.ctxt_info);\n\t\tdest = &cmd.cmd.ctxt_info;\n\t\tsrc = &ucmd->cmd.ctxt_info;\n\t\tbreak;\n\n\tcase QIB_CMD_TID_UPDATE:\n\tcase QIB_CMD_TID_FREE:\n\t\tcopy = sizeof(cmd.cmd.tid_info);\n\t\tdest = &cmd.cmd.tid_info;\n\t\tsrc = &ucmd->cmd.tid_info;\n\t\tbreak;\n\n\tcase QIB_CMD_SET_PART_KEY:\n\t\tcopy = sizeof(cmd.cmd.part_key);\n\t\tdest = &cmd.cmd.part_key;\n\t\tsrc = &ucmd->cmd.part_key;\n\t\tbreak;\n\n\tcase QIB_CMD_DISARM_BUFS:\n\tcase QIB_CMD_PIOAVAILUPD: /* force an update of PIOAvail reg */\n\t\tcopy = 0;\n\t\tsrc = NULL;\n\t\tdest = NULL;\n\t\tbreak;\n\n\tcase QIB_CMD_POLL_TYPE:\n\t\tcopy = sizeof(cmd.cmd.poll_type);\n\t\tdest = &cmd.cmd.poll_type;\n\t\tsrc = &ucmd->cmd.poll_type;\n\t\tbreak;\n\n\tcase QIB_CMD_ARMLAUNCH_CTRL:\n\t\tcopy = sizeof(cmd.cmd.armlaunch_ctrl);\n\t\tdest = &cmd.cmd.armlaunch_ctrl;\n\t\tsrc = &ucmd->cmd.armlaunch_ctrl;\n\t\tbreak;\n\n\tcase QIB_CMD_SDMA_INFLIGHT:\n\t\tcopy = sizeof(cmd.cmd.sdma_inflight);\n\t\tdest = &cmd.cmd.sdma_inflight;\n\t\tsrc = &ucmd->cmd.sdma_inflight;\n\t\tbreak;\n\n\tcase QIB_CMD_SDMA_COMPLETE:\n\t\tcopy = sizeof(cmd.cmd.sdma_complete);\n\t\tdest = &cmd.cmd.sdma_complete;\n\t\tsrc = &ucmd->cmd.sdma_complete;\n\t\tbreak;\n\n\tcase QIB_CMD_ACK_EVENT:\n\t\tcopy = sizeof(cmd.cmd.event_mask);\n\t\tdest = &cmd.cmd.event_mask;\n\t\tsrc = &ucmd->cmd.event_mask;\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tif (copy) {\n\t\tif ((count - consumed) < copy) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto bail;\n\t\t}\n\t\tif (copy_from_user(dest, src, copy)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto bail;\n\t\t}\n\t\tconsumed += copy;\n\t}\n\n\trcd = ctxt_fp(fp);\n\tif (!rcd && cmd.type != QIB_CMD_ASSIGN_CTXT) {\n\t\tret = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tswitch (cmd.type) {\n\tcase QIB_CMD_ASSIGN_CTXT:\n\t\tret = qib_assign_ctxt(fp, &cmd.cmd.user_info);\n\t\tif (ret)\n\t\t\tgoto bail;\n\t\tbreak;\n\n\tcase QIB_CMD_USER_INIT:\n\t\tret = qib_do_user_init(fp, &cmd.cmd.user_info);\n\t\tif (ret)\n\t\t\tgoto bail;\n\t\tret = qib_get_base_info(fp, (void __user *) (unsigned long)\n\t\t\t\t\tcmd.cmd.user_info.spu_base_info,\n\t\t\t\t\tcmd.cmd.user_info.spu_base_info_size);\n\t\tbreak;\n\n\tcase QIB_CMD_RECV_CTRL:\n\t\tret = qib_manage_rcvq(rcd, subctxt_fp(fp), cmd.cmd.recv_ctrl);\n\t\tbreak;\n\n\tcase QIB_CMD_CTXT_INFO:\n\t\tret = qib_ctxt_info(fp, (struct qib_ctxt_info __user *)\n\t\t\t\t    (unsigned long) cmd.cmd.ctxt_info);\n\t\tbreak;\n\n\tcase QIB_CMD_TID_UPDATE:\n\t\tret = qib_tid_update(rcd, fp, &cmd.cmd.tid_info);\n\t\tbreak;\n\n\tcase QIB_CMD_TID_FREE:\n\t\tret = qib_tid_free(rcd, subctxt_fp(fp), &cmd.cmd.tid_info);\n\t\tbreak;\n\n\tcase QIB_CMD_SET_PART_KEY:\n\t\tret = qib_set_part_key(rcd, cmd.cmd.part_key);\n\t\tbreak;\n\n\tcase QIB_CMD_DISARM_BUFS:\n\t\t(void)qib_disarm_piobufs_ifneeded(rcd);\n\t\tret = disarm_req_delay(rcd);\n\t\tbreak;\n\n\tcase QIB_CMD_PIOAVAILUPD:\n\t\tqib_force_pio_avail_update(rcd->dd);\n\t\tbreak;\n\n\tcase QIB_CMD_POLL_TYPE:\n\t\trcd->poll_type = cmd.cmd.poll_type;\n\t\tbreak;\n\n\tcase QIB_CMD_ARMLAUNCH_CTRL:\n\t\trcd->dd->f_set_armlaunch(rcd->dd, cmd.cmd.armlaunch_ctrl);\n\t\tbreak;\n\n\tcase QIB_CMD_SDMA_INFLIGHT:\n\t\tret = qib_sdma_get_inflight(user_sdma_queue_fp(fp),\n\t\t\t\t\t    (u32 __user *) (unsigned long)\n\t\t\t\t\t    cmd.cmd.sdma_inflight);\n\t\tbreak;\n\n\tcase QIB_CMD_SDMA_COMPLETE:\n\t\tret = qib_sdma_get_complete(rcd->ppd,\n\t\t\t\t\t    user_sdma_queue_fp(fp),\n\t\t\t\t\t    (u32 __user *) (unsigned long)\n\t\t\t\t\t    cmd.cmd.sdma_complete);\n\t\tbreak;\n\n\tcase QIB_CMD_ACK_EVENT:\n\t\tret = qib_user_event_ack(rcd, subctxt_fp(fp),\n\t\t\t\t\t cmd.cmd.event_mask);\n\t\tbreak;\n\t}\n\n\tif (ret >= 0)\n\t\tret = consumed;\n\nbail:\n\treturn ret;\n}", "target": 2, "idx": 10636}
{"commit_id": "a282a2f10539dce2aa619e71e1817570d557fc97", "project": "torvalds/linux", "func": "static int decode_preamble(void *p, struct ceph_frame_desc *desc)\n{\n\tvoid *crcp = p + CEPH_PREAMBLE_LEN - CEPH_CRC_LEN;\n\tu32 crc, expected_crc;\n\tint i;\n\n\tcrc = crc32c(0, p, crcp - p);\n\texpected_crc = get_unaligned_le32(crcp);\n\tif (crc != expected_crc) {\n\t\tpr_err(\"bad preamble crc, calculated %u, expected %u\\n\",\n\t\t       crc, expected_crc);\n\t\treturn -EBADMSG;\n\t}\n\n\tmemset(desc, 0, sizeof(*desc));\n\n\tdesc->fd_tag = ceph_decode_8(&p);\n\tdesc->fd_seg_cnt = ceph_decode_8(&p);\n\tif (desc->fd_seg_cnt < 1 ||\n\t    desc->fd_seg_cnt > CEPH_FRAME_MAX_SEGMENT_COUNT) {\n\t\tpr_err(\"bad segment count %d\\n\", desc->fd_seg_cnt);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < desc->fd_seg_cnt; i++) {\n\t\tdesc->fd_lens[i] = ceph_decode_32(&p);\n\t\tdesc->fd_aligns[i] = ceph_decode_16(&p);\n\t}\n\n\tif (desc->fd_lens[0] < 0 ||\n\t    desc->fd_lens[0] > CEPH_MSG_MAX_CONTROL_LEN) {\n\t\tpr_err(\"bad control segment length %d\\n\", desc->fd_lens[0]);\n\t\treturn -EINVAL;\n\t}\n\tif (desc->fd_lens[1] < 0 ||\n\t    desc->fd_lens[1] > CEPH_MSG_MAX_FRONT_LEN) {\n\t\tpr_err(\"bad front segment length %d\\n\", desc->fd_lens[1]);\n\t\treturn -EINVAL;\n\t}\n\tif (desc->fd_lens[2] < 0 ||\n\t    desc->fd_lens[2] > CEPH_MSG_MAX_MIDDLE_LEN) {\n\t\tpr_err(\"bad middle segment length %d\\n\", desc->fd_lens[2]);\n\t\treturn -EINVAL;\n\t}\n\tif (desc->fd_lens[3] < 0 ||\n\t    desc->fd_lens[3] > CEPH_MSG_MAX_DATA_LEN) {\n\t\tpr_err(\"bad data segment length %d\\n\", desc->fd_lens[3]);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * This would fire for FRAME_TAG_WAIT (it has one empty\n\t * segment), but we should never get it as client.\n\t */\n\tif (!desc->fd_lens[desc->fd_seg_cnt - 1]) {\n\t\tpr_err(\"last segment empty, segment count %d\\n\",\n\t\t       desc->fd_seg_cnt);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "target": 2, "idx": 10637}
{"commit_id": "d15d662e89fc667b90cd294b0eb45694e33144da", "project": "torvalds/linux", "func": "static ssize_t snd_seq_write(struct file *file, const char __user *buf,\n\t\t\t     size_t count, loff_t *offset)\n{\n\tstruct snd_seq_client *client = file->private_data;\n\tint written = 0, len;\n\tint err;\n\tstruct snd_seq_event event;\n\n\tif (!(snd_seq_file_flags(file) & SNDRV_SEQ_LFLG_OUTPUT))\n\t\treturn -ENXIO;\n\n\t/* check client structures are in place */\n\tif (snd_BUG_ON(!client))\n\t\treturn -ENXIO;\n\t\t\n\tif (!client->accept_output || client->pool == NULL)\n\t\treturn -ENXIO;\n\n\t/* allocate the pool now if the pool is not allocated yet */ \n\tif (client->pool->size > 0 && !snd_seq_write_pool_allocated(client)) {\n\t\tmutex_lock(&client->ioctl_mutex);\n\t\terr = snd_seq_pool_init(client->pool);\n\t\tmutex_unlock(&client->ioctl_mutex);\n\t\tif (err < 0)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* only process whole events */\n\terr = -EINVAL;\n\twhile (count >= sizeof(struct snd_seq_event)) {\n\t\t/* Read in the event header from the user */\n\t\tlen = sizeof(event);\n\t\tif (copy_from_user(&event, buf, len)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tevent.source.client = client->number;\t/* fill in client number */\n\t\t/* Check for extension data length */\n\t\tif (check_event_type_and_length(&event)) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* check for special events */\n\t\tif (event.type == SNDRV_SEQ_EVENT_NONE)\n\t\t\tgoto __skip_event;\n\t\telse if (snd_seq_ev_is_reserved(&event)) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (snd_seq_ev_is_variable(&event)) {\n\t\t\tint extlen = event.data.ext.len & ~SNDRV_SEQ_EXT_MASK;\n\t\t\tif ((size_t)(extlen + len) > count) {\n\t\t\t\t/* back out, will get an error this time or next */\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* set user space pointer */\n\t\t\tevent.data.ext.len = extlen | SNDRV_SEQ_EXT_USRPTR;\n\t\t\tevent.data.ext.ptr = (char __force *)buf\n\t\t\t\t\t\t+ sizeof(struct snd_seq_event);\n\t\t\tlen += extlen; /* increment data length */\n\t\t} else {\n#ifdef CONFIG_COMPAT\n\t\t\tif (client->convert32 && snd_seq_ev_is_varusr(&event)) {\n\t\t\t\tvoid *ptr = (void __force *)compat_ptr(event.data.raw32.d[1]);\n\t\t\t\tevent.data.ext.ptr = ptr;\n\t\t\t}\n#endif\n\t\t}\n\n\t\t/* ok, enqueue it */\n\t\terr = snd_seq_client_enqueue_event(client, &event, file,\n\t\t\t\t\t\t   !(file->f_flags & O_NONBLOCK),\n\t\t\t\t\t\t   0, 0);\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t__skip_event:\n\t\t/* Update pointers and counts */\n\t\tcount -= len;\n\t\tbuf += len;\n\t\twritten += len;\n\t}\n\n\treturn written ? written : err;\n}", "target": 2, "idx": 10638}
{"commit_id": "672d882a53f96730e4ef1e5b1639c585823b0df8", "project": "wireshark", "func": "tvbuff_t *\ntvb_uncompress(tvbuff_t *tvb, const int offset, int comprlen)\n{\n\tgint       err;\n\tguint      bytes_out      = 0;\n\tguint8    *compr;\n\tguint8    *uncompr        = NULL;\n\ttvbuff_t  *uncompr_tvb    = NULL;\n\tz_streamp  strm;\n\tBytef     *strmbuf;\n\tguint      inits_done     = 0;\n\tgint       wbits          = MAX_WBITS;\n\tguint8    *next;\n\tguint      bufsiz;\n#ifdef TVB_Z_DEBUG\n\tguint      inflate_passes = 0;\n\tguint      bytes_in       = tvb_captured_length_remaining(tvb, offset);\n#endif\n\n\tif (tvb == NULL || comprlen <= 0) {\n\t\treturn NULL;\n\t}\n\n\tcompr = (guint8 *)g_malloc(comprlen);\n\ttvb_memcpy(tvb, compr, offset, comprlen);\n\n\tif (!compr)\n\t\treturn NULL;\n\n\t/*\n\t * Assume that the uncompressed data is at least twice as big as\n\t * the compressed size.\n\t */\n\tbufsiz = tvb_captured_length_remaining(tvb, offset) * 2;\n\tbufsiz = CLAMP(bufsiz, TVB_Z_MIN_BUFSIZ, TVB_Z_MAX_BUFSIZ);\n\n#ifdef TVB_Z_DEBUG\n\tprintf(\"bufsiz: %u bytes\\n\", bufsiz);\n#endif\n\n\tnext = compr;\n\n\tstrm            = g_new0(z_stream, 1);\n\tstrm->next_in   = next;\n\tstrm->avail_in  = comprlen;\n\n\tstrmbuf         = (Bytef *)g_malloc0(bufsiz);\n\tstrm->next_out  = strmbuf;\n\tstrm->avail_out = bufsiz;\n\n\terr = inflateInit2(strm, wbits);\n\tinits_done = 1;\n\tif (err != Z_OK) {\n\t\tinflateEnd(strm);\n\t\tg_free(strm);\n\t\tg_free(compr);\n\t\tg_free(strmbuf);\n\t\treturn NULL;\n\t}\n\n\twhile (1) {\n\t\tmemset(strmbuf, '\\0', bufsiz);\n\t\tstrm->next_out  = strmbuf;\n\t\tstrm->avail_out = bufsiz;\n\n\t\terr = inflate(strm, Z_SYNC_FLUSH);\n\n\t\tif (err == Z_OK || err == Z_STREAM_END) {\n\t\t\tguint bytes_pass = bufsiz - strm->avail_out;\n\n#ifdef TVB_Z_DEBUG\n\t\t\t++inflate_passes;\n#endif\n\n\t\t\tif (uncompr == NULL) {\n\t\t\t\t/*\n\t\t\t\t * This is ugly workaround for bug #6480\n\t\t\t\t * (https://bugs.wireshark.org/bugzilla/show_bug.cgi?id=6480)\n\t\t\t\t *\n\t\t\t\t * g_memdup(..., 0) returns NULL (g_malloc(0) also)\n\t\t\t\t * when uncompr is NULL logic below doesn't create tvb\n\t\t\t\t * which is later interpreted as decompression failed.\n\t\t\t\t */\n\t\t\t\tuncompr = (guint8 *)((bytes_pass || err != Z_STREAM_END) ?\n\t\t\t\t\t\tg_memdup(strmbuf, bytes_pass) :\n\t\t\t\t\t\tg_strdup(\"\"));\n\t\t\t} else {\n\t\t\t\tguint8 *new_data = (guint8 *)g_malloc0(bytes_out + bytes_pass);\n\n\t\t\t\tmemcpy(new_data, uncompr, bytes_out);\n\t\t\t\tmemcpy(new_data + bytes_out, strmbuf, bytes_pass);\n\n\t\t\t\tg_free(uncompr);\n\t\t\t\tuncompr = new_data;\n\t\t\t}\n\n\t\t\tbytes_out += bytes_pass;\n\n\t\t\tif (err == Z_STREAM_END) {\n\t\t\t\tinflateEnd(strm);\n\t\t\t\tg_free(strm);\n\t\t\t\tg_free(strmbuf);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (err == Z_BUF_ERROR) {\n\t\t\t/*\n\t\t\t * It's possible that not enough frames were captured\n\t\t\t * to decompress this fully, so return what we've done\n\t\t\t * so far, if any.\n\t\t\t */\n\t\t\tinflateEnd(strm);\n\t\t\tg_free(strm);\n\t\t\tg_free(strmbuf);\n\n\t\t\tif (uncompr != NULL) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tg_free(compr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t} else if (err == Z_DATA_ERROR && inits_done == 1\n\t\t\t&& uncompr == NULL && comprlen >= 2 &&\n\t\t\t(*compr  == 0x1f) && (*(compr + 1) == 0x8b)) {\n\t\t\t/*\n\t\t\t * inflate() is supposed to handle both gzip and deflate\n\t\t\t * streams automatically, but in reality it doesn't\n\t\t\t * seem to handle either (at least not within the\n\t\t\t * context of an HTTP response.)  We have to try\n\t\t\t * several tweaks, depending on the type of data and\n\t\t\t * version of the library installed.\n\t\t\t */\n\n\t\t\t/*\n\t\t\t * Gzip file format.  Skip past the header, since the\n\t\t\t * fix to make it work (setting windowBits to 31)\n\t\t\t * doesn't work with all versions of the library.\n\t\t\t */\n\t\t\tBytef *c = compr + 2;\n\t\t\tBytef  flags = 0;\n\n\t\t\t/* we read two bytes already (0x1f, 0x8b) and\n\t\t\t   need at least Z_DEFLATED, 1 byte flags, 4\n\t\t\t   bytes MTIME, 1 byte XFL, 1 byte OS */\n\t\t\tif (comprlen < 10 || *c != Z_DEFLATED) {\n\t\t\t\tinflateEnd(strm);\n\t\t\t\tg_free(strm);\n\t\t\t\tg_free(compr);\n\t\t\t\tg_free(strmbuf);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tc++;\n\t\t\tflags = *c;\n\t\t\tc++;\n\n\t\t\t/* Skip past the MTIME (4 bytes),\n\t\t\t   XFL, and OS fields (1 byte each). */\n\t\t\tc += 6;\n\n\t\t\tif (flags & (1 << 2)) {\n\t\t\t\t/* An Extra field is present. It\n\t\t\t\t   consists of 2 bytes xsize and xsize\n\t\t\t\t   bytes of data.\n\t\t\t\t   Read byte-by-byte (least significant\n\t\t\t\t   byte first) to make sure we abort\n\t\t\t\t   cleanly when the xsize is truncated\n\t\t\t\t   after the first byte. */\n\t\t\t\tguint16 xsize = 0;\n\n\t\t\t\tif (c-compr < comprlen) {\n\t\t\t\t\txsize += *c;\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t\tif (c-compr < comprlen) {\n\t\t\t\t\txsize += *c << 8;\n\t\t\t\t\tc++;\n\t\t\t\t}\n\n\t\t\t\tc += xsize;\n\t\t\t}\n\n\t\t\tif (flags & (1 << 3)) {\n\t\t\t\t/* A null terminated filename */\n\n\t\t\t\twhile ((c - compr) < comprlen && *c != '\\0') {\n\t\t\t\t\tc++;\n\t\t\t\t}\n\n\t\t\t\tc++;\n\t\t\t}\n\n\t\t\tif (flags & (1 << 4)) {\n\t\t\t\t/* A null terminated comment */\n\n\t\t\t\twhile ((c - compr) < comprlen && *c != '\\0') {\n\t\t\t\t\tc++;\n\t\t\t\t}\n\n\t\t\t\tc++;\n\t\t\t}\n\n\n\t\t\tif (c - compr > comprlen) {\n\t\t\t\tinflateEnd(strm);\n\t\t\t\tg_free(strm);\n\t\t\t\tg_free(compr);\n\t\t\t\tg_free(strmbuf);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\t/* Drop gzip header */\n\t\t\tcomprlen -= (int) (c - compr);\n\t\t\tnext = c;\n\n\t\t\tinflateReset(strm);\n\t\t\tstrm->next_in   = next;\n\t\t\tstrm->avail_in  = comprlen;\n\n\t\t\tinflateEnd(strm);\n\t\t\tinflateInit2(strm, wbits);\n\t\t\tinits_done++;\n\t\t} else if (err == Z_DATA_ERROR && uncompr == NULL &&\n\t\t\tinits_done <= 3) {\n\n\t\t\t/*\n\t\t\t * Re-init the stream with a negative\n\t\t\t * MAX_WBITS. This is necessary due to\n\t\t\t * some servers (Apache) not sending\n\t\t\t * the deflate header with the\n\t\t\t * content-encoded response.\n\t\t\t */\n\t\t\twbits = -MAX_WBITS;\n\n\t\t\tinflateReset(strm);\n\n\t\t\tstrm->next_in   = next;\n\t\t\tstrm->avail_in  = comprlen;\n\n\t\t\tinflateEnd(strm);\n\t\t\tmemset(strmbuf, '\\0', bufsiz);\n\t\t\tstrm->next_out  = strmbuf;\n\t\t\tstrm->avail_out = bufsiz;\n\n\t\t\terr = inflateInit2(strm, wbits);\n\n\t\t\tinits_done++;\n\n\t\t\tif (err != Z_OK) {\n\t\t\t\tg_free(strm);\n\t\t\t\tg_free(strmbuf);\n\t\t\t\tg_free(compr);\n\t\t\t\tg_free(uncompr);\n\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tinflateEnd(strm);\n\t\t\tg_free(strm);\n\t\t\tg_free(strmbuf);\n\n\t\t\tif (uncompr == NULL) {\n\t\t\t\tg_free(compr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n#ifdef TVB_Z_DEBUG\n\tprintf(\"inflate() total passes: %u\\n\", inflate_passes);\n\tprintf(\"bytes  in: %u\\nbytes out: %u\\n\\n\", bytes_in, bytes_out);\n#endif\n\n\tif (uncompr != NULL) {\n\t\tuncompr_tvb =  tvb_new_real_data((guint8*) uncompr, bytes_out, bytes_out);\n\t\ttvb_set_free_cb(uncompr_tvb, g_free);\n\t}\n\tg_free(compr);\n\treturn uncompr_tvb;\n}", "target": 2, "idx": 10639}
{"commit_id": "04f5866e41fb70690e28397487d8bd8eea7d712a", "project": "torvalds/linux", "func": "static int userfaultfd_release(struct inode *inode, struct file *file)\n{\n\tstruct userfaultfd_ctx *ctx = file->private_data;\n\tstruct mm_struct *mm = ctx->mm;\n\tstruct vm_area_struct *vma, *prev;\n\t/* len == 0 means wake all */\n\tstruct userfaultfd_wake_range range = { .len = 0, };\n\tunsigned long new_flags;\n\n\tWRITE_ONCE(ctx->released, true);\n\n\tif (!mmget_not_zero(mm))\n\t\tgoto wakeup;\n\n\t/*\n\t * Flush page faults out of all CPUs. NOTE: all page faults\n\t * must be retried without returning VM_FAULT_SIGBUS if\n\t * userfaultfd_ctx_get() succeeds but vma->vma_userfault_ctx\n\t * changes while handle_userfault released the mmap_sem. So\n\t * it's critical that released is set to true (above), before\n\t * taking the mmap_sem for writing.\n\t */\n\tdown_write(&mm->mmap_sem);\n\tif (!mmget_still_valid(mm))\n\t\tgoto skip_mm;\n\tprev = NULL;\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tcond_resched();\n\t\tBUG_ON(!!vma->vm_userfaultfd_ctx.ctx ^\n\t\t       !!(vma->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));\n\t\tif (vma->vm_userfaultfd_ctx.ctx != ctx) {\n\t\t\tprev = vma;\n\t\t\tcontinue;\n\t\t}\n\t\tnew_flags = vma->vm_flags & ~(VM_UFFD_MISSING | VM_UFFD_WP);\n\t\tprev = vma_merge(mm, prev, vma->vm_start, vma->vm_end,\n\t\t\t\t new_flags, vma->anon_vma,\n\t\t\t\t vma->vm_file, vma->vm_pgoff,\n\t\t\t\t vma_policy(vma),\n\t\t\t\t NULL_VM_UFFD_CTX);\n\t\tif (prev)\n\t\t\tvma = prev;\n\t\telse\n\t\t\tprev = vma;\n\t\tvma->vm_flags = new_flags;\n\t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n\t}\nskip_mm:\n\tup_write(&mm->mmap_sem);\n\tmmput(mm);\nwakeup:\n\t/*\n\t * After no new page faults can wait on this fault_*wqh, flush\n\t * the last page faults that may have been already waiting on\n\t * the fault_*wqh.\n\t */\n\tspin_lock(&ctx->fault_pending_wqh.lock);\n\t__wake_up_locked_key(&ctx->fault_pending_wqh, TASK_NORMAL, &range);\n\t__wake_up(&ctx->fault_wqh, TASK_NORMAL, 1, &range);\n\tspin_unlock(&ctx->fault_pending_wqh.lock);\n\n\t/* Flush pending events that may still wait on event_wqh */\n\twake_up_all(&ctx->event_wqh);\n\n\twake_up_poll(&ctx->fd_wqh, EPOLLHUP);\n\tuserfaultfd_ctx_put(ctx);\n\treturn 0;\n}", "target": 2, "idx": 10640}
{"commit_id": "b2e668c08414c421718f73366c6c2222684eb828", "project": "bytecodealliance/wasm-micro-runtime", "func": "static bool\nwasm_loader_push_pop_frame_ref_offset(WASMLoaderContext *ctx, uint8 pop_cnt,\n                                      uint8 type_push, uint8 type_pop,\n                                      bool disable_emit, int16 operand_offset,\n                                      char *error_buf, uint32 error_buf_size)\n{\n    uint8 i;\n\n    for (i = 0; i < pop_cnt; i++) {\n        if (!wasm_loader_pop_frame_offset(ctx, type_pop, error_buf,\n                                          error_buf_size))\n            return false;\n\n        if (!wasm_loader_pop_frame_ref(ctx, type_pop, error_buf,\n                                       error_buf_size))\n            return false;\n    }\n\n    if (!wasm_loader_push_frame_offset(ctx, type_push, disable_emit,\n                                       operand_offset, error_buf,\n                                       error_buf_size))\n        return false;\n\n    if (!wasm_loader_push_frame_ref(ctx, type_push, error_buf, error_buf_size))\n        return false;\n\n    return true;\n}", "target": 1, "idx": 10641}
{"commit_id": "8c29f1607a31dac0911e45a0dd3d74173822b3c9", "project": "xorg/lib/libX11", "func": "char **\nXListFonts(\nregister Display *dpy,\n_Xconst char *pattern,  /* null-terminated */\nint maxNames,\nint *actualCount)\t/* RETURN */\n{\n    register long nbytes;\n    register unsigned i;\n    register int length;\n    char **flist = NULL;\n    char *ch = NULL;\n    char *chend;\n    int count = 0;\n    xListFontsReply rep;\n    register xListFontsReq *req;\n    unsigned long rlen = 0;\n\n    LockDisplay(dpy);\n    GetReq(ListFonts, req);\n    req->maxNames = maxNames;\n    nbytes = req->nbytes = pattern ? strlen (pattern) : 0;\n    req->length += (nbytes + 3) >> 2;\n    _XSend (dpy, pattern, nbytes);\n    /* use _XSend instead of Data, since following _XReply will flush buffer */\n\n    if (!_XReply (dpy, (xReply *)&rep, 0, xFalse)) {\n\t*actualCount = 0;\n\tUnlockDisplay(dpy);\n\tSyncHandle();\n\treturn (char **) NULL;\n    }\n\n    if (rep.nFonts) {\n\tflist = Xmalloc (rep.nFonts * sizeof(char *));\n\tif (rep.length > 0 && rep.length < (INT_MAX >> 2)) {\n\t    rlen = rep.length << 2;\n\t    ch = Xmalloc(rlen + 1);\n\t    /* +1 to leave room for last null-terminator */\n\t}\n\n\tif ((! flist) || (! ch)) {\n\t    Xfree(flist);\n\t    Xfree(ch);\n\t    _XEatDataWords(dpy, rep.length);\n\t    *actualCount = 0;\n\t    UnlockDisplay(dpy);\n\t    SyncHandle();\n\t    return (char **) NULL;\n\t}\n\n\t_XReadPad (dpy, ch, rlen);\n\t/*\n\t * unpack into null terminated strings.\n\t */\n\tchend = ch + (rlen + 1);\n\tlength = *(unsigned char *)ch;\n\t*ch = 1; /* make sure it is non-zero for XFreeFontNames */\n\tfor (i = 0; i < rep.nFonts; i++) {\n\t    if (ch + length < chend) {\n\t\tflist[i] = ch + 1;  /* skip over length */\n\t\tch += length + 1;  /* find next length ... */\n\t\tif (ch <= chend) {\n\t\t    length = *(unsigned char *)ch;\n\t\t    *ch = '\\0';  /* and replace with null-termination */\n\t\t    count++;\n\t\t} else {\n                    Xfree(flist);\n                    flist = NULL;\n                    count = 0;\n                    break;\n\t\t}\n\t    } else {\n                Xfree(flist);\n                flist = NULL;\n                count = 0;\n                break;\n            }\n\t}\n    }\n    *actualCount = count;\n    UnlockDisplay(dpy);\n    SyncHandle();\n    return (flist);\n}", "target": 3, "idx": 10642}
{"commit_id": "e9e44f797742f52996ebf307740dad58c28fd9b5", "project": "android", "func": "int validate_camera_metadata_structure(const camera_metadata_t *metadata,\n                                       const size_t *expected_size) {\n\n    if (metadata == NULL) {\n        ALOGE(\"%s: metadata is null!\", __FUNCTION__);\n        return ERROR;\n    }\n\n    // Check that the metadata pointer is well-aligned first.\n    {\n        static const struct {\n            const char *name;\n            size_t alignment;\n        } alignments[] = {\n            {\n                .name = \"camera_metadata\",\n                .alignment = METADATA_ALIGNMENT\n            },\n            {\n                .name = \"camera_metadata_buffer_entry\",\n                .alignment = ENTRY_ALIGNMENT\n            },\n            {\n                .name = \"camera_metadata_data\",\n                .alignment = DATA_ALIGNMENT\n            },\n        };\n\n        for (size_t i = 0; i < sizeof(alignments)/sizeof(alignments[0]); ++i) {\n            uintptr_t aligned_ptr = ALIGN_TO(metadata, alignments[i].alignment);\n\n            if ((uintptr_t)metadata != aligned_ptr) {\n                ALOGE(\"%s: Metadata pointer is not aligned (actual %p, \"\n                      \"expected %p) to type %s\",\n                      __FUNCTION__, metadata,\n                      (void*)aligned_ptr, alignments[i].name);\n                return ERROR;\n            }\n        }\n    }\n\n    /**\n     * Check that the metadata contents are correct\n     */\n\n    if (expected_size != NULL && metadata->size > *expected_size) {\n        ALOGE(\"%s: Metadata size (%\" PRIu32 \") should be <= expected size (%zu)\",\n              __FUNCTION__, metadata->size, *expected_size);\n        return ERROR;\n    }\n\n    if (metadata->entry_count > metadata->entry_capacity) {\n        ALOGE(\"%s: Entry count (%\" PRIu32 \") should be <= entry capacity \"\n              \"(%\" PRIu32 \")\",\n              __FUNCTION__, metadata->entry_count, metadata->entry_capacity);\n        return ERROR;\n    }\n\n    if (metadata->data_count > metadata->data_capacity) {\n        ALOGE(\"%s: Data count (%\" PRIu32 \") should be <= data capacity \"\n              \"(%\" PRIu32 \")\",\n              __FUNCTION__, metadata->data_count, metadata->data_capacity);\n        android_errorWriteLog(SN_EVENT_LOG_ID, \"30591838\");\n        return ERROR;\n    }\n\n    const metadata_uptrdiff_t entries_end = metadata->entries_start + metadata->entry_capacity;\n    if (entries_end < metadata->entries_start || // overflow check\n        entries_end > metadata->data_start) {\n\n        ALOGE(\"%s: Entry start + capacity (%\" PRIu32 \") should be <= data start \"\n              \"(%\" PRIu32 \")\",\n               __FUNCTION__,\n              (metadata->entries_start + metadata->entry_capacity),\n              metadata->data_start);\n        return ERROR;\n    }\n\n    const metadata_uptrdiff_t data_end =\n        metadata->data_start + metadata->data_capacity;\n    if (data_end < metadata->data_start || // overflow check\n        data_end > metadata->size) {\n\n        ALOGE(\"%s: Data start + capacity (%\" PRIu32 \") should be <= total size \"\n              \"(%\" PRIu32 \")\",\n               __FUNCTION__,\n              (metadata->data_start + metadata->data_capacity),\n              metadata->size);\n        return ERROR;\n    }\n\n    // Validate each entry\n    const metadata_size_t entry_count = metadata->entry_count;\n    camera_metadata_buffer_entry_t *entries = get_entries(metadata);\n\n    for (size_t i = 0; i < entry_count; ++i) {\n\n        if ((uintptr_t)&entries[i] != ALIGN_TO(&entries[i], ENTRY_ALIGNMENT)) {\n            ALOGE(\"%s: Entry index %zu had bad alignment (address %p),\"\n                  \" expected alignment %zu\",\n                  __FUNCTION__, i, &entries[i], ENTRY_ALIGNMENT);\n            return ERROR;\n        }\n\n        camera_metadata_buffer_entry_t entry = entries[i];\n\n        if (entry.type >= NUM_TYPES) {\n            ALOGE(\"%s: Entry index %zu had a bad type %d\",\n                  __FUNCTION__, i, entry.type);\n            return ERROR;\n        }\n\n        // TODO: fix vendor_tag_ops across processes so we don't need to special\n        //       case vendor-specific tags\n        uint32_t tag_section = entry.tag >> 16;\n        int tag_type = get_camera_metadata_tag_type(entry.tag);\n        if (tag_type != (int)entry.type && tag_section < VENDOR_SECTION) {\n            ALOGE(\"%s: Entry index %zu had tag type %d, but the type was %d\",\n                  __FUNCTION__, i, tag_type, entry.type);\n            return ERROR;\n        }\n\n        size_t data_size;\n        if (validate_and_calculate_camera_metadata_entry_data_size(&data_size, entry.type,\n                entry.count) != OK) {\n            ALOGE(\"%s: Entry data size is invalid. type: %u count: %u\", __FUNCTION__, entry.type,\n                    entry.count);\n            return ERROR;\n        }\n\n        if (data_size != 0) {\n            camera_metadata_data_t *data =\n                    (camera_metadata_data_t*) (get_data(metadata) +\n                                               entry.data.offset);\n\n            if ((uintptr_t)data != ALIGN_TO(data, DATA_ALIGNMENT)) {\n                ALOGE(\"%s: Entry index %zu had bad data alignment (address %p),\"\n                      \" expected align %zu, (tag name %s, data size %zu)\",\n                      __FUNCTION__, i, data, DATA_ALIGNMENT,\n                      get_camera_metadata_tag_name(entry.tag) ?: \"unknown\",\n                      data_size);\n                return ERROR;\n            }\n\n            size_t data_entry_end = entry.data.offset + data_size;\n            if (data_entry_end < entry.data.offset || // overflow check\n                data_entry_end > metadata->data_capacity) {\n\n                ALOGE(\"%s: Entry index %zu data ends (%zu) beyond the capacity \"\n                      \"%\" PRIu32, __FUNCTION__, i, data_entry_end,\n                      metadata->data_capacity);\n                return ERROR;\n            }\n\n        } else if (entry.count == 0) {\n            if (entry.data.offset != 0) {\n                ALOGE(\"%s: Entry index %zu had 0 items, but offset was non-0 \"\n                     \"(%\" PRIu32 \"), tag name: %s\", __FUNCTION__, i, entry.data.offset,\n                        get_camera_metadata_tag_name(entry.tag) ?: \"unknown\");\n                return ERROR;\n            }\n        } // else data stored inline, so we look at value which can be anything.\n    }\n\n    return OK;\n}", "target": 2, "idx": 10643}
{"commit_id": "77dd114513d7796e1e2b8aece214a380af26fbf4", "project": "tensorflow", "func": "void Compute(OpKernelContext* context) override {\n    // Checks what we're remapping and inverts the relevant remapping Tensors to\n    // be maps with key = old ID, value = new ID.\n    std::unordered_map<int64, int64> old_row_to_new_row_map;\n    std::vector<bool> row_id_present;\n    const Tensor* row_remapping_t;\n    OP_REQUIRES_OK(context, context->input(\"row_remapping\", &row_remapping_t));\n    const auto row_remapping = row_remapping_t->vec<int64>();\n    OP_REQUIRES(context, row_remapping.size() == num_rows_,\n                errors::InvalidArgument(strings::StrCat(\n                    \"Size of row_remapping is \", row_remapping.size(),\n                    \" instead of being equal to num_rows=\", num_rows_)));\n    OP_REQUIRES_OK(context, RemapVectorToMap(row_remapping, &row_id_present,\n                                             &old_row_to_new_row_map));\n\n    // Calculates the min/max old row ID that we need to read, to save us from\n    // reading some unnecessary slices of the old tensor.\n    int64 min_old_row = -1;\n    int64 max_old_row = -1;\n    for (int i = 0; i < row_remapping.size(); ++i) {\n      if (min_old_row < 0 ||\n          (row_remapping(i) >= 0 && row_remapping(i) < min_old_row)) {\n        min_old_row = row_remapping(i);\n      }\n      if (max_old_row < 0 ||\n          (row_remapping(i) >= 0 && row_remapping(i) > max_old_row)) {\n        max_old_row = row_remapping(i);\n      }\n    }\n\n    // Processes the remapping for columns.\n    std::unordered_map<int64, int64> old_col_to_new_col_map;\n    std::vector<bool> col_id_present;\n    const Tensor* col_remapping_t;\n    OP_REQUIRES_OK(context, context->input(\"col_remapping\", &col_remapping_t));\n    const auto col_remapping = col_remapping_t->vec<int64>();\n    // Note that we always \"remap rows\", even when the row vocabulary does\n    // not change, because partitioning requires a mapping from partitioned\n    // Variables to the full checkpoints we load.\n    const bool remap_cols = col_remapping.size() > 0;\n    if (remap_cols) {\n      OP_REQUIRES(\n          context, col_remapping.size() == num_cols_,\n          errors::InvalidArgument(strings::StrCat(\n              \"Provided col_remapping, but its size is \", col_remapping.size(),\n              \" instead of being equal to num_cols=\", num_cols_)));\n      OP_REQUIRES_OK(context, RemapVectorToMap(col_remapping, &col_id_present,\n                                               &old_col_to_new_col_map));\n    } else {\n      col_id_present.clear();\n      col_id_present.resize(num_cols_, true);\n    }\n\n    // Processes the checkpoint source and the provided Tensor name.\n    const Tensor* ckpt_path_t;\n    OP_REQUIRES_OK(context, context->input(\"ckpt_path\", &ckpt_path_t));\n    OP_REQUIRES(\n        context, ckpt_path_t->NumElements() == 1,\n        errors::InvalidArgument(\"The `ckpt_path` tensor must have exactly one \"\n                                \"element, got tensor of shape \",\n                                ckpt_path_t->shape().DebugString()));\n    const string& ckpt_path = ckpt_path_t->scalar<tstring>()();\n    const Tensor* old_tensor_name_t;\n    OP_REQUIRES_OK(context,\n                   context->input(\"old_tensor_name\", &old_tensor_name_t));\n    const string& old_tensor_name = old_tensor_name_t->scalar<tstring>()();\n\n    LOG(INFO) << \"Processing checkpoint : \" << ckpt_path;\n    BundleReader reader(context->env(), ckpt_path);\n    OP_REQUIRES_OK(context, reader.status());\n\n    DataType tensor_type;\n    TensorShape tensor_shape;\n    OP_REQUIRES_OK(context, reader.LookupDtypeAndShape(\n                                old_tensor_name, &tensor_type, &tensor_shape));\n    OP_REQUIRES(context, tensor_type == DT_FLOAT,\n                errors::InvalidArgument(strings::StrCat(\n                    \"Tensor \", old_tensor_name, \" has invalid type \",\n                    DataTypeString(tensor_type), \" instead of expected type \",\n                    DataTypeString(DT_FLOAT))));\n    // This op is limited to loading Tensors of rank 2 (matrices).\n    OP_REQUIRES(\n        context, tensor_shape.dims() == 2,\n        errors::InvalidArgument(strings::StrCat(\n            \"Tensor \", old_tensor_name, \" has shape \",\n            tensor_shape.DebugString(), \" of invalid rank \",\n            tensor_shape.dims(), \" instead of expected shape of rank 2.\")));\n\n    if (!remap_cols) {\n      // TODO(weiho): Consider relaxing this restriction to allow partial column\n      // loading (even when no column remapping is specified) if there turns out\n      // to be a use case for it.\n      OP_REQUIRES(context, num_cols_ == tensor_shape.dim_size(1),\n                  errors::InvalidArgument(strings::StrCat(\n                      \"Tensor \", old_tensor_name, \" has shape \",\n                      tensor_shape.DebugString(),\n                      \", where the size of its 2nd dimension is \",\n                      tensor_shape.dim_size(1),\n                      \" instead of being equal to num_cols=\", num_cols_)));\n    }\n\n    // Uses TensorSlice to potentially load the old tensor in chunks in case\n    // memory usage is a concern.\n    std::vector<TensorSlice> tensor_slices;\n    TensorSlice slice(tensor_shape.dims());\n    if (min_old_row >= 0 && max_old_row >= 0) {\n      int64 row_start = min_old_row;\n      // TODO(weiho): Given the list of old row IDs of interest (the keys of\n      // old_row_to_new_row_map), we could also try something smarter to\n      // find some minimal set of covering ranges for the list of old row IDs\n      // such that the size of each range is less than max_rows_in_memory_.\n      while (row_start <= max_old_row) {\n        const int64 slice_length =\n            max_rows_in_memory_ <= 0\n                // If max_rows_in_memory_ <= 0, we just load the entire chunk.\n                ? max_old_row - row_start + 1\n                : std::min(max_rows_in_memory_, max_old_row - row_start + 1);\n        slice.set_start(0, row_start);\n        slice.set_length(0, slice_length);\n        tensor_slices.push_back(slice);\n        row_start += slice_length;\n      }\n    }\n\n    // Allocates the output matrix.\n    Tensor* output_matrix_t = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(\"output_matrix\",\n                                            TensorShape({num_rows_, num_cols_}),\n                                            &output_matrix_t));\n    auto output_matrix = output_matrix_t->matrix<float>();\n\n    // Iterates through tensor slices and copies over values from the old tensor\n    // to the output matrix.\n    int64 row_index = min_old_row;\n    int64 rows_copied = 0;\n    Tensor loaded_tensor_t;\n    for (const TensorSlice& tensor_slice : tensor_slices) {\n      LOG(INFO) << \"Loading slice \" << tensor_slice.DebugString();\n      TensorShape slice_shape;\n      OP_REQUIRES_OK(context,\n                     tensor_slice.SliceTensorShape(tensor_shape, &slice_shape));\n      // Potentially re-allocates the tensor buffer since the last slice may\n      // have fewer rows than the other slices.\n      if (loaded_tensor_t.shape() != slice_shape) {\n        loaded_tensor_t = Tensor(DT_FLOAT, slice_shape);\n      }\n      OP_REQUIRES_OK(context, reader.LookupSlice(old_tensor_name, tensor_slice,\n                                                 &loaded_tensor_t));\n\n      // Iterates through the old loaded tensor slice row-by-row.\n      for (int row = 0; row < loaded_tensor_t.dim_size(0); ++row, ++row_index) {\n        if (row_index % 500000 == min_old_row) {\n          LOG(INFO) << \"Processing old row \" << row_index;\n        }\n\n        // If the old row ID is not found in old_row_to_new_row_map, continue\n        // to the next row; otherwise, copy it to the output matrix.\n        const int64* new_row_ptr =\n            gtl::FindOrNull(old_row_to_new_row_map, row_index);\n        if (new_row_ptr == nullptr) {\n          continue;\n        }\n        ++rows_copied;\n        const int64 new_row = *new_row_ptr;\n\n        // Copies over the row element-by-element, in case remapping is needed\n        // along the column axis.\n        const auto& loaded_tensor = loaded_tensor_t.matrix<float>();\n        for (int old_col = 0; old_col < loaded_tensor_t.dim_size(1);\n             ++old_col) {\n          int64 new_col = old_col;\n          if (remap_cols) {\n            const int64* new_col_ptr =\n                gtl::FindOrNull(old_col_to_new_col_map, old_col);\n            if (new_col_ptr == nullptr) {\n              // Column remapping is specified, but this column is not found in\n              // old_col_to_new_col_map, so we leave it uninitialized, to be\n              // filled in with initializing_values later.\n              continue;\n            }\n            new_col = *new_col_ptr;\n          }\n\n          OP_REQUIRES(context,\n                      new_row < num_rows_ && new_col < num_cols_ &&\n                          new_row >= 0 && new_col >= 0,\n                      errors::Internal(strings::StrCat(\n                          \"new_row=\", new_row, \" and new_col=\", new_col,\n                          \" should have been less than num_rows_=\", num_rows_,\n                          \" and num_cols_=\", num_cols_,\n                          \" and non-negative. This should never have happened \"\n                          \"if the code were correct. Please file a bug.\")));\n          output_matrix(new_row, new_col) = loaded_tensor(row, old_col);\n        }\n      }\n    }\n    LOG(INFO) << \"Copied \" << rows_copied << \" rows from old matrix (with \"\n              << tensor_shape.dim_size(0) << \" rows) to new matrix (with \"\n              << num_rows_ << \" rows).\";\n\n    // At this point, there are potentially whole rows/columns uninitialized\n    // (corresponding to the indices where row_id_present/col_id_present are\n    // false). We fill this in cell-by-cell using row_id_present and\n    // col_id_present while dequeuing from the initializing_values vector.\n    const Tensor* initializing_values_t;\n    OP_REQUIRES_OK(\n        context, context->input(\"initializing_values\", &initializing_values_t));\n    const auto initializing_values = initializing_values_t->flat<float>();\n    int64 initializing_values_index = 0;\n    for (int i = 0; i < num_rows_; ++i) {\n      for (int j = 0; j < num_cols_; ++j) {\n        if (row_id_present[i] && col_id_present[j]) continue;\n        OP_REQUIRES(\n            context, initializing_values_index < initializing_values.size(),\n            errors::InvalidArgument(\n                \"initializing_values contained \", initializing_values.size(),\n                \" elements, but more missing values remain.\"));\n        output_matrix(i, j) = initializing_values(initializing_values_index);\n        ++initializing_values_index;\n      }\n    }\n\n    // Checks that we used all the given initializing values.\n    OP_REQUIRES(\n        context, initializing_values_index == initializing_values.size(),\n        errors::InvalidArgument(\n            \"initializing_values contained \", initializing_values.size(),\n            \" elements, but only \", initializing_values_index,\n            \" elements were used to fill in missing values.\"));\n  }", "target": 0, "idx": 10644}
{"commit_id": "f22593b82b5d1668d1997dbccd10a9c31ffea3b3", "project": "fribidi", "func": "FriBidiStrIndex\nfribidi_cap_rtl_to_unicode (\n  /* input */\n  const char *s,\n  FriBidiStrIndex len,\n  /* output */\n  FriBidiChar *us\n)\n{\n  FriBidiStrIndex i, j;\n\n  if (!caprtl_to_unicode)\n    init_cap_rtl ();\n\n  j = 0;\n  for (i = 0; i < len; i++)\n    {\n      char ch;\n\n      ch = s[i];\n      if (ch == '_')\n\t{\n\t  switch (ch = s[++i])\n\t    {\n\t    case '>':\n\t      us[j++] = FRIBIDI_CHAR_LRM;\n\t      break;\n\t    case '<':\n\t      us[j++] = FRIBIDI_CHAR_RLM;\n\t      break;\n\t    case 'l':\n\t      us[j++] = FRIBIDI_CHAR_LRE;\n\t      break;\n\t    case 'r':\n\t      us[j++] = FRIBIDI_CHAR_RLE;\n\t      break;\n\t    case 'o':\n\t      us[j++] = FRIBIDI_CHAR_PDF;\n\t      break;\n\t    case 'L':\n\t      us[j++] = FRIBIDI_CHAR_LRO;\n\t      break;\n\t    case 'R':\n\t      us[j++] = FRIBIDI_CHAR_RLO;\n\t      break;\n            case 'i':\n              us[j++] = FRIBIDI_CHAR_LRI;\n\t      break;\n            case 'y':\n              us[j++] = FRIBIDI_CHAR_RLI;\n\t      break;\n            case 'f':\n              us[j++] = FRIBIDI_CHAR_FSI;\n\t      break;\n            case 'I':\n              us[j++] = FRIBIDI_CHAR_PDI;\n\t      break;\n\t    case '_':\n\t      us[j++] = '_';\n\t      break;\n\t    default:\n\t      us[j++] = '_';\n\t      i--;\n\t      break;\n\t    }\n\t}\n      else\n      {\n        if ((int)s[i] < 0)\n          us[j++] = '?';\n        else\n          us[j++] = caprtl_to_unicode[(int) s[i]];\n      }\n    }\n\n  return j;\n}", "target": 1, "idx": 10645}
{"commit_id": "dad48e73127ba10279ea33e6dbc8d3905c4d31c0", "project": "torvalds/linux", "func": "bool f2fs_init_extent_tree(struct inode *inode, struct f2fs_extent *i_ext)\n{\n\tbool ret =  __f2fs_init_extent_tree(inode, i_ext);\n\n\tif (!F2FS_I(inode)->extent_tree)\n\t\tset_inode_flag(inode, FI_NO_EXTENT);\n\n\treturn ret;\n}", "target": 1, "idx": 10646}
{"commit_id": "2ee0cab11f6626071f8a64c7792406dabdd94c8d", "project": "torvalds/linux", "func": "static bool io_identity_cow(struct io_kiocb *req)\n{\n\tstruct io_uring_task *tctx = req->task->io_uring;\n\tconst struct cred *creds = NULL;\n\tstruct io_identity *id;\n\n\tif (req->work.flags & IO_WQ_WORK_CREDS)\n\t\tcreds = req->work.identity->creds;\n\n\tid = kmemdup(req->work.identity, sizeof(*id), GFP_KERNEL);\n\tif (unlikely(!id)) {\n\t\treq->work.flags |= IO_WQ_WORK_CANCEL;\n\t\treturn false;\n\t}\n\n\t/*\n\t * We can safely just re-init the creds we copied  Either the field\n\t * matches the current one, or we haven't grabbed it yet. The only\n\t * exception is ->creds, through registered personalities, so handle\n\t * that one separately.\n\t */\n\tio_init_identity(id);\n\tif (creds)\n\t\tid->creds = creds;\n\n\t/* add one for this request */\n\trefcount_inc(&id->count);\n\n\t/* drop tctx and req identity references, if needed */\n\tif (tctx->identity != &tctx->__identity &&\n\t    refcount_dec_and_test(&tctx->identity->count))\n\t\tkfree(tctx->identity);\n\tif (req->work.identity != &tctx->__identity &&\n\t    refcount_dec_and_test(&req->work.identity->count))\n\t\tkfree(req->work.identity);\n\n\treq->work.identity = id;\n\ttctx->identity = id;\n\treturn true;\n}", "target": 1, "idx": 10647}
{"commit_id": "598c8c88c97fd2eb5f6f5d1324fc325e66317f0c", "project": "saitoha/libsixel", "func": "static SIXELSTATUS\ngif_load_next(\n    gif_context_t /* in */ *s,\n    gif_t         /* in */ *g,\n    unsigned char /* in */ *bgcolor\n)\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    unsigned char buffer[256];\n    int x;\n    int y;\n    int w;\n    int h;\n    int len;\n\n    for (;;) {\n        switch (gif_get8(s)) {\n        case 0x2C:  /* Image Separator (1 byte) */\n            x = gif_get16le(s);  /* Image Left Position (2 bytes)*/\n            y = gif_get16le(s);  /* Image Top Position (2 bytes) */\n            w = gif_get16le(s);  /* Image Width (2 bytes) */\n            h = gif_get16le(s);  /* Image Height (2 bytes) */\n            if (x >= g->w || y >= g->h || x + w > g->w || y + h > g->h) {\n                sixel_helper_set_additional_message(\n                    \"corrupt GIF (reason: bad Image Separator).\");\n                status = SIXEL_RUNTIME_ERROR;\n                goto end;\n            }\n\n            g->line_size = g->w;\n            g->start_x = x;\n            g->start_y = y;\n            g->max_x   = g->start_x + w;\n            g->max_y   = g->start_y + h;\n            g->cur_x   = g->start_x;\n            g->cur_y   = g->start_y;\n            g->actual_width   = g->start_x;\n            g->actual_height   = g->start_y;\n\n            /* Packed Fields (1 byte)\n             * +-+-+-+--+---+\n             * | | | |  |   |\n             * +-+-+-+--+---+\n             *  | | |  |  |\n             *  | | |  |  +- Size of Local Color Table (3 bits)\n             *  | | |  +- Reserved (2 bits)\n             *  | | +- Sort Flag (1 bit)\n             *  | +- Interlace Flag (1 bit)\n             *  +- Local Color Table Flag (1 bit)\n             */\n            g->lflags = gif_get8(s);\n\n            /* Interlace Flag */\n            if (g->lflags & 0x40) {\n                g->step = 8; /* first interlaced spacing */\n                g->parse = 3;\n            } else {\n                g->step = 1;\n                g->parse = 0;\n            }\n\n            /* Local Color Table Flag */\n            if (g->lflags & 0x80) {\n                gif_parse_colortable(s,\n                                     g->lpal,\n                                     2 << (g->lflags & 7));\n                g->color_table = (unsigned char *) g->lpal;\n            } else if (g->flags & 0x80) {\n                if (g->transparent >= 0 && (g->eflags & 0x01)) {\n                   if (bgcolor) {\n                       g->pal[g->transparent][0] = bgcolor[2];\n                       g->pal[g->transparent][1] = bgcolor[1];\n                       g->pal[g->transparent][2] = bgcolor[0];\n                   }\n                }\n                g->color_table = (unsigned char *)g->pal;\n            } else {\n                sixel_helper_set_additional_message(\n                    \"corrupt GIF (reason: missing color table).\");\n                status = SIXEL_RUNTIME_ERROR;\n                goto end;\n            }\n\n            status = gif_process_raster(s, g);\n            if (SIXEL_FAILED(status)) {\n                goto end;\n            }\n            goto end;\n\n        case 0x21:  /* Comment Extension. */\n            switch (gif_get8(s)) {\n            case 0x01:  /* Plain Text Extension */\n                break;\n            case 0x21:  /* Comment Extension */\n                break;\n            case 0xF9:  /* Graphic Control Extension */\n                len = gif_get8(s); /* block size */\n                if (len == 4) {\n                    g->eflags = gif_get8(s);\n                    g->delay = gif_get16le(s); /* delay */\n                    g->transparent = gif_get8(s);\n                } else {\n                    s->img_buffer += len;\n                    break;\n                }\n                break;\n            case 0xFF:  /* Application Extension */\n                len = gif_get8(s);  /* block size */\n                if (s->img_buffer + len > s->img_buffer_end) {\n                    status = SIXEL_RUNTIME_ERROR;\n                    goto end;\n                }\n                memcpy(buffer, s->img_buffer, (size_t)len);\n                s->img_buffer += len;\n                buffer[len] = 0;\n                if (len == 11 && strcmp((char *)buffer, \"NETSCAPE2.0\") == 0) {\n                    if (gif_get8(s) == 0x03) {\n                        /* loop count */\n                        switch (gif_get8(s)) {\n                        case 0x00:\n                            g->loop_count = 1;\n                            break;\n                        case 0x01:\n                            g->loop_count = gif_get16le(s);\n                            break;\n                        default:\n                            g->loop_count = 1;\n                            break;\n                        }\n                    }\n                }\n                break;\n            default:\n                break;\n            }\n            while ((len = gif_get8(s)) != 0) {\n                s->img_buffer += len;\n            }\n            break;\n\n        case 0x3B:  /* gif stream termination code */\n            g->is_terminated = 1;\n            status = SIXEL_OK;\n            goto end;\n\n        default:\n            sixel_helper_set_additional_message(\n                \"corrupt GIF (reason: unknown code).\");\n            status = SIXEL_RUNTIME_ERROR;\n            goto end;\n        }\n    }\n\n    status = SIXEL_OK;\n\nend:\n    return status;\n}", "target": 2, "idx": 10648}
{"commit_id": "c6688ef9f29762e65bce325ef4acd6c675806366", "project": "torvalds/linux", "func": "static void stub_recv_cmd_submit(struct stub_device *sdev,\n\t\t\t\t struct usbip_header *pdu)\n{\n\tint ret;\n\tstruct stub_priv *priv;\n\tstruct usbip_device *ud = &sdev->ud;\n\tstruct usb_device *udev = sdev->udev;\n\tint pipe = get_pipe(sdev, pdu);\n\n\tif (pipe == -1)\n\t\treturn;\n\n\tpriv = stub_priv_alloc(sdev, pdu);\n\tif (!priv)\n\t\treturn;\n\n\t/* setup a urb */\n\tif (usb_pipeisoc(pipe))\n\t\tpriv->urb = usb_alloc_urb(pdu->u.cmd_submit.number_of_packets,\n\t\t\t\t\t  GFP_KERNEL);\n\telse\n\t\tpriv->urb = usb_alloc_urb(0, GFP_KERNEL);\n\n\tif (!priv->urb) {\n\t\tusbip_event_add(ud, SDEV_EVENT_ERROR_MALLOC);\n\t\treturn;\n\t}\n\n\t/* allocate urb transfer buffer, if needed */\n\tif (pdu->u.cmd_submit.transfer_buffer_length > 0 &&\n\t    pdu->u.cmd_submit.transfer_buffer_length <= INT_MAX) {\n\t\tpriv->urb->transfer_buffer =\n\t\t\tkzalloc(pdu->u.cmd_submit.transfer_buffer_length,\n\t\t\t\tGFP_KERNEL);\n\t\tif (!priv->urb->transfer_buffer) {\n\t\t\tusbip_event_add(ud, SDEV_EVENT_ERROR_MALLOC);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* copy urb setup packet */\n\tpriv->urb->setup_packet = kmemdup(&pdu->u.cmd_submit.setup, 8,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!priv->urb->setup_packet) {\n\t\tdev_err(&udev->dev, \"allocate setup_packet\\n\");\n\t\tusbip_event_add(ud, SDEV_EVENT_ERROR_MALLOC);\n\t\treturn;\n\t}\n\n\t/* set other members from the base header of pdu */\n\tpriv->urb->context                = (void *) priv;\n\tpriv->urb->dev                    = udev;\n\tpriv->urb->pipe                   = pipe;\n\tpriv->urb->complete               = stub_complete;\n\n\tusbip_pack_pdu(pdu, priv->urb, USBIP_CMD_SUBMIT, 0);\n\n\n\tif (usbip_recv_xbuff(ud, priv->urb) < 0)\n\t\treturn;\n\n\tif (usbip_recv_iso(ud, priv->urb) < 0)\n\t\treturn;\n\n\t/* no need to submit an intercepted request, but harmless? */\n\ttweak_special_requests(priv->urb);\n\n\tmasking_bogus_flags(priv->urb);\n\t/* urb is now ready to submit */\n\tret = usb_submit_urb(priv->urb, GFP_KERNEL);\n\n\tif (ret == 0)\n\t\tusbip_dbg_stub_rx(\"submit urb ok, seqnum %u\\n\",\n\t\t\t\t  pdu->base.seqnum);\n\telse {\n\t\tdev_err(&udev->dev, \"submit_urb error, %d\\n\", ret);\n\t\tusbip_dump_header(pdu);\n\t\tusbip_dump_urb(priv->urb);\n\n\t\t/*\n\t\t * Pessimistic.\n\t\t * This connection will be discarded.\n\t\t */\n\t\tusbip_event_add(ud, SDEV_EVENT_ERROR_SUBMIT);\n\t}\n\n\tusbip_dbg_stub_rx(\"Leave\\n\");\n}", "target": 1, "idx": 10649}
{"commit_id": "4f1b083be43f351bc107541e7b0c9655a5d2c0bb", "project": "vim", "func": "static void\nqf_fill_buffer(qf_list_T *qfl, buf_T *buf, qfline_T *old_last, int qf_winid)\n{\n    linenr_T\tlnum;\n    qfline_T\t*qfp;\n    int\t\told_KeyTyped = KeyTyped;\n    list_T\t*qftf_list = NULL;\n    listitem_T\t*qftf_li = NULL;\n\n    if (old_last == NULL)\n    {\n\tif (buf != curbuf)\n\t{\n\t    internal_error(\"qf_fill_buffer()\");\n\t    return;\n\t}\n\n\t// delete all existing lines\n\twhile ((curbuf->b_ml.ml_flags & ML_EMPTY) == 0)\n\t    (void)ml_delete((linenr_T)1);\n    }\n\n    // Check if there is anything to display\n    if (qfl != NULL && qfl->qf_start != NULL)\n    {\n\tchar_u\t\tdirname[MAXPATHL];\n\tint\t\tinvalid_val = FALSE;\n\tint\t\tprev_bufnr = -1;\n\n\t*dirname = NUL;\n\n\t// Add one line for each error\n\tif (old_last == NULL)\n\t{\n\t    qfp = qfl->qf_start;\n\t    lnum = 0;\n\t}\n\telse\n\t{\n\t    if (old_last->qf_next != NULL)\n\t\tqfp = old_last->qf_next;\n\t    else\n\t\tqfp = old_last;\n\t    lnum = buf->b_ml.ml_line_count;\n\t}\n\n\tqftf_list = call_qftf_func(qfl, qf_winid, (long)(lnum + 1),\n\t\t\t\t\t\t\t(long)qfl->qf_count);\n\tif (qftf_list != NULL)\n\t    qftf_li = qftf_list->lv_first;\n\n\twhile (lnum < qfl->qf_count)\n\t{\n\t    char_u\t*qftf_str = NULL;\n\n\t    // Use the text supplied by the user defined function (if any).\n\t    // If the returned value is not string, then ignore the rest\n\t    // of the returned values and use the default.\n\t    if (qftf_li != NULL && !invalid_val)\n\t    {\n\t\tqftf_str = tv_get_string_chk(&qftf_li->li_tv);\n\t\tif (qftf_str == NULL)\n\t\t    invalid_val = TRUE;\n\t    }\n\n\t    if (qf_buf_add_line(buf, lnum, qfp, dirname,\n\t\t\tprev_bufnr != qfp->qf_fnum, qftf_str) == FAIL)\n\t\tbreak;\n\n\t    prev_bufnr = qfp->qf_fnum;\n\t    ++lnum;\n\t    qfp = qfp->qf_next;\n\t    if (qfp == NULL)\n\t\tbreak;\n\n\t    if (qftf_li != NULL)\n\t\tqftf_li = qftf_li->li_next;\n\t}\n\n\tif (old_last == NULL)\n\t    // Delete the empty line which is now at the end\n\t    (void)ml_delete(lnum + 1);\n    }\n\n    // correct cursor position\n    check_lnums(TRUE);\n\n    if (old_last == NULL)\n    {\n\t// Set the 'filetype' to \"qf\" each time after filling the buffer.\n\t// This resembles reading a file into a buffer, it's more logical when\n\t// using autocommands.\n\t++curbuf_lock;\n\tset_option_value_give_err((char_u *)\"ft\",\n\t\t\t\t\t\t0L, (char_u *)\"qf\", OPT_LOCAL);\n\tcurbuf->b_p_ma = FALSE;\n\n\tkeep_filetype = TRUE;\t\t// don't detect 'filetype'\n\tapply_autocmds(EVENT_BUFREADPOST, (char_u *)\"quickfix\", NULL,\n\t\t\t\t\t\t\t       FALSE, curbuf);\n\tapply_autocmds(EVENT_BUFWINENTER, (char_u *)\"quickfix\", NULL,\n\t\t\t\t\t\t\t       FALSE, curbuf);\n\tkeep_filetype = FALSE;\n\t--curbuf_lock;\n\n\t// make sure it will be redrawn\n\tredraw_curbuf_later(UPD_NOT_VALID);\n    }\n\n    // Restore KeyTyped, setting 'filetype' may reset it.\n    KeyTyped = old_KeyTyped;\n}", "target": 2, "idx": 10650}
{"commit_id": "066878da4d4762a9b6cb169fdf353e804d735cfd", "project": "arendst/Tasmota", "func": "bool CRtspSession::ParseRtspRequest(char const * aRequest, unsigned aRequestSize)\n{\n    // char CmdName[RTSP_PARAM_STRING_MAX];\n    //char CurRequest[RTSP_BUFFER_SIZE]; // Note: we assume single threaded, this large buf we keep off of the tiny stack\n    unsigned CurRequestSize;\n\n    Init();\n    CurRequestSize = aRequestSize;\n    memcpy(CurRequest,aRequest,aRequestSize);\n\n    // check whether the request contains information about the RTP/RTCP UDP client ports (SETUP command)\n    char * ClientPortPtr;\n    char * TmpPtr;\n    char CP[128]; //static char CP[1024];\n    char * pCP;\n    int Length;\n\n\n    ClientPortPtr = strstr(CurRequest,\"client_port\");\n    if (ClientPortPtr != nullptr)\n    {\n        TmpPtr = strstr(ClientPortPtr,\"\\r\\n\");\n        if (TmpPtr != nullptr)\n        {\n            TmpPtr[0] = 0x00;\n            Length = strlen(ClientPortPtr);\n            if (Length > 128)\n            {\n                Length = 128;\n            }\n            strncpy(CP,ClientPortPtr, Length);\n            pCP = strstr(CP,\"=\");\n            if (pCP != nullptr)\n            {\n                pCP++;\n                strcpy(CP,pCP);\n                pCP = strstr(CP,\"-\");\n                if (pCP != nullptr)\n                {\n                    pCP[0] = 0x00;\n                    m_ClientRTPPort  = atoi(CP);\n                    m_ClientRTCPPort = m_ClientRTPPort + 1;\n                };\n            };\n        };\n    };\n\n    // Read everything up to the first space as the command name\n    bool parseSucceeded = false;\n    unsigned i;\n    for (i = 0; i < sizeof(CmdName)-1 && i < CurRequestSize; ++i)\n    {\n        char c = CurRequest[i];\n        if (c == ' ' || c == '\\t')\n        {\n            parseSucceeded = true;\n            break;\n        }\n        CmdName[i] = c;\n    }\n    CmdName[i] = '\\0';\n    if (!parseSucceeded) {\n        printf(\"failed to parse RTSP\\n\");\n        return false;\n    }\n\n    printf(\"RTSP received %s\\n\", CmdName);\n\n    // find out the command type\n    if (strstr(CmdName,\"OPTIONS\")   != nullptr) m_RtspCmdType = RTSP_OPTIONS; else\n    if (strstr(CmdName,\"DESCRIBE\")  != nullptr) m_RtspCmdType = RTSP_DESCRIBE; else\n    if (strstr(CmdName,\"SETUP\")     != nullptr) m_RtspCmdType = RTSP_SETUP; else\n    if (strstr(CmdName,\"PLAY\")      != nullptr) m_RtspCmdType = RTSP_PLAY; else\n    if (strstr(CmdName,\"TEARDOWN\")  != nullptr) m_RtspCmdType = RTSP_TEARDOWN;\n\n    // check whether the request contains transport information (UDP or TCP)\n    if (m_RtspCmdType == RTSP_SETUP)\n    {\n        TmpPtr = strstr(CurRequest,\"RTP/AVP/TCP\");\n        if (TmpPtr != nullptr) m_TcpTransport = true; else m_TcpTransport = false;\n    };\n\n    // Skip over the prefix of any \"rtsp://\" or \"rtsp:/\" URL that follows:\n    unsigned j = i+1;\n    while (j < CurRequestSize && (CurRequest[j] == ' ' || CurRequest[j] == '\\t')) ++j; // skip over any additional white space\n    for (; (int)j < (int)(CurRequestSize-8); ++j)\n    {\n        if ((CurRequest[j]   == 'r' || CurRequest[j]   == 'R')   &&\n            (CurRequest[j+1] == 't' || CurRequest[j+1] == 'T') &&\n            (CurRequest[j+2] == 's' || CurRequest[j+2] == 'S') &&\n            (CurRequest[j+3] == 'p' || CurRequest[j+3] == 'P') &&\n            CurRequest[j+4] == ':' && CurRequest[j+5] == '/')\n        {\n            j += 6;\n            if (CurRequest[j] == '/')\n            {   // This is a \"rtsp://\" URL; skip over the host:port part that follows:\n                ++j;\n                unsigned uidx = 0;\n                while (j < CurRequestSize && CurRequest[j] != '/' && CurRequest[j] != ' ' && uidx < sizeof(m_URLHostPort) - 1)\n                {   // extract the host:port part of the URL here\n                    m_URLHostPort[uidx] = CurRequest[j];\n                    uidx++;\n                    ++j;\n                };\n            }\n            else --j;\n            i = j;\n            break;\n        }\n    }\n\n    // Look for the URL suffix (before the following \"RTSP/\"):\n    parseSucceeded = false;\n    for (unsigned k = i+1; (int)k < (int)(CurRequestSize-5); ++k)\n    {\n        if (CurRequest[k]   == 'R'   && CurRequest[k+1] == 'T'   &&\n            CurRequest[k+2] == 'S'   && CurRequest[k+3] == 'P'   &&\n            CurRequest[k+4] == '/')\n        {\n            while (--k >= i && CurRequest[k] == ' ') {}\n            unsigned k1 = k;\n            while (k1 > i && CurRequest[k1] != '/') --k1;\n            if (k - k1 + 1 > sizeof(m_URLSuffix)) return false;\n            unsigned n = 0, k2 = k1+1;\n\n            while (k2 <= k) m_URLSuffix[n++] = CurRequest[k2++];\n            m_URLSuffix[n] = '\\0';\n\n            if (k1 - i > sizeof(m_URLPreSuffix)) return false;\n            n = 0; k2 = i + 1;\n            while (k2 <= k1 - 1) m_URLPreSuffix[n++] = CurRequest[k2++];\n            m_URLPreSuffix[n] = '\\0';\n            i = k + 7;\n            parseSucceeded = true;\n            break;\n        }\n    }\n    if (!parseSucceeded) return false;\n\n    // Look for \"CSeq:\", skip whitespace, then read everything up to the next \\r or \\n as 'CSeq':\n    parseSucceeded = false;\n    for (j = i; (int)j < (int)(CurRequestSize-5); ++j)\n    {\n        if (CurRequest[j]   == 'C' && CurRequest[j+1] == 'S' &&\n            CurRequest[j+2] == 'e' && CurRequest[j+3] == 'q' &&\n            CurRequest[j+4] == ':')\n        {\n            j += 5;\n            while (j < CurRequestSize && (CurRequest[j] ==  ' ' || CurRequest[j] == '\\t')) ++j;\n            unsigned n;\n            for (n = 0; n < sizeof(m_CSeq)-1 && j < CurRequestSize; ++n,++j)\n            {\n                char c = CurRequest[j];\n                if (c == '\\r' || c == '\\n')\n                {\n                    parseSucceeded = true;\n                    break;\n                }\n                m_CSeq[n] = c;\n            }\n            m_CSeq[n] = '\\0';\n            break;\n        }\n    }\n    if (!parseSucceeded) return false;\n\n    // Also: Look for \"Content-Length:\" (optional)\n    for (j = i; (int)j < (int)(CurRequestSize-15); ++j)\n    {\n        if (CurRequest[j]    == 'C'  && CurRequest[j+1]  == 'o'  &&\n            CurRequest[j+2]  == 'n'  && CurRequest[j+3]  == 't'  &&\n            CurRequest[j+4]  == 'e'  && CurRequest[j+5]  == 'n'  &&\n            CurRequest[j+6]  == 't'  && CurRequest[j+7]  == '-'  &&\n            (CurRequest[j+8] == 'L' || CurRequest[j+8]   == 'l') &&\n            CurRequest[j+9]  == 'e'  && CurRequest[j+10] == 'n' &&\n            CurRequest[j+11] == 'g' && CurRequest[j+12]  == 't' &&\n            CurRequest[j+13] == 'h' && CurRequest[j+14] == ':')\n        {\n            j += 15;\n            while (j < CurRequestSize && (CurRequest[j] ==  ' ' || CurRequest[j] == '\\t')) ++j;\n            unsigned num;\n            if (sscanf(&CurRequest[j], \"%u\", &num) == 1) m_ContentLength = num;\n        }\n    }\n    return true;\n}", "target": 3, "idx": 10651}
{"commit_id": "f0dce23475b5af5da6b17b97c1765271307734b6", "project": "qemu", "func": "static int dmg_open(BlockDriverState *bs, QDict *options, int flags,\n                    Error **errp)\n{\n    BDRVDMGState *s = bs->opaque;\n    uint64_t info_begin, info_end, last_in_offset, last_out_offset;\n    uint32_t count, tmp;\n    uint32_t max_compressed_size = 1, max_sectors_per_chunk = 1, i;\n    int64_t offset;\n    int ret;\n\n    bs->read_only = 1;\n    s->n_chunks = 0;\n    s->offsets = s->lengths = s->sectors = s->sectorcounts = NULL;\n\n    /* read offset of info blocks */\n    offset = bdrv_getlength(bs->file);\n    if (offset < 0) {\n        ret = offset;\n        goto fail;\n    }\n    offset -= 0x1d8;\n\n    ret = read_uint64(bs, offset, &info_begin);\n    if (ret < 0) {\n        goto fail;\n    } else if (info_begin == 0) {\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    ret = read_uint32(bs, info_begin, &tmp);\n    if (ret < 0) {\n        goto fail;\n    } else if (tmp != 0x100) {\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    ret = read_uint32(bs, info_begin + 4, &count);\n    if (ret < 0) {\n        goto fail;\n    } else if (count == 0) {\n        ret = -EINVAL;\n        goto fail;\n    }\n    info_end = info_begin + count;\n\n    offset = info_begin + 0x100;\n\n    /* read offsets */\n    last_in_offset = last_out_offset = 0;\n    while (offset < info_end) {\n        uint32_t type;\n\n        ret = read_uint32(bs, offset, &count);\n        if (ret < 0) {\n            goto fail;\n        } else if (count == 0) {\n            ret = -EINVAL;\n            goto fail;\n        }\n        offset += 4;\n\n        ret = read_uint32(bs, offset, &type);\n        if (ret < 0) {\n            goto fail;\n        }\n\n        if (type == 0x6d697368 && count >= 244) {\n            size_t new_size;\n            uint32_t chunk_count;\n\n            offset += 4;\n            offset += 200;\n\n            chunk_count = (count - 204) / 40;\n            new_size = sizeof(uint64_t) * (s->n_chunks + chunk_count);\n            s->types = g_realloc(s->types, new_size / 2);\n            s->offsets = g_realloc(s->offsets, new_size);\n            s->lengths = g_realloc(s->lengths, new_size);\n            s->sectors = g_realloc(s->sectors, new_size);\n            s->sectorcounts = g_realloc(s->sectorcounts, new_size);\n\n            for (i = s->n_chunks; i < s->n_chunks + chunk_count; i++) {\n                ret = read_uint32(bs, offset, &s->types[i]);\n                if (ret < 0) {\n                    goto fail;\n                }\n                offset += 4;\n                if (s->types[i] != 0x80000005 && s->types[i] != 1 &&\n                    s->types[i] != 2) {\n                    if (s->types[i] == 0xffffffff && i > 0) {\n                        last_in_offset = s->offsets[i - 1] + s->lengths[i - 1];\n                        last_out_offset = s->sectors[i - 1] +\n                                          s->sectorcounts[i - 1];\n                    }\n                    chunk_count--;\n                    i--;\n                    offset += 36;\n                    continue;\n                }\n                offset += 4;\n\n                ret = read_uint64(bs, offset, &s->sectors[i]);\n                if (ret < 0) {\n                    goto fail;\n                }\n                s->sectors[i] += last_out_offset;\n                offset += 8;\n\n                ret = read_uint64(bs, offset, &s->sectorcounts[i]);\n                if (ret < 0) {\n                    goto fail;\n                }\n                offset += 8;\n\n                if (s->sectorcounts[i] > DMG_SECTORCOUNTS_MAX) {\n                    error_report(\"sector count %\" PRIu64 \" for chunk %u is \"\n                                 \"larger than max (%u)\",\n                                 s->sectorcounts[i], i, DMG_SECTORCOUNTS_MAX);\n                    ret = -EINVAL;\n                    goto fail;\n                }\n\n                ret = read_uint64(bs, offset, &s->offsets[i]);\n                if (ret < 0) {\n                    goto fail;\n                }\n                s->offsets[i] += last_in_offset;\n                offset += 8;\n\n                ret = read_uint64(bs, offset, &s->lengths[i]);\n                if (ret < 0) {\n                    goto fail;\n                }\n                offset += 8;\n\n                if (s->lengths[i] > DMG_LENGTHS_MAX) {\n                    error_report(\"length %\" PRIu64 \" for chunk %u is larger \"\n                                 \"than max (%u)\",\n                                 s->lengths[i], i, DMG_LENGTHS_MAX);\n                    ret = -EINVAL;\n                    goto fail;\n                }\n\n                update_max_chunk_size(s, i, &max_compressed_size,\n                                      &max_sectors_per_chunk);\n            }\n            s->n_chunks += chunk_count;\n        }\n    }\n\n    /* initialize zlib engine */\n    s->compressed_chunk = g_malloc(max_compressed_size + 1);\n    s->uncompressed_chunk = g_malloc(512 * max_sectors_per_chunk);\n    if (inflateInit(&s->zstream) != Z_OK) {\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    s->current_chunk = s->n_chunks;\n\n    qemu_co_mutex_init(&s->lock);\n    return 0;\n\nfail:\n    g_free(s->types);\n    g_free(s->offsets);\n    g_free(s->lengths);\n    g_free(s->sectors);\n    g_free(s->sectorcounts);\n    g_free(s->compressed_chunk);\n    g_free(s->uncompressed_chunk);\n    return ret;\n}", "target": 2, "idx": 10652}
{"commit_id": "75ec1fdbb797a389e4fe4aaf2e15358a070dcc19", "project": "binutils-gdb", "func": "static bfd_boolean\nprocess_mips_specific (FILE * file)\n{\n  Elf_Internal_Dyn * entry;\n  Elf_Internal_Shdr *sect = NULL;\n  size_t liblist_offset = 0;\n  size_t liblistno = 0;\n  size_t conflictsno = 0;\n  size_t options_offset = 0;\n  size_t conflicts_offset = 0;\n  size_t pltrelsz = 0;\n  size_t pltrel = 0;\n  bfd_vma pltgot = 0;\n  bfd_vma mips_pltgot = 0;\n  bfd_vma jmprel = 0;\n  bfd_vma local_gotno = 0;\n  bfd_vma gotsym = 0;\n  bfd_vma symtabno = 0;\n  bfd_boolean res = TRUE;\n\n  if (! process_attributes (file, NULL, SHT_GNU_ATTRIBUTES, NULL,\n\t\t\t    display_mips_gnu_attribute))\n    res = FALSE;\n\n  sect = find_section (\".MIPS.abiflags\");\n\n  if (sect != NULL)\n    {\n      Elf_External_ABIFlags_v0 *abiflags_ext;\n      Elf_Internal_ABIFlags_v0 abiflags_in;\n\n      if (sizeof (Elf_External_ABIFlags_v0) != sect->sh_size)\n\t{\n\t  error (_(\"Corrupt MIPS ABI Flags section.\\n\"));\n\t  res = FALSE;\n\t}\n      else\n\t{\n\t  abiflags_ext = get_data (NULL, file, sect->sh_offset, 1,\n\t\t\t\t   sect->sh_size, _(\"MIPS ABI Flags section\"));\n\t  if (abiflags_ext)\n\t    {\n\t      abiflags_in.version = BYTE_GET (abiflags_ext->version);\n\t      abiflags_in.isa_level = BYTE_GET (abiflags_ext->isa_level);\n\t      abiflags_in.isa_rev = BYTE_GET (abiflags_ext->isa_rev);\n\t      abiflags_in.gpr_size = BYTE_GET (abiflags_ext->gpr_size);\n\t      abiflags_in.cpr1_size = BYTE_GET (abiflags_ext->cpr1_size);\n\t      abiflags_in.cpr2_size = BYTE_GET (abiflags_ext->cpr2_size);\n\t      abiflags_in.fp_abi = BYTE_GET (abiflags_ext->fp_abi);\n\t      abiflags_in.isa_ext = BYTE_GET (abiflags_ext->isa_ext);\n\t      abiflags_in.ases = BYTE_GET (abiflags_ext->ases);\n\t      abiflags_in.flags1 = BYTE_GET (abiflags_ext->flags1);\n\t      abiflags_in.flags2 = BYTE_GET (abiflags_ext->flags2);\n\n\t      printf (\"\\nMIPS ABI Flags Version: %d\\n\", abiflags_in.version);\n\t      printf (\"\\nISA: MIPS%d\", abiflags_in.isa_level);\n\t      if (abiflags_in.isa_rev > 1)\n\t\tprintf (\"r%d\", abiflags_in.isa_rev);\n\t      printf (\"\\nGPR size: %d\",\n\t\t      get_mips_reg_size (abiflags_in.gpr_size));\n\t      printf (\"\\nCPR1 size: %d\",\n\t\t      get_mips_reg_size (abiflags_in.cpr1_size));\n\t      printf (\"\\nCPR2 size: %d\",\n\t\t      get_mips_reg_size (abiflags_in.cpr2_size));\n\t      fputs (\"\\nFP ABI: \", stdout);\n\t      print_mips_fp_abi_value (abiflags_in.fp_abi);\n\t      fputs (\"ISA Extension: \", stdout);\n\t      print_mips_isa_ext (abiflags_in.isa_ext);\n\t      fputs (\"\\nASEs:\", stdout);\n\t      print_mips_ases (abiflags_in.ases);\n\t      printf (\"\\nFLAGS 1: %8.8lx\", abiflags_in.flags1);\n\t      printf (\"\\nFLAGS 2: %8.8lx\", abiflags_in.flags2);\n\t      fputc ('\\n', stdout);\n\t      free (abiflags_ext);\n\t    }\n\t}\n    }\n\n  /* We have a lot of special sections.  Thanks SGI!  */\n  if (dynamic_section == NULL)\n    /* No information available.  */\n    return res;\n\n  for (entry = dynamic_section;\n       /* PR 17531 file: 012-50589-0.004.  */\n       entry < dynamic_section + dynamic_nent && entry->d_tag != DT_NULL;\n       ++entry)\n    switch (entry->d_tag)\n      {\n      case DT_MIPS_LIBLIST:\n\tliblist_offset\n\t  = offset_from_vma (file, entry->d_un.d_val,\n\t\t\t     liblistno * sizeof (Elf32_External_Lib));\n\tbreak;\n      case DT_MIPS_LIBLISTNO:\n\tliblistno = entry->d_un.d_val;\n\tbreak;\n      case DT_MIPS_OPTIONS:\n\toptions_offset = offset_from_vma (file, entry->d_un.d_val, 0);\n\tbreak;\n      case DT_MIPS_CONFLICT:\n\tconflicts_offset\n\t  = offset_from_vma (file, entry->d_un.d_val,\n\t\t\t     conflictsno * sizeof (Elf32_External_Conflict));\n\tbreak;\n      case DT_MIPS_CONFLICTNO:\n\tconflictsno = entry->d_un.d_val;\n\tbreak;\n      case DT_PLTGOT:\n\tpltgot = entry->d_un.d_ptr;\n\tbreak;\n      case DT_MIPS_LOCAL_GOTNO:\n\tlocal_gotno = entry->d_un.d_val;\n\tbreak;\n      case DT_MIPS_GOTSYM:\n\tgotsym = entry->d_un.d_val;\n\tbreak;\n      case DT_MIPS_SYMTABNO:\n\tsymtabno = entry->d_un.d_val;\n\tbreak;\n      case DT_MIPS_PLTGOT:\n\tmips_pltgot = entry->d_un.d_ptr;\n\tbreak;\n      case DT_PLTREL:\n\tpltrel = entry->d_un.d_val;\n\tbreak;\n      case DT_PLTRELSZ:\n\tpltrelsz = entry->d_un.d_val;\n\tbreak;\n      case DT_JMPREL:\n\tjmprel = entry->d_un.d_ptr;\n\tbreak;\n      default:\n\tbreak;\n      }\n\n  if (liblist_offset != 0 && liblistno != 0 && do_dynamic)\n    {\n      Elf32_External_Lib * elib;\n      size_t cnt;\n\n      elib = (Elf32_External_Lib *) get_data (NULL, file, liblist_offset,\n                                              liblistno,\n                                              sizeof (Elf32_External_Lib),\n                                              _(\"liblist section data\"));\n      if (elib)\n\t{\n\t  printf (_(\"\\nSection '.liblist' contains %lu entries:\\n\"),\n\t\t  (unsigned long) liblistno);\n\t  fputs (_(\"     Library              Time Stamp          Checksum   Version Flags\\n\"),\n\t\t stdout);\n\n\t  for (cnt = 0; cnt < liblistno; ++cnt)\n\t    {\n\t      Elf32_Lib liblist;\n\t      time_t atime;\n\t      char timebuf[128];\n\t      struct tm * tmp;\n\n\t      liblist.l_name = BYTE_GET (elib[cnt].l_name);\n\t      atime = BYTE_GET (elib[cnt].l_time_stamp);\n\t      liblist.l_checksum = BYTE_GET (elib[cnt].l_checksum);\n\t      liblist.l_version = BYTE_GET (elib[cnt].l_version);\n\t      liblist.l_flags = BYTE_GET (elib[cnt].l_flags);\n\n\t      tmp = gmtime (&atime);\n\t      snprintf (timebuf, sizeof (timebuf),\n\t\t\t\"%04u-%02u-%02uT%02u:%02u:%02u\",\n\t\t\ttmp->tm_year + 1900, tmp->tm_mon + 1, tmp->tm_mday,\n\t\t\ttmp->tm_hour, tmp->tm_min, tmp->tm_sec);\n\n\t      printf (\"%3lu: \", (unsigned long) cnt);\n\t      if (VALID_DYNAMIC_NAME (liblist.l_name))\n\t\tprint_symbol (20, GET_DYNAMIC_NAME (liblist.l_name));\n\t      else\n\t\tprintf (_(\"<corrupt: %9ld>\"), liblist.l_name);\n\t      printf (\" %s %#10lx %-7ld\", timebuf, liblist.l_checksum,\n\t\t      liblist.l_version);\n\n\t      if (liblist.l_flags == 0)\n\t\tputs (_(\" NONE\"));\n\t      else\n\t\t{\n\t\t  static const struct\n\t\t  {\n\t\t    const char * name;\n\t\t    int bit;\n\t\t  }\n\t\t  l_flags_vals[] =\n\t\t  {\n\t\t    { \" EXACT_MATCH\", LL_EXACT_MATCH },\n\t\t    { \" IGNORE_INT_VER\", LL_IGNORE_INT_VER },\n\t\t    { \" REQUIRE_MINOR\", LL_REQUIRE_MINOR },\n\t\t    { \" EXPORTS\", LL_EXPORTS },\n\t\t    { \" DELAY_LOAD\", LL_DELAY_LOAD },\n\t\t    { \" DELTA\", LL_DELTA }\n\t\t  };\n\t\t  int flags = liblist.l_flags;\n\t\t  size_t fcnt;\n\n\t\t  for (fcnt = 0; fcnt < ARRAY_SIZE (l_flags_vals); ++fcnt)\n\t\t    if ((flags & l_flags_vals[fcnt].bit) != 0)\n\t\t      {\n\t\t\tfputs (l_flags_vals[fcnt].name, stdout);\n\t\t\tflags ^= l_flags_vals[fcnt].bit;\n\t\t      }\n\t\t  if (flags != 0)\n\t\t    printf (\" %#x\", (unsigned int) flags);\n\n\t\t  puts (\"\");\n\t\t}\n\t    }\n\n\t  free (elib);\n\t}\n      else\n\tres = FALSE;\n    }\n\n  if (options_offset != 0)\n    {\n      Elf_External_Options * eopt;\n      Elf_Internal_Options * iopt;\n      Elf_Internal_Options * option;\n      size_t offset;\n      int cnt;\n      sect = section_headers;\n\n      /* Find the section header so that we get the size.  */\n      sect = find_section_by_type (SHT_MIPS_OPTIONS);\n      /* PR 17533 file: 012-277276-0.004.  */\n      if (sect == NULL)\n\t{\n\t  error (_(\"No MIPS_OPTIONS header found\\n\"));\n\t  return FALSE;\n\t}\n\n      eopt = (Elf_External_Options *) get_data (NULL, file, options_offset, 1,\n                                                sect->sh_size, _(\"options\"));\n      if (eopt)\n\t{\n\t  iopt = (Elf_Internal_Options *)\n              cmalloc ((sect->sh_size / sizeof (eopt)), sizeof (* iopt));\n\t  if (iopt == NULL)\n\t    {\n\t      error (_(\"Out of memory allocating space for MIPS options\\n\"));\n\t      return FALSE;\n\t    }\n\n\t  offset = cnt = 0;\n\t  option = iopt;\n\n\t  while (offset <= sect->sh_size - sizeof (* eopt))\n\t    {\n\t      Elf_External_Options * eoption;\n\n\t      eoption = (Elf_External_Options *) ((char *) eopt + offset);\n\n\t      option->kind = BYTE_GET (eoption->kind);\n\t      option->size = BYTE_GET (eoption->size);\n\t      option->section = BYTE_GET (eoption->section);\n\t      option->info = BYTE_GET (eoption->info);\n\n\t      /* PR 17531: file: ffa0fa3b.  */\n\t      if (option->size < sizeof (* eopt)\n\t\t  || offset + option->size > sect->sh_size)\n\t\t{\n\t\t  error (_(\"Invalid size (%u) for MIPS option\\n\"), option->size);\n\t\t  return FALSE;\n\t\t}\n\t      offset += option->size;\n\n\t      ++option;\n\t      ++cnt;\n\t    }\n\n\t  printf (_(\"\\nSection '%s' contains %d entries:\\n\"),\n\t\t  printable_section_name (sect), cnt);\n\n\t  option = iopt;\n\t  offset = 0;\n\n\t  while (cnt-- > 0)\n\t    {\n\t      size_t len;\n\n\t      switch (option->kind)\n\t\t{\n\t\tcase ODK_NULL:\n\t\t  /* This shouldn't happen.  */\n\t\t  printf (\" NULL       %d %lx\", option->section, option->info);\n\t\t  break;\n\t\tcase ODK_REGINFO:\n\t\t  printf (\" REGINFO    \");\n\t\t  if (elf_header.e_machine == EM_MIPS)\n\t\t    {\n\t\t      /* 32bit form.  */\n\t\t      Elf32_External_RegInfo * ereg;\n\t\t      Elf32_RegInfo reginfo;\n\n\t\t      ereg = (Elf32_External_RegInfo *) (option + 1);\n\t\t      reginfo.ri_gprmask = BYTE_GET (ereg->ri_gprmask);\n\t\t      reginfo.ri_cprmask[0] = BYTE_GET (ereg->ri_cprmask[0]);\n\t\t      reginfo.ri_cprmask[1] = BYTE_GET (ereg->ri_cprmask[1]);\n\t\t      reginfo.ri_cprmask[2] = BYTE_GET (ereg->ri_cprmask[2]);\n\t\t      reginfo.ri_cprmask[3] = BYTE_GET (ereg->ri_cprmask[3]);\n\t\t      reginfo.ri_gp_value = BYTE_GET (ereg->ri_gp_value);\n\n\t\t      printf (\"GPR %08lx  GP 0x%lx\\n\",\n\t\t\t      reginfo.ri_gprmask,\n\t\t\t      (unsigned long) reginfo.ri_gp_value);\n\t\t      printf (\"            CPR0 %08lx  CPR1 %08lx  CPR2 %08lx  CPR3 %08lx\\n\",\n\t\t\t      reginfo.ri_cprmask[0], reginfo.ri_cprmask[1],\n\t\t\t      reginfo.ri_cprmask[2], reginfo.ri_cprmask[3]);\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      /* 64 bit form.  */\n\t\t      Elf64_External_RegInfo * ereg;\n\t\t      Elf64_Internal_RegInfo reginfo;\n\n\t\t      ereg = (Elf64_External_RegInfo *) (option + 1);\n\t\t      reginfo.ri_gprmask    = BYTE_GET (ereg->ri_gprmask);\n\t\t      reginfo.ri_cprmask[0] = BYTE_GET (ereg->ri_cprmask[0]);\n\t\t      reginfo.ri_cprmask[1] = BYTE_GET (ereg->ri_cprmask[1]);\n\t\t      reginfo.ri_cprmask[2] = BYTE_GET (ereg->ri_cprmask[2]);\n\t\t      reginfo.ri_cprmask[3] = BYTE_GET (ereg->ri_cprmask[3]);\n\t\t      reginfo.ri_gp_value   = BYTE_GET (ereg->ri_gp_value);\n\n\t\t      printf (\"GPR %08lx  GP 0x\",\n\t\t\t      reginfo.ri_gprmask);\n\t\t      printf_vma (reginfo.ri_gp_value);\n\t\t      printf (\"\\n\");\n\n\t\t      printf (\"            CPR0 %08lx  CPR1 %08lx  CPR2 %08lx  CPR3 %08lx\\n\",\n\t\t\t      reginfo.ri_cprmask[0], reginfo.ri_cprmask[1],\n\t\t\t      reginfo.ri_cprmask[2], reginfo.ri_cprmask[3]);\n\t\t    }\n\t\t  ++option;\n\t\t  continue;\n\t\tcase ODK_EXCEPTIONS:\n\t\t  fputs (\" EXCEPTIONS fpe_min(\", stdout);\n\t\t  process_mips_fpe_exception (option->info & OEX_FPU_MIN);\n\t\t  fputs (\") fpe_max(\", stdout);\n\t\t  process_mips_fpe_exception ((option->info & OEX_FPU_MAX) >> 8);\n\t\t  fputs (\")\", stdout);\n\n\t\t  if (option->info & OEX_PAGE0)\n\t\t    fputs (\" PAGE0\", stdout);\n\t\t  if (option->info & OEX_SMM)\n\t\t    fputs (\" SMM\", stdout);\n\t\t  if (option->info & OEX_FPDBUG)\n\t\t    fputs (\" FPDBUG\", stdout);\n\t\t  if (option->info & OEX_DISMISS)\n\t\t    fputs (\" DISMISS\", stdout);\n\t\t  break;\n\t\tcase ODK_PAD:\n\t\t  fputs (\" PAD       \", stdout);\n\t\t  if (option->info & OPAD_PREFIX)\n\t\t    fputs (\" PREFIX\", stdout);\n\t\t  if (option->info & OPAD_POSTFIX)\n\t\t    fputs (\" POSTFIX\", stdout);\n\t\t  if (option->info & OPAD_SYMBOL)\n\t\t    fputs (\" SYMBOL\", stdout);\n\t\t  break;\n\t\tcase ODK_HWPATCH:\n\t\t  fputs (\" HWPATCH   \", stdout);\n\t\t  if (option->info & OHW_R4KEOP)\n\t\t    fputs (\" R4KEOP\", stdout);\n\t\t  if (option->info & OHW_R8KPFETCH)\n\t\t    fputs (\" R8KPFETCH\", stdout);\n\t\t  if (option->info & OHW_R5KEOP)\n\t\t    fputs (\" R5KEOP\", stdout);\n\t\t  if (option->info & OHW_R5KCVTL)\n\t\t    fputs (\" R5KCVTL\", stdout);\n\t\t  break;\n\t\tcase ODK_FILL:\n\t\t  fputs (\" FILL       \", stdout);\n\t\t  /* XXX Print content of info word?  */\n\t\t  break;\n\t\tcase ODK_TAGS:\n\t\t  fputs (\" TAGS       \", stdout);\n\t\t  /* XXX Print content of info word?  */\n\t\t  break;\n\t\tcase ODK_HWAND:\n\t\t  fputs (\" HWAND     \", stdout);\n\t\t  if (option->info & OHWA0_R4KEOP_CHECKED)\n\t\t    fputs (\" R4KEOP_CHECKED\", stdout);\n\t\t  if (option->info & OHWA0_R4KEOP_CLEAN)\n\t\t    fputs (\" R4KEOP_CLEAN\", stdout);\n\t\t  break;\n\t\tcase ODK_HWOR:\n\t\t  fputs (\" HWOR      \", stdout);\n\t\t  if (option->info & OHWA0_R4KEOP_CHECKED)\n\t\t    fputs (\" R4KEOP_CHECKED\", stdout);\n\t\t  if (option->info & OHWA0_R4KEOP_CLEAN)\n\t\t    fputs (\" R4KEOP_CLEAN\", stdout);\n\t\t  break;\n\t\tcase ODK_GP_GROUP:\n\t\t  printf (\" GP_GROUP  %#06lx  self-contained %#06lx\",\n\t\t\t  option->info & OGP_GROUP,\n\t\t\t  (option->info & OGP_SELF) >> 16);\n\t\t  break;\n\t\tcase ODK_IDENT:\n\t\t  printf (\" IDENT     %#06lx  self-contained %#06lx\",\n\t\t\t  option->info & OGP_GROUP,\n\t\t\t  (option->info & OGP_SELF) >> 16);\n\t\t  break;\n\t\tdefault:\n\t\t  /* This shouldn't happen.  */\n\t\t  printf (\" %3d ???     %d %lx\",\n\t\t\t  option->kind, option->section, option->info);\n\t\t  break;\n\t\t}\n\n\t      len = sizeof (* eopt);\n\t      while (len < option->size)\n\t\t{\n\t\t  unsigned char datum = * ((unsigned char *) eopt + offset + len);\n\n\t\t  if (ISPRINT (datum))\n\t\t    printf (\"%c\", datum);\n\t\t  else\n\t\t    printf (\"\\\\%03o\", datum);\n\t\t  len ++;\n\t\t}\n\t      fputs (\"\\n\", stdout);\n\n\t      offset += option->size;\n\t      ++option;\n\t    }\n\n\t  free (eopt);\n\t}\n      else\n\tres = FALSE;\n    }\n\n  if (conflicts_offset != 0 && conflictsno != 0)\n    {\n      Elf32_Conflict * iconf;\n      size_t cnt;\n\n      if (dynamic_symbols == NULL)\n\t{\n\t  error (_(\"conflict list found without a dynamic symbol table\\n\"));\n\t  return FALSE;\n\t}\n\n      iconf = (Elf32_Conflict *) cmalloc (conflictsno, sizeof (* iconf));\n      if (iconf == NULL)\n\t{\n\t  error (_(\"Out of memory allocating space for dynamic conflicts\\n\"));\n\t  return FALSE;\n\t}\n\n      if (is_32bit_elf)\n\t{\n\t  Elf32_External_Conflict * econf32;\n\n\t  econf32 = (Elf32_External_Conflict *)\n              get_data (NULL, file, conflicts_offset, conflictsno,\n                        sizeof (* econf32), _(\"conflict\"));\n\t  if (!econf32)\n\t    return FALSE;\n\n\t  for (cnt = 0; cnt < conflictsno; ++cnt)\n\t    iconf[cnt] = BYTE_GET (econf32[cnt]);\n\n\t  free (econf32);\n\t}\n      else\n\t{\n\t  Elf64_External_Conflict * econf64;\n\n\t  econf64 = (Elf64_External_Conflict *)\n              get_data (NULL, file, conflicts_offset, conflictsno,\n                        sizeof (* econf64), _(\"conflict\"));\n\t  if (!econf64)\n\t    return FALSE;\n\n\t  for (cnt = 0; cnt < conflictsno; ++cnt)\n\t    iconf[cnt] = BYTE_GET (econf64[cnt]);\n\n\t  free (econf64);\n\t}\n\n      printf (_(\"\\nSection '.conflict' contains %lu entries:\\n\"),\n\t      (unsigned long) conflictsno);\n      puts (_(\"  Num:    Index       Value  Name\"));\n\n      for (cnt = 0; cnt < conflictsno; ++cnt)\n\t{\n\t  printf (\"%5lu: %8lu  \", (unsigned long) cnt, iconf[cnt]);\n\n\t  if (iconf[cnt] >= num_dynamic_syms)\n\t    printf (_(\"<corrupt symbol index>\"));\n\t  else\n\t    {\n\t      Elf_Internal_Sym * psym;\n\n\t      psym = & dynamic_symbols[iconf[cnt]];\n\t      print_vma (psym->st_value, FULL_HEX);\n\t      putchar (' ');\n\t      if (VALID_DYNAMIC_NAME (psym->st_name))\n\t\tprint_symbol (25, GET_DYNAMIC_NAME (psym->st_name));\n\t      else\n\t\tprintf (_(\"<corrupt: %14ld>\"), psym->st_name);\n\t    }\n\t  putchar ('\\n');\n\t}\n\n      free (iconf);\n    }\n\n  if (pltgot != 0 && local_gotno != 0)\n    {\n      bfd_vma ent, local_end, global_end;\n      size_t i, offset;\n      unsigned char * data;\n      unsigned char * data_end;\n      int addr_size;\n\n      ent = pltgot;\n      addr_size = (is_32bit_elf ? 4 : 8);\n      local_end = pltgot + local_gotno * addr_size;\n\n      /* PR binutils/17533 file: 012-111227-0.004  */\n      if (symtabno < gotsym)\n\t{\n\t  error (_(\"The GOT symbol offset (%lu) is greater than the symbol table size (%lu)\\n\"),\n\t\t (unsigned long) gotsym, (unsigned long) symtabno);\n\t  return FALSE;\n\t}\n\n      global_end = local_end + (symtabno - gotsym) * addr_size;\n      /* PR 17531: file: 54c91a34.  */\n      if (global_end < local_end)\n\t{\n\t  error (_(\"Too many GOT symbols: %lu\\n\"), (unsigned long) symtabno);\n\t  return FALSE;\n\t}\n\n      offset = offset_from_vma (file, pltgot, global_end - pltgot);\n      data = (unsigned char *) get_data (NULL, file, offset,\n                                         global_end - pltgot, 1,\n\t\t\t\t\t _(\"Global Offset Table data\"));\n      if (data == NULL)\n\treturn FALSE;\n      data_end = data + (global_end - pltgot);\n\n      printf (_(\"\\nPrimary GOT:\\n\"));\n      printf (_(\" Canonical gp value: \"));\n      print_vma (pltgot + 0x7ff0, LONG_HEX);\n      printf (\"\\n\\n\");\n\n      printf (_(\" Reserved entries:\\n\"));\n      printf (_(\"  %*s %10s %*s Purpose\\n\"),\n\t      addr_size * 2, _(\"Address\"), _(\"Access\"),\n\t      addr_size * 2, _(\"Initial\"));\n      ent = print_mips_got_entry (data, pltgot, ent, data_end);\n      printf (_(\" Lazy resolver\\n\"));\n      if (ent == (bfd_vma) -1)\n\tgoto got_print_fail;\n\n      if (data)\n\t{\n\t  /* PR 21344 */\n\t  if (data + ent - pltgot > data_end - addr_size)\n\t    {\n\t      error (_(\"Invalid got entry - %#lx - overflows GOT table\\n\"), ent);\n\t      goto got_print_fail;\n\t    }\n\t  \n\t  if (byte_get (data + ent - pltgot, addr_size)\n\t      >> (addr_size * 8 - 1) != 0)\n\t    {\n\t      ent = print_mips_got_entry (data, pltgot, ent, data_end);\n\t      printf (_(\" Module pointer (GNU extension)\\n\"));\n\t      if (ent == (bfd_vma) -1)\n\t\tgoto got_print_fail;\n\t    }\n\t}\n      printf (\"\\n\");\n\n      if (ent < local_end)\n\t{\n\t  printf (_(\" Local entries:\\n\"));\n\t  printf (\"  %*s %10s %*s\\n\",\n\t\t  addr_size * 2, _(\"Address\"), _(\"Access\"),\n\t\t  addr_size * 2, _(\"Initial\"));\n\t  while (ent < local_end)\n\t    {\n\t      ent = print_mips_got_entry (data, pltgot, ent, data_end);\n\t      printf (\"\\n\");\n\t      if (ent == (bfd_vma) -1)\n\t\tgoto got_print_fail;\n\t    }\n\t  printf (\"\\n\");\n\t}\n\n      if (gotsym < symtabno)\n\t{\n\t  int sym_width;\n\n\t  printf (_(\" Global entries:\\n\"));\n\t  printf (\"  %*s %10s %*s %*s %-7s %3s %s\\n\",\n\t\t  addr_size * 2, _(\"Address\"),\n\t\t  _(\"Access\"),\n\t\t  addr_size * 2, _(\"Initial\"),\n\t\t  addr_size * 2, _(\"Sym.Val.\"),\n\t\t  _(\"Type\"),\n\t\t  /* Note for translators: \"Ndx\" = abbreviated form of \"Index\".  */\n\t\t  _(\"Ndx\"), _(\"Name\"));\n\n\t  sym_width = (is_32bit_elf ? 80 : 160) - 28 - addr_size * 6 - 1;\n\n\t  for (i = gotsym; i < symtabno; i++)\n\t    {\n\t      ent = print_mips_got_entry (data, pltgot, ent, data_end);\n\t      printf (\" \");\n\n\t      if (dynamic_symbols == NULL)\n\t\tprintf (_(\"<no dynamic symbols>\"));\n\t      else if (i < num_dynamic_syms)\n\t\t{\n\t\t  Elf_Internal_Sym * psym = dynamic_symbols + i;\n\n\t\t  print_vma (psym->st_value, LONG_HEX);\n\t\t  printf (\" %-7s %3s \",\n\t\t\t  get_symbol_type (ELF_ST_TYPE (psym->st_info)),\n\t\t\t  get_symbol_index_type (psym->st_shndx));\n\n\t\t  if (VALID_DYNAMIC_NAME (psym->st_name))\n\t\t    print_symbol (sym_width, GET_DYNAMIC_NAME (psym->st_name));\n\t\t  else\n\t\t    printf (_(\"<corrupt: %14ld>\"), psym->st_name);\n\t\t}\n\t      else\n\t\tprintf (_(\"<symbol index %lu exceeds number of dynamic symbols>\"),\n\t\t\t(unsigned long) i);\n\n\t      printf (\"\\n\");\n\t      if (ent == (bfd_vma) -1)\n\t\tbreak;\n\t    }\n\t  printf (\"\\n\");\n\t}\n\n    got_print_fail:\n      if (data)\n\tfree (data);\n    }\n\n  if (mips_pltgot != 0 && jmprel != 0 && pltrel != 0 && pltrelsz != 0)\n    {\n      bfd_vma ent, end;\n      size_t offset, rel_offset;\n      unsigned long count, i;\n      unsigned char * data;\n      int addr_size, sym_width;\n      Elf_Internal_Rela * rels;\n\n      rel_offset = offset_from_vma (file, jmprel, pltrelsz);\n      if (pltrel == DT_RELA)\n\t{\n\t  if (!slurp_rela_relocs (file, rel_offset, pltrelsz, &rels, &count))\n\t    return FALSE;\n\t}\n      else\n\t{\n\t  if (!slurp_rel_relocs (file, rel_offset, pltrelsz, &rels, &count))\n\t    return FALSE;\n\t}\n\n      ent = mips_pltgot;\n      addr_size = (is_32bit_elf ? 4 : 8);\n      end = mips_pltgot + (2 + count) * addr_size;\n\n      offset = offset_from_vma (file, mips_pltgot, end - mips_pltgot);\n      data = (unsigned char *) get_data (NULL, file, offset, end - mips_pltgot,\n                                         1, _(\"Procedure Linkage Table data\"));\n      if (data == NULL)\n\treturn FALSE;\n\n      printf (\"\\nPLT GOT:\\n\\n\");\n      printf (_(\" Reserved entries:\\n\"));\n      printf (_(\"  %*s %*s Purpose\\n\"),\n\t      addr_size * 2, _(\"Address\"), addr_size * 2, _(\"Initial\"));\n      ent = print_mips_pltgot_entry (data, mips_pltgot, ent);\n      printf (_(\" PLT lazy resolver\\n\"));\n      ent = print_mips_pltgot_entry (data, mips_pltgot, ent);\n      printf (_(\" Module pointer\\n\"));\n      printf (\"\\n\");\n\n      printf (_(\" Entries:\\n\"));\n      printf (\"  %*s %*s %*s %-7s %3s %s\\n\",\n\t      addr_size * 2, _(\"Address\"),\n\t      addr_size * 2, _(\"Initial\"),\n\t      addr_size * 2, _(\"Sym.Val.\"), _(\"Type\"), _(\"Ndx\"), _(\"Name\"));\n      sym_width = (is_32bit_elf ? 80 : 160) - 17 - addr_size * 6 - 1;\n      for (i = 0; i < count; i++)\n\t{\n\t  unsigned long idx = get_reloc_symindex (rels[i].r_info);\n\n\t  ent = print_mips_pltgot_entry (data, mips_pltgot, ent);\n\t  printf (\" \");\n\n\t  if (idx >= num_dynamic_syms)\n\t    printf (_(\"<corrupt symbol index: %lu>\"), idx);\n\t  else\n\t    {\n\t      Elf_Internal_Sym * psym = dynamic_symbols + idx;\n\n\t      print_vma (psym->st_value, LONG_HEX);\n\t      printf (\" %-7s %3s \",\n\t\t      get_symbol_type (ELF_ST_TYPE (psym->st_info)),\n\t\t      get_symbol_index_type (psym->st_shndx));\n\t      if (VALID_DYNAMIC_NAME (psym->st_name))\n\t\tprint_symbol (sym_width, GET_DYNAMIC_NAME (psym->st_name));\n\t      else\n\t\tprintf (_(\"<corrupt: %14ld>\"), psym->st_name);\n\t    }\n\t  printf (\"\\n\");\n\t}\n      printf (\"\\n\");\n\n      if (data)\n\tfree (data);\n      free (rels);\n    }\n\n  return res;\n}", "target": 1, "idx": 10653}
{"commit_id": "cf3ba049a2792ec2a4a877e343f5dd9654da53dc", "project": "Exiv2/exiv2", "func": "DataBuf PngChunk::readRawProfile(const DataBuf& text,bool iTXt)\n    {\n        DataBuf                 info;\n        unsigned char           unhex[103]={0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,\n                                            0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,\n                                            0,0,0,0,0,0,0,0,0,1, 2,3,4,5,6,7,8,9,0,0,\n                                            0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,\n                                            0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,10,11,12,\n                                            13,14,15};\n        if (text.size_ == 0) {\n            return DataBuf();\n        }\n\n        if ( iTXt ) {\n            info.alloc(text.size_);\n            ::memcpy(info.pData_,text.pData_,text.size_);\n            return  info;\n        }\n\n        const char *sp = (char*)text.pData_+1;\n        int pointerPos = 1;\n\n        // Look for newline\n        while (*sp != '\\n' && pointerPos < (text.size_ - 1))\n        {\n            sp++;\n            pointerPos++;\n        }\n\n        // Look for length\n        while ((*sp == '\\0' || *sp == ' ' || *sp == '\\n') && pointerPos < (text.size_ - 1))\n        {\n            sp++;\n            pointerPos++;\n        }\n\n        if (pointerPos == (text.size_ - 1))\n        {\n            return DataBuf();\n        }\n\n        long length = (long) atol(sp);\n\n        while (*sp != ' ' && *sp != '\\n' && pointerPos < (text.size_ - 1))\n        {\n            sp++;\n            pointerPos++;\n        }\n\n        if (pointerPos == (text.size_ - 1))\n        {\n            return DataBuf();\n        }\n\n        // Allocate space\n\n        if (length == 0)\n        {\n#ifdef DEBUG\n            std::cerr << \"Exiv2::PngChunk::readRawProfile: Unable To Copy Raw Profile: invalid profile length\\n\";\n#endif\n        }\n\n        info.alloc(length);\n\n        if (info.size_ != length)\n        {\n#ifdef DEBUG\n            std::cerr << \"Exiv2::PngChunk::readRawProfile: Unable To Copy Raw Profile: cannot allocate memory\\n\";\n#endif\n            return DataBuf();\n        }\n\n        // Copy profile, skipping white space and column 1 \"=\" signs\n\n        unsigned char *dp = (unsigned char*)info.pData_;\n        unsigned int nibbles = length * 2;\n\n        for (long i = 0; i < (long) nibbles; i++)\n        {\n            while (*sp < '0' || (*sp > '9' && *sp < 'a') || *sp > 'f')\n            {\n                if (*sp == '\\0')\n                {\n#ifdef DEBUG\n                    std::cerr << \"Exiv2::PngChunk::readRawProfile: Unable To Copy Raw Profile: ran out of data\\n\";\n#endif\n                    return DataBuf();\n                }\n\n                sp++;\n            }\n\n            if (i%2 == 0)\n                *dp = (unsigned char) (16*unhex[(int) *sp++]);\n            else\n                (*dp++) += unhex[(int) *sp++];\n        }\n\n        return info;\n\n    }", "target": 1, "idx": 10654}
{"commit_id": "dd051f8ed5ae3347fb1d556ced3c97822c9d8450", "project": "OpenSIPS/opensips", "func": "static int stream_process(struct sip_msg * msg, struct sdp_stream_cell *cell,\n\t\t\tstr * s, str* ss, regex_t* re, int op,int description)\n{\n\tstatic sdp_payload_attr_t static_payloads[] = {\n\t/* as per http://www.iana.org/assignments/rtp-parameters/rtp-parameters.xml */\n\t{ NULL,0,{ \"0\",1},{\"PCMU\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /* 0 - PCMU/8000  */\n\t{ NULL,0,{ \"3\",1},{ \"GSM\",3},{ \"8000\",4},{NULL,0},{NULL,0} },   /* 3 -  GSM/8000  */\n\t{ NULL,0,{ \"4\",1},{\"G723\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /* 4 - G723/8000  */\n\t{ NULL,0,{ \"5\",1},{\"DVI4\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /* 5 - DVI4/8000  */\n\t{ NULL,0,{ \"6\",1},{\"DVI4\",4},{\"16000\",5},{NULL,0},{NULL,0} },   /* 6 - DVI4/16000 */\n\t{ NULL,0,{ \"7\",1},{ \"LPC\",3},{ \"8000\",4},{NULL,0},{NULL,0} },   /* 7 -  LPC/8000  */\n\t{ NULL,0,{ \"8\",1},{\"PCMA\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /* 8 - PCMA/8000  */\n\t{ NULL,0,{ \"9\",1},{\"G722\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /* 9 - G722/8000  */\n\t{ NULL,0,{\"10\",2},{ \"L16\",3},{\"44100\",5},{NULL,0},{NULL,0} },   /*10 -  L16/44100 */\n\t{ NULL,0,{\"11\",2},{ \"L16\",3},{\"44100\",5},{NULL,0},{NULL,0} },   /*11 -  L16/44100 */\n\t{ NULL,0,{\"12\",2},{\"QCELP\",5},{\"8000\",4},{NULL,0},{NULL,0} },   /*12 -QCELP/8000  */\n\t{ NULL,0,{\"13\",2},{  \"CN\",2},{ \"8000\",4},{NULL,0},{NULL,0} },   /*13 -   CN/8000  */\n\t{ NULL,0,{\"14\",2},{ \"MPA\",3},{\"90000\",5},{NULL,0},{NULL,0} },   /*14 -  MPA/90000 */\n\t{ NULL,0,{\"15\",2},{\"G728\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /*15 - G728/8000  */\n\t{ NULL,0,{\"16\",2},{\"DVI4\",4},{\"11025\",5},{NULL,0},{NULL,0} },   /*16 - DVI4/11025 */\n\t{ NULL,0,{\"17\",2},{\"DVI4\",4},{\"22050\",5},{NULL,0},{NULL,0} },   /*17 - DVI4/22050 */\n\t{ NULL,0,{\"18\",2},{\"G729\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /*18 - G729/8000  */\n\t{ NULL,0,{\"25\",2},{\"CelB\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /*25 - CelB/8000  */\n\t{ NULL,0,{\"26\",2},{\"JPEG\",4},{\"90000\",5},{NULL,0},{NULL,0} },   /*26 - JPEG/90000 */\n\t{ NULL,0,{\"28\",2},{  \"nv\",2},{\"90000\",5},{NULL,0},{NULL,0} },   /*28 -   nv/90000 */\n\t{ NULL,0,{\"31\",2},{\"H261\",4},{\"90000\",5},{NULL,0},{NULL,0} },   /*31 - H261/90000 */\n\t{ NULL,0,{\"32\",2},{ \"MPV\",3},{\"90000\",5},{NULL,0},{NULL,0} },   /*32 -  MPV/90000 */\n\t{ NULL,0,{\"33\",2},{\"MP2T\",4},{\"90000\",5},{NULL,0},{NULL,0} },   /*33 - MP2T/90000 */\n\t{ NULL,0,{\"34\",2},{\"H263\",4},{\"90000\",5},{NULL,0},{NULL,0} },   /*34 - H263/90000 */\n\t{ NULL,0,{\"t38\",3},{\"t38\",3},{     \"\",0},{NULL,0},{NULL,0} },   /*T38- fax        */\n\t{ NULL,0,{NULL,0},{  NULL,0},{   NULL,0},{NULL,0},{NULL,0} }\n\t};\n\tsdp_payload_attr_t *payload;\n\tchar *cur, *tmp, *buff, temp;\n\tstruct lump * lmp;\n\tstr found;\n\tint ret, i,match, buff_len, is_static;\n\tregmatch_t pmatch;\n\n\n\tlmp = get_associated_lump(msg, cell);\n\tif( lmp == NULL)\n\t{\n\t\tLM_ERR(\"There is no lump for this sdp cell\\n\");\n\t\treturn -1;\n\t}\n\n\t/* is stream deleted ?? */\n\tif (lmp->len == 0)\n\t\treturn -1;\n\n\n\tbuff_len = 0;\n\tret = 0;\n\n\tbuff = pkg_malloc(lmp->len+1);\n\tif( buff == NULL)\n\t{\n\t\tLM_ERR(\"Out of memory\\n\");\n\t\treturn -1;\n\t}\n\n\t/* search through each payload */\n\tis_static = 0;\n\tpayload = cell->payload_attr;\n\n\twhile(payload)\n\t{\n\t\tif( payload->rtp_enc.s == NULL\n\t\t || (payload->rtp_clock.s == NULL && ss != NULL)\n\t\t || payload->rtp_payload.s == NULL)\n\t\t{\n\t\t\tgoto next_payload;\n\t\t}\n\n\t\tmatch = 0;\n\n\t\tif( description == DESC_REGEXP ||description == DESC_REGEXP_COMPLEMENT )\n\t\t{\n\t\t\t/* try to match a regexp */\n\t\t\tif (is_static) {\n\t\t\t\tmatch = regexec( re, payload->rtp_enc.s, 1, &pmatch, 0) == 0;\n\t\t\t} else {\n\t\t\t\ttemp = payload->rtp_enc.s[payload->rtp_enc.len];\n\t\t\t\tpayload->rtp_enc.s[payload->rtp_enc.len] = 0;\n\t\t\t\tmatch = regexec( re, payload->rtp_enc.s, 1, &pmatch, 0) == 0;\n\t\t\t\tpayload->rtp_enc.s[payload->rtp_enc.len] = temp;\n\t\t\t}\n\t\t}\n\n\t\tif( description == DESC_REGEXP_COMPLEMENT)\n\t\t\tmatch = !match;\n\n\t\tif( description == DESC_NAME  )\n\t\t{\n\t\t\tmatch = s->len == payload->rtp_enc.len &&\n\t\t\tstrncasecmp( s->s, payload->rtp_enc.s ,\tpayload->rtp_enc.len) == 0;\n\t\t}\n\n\t\tif( description == DESC_NAME_AND_CLOCK)\n\t\t{\n\t\t\t/* try to match name and clock if there is one */\n\t\t\tmatch = s->len == payload->rtp_enc.len &&\n\t\t\tstrncasecmp( s->s, payload->rtp_enc.s ,\n\t\t\t\tpayload->rtp_enc.len) == 0\n\t\t\t&&\n\t\t\t(ss == NULL || ( ss->len == payload->rtp_clock.len &&\n\t\t\tstrncasecmp( ss->s, payload->rtp_clock.s ,\n\t\t\t\tpayload->rtp_clock.len) == 0\n\t\t\t) );\n\t\t}\n\n\t\t/* if found, search its index in the m= line */\n\t\tif (match) {\n\n\t\t\tmatch = 0;\n\n\t\t\tcur = lmp->u.value;\n\t\t\twhile( !match && cur < lmp->u.value + lmp->len)\n\t\t\t{\n\t\t\t\t/* find the end of the number */\n\t\t\t\tfound.s = cur;\n\n\t\t\t\twhile(  cur < lmp->u.value + lmp->len &&  *cur != ' ' )\n\t\t\t\t\tcur++;\n\n\t\t\t\tfound.len = cur - found.s;\n\n\t\t\t\t/* does it matches payload number */\n\t\t\t\tif ( found.len == payload->rtp_payload.len &&\n\t\t\t\tstrncmp( found.s,payload->rtp_payload.s,found.len) == 0) {\n\t\t\t\t\tmatch = 1;\n\t\t\t\t} else {\n\t\t\t\t\t/* continue on searching => skip spaces\n\t\t\t\t\t   if there still are any */\n\t\t\t\t\twhile( cur < lmp->u.value + lmp->len && * cur == ' '  )\n\t\t\t\t\t\tcur++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* have we found both payload and index */\n\t\t\tif (match) {\n\n\t\t\t\tif(op == FIND)\n\t\t\t\t{\n\t\t\t\t\tret = 1;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\t\tif( op == DELETE && !is_static )\n\t\t\t\t{\n\t\t\t\t\t/* find the full 'a=...' entry */\n\n\t\t\t\t\tif( delete_sdp_line( msg, payload->rtp_enc.s, cell) < 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tLM_ERR(\"Unable to add delete lump for a=\\n\");\n\t\t\t\t\t\tret = -1;\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\n\t\t\t\t\tif( delete_sdp_line( msg, payload->fmtp_string.s, cell) < 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tLM_ERR(\"Unable to add delete lump for a=\\n\");\n\t\t\t\t\t\tret = -1;\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t{\n\t\t\t\t\t/* take the previous whitespaces as well */\n\t\t\t\t\twhile (found.s > lmp->u.value && *(found.s - 1) == ' ') {\n\t\t\t\t\t\tfound.s--;\n\t\t\t\t\t\tfound.len++;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* when trimming the very last payload, avoid trailing ws */\n\t\t\t\t\tif (cur == lmp->u.value + lmp->len) {\n\t\t\t\t\t\ttmp = found.s;\n\t\t\t\t\t\twhile (tmp>lmp->u.value && *(--tmp) == ' ') {\n\t\t\t\t\t\t\tfound.s--;\n\t\t\t\t\t\t\tfound.len++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* delete the string and update iterators */\n\t\t\t\t\tfor(tmp=found.s ; tmp< lmp->u.value + lmp->len ; tmp++ )\n\t\t\t\t\t\t*tmp  = *(tmp+found.len);\n\n\t\t\t\t\t//cur -= found.len;\n\t\t\t\t\tlmp->len -= found.len;\n\t\t\t\t}\n\n\t\t\t\t/* add the deleted number into a buffer to be addded later */\n\t\t\t\tif( op == ADD_TO_FRONT  || op == ADD_TO_BACK)\n\t\t\t\t{\n\t\t\t\t\tmemcpy(&buff[buff_len],\" \",1);\n\t\t\t\t\tbuff_len++;\n\n\t\t\t\t\tmemcpy(&buff[buff_len],payload->rtp_payload.s,\n\t\t\t\t\t\tpayload->rtp_payload.len);\n\n\t\t\t\t\tbuff_len += payload->rtp_payload.len;\n\t\t\t\t}\n\n\t\t\t\tret = 1;\n\t\t\t}\n\n\t\t}\n\n\t\t/* next payload */\n\tnext_payload:\n\t\tif (!is_static) {\n\t\t\tpayload = payload->next;\n\t\t\tif (payload==NULL) {\n\t\t\t\tpayload = static_payloads;\n\t\t\t\tis_static = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tpayload ++;\n\t\t\tif (payload->rtp_payload.s==NULL)\n\t\t\t\tpayload=NULL;\n\t\t}\n\t}\n\n\n\tif( op == ADD_TO_FRONT && buff_len >0 )\n\t{\n\t\tlmp->u.value = (char*)pkg_realloc(lmp->u.value, lmp->len+buff_len);\n\t\tif(!lmp->u.value) {\n\t\t\tLM_ERR(\"No more pkg memory\\n\");\n\t\t\tret = -1;\n\t\t\tgoto end;\n\t\t}\n\n\t\tfor( i = lmp->len -1 ; i>=0;i--)\n\t\t\tlmp->u.value[i+buff_len] = lmp->u.value[i];\n\n\t\tmemcpy(lmp->u.value,buff,buff_len);\n\n\t\tlmp->len += buff_len;\n\n\t}\n\n\tif( op == ADD_TO_BACK && buff_len >0 )\n\t{\n\n\t\tlmp->u.value = (char*)pkg_realloc(lmp->u.value, lmp->len+buff_len);\n\t\tif(!lmp->u.value) {\n\t\t\tLM_ERR(\"No more pkg memory\\n\");\n\t\t\tret = -1;\n\t\t\tgoto end;\n\t\t}\n\n\t\tmemcpy(&lmp->u.value[lmp->len],buff,buff_len);\n\n\t\tlmp->len += buff_len;\n\n\t}\n\n\t/* if we ended up with a 0-length lump, then it means that all payloads\n\t * have been deleted, therefore we need to disable the media stream */\n\tif (lmp->len == 0) {\n\t\t/* replace the media port with 0 - we also replace the spaces before\n\t\t * and after the port, to make sure we have a larger buffer */\n\t\tlmp = del_lump(msg, cell->port.s - msg->buf - 1, cell->port.len + 2, 0);\n\t\tif (!lmp) {\n\t\t\tLM_ERR(\"could not add lump to disable stream!\\n\");\n\t\t\tgoto end;\n\t\t}\n\t\ttmp = pkg_malloc(3);\n\t\tif (!tmp) {\n\t\t\tLM_ERR(\"oom for port 0\\n\");\n\t\t\tgoto end;\n\t\t}\n\t\tmemcpy(tmp, \" 0 \", 3);\n\t\tif (!insert_new_lump_after(lmp, tmp, 3, 0))\n\t\t\tLM_ERR(\"could not insert lump to disable stream!\\n\");\n\t}\n\nend:\n\tpkg_free(buff);\n\treturn ret;\n}", "target": 2, "idx": 10655}
{"commit_id": "c40f7d74c741a907cfaeb73a7697081881c497d0", "project": "torvalds/linux", "func": "void print_cfs_stats(struct seq_file *m, int cpu)\n{\n\tstruct cfs_rq *cfs_rq;\n\n\trcu_read_lock();\n\tfor_each_leaf_cfs_rq(cpu_rq(cpu), cfs_rq)\n\t\tprint_cfs_rq(m, cpu, cfs_rq);\n\trcu_read_unlock();\n}", "target": 3, "idx": 10656}
{"commit_id": "8f782fd8e181d9cfe9387ded43a5ca9692266b85", "project": "flori/json", "func": "static VALUE cState_object_nl_set(VALUE self, VALUE object_nl)\n{\n    unsigned long len;\n    GET_STATE(self);\n    Check_Type(object_nl, T_STRING);\n    len = RSTRING_LEN(object_nl);\n    if (len == 0) {\n        if (state->object_nl) {\n            ruby_xfree(state->object_nl);\n            state->object_nl = NULL;\n        }\n    } else {\n        if (state->object_nl) ruby_xfree(state->object_nl);\n        state->object_nl = fstrndup(RSTRING_PTR(object_nl), len);\n        state->object_nl_len = len;\n    }\n    return Qnil;\n}", "target": 3, "idx": 10657}
{"commit_id": "f59dac7e6d9f0aad961c5686fe832d95ec1e7b6c", "project": "tats/w3m", "func": "Str\nprocess_button(struct parsed_tag *tag)\n{\n    Str tmp = NULL;\n    char *p, *q, *r, *qq = \"\";\n    int qlen, v;\n\n    if (cur_form_id < 0) {\n       char *s = \"<form_int method=internal action=none>\";\n       tmp = process_form(parse_tag(&s, TRUE));\n    }\n    if (tmp == NULL)\n       tmp = Strnew();\n\n    p = \"submit\";\n    parsedtag_get_value(tag, ATTR_TYPE, &p);\n    q = NULL;\n    parsedtag_get_value(tag, ATTR_VALUE, &q);\n    r = \"\";\n    parsedtag_get_value(tag, ATTR_NAME, &r);\n\n    v = formtype(p);\n    if (v == FORM_UNKNOWN)\n       return NULL;\n\n    switch (v) {\n    case FORM_INPUT_SUBMIT:\n    case FORM_INPUT_BUTTON:\n    case FORM_INPUT_RESET:\n\tbreak;\n    default:\n\tp = \"submit\";\n\tv = FORM_INPUT_SUBMIT;\n\tbreak;\n    }\n\n    if (!q) {\n       switch (v) {\n       case FORM_INPUT_SUBMIT:\n       case FORM_INPUT_BUTTON:\n           q = \"SUBMIT\";\n           break;\n       case FORM_INPUT_RESET:\n           q = \"RESET\";\n           break;\n       }\n    }\n    if (q) {\n       qq = html_quote(q);\n       qlen = strlen(q);\n    }\n\n    //    Strcat_charp(tmp, \"<pre_int>\");\n    Strcat(tmp, Sprintf(\"<input_alt hseq=\\\"%d\\\" fid=\\\"%d\\\" type=\\\"%s\\\" \"\n                       \"name=\\\"%s\\\" value=\\\"%s\\\">\",\n                       cur_hseq++, cur_form_id, html_quote(p),\n                       html_quote(r), qq));\n    return tmp;\n}", "target": 1, "idx": 10658}
{"commit_id": "484411868bf9351ae7513008f6efd28caa72574f", "project": "nginx/njs", "func": "njs_int_t\nnjs_value_property_delete(njs_vm_t *vm, njs_value_t *value, njs_value_t *key,\n    njs_value_t *removed, njs_bool_t thrw)\n{\n    double                num;\n    uint32_t              index;\n    njs_int_t             ret;\n    njs_array_t           *array;\n    njs_object_prop_t     *prop;\n    njs_property_query_t  pq;\n\n    njs_assert(njs_is_index_or_key(key));\n\n    if (njs_fast_path(njs_is_number(key))) {\n        if (njs_slow_path(!(njs_is_fast_array(value)))) {\n            goto slow_path;\n        }\n\n        num = njs_number(key);\n\n        if (njs_slow_path(!njs_number_is_integer_index(num))) {\n            goto slow_path;\n        }\n\n        index = (uint32_t) num;\n\n        array = njs_array(value);\n\n        if (njs_slow_path(index >= array->length)) {\n            goto slow_path;\n        }\n\n        njs_value_assign(&array->start[index], &njs_value_invalid);\n\n        return NJS_OK;\n    }\n\nslow_path:\n\n    njs_property_query_init(&pq, NJS_PROPERTY_QUERY_DELETE, 0, 1);\n\n    ret = njs_property_query(vm, &pq, value, key);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    prop = pq.lhq.value;\n\n    if (njs_slow_path(!prop->configurable)) {\n        if (thrw) {\n            njs_key_string_get(vm, &pq.key,  &pq.lhq.key);\n            njs_type_error(vm, \"Cannot delete property \\\"%V\\\" of %s\",\n                           &pq.lhq.key, njs_type_string(value->type));\n            return NJS_ERROR;\n        }\n\n        return NJS_OK;\n    }\n\n    switch (prop->type) {\n    case NJS_PROPERTY_HANDLER:\n        if (njs_is_object(value) && njs_object_slots(value) != NULL) {\n            ret = njs_prop_handler(prop)(vm, prop, value, NULL, NULL);\n            if (njs_slow_path(ret != NJS_DECLINED)) {\n                return ret;\n            }\n        }\n\n        /* Fall through. */\n\n    case NJS_PROPERTY:\n        break;\n\n    case NJS_ACCESSOR:\n        if (removed == NULL) {\n            break;\n        }\n\n        if (njs_prop_getter(prop) == NULL) {\n            njs_set_undefined(removed);\n            break;\n        }\n\n        return njs_function_apply(vm, njs_prop_getter(prop), value, 1, removed);\n\n    case NJS_PROPERTY_REF:\n    case NJS_PROPERTY_PLACE_REF:\n        if (removed != NULL) {\n            njs_value_assign(removed, njs_prop_ref(prop));\n        }\n\n        njs_set_invalid(njs_prop_ref(prop));\n        return NJS_OK;\n\n    default:\n        njs_internal_error(vm, \"unexpected property type \\\"%s\\\" \"\n                           \"while deleting\", njs_prop_type_string(prop->type));\n        return NJS_ERROR;\n    }\n\n    if (removed != NULL) {\n        if (njs_is_valid(njs_prop_value(prop))) {\n            njs_value_assign(removed, njs_prop_value(prop));\n\n        } else {\n            njs_set_undefined(removed);\n        }\n    }\n\n    prop->type = NJS_WHITEOUT;\n\n    return NJS_OK;\n}", "target": 2, "idx": 10659}
{"commit_id": "e396648e48c57e2d53988d3fd4465b068b96c89a", "project": "gpac", "func": "static s16 swf_get_s16(SWFReader *read)\n{\n\treturn (s16) gf_bs_read_u16_le(read->bs);\n}", "target": 1, "idx": 10660}
{"commit_id": "f0d1762554014ce0ae347b9f0d088f2c157c8c72", "project": "torvalds/linux", "func": "static void pcd_init_units(void)\n{\n\tstruct pcd_unit *cd;\n\tint unit;\n\n\tpcd_drive_count = 0;\n\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\tstruct gendisk *disk = alloc_disk(1);\n\n\t\tif (!disk)\n\t\t\tcontinue;\n\n\t\tdisk->queue = blk_mq_init_sq_queue(&cd->tag_set, &pcd_mq_ops,\n\t\t\t\t\t\t   1, BLK_MQ_F_SHOULD_MERGE);\n\t\tif (IS_ERR(disk->queue)) {\n\t\t\tput_disk(disk);\n\t\t\tdisk->queue = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tINIT_LIST_HEAD(&cd->rq_list);\n\t\tdisk->queue->queuedata = cd;\n\t\tblk_queue_bounce_limit(disk->queue, BLK_BOUNCE_HIGH);\n\t\tcd->disk = disk;\n\t\tcd->pi = &cd->pia;\n\t\tcd->present = 0;\n\t\tcd->last_sense = 0;\n\t\tcd->changed = 1;\n\t\tcd->drive = (*drives[unit])[D_SLV];\n\t\tif ((*drives[unit])[D_PRT])\n\t\t\tpcd_drive_count++;\n\n\t\tcd->name = &cd->info.name[0];\n\t\tsnprintf(cd->name, sizeof(cd->info.name), \"%s%d\", name, unit);\n\t\tcd->info.ops = &pcd_dops;\n\t\tcd->info.handle = cd;\n\t\tcd->info.speed = 0;\n\t\tcd->info.capacity = 1;\n\t\tcd->info.mask = 0;\n\t\tdisk->major = major;\n\t\tdisk->first_minor = unit;\n\t\tstrcpy(disk->disk_name, cd->name);\t/* umm... */\n\t\tdisk->fops = &pcd_bdops;\n\t\tdisk->flags = GENHD_FL_BLOCK_EVENTS_ON_EXCL_WRITE;\n\t}\n}", "target": 1, "idx": 10661}
{"commit_id": "5186ddcf9e35a7aa0ff0539489a930434a1325f4", "project": "Fstark-prog/jhead", "func": "int ReadJpegSections (FILE * infile, ReadMode_t ReadMode)\n{\n    int a;\n    int HaveCom = FALSE;\n\n    a = fgetc(infile);\n\n    if (a != 0xff || fgetc(infile) != M_SOI){\n        return FALSE;\n    }\n\n    ImageInfo.JfifHeader.XDensity = ImageInfo.JfifHeader.YDensity = 300;\n    ImageInfo.JfifHeader.ResolutionUnits = 1;\n\n    for(;;){\n        int itemlen;\n        int prev;\n        int marker = 0;\n        int ll,lh, got;\n        uchar * Data;\n\n        CheckSectionsAllocated();\n\n        prev = 0;\n        for (a=0;;a++){\n            marker = fgetc(infile);\n            if (marker != 0xff && prev == 0xff) break;\n            if (marker == EOF){\n                ErrFatal(\"Unexpected end of file\");\n            }\n            prev = marker;\n        }\n\n        if (a > 10){\n            ErrNonfatal(\"Extraneous %d padding bytes before section %02X\",a-1,marker);\n        }\n\n        Sections[SectionsRead].Type = marker;\n  \n        // Read the length of the section.\n        lh = fgetc(infile);\n        ll = fgetc(infile);\n        if (lh == EOF || ll == EOF){\n            ErrFatal(\"Unexpected end of file\");\n        }\n\n        itemlen = (lh << 8) | ll;\n\n        if (itemlen < 2){\n            ErrFatal(\"invalid marker\");\n        }\n\n        Sections[SectionsRead].Size = itemlen;\n\n        // Allocate an extra 20 bytes more than needed, because sometimes when reading structures,\n        // if the section erroneously ends before short structures that should be there, that can trip\n        // memory checkers in combination with fuzzers.\n        Data = (uchar *)malloc(itemlen+20);\n        if (Data == NULL){\n            ErrFatal(\"Could not allocate memory\");\n        }\n        Sections[SectionsRead].Data = Data;\n\n        // Store first two pre-read bytes.\n        Data[0] = (uchar)lh;\n        Data[1] = (uchar)ll;\n\n        got = fread(Data+2, 1, itemlen-2, infile); // Read the whole section.\n        if (got != itemlen-2){\n            ErrFatal(\"Premature end of file?\");\n        }\n        SectionsRead += 1;\n\n        switch(marker){\n\n            case M_SOS:   // stop before hitting compressed data \n                // If reading entire image is requested, read the rest of the data.\n                if (ReadMode & READ_IMAGE){\n                    int cp, ep, size;\n                    // Determine how much file is left.\n                    cp = ftell(infile);\n                    fseek(infile, 0, SEEK_END);\n                    ep = ftell(infile);\n                    fseek(infile, cp, SEEK_SET);\n\n                    size = ep-cp;\n                    Data = (uchar *)malloc(size);\n                    if (Data == NULL){\n                        ErrFatal(\"could not allocate data for entire image\");\n                    }\n\n                    got = fread(Data, 1, size, infile);\n                    if (got != size){\n                        ErrFatal(\"could not read the rest of the image\");\n                    }\n\n                    CheckSectionsAllocated();\n                    Sections[SectionsRead].Data = Data;\n                    Sections[SectionsRead].Size = size;\n                    Sections[SectionsRead].Type = PSEUDO_IMAGE_MARKER;\n                    SectionsRead ++;\n                    HaveAll = 1;\n                }\n                return TRUE;\n\n            case M_DQT:\n                // Use for jpeg quality guessing\n                process_DQT(Data, itemlen);\n                break;\n\n            case M_DHT:   \n                // Use for jpeg quality guessing\n                process_DHT(Data, itemlen);\n                break;\n\n\n            case M_EOI:   // in case it's a tables-only JPEG stream\n                fprintf(stderr,\"No image in jpeg!\\n\");\n                return FALSE;\n\n            case M_COM: // Comment section\n                if (HaveCom || ((ReadMode & READ_METADATA) == 0)){\n                    // Discard this section.\n                    free(Sections[--SectionsRead].Data);\n                }else{\n                    process_COM(Data, itemlen);\n                    HaveCom = TRUE;\n                }\n                break;\n\n            case M_JFIF:\n                // Regular jpegs always have this tag, exif images have the exif\n                // marker instead, althogh ACDsee will write images with both markers.\n                // this program will re-create this marker on absence of exif marker.\n                // hence no need to keep the copy from the file.\n                if (itemlen < 16){\n                    fprintf(stderr,\"Jfif header too short\\n\");\n                    goto ignore;\n                }\n                if (memcmp(Data+2, \"JFIF\\0\",5)){\n                    fprintf(stderr,\"Header missing JFIF marker\\n\");\n                }\n\n                ImageInfo.JfifHeader.Present = TRUE;\n                ImageInfo.JfifHeader.ResolutionUnits = Data[9];\n                ImageInfo.JfifHeader.XDensity = (Data[10]<<8) | Data[11];\n                ImageInfo.JfifHeader.YDensity = (Data[12]<<8) | Data[13];\n                if (ShowTags){\n                    printf(\"JFIF SOI marker: Units: %d \",ImageInfo.JfifHeader.ResolutionUnits);\n                    switch(ImageInfo.JfifHeader.ResolutionUnits){\n                        case 0: printf(\"(aspect ratio)\"); break;\n                        case 1: printf(\"(dots per inch)\"); break;\n                        case 2: printf(\"(dots per cm)\"); break;\n                        default: printf(\"(unknown)\"); break;\n                    }\n                    printf(\"  X-density=%d Y-density=%d\\n\",ImageInfo.JfifHeader.XDensity, ImageInfo.JfifHeader.YDensity);\n\n                    if (Data[14] || Data[15]){\n                        fprintf(stderr,\"Ignoring jfif header thumbnail\\n\");\n                    }\n                }\n\n                ignore:\n\n                free(Sections[--SectionsRead].Data);\n                break;\n\n            case M_EXIF:\n                // There can be different section using the same marker.\n                if (ReadMode & READ_METADATA){\n                    if (memcmp(Data+2, \"Exif\", 4) == 0){\n                        process_EXIF(Data, itemlen);\n                        break;\n                    }else if (memcmp(Data+2, \"http:\", 5) == 0){\n                        Sections[SectionsRead-1].Type = M_XMP; // Change tag for internal purposes.\n                        if (ShowTags){\n                            printf(\"Image contains XMP section, %d bytes long\\n\", itemlen);\n                            if (ShowTags){\n                                ShowXmp(Sections[SectionsRead-1]);\n                            }\n                        }\n                        break;\n                    }\n                }\n                // Oterwise, discard this section.\n                free(Sections[--SectionsRead].Data);\n                break;\n\n            case M_IPTC:\n                if (ReadMode & READ_METADATA){\n                    if (ShowTags){\n                        printf(\"Image contains IPTC section, %d bytes long\\n\", itemlen);\n                    }\n                    // Note: We just store the IPTC section.  Its relatively straightforward\n                    // and we don't act on any part of it, so just display it at parse time.\n                }else{\n                    free(Sections[--SectionsRead].Data);\n                }\n                break;\n           \n            case M_SOF0: \n            case M_SOF1: \n            case M_SOF2: \n            case M_SOF3: \n            case M_SOF5: \n            case M_SOF6: \n            case M_SOF7: \n            case M_SOF9: \n            case M_SOF10:\n            case M_SOF11:\n            case M_SOF13:\n            case M_SOF14:\n            case M_SOF15:\n                if (itemlen < 8){\n                    fprintf(stderr,\"Section too short\\n\");\n                    break;\n                }\n                process_SOFn(Data, marker);\n                break;\n            default:\n                // Skip any other sections.\n                if (ShowTags){\n                    printf(\"Jpeg section marker 0x%02x size %d\\n\",marker, itemlen);\n                }\n                break;\n        }\n    }\n    return TRUE;\n}", "target": 1, "idx": 10662}
{"commit_id": "ca8ac8acdad662230ae37998c6c4091bb39402b6", "project": "android", "func": "static bool getCoverageFormat4(vector<uint32_t>& coverage, const uint8_t* data, size_t size) {\n    const size_t kSegCountOffset = 6;\n    const size_t kEndCountOffset = 14;\n    const size_t kHeaderSize = 16;\n    const size_t kSegmentSize = 8;  // total size of array elements for one segment\n    if (kEndCountOffset > size) {\n        return false;\n    }\n    size_t segCount = readU16(data, kSegCountOffset) >> 1;\n    if (kHeaderSize + segCount * kSegmentSize > size) {\n        return false;\n    }\n    for (size_t i = 0; i < segCount; i++) {\n        uint32_t end = readU16(data, kEndCountOffset + 2 * i);\n        uint32_t start = readU16(data, kHeaderSize + 2 * (segCount + i));\n        if (end < start) {\n            // invalid segment range: size must be positive\n            return false;\n        }\n        uint32_t rangeOffset = readU16(data, kHeaderSize + 2 * (3 * segCount + i));\n        if (rangeOffset == 0) {\n            uint32_t delta = readU16(data, kHeaderSize + 2 * (2 * segCount + i));\n            if (((end + delta) & 0xffff) > end - start) {\n                addRange(coverage, start, end + 1);\n            } else {\n                for (uint32_t j = start; j < end + 1; j++) {\n                    if (((j + delta) & 0xffff) != 0) {\n                        addRange(coverage, j, j + 1);\n                    }\n                }\n            }\n        } else {\n            for (uint32_t j = start; j < end + 1; j++) {\n                uint32_t actualRangeOffset = kHeaderSize + 6 * segCount + rangeOffset +\n                    (i + j - start) * 2;\n                if (actualRangeOffset + 2 > size) {\n                    return false;\n                }\n                uint32_t glyphId = readU16(data, actualRangeOffset);\n                if (glyphId != 0) {\n                    addRange(coverage, j, j + 1);\n                }\n            }\n        }\n    }\n    return true;\n}", "target": 1, "idx": 10663}
{"commit_id": "dd504589577d8e8e70f51f997ad487a4cb6c026f", "project": "torvalds/linux", "func": "static int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)\n{\n\tstruct skcipher_tfm *tfm = private;\n\tint err;\n\n\terr = crypto_skcipher_setkey(tfm->skcipher, key, keylen);\n\ttfm->has_key = !err;\n\n\treturn err;\n}", "target": 1, "idx": 10664}
{"commit_id": "2e5ff86102a973a1e3f7bedefd3bcf9bd510a9ca", "project": "starnight/MicroHttpServer", "func": "uint8_t _ReadStaticFiles(HTTPReqMessage *req, HTTPResMessage *res) {\n\tuint8_t found = 0;\n\tint8_t depth = 0;\n\tchar *uri = req->Header.URI;\n\tsize_t n = strlen(uri);\n\tsize_t i;\n\n\tFILE *fp;\n\tint size;\n\tchar path[MAX_PATH_SIZE] = {STATIC_FILE_FOLDER};\n\n\tchar header[] = \"HTTP/1.1 200 OK\\r\\nConnection: close\\r\\n\"\n\t                \"Content-Type: text/html; charset=UTF-8\\r\\n\\r\\n\";\n\n\t/* Prevent path buffer overflow. */\n\tif (strlen(STATIC_FILE_FOLDER) + n >= MAX_PATH_SIZE)\n\t\treturn found;\n\n\t/* Prevent Path Traversal. */\n\tfor(i=0; i<n; i++) {\n\t\tif(uri[i] == '/') {\n\t\t\tif(((n-i) > 2) && (uri[i+1] == '.') && ((uri[i+2] == '.'))) {\n\t\t\t\tdepth -= 1;\n\t\t\t\tif(depth < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (((n-i) > 1) && (uri[i+1] == '.'))\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tdepth += 1;\n\t\t}\n\t}\n\n\tif((depth >= 0) && (uri[i-1] != '/')) {\n\t\t/* Try to open and load the static file. */\n\t\tmemcpy(path + strlen(STATIC_FILE_FOLDER), uri, strlen(uri));\n\t\tfp = fopen(path, \"r\");\n\t\tif(fp != NULL) {\n\t\t\tfseek(fp, 0, SEEK_END);\n\t\t\tsize = ftell(fp);\n\t\t\tfseek(fp, 0, SEEK_SET);\n\n\t\t\tif(size < MAX_BODY_SIZE) {\n\t\t\t\t/* Build HTTP OK header. */\n\t\t\t\tn = strlen(header);\n\t\t\t\tmemcpy(res->_buf, header, n);\n\t\t\t\ti = n;\n\n\t\t\t\t/* Build HTTP body. */\n\t\t\t\tn = fread(res->_buf + i, 1, size, fp);\n\t\t\t\ti += n;\n\n\t\t\t\tres->_index = i;\n\n\t\t\t\tfound = 1;\n\t\t\t}\n\t\t\tfclose(fp);\n\t\t}\n\t}\n\n\treturn found;\n}", "target": 3, "idx": 10665}
{"commit_id": "4a59cfaf9ab3d48fca4a15c0d2674bf7138e3d1a", "project": "jasper-software/jasper", "func": "void jpc_qmfb_split_colres(jpc_fix_t *a, int numrows, int numcols,\n  int stride, int parity)\n{\n\n\tint bufsize = JPC_CEILDIVPOW2(numrows, 1);\n\tjpc_fix_t splitbuf[QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE];\n\tjpc_fix_t *buf = splitbuf;\n\tjpc_fix_t *srcptr;\n\tjpc_fix_t *dstptr;\n\tregister jpc_fix_t *srcptr2;\n\tregister jpc_fix_t *dstptr2;\n\tregister int n;\n\tregister int i;\n\tint m;\n\tint hstartcol;\n\n\t/* Get a buffer. */\n\tif (bufsize > QMFB_SPLITBUFSIZE) {\n\t\tif (!(buf = jas_alloc3(bufsize, numcols, sizeof(jpc_fix_t)))) {\n\t\t\t/* We have no choice but to commit suicide in this case. */\n\t\t\tabort();\n\t\t}\n\t}\n\n\tif (numrows >= 2) {\n\t\thstartcol = (numrows + 1 - parity) >> 1;\n\t\t// ORIGINAL (WRONG): m = (parity) ? hstartcol : (numrows - hstartcol);\n\t\tm = numrows - hstartcol;\n\n\t\t/* Save the samples destined for the highpass channel. */\n\t\tn = m;\n\t\tdstptr = buf;\n\t\tsrcptr = &a[(1 - parity) * stride];\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += numcols;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\t/* Copy the appropriate samples into the lowpass channel. */\n\t\tdstptr = &a[(1 - parity) * stride];\n\t\tsrcptr = &a[(2 - parity) * stride];\n\t\tn = numrows - m - (!parity);\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\t/* Copy the saved samples into the highpass channel. */\n\t\tdstptr = &a[hstartcol * stride];\n\t\tsrcptr = buf;\n\t\tn = m;\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += numcols;\n\t\t}\n\t}\n\n\t/* If the split buffer was allocated on the heap, free this memory. */\n\tif (buf != splitbuf) {\n\t\tjas_free(buf);\n\t}\n\n}", "target": 2, "idx": 10666}
{"commit_id": "a014f4c224a7b21f1c648257d1fd1128413129aa", "project": "PowerDNS/pdns", "func": "void declareArguments()\n{\n  ::arg().set(\"local-port\",\"The port on which we listen\")=\"53\";\n  ::arg().setSwitch(\"experimental-dnsupdate\",\"Enable/Disable DNS update (RFC2136) support. Default is no.\")=\"no\";\n  ::arg().set(\"allow-dnsupdate-from\",\"A global setting to allow DNS updates from these IP ranges.\")=\"127.0.0.0/8,::1\";\n  ::arg().setSwitch(\"forward-dnsupdate\",\"A global setting to allow DNS update packages that are for a Slave domain, to be forwarded to the master.\")=\"yes\";\n  ::arg().setSwitch(\"log-dns-details\",\"If PDNS should log DNS non-erroneous details\")=\"no\";\n  ::arg().setSwitch(\"log-dns-queries\",\"If PDNS should log all incoming DNS queries\")=\"no\";\n  ::arg().set(\"local-address\",\"Local IP addresses to which we bind\")=\"0.0.0.0\";\n  ::arg().setSwitch(\"local-address-nonexist-fail\",\"Fail to start if one or more of the local-address's do not exist on this server\")=\"yes\";\n  ::arg().set(\"local-ipv6\",\"Local IP address to which we bind\")=\"\";\n  ::arg().setSwitch(\"reuseport\",\"Enable higher performance on compliant kernels by using SO_REUSEPORT allowing each receiver thread to open its own socket\")=\"no\";\n  ::arg().setSwitch(\"local-ipv6-nonexist-fail\",\"Fail to start if one or more of the local-ipv6 addresses do not exist on this server\")=\"yes\";\n  ::arg().set(\"query-local-address\",\"Source IP address for sending queries\")=\"0.0.0.0\";\n  ::arg().set(\"query-local-address6\",\"Source IPv6 address for sending queries\")=\"::\";\n  ::arg().set(\"overload-queue-length\",\"Maximum queuelength moving to packetcache only\")=\"0\";\n  ::arg().set(\"max-queue-length\",\"Maximum queuelength before considering situation lost\")=\"5000\";\n\n  ::arg().set(\"retrieval-threads\", \"Number of AXFR-retrieval threads for slave operation\")=\"2\";\n  ::arg().setSwitch(\"experimental-json-interface\", \"If the webserver should serve JSON data\")=\"no\";\n  ::arg().setSwitch(\"experimental-api-readonly\", \"If the JSON API should disallow data modification\")=\"no\";\n  ::arg().set(\"experimental-api-key\", \"REST API Static authentication key (required for API use)\")=\"\";\n  ::arg().setSwitch(\"experimental-dname-processing\", \"If we should support DNAME records\")=\"no\";\n\n  ::arg().setCmd(\"help\",\"Provide a helpful message\");\n  ::arg().setCmd(\"version\",\"Output version and compilation date\");\n  ::arg().setCmd(\"config\",\"Provide configuration file on standard output\");\n  ::arg().setCmd(\"list-modules\",\"Lists all modules available\");\n  ::arg().setCmd(\"no-config\",\"Don't parse configuration file\");\n  \n  ::arg().set(\"version-string\",\"PowerDNS version in packets - full, anonymous, powerdns or custom\")=\"full\"; \n  ::arg().set(\"control-console\",\"Debugging switch - don't use\")=\"no\"; // but I know you will!\n  ::arg().set(\"loglevel\",\"Amount of logging. Higher is more. Do not set below 3\")=\"4\";\n  ::arg().set(\"disable-syslog\",\"Disable logging to syslog, useful when running inside a supervisor that logs stdout\")=\"no\";\n  ::arg().set(\"default-soa-name\",\"name to insert in the SOA record if none set in the backend\")=\"a.misconfigured.powerdns.server\";\n  ::arg().set(\"default-soa-mail\",\"mail address to insert in the SOA record if none set in the backend\")=\"\";\n  ::arg().set(\"distributor-threads\",\"Default number of Distributor (backend) threads to start\")=\"3\";\n  ::arg().set(\"signing-threads\",\"Default number of signer threads to start\")=\"3\";\n  ::arg().set(\"receiver-threads\",\"Default number of receiver threads to start\")=\"1\";\n  ::arg().set(\"queue-limit\",\"Maximum number of milliseconds to queue a query\")=\"1500\"; \n  ::arg().set(\"recursor\",\"If recursion is desired, IP address of a recursing nameserver\")=\"no\"; \n  ::arg().set(\"allow-recursion\",\"List of subnets that are allowed to recurse\")=\"0.0.0.0/0\";\n  ::arg().set(\"pipebackend-abi-version\",\"Version of the pipe backend ABI\")=\"1\";\n  ::arg().set(\"udp-truncation-threshold\", \"Maximum UDP response size before we truncate\")=\"1680\";\n  ::arg().set(\"disable-tcp\",\"Do not listen to TCP queries\")=\"no\";\n  \n  ::arg().set(\"config-name\",\"Name of this virtual configuration - will rename the binary image\")=\"\";\n\n  ::arg().set(\"load-modules\",\"Load this module - supply absolute or relative path\")=\"\";\n  ::arg().set(\"launch\",\"Which backends to launch and order to query them in\")=\"\";\n  ::arg().setSwitch(\"disable-axfr\",\"Disable zonetransfers but do allow TCP queries\")=\"no\";\n  ::arg().set(\"allow-axfr-ips\",\"Allow zonetransfers only to these subnets\")=\"127.0.0.0/8,::1\";\n  ::arg().set(\"only-notify\", \"Only send AXFR NOTIFY to these IP addresses or netmasks\")=\"0.0.0.0/0,::/0\";\n  ::arg().set(\"also-notify\", \"When notifying a domain, also notify these nameservers\")=\"\";\n  ::arg().set(\"allow-notify-from\",\"Allow AXFR NOTIFY from these IP ranges. If empty, drop all incoming notifies.\")=\"0.0.0.0/0,::/0\";\n  ::arg().set(\"slave-cycle-interval\",\"Schedule slave freshness checks once every .. seconds\")=\"60\";\n\n  ::arg().set(\"tcp-control-address\",\"If set, PowerDNS can be controlled over TCP on this address\")=\"\";\n  ::arg().set(\"tcp-control-port\",\"If set, PowerDNS can be controlled over TCP on this address\")=\"53000\";\n  ::arg().set(\"tcp-control-secret\",\"If set, PowerDNS can be controlled over TCP after passing this secret\")=\"\";\n  ::arg().set(\"tcp-control-range\",\"If set, remote control of PowerDNS is possible over these networks only\")=\"127.0.0.0/8, 10.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12, ::1/128, fe80::/10\";\n  \n  ::arg().setSwitch(\"slave\",\"Act as a slave\")=\"no\";\n  ::arg().setSwitch(\"master\",\"Act as a master\")=\"no\";\n  ::arg().setSwitch(\"disable-axfr-rectify\",\"Disable the rectify step during an outgoing AXFR. Only required for regression testing.\")=\"no\";\n  ::arg().setSwitch(\"guardian\",\"Run within a guardian process\")=\"no\";\n  ::arg().setSwitch(\"send-root-referral\",\"Send out old-fashioned root-referral instead of ServFail in case of no authority\")=\"no\";\n  ::arg().setSwitch(\"prevent-self-notification\",\"Don't send notifications to what we think is ourself\")=\"yes\";\n  ::arg().setSwitch(\"webserver\",\"Start a webserver for monitoring\")=\"no\"; \n  ::arg().setSwitch(\"webserver-print-arguments\",\"If the webserver should print arguments\")=\"no\"; \n  ::arg().setSwitch(\"edns-subnet-processing\",\"If we should act on EDNS Subnet options\")=\"no\"; \n  ::arg().setSwitch(\"any-to-tcp\",\"Answer ANY queries with tc=1, shunting to TCP\")=\"no\"; \n  ::arg().set(\"webserver-address\",\"IP Address of webserver to listen on\")=\"127.0.0.1\";\n  ::arg().set(\"webserver-port\",\"Port of webserver to listen on\")=\"8081\";\n  ::arg().set(\"webserver-password\",\"Password required for accessing the webserver\")=\"\";\n  ::arg().set(\"webserver-allow-from\",\"Webserver access is only allowed from these subnets\")=\"0.0.0.0/0,::/0\";\n\n  ::arg().setSwitch(\"out-of-zone-additional-processing\",\"Do out of zone additional processing\")=\"yes\";\n  ::arg().setSwitch(\"do-ipv6-additional-processing\", \"Do AAAA additional processing\")=\"yes\";\n  ::arg().setSwitch(\"query-logging\",\"Hint backends that queries should be logged\")=\"no\";\n\n  ::arg().set(\"carbon-ourname\", \"If set, overrides our reported hostname for carbon stats\")=\"\";\n  ::arg().set(\"carbon-server\", \"If set, send metrics in carbon (graphite) format to this server\")=\"\";\n  ::arg().set(\"carbon-interval\", \"Number of seconds between carbon (graphite) updates\")=\"30\";\n\n  ::arg().set(\"cache-ttl\",\"Seconds to store packets in the PacketCache\")=\"20\";\n  ::arg().set(\"recursive-cache-ttl\",\"Seconds to store packets for recursive queries in the PacketCache\")=\"10\";\n  ::arg().set(\"negquery-cache-ttl\",\"Seconds to store negative query results in the QueryCache\")=\"60\";\n  ::arg().set(\"query-cache-ttl\",\"Seconds to store query results in the QueryCache\")=\"20\";\n  ::arg().set(\"soa-minimum-ttl\",\"Default SOA minimum ttl\")=\"3600\";\n  ::arg().set(\"server-id\", \"Returned when queried for 'server.id' TXT or NSID, defaults to hostname - disabled or custom\")=\"\";\n  ::arg().set(\"soa-refresh-default\",\"Default SOA refresh\")=\"10800\";\n  ::arg().set(\"soa-retry-default\",\"Default SOA retry\")=\"3600\";\n  ::arg().set(\"soa-expire-default\",\"Default SOA expire\")=\"604800\";\n  ::arg().set(\"default-soa-edit\",\"Default SOA-EDIT value\")=\"\";\n  ::arg().set(\"default-soa-edit-signed\",\"Default SOA-EDIT value for signed zones\")=\"\";\n\n  ::arg().set(\"trusted-notification-proxy\", \"IP address of incoming notification proxy\")=\"\";\n  ::arg().set(\"slave-renotify\", \"If we should send out notifications for slaved updates\")=\"no\";\n\n  ::arg().set(\"default-ttl\",\"Seconds a result is valid if not set otherwise\")=\"3600\";\n  ::arg().set(\"max-tcp-connections\",\"Maximum number of TCP connections\")=\"10\";\n  ::arg().setSwitch(\"no-shuffle\",\"Set this to prevent random shuffling of answers - for regression testing\")=\"off\";\n\n  ::arg().set(\"experimental-logfile\", \"Filename of the log file for JSON parser\" )= \"/var/log/pdns.log\";\n  ::arg().set(\"setuid\",\"If set, change user id to this uid for more security\")=\"\";\n  ::arg().set(\"setgid\",\"If set, change group id to this gid for more security\")=\"\";\n\n  ::arg().set(\"max-cache-entries\", \"Maximum number of cache entries\")=\"1000000\";\n  ::arg().set(\"max-signature-cache-entries\", \"Maximum number of signatures cache entries\")=\"\";\n  ::arg().set(\"max-ent-entries\", \"Maximum number of empty non-terminals in a zone\")=\"100000\";\n  ::arg().set(\"entropy-source\", \"If set, read entropy from this file\")=\"/dev/urandom\";\n\n  ::arg().set(\"lua-prequery-script\", \"Lua script with prequery handler\")=\"\";\n\n  ::arg().setSwitch(\"traceback-handler\",\"Enable the traceback handler (Linux only)\")=\"yes\";\n  ::arg().setSwitch(\"direct-dnskey\",\"Fetch DNSKEY RRs from backend during DNSKEY synthesis\")=\"no\";\n  ::arg().set(\"default-ksk-algorithms\",\"Default KSK algorithms\")=\"rsasha256\";\n  ::arg().set(\"default-ksk-size\",\"Default KSK size (0 means default)\")=\"0\";\n  ::arg().set(\"default-zsk-algorithms\",\"Default ZSK algorithms\")=\"rsasha256\";\n  ::arg().set(\"default-zsk-size\",\"Default ZSK size (0 means default)\")=\"0\";\n  ::arg().set(\"max-nsec3-iterations\",\"Limit the number of NSEC3 hash iterations\")=\"500\"; // RFC5155 10.3\n\n  ::arg().set(\"include-dir\",\"Include *.conf files from this directory\");\n  ::arg().set(\"security-poll-suffix\",\"Domain name from which to query security update notifications\")=\"secpoll.powerdns.com.\";\n\n  ::arg().set(\"xfr-max-received-mbytes\", \"Maximum number of megabytes received from an incoming AXFR\")=\"100\";\n}", "target": 1, "idx": 10667}
{"commit_id": "4a948427100b6c109f4ec7b4361f0d2aec5e5c3f", "project": "wireshark", "func": "static tvbuff_t*\ndecompress(packet_info* pinfo, proto_tree* tree, tvbuff_t* tvb, gint offset, gint length)\n{\n\tif(PINFO_FD_VISITED(pinfo)) {\n\t\tconst decompress_result_t* saved_data = (decompress_result_t *)p_get_proto_data(wmem_file_scope(), pinfo, proto_blip, 0);\n\t\tif(!saved_data) {\n\t\t\tproto_tree_add_string(tree, hf_blip_message_body, tvb, offset, tvb_reported_length_remaining(tvb, offset), \"<Error decompressing data>\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif(saved_data->domain) {\n\t\t\tproto_item* field = proto_tree_add_string(tree, hf_blip_message_body, tvb, offset, tvb_reported_length_remaining(tvb, offset), \"<Error decompressing data>\");\n\t\t\tif(saved_data->domain == zlib_error) {\n\t\t\t\texpert_add_info_format(pinfo, field, &ei_blip_decompress_buffer_too_small, \"Unable to decompress message, got zlib error %d\", saved_data->code);\n\t\t\t} else {\n\t\t\t\texpert_add_info_format(pinfo, field, &ei_blip_decompress_buffer_too_small, \"Unable to decompress message, buffer too small (%u Kb).  Please adjust in settings.\", max_uncompressed_size);\n\t\t\t}\n\n\t\t\treturn NULL;\n\t\t} else {\n\t\t\ttvbuff_t* decompressedChild = tvb_new_child_real_data(tvb, (guint8 *)saved_data->buf,\n\t\t\t\t(gint)saved_data->size, (gint)saved_data->size);\n\t\t\tadd_new_data_source(pinfo, decompressedChild, \"Decompressed Payload\");\n\t\t\treturn decompressedChild;\n\t\t}\n\t}\n\n\tstatic gboolean size_overflow = FALSE;\n\tconst guint8* buf = tvb_get_ptr(tvb, offset, length);\n\tz_stream* decompress_stream = get_decompress_stream(pinfo);\n\tstatic Byte trailer[4] = { 0x00, 0x00, 0xff, 0xff };\n\tif(!decompress_stream->next_out) {\n\t\tdecompress_stream->zalloc = 0;\n\t\tdecompress_stream->zfree = 0;\n\t\tdecompress_stream->opaque = 0;\n\t\tint err = inflateInit2(decompress_stream, -MAX_WBITS);\n\t\tif(err != Z_OK) {\n\t\t\tdecompress_stream->next_out = 0;\n\t\t\tREPORT_DISSECTOR_BUG(\"Unable to create INFLATE context to decompress messages\");\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t// Create a temporary buffer of the maximum size, which will get cleaned up later\n\t// when the packet scope is freed\n\tuInt buffer_size = max_uncompressed_size * 1024;\n\tBytef* decompress_buffer = (Bytef*)wmem_alloc(wmem_packet_scope(), buffer_size);\n\tdecompress_stream->next_in = (Bytef*)buf;\n\tdecompress_stream->avail_in = length;\n\tdecompress_stream->next_out = decompress_buffer;\n\tdecompress_stream->avail_out = buffer_size;\n\tuLong start = decompress_stream->total_out;\n\tint err = inflate(decompress_stream, Z_NO_FLUSH);\n\tif(err != Z_OK) {\n\t\tproto_item* field = proto_tree_add_string(tree, hf_blip_message_body, tvb, offset, tvb_reported_length_remaining(tvb, offset), \"<Error decompressing data>\");\n\t\tdecompress_result_t* data_to_save = wmem_new0(wmem_file_scope(), decompress_result_t);\n\t\tif(size_overflow && err == Z_DATA_ERROR) {\n\t\t\tdata_to_save->domain = overflow_error;\n\t\t\texpert_add_info_format(pinfo, field, &ei_blip_decompress_buffer_too_small, \"Unable to decompress message, buffer too small (%u Kb).  Please adjust in settings.\", max_uncompressed_size);\n\t\t} else {\n\t\t\tdata_to_save->domain = zlib_error;\n\t\t\tdata_to_save->code = err;\n\t\t\texpert_add_info_format(pinfo, field, &ei_blip_decompress_buffer_too_small, \"Unable to decompress message, got zlib error %d\", err);\n\t\t}\n\n\t\tp_add_proto_data(wmem_file_scope(), pinfo, proto_blip, 0, data_to_save);\n\t\treturn NULL;\n\t}\n\n\tdecompress_stream->next_in = trailer;\n\tdecompress_stream->avail_in = 4;\n\terr = inflate(decompress_stream, Z_SYNC_FLUSH);\n\tif(err != Z_OK) {\n\t\tproto_item* field = proto_tree_add_string(tree, hf_blip_message_body, tvb, offset, tvb_reported_length_remaining(tvb, offset), \"<Error decompressing data>\");\n\t\tdecompress_result_t* data_to_save = wmem_new0(wmem_file_scope(), decompress_result_t);\n\t\tif(err == Z_BUF_ERROR) {\n\t\t\tdata_to_save->domain = overflow_error;\n\t\t\tsize_overflow = TRUE;\n\t\t\texpert_add_info_format(pinfo, field, &ei_blip_decompress_buffer_too_small, \"Unable to decompress message, buffer too small (%u Kb).  Please adjust in settings.\", max_uncompressed_size);\n\t\t} else {\n\t\t\tdata_to_save->domain = zlib_error;\n\t\t\tdata_to_save->code = err;\n\t\t\texpert_add_info_format(pinfo, field, &ei_blip_decompress_buffer_too_small, \"Unable to decompress message, got zlib error %d\", err);\n\t\t}\n\n\t\tp_add_proto_data(wmem_file_scope(), pinfo, proto_blip, 0, data_to_save);\n\t\treturn NULL;\n\t}\n\n\t// Shrink the buffer so that there is not wasted space on the end of it since\n\t// it will be long lived in the file scope\n\tuLong bodyLength = decompress_stream->total_out - start;\n\tBytef* shortened_buffer = (Bytef *)wmem_memdup(wmem_file_scope(), decompress_buffer, bodyLength);\n\n\ttvbuff_t* decompressedChild = tvb_new_child_real_data(tvb, shortened_buffer, (guint)bodyLength, (gint)bodyLength);\n\tadd_new_data_source(pinfo, decompressedChild, \"Decompressed Payload\");\n\tdecompress_result_t* data_to_save = wmem_new0(wmem_file_scope(), decompress_result_t);\n\tdata_to_save->size = (size_t)bodyLength;\n\tdata_to_save->buf = shortened_buffer;\n\tp_add_proto_data(wmem_file_scope(), pinfo, proto_blip, 0, data_to_save);\n\n\treturn decompressedChild;\n}", "target": 2, "idx": 10668}
{"commit_id": "58a3122250d54de3a944c487776bcd4d1da4721e", "project": "FreeRDP", "func": "static NTLM_AV_PAIR* ntlm_av_pair_next(NTLM_AV_PAIR* pAvPair, size_t* pcbAvPair)\n{\n\tsize_t offset;\n\n\tif (!pcbAvPair)\n\t\treturn NULL;\n\tif (!ntlm_av_pair_check(pAvPair, *pcbAvPair))\n\t\treturn NULL;\n\n\tif (!ntlm_av_pair_get_next_offset(pAvPair, *pcbAvPair, &offset))\n\t\treturn NULL;\n\n\t*pcbAvPair -= offset;\n\treturn (NTLM_AV_PAIR*)((PBYTE)pAvPair + offset);\n}", "target": 0, "idx": 10669}
{"commit_id": "2fd04b6ba9d830cd1324572530237b6fea58f96e", "project": "wireshark", "func": "static int\ndisplay_extension_block(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset, gchar *bundle_custodian, gboolean *lastheader)\n{\n    proto_item   *block_item, *ti, *block_flag_replicate_item, *block_flag_eid_reference_item;\n    proto_tree   *block_tree;\n    int           sdnv_length;\n    int           block_length;\n    int           block_overhead;\n    int           bundle_age;\n    guint8        type;\n    unsigned int  control_flags;\n    proto_tree   *block_flag_tree;\n    proto_item   *block_flag_item;\n\n    type = tvb_get_guint8(tvb, offset);\n    block_tree = proto_tree_add_subtree(tree, tvb, offset, -1, ett_metadata_hdr, &block_item, \"Extension Block\");\n\n    proto_tree_add_item(block_tree, hf_bundle_block_type_code, tvb, offset, 1, ENC_BIG_ENDIAN);\n    ++offset;\n    block_overhead = 1;\n\n    control_flags = (unsigned int)evaluate_sdnv(tvb, offset, &sdnv_length);\n    if (control_flags & BLOCK_CONTROL_LAST_BLOCK) {\n        *lastheader = TRUE;\n    } else {\n        *lastheader = FALSE;\n    }\n    block_flag_item = proto_tree_add_uint(block_tree, hf_block_control_flags_sdnv, tvb,\n                                            offset, sdnv_length, control_flags);\n    block_flag_tree = proto_item_add_subtree(block_flag_item, ett_block_flags);\n    block_flag_replicate_item = proto_tree_add_boolean(block_flag_tree, hf_block_control_replicate,\n                           tvb, offset, sdnv_length, control_flags);\n    proto_tree_add_boolean(block_flag_tree, hf_block_control_transmit_status,\n                           tvb, offset, sdnv_length, control_flags);\n    proto_tree_add_boolean(block_flag_tree, hf_block_control_delete_bundle,\n                           tvb, offset, sdnv_length, control_flags);\n    proto_tree_add_boolean(block_flag_tree, hf_block_control_last_block,\n                           tvb, offset, sdnv_length, control_flags);\n    proto_tree_add_boolean(block_flag_tree, hf_block_control_discard_block,\n                           tvb, offset, sdnv_length, control_flags);\n    proto_tree_add_boolean(block_flag_tree, hf_block_control_not_processed,\n                           tvb, offset, sdnv_length, control_flags);\n    block_flag_eid_reference_item = proto_tree_add_boolean(block_flag_tree, hf_block_control_eid_reference,\n                           tvb, offset, sdnv_length, control_flags);\n    offset += sdnv_length;\n    block_overhead += sdnv_length;\n\n    /* TODO: if this block has EID references, add them to display tree */\n    if (control_flags & BLOCK_CONTROL_EID_REFERENCE) {\n        int i;\n        int num_eid_ref;\n\n        num_eid_ref = evaluate_sdnv(tvb, offset, &sdnv_length);\n        offset += sdnv_length;\n        block_overhead += sdnv_length;\n\n        for (i = 0; i < num_eid_ref; i++)\n        {\n            if (evaluate_sdnv(tvb, offset, &sdnv_length) < 0)\n                break;\n            offset += sdnv_length;\n            block_overhead += sdnv_length;\n\n            if (evaluate_sdnv(tvb, offset, &sdnv_length) < 0)\n                break;\n            offset += sdnv_length;\n            block_overhead += sdnv_length;\n        }\n    }\n\n    block_length = evaluate_sdnv(tvb, offset, &sdnv_length);\n    ti = proto_tree_add_int(block_tree, hf_block_control_block_length, tvb, offset, sdnv_length, block_length);\n    if (block_length < 0) {\n        expert_add_info_format(pinfo, ti, &ei_bundle_offset_error, \"Metadata Block Length Error\");\n        /* Force quitting */\n        *lastheader = TRUE;\n        return offset;\n    }\n    offset += sdnv_length;\n    block_overhead += sdnv_length;\n\n    /* now we have enough info to know total length of metadata block */\n    proto_item_set_len(block_item, block_overhead + block_length);\n\n    switch (type)\n    {\n    case BUNDLE_BLOCK_TYPE_AUTHENTICATION:\n    case BUNDLE_BLOCK_TYPE_METADATA_EXTENSION:\n    case BUNDLE_BLOCK_TYPE_EXTENSION_SECURITY:\n    {\n        proto_tree_add_string(block_tree, hf_bundle_unprocessed_block_data, tvb, offset, block_length, \"Block data\");\n        /* not yet dissected, skip past data */\n        offset += block_length;\n        break;\n    }\n    case BUNDLE_BLOCK_TYPE_BUNDLE_AGE:\n    {\n        bundle_age = evaluate_sdnv(tvb, offset, &sdnv_length);\n        proto_tree_add_int(block_tree, hf_bundle_age_extension_block_code, tvb, offset, sdnv_length, bundle_age/1000000);\n        offset += block_length;\n        break;\n    }\n    case BUNDLE_BLOCK_TYPE_PREVIOUS_HOP_INSERT:\n    {\n        int scheme_length;\n\n        proto_tree_add_item_ret_length(block_tree, hf_bundle_block_previous_hop_scheme, tvb, offset, 4, ENC_ASCII, &scheme_length);\n        offset += scheme_length;\n        proto_tree_add_item(block_tree, hf_bundle_block_previous_hop_eid, tvb, offset, block_length-scheme_length, ENC_ASCII);\n        if (block_length - scheme_length < 1) {\n            expert_add_info_format(pinfo, ti, &ei_bundle_offset_error, \"Metadata Block Length Error\");\n            *lastheader = TRUE;\n            return offset;\n        }\n        offset += block_length - scheme_length;\n\n        break;\n    }\n    case BUNDLE_BLOCK_TYPE_INTEGRITY:\n    case BUNDLE_BLOCK_TYPE_CONFIDENTIALITY:\n    {\n        int target_block_type;\n        int target_block_occurrence;\n        int ciphersuite_type;\n        unsigned int ciphersuite_flags;\n\n        target_block_type = evaluate_sdnv(tvb, offset, &sdnv_length);\n        proto_tree_add_int(block_tree, hf_bundle_target_block_type, tvb, offset, sdnv_length, target_block_type);\n        offset += sdnv_length;\n\n        target_block_occurrence = evaluate_sdnv(tvb, offset, &sdnv_length);\n        proto_tree_add_int(block_tree, hf_bundle_target_block_occurrence, tvb, offset, sdnv_length, target_block_occurrence);\n        offset += sdnv_length;\n\n        ciphersuite_type = evaluate_sdnv(tvb, offset, &sdnv_length);\n        proto_tree_add_int(block_tree, hf_bundle_ciphersuite_type, tvb, offset, sdnv_length, ciphersuite_type);\n        offset += sdnv_length;\n\n        ciphersuite_flags = (unsigned int)evaluate_sdnv(tvb, offset, &sdnv_length);\n        block_flag_item = proto_tree_add_uint(block_tree, hf_bundle_ciphersuite_flags, tvb, offset, sdnv_length, ciphersuite_flags);\n        block_flag_tree = proto_item_add_subtree(block_flag_item, ett_block_flags);\n        proto_tree_add_boolean(block_flag_tree, hf_block_ciphersuite_params, tvb, offset, sdnv_length, ciphersuite_flags);\n        offset += sdnv_length;\n\n        int range_offset;\n        int range_length;\n        if (ciphersuite_flags & BLOCK_CIPHERSUITE_PARAMS) {\n            /* Decode cipher suite parameters */\n            int params_length;\n            int param_type;\n            int item_length;\n            proto_tree   *param_tree;\n            expert_field *ei = NULL;\n\n            params_length = evaluate_sdnv_ei(tvb, offset, &sdnv_length, &ei);\n            if (ei) {\n                proto_tree_add_expert(block_tree, pinfo, ei, tvb, offset, -1);\n                *lastheader = TRUE;\n                return offset;\n            }\n            param_tree = proto_tree_add_subtree(block_tree, tvb, offset, params_length+1, ett_sec_block_param_data, NULL, \"Ciphersuite Parameters Data\");\n            proto_tree_add_int(param_tree, hf_block_ciphersuite_params_length, tvb, offset, sdnv_length, params_length);\n            offset += sdnv_length;\n\n            for(int i = 0; i < params_length; i+=item_length+2)\n            {\n                param_type = evaluate_sdnv(tvb, offset, &sdnv_length);\n                proto_tree_add_int(param_tree, hf_block_ciphersuite_param_type, tvb, offset, sdnv_length, param_type);\n                offset += sdnv_length;\n\n                ei = NULL;\n                item_length = evaluate_sdnv_ei(tvb, offset, &sdnv_length, &ei);\n                proto_tree_add_int(param_tree, hf_block_ciphersuite_params_item_length, tvb, offset, sdnv_length, item_length);\n                if (ei) {\n                    proto_tree_add_expert(param_tree, pinfo, ei, tvb, offset, -1);\n                    *lastheader = TRUE;\n                    return offset;\n                }\n\n                offset += sdnv_length;\n\n                //display item data\n                switch (param_type)\n                {\n                case 1:\n                case 3:\n                case 5:\n                case 7:\n                case 8:\n                    proto_tree_add_item(param_tree, hf_block_ciphersuite_param_data, tvb, offset, item_length, ENC_NA);\n                    offset += item_length;\n                    break;\n                case 4:\n                    //pair of sdnvs offset and length\n                    range_offset = evaluate_sdnv(tvb, offset, &sdnv_length);\n                    proto_tree_add_int(param_tree, hf_block_ciphersuite_range_offset, tvb, offset, sdnv_length, range_offset);\n                    offset += sdnv_length;\n\n                    range_length = evaluate_sdnv(tvb, offset, &sdnv_length);\n                    proto_tree_add_int(param_tree, hf_block_ciphersuite_range_length, tvb, offset, sdnv_length, range_length);\n                    offset += sdnv_length;\n                    break;\n                default:\n                    break;\n                }\n            }\n        }\n        /* Decode cipher suite results */\n        int result_length;\n        int result_type;\n        int result_item_length;\n        proto_tree   *result_tree;\n\n        result_length = evaluate_sdnv(tvb, offset, &sdnv_length);\n        result_tree = proto_tree_add_subtree(block_tree, tvb, offset, result_length+1, ett_sec_block_param_data, NULL, \"Security Results Data\");\n        proto_tree_add_int(result_tree, hf_block_ciphersuite_result_length, tvb, offset, sdnv_length, result_length);\n        offset += sdnv_length;\n\n        for(int i = 0; i < result_length; i+=result_item_length+2)\n        {\n            result_type = evaluate_sdnv(tvb, offset, &sdnv_length);\n            proto_tree_add_int(result_tree, hf_block_ciphersuite_result_type, tvb, offset, sdnv_length, result_type);\n            offset += sdnv_length;\n\n            expert_field *ei = NULL;\n            result_item_length = evaluate_sdnv_ei(tvb, offset, &sdnv_length, &ei);\n            proto_tree_add_int(result_tree, hf_block_ciphersuite_result_item_length, tvb, offset, sdnv_length, result_item_length);\n            if (ei) {\n                proto_tree_add_expert(result_tree, pinfo, ei, tvb, offset, -1);\n                *lastheader = TRUE;\n                return offset;\n            }\n            offset += sdnv_length;\n\n            //display item data\n            switch (result_type)\n            {\n            case 1:\n            case 3:\n            case 5:\n            case 7:\n            case 8:\n                proto_tree_add_item(result_tree, hf_block_ciphersuite_result_data, tvb, offset, result_item_length, ENC_NA);\n                offset += result_item_length;\n                break;\n            case 4:\n                //pair of sdnvs offset and length\n                range_offset = evaluate_sdnv(tvb, offset, &sdnv_length);\n                proto_tree_add_int(result_tree, hf_block_ciphersuite_range_offset, tvb, offset, sdnv_length, range_offset);\n                offset += sdnv_length;\n\n                range_length = evaluate_sdnv(tvb, offset, &sdnv_length);\n                proto_tree_add_int(result_tree, hf_block_ciphersuite_range_length, tvb, offset, sdnv_length, range_length);\n                offset += sdnv_length;\n                break;\n            default:\n                break;\n            }\n\n        }\n        break;\n\n    }\n    case BUNDLE_BLOCK_TYPE_CUSTODY_TRANSFER:\n    {\n        int custody_id;\n        const guint8 *cteb_creator_custodian_eid;\n        int cteb_creator_custodian_eid_length;\n\n        /* check requirements for Block Processing Control Flags */\n        if ((control_flags & BLOCK_CONTROL_REPLICATE) != 0) {\n            expert_add_info_format(pinfo, block_flag_replicate_item, &ei_bundle_block_control_flags, \"ERROR: Replicate must be clear for CTEB\");\n        }\n        if ((control_flags & BLOCK_CONTROL_EID_REFERENCE) != 0) {\n            expert_add_info_format(pinfo, block_flag_eid_reference_item, &ei_bundle_block_control_flags, \"ERROR: EID-Reference must be clear for CTEB\");\n        }\n\n        /* there are two elements in a CTEB, first is the custody ID */\n        custody_id = evaluate_sdnv(tvb, offset, &sdnv_length);\n        proto_tree_add_int(block_tree, hf_block_control_block_cteb_custody_id, tvb, offset, sdnv_length, custody_id);\n        offset += sdnv_length;\n\n        /* and second is the creator custodian EID */\n        if (block_length - sdnv_length < 1) {\n            expert_add_info_format(pinfo, ti, &ei_bundle_offset_error, \"Metadata Block Length Error\");\n            *lastheader = TRUE;\n            return offset;\n        }\n        cteb_creator_custodian_eid_length = block_length - sdnv_length;\n        ti = proto_tree_add_item_ret_string(block_tree, hf_block_control_block_cteb_creator_custodian_eid, tvb, offset,\n                                cteb_creator_custodian_eid_length, ENC_ASCII, pinfo->pool, &cteb_creator_custodian_eid);\n\n        /* also check if CTEB is valid, i.e. custodians match */\n        if (bundle_custodian == NULL) {\n            expert_add_info_format(pinfo, ti, &ei_block_control_block_cteb_invalid,\n                                \"CTEB Is NOT Valid (Bundle Custodian NULL)\");\n        }\n        else if (strlen(cteb_creator_custodian_eid) != strlen(bundle_custodian)) {\n            expert_add_info_format(pinfo, ti, &ei_block_control_block_cteb_invalid,\n                                \"CTEB Is NOT Valid (Bundle Custodian [%s] != CTEB Custodian [%s])\",\n                                bundle_custodian, cteb_creator_custodian_eid);\n        }\n        else if (memcmp(cteb_creator_custodian_eid, bundle_custodian, strlen(bundle_custodian)) != 0) {\n            expert_add_info_format(pinfo, ti, &ei_block_control_block_cteb_invalid,\n                                \"CTEB Is NOT Valid (Bundle Custodian [%s] != CTEB Custodian [%s])\",\n                                bundle_custodian, cteb_creator_custodian_eid);\n        }\n        else {\n            expert_add_info(pinfo, ti, &ei_block_control_block_cteb_valid);\n        }\n        offset += cteb_creator_custodian_eid_length;\n\n        break;\n    }\n    case BUNDLE_BLOCK_TYPE_EXTENDED_COS:\n    {\n        int flags;\n        static int * const ecos_flags_fields[] = {\n            &hf_ecos_flags_critical,\n            &hf_ecos_flags_streaming,\n            &hf_ecos_flags_flowlabel,\n            &hf_ecos_flags_reliable,\n            NULL\n        };\n\n        /* check requirements for Block Processing Control Flags */\n        if ((control_flags & BLOCK_CONTROL_REPLICATE) == 0) {\n            expert_add_info_format(pinfo, block_flag_replicate_item, &ei_bundle_block_control_flags, \"ERROR: Replicate must be set for ECOS\");\n        }\n        if ((control_flags & BLOCK_CONTROL_EID_REFERENCE) != 0) {\n            expert_add_info_format(pinfo, block_flag_eid_reference_item, &ei_bundle_block_control_flags, \"ERROR: EID-Reference must be clear for ECOS\");\n        }\n\n        /* flags byte */\n        flags = (int)tvb_get_guint8(tvb, offset);\n        proto_tree_add_bitmask(block_tree, tvb, offset, hf_ecos_flags, ett_block_flags, ecos_flags_fields, ENC_BIG_ENDIAN);\n        offset += 1;\n\n        /* ordinal byte */\n        proto_tree_add_item(block_tree, hf_ecos_ordinal, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset += 1;\n\n        /* optional flow label sdnv */\n        if ((flags & ECOS_FLAGS_FLOWLABEL) != 0) {\n            int flow_label;\n            flow_label = evaluate_sdnv(tvb, offset, &sdnv_length);\n            ti = proto_tree_add_int(block_tree, hf_ecos_flow_label, tvb, offset, sdnv_length, flow_label);\n            if (flow_label < 0) {\n                expert_add_info_format(pinfo, ti, &ei_bundle_sdnv_length, \"ECOS Flow Label Error\");\n                /* Force quitting */\n                *lastheader = TRUE;\n                return offset;\n            }\n            offset += sdnv_length;\n        }\n\n        break;\n    }\n    default:\n    {\n        proto_tree_add_string(block_tree, hf_bundle_unprocessed_block_data, tvb, offset, block_length, \"Block data\");\n        /* unknown bundle type, skip past data */\n        offset += block_length;\n        break;\n    }\n    }\n\n    return offset;\n}", "target": 1, "idx": 10670}
{"commit_id": "e824c23316ae50beb7f7488f2055ac65e8b341f2", "project": "ipmitool", "func": "int\nread_fru_area_section(struct ipmi_intf * intf, struct fru_info *fru, uint8_t id,\n\t\t\tuint32_t offset, uint32_t length, uint8_t *frubuf)\n{\n\tstatic uint32_t fru_data_rqst_size = 20;\n\tuint32_t off = offset;\n\tuint32_t tmp, finish;\n\tuint32_t size_left_in_buffer;\n\tstruct ipmi_rs * rsp;\n\tstruct ipmi_rq req;\n\tuint8_t msg_data[4];\n\n\tif (offset > fru->size) {\n\t\tlprintf(LOG_ERR, \"Read FRU Area offset incorrect: %d > %d\",\n\t\t\toffset, fru->size);\n\t\treturn -1;\n\t}\n\n\tfinish = offset + length;\n\tif (finish > fru->size) {\n\t\tmemset(frubuf + fru->size, 0, length - fru->size);\n\t\tfinish = fru->size;\n\t\tlprintf(LOG_NOTICE, \"Read FRU Area length %d too large, \"\n\t\t\t\"Adjusting to %d\",\n\t\t\toffset + length, finish - offset);\n\t\tlength = finish - offset;\n\t}\n\n\tmemset(&req, 0, sizeof(req));\n\treq.msg.netfn = IPMI_NETFN_STORAGE;\n\treq.msg.cmd = GET_FRU_DATA;\n\treq.msg.data = msg_data;\n\treq.msg.data_len = 4;\n\n#ifdef LIMIT_ALL_REQUEST_SIZE\n\tif (fru_data_rqst_size > 16)\n#else\n\tif (fru->access && fru_data_rqst_size > 16)\n#endif\n\t\tfru_data_rqst_size = 16;\n\n\tsize_left_in_buffer = length;\n\tdo {\n\t\ttmp = fru->access ? off >> 1 : off;\n\t\tmsg_data[0] = id;\n\t\tmsg_data[1] = (uint8_t)(tmp & 0xff);\n\t\tmsg_data[2] = (uint8_t)(tmp >> 8);\n\t\ttmp = finish - off;\n\t\tif (tmp > fru_data_rqst_size)\n\t\t\tmsg_data[3] = (uint8_t)fru_data_rqst_size;\n\t\telse\n\t\t\tmsg_data[3] = (uint8_t)tmp;\n\n\t\trsp = intf->sendrecv(intf, &req);\n\t\tif (!rsp) {\n\t\t\tlprintf(LOG_NOTICE, \"FRU Read failed\");\n\t\t\tbreak;\n\t\t}\n\t\tif (rsp->ccode) {\n\t\t\t/* if we get C7 or C8  or CA return code then we requested too\n\t\t\t* many bytes at once so try again with smaller size */\n\t\t\tif (fru_cc_rq2big(rsp->ccode) && (--fru_data_rqst_size > FRU_BLOCK_SZ)) {\n\t\t\t\tlprintf(LOG_INFO,\n\t\t\t\t\t\"Retrying FRU read with request size %d\",\n\t\t\t\t\tfru_data_rqst_size);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlprintf(LOG_NOTICE, \"FRU Read failed: %s\",\n\t\t\t\tval2str(rsp->ccode, completion_code_vals));\n\t\t\tbreak;\n\t\t}\n\n\t\ttmp = fru->access ? rsp->data[0] << 1 : rsp->data[0];\n\t\tif(rsp->data_len < 1\n\t\t   || tmp > rsp->data_len - 1\n\t\t   || tmp > size_left_in_buffer)\n\t\t{\n\t\t\tprintf(\" Not enough buffer size\");\n\t\t\treturn -1;\n\t\t}\n\t\tmemcpy((frubuf + off)-offset, rsp->data + 1, tmp);\n\t\toff += tmp;\n\t\tsize_left_in_buffer -= tmp;\n\n\t\t/* sometimes the size returned in the Info command\n\t\t* is too large.  return 0 so higher level function\n\t\t* still attempts to parse what was returned */\n\t\tif (tmp == 0 && off < finish)\n\t\t\treturn 0;\n\n\t} while (off < finish);\n\n\tif (off < finish)\n\t\treturn -1;\n\n\treturn 0;\n}", "target": 2, "idx": 10671}
{"commit_id": "da5c0f119203ad9728920456a0f52a6d850c01cd", "project": "torvalds/linux", "func": "int nfc_enable_se(struct nfc_dev *dev, u32 se_idx)\n{\n\tstruct nfc_se *se;\n\tint rc;\n\n\tpr_debug(\"%s se index %d\\n\", dev_name(&dev->dev), se_idx);\n\n\tdevice_lock(&dev->dev);\n\n\tif (dev->shutting_down) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (!dev->dev_up) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (dev->polling) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\n\tif (!dev->ops->enable_se || !dev->ops->disable_se) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto error;\n\t}\n\n\tse = nfc_find_se(dev, se_idx);\n\tif (!se) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tif (se->state == NFC_SE_ENABLED) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\n\trc = dev->ops->enable_se(dev, se_idx);\n\tif (rc >= 0)\n\t\tse->state = NFC_SE_ENABLED;\n\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1, "idx": 10672}
{"commit_id": "ca8ac8acdad662230ae37998c6c4091bb39402b6", "project": "android", "func": "static bool getCoverageFormat12(vector<uint32_t>& coverage, const uint8_t* data, size_t size) {\n    const size_t kNGroupsOffset = 12;\n    const size_t kFirstGroupOffset = 16;\n    const size_t kGroupSize = 12;\n    const size_t kStartCharCodeOffset = 0;\n    const size_t kEndCharCodeOffset = 4;\n    const size_t kMaxNGroups = 0xfffffff0 / kGroupSize;  // protection against overflow\n    // For all values < kMaxNGroups, kFirstGroupOffset + nGroups * kGroupSize fits in 32 bits.\n    if (kFirstGroupOffset > size) {\n        return false;\n    }\n    uint32_t nGroups = readU32(data, kNGroupsOffset);\n    if (nGroups >= kMaxNGroups || kFirstGroupOffset + nGroups * kGroupSize > size) {\n        return false;\n    }\n    for (uint32_t i = 0; i < nGroups; i++) {\n        uint32_t groupOffset = kFirstGroupOffset + i * kGroupSize;\n        uint32_t start = readU32(data, groupOffset + kStartCharCodeOffset);\n        uint32_t end = readU32(data, groupOffset + kEndCharCodeOffset);\n        if (end < start) {\n            // invalid group range: size must be positive\n            return false;\n        }\n        addRange(coverage, start, end + 1);  // file is inclusive, vector is exclusive\n    }\n    return true;\n}", "target": 1, "idx": 10673}
{"commit_id": "16b3003ffc6393e250f069aa28a78dc5a2c064b2", "project": "php/php-src", "func": "static inline long object_common1(UNSERIALIZE_PARAMETER, zend_class_entry *ce)\n{\n\tlong elements;\n\n\tif( *p >= max - 2) {\n\t\tzend_error(E_WARNING, \"Bad unserialize data\");\n\t\treturn -1;\n\t}\n\n\telements = parse_iv2((*p) + 2, p);\n\n\t(*p) += 2;\n\n\tif (ce->serialize == NULL) {\n\t\tobject_init_ex(*rval, ce);\n\t} else {\n\t\t/* If this class implements Serializable, it should not land here but in object_custom(). The passed string\n\t\tobviously doesn't descend from the regular serializer. */\n\t\tzend_error(E_WARNING, \"Erroneous data format for unserializing '%s'\", ce->name);\n\t\treturn -1;\n\t}\n\n\treturn elements;\n}", "target": 2, "idx": 10674}
{"commit_id": "8fff105e13041e49b82f92eef034f363a6b1c071", "project": "torvalds/linux", "func": "static int\nvalidate_event(struct pmu *pmu, struct pmu_hw_events *hw_events,\n\t\t\t\tstruct perf_event *event)\n{\n\tstruct arm_pmu *armpmu;\n\tstruct hw_perf_event fake_event = event->hw;\n\tstruct pmu *leader_pmu = event->group_leader->pmu;\n\n\tif (is_software_event(event))\n\t\treturn 1;\n\n\t/*\n\t * Reject groups spanning multiple HW PMUs (e.g. CPU + CCI). The\n\t * core perf code won't check that the pmu->ctx == leader->ctx\n\t * until after pmu->event_init(event).\n\t */\n\tif (event->pmu != pmu)\n\t\treturn 0;\n\n\tif (event->pmu != leader_pmu || event->state < PERF_EVENT_STATE_OFF)\n\t\treturn 1;\n\n\tif (event->state == PERF_EVENT_STATE_OFF && !event->attr.enable_on_exec)\n\t\treturn 1;\n\n\tarmpmu = to_arm_pmu(event->pmu);\n\treturn armpmu->get_event_idx(hw_events, &fake_event) >= 0;\n}", "target": 2, "idx": 10675}
{"commit_id": "aacae2065744adb05e858d327198c7bbe7f452b0", "project": "opencv", "func": "uchar* FillColorRow1( uchar* data, uchar* indices, int len, PaletteEntry* palette )\n{\n    uchar* end = data + len*3;\n\n    const PaletteEntry p0 = palette[0], p1 = palette[1];\n\n    while( (data += 24) < end )\n    {\n        int idx = *indices++;\n        *((PaletteEntry*)(data - 24)) = (idx & 128) ? p1 : p0;\n        *((PaletteEntry*)(data - 21)) = (idx & 64) ? p1 : p0;\n        *((PaletteEntry*)(data - 18)) = (idx & 32) ? p1 : p0;\n        *((PaletteEntry*)(data - 15)) = (idx & 16) ? p1 : p0;\n        *((PaletteEntry*)(data - 12)) = (idx & 8) ? p1 : p0;\n        *((PaletteEntry*)(data - 9)) = (idx & 4) ? p1 : p0;\n        *((PaletteEntry*)(data - 6)) = (idx & 2) ? p1 : p0;\n        *((PaletteEntry*)(data - 3)) = (idx & 1) ? p1 : p0;\n    }\n\n    int idx = indices[0];\n    for( data -= 24; data < end; data += 3, idx += idx )\n    {\n        const PaletteEntry clr = (idx & 128) ? p1 : p0;\n        WRITE_PIX( data, clr );\n    }\n\n    return data;\n}", "target": 1, "idx": 10676}
{"commit_id": "77c955200ddd1761d6ed7a6c1578349fedbb55e4", "project": "android", "func": "void* reset(size_t size,\n                SkAutoMalloc::OnShrink shrink = SkAutoMalloc::kAlloc_OnShrink,\n                bool* didChangeAlloc = nullptr) {\n        size = (size < kSize) ? kSize : size;\n        bool alloc = size != fSize && (SkAutoMalloc::kAlloc_OnShrink == shrink || size > fSize);\n        if (didChangeAlloc) {\n            *didChangeAlloc = alloc;\n        }\n        if (alloc) {\n            if (fPtr != (void*)fStorage) {\n                sk_free(fPtr);\n            }\n\n            if (size == kSize) {\n                SkASSERT(fPtr != fStorage); // otherwise we lied when setting didChangeAlloc.\n                fPtr = fStorage;\n            } else {\n                fPtr = sk_malloc_throw(size);\n            }\n\n            fSize = size;\n        }\n        SkASSERT(fSize >= size && fSize >= kSize);\n        SkASSERT((fPtr == fStorage) || fSize > kSize);\n        return fPtr;\n    }", "target": 2, "idx": 10677}
{"commit_id": "5a497077f109d543ab86dfdf8add1c76c0e47d29", "project": "opencv", "func": "bool HOGDescriptor::read(FileNode& obj)\n{\n    CV_Assert(!obj[\"winSize\"].empty());\n\n    if( !obj.isMap() )\n        return false;\n    FileNodeIterator it = obj[\"winSize\"].begin();\n    it >> winSize.width >> winSize.height; CV_Assert(!winSize.empty());\n    it = obj[\"blockSize\"].begin();\n    it >> blockSize.width >> blockSize.height; CV_Assert(!blockSize.empty());\n    it = obj[\"blockStride\"].begin();\n    it >> blockStride.width >> blockStride.height; CV_Assert(!blockStride.empty());\n    it = obj[\"cellSize\"].begin();\n    it >> cellSize.width >> cellSize.height; CV_Assert(!cellSize.empty());\n    obj[\"nbins\"] >> nbins; CV_Assert(nbins > 0);\n    obj[\"derivAperture\"] >> derivAperture;\n    obj[\"winSigma\"] >> winSigma;\n    obj[\"histogramNormType\"] >> histogramNormType;\n    obj[\"L2HysThreshold\"] >> L2HysThreshold;\n    obj[\"gammaCorrection\"] >> gammaCorrection;\n    obj[\"nlevels\"] >> nlevels; CV_Assert(nlevels > 0);\n    if (obj[\"signedGradient\"].empty())\n        signedGradient = false;\n    else\n        obj[\"signedGradient\"] >> signedGradient;\n\n    FileNode vecNode = obj[\"SVMDetector\"];\n    if( vecNode.isSeq() )\n    {\n        std::vector<float> _svmDetector;\n        vecNode >> _svmDetector;\n        setSVMDetector(_svmDetector);\n    }\n    return true;\n}", "target": 1, "idx": 10678}
{"commit_id": "82b80dcb70a7ca8986125ff412bceddafc896842", "project": "libgd", "func": "static void output(code_int code, GifCtx *ctx)\n{\n\tif (ctx->cur_bits == CUR_BITS_FINISHED)\n\t\treturn;\n\tctx->cur_accum &= masks[ctx->cur_bits];\n\n\tif(ctx->cur_bits > 0) {\n\t\tctx->cur_accum |= ((long)code << ctx->cur_bits);\n\t} else {\n\t\tctx->cur_accum = code;\n\t}\n\n\tctx->cur_bits += ctx->n_bits;\n\n\twhile(ctx->cur_bits >= 8) {\n\t\tchar_out((unsigned int)(ctx->cur_accum & 0xff), ctx);\n\t\tctx->cur_accum >>= 8;\n\t\tctx->cur_bits -= 8;\n\t}\n\n\t/*\n\t * If the next entry is going to be too big for the code size,\n\t * then increase it, if possible.\n\t */\n\tif(ctx->free_ent > ctx->maxcode || ctx->clear_flg) {\n\t\tif(ctx->clear_flg) {\n\t\t\tctx->maxcode = MAXCODE (ctx->n_bits = ctx->g_init_bits);\n\t\t\tctx->clear_flg = 0;\n\t\t} else {\n\t\t\t++(ctx->n_bits);\n\t\t\tif(ctx->n_bits == maxbits) {\n\t\t\t\tctx->maxcode = maxmaxcode;\n\t\t\t} else {\n\t\t\t\tctx->maxcode = MAXCODE(ctx->n_bits);\n\t\t\t}\n\t\t}\n\t}\n\n\tif(code == ctx->EOFCode) {\n\t\t/* At EOF, write the rest of the buffer. */\n\t\twhile(ctx->cur_bits > 0) {\n\t\t\tchar_out((unsigned int)(ctx->cur_accum & 0xff), ctx);\n\t\t\tctx->cur_accum >>= 8;\n\t\t\tctx->cur_bits -= 8;\n\t\t}\n\t\t/* Flag that it's done to prevent re-entry. */\n\t\tctx->cur_bits = CUR_BITS_FINISHED;\n\n\t\tflush_char(ctx);\n\t}\n}", "target": 1, "idx": 10679}
{"commit_id": "be655fd4fb9ab3291a855a939496111674037a2f", "project": "chromium", "func": "void FrameLoader::startLoad(FrameLoadRequest& frameLoadRequest, FrameLoadType type, NavigationPolicy navigationPolicy)\n{\n    ASSERT(client()->hasWebView());\n    if (m_frame->document()->pageDismissalEventBeingDispatched() != Document::NoDismissal)\n        return;\n\n    NavigationType navigationType = determineNavigationType(type, frameLoadRequest.resourceRequest().httpBody() || frameLoadRequest.form(), frameLoadRequest.triggeringEvent());\n    frameLoadRequest.resourceRequest().setRequestContext(determineRequestContextFromNavigationType(navigationType));\n    frameLoadRequest.resourceRequest().setFrameType(m_frame->isMainFrame() ? WebURLRequest::FrameTypeTopLevel : WebURLRequest::FrameTypeNested);\n    ResourceRequest& request = frameLoadRequest.resourceRequest();\n    if (!shouldContinueForNavigationPolicy(request, frameLoadRequest.substituteData(), nullptr, frameLoadRequest.shouldCheckMainWorldContentSecurityPolicy(), navigationType, navigationPolicy, type == FrameLoadTypeReplaceCurrentItem, frameLoadRequest.clientRedirect() == ClientRedirectPolicy::ClientRedirect))\n        return;\n\n    m_frame->document()->cancelParsing();\n    detachDocumentLoader(m_provisionalDocumentLoader);\n\n    // beforeunload fired above, and detaching a DocumentLoader can fire\n    // events, which can detach this frame.\n    if (!m_frame->host())\n        return;\n\n    m_provisionalDocumentLoader = client()->createDocumentLoader(m_frame, request, frameLoadRequest.substituteData().isValid() ? frameLoadRequest.substituteData() : defaultSubstituteDataForURL(request.url()));\n    m_provisionalDocumentLoader->setNavigationType(navigationType);\n    m_provisionalDocumentLoader->setReplacesCurrentHistoryItem(type == FrameLoadTypeReplaceCurrentItem);\n    m_provisionalDocumentLoader->setIsClientRedirect(frameLoadRequest.clientRedirect() == ClientRedirectPolicy::ClientRedirect);\n\n    InspectorInstrumentation::didStartProvisionalLoad(m_frame);\n\n    m_frame->navigationScheduler().cancel();\n    m_checkTimer.stop();\n\n    m_loadType = type;\n\n    if (frameLoadRequest.form())\n        client()->dispatchWillSubmitForm(frameLoadRequest.form());\n\n    m_progressTracker->progressStarted();\n    if (m_provisionalDocumentLoader->isClientRedirect())\n        m_provisionalDocumentLoader->appendRedirect(m_frame->document()->url());\n    m_provisionalDocumentLoader->appendRedirect(m_provisionalDocumentLoader->request().url());\n    double triggeringEventTime = frameLoadRequest.triggeringEvent() ? frameLoadRequest.triggeringEvent()->platformTimeStamp() : 0;\n    client()->dispatchDidStartProvisionalLoad(triggeringEventTime);\n    ASSERT(m_provisionalDocumentLoader);\n    m_provisionalDocumentLoader->startLoadingMainResource();\n\n    takeObjectSnapshot();\n}", "target": 2, "idx": 10680}
{"commit_id": "229abab99f39f11624e5651f819e7f1f8eddedcc", "project": "debauchee/barrier", "func": "int\nSecureSocket::secureAccept(int socket)\n{\n    createSSL();\n\n    // set connection socket to SSL state\n    SSL_set_fd(m_ssl->m_ssl, socket);\n\n    LOG((CLOG_DEBUG2 \"accepting secure socket\"));\n    int r = SSL_accept(m_ssl->m_ssl);\n\n    static int retry;\n\n    checkResult(r, retry);\n\n    if (isFatal()) {\n        // tell user and sleep so the socket isn't hammered.\n        LOG((CLOG_ERR \"failed to accept secure socket\"));\n        LOG((CLOG_INFO \"client connection may not be secure\"));\n        m_secureReady = false;\n        ARCH->sleep(1);\n        retry = 0;\n        return -1; // Failed, error out\n    }\n\n    // If not fatal and no retry, state is good\n    if (retry == 0) {\n        if (security_level_ == ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED) {\n            if (verify_cert_fingerprint(\n                        barrier::DataDirectories::trusted_clients_ssl_fingerprints_path())) {\n                LOG((CLOG_INFO \"accepted secure socket\"));\n                if (!ensure_peer_certificate()) {\n                    retry = 0;\n                    disconnect();\n                    return -1;// Cert fail, error\n                }\n            }\n            else {\n                LOG((CLOG_ERR \"failed to verify server certificate fingerprint\"));\n                retry = 0;\n                disconnect();\n                return -1; // Fingerprint failed, error\n            }\n        }\n\n        m_secureReady = true;\n        LOG((CLOG_INFO \"accepted secure socket\"));\n        if (CLOG->getFilter() >= kDEBUG1) {\n            showSecureCipherInfo();\n        }\n        showSecureConnectInfo();\n        return 1;\n    }\n\n    // If not fatal and retry is set, not ready, and return retry\n    if (retry > 0) {\n        LOG((CLOG_DEBUG2 \"retry accepting secure socket\"));\n        m_secureReady = false;\n        ARCH->sleep(s_retryDelay);\n        return 0;\n    }\n\n    // no good state exists here\n    LOG((CLOG_ERR \"unexpected state attempting to accept connection\"));\n    return -1;\n}", "target": 2, "idx": 10681}
{"commit_id": "2785b2a9e04abc148e1c5259f4faee708ea356f4", "project": "xen-project/xen", "func": "int evtchn_reset(struct domain *d, bool resuming)\n{\n    unsigned int i;\n    int rc = 0;\n\n    if ( d != current->domain && !d->controller_pause_count )\n        return -EINVAL;\n\n    spin_lock(&d->event_lock);\n\n    /*\n     * If we are resuming, then start where we stopped. Otherwise, check\n     * that a reset operation is not already in progress, and if none is,\n     * record that this is now the case.\n     */\n    i = resuming ? d->next_evtchn : !d->next_evtchn;\n    if ( i > d->next_evtchn )\n        d->next_evtchn = i;\n\n    spin_unlock(&d->event_lock);\n\n    if ( !i )\n        return -EBUSY;\n\n    for ( ; port_is_valid(d, i); i++ )\n    {\n        evtchn_close(d, i, 1);\n\n        /* NB: Choice of frequency is arbitrary. */\n        if ( !(i & 0x3f) && hypercall_preempt_check() )\n        {\n            spin_lock(&d->event_lock);\n            d->next_evtchn = i;\n            spin_unlock(&d->event_lock);\n            return -ERESTART;\n        }\n    }\n\n    spin_lock(&d->event_lock);\n\n    d->next_evtchn = 0;\n\n    if ( d->active_evtchns > d->xen_evtchns )\n        rc = -EAGAIN;\n    else if ( d->evtchn_fifo )\n    {\n        /* Switching back to 2-level ABI. */\n        evtchn_fifo_destroy(d);\n        evtchn_2l_init(d);\n    }\n\n    spin_unlock(&d->event_lock);\n\n    return rc;\n}", "target": 1, "idx": 10682}
{"commit_id": "39e72bf96f5847ba87cc5bd7a3ce0fed813dc9ad", "project": "torvalds/linux", "func": "static void toggle_count_cache_flush(bool enable)\n{\n\tif (!security_ftr_enabled(SEC_FTR_FLUSH_COUNT_CACHE) &&\n\t    !security_ftr_enabled(SEC_FTR_FLUSH_LINK_STACK))\n\t\tenable = false;\n\n\tif (!enable) {\n\t\tpatch_instruction_site(&patch__call_flush_count_cache, PPC_INST_NOP);\n\t\tpr_info(\"link-stack-flush: software flush disabled.\\n\");\n\t\tlink_stack_flush_enabled = false;\n\t\tno_count_cache_flush();\n\t\treturn;\n\t}\n\n\t// This enables the branch from _switch to flush_count_cache\n\tpatch_branch_site(&patch__call_flush_count_cache,\n\t\t\t  (u64)&flush_count_cache, BRANCH_SET_LINK);\n\n\tpr_info(\"link-stack-flush: software flush enabled.\\n\");\n\tlink_stack_flush_enabled = true;\n\n\t// If we just need to flush the link stack, patch an early return\n\tif (!security_ftr_enabled(SEC_FTR_FLUSH_COUNT_CACHE)) {\n\t\tpatch_instruction_site(&patch__flush_link_stack_return, PPC_INST_BLR);\n\t\tno_count_cache_flush();\n\t\treturn;\n\t}\n\n\tif (!security_ftr_enabled(SEC_FTR_BCCTR_FLUSH_ASSIST)) {\n\t\tcount_cache_flush_type = COUNT_CACHE_FLUSH_SW;\n\t\tpr_info(\"count-cache-flush: full software flush sequence enabled.\\n\");\n\t\treturn;\n\t}\n\n\tpatch_instruction_site(&patch__flush_count_cache_return, PPC_INST_BLR);\n\tcount_cache_flush_type = COUNT_CACHE_FLUSH_HW;\n\tpr_info(\"count-cache-flush: hardware assisted flush sequence enabled\\n\");\n}", "target": 1, "idx": 10683}
{"commit_id": "0b7808818cb9df6680f98996b8e9a439fa7bcc2f", "project": "kernel/git/wireless/wireless", "func": "static inline void bss_ref_get(struct cfg80211_registered_device *rdev,\n\t\t\t       struct cfg80211_internal_bss *bss)\n{\n\tlockdep_assert_held(&rdev->bss_lock);\n\n\tbss->refcount++;\n\n\tif (bss->pub.hidden_beacon_bss)\n\t\tbss_from_pub(bss->pub.hidden_beacon_bss)->refcount++;\n\n\tif (bss->pub.transmitted_bss)\n\t\tbss_from_pub(bss->pub.transmitted_bss)->refcount++;\n}", "target": 2, "idx": 10684}
{"commit_id": "d7325bac173492b358417a0ad49fabad44447d52", "project": "ImageMagick", "func": "static MagickBooleanType SkipRGBMipmaps(Image *image,DDSInfo *dds_info,\n  int pixel_size,ExceptionInfo *exception)\n{\n  MagickOffsetType\n    offset;\n\n  register ssize_t\n    i;\n\n  size_t\n    h,\n    w;\n\n  /*\n    Only skip mipmaps for textures and cube maps\n  */\n  if (dds_info->ddscaps1 & DDSCAPS_MIPMAP\n      && (dds_info->ddscaps1 & DDSCAPS_TEXTURE\n          || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))\n    {\n      if (EOFBlob(image) != MagickFalse)\n        {\n          ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n            image->filename);\n          return(MagickFalse);\n        }\n      w = DIV2(dds_info->width);\n      h = DIV2(dds_info->height);\n\n      /*\n        Mipmapcount includes the main image, so start from one\n      */\n      for (i=1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)\n      {\n        offset = (MagickOffsetType) w * h * pixel_size;\n        (void) SeekBlob(image, offset, SEEK_CUR);\n\n        w = DIV2(w);\n        h = DIV2(h);\n      }\n    }\n  return(MagickTrue);\n}", "target": 1, "idx": 10685}
{"commit_id": "ce1924193862d58cb43d3d4d9dada710a8361b89", "project": "espruino/Espruino", "func": "size_t jsvGetString(const JsVar *v, char *str, size_t len) {\n  assert(len>0);\n  const char *s = jsvGetConstString(v);\n  if (s) {\n    /* don't use strncpy here because we don't\n     * want to pad the entire buffer with zeros */\n    len--;\n    int l = 0;\n    while (s[l] && l<len) {\n      str[l] = s[l];\n      l++;\n    }\n    str[l] = 0;\n    return l;\n  } else if (jsvIsInt(v)) {\n    itostr(v->varData.integer, str, 10);\n    return strlen(str);\n  } else if (jsvIsFloat(v)) {\n    ftoa_bounded(v->varData.floating, str, len);\n    return strlen(str);\n  } else if (jsvHasCharacterData(v)) {\n    assert(!jsvIsStringExt(v));\n    size_t l = len;\n    JsvStringIterator it;\n    jsvStringIteratorNewConst(&it, v, 0);\n    while (jsvStringIteratorHasChar(&it)) {\n      if (l--<=1) {\n        *str = 0;\n        jsvStringIteratorFree(&it);\n        return len;\n      }\n      *(str++) = jsvStringIteratorGetChar(&it);\n      jsvStringIteratorNext(&it);\n    }\n    jsvStringIteratorFree(&it);\n    *str = 0;\n    return len-l;\n  } else {\n    // Try and get as a JsVar string, and try again\n    JsVar *stringVar = jsvAsString((JsVar*)v, false); // we know we're casting to non-const here\n    if (stringVar) {\n      size_t l = jsvGetString(stringVar, str, len); // call again - but this time with converted var\n      jsvUnLock(stringVar);\n      return l;\n    } else {\n      str[0] = 0;\n      jsExceptionHere(JSET_INTERNALERROR, \"Variable type cannot be converted to string\");\n      return 0;\n    }\n  }\n}", "target": 1, "idx": 10686}
{"commit_id": "1630f53481f445ada0a455e9979236d31a8d3bb0", "project": "GNOME/nautilus", "func": "static void\ncopy_move_file (CopyMoveJob   *copy_job,\n                GFile         *src,\n                GFile         *dest_dir,\n                gboolean       same_fs,\n                gboolean       unique_names,\n                char         **dest_fs_type,\n                SourceInfo    *source_info,\n                TransferInfo  *transfer_info,\n                GHashTable    *debuting_files,\n                GdkPoint      *position,\n                gboolean       overwrite,\n                gboolean      *skipped_file,\n                gboolean       readonly_source_fs)\n{\n    GFile *dest, *new_dest;\n    g_autofree gchar *dest_uri = NULL;\n    GError *error;\n    GFileCopyFlags flags;\n    char *primary, *secondary, *details;\n    int response;\n    ProgressData pdata;\n    gboolean would_recurse, is_merge;\n    CommonJob *job;\n    gboolean res;\n    int unique_name_nr;\n    gboolean handled_invalid_filename;\n\n    job = (CommonJob *) copy_job;\n\n    if (should_skip_file (job, src))\n    {\n        *skipped_file = TRUE;\n        return;\n    }\n\n    unique_name_nr = 1;\n\n    /* another file in the same directory might have handled the invalid\n     * filename condition for us\n     */\n    handled_invalid_filename = *dest_fs_type != NULL;\n\n    if (unique_names)\n    {\n        dest = get_unique_target_file (src, dest_dir, same_fs, *dest_fs_type, unique_name_nr++);\n    }\n    else if (copy_job->target_name != NULL)\n    {\n        dest = get_target_file_with_custom_name (src, dest_dir, *dest_fs_type, same_fs,\n                                                 copy_job->target_name);\n    }\n    else\n    {\n        dest = get_target_file (src, dest_dir, *dest_fs_type, same_fs);\n    }\n\n    /* Don't allow recursive move/copy into itself.\n     * (We would get a file system error if we proceeded but it is nicer to\n     * detect and report it at this level) */\n    if (test_dir_is_parent (dest_dir, src))\n    {\n        if (job->skip_all_error)\n        {\n            goto out;\n        }\n\n        /*  the run_warning() frees all strings passed in automatically  */\n        primary = copy_job->is_move ? g_strdup (_(\"You cannot move a folder into itself.\"))\n                  : g_strdup (_(\"You cannot copy a folder into itself.\"));\n        secondary = g_strdup (_(\"The destination folder is inside the source folder.\"));\n\n        response = run_cancel_or_skip_warning (job,\n                                               primary,\n                                               secondary,\n                                               NULL,\n                                               source_info->num_files,\n                                               source_info->num_files - transfer_info->num_files);\n\n        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n        {\n            abort_job (job);\n        }\n        else if (response == 1)             /* skip all */\n        {\n            job->skip_all_error = TRUE;\n        }\n        else if (response == 2)             /* skip */\n        {               /* do nothing */\n        }\n        else\n        {\n            g_assert_not_reached ();\n        }\n\n        goto out;\n    }\n\n    /* Don't allow copying over the source or one of the parents of the source.\n     */\n    if (test_dir_is_parent (src, dest))\n    {\n        if (job->skip_all_error)\n        {\n            goto out;\n        }\n\n        /*  the run_warning() frees all strings passed in automatically  */\n        primary = copy_job->is_move ? g_strdup (_(\"You cannot move a file over itself.\"))\n                  : g_strdup (_(\"You cannot copy a file over itself.\"));\n        secondary = g_strdup (_(\"The source file would be overwritten by the destination.\"));\n\n        response = run_cancel_or_skip_warning (job,\n                                               primary,\n                                               secondary,\n                                               NULL,\n                                               source_info->num_files,\n                                               source_info->num_files - transfer_info->num_files);\n\n        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n        {\n            abort_job (job);\n        }\n        else if (response == 1)             /* skip all */\n        {\n            job->skip_all_error = TRUE;\n        }\n        else if (response == 2)             /* skip */\n        {               /* do nothing */\n        }\n        else\n        {\n            g_assert_not_reached ();\n        }\n\n        goto out;\n    }\n\n\nretry:\n\n    error = NULL;\n    flags = G_FILE_COPY_NOFOLLOW_SYMLINKS;\n    if (overwrite)\n    {\n        flags |= G_FILE_COPY_OVERWRITE;\n    }\n    if (readonly_source_fs)\n    {\n        flags |= G_FILE_COPY_TARGET_DEFAULT_PERMS;\n    }\n\n    pdata.job = copy_job;\n    pdata.last_size = 0;\n    pdata.source_info = source_info;\n    pdata.transfer_info = transfer_info;\n\n    if (copy_job->is_move)\n    {\n        res = g_file_move (src, dest,\n                           flags,\n                           job->cancellable,\n                           copy_file_progress_callback,\n                           &pdata,\n                           &error);\n    }\n    else\n    {\n        res = g_file_copy (src, dest,\n                           flags,\n                           job->cancellable,\n                           copy_file_progress_callback,\n                           &pdata,\n                           &error);\n    }\n\n    if (res)\n    {\n        GFile *real;\n\n        real = map_possibly_volatile_file_to_real (dest, job->cancellable, &error);\n        if (real == NULL)\n        {\n            res = FALSE;\n        }\n        else\n        {\n            g_object_unref (dest);\n            dest = real;\n        }\n    }\n\n    if (res)\n    {\n        transfer_info->num_files++;\n        report_copy_progress (copy_job, source_info, transfer_info);\n\n        if (debuting_files)\n        {\n            dest_uri = g_file_get_uri (dest);\n            if (position)\n            {\n                nautilus_file_changes_queue_schedule_position_set (dest, *position, job->screen_num);\n            }\n            else if (eel_uri_is_desktop (dest_uri))\n            {\n                nautilus_file_changes_queue_schedule_position_remove (dest);\n            }\n\n            g_hash_table_replace (debuting_files, g_object_ref (dest), GINT_TO_POINTER (TRUE));\n        }\n        if (copy_job->is_move)\n        {\n            nautilus_file_changes_queue_file_moved (src, dest);\n        }\n        else\n        {\n            nautilus_file_changes_queue_file_added (dest);\n        }\n\n        /* If copying a trusted desktop file to the desktop,\n         *  mark it as trusted. */\n        if (copy_job->desktop_location != NULL &&\n            g_file_equal (copy_job->desktop_location, dest_dir) &&\n            is_trusted_desktop_file (src, job->cancellable))\n        {\n            mark_desktop_file_executable (job,\n                                          job->cancellable,\n                                          dest,\n                                          FALSE);\n        }\n\n        if (job->undo_info != NULL)\n        {\n            nautilus_file_undo_info_ext_add_origin_target_pair (NAUTILUS_FILE_UNDO_INFO_EXT (job->undo_info),\n                                                                src, dest);\n        }\n\n        g_object_unref (dest);\n        return;\n    }\n\n    if (!handled_invalid_filename &&\n        IS_IO_ERROR (error, INVALID_FILENAME))\n    {\n        handled_invalid_filename = TRUE;\n\n        g_assert (*dest_fs_type == NULL);\n        *dest_fs_type = query_fs_type (dest_dir, job->cancellable);\n\n        if (unique_names)\n        {\n            new_dest = get_unique_target_file (src, dest_dir, same_fs, *dest_fs_type, unique_name_nr);\n        }\n        else\n        {\n            new_dest = get_target_file (src, dest_dir, *dest_fs_type, same_fs);\n        }\n\n        if (!g_file_equal (dest, new_dest))\n        {\n            g_object_unref (dest);\n            dest = new_dest;\n\n            g_error_free (error);\n            goto retry;\n        }\n        else\n        {\n            g_object_unref (new_dest);\n        }\n    }\n\n    /* Conflict */\n    if (!overwrite &&\n        IS_IO_ERROR (error, EXISTS))\n    {\n        gboolean is_merge;\n        FileConflictResponse *response;\n\n        g_error_free (error);\n\n        if (unique_names)\n        {\n            g_object_unref (dest);\n            dest = get_unique_target_file (src, dest_dir, same_fs, *dest_fs_type, unique_name_nr++);\n            goto retry;\n        }\n\n        is_merge = FALSE;\n\n        if (is_dir (dest) && is_dir (src))\n        {\n            is_merge = TRUE;\n        }\n\n        if ((is_merge && job->merge_all) ||\n            (!is_merge && job->replace_all))\n        {\n            overwrite = TRUE;\n            goto retry;\n        }\n\n        if (job->skip_all_conflict)\n        {\n            goto out;\n        }\n\n        response = handle_copy_move_conflict (job, src, dest, dest_dir);\n\n        if (response->id == GTK_RESPONSE_CANCEL ||\n            response->id == GTK_RESPONSE_DELETE_EVENT)\n        {\n            file_conflict_response_free (response);\n            abort_job (job);\n        }\n        else if (response->id == CONFLICT_RESPONSE_SKIP)\n        {\n            if (response->apply_to_all)\n            {\n                job->skip_all_conflict = TRUE;\n            }\n            file_conflict_response_free (response);\n        }\n        else if (response->id == CONFLICT_RESPONSE_REPLACE)             /* merge/replace */\n        {\n            if (response->apply_to_all)\n            {\n                if (is_merge)\n                {\n                    job->merge_all = TRUE;\n                }\n                else\n                {\n                    job->replace_all = TRUE;\n                }\n            }\n            overwrite = TRUE;\n            file_conflict_response_free (response);\n            goto retry;\n        }\n        else if (response->id == CONFLICT_RESPONSE_RENAME)\n        {\n            g_object_unref (dest);\n            dest = get_target_file_for_display_name (dest_dir,\n                                                     response->new_name);\n            file_conflict_response_free (response);\n            goto retry;\n        }\n        else\n        {\n            g_assert_not_reached ();\n        }\n    }\n    else if (overwrite &&\n             IS_IO_ERROR (error, IS_DIRECTORY))\n    {\n        gboolean existing_file_deleted;\n        DeleteExistingFileData data;\n\n        g_error_free (error);\n\n        data.job = job;\n        data.source = src;\n\n        existing_file_deleted =\n            delete_file_recursively (dest,\n                                     job->cancellable,\n                                     existing_file_removed_callback,\n                                     &data);\n\n        if (existing_file_deleted)\n        {\n            goto retry;\n        }\n    }\n    /* Needs to recurse */\n    else if (IS_IO_ERROR (error, WOULD_RECURSE) ||\n             IS_IO_ERROR (error, WOULD_MERGE))\n    {\n        is_merge = error->code == G_IO_ERROR_WOULD_MERGE;\n        would_recurse = error->code == G_IO_ERROR_WOULD_RECURSE;\n        g_error_free (error);\n\n        if (overwrite && would_recurse)\n        {\n            error = NULL;\n\n            /* Copying a dir onto file, first remove the file */\n            if (!g_file_delete (dest, job->cancellable, &error) &&\n                !IS_IO_ERROR (error, NOT_FOUND))\n            {\n                if (job->skip_all_error)\n                {\n                    g_error_free (error);\n                    goto out;\n                }\n                if (copy_job->is_move)\n                {\n                    primary = f (_(\"Error while moving \u201c%B\u201d.\"), src);\n                }\n                else\n                {\n                    primary = f (_(\"Error while copying \u201c%B\u201d.\"), src);\n                }\n                secondary = f (_(\"Could not remove the already existing file with the same name in %F.\"), dest_dir);\n                details = error->message;\n\n                /* setting TRUE on show_all here, as we could have\n                 * another error on the same file later.\n                 */\n                response = run_warning (job,\n                                        primary,\n                                        secondary,\n                                        details,\n                                        TRUE,\n                                        CANCEL, SKIP_ALL, SKIP,\n                                        NULL);\n\n                g_error_free (error);\n\n                if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n                {\n                    abort_job (job);\n                }\n                else if (response == 1)                     /* skip all */\n                {\n                    job->skip_all_error = TRUE;\n                }\n                else if (response == 2)                     /* skip */\n                {                       /* do nothing */\n                }\n                else\n                {\n                    g_assert_not_reached ();\n                }\n                goto out;\n            }\n            if (error)\n            {\n                g_error_free (error);\n                error = NULL;\n            }\n            nautilus_file_changes_queue_file_removed (dest);\n        }\n\n        if (is_merge)\n        {\n            /* On merge we now write in the target directory, which may not\n             *   be in the same directory as the source, even if the parent is\n             *   (if the merged directory is a mountpoint). This could cause\n             *   problems as we then don't transcode filenames.\n             *   We just set same_fs to FALSE which is safe but a bit slower. */\n            same_fs = FALSE;\n        }\n\n        if (!copy_move_directory (copy_job, src, &dest, same_fs,\n                                  would_recurse, dest_fs_type,\n                                  source_info, transfer_info,\n                                  debuting_files, skipped_file,\n                                  readonly_source_fs))\n        {\n            /* destination changed, since it was an invalid file name */\n            g_assert (*dest_fs_type != NULL);\n            handled_invalid_filename = TRUE;\n            goto retry;\n        }\n\n        g_object_unref (dest);\n        return;\n    }\n    else if (IS_IO_ERROR (error, CANCELLED))\n    {\n        g_error_free (error);\n    }\n    /* Other error */\n    else\n    {\n        if (job->skip_all_error)\n        {\n            g_error_free (error);\n            goto out;\n        }\n        primary = f (_(\"Error while copying \u201c%B\u201d.\"), src);\n        secondary = f (_(\"There was an error copying the file into %F.\"), dest_dir);\n        details = error->message;\n\n        response = run_cancel_or_skip_warning (job,\n                                               primary,\n                                               secondary,\n                                               details,\n                                               source_info->num_files,\n                                               source_info->num_files - transfer_info->num_files);\n\n        g_error_free (error);\n\n        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n        {\n            abort_job (job);\n        }\n        else if (response == 1)             /* skip all */\n        {\n            job->skip_all_error = TRUE;\n        }\n        else if (response == 2)             /* skip */\n        {               /* do nothing */\n        }\n        else\n        {\n            g_assert_not_reached ();\n        }\n    }\nout:\n    *skipped_file = TRUE;     /* Or aborted, but same-same */\n    g_object_unref (dest);\n}", "target": 1, "idx": 10687}
{"commit_id": "11d171f1910b508a81d21faa087ad1af573407d8", "project": "binutils-gdb", "func": "static uint64_t\nread_indexed_address (uint64_t idx, struct comp_unit *unit)\n{\n  struct dwarf2_debug *stash = unit->stash;\n  struct dwarf2_debug_file *file = unit->file;\n  bfd_byte *info_ptr;\n  size_t offset;\n\n  if (stash == NULL)\n    return 0;\n\n  if (!read_section (unit->abfd, &stash->debug_sections[debug_addr],\n\t\t     file->syms, 0,\n\t\t     &file->dwarf_addr_buffer, &file->dwarf_addr_size))\n    return 0;\n\n  if (_bfd_mul_overflow (idx, unit->addr_size, &offset))\n    return 0;\n\n  offset += unit->dwarf_addr_offset;\n  if (offset < unit->dwarf_addr_offset\n      || offset > file->dwarf_addr_size\n      || file->dwarf_addr_size - offset < unit->addr_size)\n    return 0;\n\n  info_ptr = file->dwarf_addr_buffer + offset;\n\n  if (unit->addr_size == 4)\n    return bfd_get_32 (unit->abfd, info_ptr);\n  else if (unit->addr_size == 8)\n    return bfd_get_64 (unit->abfd, info_ptr);\n  else\n    return 0;\n}", "target": 2, "idx": 10688}
{"commit_id": "16ce101db85db694a91380aa4c89b25530871d33", "project": "torvalds/linux", "func": "static void migrate_vma_unmap(struct migrate_vma *migrate)\n{\n\tconst unsigned long npages = migrate->npages;\n\tunsigned long i, restore = 0;\n\tbool allow_drain = true;\n\n\tlru_add_drain();\n\n\tfor (i = 0; i < npages; i++) {\n\t\tstruct page *page = migrate_pfn_to_page(migrate->src[i]);\n\t\tstruct folio *folio;\n\n\t\tif (!page)\n\t\t\tcontinue;\n\n\t\t/* ZONE_DEVICE pages are not on LRU */\n\t\tif (!is_zone_device_page(page)) {\n\t\t\tif (!PageLRU(page) && allow_drain) {\n\t\t\t\t/* Drain CPU's pagevec */\n\t\t\t\tlru_add_drain_all();\n\t\t\t\tallow_drain = false;\n\t\t\t}\n\n\t\t\tif (isolate_lru_page(page)) {\n\t\t\t\tmigrate->src[i] &= ~MIGRATE_PFN_MIGRATE;\n\t\t\t\tmigrate->cpages--;\n\t\t\t\trestore++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Drop the reference we took in collect */\n\t\t\tput_page(page);\n\t\t}\n\n\t\tfolio = page_folio(page);\n\t\tif (folio_mapped(folio))\n\t\t\ttry_to_migrate(folio, 0);\n\n\t\tif (page_mapped(page) ||\n\t\t    !migrate_vma_check_page(page, migrate->fault_page)) {\n\t\t\tif (!is_zone_device_page(page)) {\n\t\t\t\tget_page(page);\n\t\t\t\tputback_lru_page(page);\n\t\t\t}\n\n\t\t\tmigrate->src[i] &= ~MIGRATE_PFN_MIGRATE;\n\t\t\tmigrate->cpages--;\n\t\t\trestore++;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tfor (i = 0; i < npages && restore; i++) {\n\t\tstruct page *page = migrate_pfn_to_page(migrate->src[i]);\n\t\tstruct folio *folio;\n\n\t\tif (!page || (migrate->src[i] & MIGRATE_PFN_MIGRATE))\n\t\t\tcontinue;\n\n\t\tfolio = page_folio(page);\n\t\tremove_migration_ptes(folio, folio, false);\n\n\t\tmigrate->src[i] = 0;\n\t\tfolio_unlock(folio);\n\t\tfolio_put(folio);\n\t\trestore--;\n\t}\n}", "target": 1, "idx": 10689}
{"commit_id": "ff002b30181d30cdfbca316dadd099c3ca0d739c", "project": "torvalds/linux", "func": "static inline void io_req_work_grab_env(struct io_kiocb *req,\n\t\t\t\t\tconst struct io_op_def *def)\n{\n\tif (!req->work.mm && def->needs_mm) {\n\t\tmmgrab(current->mm);\n\t\treq->work.mm = current->mm;\n\t}\n\tif (!req->work.creds)\n\t\treq->work.creds = get_current_cred();\n\tif (!req->work.fs && def->needs_fs) {\n\t\tspin_lock(&current->fs->lock);\n\t\tif (!current->fs->in_exec) {\n\t\t\treq->work.fs = current->fs;\n\t\t\treq->work.fs->users++;\n\t\t} else {\n\t\t\treq->work.flags |= IO_WQ_WORK_CANCEL;\n\t\t}\n\t\tspin_unlock(&current->fs->lock);\n\t}\n}", "target": 1, "idx": 10690}
{"commit_id": "3cdb1c639da94a9dc8c75590d0ec475e7f27c226", "project": "wolfSSL/wolfssl", "func": "int DoTls13Finished(WOLFSSL* ssl, const byte* input, word32* inOutIdx,\n                           word32 size, word32 totalSz, int sniff)\n{\n    int    ret;\n    word32 finishedSz = 0;\n    byte*  secret;\n    byte   mac[WC_MAX_DIGEST_SIZE];\n\n    WOLFSSL_START(WC_FUNC_FINISHED_DO);\n    WOLFSSL_ENTER(\"DoTls13Finished\");\n\n#if !defined(NO_CERTS) && !defined(WOLFSSL_NO_CLIENT_AUTH)\n    /* verify the client sent certificate if required */\n    if (ssl->options.side == WOLFSSL_SERVER_END &&\n            (ssl->options.mutualAuth || ssl->options.failNoCert)) {\n        if (!ssl->options.havePeerVerify && !ssl->options.resuming) {\n            ret = NO_PEER_CERT;\n            DoCertFatalAlert(ssl, ret);\n            return ret;\n        }\n    }\n#endif\n\n    /* check against totalSz */\n    if (*inOutIdx + size + ssl->keys.padSz > totalSz)\n        return BUFFER_E;\n\n    if (ssl->options.handShakeDone) {\n        ret = DeriveFinishedSecret(ssl, ssl->clientSecret,\n                                   ssl->keys.client_write_MAC_secret);\n        if (ret != 0)\n            return ret;\n\n        secret = ssl->keys.client_write_MAC_secret;\n    }\n    else if (ssl->options.side == WOLFSSL_CLIENT_END) {\n        /* All the handshake messages have been received to calculate\n         * client and server finished keys.\n         */\n        ret = DeriveFinishedSecret(ssl, ssl->clientSecret,\n                                   ssl->keys.client_write_MAC_secret);\n        if (ret != 0)\n            return ret;\n\n        ret = DeriveFinishedSecret(ssl, ssl->serverSecret,\n                                   ssl->keys.server_write_MAC_secret);\n        if (ret != 0)\n            return ret;\n\n        secret = ssl->keys.server_write_MAC_secret;\n    }\n    else {\n        secret = ssl->keys.client_write_MAC_secret;\n    }\n\n    if (sniff == NO_SNIFF) {\n        ret = BuildTls13HandshakeHmac(ssl, secret, mac, &finishedSz);\n    #if defined(OPENSSL_ALL) || defined(WOLFSSL_HAPROXY) || defined(WOLFSSL_WPAS)\n        if (ssl->options.side == WOLFSSL_CLIENT_END) {\n            XMEMCPY(ssl->serverFinished, mac, finishedSz);\n            ssl->serverFinished_len = finishedSz;\n        }\n        else {\n            XMEMCPY(ssl->clientFinished, mac, finishedSz);\n            ssl->clientFinished_len = finishedSz;\n        }\n    #endif\n        if (ret != 0)\n            return ret;\n        if (size != finishedSz)\n            return BUFFER_ERROR;\n    }\n\n#ifdef WOLFSSL_CALLBACKS\n    if (ssl->hsInfoOn) AddPacketName(ssl, \"Finished\");\n    if (ssl->toInfoOn) AddLateName(\"Finished\", &ssl->timeoutInfo);\n#endif\n\n    if (sniff == NO_SNIFF) {\n        /* Actually check verify data. */\n        if (XMEMCMP(input + *inOutIdx, mac, size) != 0){\n            WOLFSSL_MSG(\"Verify finished error on hashes\");\n            SendAlert(ssl, alert_fatal, decrypt_error);\n            return VERIFY_FINISHED_ERROR;\n        }\n    }\n\n    /* Force input exhaustion at ProcessReply by consuming padSz. */\n    *inOutIdx += size + ssl->keys.padSz;\n\n    if (ssl->options.side == WOLFSSL_SERVER_END &&\n                                                  !ssl->options.handShakeDone) {\n#ifdef WOLFSSL_EARLY_DATA\n        if (ssl->earlyData != no_early_data) {\n            if ((ret = DeriveTls13Keys(ssl, no_key, DECRYPT_SIDE_ONLY, 1)) != 0)\n                return ret;\n        }\n#endif\n        /* Setup keys for application data messages from client. */\n        if ((ret = SetKeysSide(ssl, DECRYPT_SIDE_ONLY)) != 0)\n            return ret;\n    }\n\n#ifndef NO_WOLFSSL_CLIENT\n    if (ssl->options.side == WOLFSSL_CLIENT_END)\n        ssl->options.serverState = SERVER_FINISHED_COMPLETE;\n#endif\n#ifndef NO_WOLFSSL_SERVER\n    if (ssl->options.side == WOLFSSL_SERVER_END) {\n        ssl->options.clientState = CLIENT_FINISHED_COMPLETE;\n        ssl->options.handShakeState = HANDSHAKE_DONE;\n        ssl->options.handShakeDone  = 1;\n    }\n#endif\n\n    WOLFSSL_LEAVE(\"DoTls13Finished\", 0);\n    WOLFSSL_END(WC_FUNC_FINISHED_DO);\n\n    return 0;\n}", "target": 2, "idx": 10691}
{"commit_id": "f31f9b43954e06738af0f90fd75c45f869cd678a", "project": "python/cpython", "func": "static int\n_is_absW(const WCHAR *path)\n{\n    return path[0] == L'\\\\' || path[0] == L'/' ||\n        (path[0] && path[1] == L':');\n}", "target": 1, "idx": 10692}
{"commit_id": "be8c924744f1f19fa9c52cbd4dd85d44c34392ee", "project": "sass/libsass", "func": "BUILT_IN(selector_append)\n    {\n      List_Ptr arglist = ARG(\"$selectors\", List);\n\n      // Not enough parameters\n      if( arglist->length() == 0 )\n        error(\"$selectors: At least one selector must be passed for `selector-append'\", pstate, traces);\n\n      // Parse args into vector of selectors\n      SelectorStack parsedSelectors;\n      for (size_t i = 0, L = arglist->length(); i < L; ++i) {\n        Expression_Obj exp = Cast<Expression>(arglist->value_at_index(i));\n        if (exp->concrete_type() == Expression::NULL_VAL) {\n          std::stringstream msg;\n          msg << \"$selectors: null is not a valid selector: it must be a string,\\n\";\n          msg << \"a list of strings, or a list of lists of strings for 'selector-append'\";\n          error(msg.str(), pstate, traces);\n        }\n        if (String_Constant_Ptr str = Cast<String_Constant>(exp)) {\n          str->quote_mark(0);\n        }\n        std::string exp_src = exp->to_string();\n        Selector_List_Obj sel = Parser::parse_selector(exp_src.c_str(), ctx, traces,\n                                                       exp->pstate(), pstate.src,\n                                                       /*allow_parent=*/false);\n\n        parsedSelectors.push_back(sel);\n      }\n\n      // Nothing to do\n      if( parsedSelectors.empty() ) {\n        return SASS_MEMORY_NEW(Null, pstate);\n      }\n\n      // Set the first element as the `result`, keep appending to as we go down the parsedSelector vector.\n      SelectorStack::iterator itr = parsedSelectors.begin();\n      Selector_List_Obj result = *itr;\n      ++itr;\n\n      for(;itr != parsedSelectors.end(); ++itr) {\n        Selector_List_Obj child = *itr;\n        std::vector<Complex_Selector_Obj> newElements;\n\n        // For every COMPLEX_SELECTOR in `result`\n        // For every COMPLEX_SELECTOR in `child`\n          // let parentSeqClone equal a copy of result->elements[i]\n          // let childSeq equal child->elements[j]\n          // Append all of childSeq head elements into parentSeqClone\n          // Set the innermost tail of parentSeqClone, to childSeq's tail\n        // Replace result->elements with newElements\n        for (size_t i = 0, resultLen = result->length(); i < resultLen; ++i) {\n          for (size_t j = 0, childLen = child->length(); j < childLen; ++j) {\n            Complex_Selector_Obj parentSeqClone = SASS_MEMORY_CLONE((*result)[i]);\n            Complex_Selector_Obj childSeq = (*child)[j];\n            Complex_Selector_Obj base = childSeq->tail();\n\n            // Must be a simple sequence\n            if( childSeq->combinator() != Complex_Selector::Combinator::ANCESTOR_OF ) {\n              std::string msg(\"Can't append \\\"\");\n              msg += childSeq->to_string();\n              msg += \"\\\" to \\\"\";\n              msg += parentSeqClone->to_string();\n              msg += \"\\\" for `selector-append'\";\n              error(msg, pstate, traces);\n            }\n\n            // Cannot be a Universal selector\n            Element_Selector_Obj pType = Cast<Element_Selector>(childSeq->head()->first());\n            if(pType && pType->name() == \"*\") {\n              std::string msg(\"Can't append \\\"\");\n              msg += childSeq->to_string();\n              msg += \"\\\" to \\\"\";\n              msg += parentSeqClone->to_string();\n              msg += \"\\\" for `selector-append'\";\n              error(msg, pstate, traces);\n            }\n\n            // TODO: Add check for namespace stuff\n\n            Complex_Selector_Ptr lastComponent = parentSeqClone->mutable_last();\n            if (lastComponent->head() == nullptr) {\n              std::string msg = \"Parent \\\"\" + parentSeqClone->to_string() + \"\\\" is incompatible with \\\"\" + base->to_string() + \"\\\"\";\n              error(msg, pstate, traces);\n            }\n            lastComponent->head()->concat(base->head());\n            lastComponent->tail(base->tail());\n\n            newElements.push_back(parentSeqClone);\n          }\n        }\n\n        result->elements(newElements);\n      }\n\n      Listize listize;\n      return Cast<Value>(result->perform(&listize));\n    }", "target": 2, "idx": 10693}
{"commit_id": "a9bf2520ab5abb69f9328906e406fbebfb36159a", "project": "galkahana/HummusJS", "func": "IByteReader* DecryptionHelper::CreateDefaultDecryptionFilterForStream(PDFStreamInput* inStream, IByteReader* inToWrapStream) {\n\t// This will create a decryption filter for streams that dont have their own defined crypt filters. null for no decryption filter\n\tif (!IsEncrypted() || !CanDecryptDocument() || HasCryptFilterDefinition(mParser, inStream) || !mXcryptStreams)\n\t\treturn NULL;\n\t\n\tIDeletable* savedEcnryptionKey = inStream->GetMetadata(scEcnryptionKeyMetadataKey);\n\tif (savedEcnryptionKey) {\n\t\treturn CreateDecryptionReader(inToWrapStream, *(((Deletable<ByteList>*)savedEcnryptionKey)->GetPtr()), mXcryptStreams->IsUsingAES());\n\t}\n\telse \n\t\treturn NULL;\n}", "target": 2, "idx": 10694}
{"commit_id": "cfa1a965a429e4bfc5ae1539a8e87a9cf71c3090", "project": "CESNET/libyang", "func": "static LY_ERR\nlysp_stmt_validate_value(struct lysp_ctx *ctx, enum yang_arg val_type, const char *val)\n{\n    uint8_t prefix = 0;\n    ly_bool first = 1;\n    uint32_t c;\n    size_t utf8_char_len;\n\n    if (!val) {\n        if (val_type == Y_MAYBE_STR_ARG) {\n            /* fine */\n            return LY_SUCCESS;\n        }\n\n        LOGVAL_PARSER(ctx, LYVE_SYNTAX, \"Missing an expected string.\");\n        return LY_EVALID;\n    }\n\n    while (*val) {\n        LY_CHECK_ERR_RET(ly_getutf8(&val, &c, &utf8_char_len),\n                LOGVAL_PARSER(ctx, LY_VCODE_INCHAR, (val)[-utf8_char_len]), LY_EVALID);\n\n        switch (val_type) {\n        case Y_IDENTIF_ARG:\n            LY_CHECK_RET(lysp_check_identifierchar(ctx, c, first, NULL));\n            break;\n        case Y_PREF_IDENTIF_ARG:\n            LY_CHECK_RET(lysp_check_identifierchar(ctx, c, first, &prefix));\n            break;\n        case Y_STR_ARG:\n        case Y_MAYBE_STR_ARG:\n            LY_CHECK_RET(lysp_check_stringchar(ctx, c));\n            break;\n        }\n        first = 0;\n    }\n\n    return LY_SUCCESS;\n}", "target": 2, "idx": 10695}
{"commit_id": "086ff84617185393a0bbf25830c4f36412a7d3f4", "project": "torvalds/linux", "func": "static int fbcon_set_font(struct vc_data *vc, struct console_font *font,\n\t\t\t  unsigned int flags)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tunsigned charcount = font->charcount;\n\tint w = font->width;\n\tint h = font->height;\n\tint size;\n\tint i, csum;\n\tu8 *new_data, *data = font->data;\n\tint pitch = PITCH(font->width);\n\n\t/* Is there a reason why fbconsole couldn't handle any charcount >256?\n\t * If not this check should be changed to charcount < 256 */\n\tif (charcount != 256 && charcount != 512)\n\t\treturn -EINVAL;\n\n\t/* font bigger than screen resolution ? */\n\tif (w > FBCON_SWAP(info->var.rotate, info->var.xres, info->var.yres) ||\n\t    h > FBCON_SWAP(info->var.rotate, info->var.yres, info->var.xres))\n\t\treturn -EINVAL;\n\n\t/* Make sure drawing engine can handle the font */\n\tif (!(info->pixmap.blit_x & (1 << (font->width - 1))) ||\n\t    !(info->pixmap.blit_y & (1 << (font->height - 1))))\n\t\treturn -EINVAL;\n\n\t/* Make sure driver can handle the font length */\n\tif (fbcon_invalid_charcount(info, charcount))\n\t\treturn -EINVAL;\n\n\tsize = CALC_FONTSZ(h, pitch, charcount);\n\n\tnew_data = kmalloc(FONT_EXTRA_WORDS * sizeof(int) + size, GFP_USER);\n\n\tif (!new_data)\n\t\treturn -ENOMEM;\n\n\tmemset(new_data, 0, FONT_EXTRA_WORDS * sizeof(int));\n\n\tnew_data += FONT_EXTRA_WORDS * sizeof(int);\n\tFNTSIZE(new_data) = size;\n\tREFCOUNT(new_data) = 0;\t/* usage counter */\n\tfor (i=0; i< charcount; i++) {\n\t\tmemcpy(new_data + i*h*pitch, data +  i*32*pitch, h*pitch);\n\t}\n\n\t/* Since linux has a nice crc32 function use it for counting font\n\t * checksums. */\n\tcsum = crc32(0, new_data, size);\n\n\tFNTSUM(new_data) = csum;\n\t/* Check if the same font is on some other console already */\n\tfor (i = first_fb_vc; i <= last_fb_vc; i++) {\n\t\tstruct vc_data *tmp = vc_cons[i].d;\n\t\t\n\t\tif (fb_display[i].userfont &&\n\t\t    fb_display[i].fontdata &&\n\t\t    FNTSUM(fb_display[i].fontdata) == csum &&\n\t\t    FNTSIZE(fb_display[i].fontdata) == size &&\n\t\t    tmp->vc_font.width == w &&\n\t\t    !memcmp(fb_display[i].fontdata, new_data, size)) {\n\t\t\tkfree(new_data - FONT_EXTRA_WORDS * sizeof(int));\n\t\t\tnew_data = (u8 *)fb_display[i].fontdata;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn fbcon_do_set_font(vc, font->width, font->height, charcount, new_data, 1);\n}", "target": 1, "idx": 10696}
{"commit_id": "dcac57bc8b64fdc870d79d11a498ae7021cf8ae7", "project": "pdfium", "func": "CFFL_ComboBox::~CFFL_ComboBox() {\n  for (const auto& it : m_Maps)\n    it.second->InvalidateFocusHandler(this);\n  delete m_pFontMap;\n}", "target": 2, "idx": 10697}
{"commit_id": "6769a0b7ee0c3b31e1b22c3fadff2bfb642de23f", "project": "torvalds/linux", "func": "static int dvb_frontend_release(struct inode *inode, struct file *file)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct dvb_frontend *fe = dvbdev->priv;\n\tstruct dvb_frontend_private *fepriv = fe->frontend_priv;\n\tint ret;\n\n\tmutex_lock(&fe->remove_mutex);\n\n\tdev_dbg(fe->dvb->device, \"%s:\\n\", __func__);\n\n\tif ((file->f_flags & O_ACCMODE) != O_RDONLY) {\n\t\tfepriv->release_jiffies = jiffies;\n\t\tmb();\n\t}\n\n\tret = dvb_generic_release(inode, file);\n\n\tif (dvbdev->users == -1) {\n\t\twake_up(&fepriv->wait_queue);\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\n\t\tmutex_lock(&fe->dvb->mdev_lock);\n\t\tif (fe->dvb->mdev) {\n\t\t\tmutex_lock(&fe->dvb->mdev->graph_mutex);\n\t\t\tif (fe->dvb->mdev->disable_source)\n\t\t\t\tfe->dvb->mdev->disable_source(dvbdev->entity);\n\t\t\tmutex_unlock(&fe->dvb->mdev->graph_mutex);\n\t\t}\n\t\tmutex_unlock(&fe->dvb->mdev_lock);\n#endif\n\t\tif (fe->ops.ts_bus_ctrl)\n\t\t\tfe->ops.ts_bus_ctrl(fe, 0);\n\n\t\tif (fe->exit != DVB_FE_NO_EXIT) {\n\t\t\tmutex_unlock(&fe->remove_mutex);\n\t\t\twake_up(&dvbdev->wait_queue);\n\t\t} else {\n\t\t\tmutex_unlock(&fe->remove_mutex);\n\t\t}\n\n\t} else {\n\t\tmutex_unlock(&fe->remove_mutex);\n\t}\n\n\tdvb_frontend_put(fe);\n\n\treturn ret;\n}", "target": 2, "idx": 10698}
{"commit_id": "737e1f39da80e02912953269966d89afd196ad30", "project": "gpac", "func": "GF_EXPORT\nGF_VVCConfig *gf_isom_vvc_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\t/*todo, add support for subpic track and nvcl tracks*/\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tif (gf_isom_get_vvc_type(the_file, trackNumber, DescriptionIndex)==GF_ISOM_VVCTYPE_NONE)\n\t\treturn NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\tif (!entry) return NULL;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return NULL;\n\tif (!entry->vvc_config) return NULL;\n\treturn VVC_DuplicateConfig(entry->vvc_config->config);\n}", "target": 2, "idx": 10699}
{"commit_id": "cc080e9e9be16ccf26135d366d7d2b65209f1d56", "project": "torvalds/linux", "func": "static ssize_t fuse_dev_splice_write(struct pipe_inode_info *pipe,\n\t\t\t\t     struct file *out, loff_t *ppos,\n\t\t\t\t     size_t len, unsigned int flags)\n{\n\tunsigned nbuf;\n\tunsigned idx;\n\tstruct pipe_buffer *bufs;\n\tstruct fuse_copy_state cs;\n\tstruct fuse_dev *fud;\n\tsize_t rem;\n\tssize_t ret;\n\n\tfud = fuse_get_dev(out);\n\tif (!fud)\n\t\treturn -EPERM;\n\n\tbufs = kmalloc(pipe->buffers * sizeof(struct pipe_buffer), GFP_KERNEL);\n\tif (!bufs)\n\t\treturn -ENOMEM;\n\n\tpipe_lock(pipe);\n\tnbuf = 0;\n\trem = 0;\n\tfor (idx = 0; idx < pipe->nrbufs && rem < len; idx++)\n\t\trem += pipe->bufs[(pipe->curbuf + idx) & (pipe->buffers - 1)].len;\n\n\tret = -EINVAL;\n\tif (rem < len) {\n\t\tpipe_unlock(pipe);\n\t\tgoto out;\n\t}\n\n\trem = len;\n\twhile (rem) {\n\t\tstruct pipe_buffer *ibuf;\n\t\tstruct pipe_buffer *obuf;\n\n\t\tBUG_ON(nbuf >= pipe->buffers);\n\t\tBUG_ON(!pipe->nrbufs);\n\t\tibuf = &pipe->bufs[pipe->curbuf];\n\t\tobuf = &bufs[nbuf];\n\n\t\tif (rem >= ibuf->len) {\n\t\t\t*obuf = *ibuf;\n\t\t\tibuf->ops = NULL;\n\t\t\tpipe->curbuf = (pipe->curbuf + 1) & (pipe->buffers - 1);\n\t\t\tpipe->nrbufs--;\n\t\t} else {\n\t\t\tibuf->ops->get(pipe, ibuf);\n\t\t\t*obuf = *ibuf;\n\t\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\t\t\tobuf->len = rem;\n\t\t\tibuf->offset += obuf->len;\n\t\t\tibuf->len -= obuf->len;\n\t\t}\n\t\tnbuf++;\n\t\trem -= obuf->len;\n\t}\n\tpipe_unlock(pipe);\n\n\tfuse_copy_init(&cs, 0, NULL);\n\tcs.pipebufs = bufs;\n\tcs.nr_segs = nbuf;\n\tcs.pipe = pipe;\n\n\tif (flags & SPLICE_F_MOVE)\n\t\tcs.move_pages = 1;\n\n\tret = fuse_dev_do_write(fud->fc, &cs, len);\n\n\tfor (idx = 0; idx < nbuf; idx++) {\n\t\tstruct pipe_buffer *buf = &bufs[idx];\n\t\tbuf->ops->release(pipe, buf);\n\t}\nout:\n\tkfree(bufs);\n\treturn ret;\n}", "target": 1, "idx": 10700}
{"commit_id": "edb251a7ef1602d20a5afcbf23f24afb163de63b", "project": "GNOME/gimp", "func": "void fli_read_lc(FILE *f, s_fli_header *fli_header, unsigned char *old_framebuf, unsigned char *framebuf)\n{\n\tunsigned short yc, firstline, numline;\n\tunsigned char *pos;\n\tmemcpy(framebuf, old_framebuf, fli_header->width * fli_header->height);\n\tfirstline = fli_read_short(f);\n\tnumline = fli_read_short(f);\n\tif (numline > fli_header->height || fli_header->height-numline < firstline)\n\t\treturn;\n\n\tfor (yc=0; yc < numline; yc++) {\n\t\tunsigned short pc, pcnt;\n\t\tsize_t n, xc;\n\t\tpc=fli_read_char(f);\n\t\txc=0;\n\t\tpos=framebuf+(fli_header->width * (firstline+yc));\n\t\tn=(size_t)fli_header->width * (fli_header->height-firstline-yc);\n\t\tfor (pcnt=pc; pcnt>0; pcnt--) {\n\t\t\tunsigned short ps,skip;\n\t\t\tskip=fli_read_char(f);\n\t\t\tps=fli_read_char(f);\n\t\t\txc+=MIN(n-xc,skip);\n\t\t\tif (ps & 0x80) {\n\t\t\t\tunsigned char val;\n\t\t\t\tsize_t len;\n\t\t\t\tps=-(signed char)ps;\n\t\t\t\tval=fli_read_char(f);\n\t\t\t\tlen=MIN(n-xc,ps);\n\t\t\t\tmemset(&(pos[xc]), val, len);\n\t\t\t\txc+=len;\n\t\t\t} else {\n\t\t\t\tsize_t len;\n\t\t\t\tlen=MIN(n-xc,ps);\n\t\t\t\tfread(&(pos[xc]), len, 1, f);\n\t\t\t\txc+=len;\n\t\t\t}\n\t\t}\n\t}\n}", "target": 2, "idx": 10701}
{"commit_id": "cc00bcaa589914096edef7fb87ca5cee4a166b5c", "project": "torvalds/linux", "func": "struct xt_table_info *\nxt_replace_table(struct xt_table *table,\n\t      unsigned int num_counters,\n\t      struct xt_table_info *newinfo,\n\t      int *error)\n{\n\tstruct xt_table_info *private;\n\tint ret;\n\n\tret = xt_jumpstack_alloc(newinfo);\n\tif (ret < 0) {\n\t\t*error = ret;\n\t\treturn NULL;\n\t}\n\n\t/* Do the substitution. */\n\tprivate = xt_table_get_private_protected(table);\n\n\t/* Check inside lock: is the old number correct? */\n\tif (num_counters != private->number) {\n\t\tpr_debug(\"num_counters != table->private->number (%u/%u)\\n\",\n\t\t\t num_counters, private->number);\n\t\t*error = -EAGAIN;\n\t\treturn NULL;\n\t}\n\n\tnewinfo->initial_entries = private->initial_entries;\n\n\trcu_assign_pointer(table->private, newinfo);\n\tsynchronize_rcu();\n\n\taudit_log_nfcfg(table->name, table->af, private->number,\n\t\t\t!private->number ? AUDIT_XT_OP_REGISTER :\n\t\t\t\t\t   AUDIT_XT_OP_REPLACE,\n\t\t\tGFP_KERNEL);\n\treturn private;\n}", "target": 1, "idx": 10702}
{"commit_id": "a1631ac57b853edd81431e57c266ec813e180acd", "project": "php/php-src", "func": "static int exif_process_IFD_in_MAKERNOTE(image_info_type *ImageInfo, char * value_ptr, int value_len, char *offset_base, size_t IFDlength, size_t displacement)\n{\n\tsize_t i;\n\tint de, section_index = SECTION_MAKERNOTE;\n\tint NumDirEntries, old_motorola_intel;\n#ifdef KALLE_0\n\tint offset_diff;\n#endif\n\tconst maker_note_type *maker_note;\n\tchar *dir_start;\n\tint data_len;\n\n\tfor (i=0; i<=sizeof(maker_note_array)/sizeof(maker_note_type); i++) {\n\t\tif (i==sizeof(maker_note_array)/sizeof(maker_note_type)) {\n#ifdef EXIF_DEBUG\n\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"No maker note data found. Detected maker: %s (length = %d)\", ImageInfo->make, strlen(ImageInfo->make));\n#endif\n\t\t\t/* unknown manufacturer, not an error, use it as a string */\n\t\t\treturn TRUE;\n\t\t}\n\n\t\tmaker_note = maker_note_array+i;\n\n\t\t/*exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"check (%s)\", maker_note->make?maker_note->make:\"\");*/\n\t\tif (maker_note->make && (!ImageInfo->make || strcmp(maker_note->make, ImageInfo->make)))\n\t\t\tcontinue;\n\t\tif (maker_note->id_string && strncmp(maker_note->id_string, value_ptr, maker_note->id_string_len))\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\n\tif (value_len < 2 || maker_note->offset >= value_len - 1) {\n\t\t/* Do not go past the value end */\n\t\texif_error_docref(\"exif_read_data#error_ifd\" EXIFERR_CC, ImageInfo, E_WARNING, \"IFD data too short: 0x%04X offset 0x%04X\", value_len, maker_note->offset);\n\t\treturn FALSE;\n\t}\n\n\tdir_start = value_ptr + maker_note->offset;\n\n#ifdef EXIF_DEBUG\n\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Process %s @x%04X + 0x%04X=%d: %s\", exif_get_sectionname(section_index), (int)dir_start-(int)offset_base+maker_note->offset+displacement, value_len, value_len, exif_char_dump(value_ptr, value_len, (int)dir_start-(int)offset_base+maker_note->offset+displacement));\n#endif\n\n\tImageInfo->sections_found |= FOUND_MAKERNOTE;\n\n\told_motorola_intel = ImageInfo->motorola_intel;\n\tswitch (maker_note->byte_order) {\n\t\tcase MN_ORDER_INTEL:\n\t\t\tImageInfo->motorola_intel = 0;\n\t\t\tbreak;\n\t\tcase MN_ORDER_MOTOROLA:\n\t\t\tImageInfo->motorola_intel = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\tcase MN_ORDER_NORMAL:\n\t\t\tbreak;\n\t}\n\n\tNumDirEntries = php_ifd_get16u(dir_start, ImageInfo->motorola_intel);\n\n\tswitch (maker_note->offset_mode) {\n\t\tcase MN_OFFSET_MAKER:\n\t\t\toffset_base = value_ptr;\n\t\t\tdata_len = value_len;\n\t\t\tbreak;\n#ifdef KALLE_0\n\t\tcase MN_OFFSET_GUESS:\n\t\t\tif (maker_note->offset + 10 + 4 >= value_len) {\n\t\t\t\t/* Can not read dir_start+10 since it's beyond value end */\n\t\t\t\texif_error_docref(\"exif_read_data#error_ifd\" EXIFERR_CC, ImageInfo, E_WARNING, \"IFD data too short: 0x%04X\", value_len);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\toffset_diff = 2 + NumDirEntries*12 + 4 - php_ifd_get32u(dir_start+10, ImageInfo->motorola_intel);\n#ifdef EXIF_DEBUG\n\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Using automatic offset correction: 0x%04X\", ((int)dir_start-(int)offset_base+maker_note->offset+displacement) + offset_diff);\n#endif\n\t\t\tif (offset_diff < 0 || offset_diff >= value_len ) {\n\t\t\t\texif_error_docref(\"exif_read_data#error_ifd\" EXIFERR_CC, ImageInfo, E_WARNING, \"IFD data bad offset: 0x%04X length 0x%04X\", offset_diff, value_len);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\toffset_base = value_ptr + offset_diff;\n\t\t\tdata_len = value_len - offset_diff;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\tcase MN_OFFSET_NORMAL:\n\t\t\tdata_len = value_len;\n\t\t\tbreak;\n\t}\n\n\tif ((2+NumDirEntries*12) > value_len) {\n\t\texif_error_docref(\"exif_read_data#error_ifd\" EXIFERR_CC, ImageInfo, E_WARNING, \"Illegal IFD size: 2 + 0x%04X*12 = 0x%04X > 0x%04X\", NumDirEntries, 2+NumDirEntries*12, value_len);\n\t\treturn FALSE;\n\t}\n\tif ((dir_start - value_ptr) > value_len - (2+NumDirEntries*12)) {\n\t\texif_error_docref(\"exif_read_data#error_ifd\" EXIFERR_CC, ImageInfo, E_WARNING, \"Illegal IFD size: 0x%04X > 0x%04X\", (dir_start - value_ptr) + (2+NumDirEntries*12), value_len);\n\t\treturn FALSE;\n\t}\n\n\tfor (de=0;de<NumDirEntries;de++) {\n\t\tif (!exif_process_IFD_TAG(ImageInfo, dir_start + 2 + 12 * de,\n\t\t\t\t\t\t\t\t  offset_base, data_len, displacement, section_index, 0, maker_note->tag_table)) {\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\tImageInfo->motorola_intel = old_motorola_intel;\n/*\tNextDirOffset (must be NULL) = php_ifd_get32u(dir_start+2+12*de, ImageInfo->motorola_intel);*/\n#ifdef EXIF_DEBUG\n\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Subsection %s done\", exif_get_sectionname(SECTION_MAKERNOTE));\n#endif\n\treturn TRUE;\n}", "target": 3, "idx": 10703}
{"commit_id": "9690d3ab1f9bcd2db8cbe1fe3ee4a5da606b8814", "project": "kkos/oniguruma", "func": "static int\nforward_search_range(regex_t* reg, const UChar* str, const UChar* end, UChar* s,\n\t\t     UChar* range, UChar** low, UChar** high, UChar** low_prev)\n{\n  UChar *p, *pprev = (UChar* )NULL;\n\n#ifdef ONIG_DEBUG_SEARCH\n  fprintf(stderr, \"forward_search_range: str: %d, end: %d, s: %d, range: %d\\n\",\n\t  (int )str, (int )end, (int )s, (int )range);\n#endif\n\n  p = s;\n  if (reg->dmin > 0) {\n    if (ONIGENC_IS_SINGLEBYTE(reg->enc)) {\n      p += reg->dmin;\n    }\n    else {\n      UChar *q = p + reg->dmin;\n\n      if (q >= end) return 0; /* fail */\n      while (p < q) p += enclen(reg->enc, p);\n    }\n  }\n\n retry:\n  switch (reg->optimize) {\n  case ONIG_OPTIMIZE_EXACT:\n    p = slow_search(reg->enc, reg->exact, reg->exact_end, p, end, range);\n    break;\n  case ONIG_OPTIMIZE_EXACT_IC:\n    p = slow_search_ic(reg->enc, reg->case_fold_flag,\n                       reg->exact, reg->exact_end, p, end, range);\n    break;\n\n  case ONIG_OPTIMIZE_EXACT_BM:\n    p = bm_search(reg, reg->exact, reg->exact_end, p, end, range);\n    break;\n\n  case ONIG_OPTIMIZE_EXACT_BM_NOT_REV:\n    p = bm_search_notrev(reg, reg->exact, reg->exact_end, p, end, range);\n    break;\n\n  case ONIG_OPTIMIZE_MAP:\n    p = map_search(reg->enc, reg->map, p, range);\n    break;\n  }\n\n  if (p && p < range) {\n    if (p - reg->dmin < s) {\n    retry_gate:\n      pprev = p;\n      p += enclen(reg->enc, p);\n      goto retry;\n    }\n\n    if (reg->sub_anchor) {\n      UChar* prev;\n\n      switch (reg->sub_anchor) {\n      case ANCHOR_BEGIN_LINE:\n        if (!ON_STR_BEGIN(p)) {\n          prev = onigenc_get_prev_char_head(reg->enc,\n                                            (pprev ? pprev : str), p);\n          if (!ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end))\n            goto retry_gate;\n        }\n        break;\n\n      case ANCHOR_END_LINE:\n        if (ON_STR_END(p)) {\n#ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE\n          prev = (UChar* )onigenc_get_prev_char_head(reg->enc,\n                                                     (pprev ? pprev : str), p);\n          if (prev && ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end))\n            goto retry_gate;\n#endif\n        }\n        else if (! ONIGENC_IS_MBC_NEWLINE(reg->enc, p, end)\n#ifdef USE_CRNL_AS_LINE_TERMINATOR\n                 && ! ONIGENC_IS_MBC_CRNL(reg->enc, p, end)\n#endif\n                 )\n          goto retry_gate;\n        break;\n      }\n    }\n\n    if (reg->dmax == 0) {\n      *low = p;\n      if (low_prev) {\n        if (*low > s)\n          *low_prev = onigenc_get_prev_char_head(reg->enc, s, p);\n        else\n          *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                 (pprev ? pprev : str), p);\n      }\n    }\n    else {\n      if (reg->dmax != ONIG_INFINITE_DISTANCE) {\n        *low = p - reg->dmax;\n        if (*low > s) {\n          *low = onigenc_get_right_adjust_char_head_with_prev(reg->enc, s,\n                                          *low, (const UChar** )low_prev);\n          if (low_prev && IS_NULL(*low_prev))\n            *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                   (pprev ? pprev : s), *low);\n        }\n        else {\n          if (low_prev)\n            *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                   (pprev ? pprev : str), *low);\n        }\n      }\n    }\n    /* no needs to adjust *high, *high is used as range check only */\n    *high = p - reg->dmin;\n\n#ifdef ONIG_DEBUG_SEARCH\n    fprintf(stderr,\n    \"forward_search_range success: low: %d, high: %d, dmin: %d, dmax: %d\\n\",\n\t    (int )(*low - str), (int )(*high - str), reg->dmin, reg->dmax);\n#endif\n    return 1; /* success */\n  }\n\n  return 0; /* fail */\n}", "target": 3, "idx": 10704}
{"commit_id": "1c88bbd728da6bff8f4533bcfdb0dfef4ed8038b", "project": "wernsey/bitmap", "func": "int bm_puts(Bitmap *b, int x, int y, const char *text) {\n    assert(b);\n\tif(!b->font || !b->font->puts)\n        return 0;\n    return b->font->puts(b, x, y, text);\n}", "target": 2, "idx": 10705}
{"commit_id": "bde91c85bdc77975155058276f99d2e0f5eab5a9", "project": "util-linux", "func": "int xmkstemp(char **tmpname, const char *dir, const char *prefix)\n{\n\tchar *localtmp;\n\tconst char *tmpenv;\n\tmode_t old_mode;\n\tint fd, rc;\n\n\t/* Some use cases must be capable of being moved atomically\n\t * with rename(2), which is the reason why dir is here.  */\n\ttmpenv = dir ? dir : getenv(\"TMPDIR\");\n\tif (!tmpenv)\n\t\ttmpenv = _PATH_TMP;\n\n\trc = asprintf(&localtmp, \"%s/%s.XXXXXX\", tmpenv, prefix);\n\tif (rc < 0)\n\t\treturn -1;\n\n\told_mode = umask(077);\n\tfd = mkostemp(localtmp, O_RDWR|O_CREAT|O_EXCL|O_CLOEXEC);\n\tumask(old_mode);\n\tif (fd == -1) {\n\t\tfree(localtmp);\n\t\tlocaltmp = NULL;\n\t}\n\t*tmpname = localtmp;\n\treturn fd;\n}", "target": 3, "idx": 10706}
{"commit_id": "8fc52d77d6f66c438c98d536e2309b5fd13f90de", "project": "php/php-src", "func": "static void _php_image_convert(INTERNAL_FUNCTION_PARAMETERS, int image_type )\n{\n\tchar *f_org, *f_dest;\n\tint f_org_len, f_dest_len;\n\tlong height, width, threshold;\n\tgdImagePtr im_org, im_dest, im_tmp;\n\tchar *fn_org = NULL;\n\tchar *fn_dest = NULL;\n\tFILE *org, *dest;\n\tint dest_height = -1;\n\tint dest_width = -1;\n\tint org_height, org_width;\n\tint white, black;\n\tint color, color_org, median;\n\tint int_threshold;\n\tint x, y;\n\tfloat x_ratio, y_ratio;\n    long ignore_warning;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"pplll\", &f_org, &f_org_len, &f_dest, &f_dest_len, &height, &width, &threshold) == FAILURE) {\n\t\treturn;\n\t}\n\n\tfn_org  = f_org;\n\tfn_dest = f_dest;\n\tdest_height = height;\n\tdest_width = width;\n\tint_threshold = threshold;\n\n\t/* Check threshold value */\n\tif (int_threshold < 0 || int_threshold > 8) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid threshold value '%d'\", int_threshold);\n\t\tRETURN_FALSE;\n\t}\n\n\t/* Check origin file */\n\tPHP_GD_CHECK_OPEN_BASEDIR(fn_org, \"Invalid origin filename\");\n\n\t/* Check destination file */\n\tPHP_GD_CHECK_OPEN_BASEDIR(fn_dest, \"Invalid destination filename\");\n\n\t/* Open origin file */\n\torg = VCWD_FOPEN(fn_org, \"rb\");\n\tif (!org) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to open '%s' for reading\", fn_org);\n\t\tRETURN_FALSE;\n\t}\n\n\t/* Open destination file */\n\tdest = VCWD_FOPEN(fn_dest, \"wb\");\n\tif (!dest) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to open '%s' for writing\", fn_dest);\n\t\tRETURN_FALSE;\n\t}\n\n\tswitch (image_type) {\n\t\tcase PHP_GDIMG_TYPE_GIF:\n\t\t\tim_org = gdImageCreateFromGif(org);\n\t\t\tif (im_org == NULL) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to open '%s' Not a valid GIF file\", fn_dest);\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tbreak;\n\n#ifdef HAVE_GD_JPG\n\t\tcase PHP_GDIMG_TYPE_JPG:\n\t\t\tignore_warning = INI_INT(\"gd.jpeg_ignore_warning\");\n\t\t\tim_org = gdImageCreateFromJpegEx(org, ignore_warning);\n\t\t\tif (im_org == NULL) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to open '%s' Not a valid JPEG file\", fn_dest);\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tbreak;\n#endif /* HAVE_GD_JPG */\n\n#ifdef HAVE_GD_PNG\n\t\tcase PHP_GDIMG_TYPE_PNG:\n\t\t\tim_org = gdImageCreateFromPng(org);\n\t\t\tif (im_org == NULL) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to open '%s' Not a valid PNG file\", fn_dest);\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tbreak;\n#endif /* HAVE_GD_PNG */\n\n\t\tdefault:\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Format not supported\");\n\t\t\tRETURN_FALSE;\n\t\t\tbreak;\n\t}\n\n\torg_width  = gdImageSX (im_org);\n\torg_height = gdImageSY (im_org);\n\n\tx_ratio = (float) org_width / (float) dest_width;\n\ty_ratio = (float) org_height / (float) dest_height;\n\n\tif (x_ratio > 1 && y_ratio > 1) {\n\t\tif (y_ratio > x_ratio) {\n\t\t\tx_ratio = y_ratio;\n\t\t} else {\n\t\t\ty_ratio = x_ratio;\n\t\t}\n\t\tdest_width = (int) (org_width / x_ratio);\n\t\tdest_height = (int) (org_height / y_ratio);\n\t} else {\n\t\tx_ratio = (float) dest_width / (float) org_width;\n\t\ty_ratio = (float) dest_height / (float) org_height;\n\n\t\tif (y_ratio < x_ratio) {\n\t\t\tx_ratio = y_ratio;\n\t\t} else {\n\t\t\ty_ratio = x_ratio;\n\t\t}\n\t\tdest_width = (int) (org_width * x_ratio);\n\t\tdest_height = (int) (org_height * y_ratio);\n\t}\n\n\tim_tmp = gdImageCreate (dest_width, dest_height);\n\tif (im_tmp == NULL ) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to allocate temporary buffer\");\n\t\tRETURN_FALSE;\n\t}\n\n\tgdImageCopyResized (im_tmp, im_org, 0, 0, 0, 0, dest_width, dest_height, org_width, org_height);\n\n\tgdImageDestroy(im_org);\n\n\tfclose(org);\n\n\tim_dest = gdImageCreate(dest_width, dest_height);\n\tif (im_dest == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to allocate destination buffer\");\n\t\tRETURN_FALSE;\n\t}\n\n\twhite = gdImageColorAllocate(im_dest, 255, 255, 255);\n\tif (white == -1) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to allocate the colors for the destination buffer\");\n\t\tRETURN_FALSE;\n\t}\n\n\tblack = gdImageColorAllocate(im_dest, 0, 0, 0);\n\tif (black == -1) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to allocate the colors for the destination buffer\");\n\t\tRETURN_FALSE;\n\t}\n\n\tint_threshold = int_threshold * 32;\n\n\tfor (y = 0; y < dest_height; y++) {\n\t\tfor (x = 0; x < dest_width; x++) {\n\t\t\tcolor_org = gdImageGetPixel (im_tmp, x, y);\n\t\t\tmedian = (im_tmp->red[color_org] + im_tmp->green[color_org] + im_tmp->blue[color_org]) / 3;\n\t\t\tif (median < int_threshold) {\n\t\t\t\tcolor = black;\n\t\t\t} else {\n\t\t\t\tcolor = white;\n\t\t\t}\n\t\t\tgdImageSetPixel (im_dest, x, y, color);\n\t\t}\n\t}\n\n\tgdImageDestroy (im_tmp );\n\n\tgdImageWBMP(im_dest, black , dest);\n\n\tfflush(dest);\n\tfclose(dest);\n\n\tgdImageDestroy(im_dest);\n\n\tRETURN_TRUE;\n}", "target": 1, "idx": 10707}
{"commit_id": "bdfe95a6e81ffb4b2fad31a76b57943695beed20", "project": "jasper-software/jasper", "func": "void jp2_box_dump(jp2_box_t *box, FILE *out)\n{\n\tjp2_boxinfo_t *boxinfo;\n\tboxinfo = jp2_boxinfolookup(box->type);\n\tassert(boxinfo);\n\n\tfprintf(out, \"JP2 box: \");\n\tfprintf(out, \"type=%c%s%c (0x%08\"PRIxFAST32\"); length=%\"PRIuFAST32\"\\n\", '\"',\n\t  boxinfo->name, '\"', box->type, box->len);\n\tif (box->ops->dumpdata) {\n\t\t(*box->ops->dumpdata)(box, out);\n\t}\n}", "target": 2, "idx": 10708}
{"commit_id": "90b278d09f16062d93a4160ef0a54d449d739c51", "project": "julianhille/MuhammaraJS", "func": "EStatusCode PDFParser::ParseLastXrefPosition()\n{\n\tEStatusCode status = PDFHummus::eSuccess;\n\n\t// next two lines should be the xref position and then \"startxref\"\n\n\tdo\n\t{\n\n\t\t// find and read xref position\n\t\tif(!GoBackTillToken())\n\t\t{\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tTRACE_LOG(\"PDFParser::ParseXrefPosition, couldn't find xref position token\");\n\t\t\tbreak;\n\t\t}\n\n\t\tGoBackTillLineStart();\n\n\t\t// now go forward, and here i'm guessing a bit, till you get to either and integer, or the startxref keyword\n\t\tmStream->SetPositionFromEnd(GetCurrentPositionFromEnd());\n\n\t\tmObjectParser.ResetReadState();\n\t\tRefCountPtr<PDFObject> anObject(mObjectParser.ParseNewObject());\n\n\t\tif (!anObject) {\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tTRACE_LOG(\"PDFParser::ParseXrefPosition: Unable to find any object\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif(anObject->GetType() == PDFObject::ePDFObjectInteger)\n\t\t{\n\t\t\tmLastXrefPosition = (LongFilePositionType)((PDFInteger*)anObject.GetPtr())->GetValue();\n\n\t\t\t// find and read startxref keyword\n\t\t\tif(!GoBackTillToken())\n\t\t\t{\n\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\tTRACE_LOG(\"PDFParser::ParseXrefPosition, couldn't find startxref keyword\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tGoBackTillLineStart();\n\t\t\tmStream->SetPositionFromEnd(GetCurrentPositionFromEnd());\n\n\t\t\tmObjectParser.ResetReadState();\n\t\t\tPDFObjectCastPtr<PDFSymbol> startxRef(mObjectParser.ParseNewObject());\n\n\t\t\tif(!startxRef || startxRef->GetValue() != scStartxref)\n\t\t\t{\n\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\tTRACE_LOG(\"PDFParser::ParseXrefPosition, syntax error in reading xref position\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse // this means that the line is not only integer, a bit more complicated path, look for startxref and then the next would be the number\n\t\t{\n\t\t\tbool foundStartXref = (anObject->GetType() == PDFObject::ePDFObjectSymbol) && (((PDFSymbol*)anObject.GetPtr())->GetValue() == scStartxref);\n\n\t\t\twhile(!foundStartXref && mStream->NotEnded())\n\t\t\t{\n\t\t\t\tPDFObjectCastPtr<PDFSymbol> startxRef(mObjectParser.ParseNewObject());\n\t\t\t\tfoundStartXref = startxRef.GetPtr() && (startxRef->GetValue() == scStartxref);\n\t\t\t}\n\n\t\t\tif(!foundStartXref)\n\t\t\t{\n\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\tTRACE_LOG(\"PDFParser::ParseXrefPosition, could not find startxref keyword\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tPDFObjectCastPtr<PDFInteger> xrefPosition(mObjectParser.ParseNewObject());\n\t\t\tif(!xrefPosition)\n\t\t\t{\n\t\t\t\tstatus = PDFHummus::eFailure;\n\t\t\t\tTRACE_LOG(\"PDFParser::ParseXrefPosition, syntax error in reading xref position\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmLastXrefPosition = xrefPosition->GetValue();\n\t\t}\n\n\t}while(false);\n\n\treturn status;\n\n}", "target": 2, "idx": 10709}
{"commit_id": "928429c5c96a701bcbcafacb2421a82602b36915", "project": "libgit2", "func": "static int valid_entry_name(const char *filename)\n{\n\treturn *filename != '\\0' &&\n\t\tstrchr(filename, '/') == NULL &&\n\t\t(*filename != '.' ||\n\t\t (strcmp(filename, \".\") != 0 &&\n\t\t  strcmp(filename, \"..\") != 0 &&\n\t\t  strcasecmp(filename, DOT_GIT) != 0));\n}", "target": 3, "idx": 10710}
{"commit_id": "712f4aad406bb1ed67f3f98d04c044191f0ff593", "project": "torvalds/linux", "func": "void unix_notinflight(struct file *fp)\n{\n\tstruct sock *s = unix_get_socket(fp);\n\n\tspin_lock(&unix_gc_lock);\n\n\tif (s) {\n\t\tstruct unix_sock *u = unix_sk(s);\n\n\t\tBUG_ON(list_empty(&u->link));\n\n\t\tif (atomic_long_dec_and_test(&u->inflight))\n\t\t\tlist_del_init(&u->link);\n\t\tunix_tot_inflight--;\n\t}\n\tfp->f_cred->user->unix_inflight--;\n\tspin_unlock(&unix_gc_lock);\n}", "target": 1, "idx": 10711}
{"commit_id": "4f4c95cf46ba6adbd10b09747e10742801bc706b", "project": "wireshark", "func": "static int cond_seq(tvbparse_t* tt, int offset, const tvbparse_wanted_t * wanted, tvbparse_elem_t** tok) {\n    guint i;\n    int len = 0;\n    int start = offset;\n    tvbparse_elem_t* ret_tok = NULL;\n\n#ifdef TVBPARSE_DEBUG\n    if (TVBPARSE_DEBUG & TVBPARSE_DEBUG_SEQ) g_warning(\"cond_seq: START\");\n#endif\n\n    if ( offset > tt->end_offset )\n        return -1;\n\n    if (++tt->recursion_depth > TVBPARSE_MAX_RECURSION_DEPTH)\n        return -1;\n\n    for(i=0; i < wanted->control.elems->len; i++) {\n        tvbparse_wanted_t* w = (tvbparse_wanted_t *)g_ptr_array_index(wanted->control.elems,i);\n        tvbparse_elem_t* new_elem = NULL;\n\n        if ( offset + w->len > tt->end_offset )\n            return -1;\n\n\n        len = w->condition(tt, offset, w, &new_elem);\n\n        if (len >= 0) {\n            if (ret_tok) {\n                if (new_elem->len)\n                    ret_tok->len = (new_elem->offset - ret_tok->offset) + new_elem->len;\n                ret_tok->sub->last->next = new_elem;\n                ret_tok->sub->last = new_elem;\n            } else {\n                ret_tok = new_tok(tt, wanted->id, new_elem->offset, new_elem->len, wanted);\n                ret_tok->sub = new_elem;\n                new_elem->last = new_elem;\n            }\n        } else {\n            return -1;\n        }\n\n        offset += len;\n        offset += ignore_fcn(tt,offset);\n    }\n\n    *tok = ret_tok;\n\n#ifdef TVBPARSE_DEBUG\n    if (TVBPARSE_DEBUG & TVBPARSE_DEBUG_SEQ) g_warning(\"cond_seq: GOT len=%i\",offset - start);\n#endif\n\n    return offset - start;\n}", "target": 2, "idx": 10712}
{"commit_id": "cc00bcaa589914096edef7fb87ca5cee4a166b5c", "project": "torvalds/linux", "func": "static int do_add_counters(struct net *net, sockptr_t arg, unsigned int len)\n{\n\tunsigned int i;\n\tstruct xt_counters_info tmp;\n\tstruct xt_counters *paddc;\n\tstruct xt_table *t;\n\tconst struct xt_table_info *private;\n\tint ret = 0;\n\tstruct arpt_entry *iter;\n\tunsigned int addend;\n\n\tpaddc = xt_copy_counters(arg, len, &tmp);\n\tif (IS_ERR(paddc))\n\t\treturn PTR_ERR(paddc);\n\n\tt = xt_find_table_lock(net, NFPROTO_ARP, tmp.name);\n\tif (IS_ERR(t)) {\n\t\tret = PTR_ERR(t);\n\t\tgoto free;\n\t}\n\n\tlocal_bh_disable();\n\tprivate = xt_table_get_private_protected(t);\n\tif (private->number != tmp.num_counters) {\n\t\tret = -EINVAL;\n\t\tgoto unlock_up_free;\n\t}\n\n\ti = 0;\n\n\taddend = xt_write_recseq_begin();\n\txt_entry_foreach(iter,  private->entries, private->size) {\n\t\tstruct xt_counters *tmp;\n\n\t\ttmp = xt_get_this_cpu_counter(&iter->counters);\n\t\tADD_COUNTER(*tmp, paddc[i].bcnt, paddc[i].pcnt);\n\t\t++i;\n\t}\n\txt_write_recseq_end(addend);\n unlock_up_free:\n\tlocal_bh_enable();\n\txt_table_unlock(t);\n\tmodule_put(t->me);\n free:\n\tvfree(paddc);\n\n\treturn ret;\n}", "target": 1, "idx": 10713}
{"commit_id": "4f4c95cf46ba6adbd10b09747e10742801bc706b", "project": "wireshark", "func": "static int cond_hash(tvbparse_t* tt, const int offset, const tvbparse_wanted_t* wanted, tvbparse_elem_t** tok) {\n    int key_len;\n    gchar* key = NULL;\n    tvbparse_elem_t* key_elem = NULL;\n    tvbparse_wanted_t* value_wanted = NULL;\n    int value_len;\n    tvbparse_elem_t* value_elem = NULL;\n    int tot_len;\n    tvbparse_elem_t* ret_tok;\n\n#ifdef TVBPARSE_DEBUG\n    if (TVBPARSE_DEBUG & TVBPARSE_DEBUG_HASH) g_warning(\"cond_hash: START\");\n#endif\n\n    if ( offset > tt->end_offset )\n        return -1;\n\n    if (++tt->recursion_depth > TVBPARSE_MAX_RECURSION_DEPTH)\n        return -1;\n\n    key_len = wanted->control.hash.key->condition(tt, offset, wanted->control.hash.key,  &key_elem);\n\n    if (key_len < 0)\n        return -1;\n\n    key = tvb_get_string_enc(wmem_packet_scope(),key_elem->tvb,key_elem->offset,key_elem->len, ENC_ASCII);\n#ifdef TVBPARSE_DEBUG\n    if (TVBPARSE_DEBUG & TVBPARSE_DEBUG_HASH) g_warning(\"cond_hash: got key='%s'\",key);\n#endif\n\n    if ((value_wanted = (tvbparse_wanted_t *)wmem_map_lookup(wanted->control.hash.table,key))) {\n        value_len = value_wanted->condition(tt, offset + key_len, value_wanted,  &value_elem);\n    } else if (wanted->control.hash.other) {\n        value_len = wanted->control.hash.other->condition(tt, offset+key_len, wanted->control.hash.other,  &value_elem);\n        if (value_len < 0)\n            return -1;\n    } else {\n        return -1;\n    }\n\n    tot_len = key_len + value_len;\n\n    ret_tok = new_tok(tt, value_elem->id, offset, tot_len, wanted);\n    ret_tok->sub = key_elem;\n    ret_tok->sub->last->next = value_elem;\n\n    *tok = ret_tok;\n#ifdef TVBPARSE_DEBUG\n    if (TVBPARSE_DEBUG & TVBPARSE_DEBUG_HASH) g_warning(\"cond_hash: GOT len=%i\",tot_len);\n#endif\n\n    return tot_len;\n}", "target": 2, "idx": 10714}
{"commit_id": "88e7b873da5d3e85d31b601c1560d2e24a1d7b25", "project": "gpac", "func": "static s32 gf_vvc_read_pps_bs_internal(GF_BitStream *bs, VVCState *vvc)\n{\n\tu32 i;\n\ts32 pps_id;\n\tVVC_PPS *pps;\n\n\t//NAL header already read\n\tpps_id = gf_bs_read_int_log(bs, 6, \"pps_id\");\n\n\tif ((pps_id < 0) || (pps_id >= 64)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VVC] wrong PPS ID %d in PPS\\n\", pps_id));\n\t\treturn -1;\n\t}\n\tpps = &vvc->pps[pps_id];\n\n\tif (!pps->state) {\n\t\tpps->id = pps_id;\n\t\tpps->state = 1;\n\t}\n\tpps->sps_id = gf_bs_read_int_log(bs, 4, \"sps_id\");\n\tif (((s32)pps->sps_id<0) || (pps->sps_id >= 16)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VVC] wrong SPS ID %d in PPS\\n\", pps->sps_id));\n\t\tpps->sps_id=0;\n\t\treturn -1;\n\t}\n\tvvc->sps_active_idx = pps->sps_id; /*set active sps*/\n\tpps->mixed_nal_types = gf_bs_read_int_log(bs, 1, \"mixed_nal_types\");\n\tpps->width = gf_bs_read_ue_log(bs, \"width\");\n\tpps->height = gf_bs_read_ue_log(bs, \"height\");\n\tpps->conf_window = gf_bs_read_int_log(bs, 1, \"conformance_window_flag\");\n\tif (pps->conf_window) {\n\t\tpps->cw_left = gf_bs_read_ue_log(bs, \"conf_win_left_offset\");\n\t\tpps->cw_right = gf_bs_read_ue_log(bs, \"conf_win_right_offset\");\n\t\tpps->cw_top = gf_bs_read_ue_log(bs, \"conf_win_top_offset\");\n\t\tpps->cw_bottom = gf_bs_read_ue_log(bs, \"conf_win_bottom_offset\");\n\t}\n\t//scaling window\n\tif (gf_bs_read_int_log(bs, 1, \"scaling_window_explicit_signaling_flag\")) {\n\t\tgf_bs_read_se_log(bs, \"scaling_win_left_offset\");\n\t\tgf_bs_read_se_log(bs, \"scaling_win_right_offset\");\n\t\tgf_bs_read_se_log(bs, \"scaling_win_top_offset\");\n\t\tgf_bs_read_se_log(bs, \"scaling_win_bottom_offset\");\n\t}\n\tpps->output_flag_present_flag = gf_bs_read_int_log(bs, 1, \"output_flag_present_flag\");\n\tpps->no_pic_partition_flag = gf_bs_read_int_log(bs, 1, \"no_pic_partition_flag\");\n\tpps->subpic_id_mapping_present_flag = gf_bs_read_int_log(bs, 1, \"subpic_id_mapping_present_flag\");\n\tu32 pps_num_subpics = 1;\n\tif (pps->subpic_id_mapping_present_flag) {\n\t\tu32 pps_subpic_id_len;\n\t\tif (!pps->no_pic_partition_flag) {\n\t\t\tpps_num_subpics = 1+gf_bs_read_ue_log(bs, \"pps_num_subpics_minus1\");\n\t\t}\n\t\tpps_subpic_id_len = 1 + gf_bs_read_ue(bs);\n\t\tfor (i=0; i<pps_num_subpics; i++) {\n\t\t\tgf_bs_read_int_log_idx(bs, pps_subpic_id_len, \"subpic_id\", i);\n\t\t}\n\t}\n\tpps->single_slice_per_subpic_flag = 1;\n\tpps->num_slices_in_pic = 1;\n\n\tpps->num_tiles_in_pic = 0;\n\tif (!pps->no_pic_partition_flag) {\n\t\tu32 ctu_size = 5 + gf_bs_read_int_log(bs, 2, \"pps_log2_ctu_size_minus5\");\n\t\tu32 num_exp_tile_columns = 1 + gf_bs_read_ue_log(bs, \"num_exp_tile_columns_minus1\");\n\t\tu32 num_exp_tile_rows = 1 + gf_bs_read_ue_log(bs, \"num_exp_tile_rows_minus1\");\n\n\t\tif (num_exp_tile_columns > VVC_MAX_TILE_COLS) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VVC] wrong num tile columns %d in PPS\\n\", num_exp_tile_columns));\n\t\t\tpps->sps_id=0;\n\t\t\treturn -1;\n\t\t}\n\t\tif (num_exp_tile_rows > VVC_MAX_TILE_ROWS) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VVC] wrong num tile rows %d in PPS\\n\", num_exp_tile_rows));\n\t\t\tpps->sps_id=0;\n\t\t\treturn -1;\n\t\t}\n\n\t\tctu_size = 1<<ctu_size;\n\t\tpps->pic_width_in_ctbsY = pps->width / ctu_size;\n\t\tif (pps->pic_width_in_ctbsY * ctu_size < pps->width) pps->pic_width_in_ctbsY++;\n\t\tpps->pic_height_in_ctbsY = pps->height / ctu_size;\n\t\tif (pps->pic_height_in_ctbsY * ctu_size < pps->height) pps->pic_height_in_ctbsY++;\n\n\t\tu32 nb_ctb_left = pps->pic_width_in_ctbsY;\n\t\tpps->num_tile_cols=0;\n\t\tu32 nb_ctb_last=0;\n\t\tfor (i=0; i<num_exp_tile_columns; i++) {\n\t\t\tu32 nb_ctb_width = 1 + gf_bs_read_ue_log_idx(bs, \"tile_column_width_minus1\", i);\n\t\t\tif (nb_ctb_left < nb_ctb_width) {\n\t\t\t\tpps->sps_id=0;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tnb_ctb_left -= nb_ctb_width;\n\t\t\tpps->tile_cols_width_ctb[i] = nb_ctb_width;\n\t\t\tnb_ctb_last = nb_ctb_width;\n\t\t\tpps->num_tile_cols++;\n\t\t\tif (pps->num_tile_cols > VVC_MAX_TILE_COLS) {\n\t\t\t\tpps->sps_id=0;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tu32 uni_size_ctb = nb_ctb_last;\n\t\twhile (nb_ctb_left >= uni_size_ctb) {\n\t\t\tnb_ctb_left -= uni_size_ctb;\n\t\t\tif (pps->num_tile_cols >= VVC_MAX_TILE_COLS) {\n\t\t\t\tpps->sps_id=0;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tpps->tile_cols_width_ctb[pps->num_tile_cols] = uni_size_ctb;\n\t\t\tpps->num_tile_cols++;\n\t\t}\n\t\tif (nb_ctb_left>0) {\n\t\t\tif (pps->num_tile_cols >= VVC_MAX_TILE_COLS) {\n\t\t\t\tpps->sps_id=0;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tpps->tile_cols_width_ctb[pps->num_tile_cols] = nb_ctb_left;\n\t\t\tpps->num_tile_cols++;\n\t\t}\n\n\t\tnb_ctb_left = pps->pic_height_in_ctbsY;\n\t\tnb_ctb_last=0;\n\t\tpps->num_tile_rows=0;\n\t\tfor (i=0; i<num_exp_tile_rows; i++) {\n\t\t\tu32 nb_ctb_height = 1 + gf_bs_read_ue_log_idx(bs, \"tile_row_height_minus1\", i);\n\t\t\tif (nb_ctb_left < nb_ctb_height) {\n\t\t\t\tpps->sps_id=0;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tnb_ctb_left -= nb_ctb_height;\n\t\t\tpps->tile_rows_height_ctb[i] = nb_ctb_height;\n\t\t\tpps->num_tile_rows++;\n\t\t\tnb_ctb_last = nb_ctb_height;\n\t\t\tif (pps->num_tile_rows > VVC_MAX_TILE_ROWS) {\n\t\t\t\tpps->sps_id=0;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tuni_size_ctb = nb_ctb_last;\n\t\twhile (nb_ctb_left >= uni_size_ctb) {\n\t\t\tnb_ctb_left -= uni_size_ctb;\n\t\t\tif (pps->num_tile_rows >= VVC_MAX_TILE_ROWS) {\n\t\t\t\tpps->sps_id=0;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tpps->tile_rows_height_ctb[pps->num_tile_rows] = uni_size_ctb;\n\t\t\tpps->num_tile_rows++;\n\t\t}\n\t\tif (nb_ctb_left>0) {\n\t\t\tif (pps->num_tile_rows >= VVC_MAX_TILE_ROWS) {\n\t\t\t\tpps->sps_id=0;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tpps->tile_rows_height_ctb[pps->num_tile_rows] = nb_ctb_left;\n\t\t\tpps->num_tile_rows++;\n\t\t}\n\n\t\tpps->num_tiles_in_pic = pps->num_tile_cols * pps->num_tile_rows;\n\t\tpps->slice_address_len = gf_get_bit_size(pps->num_tiles_in_pic);\n\t\tif (pps->num_tiles_in_pic > 1) {\n\t\t\tgf_bs_read_int_log(bs, 1, \"pps_loop_filter_across_tiles_enabled_flag\");\n\t\t\tpps->rect_slice_flag = gf_bs_read_int_log(bs, 1, \"pps_rect_slice_flag\");\n\t\t}\n\n\t\tif (pps->rect_slice_flag) {\n\t\t\tpps->single_slice_per_subpic_flag = gf_bs_read_int_log(bs, 1, \"pps_single_slice_per_subpic_flag\");\n\t\t\tpps->num_slices_in_pic = pps_num_subpics;\n\t\t}\n\n\t\tif (pps->rect_slice_flag && !pps->single_slice_per_subpic_flag) {\n\t\t\tpps->num_slices_in_pic = 1 + gf_bs_read_ue_log(bs, \"pps_num_slices_in_pic_minus1\");\n\t\t\tu8 tile_idx_delta_present_flag = 0;\n\t\t\tif (pps->num_slices_in_pic > 1) {\n\t\t\t\ttile_idx_delta_present_flag = gf_bs_read_int_log(bs, 1, \"pps_tile_idx_delta_present_flag\");\n\t\t\t}\n\t\t\tfor (i=0; i<pps->num_slices_in_pic-1; i++) {\n\t\t\t\t//TODO FIXME we assume single slice per tile\n\t\t\t\tu32 SliceTopLeftTileIdx=0;\n\t\t\t\tu32 RowHeightVal=0;\n\n\n\t\t\t\tu32 slice_width_in_tiles_minus1=0;\n\t\t\t\tu32 slice_height_in_tiles_minus1=0;\n\t\t\t\tif (SliceTopLeftTileIdx % pps->num_tile_cols != pps->num_tile_cols - 1) {\n\t\t\t\t\tslice_width_in_tiles_minus1 = gf_bs_read_ue_log_idx(bs, \"pps_slice_width_in_tiles_minus1\", i);\n\t\t\t\t}\n\n\t\t\t\tif ( (SliceTopLeftTileIdx / pps->num_tile_cols != pps->num_tile_rows - 1)\n\t\t\t\t\t&& (tile_idx_delta_present_flag || (SliceTopLeftTileIdx % pps->num_tile_cols == 0) )\n\t\t\t\t) {\n\t\t\t\t\tslice_height_in_tiles_minus1 = gf_bs_read_ue_log_idx(bs, \"pps_slice_height_in_tiles_minus1\", i);\n\t\t\t\t}\n\n\t\t\t\tif (!slice_width_in_tiles_minus1 && !slice_height_in_tiles_minus1 && (RowHeightVal > 1 )\n\t\t\t\t) {\n\t\t\t\t\tu32 j, num_exp_slices_in_tile = gf_bs_read_ue_log_idx(bs, \"pps_num_exp_slices_in_tile\", i);\n\t\t\t\t\tfor (j=0; j<num_exp_slices_in_tile; j++) {\n\t\t\t\t\t\tgf_bs_read_ue_log_idx2 (bs, \"pps_exp_slice_height_in_ctus_minus1\", i, j);\n\t\t\t\t\t}\n\t\t\t\t\t//TODO FIXME i += NumSlicesInTile[ i ] \u2212 1\n\t\t\t\t}\n\n\t\t\t\tif (tile_idx_delta_present_flag && (i < pps->num_slices_in_pic)) {\n\t\t\t\t\tgf_bs_read_se_log_idx(bs, \"pps_tile_idx_delta_val\", i);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tif (!pps->rect_slice_flag || pps->single_slice_per_subpic_flag || (pps->num_slices_in_pic > 1)) {\n\t\t\tgf_bs_read_int_log(bs, 1, \"pps_loop_filter_across_slices_enabled_flag\");\n\t\t}\n\t}\n\n\n\tpps->cabac_init_present_flag = gf_bs_read_int_log(bs, 1, \"pps_cabac_init_present_flag\");\n\tfor (i=0; i<2; i++) {\n\t\tpps->num_ref_idx_default_active[i] = 1 + gf_bs_read_ue_log_idx(bs, \"pps_num_ref_idx_default_active_minus1\", i);\n\t}\n\tpps->rpl1_idx_present_flag = gf_bs_read_int_log(bs, 1, \"pps_rpl1_idx_present_flag\");\n\tpps->weighted_pred_flag = gf_bs_read_int_log(bs, 1, \"pps_weighted_pred_flag\");\n\tpps->weighted_bipred_flag = gf_bs_read_int_log(bs, 1, \"pps_weighted_bipred_flag\");\n\tif (gf_bs_read_int_log(bs, 1, \"pps_ref_wraparound_enabled_flag\")) {\n\t\tgf_bs_read_ue_log(bs, \"pps_pic_width_minus_wraparound_offset\");\n\t}\n\tgf_bs_read_se_log(bs, \"pps_init_qp_minus26\");\n\tpps->cu_qp_delta_enabled_flag = gf_bs_read_int_log(bs, 1, \"pps_cu_qp_delta_enabled_flag\");\n\tpps->slice_chroma_qp_offsets_present_flag = 0;\n\tpps->chroma_tool_offsets_present_flag = gf_bs_read_int_log(bs, 1, \"pps_chroma_tool_offsets_present_flag\");\n\tif (pps->chroma_tool_offsets_present_flag) {\n\t\tgf_bs_read_se_log(bs, \"pps_cb_qp_offset\");\n\t\tgf_bs_read_se_log(bs, \"pps_cr_qp_offset\");\n\t\tu8 joint_cbcr_qp_offset_present_flag = gf_bs_read_int_log(bs, 1, \"pps_joint_cbcr_qp_offset_present_flag\");\n\t\tif (joint_cbcr_qp_offset_present_flag) {\n\t\t\tgf_bs_read_se_log(bs, \"pps_joint_cbcr_qp_offset_value\");\n\t\t}\n\t\tpps->slice_chroma_qp_offsets_present_flag = gf_bs_read_int_log(bs, 1, \"pps_slice_chroma_qp_offsets_present_flag\");\n\t\tpps->cu_chroma_qp_offset_list_enabled_flag = gf_bs_read_int_log(bs, 1, \"pps_cu_chroma_qp_offset_list_enabled_flag\");\n\t\tif (pps->cu_chroma_qp_offset_list_enabled_flag) {\n\t\t\tu32 pps_chroma_qp_offset_list_len = 1 + gf_bs_read_ue_log(bs, \"pps_chroma_qp_offset_list_len_minus1\");\n\t\t\tfor (i=0; i<pps_chroma_qp_offset_list_len; i++) {\n\t\t\t\tgf_bs_read_se_log_idx(bs, \"pps_cb_qp_offset_list\", i);\n\t\t\t\tgf_bs_read_se_log_idx(bs, \"pps_cr_qp_offset_list\", i);\n\t\t\t\tif (joint_cbcr_qp_offset_present_flag) {\n\t\t\t\t\tgf_bs_read_se_log_idx(bs, \"pps_joint_cbcr_qp_offset_list\", i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpps->dbf_info_in_ph_flag = 0;\n\tpps->deblocking_filter_disabled_flag = 0;\n\tpps->deblocking_filter_override_enabled_flag = 0;\n\tif (gf_bs_read_int_log(bs, 1, \"pps_deblocking_filter_control_present_flag\")) {\n\t\tpps->deblocking_filter_override_enabled_flag = gf_bs_read_int_log(bs, 1, \"pps_deblocking_filter_override_enabled_flag\");\n\t\tpps->deblocking_filter_disabled_flag = gf_bs_read_int_log(bs, 1, \"pps_deblocking_filter_disabled_flag\");\n\n\t\tif (!pps->no_pic_partition_flag && pps->deblocking_filter_override_enabled_flag) {\n\t\t\tpps->dbf_info_in_ph_flag = gf_bs_read_int_log(bs, 1, \"pps_dbf_info_in_ph_flag\");\n\t\t}\n\t\tif (!pps->deblocking_filter_disabled_flag) {\n\t\t\tgf_bs_read_se_log(bs, \"pps_luma_beta_offset_div2\");\n\t\t\tgf_bs_read_se_log(bs, \"pps_luma_tc_offset_div2\");\n\t\t\tif (pps->chroma_tool_offsets_present_flag) {\n\t\t\t\tgf_bs_read_se_log(bs, \"pps_cb_beta_offset_div2\");\n\t\t\t\tgf_bs_read_se_log(bs, \"pps_cb_tc_offset_div2\");\n\t\t\t\tgf_bs_read_se_log(bs, \"pps_cr_beta_offset_div2\");\n\t\t\t\tgf_bs_read_se_log(bs, \"pps_cr_tc_offset_div2\");\n\t\t\t}\n\t\t}\n\t}\n\tpps->wp_info_in_ph_flag = 0;\n\tpps->qp_delta_info_in_ph_flag = 0;\n\tpps->sao_info_in_ph_flag = 0;\n\tif (!pps->no_pic_partition_flag) {\n\t\tpps->rpl_info_in_ph_flag = gf_bs_read_int_log(bs, 1, \"pps_rpl_info_in_ph_flag\");\n\t\tpps->sao_info_in_ph_flag = gf_bs_read_int_log(bs, 1, \"pps_sao_info_in_ph_flag\");\n\t\tpps->alf_info_in_ph_flag = gf_bs_read_int_log(bs, 1, \"pps_alf_info_in_ph_flag\");\n\t\tif ( (pps->weighted_pred_flag || pps->weighted_bipred_flag) && pps->rpl_info_in_ph_flag) {\n\t\t\tpps->wp_info_in_ph_flag = gf_bs_read_int_log(bs, 1, \"pps_wp_info_in_ph_flag\");\n\t\t}\n\t\tpps->qp_delta_info_in_ph_flag = gf_bs_read_int_log(bs, 1, \"pps_qp_delta_info_in_ph_flag\");\n\t}\n\tpps->picture_header_extension_present_flag = gf_bs_read_int_log(bs, 1, \"pps_picture_header_extension_present_flag\");\n\tpps->slice_header_extension_present_flag = gf_bs_read_int_log(bs, 1, \"pps_slice_header_extension_present_flag\");\n\n\t//TODO\n\tif (gf_bs_read_int_log(bs, 1, \"pps_extension_flag\")) {\n\t\t//while ( more_rbsp_data()) bit(1);\n\t}\n\t//rbsp_trailing_bits()\n\n\tif (gf_bs_is_overflow(bs))\n\t\treturn -1;\n\treturn pps_id;\n}", "target": 2, "idx": 10715}
{"commit_id": "d68f0f778e7f4fbd674627274267f269e40f0b04", "project": "qemu", "func": "void ahci_uninit(AHCIState *s)\n{\n    int i, j;\n\n    for (i = 0; i < s->ports; i++) {\n        AHCIDevice *ad = &s->dev[i];\n\n        for (j = 0; j < 2; j++) {\n            IDEState *s = &ad->port.ifs[j];\n\n            ide_exit(s);\n        }\n    }\n\n    g_free(s->dev);\n}", "target": 1, "idx": 10716}
{"commit_id": "cf687ac66b60f14a71e2a7e552943f138922a71d", "project": "envoyproxy/envoy", "func": "void ConnectionManagerImpl::ActiveStream::decodeTrailers(RequestTrailerMapPtr&& trailers) {\n  ENVOY_STREAM_LOG(debug, \"request trailers complete:\\n{}\", *this, *trailers);\n  ScopeTrackerScopeState scope(this,\n                               connection_manager_.read_callbacks_->connection().dispatcher());\n  resetIdleTimer();\n\n  ASSERT(!request_trailers_);\n  request_trailers_ = std::move(trailers);\n  if (!validateTrailers()) {\n    ENVOY_STREAM_LOG(debug, \"request trailers validation failed:\\n{}\", *this, *request_trailers_);\n    return;\n  }\n  maybeEndDecode(true);\n  if (!state_.deferred_to_next_io_iteration_) {\n    filter_manager_.decodeTrailers(*request_trailers_);\n  }\n}", "target": 2, "idx": 10717}
{"commit_id": "d14b7acc3d972b4becb2b3a27a868935eaea36b1", "project": "nodejs/node", "func": "int nghttp2_session_on_rst_stream_received(nghttp2_session *session,\n                                           nghttp2_frame *frame) {\n  int rv;\n  nghttp2_stream *stream;\n  if (frame->hd.stream_id == 0) {\n    return session_handle_invalid_connection(session, frame, NGHTTP2_ERR_PROTO,\n                                             \"RST_STREAM: stream_id == 0\");\n  }\n\n  if (session_detect_idle_stream(session, frame->hd.stream_id)) {\n    return session_handle_invalid_connection(session, frame, NGHTTP2_ERR_PROTO,\n                                             \"RST_STREAM: stream in idle\");\n  }\n\n  stream = nghttp2_session_get_stream(session, frame->hd.stream_id);\n  if (stream) {\n    /* We may use stream->shut_flags for strict error checking. */\n    nghttp2_stream_shutdown(stream, NGHTTP2_SHUT_RD);\n  }\n\n  rv = session_call_on_frame_received(session, frame);\n  if (rv != 0) {\n    return rv;\n  }\n  rv = nghttp2_session_close_stream(session, frame->hd.stream_id,\n                                    frame->rst_stream.error_code);\n  if (nghttp2_is_fatal(rv)) {\n    return rv;\n  }\n\n  return session_update_stream_reset_ratelim(session);\n}", "target": 2, "idx": 10718}
{"commit_id": "c432131c3fdb2143e148e8ba88555f7f7a63b25e", "project": "ArtifexSoftware/ghostpdl", "func": "int\nx_catch_free_colors(Display * dpy, XErrorEvent * err)\n{\n    if (err->request_code == X_FreeColors ||\n        x_error_handler.orighandler == x_catch_free_colors)\n        return 0;\n    return x_error_handler.orighandler(dpy, err);\n}", "target": 2, "idx": 10719}
{"commit_id": "43ea0649d4b70fdcf3e9fa5c03aee1bbba0b04bb", "project": "chromium", "func": "void ImageDocumentParser::appendBytes(const char* data, size_t length)\n{\n    if (!length)\n        return;\n\n    LocalFrame* frame = document()->frame();\n    Settings* settings = frame->settings();\n    if (!frame->loader().client()->allowImage(!settings || settings->imagesEnabled(), document()->url()))\n        return;\n\n    if (document()->cachedImage()) {\n        RELEASE_ASSERT(length <= std::numeric_limits<unsigned>::max());\n        document()->cachedImage()->appendData(data, length);\n    }\n\n    if (!isDetached())\n        document()->imageUpdated();\n}", "target": 2, "idx": 10720}
{"commit_id": "55ea0a085290cd2c8cdfdd960a230cbc38ba8b56", "project": "OpenIDC/mod_auth_openidc", "func": "static int oidc_request_post_preserved_restore(request_rec *r,\n\t\tconst char *original_url) {\n\n\toidc_debug(r, \"enter: original_url=%s\", original_url);\n\n\tconst char *method = \"postOnLoad\";\n\tconst char *script =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\t\t\"      function str_decode(string) {\\n\"\n\t\t\t\t\t\"        try {\\n\"\n\t\t\t\t\t\"          result = decodeURIComponent(string);\\n\"\n\t\t\t\t\t\"        } catch (e) {\\n\"\n\t\t\t\t\t\"          result =  unescape(string);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        return result;\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"      function %s() {\\n\"\n\t\t\t\t\t\"        var mod_auth_openidc_preserve_post_params = JSON.parse(sessionStorage.getItem('mod_auth_openidc_preserve_post_params'));\\n\"\n\t\t\t\t\t\"\t\t sessionStorage.removeItem('mod_auth_openidc_preserve_post_params');\\n\"\n\t\t\t\t\t\"        for (var key in mod_auth_openidc_preserve_post_params) {\\n\"\n\t\t\t\t\t\"          var input = document.createElement(\\\"input\\\");\\n\"\n\t\t\t\t\t\"          input.name = str_decode(key);\\n\"\n\t\t\t\t\t\"          input.value = str_decode(mod_auth_openidc_preserve_post_params[key]);\\n\"\n\t\t\t\t\t\"          input.type = \\\"hidden\\\";\\n\"\n\t\t\t\t\t\"          document.forms[0].appendChild(input);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        document.forms[0].action = \\\"%s\\\";\\n\"\n\t\t\t\t\t\"        document.forms[0].submit();\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"    </script>\\n\", method, oidc_util_javascript_escape(r->pool, original_url));\n\n\tconst char *body = \"    <p>Restoring...</p>\\n\"\n\t\t\t\"    <form method=\\\"post\\\"></form>\\n\";\n\n\treturn oidc_util_html_send(r, \"Restoring...\", script, method, body,\n\t\t\tOK);\n}", "target": 0, "idx": 10721}
{"commit_id": "241d91112771a6104de10b3948c3f350d6690c1d", "project": "ArtifexSoftware/ghostpdl", "func": "int\ngs_main_finit(gs_main_instance * minst, int exit_status, int code)\n{\n    i_ctx_t *i_ctx_p = minst->i_ctx_p;\n    gs_dual_memory_t dmem = {0};\n    int exit_code;\n    ref error_object;\n    char *tempnames;\n\n    /* NB: need to free gs_name_table\n     */\n\n    /*\n     * Previous versions of this code closed the devices in the\n     * device list here.  Since these devices are now prototypes,\n     * they cannot be opened, so they do not need to be closed;\n     * alloc_restore_all will close dynamically allocated devices.\n     */\n    tempnames = gs_main_tempnames(minst);\n\n    /* by the time we get here, we *must* avoid any random redefinitions of\n     * operators etc, so we push systemdict onto the top of the dict stack.\n     * We do this in C to avoid running into any other re-defininitions in the\n     * Postscript world.\n     */\n    gs_finit_push_systemdict(i_ctx_p);\n\n    /* We have to disable BGPrint before we call interp_reclaim() to prevent the\n     * parent rendering thread initialising for the next page, whilst we are\n     * removing objects it may want to access - for example, the I/O device table.\n     * We also have to mess with the BeginPage/EndPage procs so that we don't\n     * trigger a spurious extra page to be emitted.\n     */\n    if (minst->init_done >= 2) {\n        gs_main_run_string(minst,\n            \"/BGPrint /GetDeviceParam .special_op \\\n            {{ <</BeginPage {pop} /EndPage {pop pop //false } \\\n              /BGPrint false /NumRenderingThreads 0>> setpagedevice} if} if \\\n              serverdict /.jobsavelevel get 0 eq {/quit} {/stop} ifelse \\\n              .systemvar exec\",\n            0 , &exit_code, &error_object);\n    }\n\n    /*\n     * Close the \"main\" device, because it may need to write out\n     * data before destruction. pdfwrite needs so.\n     */\n    if (minst->init_done >= 2) {\n        int code = 0;\n\n        if (idmemory->reclaim != 0) {\n            code = interp_reclaim(&minst->i_ctx_p, avm_global);\n\n            if (code < 0) {\n                ref error_name;\n                if (tempnames)\n                    free(tempnames);\n\n                if (gs_errorname(i_ctx_p, code, &error_name) >= 0) {\n                    char err_str[32] = {0};\n                    name_string_ref(imemory, &error_name, &error_name);\n                    memcpy(err_str, error_name.value.const_bytes, r_size(&error_name));\n                    emprintf2(imemory, \"ERROR: %s (%d) reclaiming the memory while the interpreter finalization.\\n\", err_str, code);\n                }\n                else {\n                    emprintf1(imemory, \"UNKNOWN ERROR %d reclaiming the memory while the interpreter finalization.\\n\", code);\n                }\n#ifdef MEMENTO_SQUEEZE_BUILD\n                if (code != gs_error_VMerror ) return gs_error_Fatal;\n#else\n                return gs_error_Fatal;\n#endif\n            }\n            i_ctx_p = minst->i_ctx_p; /* interp_reclaim could change it. */\n        }\n\n        if (i_ctx_p->pgs != NULL && i_ctx_p->pgs->device != NULL &&\n            gx_device_is_null(i_ctx_p->pgs->device)) {\n            /* if the job replaced the device with the nulldevice, we we need to grestore\n               away that device, so the block below can properly dispense\n               with the default device.\n             */\n            int code = gs_grestoreall(i_ctx_p->pgs);\n            if (code < 0) return_error(gs_error_Fatal);\n        }\n\n        if (i_ctx_p->pgs != NULL && i_ctx_p->pgs->device != NULL) {\n            gx_device *pdev = i_ctx_p->pgs->device;\n            const char * dname = pdev->dname;\n\n            /* make sure device doesn't isn't freed by .uninstalldevice */\n            rc_adjust(pdev, 1, \"gs_main_finit\");\n            /* deactivate the device just before we close it for the last time */\n            gs_main_run_string(minst,\n                /* we need to do the 'quit' so we don't loop for input (double quit) */\n                \".uninstallpagedevice serverdict \\\n                /.jobsavelevel get 0 eq {/quit} {/stop} ifelse .systemvar exec\",\n                0 , &exit_code, &error_object);\n            code = gs_closedevice(pdev);\n            if (code < 0) {\n                ref error_name;\n                if (gs_errorname(i_ctx_p, code, &error_name) >= 0) {\n                    char err_str[32] = {0};\n                    name_string_ref(imemory, &error_name, &error_name);\n                    memcpy(err_str, error_name.value.const_bytes, r_size(&error_name));\n                    emprintf3(imemory, \"ERROR: %s (%d) on closing %s device.\\n\", err_str, code, dname);\n                }\n                else {\n                    emprintf2(imemory, \"UNKNOWN ERROR %d closing %s device.\\n\", code, dname);\n               }\n            }\n            rc_decrement(pdev, \"gs_main_finit\");                /* device might be freed */\n            if (exit_status == 0 || exit_status == gs_error_Quit)\n                exit_status = code;\n        }\n\n      /* Flush stdout and stderr */\n      gs_main_run_string(minst,\n        \"(%stdout) (w) file closefile (%stderr) (w) file closefile \\\n        serverdict /.jobsavelevel get 0 eq {/quit} {/stop} ifelse .systemexec \\\n          systemdict /savedinitialgstate .forceundef\",\n        0 , &exit_code, &error_object);\n    }\n    gp_readline_finit(minst->readline_data);\n    i_ctx_p = minst->i_ctx_p;\t\t/* get current interp context */\n    if (gs_debug_c(':')) {\n        print_resource_usage(minst, &gs_imemory, \"Final\");\n        dmprintf1(minst->heap, \"%% Exiting instance 0x%p\\n\", minst);\n    }\n    /* Do the equivalent of a restore \"past the bottom\". */\n    /* This will release all memory, close all open files, etc. */\n    if (minst->init_done >= 1) {\n        gs_memory_t *mem_raw = i_ctx_p->memory.current->non_gc_memory;\n        i_plugin_holder *h = i_ctx_p->plugin_list;\n\n        dmem = *idmemory;\n        code = alloc_restore_all(i_ctx_p);\n        if (code < 0)\n            emprintf1(mem_raw,\n                      \"ERROR %d while the final restore. See gs/psi/ierrors.h for code explanation.\\n\",\n                      code);\n        i_iodev_finit(&dmem);\n        i_plugin_finit(mem_raw, h);\n    }\n\n    /* clean up redirected stdout */\n    if (minst->heap->gs_lib_ctx->fstdout2\n        && (minst->heap->gs_lib_ctx->fstdout2 != minst->heap->gs_lib_ctx->fstdout)\n        && (minst->heap->gs_lib_ctx->fstdout2 != minst->heap->gs_lib_ctx->fstderr)) {\n        fclose(minst->heap->gs_lib_ctx->fstdout2);\n        minst->heap->gs_lib_ctx->fstdout2 = (FILE *)NULL;\n    }\n\n    minst->heap->gs_lib_ctx->stdout_is_redirected = 0;\n    minst->heap->gs_lib_ctx->stdout_to_stderr = 0;\n    /* remove any temporary files, after ghostscript has closed files */\n    if (tempnames) {\n        char *p = tempnames;\n        while (*p) {\n            unlink(p);\n            p += strlen(p) + 1;\n        }\n        free(tempnames);\n    }\n    gs_lib_finit(exit_status, code, minst->heap);\n\n    gs_free_object(minst->heap, minst->lib_path.container.value.refs, \"lib_path array\");\n    ialloc_finit(&dmem);\n    return exit_status;\n}", "target": 1, "idx": 10722}
{"commit_id": "ff5e59f32255913bb1cdf51441b98c9107ae165b", "project": "xorg/lib/libICE", "func": "char *\nIceGenerateMagicCookie (\n\tint len\n)\n{\n    char    *auth;\n\n    if ((auth = malloc (len + 1)) == NULL)\n\treturn (NULL);\n\n    arc4random_buf (auth, len);\n\n    auth[len] = '\\0';\n    return (auth);\n}", "target": 1, "idx": 10723}
{"commit_id": "a2dff1b59ea8c8ec10680f9e8e5593e4b38554a1", "project": "sass/libsass", "func": "void retreat (octet_iterator& it, distance_type n, octet_iterator end)\n    {\n        for (distance_type i = 0; i < n; ++i)\n            utf8::prior(it, end);\n    }", "target": 1, "idx": 10724}
{"commit_id": "0499680a42141d86417a8fbaa8c8db806bea1201", "project": "torvalds/linux", "func": "static int proc_show_options(struct seq_file *seq, struct dentry *root)\n{\n\tstruct super_block *sb = root->d_sb;\n\tstruct pid_namespace *pid = sb->s_fs_info;\n\n\tif (pid->pid_gid)\n\t\tseq_printf(seq, \",gid=%lu\", (unsigned long)pid->pid_gid);\n\tif (pid->hide_pid != 0)\n\t\tseq_printf(seq, \",hidepid=%u\", pid->hide_pid);\n\n\treturn 0;\n}", "target": 1, "idx": 10725}
{"commit_id": "548701354191a3dda5cffc6d415374b35b01d0b9", "project": "ImageMagick", "func": "static Image *ReadPWPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  FILE\n    *file;\n\n  Image\n    *image,\n    *next_image,\n    *pwp_image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  register Image\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    filesize,\n    length;\n\n  ssize_t\n    count;\n\n  unsigned char\n    magick[MagickPathExtent];\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  pwp_image=AcquireImage(image_info,exception);\n  image=pwp_image;\n  status=OpenBlob(image_info,pwp_image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return((Image *) NULL);\n  count=ReadBlob(pwp_image,5,magick);\n  if ((count != 5) || (LocaleNCompare((char *) magick,\"SFW95\",5) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  read_info=CloneImageInfo(image_info);\n  (void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,\n    (void *) NULL);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  unique_file=AcquireUniqueFileResource(read_info->filename);\n  for ( ; ; )\n  {\n    for (c=ReadBlobByte(pwp_image); c != EOF; c=ReadBlobByte(pwp_image))\n    {\n      for (i=0; i < 17; i++)\n        magick[i]=magick[i+1];\n      magick[17]=(unsigned char) c;\n      if (LocaleNCompare((char *) (magick+12),\"SFW94A\",6) == 0)\n        break;\n    }\n    if (c == EOF)\n      break;\n    if (LocaleNCompare((char *) (magick+12),\"SFW94A\",6) != 0)\n      {\n        (void) RelinquishUniqueFileResource(read_info->filename);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    /*\n      Dump SFW image to a temporary file.\n    */\n    file=(FILE *) NULL;\n    if (unique_file != -1)\n      file=fdopen(unique_file,\"wb\");\n    if ((unique_file == -1) || (file == (FILE *) NULL))\n      {\n        (void) RelinquishUniqueFileResource(read_info->filename);\n        ThrowFileException(exception,FileOpenError,\"UnableToWriteFile\",\n          image->filename);\n        image=DestroyImageList(image);\n        return((Image *) NULL);\n      }\n    length=fwrite(\"SFW94A\",1,6,file);\n    (void) length;\n    filesize=65535UL*magick[2]+256L*magick[1]+magick[0];\n    for (i=0; i < (ssize_t) filesize; i++)\n    {\n      c=ReadBlobByte(pwp_image);\n      (void) fputc(c,file);\n    }\n    (void) fclose(file);\n    next_image=ReadImage(read_info,exception);\n    if (next_image == (Image *) NULL)\n      break;\n    (void) FormatLocaleString(next_image->filename,MagickPathExtent,\n      \"slide_%02ld.sfw\",(long) next_image->scene);\n    if (image == (Image *) NULL)\n      image=next_image;\n    else\n      {\n        /*\n          Link image into image list.\n        */\n        for (p=image; p->next != (Image *) NULL; p=GetNextImageInList(p)) ;\n        next_image->previous=p;\n        next_image->scene=p->scene+1;\n        p->next=next_image;\n      }\n    if (image_info->number_scenes != 0)\n      if (next_image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(pwp_image),\n      GetBlobSize(pwp_image));\n    if (status == MagickFalse)\n      break;\n  }\n  if (unique_file != -1)\n    (void) close(unique_file);\n  (void) RelinquishUniqueFileResource(read_info->filename);\n  read_info=DestroyImageInfo(read_info);\n  if (EOFBlob(image) != MagickFalse)\n    {\n      char\n        *message;\n\n      message=GetExceptionMessage(errno);\n      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n        \"UnexpectedEndOfFile\",\"`%s': %s\",image->filename,message);\n      message=DestroyString(message);\n    }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}", "target": 2, "idx": 10726}
{"commit_id": "4dc1a2d7931017d3625f2d7cff70a17ce58b53b4", "project": "libgd", "func": "static void gdCtxPrintf(gdIOCtx * out, const char *format, ...)\n{\n\tchar buf[1024];\n\tint len;\n\tva_list args;\n\n\tva_start(args, format);\n\tlen = vsnprintf(buf, sizeof(buf)-1, format, args);\n\tva_end(args);\n\tout->putBuf(out, buf, len);\n}", "target": 3, "idx": 10727}
{"commit_id": "8e20cf2bce122ce9262d6034ee5d5b76fbb92f96", "project": "torvalds/linux", "func": "static int\naiptek_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct usb_device *usbdev = interface_to_usbdev(intf);\n\tstruct usb_endpoint_descriptor *endpoint;\n\tstruct aiptek *aiptek;\n\tstruct input_dev *inputdev;\n\tint i;\n\tint speeds[] = { 0,\n\t\tAIPTEK_PROGRAMMABLE_DELAY_50,\n\t\tAIPTEK_PROGRAMMABLE_DELAY_400,\n\t\tAIPTEK_PROGRAMMABLE_DELAY_25,\n\t\tAIPTEK_PROGRAMMABLE_DELAY_100,\n\t\tAIPTEK_PROGRAMMABLE_DELAY_200,\n\t\tAIPTEK_PROGRAMMABLE_DELAY_300\n\t};\n\tint err = -ENOMEM;\n\n\t/* programmableDelay is where the command-line specified\n\t * delay is kept. We make it the first element of speeds[],\n\t * so therefore, your override speed is tried first, then the\n\t * remainder. Note that the default value of 400ms will be tried\n\t * if you do not specify any command line parameter.\n\t */\n\tspeeds[0] = programmableDelay;\n\n\taiptek = kzalloc(sizeof(struct aiptek), GFP_KERNEL);\n\tinputdev = input_allocate_device();\n\tif (!aiptek || !inputdev) {\n\t\tdev_warn(&intf->dev,\n\t\t\t \"cannot allocate memory or input device\\n\");\n\t\tgoto fail1;\n        }\n\n\taiptek->data = usb_alloc_coherent(usbdev, AIPTEK_PACKET_LENGTH,\n\t\t\t\t\t  GFP_ATOMIC, &aiptek->data_dma);\n        if (!aiptek->data) {\n\t\tdev_warn(&intf->dev, \"cannot allocate usb buffer\\n\");\n\t\tgoto fail1;\n\t}\n\n\taiptek->urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!aiptek->urb) {\n\t        dev_warn(&intf->dev, \"cannot allocate urb\\n\");\n\t\tgoto fail2;\n\t}\n\n\taiptek->inputdev = inputdev;\n\taiptek->usbdev = usbdev;\n\taiptek->intf = intf;\n\taiptek->ifnum = intf->altsetting[0].desc.bInterfaceNumber;\n\taiptek->inDelay = 0;\n\taiptek->endDelay = 0;\n\taiptek->previousJitterable = 0;\n\taiptek->lastMacro = -1;\n\n\t/* Set up the curSettings struct. Said struct contains the current\n\t * programmable parameters. The newSetting struct contains changes\n\t * the user makes to the settings via the sysfs interface. Those\n\t * changes are not \"committed\" to curSettings until the user\n\t * writes to the sysfs/.../execute file.\n\t */\n\taiptek->curSetting.pointerMode = AIPTEK_POINTER_EITHER_MODE;\n\taiptek->curSetting.coordinateMode = AIPTEK_COORDINATE_ABSOLUTE_MODE;\n\taiptek->curSetting.toolMode = AIPTEK_TOOL_BUTTON_PEN_MODE;\n\taiptek->curSetting.xTilt = AIPTEK_TILT_DISABLE;\n\taiptek->curSetting.yTilt = AIPTEK_TILT_DISABLE;\n\taiptek->curSetting.mouseButtonLeft = AIPTEK_MOUSE_LEFT_BUTTON;\n\taiptek->curSetting.mouseButtonMiddle = AIPTEK_MOUSE_MIDDLE_BUTTON;\n\taiptek->curSetting.mouseButtonRight = AIPTEK_MOUSE_RIGHT_BUTTON;\n\taiptek->curSetting.stylusButtonUpper = AIPTEK_STYLUS_UPPER_BUTTON;\n\taiptek->curSetting.stylusButtonLower = AIPTEK_STYLUS_LOWER_BUTTON;\n\taiptek->curSetting.jitterDelay = jitterDelay;\n\taiptek->curSetting.programmableDelay = programmableDelay;\n\n\t/* Both structs should have equivalent settings\n\t */\n\taiptek->newSetting = aiptek->curSetting;\n\n\t/* Determine the usb devices' physical path.\n\t * Asketh not why we always pretend we're using \"../input0\",\n\t * but I suspect this will have to be refactored one\n\t * day if a single USB device can be a keyboard & a mouse\n\t * & a tablet, and the inputX number actually will tell\n\t * us something...\n\t */\n\tusb_make_path(usbdev, aiptek->features.usbPath,\n\t\t\tsizeof(aiptek->features.usbPath));\n\tstrlcat(aiptek->features.usbPath, \"/input0\",\n\t\tsizeof(aiptek->features.usbPath));\n\n\t/* Set up client data, pointers to open and close routines\n\t * for the input device.\n\t */\n\tinputdev->name = \"Aiptek\";\n\tinputdev->phys = aiptek->features.usbPath;\n\tusb_to_input_id(usbdev, &inputdev->id);\n\tinputdev->dev.parent = &intf->dev;\n\n\tinput_set_drvdata(inputdev, aiptek);\n\n\tinputdev->open = aiptek_open;\n\tinputdev->close = aiptek_close;\n\n\t/* Now program the capacities of the tablet, in terms of being\n\t * an input device.\n\t */\n\tfor (i = 0; i < ARRAY_SIZE(eventTypes); ++i)\n\t        __set_bit(eventTypes[i], inputdev->evbit);\n\n\tfor (i = 0; i < ARRAY_SIZE(absEvents); ++i)\n\t        __set_bit(absEvents[i], inputdev->absbit);\n\n\tfor (i = 0; i < ARRAY_SIZE(relEvents); ++i)\n\t        __set_bit(relEvents[i], inputdev->relbit);\n\n\t__set_bit(MSC_SERIAL, inputdev->mscbit);\n\n\t/* Set up key and button codes */\n\tfor (i = 0; i < ARRAY_SIZE(buttonEvents); ++i)\n\t\t__set_bit(buttonEvents[i], inputdev->keybit);\n\n\tfor (i = 0; i < ARRAY_SIZE(macroKeyEvents); ++i)\n\t\t__set_bit(macroKeyEvents[i], inputdev->keybit);\n\n\t/*\n\t * Program the input device coordinate capacities. We do not yet\n\t * know what maximum X, Y, and Z values are, so we're putting fake\n\t * values in. Later, we'll ask the tablet to put in the correct\n\t * values.\n\t */\n\tinput_set_abs_params(inputdev, ABS_X, 0, 2999, 0, 0);\n\tinput_set_abs_params(inputdev, ABS_Y, 0, 2249, 0, 0);\n\tinput_set_abs_params(inputdev, ABS_PRESSURE, 0, 511, 0, 0);\n\tinput_set_abs_params(inputdev, ABS_TILT_X, AIPTEK_TILT_MIN, AIPTEK_TILT_MAX, 0, 0);\n\tinput_set_abs_params(inputdev, ABS_TILT_Y, AIPTEK_TILT_MIN, AIPTEK_TILT_MAX, 0, 0);\n\tinput_set_abs_params(inputdev, ABS_WHEEL, AIPTEK_WHEEL_MIN, AIPTEK_WHEEL_MAX - 1, 0, 0);\n\n\t/* Verify that a device really has an endpoint */\n\tif (intf->altsetting[0].desc.bNumEndpoints < 1) {\n\t\tdev_err(&intf->dev,\n\t\t\t\"interface has %d endpoints, but must have minimum 1\\n\",\n\t\t\tintf->altsetting[0].desc.bNumEndpoints);\n\t\terr = -EINVAL;\n\t\tgoto fail3;\n\t}\n\tendpoint = &intf->altsetting[0].endpoint[0].desc;\n\n\t/* Go set up our URB, which is called when the tablet receives\n\t * input.\n\t */\n\tusb_fill_int_urb(aiptek->urb,\n\t\t\t aiptek->usbdev,\n\t\t\t usb_rcvintpipe(aiptek->usbdev,\n\t\t\t\t\tendpoint->bEndpointAddress),\n\t\t\t aiptek->data, 8, aiptek_irq, aiptek,\n\t\t\t endpoint->bInterval);\n\n\taiptek->urb->transfer_dma = aiptek->data_dma;\n\taiptek->urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\t/* Program the tablet. This sets the tablet up in the mode\n\t * specified in newSetting, and also queries the tablet's\n\t * physical capacities.\n\t *\n\t * Sanity check: if a tablet doesn't like the slow programmatic\n\t * delay, we often get sizes of 0x0. Let's use that as an indicator\n\t * to try faster delays, up to 25 ms. If that logic fails, well, you'll\n\t * have to explain to us how your tablet thinks it's 0x0, and yet that's\n\t * not an error :-)\n\t */\n\n\tfor (i = 0; i < ARRAY_SIZE(speeds); ++i) {\n\t\taiptek->curSetting.programmableDelay = speeds[i];\n\t\t(void)aiptek_program_tablet(aiptek);\n\t\tif (input_abs_get_max(aiptek->inputdev, ABS_X) > 0) {\n\t\t\tdev_info(&intf->dev,\n\t\t\t\t \"Aiptek using %d ms programming speed\\n\",\n\t\t\t\t aiptek->curSetting.programmableDelay);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Murphy says that some day someone will have a tablet that fails the\n\t   above test. That's you, Frederic Rodrigo */\n\tif (i == ARRAY_SIZE(speeds)) {\n\t\tdev_info(&intf->dev,\n\t\t\t \"Aiptek tried all speeds, no sane response\\n\");\n\t\terr = -EINVAL;\n\t\tgoto fail3;\n\t}\n\n\t/* Associate this driver's struct with the usb interface.\n\t */\n\tusb_set_intfdata(intf, aiptek);\n\n\t/* Set up the sysfs files\n\t */\n\terr = sysfs_create_group(&intf->dev.kobj, &aiptek_attribute_group);\n\tif (err) {\n\t\tdev_warn(&intf->dev, \"cannot create sysfs group err: %d\\n\",\n\t\t\t err);\n\t\tgoto fail3;\n        }\n\n\t/* Register the tablet as an Input Device\n\t */\n\terr = input_register_device(aiptek->inputdev);\n\tif (err) {\n\t\tdev_warn(&intf->dev,\n\t\t\t \"input_register_device returned err: %d\\n\", err);\n\t\tgoto fail4;\n        }\n\treturn 0;\n\n fail4:\tsysfs_remove_group(&intf->dev.kobj, &aiptek_attribute_group);\n fail3: usb_free_urb(aiptek->urb);\n fail2:\tusb_free_coherent(usbdev, AIPTEK_PACKET_LENGTH, aiptek->data,\n\t\t\t  aiptek->data_dma);\n fail1: usb_set_intfdata(intf, NULL);\n\tinput_free_device(inputdev);\n\tkfree(aiptek);\n\treturn err;\n}", "target": 1, "idx": 10728}
{"commit_id": "0ff832d31470471803b175cfff4e40c1b08ee779", "project": "aawc/unrar", "func": "bool WideToCharMap(const wchar *Src,char *Dest,size_t DestSize,bool &Success)\n{\n  // String with inconvertible characters mapped to private use Unicode area\n  // must have the mark code somewhere.\n  if (wcschr(Src,(wchar)MappedStringMark)==NULL)\n    return false;\n\n  Success=true;\n  uint SrcPos=0,DestPos=0;\n  while (Src[SrcPos]!=0 && DestPos<DestSize-MB_CUR_MAX)\n  {\n    if (uint(Src[SrcPos])==MappedStringMark)\n    {\n      SrcPos++;\n      continue;\n    }\n    // For security reasons do not restore low ASCII codes, so mapping cannot\n    // be used to hide control codes like path separators.\n    if (uint(Src[SrcPos])>=MapAreaStart+0x80 && uint(Src[SrcPos])<MapAreaStart+0x100)\n      Dest[DestPos++]=char(uint(Src[SrcPos++])-MapAreaStart);\n    else\n    {\n      mbstate_t ps;\n      memset(&ps,0,sizeof(ps));\n      if (wcrtomb(Dest+DestPos,Src[SrcPos],&ps)==(size_t)-1)\n      {\n        Dest[DestPos]='_';\n        Success=false;\n      }\n      SrcPos++;\n      memset(&ps,0,sizeof(ps));\n      int Length=mbrlen(Dest+DestPos,MB_CUR_MAX,&ps);\n      DestPos+=Max(Length,1);\n    }\n  }\n  Dest[Min(DestPos,DestSize-1)]=0;\n  return true;\n}", "target": 2, "idx": 10729}
{"commit_id": "8b74d439e1697110c5e5c600643e823eb1dd0762", "project": "torvalds/linux", "func": "void llc_conn_handler(struct llc_sap *sap, struct sk_buff *skb)\n{\n\tstruct llc_addr saddr, daddr;\n\tstruct sock *sk;\n\n\tllc_pdu_decode_sa(skb, saddr.mac);\n\tllc_pdu_decode_ssap(skb, &saddr.lsap);\n\tllc_pdu_decode_da(skb, daddr.mac);\n\tllc_pdu_decode_dsap(skb, &daddr.lsap);\n\n\tsk = __llc_lookup(sap, &saddr, &daddr);\n\tif (!sk)\n\t\tgoto drop;\n\n\tbh_lock_sock(sk);\n\t/*\n\t * This has to be done here and not at the upper layer ->accept\n\t * method because of the way the PROCOM state machine works:\n\t * it needs to set several state variables (see, for instance,\n\t * llc_adm_actions_2 in net/llc/llc_c_st.c) and send a packet to\n\t * the originator of the new connection, and this state has to be\n\t * in the newly created struct sock private area. -acme\n\t */\n\tif (unlikely(sk->sk_state == TCP_LISTEN)) {\n\t\tstruct sock *newsk = llc_create_incoming_sock(sk, skb->dev,\n\t\t\t\t\t\t\t      &saddr, &daddr);\n\t\tif (!newsk)\n\t\t\tgoto drop_unlock;\n\t\tskb_set_owner_r(skb, newsk);\n\t} else {\n\t\t/*\n\t\t * Can't be skb_set_owner_r, this will be done at the\n\t\t * llc_conn_state_process function, later on, when we will use\n\t\t * skb_queue_rcv_skb to send it to upper layers, this is\n\t\t * another trick required to cope with how the PROCOM state\n\t\t * machine works. -acme\n\t\t */\n\t\tskb_orphan(skb);\n\t\tsock_hold(sk);\n\t\tskb->sk = sk;\n\t\tskb->destructor = sock_efree;\n\t}\n\tif (!sock_owned_by_user(sk))\n\t\tllc_conn_rcv(sk, skb);\n\telse {\n\t\tdprintk(\"%s: adding to backlog...\\n\", __func__);\n\t\tllc_set_backlog_type(skb, LLC_PACKET);\n\t\tif (sk_add_backlog(sk, skb, sk->sk_rcvbuf))\n\t\t\tgoto drop_unlock;\n\t}\nout:\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n\treturn;\ndrop:\n\tkfree_skb(skb);\n\treturn;\ndrop_unlock:\n\tkfree_skb(skb);\n\tgoto out;\n}", "target": 2, "idx": 10730}
{"commit_id": "efa61528aa500a1efbd2768121820742d3bb709b", "project": "htacg/tidy-html5", "func": "static void CleanNode( TidyDocImpl* doc, Node *node )\n{\n    Stack *stack = TY_(newStack)(doc, 16);\n    Node *child, *next;\n\n    if ( (child = node->content) )\n    {\n        while (child)\n        {\n            next = child->next;\n            \n            if (TY_(nodeIsElement)(child))\n            {\n                if (nodeIsSTYLE(child))\n                    TY_(DiscardElement)(doc, child);\n                if (nodeIsP(child) && !child->content)\n                    TY_(DiscardElement)(doc, child);\n                else if (nodeIsSPAN(child))\n                    DiscardContainer( doc, child, &next);\n                else if (nodeIsA(child) && !child->content)\n                 {\n                    AttVal *id = TY_(GetAttrByName)( child, \"name\" );\n                    /* Recent Google Docs is using \"id\" instead of \"name\" in\n                    ** the exported html.\n                    */\n                    if (!id)\n                        id = TY_(GetAttrByName)( child, \"id\" );\n\n                    if (id)\n                        TY_(RepairAttrValue)( doc, child->parent, \"id\", id->value );\n\n                    TY_(DiscardElement)(doc, child);\n                }\n                else\n                {\n                    if (child->attributes)\n                        TY_(DropAttrByName)( doc, child, \"class\" );\n\n                    TY_(push)(stack,next);\n                    child = child->content;\n                    continue;\n                }\n            }\n            child = next ? next : TY_(pop)(stack);\n        }\n        TY_(freeStack)(stack);\n    }\n}", "target": 3, "idx": 10731}
{"commit_id": "efa9ace68e487ddd29c2b4d6dd23242158f1f607", "project": "kernel/git/powerpc/linux", "func": "static struct property *dlpar_parse_cc_property(struct cc_workarea *ccwa)\n{\n\tstruct property *prop;\n\tchar *name;\n\tchar *value;\n\n\tprop = kzalloc(sizeof(*prop), GFP_KERNEL);\n\tif (!prop)\n\t\treturn NULL;\n\n\tname = (char *)ccwa + be32_to_cpu(ccwa->name_offset);\n\tprop->name = kstrdup(name, GFP_KERNEL);\n\tif (!prop->name) {\n\t\tdlpar_free_cc_property(prop);\n\t\treturn NULL;\n\t}\n\n\tprop->length = be32_to_cpu(ccwa->prop_length);\n\tvalue = (char *)ccwa + be32_to_cpu(ccwa->prop_offset);\n\tprop->value = kmemdup(value, prop->length, GFP_KERNEL);\n\tif (!prop->value) {\n\t\tdlpar_free_cc_property(prop);\n\t\treturn NULL;\n\t}\n\n\treturn prop;\n}", "target": 1, "idx": 10732}
{"commit_id": "2d88f470dea2671b430884260f3626b1fe99830a", "project": "tensorflow", "func": "inline bool ResolveAxis(const int num_dims, const int* axis,\n                        const int64_t num_axis, int* out_axis,\n                        int* out_num_axis) {\n  *out_num_axis = 0;  // Just in case.\n  // Short-circuit axis resolution for scalars; the axis will go unused.\n  if (num_dims == 0) {\n    return true;\n  }\n  // o(n^2) is fine since out_num_axis should be really small, mostly <= 4\n  for (int64_t idx = 0; idx < num_axis; ++idx) {\n    // Handle negative index. A positive index 'p_idx' can be represented as a\n    // negative index 'n_idx' as: n_idx = p_idx-num_dims\n    // eg: For num_dims=3, [0, 1, 2] is the same as [-3, -2, -1]  */\n    int current = axis[idx] < 0 ? (axis[idx] + num_dims) : axis[idx];\n    TFLITE_DCHECK(current >= 0 && current < num_dims);\n    if (current < 0 || current >= num_dims) {\n      return false;\n    }\n    bool is_dup = false;\n    for (int j = 0; j < *out_num_axis; ++j) {\n      if (out_axis[j] == current) {\n        is_dup = true;\n        break;\n      }\n    }\n    if (!is_dup) {\n      out_axis[*out_num_axis] = current;\n      *out_num_axis += 1;\n    }\n  }\n  return true;\n}", "target": 2, "idx": 10733}
{"commit_id": "23c9775fb6afb7be1472944e02396f29771dc8e2", "project": "wocommunity/wonder", "func": "int WebObjects_translate(request_rec *r) {\n   WebObjects_config *wc;\n   WOURLComponents url;\n   WOURLError urlerr;\n   WOURLError charcheck;\n\n   wc = (WebObjects_config *)ap_get_module_config(r->server->module_config, &WebObjects_module);\n\n   /* WOLog(WO_DBG,\"<WebObjects Apache Module> new translate: %s\",r->uri); */\n   if (strncmp(wc->WebObjects_alias, r->uri, strlen(wc->WebObjects_alias)) == 0) {\n      url = WOURLComponents_Initializer;\n\n#ifndef __PRESERVE_UNSAFE_URLS\n      // Make sure the URL does not contain forbidden characters (0x0D or 0x0A).\n      charcheck = WOValidateInitialURL( r->uri );\n      if ( charcheck != WOURLOK ) {\n         WOLog(WO_ERR, \"WebObjects_translate(): declining request due to forbidden URL characters\");\n         return DECLINED;\n      }\n#endif\n\n\n      urlerr = WOParseApplicationName(&url, r->uri);\n      if (urlerr != WOURLOK && !((urlerr == WOURLInvalidApplicationName) && ac_authorizeAppListing(&url))) {\n         /* WOLog(WO_DBG,\"<WebObjects Apache Module> translate - DECLINED: %s\",r->uri); */\n         return DECLINED;\n      }\n      if (!adaptorEnabled)\n      {\n         WOLog(WO_ERR, \"WebObjects_translate(): declining request due to initialization failure\");\n         return DECLINED;\n      }\n      /*\n       *\twe'll take it - mark our handler...\n       */\n      r->handler = (char *)ap_pstrdup(r->pool, WEBOBJECTS);\n      return OK;\n   }\n   /* WOLog(WO_DBG,\"<WebObjects Apache Module> translate - DECLINED: %s\",r->uri); */\n   return DECLINED;\n}", "target": 1, "idx": 10734}
{"commit_id": "7873f8334c8d31031f8cfa83bd97ac6029309e4f", "project": "sudo-project/sudo", "func": "int\ncmndlist_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct member_list *list, const char *runchroot,\n    struct cmnd_info *info)\n{\n    struct member *m;\n    int matched = UNSPEC;\n    debug_decl(cmndlist_matches, SUDOERS_DEBUG_MATCH);\n\n    TAILQ_FOREACH_REVERSE(m, list, member_list, entries) {\n\tmatched = cmnd_matches(parse_tree, m, runchroot, info);\n\tif (SPECIFIED(matched))\n\t    break;\n    }\n    debug_return_int(matched);\n}", "target": 2, "idx": 10735}
{"commit_id": "f44d04e696feaf13d192d942c4f14ad2e117065a", "project": "torvalds/linux", "func": "static ssize_t do_rbd_add(struct bus_type *bus,\n\t\t\t  const char *buf,\n\t\t\t  size_t count)\n{\n\tstruct rbd_device *rbd_dev = NULL;\n\tstruct ceph_options *ceph_opts = NULL;\n\tstruct rbd_options *rbd_opts = NULL;\n\tstruct rbd_spec *spec = NULL;\n\tstruct rbd_client *rbdc;\n\tint rc;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!try_module_get(THIS_MODULE))\n\t\treturn -ENODEV;\n\n\t/* parse add command */\n\trc = rbd_add_parse_args(buf, &ceph_opts, &rbd_opts, &spec);\n\tif (rc < 0)\n\t\tgoto out;\n\n\trbdc = rbd_get_client(ceph_opts);\n\tif (IS_ERR(rbdc)) {\n\t\trc = PTR_ERR(rbdc);\n\t\tgoto err_out_args;\n\t}\n\n\t/* pick the pool */\n\trc = ceph_pg_poolid_by_name(rbdc->client->osdc.osdmap, spec->pool_name);\n\tif (rc < 0) {\n\t\tif (rc == -ENOENT)\n\t\t\tpr_info(\"pool %s does not exist\\n\", spec->pool_name);\n\t\tgoto err_out_client;\n\t}\n\tspec->pool_id = (u64)rc;\n\n\trbd_dev = rbd_dev_create(rbdc, spec, rbd_opts);\n\tif (!rbd_dev) {\n\t\trc = -ENOMEM;\n\t\tgoto err_out_client;\n\t}\n\trbdc = NULL;\t\t/* rbd_dev now owns this */\n\tspec = NULL;\t\t/* rbd_dev now owns this */\n\trbd_opts = NULL;\t/* rbd_dev now owns this */\n\n\t/* if we are mapping a snapshot it will be a read-only mapping */\n\tif (rbd_dev->opts->read_only ||\n\t    strcmp(rbd_dev->spec->snap_name, RBD_SNAP_HEAD_NAME))\n\t\t__set_bit(RBD_DEV_FLAG_READONLY, &rbd_dev->flags);\n\n\trbd_dev->config_info = kstrdup(buf, GFP_KERNEL);\n\tif (!rbd_dev->config_info) {\n\t\trc = -ENOMEM;\n\t\tgoto err_out_rbd_dev;\n\t}\n\n\trc = rbd_dev_image_probe(rbd_dev, 0);\n\tif (rc < 0)\n\t\tgoto err_out_rbd_dev;\n\n\tif (rbd_dev->opts->alloc_size > rbd_dev->layout.object_size) {\n\t\trbd_warn(rbd_dev, \"alloc_size adjusted to %u\",\n\t\t\t rbd_dev->layout.object_size);\n\t\trbd_dev->opts->alloc_size = rbd_dev->layout.object_size;\n\t}\n\n\trc = rbd_dev_device_setup(rbd_dev);\n\tif (rc)\n\t\tgoto err_out_image_probe;\n\n\trc = rbd_add_acquire_lock(rbd_dev);\n\tif (rc)\n\t\tgoto err_out_image_lock;\n\n\t/* Everything's ready.  Announce the disk to the world. */\n\n\trc = device_add(&rbd_dev->dev);\n\tif (rc)\n\t\tgoto err_out_image_lock;\n\n\tdevice_add_disk(&rbd_dev->dev, rbd_dev->disk, NULL);\n\t/* see rbd_init_disk() */\n\tblk_put_queue(rbd_dev->disk->queue);\n\n\tspin_lock(&rbd_dev_list_lock);\n\tlist_add_tail(&rbd_dev->node, &rbd_dev_list);\n\tspin_unlock(&rbd_dev_list_lock);\n\n\tpr_info(\"%s: capacity %llu features 0x%llx\\n\", rbd_dev->disk->disk_name,\n\t\t(unsigned long long)get_capacity(rbd_dev->disk) << SECTOR_SHIFT,\n\t\trbd_dev->header.features);\n\trc = count;\nout:\n\tmodule_put(THIS_MODULE);\n\treturn rc;\n\nerr_out_image_lock:\n\trbd_dev_image_unlock(rbd_dev);\n\trbd_dev_device_release(rbd_dev);\nerr_out_image_probe:\n\trbd_dev_image_release(rbd_dev);\nerr_out_rbd_dev:\n\trbd_dev_destroy(rbd_dev);\nerr_out_client:\n\trbd_put_client(rbdc);\nerr_out_args:\n\trbd_spec_put(spec);\n\tkfree(rbd_opts);\n\tgoto out;\n}", "target": 1, "idx": 10736}
{"commit_id": "4deb051cb0277d32ab402da4f941f6e502518388", "project": "fluent/fluent-bit", "func": "void cb_metrics_prometheus(mk_request_t *request, void *data)\n{\n    int i;\n    int j;\n    int m;\n    int len;\n    int time_len;\n    int start_time_len;\n    size_t index;\n    size_t num_metrics = 0;\n    long now;\n    flb_sds_t sds;\n    flb_sds_t sds_metric;\n    flb_sds_t tmp_sds;\n    struct flb_sds *metric_helptxt_head;\n    flb_sds_t metric_helptxt;\n    size_t off = 0;\n    struct flb_hs_buf *buf;\n    msgpack_unpacked result;\n    msgpack_object map;\n    char tmp[32];\n    char time_str[64];\n    char start_time_str[64];\n    char* *metrics_arr;\n    struct timeval tp;\n    struct flb_hs *hs = data;\n    struct flb_config *config = hs->config;\n\n    buf = metrics_get_latest();\n    if (!buf) {\n        mk_http_status(request, 404);\n        mk_http_done(request);\n        return;\n    }\n\n    /* ref count */\n    buf->users++;\n\n    /* Compose outgoing buffer string */\n    sds = flb_sds_create_size(1024);\n    if (!sds) {\n        mk_http_status(request, 500);\n        mk_http_done(request);\n        buf->users--;\n        return;\n    }\n\n    /* length of HELP text */\n    metric_helptxt = flb_sds_create_size(128);\n    if (!metric_helptxt) {\n        flb_sds_destroy(sds);\n        mk_http_status(request, 500);\n        mk_http_done(request);\n        buf->users--;\n        return;\n    }\n    metric_helptxt_head = FLB_SDS_HEADER(metric_helptxt);\n\n    /* current time */\n    gettimeofday(&tp, NULL);\n    now = tp.tv_sec * 1000 + tp.tv_usec / 1000;\n    time_len = snprintf(time_str, sizeof(time_str) - 1, \"%lu\", now);\n    start_time_len = snprintf(start_time_str, sizeof(start_time_str) - 1, \"%lu\", config->init_time);\n\n    /*\n     * fluentbit_input_records[name=\"cpu0\", hostname=\"${HOSTNAME}\"] NUM TIMESTAMP\n     * fluentbit_input_bytes[name=\"cpu0\", hostname=\"${HOSTNAME}\"] NUM TIMESTAMP\n     */\n    index = 0;\n    msgpack_unpacked_init(&result);\n    msgpack_unpack_next(&result, buf->raw_data, buf->raw_size, &off);\n    map = result.data;\n\n    /* we need to know number of exposed metrics to reserve a memory */\n    for (i = 0; i < map.via.map.size; i++) {\n        msgpack_object v = map.via.map.ptr[i].val;\n        /* Iterate sub-map */\n        for (j = 0; j < v.via.map.size; j++) {\n            msgpack_object sv = v.via.map.ptr[j].val;\n            for (m = 0; m < sv.via.map.size; m++) {\n                num_metrics++;\n            }\n        }\n    }\n    metrics_arr = flb_malloc(num_metrics * sizeof(char*));\n    if (!metrics_arr) {\n        flb_errno();\n\n        mk_http_status(request, 500);\n        mk_http_done(request);\n        buf->users--;\n\n        flb_sds_destroy(sds);\n        flb_sds_destroy(metric_helptxt);\n        msgpack_unpacked_destroy(&result);\n        return;\n    }\n\n    for (i = 0; i < map.via.map.size; i++) {\n        msgpack_object k;\n        msgpack_object v;\n\n        /* Keys: input, output */\n        k = map.via.map.ptr[i].key;\n        v = map.via.map.ptr[i].val;\n\n        /* Iterate sub-map */\n        for (j = 0; j < v.via.map.size; j++) {\n            msgpack_object sk;\n            msgpack_object sv;\n\n            /* Keys: plugin name , values: metrics */\n            sk = v.via.map.ptr[j].key;\n            sv = v.via.map.ptr[j].val;\n\n            for (m = 0; m < sv.via.map.size; m++) {\n                msgpack_object mk;\n                msgpack_object mv;\n\n                mk = sv.via.map.ptr[m].key;\n                mv = sv.via.map.ptr[m].val;\n\n                /* Convert metric value to string */\n                len = snprintf(tmp, sizeof(tmp) - 1, \"%\" PRIu64 \" \", mv.via.u64);\n                if (len < 0) {\n                    goto error;\n                }\n\n                /* Allocate buffer */\n                sds_metric = flb_sds_create_size(k.via.str.size\n                                                 + mk.via.str.size\n                                                 + sk.via.str.size\n                                                 + len + time_len + 28);\n                if (sds_metric == NULL) {\n                    goto error;\n                }\n\n                sds_metric = flb_sds_cat(sds_metric, \"fluentbit_\", 10);\n                sds_metric = flb_sds_cat(sds_metric, k.via.str.ptr, k.via.str.size);\n                sds_metric = flb_sds_cat(sds_metric, \"_\", 1);\n                sds_metric = flb_sds_cat(sds_metric, mk.via.str.ptr, mk.via.str.size);\n                sds_metric = flb_sds_cat(sds_metric, \"_total{name=\\\"\", 13);\n                sds_metric = flb_sds_cat(sds_metric, sk.via.str.ptr, sk.via.str.size);\n                sds_metric = flb_sds_cat(sds_metric, \"\\\"} \", 3);\n                sds_metric = flb_sds_cat(sds_metric, tmp, len);\n                sds_metric = flb_sds_cat(sds_metric, time_str, time_len);\n                sds_metric = flb_sds_cat(sds_metric, \"\\n\", 1);\n                metrics_arr[index] = sds_metric;\n                index++;\n            }\n        }\n    }\n\n    /*  Sort metrics in alphabetic order, so we can group them later. */\n    qsort(metrics_arr, num_metrics, sizeof(char *), string_cmp);\n\n    /* When a new metric starts add HELP and TYPE annotation. */\n    tmp_sds = flb_sds_cat(sds, \"# HELP \", 7);\n    null_check(tmp_sds);\n    tmp_sds = flb_sds_cat(sds, metrics_arr[0], extract_metric_name_end_position(metrics_arr[0]));\n    null_check(tmp_sds);\n    if (!metrics_help_txt(metrics_arr[0], &metric_helptxt)) {\n        goto error;\n    }\n    tmp_sds = flb_sds_cat(sds, metric_helptxt, metric_helptxt_head->len);\n    null_check(tmp_sds);\n    tmp_sds = flb_sds_cat(sds, \"# TYPE \", 7);\n    null_check(tmp_sds);\n    tmp_sds = flb_sds_cat(sds, metrics_arr[0], extract_metric_name_end_position(metrics_arr[0]));\n    null_check(tmp_sds);\n    tmp_sds = flb_sds_cat(sds, \" counter\\n\", 9);\n    null_check(tmp_sds);\n\n    for (i = 0; i < num_metrics; i++) {\n        tmp_sds = flb_sds_cat(sds, metrics_arr[i], strlen(metrics_arr[i]));\n        null_check(tmp_sds);\n        if ((i != num_metrics - 1) && (is_same_metric(metrics_arr[i], metrics_arr[i+1]) == 0)) {\n            tmp_sds = flb_sds_cat(sds, \"# HELP \", 7);\n            null_check(tmp_sds);\n            tmp_sds = flb_sds_cat(sds, metrics_arr[i+1], extract_metric_name_end_position(metrics_arr[i+1]));\n            null_check(tmp_sds);\n            metric_helptxt_head->len = 0;\n            if (!metrics_help_txt(metrics_arr[i+1], &metric_helptxt)) {\n                goto error;\n            }\n            tmp_sds = flb_sds_cat(sds, metric_helptxt, metric_helptxt_head->len);\n            null_check(tmp_sds);\n            tmp_sds = flb_sds_cat(sds, \"# TYPE \", 7);\n            null_check(tmp_sds);\n            tmp_sds = flb_sds_cat(sds, metrics_arr[i+1], extract_metric_name_end_position(metrics_arr[i+1]));\n            null_check(tmp_sds);\n            tmp_sds = flb_sds_cat(sds, \" counter\\n\", 9);\n            null_check(tmp_sds);\n        }\n    }\n    /* Attach process_start_time_seconds metric. */\n    tmp_sds = flb_sds_cat(sds, \"# HELP process_start_time_seconds Start time of the process since unix epoch in seconds.\\n\", 89);\n    null_check(tmp_sds);\n    tmp_sds = flb_sds_cat(sds, \"# TYPE process_start_time_seconds gauge\\n\", 40);\n    null_check(tmp_sds);\n    tmp_sds = flb_sds_cat(sds, \"process_start_time_seconds \", 27);\n    null_check(tmp_sds);\n    tmp_sds = flb_sds_cat(sds, start_time_str, start_time_len);\n    null_check(tmp_sds);\n    tmp_sds = flb_sds_cat(sds, \"\\n\", 1);\n    null_check(tmp_sds);\n\n    /* Attach fluentbit_build_info metric. */\n    tmp_sds = flb_sds_cat(sds, \"# HELP fluentbit_build_info Build version information.\\n\", 55);\n    null_check(tmp_sds);\n    tmp_sds = flb_sds_cat(sds, \"# TYPE fluentbit_build_info gauge\\n\", 34);\n    null_check(tmp_sds);\n    tmp_sds = flb_sds_cat(sds, \"fluentbit_build_info{version=\\\"\", 30);\n    null_check(tmp_sds);\n    tmp_sds = flb_sds_cat(sds, FLB_VERSION_STR, sizeof(FLB_VERSION_STR) - 1);\n    null_check(tmp_sds);\n    tmp_sds = flb_sds_cat(sds, \"\\\",edition=\\\"\", 11);\n    null_check(tmp_sds);\n#ifdef FLB_ENTERPRISE\n    tmp_sds = flb_sds_cat(sds, \"Enterprise\\\"} 1\\n\", 15);\n    null_check(tmp_sds);\n#else\n    tmp_sds = flb_sds_cat(sds, \"Community\\\"} 1\\n\", 14);\n    null_check(tmp_sds);\n#endif\n\n    msgpack_unpacked_destroy(&result);\n    buf->users--;\n\n    mk_http_status(request, 200);\n    mk_http_header(request,\n                   \"Content-Type\", 12,\n                   PROMETHEUS_HEADER, sizeof(PROMETHEUS_HEADER) - 1);\n    mk_http_send(request, sds, flb_sds_len(sds), NULL);\n    for (i = 0; i < num_metrics; i++) {\n      flb_sds_destroy(metrics_arr[i]);\n    }\n    flb_free(metrics_arr);\n    flb_sds_destroy(sds);\n    flb_sds_destroy(metric_helptxt);\n\n    mk_http_done(request);\n    return;\n\nerror:\n    mk_http_status(request, 500);\n    mk_http_done(request);\n    buf->users--;\n\n    for (i = 0; i < index; i++) {\n      flb_sds_destroy(metrics_arr[i]);\n    }\n    flb_free(metrics_arr);\n    flb_sds_destroy(sds);\n    flb_sds_destroy(metric_helptxt);\n    msgpack_unpacked_destroy(&result);\n}", "target": 2, "idx": 10737}
{"commit_id": "8d385b247bca40ece40c9279391054bc98934325", "project": "xen-project/xen", "func": "static long evtchn_alloc_unbound(evtchn_alloc_unbound_t *alloc)\n{\n    struct evtchn *chn;\n    struct domain *d;\n    int            port;\n    domid_t        dom = alloc->dom;\n    long           rc;\n\n    d = rcu_lock_domain_by_any_id(dom);\n    if ( d == NULL )\n        return -ESRCH;\n\n    spin_lock(&d->event_lock);\n\n    if ( (port = get_free_port(d)) < 0 )\n        ERROR_EXIT_DOM(port, d);\n    chn = evtchn_from_port(d, port);\n\n    rc = xsm_evtchn_unbound(XSM_TARGET, d, chn, alloc->remote_dom);\n    if ( rc )\n        goto out;\n\n    spin_lock(&chn->lock);\n\n    chn->state = ECS_UNBOUND;\n    if ( (chn->u.unbound.remote_domid = alloc->remote_dom) == DOMID_SELF )\n        chn->u.unbound.remote_domid = current->domain->domain_id;\n    evtchn_port_init(d, chn);\n\n    spin_unlock(&chn->lock);\n\n    alloc->port = port;\n\n out:\n    check_free_port(d, port);\n    spin_unlock(&d->event_lock);\n    rcu_unlock_domain(d);\n\n    return rc;\n}", "target": 2, "idx": 10738}
{"commit_id": "4e7736d7ec7bf64026daa611da951993bb42fdaf", "project": "gpac", "func": "void SFS_ArrayDeref(ScriptParser *parser)\n{\n\tif (parser->codec->LastError) return;\n\tSFS_Expression(parser);\n\tif (parser->codec->LastError) return;\n\tSFS_AddString(parser, \"[\");\n\tSFS_CompoundExpression(parser);\n\tSFS_AddString(parser, \"]\");\n}", "target": 1, "idx": 10739}
{"commit_id": "ff8376ade4f668130385839cef586a0990f8ef87", "project": "torvalds/linux", "func": "static void rxrpc_destroy_s(struct key *key)\n{\n\tconst struct rxrpc_security *sec = key->payload.data[1];\n\n\tif (sec && sec->destroy_server_key)\n\t\tsec->destroy_server_key(key);\n}", "target": 2, "idx": 10740}
{"commit_id": "7558d03e6498e970b761aa44fff6b2c659202d95", "project": "android", "func": "int venc_dev::venc_output_log_buffers(const char *buffer_addr, int buffer_len)\n{\n    if (venc_handle->is_secure_session()) {\n        DEBUG_PRINT_ERROR(\"logging secure output buffers is not allowed!\");\n        return -1;\n    }\n\n    if (!m_debug.outfile) {\n        int size = 0;\n        if(m_sVenc_cfg.codectype == V4L2_PIX_FMT_MPEG4) {\n           size = snprintf(m_debug.outfile_name, PROPERTY_VALUE_MAX, \"%s/output_enc_%lu_%lu_%p.m4v\",\n                           m_debug.log_loc, m_sVenc_cfg.input_width, m_sVenc_cfg.input_height, this);\n        } else if(m_sVenc_cfg.codectype == V4L2_PIX_FMT_H264) {\n           size = snprintf(m_debug.outfile_name, PROPERTY_VALUE_MAX, \"%s/output_enc_%lu_%lu_%p.264\",\n                           m_debug.log_loc, m_sVenc_cfg.input_width, m_sVenc_cfg.input_height, this);\n        } else if(m_sVenc_cfg.codectype == V4L2_PIX_FMT_HEVC) {\n           size = snprintf(m_debug.outfile_name, PROPERTY_VALUE_MAX, \"%s/output_enc_%ld_%ld_%p.265\",\n                           m_debug.log_loc, m_sVenc_cfg.input_width, m_sVenc_cfg.input_height, this);\n        } else if(m_sVenc_cfg.codectype == V4L2_PIX_FMT_H263) {\n           size = snprintf(m_debug.outfile_name, PROPERTY_VALUE_MAX, \"%s/output_enc_%lu_%lu_%p.263\",\n                           m_debug.log_loc, m_sVenc_cfg.input_width, m_sVenc_cfg.input_height, this);\n        } else if(m_sVenc_cfg.codectype == V4L2_PIX_FMT_VP8) {\n           size = snprintf(m_debug.outfile_name, PROPERTY_VALUE_MAX, \"%s/output_enc_%lu_%lu_%p.ivf\",\n                           m_debug.log_loc, m_sVenc_cfg.input_width, m_sVenc_cfg.input_height, this);\n        }\n        if ((size > PROPERTY_VALUE_MAX) && (size < 0)) {\n             DEBUG_PRINT_ERROR(\"Failed to open output file: %s for logging size:%d\",\n                                m_debug.outfile_name, size);\n        }\n        m_debug.outfile = fopen(m_debug.outfile_name, \"ab\");\n        if (!m_debug.outfile) {\n            DEBUG_PRINT_ERROR(\"Failed to open output file: %s for logging errno:%d\",\n                               m_debug.outfile_name, errno);\n            m_debug.outfile_name[0] = '\\0';\n            return -1;\n        }\n    }\n    if (m_debug.outfile && buffer_len) {\n        DEBUG_PRINT_LOW(\"%s buffer_len:%d\", __func__, buffer_len);\n        fwrite(buffer_addr, buffer_len, 1, m_debug.outfile);\n    }\n    return 0;\n}", "target": 2, "idx": 10741}
{"commit_id": "0e388fce7aec40992eadee654193cad345d62663", "project": "torvalds/linux", "func": "static int io_poll_update(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct io_kiocb *preq;\n\tint ret2, ret = 0;\n\n\tio_ring_submit_lock(ctx, !(issue_flags & IO_URING_F_NONBLOCK));\n\n\tspin_lock(&ctx->completion_lock);\n\tpreq = io_poll_find(ctx, req->poll_update.old_user_data, true);\n\tif (!preq || !io_poll_disarm(preq)) {\n\t\tspin_unlock(&ctx->completion_lock);\n\t\tret = preq ? -EALREADY : -ENOENT;\n\t\tgoto out;\n\t}\n\tspin_unlock(&ctx->completion_lock);\n\n\tif (req->poll_update.update_events || req->poll_update.update_user_data) {\n\t\t/* only mask one event flags, keep behavior flags */\n\t\tif (req->poll_update.update_events) {\n\t\t\tpreq->poll.events &= ~0xffff;\n\t\t\tpreq->poll.events |= req->poll_update.events & 0xffff;\n\t\t\tpreq->poll.events |= IO_POLL_UNMASK;\n\t\t}\n\t\tif (req->poll_update.update_user_data)\n\t\t\tpreq->user_data = req->poll_update.new_user_data;\n\n\t\tret2 = io_poll_add(preq, issue_flags);\n\t\t/* successfully updated, don't complete poll request */\n\t\tif (!ret2)\n\t\t\tgoto out;\n\t}\n\treq_set_fail(preq);\n\tio_req_complete(preq, -ECANCELED);\nout:\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\t/* complete update request, we're done with it */\n\tio_req_complete(req, ret);\n\tio_ring_submit_unlock(ctx, !(issue_flags & IO_URING_F_NONBLOCK));\n\treturn 0;\n}", "target": 2, "idx": 10742}
{"commit_id": "166e87368ae88bf31112a30e078cceae637f4cdb", "project": "util-linux", "func": "int main(int argc, char *argv[])\n{\n\tstruct libmnt_table *tb = NULL;\n\tchar **tabfiles = NULL;\n\tint direction = MNT_ITER_FORWARD;\n\tint verify = 0;\n\tint c, rc = -1, timeout = -1;\n\tint ntabfiles = 0, tabtype = 0;\n\tchar *outarg = NULL;\n\tsize_t i;\n\tint force_tree = 0, istree = 0;\n\n\tstruct libscols_table *table = NULL;\n\n\tenum {\n\t\tFINDMNT_OPT_VERBOSE = CHAR_MAX + 1,\n\t\tFINDMNT_OPT_TREE,\n\t\tFINDMNT_OPT_OUTPUT_ALL,\n\t\tFINDMNT_OPT_PSEUDO,\n\t\tFINDMNT_OPT_REAL,\n\t\tFINDMNT_OPT_VFS_ALL,\n\t\tFINDMNT_OPT_SHADOWED\n\t};\n\n\tstatic const struct option longopts[] = {\n\t\t{ \"all\",\t    no_argument,       NULL, 'A'\t\t },\n\t\t{ \"ascii\",\t    no_argument,       NULL, 'a'\t\t },\n\t\t{ \"bytes\",\t    no_argument,       NULL, 'b'\t\t },\n\t\t{ \"canonicalize\",   no_argument,       NULL, 'c'\t\t },\n\t\t{ \"direction\",\t    required_argument, NULL, 'd'\t\t },\n\t\t{ \"df\",\t\t    no_argument,       NULL, 'D'\t\t },\n\t\t{ \"evaluate\",\t    no_argument,       NULL, 'e'\t\t },\n\t\t{ \"first-only\",\t    no_argument,       NULL, 'f'\t\t },\n\t\t{ \"fstab\",\t    no_argument,       NULL, 's'\t\t },\n\t\t{ \"help\",\t    no_argument,       NULL, 'h'\t\t },\n\t\t{ \"invert\",\t    no_argument,       NULL, 'i'\t\t },\n\t\t{ \"json\",\t    no_argument,       NULL, 'J'\t\t },\n\t\t{ \"kernel\",\t    no_argument,       NULL, 'k'\t\t },\n\t\t{ \"list\",\t    no_argument,       NULL, 'l'\t\t },\n\t\t{ \"mountpoint\",\t    required_argument, NULL, 'M'\t\t },\n\t\t{ \"mtab\",\t    no_argument,       NULL, 'm'\t\t },\n\t\t{ \"noheadings\",\t    no_argument,       NULL, 'n'\t\t },\n\t\t{ \"notruncate\",\t    no_argument,       NULL, 'u'\t\t },\n\t\t{ \"options\",\t    required_argument, NULL, 'O'\t\t },\n\t\t{ \"output\",\t    required_argument, NULL, 'o'\t\t },\n\t\t{ \"output-all\",\t    no_argument,       NULL, FINDMNT_OPT_OUTPUT_ALL },\n\t\t{ \"poll\",\t    optional_argument, NULL, 'p'\t\t },\n\t\t{ \"pairs\",\t    no_argument,       NULL, 'P'\t\t },\n\t\t{ \"raw\",\t    no_argument,       NULL, 'r'\t\t },\n\t\t{ \"types\",\t    required_argument, NULL, 't'\t\t },\n\t\t{ \"nocanonicalize\", no_argument,       NULL, 'C'\t\t },\n\t\t{ \"nofsroot\",\t    no_argument,       NULL, 'v'\t\t },\n\t\t{ \"submounts\",\t    no_argument,       NULL, 'R'\t\t },\n\t\t{ \"source\",\t    required_argument, NULL, 'S'\t\t },\n\t\t{ \"tab-file\",\t    required_argument, NULL, 'F'\t\t },\n\t\t{ \"task\",\t    required_argument, NULL, 'N'\t\t },\n\t\t{ \"target\",\t    required_argument, NULL, 'T'\t\t },\n\t\t{ \"timeout\",\t    required_argument, NULL, 'w'\t\t },\n\t\t{ \"uniq\",\t    no_argument,       NULL, 'U'\t\t },\n\t\t{ \"verify\",\t    no_argument,       NULL, 'x'\t\t },\n\t\t{ \"version\",\t    no_argument,       NULL, 'V'\t\t },\n\t\t{ \"verbose\",\t    no_argument,       NULL, FINDMNT_OPT_VERBOSE },\n\t\t{ \"tree\",\t    no_argument,       NULL, FINDMNT_OPT_TREE\t },\n\t\t{ \"real\",\t    no_argument,       NULL, FINDMNT_OPT_REAL\t },\n\t\t{ \"pseudo\",\t    no_argument,       NULL, FINDMNT_OPT_PSEUDO\t },\n\t\t{ \"vfs-all\",\t    no_argument,       NULL, FINDMNT_OPT_VFS_ALL },\n\t\t{ \"shadowed\",       no_argument,       NULL, FINDMNT_OPT_SHADOWED },\n\t\t{ NULL, 0, NULL, 0 }\n\t};\n\n\tstatic const ul_excl_t excl[] = {\t/* rows and cols in ASCII order */\n\t\t{ 'C', 'c'},\t\t\t/* [no]canonicalize */\n\t\t{ 'C', 'e' },\t\t\t/* nocanonicalize, evaluate */\n\t\t{ 'J', 'P', 'r','x' },\t\t/* json,pairs,raw,verify */\n\t\t{ 'M', 'T' },\t\t\t/* mountpoint, target */\n\t\t{ 'N','k','m','s' },\t\t/* task,kernel,mtab,fstab */\n\t\t{ 'P','l','r','x' },\t\t/* pairs,list,raw,verify */\n\t\t{ 'p','x' },\t\t\t/* poll,verify */\n\t\t{ 'm','p','s' },\t\t/* mtab,poll,fstab */\n\t\t{ FINDMNT_OPT_PSEUDO, FINDMNT_OPT_REAL },\n\t\t{ 0 }\n\t};\n\tint excl_st[ARRAY_SIZE(excl)] = UL_EXCL_STATUS_INIT;\n\n\tsetlocale(LC_ALL, \"\");\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\ttextdomain(PACKAGE);\n\tclose_stdout_atexit();\n\n\t/* default output format */\n\tflags |= FL_TREE;\n\n\twhile ((c = getopt_long(argc, argv,\n\t\t\t\t\"AabCcDd:ehiJfF:o:O:p::PklmM:nN:rst:uvRS:T:Uw:Vx\",\n\t\t\t\tlongopts, NULL)) != -1) {\n\n\t\terr_exclusive_options(c, longopts, excl, excl_st);\n\n\t\tswitch(c) {\n\t\tcase 'A':\n\t\t\tflags |= FL_ALL;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tflags |= FL_ASCII;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tflags |= FL_BYTES;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tflags |= FL_NOCACHE;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tflags |= FL_CANONICALIZE;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tflags &= ~FL_TREE;\n\t\t\tflags |= FL_DF;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tif (!strcmp(optarg, \"forward\"))\n\t\t\t\tdirection = MNT_ITER_FORWARD;\n\t\t\telse if (!strcmp(optarg, \"backward\"))\n\t\t\t\tdirection = MNT_ITER_BACKWARD;\n\t\t\telse\n\t\t\t\terrx(EXIT_FAILURE,\n\t\t\t\t\t_(\"unknown direction '%s'\"), optarg);\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tflags |= FL_EVALUATE;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tflags |= FL_INVERT;\n\t\t\tbreak;\n\t\tcase 'J':\n\t\t\tflags |= FL_JSON;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tflags |= FL_FIRSTONLY;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\ttabfiles = append_tabfile(tabfiles, &ntabfiles, optarg);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tdisable_columns_truncate();\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\toutarg = optarg;\n\t\t\tbreak;\n\t\tcase FINDMNT_OPT_OUTPUT_ALL:\n\t\t\tfor (ncolumns = 0; ncolumns < ARRAY_SIZE(infos); ncolumns++) {\n\t\t\t\tif (is_tabdiff_column(ncolumns))\n\t\t\t\t\tcontinue;\n\t\t\t\tcolumns[ncolumns] = ncolumns;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tset_match(COL_OPTIONS, optarg);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tif (optarg) {\n\t\t\t\tnactions = string_to_idarray(optarg,\n\t\t\t\t\t\tactions, ARRAY_SIZE(actions),\n\t\t\t\t\t\tpoll_action_name_to_id);\n\t\t\t\tif (nactions < 0)\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tflags |= FL_POLL;\n\t\t\tflags &= ~FL_TREE;\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tflags |= FL_EXPORT;\n\t\t\tflags &= ~FL_TREE;\n\t\t\tbreak;\n\t\tcase 'm':\t\t/* mtab */\n\t\t\ttabtype = TABTYPE_MTAB;\n\t\t\tflags &= ~FL_TREE;\n\t\t\tbreak;\n\t\tcase 's':\t\t/* fstab */\n\t\t\ttabtype = TABTYPE_FSTAB;\n\t\t\tflags &= ~FL_TREE;\n\t\t\tbreak;\n\t\tcase 'k':\t\t/* kernel (mountinfo) */\n\t\t\ttabtype = TABTYPE_KERNEL;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tset_match(COL_FSTYPE, optarg);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tflags &= ~FL_TREE;\t/* disable the default */\n\t\t\tflags |= FL_RAW;\t/* enable raw */\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tflags &= ~FL_TREE;\t/* disable the default */\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tflags |= FL_NOHEADINGS;\n\t\t\tbreak;\n\t\tcase 'N':\n\t\t\ttabtype = TABTYPE_KERNEL;\n\t\t\ttabfiles = append_pid_tabfile(tabfiles, &ntabfiles,\n\t\t\t\t\tstrtou32_or_err(optarg,\n\t\t\t\t\t\t_(\"invalid TID argument\")));\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tflags |= FL_NOFSROOT;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tflags |= FL_SUBMOUNTS;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tset_source_match(optarg);\n\t\t\tflags |= FL_NOSWAPMATCH;\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\tflags |= FL_STRICTTARGET;\n\t\t\t/* fallthrough */\n\t\tcase 'T':\n\t\t\tset_match(COL_TARGET, optarg);\n\t\t\tflags |= FL_NOSWAPMATCH;\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\tflags |= FL_UNIQ;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\ttimeout = strtos32_or_err(optarg, _(\"invalid timeout argument\"));\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\tverify = 1;\n\t\t\tbreak;\n\t\tcase FINDMNT_OPT_VERBOSE:\n\t\t\tflags |= FL_VERBOSE;\n\t\t\tbreak;\n\t\tcase FINDMNT_OPT_TREE:\n\t\t\tforce_tree = 1;\n\t\t\tbreak;\n\t\tcase FINDMNT_OPT_PSEUDO:\n\t\t\tflags |= FL_PSEUDO;\n\t\t\tbreak;\n\t\tcase FINDMNT_OPT_REAL:\n\t\t\tflags |= FL_REAL;\n\t\t\tbreak;\n\t\tcase FINDMNT_OPT_VFS_ALL:\n\t\t\tflags |= FL_VFS_ALL;\n\t\t\tbreak;\n\t\tcase FINDMNT_OPT_SHADOWED:\n\t\t\tflags |= FL_SHADOWED;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage();\n\t\tcase 'V':\n\t\t\tprint_version(EXIT_SUCCESS);\n\t\tdefault:\n\t\t\terrtryhelp(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tif (!ncolumns && (flags & FL_DF)) {\n\t\tadd_column(columns, ncolumns++, COL_SOURCE);\n\t\tadd_column(columns, ncolumns++, COL_FSTYPE);\n\t\tadd_column(columns, ncolumns++, COL_SIZE);\n\t\tadd_column(columns, ncolumns++, COL_USED);\n\t\tadd_column(columns, ncolumns++, COL_AVAIL);\n\t\tadd_column(columns, ncolumns++, COL_USEPERC);\n\t\tadd_column(columns, ncolumns++, COL_TARGET);\n\t}\n\n\t/* default columns */\n\tif (!ncolumns) {\n\t\tif (flags & FL_POLL)\n\t\t\tadd_column(columns, ncolumns++, COL_ACTION);\n\n\t\tadd_column(columns, ncolumns++, COL_TARGET);\n\t\tadd_column(columns, ncolumns++, COL_SOURCE);\n\t\tadd_column(columns, ncolumns++, COL_FSTYPE);\n\t\tadd_column(columns, ncolumns++, COL_OPTIONS);\n\t}\n\n\tif (outarg && string_add_to_idarray(outarg, columns, ARRAY_SIZE(columns),\n\t\t\t\t\t &ncolumns, column_name_to_id) < 0)\n\t\treturn EXIT_FAILURE;\n\n\tif (!tabtype)\n\t\ttabtype = verify ? TABTYPE_FSTAB : TABTYPE_KERNEL;\n\n\tif ((flags & FL_POLL) && ntabfiles > 1)\n\t\terrx(EXIT_FAILURE, _(\"--poll accepts only one file, but more specified by --tab-file\"));\n\n\tif (optind < argc && (get_match(COL_SOURCE) || get_match(COL_TARGET)))\n\t\terrx(EXIT_FAILURE, _(\n\t\t\t\"options --target and --source can't be used together \"\n\t\t\t\"with command line element that is not an option\"));\n\n\tif (optind < argc)\n\t\tset_source_match(argv[optind++]);\t/* dev/tag/mountpoint/maj:min */\n\tif (optind < argc)\n\t\tset_match(COL_TARGET, argv[optind++]);\t/* mountpoint */\n\n\tif ((flags & FL_SUBMOUNTS) && is_listall_mode())\n\t\t/* don't care about submounts if list all mounts */\n\t\tflags &= ~FL_SUBMOUNTS;\n\n\tif (!(flags & FL_SUBMOUNTS) && ((flags & FL_FIRSTONLY)\n\t    || get_match(COL_TARGET)\n\t    || get_match(COL_SOURCE)\n\t    || get_match(COL_MAJMIN)))\n\t\tflags &= ~FL_TREE;\n\n\tif (!(flags & FL_NOSWAPMATCH) &&\n\t    !get_match(COL_TARGET) && get_match(COL_SOURCE)) {\n\t\t/*\n\t\t * Check if we can swap source and target, it's\n\t\t * not possible if the source is LABEL=/UUID=\n\t\t */\n\t\tconst char *x = get_match(COL_SOURCE);\n\n\t\tif (!strncmp(x, \"LABEL=\", 6) || !strncmp(x, \"UUID=\", 5) ||\n\t\t    !strncmp(x, \"PARTLABEL=\", 10) || !strncmp(x, \"PARTUUID=\", 9))\n\t\t\tflags |= FL_NOSWAPMATCH;\n\t}\n\n\t/*\n\t * initialize libmount\n\t */\n\tmnt_init_debug(0);\n\n\ttb = parse_tabfiles(tabfiles, ntabfiles, tabtype);\n\tif (!tb)\n\t\tgoto leave;\n\n\tif (tabtype == TABTYPE_MTAB && tab_is_kernel(tb))\n\t\ttabtype = TABTYPE_KERNEL;\n\n\tistree = tab_is_tree(tb);\n\tif (istree && force_tree)\n\t\tflags |= FL_TREE;\n\n\tif ((flags & FL_TREE) && (ntabfiles > 1 || !istree))\n\t\tflags &= ~FL_TREE;\n\n\tif (!(flags & FL_NOCACHE)) {\n\t\tcache = mnt_new_cache();\n\t\tif (!cache) {\n\t\t\twarn(_(\"failed to initialize libmount cache\"));\n\t\t\tgoto leave;\n\t\t}\n\t\tmnt_table_set_cache(tb, cache);\n\n\t\tif (tabtype != TABTYPE_KERNEL)\n\t\t\tcache_set_targets(cache);\n\t}\n\n\tif (flags & FL_UNIQ)\n\t\tmnt_table_uniq_fs(tb, MNT_UNIQ_KEEPTREE, uniq_fs_target_cmp);\n\n\tif (verify) {\n\t\trc = verify_table(tb);\n\t\tgoto leave;\n\t}\n\n\t/*\n\t * initialize libsmartcols\n\t */\n\tscols_init_debug(0);\n\ttable = scols_new_table();\n\tif (!table) {\n\t\twarn(_(\"failed to allocate output table\"));\n\t\tgoto leave;\n\t}\n\tscols_table_enable_raw(table,        !!(flags & FL_RAW));\n\tscols_table_enable_export(table,     !!(flags & FL_EXPORT));\n\tscols_table_enable_json(table,       !!(flags & FL_JSON));\n\tscols_table_enable_ascii(table,      !!(flags & FL_ASCII));\n\tscols_table_enable_noheadings(table, !!(flags & FL_NOHEADINGS));\n\n\tif (flags & FL_JSON)\n\t\tscols_table_set_name(table, \"filesystems\");\n\n\tfor (i = 0; i < ncolumns; i++) {\n\t\tstruct libscols_column *cl;\n\t\tint fl = get_column_flags(i);\n\t\tint id = get_column_id(i);\n\n\t\tif (!(flags & FL_TREE))\n\t\t\tfl &= ~SCOLS_FL_TREE;\n\n\t\tif (!(flags & FL_POLL) && is_tabdiff_column(id)) {\n\t\t\twarnx(_(\"%s column is requested, but --poll \"\n\t\t\t       \"is not enabled\"), get_column_name(i));\n\t\t\tgoto leave;\n\t\t}\n\t\tcl = scols_table_new_column(table, get_column_name(i),\n\t\t\t\t\tget_column_whint(i), fl);\n\t\tif (!cl)\t{\n\t\t\twarn(_(\"failed to allocate output column\"));\n\t\t\tgoto leave;\n\t\t}\n\t\t/* multi-line cells (now used for SOURCES) */\n\t\tif (fl & SCOLS_FL_WRAP) {\n\t\t\tscols_column_set_wrapfunc(cl,\n\t\t\t\t\t\tscols_wrapnl_chunksize,\n\t\t\t\t\t\tscols_wrapnl_nextchunk,\n\t\t\t\t\t\tNULL);\n\t\t\tscols_column_set_safechars(cl, \"\\n\");\n\t\t}\n\t\tif (flags & FL_JSON) {\n\t\t\tswitch (id) {\n\t\t\tcase COL_SIZE:\n\t\t\tcase COL_AVAIL:\n\t\t\tcase COL_USED:\n\t\t\t\tif (!(flags & FL_BYTES))\n\t\t\t\t\tbreak;\n\t\t\t\t/* fallthrough */\n\t\t\tcase COL_ID:\n\t\t\tcase COL_PARENT:\n\t\t\tcase COL_FREQ:\n\t\t\tcase COL_PASSNO:\n\t\t\tcase COL_TID:\n\t\t\t\tscols_column_set_json_type(cl, SCOLS_JSON_NUMBER);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (fl & SCOLS_FL_WRAP)\n\t\t\t\t\tscols_column_set_json_type(cl, SCOLS_JSON_ARRAY_STRING);\n\t\t\t\telse\n\t\t\t\t\tscols_column_set_json_type(cl, SCOLS_JSON_STRING);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Fill in data to the output table\n\t */\n\tif (flags & FL_POLL) {\n\t\t/* poll mode (accept the first tabfile only) */\n\t\trc = poll_table(tb, tabfiles ? *tabfiles : _PATH_PROC_MOUNTINFO, timeout, table, direction);\n\n\t} else if ((flags & FL_TREE) && !(flags & FL_SUBMOUNTS)) {\n\t\t/* whole tree */\n\t\trc = create_treenode(table, tb, NULL, NULL);\n\t} else {\n\t\t/* whole list of sub-tree */\n\t\trc = add_matching_lines(tb, table, direction);\n\n\t\tif (rc != 0\n\t\t    && tabtype == TABTYPE_KERNEL\n\t\t    && (flags & FL_NOSWAPMATCH)\n\t\t    && !(flags & FL_STRICTTARGET)\n\t\t    && get_match(COL_TARGET)) {\n\t\t\t/*\n\t\t\t * Found nothing, maybe the --target is regular file,\n\t\t\t * try it again with extra functionality for target\n\t\t\t * match\n\t\t\t */\n\t\t\tenable_extra_target_match(tb);\n\t\t\trc = add_matching_lines(tb, table, direction);\n\t\t}\n\t}\n\n\t/*\n\t * Print the output table for non-poll modes\n\t */\n\tif (!rc && !(flags & FL_POLL))\n\t\tscols_print_table(table);\nleave:\n\tscols_unref_table(table);\n\n\tmnt_unref_table(tb);\n\tmnt_unref_cache(cache);\n\n\tfree(tabfiles);\n#ifdef HAVE_LIBUDEV\n\tudev_unref(udev);\n#endif\n\treturn rc ? EXIT_FAILURE : EXIT_SUCCESS;\n}", "target": 1, "idx": 10743}
{"commit_id": "3ddd9a35cebc28f2b1a5693c27dcfff58218674a", "project": "DanBloomberg/leptonica", "func": "SEL  *\nselReadStream(FILE  *fp)\n{\nchar     selname[256];\nchar     linebuf[256];\nl_int32  sy, sx, cy, cx, i, j, version, ignore;\nSEL     *sel;\n\n    PROCNAME(\"selReadStream\");\n\n    if (!fp)\n        return (SEL *)ERROR_PTR(\"stream not defined\", procName, NULL);\n\n    if (fscanf(fp, \"  Sel Version %d\\n\", &version) != 1)\n        return (SEL *)ERROR_PTR(\"not a sel file\", procName, NULL);\n    if (version != SEL_VERSION_NUMBER)\n        return (SEL *)ERROR_PTR(\"invalid sel version\", procName, NULL);\n\n    if (fgets(linebuf, sizeof(linebuf), fp) == NULL)\n        return (SEL *)ERROR_PTR(\"error reading into linebuf\", procName, NULL);\n    sscanf(linebuf, \"  ------  %200s  ------\", selname);\n\n    if (fscanf(fp, \"  sy = %d, sx = %d, cy = %d, cx = %d\\n\",\n            &sy, &sx, &cy, &cx) != 4) {\n        return (SEL *)ERROR_PTR(\"dimensions not read\", procName, NULL);\n    }\n\n    if ((sel = selCreate(sy, sx, selname)) == NULL) {\n        return (SEL *)ERROR_PTR(\"sel not made\", procName, NULL);\n    }\n    selSetOrigin(sel, cy, cx);\n\n    for (i = 0; i < sy; i++) {\n        ignore = fscanf(fp, \"    \");\n        for (j = 0; j < sx; j++)\n            ignore = fscanf(fp, \"%1d\", &sel->data[i][j]);\n        ignore = fscanf(fp, \"\\n\");\n    }\n    ignore = fscanf(fp, \"\\n\");\n\n    return sel;\n}", "target": 2, "idx": 10744}
{"commit_id": "246f65838d19db6db55bfb41117c35645a2c4789", "project": "qemu", "func": "static int64_t seek_to_sector(BlockDriverState *bs, int64_t sector_num)\n{\n    BDRVBochsState *s = bs->opaque;\n    uint64_t offset = sector_num * 512;\n    uint64_t extent_index, extent_offset, bitmap_offset;\n    char bitmap_entry;\n\n    // seek to sector\n    extent_index = offset / s->extent_size;\n    extent_offset = (offset % s->extent_size) / 512;\n\n    if (s->catalog_bitmap[extent_index] == 0xffffffff) {\n\treturn -1; /* not allocated */\n    }\n\n    bitmap_offset = s->data_offset + (512 * s->catalog_bitmap[extent_index] *\n\t(s->extent_blocks + s->bitmap_blocks));\n\n    /* read in bitmap for current extent */\n    if (bdrv_pread(bs->file, bitmap_offset + (extent_offset / 8),\n                   &bitmap_entry, 1) != 1) {\n        return -1;\n    }\n\n    if (!((bitmap_entry >> (extent_offset % 8)) & 1)) {\n\treturn -1; /* not allocated */\n    }\n\n    return bitmap_offset + (512 * (s->bitmap_blocks + extent_offset));\n}", "target": 1, "idx": 10745}
{"commit_id": "520778042ccca019f3ffa136dd0ca565c486cedd", "project": "kernel/git/netdev/net", "func": "static struct nft_expr *nft_expr_init(const struct nft_ctx *ctx,\n\t\t\t\t      const struct nlattr *nla)\n{\n\tstruct nft_expr_info expr_info;\n\tstruct nft_expr *expr;\n\tstruct module *owner;\n\tint err;\n\n\terr = nf_tables_expr_parse(ctx, nla, &expr_info);\n\tif (err < 0)\n\t\tgoto err_expr_parse;\n\n\terr = -EOPNOTSUPP;\n\tif (!(expr_info.ops->type->flags & NFT_EXPR_STATEFUL))\n\t\tgoto err_expr_stateful;\n\n\terr = -ENOMEM;\n\texpr = kzalloc(expr_info.ops->size, GFP_KERNEL_ACCOUNT);\n\tif (expr == NULL)\n\t\tgoto err_expr_stateful;\n\n\terr = nf_tables_newexpr(ctx, &expr_info, expr);\n\tif (err < 0)\n\t\tgoto err_expr_new;\n\n\treturn expr;\nerr_expr_new:\n\tkfree(expr);\nerr_expr_stateful:\n\towner = expr_info.ops->type->owner;\n\tif (expr_info.ops->type->release_ops)\n\t\texpr_info.ops->type->release_ops(expr_info.ops);\n\n\tmodule_put(owner);\nerr_expr_parse:\n\treturn ERR_PTR(err);\n}", "target": 2, "idx": 10746}
{"commit_id": "1137b5e2529a8f5ca8ee709288ecba3e68044df2", "project": "torvalds/linux", "func": "static int xfrm_dump_policy_done(struct netlink_callback *cb)\n{\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb->args;\n\tstruct net *net = sock_net(cb->skb->sk);\n\n\txfrm_policy_walk_done(walk, net);\n\treturn 0;\n}", "target": 2, "idx": 10747}
{"commit_id": "5d069dbe8aaf2a197142558b6fb2978189ba3454", "project": "torvalds/linux", "func": "static int fuse_unlink(struct inode *dir, struct dentry *entry)\n{\n\tint err;\n\tstruct fuse_mount *fm = get_fuse_mount(dir);\n\tFUSE_ARGS(args);\n\n\tif (fuse_is_bad(dir))\n\t\treturn -EIO;\n\n\targs.opcode = FUSE_UNLINK;\n\targs.nodeid = get_node_id(dir);\n\targs.in_numargs = 1;\n\targs.in_args[0].size = entry->d_name.len + 1;\n\targs.in_args[0].value = entry->d_name.name;\n\terr = fuse_simple_request(fm, &args);\n\tif (!err) {\n\t\tstruct inode *inode = d_inode(entry);\n\t\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\t\tspin_lock(&fi->lock);\n\t\tfi->attr_version = atomic64_inc_return(&fm->fc->attr_version);\n\t\t/*\n\t\t * If i_nlink == 0 then unlink doesn't make sense, yet this can\n\t\t * happen if userspace filesystem is careless.  It would be\n\t\t * difficult to enforce correct nlink usage so just ignore this\n\t\t * condition here\n\t\t */\n\t\tif (inode->i_nlink > 0)\n\t\t\tdrop_nlink(inode);\n\t\tspin_unlock(&fi->lock);\n\t\tfuse_invalidate_attr(inode);\n\t\tfuse_dir_changed(dir);\n\t\tfuse_invalidate_entry_cache(entry);\n\t\tfuse_update_ctime(inode);\n\t} else if (err == -EINTR)\n\t\tfuse_invalidate_entry(entry);\n\treturn err;\n}", "target": 1, "idx": 10748}
{"commit_id": "80ff197d03db2a70c6a111f97dcdacad1b0babfa", "project": "tensorflow", "func": "void DoCompute(const ComputeOptions& options, OpKernelContext* const context) {\n  ModelWeights model_weights;\n  OP_REQUIRES_OK(context, model_weights.Initialize(context));\n\n  Examples examples;\n  OP_REQUIRES_OK(\n      context,\n      examples.Initialize(context, model_weights, options.num_sparse_features,\n                          options.num_sparse_features_with_values,\n                          options.num_dense_features));\n\n  const Tensor* example_state_data_t;\n  OP_REQUIRES_OK(context,\n                 context->input(\"example_state_data\", &example_state_data_t));\n  OP_REQUIRES(\n      context, TensorShapeUtils::IsMatrix(example_state_data_t->shape()),\n      errors::InvalidArgument(\"example_state_data must be rank 2 but is rank \",\n                              example_state_data_t->dims()));\n  TensorShape expected_example_state_shape({examples.num_examples(), 4});\n  OP_REQUIRES(context,\n              example_state_data_t->shape() == expected_example_state_shape,\n              errors::InvalidArgument(\n                  \"Expected shape \", expected_example_state_shape.DebugString(),\n                  \" for example_state_data, got \",\n                  example_state_data_t->shape().DebugString()));\n\n  Tensor mutable_example_state_data_t(*example_state_data_t);\n  auto example_state_data = mutable_example_state_data_t.matrix<float>();\n  OP_REQUIRES_OK(context, context->set_output(\"out_example_state_data\",\n                                              mutable_example_state_data_t));\n\n  if (options.adaptive) {\n    OP_REQUIRES_OK(context,\n                   examples.SampleAdaptiveProbabilities(\n                       options.num_loss_partitions, options.regularizations,\n                       model_weights, example_state_data, options.loss_updater,\n                       /*num_weight_vectors =*/1));\n  } else {\n    examples.RandomShuffle();\n  }\n  struct {\n    mutex mu;\n    Status value TF_GUARDED_BY(mu);\n  } train_step_status;\n  std::atomic<std::int64_t> atomic_index(-1);\n  auto train_step = [&](const int64_t begin, const int64_t end) {\n    // The static_cast here is safe since begin and end can be at most\n    // num_examples which is an int.\n    for (int id = static_cast<int>(begin); id < end; ++id) {\n      const int64_t example_index = examples.sampled_index(++atomic_index);\n      const Example& example = examples.example(example_index);\n      const float dual = example_state_data(example_index, 0);\n      const float example_weight = example.example_weight();\n      float example_label = example.example_label();\n      const Status conversion_status =\n          options.loss_updater->ConvertLabel(&example_label);\n      if (!conversion_status.ok()) {\n        mutex_lock l(train_step_status.mu);\n        train_step_status.value = conversion_status;\n        // Return from this worker thread - the calling thread is\n        // responsible for checking context status and returning on error.\n        return;\n      }\n\n      // Compute wx, example norm weighted by regularization, dual loss,\n      // primal loss.\n      // For binary SDCA, num_weight_vectors should be one.\n      const ExampleStatistics example_statistics =\n          example.ComputeWxAndWeightedExampleNorm(\n              options.num_loss_partitions, model_weights,\n              options.regularizations, 1 /* num_weight_vectors */);\n\n      const double new_dual = options.loss_updater->ComputeUpdatedDual(\n          options.num_loss_partitions, example_label, example_weight, dual,\n          example_statistics.wx[0], example_statistics.normalized_squared_norm);\n\n      // Compute new weights.\n      const double normalized_bounded_dual_delta =\n          (new_dual - dual) * example_weight /\n          options.regularizations.symmetric_l2();\n      model_weights.UpdateDeltaWeights(\n          context->eigen_cpu_device(), example,\n          std::vector<double>{normalized_bounded_dual_delta});\n\n      // Update example data.\n      example_state_data(example_index, 0) = new_dual;\n      example_state_data(example_index, 1) =\n          options.loss_updater->ComputePrimalLoss(\n              example_statistics.prev_wx[0], example_label, example_weight);\n      example_state_data(example_index, 2) =\n          options.loss_updater->ComputeDualLoss(dual, example_label,\n                                                example_weight);\n      example_state_data(example_index, 3) = example_weight;\n    }\n  };\n  // TODO(sibyl-Aix6ihai): Tune this properly based on sparsity of the data,\n  // number of cpus, and cost per example.\n  const int64_t kCostPerUnit = examples.num_features();\n  const DeviceBase::CpuWorkerThreads& worker_threads =\n      *context->device()->tensorflow_cpu_worker_threads();\n\n  Shard(worker_threads.num_threads, worker_threads.workers,\n        examples.num_examples(), kCostPerUnit, train_step);\n  mutex_lock l(train_step_status.mu);\n  OP_REQUIRES_OK(context, train_step_status.value);\n}", "target": 1, "idx": 10749}
{"commit_id": "43c0b81a818640429317c80fea1e66771e85024b", "project": "vadz/libtiff", "func": "static int readSeparateStripsIntoBuffer (TIFF *in, uint8 *obuf, uint32 length, \n                                         uint32 width, uint16 spp,\n                                         struct dump_opts *dump)\n  {\n  int i, bytes_per_sample, bytes_per_pixel, shift_width, result = 1;\n  uint32 j;\n  int32  bytes_read = 0;\n  uint16 bps, planar;\n  uint32 nstrips;\n  uint32 strips_per_sample;\n  uint32 src_rowsize, dst_rowsize, rows_processed, rps;\n  uint32 rows_this_strip = 0;\n  tsample_t s;\n  tstrip_t  strip;\n  tsize_t scanlinesize = TIFFScanlineSize(in);\n  tsize_t stripsize    = TIFFStripSize(in);\n  unsigned char *srcbuffs[MAX_SAMPLES];\n  unsigned char *buff = NULL;\n  unsigned char *dst = NULL;\n\n  if (obuf == NULL)\n    {\n    TIFFError(\"readSeparateStripsIntoBuffer\",\"Invalid buffer argument\");\n    return (0);\n    }\n\n  memset (srcbuffs, '\\0', sizeof(srcbuffs));\n  TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bps);\n  TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &planar);\n  TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);\n  if (rps > length)\n    rps = length;\n\n  bytes_per_sample = (bps + 7) / 8; \n  bytes_per_pixel  = ((bps * spp) + 7) / 8;\n  if (bytes_per_pixel < (bytes_per_sample + 1))\n    shift_width = bytes_per_pixel;\n  else\n    shift_width = bytes_per_sample + 1;\n\n  src_rowsize = ((bps * width) + 7) / 8;\n  dst_rowsize = ((bps * width * spp) + 7) / 8;\n  dst = obuf;\n\n  if ((dump->infile != NULL) && (dump->level == 3))\n    {\n    dump_info  (dump->infile, dump->format, \"\", \n                \"Image width %d, length %d, Scanline size, %4d bytes\",\n                width, length,  scanlinesize);\n    dump_info  (dump->infile, dump->format, \"\", \n                \"Bits per sample %d, Samples per pixel %d, Shift width %d\",\n\t\tbps, spp, shift_width);\n    }\n\n  /* Libtiff seems to assume/require that data for separate planes are \n   * written one complete plane after another and not interleaved in any way.\n   * Multiple scanlines and possibly strips of the same plane must be \n   * written before data for any other plane.\n   */\n  nstrips = TIFFNumberOfStrips(in);\n  strips_per_sample = nstrips /spp;\n\n  for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n    {\n    srcbuffs[s] = NULL;\n    buff = _TIFFmalloc(stripsize);\n    if (!buff)\n      {\n      TIFFError (\"readSeparateStripsIntoBuffer\", \n                 \"Unable to allocate strip read buffer for sample %d\", s);\n      for (i = 0; i < s; i++)\n        _TIFFfree (srcbuffs[i]);\n      return 0;\n      }\n    srcbuffs[s] = buff;\n    }\n\n  rows_processed = 0;\n  for (j = 0; (j < strips_per_sample) && (result == 1); j++)\n    {\n    for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n      {\n      buff = srcbuffs[s];\n      strip = (s * strips_per_sample) + j; \n      bytes_read = TIFFReadEncodedStrip (in, strip, buff, stripsize);\n      rows_this_strip = bytes_read / src_rowsize;\n      if (bytes_read < 0 && !ignore)\n        {\n        TIFFError(TIFFFileName(in),\n\t          \"Error, can't read strip %lu for sample %d\",\n         \t   (unsigned long) strip, s + 1);\n        result = 0;\n        break;\n        }\n#ifdef DEVELMODE\n      TIFFError(\"\", \"Strip %2d, read %5d bytes for %4d scanlines, shift width %d\", \n\t\tstrip, bytes_read, rows_this_strip, shift_width);\n#endif\n      }\n\n    if (rps > rows_this_strip)\n      rps = rows_this_strip;\n    dst = obuf + (dst_rowsize * rows_processed);\n    if ((bps % 8) == 0)\n      {\n      if (combineSeparateSamplesBytes (srcbuffs, dst, width, rps,\n                                       spp, bps, dump->infile, \n                                       dump->format, dump->level))\n        {\n        result = 0;\n        break;\n\t}\n      }\n    else\n      {\n      switch (shift_width)\n        {\n        case 1: if (combineSeparateSamples8bits (srcbuffs, dst, width, rps,\n                                                 spp, bps, dump->infile,\n                                                 dump->format, dump->level))\n\t          {\n                  result = 0;\n                  break;\n      \t          }\n\t        break;\n        case 2: if (combineSeparateSamples16bits (srcbuffs, dst, width, rps,\n                                                  spp, bps, dump->infile,\n                                                  dump->format, dump->level))\n\t          {\n                  result = 0;\n                  break;\n\t\t  }\n\t        break;\n        case 3: if (combineSeparateSamples24bits (srcbuffs, dst, width, rps,\n                                                  spp, bps, dump->infile,\n                                                  dump->format, dump->level))\n\t          {\n                  result = 0;\n                  break;\n       \t          }\n                break;\n        case 4: \n        case 5:\n        case 6:\n        case 7:\n        case 8: if (combineSeparateSamples32bits (srcbuffs, dst, width, rps,\n                                                  spp, bps, dump->infile,\n                                                  dump->format, dump->level))\n\t          {\n                  result = 0;\n                  break;\n\t\t  }\n\t        break;\n        default: TIFFError (\"readSeparateStripsIntoBuffer\", \"Unsupported bit depth: %d\", bps);\n                  result = 0;\n                  break;\n        }\n      }\n \n    if ((rows_processed + rps) > length)\n      {\n      rows_processed = length;\n      rps = length - rows_processed;\n      }\n    else\n      rows_processed += rps;\n    }\n\n  /* free any buffers allocated for each plane or scanline and \n   * any temporary buffers \n   */\n  for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n    {\n    buff = srcbuffs[s];\n    if (buff != NULL)\n      _TIFFfree(buff);\n    }\n\n  return (result);\n  }", "target": 3, "idx": 10750}
{"commit_id": "3118eb64934499d93db3230748a452351d1d9a65", "project": "openssl", "func": "BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)\n/*\n * Returns 'ret' such that ret^2 == a (mod p), using the Tonelli/Shanks\n * algorithm (cf. Henri Cohen, \"A Course in Algebraic Computational Number\n * Theory\", algorithm 1.5.1). 'p' must be prime, otherwise an error or\n * an incorrect \"result\" will be returned.\n */\n{\n    BIGNUM *ret = in;\n    int err = 1;\n    int r;\n    BIGNUM *A, *b, *q, *t, *x, *y;\n    int e, i, j;\n\n    if (!BN_is_odd(p) || BN_abs_is_word(p, 1)) {\n        if (BN_abs_is_word(p, 2)) {\n            if (ret == NULL)\n                ret = BN_new();\n            if (ret == NULL)\n                goto end;\n            if (!BN_set_word(ret, BN_is_bit_set(a, 0))) {\n                if (ret != in)\n                    BN_free(ret);\n                return NULL;\n            }\n            bn_check_top(ret);\n            return ret;\n        }\n\n        BNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);\n        return NULL;\n    }\n\n    if (BN_is_zero(a) || BN_is_one(a)) {\n        if (ret == NULL)\n            ret = BN_new();\n        if (ret == NULL)\n            goto end;\n        if (!BN_set_word(ret, BN_is_one(a))) {\n            if (ret != in)\n                BN_free(ret);\n            return NULL;\n        }\n        bn_check_top(ret);\n        return ret;\n    }\n\n    BN_CTX_start(ctx);\n    A = BN_CTX_get(ctx);\n    b = BN_CTX_get(ctx);\n    q = BN_CTX_get(ctx);\n    t = BN_CTX_get(ctx);\n    x = BN_CTX_get(ctx);\n    y = BN_CTX_get(ctx);\n    if (y == NULL)\n        goto end;\n\n    if (ret == NULL)\n        ret = BN_new();\n    if (ret == NULL)\n        goto end;\n\n    /* A = a mod p */\n    if (!BN_nnmod(A, a, p, ctx))\n        goto end;\n\n    /* now write  |p| - 1  as  2^e*q  where  q  is odd */\n    e = 1;\n    while (!BN_is_bit_set(p, e))\n        e++;\n    /* we'll set  q  later (if needed) */\n\n    if (e == 1) {\n        /*-\n         * The easy case:  (|p|-1)/2  is odd, so 2 has an inverse\n         * modulo  (|p|-1)/2,  and square roots can be computed\n         * directly by modular exponentiation.\n         * We have\n         *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),\n         * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1.\n         */\n        if (!BN_rshift(q, p, 2))\n            goto end;\n        q->neg = 0;\n        if (!BN_add_word(q, 1))\n            goto end;\n        if (!BN_mod_exp(ret, A, q, p, ctx))\n            goto end;\n        err = 0;\n        goto vrfy;\n    }\n\n    if (e == 2) {\n        /*-\n         * |p| == 5  (mod 8)\n         *\n         * In this case  2  is always a non-square since\n         * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime.\n         * So if  a  really is a square, then  2*a  is a non-square.\n         * Thus for\n         *      b := (2*a)^((|p|-5)/8),\n         *      i := (2*a)*b^2\n         * we have\n         *     i^2 = (2*a)^((1 + (|p|-5)/4)*2)\n         *         = (2*a)^((p-1)/2)\n         *         = -1;\n         * so if we set\n         *      x := a*b*(i-1),\n         * then\n         *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1)\n         *         = a^2 * b^2 * (-2*i)\n         *         = a*(-i)*(2*a*b^2)\n         *         = a*(-i)*i\n         *         = a.\n         *\n         * (This is due to A.O.L. Atkin,\n         * Subject: Square Roots and Cognate Matters modulo p=8n+5.\n         * URL: https://listserv.nodak.edu/cgi-bin/wa.exe?A2=ind9211&L=NMBRTHRY&P=4026\n         * November 1992.)\n         */\n\n        /* t := 2*a */\n        if (!BN_mod_lshift1_quick(t, A, p))\n            goto end;\n\n        /* b := (2*a)^((|p|-5)/8) */\n        if (!BN_rshift(q, p, 3))\n            goto end;\n        q->neg = 0;\n        if (!BN_mod_exp(b, t, q, p, ctx))\n            goto end;\n\n        /* y := b^2 */\n        if (!BN_mod_sqr(y, b, p, ctx))\n            goto end;\n\n        /* t := (2*a)*b^2 - 1 */\n        if (!BN_mod_mul(t, t, y, p, ctx))\n            goto end;\n        if (!BN_sub_word(t, 1))\n            goto end;\n\n        /* x = a*b*t */\n        if (!BN_mod_mul(x, A, b, p, ctx))\n            goto end;\n        if (!BN_mod_mul(x, x, t, p, ctx))\n            goto end;\n\n        if (!BN_copy(ret, x))\n            goto end;\n        err = 0;\n        goto vrfy;\n    }\n\n    /*\n     * e > 2, so we really have to use the Tonelli/Shanks algorithm. First,\n     * find some y that is not a square.\n     */\n    if (!BN_copy(q, p))\n        goto end;               /* use 'q' as temp */\n    q->neg = 0;\n    i = 2;\n    do {\n        /*\n         * For efficiency, try small numbers first; if this fails, try random\n         * numbers.\n         */\n        if (i < 22) {\n            if (!BN_set_word(y, i))\n                goto end;\n        } else {\n            if (!BN_priv_rand(y, BN_num_bits(p), 0, 0))\n                goto end;\n            if (BN_ucmp(y, p) >= 0) {\n                if (!(p->neg ? BN_add : BN_sub) (y, y, p))\n                    goto end;\n            }\n            /* now 0 <= y < |p| */\n            if (BN_is_zero(y))\n                if (!BN_set_word(y, i))\n                    goto end;\n        }\n\n        r = BN_kronecker(y, q, ctx); /* here 'q' is |p| */\n        if (r < -1)\n            goto end;\n        if (r == 0) {\n            /* m divides p */\n            BNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);\n            goto end;\n        }\n    }\n    while (r == 1 && ++i < 82);\n\n    if (r != -1) {\n        /*\n         * Many rounds and still no non-square -- this is more likely a bug\n         * than just bad luck. Even if p is not prime, we should have found\n         * some y such that r == -1.\n         */\n        BNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS);\n        goto end;\n    }\n\n    /* Here's our actual 'q': */\n    if (!BN_rshift(q, q, e))\n        goto end;\n\n    /*\n     * Now that we have some non-square, we can find an element of order 2^e\n     * by computing its q'th power.\n     */\n    if (!BN_mod_exp(y, y, q, p, ctx))\n        goto end;\n    if (BN_is_one(y)) {\n        BNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);\n        goto end;\n    }\n\n    /*-\n     * Now we know that (if  p  is indeed prime) there is an integer\n     * k,  0 <= k < 2^e,  such that\n     *\n     *      a^q * y^k == 1   (mod p).\n     *\n     * As  a^q  is a square and  y  is not,  k  must be even.\n     * q+1  is even, too, so there is an element\n     *\n     *     X := a^((q+1)/2) * y^(k/2),\n     *\n     * and it satisfies\n     *\n     *     X^2 = a^q * a     * y^k\n     *         = a,\n     *\n     * so it is the square root that we are looking for.\n     */\n\n    /* t := (q-1)/2  (note that  q  is odd) */\n    if (!BN_rshift1(t, q))\n        goto end;\n\n    /* x := a^((q-1)/2) */\n    if (BN_is_zero(t)) {        /* special case: p = 2^e + 1 */\n        if (!BN_nnmod(t, A, p, ctx))\n            goto end;\n        if (BN_is_zero(t)) {\n            /* special case: a == 0  (mod p) */\n            BN_zero(ret);\n            err = 0;\n            goto end;\n        } else if (!BN_one(x))\n            goto end;\n    } else {\n        if (!BN_mod_exp(x, A, t, p, ctx))\n            goto end;\n        if (BN_is_zero(x)) {\n            /* special case: a == 0  (mod p) */\n            BN_zero(ret);\n            err = 0;\n            goto end;\n        }\n    }\n\n    /* b := a*x^2  (= a^q) */\n    if (!BN_mod_sqr(b, x, p, ctx))\n        goto end;\n    if (!BN_mod_mul(b, b, A, p, ctx))\n        goto end;\n\n    /* x := a*x    (= a^((q+1)/2)) */\n    if (!BN_mod_mul(x, x, A, p, ctx))\n        goto end;\n\n    while (1) {\n        /*-\n         * Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E\n         * where  E  refers to the original value of  e,  which we\n         * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2).\n         *\n         * We have  a*b = x^2,\n         *    y^2^(e-1) = -1,\n         *    b^2^(e-1) = 1.\n         */\n\n        if (BN_is_one(b)) {\n            if (!BN_copy(ret, x))\n                goto end;\n            err = 0;\n            goto vrfy;\n        }\n\n        /* Find the smallest i, 0 < i < e, such that b^(2^i) = 1. */\n        for (i = 1; i < e; i++) {\n            if (i == 1) {\n                if (!BN_mod_sqr(t, b, p, ctx))\n                    goto end;\n\n            } else {\n                if (!BN_mod_mul(t, t, t, p, ctx))\n                    goto end;\n            }\n            if (BN_is_one(t))\n                break;\n        }\n        /* If not found, a is not a square or p is not prime. */\n        if (i >= e) {\n            BNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE);\n            goto end;\n        }\n\n        /* t := y^2^(e - i - 1) */\n        if (!BN_copy(t, y))\n            goto end;\n        for (j = e - i - 1; j > 0; j--) {\n            if (!BN_mod_sqr(t, t, p, ctx))\n                goto end;\n        }\n        if (!BN_mod_mul(y, t, t, p, ctx))\n            goto end;\n        if (!BN_mod_mul(x, x, t, p, ctx))\n            goto end;\n        if (!BN_mod_mul(b, b, y, p, ctx))\n            goto end;\n        e = i;\n    }\n\n vrfy:\n    if (!err) {\n        /*\n         * verify the result -- the input might have been not a square (test\n         * added in 0.9.8)\n         */\n\n        if (!BN_mod_sqr(x, ret, p, ctx))\n            err = 1;\n\n        if (!err && 0 != BN_cmp(x, A)) {\n            BNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE);\n            err = 1;\n        }\n    }\n\n end:\n    if (err) {\n        if (ret != in)\n            BN_clear_free(ret);\n        ret = NULL;\n    }\n    BN_CTX_end(ctx);\n    bn_check_top(ret);\n    return ret;\n}", "target": 2, "idx": 10751}
{"commit_id": "ad6e43325da7d5f8048f23451bef26fdf4c0f93d", "project": "hyperhq/hyperstart", "func": "struct group *hyper_getgrnam(const char *name)\n{\n\tgid_t gid;\n\tFILE *file;\n\tstruct group *gr = NULL;\n\n\tgid = (gid_t)id_or_max(name);\n\tfile = fopen(\"/etc/group\", \"r\");\n\tif (!file) {\n\t\tperror(\"faile to open /etc/group\");\n\t\treturn NULL;\n\t}\n\tfor (;;) {\n\t\tgr = fgetgrent(file);\n\t\tif (!gr)\n\t\t\tbreak;\n\t\tif (gr->gr_gid == gid ||\n\t\t  (!strcmp(gr->gr_name, name) &&  (gid_t)INVALID_UGID == gid)) {\n\t\t\tfclose(file);\n\t\t\treturn gr;\n\t\t}\n\t}\n\tfclose(file);\n\treturn NULL;\n}", "target": 2, "idx": 10752}
{"commit_id": "2b0bbc4f8809c972bad134bc1a2570dbb01dea0b", "project": "qemu", "func": "static int nbd_negotiate_options(NBDClient *client)\n{\n    uint32_t flags;\n    bool fixedNewstyle = false;\n\n    /* Client sends:\n        [ 0 ..   3]   client flags\n\n        [ 0 ..   7]   NBD_OPTS_MAGIC\n        [ 8 ..  11]   NBD option\n        [12 ..  15]   Data length\n        ...           Rest of request\n\n        [ 0 ..   7]   NBD_OPTS_MAGIC\n        [ 8 ..  11]   Second NBD option\n        [12 ..  15]   Data length\n        ...           Rest of request\n    */\n\n    if (nbd_read(client->ioc, &flags, sizeof(flags), NULL) < 0) {\n        LOG(\"read failed\");\n        return -EIO;\n    }\n    TRACE(\"Checking client flags\");\n    be32_to_cpus(&flags);\n    if (flags & NBD_FLAG_C_FIXED_NEWSTYLE) {\n        TRACE(\"Client supports fixed newstyle handshake\");\n        fixedNewstyle = true;\n        flags &= ~NBD_FLAG_C_FIXED_NEWSTYLE;\n    }\n    if (flags & NBD_FLAG_C_NO_ZEROES) {\n        TRACE(\"Client supports no zeroes at handshake end\");\n        client->no_zeroes = true;\n        flags &= ~NBD_FLAG_C_NO_ZEROES;\n    }\n    if (flags != 0) {\n        TRACE(\"Unknown client flags 0x%\" PRIx32 \" received\", flags);\n        return -EIO;\n    }\n\n    while (1) {\n        int ret;\n        uint32_t clientflags, length;\n        uint64_t magic;\n\n        if (nbd_read(client->ioc, &magic, sizeof(magic), NULL) < 0) {\n            LOG(\"read failed\");\n            return -EINVAL;\n        }\n        TRACE(\"Checking opts magic\");\n        if (magic != be64_to_cpu(NBD_OPTS_MAGIC)) {\n            LOG(\"Bad magic received\");\n            return -EINVAL;\n        }\n\n        if (nbd_read(client->ioc, &clientflags,\n                      sizeof(clientflags), NULL) < 0)\n        {\n            LOG(\"read failed\");\n            return -EINVAL;\n        }\n        clientflags = be32_to_cpu(clientflags);\n\n        if (nbd_read(client->ioc, &length, sizeof(length), NULL) < 0) {\n            LOG(\"read failed\");\n            return -EINVAL;\n        }\n        length = be32_to_cpu(length);\n\n        TRACE(\"Checking option 0x%\" PRIx32, clientflags);\n        if (client->tlscreds &&\n            client->ioc == (QIOChannel *)client->sioc) {\n            QIOChannel *tioc;\n            if (!fixedNewstyle) {\n                TRACE(\"Unsupported option 0x%\" PRIx32, clientflags);\n                return -EINVAL;\n            }\n            switch (clientflags) {\n            case NBD_OPT_STARTTLS:\n                tioc = nbd_negotiate_handle_starttls(client, length);\n                if (!tioc) {\n                    return -EIO;\n                }\n                object_unref(OBJECT(client->ioc));\n                client->ioc = QIO_CHANNEL(tioc);\n                break;\n\n            case NBD_OPT_EXPORT_NAME:\n                /* No way to return an error to client, so drop connection */\n                TRACE(\"Option 0x%x not permitted before TLS\", clientflags);\n                return -EINVAL;\n\n            default:\n                if (nbd_drop(client->ioc, length, NULL) < 0) {\n                    return -EIO;\n                }\n                ret = nbd_negotiate_send_rep_err(client->ioc,\n                                                 NBD_REP_ERR_TLS_REQD,\n                                                 clientflags,\n                                                 \"Option 0x%\" PRIx32\n                                                 \"not permitted before TLS\",\n                                                 clientflags);\n                if (ret < 0) {\n                    return ret;\n                }\n                /* Let the client keep trying, unless they asked to quit */\n                if (clientflags == NBD_OPT_ABORT) {\n                    return -EINVAL;\n                }\n                break;\n            }\n        } else if (fixedNewstyle) {\n            switch (clientflags) {\n            case NBD_OPT_LIST:\n                ret = nbd_negotiate_handle_list(client, length);\n                if (ret < 0) {\n                    return ret;\n                }\n                break;\n\n            case NBD_OPT_ABORT:\n                /* NBD spec says we must try to reply before\n                 * disconnecting, but that we must also tolerate\n                 * guests that don't wait for our reply. */\n                nbd_negotiate_send_rep(client->ioc, NBD_REP_ACK, clientflags);\n                return -EINVAL;\n\n            case NBD_OPT_EXPORT_NAME:\n                return nbd_negotiate_handle_export_name(client, length);\n\n            case NBD_OPT_STARTTLS:\n                if (nbd_drop(client->ioc, length, NULL) < 0) {\n                    return -EIO;\n                }\n                if (client->tlscreds) {\n                    ret = nbd_negotiate_send_rep_err(client->ioc,\n                                                     NBD_REP_ERR_INVALID,\n                                                     clientflags,\n                                                     \"TLS already enabled\");\n                } else {\n                    ret = nbd_negotiate_send_rep_err(client->ioc,\n                                                     NBD_REP_ERR_POLICY,\n                                                     clientflags,\n                                                     \"TLS not configured\");\n                }\n                if (ret < 0) {\n                    return ret;\n                }\n                break;\n            default:\n                if (nbd_drop(client->ioc, length, NULL) < 0) {\n                    return -EIO;\n                }\n                ret = nbd_negotiate_send_rep_err(client->ioc,\n                                                 NBD_REP_ERR_UNSUP,\n                                                 clientflags,\n                                                 \"Unsupported option 0x%\"\n                                                 PRIx32,\n                                                 clientflags);\n                if (ret < 0) {\n                    return ret;\n                }\n                break;\n            }\n        } else {\n            /*\n             * If broken new-style we should drop the connection\n             * for anything except NBD_OPT_EXPORT_NAME\n             */\n            switch (clientflags) {\n            case NBD_OPT_EXPORT_NAME:\n                return nbd_negotiate_handle_export_name(client, length);\n\n            default:\n                TRACE(\"Unsupported option 0x%\" PRIx32, clientflags);\n                return -EINVAL;\n            }\n        }\n    }\n}", "target": 1, "idx": 10753}
{"commit_id": "e0485802ec72996c20026da320650d8362f555bd", "project": "plougher/squashfs-tools", "func": "static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset,\n\tstruct inode **i)\n{\n\tstruct squashfs_dir_header dirh;\n\tchar buffer[sizeof(struct squashfs_dir_entry) + SQUASHFS_NAME_LEN + 1]\n\t\t__attribute__((aligned));\n\tstruct squashfs_dir_entry *dire = (struct squashfs_dir_entry *) buffer;\n\tlong long start;\n\tint bytes = 0, dir_count, size, res;\n\tstruct dir_ent *ent, *cur_ent = NULL;\n\tstruct dir *dir;\n\n\tTRACE(\"squashfs_opendir: inode start block %d, offset %d\\n\",\n\t\tblock_start, offset);\n\n\t*i = read_inode(block_start, offset);\n\n\tdir = malloc(sizeof(struct dir));\n\tif(dir == NULL)\n\t\tMEM_ERROR();\n\n\tdir->dir_count = 0;\n\tdir->cur_entry = NULL;\n\tdir->mode = (*i)->mode;\n\tdir->uid = (*i)->uid;\n\tdir->guid = (*i)->gid;\n\tdir->mtime = (*i)->time;\n\tdir->xattr = (*i)->xattr;\n\tdir->dirs = NULL;\n\n\tif ((*i)->data == 3)\n\t\t/*\n\t\t * if the directory is empty, skip the unnecessary\n\t\t * lookup_entry, this fixes the corner case with\n\t\t * completely empty filesystems where lookup_entry correctly\n\t\t * returning -1 is incorrectly treated as an error\n\t\t */\n\t\treturn dir;\n\n\tstart = sBlk.s.directory_table_start + (*i)->start;\n\toffset = (*i)->offset;\n\tsize = (*i)->data + bytes - 3;\n\n\twhile(bytes < size) {\t\t\t\n\t\tres = read_directory_data(&dirh, &start, &offset, sizeof(dirh));\n\t\tif(res == FALSE)\n\t\t\tgoto corrupted;\n\n\t\tSQUASHFS_INSWAP_DIR_HEADER(&dirh);\n\t\n\t\tdir_count = dirh.count + 1;\n\t\tTRACE(\"squashfs_opendir: Read directory header @ byte position \"\n\t\t\t\"%d, %d directory entries\\n\", bytes, dir_count);\n\t\tbytes += sizeof(dirh);\n\n\t\t/* dir_count should never be larger than SQUASHFS_DIR_COUNT */\n\t\tif(dir_count > SQUASHFS_DIR_COUNT) {\n\t\t\tERROR(\"File system corrupted: too many entries in directory\\n\");\n\t\t\tgoto corrupted;\n\t\t}\n\n\t\twhile(dir_count--) {\n\t\t\tres = read_directory_data(dire, &start, &offset, sizeof(*dire));\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tSQUASHFS_INSWAP_DIR_ENTRY(dire);\n\n\t\t\tbytes += sizeof(*dire);\n\n\t\t\t/* size should never be SQUASHFS_NAME_LEN or larger */\n\t\t\tif(dire->size >= SQUASHFS_NAME_LEN) {\n\t\t\t\tERROR(\"File system corrupted: filename too long\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tres = read_directory_data(dire->name, &start, &offset,\n\t\t\t\t\t\t\t\tdire->size + 1);\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tdire->name[dire->size + 1] = '\\0';\n\n\t\t\t/* check name for invalid characters (i.e /, ., ..) */\n\t\t\tif(check_name(dire->name, dire->size + 1) == FALSE) {\n\t\t\t\tERROR(\"File system corrupted: invalid characters in name\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n\t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n\t\t\t\tdirh.start_block, dire->offset, dire->type);\n\n\t\t\tent = malloc(sizeof(struct dir_ent));\n\t\t\tif(ent == NULL)\n\t\t\t\tMEM_ERROR();\n\n\t\t\tent->name = strdup(dire->name);\n\t\t\tent->start_block = dirh.start_block;\n\t\t\tent->offset = dire->offset;\n\t\t\tent->type = dire->type;\n\t\t\tent->next = NULL;\n\t\t\tif(cur_ent == NULL)\n\t\t\t\tdir->dirs = ent;\n\t\t\telse\n\t\t\t\tcur_ent->next = ent;\n\t\t\tcur_ent = ent;\n\t\t\tdir->dir_count ++;\n\t\t\tbytes += dire->size + 1;\n\t\t}\n\t}\n\n\t/* check directory for duplicate names and sorting */\n\tif(check_directory(dir) == FALSE) {\n\t\tERROR(\"File system corrupted: directory has duplicate names or is unsorted\\n\");\n\t\tgoto corrupted;\n\t}\n\n\treturn dir;\n\ncorrupted:\n\tsquashfs_closedir(dir);\n\treturn NULL;\n}", "target": 2, "idx": 10754}
{"commit_id": "3bd7fa12e146c6051490d048a4acbfba974eeb04", "project": "vim", "func": "void\ntrunc_string(\n    char_u\t*s,\n    char_u\t*buf,\n    int\t\troom_in,\n    int\t\tbuflen)\n{\n    size_t\troom = room_in - 3; // \"...\" takes 3 chars\n    size_t\thalf;\n    size_t\tlen = 0;\n    int\t\te;\n    int\t\ti;\n    int\t\tn;\n\n    if (*s == NUL)\n    {\n\tif (buflen > 0)\n\t    *buf = NUL;\n\treturn;\n    }\n\n    if (room_in < 3)\n\troom = 0;\n    half = room / 2;\n\n    // First part: Start of the string.\n    for (e = 0; len < half && e < buflen; ++e)\n    {\n\tif (s[e] == NUL)\n\t{\n\t    // text fits without truncating!\n\t    buf[e] = NUL;\n\t    return;\n\t}\n\tn = ptr2cells(s + e);\n\tif (len + n > half)\n\t    break;\n\tlen += n;\n\tbuf[e] = s[e];\n\tif (has_mbyte)\n\t    for (n = (*mb_ptr2len)(s + e); --n > 0; )\n\t    {\n\t\tif (++e == buflen)\n\t\t    break;\n\t\tbuf[e] = s[e];\n\t    }\n    }\n\n    // Last part: End of the string.\n    i = e;\n    if (enc_dbcs != 0)\n    {\n\t// For DBCS going backwards in a string is slow, but\n\t// computing the cell width isn't too slow: go forward\n\t// until the rest fits.\n\tn = vim_strsize(s + i);\n\twhile (len + n > room)\n\t{\n\t    n -= ptr2cells(s + i);\n\t    i += (*mb_ptr2len)(s + i);\n\t}\n    }\n    else if (enc_utf8)\n    {\n\t// For UTF-8 we can go backwards easily.\n\thalf = i = (int)STRLEN(s);\n\tfor (;;)\n\t{\n\t    do\n\t\thalf = half - utf_head_off(s, s + half - 1) - 1;\n\t    while (half > 0 && utf_iscomposing(utf_ptr2char(s + half)));\n\t    n = ptr2cells(s + half);\n\t    if (len + n > room || half == 0)\n\t\tbreak;\n\t    len += n;\n\t    i = (int)half;\n\t}\n    }\n    else\n    {\n\tfor (i = (int)STRLEN(s);\n\t\t   i - 1 >= 0 && len + (n = ptr2cells(s + i - 1)) <= room; --i)\n\t    len += n;\n    }\n\n\n    if (i <= e + 3)\n    {\n\t// text fits without truncating\n\tif (s != buf)\n\t{\n\t    len = STRLEN(s);\n\t    if (len >= (size_t)buflen)\n\t\tlen = buflen - 1;\n\t    len = len - e + 1;\n\t    if (len < 1)\n\t\tbuf[e - 1] = NUL;\n\t    else\n\t\tmch_memmove(buf + e, s + e, len);\n\t}\n    }\n    else if (e + 3 < buflen)\n    {\n\t// set the middle and copy the last part\n\tmch_memmove(buf + e, \"...\", (size_t)3);\n\tlen = STRLEN(s + i) + 1;\n\tif (len >= (size_t)buflen - e - 3)\n\t    len = buflen - e - 3 - 1;\n\tmch_memmove(buf + e + 3, s + i, len);\n\tbuf[e + 3 + len - 1] = NUL;\n    }\n    else\n    {\n\t// can't fit in the \"...\", just truncate it\n\tbuf[buflen - 1] = NUL;\n    }\n}", "target": 1, "idx": 10755}
{"commit_id": "0523c79d6e63858c990821a990edcb82cf8af284", "project": "radareorg/radare2", "func": "static void parse_atomic_type(const RAnal *anal, const RBinDwarfDie *all_dies, \n\tconst ut64 count, ut64 idx) {\n\n\tr_return_if_fail (all_dies);\n\tconst RBinDwarfDie *die = &all_dies[idx];\n\n\tchar *name = NULL;\n\tut64 size = 0;\n\tsize_t i;\n\t// TODO support endiannity and encoding in future?\n\tfor (i = 0; i < die->count; i++) {\n\t\tRBinDwarfAttrValue *value = &die->attr_values[i];\n\t\tswitch (die->attr_values[i].attr_name) {\n\t\tcase DW_AT_name:\n\t\t\tif (!value->string.content) {\n\t\t\t\tname = create_type_name_from_offset (die->offset);\n\t\t\t} else {\n\t\t\t\tname = strdup (value->string.content);\n\t\t\t}\n\t\t\tif (!name) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DW_AT_byte_size:\n\t\t\tsize = value->data * CHAR_BIT;\n\t\t\tbreak;\n\t\tcase DW_AT_bit_size:\n\t\t\tsize = value->data;\n\t\t\tbreak;\n\t\tcase DW_AT_encoding:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!name) { // type has to have a name for now\n\t\treturn;\n\t}\n\tRAnalBaseType *base_type = r_anal_new_base_type (R_ANAL_BASE_TYPE_KIND_ATOMIC);\n\tif (!base_type) {\n\t\treturn;\n\t}\n\tbase_type->name = name;\n\tbase_type->size = size;\n\tr_anal_save_base_type (anal, base_type);\n\tr_anal_free_base_type (base_type);\n}", "target": 1, "idx": 10756}
{"commit_id": "ba1dbd78e5f1ed67c1b8d37ac89d90e5e330b628", "project": "curl", "func": "CURLcode Curl_smtp_escape_eob(struct connectdata *conn, const ssize_t nread)\n{\n  /* When sending a SMTP payload we must detect CRLF. sequences making sure\n     they are sent as CRLF.. instead, as a . on the beginning of a line will\n     be deleted by the server when not part of an EOB terminator and a\n     genuine CRLF.CRLF which isn't escaped will wrongly be detected as end of\n     data by the server\n  */\n  ssize_t i;\n  ssize_t si;\n  struct Curl_easy *data = conn->data;\n  struct SMTP *smtp = data->req.protop;\n  char *scratch = data->state.scratch;\n  char *newscratch = NULL;\n  char *oldscratch = NULL;\n  size_t eob_sent;\n\n  /* Do we need to allocate a scratch buffer? */\n  if(!scratch || data->set.crlf) {\n    oldscratch = scratch;\n\n    scratch = newscratch = malloc(2 * UPLOAD_BUFSIZE);\n    if(!newscratch) {\n      failf(data, \"Failed to alloc scratch buffer!\");\n\n      return CURLE_OUT_OF_MEMORY;\n    }\n  }\n  DEBUGASSERT(UPLOAD_BUFSIZE >= nread);\n\n  /* Have we already sent part of the EOB? */\n  eob_sent = smtp->eob;\n\n  /* This loop can be improved by some kind of Boyer-Moore style of\n     approach but that is saved for later... */\n  for(i = 0, si = 0; i < nread; i++) {\n    if(SMTP_EOB[smtp->eob] == data->req.upload_fromhere[i]) {\n      smtp->eob++;\n\n      /* Is the EOB potentially the terminating CRLF? */\n      if(2 == smtp->eob || SMTP_EOB_LEN == smtp->eob)\n        smtp->trailing_crlf = TRUE;\n      else\n        smtp->trailing_crlf = FALSE;\n    }\n    else if(smtp->eob) {\n      /* A previous substring matched so output that first */\n      memcpy(&scratch[si], &SMTP_EOB[eob_sent], smtp->eob - eob_sent);\n      si += smtp->eob - eob_sent;\n\n      /* Then compare the first byte */\n      if(SMTP_EOB[0] == data->req.upload_fromhere[i])\n        smtp->eob = 1;\n      else\n        smtp->eob = 0;\n\n      eob_sent = 0;\n\n      /* Reset the trailing CRLF flag as there was more data */\n      smtp->trailing_crlf = FALSE;\n    }\n\n    /* Do we have a match for CRLF. as per RFC-5321, sect. 4.5.2 */\n    if(SMTP_EOB_FIND_LEN == smtp->eob) {\n      /* Copy the replacement data to the target buffer */\n      memcpy(&scratch[si], &SMTP_EOB_REPL[eob_sent],\n             SMTP_EOB_REPL_LEN - eob_sent);\n      si += SMTP_EOB_REPL_LEN - eob_sent;\n      smtp->eob = 0;\n      eob_sent = 0;\n    }\n    else if(!smtp->eob)\n      scratch[si++] = data->req.upload_fromhere[i];\n  }\n\n  if(smtp->eob - eob_sent) {\n    /* A substring matched before processing ended so output that now */\n    memcpy(&scratch[si], &SMTP_EOB[eob_sent], smtp->eob - eob_sent);\n    si += smtp->eob - eob_sent;\n  }\n\n  /* Only use the new buffer if we replaced something */\n  if(si != nread) {\n    /* Upload from the new (replaced) buffer instead */\n    data->req.upload_fromhere = scratch;\n\n    /* Save the buffer so it can be freed later */\n    data->state.scratch = scratch;\n\n    /* Free the old scratch buffer */\n    free(oldscratch);\n\n    /* Set the new amount too */\n    data->req.upload_present = si;\n  }\n  else\n    free(newscratch);\n\n  return CURLE_OK;\n}", "target": 3, "idx": 10757}
{"commit_id": "8ad0c5b3683a17d9e2e16bbf25869140fd5c1c66", "project": "wireshark", "func": "static guint\nget_chancount(tvbuff_t *tvb)\n{\n    guint         offset;\n    guint8        tlv_type;\n    guint16       tlv_len;\n    tlv_len_len_e tlv_len_len;\n    guint         chancount = THREAD_MC_INVALID_CHAN_COUNT;\n\n    offset = 0;\n\n    /* Thread Network Data TLVs */\n    while (tvb_offset_exists(tvb, offset)) {\n\n        /* Get the type and length ahead of time to pass to next function so we can highlight\n           proper amount of bytes */\n        tlv_type = tvb_get_guint8(tvb, offset);\n        tlv_len = (guint16)tvb_get_guint8(tvb, offset + 1);\n\n        /* TODO: need to make sure this applies to all MeshCoP TLVs */\n        if (THREAD_TLV_LENGTH_ESC == tlv_len) {\n            /* 16-bit length field */\n            tlv_len = tvb_get_ntohs(tvb, offset + 2);\n            tlv_len_len = TLV_LEN_LEN16;\n        } else {\n            tlv_len_len = TLV_LEN_LEN8;\n        }\n\n        /* Skip over Type and Length */\n        offset += 1 + tlv_len_len;\n\n        switch(tlv_type) {\n\n            case THREAD_MC_TLV_CHANNEL_MASK:\n                {\n                    int i, j;\n                    guint8 entries = 0;\n                    gint32 check_len = tlv_len;\n                    gint check_offset = offset + 1; /* Channel page first */\n                    guint16 masklen;\n\n                    /* Check consistency of entries */\n                    while (check_len > 0) {\n\n                        masklen = tvb_get_guint8(tvb, check_offset);\n                        if (masklen == 0) {\n                            break; /* Get out or we might spin forever */\n                        }\n                        masklen += 2; /* Add in page and length */\n                        check_offset += masklen;\n                        check_len -= masklen;\n                        entries++;\n                    }\n\n                    if (check_len != 0) {\n                        /* Not an integer number of entries */\n                        /* offset += tlv_len; */\n                        return chancount;\n                    } else {\n                        chancount = 0;\n                        for (i = 0; i < entries; i++) {\n                            /* Skip over channel page */\n                            offset++;\n                            masklen = tvb_get_guint8(tvb, offset);\n                            offset++;\n                            /* Count the number of channels in the channel mask */\n                            for (j = 0; j < masklen; j++) {\n                                chancount += count_bits_in_byte(tvb_get_guint8(tvb, offset));\n                                offset++;\n                            }\n                        }\n                    }\n                }\n                break;\n\n            default:\n                /* Skip over any other TLVs */\n                offset += tlv_len;\n        }\n    }\n    return chancount;\n}", "target": 2, "idx": 10758}
{"commit_id": "0a9f9a7410681e55362f8311537ebc7be9ad0fbe", "project": "barebox", "func": "int digest_generic_verify(struct digest *d, const unsigned char *md)\n{\n\tint ret;\n\tint len = digest_length(d);\n\tunsigned char *tmp;\n\n\ttmp = xmalloc(len);\n\n\tret = digest_final(d, tmp);\n\tif (ret)\n\t\tgoto end;\n\n\tif (crypto_memneq(md, tmp, len))\n\t\tret = -EINVAL;\n\telse\n\t\tret = 0;\nend:\n\tfree(tmp);\n\treturn ret;\n}", "target": 2, "idx": 10759}
{"commit_id": "634ce8e8a5accc0fa05dd2c20d42b4749d4b2735", "project": "jasper-software/jasper", "func": "int jas_stream_write(jas_stream_t *stream, const void *buf, int cnt)\n{\n\tint n;\n\tconst char *bufptr;\n\n\tif (cnt < 0) {\n\t\tjas_deprecated(\"negative count for jas_stream_write\");\n\t}\n\n\tbufptr = buf;\n\n\tn = 0;\n\twhile (n < cnt) {\n\t\tif (jas_stream_putc(stream, *bufptr) == EOF) {\n\t\t\treturn n;\n\t\t}\n\t\t++bufptr;\n\t\t++n;\n\t}\n\n\treturn n;\n}", "target": 1, "idx": 10760}
{"commit_id": "517298bafaaff0a8e3dd60dd055a67c41b545807", "project": "avast/retdec", "func": "bool Decoder::canSplitFunctionOn(\n\t\tutils::Address addr,\n\t\tllvm::BasicBlock* splitBb,\n\t\tstd::set<llvm::BasicBlock*>& newFncStarts)\n{\n\tnewFncStarts.insert(splitBb);\n\n\tauto* f = splitBb->getParent();\n\tauto fAddr = getFunctionAddress(f);\n\n\tauto fSzIt = _fnc2sz.find(f);\n\tif (fSzIt != _fnc2sz.end())\n\t{\n\t\tif (fAddr <= addr && addr < (fAddr+fSzIt->second))\n\t\t{\n\t\t\tLOG << \"\\t\\t\\t\\t\\t\" << \"!CAN S: addr cond @ \" << addr << std::endl;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tstd::set<Address> fncStarts;\n\tfncStarts.insert(fAddr);\n\tfncStarts.insert(addr);\n\n\tLOG << \"\\t\\t\\t\\t\\t\" << \"CAN S: split @ \" << fAddr << std::endl;\n\tLOG << \"\\t\\t\\t\\t\\t\" << \"CAN S: split @ \" << addr << std::endl;\n\n\tbool changed = true;\n\twhile (changed)\n\t{\n\t\tchanged = false;\n\t\tfor (BasicBlock& b : *f)\n\t\t{\n//\t\t\tAddress bAddr = getBasicBlockAddress(&b);\n\t\t\tAddress bAddr;\n\t\t\t// TODO: shitty\n\t\t\tBasicBlock* bPrev = &b;\n\t\t\twhile (bAddr.isUndefined() && bPrev)\n\t\t\t{\n\t\t\t\tbAddr = getBasicBlockAddress(bPrev);\n\t\t\t\tbPrev = bPrev->getPrevNode();\n\t\t\t}\n\t\t\tif (bAddr.isUndefined())\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tauto up = fncStarts.upper_bound(bAddr);\n\t\t\tif (up == fncStarts.begin()) {\n\t\t\t\treturn false;\n\t\t\t}\t\n\t\t\t--up;\n\t\t\tAddress bFnc = *up;\n\n\t\t\tfor (auto* p : predecessors(&b))\n\t\t\t{\n//\t\t\t\tAddress pAddr = getBasicBlockAddress(p);\n\t\t\t\tAddress pAddr;\n\t\t\t\t// TODO: shitty\n\t\t\t\tBasicBlock* pPrev = p;\n\t\t\t\twhile (pAddr.isUndefined() && pPrev)\n\t\t\t\t{\n\t\t\t\t\tpAddr = getBasicBlockAddress(pPrev);\n\t\t\t\t\tpPrev = pPrev->getPrevNode();\n\t\t\t\t}\n\t\t\t\tif (pAddr.isUndefined())\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tauto up = fncStarts.upper_bound(pAddr);\n\t\t\t\tif (up == fncStarts.begin()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t--up;\n\t\t\t\tAddress pFnc = *up;\n\n\t\t\t\tif (bFnc != pFnc)\n\t\t\t\t{\n\t\t\t\t\tif (!canSplitFunctionOn(&b))\n\t\t\t\t\t{\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tchanged |= newFncStarts.insert(&b).second;\n\t\t\t\t\tchanged |= fncStarts.insert(bAddr).second;\n\n\t\t\t\t\tLOG << \"\\t\\t\\t\\t\\t\" << \"CAN S: split @ \" << bAddr << std::endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}", "target": 3, "idx": 10761}
{"commit_id": "fc285cecb8469f0262db0170bf6dd7c01d9b8ed5", "project": "radareorg/radare2", "func": "static RList *oneshotall_buffer(RBin *bin, RBuffer *b) {\n\tRBinXtrData *meta = get_the_meta (bin, b);\n\tif (!meta) {\n\t\treturn NULL;\n\t}\n\tRList *list = r_list_newf (free);\n\tif (!list) {\n\t\tfree (meta);\n\t\treturn NULL;\n\t}\n\tr_list_append (list, meta);\n\treturn list;\n}", "target": 1, "idx": 10762}
{"commit_id": "441026fcb13ac23aa10edc312bdacb6445a0ad06", "project": "ffmpeg", "func": "static int xwd_decode_frame(AVCodecContext *avctx, void *data,\n                            int *got_frame, AVPacket *avpkt)\n{\n    AVFrame *p = data;\n    const uint8_t *buf = avpkt->data;\n    int i, ret, buf_size = avpkt->size;\n    uint32_t version, header_size, vclass, ncolors;\n    uint32_t xoffset, be, bpp, lsize, rsize;\n    uint32_t pixformat, pixdepth, bunit, bitorder, bpad;\n    uint32_t rgb[3];\n    uint8_t *ptr;\n    GetByteContext gb;\n\n    if (buf_size < XWD_HEADER_SIZE)\n        return AVERROR_INVALIDDATA;\n\n    bytestream2_init(&gb, buf, buf_size);\n    header_size = bytestream2_get_be32u(&gb);\n\n    version = bytestream2_get_be32u(&gb);\n    if (version != XWD_VERSION) {\n        av_log(avctx, AV_LOG_ERROR, \"unsupported version\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (buf_size < header_size || header_size < XWD_HEADER_SIZE) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid header size\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    pixformat     = bytestream2_get_be32u(&gb);\n    pixdepth      = bytestream2_get_be32u(&gb);\n    avctx->width  = bytestream2_get_be32u(&gb);\n    avctx->height = bytestream2_get_be32u(&gb);\n    xoffset       = bytestream2_get_be32u(&gb);\n    be            = bytestream2_get_be32u(&gb);\n    bunit         = bytestream2_get_be32u(&gb);\n    bitorder      = bytestream2_get_be32u(&gb);\n    bpad          = bytestream2_get_be32u(&gb);\n    bpp           = bytestream2_get_be32u(&gb);\n    lsize         = bytestream2_get_be32u(&gb);\n    vclass        = bytestream2_get_be32u(&gb);\n    rgb[0]        = bytestream2_get_be32u(&gb);\n    rgb[1]        = bytestream2_get_be32u(&gb);\n    rgb[2]        = bytestream2_get_be32u(&gb);\n    bytestream2_skipu(&gb, 8);\n    ncolors       = bytestream2_get_be32u(&gb);\n    bytestream2_skipu(&gb, header_size - (XWD_HEADER_SIZE - 20));\n\n    av_log(avctx, AV_LOG_DEBUG,\n           \"pixformat %\"PRIu32\", pixdepth %\"PRIu32\", bunit %\"PRIu32\", bitorder %\"PRIu32\", bpad %\"PRIu32\"\\n\",\n           pixformat, pixdepth, bunit, bitorder, bpad);\n    av_log(avctx, AV_LOG_DEBUG,\n           \"vclass %\"PRIu32\", ncolors %\"PRIu32\", bpp %\"PRIu32\", be %\"PRIu32\", lsize %\"PRIu32\", xoffset %\"PRIu32\"\\n\",\n           vclass, ncolors, bpp, be, lsize, xoffset);\n    av_log(avctx, AV_LOG_DEBUG,\n           \"red %0\"PRIx32\", green %0\"PRIx32\", blue %0\"PRIx32\"\\n\",\n           rgb[0], rgb[1], rgb[2]);\n\n    if (pixformat > XWD_Z_PIXMAP) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid pixmap format\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (pixdepth == 0 || pixdepth > 32) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid pixmap depth\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (xoffset) {\n        avpriv_request_sample(avctx, \"xoffset %\"PRIu32\"\", xoffset);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    if (be > 1) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid byte order\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (bitorder > 1) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid bitmap bit order\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (bunit != 8 && bunit != 16 && bunit != 32) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid bitmap unit\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (bpad != 8 && bpad != 16 && bpad != 32) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid bitmap scan-line pad\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (bpp == 0 || bpp > 32) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid bits per pixel\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (ncolors > 256) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid number of entries in colormap\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if ((ret = av_image_check_size(avctx->width, avctx->height, 0, NULL)) < 0)\n        return ret;\n\n    rsize = FFALIGN(avctx->width * bpp, bpad) / 8;\n    if (lsize < rsize) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid bytes per scan-line\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (bytestream2_get_bytes_left(&gb) < ncolors * XWD_CMAP_SIZE + (uint64_t)avctx->height * lsize) {\n        av_log(avctx, AV_LOG_ERROR, \"input buffer too small\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (pixformat != XWD_Z_PIXMAP) {\n        avpriv_report_missing_feature(avctx, \"Pixmap format %\"PRIu32, pixformat);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    avctx->pix_fmt = AV_PIX_FMT_NONE;\n    switch (vclass) {\n    case XWD_STATIC_GRAY:\n    case XWD_GRAY_SCALE:\n        if (bpp != 1 && bpp != 8)\n            return AVERROR_INVALIDDATA;\n        if (bpp == 1 && pixdepth == 1) {\n            avctx->pix_fmt = AV_PIX_FMT_MONOWHITE;\n        } else if (bpp == 8 && pixdepth == 8) {\n            avctx->pix_fmt = AV_PIX_FMT_GRAY8;\n        }\n        break;\n    case XWD_STATIC_COLOR:\n    case XWD_PSEUDO_COLOR:\n        if (bpp == 8)\n            avctx->pix_fmt = AV_PIX_FMT_PAL8;\n        break;\n    case XWD_TRUE_COLOR:\n    case XWD_DIRECT_COLOR:\n        if (bpp != 16 && bpp != 24 && bpp != 32)\n            return AVERROR_INVALIDDATA;\n        if (bpp == 16 && pixdepth == 15) {\n            if (rgb[0] == 0x7C00 && rgb[1] == 0x3E0 && rgb[2] == 0x1F)\n                avctx->pix_fmt = be ? AV_PIX_FMT_RGB555BE : AV_PIX_FMT_RGB555LE;\n            else if (rgb[0] == 0x1F && rgb[1] == 0x3E0 && rgb[2] == 0x7C00)\n                avctx->pix_fmt = be ? AV_PIX_FMT_BGR555BE : AV_PIX_FMT_BGR555LE;\n        } else if (bpp == 16 && pixdepth == 16) {\n            if (rgb[0] == 0xF800 && rgb[1] == 0x7E0 && rgb[2] == 0x1F)\n                avctx->pix_fmt = be ? AV_PIX_FMT_RGB565BE : AV_PIX_FMT_RGB565LE;\n            else if (rgb[0] == 0x1F && rgb[1] == 0x7E0 && rgb[2] == 0xF800)\n                avctx->pix_fmt = be ? AV_PIX_FMT_BGR565BE : AV_PIX_FMT_BGR565LE;\n        } else if (bpp == 24) {\n            if (rgb[0] == 0xFF0000 && rgb[1] == 0xFF00 && rgb[2] == 0xFF)\n                avctx->pix_fmt = be ? AV_PIX_FMT_RGB24 : AV_PIX_FMT_BGR24;\n            else if (rgb[0] == 0xFF && rgb[1] == 0xFF00 && rgb[2] == 0xFF0000)\n                avctx->pix_fmt = be ? AV_PIX_FMT_BGR24 : AV_PIX_FMT_RGB24;\n        } else if (bpp == 32) {\n            if (rgb[0] == 0xFF0000 && rgb[1] == 0xFF00 && rgb[2] == 0xFF)\n                avctx->pix_fmt = be ? AV_PIX_FMT_ARGB : AV_PIX_FMT_BGRA;\n            else if (rgb[0] == 0xFF && rgb[1] == 0xFF00 && rgb[2] == 0xFF0000)\n                avctx->pix_fmt = be ? AV_PIX_FMT_ABGR : AV_PIX_FMT_RGBA;\n        }\n        bytestream2_skipu(&gb, ncolors * XWD_CMAP_SIZE);\n        break;\n    default:\n        av_log(avctx, AV_LOG_ERROR, \"invalid visual class\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (avctx->pix_fmt == AV_PIX_FMT_NONE) {\n        avpriv_request_sample(avctx,\n                              \"Unknown file: bpp %\"PRIu32\", pixdepth %\"PRIu32\", vclass %\"PRIu32\"\",\n                              bpp, pixdepth, vclass);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    if ((ret = ff_get_buffer(avctx, p, 0)) < 0)\n        return ret;\n\n    p->key_frame = 1;\n    p->pict_type = AV_PICTURE_TYPE_I;\n\n    if (avctx->pix_fmt == AV_PIX_FMT_PAL8) {\n        uint32_t *dst = (uint32_t *)p->data[1];\n        uint8_t red, green, blue;\n\n        for (i = 0; i < ncolors; i++) {\n\n            bytestream2_skipu(&gb, 4); // skip colormap entry number\n            red    = bytestream2_get_byteu(&gb);\n            bytestream2_skipu(&gb, 1);\n            green  = bytestream2_get_byteu(&gb);\n            bytestream2_skipu(&gb, 1);\n            blue   = bytestream2_get_byteu(&gb);\n            bytestream2_skipu(&gb, 3); // skip bitmask flag and padding\n\n            dst[i] = red << 16 | green << 8 | blue;\n        }\n    }\n\n    ptr = p->data[0];\n    for (i = 0; i < avctx->height; i++) {\n        bytestream2_get_bufferu(&gb, ptr, rsize);\n        bytestream2_skipu(&gb, lsize - rsize);\n        ptr += p->linesize[0];\n    }\n\n    *got_frame       = 1;\n\n    return buf_size;\n}", "target": 2, "idx": 10763}
{"commit_id": "a70a16b28bf78403dc86ae798c291ba167573d4a", "project": "GNOME/glib", "func": "GVariant *\ng_variant_get_normal_form (GVariant *value)\n{\n  GVariant *trusted;\n\n  if (g_variant_is_normal_form (value))\n    return g_variant_ref (value);\n\n  trusted = g_variant_deep_copy (value, FALSE);\n  g_assert (g_variant_is_trusted (trusted));\n\n  return g_variant_ref_sink (trusted);\n}", "target": 1, "idx": 10764}
{"commit_id": "8d1d605b3d8c49bdfe9376454f0196738bed8166", "project": "upx", "func": "Elf64_Sym const *PackLinuxElf64::elf_lookup(char const *name) const\n{\n    if (hashtab && dynsym && dynstr) {\n        unsigned const nbucket = get_te32(&hashtab[0]);\n        unsigned const *const buckets = &hashtab[2];\n        unsigned const *const chains = &buckets[nbucket];\n        if (!nbucket\n        ||  (unsigned)(file_size - ((char const *)buckets - (char const *)(void const *)file_image))\n                <= sizeof(unsigned)*nbucket ) {\n            char msg[80]; snprintf(msg, sizeof(msg),\n                \"bad nbucket %#x\\n\", nbucket);\n            throwCantPack(msg);\n        }\n        unsigned const m = elf_hash(name) % nbucket;\n        unsigned si;\n        for (si= get_te32(&buckets[m]); 0!=si; si= get_te32(&chains[si])) {\n            char const *const p= get_dynsym_name(si, (unsigned)-1);\n            if (0==strcmp(name, p)) {\n                return &dynsym[si];\n            }\n        }\n    }\n    if (gashtab && dynsym && dynstr) {\n        unsigned const n_bucket = get_te32(&gashtab[0]);\n        unsigned const symbias  = get_te32(&gashtab[1]);\n        unsigned const n_bitmask = get_te32(&gashtab[2]);\n        unsigned const gnu_shift = get_te32(&gashtab[3]);\n        upx_uint64_t const *const bitmask = (upx_uint64_t const *)(void const *)&gashtab[4];\n        unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask];\n        unsigned     const *const hasharr = &buckets[n_bucket];\n        if (!n_bucket\n        || (void const *)&file_image[file_size] <= (void const *)hasharr) {\n            char msg[80]; snprintf(msg, sizeof(msg),\n                \"bad n_bucket %#x\\n\", n_bucket);\n            throwCantPack(msg);\n        }\n        if (!n_bitmask\n        || (unsigned)(file_size - ((char const *)bitmask - (char const *)(void const *)file_image))\n                <= sizeof(unsigned)*n_bitmask ) {\n            char msg[80]; snprintf(msg, sizeof(msg),\n                \"bad n_bitmask %#x\\n\", n_bitmask);\n            throwCantPack(msg);\n        }\n\n        unsigned const h = gnu_hash(name);\n        unsigned const hbit1 = 077& h;\n        unsigned const hbit2 = 077& (h>>gnu_shift);\n        upx_uint64_t const w = get_te64(&bitmask[(n_bitmask -1) & (h>>6)]);\n\n        if (1& (w>>hbit1) & (w>>hbit2)) {\n            unsigned bucket = get_te32(&buckets[h % n_bucket]);\n            if (n_bucket <= bucket) {\n                char msg[80]; snprintf(msg, sizeof(msg),\n                        \"bad DT_GNU_HASH n_bucket{%#x} <= buckets[%d]{%#x}\\n\",\n                        n_bucket, h % n_bucket, bucket);\n                throwCantPack(msg);\n            }\n            if (0!=bucket) {\n                Elf64_Sym const *dsp = &dynsym[bucket];\n                unsigned const *hp = &hasharr[bucket - symbias];\n\n                do if (0==((h ^ get_te32(hp))>>1)) {\n                    unsigned st_name = get_te32(&dsp->st_name);\n                    char const *const p = get_str_name(st_name, (unsigned)-1);\n                    if (0==strcmp(name, p)) {\n                        return dsp;\n                    }\n                } while (++dsp,\n                        (char const *)hp < (char const *)&file_image[file_size]\n                    &&  0==(1u& get_te32(hp++)));\n            }\n        }\n    }\n    return 0;\n\n}", "target": 1, "idx": 10765}
{"commit_id": "2390ad111bde16a78c98ac44572090b33c3bd2d8", "project": "znc", "func": "void CClient::EchoMessage(const CMessage& Message) {\n    CMessage EchoedMessage = Message;\n    for (CClient* pClient : GetClients()) {\n        if (pClient->HasEchoMessage() ||\n            (pClient != this && ((m_pNetwork && m_pNetwork->IsChan(Message.GetParam(0))) ||\n                                 pClient->HasSelfMessage()))) {\n            EchoedMessage.SetNick(GetNickMask());\n            pClient->PutClient(EchoedMessage);\n        }\n    }\n}", "target": 1, "idx": 10766}
{"commit_id": "e5a51c508ef952e81a6da25b43034dd1ed023c07", "project": "EliasOenal/multimon-ng", "func": "unsigned int add_ch(unsigned char ch, unsigned char* buf, unsigned int idx) {\n    // avoid buffer overflow that has been happening\n    if (idx >= MAX_ALN) {\n        verbprintf(3, \"FLEX: idx %u >= MAX_ALN %u\\n\", idx, MAX_ALN);\n        return 0;\n    }\n    // TODO sanitize % or you will have uncontrolled format string vuln\n    // Originally, this only avoided storing ETX (end of text, 0x03).\n    // At minimum you'll also want to avoid storing NULL (str term, 0x00),\n    // otherwise verbprintf will truncate the message.\n    //   ex: if (ch != 0x03 && ch != 0x00) { buf[idx] = ch; return 1; }\n    // But while we are here, make it print friendly and get it onto a single line\n    //   * remove awkward ctrl chars (del, bs, bell, vertical tab, etc)\n    //   * encode valuable ctrl chars (new line/line feed, carriage ret, tab)\n    // NOTE: if you post process FLEX ALN output by sed/grep/awk etc on non-printables\n    //   then double check this doesn't mess with your pipeline\n    if (ch == 0x09 && idx < (MAX_ALN - 2)) {  // '\\t'\n        buf[idx] = '\\\\';\n        buf[idx + 1] = 't';\n        return 2;\n    }\n    if (ch == 0x0a && idx < (MAX_ALN - 2)) {  // '\\n'\n        buf[idx] = '\\\\';\n        buf[idx + 1] = 'n';\n        return 2;\n    }\n    if (ch == 0x0d && idx < (MAX_ALN - 2)) {  // '\\r'\n        buf[idx] = '\\\\';\n        buf[idx + 1] = 'r';\n        return 2;\n    }\n    // unixinput.c::_verbprintf uses this output as a format string\n    // which introduces an uncontrolled format string vulnerability\n    // and also, generally, risks stack corruption\n    if (ch == '%') {\n        if (idx < (MAX_ALN - 2)) {\n            buf[idx] = '%';\n            buf[idx + 1] = '%';\n            return 2;\n        }\n        return 0;\n    }\n    // only store ASCII printable\n    if (ch >= 32 && ch <= 126) {\n        buf[idx] = ch;\n        return 1;\n    }\n    // if you want all non-printables, show as hex, but also make MAX_ALN 1024\n    /* if (idx < (MAX_ALN - 4)) {\n        sprintf(buf + idx, \"\\\\x%02x\", ch);\n        return 4;\n    }*/\n    return 0;\n}", "target": 3, "idx": 10767}
{"commit_id": "634ce8e8a5accc0fa05dd2c20d42b4749d4b2735", "project": "jasper-software/jasper", "func": "static int mem_write(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tsize_t n;\n\tint ret;\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tsize_t newbufsize;\n\tsize_t newpos;\n\n\tassert(buf);\n\tassert(cnt >= 0);\n\n\tJAS_DBGLOG(100, (\"mem_write(%p, %p, %d)\\n\", obj, buf, cnt));\n\tnewpos = m->pos_ + cnt;\n\tif (newpos > m->bufsize_ && m->growable_) {\n\t\tnewbufsize = m->bufsize_;\n\t\twhile (newbufsize < newpos) {\n\t\t\t//newbufsize <<= 1;\n\t\t\tif (!jas_safe_size_mul(newbufsize, 2, &newbufsize)) {\n\t\t\t\tJAS_DBGLOG(100, (\"new buffer size would cause overflow\\n\"));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tJAS_DBGLOG(100, (\"mem_write resizing from %d to %zu\\n\", m->bufsize_,\n\t\t  newbufsize));\n\t\tassert(newbufsize > 0);\n\t\tif (mem_resize(m, newbufsize)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (m->pos_ > m->len_) {\n\t\t/* The current position is beyond the end of the file, so\n\t\t  pad the file to the current position with zeros. */\n\t\tn = JAS_MIN(m->pos_, m->bufsize_) - m->len_;\n\t\tif (n > 0) {\n\t\t\tmemset(&m->buf_[m->len_], 0, n);\n\t\t\tm->len_ += n;\n\t\t}\n\t\tif (m->pos_ != m->len_) {\n\t\t\t/* The buffer is not big enough. */\n\t\t\treturn 0;\n\t\t}\n\t}\n\tn = m->bufsize_ - m->pos_;\n\tret = JAS_MIN(n, cnt);\n\tif (ret > 0) {\n\t\tmemcpy(&m->buf_[m->pos_], buf, ret);\n\t\tm->pos_ += ret;\n\t}\n\tif (m->pos_ > m->len_) {\n\t\tm->len_ = m->pos_;\n\t}\n\tassert(ret == cnt);\n\treturn ret;\n}", "target": 1, "idx": 10768}
{"commit_id": "99a63d36cb3ed5ca3aa6fcb64cffbeaf3b0fb164", "project": "torvalds/linux", "func": "static int\nnfqnl_mangle(void *data, unsigned int data_len, struct nf_queue_entry *e, int diff)\n{\n\tstruct sk_buff *nskb;\n\n\tif (diff < 0) {\n\t\tunsigned int min_len = skb_transport_offset(e->skb);\n\n\t\tif (data_len < min_len)\n\t\t\treturn -EINVAL;\n\n\t\tif (pskb_trim(e->skb, data_len))\n\t\t\treturn -ENOMEM;\n\t} else if (diff > 0) {\n\t\tif (data_len > 0xFFFF)\n\t\t\treturn -EINVAL;\n\t\tif (diff > skb_tailroom(e->skb)) {\n\t\t\tnskb = skb_copy_expand(e->skb, skb_headroom(e->skb),\n\t\t\t\t\t       diff, GFP_ATOMIC);\n\t\t\tif (!nskb)\n\t\t\t\treturn -ENOMEM;\n\t\t\tkfree_skb(e->skb);\n\t\t\te->skb = nskb;\n\t\t}\n\t\tskb_put(e->skb, diff);\n\t}\n\tif (skb_ensure_writable(e->skb, data_len))\n\t\treturn -ENOMEM;\n\tskb_copy_to_linear_data(e->skb, data, data_len);\n\te->skb->ip_summed = CHECKSUM_NONE;\n\treturn 0;\n}", "target": 2, "idx": 10769}
{"commit_id": "8c17c272184f0227e8bd42c2a7d62d5683a466a8", "project": "mate-desktop/mate-screensaver", "func": "GSWindow *\ngs_window_new (GdkMonitor *monitor,\n               gboolean   lock_enabled)\n{\n\tGObject    *result;\n\tGdkDisplay *display = gdk_monitor_get_display (monitor);\n\tGdkScreen  *screen = gdk_display_get_default_screen (display);\n\n\tresult = g_object_new (GS_TYPE_WINDOW,\n\t                       \"type\", GTK_WINDOW_POPUP,\n\t                       \"screen\", screen,\n\t                       \"monitor\", monitor,\n\t                       \"lock-enabled\", lock_enabled,\n\t                       \"app-paintable\", TRUE,\n\t                       NULL);\n\n\treturn GS_WINDOW (result);\n}", "target": 1, "idx": 10770}
{"commit_id": "c0569cc04741cccf6548c2169fcc1609d958523f", "project": "chromium", "func": "V8ContextNativeHandler::V8ContextNativeHandler(ScriptContext* context)\n    : ObjectBackedNativeHandler(context), context_(context) {\n  RouteFunction(\"GetAvailability\",\n                base::Bind(&V8ContextNativeHandler::GetAvailability,\n                           base::Unretained(this)));\n  RouteFunction(\"GetModuleSystem\",\n                base::Bind(&V8ContextNativeHandler::GetModuleSystem,\n                           base::Unretained(this)));\n  RouteFunction(\"RunWithNativesEnabled\", \"test\",\n                base::Bind(&V8ContextNativeHandler::RunWithNativesEnabled,\n                           base::Unretained(this)));\n}", "target": 2, "idx": 10771}
{"commit_id": "ff82911cd3f69f028f2537825c9720ff78bc3f19", "project": "qemu", "func": "static coroutine_fn void nbd_trip(void *opaque)\n{\n    NBDClient *client = opaque;\n    NBDExport *exp = client->exp;\n    NBDRequestData *req;\n    NBDRequest request = { 0 };    /* GCC thinks it can be used uninitialized */\n    NBDReply reply;\n    ssize_t ret;\n    int flags;\n\n    TRACE(\"Reading request.\");\n    if (client->closing) {\n        nbd_client_put(client);\n        return;\n    }\n\n    req = nbd_request_get(client);\n    ret = nbd_co_receive_request(req, &request);\n    if (ret == -EAGAIN) {\n        goto done;\n    }\n    if (ret == -EIO) {\n        goto out;\n    }\n\n    reply.handle = request.handle;\n    reply.error = 0;\n\n    if (ret < 0) {\n        reply.error = -ret;\n        goto error_reply;\n    }\n\n    if (client->closing) {\n        /*\n         * The client may be closed when we are blocked in\n         * nbd_co_receive_request()\n         */\n        goto done;\n    }\n\n    switch (request.type) {\n    case NBD_CMD_READ:\n        TRACE(\"Request type is READ\");\n\n        /* XXX: NBD Protocol only documents use of FUA with WRITE */\n        if (request.flags & NBD_CMD_FLAG_FUA) {\n            ret = blk_co_flush(exp->blk);\n            if (ret < 0) {\n                LOG(\"flush failed\");\n                reply.error = -ret;\n                goto error_reply;\n            }\n        }\n\n        ret = blk_pread(exp->blk, request.from + exp->dev_offset,\n                        req->data, request.len);\n        if (ret < 0) {\n            LOG(\"reading from file failed\");\n            reply.error = -ret;\n            goto error_reply;\n        }\n\n        TRACE(\"Read %\" PRIu32\" byte(s)\", request.len);\n        if (nbd_co_send_reply(req, &reply, request.len) < 0)\n            goto out;\n        break;\n    case NBD_CMD_WRITE:\n        TRACE(\"Request type is WRITE\");\n\n        if (exp->nbdflags & NBD_FLAG_READ_ONLY) {\n            TRACE(\"Server is read-only, return error\");\n            reply.error = EROFS;\n            goto error_reply;\n        }\n\n        TRACE(\"Writing to device\");\n\n        flags = 0;\n        if (request.flags & NBD_CMD_FLAG_FUA) {\n            flags |= BDRV_REQ_FUA;\n        }\n        ret = blk_pwrite(exp->blk, request.from + exp->dev_offset,\n                         req->data, request.len, flags);\n        if (ret < 0) {\n            LOG(\"writing to file failed\");\n            reply.error = -ret;\n            goto error_reply;\n        }\n\n        if (nbd_co_send_reply(req, &reply, 0) < 0) {\n            goto out;\n        }\n        break;\n\n    case NBD_CMD_WRITE_ZEROES:\n        TRACE(\"Request type is WRITE_ZEROES\");\n\n        if (exp->nbdflags & NBD_FLAG_READ_ONLY) {\n            TRACE(\"Server is read-only, return error\");\n            reply.error = EROFS;\n            goto error_reply;\n        }\n\n        TRACE(\"Writing to device\");\n\n        flags = 0;\n        if (request.flags & NBD_CMD_FLAG_FUA) {\n            flags |= BDRV_REQ_FUA;\n        }\n        if (!(request.flags & NBD_CMD_FLAG_NO_HOLE)) {\n            flags |= BDRV_REQ_MAY_UNMAP;\n        }\n        ret = blk_pwrite_zeroes(exp->blk, request.from + exp->dev_offset,\n                                request.len, flags);\n        if (ret < 0) {\n            LOG(\"writing to file failed\");\n            reply.error = -ret;\n            goto error_reply;\n        }\n\n        if (nbd_co_send_reply(req, &reply, 0) < 0) {\n            goto out;\n        }\n        break;\n\n    case NBD_CMD_DISC:\n        /* unreachable, thanks to special case in nbd_co_receive_request() */\n        abort();\n\n    case NBD_CMD_FLUSH:\n        TRACE(\"Request type is FLUSH\");\n\n        ret = blk_co_flush(exp->blk);\n        if (ret < 0) {\n            LOG(\"flush failed\");\n            reply.error = -ret;\n        }\n        if (nbd_co_send_reply(req, &reply, 0) < 0) {\n            goto out;\n        }\n        break;\n    case NBD_CMD_TRIM:\n        TRACE(\"Request type is TRIM\");\n        ret = blk_co_pdiscard(exp->blk, request.from + exp->dev_offset,\n                              request.len);\n        if (ret < 0) {\n            LOG(\"discard failed\");\n            reply.error = -ret;\n        }\n        if (nbd_co_send_reply(req, &reply, 0) < 0) {\n            goto out;\n        }\n        break;\n    default:\n        LOG(\"invalid request type (%\" PRIu32 \") received\", request.type);\n        reply.error = EINVAL;\n    error_reply:\n        /* We must disconnect after NBD_CMD_WRITE if we did not\n         * read the payload.\n         */\n        if (nbd_co_send_reply(req, &reply, 0) < 0 || !req->complete) {\n            goto out;\n        }\n        break;\n    }\n\n    TRACE(\"Request/Reply complete\");\n\ndone:\n    nbd_request_put(req);\n    nbd_client_put(client);\n    return;\n\nout:\n    nbd_request_put(req);\n    client_close(client);\n    nbd_client_put(client);\n}", "target": 1, "idx": 10772}
{"commit_id": "beb54596cfdaf15f6a86d7b1bf84ca8a0b9c6b9b", "project": "xen-project/xen", "func": "static void _pci_cleanup_msix(struct arch_msix *msix)\n{\n    if ( !--msix->used_entries )\n    {\n        if ( rangeset_remove_range(mmio_ro_ranges, msix->table.first,\n                                   msix->table.last) )\n            WARN();\n        msix->table.first = 0;\n        msix->table.last = 0;\n\n        if ( rangeset_remove_range(mmio_ro_ranges, msix->pba.first,\n                                   msix->pba.last) )\n            WARN();\n        msix->pba.first = 0;\n        msix->pba.last = 0;\n    }\n}", "target": 2, "idx": 10773}
{"commit_id": "53499d8d4c69142137c7c7f0097a444783fdeb90", "project": "axiomatic-systems/Bento4", "func": "AP4_AvccAtom::AP4_AvccAtom(AP4_UI32 size, const AP4_UI08* payload) :\n    AP4_Atom(AP4_ATOM_TYPE_AVCC, size)\n{\n    // make a copy of our configuration bytes\n    unsigned int payload_size = size-AP4_ATOM_HEADER_SIZE;\n    m_RawBytes.SetData(payload, payload_size);\n\n    // parse the payload\n    m_ConfigurationVersion = payload[0];\n    m_Profile              = payload[1];\n    m_ProfileCompatibility = payload[2];\n    m_Level                = payload[3];\n    m_NaluLengthSize       = 1+(payload[4]&3);\n    AP4_UI08 num_seq_params = payload[5]&31;\n    m_SequenceParameters.EnsureCapacity(num_seq_params);\n    unsigned int cursor = 6;\n    for (unsigned int i=0; i<num_seq_params; i++) {\n        if (cursor+2 <= payload_size) {\n            AP4_UI16 param_length = AP4_BytesToInt16BE(&payload[cursor]);\n            cursor += 2;\n            if (cursor + param_length < payload_size) {\n                m_SequenceParameters.Append(AP4_DataBuffer());\n                m_SequenceParameters[i].SetData(&payload[cursor], param_length);\n                cursor += param_length;\n            }\n        }\n    }\n    AP4_UI08 num_pic_params = payload[cursor++];\n    m_PictureParameters.EnsureCapacity(num_pic_params);\n    for (unsigned int i=0; i<num_pic_params; i++) {\n        if (cursor+2 <= payload_size) {\n            AP4_UI16 param_length = AP4_BytesToInt16BE(&payload[cursor]);\n            cursor += 2;\n            if (cursor + param_length < payload_size) {\n                m_PictureParameters.Append(AP4_DataBuffer());\n                m_PictureParameters[i].SetData(&payload[cursor], param_length);\n                cursor += param_length;\n            }\n        }\n    }\n}", "target": 2, "idx": 10774}
{"commit_id": "353c0956a618a07ba4bbe7ad00ff29fe70e8412a", "project": "torvalds/linux", "func": "int kvm_read_guest_virt(struct kvm_vcpu *vcpu,\n\t\t\t       gva_t addr, void *val, unsigned int bytes,\n\t\t\t       struct x86_exception *exception)\n{\n\tu32 access = (kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\n\t/*\n\t * FIXME: this should call handle_emulation_failure if X86EMUL_IO_NEEDED\n\t * is returned, but our callers are not ready for that and they blindly\n\t * call kvm_inject_page_fault.  Ensure that they at least do not leak\n\t * uninitialized kernel stack memory into cr2 and error code.\n\t */\n\tmemset(exception, 0, sizeof(*exception));\n\treturn kvm_read_guest_virt_helper(addr, val, bytes, vcpu, access,\n\t\t\t\t\t  exception);\n}", "target": 1, "idx": 10775}
{"commit_id": "5b82f4f90c3d531313714df4b936f92fb0ff15cf", "project": "android", "func": "omx_vdec::omx_vdec(): m_error_propogated(false),\n    m_state(OMX_StateInvalid),\n    m_app_data(NULL),\n    m_inp_mem_ptr(NULL),\n    m_out_mem_ptr(NULL),\n    input_flush_progress (false),\n    output_flush_progress (false),\n    input_use_buffer (false),\n    output_use_buffer (false),\n    ouput_egl_buffers(false),\n    m_use_output_pmem(OMX_FALSE),\n    m_out_mem_region_smi(OMX_FALSE),\n    m_out_pvt_entry_pmem(OMX_FALSE),\n    pending_input_buffers(0),\n    pending_output_buffers(0),\n    m_out_bm_count(0),\n    m_inp_bm_count(0),\n    m_inp_bPopulated(OMX_FALSE),\n    m_out_bPopulated(OMX_FALSE),\n    m_flags(0),\n#ifdef _ANDROID_\n    m_heap_ptr(NULL),\n#endif\n    m_inp_bEnabled(OMX_TRUE),\n    m_out_bEnabled(OMX_TRUE),\n    m_in_alloc_cnt(0),\n    m_platform_list(NULL),\n    m_platform_entry(NULL),\n    m_pmem_info(NULL),\n    h264_parser(NULL),\n    arbitrary_bytes (true),\n    psource_frame (NULL),\n    pdest_frame (NULL),\n    m_inp_heap_ptr (NULL),\n    m_phdr_pmem_ptr(NULL),\n    m_heap_inp_bm_count (0),\n    codec_type_parse ((codec_type)0),\n    first_frame_meta (true),\n    frame_count (0),\n    nal_count (0),\n    nal_length(0),\n    look_ahead_nal (false),\n    first_frame(0),\n    first_buffer(NULL),\n    first_frame_size (0),\n    m_device_file_ptr(NULL),\n    m_vc1_profile((vc1_profile_type)0),\n    h264_last_au_ts(LLONG_MAX),\n    h264_last_au_flags(0),\n    m_disp_hor_size(0),\n    m_disp_vert_size(0),\n    prev_ts(LLONG_MAX),\n    rst_prev_ts(true),\n    frm_int(0),\n    in_reconfig(false),\n    m_display_id(NULL),\n    client_extradata(0),\n    m_reject_avc_1080p_mp (0),\n#ifdef _ANDROID_\n    m_enable_android_native_buffers(OMX_FALSE),\n    m_use_android_native_buffers(OMX_FALSE),\n    iDivXDrmDecrypt(NULL),\n#endif\n    m_desc_buffer_ptr(NULL),\n    secure_mode(false),\n    m_other_extradata(NULL),\n    m_profile(0),\n    client_set_fps(false),\n    m_last_rendered_TS(-1),\n    m_queued_codec_config_count(0),\n    secure_scaling_to_non_secure_opb(false)\n{\n    /* Assumption is that , to begin with , we have all the frames with decoder */\n    DEBUG_PRINT_HIGH(\"In %u bit OMX vdec Constructor\", (unsigned int)sizeof(long) * 8);\n    memset(&m_debug,0,sizeof(m_debug));\n#ifdef _ANDROID_\n    char property_value[PROPERTY_VALUE_MAX] = {0};\n    property_get(\"vidc.debug.level\", property_value, \"1\");\n    debug_level = atoi(property_value);\n    property_value[0] = '\\0';\n\n    DEBUG_PRINT_HIGH(\"In OMX vdec Constructor\");\n\n    property_get(\"vidc.dec.debug.perf\", property_value, \"0\");\n    perf_flag = atoi(property_value);\n    if (perf_flag) {\n        DEBUG_PRINT_HIGH(\"vidc.dec.debug.perf is %d\", perf_flag);\n        dec_time.start();\n        proc_frms = latency = 0;\n    }\n    prev_n_filled_len = 0;\n    property_value[0] = '\\0';\n    property_get(\"vidc.dec.debug.ts\", property_value, \"0\");\n    m_debug_timestamp = atoi(property_value);\n    DEBUG_PRINT_HIGH(\"vidc.dec.debug.ts value is %d\",m_debug_timestamp);\n    if (m_debug_timestamp) {\n        time_stamp_dts.set_timestamp_reorder_mode(true);\n        time_stamp_dts.enable_debug_print(true);\n    }\n\n    property_value[0] = '\\0';\n    property_get(\"vidc.dec.debug.concealedmb\", property_value, \"0\");\n    m_debug_concealedmb = atoi(property_value);\n    DEBUG_PRINT_HIGH(\"vidc.dec.debug.concealedmb value is %d\",m_debug_concealedmb);\n\n    property_value[0] = '\\0';\n    property_get(\"vidc.dec.profile.check\", property_value, \"0\");\n    m_reject_avc_1080p_mp = atoi(property_value);\n    DEBUG_PRINT_HIGH(\"vidc.dec.profile.check value is %d\",m_reject_avc_1080p_mp);\n\n    property_value[0] = '\\0';\n    property_get(\"vidc.dec.log.in\", property_value, \"0\");\n    m_debug.in_buffer_log = atoi(property_value);\n\n    property_value[0] = '\\0';\n    property_get(\"vidc.dec.log.out\", property_value, \"0\");\n    m_debug.out_buffer_log = atoi(property_value);\n    sprintf(m_debug.log_loc, \"%s\", BUFFER_LOG_LOC);\n\n    property_value[0] = '\\0';\n    property_get(\"vidc.log.loc\", property_value, \"\");\n    if (*property_value)\n        strlcpy(m_debug.log_loc, property_value, PROPERTY_VALUE_MAX);\n\n    property_value[0] = '\\0';\n    property_get(\"vidc.dec.120fps.enabled\", property_value, \"0\");\n\n    //if this feature is not enabled then reset this value -ve\n    if(atoi(property_value)) {\n        DEBUG_PRINT_LOW(\"feature 120 FPS decode enabled\");\n        m_last_rendered_TS = 0;\n    }\n\n    property_value[0] = '\\0';\n    property_get(\"vidc.dec.debug.dyn.disabled\", property_value, \"0\");\n    m_disable_dynamic_buf_mode = atoi(property_value);\n    DEBUG_PRINT_HIGH(\"vidc.dec.debug.dyn.disabled value is %d\",m_disable_dynamic_buf_mode);\n\n#endif\n    memset(&m_cmp,0,sizeof(m_cmp));\n    memset(&m_cb,0,sizeof(m_cb));\n    memset (&drv_ctx,0,sizeof(drv_ctx));\n    memset (&h264_scratch,0,sizeof (OMX_BUFFERHEADERTYPE));\n    memset (m_hwdevice_name,0,sizeof(m_hwdevice_name));\n    memset(m_demux_offsets, 0, ( sizeof(OMX_U32) * 8192) );\n    memset(&m_custom_buffersize, 0, sizeof(m_custom_buffersize));\n    m_demux_entries = 0;\n    msg_thread_id = 0;\n    async_thread_id = 0;\n    msg_thread_created = false;\n    async_thread_created = false;\n#ifdef _ANDROID_ICS_\n    memset(&native_buffer, 0 ,(sizeof(struct nativebuffer) * MAX_NUM_INPUT_OUTPUT_BUFFERS));\n#endif\n    memset(&drv_ctx.extradata_info, 0, sizeof(drv_ctx.extradata_info));\n\n    /* invalidate m_frame_pack_arrangement */\n    memset(&m_frame_pack_arrangement, 0, sizeof(OMX_QCOM_FRAME_PACK_ARRANGEMENT));\n    m_frame_pack_arrangement.cancel_flag = 1;\n\n    drv_ctx.timestamp_adjust = false;\n    drv_ctx.video_driver_fd = -1;\n    m_vendor_config.pData = NULL;\n    pthread_mutex_init(&m_lock, NULL);\n    pthread_mutex_init(&c_lock, NULL);\n    pthread_mutex_init(&buf_lock, NULL);\n    sem_init(&m_cmd_lock,0,0);\n    sem_init(&m_safe_flush, 0, 0);\n    streaming[CAPTURE_PORT] =\n        streaming[OUTPUT_PORT] = false;\n#ifdef _ANDROID_\n    char extradata_value[PROPERTY_VALUE_MAX] = {0};\n    property_get(\"vidc.dec.debug.extradata\", extradata_value, \"0\");\n    m_debug_extradata = atoi(extradata_value);\n    DEBUG_PRINT_HIGH(\"vidc.dec.debug.extradata value is %d\",m_debug_extradata);\n#endif\n    m_fill_output_msg = OMX_COMPONENT_GENERATE_FTB;\n    client_buffers.set_vdec_client(this);\n    dynamic_buf_mode = false;\n    out_dynamic_list = NULL;\n    is_down_scalar_enabled = false;\n    m_smoothstreaming_mode = false;\n    m_smoothstreaming_width = 0;\n    m_smoothstreaming_height = 0;\n    is_q6_platform = false;\n}", "target": 2, "idx": 10776}
{"commit_id": "1e59e000ecae2523e707242621738da27d0d6296", "project": "ImageMagick", "func": "static MagickBooleanType WriteJP2Image(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  const char\n    *option,\n    *property;\n\n  int\n    jp2_status;\n\n  MagickBooleanType\n    status;\n\n  opj_codec_t\n    *jp2_codec;\n\n  OPJ_COLOR_SPACE\n    jp2_colorspace;\n\n  opj_cparameters_t\n    *parameters;\n\n  opj_image_cmptparm_t\n    jp2_info[5];\n\n  opj_image_t\n    *jp2_image;\n\n  opj_stream_t\n    *jp2_stream;\n\n  ssize_t\n    i;\n\n  ssize_t\n    y;\n\n  unsigned int\n    channels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  /*\n    Initialize JPEG 2000 API.\n  */\n  parameters=(opj_cparameters_t *) AcquireMagickMemory(sizeof(*parameters));\n  if (parameters == (opj_cparameters_t *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  opj_set_default_encoder_parameters(parameters);\n  option=GetImageOption(image_info,\"jp2:number-resolutions\");\n  if (option != (const char *) NULL)\n    parameters->numresolution=StringToInteger(option);\n  else\n    parameters->numresolution=CalculateNumResolutions(image->columns,\n      image->rows);\n  parameters->tcp_numlayers=1;\n  parameters->tcp_rates[0]=0;  /* lossless */\n  parameters->cp_disto_alloc=1;\n  if ((image_info->quality != 0) && (image_info->quality != 100))\n    {\n      parameters->tcp_distoratio[0]=(double) image_info->quality;\n      parameters->cp_fixed_quality=OPJ_TRUE;\n      parameters->cp_disto_alloc=0;\n    }\n  if (image_info->extract != (char *) NULL)\n    {\n      RectangleInfo\n        geometry;\n\n      int\n        flags;\n\n      /*\n        Set tile size.\n      */\n      (void) memset(&geometry,0,sizeof(geometry));\n      flags=ParseAbsoluteGeometry(image_info->extract,&geometry);\n      parameters->cp_tdx=(int) geometry.width;\n      parameters->cp_tdy=(int) geometry.width;\n      if ((flags & HeightValue) != 0)\n        parameters->cp_tdy=(int) geometry.height;\n      if ((flags & XValue) != 0)\n        parameters->cp_tx0=geometry.x;\n      if ((flags & YValue) != 0)\n        parameters->cp_ty0=geometry.y;\n      parameters->tile_size_on=OPJ_TRUE;\n      parameters->numresolution=CalculateNumResolutions(parameters->cp_tdx,\n        parameters->cp_tdy);\n    }\n  option=GetImageOption(image_info,\"jp2:quality\");\n  if (option != (const char *) NULL)\n    {\n      const char\n        *p;\n\n      /*\n        Set quality PSNR.\n      */\n      p=option;\n      for (i=0; sscanf(p,\"%f\",&parameters->tcp_distoratio[i]) == 1; i++)\n      {\n        if (i > 100)\n          break;\n        while ((*p != '\\0') && (*p != ','))\n          p++;\n        if (*p == '\\0')\n          break;\n        p++;\n      }\n      parameters->tcp_numlayers=i+1;\n      parameters->cp_fixed_quality=OPJ_TRUE;\n      parameters->cp_disto_alloc=0;\n    }\n  option=GetImageOption(image_info,\"jp2:progression-order\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleCompare(option,\"LRCP\") == 0)\n        parameters->prog_order=OPJ_LRCP;\n      if (LocaleCompare(option,\"RLCP\") == 0)\n        parameters->prog_order=OPJ_RLCP;\n      if (LocaleCompare(option,\"RPCL\") == 0)\n        parameters->prog_order=OPJ_RPCL;\n      if (LocaleCompare(option,\"PCRL\") == 0)\n        parameters->prog_order=OPJ_PCRL;\n      if (LocaleCompare(option,\"CPRL\") == 0)\n        parameters->prog_order=OPJ_CPRL;\n    }\n  option=GetImageOption(image_info,\"jp2:rate\");\n  if (option != (const char *) NULL)\n    {\n      const char\n        *p;\n\n      /*\n        Set compression rate.\n      */\n      p=option;\n      for (i=0; sscanf(p,\"%f\",&parameters->tcp_rates[i]) == 1; i++)\n      {\n        if (i >= 100)\n          break;\n        while ((*p != '\\0') && (*p != ','))\n          p++;\n        if (*p == '\\0')\n          break;\n        p++;\n      }\n      parameters->tcp_numlayers=i+1;\n      parameters->cp_disto_alloc=OPJ_TRUE;\n    }\n  if (image_info->sampling_factor != (const char *) NULL)\n    (void) sscanf(image_info->sampling_factor,\"%d,%d\",\n      &parameters->subsampling_dx,&parameters->subsampling_dy);\n  property=GetImageProperty(image,\"comment\",exception);\n  if (property != (const char *) NULL)\n    parameters->cp_comment=(char *) property;\n  channels=3;\n  jp2_colorspace=OPJ_CLRSPC_SRGB;\n  if (image->colorspace == YUVColorspace)\n    {\n      jp2_colorspace=OPJ_CLRSPC_SYCC;\n      parameters->subsampling_dx=2;\n    }\n  else\n    {\n      if (IsGrayColorspace(image->colorspace) != MagickFalse)\n        {\n          channels=1;\n          jp2_colorspace=OPJ_CLRSPC_GRAY;\n        }\n      else\n        (void) TransformImageColorspace(image,sRGBColorspace,exception);\n      if (image->alpha_trait != UndefinedPixelTrait)\n        channels++;\n    }\n  parameters->tcp_mct=channels == 3 ? 1 : 0;\n  memset(jp2_info,0,sizeof(jp2_info));\n  for (i=0; i < (ssize_t) channels; i++)\n  {\n    jp2_info[i].prec=(OPJ_UINT32) image->depth;\n    jp2_info[i].bpp=(OPJ_UINT32) image->depth;\n    if ((image->depth == 1) &&\n        ((LocaleCompare(image_info->magick,\"JPT\") == 0) ||\n         (LocaleCompare(image_info->magick,\"JP2\") == 0)))\n      {\n        jp2_info[i].prec++;  /* OpenJPEG returns exception for depth @ 1 */\n        jp2_info[i].bpp++;\n      }\n    jp2_info[i].sgnd=0;\n    jp2_info[i].dx=parameters->subsampling_dx;\n    jp2_info[i].dy=parameters->subsampling_dy;\n    jp2_info[i].w=(OPJ_UINT32) image->columns;\n    jp2_info[i].h=(OPJ_UINT32) image->rows;\n  }\n  jp2_image=opj_image_create((OPJ_UINT32) channels,jp2_info,jp2_colorspace);\n  if (jp2_image == (opj_image_t *) NULL)\n    {\n      parameters=(opj_cparameters_t *) RelinquishMagickMemory(parameters);\n      ThrowWriterException(DelegateError,\"UnableToEncodeImageFile\");\n    }\n  jp2_image->x0=parameters->image_offset_x0;\n  jp2_image->y0=parameters->image_offset_y0;\n  jp2_image->x1=(unsigned int) (2*parameters->image_offset_x0+\n    (image->columns-1)*parameters->subsampling_dx+1);\n  jp2_image->y1=(unsigned int) (2*parameters->image_offset_y0+\n    (image->rows-1)*parameters->subsampling_dx+1);\n  if ((image->depth == 12) &&\n      ((image->columns == 2048) || (image->rows == 1080) ||\n       (image->columns == 4096) || (image->rows == 2160)))\n    CinemaProfileCompliance(jp2_image,parameters);\n  if (channels == 4)\n    jp2_image->comps[3].alpha=1;\n  else\n   if ((channels == 2) && (jp2_colorspace == OPJ_CLRSPC_GRAY))\n     jp2_image->comps[1].alpha=1;\n  /*\n    Convert to JP2 pixels.\n  */\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    const Quantum\n      *p;\n\n    ssize_t\n      x;\n\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      for (i=0; i < (ssize_t) channels; i++)\n      {\n        double\n          scale;\n\n        int\n          *q;\n\n        scale=(double) (((size_t) 1UL << jp2_image->comps[i].prec)-1)/\n          QuantumRange;\n        q=jp2_image->comps[i].data+(y*PerceptibleReciprocal(jp2_image->comps[i].dy)*\n          image->columns*PerceptibleReciprocal(jp2_image->comps[i].dx)+x*PerceptibleReciprocal(jp2_image->comps[i].dx));\n        switch (i)\n        {\n          case 0:\n          {\n            if (jp2_colorspace == OPJ_CLRSPC_GRAY)\n              {\n                *q=(int) (scale*GetPixelGray(image,p));\n                break;\n              }\n            *q=(int) (scale*GetPixelRed(image,p));\n            break;\n          }\n          case 1:\n          {\n            if (jp2_colorspace == OPJ_CLRSPC_GRAY)\n              {\n                *q=(int) (scale*GetPixelAlpha(image,p));\n                break;\n              }\n            *q=(int) (scale*GetPixelGreen(image,p));\n            break;\n          }\n          case 2:\n          {\n            *q=(int) (scale*GetPixelBlue(image,p));\n            break;\n          }\n          case 3:\n          {\n            *q=(int) (scale*GetPixelAlpha(image,p));\n            break;\n          }\n        }\n      }\n      p+=GetPixelChannels(image);\n    }\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  if (LocaleCompare(image_info->magick,\"JPT\") == 0)\n    jp2_codec=opj_create_compress(OPJ_CODEC_JPT);\n  else\n    if (LocaleCompare(image_info->magick,\"J2K\") == 0)\n      jp2_codec=opj_create_compress(OPJ_CODEC_J2K);\n    else\n      jp2_codec=opj_create_compress(OPJ_CODEC_JP2);\n  opj_set_warning_handler(jp2_codec,JP2WarningHandler,exception);\n  opj_set_error_handler(jp2_codec,JP2ErrorHandler,exception);\n  opj_setup_encoder(jp2_codec,parameters,jp2_image);\n  jp2_stream=opj_stream_create(OPJ_J2K_STREAM_CHUNK_SIZE,OPJ_FALSE);\n  if (jp2_stream == (opj_stream_t *) NULL)\n    {\n      opj_destroy_codec(jp2_codec);\n      opj_image_destroy(jp2_image);\n      parameters=(opj_cparameters_t *) RelinquishMagickMemory(parameters);\n      ThrowWriterException(DelegateError,\"UnableToEncodeImageFile\");\n    }\n  opj_stream_set_read_function(jp2_stream,JP2ReadHandler);\n  opj_stream_set_write_function(jp2_stream,JP2WriteHandler);\n  opj_stream_set_seek_function(jp2_stream,JP2SeekHandler);\n  opj_stream_set_skip_function(jp2_stream,JP2SkipHandler);\n  opj_stream_set_user_data(jp2_stream,image,NULL);\n  jp2_status=opj_start_compress(jp2_codec,jp2_image,jp2_stream);\n  if ((jp2_status == 0) || (opj_encode(jp2_codec,jp2_stream) == 0) ||\n      (opj_end_compress(jp2_codec,jp2_stream) == 0))\n    {\n      opj_stream_destroy(jp2_stream);\n      opj_destroy_codec(jp2_codec);\n      opj_image_destroy(jp2_image);\n      parameters=(opj_cparameters_t *) RelinquishMagickMemory(parameters);\n      ThrowWriterException(DelegateError,\"UnableToEncodeImageFile\");\n    }\n  /*\n    Free resources.\n  */\n  opj_stream_destroy(jp2_stream);\n  opj_destroy_codec(jp2_codec);\n  opj_image_destroy(jp2_image);\n  parameters=(opj_cparameters_t *) RelinquishMagickMemory(parameters);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}", "target": 1, "idx": 10777}
{"commit_id": "6f163e07ae68654d7ac5268cbb7565f6df79ad85", "project": "neomutt", "func": "enum ImapAuthRes imap_auth_cram_md5(struct ImapData *idata, const char *method)\n{\n  char ibuf[LONG_STRING * 2], obuf[LONG_STRING];\n  unsigned char hmac_response[MD5_DIGEST_LEN];\n  int len;\n  int rc;\n\n  if (!mutt_bit_isset(idata->capabilities, ACRAM_MD5))\n    return IMAP_AUTH_UNAVAIL;\n\n  mutt_message(_(\"Authenticating (CRAM-MD5)...\"));\n\n  /* get auth info */\n  if (mutt_account_getlogin(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n  if (mutt_account_getpass(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n\n  imap_cmd_start(idata, \"AUTHENTICATE CRAM-MD5\");\n\n  /* From RFC2195:\n   * The data encoded in the first ready response contains a presumptively\n   * arbitrary string of random digits, a timestamp, and the fully-qualified\n   * primary host name of the server. The syntax of the unencoded form must\n   * correspond to that of an RFC822 'msg-id' [RFC822] as described in [POP3].\n   */\n  do\n    rc = imap_cmd_step(idata);\n  while (rc == IMAP_CMD_CONTINUE);\n\n  if (rc != IMAP_CMD_RESPOND)\n  {\n    mutt_debug(1, \"Invalid response from server: %s\\n\", ibuf);\n    goto bail;\n  }\n\n  len = mutt_b64_decode(obuf, idata->buf + 2, sizeof(obuf));\n  if (len == -1)\n  {\n    mutt_debug(1, \"Error decoding base64 response.\\n\");\n    goto bail;\n  }\n\n  obuf[len] = '\\0';\n  mutt_debug(2, \"CRAM challenge: %s\\n\", obuf);\n\n  /* The client makes note of the data and then responds with a string\n   * consisting of the user name, a space, and a 'digest'. The latter is\n   * computed by applying the keyed MD5 algorithm from [KEYED-MD5] where the\n   * key is a shared secret and the digested text is the timestamp (including\n   * angle-brackets).\n   *\n   * Note: The user name shouldn't be quoted. Since the digest can't contain\n   *   spaces, there is no ambiguity. Some servers get this wrong, we'll work\n   *   around them when the bug report comes in. Until then, we'll remain\n   *   blissfully RFC-compliant.\n   */\n  hmac_md5(idata->conn->account.pass, obuf, hmac_response);\n  /* dubious optimisation I saw elsewhere: make the whole string in one call */\n  int off = snprintf(obuf, sizeof(obuf), \"%s \", idata->conn->account.user);\n  mutt_md5_toascii(hmac_response, obuf + off);\n  mutt_debug(2, \"CRAM response: %s\\n\", obuf);\n\n  /* ibuf must be long enough to store the base64 encoding of obuf,\n   * plus the additional debris */\n  mutt_b64_encode(ibuf, obuf, strlen(obuf), sizeof(ibuf) - 2);\n  mutt_str_strcat(ibuf, sizeof(ibuf), \"\\r\\n\");\n  mutt_socket_send(idata->conn, ibuf);\n\n  do\n    rc = imap_cmd_step(idata);\n  while (rc == IMAP_CMD_CONTINUE);\n\n  if (rc != IMAP_CMD_OK)\n  {\n    mutt_debug(1, \"Error receiving server response.\\n\");\n    goto bail;\n  }\n\n  if (imap_code(idata->buf))\n    return IMAP_AUTH_SUCCESS;\n\nbail:\n  mutt_error(_(\"CRAM-MD5 authentication failed.\"));\n  return IMAP_AUTH_FAILURE;\n}", "target": 3, "idx": 10778}
{"commit_id": "843d0b7a10bb45627f94764a6c5d468a24143345", "project": "OISF/suricata", "func": "static void StreamTcpPacketSetState(Packet *p, TcpSession *ssn,\n                                           uint8_t state)\n{\n    if (state == ssn->state || PKT_IS_PSEUDOPKT(p))\n        return;\n\n    ssn->pstate = ssn->state;\n    ssn->state = state;\n\n    /* update the flow state */\n    switch(ssn->state) {\n        case TCP_ESTABLISHED:\n        case TCP_FIN_WAIT1:\n        case TCP_FIN_WAIT2:\n        case TCP_CLOSING:\n        case TCP_CLOSE_WAIT:\n            FlowUpdateState(p->flow, FLOW_STATE_ESTABLISHED);\n            break;\n        case TCP_LAST_ACK:\n        case TCP_TIME_WAIT:\n        case TCP_CLOSED:\n            FlowUpdateState(p->flow, FLOW_STATE_CLOSED);\n            break;\n    }\n}", "target": 2, "idx": 10779}
{"commit_id": "7beec9a7a8a5701652b313e6e94bafd36b3627dc", "project": "ImageMagick", "func": "static Image *ReadPESImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  FILE\n    *file;\n\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    delta_x,\n    delta_y,\n    j,\n    unique_file,\n    x,\n    y;\n\n  MagickBooleanType\n    status;\n\n  PESBlockInfo\n    blocks[256];\n\n  PointInfo\n    *stitches;\n\n  SegmentInfo\n    bounds;\n\n  register ssize_t\n    i;\n\n  size_t\n    number_blocks,\n    number_colors,\n    number_stitches;\n\n  ssize_t\n    count,\n    offset;\n\n  unsigned char\n    magick[4],\n    version[4];\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Verify PES identifier.\n  */\n  count=ReadBlob(image,4,magick);\n  if ((count != 4) || (LocaleNCompare((char *) magick,\"#PES\",4) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  count=ReadBlob(image,4,version);\n  offset=ReadBlobLSBSignedLong(image);\n  if (DiscardBlobBytes(image,offset+36) == MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n  /*\n    Get PES colors.\n  */\n  number_colors=(size_t) ReadBlobByte(image)+1;\n  for (i=0; i < (ssize_t) number_colors; i++)\n  {\n    j=ReadBlobByte(image);\n    blocks[i].color=PESColor+(j < 0 ? 0 : j);\n    blocks[i].offset=0;\n  }\n  for ( ; i < 256L; i++)\n  {\n    blocks[i].offset=0;\n    blocks[i].color=PESColor;\n  }\n  if (DiscardBlobBytes(image,532L-number_colors-21) == MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n  /*\n    Stitch away.\n  */\n  number_stitches=64;\n  stitches=(PointInfo *) AcquireQuantumMemory(number_stitches,\n    sizeof(*stitches));\n  if (stitches == (PointInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  bounds.x1=65535.0;\n  bounds.y1=65535.0;\n  bounds.x2=(-65535.0);\n  bounds.y2=(-65535.0);\n  i=0;\n  j=0;\n  delta_x=0;\n  delta_y=0;\n  while (EOFBlob(image) == MagickFalse)\n  {\n    x=ReadBlobByte(image);\n    y=ReadBlobByte(image);\n    if ((x == 0xff) && (y == 0))\n      break;\n    if ((x == 254) && (y == 176))\n      {\n        /*\n          Start a new stitch block.\n        */\n        j++;\n        blocks[j].offset=(ssize_t) i;\n        if (j >= 256)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) ReadBlobByte(image);\n        continue;\n      }\n    if ((x & 0x80) == 0)\n      {\n        /*\n          Normal stitch.\n        */\n        if ((x & 0x40) != 0)\n          x-=0x80;\n      }\n    else\n      {\n        /*\n          Jump stitch.\n        */\n        x=((x & 0x0f) << 8)+y;\n        if ((x & 0x800) != 0)\n          x-=0x1000;\n        y=ReadBlobByte(image);\n      }\n    if ((y & 0x80) == 0)\n      {\n        /*\n          Normal stitch.\n        */\n        if ((y & 0x40) != 0)\n          y-=0x80;\n      }\n    else\n      {\n        /*\n          Jump stitch.\n        */\n        y=((y & 0x0f) << 8)+ReadBlobByte(image);\n        if ((y & 0x800) != 0)\n          y-=0x1000;\n      }\n    /*\n      Note stitch (x,y).\n    */\n    x+=delta_x;\n    y+=delta_y;\n    delta_x=x;\n    delta_y=y;\n    stitches[i].x=(double) x;\n    stitches[i].y=(double) y;\n    if ((double) x < bounds.x1)\n      bounds.x1=(double) x;\n    if ((double) x > bounds.x2)\n      bounds.x2=(double) x;\n    if ((double) y < bounds.y1)\n      bounds.y1=(double) y;\n    if ((double) y > bounds.y2)\n      bounds.y2=(double) y;\n    i++;\n    if (i >= (ssize_t) number_stitches)\n      {\n        /*\n          Make room for more stitches.\n        */\n        number_stitches<<=1;\n        stitches=(PointInfo *)  ResizeQuantumMemory(stitches,(size_t)\n          number_stitches,sizeof(*stitches));\n        if (stitches == (PointInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n     }\n  }\n  j++;\n  blocks[j].offset=(ssize_t) i;\n  number_blocks=(size_t) j;\n  image->columns=bounds.x2-bounds.x1;\n  image->rows=bounds.y2-bounds.y1;\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    {\n      stitches=(PointInfo *) RelinquishMagickMemory(stitches);\n      return(DestroyImageList(image));\n    }\n  /*\n    Write stitches as SVG file.\n  */\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    ThrowImageException(FileOpenError,\"UnableToCreateTemporaryFile\");\n  (void) FormatLocaleFile(file,\"<?xml version=\\\"1.0\\\"?>\\n\");\n  (void) FormatLocaleFile(file,\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" \"\n    \"xlink=\\\"http://www.w3.org/1999/xlink\\\" \"\n    \"ev=\\\"http://www.w3.org/2001/xml-events\\\" version=\\\"1.1\\\" \"\n    \"baseProfile=\\\"full\\\" width=\\\"%g\\\" height=\\\"%g\\\">\\n\",(double)\n    image->columns,(double) image->rows);\n  for (i=0; i < (ssize_t) number_blocks; i++)\n  {\n    offset=blocks[i].offset;\n    (void) FormatLocaleFile(file,\"  <path stroke=\\\"#%02x%02x%02x\\\" \"\n      \"fill=\\\"none\\\" d=\\\"M %g %g\",blocks[i].color->red,blocks[i].color->green,\n      blocks[i].color->blue,stitches[offset].x-bounds.x1,\n      stitches[offset].y-bounds.y1);\n    for (j=1; j < (ssize_t) (blocks[i+1].offset-offset); j++)\n      (void) FormatLocaleFile(file,\" L %g %g\",stitches[offset+j].x-bounds.x1,\n        stitches[offset+j].y-bounds.y1);\n    (void) FormatLocaleFile(file,\"\\\"/>\\n\");\n  }\n  (void) FormatLocaleFile(file,\"</svg>\\n\");\n  (void) fclose(file);\n  stitches=(PointInfo *) RelinquishMagickMemory(stitches);\n  (void) CloseBlob(image);\n  image=DestroyImage(image);\n  /*\n    Read SVG file.\n  */\n  read_info=CloneImageInfo(image_info);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  (void) FormatLocaleString(read_info->filename,MagickPathExtent,\"svg:%s\",\n    filename);\n  image=ReadImage(read_info,exception);\n  if (image != (Image *) NULL)\n    {\n      (void) CopyMagickString(image->filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick_filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick,\"PES\",MagickPathExtent);\n    }\n  read_info=DestroyImageInfo(read_info);\n  (void) RelinquishUniqueFileResource(filename);\n  return(GetFirstImageInList(image));\n}", "target": 1, "idx": 10780}
{"commit_id": "e4bb58cc8b6202a421e65f8230217d8ae6e16eb5", "project": "Yubico/libu2f-host", "func": "static int\ninit_device (u2fh_devs * devs, struct u2fdevice *dev)\n{\n  unsigned char resp[1024];\n  unsigned char nonce[8];\n  if (obtain_nonce(nonce) != 0)\n    {\n      return U2FH_TRANSPORT_ERROR;\n    }\n  size_t resplen = sizeof (resp);\n  dev->cid = CID_BROADCAST;\n\n  if (u2fh_sendrecv\n      (devs, dev->id, U2FHID_INIT, nonce, sizeof (nonce), resp,\n       &resplen) == U2FH_OK)\n    {\n      int offs = sizeof (nonce);\n      /* the response has to be atleast 17 bytes, if it's more we discard that */\n      if (resplen < 17)\n\t{\n\t  return U2FH_SIZE_ERROR;\n\t}\n\n      /* incoming and outgoing nonce has to match */\n      if (memcmp (nonce, resp, sizeof (nonce)) != 0)\n\t{\n\t  return U2FH_TRANSPORT_ERROR;\n\t}\n\n      dev->cid =\n\tresp[offs] << 24 | resp[offs + 1] << 16 | resp[offs +\n\t\t\t\t\t\t       2] << 8 | resp[offs +\n\t\t\t\t\t\t\t\t      3];\n      offs += 4;\n      dev->versionInterface = resp[offs++];\n      dev->versionMajor = resp[offs++];\n      dev->versionMinor = resp[offs++];\n      dev->versionBuild = resp[offs++];\n      dev->capFlags = resp[offs++];\n    }\n  else\n    {\n      return U2FH_TRANSPORT_ERROR;\n    }\n  return U2FH_OK;\n}", "target": 2, "idx": 10781}
{"commit_id": "8d385b247bca40ece40c9279391054bc98934325", "project": "xen-project/xen", "func": "static long evtchn_bind_interdomain(evtchn_bind_interdomain_t *bind)\n{\n    struct evtchn *lchn, *rchn;\n    struct domain *ld = current->domain, *rd;\n    int            lport, rport = bind->remote_port;\n    domid_t        rdom = bind->remote_dom;\n    long           rc;\n\n    if ( rdom == DOMID_SELF )\n        rdom = current->domain->domain_id;\n\n    if ( (rd = rcu_lock_domain_by_id(rdom)) == NULL )\n        return -ESRCH;\n\n    /* Avoid deadlock by first acquiring lock of domain with smaller id. */\n    if ( ld < rd )\n    {\n        spin_lock(&ld->event_lock);\n        spin_lock(&rd->event_lock);\n    }\n    else\n    {\n        if ( ld != rd )\n            spin_lock(&rd->event_lock);\n        spin_lock(&ld->event_lock);\n    }\n\n    if ( (lport = get_free_port(ld)) < 0 )\n        ERROR_EXIT(lport);\n    lchn = evtchn_from_port(ld, lport);\n\n    if ( !port_is_valid(rd, rport) )\n        ERROR_EXIT_DOM(-EINVAL, rd);\n    rchn = evtchn_from_port(rd, rport);\n    if ( (rchn->state != ECS_UNBOUND) ||\n         (rchn->u.unbound.remote_domid != ld->domain_id) )\n        ERROR_EXIT_DOM(-EINVAL, rd);\n\n    rc = xsm_evtchn_interdomain(XSM_HOOK, ld, lchn, rd, rchn);\n    if ( rc )\n        goto out;\n\n    double_evtchn_lock(lchn, rchn);\n\n    lchn->u.interdomain.remote_dom  = rd;\n    lchn->u.interdomain.remote_port = rport;\n    lchn->state                     = ECS_INTERDOMAIN;\n    evtchn_port_init(ld, lchn);\n    \n    rchn->u.interdomain.remote_dom  = ld;\n    rchn->u.interdomain.remote_port = lport;\n    rchn->state                     = ECS_INTERDOMAIN;\n\n    /*\n     * We may have lost notifications on the remote unbound port. Fix that up\n     * here by conservatively always setting a notification on the local port.\n     */\n    evtchn_port_set_pending(ld, lchn->notify_vcpu_id, lchn);\n\n    double_evtchn_unlock(lchn, rchn);\n\n    bind->local_port = lport;\n\n out:\n    check_free_port(ld, lport);\n    spin_unlock(&ld->event_lock);\n    if ( ld != rd )\n        spin_unlock(&rd->event_lock);\n    \n    rcu_unlock_domain(rd);\n\n    return rc;\n}", "target": 2, "idx": 10782}
{"commit_id": "55a45fd5039061d5cc62e9f1b9d1f7e97a15143f", "project": "sprinfall/webcc", "func": "ResponsePtr Server::ServeStatic(RequestPtr request) {\n  assert(request->method() == methods::kGet);\n\n  if (doc_root_.empty()) {\n    LOG_INFO(\"The doc root was not specified\");\n    return {};\n  }\n\n  std::string url_path = Url::DecodeUnsafe(request->url().path());\n  fs::path sub_path = utility::TranslatePath(url_path);\n  fs::path path = doc_root_ / sub_path;\n\n  try {\n    // NOTE: FileBody might throw Error::kFileError.\n    auto body = std::make_shared<FileBody>(path, file_chunk_size_);\n\n    auto response = std::make_shared<Response>(Status::kOK);\n\n    std::string extension = path.extension().string();\n    response->SetContentType(media_types::FromExtension(extension), \"\");\n\n    // NOTE: Gzip compression is not supported.\n    response->SetBody(body, true);\n\n    return response;\n\n  } catch (const Error& error) {\n    LOG_ERRO(\"File error: %s\", error.message().c_str());\n    return {};\n  }\n}", "target": 2, "idx": 10783}
{"commit_id": "6814f2e0138a6ea5e1f83bdd9085d9a77999900b", "project": "FRRouting/frr", "func": "static int bgp_attr_check(struct peer *peer, struct attr *attr,\n\t\t\t  bgp_size_t length)\n{\n\tuint8_t type = 0;\n\n\t/* BGP Graceful-Restart End-of-RIB for IPv4 unicast is signaled as an\n\t * empty UPDATE. Treat-as-withdraw, otherwise if we just ignore it,\n\t * we will pass it to be processed as a normal UPDATE without mandatory\n\t * attributes, that could lead to harmful behavior.\n\t */\n\tif (CHECK_FLAG(peer->cap, PEER_CAP_RESTART_RCV) && !attr->flag &&\n\t    !length)\n\t\treturn BGP_ATTR_PARSE_WITHDRAW;\n\n\t/* \"An UPDATE message that contains the MP_UNREACH_NLRI is not required\n\t   to carry any other path attributes.\", though if MP_REACH_NLRI or NLRI\n\t   are present, it should.  Check for any other attribute being present\n\t   instead.\n\t */\n\tif ((!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI)) &&\n\t     CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_UNREACH_NLRI))))\n\t\treturn BGP_ATTR_PARSE_PROCEED;\n\n\tif (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_ORIGIN)))\n\t\ttype = BGP_ATTR_ORIGIN;\n\n\tif (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_AS_PATH)))\n\t\ttype = BGP_ATTR_AS_PATH;\n\n\t/* RFC 2858 makes Next-Hop optional/ignored, if MP_REACH_NLRI is present\n\t * and\n\t * NLRI is empty. We can't easily check NLRI empty here though.\n\t */\n\tif (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_NEXT_HOP))\n\t    && !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI)))\n\t\ttype = BGP_ATTR_NEXT_HOP;\n\n\tif (peer->sort == BGP_PEER_IBGP\n\t    && !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF)))\n\t\ttype = BGP_ATTR_LOCAL_PREF;\n\n\t/* If any of the well-known mandatory attributes are not present\n\t * in an UPDATE message, then \"treat-as-withdraw\" MUST be used.\n\t */\n\tif (type) {\n\t\tflog_warn(EC_BGP_MISSING_ATTRIBUTE,\n\t\t\t  \"%s Missing well-known attribute %s.\", peer->host,\n\t\t\t  lookup_msg(attr_str, type, NULL));\n\t\treturn BGP_ATTR_PARSE_WITHDRAW;\n\t}\n\treturn BGP_ATTR_PARSE_PROCEED;\n}", "target": 2, "idx": 10784}
{"commit_id": "d553d92d6e9f53cbe5a34166fcb919ba652c6a8e", "project": "GNOME/glib", "func": "static void\ng_socket_client_async_connect_data_free (GSocketClientAsyncConnectData *data)\n{\n  data->task = NULL;\n  g_clear_object (&data->connectable);\n  g_clear_object (&data->enumerator);\n  g_clear_object (&data->proxy_addr);\n  g_clear_object (&data->socket);\n  g_clear_object (&data->connection);\n  g_slist_free_full (data->connection_attempts, connection_attempt_unref);\n\n  g_clear_error (&data->last_error);\n\n  g_slice_free (GSocketClientAsyncConnectData, data);\n}", "target": 1, "idx": 10785}
{"commit_id": "d1615ba11a93062b1429fce9f0f638d1572d3418", "project": "opencv", "func": "void DISOpticalFlowImpl::calc(InputArray I0, InputArray I1, InputOutputArray flow)\n{\n    CV_Assert(!I0.empty() && I0.depth() == CV_8U && I0.channels() == 1);\n    CV_Assert(!I1.empty() && I1.depth() == CV_8U && I1.channels() == 1);\n    CV_Assert(I0.sameSize(I1));\n    CV_Assert(I0.isContinuous());\n    CV_Assert(I1.isContinuous());\n\n    CV_OCL_RUN(flow.isUMat() &&\n               (patch_size == 8) && (use_spatial_propagation == true),\n               ocl_calc(I0, I1, flow));\n\n    Mat I0Mat = I0.getMat();\n    Mat I1Mat = I1.getMat();\n    bool use_input_flow = false;\n    if (flow.sameSize(I0) && flow.depth() == CV_32F && flow.channels() == 2)\n        use_input_flow = true;\n    else\n        flow.create(I1Mat.size(), CV_32FC2);\n    Mat flowMat = flow.getMat();\n    coarsest_scale = min((int)(log(max(I0Mat.cols, I0Mat.rows) / (4.0 * patch_size)) / log(2.0) + 0.5), /* Original code search for maximal movement of width/4 */\n                         (int)(log(min(I0Mat.cols, I0Mat.rows) / patch_size) / log(2.0)));              /* Deepest pyramid level greater or equal than patch*/\n\n    if (coarsest_scale<0)\n        CV_Error(cv::Error::StsBadSize, \"The input image must have either width or height >= 12\");\n\n    if (coarsest_scale<finest_scale)\n    {\n        // choose the finest level based on coarsest level.\n        // Refs: https://github.com/tikroeger/OF_DIS/blob/2c9f2a674f3128d3a41c10e41cc9f3a35bb1b523/run_dense.cpp#L239\n        int original_img_width = I0.size().width;\n        autoSelectPatchSizeAndScales(original_img_width);\n    }\n\n    int num_stripes = getNumThreads();\n\n    prepareBuffers(I0Mat, I1Mat, flowMat, use_input_flow);\n    Ux[coarsest_scale].setTo(0.0f);\n    Uy[coarsest_scale].setTo(0.0f);\n\n    for (int i = coarsest_scale; i >= finest_scale; i--)\n    {\n        w = I0s[i].cols;\n        h = I0s[i].rows;\n        ws = 1 + (w - patch_size) / patch_stride;\n        hs = 1 + (h - patch_size) / patch_stride;\n\n        precomputeStructureTensor(I0xx_buf, I0yy_buf, I0xy_buf, I0x_buf, I0y_buf, I0xs[i], I0ys[i]);\n        if (use_spatial_propagation)\n        {\n            /* Use a fixed number of stripes regardless the number of threads to make inverse search\n             * with spatial propagation reproducible\n             */\n            parallel_for_(Range(0, 8), PatchInverseSearch_ParBody(*this, 8, hs, Sx, Sy, Ux[i], Uy[i], I0s[i],\n                                                                  I1s_ext[i], I0xs[i], I0ys[i], 2, i));\n        }\n        else\n        {\n            parallel_for_(Range(0, num_stripes),\n                          PatchInverseSearch_ParBody(*this, num_stripes, hs, Sx, Sy, Ux[i], Uy[i], I0s[i], I1s_ext[i],\n                                                     I0xs[i], I0ys[i], 1, i));\n        }\n\n        parallel_for_(Range(0, num_stripes),\n                      Densification_ParBody(*this, num_stripes, I0s[i].rows, Ux[i], Uy[i], Sx, Sy, I0s[i], I1s[i]));\n        if (variational_refinement_iter > 0)\n            variational_refinement_processors[i]->calcUV(I0s[i], I1s[i], Ux[i], Uy[i]);\n\n        if (i > finest_scale)\n        {\n            resize(Ux[i], Ux[i - 1], Ux[i - 1].size());\n            resize(Uy[i], Uy[i - 1], Uy[i - 1].size());\n            Ux[i - 1] *= 2;\n            Uy[i - 1] *= 2;\n        }\n    }\n    Mat uxy[] = {Ux[finest_scale], Uy[finest_scale]};\n    merge(uxy, 2, U);\n    resize(U, flowMat, flowMat.size());\n    flowMat *= 1 << finest_scale;\n}", "target": 1, "idx": 10786}
{"commit_id": "56933f9e3e90eebf1018ed7417d6c1184b91db6b", "project": "binutils-gdb", "func": "static long\nelf_x86_64_get_synthetic_symtab (bfd *abfd,\n\t\t\t\t long symcount ATTRIBUTE_UNUSED,\n\t\t\t\t asymbol **syms ATTRIBUTE_UNUSED,\n\t\t\t\t long dynsymcount,\n\t\t\t\t asymbol **dynsyms,\n\t\t\t\t asymbol **ret)\n{\n  long size, count, i, n;\n  int j;\n  unsigned int plt_got_offset, plt_entry_size, plt_got_insn_size;\n  asymbol *s;\n  bfd_byte *plt_contents;\n  long dynrelcount, relsize;\n  arelent **dynrelbuf;\n  const struct elf_x86_64_lazy_plt_layout *lazy_plt;\n  const struct elf_x86_64_non_lazy_plt_layout *non_lazy_plt;\n  const struct elf_x86_64_lazy_plt_layout *lazy_bnd_plt;\n  const struct elf_x86_64_non_lazy_plt_layout *non_lazy_bnd_plt;\n  const struct elf_x86_64_lazy_plt_layout *lazy_ibt_plt;\n  const struct elf_x86_64_non_lazy_plt_layout *non_lazy_ibt_plt;\n  asection *plt;\n  char *names;\n  enum elf_x86_64_plt_type plt_type;\n  struct elf_x86_64_plt plts[] =\n    {\n      { \".plt\", NULL, NULL, plt_unknown, 0, 0, 0, 0 },\n      { \".plt.got\", NULL, NULL, plt_non_lazy, 0, 0, 0, 0 },\n      { \".plt.sec\", NULL, NULL, plt_second, 0, 0, 0, 0 },\n      { \".plt.bnd\", NULL, NULL, plt_second, 0, 0, 0, 0 },\n      { NULL, NULL, NULL, plt_non_lazy, 0, 0, 0, 0 }\n    };\n\n  *ret = NULL;\n\n  if ((abfd->flags & (DYNAMIC | EXEC_P)) == 0)\n    return 0;\n\n  if (dynsymcount <= 0)\n    return 0;\n\n  relsize = bfd_get_dynamic_reloc_upper_bound (abfd);\n  if (relsize <= 0)\n    return -1;\n\n  dynrelbuf = (arelent **) bfd_malloc (relsize);\n  if (dynrelbuf == NULL)\n    return -1;\n\n  dynrelcount = bfd_canonicalize_dynamic_reloc (abfd, dynrelbuf,\n\t\t\t\t\t\tdynsyms);\n  if (dynrelcount <= 0)\n    return -1;\n\n  /* Sort the relocs by address.  */\n  qsort (dynrelbuf, dynrelcount, sizeof (arelent *), compare_relocs);\n\n  if (get_elf_x86_64_backend_data (abfd)->os == is_normal)\n    {\n      lazy_plt = &elf_x86_64_lazy_plt;\n      non_lazy_plt = &elf_x86_64_non_lazy_plt;\n      lazy_bnd_plt = &elf_x86_64_lazy_bnd_plt;\n      non_lazy_bnd_plt = &elf_x86_64_non_lazy_bnd_plt;\n      if (ABI_64_P (abfd))\n\t{\n\t  lazy_ibt_plt = &elf_x86_64_lazy_ibt_plt;\n\t  non_lazy_ibt_plt = &elf_x86_64_non_lazy_ibt_plt;\n\t}\n      else\n\t{\n\t  lazy_ibt_plt = &elf_x32_lazy_ibt_plt;\n\t  non_lazy_ibt_plt = &elf_x32_non_lazy_ibt_plt;\n\t}\n    }\n  else\n    {\n      lazy_plt = &elf_x86_64_nacl_plt;\n      non_lazy_plt = NULL;\n      lazy_bnd_plt = NULL;\n      non_lazy_bnd_plt = NULL;\n      lazy_ibt_plt = NULL;\n      non_lazy_ibt_plt = NULL;\n    }\n\n  count = 0;\n  for (j = 0; plts[j].name != NULL; j++)\n    {\n      plt = bfd_get_section_by_name (abfd, plts[j].name);\n      if (plt == NULL || plt->size == 0)\n\tcontinue;\n\n      /* Get the PLT section contents.  */\n      plt_contents = (bfd_byte *) bfd_malloc (plt->size);\n      if (plt_contents == NULL)\n\tbreak;\n      if (!bfd_get_section_contents (abfd, (asection *) plt,\n\t\t\t\t     plt_contents, 0, plt->size))\n\t{\n\t  free (plt_contents);\n\t  break;\n\t}\n\n      /* Check what kind of PLT it is.  */\n      plt_type = plt_unknown;\n      if (plts[j].type == plt_unknown\n\t  && (plt->size >= (lazy_plt->plt_entry_size\n\t\t\t    + lazy_plt->plt_entry_size)))\n\t{\n\t  /* Match lazy PLT first.  Need to check the first two\n\t     instructions.   */\n\t  if ((memcmp (plt_contents, lazy_plt->plt0_entry,\n\t\t       lazy_plt->plt0_got1_offset) == 0)\n\t      && (memcmp (plt_contents + 6, lazy_plt->plt0_entry + 6,\n\t\t\t  2) == 0))\n\t    plt_type = plt_lazy;\n\t  else if (lazy_bnd_plt != NULL\n\t\t   && (memcmp (plt_contents, lazy_bnd_plt->plt0_entry,\n\t\t\t       lazy_bnd_plt->plt0_got1_offset) == 0)\n\t\t   && (memcmp (plt_contents + 6,\n\t\t\t       lazy_bnd_plt->plt0_entry + 6, 3) == 0))\n\t    {\n\t      plt_type = plt_lazy | plt_second;\n\t      /* The fist entry in the lazy IBT PLT is the same as the\n\t\t lazy BND PLT.  */\n\t      if ((memcmp (plt_contents + lazy_ibt_plt->plt_entry_size,\n\t\t\t   lazy_ibt_plt->plt_entry,\n\t\t\t   lazy_ibt_plt->plt_got_offset) == 0))\n\t\tlazy_plt = lazy_ibt_plt;\n\t      else\n\t\tlazy_plt = lazy_bnd_plt;\n\t    }\n\t}\n\n      if (non_lazy_plt != NULL\n\t  && (plt_type == plt_unknown || plt_type == plt_non_lazy)\n\t  && plt->size >= non_lazy_plt->plt_entry_size)\n\t{\n\t  /* Match non-lazy PLT.  */\n\t  if (memcmp (plt_contents, non_lazy_plt->plt_entry,\n\t\t      non_lazy_plt->plt_got_offset) == 0)\n\t    plt_type = plt_non_lazy;\n\t}\n\n      if (plt_type == plt_unknown || plt_type == plt_second)\n\t{\n\t  if (non_lazy_bnd_plt != NULL\n\t      && plt->size >= non_lazy_bnd_plt->plt_entry_size\n\t      && (memcmp (plt_contents, non_lazy_bnd_plt->plt_entry,\n\t\t\t  non_lazy_bnd_plt->plt_got_offset) == 0))\n\t    {\n\t      /* Match BND PLT.  */\n\t      plt_type = plt_second;\n\t      non_lazy_plt = non_lazy_bnd_plt;\n\t    }\n\t  else if (non_lazy_ibt_plt != NULL\n\t\t   && plt->size >= non_lazy_ibt_plt->plt_entry_size\n\t\t   && (memcmp (plt_contents,\n\t\t\t       non_lazy_ibt_plt->plt_entry,\n\t\t\t       non_lazy_ibt_plt->plt_got_offset) == 0))\n\t    {\n\t      /* Match IBT PLT.  */\n\t      plt_type = plt_second;\n\t      non_lazy_plt = non_lazy_ibt_plt;\n\t    }\n\t}\n\n      if (plt_type == plt_unknown)\n\tcontinue;\n\n      plts[j].sec = plt;\n      plts[j].type = plt_type;\n\n      if ((plt_type & plt_lazy))\n\t{\n\t  plts[j].plt_got_offset = lazy_plt->plt_got_offset;\n\t  plts[j].plt_got_insn_size = lazy_plt->plt_got_insn_size;\n\t  plts[j].plt_entry_size = lazy_plt->plt_entry_size;\n\t  /* Skip PLT0 in lazy PLT.  */\n\t  i = 1;\n\t}\n      else\n\t{\n\t  plts[j].plt_got_offset = non_lazy_plt->plt_got_offset;\n\t  plts[j].plt_got_insn_size = non_lazy_plt->plt_got_insn_size;\n\t  plts[j].plt_entry_size = non_lazy_plt->plt_entry_size;\n\t  i = 0;\n\t}\n\n      /* Skip lazy PLT when the second PLT is used.  */\n      if (plt_type == (plt_lazy | plt_second))\n\tplts[j].count = 0;\n      else\n\t{\n\t  n = plt->size / plts[j].plt_entry_size;\n\t  plts[j].count = n;\n\t  count += n - i;\n\t}\n\n      plts[j].contents = plt_contents;\n    }\n\n  if (count == 0)\n    return -1;\n\n  size = count * sizeof (asymbol);\n  s = *ret = (asymbol *) bfd_zmalloc (size);\n  if (s == NULL)\n    {\nbad_return:\n      for (j = 0; plts[j].name != NULL; j++)\n\tif (plts[j].contents != NULL)\n\t  free (plts[j].contents);\n      free (dynrelbuf);\n      return -1;\n    }\n\n  /* Check for each PLT section.  */\n  size = 0;\n  n = 0;\n  for (j = 0; plts[j].name != NULL; j++)\n    if ((plt_contents = plts[j].contents) != NULL)\n      {\n\tlong k;\n\tbfd_vma offset;\n\n\tplt_got_offset = plts[j].plt_got_offset;\n\tplt_got_insn_size = plts[j].plt_got_insn_size;\n\tplt_entry_size = plts[j].plt_entry_size;\n\n\tplt = plts[j].sec;\n\n\tif ((plts[j].type & plt_lazy))\n\t  {\n\t    /* Skip PLT0 in lazy PLT.  */\n\t    k = 1;\n\t    offset = plt_entry_size;\n\t  }\n\telse\n\t  {\n\t    k = 0;\n\t    offset = 0;\n\t  }\n\n\t/* Check each PLT entry against dynamic relocations.  */\n\tfor (; k < plts[j].count; k++)\n\t  {\n\t    int off;\n\t    bfd_vma got_vma;\n\t    long min, max, mid;\n\t    arelent *p;\n\n\t    /* Get the PC-relative offset, a signed 32-bit integer.  */\n\t    off = H_GET_32 (abfd, (plt_contents + offset\n\t\t\t\t   + plt_got_offset));\n\t    got_vma = plt->vma + offset + off + plt_got_insn_size;\n\n\t    /* Binary search.  */\n\t    p = dynrelbuf[0];\n\t    min = 0;\n\t    max = dynrelcount;\n\t    while ((min + 1) < max)\n\t      {\n\t\tarelent *r;\n\n\t\tmid = (min + max) / 2;\n\t\tr = dynrelbuf[mid];\n\t\tif (got_vma > r->address)\n\t\t  min = mid;\n\t\telse if (got_vma < r->address)\n\t\t  max = mid;\n\t\telse\n\t\t  {\n\t\t    p = r;\n\t\t    break;\n\t\t  }\n\t      }\n\n\t    /* Skip unknown relocation.  PR 17512: file: bc9d6cf5.  */\n\t    if (got_vma == p->address\n\t\t&& p->howto != NULL\n\t\t&& (p->howto->type == R_X86_64_JUMP_SLOT\n\t\t    || p->howto->type == R_X86_64_GLOB_DAT\n\t\t    || p->howto->type == R_X86_64_IRELATIVE))\n\t      {\n\t\t*s = **p->sym_ptr_ptr;\n\t\t/* Undefined syms won't have BSF_LOCAL or BSF_GLOBAL\n\t\t   set.  Since we are defining a symbol, ensure one\n\t\t   of them is set.  */\n\t\tif ((s->flags & BSF_LOCAL) == 0)\n\t\t  s->flags |= BSF_GLOBAL;\n\t\ts->flags |= BSF_SYNTHETIC;\n\t\t/* This is no longer a section symbol.  */\n\t\ts->flags &= ~BSF_SECTION_SYM;\n\t\ts->section = plt;\n\t\ts->the_bfd = plt->owner;\n\t\ts->value = offset;\n\t\t/* Store relocation for later use.  */\n\t\ts->udata.p = p;\n\t\t/* Add @plt to function name later.  */\n\t\tsize += strlen (s->name) + sizeof (\"@plt\");\n\t\tif (p->addend != 0)\n\t\t  size += sizeof (\"+0x\") - 1 + 8 + 8 * ABI_64_P (abfd);\n\t\tn++;\n\t\ts++;\n\t\t/* There should be only one entry in PLT for a given\n\t\t   symbol.  Set howto to NULL after processing a PLT\n\t\t   entry to guard against corrupted PLT.  */\n\t\tp->howto = NULL;\n\t      }\n\t    offset += plt_entry_size;\n\t  }\n      }\n\n  /* PLT entries with R_X86_64_TLSDESC relocations are skipped.  */\n  if (n == 0)\n    goto bad_return;\n\n  count = n;\n\n  /* Allocate space for @plt suffixes.  */\n  names = (char *) bfd_malloc (size);\n  if (s == NULL)\n    goto bad_return;\n\n  s = *ret;\n  for (i = 0; i < count; i++)\n    {\n      /* Add @plt to function name.  */\n      arelent *p = (arelent *) s->udata.p;\n      /* Clear it now.  */\n      s->udata.p = NULL;\n      size = strlen (s->name);\n      memcpy (names, s->name, size);\n      s->name = names;\n      names += size;\n      if (p->addend != 0)\n\t{\n\t  char buf[30], *a;\n\n\t  memcpy (names, \"+0x\", sizeof (\"+0x\") - 1);\n\t  names += sizeof (\"+0x\") - 1;\n\t  bfd_sprintf_vma (abfd, buf, p->addend);\n\t  for (a = buf; *a == '0'; ++a)\n\t    ;\n\t  size = strlen (a);\n\t  memcpy (names, a, size);\n\t  names += size;\n\t}\n      memcpy (names, \"@plt\", sizeof (\"@plt\"));\n      names += sizeof (\"@plt\");\n      s++;\n    }\n\n  for (j = 0; plts[j].name != NULL; j++)\n    if (plts[j].contents != NULL)\n      free (plts[j].contents);\n\n  free (dynrelbuf);\n\n  return count;\n}", "target": 2, "idx": 10787}
{"commit_id": "1e84674d95353c64e5c4c0e7232ae86fd6ea813b", "project": "jasper-software/jasper", "func": "long jpc_bitstream_getbits(jpc_bitstream_t *bitstream, int n)\n{\n\tlong v;\n\tint u;\n\n\t/* We can reliably get at most 31 bits since ISO/IEC 9899 only\n\t  guarantees that a long can represent values up to 2^31-1. */\n\t//assert(n >= 0 && n < 32);\n\tif (n < 0 || n >= 32) {\n\t\treturn -1;\n\t}\n\n\t/* Get the number of bits requested from the specified bit stream. */\n\tv = 0;\n\twhile (--n >= 0) {\n\t\tif ((u = jpc_bitstream_getbit(bitstream)) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tv = (v << 1) | u;\n\t}\n\treturn v;\n}", "target": 2, "idx": 10788}
{"commit_id": "fb85040405495748dbc7c4850b97da9b67b7b47b", "project": "meetecho/janus-gateway", "func": "const char *janus_rtp_header_extension_get_from_id(const char *sdp, int id) {\n\tif(!sdp || id < 0)\n\t\treturn NULL;\n\t/* Look for the mapping */\n\tchar extmap[100];\n\tg_snprintf(extmap, 100, \"a=extmap:%d \", id);\n\tconst char *line = strstr(sdp, \"m=\");\n\twhile(line) {\n\t\tchar *next = strchr(line, '\\n');\n\t\tif(next) {\n\t\t\t*next = '\\0';\n\t\t\tif(strstr(line, extmap)) {\n\t\t\t\t/* Gotcha! */\n\t\t\t\tchar extension[100];\n\t\t\t\tif(sscanf(line, \"a=extmap:%d %99s\", &id, extension) == 2) {\n\t\t\t\t\t*next = '\\n';\n\t\t\t\t\tif(strstr(extension, JANUS_RTP_EXTMAP_AUDIO_LEVEL))\n\t\t\t\t\t\treturn JANUS_RTP_EXTMAP_AUDIO_LEVEL;\n\t\t\t\t\tif(strstr(extension, JANUS_RTP_EXTMAP_VIDEO_ORIENTATION))\n\t\t\t\t\t\treturn JANUS_RTP_EXTMAP_VIDEO_ORIENTATION;\n\t\t\t\t\tif(strstr(extension, JANUS_RTP_EXTMAP_PLAYOUT_DELAY))\n\t\t\t\t\t\treturn JANUS_RTP_EXTMAP_PLAYOUT_DELAY;\n\t\t\t\t\tif(strstr(extension, JANUS_RTP_EXTMAP_TOFFSET))\n\t\t\t\t\t\treturn JANUS_RTP_EXTMAP_TOFFSET;\n\t\t\t\t\tif(strstr(extension, JANUS_RTP_EXTMAP_ABS_SEND_TIME))\n\t\t\t\t\t\treturn JANUS_RTP_EXTMAP_ABS_SEND_TIME;\n\t\t\t\t\tif(strstr(extension, JANUS_RTP_EXTMAP_TRANSPORT_WIDE_CC))\n\t\t\t\t\t\treturn JANUS_RTP_EXTMAP_TRANSPORT_WIDE_CC;\n\t\t\t\t\tif(strstr(extension, JANUS_RTP_EXTMAP_MID))\n\t\t\t\t\t\treturn JANUS_RTP_EXTMAP_MID;\n\t\t\t\t\tif(strstr(extension, JANUS_RTP_EXTMAP_RID))\n\t\t\t\t\t\treturn JANUS_RTP_EXTMAP_RID;\n\t\t\t\t\tif(strstr(extension, JANUS_RTP_EXTMAP_REPAIRED_RID))\n\t\t\t\t\t\treturn JANUS_RTP_EXTMAP_REPAIRED_RID;\n\t\t\t\t\tJANUS_LOG(LOG_ERR, \"Unsupported extension '%s'\\n\", extension);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\t*next = '\\n';\n\t\t}\n\t\tline = next ? (next+1) : NULL;\n\t}\n\treturn NULL;\n}", "target": 3, "idx": 10789}
{"commit_id": "dd88504804e186029f845a166dc5c31695e2cca2", "project": "projectacrn/acrn-hypervisor", "func": "static void\nvirtio_input_teardown(void *param)\n{\n\tstruct virtio_input *vi;\n\n\tvi = (struct virtio_input *)param;\n\tif (vi) {\n\t\tpthread_mutex_destroy(&vi->mtx);\n\t\tif (vi->event_queue)\n\t\t\tfree(vi->event_queue);\n\t\tif (vi->fd > 0)\n\t\t\tclose(vi->fd);\n\t\tif (vi->evdev)\n\t\t\tfree(vi->evdev);\n\t\tif (vi->serial)\n\t\t\tfree(vi->serial);\n\n\t\tvirtio_input_reset(vi);\n\t\tfree(vi);\n\t\tvi = NULL;\n\t}\n}", "target": 2, "idx": 10790}
{"commit_id": "f2a7af8d3928e18ef15778e63b9b6c78f8bd1bef", "project": "wireshark", "func": "static int\ndissect_openflow_match_v5(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int offset, guint16 length _U_)\n{\n    proto_item *ti;\n    proto_tree *match_tree;\n    guint16 match_type;\n    guint16 match_length;\n    gint32 fields_end;\n    guint16 pad_length;\n\n    match_tree = proto_tree_add_subtree(tree, tvb, offset, -1, ett_openflow_v5_match, &ti, \"Match\");\n\n    /* uint16_t type; */\n    match_type = tvb_get_ntohs(tvb, offset);\n    proto_tree_add_item(match_tree, hf_openflow_v5_match_type, tvb, offset, 2, ENC_BIG_ENDIAN);\n    offset+=2;\n\n    /* uint16_t length; (excluding padding) */\n    match_length = tvb_get_ntohs(tvb, offset);\n    pad_length = (match_length + 7)/8*8 - match_length;\n    proto_item_set_len(ti, match_length + pad_length);\n    ti = proto_tree_add_item(match_tree, hf_openflow_v5_match_length, tvb, offset, 2, ENC_BIG_ENDIAN);\n    offset+=2;\n\n    if (match_length < 4) {\n        expert_add_info(pinfo, ti, &ei_openflow_v5_length_too_short);\n        return offset;\n    }\n\n    /* body */\n    switch (match_type) {\n    case OFPMT_STANDARD:\n        proto_tree_add_expert_format(match_tree, pinfo, &ei_openflow_v5_match_undecoded,\n                                     tvb, offset, match_length - 4, \"Standard match body (deprecated).\");\n        offset+=match_length-4;\n        break;\n\n    case OFPMT_OXM:\n        fields_end = offset + match_length - 4;\n        while(offset < fields_end) {\n            offset = dissect_openflow_oxm_v5(tvb, pinfo, match_tree, offset, length);\n        }\n        break;\n\n    default:\n        proto_tree_add_expert_format(match_tree, pinfo, &ei_openflow_v5_match_undecoded,\n                                     tvb, offset, match_length - 4, \"Unknown match body.\");\n        offset+=match_length-4;\n        break;\n    }\n\n    /* pad; Exactly ((length + 7)/8*8 - length) (between 0 and 7) bytes of all-zero bytes. */\n    if (pad_length > 0) {\n        proto_tree_add_item(match_tree, hf_openflow_v5_match_pad, tvb, offset, pad_length, ENC_NA);\n        offset+=pad_length;\n    }\n\n    return offset;\n}", "target": 1, "idx": 10791}
{"commit_id": "a062006b9de0b2947ab5fb376c6e67ef92a8cd69", "project": "vim", "func": "static void\nn_start_visual_mode(int c)\n{\n#ifdef FEAT_CONCEAL\n    int cursor_line_was_concealed = curwin->w_p_cole > 0\n\t\t\t\t\t\t&& conceal_cursor_line(curwin);\n#endif\n\n    VIsual_mode = c;\n    VIsual_active = TRUE;\n    VIsual_reselect = TRUE;\n\n    // Corner case: the 0 position in a tab may change when going into\n    // virtualedit.  Recalculate curwin->w_cursor to avoid bad highlighting.\n    if (c == Ctrl_V && (get_ve_flags() & VE_BLOCK) && gchar_cursor() == TAB)\n    {\n\tvalidate_virtcol();\n\tcoladvance(curwin->w_virtcol);\n    }\n    VIsual = curwin->w_cursor;\n\n#ifdef FEAT_FOLDING\n    foldAdjustVisual();\n#endif\n\n    trigger_modechanged();\n    setmouse();\n#ifdef FEAT_CONCEAL\n    // Check if redraw is needed after changing the state.\n    conceal_check_cursor_line(cursor_line_was_concealed);\n#endif\n\n    if (p_smd && msg_silent == 0)\n\tredraw_cmdline = TRUE;\t// show visual mode later\n#ifdef FEAT_CLIPBOARD\n    // Make sure the clipboard gets updated.  Needed because start and\n    // end may still be the same, and the selection needs to be owned\n    clip_star.vmode = NUL;\n#endif\n\n    // Only need to redraw this line, unless still need to redraw an old\n    // Visual area (when 'lazyredraw' is set).\n    if (curwin->w_redr_type < INVERTED)\n    {\n\tcurwin->w_old_cursor_lnum = curwin->w_cursor.lnum;\n\tcurwin->w_old_visual_lnum = curwin->w_cursor.lnum;\n    }\n}", "target": 2, "idx": 10792}
{"commit_id": "338da1c0ea0b2f8595d3a7b6d6c9548f7da3e27b", "project": "wireshark", "func": "static gint64 ascend_seek(wtap *wth, int *err, gchar **err_info)\n{\n  int byte;\n  gint64 date_off = -1, cur_off, packet_off;\n  size_t string_level[ASCEND_MAGIC_STRINGS];\n  guint string_i = 0, type = 0;\n  guint excessive_read_count = 262144;\n\n  memset(&string_level, 0, sizeof(string_level));\n\n  while (((byte = file_getc(wth->fh)) != EOF)) {\n    excessive_read_count--;\n\n    if (!excessive_read_count) {\n      *err = 0;\n      return -1;\n    }\n\n    for (string_i = 0; string_i < ASCEND_MAGIC_STRINGS; string_i++) {\n      const gchar *strptr = ascend_magic[string_i].strptr;\n      size_t len          = strlen(strptr);\n\n      if (byte == *(strptr + string_level[string_i])) {\n        string_level[string_i]++;\n        if (string_level[string_i] >= len) {\n          cur_off = file_tell(wth->fh);\n          if (cur_off == -1) {\n            /* Error. */\n            *err = file_error(wth->fh, err_info);\n            return -1;\n          }\n\n          /* Date: header is a special case. Remember the offset,\n             but keep looking for other headers. */\n          if (strcmp(strptr, ASCEND_DATE) == 0) {\n            date_off = cur_off - len;\n            string_level[string_i] = 0;\n          } else {\n            if (date_off == -1) {\n              /* Back up over the header we just read; that's where a read\n                 of this packet should start. */\n              packet_off = cur_off - len;\n            } else {\n              /* This packet has a date/time header; a read of it should\n                 start at the beginning of *that* header. */\n              packet_off = date_off;\n            }\n\n            type = ascend_magic[string_i].type;\n            goto found;\n          }\n        }\n      } else {\n        string_level[string_i] = 0;\n      }\n    }\n  }\n\n  *err = file_error(wth->fh, err_info);\n  return -1;\n\nfound:\n  /*\n   * Move to where the read for this packet should start, and return\n   * that seek offset.\n   */\n  if (file_seek(wth->fh, packet_off, SEEK_SET, err) == -1)\n    return -1;\n\n  wth->phdr.pseudo_header.ascend.type = type;\n\n  return packet_off;\n}", "target": 1, "idx": 10793}
{"commit_id": "e8d5f92b8d30bb4ade76494490c3c065e12411b1", "project": "torvalds/linux", "func": "static void gprinter_free(struct usb_function *f)\n{\n\tstruct printer_dev *dev = func_to_printer(f);\n\tstruct f_printer_opts *opts;\n\n\topts = container_of(f->fi, struct f_printer_opts, func_inst);\n\n\tkref_put(&dev->kref, printer_dev_free);\n\tmutex_lock(&opts->lock);\n\t--opts->refcnt;\n\tmutex_unlock(&opts->lock);\n}", "target": 1, "idx": 10794}
{"commit_id": "a014f4c224a7b21f1c648257d1fd1128413129aa", "project": "PowerDNS/pdns", "func": "void CommunicatorClass::suck(const string &domain,const string &remote)\n{\n  L<<Logger::Error<<\"Initiating transfer of '\"<<domain<<\"' from remote '\"<<remote<<\"'\"<<endl;\n  UeberBackend B; // fresh UeberBackend\n\n  DomainInfo di;\n  di.backend=0;\n  bool transaction=false;\n  try {\n    DNSSECKeeper dk (&B); // reuse our UeberBackend copy for DNSSECKeeper\n\n    if(!B.getDomainInfo(domain, di) || !di.backend) { // di.backend and B are mostly identical\n      L<<Logger::Error<<\"Can't determine backend for domain '\"<<domain<<\"'\"<<endl;\n      return;\n    }\n    uint32_t domain_id=di.id;\n\n\n    string tsigkeyname, tsigalgorithm, tsigsecret;\n    if(dk.getTSIGForAccess(domain, remote, &tsigkeyname)) {\n      string tsigsecret64;\n      if(B.getTSIGKey(tsigkeyname, &tsigalgorithm, &tsigsecret64)) {\n        B64Decode(tsigsecret64, tsigsecret);\n      } else {\n        L<<Logger::Error<<\"TSIG key '\"<<tsigkeyname<<\"' for domain '\"<<domain<<\"' not found\"<<endl;\n        return;\n      }\n    }\n\n\n    scoped_ptr<AuthLua> pdl;\n    vector<string> scripts;\n    if(B.getDomainMetadata(domain, \"LUA-AXFR-SCRIPT\", scripts) && !scripts.empty()) {\n      try {\n        pdl.reset(new AuthLua(scripts[0]));\n        L<<Logger::Info<<\"Loaded Lua script '\"<<scripts[0]<<\"' to edit the incoming AXFR of '\"<<domain<<\"'\"<<endl;\n      }\n      catch(std::exception& e) {\n        L<<Logger::Error<<\"Failed to load Lua editing script '\"<<scripts[0]<<\"' for incoming AXFR of '\"<<domain<<\"': \"<<e.what()<<endl;\n        return;\n      }\n    }\n\n\n    vector<string> localaddr;\n    ComboAddress laddr;\n    if(B.getDomainMetadata(domain, \"AXFR-SOURCE\", localaddr) && !localaddr.empty()) {\n      try {\n        laddr = ComboAddress(localaddr[0]);\n        L<<Logger::Info<<\"AXFR source for domain '\"<<domain<<\"' set to \"<<localaddr[0]<<endl;\n      }\n      catch(std::exception& e) {\n        L<<Logger::Error<<\"Failed to load AXFR source '\"<<localaddr[0]<<\"' for incoming AXFR of '\"<<domain<<\"': \"<<e.what()<<endl;\n        return;\n      }\n    } else {\n      laddr.sin4.sin_family = 0;\n    }\n\n\n    bool hadDnssecZone = false;\n    bool hadPresigned = false;\n    bool hadNSEC3 = false;\n    NSEC3PARAMRecordContent ns3pr, hadNs3pr;\n    bool isNarrow, hadNarrow=false;\n\n    if(dk.isSecuredZone(domain)) {\n      hadDnssecZone=true;\n      hadPresigned=dk.isPresigned(domain);\n      if (dk.getNSEC3PARAM(domain, &ns3pr, &isNarrow)) {\n        hadNSEC3 = true;\n        hadNs3pr = ns3pr;\n        hadNarrow = isNarrow;\n      }\n    }\n\n\n    bool isDnssecZone = false;\n    bool isPresigned = false;\n    bool isNSEC3 = false;\n    bool optOutFlag = false;\n\n    bool first=true;\n    bool firstNSEC3=true;\n    unsigned int soa_serial = 0;\n    set<string> nsset, qnames, secured;\n    vector<DNSResourceRecord> rrs;\n\n    ComboAddress raddr(remote, 53);\n    AXFRRetriever retriever(raddr, domain.c_str(), tsigkeyname, tsigalgorithm, tsigsecret, (laddr.sin4.sin_family == 0) ? NULL : &laddr, ((size_t) ::arg().asNum(\"xfr-max-received-mbytes\")) * 1024 * 1024);\n    Resolver::res_t recs;\n    while(retriever.getChunk(recs)) {\n      if(first) {\n        L<<Logger::Error<<\"AXFR started for '\"<<domain<<\"'\"<<endl;\n        first=false;\n      }\n\n      for(Resolver::res_t::iterator i=recs.begin();i!=recs.end();++i) {\n        if(i->qtype.getCode() == QType::OPT || i->qtype.getCode() == QType::TSIG) // ignore EDNS0 & TSIG\n          continue;\n\n        if(!endsOn(i->qname, domain)) {\n          L<<Logger::Error<<\"Remote \"<<remote<<\" tried to sneak in out-of-zone data '\"<<i->qname<<\"'|\"<<i->qtype.getName()<<\" during AXFR of zone '\"<<domain<<\"', ignoring\"<<endl;\n          continue;\n        }\n\n        vector<DNSResourceRecord> out;\n        if(!pdl || !pdl->axfrfilter(raddr, domain, *i, out)) {\n          out.push_back(*i);\n        }\n\n        BOOST_FOREACH(DNSResourceRecord& rr, out) {\n          switch(rr.qtype.getCode()) {\n            case QType::NSEC3PARAM: {\n              ns3pr = NSEC3PARAMRecordContent(rr.content);\n              isDnssecZone = isNSEC3 = true;\n              isNarrow = false;\n              continue;\n            }\n            case QType::NSEC3: {\n              NSEC3RecordContent ns3rc(rr.content);\n              if (firstNSEC3) {\n                isDnssecZone = isPresigned = true;\n                firstNSEC3 = false;\n              } else if (optOutFlag != (ns3rc.d_flags & 1))\n                throw PDNSException(\"Zones with a mixture of Opt-Out NSEC3 RRs and non-Opt-Out NSEC3 RRs are not supported.\");\n              optOutFlag = ns3rc.d_flags & 1;\n              if (ns3rc.d_set.count(QType::NS) && !pdns_iequals(rr.qname, domain))\n                secured.insert(toLower(makeRelative(rr.qname, domain)));\n              continue;\n            }\n            case QType::NSEC: {\n              isDnssecZone = isPresigned = true;\n              continue;\n            }\n            case QType::SOA: {\n              if(soa_serial != 0)\n                continue; //skip the last SOA\n              SOAData sd;\n              fillSOAData(rr.content,sd);\n              soa_serial = sd.serial;\n              break;\n            }\n            case QType::NS: {\n              if(!pdns_iequals(rr.qname, domain))\n                nsset.insert(rr.qname);\n              break;\n            }\n            default:\n              break;\n          }\n\n          qnames.insert(rr.qname);\n\n          rr.domain_id=domain_id;\n          rrs.push_back(rr);\n        }\n      }\n    }\n\n    if(isNSEC3) {\n      ns3pr.d_flags = optOutFlag ? 1 : 0;\n    }\n\n\n    if(!isPresigned) {\n      DNSSECKeeper::keyset_t keys = dk.getKeys(domain);\n      if(!keys.empty()) {\n        isDnssecZone = true;\n        isNSEC3 = hadNSEC3;\n        ns3pr = hadNs3pr;\n        optOutFlag = (hadNs3pr.d_flags & 1);\n        isNarrow = hadNarrow;\n      }\n    }\n\n\n    if(isDnssecZone) {\n      if(!isNSEC3)\n        L<<Logger::Info<<\"Adding NSEC ordering information\"<<endl;\n      else if(!isNarrow)\n        L<<Logger::Info<<\"Adding NSEC3 hashed ordering information for '\"<<domain<<\"'\"<<endl;\n      else\n        L<<Logger::Info<<\"Erasing NSEC3 ordering since we are narrow, only setting 'auth' fields\"<<endl;\n    }\n\n\n    transaction=di.backend->startTransaction(domain, domain_id);\n    L<<Logger::Error<<\"Transaction started for '\"<<domain<<\"'\"<<endl;\n\n    // update the presigned flag and NSEC3PARAM\n    if (isDnssecZone) {\n      // update presigned if there was a change\n      if (isPresigned && !hadPresigned) {\n        // zone is now presigned\n        dk.setPresigned(domain);\n      } else if (hadPresigned && !isPresigned) {\n        // zone is no longer presigned\n        dk.unsetPresigned(domain);\n      }\n      // update NSEC3PARAM\n      if (isNSEC3) {\n        // zone is NSEC3, only update if there was a change\n        if (!hadNSEC3 || (hadNarrow  != isNarrow) ||\n            (ns3pr.d_algorithm != hadNs3pr.d_algorithm) ||\n            (ns3pr.d_flags != hadNs3pr.d_flags) ||\n            (ns3pr.d_iterations != hadNs3pr.d_iterations) ||\n            (ns3pr.d_salt != hadNs3pr.d_salt)) {\n          dk.setNSEC3PARAM(domain, ns3pr, isNarrow);\n        }\n      } else if (hadNSEC3 ) {\n         // zone is no longer NSEC3\n         dk.unsetNSEC3PARAM(domain);\n      }\n    } else if (hadDnssecZone) {\n      // zone is no longer signed\n      if (hadPresigned) {\n        // remove presigned\n        dk.unsetPresigned(domain);\n      }\n      if (hadNSEC3) {\n        // unset NSEC3PARAM\n        dk.unsetNSEC3PARAM(domain);\n      }\n    }\n\n    bool doent=true;\n    uint32_t maxent = ::arg().asNum(\"max-ent-entries\");\n    string ordername, shorter;\n    set<string> rrterm;\n    map<string,bool> nonterm;\n\n\n    BOOST_FOREACH(DNSResourceRecord& rr, rrs) {\n\n      if(!isPresigned) {\n        if (rr.qtype.getCode() == QType::RRSIG)\n          continue;\n        if(isDnssecZone && rr.qtype.getCode() == QType::DNSKEY && !::arg().mustDo(\"direct-dnskey\"))\n          continue;\n      }\n\n      // Figure out auth and ents\n      rr.auth=true;\n      shorter=rr.qname;\n      rrterm.clear();\n      do {\n        if(doent) {\n          if (!qnames.count(shorter))\n            rrterm.insert(shorter);\n        }\n        if(nsset.count(shorter) && rr.qtype.getCode() != QType::DS)\n          rr.auth=false;\n\n        if (pdns_iequals(shorter, domain)) // stop at apex\n          break;\n      }while(chopOff(shorter));\n\n      // Insert ents\n      if(doent && !rrterm.empty()) {\n        bool auth;\n        if (!rr.auth && rr.qtype.getCode() == QType::NS) {\n          if (isNSEC3)\n            ordername=toBase32Hex(hashQNameWithSalt(ns3pr.d_iterations, ns3pr.d_salt, rr.qname));\n          auth=(!isNSEC3 || !optOutFlag || secured.count(ordername));\n        } else\n          auth=rr.auth;\n\n        BOOST_FOREACH(const string nt, rrterm){\n          if (!nonterm.count(nt))\n              nonterm.insert(pair<string, bool>(nt, auth));\n            else if (auth)\n              nonterm[nt]=true;\n        }\n\n        if(nonterm.size() > maxent) {\n          L<<Logger::Error<<\"AXFR zone \"<<domain<<\" has too many empty non terminals.\"<<endl;\n          nonterm.clear();\n          doent=false;\n        }\n      }\n\n      // RRSIG is always auth, even inside a delegation\n      if (rr.qtype.getCode() == QType::RRSIG)\n        rr.auth=true;\n\n      // Add ordername and insert record\n      if (isDnssecZone && rr.qtype.getCode() != QType::RRSIG) {\n        if (isNSEC3) {\n          // NSEC3\n          ordername=toBase32Hex(hashQNameWithSalt(ns3pr.d_iterations, ns3pr.d_salt, rr.qname));\n          if(!isNarrow && (rr.auth || (rr.qtype.getCode() == QType::NS && (!optOutFlag || secured.count(ordername))))) {\n            di.backend->feedRecord(rr, &ordername);\n          } else\n            di.backend->feedRecord(rr);\n        } else {\n          // NSEC\n          if (rr.auth || rr.qtype.getCode() == QType::NS) {\n            ordername=toLower(labelReverse(makeRelative(rr.qname, domain)));\n            di.backend->feedRecord(rr, &ordername);\n          } else\n            di.backend->feedRecord(rr);\n        }\n      } else\n        di.backend->feedRecord(rr);\n    }\n\n    // Insert empty non-terminals\n    if(doent && !nonterm.empty()) {\n      if (isNSEC3) {\n        di.backend->feedEnts3(domain_id, domain, nonterm, ns3pr.d_iterations, ns3pr.d_salt, isNarrow);\n      } else\n        di.backend->feedEnts(domain_id, nonterm);\n    }\n\n    di.backend->commitTransaction();\n    transaction = false;\n    di.backend->setFresh(domain_id);\n    PC.purge(domain+\"$\");\n\n\n    L<<Logger::Error<<\"AXFR done for '\"<<domain<<\"', zone committed with serial number \"<<soa_serial<<endl;\n    if(::arg().mustDo(\"slave-renotify\"))\n      notifyDomain(domain);\n  }\n  catch(DBException &re) {\n    L<<Logger::Error<<\"Unable to feed record during incoming AXFR of '\"+domain+\"': \"<<re.reason<<endl;\n    if(di.backend && transaction) {\n      L<<Logger::Error<<\"Aborting possible open transaction for domain '\"<<domain<<\"' AXFR\"<<endl;\n      di.backend->abortTransaction();\n    }\n  }\n  catch(MOADNSException &re) {\n    L<<Logger::Error<<\"Unable to parse record during incoming AXFR of '\"+domain+\"' (MOADNSException): \"<<re.what()<<endl;\n    if(di.backend && transaction) {\n      L<<Logger::Error<<\"Aborting possible open transaction for domain '\"<<domain<<\"' AXFR\"<<endl;\n      di.backend->abortTransaction();\n    }\n  }\n  catch(std::exception &re) {\n    L<<Logger::Error<<\"Unable to parse record during incoming AXFR of '\"+domain+\"' (std::exception): \"<<re.what()<<endl;\n    if(di.backend && transaction) {\n      L<<Logger::Error<<\"Aborting possible open transaction for domain '\"<<domain<<\"' AXFR\"<<endl;\n      di.backend->abortTransaction();\n    }\n  }\n  catch(ResolverException &re) {\n    L<<Logger::Error<<\"Unable to AXFR zone '\"+domain+\"' from remote '\"<<remote<<\"' (resolver): \"<<re.reason<<endl;\n    if(di.backend && transaction) {\n      L<<Logger::Error<<\"Aborting possible open transaction for domain '\"<<domain<<\"' AXFR\"<<endl;\n      di.backend->abortTransaction();\n    }\n  }\n  catch(PDNSException &ae) {\n    L<<Logger::Error<<\"Unable to AXFR zone '\"+domain+\"' from remote '\"<<remote<<\"' (PDNSException): \"<<ae.reason<<endl;\n    if(di.backend && transaction) {\n      L<<Logger::Error<<\"Aborting possible open transaction for domain '\"<<domain<<\"' AXFR\"<<endl;\n      di.backend->abortTransaction();\n    }\n  }\n}", "target": 1, "idx": 10795}
{"commit_id": "6709d4b7bc2e079241fdef15d1160581c5261c10", "project": "torvalds/linux", "func": "void nfc_llcp_mac_is_up(struct nfc_dev *dev, u32 target_idx,\n\t\t\tu8 comm_mode, u8 rf_mode)\n{\n\tstruct nfc_llcp_local *local;\n\n\tpr_debug(\"rf mode %d\\n\", rf_mode);\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL)\n\t\treturn;\n\n\tlocal->target_idx = target_idx;\n\tlocal->comm_mode = comm_mode;\n\tlocal->rf_mode = rf_mode;\n\n\tif (rf_mode == NFC_RF_INITIATOR) {\n\t\tpr_debug(\"Queueing Tx work\\n\");\n\n\t\tschedule_work(&local->tx_work);\n\t} else {\n\t\tmod_timer(&local->link_timer,\n\t\t\t  jiffies + msecs_to_jiffies(local->remote_lto));\n\t}\n\n\tnfc_llcp_local_put(local);\n}", "target": 1, "idx": 10796}
{"commit_id": "2935e0a3cec1ffa558eea90db6279cff83aa3592", "project": "torvalds/linux", "func": "int romfs_dev_read(struct super_block *sb, unsigned long pos,\n\t\t   void *buf, size_t buflen)\n{\n\tsize_t limit;\n\n\tlimit = romfs_maxsize(sb);\n\tif (pos >= limit || buflen > limit - pos)\n\t\treturn -EIO;\n\n#ifdef CONFIG_ROMFS_ON_MTD\n\tif (sb->s_mtd)\n\t\treturn romfs_mtd_read(sb, pos, buf, buflen);\n#endif\n#ifdef CONFIG_ROMFS_ON_BLOCK\n\tif (sb->s_bdev)\n\t\treturn romfs_blk_read(sb, pos, buf, buflen);\n#endif\n\treturn -EIO;\n}", "target": 0, "idx": 10797}
{"commit_id": "c62e7bcb3ae9d8ef1a94c2fbb143019d647f6304", "project": "google/google-api-cpp-client", "func": "util::Status OAuth2Credential::UpdateFromString(const string& json) {\n  OAuth2AuthorizationFlow::SimpleJsonData data;\n  googleapis::util::Status status = data.Init(json);\n  if (!status.ok()) return status;\n\n  string str_value;\n  int int_value;\n\n  if (data.GetString(\"refresh_token\", &str_value)) {\n    VLOG(1) << \"Updating refresh token\";\n    refresh_token_.set(str_value);\n  }\n  if (data.GetString(\"access_token\", &str_value)) {\n    access_token_.set(str_value);\n    VLOG(1) << \"Updating access token\";\n  }\n  if (data.GetString(\"expires_at\", &str_value)) {\n    int64 timestamp;\n    if (!safe_strto64(str_value.c_str(), &timestamp)) {\n      LOG(ERROR) << \"Invalid timestamp=[\" << str_value << \"]\";\n    } else {\n      expiration_timestamp_secs_.set(timestamp);\n      VLOG(1) << \"Updating access token expiration\";\n    }\n  } else if (data.GetScalar(\"exp\", &int_value)) {\n    int64 timestamp = int_value;\n    expiration_timestamp_secs_.set(timestamp);\n    VLOG(1) << \"Updating access token expiration\";\n  } else if (data.GetScalar(\"expires_in\", &int_value)) {\n    int64 now = DateTime().ToEpochTime();\n    int64 expiration = now + int_value;\n    expiration_timestamp_secs_.set(expiration);\n    VLOG(1) << \"Updating access token expiration\";\n  }\n  if (data.GetString(\"email\", &str_value)) {\n    string bool_str;\n    // Read this as a string because OAuth2 server returns it as\n    // a true/false string.\n    data.GetString(\"email_verified\", &bool_str);\n\n    email_ = str_value;\n    email_verified_ = bool_str == \"true\";\n  }\n\n  if (data.GetString(\"id_token\", &str_value)) {\n    // Extract additional stuff from the JWT claims.\n    // We dont need to verify the signature since we already know\n    // this is coming from the OAuth2 server and is secure with https.\n    // see https://developers.google.com/accounts/docs/OAuth2Login\n    //     #validatinganidtoken\n    int dot_positions[3];\n    int n_dots = 0;\n    for (size_t i = 0; i < str_value.size(); ++i) {\n      if (str_value[i] == '.') {\n        dot_positions[n_dots] = i;\n        ++n_dots;\n        if (n_dots == 3) break;\n      }\n    }\n    if (n_dots != 2) {\n      return StatusUnknown(\"Invalid id_token attribute - not a JWT\");\n    }\n    string claims;\n    const char *claims_start = str_value.data() + dot_positions[0] + 1;\n    size_t claims_len = dot_positions[1] - dot_positions[0] - 1;\n    if (!googleapis_util::Base64Unescape(claims_start, claims_len, &claims)) {\n      return StatusUnknown(\"id_token claims not base-64 encoded\");\n    }\n    return UpdateFromString(claims);\n  }\n\n  return StatusOk();\n}", "target": 2, "idx": 10798}
{"commit_id": "889f6af37164775192e33b233a90e86fd3df0f57", "project": "vim", "func": "static int\ndo_addsub(\n    int\t\top_type,\n    pos_T\t*pos,\n    int\t\tlength,\n    linenr_T\tPrenum1)\n{\n    int\t\tcol;\n    char_u\t*buf1;\n    char_u\tbuf2[NUMBUFLEN];\n    int\t\tpre;\t\t// 'X'/'x': hex; '0': octal; 'B'/'b': bin\n    static int\thexupper = FALSE;\t// 0xABC\n    uvarnumber_T\tn;\n    uvarnumber_T\toldn;\n    char_u\t*ptr;\n    int\t\tc;\n    int\t\ttodel;\n    int\t\tdo_hex;\n    int\t\tdo_oct;\n    int\t\tdo_bin;\n    int\t\tdo_alpha;\n    int\t\tdo_unsigned;\n    int\t\tfirstdigit;\n    int\t\tsubtract;\n    int\t\tnegative = FALSE;\n    int\t\twas_positive = TRUE;\n    int\t\tvisual = VIsual_active;\n    int\t\tdid_change = FALSE;\n    pos_T\tsave_cursor = curwin->w_cursor;\n    int\t\tmaxlen = 0;\n    pos_T\tstartpos;\n    pos_T\tendpos;\n    colnr_T\tsave_coladd = 0;\n\n    do_hex = (vim_strchr(curbuf->b_p_nf, 'x') != NULL);\t// \"heX\"\n    do_oct = (vim_strchr(curbuf->b_p_nf, 'o') != NULL);\t// \"Octal\"\n    do_bin = (vim_strchr(curbuf->b_p_nf, 'b') != NULL);\t// \"Bin\"\n    do_alpha = (vim_strchr(curbuf->b_p_nf, 'p') != NULL);\t// \"alPha\"\n    do_unsigned = (vim_strchr(curbuf->b_p_nf, 'u') != NULL);\t// \"Unsigned\"\n\n    if (virtual_active())\n    {\n\tsave_coladd = pos->coladd;\n\tpos->coladd = 0;\n    }\n\n    curwin->w_cursor = *pos;\n    ptr = ml_get(pos->lnum);\n    col = pos->col;\n\n    if (*ptr == NUL || col + !!save_coladd >= (int)STRLEN(ptr))\n\tgoto theend;\n\n    /*\n     * First check if we are on a hexadecimal number, after the \"0x\".\n     */\n    if (!VIsual_active)\n    {\n\tif (do_bin)\n\t    while (col > 0 && vim_isbdigit(ptr[col]))\n\t    {\n\t\t--col;\n\t\tif (has_mbyte)\n\t\t    col -= (*mb_head_off)(ptr, ptr + col);\n\t    }\n\n\tif (do_hex)\n\t    while (col > 0 && vim_isxdigit(ptr[col]))\n\t    {\n\t\t--col;\n\t\tif (has_mbyte)\n\t\t    col -= (*mb_head_off)(ptr, ptr + col);\n\t    }\n\n\tif (       do_bin\n\t\t&& do_hex\n\t\t&& ! ((col > 0\n\t\t    && (ptr[col] == 'X'\n\t\t\t|| ptr[col] == 'x')\n\t\t    && ptr[col - 1] == '0'\n\t\t    && (!has_mbyte ||\n\t\t\t!(*mb_head_off)(ptr, ptr + col - 1))\n\t\t    && vim_isxdigit(ptr[col + 1]))))\n\t{\n\n\t    // In case of binary/hexadecimal pattern overlap match, rescan\n\n\t    col = pos->col;\n\n\t    while (col > 0 && vim_isdigit(ptr[col]))\n\t    {\n\t\tcol--;\n\t\tif (has_mbyte)\n\t\t    col -= (*mb_head_off)(ptr, ptr + col);\n\t    }\n\t}\n\n\tif ((       do_hex\n\t\t&& col > 0\n\t\t&& (ptr[col] == 'X'\n\t\t    || ptr[col] == 'x')\n\t\t&& ptr[col - 1] == '0'\n\t\t&& (!has_mbyte ||\n\t\t    !(*mb_head_off)(ptr, ptr + col - 1))\n\t\t&& vim_isxdigit(ptr[col + 1])) ||\n\t    (       do_bin\n\t\t&& col > 0\n\t\t&& (ptr[col] == 'B'\n\t\t    || ptr[col] == 'b')\n\t\t&& ptr[col - 1] == '0'\n\t\t&& (!has_mbyte ||\n\t\t    !(*mb_head_off)(ptr, ptr + col - 1))\n\t\t&& vim_isbdigit(ptr[col + 1])))\n\t{\n\t    // Found hexadecimal or binary number, move to its start.\n\t    --col;\n\t    if (has_mbyte)\n\t\tcol -= (*mb_head_off)(ptr, ptr + col);\n\t}\n\telse\n\t{\n\t    /*\n\t     * Search forward and then backward to find the start of number.\n\t     */\n\t    col = pos->col;\n\n\t    while (ptr[col] != NUL\n\t\t    && !vim_isdigit(ptr[col])\n\t\t    && !(do_alpha && ASCII_ISALPHA(ptr[col])))\n\t\tcol += mb_ptr2len(ptr + col);\n\n\t    while (col > 0\n\t\t    && vim_isdigit(ptr[col - 1])\n\t\t    && !(do_alpha && ASCII_ISALPHA(ptr[col])))\n\t    {\n\t\t--col;\n\t\tif (has_mbyte)\n\t\t    col -= (*mb_head_off)(ptr, ptr + col);\n\t    }\n\t}\n    }\n\n    if (visual)\n    {\n\twhile (ptr[col] != NUL && length > 0\n\t\t&& !vim_isdigit(ptr[col])\n\t\t&& !(do_alpha && ASCII_ISALPHA(ptr[col])))\n\t{\n\t    int mb_len = mb_ptr2len(ptr + col);\n\n\t    col += mb_len;\n\t    length -= mb_len;\n\t}\n\n\tif (length == 0)\n\t    goto theend;\n\n\tif (col > pos->col && ptr[col - 1] == '-'\n\t\t&& (!has_mbyte || !(*mb_head_off)(ptr, ptr + col - 1))\n\t\t&& !do_unsigned)\n\t{\n\t    negative = TRUE;\n\t    was_positive = FALSE;\n\t}\n    }\n\n    /*\n     * If a number was found, and saving for undo works, replace the number.\n     */\n    firstdigit = ptr[col];\n    if (!VIM_ISDIGIT(firstdigit) && !(do_alpha && ASCII_ISALPHA(firstdigit)))\n    {\n\tbeep_flush();\n\tgoto theend;\n    }\n\n    if (do_alpha && ASCII_ISALPHA(firstdigit))\n    {\n\t// decrement or increment alphabetic character\n\tif (op_type == OP_NR_SUB)\n\t{\n\t    if (CharOrd(firstdigit) < Prenum1)\n\t    {\n\t\tif (isupper(firstdigit))\n\t\t    firstdigit = 'A';\n\t\telse\n\t\t    firstdigit = 'a';\n\t    }\n\t    else\n\t\tfirstdigit -= Prenum1;\n\t}\n\telse\n\t{\n\t    if (26 - CharOrd(firstdigit) - 1 < Prenum1)\n\t    {\n\t\tif (isupper(firstdigit))\n\t\t    firstdigit = 'Z';\n\t\telse\n\t\t    firstdigit = 'z';\n\t    }\n\t    else\n\t\tfirstdigit += Prenum1;\n\t}\n\tcurwin->w_cursor.col = col;\n\tif (!did_change)\n\t    startpos = curwin->w_cursor;\n\tdid_change = TRUE;\n\t(void)del_char(FALSE);\n\tins_char(firstdigit);\n\tendpos = curwin->w_cursor;\n\tcurwin->w_cursor.col = col;\n    }\n    else\n    {\n\tpos_T\tsave_pos;\n\tint\ti;\n\n\tif (col > 0 && ptr[col - 1] == '-'\n\t\t&& (!has_mbyte ||\n\t\t    !(*mb_head_off)(ptr, ptr + col - 1))\n\t\t&& !visual\n\t\t&& !do_unsigned)\n\t{\n\t    // negative number\n\t    --col;\n\t    negative = TRUE;\n\t}\n\t// get the number value (unsigned)\n\tif (visual && VIsual_mode != 'V')\n\t    maxlen = (curbuf->b_visual.vi_curswant == MAXCOL\n\t\t    ? (int)STRLEN(ptr) - col\n\t\t    : length);\n\n\tint overflow = FALSE;\n\tvim_str2nr(ptr + col, &pre, &length,\n\t\t0 + (do_bin ? STR2NR_BIN : 0)\n\t\t    + (do_oct ? STR2NR_OCT : 0)\n\t\t    + (do_hex ? STR2NR_HEX : 0),\n\t\tNULL, &n, maxlen, FALSE, &overflow);\n\n\t// ignore leading '-' for hex and octal and bin numbers\n\tif (pre && negative)\n\t{\n\t    ++col;\n\t    --length;\n\t    negative = FALSE;\n\t}\n\t// add or subtract\n\tsubtract = FALSE;\n\tif (op_type == OP_NR_SUB)\n\t    subtract ^= TRUE;\n\tif (negative)\n\t    subtract ^= TRUE;\n\n\toldn = n;\n\tif (!overflow)  // if number is too big don't add/subtract\n\t{\n\t    if (subtract)\n\t\tn -= (uvarnumber_T)Prenum1;\n\t    else\n\t\tn += (uvarnumber_T)Prenum1;\n\t}\n\n\t// handle wraparound for decimal numbers\n\tif (!pre)\n\t{\n\t    if (subtract)\n\t    {\n\t\tif (n > oldn)\n\t\t{\n\t\t    n = 1 + (n ^ (uvarnumber_T)-1);\n\t\t    negative ^= TRUE;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// add\n\t\tif (n < oldn)\n\t\t{\n\t\t    n = (n ^ (uvarnumber_T)-1);\n\t\t    negative ^= TRUE;\n\t\t}\n\t    }\n\t    if (n == 0)\n\t\tnegative = FALSE;\n\t}\n\n\tif (do_unsigned && negative)\n\t{\n\t    if (subtract)\n\t\t// sticking at zero.\n\t\tn = (uvarnumber_T)0;\n\t    else\n\t\t// sticking at 2^64 - 1.\n\t\tn = (uvarnumber_T)(-1);\n\t    negative = FALSE;\n\t}\n\n\tif (visual && !was_positive && !negative && col > 0)\n\t{\n\t    // need to remove the '-'\n\t    col--;\n\t    length++;\n\t}\n\n\t/*\n\t * Delete the old number.\n\t */\n\tcurwin->w_cursor.col = col;\n\tif (!did_change)\n\t    startpos = curwin->w_cursor;\n\tdid_change = TRUE;\n\ttodel = length;\n\tc = gchar_cursor();\n\t/*\n\t * Don't include the '-' in the length, only the length of the\n\t * part after it is kept the same.\n\t */\n\tif (c == '-')\n\t    --length;\n\n\tsave_pos = curwin->w_cursor;\n\tfor (i = 0; i < todel; ++i)\n\t{\n\t    if (c < 0x100 && isalpha(c))\n\t    {\n\t\tif (isupper(c))\n\t\t    hexupper = TRUE;\n\t\telse\n\t\t    hexupper = FALSE;\n\t    }\n\t    inc_cursor();\n\t    c = gchar_cursor();\n\t}\n\tcurwin->w_cursor = save_pos;\n\n\t/*\n\t * Prepare the leading characters in buf1[].\n\t * When there are many leading zeros it could be very long.\n\t * Allocate a bit too much.\n\t */\n\tbuf1 = alloc(length + NUMBUFLEN);\n\tif (buf1 == NULL)\n\t    goto theend;\n\tptr = buf1;\n\tif (negative && (!visual || was_positive))\n\t    *ptr++ = '-';\n\tif (pre)\n\t{\n\t    *ptr++ = '0';\n\t    --length;\n\t}\n\tif (pre == 'b' || pre == 'B' ||\n\t    pre == 'x' || pre == 'X')\n\t{\n\t    *ptr++ = pre;\n\t    --length;\n\t}\n\n\t/*\n\t * Put the number characters in buf2[].\n\t */\n\tif (pre == 'b' || pre == 'B')\n\t{\n\t    int bit = 0;\n\t    int bits = sizeof(uvarnumber_T) * 8;\n\n\t    // leading zeros\n\t    for (bit = bits; bit > 0; bit--)\n\t\tif ((n >> (bit - 1)) & 0x1) break;\n\n\t    for (i = 0; bit > 0 && i < (NUMBUFLEN - 1); bit--)\n\t\tbuf2[i++] = ((n >> (bit - 1)) & 0x1) ? '1' : '0';\n\n\t    buf2[i] = '\\0';\n\t}\n\telse if (pre == 0)\n\t    vim_snprintf((char *)buf2, NUMBUFLEN, \"%llu\", n);\n\telse if (pre == '0')\n\t    vim_snprintf((char *)buf2, NUMBUFLEN, \"%llo\", n);\n\telse if (pre && hexupper)\n\t    vim_snprintf((char *)buf2, NUMBUFLEN, \"%llX\", n);\n\telse\n\t    vim_snprintf((char *)buf2, NUMBUFLEN, \"%llx\", n);\n\tlength -= (int)STRLEN(buf2);\n\n\t/*\n\t * Adjust number of zeros to the new number of digits, so the\n\t * total length of the number remains the same.\n\t * Don't do this when\n\t * the result may look like an octal number.\n\t */\n\tif (firstdigit == '0' && !(do_oct && pre == 0))\n\t    while (length-- > 0)\n\t\t*ptr++ = '0';\n\t*ptr = NUL;\n\n\tSTRCAT(buf1, buf2);\n\n\t// Insert just after the first character to be removed, so that any\n\t// text properties will be adjusted.  Then delete the old number\n\t// afterwards.\n\tsave_pos = curwin->w_cursor;\n\tif (todel > 0)\n\t    inc_cursor();\n\tins_str(buf1);\t\t// insert the new number\n\tvim_free(buf1);\n\n\t// del_char() will also mark line needing displaying\n\tif (todel > 0)\n\t{\n\t    int bytes_after = (int)STRLEN(ml_get_curline())\n\t\t\t\t\t\t\t- curwin->w_cursor.col;\n\n\t    // Delete the one character before the insert.\n\t    curwin->w_cursor = save_pos;\n\t    (void)del_char(FALSE);\n\t    curwin->w_cursor.col = (colnr_T)(STRLEN(ml_get_curline())\n\t\t\t\t\t\t\t\t- bytes_after);\n\t    --todel;\n\t}\n\twhile (todel-- > 0)\n\t    (void)del_char(FALSE);\n\n\tendpos = curwin->w_cursor;\n\tif (did_change && curwin->w_cursor.col)\n\t    --curwin->w_cursor.col;\n    }\n\n    if (did_change && (cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\t// set the '[ and '] marks\n\tcurbuf->b_op_start = startpos;\n\tcurbuf->b_op_end = endpos;\n\tif (curbuf->b_op_end.col > 0)\n\t    --curbuf->b_op_end.col;\n    }\n\ntheend:\n    if (visual)\n\tcurwin->w_cursor = save_cursor;\n    else if (did_change)\n\tcurwin->w_set_curswant = TRUE;\n    else if (virtual_active())\n\tcurwin->w_cursor.coladd = save_coladd;\n\n    return did_change;\n}", "target": 2, "idx": 10799}
{"commit_id": "697af434fbeb2e3ba2ba9687cd283ed1a2734fa5", "project": "redis", "func": "sds genRedisInfoString(void) {\n    sds info;\n    time_t uptime = time(NULL)-server.stat_starttime;\n    int j;\n    char hmem[64];\n    struct rusage self_ru, c_ru;\n\n    getrusage(RUSAGE_SELF, &self_ru);\n    getrusage(RUSAGE_CHILDREN, &c_ru);\n\n    bytesToHuman(hmem,zmalloc_used_memory());\n    info = sdscatprintf(sdsempty(),\n        \"redis_version:%s\\r\\n\"\n        \"redis_git_sha1:%s\\r\\n\"\n        \"redis_git_dirty:%d\\r\\n\"\n        \"arch_bits:%s\\r\\n\"\n        \"multiplexing_api:%s\\r\\n\"\n        \"process_id:%ld\\r\\n\"\n        \"uptime_in_seconds:%ld\\r\\n\"\n        \"uptime_in_days:%ld\\r\\n\"\n        \"lru_clock:%ld\\r\\n\"\n        \"used_cpu_sys:%.2f\\r\\n\"\n        \"used_cpu_user:%.2f\\r\\n\"\n        \"used_cpu_sys_childrens:%.2f\\r\\n\"\n        \"used_cpu_user_childrens:%.2f\\r\\n\"\n        \"connected_clients:%d\\r\\n\"\n        \"connected_slaves:%d\\r\\n\"\n        \"blocked_clients:%d\\r\\n\"\n        \"used_memory:%zu\\r\\n\"\n        \"used_memory_human:%s\\r\\n\"\n        \"used_memory_rss:%zu\\r\\n\"\n        \"mem_fragmentation_ratio:%.2f\\r\\n\"\n        \"use_tcmalloc:%d\\r\\n\"\n        \"loading:%d\\r\\n\"\n        \"aof_enabled:%d\\r\\n\"\n        \"changes_since_last_save:%lld\\r\\n\"\n        \"bgsave_in_progress:%d\\r\\n\"\n        \"last_save_time:%ld\\r\\n\"\n        \"bgrewriteaof_in_progress:%d\\r\\n\"\n        \"total_connections_received:%lld\\r\\n\"\n        \"total_commands_processed:%lld\\r\\n\"\n        \"expired_keys:%lld\\r\\n\"\n        \"evicted_keys:%lld\\r\\n\"\n        \"keyspace_hits:%lld\\r\\n\"\n        \"keyspace_misses:%lld\\r\\n\"\n        \"hash_max_zipmap_entries:%zu\\r\\n\"\n        \"hash_max_zipmap_value:%zu\\r\\n\"\n        \"pubsub_channels:%ld\\r\\n\"\n        \"pubsub_patterns:%u\\r\\n\"\n        \"ds_enabled:%d\\r\\n\"\n        \"role:%s\\r\\n\"\n        ,REDIS_VERSION,\n        redisGitSHA1(),\n        strtol(redisGitDirty(),NULL,10) > 0,\n        (sizeof(long) == 8) ? \"64\" : \"32\",\n        aeGetApiName(),\n        (long) getpid(),\n        uptime,\n        uptime/(3600*24),\n        (unsigned long) server.lruclock,\n        (float)self_ru.ru_utime.tv_sec+(float)self_ru.ru_utime.tv_usec/1000000,\n        (float)self_ru.ru_stime.tv_sec+(float)self_ru.ru_stime.tv_usec/1000000,\n        (float)c_ru.ru_utime.tv_sec+(float)c_ru.ru_utime.tv_usec/1000000,\n        (float)c_ru.ru_stime.tv_sec+(float)c_ru.ru_stime.tv_usec/1000000,\n        listLength(server.clients)-listLength(server.slaves),\n        listLength(server.slaves),\n        server.bpop_blocked_clients,\n        zmalloc_used_memory(),\n        hmem,\n        zmalloc_get_rss(),\n        zmalloc_get_fragmentation_ratio(),\n#ifdef USE_TCMALLOC\n        1,\n#else\n        0,\n#endif\n        server.loading,\n        server.appendonly,\n        server.dirty,\n        server.bgsavechildpid != -1,\n        server.lastsave,\n        server.bgrewritechildpid != -1,\n        server.stat_numconnections,\n        server.stat_numcommands,\n        server.stat_expiredkeys,\n        server.stat_evictedkeys,\n        server.stat_keyspace_hits,\n        server.stat_keyspace_misses,\n        server.hash_max_zipmap_entries,\n        server.hash_max_zipmap_value,\n        dictSize(server.pubsub_channels),\n        listLength(server.pubsub_patterns),\n        server.ds_enabled != 0,\n        server.masterhost == NULL ? \"master\" : \"slave\"\n    );\n    if (server.masterhost) {\n        info = sdscatprintf(info,\n            \"master_host:%s\\r\\n\"\n            \"master_port:%d\\r\\n\"\n            \"master_link_status:%s\\r\\n\"\n            \"master_last_io_seconds_ago:%d\\r\\n\"\n            \"master_sync_in_progress:%d\\r\\n\"\n            ,server.masterhost,\n            server.masterport,\n            (server.replstate == REDIS_REPL_CONNECTED) ?\n                \"up\" : \"down\",\n            server.master ? ((int)(time(NULL)-server.master->lastinteraction)) : -1,\n            server.replstate == REDIS_REPL_TRANSFER\n        );\n\n        if (server.replstate == REDIS_REPL_TRANSFER) {\n            info = sdscatprintf(info,\n                \"master_sync_left_bytes:%ld\\r\\n\"\n                \"master_sync_last_io_seconds_ago:%d\\r\\n\"\n                ,(long)server.repl_transfer_left,\n                (int)(time(NULL)-server.repl_transfer_lastio)\n            );\n        }\n    }\n    if (server.ds_enabled) {\n        lockThreadedIO();\n        info = sdscatprintf(info,\n            \"cache_max_memory:%llu\\r\\n\"\n            \"cache_blocked_clients:%lu\\r\\n\"\n            ,(unsigned long long) server.cache_max_memory,\n            (unsigned long) server.cache_blocked_clients\n        );\n        unlockThreadedIO();\n    }\n    if (server.loading) {\n        double perc;\n        time_t eta, elapsed;\n        off_t remaining_bytes = server.loading_total_bytes-\n                                server.loading_loaded_bytes;\n\n        perc = ((double)server.loading_loaded_bytes /\n               server.loading_total_bytes) * 100;\n\n        elapsed = time(NULL)-server.loading_start_time;\n        if (elapsed == 0) {\n            eta = 1; /* A fake 1 second figure if we don't have enough info */\n        } else {\n            eta = (elapsed*remaining_bytes)/server.loading_loaded_bytes;\n        }\n\n        info = sdscatprintf(info,\n            \"loading_start_time:%ld\\r\\n\"\n            \"loading_total_bytes:%llu\\r\\n\"\n            \"loading_loaded_bytes:%llu\\r\\n\"\n            \"loading_loaded_perc:%.2f\\r\\n\"\n            \"loading_eta_seconds:%ld\\r\\n\"\n            ,(unsigned long) server.loading_start_time,\n            (unsigned long long) server.loading_total_bytes,\n            (unsigned long long) server.loading_loaded_bytes,\n            perc,\n            eta\n        );\n    }\n    for (j = 0; j < server.dbnum; j++) {\n        long long keys, vkeys;\n\n        keys = dictSize(server.db[j].dict);\n        vkeys = dictSize(server.db[j].expires);\n        if (keys || vkeys) {\n            info = sdscatprintf(info, \"db%d:keys=%lld,expires=%lld\\r\\n\",\n                j, keys, vkeys);\n        }\n    }\n    return info;\n}", "target": 1, "idx": 10800}
{"commit_id": "5ccb6f7a791bf3490357b00a898885759d98bab0", "project": "redis", "func": "int mp_pack(lua_State *L) {\n    int nargs = lua_gettop(L);\n    int i;\n    mp_buf *buf;\n\n    if (nargs == 0)\n        return luaL_argerror(L, 0, \"MessagePack pack needs input.\");\n\n    if (!lua_checkstack(L, nargs))\n        return luaL_argerror(L, 0, \"Too many arguments for MessagePack pack.\");\n\n    buf = mp_buf_new(L);\n    for(i = 1; i <= nargs; i++) {\n        /* Copy argument i to top of stack for _encode processing;\n         * the encode function pops it from the stack when complete. */\n        luaL_checkstack(L, 1, \"in function mp_check\");\n        lua_pushvalue(L, i);\n\n        mp_encode_lua_type(L,buf,0);\n\n        lua_pushlstring(L,(char*)buf->b,buf->len);\n\n        /* Reuse the buffer for the next operation by\n         * setting its free count to the total buffer size\n         * and the current position to zero. */\n        buf->free += buf->len;\n        buf->len = 0;\n    }\n    mp_buf_free(L, buf);\n\n    /* Concatenate all nargs buffers together */\n    lua_concat(L, nargs);\n    return 1;\n}", "target": 3, "idx": 10801}
{"commit_id": "1dcd10aceabbc03bf571ea32b892c522cbe923de", "project": "the-tcpdump-group/tcpdump", "func": "u_int\natm_if_print(netdissect_options *ndo,\n             const struct pcap_pkthdr *h, const u_char *p)\n{\n\tu_int caplen = h->caplen;\n\tu_int length = h->len;\n\tuint32_t llchdr;\n\tu_int hdrlen = 0;\n\n\tif (caplen < 1 || length < 1) {\n\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\treturn (caplen);\n\t}\n\n        /* Cisco Style NLPID ? */\n        if (*p == LLC_UI) {\n            if (ndo->ndo_eflag)\n                ND_PRINT((ndo, \"CNLPID \"));\n            isoclns_print(ndo, p + 1, length - 1);\n            return hdrlen;\n        }\n\n\t/*\n\t * Must have at least a DSAP, an SSAP, and the first byte of the\n\t * control field.\n\t */\n\tif (caplen < 3 || length < 3) {\n\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\treturn (caplen);\n\t}\n\n\t/*\n\t * Extract the presumed LLC header into a variable, for quick\n\t * testing.\n\t * Then check for a header that's neither a header for a SNAP\n\t * packet nor an RFC 2684 routed NLPID-formatted PDU nor\n\t * an 802.2-but-no-SNAP IP packet.\n\t */\n\tllchdr = EXTRACT_24BITS(p);\n\tif (llchdr != LLC_UI_HDR(LLCSAP_SNAP) &&\n\t    llchdr != LLC_UI_HDR(LLCSAP_ISONS) &&\n\t    llchdr != LLC_UI_HDR(LLCSAP_IP)) {\n\t\t/*\n\t\t * XXX - assume 802.6 MAC header from Fore driver.\n\t\t *\n\t\t * Unfortunately, the above list doesn't check for\n\t\t * all known SAPs, doesn't check for headers where\n\t\t * the source and destination SAP aren't the same,\n\t\t * and doesn't check for non-UI frames.  It also\n\t\t * runs the risk of an 802.6 MAC header that happens\n\t\t * to begin with one of those values being\n\t\t * incorrectly treated as an 802.2 header.\n\t\t *\n\t\t * So is that Fore driver still around?  And, if so,\n\t\t * is it still putting 802.6 MAC headers on ATM\n\t\t * packets?  If so, could it be changed to use a\n\t\t * new DLT_IEEE802_6 value if we added it?\n\t\t */\n\t\tif (caplen < 20 || length < 20) {\n\t\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\t\treturn (caplen);\n\t\t}\n\t\tif (ndo->ndo_eflag)\n\t\t\tND_PRINT((ndo, \"%08x%08x %08x%08x \",\n\t\t\t       EXTRACT_32BITS(p),\n\t\t\t       EXTRACT_32BITS(p+4),\n\t\t\t       EXTRACT_32BITS(p+8),\n\t\t\t       EXTRACT_32BITS(p+12)));\n\t\tp += 20;\n\t\tlength -= 20;\n\t\tcaplen -= 20;\n\t\thdrlen += 20;\n\t}\n\thdrlen += atm_llc_print(ndo, p, length, caplen);\n\treturn (hdrlen);\n}", "target": 3, "idx": 10802}
{"commit_id": "5beb00c93d3adb5c23149535624d27c67bc146ea", "project": "TokTok/c-toxcore", "func": "void kill_TCP_connection(TCP_Client_Connection *tcp_connection)\n{\n    if (tcp_connection == nullptr) {\n        return;\n    }\n\n    wipe_priority_list(tcp_connection->priority_queue_start);\n    kill_sock(tcp_connection->sock);\n    crypto_memzero(tcp_connection, sizeof(TCP_Client_Connection));\n    free(tcp_connection);\n}", "target": 2, "idx": 10803}
{"commit_id": "a24543157ae2cdd25da43e20f4e48a07481e6ceb", "project": "android", "func": "explicit ElementsAccessorBase(const char* name)\n      : InternalElementsAccessor(name) {}", "target": 2, "idx": 10804}
{"commit_id": "e8eff147e9da1185f9afd5b25948153a3b97cf52", "project": "dosfstools", "func": "static void dump_boot(DOS_FS * fs, struct boot_sector *b, unsigned lss)\n{\n    unsigned short sectors;\n\n    printf(\"Boot sector contents:\\n\");\n    if (!atari_format) {\n\tchar id[9];\n\tstrncpy(id, (const char *)b->system_id, 8);\n\tid[8] = 0;\n\tprintf(\"System ID \\\"%s\\\"\\n\", id);\n    } else {\n\t/* On Atari, a 24 bit serial number is stored at offset 8 of the boot\n\t * sector */\n\tprintf(\"Serial number 0x%x\\n\",\n\t       b->system_id[5] | (b->system_id[6] << 8) | (b->\n\t\t\t\t\t\t\t   system_id[7] << 16));\n    }\n    printf(\"Media byte 0x%02x (%s)\\n\", b->media, get_media_descr(b->media));\n    printf(\"%10d bytes per logical sector\\n\", GET_UNALIGNED_W(b->sector_size));\n    printf(\"%10d bytes per cluster\\n\", fs->cluster_size);\n    printf(\"%10d reserved sector%s\\n\", le16toh(b->reserved),\n\t   le16toh(b->reserved) == 1 ? \"\" : \"s\");\n    printf(\"First FAT starts at byte %llu (sector %llu)\\n\",\n\t   (unsigned long long)fs->fat_start,\n\t   (unsigned long long)fs->fat_start / lss);\n    printf(\"%10d FATs, %d bit entries\\n\", b->fats, fs->fat_bits);\n    printf(\"%10lld bytes per FAT (= %llu sectors)\\n\", (long long)fs->fat_size,\n\t   (long long)fs->fat_size / lss);\n    if (!fs->root_cluster) {\n\tprintf(\"Root directory starts at byte %llu (sector %llu)\\n\",\n\t       (unsigned long long)fs->root_start,\n\t       (unsigned long long)fs->root_start / lss);\n\tprintf(\"%10d root directory entries\\n\", fs->root_entries);\n    } else {\n\tprintf(\"Root directory start at cluster %lu (arbitrary size)\\n\",\n\t       (unsigned long)fs->root_cluster);\n    }\n    printf(\"Data area starts at byte %llu (sector %llu)\\n\",\n\t   (unsigned long long)fs->data_start,\n\t   (unsigned long long)fs->data_start / lss);\n    printf(\"%10lu data clusters (%llu bytes)\\n\",\n\t   (unsigned long)fs->data_clusters,\n\t   (unsigned long long)fs->data_clusters * fs->cluster_size);\n    printf(\"%u sectors/track, %u heads\\n\", le16toh(b->secs_track),\n\t   le16toh(b->heads));\n    printf(\"%10u hidden sectors\\n\", atari_format ?\n\t   /* On Atari, the hidden field is only 16 bit wide and unused */\n\t   (((unsigned char *)&b->hidden)[0] |\n\t    ((unsigned char *)&b->hidden)[1] << 8) : le32toh(b->hidden));\n    sectors = GET_UNALIGNED_W(b->sectors);\n    printf(\"%10u sectors total\\n\", sectors ? sectors : le32toh(b->total_sect));\n}", "target": 1, "idx": 10805}
{"commit_id": "75fd1d21be5ae03834209bc1fcf9fb8221b97e7b", "project": "nextcloud/desktop", "func": "void PropagateUploadEncrypted::slotFolderEncryptedMetadataReceived(const QJsonDocument &json, int statusCode)\n{\n  qCDebug(lcPropagateUploadEncrypted) << \"Metadata Received, Preparing it for the new file.\" << json.toVariant();\n\n  // Encrypt File!\n  _metadata.reset(new FolderMetadata(_propagator->account(), json.toJson(QJsonDocument::Compact), statusCode));\n\n  if (!_metadata->isMetadataSetup()) {\n      if (_isFolderLocked) {\n          connect(this, &PropagateUploadEncrypted::folderUnlocked, this, &PropagateUploadEncrypted::error);\n          unlockFolder();\n      } else {\n          emit error();\n      }\n      return;\n  }\n\n  QFileInfo info(_propagator->fullLocalPath(_item->_file));\n  const QString fileName = info.fileName();\n\n  // Find existing metadata for this file\n  bool found = false;\n  EncryptedFile encryptedFile;\n  const QVector<EncryptedFile> files = _metadata->files();\n\n  for(const EncryptedFile &file : files) {\n    if (file.originalFilename == fileName) {\n      encryptedFile = file;\n      found = true;\n    }\n  }\n\n\n\n  // New encrypted file so set it all up!\n  if (!found) {\n      encryptedFile.encryptionKey = EncryptionHelper::generateRandom(16);\n      encryptedFile.encryptedFilename = EncryptionHelper::generateRandomFilename();\n      encryptedFile.fileVersion = 1;\n      encryptedFile.metadataKey = 1;\n      encryptedFile.originalFilename = fileName;\n\n      QMimeDatabase mdb;\n      encryptedFile.mimetype = mdb.mimeTypeForFile(info).name().toLocal8Bit();\n\n      // Other clients expect \"httpd/unix-directory\" instead of \"inode/directory\"\n      // Doesn't matter much for us since we don't do much about that mimetype anyway\n      if (encryptedFile.mimetype == QByteArrayLiteral(\"inode/directory\")) {\n          encryptedFile.mimetype = QByteArrayLiteral(\"httpd/unix-directory\");\n      }\n  }\n  \n  encryptedFile.initializationVector = EncryptionHelper::generateRandom(16);\n\n  _item->_encryptedFileName = _remoteParentPath + QLatin1Char('/') + encryptedFile.encryptedFilename;\n  _item->_isEncrypted = true;\n\n  qCDebug(lcPropagateUploadEncrypted) << \"Creating the encrypted file.\";\n\n  if (info.isDir()) {\n      _completeFileName = encryptedFile.encryptedFilename;\n  } else {\n      QFile input(info.absoluteFilePath());\n      QFile output(QDir::tempPath() + QDir::separator() + encryptedFile.encryptedFilename);\n\n      QByteArray tag;\n      bool encryptionResult = EncryptionHelper::fileEncryption(\n        encryptedFile.encryptionKey,\n        encryptedFile.initializationVector,\n        &input, &output, tag);\n\n      if (!encryptionResult) {\n        qCDebug(lcPropagateUploadEncrypted()) << \"There was an error encrypting the file, aborting upload.\";\n        connect(this, &PropagateUploadEncrypted::folderUnlocked, this, &PropagateUploadEncrypted::error);\n        unlockFolder();\n        return;\n      }\n\n      encryptedFile.authenticationTag = tag;\n      _completeFileName = output.fileName();\n  }\n\n  qCDebug(lcPropagateUploadEncrypted) << \"Creating the metadata for the encrypted file.\";\n\n  _metadata->addEncryptedFile(encryptedFile);\n  _encryptedFile = encryptedFile;\n\n  qCDebug(lcPropagateUploadEncrypted) << \"Metadata created, sending to the server.\";\n\n  if (statusCode == 404) {\n    auto job = new StoreMetaDataApiJob(_propagator->account(),\n                                       _folderId,\n                                       _metadata->encryptedMetadata());\n    connect(job, &StoreMetaDataApiJob::success, this, &PropagateUploadEncrypted::slotUpdateMetadataSuccess);\n    connect(job, &StoreMetaDataApiJob::error, this, &PropagateUploadEncrypted::slotUpdateMetadataError);\n    job->start();\n  } else {\n    auto job = new UpdateMetadataApiJob(_propagator->account(),\n                                      _folderId,\n                                      _metadata->encryptedMetadata(),\n                                      _folderToken);\n\n    connect(job, &UpdateMetadataApiJob::success, this, &PropagateUploadEncrypted::slotUpdateMetadataSuccess);\n    connect(job, &UpdateMetadataApiJob::error, this, &PropagateUploadEncrypted::slotUpdateMetadataError);\n    job->start();\n  }\n}", "target": 1, "idx": 10806}
{"commit_id": "d55bfcd6804699e1435dc3e233fd76c8a5d3f9e3", "project": "Blosc/c-blosc2", "func": "int ndlz4_decompress(const uint8_t *input, int32_t input_len, uint8_t *output, int32_t output_len,\n                     uint8_t meta, blosc2_dparams *dparams) {\n  BLOSC_UNUSED_PARAM(meta);\n  BLOSC_UNUSED_PARAM(dparams);\n  BLOSC_ERROR_NULL(input, BLOSC2_ERROR_NULL_POINTER);\n  BLOSC_ERROR_NULL(output, BLOSC2_ERROR_NULL_POINTER);\n\n  uint8_t *ip = (uint8_t *) input;\n  uint8_t *ip_limit = ip + input_len;\n  uint8_t *op = (uint8_t *) output;\n  uint8_t ndim;\n  uint32_t blockshape[2];\n  uint32_t eshape[2];\n  uint8_t *buffercpy;\n  uint8_t local_buffer[16];\n  uint8_t token;\n  if (NDLZ_UNEXPECT_CONDITIONAL(input_len < 8)) {\n    return 0;\n  }\n\n  /* we start with literal copy */\n  ndim = *ip;\n  ip++;\n  if (ndim != 2) {\n    BLOSC_TRACE_ERROR(\"This codec only works for ndim = 2\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n  memcpy(&blockshape[0], ip, 4);\n  ip += 4;\n  memcpy(&blockshape[1], ip, 4);\n  ip += 4;\n  eshape[0] = ((blockshape[0] + 3) / 4) * 4;\n  eshape[1] = ((blockshape[1] + 3) / 4) * 4;\n\n  if (NDLZ_UNEXPECT_CONDITIONAL((int64_t)output_len < (int64_t)blockshape[0] * (int64_t)blockshape[1])) {\n    return 0;\n  }\n  memset(op, 0, blockshape[0] * blockshape[1]);\n\n  uint32_t i_stop[2];\n  for (int i = 0; i < 2; ++i) {\n    i_stop[i] = eshape[i] / 4;\n  }\n\n  /* main loop */\n  uint32_t ii[2];\n  uint32_t padding[2] = {0};\n  uint32_t ind = 0;\n  uint8_t cell_aux[16];\n  for (ii[0] = 0; ii[0] < i_stop[0]; ++ii[0]) {\n    for (ii[1] = 0; ii[1] < i_stop[1]; ++ii[1]) {      // for each cell\n      if (NDLZ_UNEXPECT_CONDITIONAL(ip > ip_limit)) {\n        BLOSC_TRACE_ERROR(\"Exceeding input length\");\n        return BLOSC2_ERROR_FAILURE;\n      }\n      if (ii[0] == i_stop[0] - 1) {\n        padding[0] = (blockshape[0] % 4 == 0) ? 4 : blockshape[0] % 4;\n      } else {\n        padding[0] = 4;\n      }\n      if (ii[1] == i_stop[1] - 1) {\n        padding[1] = (blockshape[1] % 4 == 0) ? 4 : blockshape[1] % 4;\n      } else {\n        padding[1] = 4;\n      }\n      token = *ip++;\n      if (token == 0) {    // no match\n        buffercpy = ip;\n        ip += padding[0] * padding[1];\n      } else if (token == (uint8_t) ((1U << 7U) | (1U << 6U))) {  // cell match\n        uint16_t offset = *((uint16_t *) ip);\n        buffercpy = ip - offset - 1;\n        ip += 2;\n      } else if (token == (uint8_t) (1U << 6U)) { // whole cell of same element\n        buffercpy = cell_aux;\n        memset(buffercpy, *ip, 16);\n        ip++;\n      } else if (token >= 224) { // three rows match\n        buffercpy = local_buffer;\n        uint16_t offset = *((uint16_t *) ip);\n        offset += 3;\n        ip += 2;\n        int i, j, k;\n        if ((token >> 3U) == 28) {\n          i = 1;\n          j = 2;\n          k = 3;\n        } else {\n          i = 0;\n          if ((token >> 3U) < 30) {\n            j = 1;\n            k = 2;\n          } else {\n            k = 3;\n            if ((token >> 3U) == 30) {\n              j = 1;\n            } else {\n              j = 2;\n            }\n          }\n        }\n        memcpy(&buffercpy[i * 4], ip - offset, 4);\n        memcpy(&buffercpy[j * 4], ip - offset + 4, 4);\n        memcpy(&buffercpy[k * 4], ip - offset + 8, 4);\n        for (int l = 0; l < 4; l++) {\n          if ((l != i) && (l != j) && (l != k)) {\n            memcpy(&buffercpy[l * 4], ip, 4);\n            ip += 4;\n            break;\n          }\n        }\n\n      } else if ((token >= 128) && (token <= 191)) { // rows pair match\n        buffercpy = local_buffer;\n        uint16_t offset = *((uint16_t *) ip);\n        offset += 3;\n        ip += 2;\n        int i, j;\n        if (token == 128) {\n          i = 2;\n          j = 3;\n        } else {\n          i = (token - 128) >> 5U;\n          j = ((token - 128) >> 3U) - (i << 2U);\n        }\n        memcpy(&buffercpy[i * 4], ip - offset, 4);\n        memcpy(&buffercpy[j * 4], ip - offset + 4, 4);\n        for (int k = 0; k < 4; k++) {\n          if ((k != i) && (k != j)) {\n            memcpy(&buffercpy[k * 4], ip, 4);\n            ip += 4;\n          }\n        }\n      } else if ((token >= 40) && (token <= 63)) {  // 2 rows pair matches\n        buffercpy = local_buffer;\n        uint16_t offset_1 = *((uint16_t *) ip);\n        offset_1 += 5;\n        ip += 2;\n        uint16_t offset_2 = *((uint16_t *) ip);\n        offset_2 += 5;\n        ip += 2;\n        int i, j, k, l, m;\n        i = 0;\n        j = ((token - 32) >> 3U);\n        l = -1;\n        for (k = 1; k < 4; k++) {\n          if ((k != i) && (k != j)) {\n            if (l == -1) {\n              l = k;\n            } else {\n              m = k;\n            }\n          }\n        }\n        memcpy(&buffercpy[i * 4], ip - offset_1, 4);\n        memcpy(&buffercpy[j * 4], ip - offset_1 + 4, 4);\n        memcpy(&buffercpy[l * 4], ip - offset_2, 4);\n        memcpy(&buffercpy[m * 4], ip - offset_2 + 4, 4);\n\n      } else {\n        BLOSC_TRACE_ERROR(\"Invalid token: %u at cell [%d, %d]\\n\", token, ii[0], ii[1]);\n        return BLOSC2_ERROR_FAILURE;\n      }\n      // fill op with buffercpy\n      uint32_t orig = ii[0] * 4 * blockshape[1] + ii[1] * 4;\n      for (uint32_t i = 0; i < 4; i++) {\n        if (i < padding[0]) {\n          ind = orig + i * blockshape[1];\n          memcpy(&op[ind], buffercpy, padding[1]);\n        }\n        buffercpy += padding[1];\n      }\n      if (ind > (uint32_t) output_len) {\n        BLOSC_TRACE_ERROR(\"Exceeding output size\");\n        return BLOSC2_ERROR_FAILURE;\n      }\n    }\n  }\n  ind += padding[1];\n\n  if (ind != (blockshape[0] * blockshape[1])) {\n    BLOSC_TRACE_ERROR(\"Output size is not compatible with embedded blockshape\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n  if (ind > (uint32_t) output_len) {\n    BLOSC_TRACE_ERROR(\"Exceeding output size\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n\n  return (int) ind;\n}", "target": 2, "idx": 10807}
{"commit_id": "9cf6926c5d947371dc9e44f32bc7a2fbfca5d469", "project": "tats/w3m", "func": "void\nwc_push_to_iso2022(Str os, wc_wchar_t cc, wc_status *st)\n{\n    wc_uchar g = 0;\n    wc_bool is_wide = WC_FALSE, retry = WC_FALSE;\n    wc_wchar_t cc2;\n\n  while (1) {\n    switch (WC_CCS_TYPE(cc.ccs)) {\n    case WC_CCS_A_CS94:\n\tif (cc.ccs == WC_CCS_US_ASCII)\n\t    cc.ccs = st->g0_ccs;\n\tif (WC_CCS_INDEX(cc.ccs) >= WC_F_ISO_BASE)\n\t    g = cs94_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];\n\tbreak;\n    case WC_CCS_A_CS94W:\n\tis_wide = 1;\n\tswitch (cc.ccs) {\n#ifdef USE_UNICODE\n\tcase WC_CCS_JIS_X_0212:\n\t    if (!WcOption.use_jisx0212 && WcOption.use_jisx0213 &&\n\t\tWcOption.ucs_conv) {\n\t\tcc2 = wc_jisx0212_to_jisx0213(cc);\n\t\tif (cc2.ccs == WC_CCS_JIS_X_0213_1 ||\n\t\t    cc2.ccs == WC_CCS_JIS_X_0213_2) {\n\t\t    cc = cc2;\n\t\t    continue;\n\t\t}\n\t    }\n\t    break;\n\tcase WC_CCS_JIS_X_0213_1:\n\tcase WC_CCS_JIS_X_0213_2:\n\t    if (!WcOption.use_jisx0213 && WcOption.use_jisx0212 &&\n\t\tWcOption.ucs_conv) {\n\t\tcc2 = wc_jisx0213_to_jisx0212(cc);\n\t\tif (cc2.ccs == WC_CCS_JIS_X_0212) {\n\t\t    cc = cc2;\n\t\t    continue;\n\t\t}\n\t    }\n\t    break;\n#endif\n\t}\n\tif (WC_CCS_INDEX(cc.ccs) >= WC_F_ISO_BASE)\n\t    g = cs94w_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];\n\tbreak;\n    case WC_CCS_A_CS96:\n\tif (WC_CCS_INDEX(cc.ccs) >= WC_F_ISO_BASE)\n\t    g = cs96_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];\n\tbreak;\n    case WC_CCS_A_CS96W:\n\tis_wide = 1;\n\tif (WC_CCS_INDEX(cc.ccs) >= WC_F_ISO_BASE)\n\t    g = cs96w_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];\n\tbreak;\n    case WC_CCS_A_CS942:\n\tif (WC_CCS_INDEX(cc.ccs) >= WC_F_ISO_BASE)\n\t    g = cs942_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];\n\tbreak;\n    case WC_CCS_A_UNKNOWN_W:\n\tif (WcOption.no_replace)\n\t    return;\n\tis_wide = 1;\n\tcc.ccs = WC_CCS_US_ASCII;\n\tif (WC_CCS_INDEX(cc.ccs) >= WC_F_ISO_BASE)\n\t    g = cs94_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];\n\tcc.code = ((wc_uint32)WC_REPLACE_W[0] << 8) | WC_REPLACE_W[1];\n\tbreak;\n    case WC_CCS_A_UNKNOWN:\n\tif (WcOption.no_replace)\n\t    return;\n\tcc.ccs = WC_CCS_US_ASCII;\n\tif (WC_CCS_INDEX(cc.ccs) >= WC_F_ISO_BASE)\n\t    g = cs94_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];\n\tcc.code = (wc_uint32)WC_REPLACE[0];\n\tbreak;\n    default:\n\tif ((cc.ccs == WC_CCS_JOHAB || cc.ccs == WC_CCS_JOHAB_1 ||\n\t\tcc.ccs == WC_CCS_JOHAB_2 || cc.ccs == WC_CCS_JOHAB_3) &&\n\t\tcs94w_gmap[WC_F_KS_X_1001 - WC_F_ISO_BASE]) {\n\t    wc_wchar_t cc2 = wc_johab_to_ksx1001(cc);\n\t    if (cc2.ccs == WC_CCS_KS_X_1001) {\n\t\tcc = cc2;\n\t\tcontinue;\n\t    }\n\t}\n#ifdef USE_UNICODE\n\tif (WcOption.ucs_conv)\n\t    cc = wc_any_to_iso2022(cc, st);\n\telse\n#endif\n\t    cc.ccs = WC_CCS_IS_WIDE(cc.ccs) ? WC_CCS_UNKNOWN_W : WC_CCS_UNKNOWN;\n\tcontinue;\n    }\n    if (! g) {\n#ifdef USE_UNICODE\n\tif (WcOption.ucs_conv && ! retry)\n\t    cc = wc_any_to_any_ces(cc, st);\n\telse\n#endif\n\t    cc.ccs = WC_CCS_IS_WIDE(cc.ccs) ? WC_CCS_UNKNOWN_W : WC_CCS_UNKNOWN;\n\tretry = WC_TRUE;\n\tcontinue;\n    }\n\n    wc_push_iso2022_esc(os, cc.ccs, g, 1, st);\n    if (is_wide)\n\tStrcat_char(os, (char)((cc.code >> 8) & 0x7f));\n    Strcat_char(os, (char)(cc.code & 0x7f));\n    return;\n  }\n}", "target": 1, "idx": 10808}
{"commit_id": "0e215b8d3de29dcec8b02ee9196ca3bfd5a8c653", "project": "nanomq/NanoNNG", "func": "property *\ndecode_buf_properties(uint8_t *packet, uint32_t packet_len, uint32_t *pos,\n    uint32_t *len, bool copy_value)\n{\n\tint       rv;\n\tuint8_t * msg_body    = packet;\n\tsize_t    msg_len     = packet_len;\n\tuint32_t  prop_len    = 0;\n\tuint8_t   bytes       = 0;\n\tuint32_t  current_pos = *pos;\n\tproperty *list        = NULL;\n\n\tif (current_pos >= msg_len) {\n\t\treturn NULL;\n\t}\n\n\tif ((rv = read_variable_int(msg_body + current_pos,\n\t         msg_len - current_pos, &prop_len, &bytes)) != 0) {\n\t\treturn NULL;\n\t}\n\tcurrent_pos += bytes;\n\tstruct pos_buf buf = { .curpos = &msg_body[current_pos],\n\t\t.endpos                = &msg_body[current_pos + prop_len] };\n\n\tif (prop_len == 0) {\n\t\tgoto out;\n\t}\n\n\tuint8_t prop_id = 0;\n\tlist            = property_alloc();\n\t/* Check properties appearance time */\n\t// TODO\n\n\tlog_debug(\"remain len %d prop len %d curpos %p endpos %p\", msg_len, prop_len, buf.curpos, buf.endpos);\n\twhile (buf.curpos < buf.endpos) {\n\t\tread_byte(&buf, &prop_id);\n\t\tproperty *         cur_prop = NULL;\n\t\tproperty_type_enum type     = property_get_value_type(prop_id);\n\t\tcur_prop =\n\t\t    property_parse(&buf, cur_prop, prop_id, type, copy_value);\n\t\tproperty_append(list, cur_prop);\n\t}\n\nout:\n\tcurrent_pos += (prop_len);\n\t*pos = current_pos;\n\t*len = prop_len;\n\treturn list;\n}", "target": 2, "idx": 10809}
{"commit_id": "c8986a876959a9d282e882d782af351a86e4034c", "project": "schismtracker", "func": "int fmt_mtm_load_song(song_t *song, slurp_t *fp, unsigned int lflags)\n{\n\tuint8_t b[192];\n\tint16_t ntrk, nchan, nord, npat, nsmp; // signed so that EOF is -1\n\tuint16_t comment_len;\n\tint n, pat, chan, smp, rows, todo = 0;\n\tsong_note_t *note;\n\tuint16_t tmp;\n\tuint32_t tmplong;\n\tsong_note_t **trackdata, *tracknote;\n\tsong_sample_t *sample;\n\n\tslurp_read(fp, b, 3);\n\tif (memcmp(b, \"MTM\", 3) != 0)\n\t\treturn LOAD_UNSUPPORTED;\n\tn = slurp_getc(fp);\n\tsprintf(song->tracker_id, \"MultiTracker %d.%d\", n >> 4, n & 0xf);\n\tslurp_read(fp, song->title, 20);\n\tsong->title[20] = 0;\n\tslurp_read(fp, &ntrk, 2);\n\tntrk = bswapLE16(ntrk);\n\tnpat = slurp_getc(fp);\n\tnord = slurp_getc(fp) + 1;\n\n\tslurp_read(fp, &comment_len, 2);\n\tcomment_len = bswapLE16(comment_len);\n\n\tnsmp = slurp_getc(fp);\n\tslurp_getc(fp); /* attribute byte (unused) */\n\trows = slurp_getc(fp); /* beats per track (translation: number of rows in every pattern) */\n\tif (rows != 64)\n\t\ttodo |= 64;\n\trows = MIN(rows, 64);\n\tnchan = slurp_getc(fp);\n\tfor (n = 0; n < 32; n++) {\n\t\tint pan = slurp_getc(fp) & 0xf;\n\t\tpan = SHORT_PANNING(pan);\n\t\tpan *= 4; //mphack\n\t\tsong->channels[n].panning = pan;\n\t}\n\tfor (n = nchan; n < MAX_CHANNELS; n++)\n\t\tsong->channels[n].flags = CHN_MUTE;\n\n\tif (slurp_eof(fp)) {\n\t\treturn LOAD_FORMAT_ERROR;\n\t}\n\n\t/* samples */\n\tif (nsmp > MAX_SAMPLES) {\n\t\tlog_appendf(4, \" Warning: Too many samples\");\n\t}\n\tfor (n = 1, sample = song->samples + 1; n <= nsmp; n++, sample++) {\n\t\tif (n > MAX_SAMPLES) {\n\t\t\tslurp_seek(fp, 37, SEEK_CUR);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* IT truncates .mtm sample names at the first \\0 rather than the normal behavior\n\t\tof presenting them as spaces (k-achaet.mtm has some \"junk\" in the sample text) */\n\t\tchar name[23];\n\t\tslurp_read(fp, name, 22);\n\t\tname[22] = '\\0';\n\t\tstrcpy(sample->name, name);\n\t\tslurp_read(fp, &tmplong, 4);\n\t\tsample->length = bswapLE32(tmplong);\n\t\tslurp_read(fp, &tmplong, 4);\n\t\tsample->loop_start = bswapLE32(tmplong);\n\t\tslurp_read(fp, &tmplong, 4);\n\t\tsample->loop_end = bswapLE32(tmplong);\n\t\tif ((sample->loop_end - sample->loop_start) > 2) {\n\t\t\tsample->flags |= CHN_LOOP;\n\t\t} else {\n\t\t\t/* Both Impulse Tracker and Modplug do this */\n\t\t\tsample->loop_start = 0;\n\t\t\tsample->loop_end = 0;\n\t\t}\n\t\tsong->samples[n].c5speed = MOD_FINETUNE(slurp_getc(fp));\n\t\tsample->volume = slurp_getc(fp);\n\t\tsample->volume *= 4; //mphack\n\t\tsample->global_volume = 64;\n\t\tif (slurp_getc(fp) & 1) {\n\t\t\ttodo |= 16;\n\t\t\tsample->flags |= CHN_16BIT;\n\t\t\tsample->length >>= 1;\n\t\t\tsample->loop_start >>= 1;\n\t\t\tsample->loop_end >>= 1;\n\t\t}\n\t\tsong->samples[n].vib_type = 0;\n\t\tsong->samples[n].vib_rate = 0;\n\t\tsong->samples[n].vib_depth = 0;\n\t\tsong->samples[n].vib_speed = 0;\n\t}\n\n\t/* orderlist */\n\tslurp_read(fp, song->orderlist, 128);\n\tmemset(song->orderlist + nord, ORDER_LAST, MAX_ORDERS - nord);\n\n\t/* tracks */\n\ttrackdata = mem_calloc(ntrk, sizeof(song_note_t *));\n\tfor (n = 0; n < ntrk; n++) {\n\t\tslurp_read(fp, b, 3 * rows);\n\t\ttrackdata[n] = mem_calloc(rows, sizeof(song_note_t));\n\t\tmtm_unpack_track(b, trackdata[n], rows);\n\t}\n\n\t/* patterns */\n\tif (npat >= MAX_PATTERNS) {\n\t\tlog_appendf(4, \" Warning: Too many patterns\");\n\t}\n\tfor (pat = 0; pat <= npat; pat++) {\n\t\t// skip ones that can't be loaded\n\t\tif (pat >= MAX_PATTERNS) {\n\t\t\tslurp_seek(fp, 64, SEEK_CUR);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsong->patterns[pat] = csf_allocate_pattern(MAX(rows, 32));\n\t\tsong->pattern_size[pat] = song->pattern_alloc_size[pat] = 64;\n\t\ttracknote = trackdata[n];\n\t\tfor (chan = 0; chan < 32; chan++) {\n\t\t\tslurp_read(fp, &tmp, 2);\n\t\t\ttmp = bswapLE16(tmp);\n\t\t\tif (tmp == 0) {\n\t\t\t\tcontinue;\n\t\t\t} else if (tmp > ntrk) {\n\t\t\t\tfor (n = 0; n < ntrk; n++)\n\t\t\t\t\tfree(trackdata[n]);\n\t\t\t\tfree(trackdata);\n\t\t\t\treturn LOAD_FORMAT_ERROR;\n\t\t\t}\n\t\t\tnote = song->patterns[pat] + chan;\n\t\t\ttracknote = trackdata[tmp - 1];\n\t\t\tfor (n = 0; n < rows; n++, tracknote++, note += MAX_CHANNELS)\n\t\t\t\t*note = *tracknote;\n\t\t}\n\t\tif (rows < 32) {\n\t\t\t/* stick a pattern break on the first channel with an empty effect column\n\t\t\t * (XXX don't do this if there's already one in another column) */\n\t\t\tnote = song->patterns[pat] + 64 * (rows - 1);\n\t\t\twhile (note->effect || note->param)\n\t\t\t\tnote++;\n\t\t\tnote->effect = FX_PATTERNBREAK;\n\t\t}\n\t}\n\n\t/* free willy */\n\tfor (n = 0; n < ntrk; n++)\n\t\tfree(trackdata[n]);\n\tfree(trackdata);\n\n\tread_lined_message(song->message, fp, comment_len, 40);\n\n\t/* sample data */\n\tif (!(lflags & LOAD_NOSAMPLES)) {\n\t\tfor (smp = 1; smp <= nsmp && smp <= MAX_SAMPLES; smp++) {\n\t\t\tuint32_t ssize;\n\n\t\t\tif (song->samples[smp].length == 0)\n\t\t\t\tcontinue;\n\t\t\tssize = csf_read_sample(song->samples + smp,\n\t\t\t\t(SF_LE | SF_PCMU | SF_M\n\t\t\t\t | ((song->samples[smp].flags & CHN_16BIT) ? SF_16 : SF_8)),\n\t\t\t\tfp->data + fp->pos, fp->length - fp->pos);\n\t\t\tslurp_seek(fp, ssize, SEEK_CUR);\n\t\t}\n\t}\n\n\t/* set the rest of the stuff */\n\tsong->flags = SONG_ITOLDEFFECTS | SONG_COMPATGXX;\n\n//      if (ferror(fp)) {\n//              return LOAD_FILE_ERROR;\n//      }\n\n\tif (todo & 64)\n\t\tlog_appendf(2, \" TODO: test this file with other players (beats per track != 64)\");\n\tif (todo & 16)\n\t\tlog_appendf(2, \" TODO: double check 16 bit sample loading\");\n\n\t/* done! */\n\treturn LOAD_SUCCESS;\n}", "target": 2, "idx": 10810}
{"commit_id": "34cc326eb2c5695833361887fe0b32e8d987741c", "project": "ArtifexSoftware/ghostpdl", "func": "static int\nexecstack2_continue(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n\n    return do_execstack(i_ctx_p, op->value.boolval, true, op - 1);\n}", "target": 1, "idx": 10811}
{"commit_id": "a70a16b28bf78403dc86ae798c291ba167573d4a", "project": "GNOME/glib", "func": "static GVariant *\ng_variant_deep_copy (GVariant *value,\n                     gboolean  byteswap)\n{\n  switch (g_variant_classify (value))\n    {\n    case G_VARIANT_CLASS_MAYBE:\n    case G_VARIANT_CLASS_TUPLE:\n    case G_VARIANT_CLASS_DICT_ENTRY:\n    case G_VARIANT_CLASS_VARIANT:\n      {\n        GVariantBuilder builder;\n        gsize i, n_children;\n\n        g_variant_builder_init (&builder, g_variant_get_type (value));\n\n        for (i = 0, n_children = g_variant_n_children (value); i < n_children; i++)\n          {\n            GVariant *child = g_variant_get_child_value (value, i);\n            g_variant_builder_add_value (&builder, g_variant_deep_copy (child, byteswap));\n            g_variant_unref (child);\n          }\n\n        return g_variant_builder_end (&builder);\n      }\n\n    case G_VARIANT_CLASS_ARRAY:\n      {\n        GVariantBuilder builder;\n        gsize i, n_children;\n        GVariant *first_invalid_child_deep_copy = NULL;\n\n        /* Arrays are in theory treated the same as maybes, tuples, dict entries\n         * and variants, and could be another case in the above block of code.\n         *\n         * However, they have the property that when dealing with non-normal\n         * data (which is the only time g_variant_deep_copy() is currently\n         * called) in a variable-sized array, the code above can easily end up\n         * creating many default child values in order to return an array which\n         * is of the right length and type, but without containing non-normal\n         * data. This can happen if the offset table for the array is malformed.\n         *\n         * In this case, the code above would end up allocating the same default\n         * value for each one of the child indexes beyond the first malformed\n         * entry in the offset table. This can end up being a lot of identical\n         * allocations of default values, particularly if the non-normal array\n         * is crafted maliciously.\n         *\n         * Avoid that problem by returning a new reference to the same default\n         * value for every child after the first invalid one. This results in\n         * returning an equivalent array, in normal form and trusted \u2014 but with\n         * significantly fewer memory allocations.\n         *\n         * See https://gitlab.gnome.org/GNOME/glib/-/issues/2540 */\n\n        g_variant_builder_init (&builder, g_variant_get_type (value));\n\n        for (i = 0, n_children = g_variant_n_children (value); i < n_children; i++)\n          {\n            /* Try maybe_get_child_value() first; if it returns NULL, this child\n             * is non-normal. get_child_value() would have constructed and\n             * returned a default value in that case. */\n            GVariant *child = g_variant_maybe_get_child_value (value, i);\n\n            if (child != NULL)\n              {\n                /* Non-normal children may not always be contiguous, as they may\n                 * be non-normal for reasons other than invalid offset table\n                 * entries. As they are all the same type, they will all have\n                 * the same default value though, so keep that around. */\n                g_variant_builder_add_value (&builder, g_variant_deep_copy (child, byteswap));\n              }\n            else if (child == NULL && first_invalid_child_deep_copy != NULL)\n              {\n                g_variant_builder_add_value (&builder, first_invalid_child_deep_copy);\n              }\n            else if (child == NULL)\n              {\n                child = g_variant_get_child_value (value, i);\n                first_invalid_child_deep_copy = g_variant_ref_sink (g_variant_deep_copy (child, byteswap));\n                g_variant_builder_add_value (&builder, first_invalid_child_deep_copy);\n              }\n\n            g_clear_pointer (&child, g_variant_unref);\n          }\n\n        g_clear_pointer (&first_invalid_child_deep_copy, g_variant_unref);\n\n        return g_variant_builder_end (&builder);\n      }\n\n    case G_VARIANT_CLASS_BOOLEAN:\n      return g_variant_new_boolean (g_variant_get_boolean (value));\n\n    case G_VARIANT_CLASS_BYTE:\n      return g_variant_new_byte (g_variant_get_byte (value));\n\n    case G_VARIANT_CLASS_INT16:\n      if (byteswap)\n        return g_variant_new_int16 (GUINT16_SWAP_LE_BE (g_variant_get_int16 (value)));\n      else\n        return g_variant_new_int16 (g_variant_get_int16 (value));\n\n    case G_VARIANT_CLASS_UINT16:\n      if (byteswap)\n        return g_variant_new_uint16 (GUINT16_SWAP_LE_BE (g_variant_get_uint16 (value)));\n      else\n        return g_variant_new_uint16 (g_variant_get_uint16 (value));\n\n    case G_VARIANT_CLASS_INT32:\n      if (byteswap)\n        return g_variant_new_int32 (GUINT32_SWAP_LE_BE (g_variant_get_int32 (value)));\n      else\n        return g_variant_new_int32 (g_variant_get_int32 (value));\n\n    case G_VARIANT_CLASS_UINT32:\n      if (byteswap)\n        return g_variant_new_uint32 (GUINT32_SWAP_LE_BE (g_variant_get_uint32 (value)));\n      else\n        return g_variant_new_uint32 (g_variant_get_uint32 (value));\n\n    case G_VARIANT_CLASS_INT64:\n      if (byteswap)\n        return g_variant_new_int64 (GUINT64_SWAP_LE_BE (g_variant_get_int64 (value)));\n      else\n        return g_variant_new_int64 (g_variant_get_int64 (value));\n\n    case G_VARIANT_CLASS_UINT64:\n      if (byteswap)\n        return g_variant_new_uint64 (GUINT64_SWAP_LE_BE (g_variant_get_uint64 (value)));\n      else\n        return g_variant_new_uint64 (g_variant_get_uint64 (value));\n\n    case G_VARIANT_CLASS_HANDLE:\n      if (byteswap)\n        return g_variant_new_handle (GUINT32_SWAP_LE_BE (g_variant_get_handle (value)));\n      else\n        return g_variant_new_handle (g_variant_get_handle (value));\n\n    case G_VARIANT_CLASS_DOUBLE:\n      if (byteswap)\n        {\n          /* We have to convert the double to a uint64 here using a union,\n           * because a cast will round it numerically. */\n          union\n            {\n              guint64 u64;\n              gdouble dbl;\n            } u1, u2;\n          u1.dbl = g_variant_get_double (value);\n          u2.u64 = GUINT64_SWAP_LE_BE (u1.u64);\n          return g_variant_new_double (u2.dbl);\n        }\n      else\n        return g_variant_new_double (g_variant_get_double (value));\n\n    case G_VARIANT_CLASS_STRING:\n      return g_variant_new_string (g_variant_get_string (value, NULL));\n\n    case G_VARIANT_CLASS_OBJECT_PATH:\n      return g_variant_new_object_path (g_variant_get_string (value, NULL));\n\n    case G_VARIANT_CLASS_SIGNATURE:\n      return g_variant_new_signature (g_variant_get_string (value, NULL));\n    }\n\n  g_assert_not_reached ();\n}", "target": 1, "idx": 10812}
{"commit_id": "b71812168571fa55e44cdd0254471331b9c4c4c6", "project": "torvalds/linux", "func": "static int ebt_size_mwt(struct compat_ebt_entry_mwt *match32,\n\t\t\tunsigned int size_left, enum compat_mwt type,\n\t\t\tstruct ebt_entries_buf_state *state, const void *base)\n{\n\tint growth = 0;\n\tchar *buf;\n\n\tif (size_left == 0)\n\t\treturn 0;\n\n\tbuf = (char *) match32;\n\n\twhile (size_left >= sizeof(*match32)) {\n\t\tstruct ebt_entry_match *match_kern;\n\t\tint ret;\n\n\t\tmatch_kern = (struct ebt_entry_match *) state->buf_kern_start;\n\t\tif (match_kern) {\n\t\t\tchar *tmp;\n\t\t\ttmp = state->buf_kern_start + state->buf_kern_offset;\n\t\t\tmatch_kern = (struct ebt_entry_match *) tmp;\n\t\t}\n\t\tret = ebt_buf_add(state, buf, sizeof(*match32));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tsize_left -= sizeof(*match32);\n\n\t\t/* add padding before match->data (if any) */\n\t\tret = ebt_buf_add_pad(state, ebt_compat_entry_padsize());\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (match32->match_size > size_left)\n\t\t\treturn -EINVAL;\n\n\t\tsize_left -= match32->match_size;\n\n\t\tret = compat_mtw_from_user(match32, type, state, base);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (WARN_ON(ret < match32->match_size))\n\t\t\treturn -EINVAL;\n\t\tgrowth += ret - match32->match_size;\n\t\tgrowth += ebt_compat_entry_padsize();\n\n\t\tbuf += sizeof(*match32);\n\t\tbuf += match32->match_size;\n\n\t\tif (match_kern)\n\t\t\tmatch_kern->match_size = ret;\n\n\t\tif (WARN_ON(type == EBT_COMPAT_TARGET && size_left))\n\t\t\treturn -EINVAL;\n\n\t\tmatch32 = (struct compat_ebt_entry_mwt *) buf;\n\t}\n\n\treturn growth;\n}", "target": 1, "idx": 10813}
{"commit_id": "3a8b0677fc6180a467e26cc32ce6b0c09a32f9bb", "project": "torvalds/linux", "func": "static int vmx_update_pi_irte(struct kvm *kvm, unsigned int host_irq,\n\t\t\t      uint32_t guest_irq, bool set)\n{\n\tstruct kvm_kernel_irq_routing_entry *e;\n\tstruct kvm_irq_routing_table *irq_rt;\n\tstruct kvm_lapic_irq irq;\n\tstruct kvm_vcpu *vcpu;\n\tstruct vcpu_data vcpu_info;\n\tint idx, ret = 0;\n\n\tif (!kvm_arch_has_assigned_device(kvm) ||\n\t\t!irq_remapping_cap(IRQ_POSTING_CAP) ||\n\t\t!kvm_vcpu_apicv_active(kvm->vcpus[0]))\n\t\treturn 0;\n\n\tidx = srcu_read_lock(&kvm->irq_srcu);\n\tirq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);\n\tif (guest_irq >= irq_rt->nr_rt_entries ||\n\t    hlist_empty(&irq_rt->map[guest_irq])) {\n\t\tpr_warn_once(\"no route for guest_irq %u/%u (broken user space?)\\n\",\n\t\t\t     guest_irq, irq_rt->nr_rt_entries);\n\t\tgoto out;\n\t}\n\n\thlist_for_each_entry(e, &irq_rt->map[guest_irq], link) {\n\t\tif (e->type != KVM_IRQ_ROUTING_MSI)\n\t\t\tcontinue;\n\t\t/*\n\t\t * VT-d PI cannot support posting multicast/broadcast\n\t\t * interrupts to a vCPU, we still use interrupt remapping\n\t\t * for these kind of interrupts.\n\t\t *\n\t\t * For lowest-priority interrupts, we only support\n\t\t * those with single CPU as the destination, e.g. user\n\t\t * configures the interrupts via /proc/irq or uses\n\t\t * irqbalance to make the interrupts single-CPU.\n\t\t *\n\t\t * We will support full lowest-priority interrupt later.\n\t\t */\n\n\t\tkvm_set_msi_irq(kvm, e, &irq);\n\t\tif (!kvm_intr_is_single_vcpu(kvm, &irq, &vcpu)) {\n\t\t\t/*\n\t\t\t * Make sure the IRTE is in remapped mode if\n\t\t\t * we don't handle it in posted mode.\n\t\t\t */\n\t\t\tret = irq_set_vcpu_affinity(host_irq, NULL);\n\t\t\tif (ret < 0) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t   \"failed to back to remapped mode, irq: %u\\n\",\n\t\t\t\t   host_irq);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tvcpu_info.pi_desc_addr = __pa(vcpu_to_pi_desc(vcpu));\n\t\tvcpu_info.vector = irq.vector;\n\n\t\ttrace_kvm_pi_irte_update(vcpu->vcpu_id, host_irq, e->gsi,\n\t\t\t\tvcpu_info.vector, vcpu_info.pi_desc_addr, set);\n\n\t\tif (set)\n\t\t\tret = irq_set_vcpu_affinity(host_irq, &vcpu_info);\n\t\telse {\n\t\t\t/* suppress notification event before unposting */\n\t\t\tpi_set_sn(vcpu_to_pi_desc(vcpu));\n\t\t\tret = irq_set_vcpu_affinity(host_irq, NULL);\n\t\t\tpi_clear_sn(vcpu_to_pi_desc(vcpu));\n\t\t}\n\n\t\tif (ret < 0) {\n\t\t\tprintk(KERN_INFO \"%s: failed to update PI IRTE\\n\",\n\t\t\t\t\t__func__);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = 0;\nout:\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n\treturn ret;\n}", "target": 1, "idx": 10814}
{"commit_id": "c63e3a4ada9852138042cb69441644bfe06ac430", "project": "GNOME/glib", "func": "static void\ng_keyfile_settings_backend_set_property (GObject      *object,\n                                         guint         prop_id,\n                                         const GValue *value,\n                                         GParamSpec   *pspec)\n{\n  GKeyfileSettingsBackend *kfsb = G_KEYFILE_SETTINGS_BACKEND (object);\n\n  switch ((GKeyfileSettingsBackendProperty)prop_id)\n    {\n    case PROP_FILENAME:\n      /* Construct only. */\n      g_assert (kfsb->file == NULL);\n      kfsb->file = g_file_new_for_path (g_value_get_string (value));\n      break;\n\n    case PROP_ROOT_PATH:\n      /* Construct only. */\n      g_assert (kfsb->prefix == NULL);\n      kfsb->prefix = g_value_dup_string (value);\n      if (kfsb->prefix)\n        kfsb->prefix_len = strlen (kfsb->prefix);\n      break;\n\n    case PROP_ROOT_GROUP:\n      /* Construct only. */\n      g_assert (kfsb->root_group == NULL);\n      kfsb->root_group = g_value_dup_string (value);\n      if (kfsb->root_group)\n        kfsb->root_group_len = strlen (kfsb->root_group);\n      break;\n\n    case PROP_DEFAULTS_DIR:\n      /* Construct only. */\n      g_assert (kfsb->defaults_dir == NULL);\n      kfsb->defaults_dir = g_value_dup_string (value);\n      break;\n\n    default:\n      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);\n      break;\n    }\n}", "target": 2, "idx": 10815}
{"commit_id": "533f285ff6fd9c2284fd290bdfbd355e302ae9a4", "project": "eclipse-wakaama/wakaama", "func": "coap_status_t\ncoap_parse_message(void *packet, uint8_t *data, uint16_t data_len)\n{\n  coap_packet_t *const coap_pkt = (coap_packet_t *) packet;\n  uint8_t *current_option;\n  unsigned int option_number = 0;\n  unsigned int option_delta = 0;\n  size_t option_length = 0;\n  unsigned int *x;\n\n  /* Initialize packet */\n  memset(coap_pkt, 0, sizeof(coap_packet_t));\n\n  /* pointer to packet bytes */\n  coap_pkt->buffer = data;\n\n  /* parse header fields */\n  coap_pkt->version = (COAP_HEADER_VERSION_MASK & coap_pkt->buffer[0])>>COAP_HEADER_VERSION_POSITION;\n  coap_pkt->type = (COAP_HEADER_TYPE_MASK & coap_pkt->buffer[0])>>COAP_HEADER_TYPE_POSITION;\n  coap_pkt->token_len = MIN(COAP_TOKEN_LEN, (COAP_HEADER_TOKEN_LEN_MASK & coap_pkt->buffer[0])>>COAP_HEADER_TOKEN_LEN_POSITION);\n  coap_pkt->code = coap_pkt->buffer[1];\n  coap_pkt->mid = coap_pkt->buffer[2]<<8 | coap_pkt->buffer[3];\n\n  if (coap_pkt->version != 1)\n  {\n    coap_error_message = \"CoAP version must be 1\";\n    return BAD_REQUEST_4_00;\n  }\n\n  current_option = data + COAP_HEADER_LEN;\n\n  if (coap_pkt->token_len != 0)\n  {\n      memcpy(coap_pkt->token, current_option, coap_pkt->token_len);\n      SET_OPTION(coap_pkt, COAP_OPTION_TOKEN);\n\n      PRINTF(\"Token (len %u) [0x%02X%02X%02X%02X%02X%02X%02X%02X]\\n\", coap_pkt->token_len,\n        coap_pkt->token[0],\n        coap_pkt->token[1],\n        coap_pkt->token[2],\n        coap_pkt->token[3],\n        coap_pkt->token[4],\n        coap_pkt->token[5],\n        coap_pkt->token[6],\n        coap_pkt->token[7]\n      ); /*FIXME always prints 8 bytes */\n  }\n\n  /* parse options */\n  current_option += coap_pkt->token_len;\n\n  while (current_option < data+data_len)\n  {\n    /* Payload marker 0xFF, currently only checking for 0xF* because rest is reserved */\n    if ((current_option[0] & 0xF0)==0xF0)\n    {\n      coap_pkt->payload = ++current_option;\n      coap_pkt->payload_len = data_len - (coap_pkt->payload - data);\n\n      break;\n    }\n\n    option_delta = current_option[0]>>4;\n    option_length = current_option[0] & 0x0F;\n    ++current_option;\n\n    /* avoids code duplication without function overhead */\n    x = &option_delta;\n    do\n    {\n      if (*x==13)\n      {\n        *x += current_option[0];\n        ++current_option;\n      }\n      else if (*x==14)\n      {\n        *x += 255;\n        *x += current_option[0]<<8;\n        ++current_option;\n        *x += current_option[0];\n        ++current_option;\n      }\n    }\n    while (x!=(unsigned int *)&option_length && (x=(unsigned int *)&option_length));\n\n    option_number += option_delta;\n\n    if (current_option + option_length > data + data_len)\n    {\n        PRINTF(\"OPTION %u (delta %u, len %u) has invalid length.\\n\", option_number, option_delta, option_length);\n        coap_free_header(coap_pkt);\n        return BAD_REQUEST_4_00;\n    }\n    else\n    {\n        PRINTF(\"OPTION %u (delta %u, len %u): \", option_number, option_delta, option_length);\n    }\n\n    SET_OPTION(coap_pkt, option_number);\n\n    switch (option_number)\n    {\n      case COAP_OPTION_CONTENT_TYPE:\n        coap_pkt->content_type = coap_parse_int_option(current_option, option_length);\n        PRINTF(\"Content-Format [%u]\\n\", coap_pkt->content_type);\n        break;\n      case COAP_OPTION_MAX_AGE:\n        coap_pkt->max_age = coap_parse_int_option(current_option, option_length);\n        PRINTF(\"Max-Age [%lu]\\n\", coap_pkt->max_age);\n        break;\n      case COAP_OPTION_ETAG:\n        coap_pkt->etag_len = (uint8_t)(MIN(COAP_ETAG_LEN, option_length));\n        memcpy(coap_pkt->etag, current_option, coap_pkt->etag_len);\n        PRINTF(\"ETag %u [0x%02X%02X%02X%02X%02X%02X%02X%02X]\\n\", coap_pkt->etag_len,\n          coap_pkt->etag[0],\n          coap_pkt->etag[1],\n          coap_pkt->etag[2],\n          coap_pkt->etag[3],\n          coap_pkt->etag[4],\n          coap_pkt->etag[5],\n          coap_pkt->etag[6],\n          coap_pkt->etag[7]\n        ); /*FIXME always prints 8 bytes */\n        break;\n      case COAP_OPTION_ACCEPT:\n        if (coap_pkt->accept_num < COAP_MAX_ACCEPT_NUM)\n        {\n          coap_pkt->accept[coap_pkt->accept_num] = coap_parse_int_option(current_option, option_length);\n          coap_pkt->accept_num += 1;\n          PRINTF(\"Accept [%u]\\n\", coap_pkt->content_type);\n        }\n        break;\n      case COAP_OPTION_IF_MATCH:\n        /*FIXME support multiple ETags */\n        coap_pkt->if_match_len = (uint8_t)(MIN(COAP_ETAG_LEN, option_length));\n        memcpy(coap_pkt->if_match, current_option, coap_pkt->if_match_len);\n        PRINTF(\"If-Match %u [0x%02X%02X%02X%02X%02X%02X%02X%02X]\\n\", coap_pkt->if_match_len,\n          coap_pkt->if_match[0],\n          coap_pkt->if_match[1],\n          coap_pkt->if_match[2],\n          coap_pkt->if_match[3],\n          coap_pkt->if_match[4],\n          coap_pkt->if_match[5],\n          coap_pkt->if_match[6],\n          coap_pkt->if_match[7]\n        ); /*FIXME always prints 8 bytes */\n        break;\n      case COAP_OPTION_IF_NONE_MATCH:\n        coap_pkt->if_none_match = 1;\n        PRINTF(\"If-None-Match\\n\");\n        break;\n\n      case COAP_OPTION_URI_HOST:\n        coap_pkt->uri_host = current_option;\n        coap_pkt->uri_host_len = option_length;\n        PRINTF(\"Uri-Host [%.*s]\\n\", coap_pkt->uri_host_len, coap_pkt->uri_host);\n        break;\n      case COAP_OPTION_URI_PORT:\n        coap_pkt->uri_port = coap_parse_int_option(current_option, option_length);\n        PRINTF(\"Uri-Port [%u]\\n\", coap_pkt->uri_port);\n        break;\n      case COAP_OPTION_URI_PATH:\n        /* coap_merge_multi_option() operates in-place on the IPBUF, but final packet field should be const string -> cast to string */\n        // coap_merge_multi_option( (char **) &(coap_pkt->uri_path), &(coap_pkt->uri_path_len), current_option, option_length, 0);\n        coap_add_multi_option( &(coap_pkt->uri_path), current_option, option_length, 1);\n        PRINTF(\"Uri-Path [%.*s]\\n\", option_length, current_option);\n        break;\n      case COAP_OPTION_URI_QUERY:\n        /* coap_merge_multi_option() operates in-place on the IPBUF, but final packet field should be const string -> cast to string */\n        // coap_merge_multi_option( (char **) &(coap_pkt->uri_query), &(coap_pkt->uri_query_len), current_option, option_length, '&');\n        coap_add_multi_option( &(coap_pkt->uri_query), current_option, option_length, 1);\n        PRINTF(\"Uri-Query [%.*s]\\n\", option_length, current_option);\n        break;\n\n      case COAP_OPTION_LOCATION_PATH:\n        coap_add_multi_option( &(coap_pkt->location_path), current_option, option_length, 1);\n        break;\n      case COAP_OPTION_LOCATION_QUERY:\n        /* coap_merge_multi_option() operates in-place on the IPBUF, but final packet field should be const string -> cast to string */\n        coap_merge_multi_option( &(coap_pkt->location_query), &(coap_pkt->location_query_len), current_option, option_length, '&');\n        PRINTF(\"Location-Query [%.*s]\\n\", option_length, current_option);\n        break;\n\n      case COAP_OPTION_PROXY_URI:\n        /*FIXME check for own end-point */\n        coap_pkt->proxy_uri = current_option;\n        coap_pkt->proxy_uri_len = option_length;\n        /*TODO length > 270 not implemented (actually not required) */\n        PRINTF(\"Proxy-Uri NOT IMPLEMENTED [%.*s]\\n\", coap_pkt->proxy_uri_len, coap_pkt->proxy_uri);\n        coap_error_message = \"This is a constrained server (Contiki)\";\n        return PROXYING_NOT_SUPPORTED_5_05;\n        break;\n\n      case COAP_OPTION_OBSERVE:\n        coap_pkt->observe = coap_parse_int_option(current_option, option_length);\n        PRINTF(\"Observe [%lu]\\n\", coap_pkt->observe);\n        break;\n      case COAP_OPTION_BLOCK2:\n        coap_pkt->block2_num = coap_parse_int_option(current_option, option_length);\n        coap_pkt->block2_more = (coap_pkt->block2_num & 0x08)>>3;\n        coap_pkt->block2_size = 16 << (coap_pkt->block2_num & 0x07);\n        coap_pkt->block2_offset = (coap_pkt->block2_num & ~0x0000000F)<<(coap_pkt->block2_num & 0x07);\n        coap_pkt->block2_num >>= 4;\n        PRINTF(\"Block2 [%lu%s (%u B/blk)]\\n\", coap_pkt->block2_num, coap_pkt->block2_more ? \"+\" : \"\", coap_pkt->block2_size);\n        break;\n      case COAP_OPTION_BLOCK1:\n        coap_pkt->block1_num = coap_parse_int_option(current_option, option_length);\n        coap_pkt->block1_more = (coap_pkt->block1_num & 0x08)>>3;\n        coap_pkt->block1_size = 16 << (coap_pkt->block1_num & 0x07);\n        coap_pkt->block1_offset = (coap_pkt->block1_num & ~0x0000000F)<<(coap_pkt->block1_num & 0x07);\n        coap_pkt->block1_num >>= 4;\n        PRINTF(\"Block1 [%lu%s (%u B/blk)]\\n\", coap_pkt->block1_num, coap_pkt->block1_more ? \"+\" : \"\", coap_pkt->block1_size);\n        break;\n      case COAP_OPTION_SIZE:\n        coap_pkt->size = coap_parse_int_option(current_option, option_length);\n        PRINTF(\"Size [%lu]\\n\", coap_pkt->size);\n        break;\n      default:\n        PRINTF(\"unknown (%u)\\n\", option_number);\n        /* Check if critical (odd) */\n        if (option_number & 1)\n        {\n          coap_error_message = \"Unsupported critical option\";\n          coap_free_header(coap_pkt);\n          return BAD_OPTION_4_02;\n        }\n    }\n\n    current_option += option_length;\n  } /* for */\n  PRINTF(\"-Done parsing-------\\n\");\n\n\n\n  return NO_ERROR;\n}", "target": 2, "idx": 10816}
{"commit_id": "520cc26d18c9ee245b56e9e91f9d4fcae02be5f0", "project": "ArtifexSoftware/mupdf", "func": "static void initialise_write_state(fz_context *ctx, pdf_document *doc, const pdf_write_options *in_opts, pdf_write_state *opts)\n{\n\tint num;\n\tint xref_len = pdf_xref_len(ctx, doc);\n\n\topts->do_incremental = in_opts->do_incremental;\n\topts->do_ascii = in_opts->do_ascii;\n\topts->do_tight = !in_opts->do_pretty;\n\topts->do_expand = in_opts->do_decompress;\n\topts->do_compress = in_opts->do_compress;\n\topts->do_compress_images = in_opts->do_compress_images;\n\topts->do_compress_fonts = in_opts->do_compress_fonts;\n\n\topts->do_garbage = in_opts->do_garbage;\n\topts->do_linear = in_opts->do_linear;\n\topts->do_clean = in_opts->do_clean;\n\topts->start = 0;\n\topts->main_xref_offset = INT_MIN;\n\n\t/* We deliberately make these arrays long enough to cope with\n\t* 1 to n access rather than 0..n-1, and add space for 2 new\n\t* extra entries that may be required for linearization. */\n\topts->list_len = 0;\n\topts->use_list = NULL;\n\topts->ofs_list = NULL;\n\topts->gen_list = NULL;\n\topts->renumber_map = NULL;\n\topts->rev_renumber_map = NULL;\n\topts->continue_on_error = in_opts->continue_on_error;\n\topts->errors = in_opts->errors;\n\n\texpand_lists(ctx, opts, xref_len + 3);\n}", "target": 2, "idx": 10817}
{"commit_id": "6d816e088c359866f9867057e04f244c608c42fe", "project": "torvalds/linux", "func": "static void io_req_task_queue(struct io_kiocb *req)\n{\n\tint ret;\n\n\tinit_task_work(&req->task_work, io_req_task_submit);\n\tpercpu_ref_get(&req->ctx->refs);\n\n\tret = io_req_task_work_add(req, &req->task_work);\n\tif (unlikely(ret)) {\n\t\tstruct task_struct *tsk;\n\n\t\tinit_task_work(&req->task_work, io_req_task_cancel);\n\t\ttsk = io_wq_get_task(req->ctx->io_wq);\n\t\ttask_work_add(tsk, &req->task_work, 0);\n\t\twake_up_process(tsk);\n\t}\n}", "target": 2, "idx": 10818}
{"commit_id": "6aa825e480d48127b480b08d13adf70033237097", "project": "facebook/hermes", "func": "std::pair<std::unique_ptr<BCProviderFromSrc>, std::string>\nBCProviderFromSrc::createBCProviderFromSrcImpl(\n    std::unique_ptr<Buffer> buffer,\n    llvh::StringRef sourceURL,\n    std::unique_ptr<SourceMap> sourceMap,\n    const CompileFlags &compileFlags,\n    const ScopeChain &scopeChain,\n    SourceErrorManager::DiagHandlerTy diagHandler,\n    void *diagContext,\n    const std::function<void(Module &)> &runOptimizationPasses) {\n  assert(\n      buffer->data()[buffer->size()] == 0 &&\n      \"The input buffer must be null terminated\");\n\n  CodeGenerationSettings codeGenOpts{};\n  codeGenOpts.unlimitedRegisters = false;\n  codeGenOpts.instrumentIR = compileFlags.instrumentIR;\n\n  OptimizationSettings optSettings;\n  // If the optional value is not set, the parser will automatically detect\n  // the 'use static builtin' directive and we will set it correctly.\n  optSettings.staticBuiltins = compileFlags.staticBuiltins.hasValue()\n      ? compileFlags.staticBuiltins.getValue()\n      : false;\n\n  auto context = std::make_shared<Context>(codeGenOpts, optSettings);\n  std::unique_ptr<SimpleDiagHandlerRAII> outputManager;\n  if (diagHandler) {\n    context->getSourceErrorManager().setDiagHandler(diagHandler, diagContext);\n  } else {\n    outputManager.reset(\n        new SimpleDiagHandlerRAII(context->getSourceErrorManager()));\n  }\n  // If a custom diagHandler was provided, it will receive the details and we\n  // just return the string \"error\" on failure.\n  auto getErrorString = [&outputManager]() {\n    return outputManager ? outputManager->getErrorString()\n                         : std::string(\"error\");\n  };\n\n  // To avoid frequent source buffer rescans, avoid emitting warnings about\n  // undefined variables.\n  context->getSourceErrorManager().setWarningStatus(\n      Warning::UndefinedVariable, false);\n\n  context->setStrictMode(compileFlags.strict);\n  context->setEnableEval(true);\n  context->setPreemptiveFunctionCompilationThreshold(\n      compileFlags.preemptiveFunctionCompilationThreshold);\n  context->setPreemptiveFileCompilationThreshold(\n      compileFlags.preemptiveFileCompilationThreshold);\n\n  if (compileFlags.lazy && !runOptimizationPasses) {\n    context->setLazyCompilation(true);\n  }\n\n  context->setGeneratorEnabled(compileFlags.enableGenerator);\n  context->setDebugInfoSetting(\n      compileFlags.debug ? DebugInfoSetting::ALL : DebugInfoSetting::THROWING);\n  context->setEmitAsyncBreakCheck(compileFlags.emitAsyncBreakCheck);\n\n  // Populate the declFileList.\n  DeclarationFileListTy declFileList;\n  if (compileFlags.includeLibHermes) {\n    auto libBuffer = llvh::MemoryBuffer::getMemBuffer(libhermes);\n    parser::JSParser libParser(*context, std::move(libBuffer));\n    auto libParsed = libParser.parse();\n    assert(libParsed && \"Libhermes failed to parse\");\n    declFileList.push_back(libParsed.getValue());\n  }\n\n  bool isLargeFile =\n      buffer->size() >= context->getPreemptiveFileCompilationThreshold();\n  int fileBufId = context->getSourceErrorManager().addNewSourceBuffer(\n      std::make_unique<HermesLLVMMemoryBuffer>(std::move(buffer), sourceURL));\n  if (sourceMap != nullptr) {\n    auto sourceMapTranslator =\n        std::make_shared<SourceMapTranslator>(context->getSourceErrorManager());\n    context->getSourceErrorManager().setTranslator(sourceMapTranslator);\n    sourceMapTranslator->addSourceMap(fileBufId, std::move(sourceMap));\n  }\n\n  auto parserMode = parser::FullParse;\n  bool useStaticBuiltinDetected = false;\n  if (context->isLazyCompilation() && isLargeFile) {\n    if (!parser::JSParser::preParseBuffer(\n            *context, fileBufId, useStaticBuiltinDetected)) {\n      return {nullptr, getErrorString()};\n    }\n    parserMode = parser::LazyParse;\n  }\n\n  sem::SemContext semCtx{};\n  parser::JSParser parser(*context, fileBufId, parserMode);\n  auto parsed = parser.parse();\n  if (!parsed || !hermes::sem::validateAST(*context, semCtx, *parsed)) {\n    return {nullptr, getErrorString()};\n  }\n  // If we are using lazy parse mode, we should have already detected the 'use\n  // static builtin' directive in the pre-parsing stage.\n  if (parserMode != parser::LazyParse) {\n    useStaticBuiltinDetected = parser.getUseStaticBuiltin();\n  }\n  // The compiler flag is not set, automatically detect 'use static builtin'\n  // from the source.\n  if (!compileFlags.staticBuiltins) {\n    context->setStaticBuiltinOptimization(useStaticBuiltinDetected);\n  }\n\n  Module M(context);\n  hermes::generateIRFromESTree(parsed.getValue(), &M, declFileList, scopeChain);\n  if (context->getSourceErrorManager().getErrorCount() > 0) {\n    return {nullptr, getErrorString()};\n  }\n\n  if (runOptimizationPasses)\n    runOptimizationPasses(M);\n\n  BytecodeGenerationOptions opts{compileFlags.format};\n  opts.optimizationEnabled = !!runOptimizationPasses;\n  opts.staticBuiltinsEnabled =\n      context->getOptimizationSettings().staticBuiltins;\n  opts.verifyIR = compileFlags.verifyIR;\n  auto BM = hbc::generateBytecodeModule(&M, M.getTopLevelFunction(), opts);\n  if (context->getSourceErrorManager().getErrorCount() > 0) {\n    return {nullptr, getErrorString()};\n  }\n  auto bytecode = createBCProviderFromSrc(std::move(BM));\n  bytecode->singleFunction_ = isSingleFunctionExpression(parsed.getValue());\n  return {std::move(bytecode), std::string{}};\n}", "target": 3, "idx": 10819}
{"commit_id": "b860822ad233304fceefc4644bd353087a5309ec", "project": "mhammond/pywin32", "func": "PyObject *addaceex(addaceexfunc addfunc, CHAR *funcname, PyACL *This, DWORD revision, DWORD aceflags, DWORD access,\n                   PyObject *obSID)\n{\n    /* AddAccessAllowedAceEx and AddAccessDeniedAceEx have the same signature and semantics */\n    if (addfunc == NULL)\n        return PyErr_Format(PyExc_NotImplementedError, \"%s not supported by this version of Windows\", funcname);\n    PSID psid;\n    BOOL bsuccess;\n    PACL pacl = This->GetACL();\n    PACL pacl_padded = NULL;\n    if (!PyWinObject_AsSID(obSID, &psid, FALSE))\n        return NULL;\n\n    bsuccess = (*addfunc)(pacl, revision, aceflags, access, psid);\n    if (bsuccess)\n        bsuccess = _ReorderACL(pacl);\n    else {\n        DWORD err = GetLastError();\n        if (err != ERROR_ALLOTTED_SPACE_EXCEEDED)\n            return PyWin_SetAPIError(funcname, err);\n        // resize if dacl too small\n        unsigned int required_size = pacl->AclSize + sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(psid);\n        // max ACL size is USHRT_MAX\n        if (required_size > USHRT_MAX)\n            return PyErr_Format(PyExc_OverflowError, \"%s: adding ACE would put ACL over size limit\", funcname);\n        pacl_padded = (ACL *)malloc(required_size);\n        if (pacl_padded == NULL)\n            return PyErr_Format(PyExc_MemoryError, \"%s: unable to allocated %d bytes\", funcname, required_size);\n\n        ZeroMemory(pacl_padded, required_size);\n        memcpy(pacl_padded, pacl, pacl->AclSize);\n        pacl_padded->AclSize = (unsigned short)required_size;\n        bsuccess = (*addfunc)(pacl_padded, revision, aceflags, access, psid);\n        if (bsuccess) {\n            bsuccess = _ReorderACL(pacl_padded);\n            if (bsuccess)\n                bsuccess = This->SetACL(pacl_padded);\n        }\n        else\n            PyWin_SetAPIError(funcname);\n    }\n    if (pacl_padded)\n        free(pacl_padded);\n    if (bsuccess) {\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n    return NULL;\n}", "target": 1, "idx": 10820}
{"commit_id": "11559e49e65bdf00922ad5ae28913ec6a198d508", "project": "pjsip/pjproject", "func": "PJ_DEF(void) pjmedia_rtcp_init2( pjmedia_rtcp_session *sess,\n\t\t\t\t const pjmedia_rtcp_session_setting *settings)\n{\n    pjmedia_rtcp_sr_pkt *sr_pkt = &sess->rtcp_sr_pkt;\n    pj_time_val now;\n    \n    /* Memset everything */\n    pj_bzero(sess, sizeof(pjmedia_rtcp_session));\n\n    /* Last RX timestamp in RTP packet */\n    sess->rtp_last_ts = (unsigned)-1;\n\n    /* Name */\n    sess->name = settings->name ? settings->name : (char*)THIS_FILE;\n\n    /* Set clock rate */\n    sess->clock_rate = settings->clock_rate;\n    sess->pkt_size = settings->samples_per_frame;\n\n    /* Init common RTCP SR header */\n    sr_pkt->common.version = 2;\n    sr_pkt->common.count = 1;\n    sr_pkt->common.pt = RTCP_SR;\n    sr_pkt->common.length = pj_htons(12);\n    sr_pkt->common.ssrc = pj_htonl(settings->ssrc);\n    \n    /* Copy to RTCP RR header */\n    pj_memcpy(&sess->rtcp_rr_pkt.common, &sr_pkt->common, \n\t      sizeof(pjmedia_rtcp_common));\n    sess->rtcp_rr_pkt.common.pt = RTCP_RR;\n    sess->rtcp_rr_pkt.common.length = pj_htons(7);\n\n    /* Copy to RTCP FB common header */\n    pj_memcpy(&sess->rtcp_fb_com, &sr_pkt->common, \n\t      sizeof(pjmedia_rtcp_common));\n    sess->rtcp_fb_com.ssrc_src = 0;\n\n    /* Get time and timestamp base and frequency */\n    pj_gettimeofday(&now);\n    sess->tv_base = now;\n    pj_get_timestamp(&sess->ts_base);\n    pj_get_timestamp_freq(&sess->ts_freq);\n    sess->rtp_ts_base = settings->rtp_ts_base;\n\n    /* Initialize statistics states */\n    pjmedia_rtcp_init_stat(&sess->stat);\n\n    /* RR will be initialized on receipt of the first RTP packet. */\n}", "target": 3, "idx": 10821}
{"commit_id": "449e8171f96a6a944d1f3b7d3627ae059eae21ca", "project": "qemu-project/qemu", "func": "int main(int argc, char *argv[])\n{\n    struct fuse_args args = FUSE_ARGS_INIT(argc, argv);\n    struct fuse_session *se;\n    struct fuse_cmdline_opts opts;\n    struct lo_data lo = {\n        .sandbox = SANDBOX_NAMESPACE,\n        .debug = 0,\n        .writeback = 0,\n        .posix_lock = 0,\n        .allow_direct_io = 0,\n        .proc_self_fd = -1,\n        .user_killpriv_v2 = -1,\n        .user_posix_acl = -1,\n    };\n    struct lo_map_elem *root_elem;\n    struct lo_map_elem *reserve_elem;\n    int ret = -1;\n\n    /* Initialize time conversion information for localtime_r(). */\n    tzset();\n\n    /* Don't mask creation mode, kernel already did that */\n    umask(0);\n\n    qemu_init_exec_dir(argv[0]);\n\n    drop_supplementary_groups();\n\n    pthread_mutex_init(&lo.mutex, NULL);\n    lo.inodes = g_hash_table_new(lo_key_hash, lo_key_equal);\n    lo.root.fd = -1;\n    lo.root.fuse_ino = FUSE_ROOT_ID;\n    lo.cache = CACHE_AUTO;\n\n    /*\n     * Set up the ino map like this:\n     * [0] Reserved (will not be used)\n     * [1] Root inode\n     */\n    lo_map_init(&lo.ino_map);\n    reserve_elem = lo_map_reserve(&lo.ino_map, 0);\n    if (!reserve_elem) {\n        fuse_log(FUSE_LOG_ERR, \"failed to alloc reserve_elem.\\n\");\n        goto err_out1;\n    }\n    reserve_elem->in_use = false;\n    root_elem = lo_map_reserve(&lo.ino_map, lo.root.fuse_ino);\n    if (!root_elem) {\n        fuse_log(FUSE_LOG_ERR, \"failed to alloc root_elem.\\n\");\n        goto err_out1;\n    }\n    root_elem->inode = &lo.root;\n\n    lo_map_init(&lo.dirp_map);\n    lo_map_init(&lo.fd_map);\n\n    if (fuse_parse_cmdline(&args, &opts) != 0) {\n        goto err_out1;\n    }\n    fuse_set_log_func(log_func);\n    use_syslog = opts.syslog;\n    if (use_syslog) {\n        openlog(\"virtiofsd\", LOG_PID, LOG_DAEMON);\n    }\n\n    if (opts.show_help) {\n        printf(\"usage: %s [options]\\n\\n\", argv[0]);\n        fuse_cmdline_help();\n        printf(\"    -o source=PATH             shared directory tree\\n\");\n        fuse_lowlevel_help();\n        ret = 0;\n        goto err_out1;\n    } else if (opts.show_version) {\n        qemu_version();\n        fuse_lowlevel_version();\n        ret = 0;\n        goto err_out1;\n    } else if (opts.print_capabilities) {\n        print_capabilities();\n        ret = 0;\n        goto err_out1;\n    }\n\n    if (fuse_opt_parse(&args, &lo, lo_opts, NULL) == -1) {\n        goto err_out1;\n    }\n\n    if (opts.log_level != 0) {\n        current_log_level = opts.log_level;\n    } else {\n        /* default log level is INFO */\n        current_log_level = FUSE_LOG_INFO;\n    }\n    lo.debug = opts.debug;\n    if (lo.debug) {\n        current_log_level = FUSE_LOG_DEBUG;\n    }\n    if (lo.source) {\n        struct stat stat;\n        int res;\n\n        res = lstat(lo.source, &stat);\n        if (res == -1) {\n            fuse_log(FUSE_LOG_ERR, \"failed to stat source (\\\"%s\\\"): %m\\n\",\n                     lo.source);\n            exit(1);\n        }\n        if (!S_ISDIR(stat.st_mode)) {\n            fuse_log(FUSE_LOG_ERR, \"source is not a directory\\n\");\n            exit(1);\n        }\n    } else {\n        lo.source = strdup(\"/\");\n        if (!lo.source) {\n            fuse_log(FUSE_LOG_ERR, \"failed to strdup source\\n\");\n            goto err_out1;\n        }\n    }\n\n    if (lo.xattrmap) {\n        lo.xattr = 1;\n        parse_xattrmap(&lo);\n    }\n\n    if (!lo.timeout_set) {\n        switch (lo.cache) {\n        case CACHE_NONE:\n            lo.timeout = 0.0;\n            break;\n\n        case CACHE_AUTO:\n            lo.timeout = 1.0;\n            break;\n\n        case CACHE_ALWAYS:\n            lo.timeout = 86400.0;\n            break;\n        }\n    } else if (lo.timeout < 0) {\n        fuse_log(FUSE_LOG_ERR, \"timeout is negative (%lf)\\n\", lo.timeout);\n        exit(1);\n    }\n\n    if (lo.user_posix_acl == 1 && !lo.xattr) {\n        fuse_log(FUSE_LOG_ERR, \"Can't enable posix ACLs. xattrs are disabled.\"\n                 \"\\n\");\n        exit(1);\n    }\n\n    lo.use_statx = true;\n\n    se = fuse_session_new(&args, &lo_oper, sizeof(lo_oper), &lo);\n    if (se == NULL) {\n        goto err_out1;\n    }\n\n    if (fuse_set_signal_handlers(se) != 0) {\n        goto err_out2;\n    }\n\n    if (fuse_session_mount(se) != 0) {\n        goto err_out3;\n    }\n\n    fuse_daemonize(opts.foreground);\n\n    setup_nofile_rlimit(opts.rlimit_nofile);\n\n    /* Must be before sandbox since it wants /proc */\n    setup_capng();\n\n    setup_sandbox(&lo, se, opts.syslog);\n\n    setup_root(&lo, &lo.root);\n    /* Block until ctrl+c or fusermount -u */\n    ret = virtio_loop(se);\n\n    fuse_session_unmount(se);\n    cleanup_capng();\nerr_out3:\n    fuse_remove_signal_handlers(se);\nerr_out2:\n    fuse_session_destroy(se);\nerr_out1:\n    fuse_opt_free_args(&args);\n\n    fuse_lo_data_cleanup(&lo);\n\n    return ret ? 1 : 0;\n}", "target": 2, "idx": 10822}
{"commit_id": "54d83fc74aa9ec72794373cb47432c5f7fb1a309", "project": "torvalds/linux", "func": "static inline int\nget_chainname_rulenum(const struct ipt_entry *s, const struct ipt_entry *e,\n\t\t      const char *hookname, const char **chainname,\n\t\t      const char **comment, unsigned int *rulenum)\n{\n\tconst struct xt_standard_target *t = (void *)ipt_get_target_c(s);\n\n\tif (strcmp(t->target.u.kernel.target->name, XT_ERROR_TARGET) == 0) {\n\t\t/* Head of user chain: ERROR target with chainname */\n\t\t*chainname = t->target.data;\n\t\t(*rulenum) = 0;\n\t} else if (s == e) {\n\t\t(*rulenum)++;\n\n\t\tif (unconditional(s) &&\n\t\t    strcmp(t->target.u.kernel.target->name,\n\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t   t->verdict < 0) {\n\t\t\t/* Tail of chains: STANDARD target (return/policy) */\n\t\t\t*comment = *chainname == hookname\n\t\t\t\t? comments[NF_IP_TRACE_COMMENT_POLICY]\n\t\t\t\t: comments[NF_IP_TRACE_COMMENT_RETURN];\n\t\t}\n\t\treturn 1;\n\t} else\n\t\t(*rulenum)++;\n\n\treturn 0;\n}", "target": 2, "idx": 10823}
{"commit_id": "693baf02152119af6e6afd30bb8ec76d14f84bbf", "project": "ArtifexSoftware/ghostpdl", "func": "static int iccompareproc(i_ctx_t *i_ctx_p, ref *space, ref *testspace)\n{\n    int code1, code2;\n    ref ICCdict1, ICCdict2, *tempref1, *tempref2;\n    int buff_size;\n\n    code1 = array_get(imemory, space, 1, &ICCdict1);\n    if (code1 < 0)\n        return 0;\n    code2 = array_get(imemory, testspace, 1, &ICCdict2);\n    if (code2 < 0)\n        return 0;\n\n    /* As a quick check see if current is same as new */\n    if (ICCdict1.value.bytes == ICCdict2.value.bytes)\n         return 1;\n\n    /* Need to check all the various parts */\n    code1 = dict_find_string(&ICCdict1, \"N\", &tempref1);\n    code2 = dict_find_string(&ICCdict2, \"N\", &tempref2);\n    if (code1 != code2)\n        return 0;\n    if (tempref1->value.intval != tempref2->value.intval)\n        return 0;\n\n    if (!comparedictkey(i_ctx_p, &ICCdict1, &ICCdict2, (char *)\"Range\"))\n        return 0;\n\n    code1 = dict_find_string(&ICCdict1, \"DataSource\", &tempref1);\n    if (code1 <= 0)\n        return 0;\n    code2 = dict_find_string(&ICCdict2, \"DataSource\", &tempref2);\n    if (code2 <= 0)\n        return 0;\n    if (r_size(tempref1) != r_size(tempref2))\n        return 0;\n\n    buff_size = r_size(tempref1);\n    if (memcmp(tempref1->value.const_bytes, tempref2->value.const_bytes, buff_size) == 0)\n        return 1;\n    else\n        return 0;\n}", "target": 2, "idx": 10824}
{"commit_id": "f960d81215ebf3f65e03d4d5d857fb9b666d6920", "project": "openssl", "func": "int GENERAL_NAME_cmp(GENERAL_NAME *a, GENERAL_NAME *b)\n{\n    int result = -1;\n\n    if (!a || !b || a->type != b->type)\n        return -1;\n    switch (a->type) {\n    case GEN_X400:\n        result = ASN1_TYPE_cmp(a->d.x400Address, b->d.x400Address);\n        break;\n\n    case GEN_EDIPARTY:\n        result = edipartyname_cmp(a->d.ediPartyName, b->d.ediPartyName);\n        break;\n\n    case GEN_OTHERNAME:\n        result = OTHERNAME_cmp(a->d.otherName, b->d.otherName);\n        break;\n\n    case GEN_EMAIL:\n    case GEN_DNS:\n    case GEN_URI:\n        result = ASN1_STRING_cmp(a->d.ia5, b->d.ia5);\n        break;\n\n    case GEN_DIRNAME:\n        result = X509_NAME_cmp(a->d.dirn, b->d.dirn);\n        break;\n\n    case GEN_IPADD:\n        result = ASN1_OCTET_STRING_cmp(a->d.ip, b->d.ip);\n        break;\n\n    case GEN_RID:\n        result = OBJ_cmp(a->d.rid, b->d.rid);\n        break;\n    }\n    return result;\n}", "target": 1, "idx": 10825}
{"commit_id": "946e51f2bf37f1656916eb75bd0742ba33983c28", "project": "torvalds/linux", "func": "void ll_invalidate_aliases(struct inode *inode)\n{\n\tstruct dentry *dentry;\n\tstruct ll_d_hlist_node *p;\n\n\tLASSERT(inode != NULL);\n\n\tCDEBUG(D_INODE, \"marking dentries for ino %lu/%u(%p) invalid\\n\",\n\t       inode->i_ino, inode->i_generation, inode);\n\n\tll_lock_dcache(inode);\n\tll_d_hlist_for_each_entry(dentry, p, &inode->i_dentry, d_u.d_alias) {\n\t\tCDEBUG(D_DENTRY, \"dentry in drop %.*s (%p) parent %p \"\n\t\t       \"inode %p flags %d\\n\", dentry->d_name.len,\n\t\t       dentry->d_name.name, dentry, dentry->d_parent,\n\t\t       dentry->d_inode, dentry->d_flags);\n\n\t\tif (unlikely(dentry == dentry->d_sb->s_root)) {\n\t\t\tCERROR(\"%s: called on root dentry=%p, fid=\"DFID\"\\n\",\n\t\t\t       ll_get_fsname(dentry->d_sb, NULL, 0),\n\t\t\t       dentry, PFID(ll_inode2fid(inode)));\n\t\t\tlustre_dump_dentry(dentry, 1);\n\t\t\tdump_stack();\n\t\t}\n\n\t\td_lustre_invalidate(dentry, 0);\n\t}\n\tll_unlock_dcache(inode);\n}", "target": 1, "idx": 10826}
{"commit_id": "19c47afbc402542720ddd280e1bbde3b2277b586", "project": "android", "func": "int SoundPool::load(const char* path, int priority __unused)\n{\n    ALOGV(\"load: path=%s, priority=%d\", path, priority);\n    int sampleID;\n    {\n        Mutex::Autolock lock(&mLock);\n        sampleID = ++mNextSampleID;\n        sp<Sample> sample = new Sample(sampleID, path);\n        mSamples.add(sampleID, sample);\n        sample->startLoad();\n    }\n    // mDecodeThread->loadSample() must be called outside of mLock.\n    // mDecodeThread->loadSample() may block on mDecodeThread message queue space;\n    // the message queue emptying may block on SoundPool::findSample().\n    //\n    // It theoretically possible that sample loads might decode out-of-order.\n    mDecodeThread->loadSample(sampleID);\n    return sampleID;\n}", "target": 2, "idx": 10827}
{"commit_id": "96d585a5e9baef21e1eea8505d78305b034dc80e", "project": "wireshark", "func": "static gboolean\niseries_check_file_type (wtap * wth, int *err, gchar **err_info, int format)\n{\n  gboolean   is_iseries = FALSE;\n  guint      line;\n  int        num_items_scanned;\n  char       buf[ISERIES_LINE_LENGTH], protocol[9];\n  iseries_t *iseries;\n\n  /* Save trace format for passing between packets */\n  iseries                = (iseries_t *) g_malloc (sizeof (iseries_t));\n  iseries->have_date     = FALSE;\n  iseries->format        = format;\n\n  for (line = 0; line < ISERIES_HDR_LINES_TO_CHECK; line++)\n    {\n      memset(buf, 0x0, sizeof(buf));\n      if (file_gets (buf, ISERIES_LINE_LENGTH, wth->fh) == NULL)\n        {\n          /* EOF or error. */\n          *err = file_error (wth->fh, err_info);\n          if (*err == WTAP_ERR_SHORT_READ)\n            *err = 0;\n          break;\n        }\n\n        /*\n         * Check that we are dealing with an ETHERNET trace\n         */\n        if (iseries->format == ISERIES_FORMAT_UNICODE)\n          {\n            iseries_UNICODE_to_ASCII ((guint8 *)buf, ISERIES_LINE_LENGTH);\n          }\n        ascii_strup_inplace (buf);\n        num_items_scanned = sscanf (buf,\n                                   \"%*[ \\n\\t]OBJECT PROTOCOL%*[ .:\\n\\t]%8s\",\n                                   protocol);\n        if (num_items_scanned == 1)\n          {\n            if (memcmp (protocol, \"ETHERNET\", 8) == 0)\n              {\n                *err = 0;\n                is_iseries = TRUE;\n              }\n          }\n\n        /*\n         * The header is the only place where the date part of the timestamp is held, so\n         * extract it here and store for all packets to access\n         */\n        num_items_scanned = sscanf (buf,\n                                    \"%*[ \\n\\t]START DATE/TIME%*[ .:\\n\\t]%2d/%2d/%2d\",\n                                    &iseries->month, &iseries->day,\n                                    &iseries->year);\n        if (num_items_scanned == 3)\n          {\n            iseries->have_date = TRUE;\n          }\n    }\n\n  if (is_iseries)\n    wth->priv = (void *) iseries;\n  else\n    g_free(iseries);\n\n  return is_iseries;\n}", "target": 1, "idx": 10828}
{"commit_id": "a79e80a25874dacaa266906a9048f13d4bac41c6", "project": "android", "func": "static FT_Error\n  tt_size_select( FT_Size   size,\n                  FT_ULong  strike_index )\n  {\n    TT_Face   ttface = (TT_Face)size->face;\n    TT_Size   ttsize = (TT_Size)size;\n    FT_Error  error  = FT_Err_Ok;\n\n\n    ttsize->strike_index = strike_index;\n\n    if ( FT_IS_SCALABLE( size->face ) )\n    {\n      /* use the scaled metrics, even when tt_size_reset fails */\n      FT_Select_Metrics( size->face, strike_index );\n\n      tt_size_reset( ttsize ); /* ignore return value */\n    }\n    else\n    {\n      SFNT_Service      sfnt         = (SFNT_Service)ttface->sfnt;\n      FT_Size_Metrics*  size_metrics = &size->metrics;\n\n\n      error = sfnt->load_strike_metrics( ttface,\n                                         strike_index,\n                                         size_metrics );\n      if ( error )\n        ttsize->strike_index = 0xFFFFFFFFUL;\n    }\n\n    return error;\n  }", "target": 3, "idx": 10829}
{"commit_id": "771ab014c24a682b32990da08e87e2f0ab765bd2", "project": "android", "func": "void FrameworkListener::init(const char *socketName UNUSED, bool withSeq) {\n    mCommands = new FrameworkCommandCollection();\n    errorRate = 0;\n    mCommandCount = 0;\n    mWithSeq = withSeq;\n    mSkipToNextNullByte = false;\n}", "target": 2, "idx": 10830}
{"commit_id": "057b8945f78f76d0b04eeb5c27cd9225e5e7ad86", "project": "torvalds/linux", "func": "static int fsl_lpspi_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct fsl_lpspi_data *fsl_lpspi;\n\tstruct spi_controller *controller;\n\tstruct spi_imx_master *lpspi_platform_info =\n\t\tdev_get_platdata(&pdev->dev);\n\tstruct resource *res;\n\tint i, ret, irq;\n\tu32 temp;\n\tbool is_slave;\n\n\tis_slave = of_property_read_bool((&pdev->dev)->of_node, \"spi-slave\");\n\tif (is_slave)\n\t\tcontroller = spi_alloc_slave(&pdev->dev,\n\t\t\t\t\tsizeof(struct fsl_lpspi_data));\n\telse\n\t\tcontroller = spi_alloc_master(&pdev->dev,\n\t\t\t\t\tsizeof(struct fsl_lpspi_data));\n\n\tif (!controller)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, controller);\n\n\tfsl_lpspi = spi_controller_get_devdata(controller);\n\tfsl_lpspi->dev = &pdev->dev;\n\tfsl_lpspi->is_slave = is_slave;\n\n\tif (!fsl_lpspi->is_slave) {\n\t\tfor (i = 0; i < controller->num_chipselect; i++) {\n\t\t\tint cs_gpio = of_get_named_gpio(np, \"cs-gpios\", i);\n\n\t\t\tif (!gpio_is_valid(cs_gpio) && lpspi_platform_info)\n\t\t\t\tcs_gpio = lpspi_platform_info->chipselect[i];\n\n\t\t\tfsl_lpspi->chipselect[i] = cs_gpio;\n\t\t\tif (!gpio_is_valid(cs_gpio))\n\t\t\t\tcontinue;\n\n\t\t\tret = devm_gpio_request(&pdev->dev,\n\t\t\t\t\t\tfsl_lpspi->chipselect[i],\n\t\t\t\t\t\tDRIVER_NAME);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(&pdev->dev, \"can't get cs gpios\\n\");\n\t\t\t\tgoto out_controller_put;\n\t\t\t}\n\t\t}\n\t\tcontroller->cs_gpios = fsl_lpspi->chipselect;\n\t\tcontroller->prepare_message = fsl_lpspi_prepare_message;\n\t}\n\n\tcontroller->bits_per_word_mask = SPI_BPW_RANGE_MASK(8, 32);\n\tcontroller->transfer_one = fsl_lpspi_transfer_one;\n\tcontroller->prepare_transfer_hardware = lpspi_prepare_xfer_hardware;\n\tcontroller->unprepare_transfer_hardware = lpspi_unprepare_xfer_hardware;\n\tcontroller->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;\n\tcontroller->flags = SPI_MASTER_MUST_RX | SPI_MASTER_MUST_TX;\n\tcontroller->dev.of_node = pdev->dev.of_node;\n\tcontroller->bus_num = pdev->id;\n\tcontroller->slave_abort = fsl_lpspi_slave_abort;\n\n\tinit_completion(&fsl_lpspi->xfer_done);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tfsl_lpspi->base = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(fsl_lpspi->base)) {\n\t\tret = PTR_ERR(fsl_lpspi->base);\n\t\tgoto out_controller_put;\n\t}\n\tfsl_lpspi->base_phys = res->start;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto out_controller_put;\n\t}\n\n\tret = devm_request_irq(&pdev->dev, irq, fsl_lpspi_isr, 0,\n\t\t\t       dev_name(&pdev->dev), fsl_lpspi);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"can't get irq%d: %d\\n\", irq, ret);\n\t\tgoto out_controller_put;\n\t}\n\n\tfsl_lpspi->clk_per = devm_clk_get(&pdev->dev, \"per\");\n\tif (IS_ERR(fsl_lpspi->clk_per)) {\n\t\tret = PTR_ERR(fsl_lpspi->clk_per);\n\t\tgoto out_controller_put;\n\t}\n\n\tfsl_lpspi->clk_ipg = devm_clk_get(&pdev->dev, \"ipg\");\n\tif (IS_ERR(fsl_lpspi->clk_ipg)) {\n\t\tret = PTR_ERR(fsl_lpspi->clk_ipg);\n\t\tgoto out_controller_put;\n\t}\n\n\t/* enable the clock */\n\tret = fsl_lpspi_init_rpm(fsl_lpspi);\n\tif (ret)\n\t\tgoto out_controller_put;\n\n\tret = pm_runtime_get_sync(fsl_lpspi->dev);\n\tif (ret < 0) {\n\t\tdev_err(fsl_lpspi->dev, \"failed to enable clock\\n\");\n\t\tgoto out_controller_put;\n\t}\n\n\ttemp = readl(fsl_lpspi->base + IMX7ULP_PARAM);\n\tfsl_lpspi->txfifosize = 1 << (temp & 0x0f);\n\tfsl_lpspi->rxfifosize = 1 << ((temp >> 8) & 0x0f);\n\n\tret = fsl_lpspi_dma_init(&pdev->dev, fsl_lpspi, controller);\n\tif (ret == -EPROBE_DEFER)\n\t\tgoto out_controller_put;\n\n\tif (ret < 0)\n\t\tdev_err(&pdev->dev, \"dma setup error %d, use pio\\n\", ret);\n\n\tret = devm_spi_register_controller(&pdev->dev, controller);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"spi_register_controller error.\\n\");\n\t\tgoto out_controller_put;\n\t}\n\n\treturn 0;\n\nout_controller_put:\n\tspi_controller_put(controller);\n\n\treturn ret;\n}", "target": 2, "idx": 10831}
{"commit_id": "a00183107d4b84bc8a714290e824ca9c68dac738", "project": "jsummers/imageworsener", "func": "static int find_high_bit(unsigned int x)\n{\n\tint i;\n\tfor(i=31;i>=0;i--) {\n\t\tif(x&(1U<<(unsigned int)i)) return i;\n\t}\n\treturn 0;\n}", "target": 2, "idx": 10832}
{"commit_id": "fd3d91ab1c6ab0628fe642dd570b56302c30a792", "project": "torvalds/linux", "func": "static int dvb_demux_open(struct inode *inode, struct file *file)\n{\n\tstruct dvb_device *dvbdev = file->private_data;\n\tstruct dmxdev *dmxdev = dvbdev->priv;\n\tint i;\n\tstruct dmxdev_filter *dmxdevfilter;\n\n\tif (!dmxdev->filter)\n\t\treturn -EINVAL;\n\n\tif (mutex_lock_interruptible(&dmxdev->mutex))\n\t\treturn -ERESTARTSYS;\n\n\tif (dmxdev->exit) {\n\t\tmutex_unlock(&dmxdev->mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tfor (i = 0; i < dmxdev->filternum; i++)\n\t\tif (dmxdev->filter[i].state == DMXDEV_STATE_FREE)\n\t\t\tbreak;\n\n\tif (i == dmxdev->filternum) {\n\t\tmutex_unlock(&dmxdev->mutex);\n\t\treturn -EMFILE;\n\t}\n\n\tdmxdevfilter = &dmxdev->filter[i];\n\tmutex_init(&dmxdevfilter->mutex);\n\tfile->private_data = dmxdevfilter;\n\n#ifdef CONFIG_DVB_MMAP\n\tdmxdev->may_do_mmap = 1;\n#else\n\tdmxdev->may_do_mmap = 0;\n#endif\n\n\tdvb_ringbuffer_init(&dmxdevfilter->buffer, NULL, 8192);\n\tdvb_vb2_init(&dmxdevfilter->vb2_ctx, \"demux_filter\",\n\t\t     file->f_flags & O_NONBLOCK);\n\tdmxdevfilter->type = DMXDEV_TYPE_NONE;\n\tdvb_dmxdev_filter_state_set(dmxdevfilter, DMXDEV_STATE_ALLOCATED);\n\ttimer_setup(&dmxdevfilter->timer, dvb_dmxdev_filter_timeout, 0);\n\n\tdvbdev->users++;\n\n\tmutex_unlock(&dmxdev->mutex);\n\treturn 0;\n}", "target": 1, "idx": 10833}
{"commit_id": "f2d3be2a8741234faaa96f5fd05fdfdc75779a79", "project": "rpm-software-management/rpm", "func": "int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,\n              rpmpsm psm, char ** failedFile)\n{\n    FD_t payload = rpmtePayload(te);\n    rpmfi fi = rpmfiNewArchiveReader(payload, files, RPMFI_ITER_READ_ARCHIVE);\n    rpmfs fs = rpmteGetFileStates(te);\n    rpmPlugins plugins = rpmtsPlugins(ts);\n    struct stat sb;\n    int saveerrno = errno;\n    int rc = 0;\n    int nodigest = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOFILEDIGEST) ? 1 : 0;\n    int nofcaps = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOCAPS) ? 1 : 0;\n    int firsthardlink = -1;\n    int skip;\n    rpmFileAction action;\n    char *tid = NULL;\n    const char *suffix;\n    char *fpath = NULL;\n\n    if (fi == NULL) {\n\trc = RPMERR_BAD_MAGIC;\n\tgoto exit;\n    }\n\n    /* transaction id used for temporary path suffix while installing */\n    rasprintf(&tid, \";%08x\", (unsigned)rpmtsGetTid(ts));\n\n    /* Detect and create directories not explicitly in package. */\n    rc = fsmMkdirs(files, fs, plugins);\n\n    while (!rc) {\n\t/* Read next payload header. */\n\trc = rpmfiNext(fi);\n\n\tif (rc < 0) {\n\t    if (rc == RPMERR_ITER_END)\n\t\trc = 0;\n\t    break;\n\t}\n\n\taction = rpmfsGetAction(fs, rpmfiFX(fi));\n\tskip = XFA_SKIPPING(action);\n\tsuffix = S_ISDIR(rpmfiFMode(fi)) ? NULL : tid;\n\tif (action != FA_TOUCH) {\n\t    fpath = fsmFsPath(fi, suffix);\n\t} else {\n\t    fpath = fsmFsPath(fi, \"\");\n\t}\n\n\t/* Remap file perms, owner, and group. */\n\trc = rpmfiStat(fi, 1, &sb);\n\n\tfsmDebug(fpath, action, &sb);\n\n        /* Exit on error. */\n        if (rc)\n            break;\n\n\t/* Run fsm file pre hook for all plugins */\n\trc = rpmpluginsCallFsmFilePre(plugins, fi, fpath,\n\t\t\t\t      sb.st_mode, action);\n\tif (rc) {\n\t    skip = 1;\n\t} else {\n\t    setFileState(fs, rpmfiFX(fi));\n\t}\n\n        if (!skip) {\n\t    int setmeta = 1;\n\n\t    /* Directories replacing something need early backup */\n\t    if (!suffix) {\n\t\trc = fsmBackup(fi, action);\n\t    }\n\t    /* Assume file does't exist when tmp suffix is in use */\n\t    if (!suffix) {\n\t\trc = fsmVerify(fpath, fi, &sb);\n\t    } else {\n\t\trc = (action == FA_TOUCH) ? 0 : RPMERR_ENOENT;\n\t    }\n\n            if (S_ISREG(sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmMkfile(fi, fpath, files, psm, nodigest,\n\t\t\t\t   &setmeta, &firsthardlink);\n\t\t}\n            } else if (S_ISDIR(sb.st_mode)) {\n                if (rc == RPMERR_ENOENT) {\n                    mode_t mode = sb.st_mode;\n                    mode &= ~07777;\n                    mode |=  00700;\n                    rc = fsmMkdir(fpath, mode);\n                }\n            } else if (S_ISLNK(sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmSymlink(rpmfiFLink(fi), fpath);\n\t\t}\n            } else if (S_ISFIFO(sb.st_mode)) {\n                /* This mimics cpio S_ISSOCK() behavior but probably isn't right */\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMkfifo(fpath, 0000);\n                }\n            } else if (S_ISCHR(sb.st_mode) ||\n                       S_ISBLK(sb.st_mode) ||\n                       S_ISSOCK(sb.st_mode))\n            {\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMknod(fpath, sb.st_mode, sb.st_rdev);\n                }\n            } else {\n                /* XXX Special case /dev/log, which shouldn't be packaged anyways */\n                if (!IS_DEV_LOG(fpath))\n                    rc = RPMERR_UNKNOWN_FILETYPE;\n            }\n\t    /* Set permissions, timestamps etc for non-hardlink entries */\n\t    if (!rc && setmeta) {\n\t\trc = fsmSetmeta(fpath, fi, plugins, action, &sb, nofcaps);\n\t    }\n        } else if (firsthardlink >= 0 && rpmfiArchiveHasContent(fi)) {\n\t    /* we skip the hard linked file containing the content */\n\t    /* write the content to the first used instead */\n\t    char *fn = rpmfilesFN(files, firsthardlink);\n\t    rc = expandRegular(fi, fn, psm, 0, nodigest, 0);\n\t    firsthardlink = -1;\n\t    free(fn);\n\t}\n\n        if (rc) {\n            if (!skip) {\n                /* XXX only erase if temp fn w suffix is in use */\n                if (suffix && (action != FA_TOUCH)) {\n\t\t    (void) fsmRemove(fpath, sb.st_mode);\n                }\n                errno = saveerrno;\n            }\n        } else {\n\t    /* Notify on success. */\n\t    rpmpsmNotify(psm, RPMCALLBACK_INST_PROGRESS, rpmfiArchiveTell(fi));\n\n\t    if (!skip) {\n\t\t/* Backup file if needed. Directories are handled earlier */\n\t\tif (suffix)\n\t\t    rc = fsmBackup(fi, action);\n\n\t\tif (!rc)\n\t\t    rc = fsmCommit(&fpath, fi, action, suffix);\n\t    }\n\t}\n\n\tif (rc)\n\t    *failedFile = xstrdup(fpath);\n\n\t/* Run fsm file post hook for all plugins */\n\trpmpluginsCallFsmFilePost(plugins, fi, fpath,\n\t\t\t\t  sb.st_mode, action, rc);\n\tfpath = _free(fpath);\n    }\n\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_UNCOMPRESS), fdOp(payload, FDSTAT_READ));\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_DIGEST), fdOp(payload, FDSTAT_DIGEST));\n\nexit:\n\n    /* No need to bother with close errors on read */\n    rpmfiArchiveClose(fi);\n    rpmfiFree(fi);\n    Fclose(payload);\n    free(tid);\n    free(fpath);\n\n    return rc;\n}", "target": 2, "idx": 10834}
{"commit_id": "9fdcc15962f9ff4baebe6fdd947816f43f730d50", "project": "redis", "func": "static void cliRefreshPrompt(void) {\n    if (config.eval_ldb) return;\n\n    sds prompt = sdsempty();\n    if (config.hostsocket != NULL) {\n        prompt = sdscatfmt(prompt,\"redis %s\",config.hostsocket);\n    } else {\n        char addr[256];\n        anetFormatAddr(addr, sizeof(addr), config.hostip, config.hostport);\n        prompt = sdscatlen(prompt,addr,strlen(addr));\n    }\n\n    /* Add [dbnum] if needed */\n    if (config.dbnum != 0)\n        prompt = sdscatfmt(prompt,\"[%i]\",config.dbnum);\n\n    /* Copy the prompt in the static buffer. */\n    prompt = sdscatlen(prompt,\"> \",2);\n    snprintf(config.prompt,sizeof(config.prompt),\"%s\",prompt);\n    sdsfree(prompt);\n}", "target": 2, "idx": 10835}
{"commit_id": "69082916c8b5d321545d60b9f5facad0a2dd5a4e", "project": "vim", "func": "char_u *\neval_next_non_blank(char_u *arg, evalarg_T *evalarg, int *getnext)\n{\n    char_u *p = skipwhite(arg);\n\n    *getnext = FALSE;\n    if (in_vim9script()\n\t    && evalarg != NULL\n\t    && (evalarg->eval_cookie != NULL || evalarg->eval_cctx != NULL\n\t\t\t\t\t\t\t\t   || *p == NL)\n\t    && (*p == NUL || *p == NL\n\t\t\t     || (vim9_comment_start(p) && VIM_ISWHITE(p[-1]))))\n    {\n\tchar_u *next;\n\n\tif (*p == NL)\n\t    next = newline_skip_comments(p);\n\telse if (evalarg->eval_cookie != NULL)\n\t    next = getline_peek_skip_comments(evalarg);\n\telse\n\t    next = peek_next_line_from_context(evalarg->eval_cctx);\n\n\tif (next != NULL)\n\t{\n\t    *getnext = *p != NL;\n\t    return skipwhite(next);\n\t}\n    }\n    return p;\n}", "target": 1, "idx": 10836}
{"commit_id": "f55cbcde2c8f74b652add4450b0592082eb6acff", "project": "wireshark", "func": "static void\nadd_capabilities (proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb, guint8 pdu_type)\n{\n    proto_tree *wsp_capabilities, *cap_subtree, *cap_subtree2;\n    proto_item *ti, *cap_item, *cap_item2;\n\n    char       *capaName, *str;\n    guint32     offset       = 0;\n    guint32     len          = 0;\n    guint32     capaStart    = 0; /* Start offset of the capability */\n    guint32     capaLen      = 0; /* Length of the entire capability */\n    guint32     capaValueLen = 0; /* Length of the capability value & type */\n    guint32     tvb_len      = tvb_reported_length(tvb);\n    gboolean    ok           = FALSE;\n    guint8      peek;\n    guint32     value;\n\n    if (tvb_len == 0) {\n        return;\n    }\n\n    ti = proto_tree_add_item(tree, hf_capabilities_section,\n            tvb, 0, tvb_len, ENC_NA);\n    wsp_capabilities = proto_item_add_subtree(ti, ett_capabilities);\n\n    while (offset < tvb_len) {\n        /*\n         * WSP capabilities consist of:\n         *  - a guint32 length field,\n         *  - a capability identifier as Token-text or Short-integer,\n         *  - a capability-specific sequence of <length> octets.\n         */\n        capaStart = offset;\n        /*\n         * Now Offset points to the 1st byte of a capability field.\n         * Get the length of the capability field\n         */\n        capaValueLen = tvb_get_guintvar(tvb, offset, &len, pinfo, &ei_wsp_oversized_uintvar);\n        capaLen = capaValueLen + len;\n\n        cap_subtree = proto_tree_add_subtree(wsp_capabilities, tvb, offset, capaLen, ett_capabilities_entry, &cap_item, \"Capability\");\n        if (capaValueLen > tvb_len)\n            return;\n        offset += len;\n        /*\n         * Now offset points to the 1st byte of the capability type.\n         * Get the capability identifier.\n         */\n        peek = tvb_get_guint8(tvb, offset);\n        if (is_token_text(peek)) { /* Literal capability name */\n            /* 1. Get the string from the tvb */\n            capaName = (gchar *)tvb_get_stringz_enc(wmem_packet_scope(), tvb, capaStart, (gint *)&len, ENC_ASCII);\n\n            /* 2. Look up the string capability name */\n            if (g_ascii_strcasecmp(capaName, \"client-sdu-size\") == 0) {\n                peek = WSP_CAPA_CLIENT_SDU_SIZE;\n            } else if (g_ascii_strcasecmp(capaName, \"server-sdu-size\") == 0) {\n                peek = WSP_CAPA_SERVER_SDU_SIZE;\n            } else if (g_ascii_strcasecmp(capaName, \"protocol options\") == 0) {\n                peek = WSP_CAPA_PROTOCOL_OPTIONS;\n            } else if (g_ascii_strcasecmp(capaName, \"method-mor\") == 0) {\n                peek = WSP_CAPA_METHOD_MOR;\n            } else if (g_ascii_strcasecmp(capaName, \"push-mor\") == 0) {\n                peek = WSP_CAPA_PUSH_MOR;\n            } else if (g_ascii_strcasecmp(capaName, \"extended methods\") == 0) {\n                peek = WSP_CAPA_EXTENDED_METHODS;\n            } else if (g_ascii_strcasecmp(capaName, \"header code pages\") == 0) {\n                peek = WSP_CAPA_HEADER_CODE_PAGES;\n            } else if (g_ascii_strcasecmp(capaName, \"aliases\") == 0) {\n                peek = WSP_CAPA_ALIASES;\n            } else if (g_ascii_strcasecmp(capaName, \"client-message-size\") == 0) {\n                peek = WSP_CAPA_CLIENT_MESSAGE_SIZE;\n            } else if (g_ascii_strcasecmp(capaName, \"server-message-size\") == 0) {\n                peek = WSP_CAPA_SERVER_MESSAGE_SIZE;\n            } else {\n                expert_add_info_format(pinfo, cap_item, &ei_wsp_capability_invalid,\n                        \"Unknown or invalid textual capability: %s\", capaName);\n                /* Skip this capability */\n                offset = capaStart + capaLen;\n                continue;\n            }\n            offset += len;\n            /* Now offset points to the 1st value byte of the capability. */\n        } else if (peek < 0x80) {\n            expert_add_info_format(pinfo, cap_item, &ei_wsp_capability_invalid,\n                    \"Invalid well-known capability: 0x%02X\", peek);\n            /* Skip further capability parsing */\n            return;\n        }\n        if (peek & 0x80) { /* Well-known capability */\n            peek &= 0x7F;\n            len = 1;\n            offset++;\n            /* Now offset points to the 1st value byte of the capability. */\n        }\n\n        proto_item_append_text(cap_item, \": %s\", val_to_str_const(peek, wsp_capability_vals, \"Invalid capability\"));\n        /* Now the capability type is known */\n        switch (peek) {\n            case WSP_CAPA_CLIENT_SDU_SIZE:\n                value = tvb_get_guintvar(tvb, offset, &len, pinfo, &ei_wsp_oversized_uintvar);\n                proto_tree_add_uint(cap_subtree, hf_capa_client_sdu_size,\n                        tvb, offset, len, value);\n                break;\n            case WSP_CAPA_SERVER_SDU_SIZE:\n                value = tvb_get_guintvar(tvb, offset, &len, pinfo, &ei_wsp_oversized_uintvar);\n                proto_tree_add_uint(cap_subtree, hf_capa_server_sdu_size,\n                        tvb, offset, len, value);\n                break;\n            case WSP_CAPA_PROTOCOL_OPTIONS:\n                /*\n                 * The bits are stored in one or more octets, not an\n                 * uintvar-integer! Note that capability name and value\n                 * have length capaValueLength, and that the capability\n                 * name has length = len. Hence the remaining length is\n                 * given by capaValueLen - len.\n                 */\n                if (capaValueLen - len == 1) {\n                    static const int * capabilities[] = {\n                        &hf_capa_protocol_option_confirmed_push,\n                        &hf_capa_protocol_option_push,\n                        &hf_capa_protocol_option_session_resume,\n                        &hf_capa_protocol_option_ack_headers,\n                        &hf_capa_protocol_option_large_data_transfer,\n                        NULL\n                    };\n\n                    proto_tree_add_bitmask_with_flags(cap_subtree, tvb, offset, hf_capa_protocol_options,\n                                   ett_proto_option_capability, capabilities, ENC_NA, BMT_NO_FALSE);\n                }\n                else\n                {\n                    /*\n                     * The WSP spec foresees that this bit field can be\n                     * extended in the future. This does not make sense yet.\n                     */\n                    proto_item_append_text(cap_item,\n                            \" <warning: bit field too large>\");\n                    offset = capaStart + capaLen;\n                    continue;\n                }\n                break;\n            case WSP_CAPA_METHOD_MOR:\n                proto_tree_add_item(cap_subtree, hf_capa_method_mor, tvb, offset, len, ENC_NA);\n                break;\n            case WSP_CAPA_PUSH_MOR:\n                proto_tree_add_item(cap_subtree, hf_capa_push_mor, tvb, offset, len, ENC_NA);\n               break;\n            case WSP_CAPA_EXTENDED_METHODS:\n                /* Extended Methods capability format:\n                 * Connect PDU: collection of { Method (octet), Method-name (Token-text) }\n                 * ConnectReply PDU: collection of accepted { Method (octet) }\n                 */\n                cap_subtree2 = proto_tree_add_subtree(cap_subtree, tvb, capaStart, capaLen, ett_capabilities_extended_methods, &cap_item2, \"Extended Methods\");\n                if (pdu_type == WSP_PDU_CONNECT) {\n                    while (offset < capaStart + capaLen) {\n                        ti = proto_tree_add_item(cap_subtree2, hf_capa_extended_method, tvb, offset, 1, ENC_NA);\n                        offset++;\n\n                        get_text_string(str, tvb, offset, len, ok);\n                        if (! ok) {\n                            expert_add_info(pinfo, ti, &ei_wsp_capability_encoding_invalid);\n                            return;\n                        }\n                        proto_item_append_text(ti, \" = %s\", str);\n                        proto_item_set_len(ti, len+1);\n                        offset += len;\n                    }\n                } else {\n                    while (offset < capaStart + capaLen) {\n                        proto_tree_add_item(cap_subtree2, hf_capa_extended_method, tvb, offset, 1, ENC_NA);\n                        offset++;\n                    }\n                }\n                break;\n            case WSP_CAPA_HEADER_CODE_PAGES:\n                /* Header Code Pages capability format:\n                 * Connect PDU: collection of { Page-id (octet), Page-name (Token-text) }\n                 * ConnectReply PDU: collection of accepted { Page-id (octet) }\n                 */\n                cap_subtree2 = proto_tree_add_subtree(cap_subtree, tvb, capaStart, capaLen, ett_capabilities_header_code_pages, &cap_item2, \"Header Code Pages\");\n                if (pdu_type == WSP_PDU_CONNECT) {\n                    while (offset < capaStart + capaLen) {\n                        ti = proto_tree_add_item(cap_subtree2, hf_capa_header_code_page, tvb, offset, 1, ENC_NA);\n                        offset++;\n\n                        get_text_string(str, tvb, offset, len, ok);\n                        if (! ok) {\n                            expert_add_info(pinfo, ti, &ei_wsp_capability_encoding_invalid);\n                            return;\n                        }\n                        proto_item_append_text(ti, \" = %s\", str);\n                        proto_item_set_len(ti, len+1);\n                        offset += len;\n                    }\n                } else {\n                    while (offset < capaStart + capaLen) {\n                        proto_tree_add_item(cap_subtree2, hf_capa_header_code_page, tvb, offset, 1, ENC_NA);\n                        offset++;\n                    }\n                }\n                break;\n            case WSP_CAPA_ALIASES:\n                /* TODO - same format as redirect addresses */\n                proto_tree_add_item(cap_subtree, hf_capa_aliases,\n                        tvb, capaStart, capaLen, ENC_NA);\n                break;\n            case WSP_CAPA_CLIENT_MESSAGE_SIZE:\n                value = tvb_get_guintvar(tvb, offset, &len, pinfo, &ei_wsp_oversized_uintvar);\n                proto_tree_add_uint(cap_subtree, hf_capa_client_message_size,\n                        tvb, offset, len, value);\n                break;\n            case WSP_CAPA_SERVER_MESSAGE_SIZE:\n                value = tvb_get_guintvar(tvb, offset, &len, pinfo, &ei_wsp_oversized_uintvar);\n                proto_tree_add_uint(cap_subtree, hf_capa_server_message_size,\n                        tvb, offset, len, value);\n                break;\n            default:\n                expert_add_info_format(pinfo, cap_item, &ei_wsp_capability_invalid,\n                        \"Unknown well-known capability: 0x%02X\", peek);\n                break;\n        }\n        offset = capaStart + capaLen;\n    }\n}", "target": 2, "idx": 10837}
{"commit_id": "65f8ea4cd57dbd46ea13b41dc8bac03176b04233", "project": "torvalds/linux", "func": "static struct buffer_head *__ext4_read_dirblock(struct inode *inode,\n\t\t\t\t\t\text4_lblk_t block,\n\t\t\t\t\t\tdirblock_type_t type,\n\t\t\t\t\t\tconst char *func,\n\t\t\t\t\t\tunsigned int line)\n{\n\tstruct buffer_head *bh;\n\tstruct ext4_dir_entry *dirent;\n\tint is_dx_block = 0;\n\n\tif (block >= inode->i_size) {\n\t\text4_error_inode(inode, func, line, block,\n\t\t       \"Attempting to read directory block (%u) that is past i_size (%llu)\",\n\t\t       block, inode->i_size);\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\t}\n\n\tif (ext4_simulate_fail(inode->i_sb, EXT4_SIM_DIRBLOCK_EIO))\n\t\tbh = ERR_PTR(-EIO);\n\telse\n\t\tbh = ext4_bread(NULL, inode, block, 0);\n\tif (IS_ERR(bh)) {\n\t\t__ext4_warning(inode->i_sb, func, line,\n\t\t\t       \"inode #%lu: lblock %lu: comm %s: \"\n\t\t\t       \"error %ld reading directory block\",\n\t\t\t       inode->i_ino, (unsigned long)block,\n\t\t\t       current->comm, PTR_ERR(bh));\n\n\t\treturn bh;\n\t}\n\tif (!bh && (type == INDEX || type == DIRENT_HTREE)) {\n\t\text4_error_inode(inode, func, line, block,\n\t\t\t\t \"Directory hole found for htree %s block\",\n\t\t\t\t (type == INDEX) ? \"index\" : \"leaf\");\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\t}\n\tif (!bh)\n\t\treturn NULL;\n\tdirent = (struct ext4_dir_entry *) bh->b_data;\n\t/* Determine whether or not we have an index block */\n\tif (is_dx(inode)) {\n\t\tif (block == 0)\n\t\t\tis_dx_block = 1;\n\t\telse if (ext4_rec_len_from_disk(dirent->rec_len,\n\t\t\t\t\t\tinode->i_sb->s_blocksize) ==\n\t\t\t inode->i_sb->s_blocksize)\n\t\t\tis_dx_block = 1;\n\t}\n\tif (!is_dx_block && type == INDEX) {\n\t\text4_error_inode(inode, func, line, block,\n\t\t       \"directory leaf block found instead of index block\");\n\t\tbrelse(bh);\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\t}\n\tif (!ext4_has_metadata_csum(inode->i_sb) ||\n\t    buffer_verified(bh))\n\t\treturn bh;\n\n\t/*\n\t * An empty leaf block can get mistaken for a index block; for\n\t * this reason, we can only check the index checksum when the\n\t * caller is sure it should be an index block.\n\t */\n\tif (is_dx_block && type == INDEX) {\n\t\tif (ext4_dx_csum_verify(inode, dirent) &&\n\t\t    !ext4_simulate_fail(inode->i_sb, EXT4_SIM_DIRBLOCK_CRC))\n\t\t\tset_buffer_verified(bh);\n\t\telse {\n\t\t\text4_error_inode_err(inode, func, line, block,\n\t\t\t\t\t     EFSBADCRC,\n\t\t\t\t\t     \"Directory index failed checksum\");\n\t\t\tbrelse(bh);\n\t\t\treturn ERR_PTR(-EFSBADCRC);\n\t\t}\n\t}\n\tif (!is_dx_block) {\n\t\tif (ext4_dirblock_csum_verify(inode, bh) &&\n\t\t    !ext4_simulate_fail(inode->i_sb, EXT4_SIM_DIRBLOCK_CRC))\n\t\t\tset_buffer_verified(bh);\n\t\telse {\n\t\t\text4_error_inode_err(inode, func, line, block,\n\t\t\t\t\t     EFSBADCRC,\n\t\t\t\t\t     \"Directory block failed checksum\");\n\t\t\tbrelse(bh);\n\t\t\treturn ERR_PTR(-EFSBADCRC);\n\t\t}\n\t}\n\treturn bh;\n}", "target": 2, "idx": 10838}
{"commit_id": "657e6c81c474bdee0e6413483b990e90610030c1", "project": "nanomq/NanoNNG", "func": "static void\nmqtts_tcptran_pipe_recv_cb(void *arg)\n{\n\tnni_aio *           aio;\n\tnni_iov             iov;\n\tuint8_t             type, pos, flags;\n\tuint32_t            len = 0, rv;\n\tsize_t              n;\n\tnni_msg *           msg, *qmsg;\n\tmqtts_tcptran_pipe *p     = arg;\n\tnni_aio *           rxaio = p->rxaio;\n\tbool                ack   = false;\n\tnni_mtx_lock(&p->mtx);\n\n\taio = nni_list_first(&p->recvq);\n\n\tif ((rv = nni_aio_result(rxaio)) != 0) {\n\t\trv = SERVER_UNAVAILABLE;\n\t\tgoto recv_error;\n\t}\n\n\tn = nni_aio_count(rxaio);\n\tp->gotrxhead += n;\n\n\t// in case one aio is not enough for handling whole buffer\n\tnni_aio_iov_advance(rxaio, n);\n\tif (nni_aio_iov_count(rxaio) > 0) {\n\t\tnng_stream_recv(p->conn, rxaio);\n\t\tnni_mtx_unlock(&p->mtx);\n\t\treturn;\n\t}\n\n\trv = mqtt_get_remaining_length(p->rxlen, p->gotrxhead, &len, &pos);\n\tp->wantrxhead = len + 1 + pos;\n\tif (p->gotrxhead <= 5 && p->rxlen[p->gotrxhead - 1] > 0x7f) {\n\t\tif (p->gotrxhead == NNI_NANO_MAX_HEADER_SIZE) {\n\t\t\trv = PACKET_TOO_LARGE;\n\t\t\tgoto recv_error;\n\t\t}\n\t\t// same packet, continue receving next byte of remaining length\n\t\tiov.iov_buf = &p->rxlen[p->gotrxhead];\n\t\tiov.iov_len = 1;\n\t\tnni_aio_set_iov(rxaio, 1, &iov);\n\t\tnng_stream_recv(p->conn, rxaio);\n\t\tnni_mtx_unlock(&p->mtx);\n\t\treturn;\n\t}\n\n\t// fixed header finished\n\tif (NULL == p->rxmsg) {\n\t\t// Make sure the message payload is not too big.  If it is\n\t\t// the caller will shut down the pipe.\n\t\tif ((len > p->rcvmax) && (p->rcvmax > 0)) {\n\t\t\trv = PACKET_TOO_LARGE;\n\t\t\tgoto recv_error;\n\t\t}\n\t\tif ((rv = nni_msg_alloc(&p->rxmsg, (size_t) len)) != 0) {\n\t\t\trv = UNSPECIFIED_ERROR;\n\t\t\tgoto recv_error;\n\t\t}\n\t\tnni_msg_set_remaining_len(p->rxmsg, len);\n\n\t\t// Submit the rest of the data for a read -- seperate Fixed\n\t\t// header with variable header and so on\n\t\t//  we want to read the entire message now.\n\t\tif (len != 0) {\n\t\t\tiov.iov_buf = nni_msg_body(p->rxmsg);\n\t\t\tiov.iov_len = (size_t) len;\n\n\t\t\tnni_aio_set_iov(rxaio, 1, &iov);\n\t\t\t// second recv action\n\t\t\tnng_stream_recv(p->conn, rxaio);\n\t\t\tnni_mtx_unlock(&p->mtx);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// We read a message completely.  Let the user know the good news. use\n\t// as application message callback of users\n\tnni_aio_list_remove(aio);\n\tnni_msg_header_append(p->rxmsg, p->rxlen, pos + 1);\n\tmsg      = p->rxmsg;\n\tp->rxmsg = NULL;\n\tn        = nni_msg_len(msg);\n\ttype     = p->rxlen[0] & 0xf0;\n\tflags    = p->rxlen[0] & 0x0f;\n\t// set the payload pointer of msg according to packet_type\n\tuint8_t   qos_pac;\n\tuint16_t  packet_id   = 0;\n\tuint8_t   reason_code = 0;\n\tproperty *prop        = NULL;\n\tuint8_t   ack_cmd     = 0;\n\tswitch (type) {\n\tcase CMD_PUBLISH:\n\t\t// should we seperate the 2 phase work of QoS into 2 aios?\n\t\t// TODO MQTT v5 qos\n\t\tqos_pac = nni_msg_get_pub_qos(msg);\n\t\tif (qos_pac > 0) {\n\t\t\tif (qos_pac == 1) {\n\t\t\t\tack_cmd = CMD_PUBACK;\n\t\t\t} else if (qos_pac == 2) {\n\t\t\t\tack_cmd = CMD_PUBREC;\n\t\t\t} else {\n\t\t\t\tlog_warn(\"Wrong QoS level!\");\n\t\t\t\trv = PROTOCOL_ERROR;\n\t\t\t\tgoto recv_error;\n\t\t\t}\n\t\t\tif ((packet_id = nni_msg_get_pub_pid(msg)) == 0) {\n\t\t\t\trv = PROTOCOL_ERROR;\n\t\t\t\tgoto recv_error;\n\t\t\t}\n\t\t\tack = true;\n\t\t}\n\t\tbreak;\n\tcase CMD_PUBREC:\n\t\tif (nni_mqtt_pubres_decode(msg, &packet_id, &reason_code, &prop,\n\t\t        p->proto) != 0) {\n\t\t\trv = PROTOCOL_ERROR;\n\t\t\tgoto recv_error;\n\t\t}\n\t\tack_cmd = CMD_PUBREL;\n\t\tack     = true;\n\t\tbreak;\n\tcase CMD_PUBREL:\n\t\tif (flags == 0x02) {\n\t\t\tif (nni_mqtt_pubres_decode(msg, &packet_id, &reason_code,\n\t\t\t        &prop, p->proto) != 0) {\n\t\t\t\trv = PROTOCOL_ERROR;\n\t\t\t\tgoto recv_error;\n\t\t\t}\n\t\t\tack_cmd = CMD_PUBCOMP;\n\t\t\tack     = true;\n\t\t\tbreak;\n\t\t} else {\n\t\t\trv = PROTOCOL_ERROR;\n\t\t\tgoto recv_error;\n\t\t}\n\tcase CMD_PUBACK:\n\t\t// TODO set property for user callback\n\tcase CMD_PUBCOMP:\n\t\tif (nni_mqtt_pubres_decode(\n\t\t        msg, &packet_id, &reason_code, &prop, p->proto) != 0) {\n\t\t\trv = PROTOCOL_ERROR;\n\t\t\tgoto recv_error;\n\t\t}\n\t\tif (p->proto == MQTT_PROTOCOL_VERSION_v5) {\n\t\t\tp->sndmax++;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (ack == true) {\n\t\t// alloc a msg here costs memory. However we must do it for the\n\t\t// sake of compatibility with nng.\n\t\tif ((rv = nni_msg_alloc(&qmsg, 0)) != 0) {\n\t\t\tack = false;\n\t\t\trv  = UNSPECIFIED_ERROR;\n\t\t\tgoto recv_error;\n\t\t}\n\t\t// TODO set reason code or property here if necessary\n\t\tnni_mqtt_msgack_encode(\n\t\t    qmsg, packet_id, reason_code, prop, p->proto);\n\t\tnni_mqtt_pubres_header_encode(qmsg, ack_cmd);\n\t\tif (p->proto == MQTT_PROTOCOL_VERSION_v5) {\n\t\t\tproperty_free(prop);\n\t\t}\n\t\t// aio_begin?\n\t\tif (p->busy == false) {\n\t\t\tnni_msg_insert(qmsg, nni_msg_header(qmsg),\n\t\t\t    nni_msg_header_len(qmsg));\n\t\t\tiov.iov_len    = nni_msg_len(qmsg);\n\t\t\tiov.iov_buf    = nni_msg_body(qmsg);\n\t\t\tp->busy        = true;\n\t\t\tnni_aio_set_msg(p->qsaio, qmsg);\n\t\t\t// send ACK down...\n\t\t\tnni_aio_set_iov(p->qsaio, 1, &iov);\n\t\t\tnng_stream_send(p->conn, p->qsaio);\n\t\t} else {\n\t\t\tif (nni_lmq_full(&p->rslmq)) {\n\t\t\t\t// Make space for the new message. TODO add max\n\t\t\t\t// limit of msgq len in conf\n\t\t\t\tif (nni_lmq_cap(&p->rslmq) <=\n\t\t\t\t    NNG_TRAN_MAX_LMQ_SIZE) {\n\t\t\t\t\tif ((rv = nni_lmq_resize(&p->rslmq,\n\t\t\t\t\t         nni_lmq_cap(&p->rslmq) *\n\t\t\t\t\t             2)) == 0) {\n\t\t\t\t\t\tnni_lmq_put(&p->rslmq, qmsg);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// memory error.\n\t\t\t\t\t\tnni_msg_free(qmsg);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnni_msg *old;\n\t\t\t\t\t(void) nni_lmq_get(&p->rslmq, &old);\n\t\t\t\t\tnni_msg_free(old);\n\t\t\t\t\tnni_lmq_put(&p->rslmq, qmsg);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnni_lmq_put(&p->rslmq, qmsg);\n\t\t\t}\n\t\t}\n\t\tack = false;\n\t}\n\n\t// keep connection & Schedule next receive\n\tnni_pipe_bump_rx(p->npipe, n);\n\tif (!nni_list_empty(&p->recvq)) {\n\t\tmqtts_tcptran_pipe_recv_start(p);\n\t}\n#ifdef NNG_HAVE_MQTT_BROKER\n\tnni_msg_set_conn_param(msg, p->cparam);\n#endif\n\tnni_aio_set_msg(aio, msg);\n\tp->pingcnt = 0;\n\tnni_mtx_unlock(&p->mtx);\n\tnni_aio_finish_sync(aio, 0, n);\n\treturn;\n\nrecv_error:\n\tnni_aio_list_remove(aio);\n\tmsg      = p->rxmsg;\n\tp->rxmsg = NULL;\n\tnni_pipe_bump_error(p->npipe, rv);\n\tnni_mtx_unlock(&p->mtx);\n\n\tnni_msg_free(msg);\n\tnni_aio_finish_error(aio, rv);\n}", "target": 2, "idx": 10839}
{"commit_id": "1f097d168d9cad473dd44010a337c1413a9cd198", "project": "ffmpeg", "func": "static int decode_update_thread_context(AVCodecContext *dst,\n                                        const AVCodecContext *src)\n{\n    H264Context *h = dst->priv_data, *h1 = src->priv_data;\n    int inited = h->context_initialized, err = 0;\n    int context_reinitialized = 0;\n    int i, ret;\n\n    if (dst == src || !h1->context_initialized)\n        return 0;\n\n    if (inited &&\n        (h->width                 != h1->width                 ||\n         h->height                != h1->height                ||\n         h->mb_width              != h1->mb_width              ||\n         h->mb_height             != h1->mb_height             ||\n         h->sps.bit_depth_luma    != h1->sps.bit_depth_luma    ||\n         h->sps.chroma_format_idc != h1->sps.chroma_format_idc ||\n         h->sps.colorspace        != h1->sps.colorspace)) {\n\n        /* set bits_per_raw_sample to the previous value. the check for changed\n         * bit depth in h264_set_parameter_from_sps() uses it and sets it to\n         * the current value */\n        h->avctx->bits_per_raw_sample = h->sps.bit_depth_luma;\n\n        av_freep(&h->bipred_scratchpad);\n\n        h->width     = h1->width;\n        h->height    = h1->height;\n        h->mb_height = h1->mb_height;\n        h->mb_width  = h1->mb_width;\n        h->mb_num    = h1->mb_num;\n        h->mb_stride = h1->mb_stride;\n        h->b_stride  = h1->b_stride;\n\n        if ((err = h264_slice_header_init(h, 1)) < 0) {\n            av_log(h->avctx, AV_LOG_ERROR, \"h264_slice_header_init() failed\");\n            return err;\n        }\n        context_reinitialized = 1;\n\n        /* update linesize on resize. The decoder doesn't\n         * necessarily call h264_frame_start in the new thread */\n        h->linesize   = h1->linesize;\n        h->uvlinesize = h1->uvlinesize;\n\n        /* copy block_offset since frame_start may not be called */\n        memcpy(h->block_offset, h1->block_offset, sizeof(h->block_offset));\n    }\n\n    if (!inited) {\n        for (i = 0; i < MAX_SPS_COUNT; i++)\n            av_freep(h->sps_buffers + i);\n\n        for (i = 0; i < MAX_PPS_COUNT; i++)\n            av_freep(h->pps_buffers + i);\n\n        memcpy(h, h1, sizeof(*h1));\n        memset(h->sps_buffers, 0, sizeof(h->sps_buffers));\n        memset(h->pps_buffers, 0, sizeof(h->pps_buffers));\n        memset(&h->er, 0, sizeof(h->er));\n        memset(&h->me, 0, sizeof(h->me));\n        memset(&h->mb, 0, sizeof(h->mb));\n        memset(&h->mb_luma_dc, 0, sizeof(h->mb_luma_dc));\n        memset(&h->mb_padding, 0, sizeof(h->mb_padding));\n        h->context_initialized = 0;\n\n        memset(&h->cur_pic, 0, sizeof(h->cur_pic));\n        av_frame_unref(&h->cur_pic.f);\n        h->cur_pic.tf.f = &h->cur_pic.f;\n\n        h->avctx             = dst;\n        h->DPB               = NULL;\n        h->qscale_table_pool = NULL;\n        h->mb_type_pool      = NULL;\n        h->ref_index_pool    = NULL;\n        h->motion_val_pool   = NULL;\n\n        ret = ff_h264_alloc_tables(h);\n        if (ret < 0) {\n            av_log(dst, AV_LOG_ERROR, \"Could not allocate memory for h264\\n\");\n            return ret;\n        }\n        ret = context_init(h);\n        if (ret < 0) {\n            av_log(dst, AV_LOG_ERROR, \"context_init() failed.\\n\");\n            return ret;\n        }\n\n        for (i = 0; i < 2; i++) {\n            h->rbsp_buffer[i]      = NULL;\n            h->rbsp_buffer_size[i] = 0;\n        }\n        h->bipred_scratchpad = NULL;\n        h->edge_emu_buffer   = NULL;\n\n        h->thread_context[0] = h;\n\n        h->context_initialized = 1;\n    }\n\n    h->avctx->coded_height  = h1->avctx->coded_height;\n    h->avctx->coded_width   = h1->avctx->coded_width;\n    h->avctx->width         = h1->avctx->width;\n    h->avctx->height        = h1->avctx->height;\n    h->coded_picture_number = h1->coded_picture_number;\n    h->first_field          = h1->first_field;\n    h->picture_structure    = h1->picture_structure;\n    h->qscale               = h1->qscale;\n    h->droppable            = h1->droppable;\n    h->low_delay            = h1->low_delay;\n\n    for (i = 0; i < MAX_PICTURE_COUNT; i++) {\n        unref_picture(h, &h->DPB[i]);\n        if (h1->DPB[i].f.buf[0] &&\n            (ret = ref_picture(h, &h->DPB[i], &h1->DPB[i])) < 0)\n            return ret;\n    }\n\n    h->cur_pic_ptr = REBASE_PICTURE(h1->cur_pic_ptr, h, h1);\n    unref_picture(h, &h->cur_pic);\n    if ((ret = ref_picture(h, &h->cur_pic, &h1->cur_pic)) < 0)\n        return ret;\n\n    h->workaround_bugs = h1->workaround_bugs;\n    h->low_delay       = h1->low_delay;\n    h->droppable       = h1->droppable;\n\n    /* frame_start may not be called for the next thread (if it's decoding\n     * a bottom field) so this has to be allocated here */\n    err = alloc_scratch_buffers(h, h1->linesize);\n    if (err < 0)\n        return err;\n\n    // extradata/NAL handling\n    h->is_avc = h1->is_avc;\n\n    // SPS/PPS\n    if ((ret = copy_parameter_set((void **)h->sps_buffers,\n                                  (void **)h1->sps_buffers,\n                                  MAX_SPS_COUNT, sizeof(SPS))) < 0)\n        return ret;\n    h->sps = h1->sps;\n    if ((ret = copy_parameter_set((void **)h->pps_buffers,\n                                  (void **)h1->pps_buffers,\n                                  MAX_PPS_COUNT, sizeof(PPS))) < 0)\n        return ret;\n    h->pps = h1->pps;\n\n    // Dequantization matrices\n    // FIXME these are big - can they be only copied when PPS changes?\n    copy_fields(h, h1, dequant4_buffer, dequant4_coeff);\n\n    for (i = 0; i < 6; i++)\n        h->dequant4_coeff[i] = h->dequant4_buffer[0] +\n                               (h1->dequant4_coeff[i] - h1->dequant4_buffer[0]);\n\n    for (i = 0; i < 6; i++)\n        h->dequant8_coeff[i] = h->dequant8_buffer[0] +\n                               (h1->dequant8_coeff[i] - h1->dequant8_buffer[0]);\n\n    h->dequant_coeff_pps = h1->dequant_coeff_pps;\n\n    // POC timing\n    copy_fields(h, h1, poc_lsb, redundant_pic_count);\n\n    // reference lists\n    copy_fields(h, h1, short_ref, cabac_init_idc);\n\n    copy_picture_range(h->short_ref, h1->short_ref, 32, h, h1);\n    copy_picture_range(h->long_ref, h1->long_ref, 32, h, h1);\n    copy_picture_range(h->delayed_pic, h1->delayed_pic,\n                       MAX_DELAYED_PIC_COUNT + 2, h, h1);\n\n    h->last_slice_type = h1->last_slice_type;\n\n    if (context_reinitialized)\n        h264_set_parameter_from_sps(h);\n\n    if (!h->cur_pic_ptr)\n        return 0;\n\n    if (!h->droppable) {\n        err = ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index);\n        h->prev_poc_msb = h->poc_msb;\n        h->prev_poc_lsb = h->poc_lsb;\n    }\n    h->prev_frame_num_offset = h->frame_num_offset;\n    h->prev_frame_num        = h->frame_num;\n    h->outputed_poc          = h->next_outputed_poc;\n\n    h->recovery_frame        = h1->recovery_frame;\n    h->frame_recovered       = h1->frame_recovered;\n\n    return err;\n}", "target": 2, "idx": 10840}
{"commit_id": "c4d34984ec92b3d5252a7d5cddd85a1d3a8001ae", "project": "pjsip/pjproject", "func": "static void parse_version(pj_scanner *scanner, \n                          volatile parse_context *ctx)\n{\n    ctx->last_error = PJMEDIA_SDP_EINVER;\n\n    /* check equal sign */\n    if (scanner->curptr+1 >= scanner->end || *(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n\n    /* check version is 0 */\n    if (scanner->curptr+2 >= scanner->end || *(scanner->curptr+2) != '0') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n\n    /* We've got what we're looking for, skip anything until newline */\n    pj_scan_skip_line(scanner);\n}", "target": 2, "idx": 10841}
{"commit_id": "4c185ce06dca14f5cea192f5a2c981ef50663f2b", "project": "torvalds/linux", "func": "static ssize_t aio_setup_single_vector(struct kiocb *kiocb,\n\t\t\t\t       int rw, char __user *buf,\n\t\t\t\t       unsigned long *nr_segs,\n\t\t\t\t       size_t len,\n\t\t\t\t       struct iovec *iovec,\n\t\t\t\t       struct iov_iter *iter)\n{\n\tif (len > MAX_RW_COUNT)\n\t\tlen = MAX_RW_COUNT;\n\tif (unlikely(!access_ok(!rw, buf, len)))\n\t\treturn -EFAULT;\n\n\tiovec->iov_base = buf;\n\tiovec->iov_len = len;\n\t*nr_segs = 1;\n\tiov_iter_init(iter, rw, iovec, *nr_segs, len);\n\treturn 0;\n}", "target": 2, "idx": 10842}
{"commit_id": "6f34307bff645eb2935d82deee0119ec89866118", "project": "gobby", "func": "void Gobby::GotoDialog::on_changed()\n{\n\tif (!m_current_view) {\n\t\tg_warning(\"No current view exists.\");\n\t\treturn;\n\t}\n\n\tGtkTextBuffer* buffer = GTK_TEXT_BUFFER(\n\t\tm_current_view->get_text_buffer());\n\n\tm_entry_line->set_range(1, gtk_text_buffer_get_line_count(buffer));\n}", "target": 2, "idx": 10843}
{"commit_id": "80caf43549e7e41a695c6d1e11066286538b336f", "project": "kernel/git/davem/sparc", "func": "static int get_vdev_port_node_info(struct mdesc_handle *md, u64 node,\n\t\t\t\t   union md_node_info *node_info)\n{\n\tconst u64 *parent_cfg_hdlp;\n\tconst char *name;\n\tconst u64 *idp;\n\n\t/*\n\t * Virtual device nodes are distinguished by:\n\t * 1. \"id\" property\n\t * 2. \"name\" property\n\t * 3. parent node \"cfg-handle\" property\n\t */\n\tidp = mdesc_get_property(md, node, \"id\", NULL);\n\tname = mdesc_get_property(md, node, \"name\", NULL);\n\tparent_cfg_hdlp = parent_cfg_handle(md, node);\n\n\tif (!idp || !name || !parent_cfg_hdlp)\n\t\treturn -1;\n\n\tnode_info->vdev_port.id = *idp;\n\tnode_info->vdev_port.name = kstrdup_const(name, GFP_KERNEL);\n\tif (!node_info->vdev_port.name)\n\t\treturn -1;\n\tnode_info->vdev_port.parent_cfg_hdl = *parent_cfg_hdlp;\n\n\treturn 0;\n}", "target": 2, "idx": 10844}
{"commit_id": "4fbcc1a4cb20fe26ad0225679c536c80f1648221", "project": "torvalds/linux", "func": "int st21nfca_connectivity_event_received(struct nfc_hci_dev *hdev, u8 host,\n\t\t\t\tu8 event, struct sk_buff *skb)\n{\n\tint r = 0;\n\tstruct device *dev = &hdev->ndev->dev;\n\tstruct nfc_evt_transaction *transaction;\n\n\tpr_debug(\"connectivity gate event: %x\\n\", event);\n\n\tswitch (event) {\n\tcase ST21NFCA_EVT_CONNECTIVITY:\n\t\tr = nfc_se_connectivity(hdev->ndev, host);\n\tbreak;\n\tcase ST21NFCA_EVT_TRANSACTION:\n\t\t/*\n\t\t * According to specification etsi 102 622\n\t\t * 11.2.2.4 EVT_TRANSACTION Table 52\n\t\t * Description\tTag\tLength\n\t\t * AID\t\t81\t5 to 16\n\t\t * PARAMETERS\t82\t0 to 255\n\t\t */\n\t\tif (skb->len < NFC_MIN_AID_LENGTH + 2 &&\n\t\t    skb->data[0] != NFC_EVT_TRANSACTION_AID_TAG)\n\t\t\treturn -EPROTO;\n\n\t\ttransaction = devm_kzalloc(dev, skb->len - 2, GFP_KERNEL);\n\t\tif (!transaction)\n\t\t\treturn -ENOMEM;\n\n\t\ttransaction->aid_len = skb->data[1];\n\n\t\t/* Checking if the length of the AID is valid */\n\t\tif (transaction->aid_len > sizeof(transaction->aid))\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(transaction->aid, &skb->data[2],\n\t\t       transaction->aid_len);\n\n\t\t/* Check next byte is PARAMETERS tag (82) */\n\t\tif (skb->data[transaction->aid_len + 2] !=\n\t\t    NFC_EVT_TRANSACTION_PARAMS_TAG)\n\t\t\treturn -EPROTO;\n\n\t\ttransaction->params_len = skb->data[transaction->aid_len + 3];\n\n\t\t/* Total size is allocated (skb->len - 2) minus fixed array members */\n\t\tif (transaction->params_len > ((skb->len - 2) - sizeof(struct nfc_evt_transaction)))\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(transaction->params, skb->data +\n\t\t       transaction->aid_len + 4, transaction->params_len);\n\n\t\tr = nfc_se_transaction(hdev->ndev, host, transaction);\n\tbreak;\n\tdefault:\n\t\tnfc_err(&hdev->ndev->dev, \"Unexpected event on connectivity gate\\n\");\n\t\treturn 1;\n\t}\n\tkfree_skb(skb);\n\treturn r;\n}", "target": 2, "idx": 10845}
{"commit_id": "6ed0077520e2b0da1fd060c7f88db7b2e6068e4c", "project": "TeX-Live/texlive-source", "func": "static void t1_check_unusual_charstring(void)\n{\n    char *p = strstr(t1_line_array, charstringname) + strlen(charstringname);\n    int i;\n    /* if no number follows \"/CharStrings\", let's read the next line */\n    if (sscanf(p, \"%i\", &i) != 1) {\n        /* pdftex_warn(\"no number found after `%s', I assume it's on the next line\",\n                    charstringname); */\n        strcpy(t1_buf_array, t1_line_array);\n\n        /* t1_getline always appends EOL to t1_line_array; let's change it to\n         * space before appending the next line\n         */\n        *(strend(t1_buf_array) - 1) = ' ';\n\n        t1_getline();\n        alloc_array(t1_buf, strlen(t1_line_array) + strlen(t1_buf_array) + 1, T1_BUF_SIZE);\n        strcat(t1_buf_array, t1_line_array);\n        alloc_array(t1_line, strlen(t1_buf_array) + 1, T1_BUF_SIZE);\n        strcpy(t1_line_array, t1_buf_array);\n        t1_line_ptr = eol(t1_line_array);\n    }\n}", "target": 2, "idx": 10846}
{"commit_id": "c9f838d104fed6f2f61d68164712e3204bf5271b", "project": "torvalds/linux", "func": "long keyctl_set_reqkey_keyring(int reqkey_defl)\n{\n\tstruct cred *new;\n\tint ret, old_setting;\n\n\told_setting = current_cred_xxx(jit_keyring);\n\n\tif (reqkey_defl == KEY_REQKEY_DEFL_NO_CHANGE)\n\t\treturn old_setting;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tswitch (reqkey_defl) {\n\tcase KEY_REQKEY_DEFL_THREAD_KEYRING:\n\t\tret = install_thread_keyring_to_cred(new);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tgoto set;\n\n\tcase KEY_REQKEY_DEFL_PROCESS_KEYRING:\n\t\tret = install_process_keyring_to_cred(new);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tgoto set;\n\n\tcase KEY_REQKEY_DEFL_DEFAULT:\n\tcase KEY_REQKEY_DEFL_SESSION_KEYRING:\n\tcase KEY_REQKEY_DEFL_USER_KEYRING:\n\tcase KEY_REQKEY_DEFL_USER_SESSION_KEYRING:\n\tcase KEY_REQKEY_DEFL_REQUESTOR_KEYRING:\n\t\tgoto set;\n\n\tcase KEY_REQKEY_DEFL_NO_CHANGE:\n\tcase KEY_REQKEY_DEFL_GROUP_KEYRING:\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\nset:\n\tnew->jit_keyring = reqkey_defl;\n\tcommit_creds(new);\n\treturn old_setting;\nerror:\n\tabort_creds(new);\n\treturn ret;\n}", "target": 1, "idx": 10847}
{"commit_id": "72e70a921f0f07fee748aec2274b30784e1d312a", "project": "kyz/libmspack", "func": "static int chmd_read_headers(struct mspack_system *sys, struct mspack_file *fh,\n\t\t\t     struct mschmd_header *chm, int entire)\n{\n  unsigned int section, name_len, x, errors, num_chunks;\n  unsigned char buf[0x54], *chunk = NULL, *name, *p, *end;\n  struct mschmd_file *fi, *link = NULL;\n  off_t offset, length;\n  int num_entries;\n\n  /* initialise pointers */\n  chm->files         = NULL;\n  chm->sysfiles      = NULL;\n  chm->chunk_cache   = NULL;\n  chm->sec0.base.chm = chm;\n  chm->sec0.base.id  = 0;\n  chm->sec1.base.chm = chm;\n  chm->sec1.base.id  = 1;\n  chm->sec1.content  = NULL;\n  chm->sec1.control  = NULL;\n  chm->sec1.spaninfo = NULL;\n  chm->sec1.rtable   = NULL;\n\n  /* read the first header */\n  if (sys->read(fh, &buf[0], chmhead_SIZEOF) != chmhead_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  /* check ITSF signature */\n  if (EndGetI32(&buf[chmhead_Signature]) != 0x46535449) {\n    return MSPACK_ERR_SIGNATURE;\n  }\n\n  /* check both header GUIDs */\n  if (mspack_memcmp(&buf[chmhead_GUID1], &guids[0], 32L) != 0) {\n    D((\"incorrect GUIDs\"))\n    return MSPACK_ERR_SIGNATURE;\n  }\n\n  chm->version   = EndGetI32(&buf[chmhead_Version]);\n  chm->timestamp = EndGetM32(&buf[chmhead_Timestamp]);\n  chm->language  = EndGetI32(&buf[chmhead_LanguageID]);\n  if (chm->version > 3) {\n    sys->message(fh, \"WARNING; CHM version > 3\");\n  }\n\n  /* read the header section table */\n  if (sys->read(fh, &buf[0], chmhst3_SIZEOF) != chmhst3_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  /* chmhst3_OffsetCS0 does not exist in version 1 or 2 CHM files.\n   * The offset will be corrected later, once HS1 is read.\n   */\n  if (read_off64(&offset,           &buf[chmhst_OffsetHS0],  sys, fh) ||\n      read_off64(&chm->dir_offset,  &buf[chmhst_OffsetHS1],  sys, fh) ||\n      read_off64(&chm->sec0.offset, &buf[chmhst3_OffsetCS0], sys, fh))\n  {\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* seek to header section 0 */\n  if (sys->seek(fh, offset, MSPACK_SYS_SEEK_START)) {\n    return MSPACK_ERR_SEEK;\n  }\n\n  /* read header section 0 */\n  if (sys->read(fh, &buf[0], chmhs0_SIZEOF) != chmhs0_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n  if (read_off64(&chm->length, &buf[chmhs0_FileLen], sys, fh)) {\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* seek to header section 1 */\n  if (sys->seek(fh, chm->dir_offset, MSPACK_SYS_SEEK_START)) {\n    return MSPACK_ERR_SEEK;\n  }\n\n  /* read header section 1 */\n  if (sys->read(fh, &buf[0], chmhs1_SIZEOF) != chmhs1_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  chm->dir_offset = sys->tell(fh);\n  chm->chunk_size = EndGetI32(&buf[chmhs1_ChunkSize]);\n  chm->density    = EndGetI32(&buf[chmhs1_Density]);\n  chm->depth      = EndGetI32(&buf[chmhs1_Depth]);\n  chm->index_root = EndGetI32(&buf[chmhs1_IndexRoot]);\n  chm->num_chunks = EndGetI32(&buf[chmhs1_NumChunks]);\n  chm->first_pmgl = EndGetI32(&buf[chmhs1_FirstPMGL]);\n  chm->last_pmgl  = EndGetI32(&buf[chmhs1_LastPMGL]);\n\n  if (chm->version < 3) {\n    /* versions before 3 don't have chmhst3_OffsetCS0 */\n    chm->sec0.offset = chm->dir_offset + (chm->chunk_size * chm->num_chunks);\n  }\n\n  /* check if content offset or file size is wrong */\n  if (chm->sec0.offset > chm->length) {\n    D((\"content section begins after file has ended\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  \n  /* ensure there are chunks and that chunk size is\n   * large enough for signature and num_entries */\n  if (chm->chunk_size < (pmgl_Entries + 2)) {\n    D((\"chunk size not large enough\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  if (chm->num_chunks == 0) {\n    D((\"no chunks\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* The chunk_cache data structure is not great; large values for num_chunks\n   * or num_chunks*chunk_size can exhaust all memory. Until a better chunk\n   * cache is implemented, put arbitrary limits on num_chunks and chunk size.\n   */\n  if (chm->num_chunks > 100000) {\n    D((\"more than 100,000 chunks\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }   \n  if ((off_t)chm->chunk_size * (off_t)chm->num_chunks > chm->length) {\n    D((\"chunks larger than entire file\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* common sense checks on header section 1 fields */\n  if ((chm->chunk_size & (chm->chunk_size - 1)) != 0) {\n    sys->message(fh, \"WARNING; chunk size is not a power of two\");\n  }\n  if (chm->first_pmgl != 0) {\n    sys->message(fh, \"WARNING; first PMGL chunk is not zero\");\n  }\n  if (chm->first_pmgl > chm->last_pmgl) {\n    D((\"first pmgl chunk is after last pmgl chunk\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  if (chm->index_root != 0xFFFFFFFF && chm->index_root >= chm->num_chunks) {\n    D((\"index_root outside valid range\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* if we are doing a quick read, stop here! */\n  if (!entire) {\n    return MSPACK_ERR_OK;\n  }\n\n  /* seek to the first PMGL chunk, and reduce the number of chunks to read */\n  if ((x = chm->first_pmgl) != 0) {\n    if (sys->seek(fh,(off_t) (x * chm->chunk_size), MSPACK_SYS_SEEK_CUR)) {\n      return MSPACK_ERR_SEEK;\n    }\n  }\n  num_chunks = chm->last_pmgl - x + 1;\n\n  if (!(chunk = (unsigned char *) sys->alloc(sys, (size_t)chm->chunk_size))) {\n    return MSPACK_ERR_NOMEMORY;\n  }\n\n  /* read and process all chunks from FirstPMGL to LastPMGL */\n  errors = 0;\n  while (num_chunks--) {\n    /* read next chunk */\n    if (sys->read(fh, chunk, (int)chm->chunk_size) != (int)chm->chunk_size) {\n      sys->free(chunk);\n      return MSPACK_ERR_READ;\n    }\n\n    /* process only directory (PMGL) chunks */\n    if (EndGetI32(&chunk[pmgl_Signature]) != 0x4C474D50) continue;\n\n    if (EndGetI32(&chunk[pmgl_QuickRefSize]) < 2) {\n      sys->message(fh, \"WARNING; PMGL quickref area is too small\");\n    }\n    if (EndGetI32(&chunk[pmgl_QuickRefSize]) > \n\t((int)chm->chunk_size - pmgl_Entries))\n    {\n      sys->message(fh, \"WARNING; PMGL quickref area is too large\");\n    }\n\n    p = &chunk[pmgl_Entries];\n    end = &chunk[chm->chunk_size - 2];\n    num_entries = EndGetI16(end);\n\n    while (num_entries--) {\n      READ_ENCINT(name_len);\n      if (name_len > (unsigned int) (end - p)) goto chunk_end;\n      /* consider blank filenames to be an error */\n      if (name_len == 0) goto chunk_end;\n      name = p; p += name_len;\n\n      READ_ENCINT(section);\n      READ_ENCINT(offset);\n      READ_ENCINT(length);\n\n      /* empty files and directory names are stored as a file entry at\n       * offset 0 with length 0. We want to keep empty files, but not\n       * directory names, which end with a \"/\" */\n      if ((offset == 0) && (length == 0)) {\n\tif ((name_len > 0) && (name[name_len-1] == '/')) continue;\n      }\n\n      if (section > 1) {\n\tsys->message(fh, \"invalid section number '%u'.\", section);\n\tcontinue;\n      }\n\n      if (!(fi = (struct mschmd_file *) sys->alloc(sys, sizeof(struct mschmd_file) + name_len + 1))) {\n\tsys->free(chunk);\n\treturn MSPACK_ERR_NOMEMORY;\n      }\n\n      fi->next     = NULL;\n      fi->filename = (char *) &fi[1];\n      fi->section  = ((section == 0) ? (struct mschmd_section *) (&chm->sec0)\n\t\t                     : (struct mschmd_section *) (&chm->sec1));\n      fi->offset   = offset;\n      fi->length   = length;\n      sys->copy(name, fi->filename, (size_t) name_len);\n      fi->filename[name_len] = '\\0';\n\n      if (name[0] == ':' && name[1] == ':') {\n\t/* system file */\n\tif (mspack_memcmp(&name[2], &content_name[2], 31L) == 0) {\n\t  if (mspack_memcmp(&name[33], &content_name[33], 8L) == 0) {\n\t    chm->sec1.content = fi;\n\t  }\n\t  else if (mspack_memcmp(&name[33], &control_name[33], 11L) == 0) {\n\t    chm->sec1.control = fi;\n\t  }\n\t  else if (mspack_memcmp(&name[33], &spaninfo_name[33], 8L) == 0) {\n\t    chm->sec1.spaninfo = fi;\n\t  }\n\t  else if (mspack_memcmp(&name[33], &rtable_name[33], 72L) == 0) {\n\t    chm->sec1.rtable = fi;\n\t  }\n\t}\n\tfi->next = chm->sysfiles;\n\tchm->sysfiles = fi;\n      }\n      else {\n\t/* normal file */\n\tif (link) link->next = fi; else chm->files = fi;\n\tlink = fi;\n      }\n    }\n\n    /* this is reached either when num_entries runs out, or if\n     * reading data from the chunk reached a premature end of chunk */\n  chunk_end:\n    if (num_entries >= 0) {\n      D((\"chunk ended before all entries could be read\"))\n      errors++;\n    }\n\n  }\n  sys->free(chunk);\n  return (errors > 0) ? MSPACK_ERR_DATAFORMAT : MSPACK_ERR_OK;\n}", "target": 1, "idx": 10848}
{"commit_id": "ea92d2f0fcceb54a70910fa32e9a0d7a5afc3583", "project": "krb5", "func": "int\nmain(int argc, char **argv)\n{\n    krb5_error_code ret;\n    krb5_context context;\n    krb5_pac pac;\n    krb5_data data;\n    krb5_principal p;\n\n    ret = krb5_init_context(&context);\n    if (ret)\n        err(NULL, 0, \"krb5_init_contex\");\n\n    test_pac_ticket_signature(context);\n\n    ret = krb5_set_default_realm(context, \"WIN2K3.THINKER.LOCAL\");\n    if (ret)\n        err(context, ret, \"krb5_set_default_realm\");\n\n    ret = krb5_parse_name(context, user, &p);\n    if (ret)\n        err(context, ret, \"krb5_parse_name\");\n\n    /* Check a pre-saved PAC. */\n    check_pac(context, -1, saved_pac, sizeof(saved_pac), authtime, p,\n              type_1_length, 0, &member_keyblock, &kdc_keyblock);\n\n    /* Check S4U2Self PACs. */\n    {\n        krb5_principal sp;\n        krb5_principal sep;\n        const struct pac_and_info *pi;\n\n        ret = krb5_parse_name(context, s4u_principal, &sp);\n        if (ret)\n            err(context, ret, \"krb5_parse_name\");\n\n        ret = krb5_parse_name_flags(context, s4u_enterprise,\n                                    KRB5_PRINCIPAL_PARSE_ENTERPRISE, &sep);\n        if (ret)\n            err(context, ret, \"krb5_parse_name_flags\");\n\n        for (pi = s4u_pacs; pi->data != NULL; pi++) {\n            check_pac(context, pi - s4u_pacs, pi->data, pi->length,\n                      pi->authtime, pi->is_enterprise ? sep : sp,\n                      s4u_logon_info_buffer_len, pi->is_xrealm,\n                      pi->is_xrealm ? &s4u_tgt_srv_key : &s4u_srv_key, NULL);\n        }\n\n        krb5_free_principal(context, sp);\n        krb5_free_principal(context, sep);\n    }\n\n    /* Check problematic PACs found by fuzzing. */\n    ret = krb5_pac_parse(context, fuzz1, sizeof(fuzz1), &pac);\n    if (!ret)\n        err(context, ret, \"krb5_pac_parse should have failed\");\n    ret = krb5_pac_parse(context, fuzz2, sizeof(fuzz2), &pac);\n    if (!ret)\n        err(context, ret, \"krb5_pac_parse should have failed\");\n\n    /*\n     * Test empty free\n     */\n\n    ret = krb5_pac_init(context, &pac);\n    if (ret)\n        err(context, ret, \"krb5_pac_init\");\n    krb5_pac_free(context, pac);\n\n    /*\n     * Test add remove buffer\n     */\n\n    ret = krb5_pac_init(context, &pac);\n    if (ret)\n        err(context, ret, \"krb5_pac_init\");\n\n    {\n        const krb5_data cdata = { 0, 2, \"\\x00\\x01\" } ;\n\n        ret = krb5_pac_add_buffer(context, pac, 1, &cdata);\n        if (ret)\n            err(context, ret, \"krb5_pac_add_buffer\");\n    }\n    {\n        ret = krb5_pac_get_buffer(context, pac, 1, &data);\n        if (ret)\n            err(context, ret, \"krb5_pac_get_buffer\");\n        if (data.length != 2 || memcmp(data.data, \"\\x00\\x01\", 2) != 0)\n            err(context, 0, \"krb5_pac_get_buffer data not the same\");\n        krb5_free_data_contents(context, &data);\n    }\n\n    {\n        const krb5_data cdata = { 0, 2, \"\\x02\\x00\" } ;\n\n        ret = krb5_pac_add_buffer(context, pac, 2, &cdata);\n        if (ret)\n            err(context, ret, \"krb5_pac_add_buffer\");\n    }\n    {\n        ret = krb5_pac_get_buffer(context, pac, 1, &data);\n        if (ret)\n            err(context, ret, \"krb5_pac_get_buffer\");\n        if (data.length != 2 || memcmp(data.data, \"\\x00\\x01\", 2) != 0)\n            err(context, 0, \"krb5_pac_get_buffer data not the same\");\n        krb5_free_data_contents(context, &data);\n        /* */\n        ret = krb5_pac_get_buffer(context, pac, 2, &data);\n        if (ret)\n            err(context, ret, \"krb5_pac_get_buffer\");\n        if (data.length != 2 || memcmp(data.data, \"\\x02\\x00\", 2) != 0)\n            err(context, 0, \"krb5_pac_get_buffer data not the same\");\n        krb5_free_data_contents(context, &data);\n    }\n\n    ret = krb5_pac_sign(context, pac, authtime, p,\n                        &member_keyblock, &kdc_keyblock, &data);\n    if (ret)\n        err(context, ret, \"krb5_pac_sign\");\n\n    krb5_pac_free(context, pac);\n\n    ret = krb5_pac_parse(context, data.data, data.length, &pac);\n    krb5_free_data_contents(context, &data);\n    if (ret)\n        err(context, ret, \"krb5_pac_parse 3\");\n\n    ret = krb5_pac_verify(context, pac, authtime, p,\n                          &member_keyblock, &kdc_keyblock);\n    if (ret)\n        err(context, ret, \"krb5_pac_verify 3\");\n\n    {\n        uint32_t *list;\n        size_t len;\n\n        /* our two user buffer plus the three \"system\" buffers */\n        ret = krb5_pac_get_types(context, pac, &len, &list);\n        if (ret)\n            err(context, ret, \"krb5_pac_get_types\");\n        if (len != 5)\n            err(context, 0, \"list wrong length\");\n        free(list);\n    }\n\n    {\n        krb5_principal ep, np;\n\n        ret = krb5_parse_name_flags(context, user,\n                                    KRB5_PRINCIPAL_PARSE_ENTERPRISE, &ep);\n        if (ret)\n            err(context, ret, \"krb5_parse_name_flags\");\n\n        ret = krb5_copy_principal(context, ep, &np);\n        if (ret)\n            err(context, ret, \"krb5_copy_principal\");\n        np->type = KRB5_NT_MS_PRINCIPAL;\n\n        /* Try to verify as enterprise. */\n        ret = krb5_pac_verify(context, pac, authtime, ep, &member_keyblock,\n                              &kdc_keyblock);\n        if (!ret)\n            err(context, ret, \"krb5_pac_verify should have failed\");\n\n        ret = krb5_pac_sign(context, pac, authtime, ep, &member_keyblock,\n                            &kdc_keyblock, &data);\n        if (!ret)\n            err(context, ret, \"krb5_pac_sign should have failed\");\n\n        /* Try to verify with realm. */\n        ret = krb5_pac_verify_ext(context, pac, authtime, p, &member_keyblock,\n                                  &kdc_keyblock, TRUE);\n        if (!ret)\n            err(context, ret, \"krb5_pac_verify_ext with realm should fail\");\n\n        /* Currently we can't re-sign the PAC with realm (although that could\n         * be useful), only sign a new one. */\n        ret = krb5_pac_sign_ext(context, pac, authtime, p, &member_keyblock,\n                                &kdc_keyblock, TRUE, &data);\n        if (!ret)\n            err(context, ret, \"krb5_pac_sign_ext with realm should fail\");\n\n        krb5_pac_free(context, pac);\n\n        /* Test enterprise. */\n        ret = krb5_pac_init(context, &pac);\n        if (ret)\n            err(context, ret, \"krb5_pac_init\");\n\n        ret = krb5_pac_sign(context, pac, authtime, ep, &member_keyblock,\n                            &kdc_keyblock, &data);\n        if (ret)\n            err(context, ret, \"krb5_pac_sign enterprise failed\");\n\n        krb5_pac_free(context, pac);\n\n        ret = krb5_pac_parse(context, data.data, data.length, &pac);\n        krb5_free_data_contents(context, &data);\n        if (ret)\n            err(context, ret, \"krb5_pac_parse failed\");\n\n        ret = krb5_pac_verify(context, pac, authtime, ep, &member_keyblock,\n                              &kdc_keyblock);\n        if (ret)\n            err(context, ret, \"krb5_pac_verify enterprise failed\");\n\n        /* Also verify enterprise as KRB5_NT_MS_PRINCIPAL. */\n        ret = krb5_pac_verify(context, pac, authtime, np, &member_keyblock,\n                              &kdc_keyblock);\n        if (ret)\n            err(context, ret, \"krb5_pac_verify enterprise as nt-ms failed\");\n\n        ret = krb5_pac_verify(context, pac, authtime, p, &member_keyblock,\n                              &kdc_keyblock);\n        if (!ret)\n            err(context, ret, \"krb5_pac_verify should have failed\");\n\n        krb5_pac_free(context, pac);\n\n        /* Test nt-ms-principal. */\n        ret = krb5_pac_init(context, &pac);\n        if (ret)\n            err(context, ret, \"krb5_pac_init\");\n\n        ret = krb5_pac_sign(context, pac, authtime, np, &member_keyblock,\n                            &kdc_keyblock, &data);\n        if (ret)\n            err(context, ret, \"krb5_pac_sign enterprise failed\");\n\n        krb5_pac_free(context, pac);\n\n        ret = krb5_pac_parse(context, data.data, data.length, &pac);\n        krb5_free_data_contents(context, &data);\n        if (ret)\n            err(context, ret, \"krb5_pac_parse failed\");\n\n        ret = krb5_pac_verify(context, pac, authtime, np, &member_keyblock,\n                              &kdc_keyblock);\n        if (ret)\n            err(context, ret, \"krb5_pac_verify enterprise failed\");\n\n        /* Also verify as enterprise principal. */\n        ret = krb5_pac_verify(context, pac, authtime, ep, &member_keyblock,\n                              &kdc_keyblock);\n        if (ret)\n            err(context, ret, \"krb5_pac_verify nt-ms as enterprise failed\");\n\n        ret = krb5_pac_verify(context, pac, authtime, p, &member_keyblock,\n                              &kdc_keyblock);\n        if (!ret)\n            err(context, ret, \"krb5_pac_verify should have failed\");\n\n        krb5_pac_free(context, pac);\n\n        /* Test with realm. */\n        ret = krb5_pac_init(context, &pac);\n        if (ret)\n            err(context, ret, \"krb5_pac_init\");\n\n        ret = krb5_pac_sign_ext(context, pac, authtime, p, &member_keyblock,\n                                &kdc_keyblock, TRUE, &data);\n        if (ret)\n            err(context, ret, \"krb5_pac_sign_ext with realm failed\");\n\n        krb5_pac_free(context, pac);\n\n        ret = krb5_pac_parse(context, data.data, data.length, &pac);\n        krb5_free_data_contents(context, &data);\n        if (ret)\n            err(context, ret, \"krb5_pac_parse failed\");\n\n        ret = krb5_pac_verify_ext(context, pac, authtime, p, &member_keyblock,\n                                  &kdc_keyblock, TRUE);\n        if (ret)\n            err(context, ret, \"krb5_pac_verify_ext with realm failed\");\n\n        ret = krb5_pac_verify(context, pac, authtime, p, &member_keyblock,\n                              &kdc_keyblock);\n        if (!ret)\n            err(context, ret, \"krb5_pac_verify should have failed\");\n\n        krb5_pac_free(context, pac);\n\n        /* Test enterprise with realm. */\n        ret = krb5_pac_init(context, &pac);\n        if (ret)\n            err(context, ret, \"krb5_pac_init\");\n\n        ret = krb5_pac_sign_ext(context, pac, authtime, ep, &member_keyblock,\n                                &kdc_keyblock, TRUE, &data);\n        if (ret)\n            err(context, ret, \"krb5_pac_sign_ext ent with realm failed\");\n\n        krb5_pac_free(context, pac);\n\n        ret = krb5_pac_parse(context, data.data, data.length, &pac);\n        krb5_free_data_contents(context, &data);\n        if (ret)\n            err(context, ret, \"krb5_pac_parse failed\");\n\n        ret = krb5_pac_verify_ext(context, pac, authtime, ep, &member_keyblock,\n                                  &kdc_keyblock, TRUE);\n        if (ret)\n            err(context, ret, \"krb5_pac_verify_ext ent with realm failed\");\n\n        ret = krb5_pac_verify(context, pac, authtime, p, &member_keyblock,\n                              &kdc_keyblock);\n        if (!ret)\n            err(context, ret, \"krb5_pac_verify should have failed\");\n\n        ret = krb5_pac_verify(context, pac, authtime, ep, &member_keyblock,\n                              &kdc_keyblock);\n        if (!ret)\n            err(context, ret, \"krb5_pac_verify should have failed\");\n\n        ret = krb5_pac_verify_ext(context, pac, authtime, p, &member_keyblock,\n                                  &kdc_keyblock, TRUE);\n        if (!ret)\n            err(context, ret, \"krb5_pac_verify_ext should have failed\");\n\n        krb5_free_principal(context, ep);\n        krb5_free_principal(context, np);\n    }\n\n    krb5_pac_free(context, pac);\n\n    krb5_free_principal(context, p);\n    krb5_free_context(context);\n\n    return 0;\n}", "target": 2, "idx": 10849}
{"commit_id": "becf9e5d553c2389d857a3c178ce80fdb34a02e1", "project": "torvalds/linux", "func": "static int snd_ctl_elem_write_user(struct snd_ctl_file *file,\n\t\t\t\t   struct snd_ctl_elem_value __user *_control)\n{\n\tstruct snd_ctl_elem_value *control;\n\tstruct snd_card *card;\n\tint result;\n\n\tcontrol = memdup_user(_control, sizeof(*control));\n\tif (IS_ERR(control))\n\t\treturn PTR_ERR(control);\n\n\tcard = file->card;\n\tsnd_power_lock(card);\n\tresult = snd_power_wait(card, SNDRV_CTL_POWER_D0);\n\tif (result >= 0) {\n\t\tdown_read(&card->controls_rwsem);\n\t\tresult = snd_ctl_elem_write(card, file, control);\n\t\tup_read(&card->controls_rwsem);\n\t}\n\tsnd_power_unlock(card);\n\tif (result >= 0)\n\t\tif (copy_to_user(_control, control, sizeof(*control)))\n\t\t\tresult = -EFAULT;\n\tkfree(control);\n\treturn result;\n}", "target": 2, "idx": 10850}
{"commit_id": "6a51b9e1d0cf0bf8515f7201b68fb0a3482b3dc1", "project": "openssl", "func": "static int evp_EncryptDecryptUpdate(EVP_CIPHER_CTX *ctx,\n                                    unsigned char *out, int *outl,\n                                    const unsigned char *in, int inl)\n{\n    int i, j, bl, cmpl = inl;\n\n    if (EVP_CIPHER_CTX_test_flags(ctx, EVP_CIPH_FLAG_LENGTH_BITS))\n        cmpl = (cmpl + 7) / 8;\n\n    bl = ctx->cipher->block_size;\n\n    /*\n     * CCM mode needs to know about the case where inl == 0 && in == NULL - it\n     * means the plaintext/ciphertext length is 0\n     */\n    if (inl < 0\n            || (inl == 0\n                && EVP_CIPHER_mode(ctx->cipher) != EVP_CIPH_CCM_MODE)) {\n        *outl = 0;\n        return inl == 0;\n    }\n\n    if (ctx->cipher->flags & EVP_CIPH_FLAG_CUSTOM_CIPHER) {\n        /* If block size > 1 then the cipher will have to do this check */\n        if (bl == 1 && is_partially_overlapping(out, in, cmpl)) {\n            EVPerr(EVP_F_EVP_ENCRYPTDECRYPTUPDATE, EVP_R_PARTIALLY_OVERLAPPING);\n            return 0;\n        }\n\n        i = ctx->cipher->do_cipher(ctx, out, in, inl);\n        if (i < 0)\n            return 0;\n        else\n            *outl = i;\n        return 1;\n    }\n\n    if (is_partially_overlapping(out + ctx->buf_len, in, cmpl)) {\n        EVPerr(EVP_F_EVP_ENCRYPTDECRYPTUPDATE, EVP_R_PARTIALLY_OVERLAPPING);\n        return 0;\n    }\n\n    if (ctx->buf_len == 0 && (inl & (ctx->block_mask)) == 0) {\n        if (ctx->cipher->do_cipher(ctx, out, in, inl)) {\n            *outl = inl;\n            return 1;\n        } else {\n            *outl = 0;\n            return 0;\n        }\n    }\n    i = ctx->buf_len;\n    OPENSSL_assert(bl <= (int)sizeof(ctx->buf));\n    if (i != 0) {\n        if (bl - i > inl) {\n            memcpy(&(ctx->buf[i]), in, inl);\n            ctx->buf_len += inl;\n            *outl = 0;\n            return 1;\n        } else {\n            j = bl - i;\n\n            /*\n             * Once we've processed the first j bytes from in, the amount of\n             * data left that is a multiple of the block length is:\n             * (inl - j) & ~(bl - 1)\n             * We must ensure that this amount of data, plus the one block that\n             * we process from ctx->buf does not exceed INT_MAX\n             */\n            if (((inl - j) & ~(bl - 1)) > INT_MAX - bl) {\n                EVPerr(EVP_F_EVP_ENCRYPTDECRYPTUPDATE,\n                       EVP_R_OUTPUT_WOULD_OVERFLOW);\n                return 0;\n            }\n            memcpy(&(ctx->buf[i]), in, j);\n            inl -= j;\n            in += j;\n            if (!ctx->cipher->do_cipher(ctx, out, ctx->buf, bl))\n                return 0;\n            out += bl;\n            *outl = bl;\n        }\n    } else\n        *outl = 0;\n    i = inl & (bl - 1);\n    inl -= i;\n    if (inl > 0) {\n        if (!ctx->cipher->do_cipher(ctx, out, in, inl))\n            return 0;\n        *outl += inl;\n    }\n\n    if (i != 0)\n        memcpy(ctx->buf, &(in[inl]), i);\n    ctx->buf_len = i;\n    return 1;\n}", "target": 2, "idx": 10851}
{"commit_id": "e3a9566e6463186230f215151b57b893df6d9ce2", "project": "igraph", "func": "void igraph_i_graphml_attribute_data_finish(struct igraph_i_graphml_parser_state *state) {\n  const char *key=fromXmlChar(state->data_key);\n  igraph_attribute_elemtype_t type=state->data_type;\n  igraph_trie_t *trie=0;\n  igraph_vector_ptr_t *ptrvector=0;\n  igraph_i_graphml_attribute_record_t *graphmlrec;\n  igraph_attribute_record_t *rec;\n  long int recid, id=0;\n  int ret;\n  \n  switch (type) {\n  case IGRAPH_ATTRIBUTE_GRAPH:\n    trie=&state->g_names;\n    ptrvector=&state->g_attrs;\n    id=0;\n    break;\n  case IGRAPH_ATTRIBUTE_VERTEX:\n    trie=&state->v_names;\n    ptrvector=&state->v_attrs;\n    id=state->act_node;\n    break;\n  case IGRAPH_ATTRIBUTE_EDGE:\n    trie=&state->e_names;\n    ptrvector=&state->e_attrs;\n    id=igraph_vector_size(&state->edgelist)/2-1; /* hack */\n    break;\n  default:\n    /* impossible */\n    break;\n  }\n\n  if (key == 0) {\n    /* no key specified, issue a warning */\n    igraph_warningf(\n        \"missing attribute key in a <data> tag, ignoring attribute\",\n        __FILE__, __LINE__, 0,\n        key\n    );\n    igraph_Free(state->data_char);\n    return;\n  }\n\n  igraph_trie_check(trie, key, &recid);\n  if (recid < 0) {\n    /* no such attribute key, issue a warning */\n    igraph_warningf(\n        \"unknown attribute key '%s' in a <data> tag, ignoring attribute\",\n        __FILE__, __LINE__, 0,\n        key\n    );\n    igraph_Free(state->data_char);\n    return;\n  }\n   \n  graphmlrec=VECTOR(*ptrvector)[recid];\n  rec=&graphmlrec->record;\n\n  switch (rec->type) {\n    igraph_vector_bool_t *boolvec;\n    igraph_vector_t *vec;\n    igraph_strvector_t *strvec;\n    long int s, i;\n    const char* strvalue;\n  case IGRAPH_ATTRIBUTE_BOOLEAN:\n    boolvec=(igraph_vector_bool_t *)rec->value;\n    s=igraph_vector_bool_size(boolvec);\n    if (id >= s) {\n      ret=igraph_vector_bool_resize(boolvec, id+1);\n      if (ret) {\n        RETURN_GRAPHML_PARSE_ERROR_WITH_CODE(state, \"Cannot parse GraphML file\", ret);\n      }\n      for (i=s; i<id; i++) {\n\tVECTOR(*boolvec)[i] = graphmlrec->default_value.as_boolean;\n      }\n    }\n    VECTOR(*boolvec)[id] = igraph_i_graphml_parse_boolean(state->data_char,\n\tgraphmlrec->default_value.as_boolean);\n    break;\n  case IGRAPH_ATTRIBUTE_NUMERIC:\n    vec=(igraph_vector_t *)rec->value;\n    s=igraph_vector_size(vec);\n    if (id >= s) {\n      ret=igraph_vector_resize(vec, id+1);\n      if (ret) {\n        RETURN_GRAPHML_PARSE_ERROR_WITH_CODE(state, \"Cannot parse GraphML file\", ret);\n      }\n      for (i=s; i<id; i++) {\n\tVECTOR(*vec)[i] = graphmlrec->default_value.as_numeric;\n      }\n    }\n    VECTOR(*vec)[id] = igraph_i_graphml_parse_numeric(state->data_char,\n\tgraphmlrec->default_value.as_numeric);\n    break;\n  case IGRAPH_ATTRIBUTE_STRING:\n    strvec=(igraph_strvector_t *)rec->value;\n    s=igraph_strvector_size(strvec);\n    if (id >= s) {\n      ret=igraph_strvector_resize(strvec, id+1);\n      if (ret) {\n        RETURN_GRAPHML_PARSE_ERROR_WITH_CODE(state, \"Cannot parse GraphML file\", ret);\n      }\n      strvalue = graphmlrec->default_value.as_string;\n      for (i=s;i<id;i++) {\n\tigraph_strvector_set(strvec, i, strvalue);\n      }\n    }\n    if (state->data_char) {\n      strvalue = state->data_char;\n    } else {\n      strvalue = graphmlrec->default_value.as_string;\n    }\n    ret=igraph_strvector_set(strvec, id, strvalue);\n    if (ret) {\n      RETURN_GRAPHML_PARSE_ERROR_WITH_CODE(state, \"Cannot parse GraphML file\", ret);\n    }\n    break;\n  default:\n    break;\n  }\n\n  if (state->data_char) {\n    igraph_Free(state->data_char);\n  }\n}", "target": 1, "idx": 10852}
{"commit_id": "6987fc7558bdbab8119eabf026e3cdad1053f0e5", "project": "xen-project/xen", "func": "static int put_page_from_l4e(l4_pgentry_t l4e, unsigned long pfn,\n                             int partial, bool defer)\n{\n    int rc = 1;\n\n    if ( (l4e_get_flags(l4e) & _PAGE_PRESENT) &&\n         (l4e_get_pfn(l4e) != pfn) )\n    {\n        struct page_info *pg = l4e_get_page(l4e);\n\n        if ( unlikely(partial > 0) )\n        {\n            ASSERT(!defer);\n            return _put_page_type(pg, true, mfn_to_page(_mfn(pfn)));\n        }\n\n        if ( defer )\n        {\n            current->arch.old_guest_ptpg = mfn_to_page(_mfn(pfn));\n            current->arch.old_guest_table = pg;\n            return 0;\n        }\n\n        rc = _put_page_type(pg, true, mfn_to_page(_mfn(pfn)));\n        if ( likely(!rc) )\n            put_page(pg);\n    }\n\n    return rc;\n}", "target": 2, "idx": 10853}
{"commit_id": "f3fa3abf3e61fb1f25ce721e14ac324dda67311f", "project": "xen-project/xen", "func": "static int priv_op_write_msr(unsigned int reg, uint64_t val,\n                             struct x86_emulate_ctxt *ctxt)\n{\n    struct vcpu *curr = current;\n    const struct domain *currd = curr->domain;\n    bool vpmu_msr = false;\n\n    switch ( reg )\n    {\n        uint64_t temp;\n        int rc;\n\n    case MSR_FS_BASE:\n        if ( is_pv_32bit_domain(currd) || !is_canonical_address(val) )\n            break;\n        wrfsbase(val);\n        curr->arch.pv_vcpu.fs_base = val;\n        return X86EMUL_OKAY;\n\n    case MSR_GS_BASE:\n        if ( is_pv_32bit_domain(currd) || !is_canonical_address(val) )\n            break;\n        wrgsbase(val);\n        curr->arch.pv_vcpu.gs_base_kernel = val;\n        return X86EMUL_OKAY;\n\n    case MSR_SHADOW_GS_BASE:\n        if ( is_pv_32bit_domain(currd) || !is_canonical_address(val) ||\n             wrmsr_safe(MSR_SHADOW_GS_BASE, val) )\n            break;\n        curr->arch.pv_vcpu.gs_base_user = val;\n        return X86EMUL_OKAY;\n\n    case MSR_K7_FID_VID_STATUS:\n    case MSR_K7_FID_VID_CTL:\n    case MSR_K8_PSTATE_LIMIT:\n    case MSR_K8_PSTATE_CTRL:\n    case MSR_K8_PSTATE_STATUS:\n    case MSR_K8_PSTATE0:\n    case MSR_K8_PSTATE1:\n    case MSR_K8_PSTATE2:\n    case MSR_K8_PSTATE3:\n    case MSR_K8_PSTATE4:\n    case MSR_K8_PSTATE5:\n    case MSR_K8_PSTATE6:\n    case MSR_K8_PSTATE7:\n    case MSR_K8_HWCR:\n        if ( boot_cpu_data.x86_vendor != X86_VENDOR_AMD )\n            break;\n        if ( likely(!is_cpufreq_controller(currd)) ||\n             wrmsr_safe(reg, val) == 0 )\n            return X86EMUL_OKAY;\n        break;\n\n    case MSR_AMD64_NB_CFG:\n        if ( boot_cpu_data.x86_vendor != X86_VENDOR_AMD ||\n             boot_cpu_data.x86 < 0x10 || boot_cpu_data.x86 > 0x17 )\n            break;\n        if ( !is_hardware_domain(currd) || !is_pinned_vcpu(curr) )\n            return X86EMUL_OKAY;\n        if ( (rdmsr_safe(MSR_AMD64_NB_CFG, temp) != 0) ||\n             ((val ^ temp) & ~(1ULL << AMD64_NB_CFG_CF8_EXT_ENABLE_BIT)) )\n            goto invalid;\n        if ( wrmsr_safe(MSR_AMD64_NB_CFG, val) == 0 )\n            return X86EMUL_OKAY;\n        break;\n\n    case MSR_FAM10H_MMIO_CONF_BASE:\n        if ( boot_cpu_data.x86_vendor != X86_VENDOR_AMD ||\n             boot_cpu_data.x86 < 0x10 || boot_cpu_data.x86 > 0x17 )\n            break;\n        if ( !is_hardware_domain(currd) || !is_pinned_vcpu(curr) )\n            return X86EMUL_OKAY;\n        if ( rdmsr_safe(MSR_FAM10H_MMIO_CONF_BASE, temp) != 0 )\n            break;\n        if ( (pci_probe & PCI_PROBE_MASK) == PCI_PROBE_MMCONF ?\n             temp != val :\n             ((temp ^ val) &\n              ~(FAM10H_MMIO_CONF_ENABLE |\n                (FAM10H_MMIO_CONF_BUSRANGE_MASK <<\n                 FAM10H_MMIO_CONF_BUSRANGE_SHIFT) |\n                ((u64)FAM10H_MMIO_CONF_BASE_MASK <<\n                 FAM10H_MMIO_CONF_BASE_SHIFT))) )\n            goto invalid;\n        if ( wrmsr_safe(MSR_FAM10H_MMIO_CONF_BASE, val) == 0 )\n            return X86EMUL_OKAY;\n        break;\n\n    case MSR_IA32_UCODE_REV:\n        if ( boot_cpu_data.x86_vendor != X86_VENDOR_INTEL )\n            break;\n        if ( !is_hardware_domain(currd) || !is_pinned_vcpu(curr) )\n            return X86EMUL_OKAY;\n        if ( rdmsr_safe(reg, temp) )\n            break;\n        if ( val )\n            goto invalid;\n        return X86EMUL_OKAY;\n\n    case MSR_IA32_MISC_ENABLE:\n        if ( rdmsr_safe(reg, temp) )\n            break;\n        if ( val != guest_misc_enable(temp) )\n            goto invalid;\n        return X86EMUL_OKAY;\n\n    case MSR_IA32_MPERF:\n    case MSR_IA32_APERF:\n        if ( (boot_cpu_data.x86_vendor != X86_VENDOR_INTEL) &&\n             (boot_cpu_data.x86_vendor != X86_VENDOR_AMD) )\n            break;\n        if ( likely(!is_cpufreq_controller(currd)) ||\n             wrmsr_safe(reg, val) == 0 )\n            return X86EMUL_OKAY;\n        break;\n\n    case MSR_IA32_PERF_CTL:\n        if ( boot_cpu_data.x86_vendor != X86_VENDOR_INTEL )\n            break;\n        if ( likely(!is_cpufreq_controller(currd)) ||\n             wrmsr_safe(reg, val) == 0 )\n            return X86EMUL_OKAY;\n        break;\n\n    case MSR_IA32_THERM_CONTROL:\n    case MSR_IA32_ENERGY_PERF_BIAS:\n        if ( boot_cpu_data.x86_vendor != X86_VENDOR_INTEL )\n            break;\n        if ( !is_hardware_domain(currd) || !is_pinned_vcpu(curr) ||\n             wrmsr_safe(reg, val) == 0 )\n            return X86EMUL_OKAY;\n        break;\n\n    case MSR_AMD64_DR0_ADDRESS_MASK:\n        if ( !boot_cpu_has(X86_FEATURE_DBEXT) || (val >> 32) )\n            break;\n        curr->arch.pv_vcpu.dr_mask[0] = val;\n        if ( curr->arch.debugreg[7] & DR7_ACTIVE_MASK )\n            wrmsrl(MSR_AMD64_DR0_ADDRESS_MASK, val);\n        return X86EMUL_OKAY;\n\n    case MSR_AMD64_DR1_ADDRESS_MASK ... MSR_AMD64_DR3_ADDRESS_MASK:\n        if ( !boot_cpu_has(X86_FEATURE_DBEXT) || (val >> 32) )\n            break;\n        curr->arch.pv_vcpu.dr_mask[reg - MSR_AMD64_DR1_ADDRESS_MASK + 1] = val;\n        if ( curr->arch.debugreg[7] & DR7_ACTIVE_MASK )\n            wrmsrl(reg, val);\n        return X86EMUL_OKAY;\n\n    case MSR_INTEL_PLATFORM_INFO:\n        if ( boot_cpu_data.x86_vendor != X86_VENDOR_INTEL ||\n             val || rdmsr_safe(MSR_INTEL_PLATFORM_INFO, val) )\n            break;\n        return X86EMUL_OKAY;\n\n    case MSR_INTEL_MISC_FEATURES_ENABLES:\n        if ( boot_cpu_data.x86_vendor != X86_VENDOR_INTEL ||\n             (val & ~MSR_MISC_FEATURES_CPUID_FAULTING) ||\n             rdmsr_safe(MSR_INTEL_MISC_FEATURES_ENABLES, temp) )\n            break;\n        if ( (val & MSR_MISC_FEATURES_CPUID_FAULTING) &&\n             !this_cpu(cpuid_faulting_enabled) )\n            break;\n        curr->arch.cpuid_faulting = !!(val & MSR_MISC_FEATURES_CPUID_FAULTING);\n        return X86EMUL_OKAY;\n\n    case MSR_P6_PERFCTR(0)...MSR_P6_PERFCTR(7):\n    case MSR_P6_EVNTSEL(0)...MSR_P6_EVNTSEL(3):\n    case MSR_CORE_PERF_FIXED_CTR0...MSR_CORE_PERF_FIXED_CTR2:\n    case MSR_CORE_PERF_FIXED_CTR_CTRL...MSR_CORE_PERF_GLOBAL_OVF_CTRL:\n        if ( boot_cpu_data.x86_vendor == X86_VENDOR_INTEL )\n        {\n            vpmu_msr = true;\n    case MSR_AMD_FAM15H_EVNTSEL0...MSR_AMD_FAM15H_PERFCTR5:\n    case MSR_K7_EVNTSEL0...MSR_K7_PERFCTR3:\n            if ( vpmu_msr || (boot_cpu_data.x86_vendor == X86_VENDOR_AMD) )\n            {\n                if ( (vpmu_mode & XENPMU_MODE_ALL) &&\n                     !is_hardware_domain(currd) )\n                    return X86EMUL_OKAY;\n\n                if ( vpmu_do_wrmsr(reg, val, 0) )\n                    break;\n                return X86EMUL_OKAY;\n            }\n        }\n        /* fall through */\n    default:\n        if ( wrmsr_hypervisor_regs(reg, val) == 1 )\n            return X86EMUL_OKAY;\n\n        rc = vmce_wrmsr(reg, val);\n        if ( rc < 0 )\n            break;\n        if ( rc )\n            return X86EMUL_OKAY;\n\n        if ( (rdmsr_safe(reg, temp) != 0) || (val != temp) )\n    invalid:\n            gdprintk(XENLOG_WARNING,\n                     \"Domain attempted WRMSR %08x from 0x%016\"PRIx64\" to 0x%016\"PRIx64\"\\n\",\n                     reg, temp, val);\n        return X86EMUL_OKAY;\n    }\n\n    return X86EMUL_UNHANDLEABLE;\n}", "target": 1, "idx": 10854}
{"commit_id": "d229761821da38d984a9e4098ad96842490dc001", "project": "znc", "func": "bool CClient::OnTextMessage(CTextMessage& Message) {\n    CString sTargets = Message.GetTarget();\n\n    VCString vTargets;\n    sTargets.Split(\",\", vTargets, false);\n\n    for (CString& sTarget : vTargets) {\n        Message.SetTarget(sTarget);\n        if (m_pNetwork) {\n            // May be nullptr.\n            Message.SetChan(m_pNetwork->FindChan(sTarget));\n        }\n\n        if (sTarget.TrimPrefix(m_pUser->GetStatusPrefix())) {\n            EchoMessage(Message);\n\n            if (sTarget.Equals(\"status\")) {\n                CString sMsg = Message.GetText();\n                UserCommand(sMsg);\n            } else {\n                CALLMOD(sTarget, this, m_pUser, m_pNetwork,\n                        OnModCommand(Message.GetText()));\n            }\n            continue;\n        }\n\n        bool bContinue = false;\n        NETWORKMODULECALL(OnUserTextMessage(Message), m_pUser, m_pNetwork, this,\n                          &bContinue);\n        if (bContinue) continue;\n\n        if (!GetIRCSock()) {\n            // Some lagmeters do a PRIVMSG to their own nick, ignore those.\n            if (!sTarget.Equals(m_sNick))\n                PutStatus(\n                    t_f(\"Your message to {1} got lost, you are not connected \"\n                        \"to IRC!\")(Message.GetTarget()));\n            continue;\n        }\n\n        if (m_pNetwork) {\n            AddBuffer(Message);\n            EchoMessage(Message);\n            PutIRC(Message.ToString(CMessage::ExcludePrefix |\n                                    CMessage::ExcludeTags));\n        }\n    }\n\n    return true;\n}", "target": 1, "idx": 10855}
{"commit_id": "ec54f1c7b50df944ae4a8d3e29cd7eaf1cc97b21", "project": "openlink/virtuoso-opensource", "func": "void\nddl_ensure_index (const char *table, const char * index_name, const char *text)\n{\n  client_connection_t *old_cli = sqlc_client();\n  sqlc_set_client (NULL);\n  dbe_table_t * tb = sch_name_to_table (wi_inst.wi_schema, table);\n  dbe_key_t * key = tb ? tb_find_key (tb, index_name, 0) : NULL;\n  if (!key)\n    {\n      caddr_t err = NULL;\n      query_t *obj_create = eql_compile_2 (text, bootstrap_cli, &err, SQLC_DEFAULT);\n      if (err)\n\t{\n\t  log_error (\"Error compiling a server init statement : %s: %s -- %s\",\n\t      ((caddr_t *) err)[QC_ERRNO], ((caddr_t *) err)[QC_ERROR_STRING],\n\t\t     err_first_line (text));\n\t  sqlc_set_client (old_cli);\n\t  dk_free_tree (err);\n\t  return;\n\t}\n      sqlc_set_client (bootstrap_cli);\n      first_id = DD_FIRST_PRIVATE_OID;\n      err = qr_quick_exec (obj_create, bootstrap_cli, \"\", NULL, 0);\n      if (err)\n\t{\n\t  if (err == (caddr_t) SQL_NO_DATA_FOUND)\n\t    log_error (\"Error executing a server init statement : NO DATA FOUND -- %s\",\n\t\t       err_first_line (text));\n\t  else\n\t    log_error (\"Error executing a server init statement : %s: %s -- %s\",\n\t\t((caddr_t *) err)[QC_ERRNO], ((caddr_t *) err)[QC_ERROR_STRING],\n\t\t       err_first_line (text));\n\t  dk_free_tree (err);\n\t  qr_free (obj_create);\n\t  sqlc_set_client (old_cli);\n\t  return;\n\t}\n      qr_free (obj_create);\n\n      first_id = DD_FIRST_FREE_OID;\n      sqlc_set_client (old_cli);\n      local_commit (bootstrap_cli);\n    }\n  else\n    sqlc_set_client (old_cli);\n}", "target": 2, "idx": 10856}
{"commit_id": "3eb6764acd2d708f6873c177a77f9bef3b266fa9", "project": "libuv", "func": "static void uv__rwlock_fallback_wrunlock(uv_rwlock_t* rwlock) {\n  if (!ReleaseSemaphore(rwlock->fallback_.write_lock_.sem, 1, NULL))\n    uv_fatal_error(GetLastError(), \"ReleaseSemaphore\");\n}", "target": 2, "idx": 10857}
{"commit_id": "c5f30c70e48786e1aef8c815f35e406a6c4fb3ae", "project": "Samsung/mTower", "func": "TEE_Result tee_pobj_get(TEE_UUID *uuid, void *obj_id, uint32_t obj_id_len,\n\t\t\tuint32_t flags, bool temporary,\n\t\t\tconst struct tee_file_operations *fops,\n\t\t\tstruct tee_pobj **obj)\n{\n\tstruct tee_pobj *o;\n\tTEE_Result res;\n\n\t*obj = NULL;\n\n//\tmutex_lock(&pobjs_mutex);\n\t/* Check if file is open */\n\tTAILQ_FOREACH(o, &tee_pobjs, link) {\n\t\tif ((obj_id_len == o->obj_id_len) &&\n\t\t    (memcmp(obj_id, o->obj_id, obj_id_len) == 0) &&\n\t\t    (memcmp(uuid, &o->uuid, sizeof(TEE_UUID)) == 0) &&\n\t\t    (fops == o->fops)) {\n\t\t\t*obj = o;\n\t\t}\n\t}\n\n\tif (*obj) {\n\t\tif (temporary != (*obj)->temporary) {\n\t\t\tres = TEE_ERROR_ACCESS_CONFLICT;\n\t\t\tgoto out;\n\t\t}\n\t\tres = tee_pobj_check_access((*obj)->flags, flags);\n\t\tif (res == TEE_SUCCESS)\n\t\t\t(*obj)->refcnt++;\n\t\tgoto out;\n\t}\n\n\t/* new file */\n\to = TEE_Malloc(sizeof(struct tee_pobj), TEE_MALLOC_FILL_ZERO);\n\t// o = calloc(1, sizeof(struct tee_pobj));\n\tif (!o) {\n\t\tres = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto out;\n\t}\n\n\to->refcnt = 1;\n\tmemcpy(&o->uuid, uuid, sizeof(TEE_UUID));\n\to->flags = flags;\n\to->fops = fops;\n\to->temporary = temporary;\n\n\to->obj_id = malloc(obj_id_len);\n\tif (o->obj_id == NULL) {\n\t\tfree(o);\n\t\tres = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto out;\n\t}\n\tmemcpy(o->obj_id, obj_id, obj_id_len);\n\to->obj_id_len = obj_id_len;\n\n\tTAILQ_INSERT_TAIL(&tee_pobjs, o, link);\n\t*obj = o;\n\n\tres = TEE_SUCCESS;\nout:\n\tif (res != TEE_SUCCESS)\n\t\t*obj = NULL;\n//\tmutex_unlock(&pobjs_mutex);\n\treturn res;\n}", "target": 2, "idx": 10858}
{"commit_id": "2ddd92b6f8f587325b9e14598658626f3a007c5c", "project": "wireshark", "func": "static void\ndissect_sdp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\n{\n    proto_tree *sdp_tree;\n    proto_item *ti, *sub_ti;\n    gint        offset = 0, next_offset, n, i;\n    int         linelen;\n    gboolean    in_media_description;\n    guchar      type, delim;\n    int         datalen, tokenoffset, hf = -1;\n    char       *string;\n\n    transport_info_t  local_transport_info;\n    transport_info_t* transport_info = NULL;\n    disposable_media_info_t media_info;\n\n    sdp_packet_info  *sdp_pi;\n    struct srtp_info *srtp_info = NULL;\n\n    DPRINT2((\"----------------------- dissect_sdp ------------------------\"));\n\n    /* Initialise packet info for passing to tap */\n    sdp_pi = wmem_new(wmem_packet_scope(), sdp_packet_info);\n    sdp_pi->summary_str[0] = '\\0';\n\n    if (!pinfo->fd->flags.visited) {\n        transport_info = (transport_info_t*)wmem_tree_lookup32( sdp_transport_reqs, pinfo->fd->num );\n\n        if (transport_info == NULL) {\n          /* Can't find it in the requests, make sure it's not a response */\n          transport_info = (transport_info_t*)wmem_tree_lookup32( sdp_transport_rsps, pinfo->fd->num );\n        }\n    }\n\n    if (transport_info == NULL) {\n      transport_info = &local_transport_info;\n    }\n#ifdef DEBUG_CONVERSATION\n    else {\n        DPRINT((\"found previous transport_info:\"));\n        sdp_dump_transport_info(transport_info);\n    }\n#endif\n\n    /* Initialize local transport info */\n    memset(&local_transport_info, 0, sizeof(local_transport_info));\n    local_transport_info.media_count = -1;\n\n    for (n = 0; n < SDP_NO_OF_PT; n++) {\n        local_transport_info.encoding_name[n] = (char*)UNKNOWN_ENCODING;\n    }\n    for (n = 0; n < SDP_MAX_RTP_CHANNELS; n++) {\n        local_transport_info.media[n].rtp_dyn_payload = rtp_dyn_payload_new();\n        local_transport_info.media[n].set_rtp = FALSE;\n    }\n\n    memset(&media_info, 0, sizeof(media_info));\n\n    /*\n     * As RFC 2327 says, \"SDP is purely a format for session\n     * description - it does not incorporate a transport protocol,\n     * and is intended to use different transport protocols as\n     * appropriate including the Session Announcement Protocol,\n     * Session Initiation Protocol, Real-Time Streaming Protocol,\n     * electronic mail using the MIME extensions, and the\n     * Hypertext Transport Protocol.\"\n     *\n     * We therefore don't set the protocol or info columns;\n     * instead, we append to them, so that we don't erase\n     * what the protocol inside which the SDP stuff resides\n     * put there.\n     */\n    col_append_str(pinfo->cinfo, COL_PROTOCOL, \"/SDP\");\n\n    /* XXX: Needs description.\n     * Putting with session description in info col is redundant when it's in the\n     * protocol col in my opinion, commenting it out for now 2012-10-09. Remove if no one complains.\n     * If some one want it consider \" ,with SDP\"\n     */\n    /*col_append_str(pinfo->cinfo, COL_INFO, \", with session description\");*/\n\n    ti = proto_tree_add_item(tree, proto_sdp, tvb, offset, -1, ENC_NA);\n    sdp_tree = proto_item_add_subtree(ti, ett_sdp);\n\n    /*\n     * Show the SDP message a line at a time.\n     */\n    in_media_description = FALSE;\n\n    while (tvb_offset_exists(tvb, offset)) {\n        /*\n         * Find the end of the line.\n         */\n        linelen = tvb_find_line_end_unquoted(tvb, offset, -1, &next_offset);\n\n        /*\n         * Line must contain at least e.g. \"v=\".\n         */\n        if (linelen < 2)\n            break;\n\n        type  = tvb_get_guint8(tvb, offset);\n        delim = tvb_get_guint8(tvb, offset + 1);\n        if (delim != '=') {\n            proto_item *ti2 = proto_tree_add_item(sdp_tree, hf_invalid, tvb, offset, linelen, ENC_UTF_8|ENC_NA);\n            expert_add_info(pinfo, ti2, &ei_sdp_invalid_line_equal);\n            offset = next_offset;\n            continue;\n        }\n\n        /*\n         * Attributes.\n         */\n        switch (type) {\n            case 'v':\n                hf = hf_protocol_version;\n                break;\n            case 'o':\n                hf = hf_owner;\n                break;\n            case 's':\n                hf = hf_session_name;\n                break;\n            case 'i':\n                if (in_media_description) {\n                  hf = hf_media_title;\n                } else {\n                  hf = hf_session_info;\n                }\n                break;\n            case 'u':\n                hf = hf_uri;\n                break;\n            case 'e':\n                hf = hf_email;\n                break;\n            case 'p':\n                hf = hf_phone;\n                break;\n            case 'c':\n                hf = hf_connection_info;\n                break;\n            case 'b':\n                hf = hf_bandwidth;\n                break;\n            case 't':\n                hf = hf_time;\n                break;\n            case 'r':\n                hf = hf_repeat_time;\n                break;\n            case 'm':\n                hf = hf_media;\n\n                /* Increase the count of media channels, but don't walk off the end of the arrays. */\n                if (local_transport_info.media_count < (SDP_MAX_RTP_CHANNELS-1))\n                    local_transport_info.media_count++;\n\n                if (in_media_description && (media_info.media_count < (SDP_MAX_RTP_CHANNELS-1)))\n                    media_info.media_count++;\n\n                in_media_description = TRUE;\n                break;\n            case 'k':\n                hf = hf_encryption_key;\n                break;\n            case 'a':\n                if (in_media_description) {\n                    hf = hf_media_attribute;\n                } else {\n                    hf = hf_session_attribute;\n                }\n                break;\n            case 'z':\n                hf = hf_timezone;\n                break;\n            default:\n                hf = hf_unknown;\n                break;\n        }\n        tokenoffset = 2;\n        if (hf == hf_unknown)\n            tokenoffset = 0;\n        string = (char*)tvb_get_string_enc(wmem_packet_scope(), tvb, offset + tokenoffset,\n                                                 linelen - tokenoffset, ENC_ASCII);\n        sub_ti = proto_tree_add_string(sdp_tree, hf, tvb, offset, linelen,\n                                       string);\n\n        call_sdp_subdissector(tvb_new_subset_length(tvb, offset + tokenoffset,\n                                             linelen - tokenoffset),\n                              pinfo,\n                              hf, sub_ti, linelen-tokenoffset,\n                              &local_transport_info, &media_info);\n\n        offset = next_offset;\n    }\n\n    if (in_media_description) {\n        /* Increase the count of media channels, but don't walk off the end of the arrays. */\n        if (local_transport_info.media_count < (SDP_MAX_RTP_CHANNELS-1))\n            local_transport_info.media_count++;\n        if (media_info.media_count < (SDP_MAX_RTP_CHANNELS-1))\n            media_info.media_count++;\n    }\n\n    /* Take all of the collected strings and convert them into something permanent\n     * for the life of the capture\n     */\n    if (transport_info == &local_transport_info) {\n        DPRINT((\"no previous transport_info saved, calling convert_disposable_media()\"));\n        DINDENT();\n        convert_disposable_media(transport_info, &media_info, 0);\n        DENDENT();\n#ifdef DEBUG_CONVERSATION\n        sdp_dump_transport_info(transport_info);\n#endif\n    }\n#ifdef DEBUG_CONVERSATION\n    else {\n        DPRINT((\"not overwriting previous transport_info, local_transport_info contents:\"));\n        sdp_dump_transport_info(&local_transport_info);\n    }\n#endif\n\n    for (n = 0; n < local_transport_info.media_count; n++)\n    {\n        /* Add (s)rtp and (s)rtcp conversation, if available (overrides t38 if conversation already set) */\n        /* XXX - This is a placeholder for higher layer protocols that haven't implemented the proper\n         * OFFER/ANSWER functionality using setup_sdp_transport().  Once all of the higher layers\n         * use setup_sdp_transport(), this should be removed\n         */\n        guint32 current_rtp_port = 0;\n\n        if ((!pinfo->fd->flags.visited) && (transport_info == &local_transport_info) &&\n            (transport_info->media_port[n] != 0) &&\n            (transport_info->proto_bitmask[n] & (SDP_RTP_PROTO|SDP_SRTP_PROTO)) &&\n            (transport_info->proto_bitmask[n] & (SDP_IPv4|SDP_IPv6))) {\n\n            if (transport_info->proto_bitmask[n] & SDP_SRTP_PROTO) {\n                srtp_info = wmem_new0(wmem_file_scope(), struct srtp_info);\n                if (transport_info->encryption_algorithm != SRTP_ENC_ALG_NOT_SET) {\n                    srtp_info->encryption_algorithm = transport_info->encryption_algorithm;\n                    srtp_info->auth_algorithm       = transport_info->auth_algorithm;\n                    srtp_info->mki_len              = transport_info->mki_len;\n                    srtp_info->auth_tag_len         = transport_info->auth_tag_len;\n                }\n                DPRINT((\"calling srtp_add_address for media_port=%d, for channel=%d\",\n                        transport_info->media_port[n],n));\n                DINDENT();\n                srtp_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n], 0, \"SDP\", pinfo->fd->num,\n                                (transport_info->proto_bitmask[n] & SDP_VIDEO) ? TRUE : FALSE,\n                                 transport_info->media[n].rtp_dyn_payload, srtp_info);\n                DENDENT();\n            } else {\n                DPRINT((\"calling rtp_add_address for media_port=%d, for channel=%d\",\n                        transport_info->media_port[n],n));\n                DINDENT();\n                rtp_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n], 0, \"SDP\", pinfo->fd->num,\n                                (transport_info->proto_bitmask[n] & SDP_VIDEO) ? TRUE : FALSE,\n                                transport_info->media[n].rtp_dyn_payload);\n                DENDENT();\n            }\n            transport_info->media[n].set_rtp = TRUE;\n            /* SPRT might use the same port... */\n            current_rtp_port = transport_info->media_port[n];\n\n            if (rtcp_handle) {\n                if (transport_info->proto_bitmask[n] & SDP_SRTP_PROTO) {\n                    DPRINT((\"calling srtcp_add_address for media_port=%d, for channel=%d\",\n                            transport_info->media_port[n],n));\n                    DINDENT();\n                    srtcp_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n]+1, 0, \"SDP\", pinfo->fd->num, srtp_info);\n                    DENDENT();\n                } else {\n                    DPRINT((\"calling rtcp_add_address for media_port=%d, for channel=%d\",\n                            transport_info->media_port[n],n));\n                    DINDENT();\n                    rtcp_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n]+1, 0, \"SDP\", pinfo->fd->num);\n                    DENDENT();\n                }\n            }\n        }\n\n        /* add SPRT conversation */\n        /* XXX - more placeholder functionality */\n        if ((!pinfo->fd->flags.visited) && (transport_info == &local_transport_info) &&\n            (transport_info->proto_bitmask[n] & SDP_SPRT_PROTO) &&\n            (transport_info->proto_bitmask[n] & (SDP_IPv4|SDP_IPv6)) &&\n            (sprt_handle)) {\n\n            if (transport_info->media_port[n] == 0 && current_rtp_port) {\n                sprt_add_address(pinfo, &transport_info->src_addr[n], current_rtp_port,\n                                 0, \"SDP\", pinfo->fd->num); /* will use same port as RTP */\n            } else {\n                sprt_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n], 0, \"SDP\", pinfo->fd->num);\n            }\n        }\n\n        /* Add t38 conversation, if available and only if no rtp */\n        /* XXX - more placeholder functionality */\n        if ((!pinfo->fd->flags.visited) && (transport_info == &local_transport_info) &&\n            (transport_info->media_port[n] != 0) &&\n            !transport_info->media[n].set_rtp &&\n            (transport_info->proto_bitmask[n] & SDP_T38_PROTO) &&\n            (transport_info->proto_bitmask[n] & SDP_IPv4)) {\n            t38_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n], 0, \"SDP\", pinfo->fd->num);\n        }\n\n        /* Add MSRP conversation.  Uses addresses discovered in attribute\n           rather than connection information of media session line */\n        /* XXX - more placeholder functionality */\n        if ((!pinfo->fd->flags.visited) && (transport_info == &local_transport_info) &&\n            (transport_info->proto_bitmask[n] & SDP_MSRP_PROTO) &&\n            (transport_info->proto_bitmask[n] & SDP_MSRP_IPv4) &&\n            msrp_handle) {\n            msrp_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n], \"SDP\", pinfo->fd->num);\n        }\n\n        if (local_transport_info.media_port[n] != 0) {\n            /* Create the RTP summary str for the Voip Call analysis.\n             * XXX - Currently this is based only on the current packet\n             */\n            for (i = 0; i < local_transport_info.media[n].pt_count; i++)\n            {\n                DPRINT((\"in for-loop for voip call analysis setting for media #%d, pt=%d\",\n                        i, local_transport_info.media[n].pt[i]));\n                /* if the payload type is dynamic (96 to 127), check the hash table to add the desc in the SDP summary */\n                if ((local_transport_info.media[n].pt[i] >= 96) && (local_transport_info.media[n].pt[i] <= 127)) {\n                    const gchar *payload_type_str = rtp_dyn_payload_get_name(\n                        local_transport_info.media[n].rtp_dyn_payload,\n                        local_transport_info.media[n].pt[i]);\n                    if (payload_type_str) {\n                        if (strlen(sdp_pi->summary_str))\n                            g_strlcat(sdp_pi->summary_str, \" \", 50);\n                        g_strlcat(sdp_pi->summary_str, payload_type_str, 50);\n                    } else {\n                        char num_pt[10];\n                        g_snprintf(num_pt, 10, \"%u\", local_transport_info.media[n].pt[i]);\n                        if (strlen(sdp_pi->summary_str))\n                            g_strlcat(sdp_pi->summary_str, \" \", 50);\n                        g_strlcat(sdp_pi->summary_str, num_pt, 50);\n                      }\n                } else {\n                    if (strlen(sdp_pi->summary_str))\n                        g_strlcat(sdp_pi->summary_str, \" \", 50);\n                    g_strlcat(sdp_pi->summary_str,\n                              val_to_str_ext(local_transport_info.media[n].pt[i], &rtp_payload_type_short_vals_ext, \"%u\"),\n                              50);\n                }\n            }\n        }\n\n        /* Free the hash table if we did't assigned it to a conv use it */\n        /* XXX - more placeholder functionality */\n        if ((transport_info == &local_transport_info) &&\n            !transport_info->media[n].set_rtp)\n        {\n            rtp_dyn_payload_free(transport_info->media[n].rtp_dyn_payload);\n            transport_info->media[n].rtp_dyn_payload = NULL;\n        }\n\n        /* Create the T38 summary str for the Voip Call analysis\n         * XXX - Currently this is based only on the current packet\n         */\n        if ((local_transport_info.media_port[n] != 0) &&\n            (local_transport_info.proto_bitmask[n] & SDP_T38_PROTO)) {\n            if (strlen(sdp_pi->summary_str))\n                g_strlcat(sdp_pi->summary_str, \" \", 50);\n            g_strlcat(sdp_pi->summary_str, \"t38\", 50);\n        }\n    }\n\n    /* Free the remainded hash tables not used */\n    /* XXX - more placeholder functionality */\n    if (transport_info == &local_transport_info) {\n        for (n = MAX(transport_info->media_count, 0); n < SDP_MAX_RTP_CHANNELS; n++)\n        {\n            if (!transport_info->media[n].set_rtp)\n            {\n                rtp_dyn_payload_free(transport_info->media[n].rtp_dyn_payload);\n                transport_info->media[n].rtp_dyn_payload = NULL;\n            }\n        }\n    }\n\n    datalen = tvb_captured_length_remaining(tvb, offset);\n    if (datalen > 0) {\n        proto_tree_add_item(sdp_tree, hf_sdp_data, tvb, offset, datalen, ENC_NA);\n    }\n    /* Report this packet to the tap */\n    tap_queue_packet(sdp_tap, pinfo, sdp_pi);\n}", "target": 1, "idx": 10859}
{"commit_id": "014b40fb7e8d59087cf1c1988a68dd1979f86cb3", "project": "timescale/timescaledb", "func": "void\ncontinuous_agg_update_materialization(SchemaAndName partial_view,\n\t\t\t\t\t\t\t\t\t  SchemaAndName materialization_table,\n\t\t\t\t\t\t\t\t\t  const NameData *time_column_name,\n\t\t\t\t\t\t\t\t\t  InternalTimeRange new_materialization_range,\n\t\t\t\t\t\t\t\t\t  InternalTimeRange invalidation_range, int32 chunk_id)\n{\n\tInternalTimeRange combined_materialization_range = new_materialization_range;\n\tbool materialize_invalidations_separately = range_length(invalidation_range) > 0;\n\tint res = SPI_connect();\n\tif (res != SPI_OK_CONNECT)\n\t\telog(ERROR, \"could not connect to SPI in materializer\");\n\n\t/* Lock down search_path */\n\tres = SPI_exec(\"SET LOCAL search_path TO pg_catalog, pg_temp\", 0);\n\tif (res < 0)\n\t\tereport(ERROR, (errcode(ERRCODE_INTERNAL_ERROR), (errmsg(\"could not set search_path\"))));\n\n\t/* pin the start of new_materialization to the end of new_materialization,\n\t * we are not allowed to materialize beyond that point\n\t */\n\tif (new_materialization_range.start > new_materialization_range.end)\n\t\tnew_materialization_range.start = new_materialization_range.end;\n\n\tif (range_length(invalidation_range) > 0)\n\t{\n\t\tAssert(invalidation_range.start <= invalidation_range.end);\n\n\t\t/* we never materialize beyond the new materialization range */\n\t\tif (invalidation_range.start >= new_materialization_range.end ||\n\t\t\tinvalidation_range.end > new_materialization_range.end)\n\t\t\telog(ERROR, \"internal error: invalidation range ahead of new materialization range\");\n\n\t\t/* If the invalidation and new materialization ranges overlap, materialize in one go */\n\t\tmaterialize_invalidations_separately =\n\t\t\t!ranges_overlap(invalidation_range, new_materialization_range);\n\n\t\tcombined_materialization_range.start =\n\t\t\tint64_min(invalidation_range.start, new_materialization_range.start);\n\t}\n\n\t/* Then insert the materializations.\n\t * We insert them in two groups:\n\t * [lowest_invalidated, greatest_invalidated] and\n\t * [start_of_new_materialization, end_of_new_materialization]\n\t * eventually, we may want more precise deletions and insertions for the invalidated ranges.\n\t * if greatest_invalidated == end_of_new_materialization then we only perform 1 insertion.\n\t * to prevent values from being inserted multiple times.\n\t */\n\tif (range_length(invalidation_range) == 0 || !materialize_invalidations_separately)\n\t{\n\t\tspi_update_materializations(partial_view,\n\t\t\t\t\t\t\t\t\tmaterialization_table,\n\t\t\t\t\t\t\t\t\ttime_column_name,\n\t\t\t\t\t\t\t\t\tinternal_time_range_to_time_range(\n\t\t\t\t\t\t\t\t\t\tcombined_materialization_range),\n\t\t\t\t\t\t\t\t\tchunk_id);\n\t}\n\telse\n\t{\n\t\tspi_update_materializations(partial_view,\n\t\t\t\t\t\t\t\t\tmaterialization_table,\n\t\t\t\t\t\t\t\t\ttime_column_name,\n\t\t\t\t\t\t\t\t\tinternal_time_range_to_time_range(invalidation_range),\n\t\t\t\t\t\t\t\t\tchunk_id);\n\n\t\tspi_update_materializations(partial_view,\n\t\t\t\t\t\t\t\t\tmaterialization_table,\n\t\t\t\t\t\t\t\t\ttime_column_name,\n\t\t\t\t\t\t\t\t\tinternal_time_range_to_time_range(new_materialization_range),\n\t\t\t\t\t\t\t\t\tchunk_id);\n\t}\n\n\tif ((res = SPI_finish()) != SPI_OK_FINISH)\n\t\telog(ERROR, \"SPI_finish failed: %s\", SPI_result_code_string(res));\n}", "target": 2, "idx": 10860}
{"commit_id": "14dd68afa50a82ed7a43d25508d701dcaa631e3e", "project": "jerryscript-project/jerryscript", "func": "static void\nparser_parse_function_statement (parser_context_t *context_p) /**< context */\n{\n  JERRY_ASSERT (context_p->token.type == LEXER_KEYW_FUNCTION);\n\n#if ENABLED (JERRY_ES2015)\n  if (JERRY_UNLIKELY (parser_statement_flags[context_p->stack_top_uint8] & PARSER_STATM_SINGLE_STATM))\n  {\n    if (context_p->status_flags & PARSER_IS_STRICT)\n    {\n      parser_raise_error (context_p, PARSER_ERR_LEXICAL_SINGLE_STATEMENT);\n    }\n\n    if (context_p->stack_top_uint8 == PARSER_STATEMENT_IF\n        || context_p->stack_top_uint8 == PARSER_STATEMENT_ELSE)\n    {\n      /* There must be a parser error later if this check fails. */\n      if (context_p->next_scanner_info_p->source_p == context_p->source_p)\n      {\n        parser_push_block_context (context_p, true);\n      }\n    }\n    else if (context_p->stack_top_uint8 == PARSER_STATEMENT_LABEL)\n    {\n      parser_stack_iterator_t iterator;\n      parser_stack_iterator_init (context_p, &iterator);\n      parser_stack_iterator_skip (&iterator, sizeof (parser_label_statement_t) + 1);\n\n      while (true)\n      {\n        uint8_t type = parser_stack_iterator_read_uint8 (&iterator);\n\n        if (type == PARSER_STATEMENT_LABEL)\n        {\n          parser_stack_iterator_skip (&iterator, sizeof (parser_label_statement_t) + 1);\n          continue;\n        }\n\n        if (parser_statement_flags[type] & PARSER_STATM_HAS_BLOCK)\n        {\n          break;\n        }\n\n        parser_raise_error (context_p, PARSER_ERR_LABELLED_FUNC_NOT_IN_BLOCK);\n      }\n    }\n    else\n    {\n      parser_raise_error (context_p, PARSER_ERR_LEXICAL_SINGLE_STATEMENT);\n    }\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n#if ENABLED (JERRY_DEBUGGER)\n  parser_line_counter_t debugger_line = context_p->token.line;\n  parser_line_counter_t debugger_column = context_p->token.column;\n#endif /* ENABLED (JERRY_DEBUGGER) */\n\n#if ENABLED (JERRY_ES2015)\n  bool is_generator_function = false;\n\n  if (lexer_consume_generator (context_p))\n  {\n    is_generator_function = true;\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n  lexer_expect_identifier (context_p, LEXER_NEW_IDENT_LITERAL);\n  JERRY_ASSERT (context_p->token.type == LEXER_LITERAL\n                && context_p->token.lit_location.type == LEXER_IDENT_LITERAL);\n\n#if ENABLED (JERRY_ES2015)\n  if (context_p->next_scanner_info_p->source_p == context_p->source_p\n      && context_p->next_scanner_info_p->type == SCANNER_TYPE_ERR_REDECLARED)\n  {\n    parser_raise_error (context_p, PARSER_ERR_VARIABLE_REDECLARED);\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n  uint16_t function_name_index = context_p->lit_object.index;\n  parser_module_append_export_name (context_p);\n  context_p->status_flags &= (uint32_t) ~(PARSER_MODULE_STORE_IDENT);\n#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */\n\n  uint32_t status_flags = PARSER_FUNCTION_CLOSURE;\n\n  if (context_p->token.keyword_type >= LEXER_FIRST_NON_STRICT_ARGUMENTS)\n  {\n    status_flags |= PARSER_HAS_NON_STRICT_ARG;\n  }\n\n#if ENABLED (JERRY_ES2015)\n  if (is_generator_function)\n  {\n    status_flags |= PARSER_IS_GENERATOR_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;\n  }\n\n  if (context_p->next_scanner_info_p->u8_arg & SCANNER_FUNCTION_ASYNC)\n  {\n    status_flags |= PARSER_IS_ASYNC_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n#if ENABLED (JERRY_DEBUGGER)\n  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)\n  {\n    lexer_literal_t *name_p = context_p->lit_object.literal_p;\n    jerry_debugger_send_string (JERRY_DEBUGGER_FUNCTION_NAME,\n                                JERRY_DEBUGGER_NO_SUBTYPE,\n                                name_p->u.char_p,\n                                name_p->prop.length);\n\n    /* Reset token position for the function. */\n    context_p->token.line = debugger_line;\n    context_p->token.column = debugger_column;\n  }\n#endif /* ENABLED (JERRY_DEBUGGER) */\n\n  JERRY_ASSERT (context_p->scope_stack_top >= 2);\n  parser_scope_stack_t *scope_stack_p = context_p->scope_stack_p + context_p->scope_stack_top - 2;\n\n  uint16_t literal_index = context_p->lit_object.index;\n\n  while (literal_index != scope_stack_p->map_from)\n  {\n    scope_stack_p--;\n\n    JERRY_ASSERT (scope_stack_p >= context_p->scope_stack_p);\n  }\n\n  JERRY_ASSERT (scope_stack_p[1].map_from == PARSER_SCOPE_STACK_FUNC);\n\n#if ENABLED (JERRY_ES2015)\n  if (!(context_p->status_flags & PARSER_IS_STRICT)\n      && (scope_stack_p >= context_p->scope_stack_p + context_p->scope_stack_global_end))\n  {\n    bool copy_value = true;\n\n    parser_scope_stack_t *stack_p = context_p->scope_stack_p;\n\n    while (stack_p < scope_stack_p)\n    {\n      if (literal_index == stack_p->map_from\n          && (stack_p->map_to & PARSER_SCOPE_STACK_NO_FUNCTION_COPY))\n      {\n        copy_value = false;\n        break;\n      }\n      stack_p++;\n    }\n\n    if (copy_value)\n    {\n      stack_p = context_p->scope_stack_p;\n\n      while (stack_p < scope_stack_p)\n      {\n        if (literal_index == stack_p->map_from)\n        {\n          JERRY_ASSERT (!(stack_p->map_to & PARSER_SCOPE_STACK_NO_FUNCTION_COPY));\n\n          uint16_t map_to = scanner_decode_map_to (stack_p);\n          uint16_t opcode = ((map_to >= PARSER_REGISTER_START) ? CBC_ASSIGN_LITERAL_SET_IDENT\n                                                               : CBC_COPY_TO_GLOBAL);\n\n          parser_emit_cbc_literal_value (context_p,\n                                         opcode,\n                                         scanner_decode_map_to (scope_stack_p),\n                                         map_to);\n          break;\n        }\n        stack_p++;\n      }\n\n      parser_flush_cbc (context_p);\n    }\n\n    if (JERRY_UNLIKELY (context_p->stack_top_uint8 == PARSER_STATEMENT_PRIVATE_SCOPE\n                        || context_p->stack_top_uint8 == PARSER_STATEMENT_PRIVATE_CONTEXT))\n    {\n      parser_pop_block_context (context_p);\n    }\n  }\n#endif /* ENABLED (JERRY_ES2015) */\n\n  lexer_literal_t *literal_p = PARSER_GET_LITERAL ((size_t) scope_stack_p[1].map_to);\n\n  JERRY_ASSERT ((literal_p->type == LEXER_UNUSED_LITERAL || literal_p->type == LEXER_FUNCTION_LITERAL)\n                && literal_p->status_flags == 0);\n\n  ecma_compiled_code_t *compiled_code_p = parser_parse_function (context_p, status_flags);\n\n  if (literal_p->type == LEXER_FUNCTION_LITERAL)\n  {\n    ecma_bytecode_deref (literal_p->u.bytecode_p);\n  }\n\n  literal_p->u.bytecode_p = compiled_code_p;\n  literal_p->type = LEXER_FUNCTION_LITERAL;\n\n#if ENABLED (JERRY_ES2015)\n  parser_compiled_code_set_function_name (context_p, compiled_code_p, function_name_index, 0);\n#endif /* ENABLED (JERRY_ES2015) */\n\n  lexer_next_token (context_p);\n}", "target": 2, "idx": 10861}
{"commit_id": "58bdd544e2933a21a51eecf17c3f5f94038261b5", "project": "torvalds/linux", "func": "int nfc_llcp_send_connect(struct nfc_llcp_sock *sock)\n{\n\tstruct nfc_llcp_local *local;\n\tstruct sk_buff *skb;\n\tu8 *service_name_tlv = NULL, service_name_tlv_length;\n\tu8 *miux_tlv = NULL, miux_tlv_length;\n\tu8 *rw_tlv = NULL, rw_tlv_length, rw;\n\tint err;\n\tu16 size = 0;\n\t__be16 miux;\n\n\tpr_debug(\"Sending CONNECT\\n\");\n\n\tlocal = sock->local;\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\tif (sock->service_name != NULL) {\n\t\tservice_name_tlv = nfc_llcp_build_tlv(LLCP_TLV_SN,\n\t\t\t\t\t\t      sock->service_name,\n\t\t\t\t\t\t      sock->service_name_len,\n\t\t\t\t\t\t      &service_name_tlv_length);\n\t\tif (!service_name_tlv) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error_tlv;\n\t\t}\n\t\tsize += service_name_tlv_length;\n\t}\n\n\t/* If the socket parameters are not set, use the local ones */\n\tmiux = be16_to_cpu(sock->miux) > LLCP_MAX_MIUX ?\n\t\tlocal->miux : sock->miux;\n\trw = sock->rw > LLCP_MAX_RW ? local->rw : sock->rw;\n\n\tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,\n\t\t\t\t      &miux_tlv_length);\n\tif (!miux_tlv) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\tsize += miux_tlv_length;\n\n\trw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);\n\tif (!rw_tlv) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\tsize += rw_tlv_length;\n\n\tpr_debug(\"SKB size %d SN length %zu\\n\", size, sock->service_name_len);\n\n\tskb = llcp_allocate_pdu(sock, LLCP_PDU_CONNECT, size);\n\tif (skb == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\n\tllcp_add_tlv(skb, service_name_tlv, service_name_tlv_length);\n\tllcp_add_tlv(skb, miux_tlv, miux_tlv_length);\n\tllcp_add_tlv(skb, rw_tlv, rw_tlv_length);\n\n\tskb_queue_tail(&local->tx_queue, skb);\n\n\terr = 0;\n\nerror_tlv:\n\tif (err)\n\t\tpr_err(\"error %d\\n\", err);\n\n\tkfree(service_name_tlv);\n\tkfree(miux_tlv);\n\tkfree(rw_tlv);\n\n\treturn err;\n}", "target": 2, "idx": 10862}
{"commit_id": "6caabe7f197d3466d238f70915d65301f1716626", "project": "torvalds/linux", "func": "int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],\n\t\t     unsigned char multicast_spec, u8 protocol_version)\n{\n\tstruct hsr_priv *hsr;\n\tstruct hsr_port *port;\n\tint res;\n\n\thsr = netdev_priv(hsr_dev);\n\tINIT_LIST_HEAD(&hsr->ports);\n\tINIT_LIST_HEAD(&hsr->node_db);\n\tINIT_LIST_HEAD(&hsr->self_node_db);\n\n\tether_addr_copy(hsr_dev->dev_addr, slave[0]->dev_addr);\n\n\t/* Make sure we recognize frames from ourselves in hsr_rcv() */\n\tres = hsr_create_self_node(&hsr->self_node_db, hsr_dev->dev_addr,\n\t\t\t\t   slave[1]->dev_addr);\n\tif (res < 0)\n\t\treturn res;\n\n\tspin_lock_init(&hsr->seqnr_lock);\n\t/* Overflow soon to find bugs easier: */\n\thsr->sequence_nr = HSR_SEQNR_START;\n\thsr->sup_sequence_nr = HSR_SUP_SEQNR_START;\n\n\ttimer_setup(&hsr->announce_timer, hsr_announce, 0);\n\ttimer_setup(&hsr->prune_timer, hsr_prune_nodes, 0);\n\n\tether_addr_copy(hsr->sup_multicast_addr, def_multicast_addr);\n\thsr->sup_multicast_addr[ETH_ALEN - 1] = multicast_spec;\n\n\thsr->protVersion = protocol_version;\n\n\t/* FIXME: should I modify the value of these?\n\t *\n\t * - hsr_dev->flags - i.e.\n\t *\t\t\tIFF_MASTER/SLAVE?\n\t * - hsr_dev->priv_flags - i.e.\n\t *\t\t\tIFF_EBRIDGE?\n\t *\t\t\tIFF_TX_SKB_SHARING?\n\t *\t\t\tIFF_HSR_MASTER/SLAVE?\n\t */\n\n\t/* Make sure the 1st call to netif_carrier_on() gets through */\n\tnetif_carrier_off(hsr_dev);\n\n\tres = hsr_add_port(hsr, hsr_dev, HSR_PT_MASTER);\n\tif (res)\n\t\tgoto err_add_port;\n\n\tres = register_netdevice(hsr_dev);\n\tif (res)\n\t\tgoto fail;\n\n\tres = hsr_add_port(hsr, slave[0], HSR_PT_SLAVE_A);\n\tif (res)\n\t\tgoto fail;\n\tres = hsr_add_port(hsr, slave[1], HSR_PT_SLAVE_B);\n\tif (res)\n\t\tgoto fail;\n\n\tmod_timer(&hsr->prune_timer, jiffies + msecs_to_jiffies(PRUNE_PERIOD));\n\n\treturn 0;\n\nfail:\n\thsr_for_each_port(hsr, port)\n\t\thsr_del_port(port);\nerr_add_port:\n\thsr_del_node(&hsr->self_node_db);\n\n\treturn res;\n}", "target": 2, "idx": 10863}
