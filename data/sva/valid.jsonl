{"commit_id": "edb272e35ee57e7b89f3e127222c6981b6a1e730", "project": "wolfSSL/wolfssh", "func": "int wolfSSH_SFTP_RecvLSTAT(WOLFSSH* ssh, int reqId, byte* data, word32 maxSz)\n{\n    WS_SFTP_FILEATRB atr;\n    char* name = NULL;\n    int   ret = WS_SUCCESS;\n\n    word32 sz;\n    word32 idx = 0;\n\n    byte*  out = NULL;\n    word32 outSz = 0;\n\n    if (ssh == NULL) {\n        return WS_BAD_ARGUMENT;\n    }\n\n    WLOG(WS_LOG_SFTP, \"Receiving WOLFSSH_FTP_LSTAT\");\n\n    ato32(data + idx, &sz); idx += UINT32_SZ;\n    if (sz > maxSz - idx) {\n        return WS_BUFFER_E;\n    }\n\n    /* plus one to make sure is null terminated */\n    name = (char*)WMALLOC(sz + 1, ssh->ctx->heap, DYNTYPE_BUFFER);\n    if (name == NULL) {\n        return WS_MEMORY_E;\n    }\n    WMEMCPY(name, data + idx, sz);\n    name[sz] = '\\0';\n    if (wolfSSH_CleanPath(ssh, name) < 0) {\n        WLOG(WS_LOG_SFTP, \"Unable to clean path\");\n        if (wolfSSH_SFTP_CreateStatus(ssh, WOLFSSH_FTP_FAILURE, reqId,\n                \"LSTAT error\", \"English\", NULL, &outSz) != WS_SIZE_ONLY) {\n            WFREE(name, ssh->ctx->heap, DYNTYPE_BUFFER);\n            return WS_FATAL_ERROR;\n        }\n        ret = WS_FATAL_ERROR;\n    }\n\n    /* try to get file attributes and send back to client */\n    if (ret == WS_SUCCESS) {\n        WMEMSET((byte*)&atr, 0, sizeof(WS_SFTP_FILEATRB));\n        if ((ret = SFTP_GetAttributes(ssh->fs, name, &atr, 1, ssh->ctx->heap))\n                != WS_SUCCESS) {\n            /* tell peer that was not ok */\n            WLOG(WS_LOG_SFTP, \"Unable to get lstat of file/directory\");\n            if (wolfSSH_SFTP_CreateStatus(ssh, WOLFSSH_FTP_FAILURE, reqId,\n                    \"LSTAT error\", \"English\", NULL, &outSz) != WS_SIZE_ONLY) {\n                WFREE(name, ssh->ctx->heap, DYNTYPE_BUFFER);\n                return WS_FATAL_ERROR;\n            }\n            ret = WS_BAD_FILE_E;\n        }\n        else {\n            sz = SFTP_AtributesSz(ssh, &atr);\n            outSz = sz + WOLFSSH_SFTP_HEADER;\n        }\n    }\n    WFREE(name, ssh->ctx->heap, DYNTYPE_BUFFER);\n\n    out = (byte*)WMALLOC(outSz, ssh->ctx->heap, DYNTYPE_BUFFER);\n    if (out == NULL) {\n        return WS_MEMORY_E;\n    }\n\n    if (ret != WS_SUCCESS) {\n        if (wolfSSH_SFTP_CreateStatus(ssh, WOLFSSH_FTP_FAILURE, reqId,\n                \"LSTAT error\", \"English\", out, &outSz) != WS_SUCCESS) {\n            WFREE(out, ssh->ctx->heap, DYNTYPE_BUFFER);\n            return WS_FATAL_ERROR;\n        }\n    }\n    else {\n        if (SFTP_SetHeader(ssh, reqId, WOLFSSH_FTP_ATTRS, sz, out) != WS_SUCCESS) {\n            WFREE(out, ssh->ctx->heap, DYNTYPE_BUFFER);\n            return WS_FATAL_ERROR;\n        }\n        SFTP_SetAttributes(ssh, out + WOLFSSH_SFTP_HEADER, sz, &atr);\n    }\n\n    /* set send out buffer, \"out\" is taken by ssh  */\n    wolfSSH_SFTP_RecvSetSend(ssh, out, outSz);\n    return ret;\n}", "target": 3, "idx": 10864}
{"commit_id": "3627aaf7d289315b614a584afb388f04abfb5bbf", "project": "FreeRDP", "func": "static BOOL rdp_read_font_capability_set(wStream* s, UINT16 length, rdpSettings* settings)\n{\n\tWINPR_UNUSED(settings);\n\tif (length > 5)\n\t\tStream_Seek_UINT16(s); /* fontSupportFlags (2 bytes) */\n\n\tif (length > 7)\n\t\tStream_Seek_UINT16(s); /* pad2Octets (2 bytes) */\n\n\treturn TRUE;\n}", "target": 0, "idx": 10865}
{"commit_id": "f73da86bf32992f62b9ff2b9c9e853e3c97edf8e", "project": "gpac", "func": "GF_Err gf_bifs_dec_sf_field(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node, GF_FieldInfo *field, Bool is_mem_com)\n{\n\tGF_Err e;\n\tGF_Node *new_node;\n\tu32 size, length, w, h, i;\n\tchar *buffer;\n\n\t//blindly call unquantize. return is OK, error or GF_EOS\n\tif (codec->ActiveQP && node) {\n\t\te = gf_bifs_dec_unquant_field(codec, bs, node, field);\n\t\tif (e != GF_EOS) return e;\n\t}\n\t//not quantized, use normal scheme\n\tswitch (field->fieldType) {\n\tcase GF_SG_VRML_SFBOOL:\n\t\t* ((SFBool *) field->far_ptr) = (SFBool) gf_bs_read_int(bs, 1);\n\t\tbreak;\n\tcase GF_SG_VRML_SFCOLOR:\n\t\t((SFColor *)field->far_ptr)->red = BD_ReadSFFloat(codec, bs);\n\t\t((SFColor *)field->far_ptr)->green = BD_ReadSFFloat(codec, bs);\n\t\t((SFColor *)field->far_ptr)->blue = BD_ReadSFFloat(codec, bs);\n\t\tbreak;\n\tcase GF_SG_VRML_SFFLOAT:\n\t\t*((SFFloat *)field->far_ptr) = BD_ReadSFFloat(codec, bs);\n\t\tbreak;\n\tcase GF_SG_VRML_SFINT32:\n\t\t*((SFInt32 *)field->far_ptr) = (s32) gf_bs_read_int(bs, 32);\n\t\tbreak;\n\tcase GF_SG_VRML_SFTIME:\n\t\t*((SFTime *)field->far_ptr) = gf_bs_read_double(bs);\n\t\tif (node) BD_CheckSFTimeOffset(codec, node, field);\n\t\tbreak;\n\tcase GF_SG_VRML_SFVEC2F:\n\t\t((SFVec2f *)field->far_ptr)->x = BD_ReadSFFloat(codec, bs);\n\t\t((SFVec2f *)field->far_ptr)->y = BD_ReadSFFloat(codec, bs);\n\t\tbreak;\n\tcase GF_SG_VRML_SFVEC3F:\n\t\t((SFVec3f *)field->far_ptr)->x = BD_ReadSFFloat(codec, bs);\n\t\t((SFVec3f *)field->far_ptr)->y = BD_ReadSFFloat(codec, bs);\n\t\t((SFVec3f *)field->far_ptr)->z = BD_ReadSFFloat(codec, bs);\n\t\tbreak;\n\tcase GF_SG_VRML_SFROTATION:\n\t\t((SFRotation *)field->far_ptr)->x = BD_ReadSFFloat(codec, bs);\n\t\t((SFRotation *)field->far_ptr)->y = BD_ReadSFFloat(codec, bs);\n\t\t((SFRotation *)field->far_ptr)->z = BD_ReadSFFloat(codec, bs);\n\t\t((SFRotation *)field->far_ptr)->q = BD_ReadSFFloat(codec, bs);\n\t\tbreak;\n\tcase GF_SG_VRML_SFSTRING:\n\t\tsize = gf_bs_read_int(bs, 5);\n\t\tlength = gf_bs_read_int(bs, size);\n\t\tif (gf_bs_available(bs) < length) return GF_NON_COMPLIANT_BITSTREAM;\n\n\t\tif (node && (node->sgprivate->tag==TAG_MPEG4_CacheTexture) && (field->fieldIndex<=2)) {\n\t\t\tM_CacheTexture *ct = (M_CacheTexture *) node;\n\t\t\tct->data_len = length;\n\t\t\tif (ct->data) gf_free(ct->data);\n\t\t\tct->data = (u8*)gf_malloc(sizeof(char)*length);\n\t\t\tgf_bs_read_data(bs, (char*)ct->data, length);\n\t\t} else if (node && (node->sgprivate->tag==TAG_MPEG4_BitWrapper) ) {\n\t\t\tM_BitWrapper *bw = (M_BitWrapper*) node;\n\t\t\tif (bw->buffer.buffer) gf_free(bw->buffer.buffer);\n\t\t\tbw->buffer_len = length;\n\t\t\tbw->buffer.buffer = (char*)gf_malloc(sizeof(char)*length);\n\t\t\tgf_bs_read_data(bs, (char*)bw->buffer.buffer, length);\n\t\t} else {\n\t\t\tif ( ((SFString *)field->far_ptr)->buffer ) gf_free( ((SFString *)field->far_ptr)->buffer);\n\t\t\t((SFString *)field->far_ptr)->buffer = (char *)gf_malloc(sizeof(char)*(length+1));\n\t\t\tmemset(((SFString *)field->far_ptr)->buffer , 0, length+1);\n\t\t\tfor (i=0; i<length; i++) {\n\t\t\t\t((SFString *)field->far_ptr)->buffer[i] = gf_bs_read_int(bs, 8);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase GF_SG_VRML_SFURL:\n\t{\n\t\tSFURL *url = (SFURL *) field->far_ptr;\n\t\tsize = gf_bs_read_int(bs, 1);\n\t\tif (size) {\n\t\t\tif (url->url) gf_free(url->url );\n\t\t\turl->url = NULL;\n\t\t\tlength = gf_bs_read_int(bs, 10);\n\t\t\turl->OD_ID = length;\n\t\t} else {\n\t\t\tif ( url->OD_ID ) url->OD_ID = (u32) -1;\n\t\t\tsize = gf_bs_read_int(bs, 5);\n\t\t\tlength = gf_bs_read_int(bs, size);\n\t\t\tif (gf_bs_available(bs) < length) return GF_NON_COMPLIANT_BITSTREAM;\n\t\t\tbuffer = NULL;\n\t\t\tif (length) {\n\t\t\t\tbuffer = (char *)gf_malloc(sizeof(char)*(length+1));\n\t\t\t\tmemset(buffer, 0, length+1);\n\t\t\t\tfor (i=0; i<length; i++) buffer[i] = gf_bs_read_int(bs, 8);\n\t\t\t}\n\t\t\tif (url->url) gf_free( url->url);\n\t\t\t/*if URL is empty set it to NULL*/\n\t\t\tif (buffer && strlen(buffer)) {\n\t\t\t\turl->url = buffer;\n\t\t\t} else {\n\t\t\t\tgf_free(buffer);\n\t\t\t\turl->url = NULL;\n\t\t\t}\n\t\t}\n\t}\n\tbreak;\n\tcase GF_SG_VRML_SFIMAGE:\n\t\tif (((SFImage *)field->far_ptr)->pixels) gf_free(((SFImage *)field->far_ptr)->pixels);\n\t\tw = gf_bs_read_int(bs, 12);\n\t\th = gf_bs_read_int(bs, 12);\n\t\tlength = gf_bs_read_int(bs, 2);\n\n\t\tif (length > 3) length = 3;\n\t\tlength += 1;\n\t\tsize = w * h * length;\n\t\tif (gf_bs_available(bs) < size) return GF_NON_COMPLIANT_BITSTREAM;\n\t\t((SFImage *)field->far_ptr)->width = w;\n\t\t((SFImage *)field->far_ptr)->height = h;\n\t\t((SFImage *)field->far_ptr)->numComponents = length;\n\t\t((SFImage *)field->far_ptr)->pixels = (unsigned char *)gf_malloc(sizeof(char)*size);\n\t\t//WARNING: Buffers are NOT ALIGNED IN THE BITSTREAM\n\t\tfor (i=0; i<size; i++) {\n\t\t\t((SFImage *)field->far_ptr)->pixels[i] = gf_bs_read_int(bs, 8);\n\t\t}\n\t\tbreak;\n\tcase GF_SG_VRML_SFCOMMANDBUFFER:\n\t{\n\t\tSFCommandBuffer *sfcb = (SFCommandBuffer *)field->far_ptr;\n\t\tif (!node) return GF_BAD_PARAM;\n\t\tif (sfcb->buffer) {\n\t\t\tgf_free(sfcb->buffer);\n\t\t\tsfcb->buffer = NULL;\n\t\t}\n\t\twhile (gf_list_count(sfcb->commandList)) {\n\t\t\tGF_Command *com = (GF_Command*)gf_list_get(sfcb->commandList, 0);\n\t\t\tgf_list_rem(sfcb->commandList, 0);\n\t\t\tgf_sg_command_del(com);\n\t\t}\n\n\t\tsize = gf_bs_read_int(bs, 5);\n\t\tlength = gf_bs_read_int(bs, size);\n\t\tif (gf_bs_available(bs) < length) return GF_NON_COMPLIANT_BITSTREAM;\n\n\t\tsfcb->bufferSize = length;\n\t\tif (length) {\n\t\t\tsfcb->buffer = (unsigned char *)gf_malloc(sizeof(char)*(length));\n\t\t\t//WARNING Buffers are NOT ALIGNED IN THE BITSTREAM\n\t\t\tfor (i=0; i<length; i++) {\n\t\t\t\tsfcb->buffer[i] = gf_bs_read_int(bs, 8);\n\t\t\t}\n\t\t}\n\t\t//notify the node - this is needed in case an enhencement layer replaces the buffer, in which case\n\t\t//the # ID Bits may change\n\t\tSFCommandBufferChanged(codec, node);\n\n\t\t/*\n\t\t 1 - memory mode, register command buffer for later parsing\n\t\t 2 - InputSensor only works on decompressed commands\n\t\t*/\n\t\tif (codec->dec_memory_mode || (node->sgprivate->tag==TAG_MPEG4_InputSensor)) {\n\t\t\tCommandBufferItem *cbi = (CommandBufferItem *)gf_malloc(sizeof(CommandBufferItem));\n\t\t\tcbi->node = node;\n\t\t\tcbi->cb = sfcb;\n\t\t\tgf_list_add(codec->command_buffers, cbi);\n\t\t}\n\t}\n\tbreak;\n\tcase GF_SG_VRML_SFNODE:\n\t\t//for nodes the field ptr is a ptr to the field, which is a node ptr ;)\n\t\tnew_node = gf_bifs_dec_node(codec, bs, field->NDTtype);\n\t\tif (new_node) {\n\t\t\te = gf_node_register(new_node, is_mem_com ? NULL : node);\n\t\t\tif (e) return e;\n\t\t}\n\t\t//it may happen that new_node is NULL (this is valid for a proto declaration)\n\t\t*((GF_Node **) field->far_ptr) = new_node;\n\t\tbreak;\n\tcase GF_SG_VRML_SFSCRIPT:\n#ifdef GPAC_HAS_QJS\n\t\tcodec->LastError = node ? SFScript_Parse(codec, (SFScript*)field->far_ptr, bs, node) : GF_NON_COMPLIANT_BITSTREAM;\n#else\n\t\treturn GF_NOT_SUPPORTED;\n#endif\n\t\tbreak;\n\tcase GF_SG_VRML_SFATTRREF:\n\t{\n\t\tSFAttrRef *ar = (SFAttrRef *)field->far_ptr;\n\t\tu32 nodeID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\t\tar->node = gf_sg_find_node(codec->current_graph, nodeID);\n\t\tif (!ar->node) {\n\n\t\t} else {\n\t\t\tu32 nbBitsDEF = gf_get_bit_size(gf_node_get_num_fields_in_mode(ar->node, GF_SG_FIELD_CODING_DEF) - 1);\n\t\t\tu32 field_ref = gf_bs_read_int(bs, nbBitsDEF);\n\t\t\tcodec->LastError = gf_bifs_get_field_index(ar->node, field_ref, GF_SG_FIELD_CODING_DEF, &ar->fieldIndex);\n\t\t}\n\t}\n\tbreak;\n\tdefault:\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\treturn codec->LastError;\n}", "target": 1, "idx": 10866}
{"commit_id": "4e610ccd87a2ba9413819777d508f71163fcc237", "project": "CESNET/libyang", "func": "int\nresolve_superior_type(const char *name, const char *mod_name, const struct lys_module *module,\n                      const struct lys_node *parent, struct lys_tpdf **ret)\n{\n    int i, j;\n    struct lys_tpdf *tpdf, *match;\n    int tpdf_size;\n\n    if (!mod_name) {\n        /* no prefix, try built-in types */\n        for (i = 1; i < LY_DATA_TYPE_COUNT; i++) {\n            if (!strcmp(ly_types[i]->name, name)) {\n                if (ret) {\n                    *ret = ly_types[i];\n                }\n                return EXIT_SUCCESS;\n            }\n        }\n    } else {\n        if (!strcmp(mod_name, module->name)) {\n            /* prefix refers to the current module, ignore it */\n            mod_name = NULL;\n        }\n    }\n\n    if (!mod_name && parent) {\n        /* search in local typedefs */\n        while (parent) {\n            switch (parent->nodetype) {\n            case LYS_CONTAINER:\n                tpdf_size = ((struct lys_node_container *)parent)->tpdf_size;\n                tpdf = ((struct lys_node_container *)parent)->tpdf;\n                break;\n\n            case LYS_LIST:\n                tpdf_size = ((struct lys_node_list *)parent)->tpdf_size;\n                tpdf = ((struct lys_node_list *)parent)->tpdf;\n                break;\n\n            case LYS_GROUPING:\n                tpdf_size = ((struct lys_node_grp *)parent)->tpdf_size;\n                tpdf = ((struct lys_node_grp *)parent)->tpdf;\n                break;\n\n            case LYS_RPC:\n            case LYS_ACTION:\n                tpdf_size = ((struct lys_node_rpc_action *)parent)->tpdf_size;\n                tpdf = ((struct lys_node_rpc_action *)parent)->tpdf;\n                break;\n\n            case LYS_NOTIF:\n                tpdf_size = ((struct lys_node_notif *)parent)->tpdf_size;\n                tpdf = ((struct lys_node_notif *)parent)->tpdf;\n                break;\n\n            case LYS_INPUT:\n            case LYS_OUTPUT:\n                tpdf_size = ((struct lys_node_inout *)parent)->tpdf_size;\n                tpdf = ((struct lys_node_inout *)parent)->tpdf;\n                break;\n\n            default:\n                parent = lys_parent(parent);\n                continue;\n            }\n\n            for (i = 0; i < tpdf_size; i++) {\n                if (!strcmp(tpdf[i].name, name)) {\n                    match = &tpdf[i];\n                    goto check_typedef;\n                }\n            }\n\n            parent = lys_parent(parent);\n        }\n    } else {\n        /* get module where to search */\n        module = lyp_get_module(module, NULL, 0, mod_name, 0, 0);\n        if (!module) {\n            return -1;\n        }\n    }\n\n    /* search in top level typedefs */\n    for (i = 0; i < module->tpdf_size; i++) {\n        if (!strcmp(module->tpdf[i].name, name)) {\n            match = &module->tpdf[i];\n            goto check_typedef;\n        }\n    }\n\n    /* search in submodules */\n    for (i = 0; i < module->inc_size && module->inc[i].submodule; i++) {\n        for (j = 0; j < module->inc[i].submodule->tpdf_size; j++) {\n            if (!strcmp(module->inc[i].submodule->tpdf[j].name, name)) {\n                match = &module->inc[i].submodule->tpdf[j];\n                goto check_typedef;\n            }\n        }\n    }\n\n    return EXIT_FAILURE;\n\ncheck_typedef:\n    if (resolve_superior_type_check(&match->type)) {\n        return EXIT_FAILURE;\n    }\n\n    if (ret) {\n        *ret = match;\n    }\n    return EXIT_SUCCESS;\n}", "target": 1, "idx": 10867}
{"commit_id": "9fae8f43accef8ea65d4a8ae9cdf297c46cfe29a", "project": "pjsip/pjproject", "func": "static pj_status_t get_name(int rec_counter, const pj_uint8_t *pkt, \n\t\t\t    const pj_uint8_t *start, const pj_uint8_t *max,\n\t\t\t    pj_str_t *name)\n{\n    const pj_uint8_t *p;\n    pj_status_t status;\n\n    /* Limit the number of recursion */\n    if (rec_counter > 10) {\n\t/* Too many name recursion */\n\treturn PJLIB_UTIL_EDNSINNAMEPTR;\n    }\n\n    p = start;\n    while (*p) {\n\tif ((*p & 0xc0) == 0xc0) {\n\t    /* Compression is found! */\n\t    pj_uint16_t offset;\n\n\t    /* Get the 14bit offset */\n\t    pj_memcpy(&offset, p, 2);\n\t    offset ^= pj_htons((pj_uint16_t)(0xc0 << 8));\n\t    offset = pj_ntohs(offset);\n\n\t    /* Check that offset is valid */\n\t    if (offset >= max - pkt)\n\t\treturn PJLIB_UTIL_EDNSINNAMEPTR;\n\n\t    /* Retrieve the name from that offset. */\n\t    status = get_name(rec_counter+1, pkt, pkt + offset, max, name);\n\t    if (status != PJ_SUCCESS)\n\t\treturn status;\n\n\t    return PJ_SUCCESS;\n\t} else {\n\t    unsigned label_len = *p;\n\n\t    /* Check that label length is valid.\n\t     * Each label consists of an octet length (of size 1) followed\n\t     * by the octet of the specified length (label_len). Then it\n\t     * must be followed by either another label's octet length or\n\t     * a zero length octet (that terminates the sequence).\n\t     */\n\t    if (p+1+label_len+1 > max)\n\t\treturn PJLIB_UTIL_EDNSINNAMEPTR;\n\n\t    pj_memcpy(name->ptr + name->slen, p+1, label_len);\n\t    name->slen += label_len;\n\n\t    p += label_len + 1;\n\t    if (*p != 0) {\n\t\t*(name->ptr + name->slen) = '.';\n\t\t++name->slen;\n\t    }\n\t}\n    }\n\n    return PJ_SUCCESS;\n}", "target": 2, "idx": 10868}
{"commit_id": "ec6d9023e1f54cdccbf2e4c63cf947f1be2b1e8e", "project": "xen-project/xen", "func": "static void init_heap_pages(\n    struct page_info *pg, unsigned long nr_pages)\n{\n    unsigned long i;\n\n    /*\n     * Some pages may not go through the boot allocator (e.g reserved\n     * memory at boot but released just after --- kernel, initramfs,\n     * etc.).\n     * Update first_valid_mfn to ensure those regions are covered.\n     */\n    spin_lock(&heap_lock);\n    first_valid_mfn = min_t(unsigned long, page_to_mfn(pg), first_valid_mfn);\n    spin_unlock(&heap_lock);\n\n    for ( i = 0; i < nr_pages; i++ )\n    {\n        unsigned int nid = phys_to_nid(page_to_maddr(pg+i));\n\n        if ( unlikely(!avail[nid]) )\n        {\n            unsigned long s = page_to_mfn(pg + i);\n            unsigned long e = page_to_mfn(pg + nr_pages - 1) + 1;\n            bool_t use_tail = (nid == phys_to_nid(pfn_to_paddr(e - 1))) &&\n                              !(s & ((1UL << MAX_ORDER) - 1)) &&\n                              (find_first_set_bit(e) <= find_first_set_bit(s));\n            unsigned long n;\n\n            n = init_node_heap(nid, page_to_mfn(pg+i), nr_pages - i,\n                               &use_tail);\n            BUG_ON(i + n > nr_pages);\n            if ( n && !use_tail )\n            {\n                i += n - 1;\n                continue;\n            }\n            if ( i + n == nr_pages )\n                break;\n            nr_pages -= n;\n        }\n\n        free_heap_pages(pg + i, 0, scrub_debug);\n    }\n}", "target": 1, "idx": 10869}
{"commit_id": "a50829479f58416a013a4ccca791336af3c584c7", "project": "torvalds/linux", "func": "static void parse_hid_report_descriptor(struct gtco *device, char * report,\n\t\t\t\t\tint length)\n{\n\tstruct device *ddev = &device->intf->dev;\n\tint   x, i = 0;\n\n\t/* Tag primitive vars */\n\t__u8   prefix;\n\t__u8   size;\n\t__u8   tag;\n\t__u8   type;\n\t__u8   data   = 0;\n\t__u16  data16 = 0;\n\t__u32  data32 = 0;\n\n\t/* For parsing logic */\n\tint   inputnum = 0;\n\t__u32 usage = 0;\n\n\t/* Global Values, indexed by TAG */\n\t__u32 globalval[TAG_GLOB_MAX];\n\t__u32 oldval[TAG_GLOB_MAX];\n\n\t/* Debug stuff */\n\tchar  maintype = 'x';\n\tchar  globtype[12];\n\tint   indent = 0;\n\tchar  indentstr[10] = \"\";\n\n\n\tdev_dbg(ddev, \"======>>>>>>PARSE<<<<<<======\\n\");\n\n\t/* Walk  this report and pull out the info we need */\n\twhile (i < length) {\n\t\tprefix = report[i++];\n\n\t\t/* Determine data size and save the data in the proper variable */\n\t\tsize = (1U << PREF_SIZE(prefix)) >> 1;\n\t\tif (i + size > length) {\n\t\t\tdev_err(ddev,\n\t\t\t\t\"Not enough data (need %d, have %d)\\n\",\n\t\t\t\ti + size, length);\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (size) {\n\t\tcase 1:\n\t\t\tdata = report[i];\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdata16 = get_unaligned_le16(&report[i]);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdata32 = get_unaligned_le32(&report[i]);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Skip size of data */\n\t\ti += size;\n\n\t\t/* What we do depends on the tag type */\n\t\ttag  = PREF_TAG(prefix);\n\t\ttype = PREF_TYPE(prefix);\n\t\tswitch (type) {\n\t\tcase TYPE_MAIN:\n\t\t\tstrcpy(globtype, \"\");\n\t\t\tswitch (tag) {\n\n\t\t\tcase TAG_MAIN_INPUT:\n\t\t\t\t/*\n\t\t\t\t * The INPUT MAIN tag signifies this is\n\t\t\t\t * information from a report.  We need to\n\t\t\t\t * figure out what it is and store the\n\t\t\t\t * min/max values\n\t\t\t\t */\n\n\t\t\t\tmaintype = 'I';\n\t\t\t\tif (data == 2)\n\t\t\t\t\tstrcpy(globtype, \"Variable\");\n\t\t\t\telse if (data == 3)\n\t\t\t\t\tstrcpy(globtype, \"Var|Const\");\n\n\t\t\t\tdev_dbg(ddev, \"::::: Saving Report: %d input #%d Max: 0x%X(%d) Min:0x%X(%d) of %d bits\\n\",\n\t\t\t\t\tglobalval[TAG_GLOB_REPORT_ID], inputnum,\n\t\t\t\t\tglobalval[TAG_GLOB_LOG_MAX], globalval[TAG_GLOB_LOG_MAX],\n\t\t\t\t\tglobalval[TAG_GLOB_LOG_MIN], globalval[TAG_GLOB_LOG_MIN],\n\t\t\t\t\tglobalval[TAG_GLOB_REPORT_SZ] * globalval[TAG_GLOB_REPORT_CNT]);\n\n\n\t\t\t\t/*\n\t\t\t\t  We can assume that the first two input items\n\t\t\t\t  are always the X and Y coordinates.  After\n\t\t\t\t  that, we look for everything else by\n\t\t\t\t  local usage value\n\t\t\t\t */\n\t\t\t\tswitch (inputnum) {\n\t\t\t\tcase 0:  /* X coord */\n\t\t\t\t\tdev_dbg(ddev, \"GER: X Usage: 0x%x\\n\", usage);\n\t\t\t\t\tif (device->max_X == 0) {\n\t\t\t\t\t\tdevice->max_X = globalval[TAG_GLOB_LOG_MAX];\n\t\t\t\t\t\tdevice->min_X = globalval[TAG_GLOB_LOG_MIN];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:  /* Y coord */\n\t\t\t\t\tdev_dbg(ddev, \"GER: Y Usage: 0x%x\\n\", usage);\n\t\t\t\t\tif (device->max_Y == 0) {\n\t\t\t\t\t\tdevice->max_Y = globalval[TAG_GLOB_LOG_MAX];\n\t\t\t\t\t\tdevice->min_Y = globalval[TAG_GLOB_LOG_MIN];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t/* Tilt X */\n\t\t\t\t\tif (usage == DIGITIZER_USAGE_TILT_X) {\n\t\t\t\t\t\tif (device->maxtilt_X == 0) {\n\t\t\t\t\t\t\tdevice->maxtilt_X = globalval[TAG_GLOB_LOG_MAX];\n\t\t\t\t\t\t\tdevice->mintilt_X = globalval[TAG_GLOB_LOG_MIN];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Tilt Y */\n\t\t\t\t\tif (usage == DIGITIZER_USAGE_TILT_Y) {\n\t\t\t\t\t\tif (device->maxtilt_Y == 0) {\n\t\t\t\t\t\t\tdevice->maxtilt_Y = globalval[TAG_GLOB_LOG_MAX];\n\t\t\t\t\t\t\tdevice->mintilt_Y = globalval[TAG_GLOB_LOG_MIN];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Pressure */\n\t\t\t\t\tif (usage == DIGITIZER_USAGE_TIP_PRESSURE) {\n\t\t\t\t\t\tif (device->maxpressure == 0) {\n\t\t\t\t\t\t\tdevice->maxpressure = globalval[TAG_GLOB_LOG_MAX];\n\t\t\t\t\t\t\tdevice->minpressure = globalval[TAG_GLOB_LOG_MIN];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tinputnum++;\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_MAIN_OUTPUT:\n\t\t\t\tmaintype = 'O';\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_MAIN_FEATURE:\n\t\t\t\tmaintype = 'F';\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_MAIN_COL_START:\n\t\t\t\tmaintype = 'S';\n\n\t\t\t\tif (data == 0) {\n\t\t\t\t\tdev_dbg(ddev, \"======>>>>>> Physical\\n\");\n\t\t\t\t\tstrcpy(globtype, \"Physical\");\n\t\t\t\t} else\n\t\t\t\t\tdev_dbg(ddev, \"======>>>>>>\\n\");\n\n\t\t\t\t/* Indent the debug output */\n\t\t\t\tindent++;\n\t\t\t\tfor (x = 0; x < indent; x++)\n\t\t\t\t\tindentstr[x] = '-';\n\t\t\t\tindentstr[x] = 0;\n\n\t\t\t\t/* Save global tags */\n\t\t\t\tfor (x = 0; x < TAG_GLOB_MAX; x++)\n\t\t\t\t\toldval[x] = globalval[x];\n\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_MAIN_COL_END:\n\t\t\t\tdev_dbg(ddev, \"<<<<<<======\\n\");\n\t\t\t\tmaintype = 'E';\n\t\t\t\tindent--;\n\t\t\t\tfor (x = 0; x < indent; x++)\n\t\t\t\t\tindentstr[x] = '-';\n\t\t\t\tindentstr[x] = 0;\n\n\t\t\t\t/* Copy global tags back */\n\t\t\t\tfor (x = 0; x < TAG_GLOB_MAX; x++)\n\t\t\t\t\tglobalval[x] = oldval[x];\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (size) {\n\t\t\tcase 1:\n\t\t\t\tdev_dbg(ddev, \"%sMAINTAG:(%d) %c SIZE: %d Data: %s 0x%x\\n\",\n\t\t\t\t\tindentstr, tag, maintype, size, globtype, data);\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tdev_dbg(ddev, \"%sMAINTAG:(%d) %c SIZE: %d Data: %s 0x%x\\n\",\n\t\t\t\t\tindentstr, tag, maintype, size, globtype, data16);\n\t\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\t\tdev_dbg(ddev, \"%sMAINTAG:(%d) %c SIZE: %d Data: %s 0x%x\\n\",\n\t\t\t\t\tindentstr, tag, maintype, size, globtype, data32);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TYPE_GLOBAL:\n\t\t\tswitch (tag) {\n\t\t\tcase TAG_GLOB_USAGE:\n\t\t\t\t/*\n\t\t\t\t * First time we hit the global usage tag,\n\t\t\t\t * it should tell us the type of device\n\t\t\t\t */\n\t\t\t\tif (device->usage == 0)\n\t\t\t\t\tdevice->usage = data;\n\n\t\t\t\tstrcpy(globtype, \"USAGE\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_LOG_MIN:\n\t\t\t\tstrcpy(globtype, \"LOG_MIN\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_LOG_MAX:\n\t\t\t\tstrcpy(globtype, \"LOG_MAX\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_PHYS_MIN:\n\t\t\t\tstrcpy(globtype, \"PHYS_MIN\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_PHYS_MAX:\n\t\t\t\tstrcpy(globtype, \"PHYS_MAX\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_UNIT_EXP:\n\t\t\t\tstrcpy(globtype, \"EXP\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_UNIT:\n\t\t\t\tstrcpy(globtype, \"UNIT\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_REPORT_SZ:\n\t\t\t\tstrcpy(globtype, \"REPORT_SZ\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_REPORT_ID:\n\t\t\t\tstrcpy(globtype, \"REPORT_ID\");\n\t\t\t\t/* New report, restart numbering */\n\t\t\t\tinputnum = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_REPORT_CNT:\n\t\t\t\tstrcpy(globtype, \"REPORT_CNT\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_PUSH:\n\t\t\t\tstrcpy(globtype, \"PUSH\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_POP:\n\t\t\t\tstrcpy(globtype, \"POP\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Check to make sure we have a good tag number\n\t\t\t   so we don't overflow array */\n\t\t\tif (tag < TAG_GLOB_MAX) {\n\t\t\t\tswitch (size) {\n\t\t\t\tcase 1:\n\t\t\t\t\tdev_dbg(ddev, \"%sGLOBALTAG:%s(%d) SIZE: %d Data: 0x%x\\n\",\n\t\t\t\t\t\tindentstr, globtype, tag, size, data);\n\t\t\t\t\tglobalval[tag] = data;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\t\tdev_dbg(ddev, \"%sGLOBALTAG:%s(%d) SIZE: %d Data: 0x%x\\n\",\n\t\t\t\t\t\tindentstr, globtype, tag, size, data16);\n\t\t\t\t\tglobalval[tag] = data16;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 4:\n\t\t\t\t\tdev_dbg(ddev, \"%sGLOBALTAG:%s(%d) SIZE: %d Data: 0x%x\\n\",\n\t\t\t\t\t\tindentstr, globtype, tag, size, data32);\n\t\t\t\t\tglobalval[tag] = data32;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdev_dbg(ddev, \"%sGLOBALTAG: ILLEGAL TAG:%d SIZE: %d\\n\",\n\t\t\t\t\tindentstr, tag, size);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TYPE_LOCAL:\n\t\t\tswitch (tag) {\n\t\t\tcase TAG_GLOB_USAGE:\n\t\t\t\tstrcpy(globtype, \"USAGE\");\n\t\t\t\t/* Always 1 byte */\n\t\t\t\tusage = data;\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_LOG_MIN:\n\t\t\t\tstrcpy(globtype, \"MIN\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_LOG_MAX:\n\t\t\t\tstrcpy(globtype, \"MAX\");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tstrcpy(globtype, \"UNKNOWN\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (size) {\n\t\t\tcase 1:\n\t\t\t\tdev_dbg(ddev, \"%sLOCALTAG:(%d) %s SIZE: %d Data: 0x%x\\n\",\n\t\t\t\t\tindentstr, tag, globtype, size, data);\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tdev_dbg(ddev, \"%sLOCALTAG:(%d) %s SIZE: %d Data: 0x%x\\n\",\n\t\t\t\t\tindentstr, tag, globtype, size, data16);\n\t\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\t\tdev_dbg(ddev, \"%sLOCALTAG:(%d) %s SIZE: %d Data: 0x%x\\n\",\n\t\t\t\t\tindentstr, tag, globtype, size, data32);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t}\n}", "target": 1, "idx": 10870}
{"commit_id": "b57b3967b1a42dd505dbe4fcf1e1d810e3ae3777", "project": "android", "func": "bool SampleTable::isValid() const {\n    return mChunkOffsetOffset >= 0\n        && mSampleToChunkOffset >= 0\n        && mSampleSizeOffset >= 0\n        && mHasTimeToSample;\n}", "target": 1, "idx": 10871}
{"commit_id": "afc39bea36fd436e54262f150c009e8d72db5014", "project": "envoyproxy/envoy", "func": "absl::optional<CelValue> RequestWrapper::operator[](CelValue key) const {\n  if (!key.IsString()) {\n    return {};\n  }\n  auto value = key.StringOrDie().value();\n\n  if (value == Headers) {\n    return CelValue::CreateMap(&headers_);\n  } else if (value == Time) {\n    return CelValue::CreateTimestamp(absl::FromChrono(info_.startTime()));\n  } else if (value == Size) {\n    // it is important to make a choice whether to rely on content-length vs stream info\n    // (which is not available at the time of the request headers)\n    if (headers_.value_ != nullptr && headers_.value_->ContentLength() != nullptr) {\n      int64_t length;\n      if (absl::SimpleAtoi(headers_.value_->ContentLength()->value().getStringView(), &length)) {\n        return CelValue::CreateInt64(length);\n      }\n    } else {\n      return CelValue::CreateInt64(info_.bytesReceived());\n    }\n  } else if (value == Duration) {\n    auto duration = info_.requestComplete();\n    if (duration.has_value()) {\n      return CelValue::CreateDuration(absl::FromChrono(duration.value()));\n    }\n  }\n\n  if (headers_.value_ != nullptr) {\n    if (value == Path) {\n      return convertHeaderEntry(headers_.value_->Path());\n    } else if (value == UrlPath) {\n      absl::string_view path = headers_.value_->Path()->value().getStringView();\n      size_t query_offset = path.find('?');\n      if (query_offset == absl::string_view::npos) {\n        return CelValue::CreateString(path);\n      }\n      return CelValue::CreateString(path.substr(0, query_offset));\n    } else if (value == Host) {\n      return convertHeaderEntry(headers_.value_->Host());\n    } else if (value == Scheme) {\n      return convertHeaderEntry(headers_.value_->Scheme());\n    } else if (value == Method) {\n      return convertHeaderEntry(headers_.value_->Method());\n    } else if (value == Referer) {\n      return convertHeaderEntry(headers_.value_->Referer());\n    } else if (value == ID) {\n      return convertHeaderEntry(headers_.value_->RequestId());\n    } else if (value == UserAgent) {\n      return convertHeaderEntry(headers_.value_->UserAgent());\n    } else if (value == TotalSize) {\n      return CelValue::CreateInt64(info_.bytesReceived() + headers_.value_->byteSize().value());\n    }\n  }\n  return {};\n}", "target": 2, "idx": 10872}
{"commit_id": "cf60095a4d8c3cb2e182a14415467afd356e982f", "project": "moby/hyperkit", "func": "static void\npci_vtblk_proc(struct pci_vtblk_softc *sc, struct vqueue_info *vq)\n{\n\tstruct virtio_blk_hdr *vbh;\n\tstruct virtio_blk_discard_write_zeroes *vbdiscard;\n\tstruct pci_vtblk_ioreq *io;\n\tint i, n;\n\tint err;\n\tssize_t iolen;\n\tint expectro, type;\n\tstruct iovec iov[BLOCKIF_IOV_MAX + 2];\n\tuint16_t idx, flags[BLOCKIF_IOV_MAX + 2];\n\n\tn = vq_getchain(vq, &idx, iov, BLOCKIF_IOV_MAX + 2, flags);\n\n\t/*\n\t * The first descriptor will be the read-only fixed header,\n\t * and the last is for status (hence +2 above and below).\n\t * The remaining iov's are the actual data I/O vectors.\n\t *\n\t * XXX - note - this fails on crash dump, which does a\n\t * VIRTIO_BLK_T_FLUSH with a zero transfer length\n\t */\n\tassert(n >= 2 && n <= BLOCKIF_IOV_MAX + 2);\n\n\tio = &sc->vbsc_ios[idx];\n\tassert((flags[0] & VRING_DESC_F_WRITE) == 0);\n\tassert(iov[0].iov_len == sizeof(struct virtio_blk_hdr));\n\tvbh = iov[0].iov_base;\n\tmemcpy(&io->io_req.br_iov, &iov[1],\n\t       sizeof(struct iovec) * ((size_t)n - 2));\n\tio->io_req.br_iovcnt = n - 2;\n\tio->io_req.br_offset = (off_t)(vbh->vbh_sector * DEV_BSIZE);\n\tio->io_status = iov[--n].iov_base;\n\tassert(iov[n].iov_len == 1);\n\tassert(flags[n] & VRING_DESC_F_WRITE);\n\n\t/*\n\t * XXX\n\t * The guest should not be setting the BARRIER flag because\n\t * we don't advertise the capability.\n\t */\n\ttype = vbh->vbh_type & ~VBH_FLAG_BARRIER;\n\texpectro = (type == VBH_OP_WRITE) || (type == VBH_OP_DISCARD);\n\tiolen = 0;\n\tfor (i = 1; i < n; i++) {\n\t\t/*\n\t\t * - write/discard op implies read-only descriptor,\n\t\t * - read/ident op implies write-only descriptor,\n\t\t * therefore test the inverse of the descriptor bit\n\t\t * to the op.\n\t\t */\n\t\tassert(((flags[i] & VRING_DESC_F_WRITE) == 0) == expectro);\n\t\tiolen += iov[i].iov_len;\n\t}\n\tio->io_req.br_resid = iolen;\n\n\tDPRINTF((\"virtio-block: %s op, %zd bytes, %d segs\\n\\r\",\n\t\t print_vbh_op(type), iolen, i - 1));\n\n\tswitch (type) {\n\tcase VBH_OP_READ:\n\t\terr = blockif_read(sc->bc, &io->io_req);\n\t\tbreak;\n\tcase VBH_OP_WRITE:\n\t\terr = blockif_write(sc->bc, &io->io_req);\n\t\tbreak;\n\tcase VBH_OP_DISCARD:\n\t\t/* We currently limit the discard to one segment in the initial negotiation\n\t\t   so expect exactly one correctly-sized payload descriptor. */\n\t\tassert(iov[1].iov_len == sizeof(struct virtio_blk_discard_write_zeroes));\n\t\tassert(n == 2);\n\t\tvbdiscard = iov[1].iov_base;\n\t\tio->io_req.br_offset = (off_t) vbdiscard->sector * DEV_BSIZE;\n\t\tio->io_req.br_resid = vbdiscard->num_sectors * DEV_BSIZE;\n\t\terr = blockif_delete(sc->bc, &io->io_req);\n\t\tbreak;\n\tcase VBH_OP_FLUSH:\n\tcase VBH_OP_FLUSH_OUT:\n\t\terr = blockif_flush(sc->bc, &io->io_req);\n\t\tbreak;\n\tcase VBH_OP_IDENT:\n\t\t/* Assume a single buffer */\n\t\t/* S/n equal to buffer is not zero-terminated. */\n\t\tmemset(iov[1].iov_base, 0, iov[1].iov_len);\n\t\tstrncpy(iov[1].iov_base, sc->vbsc_ident,\n\t\t    MIN(iov[1].iov_len, sizeof(sc->vbsc_ident)));\n\t\t/* xhyve: FIXME */\n\t\tpci_vtblk_done_locked(&io->io_req, 0);\n\t\treturn;\n\tdefault:\n\t\t/* xhyve: FIXME */\n\t\tpci_vtblk_done_locked(&io->io_req, EOPNOTSUPP);\n\t\treturn;\n\t}\n\tassert(err == 0);\n}", "target": 2, "idx": 10873}
{"commit_id": "611d80db29dd7b0cfb755772c69d60ae5bca05f9", "project": "tensorflow", "func": "void Compute(OpKernelContext* context) override {\n    // Input tensor is of the following dimensions:\n    // [ batch, in_rows, in_cols, in_depth ]\n    const Tensor& input = context->input(0);\n\n    // Input filter is of the following dimensions:\n    // [ filter_rows, filter_cols, in_depth, out_depth]\n    const Tensor& filter = context->input(1);\n\n    Conv2DDimensions dimensions;\n    OP_REQUIRES_OK(context,\n                   ComputeConv2DDimension(params_, input, filter, &dimensions));\n\n    TensorShape out_shape = ShapeFromFormat(\n        params_.data_format, dimensions.batch, dimensions.out_rows,\n        dimensions.out_cols, dimensions.out_depth);\n\n    // Output tensor is of the following dimensions:\n    // [ in_batch, out_rows, out_cols, out_depth ]\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, out_shape, &output));\n\n    VLOG(2) << \"Conv2D: in_depth = \" << dimensions.in_depth\n            << \", patch_depth = \" << dimensions.patch_depth\n            << \", input_cols = \" << dimensions.input_cols\n            << \", filter_cols = \" << dimensions.filter_cols\n            << \", input_rows = \" << dimensions.input_rows\n            << \", filter_rows = \" << dimensions.filter_rows\n            << \", stride_rows = \" << dimensions.stride_rows\n            << \", stride_cols = \" << dimensions.stride_cols\n            << \", dilation_rows = \" << dimensions.dilation_rows\n            << \", dilation_cols = \" << dimensions.dilation_cols\n            << \", out_depth = \" << dimensions.out_depth;\n\n    // If there is nothing to compute, return.\n    if (out_shape.num_elements() == 0) {\n      return;\n    }\n\n    // If the input is empty, result can only be due to padding.\n    if (input.NumElements() == 0) {\n      // Zero-out output and return.\n      functor::SetZeroFunctor<Device, T>()(context->eigen_device<Device>(),\n                                           output->template flat<T>());\n\n      return;\n    }\n\n#ifdef TENSORFLOW_USE_LIBXSMM_CONVOLUTIONS\n    if (params_.padding != EXPLICIT &&\n        LaunchXsmmConvOp<Device, T>::Run(\n            context, input, filter, dimensions.batch, dimensions.input_rows,\n            dimensions.input_cols, dimensions.in_depth, dimensions.filter_rows,\n            dimensions.filter_cols, dimensions.pad_rows_before,\n            dimensions.pad_cols_before, dimensions.out_rows,\n            dimensions.out_cols, dimensions.out_depth, dimensions.dilation_rows,\n            dimensions.dilation_cols, dimensions.stride_rows,\n            dimensions.stride_cols, output, params_.data_format)) {\n      return;\n    }\n#endif\n\n    if (params_.padding != EXPLICIT &&\n        LaunchDeepConvOp<Device, T>::Run(\n            context, input, filter, dimensions.batch, dimensions.input_rows,\n            dimensions.input_cols, dimensions.in_depth, dimensions.filter_rows,\n            dimensions.filter_cols, dimensions.pad_rows_before,\n            dimensions.pad_cols_before, dimensions.out_rows,\n            dimensions.out_cols, dimensions.out_depth, dimensions.dilation_rows,\n            dimensions.dilation_cols, dimensions.stride_rows,\n            dimensions.stride_cols, output, params_.data_format)) {\n      return;\n    }\n\n    launcher_(context, use_cudnn_, cudnn_use_autotune_, input, filter,\n              dimensions.dilation_rows, dimensions.dilation_cols,\n              dimensions.stride_rows, dimensions.stride_cols, params_.padding,\n              params_.explicit_paddings, output, params_.data_format);\n  }", "target": 1, "idx": 10874}
{"commit_id": "8b06f835e259652b0ff026898014fc7297ade858", "project": "LibVNC/libvncserver", "func": "rfbBool ConnectToRFBRepeater(rfbClient* client,const char *repeaterHost, int repeaterPort, const char *destHost, int destPort)\n{\n  rfbProtocolVersionMsg pv;\n  int major,minor;\n  char tmphost[250];\n  int tmphostlen;\n\n#ifdef LIBVNCSERVER_IPv6\n  client->sock = ConnectClientToTcpAddr6(repeaterHost, repeaterPort);\n  if (client->sock == -1)\n#endif\n  {\n    unsigned int host;\n    if (!StringToIPAddr(repeaterHost, &host)) {\n      rfbClientLog(\"Couldn't convert '%s' to host address\\n\", repeaterHost);\n      return FALSE;\n    }\n\n    client->sock = ConnectClientToTcpAddr(host, repeaterPort);\n  }\n\n  if (client->sock < 0) {\n    rfbClientLog(\"Unable to connect to VNC repeater\\n\");\n    return FALSE;\n  }\n\n  if (!SetNonBlocking(client->sock))\n    return FALSE;\n\n  if (!ReadFromRFBServer(client, pv, sz_rfbProtocolVersionMsg))\n    return FALSE;\n  pv[sz_rfbProtocolVersionMsg] = 0;\n\n  /* UltraVNC repeater always report version 000.000 to identify itself */\n  if (sscanf(pv,rfbProtocolVersionFormat,&major,&minor) != 2 || major != 0 || minor != 0) {\n    rfbClientLog(\"Not a valid VNC repeater (%s)\\n\",pv);\n    return FALSE;\n  }\n\n  rfbClientLog(\"Connected to VNC repeater, using protocol version %d.%d\\n\", major, minor);\n\n  tmphostlen = snprintf(tmphost, sizeof(tmphost), \"%s:%d\", destHost, destPort);\n  if(tmphostlen < 0 || tmphostlen >= (int)sizeof(tmphost))\n    return FALSE; /* snprintf error or output truncated */\n\n  if (!WriteToRFBServer(client, tmphost, tmphostlen + 1))\n    return FALSE;\n\n  return TRUE;\n}", "target": 2, "idx": 10875}
{"commit_id": "a40aa8e6387c9a7ee8013dd968298c26728c4966", "project": "tats/w3m", "func": "Str\ncheckType(Str s, Lineprop **oprop, Linecolor **ocolor)\n{\n    Lineprop mode;\n    Lineprop effect = PE_NORMAL;\n    Lineprop *prop;\n    static Lineprop *prop_buffer = NULL;\n    static int prop_size = 0;\n    char *str = s->ptr, *endp = &s->ptr[s->length], *bs = NULL;\n#ifdef USE_ANSI_COLOR\n    Lineprop ceffect = PE_NORMAL;\n    Linecolor cmode = 0;\n    int check_color = FALSE;\n    Linecolor *color = NULL;\n    static Linecolor *color_buffer = NULL;\n    static int color_size = 0;\n    char *es = NULL;\n#endif\n    int do_copy = FALSE;\n#ifdef USE_M17N\n    int i;\n    int plen = 0, clen;\n    int *plens = NULL;\n    static int *plens_buffer = NULL;\n    static int plens_size = 0;\n#endif\n\n    if (prop_size < s->length) {\n\tprop_size = (s->length > LINELEN) ? s->length : LINELEN;\n\tprop_buffer = New_Reuse(Lineprop, prop_buffer, prop_size);\n    }\n    prop = prop_buffer;\n#ifdef USE_M17N\n    if (plens_size < s->length) {\n\tplens_size = (s->length > LINELEN) ? s->length : LINELEN;\n\tplens_buffer = New_Reuse(int, plens_buffer, plens_size);\n    }\n    plens = plens_buffer;\n#endif\n\n    if (ShowEffect) {\n\tbs = memchr(str, '\\b', s->length);\n#ifdef USE_ANSI_COLOR\n\tif (ocolor) {\n\t    es = memchr(str, ESC_CODE, s->length);\n\t    if (es) {\n\t\tif (color_size < s->length) {\n\t\t    color_size = (s->length > LINELEN) ? s->length : LINELEN;\n\t\t    color_buffer = New_Reuse(Linecolor, color_buffer,\n\t\t\t\t\t     color_size);\n\t\t}\n\t\tcolor = color_buffer;\n\t    }\n\t}\n#endif\n\tif ((bs != NULL)\n#ifdef USE_ANSI_COLOR\n\t    || (es != NULL)\n#endif\n\t    ) {\n\t    char *sp = str, *ep;\n\t    s = Strnew_size(s->length);\n\t    do_copy = TRUE;\n\t    ep = bs ? (bs - 2) : endp;\n#ifdef USE_ANSI_COLOR\n\t    if (es && ep > es - 2)\n\t\tep = es - 2;\n#endif\n\t    for (; str < ep && IS_ASCII(*str); str++) {\n\t\t*(prop++) = PE_NORMAL | (IS_CNTRL(*str) ? PC_CTRL : PC_ASCII);\n#ifdef USE_ANSI_COLOR\n\t\tif (color)\n\t\t    *(color++) = 0;\n#endif\n#ifdef USE_M17N\n\t\t*(plens++) = plen = 1;\n#endif\n\t    }\n\t    Strcat_charp_n(s, sp, (int)(str - sp));\n\t}\n    }\n    if (!do_copy) {\n\tfor (; str < endp && IS_ASCII(*str); str++) {\n\t    *(prop++) = PE_NORMAL | (IS_CNTRL(*str) ? PC_CTRL : PC_ASCII);\n#ifdef USE_M17N\n\t    *(plens++) = plen = 1;\n#endif\n\t}\n    }\n\n    while (str < endp) {\n\tif (prop - prop_buffer >= prop_size)\n\t    break;\n\tif (bs != NULL) {\n#ifdef USE_M17N\n\t    if (str == bs - 2 && !strncmp(str, \"__\\b\\b\", 4)) {\n\t\tstr += 4;\n\t\teffect = PE_UNDER;\n\t\tif (str < endp)\n\t\t    bs = memchr(str, '\\b', endp - str);\n\t\tcontinue;\n\t    }\n\t    else\n#endif\n\t    if (str == bs - 1 && *str == '_') {\n\t\tstr += 2;\n\t\teffect = PE_UNDER;\n\t\tif (str < endp)\n\t\t    bs = memchr(str, '\\b', endp - str);\n\t\tcontinue;\n\t    }\n\t    else if (str == bs) {\n\t\tif (*(str + 1) == '_') {\n\t\t    if (s->length) {\n\t\t\tstr += 2;\n#ifdef USE_M17N\n\t\t\tfor (i = 1; i <= plen; i++)\n\t\t\t    *(prop - i) |= PE_UNDER;\n#else\n\t\t\t*(prop - 1) |= PE_UNDER;\n#endif\n\t\t    }\n\t\t    else {\n\t\t\tstr++;\n\t\t    }\n\t\t}\n#ifdef USE_M17N\n\t\telse if (!strncmp(str + 1, \"\\b__\", 3)) {\n\t\t    if (s->length) {\n\t\t\tstr += (plen == 1) ? 3 : 4;\n\t\t\tfor (i = 1; i <= plen; i++)\n\t\t\t    *(prop - i) |= PE_UNDER;\n\t\t    }\n\t\t    else {\n\t\t\tstr += 2;\n\t\t    }\n\t\t}\n\t\telse if (*(str + 1) == '\\b') {\n\t\t    if (s->length) {\n\t\t\tclen = get_mclen(str + 2);\n\t\t\tif (plen == clen &&\n\t\t\t    !strncmp(str - plen, str + 2, plen)) {\n\t\t\t    for (i = 1; i <= plen; i++)\n\t\t\t\t*(prop - i) |= PE_BOLD;\n\t\t\t    str += 2 + clen;\n\t\t\t}\n\t\t\telse {\n\t\t\t    Strshrink(s, plen);\n\t\t\t    prop -= plen;\n\t\t\t    plen = *(--plens);\n\t\t\t    str += 2;\n\t\t\t}\n\t\t    }\n\t\t    else {\n\t\t\tstr += 2;\n\t\t    }\n\t\t}\n#endif\n\t\telse {\n\t\t    if (s->length) {\n#ifdef USE_M17N\n\t\t\tclen = get_mclen(str + 1);\n\t\t\tif (plen == clen &&\n\t\t\t    !strncmp(str - plen, str + 1, plen)) {\n\t\t\t    for (i = 1; i <= plen; i++)\n\t\t\t\t*(prop - i) |= PE_BOLD;\n\t\t\t    str += 1 + clen;\n\t\t\t}\n\t\t\telse {\n\t\t\t    Strshrink(s, plen);\n\t\t\t    prop -= plen;\n\t\t\t    plen = *(--plens);\n\t\t\t    str++;\n\t\t\t}\n#else\n\t\t\tif (*(str - 1) == *(str + 1)) {\n\t\t\t    *(prop - 1) |= PE_BOLD;\n\t\t\t    str += 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t    Strshrink(s, 1);\n\t\t\t    prop--;\n\t\t\t    str++;\n\t\t\t}\n#endif\n\t\t    }\n\t\t    else {\n\t\t\tstr++;\n\t\t    }\n\t\t}\n\t\tif (str < endp)\n\t\t    bs = memchr(str, '\\b', endp - str);\n\t\tcontinue;\n\t    }\n#ifdef USE_ANSI_COLOR\n\t    else if (str > bs)\n\t\tbs = memchr(str, '\\b', endp - str);\n#endif\n\t}\n#ifdef USE_ANSI_COLOR\n\tif (es != NULL) {\n\t    if (str == es) {\n\t\tint ok = parse_ansi_color(&str, &ceffect, &cmode);\n\t\tif (str < endp)\n\t\t    es = memchr(str, ESC_CODE, endp - str);\n\t\tif (ok) {\n\t\t    if (cmode)\n\t\t\tcheck_color = TRUE;\n\t\t    continue;\n\t\t}\n\t    }\n\t    else if (str > es)\n\t\tes = memchr(str, ESC_CODE, endp - str);\n\t}\n#endif\n\n\tmode = get_mctype(str) | effect;\n#ifdef USE_ANSI_COLOR\n\tif (color) {\n\t    *(color++) = cmode;\n\t    mode |= ceffect;\n\t}\n#endif\n\t*(prop++) = mode;\n#ifdef USE_M17N\n\tplen = get_mclen(str);\n\t*(plens++) = plen;\n\tif (plen > 1) {\n\t    mode = (mode & ~PC_WCHAR1) | PC_WCHAR2;\n\t    for (i = 1; i < plen; i++) {\n\t\t*(prop++) = mode;\n#ifdef USE_ANSI_COLOR\n\t\tif (color)\n\t\t    *(color++) = cmode;\n#endif\n\t    }\n\t    if (do_copy)\n\t\tStrcat_charp_n(s, (char *)str, plen);\n\t    str += plen;\n\t}\n\telse\n#endif\n\t{\n\t    if (do_copy)\n\t\tStrcat_char(s, (char)*str);\n\t    str++;\n\t}\n\teffect = PE_NORMAL;\n    }\n    *oprop = prop_buffer;\n#ifdef USE_ANSI_COLOR\n    if (ocolor)\n\t*ocolor = check_color ? color_buffer : NULL;\n#endif\n    return s;\n}", "target": 2, "idx": 10876}
{"commit_id": "5460617d1567657621107d895ee2dd83bc1f88f2", "project": "glibc", "func": "char *\n__realpath (const char *name, char *resolved)\n{\n  char *rpath, *dest, *extra_buf = NULL;\n  const char *start, *end, *rpath_limit;\n  long int path_max;\n  int num_links = 0;\n\n  if (name == NULL)\n    {\n      /* As per Single Unix Specification V2 we must return an error if\n\t either parameter is a null pointer.  We extend this to allow\n\t the RESOLVED parameter to be NULL in case the we are expected to\n\t allocate the room for the return value.  */\n      __set_errno (EINVAL);\n      return NULL;\n    }\n\n  if (name[0] == '\\0')\n    {\n      /* As per Single Unix Specification V2 we must return an error if\n\t the name argument points to an empty string.  */\n      __set_errno (ENOENT);\n      return NULL;\n    }\n\n#ifdef PATH_MAX\n  path_max = PATH_MAX;\n#else\n  path_max = __pathconf (name, _PC_PATH_MAX);\n  if (path_max <= 0)\n    path_max = 1024;\n#endif\n\n  if (resolved == NULL)\n    {\n      rpath = malloc (path_max);\n      if (rpath == NULL)\n\treturn NULL;\n    }\n  else\n    rpath = resolved;\n  rpath_limit = rpath + path_max;\n\n  if (name[0] != '/')\n    {\n      if (!__getcwd (rpath, path_max))\n\t{\n\t  rpath[0] = '\\0';\n\t  goto error;\n\t}\n      dest = __rawmemchr (rpath, '\\0');\n    }\n  else\n    {\n      rpath[0] = '/';\n      dest = rpath + 1;\n    }\n\n  for (start = end = name; *start; start = end)\n    {\n      struct stat64 st;\n      int n;\n\n      /* Skip sequence of multiple path-separators.  */\n      while (*start == '/')\n\t++start;\n\n      /* Find end of path component.  */\n      for (end = start; *end && *end != '/'; ++end)\n\t/* Nothing.  */;\n\n      if (end - start == 0)\n\tbreak;\n      else if (end - start == 1 && start[0] == '.')\n\t/* nothing */;\n      else if (end - start == 2 && start[0] == '.' && start[1] == '.')\n\t{\n\t  /* Back up to previous component, ignore if at root already.  */\n\t  if (dest > rpath + 1)\n\t    while ((--dest)[-1] != '/');\n\t}\n      else\n\t{\n\t  size_t new_size;\n\n\t  if (dest[-1] != '/')\n\t    *dest++ = '/';\n\n\t  if (dest + (end - start) >= rpath_limit)\n\t    {\n\t      ptrdiff_t dest_offset = dest - rpath;\n\t      char *new_rpath;\n\n\t      if (resolved)\n\t\t{\n\t\t  __set_errno (ENAMETOOLONG);\n\t\t  if (dest > rpath + 1)\n\t\t    dest--;\n\t\t  *dest = '\\0';\n\t\t  goto error;\n\t\t}\n\t      new_size = rpath_limit - rpath;\n\t      if (end - start + 1 > path_max)\n\t\tnew_size += end - start + 1;\n\t      else\n\t\tnew_size += path_max;\n\t      new_rpath = (char *) realloc (rpath, new_size);\n\t      if (new_rpath == NULL)\n\t\tgoto error;\n\t      rpath = new_rpath;\n\t      rpath_limit = rpath + new_size;\n\n\t      dest = rpath + dest_offset;\n\t    }\n\n\t  dest = __mempcpy (dest, start, end - start);\n\t  *dest = '\\0';\n\n\t  if (__lxstat64 (_STAT_VER, rpath, &st) < 0)\n\t    goto error;\n\n\t  if (S_ISLNK (st.st_mode))\n\t    {\n\t      char *buf = __alloca (path_max);\n\t      size_t len;\n\n\t      if (++num_links > __eloop_threshold ())\n\t\t{\n\t\t  __set_errno (ELOOP);\n\t\t  goto error;\n\t\t}\n\n\t      n = __readlink (rpath, buf, path_max - 1);\n\t      if (n < 0)\n\t\tgoto error;\n\t      buf[n] = '\\0';\n\n\t      if (!extra_buf)\n\t\textra_buf = __alloca (path_max);\n\n\t      len = strlen (end);\n\t      if (path_max - n <= len)\n\t\t{\n\t\t  __set_errno (ENAMETOOLONG);\n\t\t  goto error;\n\t\t}\n\n\t      /* Careful here, end may be a pointer into extra_buf... */\n\t      memmove (&extra_buf[n], end, len + 1);\n\t      name = end = memcpy (extra_buf, buf, n);\n\n\t      if (buf[0] == '/')\n\t\tdest = rpath + 1;\t/* It's an absolute symlink */\n\t      else\n\t\t/* Back up to previous component, ignore if at root already: */\n\t\tif (dest > rpath + 1)\n\t\t  while ((--dest)[-1] != '/');\n\t    }\n\t  else if (!S_ISDIR (st.st_mode) && *end != '\\0')\n\t    {\n\t      __set_errno (ENOTDIR);\n\t      goto error;\n\t    }\n\t}\n    }\n  if (dest > rpath + 1 && dest[-1] == '/')\n    --dest;\n  *dest = '\\0';\n\n  assert (resolved == NULL || resolved == rpath);\n  return rpath;\n\nerror:\n  assert (resolved == NULL || resolved == rpath);\n  if (resolved == NULL)\n    free (rpath);\n  return NULL;\n}", "target": 3, "idx": 10877}
{"commit_id": "42ceb8ee940a4c0bddeaf22e5a9c20cea2e85a8f", "project": "ImageMagick", "func": "static Image *ReadDPXImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    magick[4],\n    value[MaxTextExtent];\n\n  DPXInfo\n    dpx;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  register ssize_t\n    i;\n\n  size_t\n    extent,\n    samples_per_pixel;\n\n  ssize_t\n    count,\n    n,\n    row,\n    y;\n\n  unsigned char\n    component_type;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read DPX file header.\n  */\n  offset=0;\n  count=ReadBlob(image,4,(unsigned char *) magick);\n  offset+=count;\n  if ((count != 4) || ((LocaleNCompare(magick,\"SDPX\",4) != 0) &&\n      (LocaleNCompare((char *) magick,\"XPDS\",4) != 0)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  image->endian=LSBEndian;\n  if (LocaleNCompare(magick,\"SDPX\",4) == 0)\n    image->endian=MSBEndian;\n  (void) ResetMagickMemory(&dpx,0,sizeof(dpx));\n  dpx.file.image_offset=ReadBlobLong(image);\n  offset+=4;\n  offset+=ReadBlob(image,sizeof(dpx.file.version),(unsigned char *)\n    dpx.file.version);\n  (void) FormatImageProperty(image,\"dpx:file.version\",\"%.8s\",dpx.file.version);\n  dpx.file.file_size=ReadBlobLong(image);\n  offset+=4;\n  dpx.file.ditto_key=ReadBlobLong(image);\n  offset+=4;\n  if (dpx.file.ditto_key != ~0U)\n    (void) FormatImageProperty(image,\"dpx:file.ditto.key\",\"%u\",\n      dpx.file.ditto_key);\n  dpx.file.generic_size=ReadBlobLong(image);\n  offset+=4;\n  dpx.file.industry_size=ReadBlobLong(image);\n  offset+=4;\n  dpx.file.user_size=ReadBlobLong(image);\n  offset+=4;\n  offset+=ReadBlob(image,sizeof(dpx.file.filename),(unsigned char *)\n    dpx.file.filename);\n  (void) FormatImageProperty(image,\"dpx:file.filename\",\"%.100s\",\n    dpx.file.filename);\n  (void) FormatImageProperty(image,\"document\",\"%.100s\",dpx.file.filename);\n  offset+=ReadBlob(image,sizeof(dpx.file.timestamp),(unsigned char *)\n    dpx.file.timestamp);\n  if (*dpx.file.timestamp != '\\0')\n    (void) FormatImageProperty(image,\"dpx:file.timestamp\",\"%.24s\",\n      dpx.file.timestamp);\n  offset+=ReadBlob(image,sizeof(dpx.file.creator),(unsigned char *)\n    dpx.file.creator);\n  if (*dpx.file.creator == '\\0')\n    {\n      char\n        *url;\n\n      url=GetMagickHomeURL();\n      (void) FormatImageProperty(image,\"dpx:file.creator\",\"%.100s\",url);\n      (void) FormatImageProperty(image,\"software\",\"%.100s\",url);\n      url=DestroyString(url);\n    }\n  else\n    {\n      (void) FormatImageProperty(image,\"dpx:file.creator\",\"%.100s\",\n        dpx.file.creator);\n      (void) FormatImageProperty(image,\"software\",\"%.100s\",dpx.file.creator);\n    }\n  offset+=ReadBlob(image,sizeof(dpx.file.project),(unsigned char *)\n    dpx.file.project);\n  if (*dpx.file.project != '\\0')\n    {\n      (void) FormatImageProperty(image,\"dpx:file.project\",\"%.200s\",\n        dpx.file.project);\n      (void) FormatImageProperty(image,\"comment\",\"%.100s\",dpx.file.project);\n    }\n  offset+=ReadBlob(image,sizeof(dpx.file.copyright),(unsigned char *)\n    dpx.file.copyright);\n  if (*dpx.file.copyright != '\\0')\n    {\n      (void) FormatImageProperty(image,\"dpx:file.copyright\",\"%.200s\",\n        dpx.file.copyright);\n      (void) FormatImageProperty(image,\"copyright\",\"%.100s\",\n        dpx.file.copyright);\n    }\n  dpx.file.encrypt_key=ReadBlobLong(image);\n  offset+=4;\n  if (dpx.file.encrypt_key != ~0U)\n    (void) FormatImageProperty(image,\"dpx:file.encrypt_key\",\"%u\",\n      dpx.file.encrypt_key);\n  offset+=ReadBlob(image,sizeof(dpx.file.reserve),(unsigned char *)\n    dpx.file.reserve);\n  /*\n    Read DPX image header.\n  */\n  dpx.image.orientation=ReadBlobShort(image);\n  if (dpx.image.orientation > 7)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  offset+=2;\n  if (dpx.image.orientation != (unsigned short) ~0)\n    (void) FormatImageProperty(image,\"dpx:image.orientation\",\"%d\",\n      dpx.image.orientation);\n  switch (dpx.image.orientation)\n  {\n    default:\n    case 0: image->orientation=TopLeftOrientation; break;\n    case 1: image->orientation=TopRightOrientation; break;\n    case 2: image->orientation=BottomLeftOrientation; break;\n    case 3: image->orientation=BottomRightOrientation; break;\n    case 4: image->orientation=LeftTopOrientation; break;\n    case 5: image->orientation=RightTopOrientation; break;\n    case 6: image->orientation=LeftBottomOrientation; break;\n    case 7: image->orientation=RightBottomOrientation; break;\n  }\n  dpx.image.number_elements=ReadBlobShort(image);\n  if (dpx.image.number_elements > MaxNumberImageElements)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  offset+=2;\n  dpx.image.pixels_per_line=ReadBlobLong(image);\n  offset+=4;\n  image->columns=dpx.image.pixels_per_line;\n  dpx.image.lines_per_element=ReadBlobLong(image);\n  offset+=4;\n  image->rows=dpx.image.lines_per_element;\n  for (i=0; i < 8; i++)\n  {\n    char\n      property[MaxTextExtent];\n\n    dpx.image.image_element[i].data_sign=ReadBlobLong(image);\n    offset+=4;\n    dpx.image.image_element[i].low_data=ReadBlobLong(image);\n    offset+=4;\n    dpx.image.image_element[i].low_quantity=ReadBlobFloat(image);\n    offset+=4;\n    dpx.image.image_element[i].high_data=ReadBlobLong(image);\n    offset+=4;\n    dpx.image.image_element[i].high_quantity=ReadBlobFloat(image);\n    offset+=4;\n    dpx.image.image_element[i].descriptor=(unsigned char) ReadBlobByte(image);\n    offset++;\n    dpx.image.image_element[i].transfer_characteristic=(unsigned char)\n      ReadBlobByte(image);\n    (void) FormatLocaleString(property,MaxTextExtent,\n      \"dpx:image.element[%lu].transfer-characteristic\",(long) i);\n    (void) FormatImageProperty(image,property,\"%s\",\n      GetImageTransferCharacteristic((DPXTransferCharacteristic)\n      dpx.image.image_element[i].transfer_characteristic));\n    offset++;\n    dpx.image.image_element[i].colorimetric=(unsigned char) ReadBlobByte(image);\n    offset++;\n    dpx.image.image_element[i].bit_size=(unsigned char) ReadBlobByte(image);\n    offset++;\n    dpx.image.image_element[i].packing=ReadBlobShort(image);\n    offset+=2;\n    dpx.image.image_element[i].encoding=ReadBlobShort(image);\n    offset+=2;\n    dpx.image.image_element[i].data_offset=ReadBlobLong(image);\n    offset+=4;\n    dpx.image.image_element[i].end_of_line_padding=ReadBlobLong(image);\n    offset+=4;\n    dpx.image.image_element[i].end_of_image_padding=ReadBlobLong(image);\n    offset+=4;\n    offset+=ReadBlob(image,sizeof(dpx.image.image_element[i].description),\n      (unsigned char *) dpx.image.image_element[i].description);\n  }\n  (void) SetImageColorspace(image,RGBColorspace);\n  offset+=ReadBlob(image,sizeof(dpx.image.reserve),(unsigned char *)\n    dpx.image.reserve);\n  if (dpx.file.image_offset >= 1664U)\n    {\n      /*\n        Read DPX orientation header.\n      */\n      dpx.orientation.x_offset=ReadBlobLong(image);\n      offset+=4;\n      if (dpx.orientation.x_offset != ~0U)\n        (void) FormatImageProperty(image,\"dpx:orientation.x_offset\",\"%u\",\n          dpx.orientation.x_offset);\n      dpx.orientation.y_offset=ReadBlobLong(image);\n      offset+=4;\n      if (dpx.orientation.y_offset != ~0U)\n        (void) FormatImageProperty(image,\"dpx:orientation.y_offset\",\"%u\",\n          dpx.orientation.y_offset);\n      dpx.orientation.x_center=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.orientation.x_center) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:orientation.x_center\",\"%g\",\n          dpx.orientation.x_center);\n      dpx.orientation.y_center=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.orientation.y_center) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:orientation.y_center\",\"%g\",\n          dpx.orientation.y_center);\n      dpx.orientation.x_size=ReadBlobLong(image);\n      offset+=4;\n      if (dpx.orientation.x_size != ~0U)\n        (void) FormatImageProperty(image,\"dpx:orientation.x_size\",\"%u\",\n          dpx.orientation.x_size);\n      dpx.orientation.y_size=ReadBlobLong(image);\n      offset+=4;\n      if (dpx.orientation.y_size != ~0U)\n        (void) FormatImageProperty(image,\"dpx:orientation.y_size\",\"%u\",\n          dpx.orientation.y_size);\n      offset+=ReadBlob(image,sizeof(dpx.orientation.filename),(unsigned char *)\n        dpx.orientation.filename);\n      if (*dpx.orientation.filename != '\\0')\n        (void) FormatImageProperty(image,\"dpx:orientation.filename\",\"%.100s\",\n          dpx.orientation.filename);\n      offset+=ReadBlob(image,sizeof(dpx.orientation.timestamp),(unsigned char *)\n        dpx.orientation.timestamp);\n      if (*dpx.orientation.timestamp != '\\0')\n        (void) FormatImageProperty(image,\"dpx:orientation.timestamp\",\"%.24s\",\n          dpx.orientation.timestamp);\n      offset+=ReadBlob(image,sizeof(dpx.orientation.device),(unsigned char *)\n        dpx.orientation.device);\n      if (*dpx.orientation.device != '\\0')\n        (void) FormatImageProperty(image,\"dpx:orientation.device\",\"%.32s\",\n          dpx.orientation.device);\n      offset+=ReadBlob(image,sizeof(dpx.orientation.serial),(unsigned char *)\n        dpx.orientation.serial);\n      if (*dpx.orientation.serial != '\\0')\n        (void) FormatImageProperty(image,\"dpx:orientation.serial\",\"%.32s\",\n          dpx.orientation.serial);\n      for (i=0; i < 4; i++)\n      {\n        dpx.orientation.border[i]=ReadBlobShort(image);\n        offset+=2;\n      }\n      if ((dpx.orientation.border[0] != (unsigned short) (~0)) &&\n          (dpx.orientation.border[1] != (unsigned short) (~0)))\n        (void) FormatImageProperty(image,\"dpx:orientation.border\",\"%dx%d%+d%+d\",          dpx.orientation.border[0],dpx.orientation.border[1],\n          dpx.orientation.border[2],dpx.orientation.border[3]);\n      for (i=0; i < 2; i++)\n      {\n        dpx.orientation.aspect_ratio[i]=ReadBlobLong(image);\n        offset+=4;\n      }\n      if ((dpx.orientation.aspect_ratio[0] != ~0U) &&\n          (dpx.orientation.aspect_ratio[1] != ~0U))\n        (void) FormatImageProperty(image,\"dpx:orientation.aspect_ratio\",\n          \"%ux%u\",dpx.orientation.aspect_ratio[0],\n          dpx.orientation.aspect_ratio[1]);\n      offset+=ReadBlob(image,sizeof(dpx.orientation.reserve),(unsigned char *)\n        dpx.orientation.reserve);\n    }\n  if (dpx.file.image_offset >= 1920U)\n    {\n      /*\n        Read DPX film header.\n      */\n      offset+=ReadBlob(image,sizeof(dpx.film.id),(unsigned char *) dpx.film.id);\n      if (*dpx.film.id != '\\0')\n        (void) FormatImageProperty(image,\"dpx:film.id\",\"%.2s\",dpx.film.id);\n      offset+=ReadBlob(image,sizeof(dpx.film.type),(unsigned char *)\n        dpx.film.type);\n      if (*dpx.film.type != '\\0')\n        (void) FormatImageProperty(image,\"dpx:film.type\",\"%.2s\",dpx.film.type);\n      offset+=ReadBlob(image,sizeof(dpx.film.offset),(unsigned char *)\n        dpx.film.offset);\n      if (*dpx.film.offset != '\\0')\n        (void) FormatImageProperty(image,\"dpx:film.offset\",\"%.2s\",\n          dpx.film.offset);\n      offset+=ReadBlob(image,sizeof(dpx.film.prefix),(unsigned char *)\n        dpx.film.prefix);\n      if (*dpx.film.prefix != '\\0')\n        (void) FormatImageProperty(image,\"dpx:film.prefix\",\"%.6s\",\n          dpx.film.prefix);\n      offset+=ReadBlob(image,sizeof(dpx.film.count),(unsigned char *)\n        dpx.film.count);\n      if (*dpx.film.count != '\\0')\n        (void) FormatImageProperty(image,\"dpx:film.count\",\"%.4s\",\n          dpx.film.count);\n      offset+=ReadBlob(image,sizeof(dpx.film.format),(unsigned char *)\n        dpx.film.format);\n      if (*dpx.film.format != '\\0')\n        (void) FormatImageProperty(image,\"dpx:film.format\",\"%.4s\",\n          dpx.film.format);\n      dpx.film.frame_position=ReadBlobLong(image);\n      offset+=4;\n      if (dpx.film.frame_position != ~0U)\n        (void) FormatImageProperty(image,\"dpx:film.frame_position\",\"%u\",\n          dpx.film.frame_position);\n      dpx.film.sequence_extent=ReadBlobLong(image);\n      offset+=4;\n      if (dpx.film.sequence_extent != ~0U)\n        (void) FormatImageProperty(image,\"dpx:film.sequence_extent\",\"%u\",\n          dpx.film.sequence_extent);\n      dpx.film.held_count=ReadBlobLong(image);\n      offset+=4;\n      if (dpx.film.held_count != ~0U)\n        (void) FormatImageProperty(image,\"dpx:film.held_count\",\"%u\",\n          dpx.film.held_count);\n      dpx.film.frame_rate=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.film.frame_rate) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:film.frame_rate\",\"%g\",\n          dpx.film.frame_rate);\n      dpx.film.shutter_angle=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.film.shutter_angle) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:film.shutter_angle\",\"%g\",\n          dpx.film.shutter_angle);\n      offset+=ReadBlob(image,sizeof(dpx.film.frame_id),(unsigned char *)\n        dpx.film.frame_id);\n      if (*dpx.film.frame_id != '\\0')\n        (void) FormatImageProperty(image,\"dpx:film.frame_id\",\"%.32s\",\n          dpx.film.frame_id);\n      offset+=ReadBlob(image,sizeof(dpx.film.slate),(unsigned char *)\n        dpx.film.slate);\n      if (*dpx.film.slate != '\\0')\n        (void) FormatImageProperty(image,\"dpx:film.slate\",\"%.100s\",\n          dpx.film.slate);\n      offset+=ReadBlob(image,sizeof(dpx.film.reserve),(unsigned char *)\n        dpx.film.reserve);\n    }\n  if (dpx.file.image_offset >= 2048U)\n    {\n      /*\n        Read DPX television header.\n      */\n      dpx.television.time_code=(unsigned int) ReadBlobLong(image);\n      offset+=4;\n      TimeCodeToString(dpx.television.time_code,value);\n      (void) SetImageProperty(image,\"dpx:television.time.code\",value);\n      dpx.television.user_bits=(unsigned int) ReadBlobLong(image);\n      offset+=4;\n      TimeCodeToString(dpx.television.user_bits,value);\n      (void) SetImageProperty(image,\"dpx:television.user.bits\",value);\n      dpx.television.interlace=(unsigned char) ReadBlobByte(image);\n      offset++;\n      if (dpx.television.interlace != 0)\n        (void) FormatImageProperty(image,\"dpx:television.interlace\",\"%.20g\",\n          (double) dpx.television.interlace);\n      dpx.television.field_number=(unsigned char) ReadBlobByte(image);\n      offset++;\n      if (dpx.television.field_number != 0)\n        (void) FormatImageProperty(image,\"dpx:television.field_number\",\"%.20g\",\n          (double) dpx.television.field_number);\n      dpx.television.video_signal=(unsigned char) ReadBlobByte(image);\n      offset++;\n      if (dpx.television.video_signal != 0)\n        (void) FormatImageProperty(image,\"dpx:television.video_signal\",\"%.20g\",\n          (double) dpx.television.video_signal);\n      dpx.television.padding=(unsigned char) ReadBlobByte(image);\n      offset++;\n      if (dpx.television.padding != 0)\n        (void) FormatImageProperty(image,\"dpx:television.padding\",\"%d\",\n          dpx.television.padding);\n      dpx.television.horizontal_sample_rate=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.horizontal_sample_rate) != MagickFalse)\n        (void) FormatImageProperty(image,\n          \"dpx:television.horizontal_sample_rate\",\"%g\",\n          dpx.television.horizontal_sample_rate);\n      dpx.television.vertical_sample_rate=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.vertical_sample_rate) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:television.vertical_sample_rate\",\n          \"%g\",dpx.television.vertical_sample_rate);\n      dpx.television.frame_rate=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.frame_rate) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:television.frame_rate\",\"%g\",\n          dpx.television.frame_rate);\n      dpx.television.time_offset=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.time_offset) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:television.time_offset\",\"%g\",\n          dpx.television.time_offset);\n      dpx.television.gamma=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.gamma) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:television.gamma\",\"%g\",\n          dpx.television.gamma);\n      dpx.television.black_level=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.black_level) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:television.black_level\",\"%g\",\n          dpx.television.black_level);\n      dpx.television.black_gain=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.black_gain) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:television.black_gain\",\"%g\",\n          dpx.television.black_gain);\n      dpx.television.break_point=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.break_point) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:television.break_point\",\"%g\",\n          dpx.television.break_point);\n      dpx.television.white_level=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.white_level) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:television.white_level\",\"%g\",\n          dpx.television.white_level);\n      dpx.television.integration_times=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.integration_times) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:television.integration_times\",\n          \"%g\",dpx.television.integration_times);\n      offset+=ReadBlob(image,sizeof(dpx.television.reserve),(unsigned char *)\n        dpx.television.reserve);\n    }\n  if (dpx.file.image_offset > 2080U)\n    {\n      /*\n        Read DPX user header.\n      */\n      offset+=ReadBlob(image,sizeof(dpx.user.id),(unsigned char *) dpx.user.id);\n      if (*dpx.user.id != '\\0')\n        (void) FormatImageProperty(image,\"dpx:user.id\",\"%.32s\",dpx.user.id);\n      if ((dpx.file.user_size != ~0U) &&\n          ((size_t) dpx.file.user_size > sizeof(dpx.user.id)))\n        {\n          StringInfo\n            *profile;\n\n           profile=BlobToStringInfo((const void *) NULL,\n             dpx.file.user_size-sizeof(dpx.user.id));\n           if (profile == (StringInfo *) NULL)\n             ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n           offset+=ReadBlob(image,GetStringInfoLength(profile),\n             GetStringInfoDatum(profile));\n           (void) SetImageProfile(image,\"dpx:user-data\",profile);\n           profile=DestroyStringInfo(profile);\n        }\n    }\n  for ( ; offset < (MagickOffsetType) dpx.file.image_offset; offset++)\n    if (ReadBlobByte(image) == EOF)\n      break;\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  for (n=0; n < (ssize_t) dpx.image.number_elements; n++)\n  {\n    /*\n      Convert DPX raster image to pixel packets.\n    */\n    if ((dpx.image.image_element[n].data_offset != ~0U) &&\n        (dpx.image.image_element[n].data_offset != 0U))\n      {\n         MagickOffsetType\n           data_offset;\n\n         data_offset=(MagickOffsetType) dpx.image.image_element[n].data_offset;\n         if (data_offset < offset)\n           offset=SeekBlob(image,data_offset,SEEK_SET);\n         else\n           for ( ; offset < data_offset; offset++)\n             (void) ReadBlobByte(image);\n          if (offset != data_offset)\n            ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n       }\n    SetPrimaryChromaticity((DPXColorimetric)\n      dpx.image.image_element[n].colorimetric,&image->chromaticity);\n    image->depth=dpx.image.image_element[n].bit_size;\n    samples_per_pixel=1;\n    quantum_type=GrayQuantum;\n    component_type=dpx.image.image_element[n].descriptor;\n    switch (component_type)\n    {\n      case CbYCrY422ComponentType:\n      {\n        samples_per_pixel=2;\n        quantum_type=CbYCrYQuantum;\n        break;\n      }\n      case CbYACrYA4224ComponentType:\n      case CbYCr444ComponentType:\n      {\n        samples_per_pixel=3;\n        quantum_type=CbYCrQuantum;\n        break;\n      }\n      case RGBComponentType:\n      {\n        samples_per_pixel=3;\n        quantum_type=RGBQuantum;\n        break;\n      }\n      case ABGRComponentType:\n      case RGBAComponentType:\n      {\n        image->matte=MagickTrue;\n        samples_per_pixel=4;\n        quantum_type=RGBAQuantum;\n        break;\n      }\n      default:\n        break;\n    }\n    switch (component_type)\n    {\n      case CbYCrY422ComponentType:\n      case CbYACrYA4224ComponentType:\n      case CbYCr444ComponentType:\n      {\n        (void) SetImageColorspace(image,Rec709YCbCrColorspace);\n        break;\n      }\n      case LumaComponentType:\n      {\n        (void) SetImageColorspace(image,GRAYColorspace);\n        break;\n      }\n      default:\n      {\n        (void) SetImageColorspace(image,RGBColorspace);\n        if (dpx.image.image_element[n].transfer_characteristic == LogarithmicColorimetric)\n          (void) SetImageColorspace(image,LogColorspace);\n        if (dpx.image.image_element[n].transfer_characteristic == PrintingDensityColorimetric)\n          (void) SetImageColorspace(image,LogColorspace);\n        break;\n      }\n    }\n    extent=GetBytesPerRow(image->columns,samples_per_pixel,image->depth,\n      dpx.image.image_element[n].packing == 0 ? MagickFalse : MagickTrue);\n    /*\n      DPX any-bit pixel format.\n    */\n    status=MagickTrue;\n    row=0;\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    SetQuantumQuantum(quantum_info,32);\n    SetQuantumPack(quantum_info,dpx.image.image_element[n].packing == 0 ?\n      MagickTrue : MagickFalse);\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      const unsigned char\n        *pixels;\n\n      MagickBooleanType\n        sync;\n\n      register PixelPacket\n        *q;\n\n      size_t\n        length;\n\n      ssize_t\n        count,\n        offset;\n\n      if (status == MagickFalse)\n        continue;\n      pixels=(const unsigned char *) ReadBlobStream(image,extent,\n        GetQuantumPixels(quantum_info),&count);\n      if (count != (ssize_t) extent)\n        status=MagickFalse;\n      if ((image->progress_monitor != (MagickProgressMonitor) NULL) &&\n          (image->previous == (Image *) NULL))\n        {\n          MagickBooleanType\n            proceed;\n\n          proceed=SetImageProgress(image,LoadImageTag,(MagickOffsetType) row,\n            image->rows);\n          if (proceed == MagickFalse)\n            status=MagickFalse;\n        }\n      offset=row++;\n      q=QueueAuthenticPixels(image,0,offset,image->columns,1,exception);\n      if (q == (PixelPacket *) NULL)\n        {\n          status=MagickFalse;\n          continue;\n        }\n      length=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n        quantum_type,pixels,exception);\n      (void) length;\n      sync=SyncAuthenticPixels(image,exception);\n      if (sync == MagickFalse)\n        status=MagickFalse;\n    }\n    quantum_info=DestroyQuantumInfo(quantum_info);\n    if (status == MagickFalse)\n      ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n    SetQuantumImageType(image,quantum_type);\n    if (EOFBlob(image) != MagickFalse)\n      ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n        image->filename);\n  }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}", "target": 2, "idx": 10878}
{"commit_id": "04f2d32871bb3b11d7dc024039952f2fe2750306", "project": "acassen/keepalived", "func": "void\nvrrp_print_json(void)\n{\n\tFILE *file;\n\telement e;\n\tstruct json_object *array;\n\n\tif (LIST_ISEMPTY(vrrp_data->vrrp))\n\t\treturn;\n\n\tfile = fopen_safe(\"/tmp/keepalived.json\", \"w\");\n\tif (!file) {\n\t\tlog_message(LOG_INFO, \"Can't open /tmp/keepalived.json (%d: %s)\",\n\t\t\terrno, strerror(errno));\n\t\treturn;\n\t}\n\n\tarray = json_object_new_array();\n\n\tfor (e = LIST_HEAD(vrrp_data->vrrp); e; ELEMENT_NEXT(e)) {\n\t\tstruct json_object *instance_json, *json_stats, *json_data,\n\t\t\t*vips, *evips, *track_ifp, *track_script;\n#ifdef _HAVE_FIB_ROUTING_\n\t\tstruct json_object *vroutes, *vrules;\n#endif\n\t\telement f;\n\n\t\tvrrp_t *vrrp = ELEMENT_DATA(e);\n\t\tinstance_json = json_object_new_object();\n\t\tjson_stats = json_object_new_object();\n\t\tjson_data = json_object_new_object();\n\t\tvips = json_object_new_array();\n\t\tevips = json_object_new_array();\n\t\ttrack_ifp = json_object_new_array();\n\t\ttrack_script = json_object_new_array();\n#ifdef _HAVE_FIB_ROUTING_\n\t\tvroutes = json_object_new_array();\n\t\tvrules = json_object_new_array();\n#endif\n\n\t\t// Dump data to json\n\t\tjson_object_object_add(json_data, \"iname\",\n\t\t\tjson_object_new_string(vrrp->iname));\n\t\tjson_object_object_add(json_data, \"dont_track_primary\",\n\t\t\tjson_object_new_int(vrrp->dont_track_primary));\n\t\tjson_object_object_add(json_data, \"skip_check_adv_addr\",\n\t\t\tjson_object_new_int(vrrp->skip_check_adv_addr));\n\t\tjson_object_object_add(json_data, \"strict_mode\",\n\t\t\tjson_object_new_int((int)vrrp->strict_mode));\n#ifdef _HAVE_VRRP_VMAC_\n\t\tjson_object_object_add(json_data, \"vmac_ifname\",\n\t\t\tjson_object_new_string(vrrp->vmac_ifname));\n#endif\n\t\t// Tracked interfaces are stored in a list\n\t\tif (!LIST_ISEMPTY(vrrp->track_ifp)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->track_ifp); f; ELEMENT_NEXT(f)) {\n\t\t\t\tinterface_t *ifp = ELEMENT_DATA(f);\n\t\t\t\tjson_object_array_add(track_ifp,\n\t\t\t\t\tjson_object_new_string(ifp->ifname));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"track_ifp\", track_ifp);\n\n\t\t// Tracked scripts also\n\t\tif (!LIST_ISEMPTY(vrrp->track_script)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->track_script); f; ELEMENT_NEXT(f)) {\n\t\t\t\ttracked_sc_t *tsc = ELEMENT_DATA(f);\n\t\t\t\tvrrp_script_t *vscript = tsc->scr;\n\t\t\t\tjson_object_array_add(track_script,\n\t\t\t\t\tjson_object_new_string(cmd_str(&vscript->script)));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"track_script\", track_script);\n\n\t\tjson_object_object_add(json_data, \"ifp_ifname\",\n\t\t\tjson_object_new_string(vrrp->ifp->ifname));\n\t\tjson_object_object_add(json_data, \"master_priority\",\n\t\t\tjson_object_new_int(vrrp->master_priority));\n\t\tjson_object_object_add(json_data, \"last_transition\",\n\t\t\tjson_object_new_double(timeval_to_double(&vrrp->last_transition)));\n\t\tjson_object_object_add(json_data, \"garp_delay\",\n\t\t\tjson_object_new_double(vrrp->garp_delay / TIMER_HZ_FLOAT));\n\t\tjson_object_object_add(json_data, \"garp_refresh\",\n\t\t\tjson_object_new_int((int)vrrp->garp_refresh.tv_sec));\n\t\tjson_object_object_add(json_data, \"garp_rep\",\n\t\t\tjson_object_new_int((int)vrrp->garp_rep));\n\t\tjson_object_object_add(json_data, \"garp_refresh_rep\",\n\t\t\tjson_object_new_int((int)vrrp->garp_refresh_rep));\n\t\tjson_object_object_add(json_data, \"garp_lower_prio_delay\",\n\t\t\tjson_object_new_int((int)(vrrp->garp_lower_prio_delay / TIMER_HZ)));\n\t\tjson_object_object_add(json_data, \"garp_lower_prio_rep\",\n\t\t\tjson_object_new_int((int)vrrp->garp_lower_prio_rep));\n\t\tjson_object_object_add(json_data, \"lower_prio_no_advert\",\n\t\t\tjson_object_new_int((int)vrrp->lower_prio_no_advert));\n\t\tjson_object_object_add(json_data, \"higher_prio_send_advert\",\n\t\t\tjson_object_new_int((int)vrrp->higher_prio_send_advert));\n\t\tjson_object_object_add(json_data, \"vrid\",\n\t\t\tjson_object_new_int(vrrp->vrid));\n\t\tjson_object_object_add(json_data, \"base_priority\",\n\t\t\tjson_object_new_int(vrrp->base_priority));\n\t\tjson_object_object_add(json_data, \"effective_priority\",\n\t\t\tjson_object_new_int(vrrp->effective_priority));\n\t\tjson_object_object_add(json_data, \"vipset\",\n\t\t\tjson_object_new_boolean(vrrp->vipset));\n\n\t\t//Virtual IPs are stored in a list\n\t\tif (!LIST_ISEMPTY(vrrp->vip)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->vip); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_address_t *vip = ELEMENT_DATA(f);\n\t\t\t\tchar ipaddr[INET6_ADDRSTRLEN];\n\t\t\t\tinet_ntop(vrrp->family, &(vip->u.sin.sin_addr.s_addr),\n\t\t\t\t\tipaddr, INET6_ADDRSTRLEN);\n\t\t\t\tjson_object_array_add(vips,\n\t\t\t\t\tjson_object_new_string(ipaddr));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"vips\", vips);\n\n\t\t//External VIPs are also stored in a list\n\t\tif (!LIST_ISEMPTY(vrrp->evip)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->evip); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_address_t *evip = ELEMENT_DATA(f);\n\t\t\t\tchar ipaddr[INET6_ADDRSTRLEN];\n\t\t\t\tinet_ntop(vrrp->family, &(evip->u.sin.sin_addr.s_addr),\n\t\t\t\t\tipaddr, INET6_ADDRSTRLEN);\n\t\t\t\tjson_object_array_add(evips,\n\t\t\t\t\tjson_object_new_string(ipaddr));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"evips\", evips);\n\n\t\tjson_object_object_add(json_data, \"promote_secondaries\",\n\t\t\tjson_object_new_boolean(vrrp->promote_secondaries));\n\n#ifdef _HAVE_FIB_ROUTING_\n\t\t// Dump vroutes\n\t\tif (!LIST_ISEMPTY(vrrp->vroutes)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->vroutes); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_route_t *route = ELEMENT_DATA(f);\n\t\t\t\tchar *buf = MALLOC(ROUTE_BUF_SIZE);\n\t\t\t\tformat_iproute(route, buf, ROUTE_BUF_SIZE);\n\t\t\t\tjson_object_array_add(vroutes,\n\t\t\t\t\tjson_object_new_string(buf));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"vroutes\", vroutes);\n\n\t\t// Dump vrules\n\t\tif (!LIST_ISEMPTY(vrrp->vrules)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->vrules); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_rule_t *rule = ELEMENT_DATA(f);\n\t\t\t\tchar *buf = MALLOC(RULE_BUF_SIZE);\n\t\t\t\tformat_iprule(rule, buf, RULE_BUF_SIZE);\n\t\t\t\tjson_object_array_add(vrules,\n\t\t\t\t\tjson_object_new_string(buf));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"vrules\", vrules);\n#endif\n\n\t\tjson_object_object_add(json_data, \"adver_int\",\n\t\t\tjson_object_new_double(vrrp->adver_int / TIMER_HZ_FLOAT));\n\t\tjson_object_object_add(json_data, \"master_adver_int\",\n\t\t\tjson_object_new_double(vrrp->master_adver_int / TIMER_HZ_FLOAT));\n\t\tjson_object_object_add(json_data, \"accept\",\n\t\t\tjson_object_new_int((int)vrrp->accept));\n\t\tjson_object_object_add(json_data, \"nopreempt\",\n\t\t\tjson_object_new_boolean(vrrp->nopreempt));\n\t\tjson_object_object_add(json_data, \"preempt_delay\",\n\t\t\tjson_object_new_int((int)(vrrp->preempt_delay / TIMER_HZ)));\n\t\tjson_object_object_add(json_data, \"state\",\n\t\t\tjson_object_new_int(vrrp->state));\n\t\tjson_object_object_add(json_data, \"wantstate\",\n\t\t\tjson_object_new_int(vrrp->wantstate));\n\t\tjson_object_object_add(json_data, \"version\",\n\t\t\tjson_object_new_int(vrrp->version));\n\t\tif (vrrp->script_backup)\n\t\t\tjson_object_object_add(json_data, \"script_backup\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_backup)));\n\t\tif (vrrp->script_master)\n\t\t\tjson_object_object_add(json_data, \"script_master\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_master)));\n\t\tif (vrrp->script_fault)\n\t\t\tjson_object_object_add(json_data, \"script_fault\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_fault)));\n\t\tif (vrrp->script_stop)\n\t\t\tjson_object_object_add(json_data, \"script_stop\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_stop)));\n\t\tif (vrrp->script)\n\t\t\tjson_object_object_add(json_data, \"script\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script)));\n\t\tif (vrrp->script_master_rx_lower_pri)\n\t\t\tjson_object_object_add(json_data, \"script_master_rx_lower_pri\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_master_rx_lower_pri)));\n\t\tjson_object_object_add(json_data, \"smtp_alert\",\n\t\t\tjson_object_new_boolean(vrrp->smtp_alert));\n#ifdef _WITH_VRRP_AUTH_\n\t\tif (vrrp->auth_type) {\n\t\t\tjson_object_object_add(json_data, \"auth_type\",\n\t\t\t\tjson_object_new_int(vrrp->auth_type));\n\n\t\t\tif (vrrp->auth_type != VRRP_AUTH_AH) {\n\t\t\t\tchar auth_data[sizeof(vrrp->auth_data) + 1];\n\t\t\t\tmemcpy(auth_data, vrrp->auth_data, sizeof(vrrp->auth_data));\n\t\t\t\tauth_data[sizeof(vrrp->auth_data)] = '\\0';\n\t\t\t\tjson_object_object_add(json_data, \"auth_data\",\n\t\t\t\t\tjson_object_new_string(auth_data));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tjson_object_object_add(json_data, \"auth_type\",\n\t\t\t\tjson_object_new_int(0));\n#endif\n\n\t\t// Dump stats to json\n\t\tjson_object_object_add(json_stats, \"advert_rcvd\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->advert_rcvd));\n\t\tjson_object_object_add(json_stats, \"advert_sent\",\n\t\t\tjson_object_new_int64(vrrp->stats->advert_sent));\n\t\tjson_object_object_add(json_stats, \"become_master\",\n\t\t\tjson_object_new_int64(vrrp->stats->become_master));\n\t\tjson_object_object_add(json_stats, \"release_master\",\n\t\t\tjson_object_new_int64(vrrp->stats->release_master));\n\t\tjson_object_object_add(json_stats, \"packet_len_err\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->packet_len_err));\n\t\tjson_object_object_add(json_stats, \"advert_interval_err\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->advert_interval_err));\n\t\tjson_object_object_add(json_stats, \"ip_ttl_err\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->ip_ttl_err));\n\t\tjson_object_object_add(json_stats, \"invalid_type_rcvd\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->invalid_type_rcvd));\n\t\tjson_object_object_add(json_stats, \"addr_list_err\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->addr_list_err));\n\t\tjson_object_object_add(json_stats, \"invalid_authtype\",\n\t\t\tjson_object_new_int64(vrrp->stats->invalid_authtype));\n#ifdef _WITH_VRRP_AUTH_\n\t\tjson_object_object_add(json_stats, \"authtype_mismatch\",\n\t\t\tjson_object_new_int64(vrrp->stats->authtype_mismatch));\n\t\tjson_object_object_add(json_stats, \"auth_failure\",\n\t\t\tjson_object_new_int64(vrrp->stats->auth_failure));\n#endif\n\t\tjson_object_object_add(json_stats, \"pri_zero_rcvd\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->pri_zero_rcvd));\n\t\tjson_object_object_add(json_stats, \"pri_zero_sent\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->pri_zero_sent));\n\n\t\t// Add both json_data and json_stats to main instance_json\n\t\tjson_object_object_add(instance_json, \"data\", json_data);\n\t\tjson_object_object_add(instance_json, \"stats\", json_stats);\n\n\t\t// Add instance_json to main array\n\t\tjson_object_array_add(array, instance_json);\n\n\t}\n\tfprintf(file, \"%s\", json_object_to_json_string(array));\n\tfclose(file);\n}", "target": 1, "idx": 10879}
{"commit_id": "e477f09d0b3619f3d29173b2cd593e17e2d1978e", "project": "ffmpeg", "func": "static int decode_trns_chunk(AVCodecContext *avctx, PNGDecContext *s,\n                             uint32_t length)\n{\n    int v, i;\n\n    if (!(s->state & PNG_IHDR)) {\n        av_log(avctx, AV_LOG_ERROR, \"trns before IHDR\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (s->state & PNG_IDAT) {\n        av_log(avctx, AV_LOG_ERROR, \"trns after IDAT\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (s->color_type == PNG_COLOR_TYPE_PALETTE) {\n        if (length > 256 || !(s->state & PNG_PLTE))\n            return AVERROR_INVALIDDATA;\n\n        for (i = 0; i < length; i++) {\n            v = bytestream2_get_byte(&s->gb);\n            s->palette[i] = (s->palette[i] & 0x00ffffff) | (v << 24);\n        }\n    } else if (s->color_type == PNG_COLOR_TYPE_GRAY || s->color_type == PNG_COLOR_TYPE_RGB) {\n        if ((s->color_type == PNG_COLOR_TYPE_GRAY && length != 2) ||\n            (s->color_type == PNG_COLOR_TYPE_RGB && length != 6) ||\n            s->bit_depth == 1)\n            return AVERROR_INVALIDDATA;\n\n        for (i = 0; i < length / 2; i++) {\n            /* only use the least significant bits */\n            v = av_mod_uintp2(bytestream2_get_be16(&s->gb), s->bit_depth);\n\n            if (s->bit_depth > 8)\n                AV_WB16(&s->transparent_color_be[2 * i], v);\n            else\n                s->transparent_color_be[i] = v;\n        }\n    } else {\n        return AVERROR_INVALIDDATA;\n    }\n\n    bytestream2_skip(&s->gb, 4); /* crc */\n    s->has_trns = 1;\n\n    return 0;\n}", "target": 3, "idx": 10880}
{"commit_id": "f57bd745b4cbed577ea654fad4701bea4d38b44c", "project": "moonlight-stream/moonlight-common-c", "func": "int startVideoStream(void* rendererContext, int drFlags) {\n    int err;\n\n    // This must be called before the decoder thread starts submitting\n    // decode units\n    LC_ASSERT(NegotiatedVideoFormat != 0);\n    VideoCallbacks.setup(NegotiatedVideoFormat, StreamConfig.width,\n        StreamConfig.height, StreamConfig.fps, rendererContext, drFlags);\n\n    rtpSocket = bindUdpSocket(RemoteAddr.ss_family, RTP_RECV_BUFFER);\n    if (rtpSocket == INVALID_SOCKET) {\n        return LastSocketError();\n    }\n\n    err = PltCreateThread(ReceiveThreadProc, NULL, &receiveThread);\n    if (err != 0) {\n        return err;\n    }\n\n    if ((VideoCallbacks.capabilities & CAPABILITY_DIRECT_SUBMIT) == 0) {\n        err = PltCreateThread(DecoderThreadProc, NULL, &decoderThread);\n        if (err != 0) {\n            return err;\n        }\n    }\n\n    if (AppVersionQuad[0] == 3) {\n        // Connect this socket to open port 47998 for our ping thread\n        firstFrameSocket = connectTcpSocket(&RemoteAddr, RemoteAddrLen,\n                                            FIRST_FRAME_PORT, FIRST_FRAME_TIMEOUT_SEC);\n        if (firstFrameSocket == INVALID_SOCKET) {\n            return LastSocketError();\n        }\n    }\n\n    // Start pinging before reading the first frame so GFE knows where\n    // to send UDP data\n    err = PltCreateThread(UdpPingThreadProc, NULL, &udpPingThread);\n    if (err != 0) {\n        return err;\n    }\n\n    if (AppVersionQuad[0] == 3) {\n        // Read the first frame to start the flow of video\n        err = readFirstFrame();\n        if (err != 0) {\n            return err;\n        }\n    }\n\n    return 0;\n}", "target": 2, "idx": 10881}
{"commit_id": "34a08bec755670ea0490cb53bbc68058cafc69b6", "project": "OP-TEE/optee_os", "func": "TEE_Result syscall_cipher_init(unsigned long state, const void *iv,\n\t\t\tsize_t iv_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\tstruct tee_cryp_obj_secret *key1;\n\tstruct user_ta_ctx *utc;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tutc = to_user_ta_ctx(sess->ctx);\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_CIPHER)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tres = tee_mmu_check_access_rights(utc,\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t) iv, iv_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(utc, cs->key1, &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tkey1 = o->attr;\n\n\tif (tee_obj_get(utc, cs->key2, &o) == TEE_SUCCESS) {\n\t\tstruct tee_cryp_obj_secret *key2 = o->attr;\n\n\t\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t\tres = crypto_cipher_init(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\t (uint8_t *)(key1 + 1), key1->key_size,\n\t\t\t\t\t (uint8_t *)(key2 + 1), key2->key_size,\n\t\t\t\t\t iv, iv_len);\n\t} else {\n\t\tres = crypto_cipher_init(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\t (uint8_t *)(key1 + 1), key1->key_size,\n\t\t\t\t\t NULL, 0, iv, iv_len);\n\t}\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tcs->ctx_finalize = crypto_cipher_final;\n\tcs->state = CRYP_STATE_INITIALIZED;\n\n\treturn TEE_SUCCESS;\n}", "target": 3, "idx": 10882}
{"commit_id": "fcd18ce3101f245b083b30655c27b239dc72221e", "project": "tensorflow", "func": "int64_t OpLevelCostEstimator::CalculateTensorSize(\n    const OpInfo::TensorProperties& tensor, bool* found_unknown_shapes) {\n  int64_t count = CalculateTensorElementCount(tensor, found_unknown_shapes);\n  int size = DataTypeSize(BaseType(tensor.dtype()));\n  VLOG(2) << \"Count: \" << count << \" DataTypeSize: \" << size;\n  int64_t tensor_size = MultiplyWithoutOverflow(count, size);\n  if (tensor_size < 0) {\n    VLOG(1) << \"Overflow encountered when computing tensor size, multiplying \"\n            << count << \" with \" << size;\n    return -1;\n  }\n  return tensor_size;\n}", "target": 1, "idx": 10883}
{"commit_id": "a6da1472c0c5e05ff249325f979531ad51533110", "project": "lua", "func": "void luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v) {\n  global_State *g = G(L);\n  lua_assert(isblack(o) && iswhite(v) && !isdead(g, v) && !isdead(g, o));\n  if (keepinvariant(g)) {  /* must keep invariant? */\n    reallymarkobject(g, v);  /* restore invariant */\n    if (isold(o)) {\n      lua_assert(!isold(v));  /* white object could not be old */\n      setage(v, G_OLD0);  /* restore generational invariant */\n    }\n  }\n  else {  /* sweep phase */\n    lua_assert(issweepphase(g));\n    if (g->gckind == KGC_INC)  /* incremental mode? */\n      makewhite(g, o);  /* mark 'o' as white to avoid other barriers */\n  }\n}", "target": 1, "idx": 10884}
{"commit_id": "bc4812d31a67d5e2f973fbfaf950d6118226cf36", "project": "pjsip/pjproject", "func": "static pj_status_t decode_errcode_attr(pj_pool_t *pool, \n                                       const pj_uint8_t *buf,\n                                       const pj_stun_msg_hdr *msghdr, \n                                       void **p_attr)\n{\n    pj_stun_errcode_attr *attr;\n    pj_str_t value;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_errcode_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    /* Check that the attribute length is valid */\n    if (attr->hdr.length < 4)\n        return PJNATH_ESTUNINATTRLEN;\n\n    attr->err_code = buf[6] * 100 + buf[7];\n\n    /* Get pointer to the string in the message */\n    value.ptr = ((char*)buf + ATTR_HDR_LEN + 4);\n    value.slen = attr->hdr.length - 4;\n\n    /* Copy the string to the attribute */\n    pj_strdup(pool, &attr->reason, &value);\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}", "target": 1, "idx": 10885}
{"commit_id": "3f04db891a353f4b127ed57279279f851c6b4917", "project": "u-boot", "func": "int fit_check_format(const void *fit, ulong size)\n{\n\tint ret;\n\n\t/* A FIT image must be a valid FDT */\n\tret = fdt_check_header(fit);\n\tif (ret) {\n\t\tlog_debug(\"Wrong FIT format: not a flattened device tree (err=%d)\\n\",\n\t\t\t  ret);\n\t\treturn -ENOEXEC;\n\t}\n\n\tif (CONFIG_IS_ENABLED(FIT_FULL_CHECK)) {\n\t\t/*\n\t\t * If we are not given the size, make do wtih calculating it.\n\t\t * This is not as secure, so we should consider a flag to\n\t\t * control this.\n\t\t */\n\t\tif (size == IMAGE_SIZE_INVAL)\n\t\t\tsize = fdt_totalsize(fit);\n\t\tret = fdt_check_full(fit, size);\n\t\tif (ret)\n\t\t\tret = -EINVAL;\n\n\t\t/*\n\t\t * U-Boot stopped using unit addressed in 2017. Since libfdt\n\t\t * can match nodes ignoring any unit address, signature\n\t\t * verification can see the wrong node if one is inserted with\n\t\t * the same name as a valid node but with a unit address\n\t\t * attached. Protect against this by disallowing unit addresses.\n\t\t */\n\t\tif (!ret && CONFIG_IS_ENABLED(FIT_SIGNATURE)) {\n\t\t\tret = fdt_check_no_at(fit, 0);\n\n\t\t\tif (ret) {\n\t\t\t\tlog_debug(\"FIT check error %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tif (ret) {\n\t\t\tlog_debug(\"FIT check error %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* mandatory / node 'description' property */\n\tif (!fdt_getprop(fit, 0, FIT_DESC_PROP, NULL)) {\n\t\tlog_debug(\"Wrong FIT format: no description\\n\");\n\t\treturn -ENOMSG;\n\t}\n\n\tif (IMAGE_ENABLE_TIMESTAMP) {\n\t\t/* mandatory / node 'timestamp' property */\n\t\tif (!fdt_getprop(fit, 0, FIT_TIMESTAMP_PROP, NULL)) {\n\t\t\tlog_debug(\"Wrong FIT format: no timestamp\\n\");\n\t\t\treturn -ENODATA;\n\t\t}\n\t}\n\n\t/* mandatory subimages parent '/images' node */\n\tif (fdt_path_offset(fit, FIT_IMAGES_PATH) < 0) {\n\t\tlog_debug(\"Wrong FIT format: no images parent node\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\treturn 0;\n}", "target": 2, "idx": 10886}
{"commit_id": "b9bd6cfd1c50e6807846af9a86f9b83cafc9c8ae", "project": "tensorflow", "func": "int64_t OpLevelCostEstimator::CalculateOutputSize(const OpInfo& op_info,\n                                                  bool* found_unknown_shapes) {\n  int64_t total_output_size = 0;\n  // Use float as default for calculations.\n  for (const auto& output : op_info.outputs()) {\n    DataType dt = output.dtype();\n    const auto& original_output_shape = output.shape();\n    int64_t output_size = DataTypeSize(BaseType(dt));\n    int num_dims = std::max(1, original_output_shape.dim_size());\n    auto output_shape = MaybeGetMinimumShape(original_output_shape, num_dims,\n                                             found_unknown_shapes);\n    for (const auto& dim : output_shape.dim()) {\n      int64_t new_output_size =\n          MultiplyWithoutOverflow(output_size, dim.size());\n      if (new_output_size < 0) {\n        VLOG(1) << \"Overflow encountered when estimating cost, multiplying \"\n                << output_size << \" with \" << dim.size();\n        return -1;\n      }\n      output_size = new_output_size;\n    }\n    total_output_size += output_size;\n    VLOG(1) << \"Output Size: \" << output_size\n            << \" Total Output Size:\" << total_output_size;\n  }\n  return total_output_size;\n}", "target": 1, "idx": 10887}
{"commit_id": "340d394a789518018f834ff70f7534fc463d3226", "project": "torvalds/linux", "func": "static int i8042_start(struct serio *serio)\n{\n\tstruct i8042_port *port = serio->port_data;\n\n\tspin_lock_irq(&i8042_lock);\n\tport->exists = true;\n\tspin_unlock_irq(&i8042_lock);\n\n\treturn 0;\n}", "target": 2, "idx": 10888}
{"commit_id": "0ff832d31470471803b175cfff4e40c1b08ee779", "project": "aawc/unrar", "func": "void CharToWideMap(const char *Src,wchar *Dest,size_t DestSize,bool &Success)\n{\n  // Map inconvertible characters to private use Unicode area 0xE000.\n  // Mark such string by placing special non-character code before\n  // first inconvertible character.\n  Success=false;\n  bool MarkAdded=false;\n  uint SrcPos=0,DestPos=0;\n  while (DestPos<DestSize)\n  {\n    if (Src[SrcPos]==0)\n    {\n      Success=true;\n      break;\n    }\n    mbstate_t ps;\n    memset(&ps,0,sizeof(ps));\n    size_t res=mbrtowc(Dest+DestPos,Src+SrcPos,MB_CUR_MAX,&ps);\n    if (res==(size_t)-1 || res==(size_t)-2)\n    {\n      // For security reasons we do not want to map low ASCII characters,\n      // so we do not have additional .. and path separator codes.\n      if (byte(Src[SrcPos])>=0x80)\n      {\n        if (!MarkAdded)\n        {\n          Dest[DestPos++]=MappedStringMark;\n          MarkAdded=true;\n          if (DestPos>=DestSize)\n            break;\n        }\n        Dest[DestPos++]=byte(Src[SrcPos++])+MapAreaStart;\n      }\n      else\n        break;\n    }\n    else\n    {\n      memset(&ps,0,sizeof(ps));\n      int Length=mbrlen(Src+SrcPos,MB_CUR_MAX,&ps);\n      SrcPos+=Max(Length,1);\n      DestPos++;\n    }\n  }\n  Dest[Min(DestPos,DestSize-1)]=0;\n}", "target": 2, "idx": 10889}
{"commit_id": "0e0548c18414656be5977ae0e6c8dd92100b3e37", "project": "espruino/Espruino", "func": "void vcbprintf(\n    vcbprintf_callback user_callback, //!< Unknown\n    void *user_data,                  //!< Unknown\n    const char *fmt,                  //!< The format specified\n    va_list argp                      //!< List of parameter values\n  ) {\n  char buf[32];\n  while (*fmt) {\n    if (*fmt == '%') {\n      fmt++;\n      char fmtChar = *fmt++;\n      switch (fmtChar) {\n      case ' ':\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n      {\n        const char *pad = \" \";\n        if (!*fmt) break;\n        if (fmtChar=='0') {\n          pad = \"0\";\n          fmtChar = *fmt++;\n          if (!*fmt) break;\n        }\n        int digits = fmtChar - '0';\n         // of the form '%02d'\n        int v = va_arg(argp, int);\n        if (*fmt=='x') itostr_extra(v, buf, false, 16);\n        else { assert('d' == *fmt); itostr(v, buf, 10); }\n        fmt++; // skip over 'd'\n        int len = (int)strlen(buf);\n        while (len < digits) {\n          user_callback(pad,user_data);\n          len++;\n        }\n        user_callback(buf,user_data);\n        break;\n      }\n      case 'd': itostr(va_arg(argp, int), buf, 10); user_callback(buf,user_data); break;\n      case 'x': itostr_extra(va_arg(argp, int), buf, false, 16); user_callback(buf,user_data); break;\n      case 'L': {\n        unsigned int rad = 10;\n        bool signedVal = true;\n        if (*fmt=='x') { rad=16; fmt++; signedVal = false; }\n        itostr_extra(va_arg(argp, JsVarInt), buf, signedVal, rad); user_callback(buf,user_data);\n      } break;\n      case 'f': ftoa_bounded(va_arg(argp, JsVarFloat), buf, sizeof(buf)); user_callback(buf,user_data);  break;\n      case 's': user_callback(va_arg(argp, char *), user_data); break;\n      case 'c': buf[0]=(char)va_arg(argp, int/*char*/);buf[1]=0; user_callback(buf, user_data); break;\n      case 'q':\n      case 'Q':\n      case 'v': {\n        bool quoted = fmtChar!='v';\n        bool isJSONStyle = fmtChar=='Q';\n        if (quoted) user_callback(\"\\\"\",user_data);\n        JsVar *v = jsvAsString(va_arg(argp, JsVar*));\n        buf[1] = 0;\n        if (jsvIsString(v)) {\n          JsvStringIterator it;\n          jsvStringIteratorNew(&it, v, 0);\n          // OPT: this could be faster than it is (sending whole blocks at once)\n          while (jsvStringIteratorHasChar(&it)) {\n            buf[0] = jsvStringIteratorGetCharAndNext(&it);\n            if (quoted) {\n              user_callback(escapeCharacter(buf[0], isJSONStyle), user_data);\n            } else {\n              user_callback(buf,user_data);\n            }\n          }\n          jsvStringIteratorFree(&it);\n          jsvUnLock(v);\n        }\n        if (quoted) user_callback(\"\\\"\",user_data);\n      } break;\n      case 'j': {\n        JsVar *v = va_arg(argp, JsVar*);\n        jsfGetJSONWithCallback(v, NULL, JSON_SOME_NEWLINES | JSON_PRETTY | JSON_SHOW_DEVICES | JSON_ALLOW_TOJSON, 0, user_callback, user_data);\n        break;\n      }\n      case 't': {\n        JsVar *v = va_arg(argp, JsVar*);\n        const char *n = jsvIsNull(v)?\"null\":jswGetBasicObjectName(v);\n        if (!n) n = jsvGetTypeOf(v);\n        user_callback(n, user_data);\n        break;\n      }\n      case 'p': jshGetPinString(buf, (Pin)va_arg(argp, int/*Pin*/)); user_callback(buf, user_data); break;\n      default: assert(0); return; // eep\n      }\n    } else {\n      buf[0] = *(fmt++);\n      buf[1] = 0;\n      user_callback(&buf[0], user_data);\n    }\n  }\n}", "target": 2, "idx": 10890}
{"commit_id": "8d6ee5aad20ecf69a7f59bd8c7fb416a0db87eda", "project": "electron", "func": "content::WebUIController*\nAtomWebUIControllerFactory::CreateWebUIControllerForURL(content::WebUI* web_ui,\n                                                        const GURL& url) const {\n  if (url.host() == kPdfViewerUIHost) {\n    base::StringPairs toplevel_params;\n    base::SplitStringIntoKeyValuePairs(url.query(), '=', '&', &toplevel_params);\n    std::string stream_id, src;\n\n    const net::UnescapeRule::Type unescape_rules =\n      net::UnescapeRule::SPACES | net::UnescapeRule::PATH_SEPARATORS |\n      net::UnescapeRule::URL_SPECIAL_CHARS_EXCEPT_PATH_SEPARATORS |\n      net::UnescapeRule::REPLACE_PLUS_WITH_SPACE;\n\n    for (const auto& param : toplevel_params) {\n      if (param.first == kPdfPluginSrc) {\n        src = net::UnescapeURLComponent(param.second, unescape_rules);\n      }\n    }\n    if (url.has_ref()) {\n      src = src + '#' + url.ref();\n    }\n    auto browser_context = web_ui->GetWebContents()->GetBrowserContext();\n    return new PdfViewerUI(browser_context, web_ui, src);\n  }\n  return nullptr;\n}", "target": 1, "idx": 10891}
{"commit_id": "7417505e1d93cc95ec648b74e3c801bc67aacb9f", "project": "abrt", "func": "static gboolean key_value_ok(gchar *key, gchar *value)\n{\n    char *i;\n\n    /* check key, it has to be valid filename and will end up in the\n     * bugzilla */\n    for (i = key; *i != 0; i++)\n    {\n        if (!isalpha(*i) && (*i != '-') && (*i != '_') && (*i != ' '))\n            return FALSE;\n    }\n\n    /* check value of 'basename', it has to be valid non-hidden directory\n     * name */\n    if (strcmp(key, \"basename\") == 0\n     || strcmp(key, FILENAME_TYPE) == 0\n    )\n    {\n        if (!str_is_correct_filename(value))\n        {\n            error_msg(\"Value of '%s' ('%s') is not a valid directory name\",\n                      key, value);\n            return FALSE;\n        }\n    }\n\n    return allowed_new_user_problem_entry(client_uid, key, value);\n}", "target": 2, "idx": 10892}
{"commit_id": "086491555022b3b0ec59d26c6442a302171666ba", "project": "php/php-src", "func": "static int dynamicGetbuf (gdIOCtxPtr ctx, void *buf, int len)\n{\n\tint rlen, remain;\n\tdpIOCtxPtr dctx;\n\tdynamicPtr *dp;\n\n\tdctx = (dpIOCtxPtr) ctx;\n\tdp = dctx->dp;\n\n\tremain = dp->logicalSize - dp->pos;\n\tif (remain >= len) {\n\t\trlen = len;\n\t} else {\n\t\tif (remain <= 0) {\n\t\t\treturn EOF;\n\t\t}\n\t\trlen = remain;\n\t}\n\n\tmemcpy(buf, (void *) ((char *) dp->data + dp->pos), rlen);\n\tdp->pos += rlen;\n\n\treturn rlen;\n}", "target": 3, "idx": 10893}
{"commit_id": "94caa94fdc855d982b4f4de5a0f865a7cb734acc", "project": "openSUSE/libstorage-ng", "func": "void\n    SystemCmd::init()\n    {\n        _childStdin = NULL;\n\t_files[0] = _files[1] = NULL;\n\t_pfds[0].events = POLLOUT; // stdin\n\t_pfds[1].events = POLLIN;  // stdout\n\t_pfds[2].events = POLLIN;  // stderr\n    }", "target": 1, "idx": 10894}
{"commit_id": "1ba660b3300d67b8ce9f6b96bbae0b36fa2d6b06", "project": "gdraheim/zziplib", "func": "zzip__new__ ZZIP_DISK_FILE *\nzzip_disk_entry_fopen(ZZIP_DISK * disk, ZZIP_DISK_ENTRY * entry)\n{\n    /* keep this in sync with zzip_mem_entry_fopen */\n    struct zzip_file_header *header =\n        zzip_disk_entry_to_file_header(disk, entry);\n    if (! header)\n        return 0; /* EBADMSG */\n    ___ ZZIP_DISK_FILE *file = malloc(sizeof(ZZIP_DISK_FILE));\n    if (! file)\n        return 0; /* ENOMEM */\n    file->buffer = disk->buffer;\n    file->endbuf = disk->endbuf;\n    file->avail = zzip_file_header_usize(header);\n\n    if (! file->avail || zzip_file_header_data_stored(header))\n    { \n         file->stored = zzip_file_header_to_data (header);\n         DBG2(\"stored size %i\", (int) file->avail);\n         if (file->stored + file->avail >= disk->endbuf)\n             goto error;\n         return file; \n    }\n\n    file->stored = 0;\n    file->zlib.opaque = 0;\n    file->zlib.zalloc = Z_NULL;\n    file->zlib.zfree = Z_NULL;\n    file->zlib.avail_in = zzip_file_header_csize(header);\n    file->zlib.next_in = zzip_file_header_to_data(header);\n\n    DBG2(\"compressed size %i\", (int) file->zlib.avail_in);\n    if (file->zlib.next_in + file->zlib.avail_in >= disk->endbuf)\n         goto error;\n    if (file->zlib.next_in < disk->buffer)\n         goto error;\n\n    if (! zzip_file_header_data_deflated(header))\n        goto error;\n    if (inflateInit2(&file->zlib, -MAX_WBITS) != Z_OK)\n        goto error;\n\n    return file;\nerror:\n    free (file);\n    errno = EBADMSG;\n    return 0; \n    ____;\n}", "target": 1, "idx": 10895}
{"commit_id": "8001e9f7d17e90b4b0898ba64e3b8bbd716c513c", "project": "ffmpeg", "func": "static int get_siz(Jpeg2000DecoderContext *s)\n{\n    int i;\n    int ncomponents;\n    uint32_t log2_chroma_wh = 0;\n    const enum AVPixelFormat *possible_fmts = NULL;\n    int possible_fmts_nb = 0;\n\n    if (bytestream2_get_bytes_left(&s->g) < 36)\n        return AVERROR_INVALIDDATA;\n\n    s->avctx->profile = bytestream2_get_be16u(&s->g); // Rsiz\n    s->width          = bytestream2_get_be32u(&s->g); // Width\n    s->height         = bytestream2_get_be32u(&s->g); // Height\n    s->image_offset_x = bytestream2_get_be32u(&s->g); // X0Siz\n    s->image_offset_y = bytestream2_get_be32u(&s->g); // Y0Siz\n    s->tile_width     = bytestream2_get_be32u(&s->g); // XTSiz\n    s->tile_height    = bytestream2_get_be32u(&s->g); // YTSiz\n    s->tile_offset_x  = bytestream2_get_be32u(&s->g); // XT0Siz\n    s->tile_offset_y  = bytestream2_get_be32u(&s->g); // YT0Siz\n    ncomponents       = bytestream2_get_be16u(&s->g); // CSiz\n\n    if (s->image_offset_x || s->image_offset_y) {\n        avpriv_request_sample(s->avctx, \"Support for image offsets\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    if (ncomponents <= 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Invalid number of components: %d\\n\",\n               s->ncomponents);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (ncomponents > 4) {\n        avpriv_request_sample(s->avctx, \"Support for %d components\",\n                              s->ncomponents);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    s->ncomponents = ncomponents;\n\n    if (s->tile_width <= 0 || s->tile_height <= 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Invalid tile dimension %dx%d.\\n\",\n               s->tile_width, s->tile_height);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (bytestream2_get_bytes_left(&s->g) < 3 * s->ncomponents)\n        return AVERROR_INVALIDDATA;\n\n    for (i = 0; i < s->ncomponents; i++) { // Ssiz_i XRsiz_i, YRsiz_i\n        uint8_t x    = bytestream2_get_byteu(&s->g);\n        s->cbps[i]   = (x & 0x7f) + 1;\n        s->precision = FFMAX(s->cbps[i], s->precision);\n        s->sgnd[i]   = !!(x & 0x80);\n        s->cdx[i]    = bytestream2_get_byteu(&s->g);\n        s->cdy[i]    = bytestream2_get_byteu(&s->g);\n        if (   !s->cdx[i] || s->cdx[i] == 3 || s->cdx[i] > 4\n            || !s->cdy[i] || s->cdy[i] == 3 || s->cdy[i] > 4) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Invalid sample separation %d/%d\\n\", s->cdx[i], s->cdy[i]);\n            return AVERROR_INVALIDDATA;\n        }\n        log2_chroma_wh |= s->cdy[i] >> 1 << i * 4 | s->cdx[i] >> 1 << i * 4 + 2;\n    }\n\n    s->numXtiles = ff_jpeg2000_ceildiv(s->width  - s->tile_offset_x, s->tile_width);\n    s->numYtiles = ff_jpeg2000_ceildiv(s->height - s->tile_offset_y, s->tile_height);\n\n    if (s->numXtiles * (uint64_t)s->numYtiles > INT_MAX/sizeof(*s->tile)) {\n        s->numXtiles = s->numYtiles = 0;\n        return AVERROR(EINVAL);\n    }\n\n    s->tile = av_mallocz_array(s->numXtiles * s->numYtiles, sizeof(*s->tile));\n    if (!s->tile) {\n        s->numXtiles = s->numYtiles = 0;\n        return AVERROR(ENOMEM);\n    }\n\n    for (i = 0; i < s->numXtiles * s->numYtiles; i++) {\n        Jpeg2000Tile *tile = s->tile + i;\n\n        tile->comp = av_mallocz(s->ncomponents * sizeof(*tile->comp));\n        if (!tile->comp)\n            return AVERROR(ENOMEM);\n    }\n\n    /* compute image size with reduction factor */\n    s->avctx->width  = ff_jpeg2000_ceildivpow2(s->width  - s->image_offset_x,\n                                               s->reduction_factor);\n    s->avctx->height = ff_jpeg2000_ceildivpow2(s->height - s->image_offset_y,\n                                               s->reduction_factor);\n\n    if (s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_2K ||\n        s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_4K) {\n        possible_fmts = xyz_pix_fmts;\n        possible_fmts_nb = FF_ARRAY_ELEMS(xyz_pix_fmts);\n    } else {\n        switch (s->colour_space) {\n        case 16:\n            possible_fmts = rgb_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(rgb_pix_fmts);\n            break;\n        case 17:\n            possible_fmts = gray_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(gray_pix_fmts);\n            break;\n        case 18:\n            possible_fmts = yuv_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(yuv_pix_fmts);\n            break;\n        default:\n            possible_fmts = all_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(all_pix_fmts);\n            break;\n        }\n    }\n    for (i = 0; i < possible_fmts_nb; ++i) {\n        if (pix_fmt_match(possible_fmts[i], ncomponents, s->precision, log2_chroma_wh, s->pal8)) {\n            s->avctx->pix_fmt = possible_fmts[i];\n            break;\n        }\n    }\n    if (i == possible_fmts_nb) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"Unknown pix_fmt, profile: %d, colour_space: %d, \"\n               \"components: %d, precision: %d, \"\n               \"cdx[1]: %d, cdy[1]: %d, cdx[2]: %d, cdy[2]: %d\\n\",\n               s->avctx->profile, s->colour_space, ncomponents, s->precision,\n               ncomponents > 2 ? s->cdx[1] : 0,\n               ncomponents > 2 ? s->cdy[1] : 0,\n               ncomponents > 2 ? s->cdx[2] : 0,\n               ncomponents > 2 ? s->cdy[2] : 0);\n        return AVERROR_PATCHWELCOME;\n    }\n    s->avctx->bits_per_raw_sample = s->precision;\n    return 0;\n}", "target": 1, "idx": 10896}
{"commit_id": "879f7080d7e141f415c79eaa3a8ac4a3dad0348b", "project": "openssl", "func": "static int tree_evaluate(X509_POLICY_TREE *tree)\n{\n    int ret, i;\n    X509_POLICY_LEVEL *curr = tree->levels + 1;\n    const X509_POLICY_CACHE *cache;\n\n    for (i = 1; i < tree->nlevel; i++, curr++) {\n        cache = policy_cache_set(curr->cert);\n        if (!tree_link_nodes(curr, cache, tree))\n            return X509_PCY_TREE_INTERNAL;\n\n        if (!(curr->flags & X509_V_FLAG_INHIBIT_ANY)\n            && !tree_link_any(curr, cache, tree))\n            return X509_PCY_TREE_INTERNAL;\n#ifdef OPENSSL_POLICY_DEBUG\n        tree_print(\"before tree_prune()\", tree, curr);\n#endif\n        ret = tree_prune(tree, curr);\n        if (ret != X509_PCY_TREE_VALID)\n            return ret;\n    }\n    return X509_PCY_TREE_VALID;\n}", "target": 2, "idx": 10897}
{"commit_id": "40d373ede795443ae6f2f756e9fb1f4f4ae90bbe", "project": "wireapp/wire-avs", "func": "int ecall_start(struct ecall *ecall, enum icall_call_type call_type,\n\t\tbool audio_cbr)\n{\n\tint err;\n\n\tinfo(\"ecall(%p): start call_type=%d cbr=%d\\n\",\n\t     ecall, call_type, audio_cbr);\n\n\tif (!ecall)\n\t\treturn EINVAL;\n\n#ifdef ECALL_CBR_ALWAYS_ON\n\taudio_cbr = true;\n#endif\n\n\tif (ecall->econn) {\n\t\tif (ECONN_PENDING_INCOMING == econn_current_state(ecall->econn)) {\n\t\t\treturn ecall_answer(ecall, call_type, audio_cbr);\n\t\t}\n\t\telse {\n\t\t\twarning(\"ecall: start: already in progress (econn=%s)\\n\",\n\t\t\t\teconn_state_name(econn_current_state(ecall->econn)));\n\t\t\treturn EALREADY;\n\t\t}\n\t}\n\n#if 0\n\tif (ecall->turnc == 0) {\n\t\twarning(\"ecall: start: no TURN servers -- cannot start\\n\");\n\t\treturn EINTR;\n\t}\n#endif\n\n\tecall->call_type = call_type;\n\t\n\terr = ecall_create_econn(ecall);\n\tif (err) {\n\t\twarning(\"ecall: start: create_econn failed: %m\\n\", err);\n\t\treturn err;\n\t}\n\n\teconn_set_state(ecall_get_econn(ecall), ECONN_PENDING_OUTGOING);\n\n\terr = alloc_flow(ecall, ASYNC_OFFER, ecall->call_type, audio_cbr);\n\tif (err) {\n\t\twarning(\"ecall: start: alloc_flow failed: %m\\n\", err);\n\t\tgoto out;\n\t}\n\n\tIFLOW_CALL(ecall->flow, set_audio_cbr, audio_cbr);\n\t\n\tif (ecall->props_local &&\n\t    (call_type == ICALL_CALL_TYPE_VIDEO\n\t     && ecall->vstate == ICALL_VIDEO_STATE_STARTED)) {\n\t\tconst char *vstate_string = \"true\";\n\n\t\tint err2 = econn_props_update(ecall->props_local,\n\t\t\t\t\t      \"videosend\", vstate_string);\n\t\tif (err2) {\n\t\t\twarning(\"ecall(%p): econn_props_update(videosend)\",\n\t\t\t\t\" failed (%m)\\n\", ecall, err2);\n\t\t\t/* Non fatal, carry on */\n\t\t}\n\t}\n\n\tecall->sdp.async = ASYNC_NONE;\n\terr = generate_offer(ecall);\n\tif (err) {\n\t\twarning(\"ecall(%p): start: generate_offer\"\n\t\t\t\" failed (%m)\\n\", ecall, err);\n\t\tgoto out;\n\t}\n\n\tecall->ts_started = tmr_jiffies();\n\tecall->call_setup_time = -1;\n\n out:\n\t/* err handling */\n\treturn err;\n}", "target": 3, "idx": 10898}
{"commit_id": "efc89e3b939b4bde42c10f065f6b7b02958ed50e", "project": "containers/bubblewrap", "func": "int\nmain (int    argc,\n      char **argv)\n{\n  mode_t old_umask;\n  const char *base_path = NULL;\n  int clone_flags;\n  char *old_cwd = NULL;\n  pid_t pid;\n  int event_fd = -1;\n  int child_wait_fd = -1;\n  int setup_finished_pipe[] = {-1, -1};\n  const char *new_cwd;\n  uid_t ns_uid;\n  gid_t ns_gid;\n  struct stat sbuf;\n  uint64_t val;\n  int res UNUSED;\n  cleanup_free char *seccomp_data = NULL;\n  size_t seccomp_len;\n  struct sock_fprog seccomp_prog;\n  cleanup_free char *args_data = NULL;\n\n  /* Handle --version early on before we try to acquire/drop\n   * any capabilities so it works in a build environment;\n   * right now flatpak's build runs bubblewrap --version.\n   * https://github.com/projectatomic/bubblewrap/issues/185\n   */\n  if (argc == 2 && (strcmp (argv[1], \"--version\") == 0))\n    print_version_and_exit ();\n\n  real_uid = getuid ();\n  real_gid = getgid ();\n\n  /* Get the (optional) privileges we need */\n  acquire_privs ();\n\n  /* Never gain any more privs during exec */\n  if (prctl (PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) < 0)\n    die_with_error (\"prctl(PR_SET_NO_NEW_CAPS) failed\");\n\n  /* The initial code is run with high permissions\n     (i.e. CAP_SYS_ADMIN), so take lots of care. */\n\n  read_overflowids ();\n\n  argv0 = argv[0];\n\n  if (isatty (1))\n    host_tty_dev = ttyname (1);\n\n  argv++;\n  argc--;\n\n  if (argc == 0)\n    usage (EXIT_FAILURE, stderr);\n\n  parse_args (&argc, (const char ***) &argv);\n\n  /* suck the args into a cleanup_free variable to control their lifecycle */\n  args_data = opt_args_data;\n  opt_args_data = NULL;\n\n  if ((requested_caps[0] || requested_caps[1]) && is_privileged)\n    die (\"--cap-add in setuid mode can be used only by root\");\n\n  if (opt_userns_block_fd != -1 && !opt_unshare_user)\n    die (\"--userns-block-fd requires --unshare-user\");\n\n  if (opt_userns_block_fd != -1 && opt_info_fd == -1)\n    die (\"--userns-block-fd requires --info-fd\");\n\n  /* We have to do this if we weren't installed setuid (and we're not\n   * root), so let's just DWIM */\n  if (!is_privileged && getuid () != 0)\n    opt_unshare_user = TRUE;\n\n#ifdef ENABLE_REQUIRE_USERNS\n  /* In this build option, we require userns. */\n  if (is_privileged && getuid () != 0)\n    opt_unshare_user = TRUE;\n#endif\n\n  if (opt_unshare_user_try &&\n      stat (\"/proc/self/ns/user\", &sbuf) == 0)\n    {\n      bool disabled = FALSE;\n\n      /* RHEL7 has a kernel module parameter that lets you enable user namespaces */\n      if (stat (\"/sys/module/user_namespace/parameters/enable\", &sbuf) == 0)\n        {\n          cleanup_free char *enable = NULL;\n          enable = load_file_at (AT_FDCWD, \"/sys/module/user_namespace/parameters/enable\");\n          if (enable != NULL && enable[0] == 'N')\n            disabled = TRUE;\n        }\n\n      /* Check for max_user_namespaces */\n      if (stat (\"/proc/sys/user/max_user_namespaces\", &sbuf) == 0)\n        {\n          cleanup_free char *max_user_ns = NULL;\n          max_user_ns = load_file_at (AT_FDCWD, \"/proc/sys/user/max_user_namespaces\");\n          if (max_user_ns != NULL && strcmp(max_user_ns, \"0\\n\") == 0)\n            disabled = TRUE;\n        }\n\n      /* Debian lets you disable *unprivileged* user namespaces. However this is not\n         a problem if we're privileged, and if we're not opt_unshare_user is TRUE\n         already, and there is not much we can do, its just a non-working setup. */\n\n      if (!disabled)\n        opt_unshare_user = TRUE;\n    }\n\n  if (argc == 0)\n    usage (EXIT_FAILURE, stderr);\n\n  __debug__ ((\"Creating root mount point\\n\"));\n\n  if (opt_sandbox_uid == -1)\n    opt_sandbox_uid = real_uid;\n  if (opt_sandbox_gid == -1)\n    opt_sandbox_gid = real_gid;\n\n  if (!opt_unshare_user && opt_sandbox_uid != real_uid)\n    die (\"Specifying --uid requires --unshare-user\");\n\n  if (!opt_unshare_user && opt_sandbox_gid != real_gid)\n    die (\"Specifying --gid requires --unshare-user\");\n\n  if (!opt_unshare_uts && opt_sandbox_hostname != NULL)\n    die (\"Specifying --hostname requires --unshare-uts\");\n\n  if (opt_as_pid_1 && !opt_unshare_pid)\n    die (\"Specifying --as-pid-1 requires --unshare-pid\");\n\n  if (opt_as_pid_1 && lock_files != NULL)\n    die (\"Specifying --as-pid-1 and --lock-file is not permitted\");\n\n  /* We need to read stuff from proc during the pivot_root dance, etc.\n     Lets keep a fd to it open */\n  proc_fd = open (\"/proc\", O_PATH);\n  if (proc_fd == -1)\n    die_with_error (\"Can't open /proc\");\n\n  /* We need *some* mountpoint where we can mount the root tmpfs.\n   * Because we use pivot_root, it won't appear to be mounted from\n   * the perspective of the sandboxed process, so we can use anywhere\n   * that is sure to exist, that is sure to not be a symlink controlled\n   * by someone malicious, and that we won't immediately need to\n   * access ourselves. */\n  base_path = \"/tmp\";\n\n  __debug__ ((\"creating new namespace\\n\"));\n\n  if (opt_unshare_pid && !opt_as_pid_1)\n    {\n      event_fd = eventfd (0, EFD_CLOEXEC | EFD_NONBLOCK);\n      if (event_fd == -1)\n        die_with_error (\"eventfd()\");\n    }\n\n  /* We block sigchild here so that we can use signalfd in the monitor. */\n  block_sigchild ();\n\n  clone_flags = SIGCHLD | CLONE_NEWNS;\n  if (opt_unshare_user)\n    clone_flags |= CLONE_NEWUSER;\n  if (opt_unshare_pid)\n    clone_flags |= CLONE_NEWPID;\n  if (opt_unshare_net)\n    clone_flags |= CLONE_NEWNET;\n  if (opt_unshare_ipc)\n    clone_flags |= CLONE_NEWIPC;\n  if (opt_unshare_uts)\n    clone_flags |= CLONE_NEWUTS;\n  if (opt_unshare_cgroup)\n    {\n      if (stat (\"/proc/self/ns/cgroup\", &sbuf))\n        {\n          if (errno == ENOENT)\n            die (\"Cannot create new cgroup namespace because the kernel does not support it\");\n          else\n            die_with_error (\"stat on /proc/self/ns/cgroup failed\");\n        }\n      clone_flags |= CLONE_NEWCGROUP;\n    }\n  if (opt_unshare_cgroup_try)\n    if (!stat (\"/proc/self/ns/cgroup\", &sbuf))\n      clone_flags |= CLONE_NEWCGROUP;\n\n  child_wait_fd = eventfd (0, EFD_CLOEXEC);\n  if (child_wait_fd == -1)\n    die_with_error (\"eventfd()\");\n\n  /* Track whether pre-exec setup finished if we're reporting process exit */\n  if (opt_json_status_fd != -1)\n    {\n      int ret;\n      ret = pipe2 (setup_finished_pipe, O_CLOEXEC);\n      if (ret == -1)\n        die_with_error (\"pipe2()\");\n    }\n\n  pid = raw_clone (clone_flags, NULL);\n  if (pid == -1)\n    {\n      if (opt_unshare_user)\n        {\n          if (errno == EINVAL)\n            die (\"Creating new namespace failed, likely because the kernel does not support user namespaces.  bwrap must be installed setuid on such systems.\");\n          else if (errno == EPERM && !is_privileged)\n            die (\"No permissions to creating new namespace, likely because the kernel does not allow non-privileged user namespaces. On e.g. debian this can be enabled with 'sysctl kernel.unprivileged_userns_clone=1'.\");\n        }\n\n      die_with_error (\"Creating new namespace failed\");\n    }\n\n  ns_uid = opt_sandbox_uid;\n  ns_gid = opt_sandbox_gid;\n\n  if (pid != 0)\n    {\n      /* Parent, outside sandbox, privileged (initially) */\n\n      if (is_privileged && opt_unshare_user && opt_userns_block_fd == -1)\n        {\n          /* We're running as euid 0, but the uid we want to map is\n           * not 0. This means we're not allowed to write this from\n           * the child user namespace, so we do it from the parent.\n           *\n           * Also, we map uid/gid 0 in the namespace (to overflowuid)\n           * if opt_needs_devpts is true, because otherwise the mount\n           * of devpts fails due to root not being mapped.\n           */\n          write_uid_gid_map (ns_uid, real_uid,\n                             ns_gid, real_gid,\n                             pid, TRUE, opt_needs_devpts);\n        }\n\n      /* Initial launched process, wait for exec:ed command to exit */\n\n      /* We don't need any privileges in the launcher, drop them immediately. */\n      drop_privs (FALSE);\n\n      /* Optionally bind our lifecycle to that of the parent */\n      handle_die_with_parent ();\n\n      if (opt_info_fd != -1)\n        {\n          cleanup_free char *output = xasprintf (\"{\\n    \\\"child-pid\\\": %i\\n}\\n\", pid);\n          dump_info (opt_info_fd, output, TRUE);\n          close (opt_info_fd);\n        }\n      if (opt_json_status_fd != -1)\n        {\n          cleanup_free char *output = xasprintf (\"{ \\\"child-pid\\\": %i }\\n\", pid);\n          dump_info (opt_json_status_fd, output, TRUE);\n        }\n\n      if (opt_userns_block_fd != -1)\n        {\n          char b[1];\n          (void) TEMP_FAILURE_RETRY (read (opt_userns_block_fd, b, 1));\n          close (opt_userns_block_fd);\n        }\n\n      /* Let child run now that the uid maps are set up */\n      val = 1;\n      res = write (child_wait_fd, &val, 8);\n      /* Ignore res, if e.g. the child died and closed child_wait_fd we don't want to error out here */\n      close (child_wait_fd);\n\n      return monitor_child (event_fd, pid, setup_finished_pipe[0]);\n    }\n\n  /* Child, in sandbox, privileged in the parent or in the user namespace (if --unshare-user).\n   *\n   * Note that for user namespaces we run as euid 0 during clone(), so\n   * the child user namespace is owned by euid 0., This means that the\n   * regular user namespace parent (with uid != 0) doesn't have any\n   * capabilities in it, which is nice as we can't exploit those. In\n   * particular the parent user namespace doesn't have CAP_PTRACE\n   * which would otherwise allow the parent to hijack of the child\n   * after this point.\n   *\n   * Unfortunately this also means you can't ptrace the final\n   * sandboxed process from outside the sandbox either.\n   */\n\n  if (opt_info_fd != -1)\n    close (opt_info_fd);\n\n  if (opt_json_status_fd != -1)\n    close (opt_json_status_fd);\n\n  /* Wait for the parent to init uid/gid maps and drop caps */\n  res = read (child_wait_fd, &val, 8);\n  close (child_wait_fd);\n\n  /* At this point we can completely drop root uid, but retain the\n   * required permitted caps. This allow us to do full setup as\n   * the user uid, which makes e.g. fuse access work.\n   */\n  switch_to_user_with_privs ();\n\n  if (opt_unshare_net)\n    loopback_setup (); /* Will exit if unsuccessful */\n\n  ns_uid = opt_sandbox_uid;\n  ns_gid = opt_sandbox_gid;\n  if (!is_privileged && opt_unshare_user && opt_userns_block_fd == -1)\n    {\n      /* In the unprivileged case we have to write the uid/gid maps in\n       * the child, because we have no caps in the parent */\n\n      if (opt_needs_devpts)\n        {\n          /* This is a bit hacky, but we need to first map the real uid/gid to\n             0, otherwise we can't mount the devpts filesystem because root is\n             not mapped. Later we will create another child user namespace and\n             map back to the real uid */\n          ns_uid = 0;\n          ns_gid = 0;\n        }\n\n      write_uid_gid_map (ns_uid, real_uid,\n                         ns_gid, real_gid,\n                         -1, TRUE, FALSE);\n    }\n\n  old_umask = umask (0);\n\n  /* Need to do this before the chroot, but after we're the real uid */\n  resolve_symlinks_in_ops ();\n\n  /* Mark everything as slave, so that we still\n   * receive mounts from the real root, but don't\n   * propagate mounts to the real root. */\n  if (mount (NULL, \"/\", NULL, MS_SLAVE | MS_REC, NULL) < 0)\n    die_with_error (\"Failed to make / slave\");\n\n  /* Create a tmpfs which we will use as / in the namespace */\n  if (mount (\"tmpfs\", base_path, \"tmpfs\", MS_NODEV | MS_NOSUID, NULL) != 0)\n    die_with_error (\"Failed to mount tmpfs\");\n\n  old_cwd = get_current_dir_name ();\n\n  /* Chdir to the new root tmpfs mount. This will be the CWD during\n     the entire setup. Access old or new root via \"oldroot\" and \"newroot\". */\n  if (chdir (base_path) != 0)\n    die_with_error (\"chdir base_path\");\n\n  /* We create a subdir \"$base_path/newroot\" for the new root, that\n   * way we can pivot_root to base_path, and put the old root at\n   * \"$base_path/oldroot\". This avoids problems accessing the oldroot\n   * dir if the user requested to bind mount something over / (or\n   * over /tmp, now that we use that for base_path). */\n\n  if (mkdir (\"newroot\", 0755))\n    die_with_error (\"Creating newroot failed\");\n\n  if (mount (\"newroot\", \"newroot\", NULL, MS_MGC_VAL | MS_BIND | MS_REC, NULL) < 0)\n    die_with_error (\"setting up newroot bind\");\n\n  if (mkdir (\"oldroot\", 0755))\n    die_with_error (\"Creating oldroot failed\");\n\n  if (pivot_root (base_path, \"oldroot\"))\n    die_with_error (\"pivot_root\");\n\n  if (chdir (\"/\") != 0)\n    die_with_error (\"chdir / (base path)\");\n\n  if (is_privileged)\n    {\n      pid_t child;\n      int privsep_sockets[2];\n\n      if (socketpair (AF_UNIX, SOCK_SEQPACKET | SOCK_CLOEXEC, 0, privsep_sockets) != 0)\n        die_with_error (\"Can't create privsep socket\");\n\n      child = fork ();\n      if (child == -1)\n        die_with_error (\"Can't fork unprivileged helper\");\n\n      if (child == 0)\n        {\n          /* Unprivileged setup process */\n          drop_privs (FALSE);\n          close (privsep_sockets[0]);\n          setup_newroot (opt_unshare_pid, privsep_sockets[1]);\n          exit (0);\n        }\n      else\n        {\n          int status;\n          uint32_t buffer[2048];  /* 8k, but is int32 to guarantee nice alignment */\n          uint32_t op, flags;\n          const char *arg1, *arg2;\n          cleanup_fd int unpriv_socket = -1;\n\n          unpriv_socket = privsep_sockets[0];\n          close (privsep_sockets[1]);\n\n          do\n            {\n              op = read_priv_sec_op (unpriv_socket, buffer, sizeof (buffer),\n                                     &flags, &arg1, &arg2);\n              privileged_op (-1, op, flags, arg1, arg2);\n              if (write (unpriv_socket, buffer, 1) != 1)\n                die (\"Can't write to op_socket\");\n            }\n          while (op != PRIV_SEP_OP_DONE);\n\n          waitpid (child, &status, 0);\n          /* Continue post setup */\n        }\n    }\n  else\n    {\n      setup_newroot (opt_unshare_pid, -1);\n    }\n\n  close_ops_fd ();\n\n  /* The old root better be rprivate or we will send unmount events to the parent namespace */\n  if (mount (\"oldroot\", \"oldroot\", NULL, MS_REC | MS_PRIVATE, NULL) != 0)\n    die_with_error (\"Failed to make old root rprivate\");\n\n  if (umount2 (\"oldroot\", MNT_DETACH))\n    die_with_error (\"unmount old root\");\n\n  /* This is our second pivot. It's like we're a Silicon Valley startup flush\n   * with cash but short on ideas!\n   *\n   * We're aiming to make /newroot the real root, and get rid of /oldroot. To do\n   * that we need a temporary place to store it before we can unmount it.\n   */\n  { cleanup_fd int oldrootfd = open (\"/\", O_DIRECTORY | O_RDONLY);\n    if (oldrootfd < 0)\n      die_with_error (\"can't open /\");\n    if (chdir (\"/newroot\") != 0)\n      die_with_error (\"chdir /newroot\");\n    /* While the documentation claims that put_old must be underneath\n     * new_root, it is perfectly fine to use the same directory as the\n     * kernel checks only if old_root is accessible from new_root.\n     *\n     * Both runc and LXC are using this \"alternative\" method for\n     * setting up the root of the container:\n     *\n     * https://github.com/opencontainers/runc/blob/master/libcontainer/rootfs_linux.go#L671\n     * https://github.com/lxc/lxc/blob/master/src/lxc/conf.c#L1121\n     */\n    if (pivot_root (\".\", \".\") != 0)\n      die_with_error (\"pivot_root(/newroot)\");\n    if (fchdir (oldrootfd) < 0)\n      die_with_error (\"fchdir to oldroot\");\n    if (umount2 (\".\", MNT_DETACH) < 0)\n      die_with_error (\"umount old root\");\n    if (chdir (\"/\") != 0)\n      die_with_error (\"chdir /\");\n  }\n\n  if (opt_unshare_user &&\n      (ns_uid != opt_sandbox_uid || ns_gid != opt_sandbox_gid) &&\n      opt_userns_block_fd == -1)\n    {\n      /* Now that devpts is mounted and we've no need for mount\n         permissions we can create a new userspace and map our uid\n         1:1 */\n\n      if (unshare (CLONE_NEWUSER))\n        die_with_error (\"unshare user ns\");\n\n      write_uid_gid_map (opt_sandbox_uid, ns_uid,\n                         opt_sandbox_gid, ns_gid,\n                         -1, FALSE, FALSE);\n    }\n\n  /* All privileged ops are done now, so drop caps we don't need */\n  drop_privs (!is_privileged);\n\n  if (opt_block_fd != -1)\n    {\n      char b[1];\n      (void) TEMP_FAILURE_RETRY (read (opt_block_fd, b, 1));\n      close (opt_block_fd);\n    }\n\n  if (opt_seccomp_fd != -1)\n    {\n      seccomp_data = load_file_data (opt_seccomp_fd, &seccomp_len);\n      if (seccomp_data == NULL)\n        die_with_error (\"Can't read seccomp data\");\n\n      if (seccomp_len % 8 != 0)\n        die (\"Invalid seccomp data, must be multiple of 8\");\n\n      seccomp_prog.len = seccomp_len / 8;\n      seccomp_prog.filter = (struct sock_filter *) seccomp_data;\n\n      close (opt_seccomp_fd);\n    }\n\n  umask (old_umask);\n\n  new_cwd = \"/\";\n  if (opt_chdir_path)\n    {\n      if (chdir (opt_chdir_path))\n        die_with_error (\"Can't chdir to %s\", opt_chdir_path);\n      new_cwd = opt_chdir_path;\n    }\n  else if (chdir (old_cwd) == 0)\n    {\n      /* If the old cwd is mapped in the sandbox, go there */\n      new_cwd = old_cwd;\n    }\n  else\n    {\n      /* If the old cwd is not mapped, go to home */\n      const char *home = getenv (\"HOME\");\n      if (home != NULL &&\n          chdir (home) == 0)\n        new_cwd = home;\n    }\n  xsetenv (\"PWD\", new_cwd, 1);\n  free (old_cwd);\n\n  if (opt_new_session &&\n      setsid () == (pid_t) -1)\n    die_with_error (\"setsid\");\n\n  if (label_exec (opt_exec_label) == -1)\n    die_with_error (\"label_exec %s\", argv[0]);\n\n  __debug__ ((\"forking for child\\n\"));\n\n  if (!opt_as_pid_1 && (opt_unshare_pid || lock_files != NULL || opt_sync_fd != -1))\n    {\n      /* We have to have a pid 1 in the pid namespace, because\n       * otherwise we'll get a bunch of zombies as nothing reaps\n       * them. Alternatively if we're using sync_fd or lock_files we\n       * need some process to own these.\n       */\n\n      pid = fork ();\n      if (pid == -1)\n        die_with_error (\"Can't fork for pid 1\");\n\n      if (pid != 0)\n        {\n          drop_all_caps (FALSE);\n\n          /* Close fds in pid 1, except stdio and optionally event_fd\n             (for syncing pid 2 lifetime with monitor_child) and\n             opt_sync_fd (for syncing sandbox lifetime with outside\n             process).\n             Any other fds will been passed on to the child though. */\n          {\n            int dont_close[3];\n            int j = 0;\n            if (event_fd != -1)\n              dont_close[j++] = event_fd;\n            if (opt_sync_fd != -1)\n              dont_close[j++] = opt_sync_fd;\n            dont_close[j++] = -1;\n            fdwalk (proc_fd, close_extra_fds, dont_close);\n          }\n\n          return do_init (event_fd, pid, seccomp_data != NULL ? &seccomp_prog : NULL);\n        }\n    }\n\n  __debug__ ((\"launch executable %s\\n\", argv[0]));\n\n  if (proc_fd != -1)\n    close (proc_fd);\n\n  /* If we are using --as-pid-1 leak the sync fd into the sandbox.\n     --sync-fd will still work unless the container process doesn't close this file.  */\n  if (!opt_as_pid_1)\n    {\n      if (opt_sync_fd != -1)\n        close (opt_sync_fd);\n    }\n\n  /* We want sigchild in the child */\n  unblock_sigchild ();\n\n  /* Optionally bind our lifecycle */\n  handle_die_with_parent ();\n\n  if (!is_privileged)\n    set_ambient_capabilities ();\n\n  /* Should be the last thing before execve() so that filters don't\n   * need to handle anything above */\n  if (seccomp_data != NULL &&\n      prctl (PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &seccomp_prog) != 0)\n    die_with_error (\"prctl(PR_SET_SECCOMP)\");\n\n  if (setup_finished_pipe[1] != -1)\n    {\n      char data = 0;\n      res = write_to_fd (setup_finished_pipe[1], &data, 1);\n      /* Ignore res, if e.g. the parent died and closed setup_finished_pipe[0]\n         we don't want to error out here */\n    }\n\n  if (execvp (argv[0], argv) == -1)\n    {\n      if (setup_finished_pipe[1] != -1)\n        {\n          int saved_errno = errno;\n          char data = 0;\n          res = write_to_fd (setup_finished_pipe[1], &data, 1);\n          errno = saved_errno;\n          /* Ignore res, if e.g. the parent died and closed setup_finished_pipe[0]\n             we don't want to error out here */\n        }\n      die_with_error (\"execvp %s\", argv[0]);\n    }\n\n  return 0;\n}", "target": 2, "idx": 10899}
{"commit_id": "e2ac765a25e902728b6d4a825358aa536e6668c2", "project": "appneta/tcpreplay", "func": "int\ntcpedit_packet(tcpedit_t *tcpedit, struct pcap_pkthdr **pkthdr,\n        u_char **pktdata, tcpr_dir_t direction)\n{\n    bool fuzz_once = tcpedit->fuzz_seed != 0;\n    ipv4_hdr_t *ip_hdr;\n    ipv6_hdr_t *ip6_hdr;\n    arp_hdr_t *arp_hdr;\n    int l2len, l2proto, retval;\n    int dst_dlt, src_dlt, pktlen, lendiff;\n    int ipflags, tclass;\n    int needtorecalc;           /* did the packet change? if so, checksum */\n    u_char *packet;\n\n\n    assert(tcpedit);\n    assert(pkthdr);\n    assert(*pkthdr);\n    assert(pktdata);\n    assert(*pktdata);\n    assert(tcpedit->validated);\n\n    packet = *pktdata;\n\n    tcpedit->runtime.packetnum++;\n\n    dbgx(3, \"packet \" COUNTER_SPEC \" caplen %d\", \n            tcpedit->runtime.packetnum, (*pkthdr)->caplen);\n\n    /*\n     * remove the Ethernet FCS (checksum)?\n     * note that this feature requires the end user to be smart and\n     * only set this flag IFF the pcap has the FCS.  If not, then they\n     * just removed 2 bytes of ACTUAL PACKET DATA.  Sucks to be them.\n     */\n    if (tcpedit->efcs > 0 &&(*pkthdr)->len > 4) {\n        if ((*pkthdr)->caplen == (*pkthdr)->len) {\n            (*pkthdr)->caplen -= 4;\n        }\n\n        (*pkthdr)->len -= 4;\n    }\n\n    src_dlt = tcpedit_dlt_src(tcpedit->dlt_ctx);\n    \n    needtorecalc = 0;\nagain:\n    ip_hdr = NULL;\n    ip6_hdr = NULL;\n    arp_hdr = NULL;\n    retval = 0;\n    ipflags = 0;\n    tclass = 0;\n    /* not everything has a L3 header, so check for errors.  returns proto in network byte order */\n    if ((l2proto = tcpedit_dlt_proto(tcpedit->dlt_ctx, src_dlt, packet, (*pkthdr)->caplen)) < 0) {\n        dbgx(2, \"Packet has no L3+ header: %s\", tcpedit_geterr(tcpedit));\n        return TCPEDIT_SOFT_ERROR;\n    } else {\n        dbgx(2, \"Layer 3 protocol type is: 0x%04x\", ntohs(l2proto));\n    }\n        \n    /* rewrite Layer 2 */\n    if ((pktlen = tcpedit_dlt_process(tcpedit->dlt_ctx, pktdata, (*pkthdr)->caplen, direction)) < 0) {\n        /* unable to edit packet, most likely 802.11 management or data QoS frame */\n        dbgx(3, \"Failed to edit DLT: %s\", tcpedit_geterr(tcpedit));\n        return TCPEDIT_SOFT_ERROR;\n    }\n\n    /* update our packet lengths (real/captured) based on L2 length changes */\n    lendiff = pktlen - (*pkthdr)->caplen;\n    (*pkthdr)->caplen += lendiff;\n    (*pkthdr)->len += lendiff;\n    \n    dst_dlt = tcpedit_dlt_dst(tcpedit->dlt_ctx);\n    l2len = tcpedit_dlt_l2len(tcpedit->dlt_ctx, dst_dlt, packet, (*pkthdr)->caplen);\n    if (l2len == -1)\n        return TCPEDIT_SOFT_ERROR;\n\n    dbgx(2, \"dst_dlt = %04x\\tsrc_dlt = %04x\\tproto = %04x\\tl2len = %d\", dst_dlt, src_dlt, ntohs(l2proto), l2len);\n\n    /* does packet have an IP header?  if so set our pointer to it */\n    if (l2proto == htons(ETHERTYPE_IP)) {\n        u_char *p;\n\n        if ((*pkthdr)->caplen < l2len + sizeof(*ip_hdr)) {\n            tcpedit_seterr(tcpedit, \"Packet length %d is too short to contain a layer IP header for DLT 0x%04x\",\n                    pktlen, dst_dlt);\n            return TCPEDIT_SOFT_ERROR;\n        }\n\n        ip_hdr = (ipv4_hdr_t *)tcpedit_dlt_l3data(tcpedit->dlt_ctx, dst_dlt, packet, (*pkthdr)->caplen);\n        if (ip_hdr == NULL)\n            return TCPEDIT_SOFT_ERROR;\n\n        p = get_layer4_v4(ip_hdr, (*pkthdr)->caplen - l2len);\n        if (!p) {\n            tcpedit_seterr(tcpedit, \"Packet length %d is too short to contain a layer %d byte IP header for DLT 0x%04x\",\n                    pktlen, ip_hdr->ip_hl << 2,  dst_dlt);\n            return TCPEDIT_SOFT_ERROR;\n        }\n\n        dbgx(3, \"Packet has an IPv4 header: 0x%p...\", ip_hdr);\n    } else if (l2proto == htons(ETHERTYPE_IP6)) {\n        u_char *p;\n\n        if ((*pkthdr)->caplen < l2len + sizeof(*ip6_hdr)) {\n            tcpedit_seterr(tcpedit, \"Packet length %d is too short to contain a layer IPv6 header for DLT 0x%04x\",\n                    pktlen, dst_dlt);\n            return TCPEDIT_SOFT_ERROR;\n        }\n\n        ip6_hdr = (ipv6_hdr_t *)tcpedit_dlt_l3data(tcpedit->dlt_ctx, dst_dlt, packet, (*pkthdr)->caplen);\n        if (ip6_hdr == NULL)\n            return TCPEDIT_SOFT_ERROR;\n\n        p = get_layer4_v6(ip6_hdr, (*pkthdr)->caplen - l2len);\n        if (!p) {\n            tcpedit_seterr(tcpedit, \"Packet length %d is too short to contain an IPv6 header for DLT 0x%04x\",\n                    pktlen, dst_dlt);\n            return TCPEDIT_SOFT_ERROR;\n        }\n\n        dbgx(3, \"Packet has an IPv6 header: 0x%p...\", ip6_hdr);\n    } else {\n        dbgx(3, \"Packet isn't IPv4 or IPv6: 0x%04x\", l2proto);\n        /* non-IP packets have a NULL ip_hdr struct */\n        ip_hdr = NULL;\n        ip6_hdr = NULL;\n    }\n\n    /* The following edits only apply for IPv4 */\n    if (ip_hdr != NULL) {\n\n        /* set TOS ? */\n        if (tcpedit->tos > -1) {\n            volatile uint16_t oldval = *((uint16_t*)ip_hdr);\n            volatile uint16_t newval;\n\n            ip_hdr->ip_tos = tcpedit->tos;\n            newval = *((uint16_t*)ip_hdr);\n            csum_replace2(&ip_hdr->ip_sum, oldval, newval);\n        }\n\n        /* rewrite the TTL */\n        needtorecalc += rewrite_ipv4_ttl(tcpedit, ip_hdr);\n\n        /* rewrite TCP/UDP ports */\n        if (tcpedit->portmap != NULL) {\n            if ((retval = rewrite_ipv4_ports(tcpedit, &ip_hdr,\n                    (*pkthdr)->caplen - l2len)) < 0)\n                return TCPEDIT_ERROR;\n            needtorecalc += retval;\n        }\n\n        if (tcpedit->tcp_sequence_enable)\n            rewrite_ipv4_tcp_sequence(tcpedit, &ip_hdr,\n                    (*pkthdr)->caplen - l2len);\n    }\n\n    /* IPv6 edits */\n    else if (ip6_hdr != NULL) {\n        /* rewrite the hop limit */\n        needtorecalc += rewrite_ipv6_hlim(tcpedit, ip6_hdr);\n\n        /* set traffic class? */\n        if (tcpedit->tclass > -1) {\n            /* calculate the bits */\n            tclass = tcpedit->tclass << 20;\n            \n            /* convert our 4 bytes to an int */\n            memcpy(&ipflags, &ip6_hdr->ip_flags, 4);\n            \n            /* strip out the old tclass bits */\n            ipflags = ntohl(ipflags) & 0xf00fffff;\n\n            /* add the tclass bits back */\n            ipflags += tclass; \n            ipflags = htonl(ipflags);\n            memcpy(&ip6_hdr->ip_flags, &ipflags, 4);\n        }\n\n        /* set the flow label? */\n        if (tcpedit->flowlabel > -1) {\n            memcpy(&ipflags, &ip6_hdr->ip_flags, 4);\n            ipflags = ntohl(ipflags) & 0xfff00000;\n            ipflags += tcpedit->flowlabel;\n            ipflags = htonl(ipflags);\n            memcpy(&ip6_hdr->ip_flags, &ipflags, 4);\n        }\n\n        /* rewrite TCP/UDP ports */\n        if (tcpedit->portmap != NULL) {\n            if ((retval = rewrite_ipv6_ports(tcpedit, &ip6_hdr,\n                    (*pkthdr)->caplen - l2len)) < 0)\n                return TCPEDIT_ERROR;\n            needtorecalc += retval;\n        }\n\n        if (tcpedit->tcp_sequence_enable)\n            rewrite_ipv6_tcp_sequence(tcpedit, &ip6_hdr, (*pkthdr)->caplen - l2len);\n    }\n\n    if (fuzz_once) {\n        fuzz_once = false;\n        retval = fuzzing(tcpedit, *pkthdr, pktdata);\n        if (retval < 0) {\n            return TCPEDIT_ERROR;\n        }\n        needtorecalc += retval;\n        goto again;\n    }\n\n    /* (Un)truncate or MTU truncate packet? */\n    if (tcpedit->fixlen || tcpedit->mtu_truncate) {\n        if ((retval = untrunc_packet(tcpedit, *pkthdr, pktdata, ip_hdr, ip6_hdr)) < 0)\n            return TCPEDIT_ERROR;\n        needtorecalc += retval;\n    }\n    \n    /* rewrite IP addresses in IPv4/IPv6 or ARP */\n    if (tcpedit->rewrite_ip) {\n        /* IP packets */\n        if (ip_hdr != NULL) {\n            if ((retval = rewrite_ipv4l3(tcpedit, ip_hdr, direction,\n                    (*pkthdr)->caplen - l2len)) < 0)\n                return TCPEDIT_ERROR;\n            needtorecalc += retval;\n        } else if (ip6_hdr != NULL) {\n            if ((retval = rewrite_ipv6l3(tcpedit, ip6_hdr, direction,\n                    (*pkthdr)->caplen - l2len)) < 0)\n                return TCPEDIT_ERROR;\n            needtorecalc += retval;\n        }\n\n        /* ARP packets */\n        else if (l2proto == htons(ETHERTYPE_ARP)) {\n            arp_hdr = (arp_hdr_t *)&(packet[l2len]);\n            /* unlike, rewrite_ipl3, we don't care if the packet changed\n             * because we never need to recalc the checksums for an ARP\n             * packet.  So ignore the return value\n             */\n            if (rewrite_iparp(tcpedit, arp_hdr, direction) < 0)\n                return TCPEDIT_ERROR;\n        }\n    }\n\n\n    /* do we need to spoof the src/dst IP address in IPv4 or ARP? */\n    if (tcpedit->seed) {\n        /* IPv4 Packets */\n        if (ip_hdr != NULL) {\n            if ((retval = randomize_ipv4(tcpedit, *pkthdr, packet, \n                    ip_hdr, (*pkthdr)->caplen - l2len)) < 0)\n                return TCPEDIT_ERROR;\n            needtorecalc += retval;\n\n        } else if (ip6_hdr != NULL) {\n            if ((retval = randomize_ipv6(tcpedit, *pkthdr, packet,\n                    ip6_hdr, (*pkthdr)->caplen - l2len)) < 0)\n                return TCPEDIT_ERROR;\n            needtorecalc += retval;\n\n        /* ARP packets */\n        } else if (l2proto == htons(ETHERTYPE_ARP)) {\n            if (direction == TCPR_DIR_C2S) {\n                if (randomize_iparp(tcpedit, *pkthdr, packet, \n                        tcpedit->runtime.dlt1, (*pkthdr)->caplen - l2len) < 0)\n                    return TCPEDIT_ERROR;\n            } else {\n                if (randomize_iparp(tcpedit, *pkthdr, packet, \n                        tcpedit->runtime.dlt2, (*pkthdr)->caplen - l2len) < 0)\n                    return TCPEDIT_ERROR;\n            }\n        }\n    }\n\n    /* do we need to fix checksums? -- must always do this last! */\n    if ((tcpedit->fixcsum || needtorecalc)) {\n        if (ip_hdr != NULL) {\n            dbgx(3, \"doing IPv4 checksum: needtorecalc=%d\", needtorecalc);\n            retval = fix_ipv4_checksums(tcpedit, *pkthdr, ip_hdr, l2len);\n        } else if (ip6_hdr != NULL) {\n            dbgx(3, \"doing IPv6 checksum: needtorecalc=%d\", needtorecalc);\n            retval = fix_ipv6_checksums(tcpedit, *pkthdr, ip6_hdr, l2len);\n        } else {\n            dbgx(3, \"checksum not performed: needtorecalc=%d\", needtorecalc);\n            retval = TCPEDIT_OK;\n        }\n        if (retval < 0) {\n            return TCPEDIT_ERROR;\n        } else if (retval == TCPEDIT_WARN) {\n            warnx(\"%s\", tcpedit_getwarn(tcpedit));\n        }\n    }\n\n    tcpedit_dlt_merge_l3data(tcpedit->dlt_ctx,\n                             dst_dlt, packet,\n                             (*pkthdr)->caplen,\n                             (u_char*)ip_hdr,\n                             (u_char*)ip6_hdr);\n\n    tcpedit->runtime.total_bytes += (*pkthdr)->caplen;\n    tcpedit->runtime.pkts_edited ++;\n    return retval;\n}", "target": 2, "idx": 10900}
{"commit_id": "08278c7cf1c0b4f1da4cdcfaa857ff6b2373a1b2", "project": "ImageMagick", "func": "static void MSLPopImage(MSLInfo *msl_info)\n{\n  if (msl_info->number_groups != 0)\n    return;\n  if (msl_info->image[msl_info->n] != (Image *) NULL)\n    msl_info->image[msl_info->n]=DestroyImage(msl_info->image[msl_info->n]);\n  msl_info->attributes[msl_info->n]=DestroyImage(\n    msl_info->attributes[msl_info->n]);\n  msl_info->draw_info[msl_info->n]=DestroyDrawInfo(\n    msl_info->draw_info[msl_info->n]);\n  msl_info->image_info[msl_info->n]=DestroyImageInfo(\n    msl_info->image_info[msl_info->n]);\n  msl_info->n--;\n}", "target": 1, "idx": 10901}
{"commit_id": "c7153361a4041260719b340f73f2f76", "project": "vadz/libtiff", "func": "tsize_t t2p_readwrite_pdf_image_tile(T2P* t2p, TIFF* input, TIFF* output, ttile_t tile){\n\n\tuint16 edge=0;\n\ttsize_t written=0;\n\tunsigned char* buffer=NULL;\n\ttsize_t bufferoffset=0;\n\tunsigned char* samplebuffer=NULL;\n\ttsize_t samplebufferoffset=0;\n\ttsize_t read=0;\n\tuint16 i=0;\n\tttile_t tilecount=0;\n\t/* tsize_t tilesize=0; */\n\tttile_t septilecount=0;\n\ttsize_t septilesize=0;\n#ifdef JPEG_SUPPORT\n\tunsigned char* jpt;\n\tfloat* xfloatp;\n\tuint32 xuint32=0;\n#endif\n\n\t/* Fail if prior error (in particular, can't trust tiff_datasize) */\n\tif (t2p->t2p_error != T2P_ERR_OK)\n\t\treturn(0);\n\n\tedge |= t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile);\n\tedge |= t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile);\n\n\tif( (t2p->pdf_transcode == T2P_TRANSCODE_RAW) && ((edge == 0)\n#if defined(JPEG_SUPPORT) || defined(OJPEG_SUPPORT)\n\t\t|| (t2p->pdf_compression == T2P_COMPRESS_JPEG)\n#endif\n\t)\n\t){\n#ifdef CCITT_SUPPORT\n\t\tif(t2p->pdf_compression == T2P_COMPRESS_G4){\n\t\t\tbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tTIFFReadRawTile(input, tile, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\tif (t2p->tiff_fillorder==FILLORDER_LSB2MSB){\n\t\t\t\t\tTIFFReverseBits(buffer, t2p->tiff_datasize);\n\t\t\t}\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(t2p->tiff_datasize);\n\t\t}\n#endif\n#ifdef ZIP_SUPPORT\n\t\tif(t2p->pdf_compression == T2P_COMPRESS_ZIP){\n\t\t\tbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tTIFFReadRawTile(input, tile, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\tif (t2p->tiff_fillorder==FILLORDER_LSB2MSB){\n\t\t\t\t\tTIFFReverseBits(buffer, t2p->tiff_datasize);\n\t\t\t}\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(t2p->tiff_datasize);\n\t\t}\n#endif\n#ifdef OJPEG_SUPPORT\n\t\tif(t2p->tiff_compression == COMPRESSION_OJPEG){\n\t\t\tif(! t2p->pdf_ojpegdata){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"No support for OJPEG image %s with \"\n                                        \"bad tables\", \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tbuffer=(unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\t_TIFFmemcpy(buffer, t2p->pdf_ojpegdata, t2p->pdf_ojpegdatalength);\n\t\t\tif(edge!=0){\n\t\t\t\tif(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile)){\n\t\t\t\t\tbuffer[7]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength >> 8) & 0xff;\n\t\t\t\t\tbuffer[8]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength ) & 0xff;\n\t\t\t\t}\n\t\t\t\tif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile)){\n\t\t\t\t\tbuffer[9]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth >> 8) & 0xff;\n\t\t\t\t\tbuffer[10]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth ) & 0xff;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbufferoffset=t2p->pdf_ojpegdatalength;\n\t\t\tbufferoffset+=TIFFReadRawTile(input, \n\t\t\t\t\ttile, \n\t\t\t\t\t(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), \n\t\t\t\t\t-1);\n\t\t\t((unsigned char*)buffer)[bufferoffset++]=0xff;\n\t\t\t((unsigned char*)buffer)[bufferoffset++]=0xd9;\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, bufferoffset);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(bufferoffset);\n\t\t}\n#endif\n#ifdef JPEG_SUPPORT\n\t\tif(t2p->tiff_compression == COMPRESSION_JPEG){\n\t\t\tunsigned char table_end[2];\n\t\t\tuint32 count = 0;\n\t\t\tbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate \" TIFF_SIZE_FORMAT \" bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n                                          (TIFF_SIZE_T) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tif(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0) {\n\t\t\t\tif (count > 4) {\n                                        int retTIFFReadRawTile;\n                    /* Ignore EOI marker of JpegTables */\n\t\t\t\t\t_TIFFmemcpy(buffer, jpt, count - 2);\n\t\t\t\t\tbufferoffset += count - 2;\n                    /* Store last 2 bytes of the JpegTables */\n\t\t\t\t\ttable_end[0] = buffer[bufferoffset-2];\n\t\t\t\t\ttable_end[1] = buffer[bufferoffset-1];\n\t\t\t\t\txuint32 = bufferoffset;\n                                        bufferoffset -= 2;\n                                        retTIFFReadRawTile= TIFFReadRawTile(\n\t\t\t\t\t\tinput, \n\t\t\t\t\t\ttile, \n\t\t\t\t\t\t(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), \n\t\t\t\t\t\t-1);\n                                        if( retTIFFReadRawTile < 0 )\n                                        {\n                                            _TIFFfree(buffer);\n                                            t2p->t2p_error = T2P_ERR_ERROR;\n                                            return(0);\n                                        }\n\t\t\t\t\tbufferoffset += retTIFFReadRawTile;\n                    /* Overwrite SOI marker of image scan with previously */\n                    /* saved end of JpegTables */\n\t\t\t\t\tbuffer[xuint32-2]=table_end[0];\n\t\t\t\t\tbuffer[xuint32-1]=table_end[1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, bufferoffset);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(bufferoffset);\n\t\t}\n#endif\n\t\t(void)0;\n\t}\n\n\tif(t2p->pdf_sample==T2P_SAMPLE_NOTHING){\n\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\tif(buffer==NULL){\n\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\"Can't allocate %lu bytes of memory for \"\n                                \"t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\tTIFFFileName(input));\n\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\treturn(0);\n\t\t}\n\n\t\tread = TIFFReadEncodedTile(\n\t\t\tinput, \n\t\t\ttile, \n\t\t\t(tdata_t) &buffer[bufferoffset], \n\t\t\tt2p->tiff_datasize);\n\t\tif(read==-1){\n\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\"Error on decoding tile %u of %s\", \n\t\t\t\ttile, \n\t\t\t\tTIFFFileName(input));\n\t\t\t_TIFFfree(buffer);\n\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\n\t\t\treturn(0);\n\t\t}\n\n\t} else {\n\n\t\tif(t2p->pdf_sample == T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG){\n\t\t\tseptilesize=TIFFTileSize(input);\n\t\t\tseptilecount=TIFFNumberOfTiles(input);\n\t\t\t/* tilesize=septilesize*t2p->tiff_samplesperpixel; */\n\t\t\ttilecount=septilecount/t2p->tiff_samplesperpixel;\n\t\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tsamplebuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(samplebuffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tsamplebufferoffset=0;\n\t\t\tfor(i=0;i<t2p->tiff_samplesperpixel;i++){\n\t\t\t\tread = \n\t\t\t\t\tTIFFReadEncodedTile(input, \n\t\t\t\t\t\ttile + i*tilecount, \n\t\t\t\t\t\t(tdata_t) &(samplebuffer[samplebufferoffset]), \n\t\t\t\t\t\tseptilesize);\n\t\t\t\tif(read==-1){\n\t\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\t\"Error on decoding tile %u of %s\", \n\t\t\t\t\t\ttile + i*tilecount, \n\t\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t\t\t_TIFFfree(samplebuffer);\n\t\t\t\t\t\t_TIFFfree(buffer);\n\t\t\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t\tsamplebufferoffset+=read;\n\t\t\t}\n\t\t\tt2p_sample_planar_separate_to_contig(\n\t\t\t\tt2p,\n\t\t\t\t&(buffer[bufferoffset]),\n\t\t\t\tsamplebuffer, \n\t\t\t\tsamplebufferoffset); \n\t\t\tbufferoffset+=samplebufferoffset;\n\t\t\t_TIFFfree(samplebuffer);\n\t\t}\n\n\t\tif(buffer==NULL){\n\t\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tread = TIFFReadEncodedTile(\n\t\t\t\tinput, \n\t\t\t\ttile, \n\t\t\t\t(tdata_t) &buffer[bufferoffset], \n\t\t\t\tt2p->tiff_datasize);\n\t\t\tif(read==-1){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Error on decoding tile %u of %s\", \n\t\t\t\t\ttile, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t_TIFFfree(buffer);\n\t\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_RGBA_TO_RGB){\n\t\t\tt2p->tiff_datasize=t2p_sample_rgba_to_rgb(\n\t\t\t\t(tdata_t)buffer, \n\t\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth\n\t\t\t\t*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_RGBAA_TO_RGB){\n\t\t\tt2p->tiff_datasize=t2p_sample_rgbaa_to_rgb(\n\t\t\t\t(tdata_t)buffer, \n\t\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth\n\t\t\t\t*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_YCBCR_TO_RGB){\n\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\"No support for YCbCr to RGB in tile for %s\", \n\t\t\t\tTIFFFileName(input));\n\t\t\t_TIFFfree(buffer);\n\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\treturn(0);\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED){\n\t\t\tt2p->tiff_datasize=t2p_sample_lab_signed_to_unsigned(\n\t\t\t\t(tdata_t)buffer, \n\t\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth\n\t\t\t\t*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t\t}\n\t}\n\n\tif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile) != 0){\n\t\tt2p_tile_collapse_left(\n\t\t\tbuffer, \n\t\t\tTIFFTileRowSize(input),\n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth,\n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t}\n\n\n\tt2p_disable(output);\n\tTIFFSetField(output, TIFFTAG_PHOTOMETRIC, t2p->tiff_photometric);\n\tTIFFSetField(output, TIFFTAG_BITSPERSAMPLE, t2p->tiff_bitspersample);\n\tTIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, t2p->tiff_samplesperpixel);\n\tif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile) == 0){\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_IMAGEWIDTH, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth);\n\t} else {\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_IMAGEWIDTH, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth);\n\t}\n\tif(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile) == 0){\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_IMAGELENGTH, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_ROWSPERSTRIP, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t} else {\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_IMAGELENGTH, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_ROWSPERSTRIP, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);\n\t}\n\tTIFFSetField(output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\tTIFFSetField(output, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n\n\tswitch(t2p->pdf_compression){\n\tcase T2P_COMPRESS_NONE:\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\t\tbreak;\n#ifdef CCITT_SUPPORT\n\tcase T2P_COMPRESS_G4:\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX4);\n\t\tbreak;\n#endif\n#ifdef JPEG_SUPPORT\n\tcase T2P_COMPRESS_JPEG:\n\t\tif (t2p->tiff_photometric==PHOTOMETRIC_YCBCR) {\n\t\t\tuint16 hor = 0, ver = 0;\n\t\t\tif (TIFFGetField(input, TIFFTAG_YCBCRSUBSAMPLING, &hor, &ver)!=0) {\n\t\t\t\tif (hor != 0 && ver != 0) {\n\t\t\t\t\tTIFFSetField(output, TIFFTAG_YCBCRSUBSAMPLING, hor, ver);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(TIFFGetField(input, TIFFTAG_REFERENCEBLACKWHITE, &xfloatp)!=0){\n\t\t\t\tTIFFSetField(output, TIFFTAG_REFERENCEBLACKWHITE, xfloatp);\n\t\t\t}\n\t\t}\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);\n\t\tTIFFSetField(output, TIFFTAG_JPEGTABLESMODE, 0); /* JPEGTABLESMODE_NONE */\n\t\tif(t2p->pdf_colorspace & (T2P_CS_RGB | T2P_CS_LAB)){\n\t\t\tTIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);\n\t\t\tif(t2p->tiff_photometric != PHOTOMETRIC_YCBCR){\n\t\t\t\tTIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n\t\t\t} else {\n\t\t\t\tTIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RAW);\n\t\t\t}\n\t\t}\n\t\tif(t2p->pdf_colorspace & T2P_CS_GRAY){\n\t\t\t(void)0;\n\t\t}\n\t\tif(t2p->pdf_colorspace & T2P_CS_CMYK){\n\t\t\t(void)0;\n\t\t}\n\t\tif(t2p->pdf_defaultcompressionquality != 0){\n\t\t\tTIFFSetField(output, \n\t\t\t\tTIFFTAG_JPEGQUALITY, \n\t\t\t\tt2p->pdf_defaultcompressionquality);\n\t\t}\n\t\tbreak;\n#endif\n#ifdef ZIP_SUPPORT\n\tcase T2P_COMPRESS_ZIP:\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\n\t\tif(t2p->pdf_defaultcompressionquality%100 != 0){\n\t\t\tTIFFSetField(output, \n\t\t\t\tTIFFTAG_PREDICTOR, \n\t\t\t\tt2p->pdf_defaultcompressionquality % 100);\n\t\t}\n\t\tif(t2p->pdf_defaultcompressionquality/100 != 0){\n\t\t\tTIFFSetField(output, \n\t\t\t\tTIFFTAG_ZIPQUALITY, \n\t\t\t\t(t2p->pdf_defaultcompressionquality / 100));\n\t\t}\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\n\tt2p_enable(output);\n\tt2p->outputwritten = 0;\n\tbufferoffset = TIFFWriteEncodedStrip(output, (tstrip_t) 0, buffer,\n\t\t\t\t\t     TIFFStripSize(output)); \n\tif (buffer != NULL) {\n\t\t_TIFFfree(buffer);\n\t\tbuffer = NULL;\n\t}\n\tif (bufferoffset == -1) {\n\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t  \"Error writing encoded tile to output PDF %s\", \n\t\t\t  TIFFFileName(output));\n\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\treturn(0);\n\t}\n\t\n\twritten = t2p->outputwritten;\n\t\n\treturn(written);\n}", "target": 2, "idx": 10902}
{"commit_id": "96df3106d49438e442510c59acad306e94f3db4d", "project": "xkbcommon/libxkbcommon", "func": "static bool\nResolveStateAndPredicate(ExprDef *expr, enum xkb_match_operation *pred_rtrn,\n                         xkb_mod_mask_t *mods_rtrn, CompatInfo *info)\n{\n    if (expr == NULL) {\n        *pred_rtrn = MATCH_ANY_OR_NONE;\n        *mods_rtrn = MOD_REAL_MASK_ALL;\n        return true;\n    }\n\n    *pred_rtrn = MATCH_EXACTLY;\n    if (expr->expr.op == EXPR_ACTION_DECL) {\n        const char *pred_txt = xkb_atom_text(info->ctx, expr->action.name);\n        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn) ||\n            !expr->action.args) {\n            log_err(info->ctx,\n                    \"Illegal modifier predicate \\\"%s\\\"; Ignored\\n\", pred_txt);\n            return false;\n        }\n        expr = expr->action.args;\n    }\n    else if (expr->expr.op == EXPR_IDENT) {\n        const char *pred_txt = xkb_atom_text(info->ctx, expr->ident.ident);\n        if (pred_txt && istreq(pred_txt, \"any\")) {\n            *pred_rtrn = MATCH_ANY;\n            *mods_rtrn = MOD_REAL_MASK_ALL;\n            return true;\n        }\n    }\n\n    return ExprResolveModMask(info->ctx, expr, MOD_REAL, &info->mods,\n                              mods_rtrn);\n}", "target": 1, "idx": 10903}
{"commit_id": "08681391b84da27133deefaaddefd0acfa90c2be", "project": "torvalds/linux", "func": "static inline struct file *io_file_get_fixed(struct io_ring_ctx *ctx,\n\t\t\t\t\t     struct io_kiocb *req, int fd,\n\t\t\t\t\t     unsigned int issue_flags)\n{\n\tstruct file *file = NULL;\n\tunsigned long file_ptr;\n\n\tio_ring_submit_lock(ctx, !(issue_flags & IO_URING_F_NONBLOCK));\n\n\tif (unlikely((unsigned int)fd >= ctx->nr_user_files))\n\t\tgoto out;\n\tfd = array_index_nospec(fd, ctx->nr_user_files);\n\tfile_ptr = io_fixed_file_slot(&ctx->file_table, fd)->file_ptr;\n\tfile = (struct file *) (file_ptr & FFS_MASK);\n\tfile_ptr &= ~FFS_MASK;\n\t/* mask in overlapping REQ_F and FFS bits */\n\treq->flags |= (file_ptr << REQ_F_NOWAIT_READ_BIT);\n\tio_req_set_rsrc_node(req);\nout:\n\tio_ring_submit_unlock(ctx, !(issue_flags & IO_URING_F_NONBLOCK));\n\treturn file;\n}", "target": 2, "idx": 10904}
{"commit_id": "520cc26d18c9ee245b56e9e91f9d4fcae02be5f0", "project": "ArtifexSoftware/mupdf", "func": "static void removeduplicateobjs(fz_context *ctx, pdf_document *doc, pdf_write_state *opts)\n{\n\tint num, other, max_num;\n\tint xref_len = pdf_xref_len(ctx, doc);\n\n\tfor (num = 1; num < xref_len; num++)\n\t{\n\t\t/* Only compare an object to objects preceding it */\n\t\tfor (other = 1; other < num; other++)\n\t\t{\n\t\t\tpdf_obj *a, *b;\n\t\t\tint newnum, streama = 0, streamb = 0, differ = 0;\n\n\t\t\tif (num == other || !opts->use_list[num] || !opts->use_list[other])\n\t\t\t\tcontinue;\n\n\t\t\t/* TODO: resolve indirect references to see if we can omit them */\n\n\t\t\t/*\n\t\t\t * Comparing stream objects data contents would take too long.\n\t\t\t *\n\t\t\t * pdf_obj_num_is_stream calls pdf_cache_object and ensures\n\t\t\t * that the xref table has the objects loaded.\n\t\t\t */\n\t\t\tfz_try(ctx)\n\t\t\t{\n\t\t\t\tstreama = pdf_obj_num_is_stream(ctx, doc, num);\n\t\t\t\tstreamb = pdf_obj_num_is_stream(ctx, doc, other);\n\t\t\t\tdiffer = streama || streamb;\n\t\t\t\tif (streama && streamb && opts->do_garbage >= 4)\n\t\t\t\t\tdiffer = 0;\n\t\t\t}\n\t\t\tfz_catch(ctx)\n\t\t\t{\n\t\t\t\t/* Assume different */\n\t\t\t\tdiffer = 1;\n\t\t\t}\n\t\t\tif (differ)\n\t\t\t\tcontinue;\n\n\t\t\ta = pdf_get_xref_entry(ctx, doc, num)->obj;\n\t\t\tb = pdf_get_xref_entry(ctx, doc, other)->obj;\n\n\t\t\tif (pdf_objcmp(ctx, a, b))\n\t\t\t\tcontinue;\n\n\t\t\tif (streama && streamb)\n\t\t\t{\n\t\t\t\t/* Check to see if streams match too. */\n\t\t\t\tfz_buffer *sa = NULL;\n\t\t\t\tfz_buffer *sb = NULL;\n\n\t\t\t\tfz_var(sa);\n\t\t\t\tfz_var(sb);\n\n\t\t\t\tdiffer = 1;\n\t\t\t\tfz_try(ctx)\n\t\t\t\t{\n\t\t\t\t\tunsigned char *dataa, *datab;\n\t\t\t\t\tsize_t lena, lenb;\n\t\t\t\t\tsa = pdf_load_raw_stream_number(ctx, doc, num);\n\t\t\t\t\tsb = pdf_load_raw_stream_number(ctx, doc, other);\n\t\t\t\t\tlena = fz_buffer_storage(ctx, sa, &dataa);\n\t\t\t\t\tlenb = fz_buffer_storage(ctx, sb, &datab);\n\t\t\t\t\tif (lena == lenb && memcmp(dataa, datab, lena) == 0)\n\t\t\t\t\t\tdiffer = 0;\n\t\t\t\t}\n\t\t\t\tfz_always(ctx)\n\t\t\t\t{\n\t\t\t\t\tfz_drop_buffer(ctx, sa);\n\t\t\t\t\tfz_drop_buffer(ctx, sb);\n\t\t\t\t}\n\t\t\t\tfz_catch(ctx)\n\t\t\t\t{\n\t\t\t\t\tfz_rethrow(ctx);\n\t\t\t\t}\n\t\t\t\tif (differ)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Keep the lowest numbered object */\n\t\t\tnewnum = fz_mini(num, other);\n\t\t\tmax_num = fz_maxi(num, other);\n\t\t\tif (max_num >= opts->list_len)\n\t\t\t\texpand_lists(ctx, opts, max_num);\n\t\t\topts->renumber_map[num] = newnum;\n\t\t\topts->renumber_map[other] = newnum;\n\t\t\topts->rev_renumber_map[newnum] = num; /* Either will do */\n\t\t\topts->use_list[fz_maxi(num, other)] = 0;\n\n\t\t\t/* One duplicate was found, do not look for another */\n\t\t\tbreak;\n\t\t}\n\t}\n}", "target": 2, "idx": 10905}
{"commit_id": "7872a831783e17dcc4d0aa70cffc256afb664f7a", "project": "ceph", "func": "int RGWLoadGenIO::init_env(CephContext *cct)\n{\n  env.init(cct);\n\n  left_to_read = req->content_length;\n\n  char buf[32];\n  snprintf(buf, sizeof(buf), \"%lld\", (long long)req->content_length);\n  env.set(\"CONTENT_LENGTH\", buf);\n\n  env.set(\"CONTENT_TYPE\", req->content_type.c_str());\n  env.set(\"HTTP_DATE\", req->date_str.c_str());\n\n  for (map<string, string>::iterator iter = req->headers.begin(); iter != req->headers.end(); ++iter) {\n    env.set(iter->first.c_str(), iter->second.c_str());\n  }\n\n  env.set(\"REQUEST_METHOD\", req->request_method.c_str());\n  env.set(\"REQUEST_URI\", req->uri.c_str());\n  env.set(\"QUERY_STRING\", req->query_string.c_str());\n  env.set(\"SCRIPT_URI\", req->uri.c_str());\n\n  char port_buf[16];\n  snprintf(port_buf, sizeof(port_buf), \"%d\", req->port);\n  env.set(\"SERVER_PORT\", port_buf);\n  return 0;\n}", "target": 2, "idx": 10906}
{"commit_id": "cb4ef0b09200c720dfdb07e097092dd105450343", "project": "envoyproxy/envoy", "func": "void ZstdDecompressorImpl::decompress(const Buffer::Instance& input_buffer,\n                                      Buffer::Instance& output_buffer) {\n  uint64_t limit = MaxInflateRatio * input_buffer.length();\n\n  for (const Buffer::RawSlice& input_slice : input_buffer.getRawSlices()) {\n    if (input_slice.len_ > 0) {\n      if (ddict_manager_ && !is_dictionary_set_) {\n        is_dictionary_set_ = true;\n        // If id == 0, it means that dictionary id could not be decoded.\n        dictionary_id_ =\n            ZSTD_getDictID_fromFrame(static_cast<uint8_t*>(input_slice.mem_), input_slice.len_);\n        if (dictionary_id_ != 0) {\n          auto dictionary = ddict_manager_->getDictionaryById(dictionary_id_);\n          if (!dictionary) {\n            stats_.zstd_dictionary_error_.inc();\n            return;\n          }\n          const size_t result = ZSTD_DCtx_refDDict(dctx_.get(), dictionary);\n          if (isError(result)) {\n            return;\n          }\n        }\n      }\n\n      setInput(input_slice);\n      if (!process(output_buffer)) {\n        return;\n      }\n      if (Runtime::runtimeFeatureEnabled(\n              \"envoy.reloadable_features.enable_compression_bomb_protection\") &&\n          (output_buffer.length() > limit)) {\n        stats_.zstd_generic_error_.inc();\n        ENVOY_LOG(trace,\n                  \"excessive decompression ratio detected: output \"\n                  \"size {} for input size {}\",\n                  output_buffer.length(), input_buffer.length());\n        return;\n      }\n    }\n  }\n}", "target": 2, "idx": 10907}
{"commit_id": "b351eabb428c7ca85a34513c64601f437923d576", "project": "android", "func": "status_t OMXNodeInstance::updateGraphicBufferInMeta(\n        OMX_U32 portIndex, const sp<GraphicBuffer>& graphicBuffer,\n        OMX::buffer_id buffer) {\n    Mutex::Autolock autoLock(mLock);\n    OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer, portIndex);\n    return updateGraphicBufferInMeta_l(portIndex, graphicBuffer, buffer, header);\n}", "target": 2, "idx": 10908}
{"commit_id": "3d6d98d8a2be30d74172ab43b5b8e874d2deb158", "project": "ImageMagick", "func": "MagickExport MagickStatusType ParseMetaGeometry(const char *geometry,ssize_t *x,\n  ssize_t *y,size_t *width,size_t *height)\n{\n  GeometryInfo\n    geometry_info;\n\n  MagickStatusType\n    flags;\n\n  size_t\n    stasis_height,\n    stasis_width;\n\n  /*\n    Ensure the image geometry is valid.\n  */\n  assert(x != (ssize_t *) NULL);\n  assert(y != (ssize_t *) NULL);\n  assert(width != (size_t *) NULL);\n  assert(height != (size_t *) NULL);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",geometry);\n  if ((geometry == (char *) NULL) || (*geometry == '\\0'))\n    return(NoValue);\n  /*\n    Parse geometry using GetGeometry.\n  */\n  stasis_width=(*width);\n  stasis_height=(*height);\n  SetGeometryInfo(&geometry_info);\n  flags=GetGeometry(geometry,x,y,width,height);\n  if ((flags & PercentValue) != 0)\n    {\n      MagickStatusType\n        percent_flags;\n\n      PointInfo\n        scale;\n\n      /*\n        Geometry is a percentage of the image size.\n      */\n      percent_flags=ParseGeometry(geometry,&geometry_info);\n      scale.x=geometry_info.rho;\n      if ((percent_flags & RhoValue) == 0)\n        scale.x=100.0;\n      scale.y=geometry_info.sigma;\n      if ((percent_flags & SigmaValue) == 0)\n        scale.y=scale.x;\n      *width=CastDoubleToUnsigned(scale.x*stasis_width/100.0+0.5);\n      *height=CastDoubleToUnsigned(scale.y*stasis_height/100.0+0.5);\n      stasis_width=(*width);\n      stasis_height=(*height);\n    }\n  if ((flags & AspectRatioValue) != 0)\n    {\n      double\n        geometry_ratio,\n        image_ratio;\n\n      /*\n        Geometry is a relative to image size and aspect ratio.\n      */\n      (void) ParseGeometry(geometry,&geometry_info);\n      geometry_ratio=geometry_info.rho;\n      image_ratio=(double) stasis_width*PerceptibleReciprocal((double)\n        stasis_height);\n      if (geometry_ratio >= image_ratio)\n        {\n          *width=stasis_width;\n          *height=CastDoubleToUnsigned((double) (PerceptibleReciprocal(\n            geometry_ratio)*stasis_height*image_ratio)+0.5);\n        }\n      else\n        {\n          *width=CastDoubleToUnsigned(PerceptibleReciprocal(image_ratio)*\n            stasis_width*geometry_ratio+0.5);\n          *height=stasis_height;\n        }\n      stasis_width=(*width);\n      stasis_height=(*height);\n    }\n  if (((flags & AspectValue) != 0) || ((*width == stasis_width) &&\n      (*height == stasis_height)))\n    {\n      if ((flags & RhoValue) == 0)\n        *width=stasis_width;\n      if ((flags & SigmaValue) == 0)\n        *height=stasis_height;\n    }\n  else\n    {\n      double\n        scale_factor;\n\n      /*\n        Respect aspect ratio of the image.\n      */\n      if ((stasis_width == 0) || (stasis_height == 0))\n        scale_factor=1.0;\n      else\n        if (((flags & RhoValue) != 0) && (flags & SigmaValue) != 0)\n          {\n            scale_factor=(double) *width/(double) stasis_width;\n            if ((flags & MinimumValue) == 0)\n              {\n                if (scale_factor > ((double) *height/(double) stasis_height))\n                  scale_factor=(double) *height/(double) stasis_height;\n              }\n            else\n              if (scale_factor < ((double) *height/(double) stasis_height))\n                scale_factor=(double) *height/(double) stasis_height;\n          }\n        else\n          if ((flags & RhoValue) != 0)\n            {\n              scale_factor=(double) *width/(double) stasis_width;\n              if (((flags & MinimumValue) != 0) &&\n                  (scale_factor < ((double) *width/(double) stasis_height)))\n                scale_factor=(double) *width/(double) stasis_height;\n            }\n          else\n            {\n              scale_factor=(double) *height/(double) stasis_height;\n              if (((flags & MinimumValue) != 0) &&\n                  (scale_factor < ((double) *height/(double) stasis_width)))\n                scale_factor=(double) *height/(double) stasis_width;\n            }\n      *width=CastDoubleToUnsigned(MagickMax(floor(scale_factor*stasis_width+\n        0.5),1.0));\n      *height=CastDoubleToUnsigned(MagickMax(floor(scale_factor*stasis_height+\n        0.5),1.0));\n    }\n  if ((flags & GreaterValue) != 0)\n    {\n      if (stasis_width < *width)\n        *width=stasis_width;\n      if (stasis_height < *height)\n        *height=stasis_height;\n    }\n  if ((flags & LessValue) != 0)\n    {\n      if (stasis_width > *width)\n        *width=stasis_width;\n      if (stasis_height > *height)\n        *height=stasis_height;\n    }\n  if ((flags & AreaValue) != 0)\n    {\n      double\n        area,\n        distance;\n\n      PointInfo\n        scale;\n\n      /*\n        Geometry is a maximum area in pixels.\n      */\n      (void) ParseGeometry(geometry,&geometry_info);\n      area=geometry_info.rho+sqrt(MagickEpsilon);\n      distance=sqrt((double) stasis_width*stasis_height);\n      scale.x=(double) stasis_width*PerceptibleReciprocal(distance*\n        PerceptibleReciprocal(sqrt(area)));\n      scale.y=(double) stasis_height*PerceptibleReciprocal(distance*\n        PerceptibleReciprocal(sqrt(area)));\n      if ((scale.x < (double) *width) || (scale.y < (double) *height))\n        {\n          *width=CastDoubleToUnsigned(stasis_width*PerceptibleReciprocal(\n            distance*PerceptibleReciprocal(sqrt(area)))+0.5);\n          *height=CastDoubleToUnsigned(stasis_height*PerceptibleReciprocal(\n            distance*PerceptibleReciprocal(sqrt(area)))+0.5);\n        }\n    }\n  return(flags);\n}", "target": 1, "idx": 10909}
{"commit_id": "5beb00c93d3adb5c23149535624d27c67bc146ea", "project": "TokTok/c-toxcore", "func": "void kill_TCP_server(TCP_Server *tcp_server)\n{\n    for (uint32_t i = 0; i < tcp_server->num_listening_socks; ++i) {\n        kill_sock(tcp_server->socks_listening[i]);\n    }\n\n    if (tcp_server->onion) {\n        set_callback_handle_recv_1(tcp_server->onion, nullptr, nullptr);\n    }\n\n    bs_list_free(&tcp_server->accepted_key_list);\n\n#ifdef TCP_SERVER_USE_EPOLL\n    close(tcp_server->efd);\n#endif\n\n    for (uint32_t i = 0; i < MAX_INCOMING_CONNECTIONS; ++i) {\n        wipe_secure_connection(&tcp_server->incoming_connection_queue[i]);\n        wipe_secure_connection(&tcp_server->unconfirmed_connection_queue[i]);\n    }\n\n    free_accepted_connection_array(tcp_server);\n\n    free(tcp_server->socks_listening);\n    free(tcp_server);\n}", "target": 2, "idx": 10910}
{"commit_id": "c7a4d332b426a25478afd3118f3be5af37972edd", "project": "colinbourassa/crasm", "func": "void opdiv(struct result* presult, struct result* parg)\n{\n  presult->flags |= parg->flags;\n  checktype(presult, L_ABSOLUTE);\n  checktype(parg, L_ABSOLUTE);\n  if (parg->value != 0)\n  {\n    presult->value /= parg->value;\n  }\n}", "target": 2, "idx": 10911}
{"commit_id": "e248db02fbab2ee9162940bc19f087fd7d96cb9d", "project": "android", "func": "status_t DRMSource::read(MediaBuffer **buffer, const ReadOptions *options) {\n    Mutex::Autolock autoLock(mDRMLock);\n    status_t err;\n    if ((err = mOriginalMediaSource->read(buffer, options)) != OK) {\n        return err;\n    }\n\n    size_t len = (*buffer)->range_length();\n\n    char *src = (char *)(*buffer)->data() + (*buffer)->range_offset();\n\n    DrmBuffer encryptedDrmBuffer(src, len);\n    DrmBuffer decryptedDrmBuffer;\n    decryptedDrmBuffer.length = len;\n    decryptedDrmBuffer.data = new char[len];\n    DrmBuffer *pDecryptedDrmBuffer = &decryptedDrmBuffer;\n\n    if ((err = mDrmManagerClient->decrypt(mDecryptHandle, mTrackId,\n            &encryptedDrmBuffer, &pDecryptedDrmBuffer)) != NO_ERROR) {\n\n        if (decryptedDrmBuffer.data) {\n            delete [] decryptedDrmBuffer.data;\n            decryptedDrmBuffer.data = NULL;\n        }\n\n        return err;\n    }\n    CHECK(pDecryptedDrmBuffer == &decryptedDrmBuffer);\n\n    const char *mime;\n    CHECK(getFormat()->findCString(kKeyMIMEType, &mime));\n\n    if (!strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_AVC) && !mWantsNALFragments) {\n        uint8_t *dstData = (uint8_t*)src;\n        size_t srcOffset = 0;\n        size_t dstOffset = 0;\n\n        len = decryptedDrmBuffer.length;\n        while (srcOffset < len) {\n            CHECK(srcOffset + mNALLengthSize <= len);\n            size_t nalLength = 0;\n            const uint8_t* data = (const uint8_t*)(&decryptedDrmBuffer.data[srcOffset]);\n\n            switch (mNALLengthSize) {\n                case 1:\n                    nalLength = *data;\n                    break;\n                case 2:\n                    nalLength = U16_AT(data);\n                    break;\n                case 3:\n                    nalLength = ((size_t)data[0] << 16) | U16_AT(&data[1]);\n                    break;\n                case 4:\n                    nalLength = U32_AT(data);\n                    break;\n                default:\n                    CHECK(!\"Should not be here.\");\n                    break;\n            }\n\n            srcOffset += mNALLengthSize;\n\n            size_t end = srcOffset + nalLength;\n            if (end > len || end < srcOffset) {\n                if (decryptedDrmBuffer.data) {\n                    delete [] decryptedDrmBuffer.data;\n                    decryptedDrmBuffer.data = NULL;\n                }\n\n                return ERROR_MALFORMED;\n            }\n\n            if (nalLength == 0) {\n                continue;\n            }\n\n            if (dstOffset > SIZE_MAX - 4 ||\n                dstOffset + 4 > SIZE_MAX - nalLength ||\n                dstOffset + 4 + nalLength > (*buffer)->size()) {\n                (*buffer)->release();\n                (*buffer) = NULL;\n                if (decryptedDrmBuffer.data) {\n                    delete [] decryptedDrmBuffer.data;\n                    decryptedDrmBuffer.data = NULL;\n                }\n                return ERROR_MALFORMED;\n            }\n\n            dstData[dstOffset++] = 0;\n            dstData[dstOffset++] = 0;\n            dstData[dstOffset++] = 0;\n            dstData[dstOffset++] = 1;\n            memcpy(&dstData[dstOffset], &decryptedDrmBuffer.data[srcOffset], nalLength);\n            srcOffset += nalLength;\n            dstOffset += nalLength;\n        }\n\n        CHECK_EQ(srcOffset, len);\n        (*buffer)->set_range((*buffer)->range_offset(), dstOffset);\n\n    } else {\n        memcpy(src, decryptedDrmBuffer.data, decryptedDrmBuffer.length);\n        (*buffer)->set_range((*buffer)->range_offset(), decryptedDrmBuffer.length);\n    }\n\n    if (decryptedDrmBuffer.data) {\n        delete [] decryptedDrmBuffer.data;\n        decryptedDrmBuffer.data = NULL;\n    }\n\n    return OK;\n}", "target": 3, "idx": 10912}
{"commit_id": "759c01142a5d0f364a462346168a56de28a80f52", "project": "torvalds/linux", "func": "long pipe_fcntl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct pipe_inode_info *pipe;\n\tlong ret;\n\n\tpipe = get_pipe_info(file);\n\tif (!pipe)\n\t\treturn -EBADF;\n\n\t__pipe_lock(pipe);\n\n\tswitch (cmd) {\n\tcase F_SETPIPE_SZ: {\n\t\tunsigned int size, nr_pages;\n\n\t\tsize = round_pipe_size(arg);\n\t\tnr_pages = size >> PAGE_SHIFT;\n\n\t\tret = -EINVAL;\n\t\tif (!nr_pages)\n\t\t\tgoto out;\n\n\t\tif (!capable(CAP_SYS_RESOURCE) && size > pipe_max_size) {\n\t\t\tret = -EPERM;\n\t\t\tgoto out;\n\t\t} else if ((too_many_pipe_buffers_hard(pipe->user) ||\n\t\t\t    too_many_pipe_buffers_soft(pipe->user)) &&\n\t\t           !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = pipe_set_size(pipe, nr_pages);\n\t\tbreak;\n\t\t}\n\tcase F_GETPIPE_SZ:\n\t\tret = pipe->buffers * PAGE_SIZE;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\nout:\n\t__pipe_unlock(pipe);\n\treturn ret;\n}", "target": 1, "idx": 10913}
{"commit_id": "08aef597656d065e86075f3d53fda89765845eae", "project": "lewdlime/abcm2ps", "func": "void frontend(unsigned char *s,\n\t\tint ftype,\n\t\tchar *fname,\n\t\tint linenum)\n{\n\tunsigned char *p, *q, c, *begin_end, sep;\n\tint i, l, str_cnv_p, histo, end_len;\n\tchar prefix_sav[4];\n\tint latin_sav = 0;\t\t/* have C compiler happy */\n\n\tbegin_end = NULL;\n\tend_len = 0;\n\thisto = 0;\n//\tstate = 0;\n\n\tif (ftype == FE_ABC\n\t && strncmp((char *) s, \"%abc-\", 5) == 0) {\n\t\tget_vers((char *) s + 5);\n\t\twhile (*s != '\\0'\n\t\t    && *s != '\\r'\n\t\t    && *s != '\\n')\n\t\t\ts++;\n\t\tif (*s != '\\0') {\n\t\t\ts++;\n\t\t\tif (s[-1] == '\\r' && *s == '\\n')\n\t\t\t\ts++;\n\t\t}\n\t\tlinenum++;\n\t}\n\n\t/* if unknown encoding, check if latin1 or utf-8 */\n\tif (ftype == FE_ABC\n\t && parse.abc_vers >= ((2 << 16) | (1 << 8))) {\t// if ABC version >= 2.1\n\t\tlatin = 0;\t\t\t\t// always UTF-8\n\t} else {\n\t\tfor (p = s; *p != '\\0'; p++) {\n\t\t\tc = *p;\n\t\t\tif (c == '\\\\') {\n\t\t\t\tif (!isdigit(p[1]))\n\t\t\t\t\tcontinue;\n\t\t\t\tif ((p[1] == '0' || p[1] == '2')\n\t\t\t\t && p[2] == '0')\t/* accidental */\n\t\t\t\t\tcontinue;\n\t\t\t\tlatin = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (c < 0x80)\n\t\t\t\tcontinue;\n\t\t\tif (c >= 0xc2) {\n\t\t\t\tif ((p[1] & 0xc0) == 0x80) {\n\t\t\t\t\tlatin = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlatin = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tlatin_sav = latin;\t\t/* (have gcc happy) */\n\n\t/* scan the file */\n\tskip = 0;\n\twhile (*s != '\\0') {\n\n\t\t/* get a line */\n\t\tstr_cnv_p = 0;\n\t\tp = s;\n\t\twhile (*p != '\\0'\n\t\t    && *p != '\\r'\n\t\t    && *p != '\\n') {\n\t\t\tif (*p == '\\\\'\n\t\t\t || *p == '%'\n\t\t\t || (latin > 0 && *p >= 0x80))\n\t\t\t\tstr_cnv_p = 1;\n\t\t\tp++;\n\t\t}\n\t\tl = p - s;\n\t\tif (*p != '\\0') {\n\t\t\tp++;\n\t\t\tif (p[-1] == '\\r' && *p == '\\n')\t/* (DOS) */\n\t\t\t\tp++;\n\t\t}\n\t\tlinenum++;\n\n\t\tif (skip) {\n\t\t\tif (l != 0)\n\t\t\t\tgoto ignore;\n\t\t\tskip = 0;\n\t\t}\n\t\tif (begin_end) {\n\t\t\tif (ftype == FE_FMT) {\n\t\t\t\tif (strncmp((char *) s, \"end\", 3) == 0\n\t\t\t\t && strncmp((char *) s + 3,\n\t\t\t\t\t\t(char *) begin_end, end_len) == 0) {\n\t\t\t\t\tbegin_end = NULL;\n\t\t\t\t\tgoto next_eol;\n\t\t\t\t}\n\t\t\t\tif (*s == '%')\n\t\t\t\t\tgoto ignore;\t\t/* comment */\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tif (*s == '%' && strchr(prefix, s[1])) {\n\t\t\t\tq = s + 2;\n\t\t\t\twhile (*q == ' ' || *q == '\\t')\n\t\t\t\t\tq++;\n\t\t\t\tif (strncmp((char *) q, \"end\", 3) == 0\n\t\t\t\t && strncmp((char *) q + 3,\n\t\t\t\t\t\t(char *) begin_end, end_len) == 0) {\n\t\t\t\t\tbegin_end = NULL;\n\t\t\t\t\tgoto next_eol;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (strncmp(\"ps\", (char *) begin_end, end_len) == 0) {\n\t\t\t\tif (*s == '%')\n\t\t\t\t\tgoto ignore;\t\t/* comment */\n\t\t\t} else {\n\t\t\t\tif (*s == '%' && strchr(prefix, s[1])) {\n\t\t\t\t\ts += 2;\n\t\t\t\t\tl -= 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto next;\n\t\t}\n\n\t\twhile (l > 0 && isspace(s[l - 1]))\n\t\t\tl--;\n\n\t\tif (l == 0) {\t\t\t/* empty line */\n\t\t\tif (ftype == FE_FMT)\n\t\t\t\tgoto next_eol;\n\t\t\tswitch (state) {\n\t\t\tdefault:\n\t\t\t\tgoto ignore;\n\t\t\tcase 1:\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"Line %d: Empty line in tune header - K:C added\\n\",\n\t\t\t\t\tlinenum);\n\t\t\t\ttxt_add((unsigned char *) \"K:C\", 3);\n\t\t\t\ttxt_add_eos(fname, linenum);\n\t\t\t\t/* fall thru */\n\t\t\tcase 2:\n\t\t\t\tstate = 0;\n\t\t\t\tstrcpy(prefix, prefix_sav);\n\t\t\t\tlatin = latin_sav;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto next_eol;\n\t\t}\n\t\tif (histo) {\t\t\t/* H: continuation */\n\t\t\tif ((s[1] == ':' && isalpha(*s))\n\t\t\t || (*s == '%' && strchr(prefix, s[1]))) {\n\t\t\t\thisto = 0;\n\t\t\t} else {\n\t\t\t\tif (*s != '+' || s[1] != ':')\n\t\t\t\t\ttxt_add((unsigned char *) \"+:\", 2);\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\n\n\t\t/* special case 'space* \"%\" ' */\n\t\tif (*s == ' ' || *s == '\\t') {\n\t\t\tq = s;\n\t\t\tdo {\n\t\t\t\tq++;\n\t\t\t} while (*q == ' ' || *q == '\\t');\n\t\t\tif (*q == '%')\n\t\t\t\tgoto ignore;\n\t\t}\n\n\t\tif (ftype == FE_PS) {\n\t\t\tif (*s == '%')\n\t\t\t\tgoto ignore;\n\t\t\tgoto next;\n\t\t}\n\n\t\t/* treat the pseudo-comments */\n\t\tif (ftype == FE_FMT) {\n\t\t\tif (*s == '%')\n\t\t\t\tgoto ignore;\n\t\t\tgoto pscom;\n\t\t}\n\t\tif (*s == 'I' && s[1] == ':') {\n\t\t\ts += 2;\n\t\t\tl -= 2;\n\t\t\twhile (*s == ' ' || *s == '\\t') {\n\t\t\t\ts++;\n\t\t\t\tl--;\n\t\t\t}\n\t\t\tif (l <= 0)\n\t\t\t\tgoto ignore;\n\t\t\ttxt_add((unsigned char *) \"%%\", 2);\n\t\t\tgoto pcinfo;\n\t\t}\n\t\tif (*s == '%') {\n\t\t\tif (!strchr(prefix, s[1]))\t/* pure comment */\n\t\t\t\tgoto ignore;\n\t\t\ts += 2;\n\t\t\tl -= 2;\n\t\t\tif (strncmp((char *) s, \"abc \", 4) == 0) {\n\t\t\t\ts += 4;\n\t\t\t\tl -= 4;\n\t\t\t\tgoto info;\n\t\t\t}\n\t\t\tif (strncmp((char *) s, \"abcm2ps \", 8) == 0\n\t\t\t || strncmp((char *) s, \"ss-pref \", 8) == 0) {\n\t\t\t\ts += 8;\n\t\t\t\tl -= 8;\n\t\t\t\twhile (*s == ' ' || *s == '\\t') {\n\t\t\t\t\ts++;\n\t\t\t\t\tl--;\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < sizeof prefix - 1; i++) {\n\t\t\t\t\tif (*s == ' ' || *s == '\\t'\n\t\t\t\t\t || --l < 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tprefix[i] = *s++;\n\t\t\t\t}\n\t\t\t\tif (i == 0)\n\t\t\t\t\tprefix[i++] = '%';\n\t\t\t\tprefix[i] = '\\0';\n\t\t\t\tgoto ignore;\n\t\t\t}\n\t\t\tif (strncmp((char *) s, \"abc-version \", 12) == 0) {\n\t\t\t\tget_vers((char *) s + 12);\n\t\t\t\tgoto ignore;\n\t\t\t}\npscom:\n\t\t\twhile (*s == ' ' || *s == '\\t') {\n\t\t\t\ts++;\n\t\t\t\tl--;\n\t\t\t}\n\t\t\tif (l <= 0)\n\t\t\t\tgoto ignore;\n\t\t\ttxt_add((unsigned char *) \"%%\", 2);\n\t\t\tif (strncmp((char *) s, \"begin\", 5) == 0) {\n\t\t\t\tq = begin_end = s + 5;\n\t\t\t\twhile (!isspace(*q))\n\t\t\t\t\tq++;\n\t\t\t\tend_len = q - begin_end;\n\t\t\t\tgoto next;\n\t\t\t}\npcinfo:\n\t\t\tif (strncmp((char *) s, \"encoding \", 9) == 0\n\t\t\t || strncmp((char *) s, \"abc-charset \", 12) == 0) {\n\t\t\t\tif (*s == 'e')\n\t\t\t\t\tq = s + 9;\n\t\t\t\telse\n\t\t\t\t\tq = s + 12;\n\t\t\t\twhile (*q == ' ' || *q == '\\t')\n\t\t\t\t\tq++;\n\t\t\t\tif (strncasecmp((char *) q, \"latin\", 5) == 0) {\n\t\t\t\t\tq += 5;\n\t\t\t\t} else if (strncasecmp((char *) q, \"iso-8859-\", 9) == 0) {\n\t\t\t\t\tq += 9;\n\t\t\t\t} else if (strncasecmp((char *) q, \"utf-8\", 5) == 0\n\t\t\t\t\t|| strncasecmp((char *) q, \"native\", 6) == 0) {\n\t\t\t\t\tlatin = 0;\n\t\t\t\t\tgoto next;\n\t\t\t\t} else if (!isdigit(*q)) {\n\t\t\t\t\tgoto next;\t/* unknown charset */\n\t\t\t\t}\n\t\t\t\tswitch (*q) {\n\t\t\t\tcase '1':\n\t\t\t\t\tif (q[1] == '0')\n\t\t\t\t\t\tlatin = 6;\n\t\t\t\t\telse\n\t\t\t\t\t\tlatin = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '2': latin = 2; break;\n\t\t\t\tcase '3': latin = 3; break;\n\t\t\t\tcase '4': latin = 4; break;\n\t\t\t\tcase '5':\n\t\t\t\t\tif (q[-1] != '-')\n\t\t\t\t\t\tlatin = 5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '6':\n\t\t\t\t\tif (q[-1] != '-')\n\t\t\t\t\t\tlatin = 6;\n\t\t\t\t\tbreak;\n/*fixme: iso-8859 5..8 not treated */\n\t\t\t\tcase '9': latin = 5; break;\n\t\t\t\t}\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tif (strncmp((char *) s, \"format \", 7) == 0\n\t\t\t  || strncmp((char *) s, \"abc-include \", 12) == 0) {\n\t\t\t\tint skip_sav;\n\n\t\t\t\tif (*s == 'f')\n\t\t\t\t\ts += 7;\n\t\t\t\telse\n\t\t\t\t\ts += 12;\n\t\t\t\twhile (*s == ' ' || *s == '\\t')\n\t\t\t\t\ts++;\n\t\t\t\tq = s;\n\t\t\t\twhile (*q != '\\0'\n\t\t\t\t    && *q != '%'\n\t\t\t\t    && *q != '\\n'\n\t\t\t\t    && *q != '\\r')\n\t\t\t\t\tq++;\n\t\t\t\twhile (q[-1] == ' ')\n\t\t\t\t\tq--;\n\t\t\t\tsep = *q;\n\t\t\t\t*q = '\\0';\n\t\t\t\tskip_sav = skip;\n//fixme: pb when different encoding in included file: != behaviour .fmt or .abc...\n//\t\t\t\tlatin_sav = latin;\n\t\t\t\toffset = 0;\n\t\t\t\tinclude_file(s);\n//\t\t\t\tlatin = latin_sav;\n\t\t\t\tskip = skip_sav;\n\t\t\t\t*q = sep;\n\t\t\t\tgoto ignore;\n\t\t\t}\n\t\t\tif (strncmp((char *) s, \"select\", 6) == 0) {\n\t\t\t\ts += 6;\n\t\t\t\tif (*s == '\\n') {\t/* select clear */\n\t\t\t\t\tq = s;\n\t\t\t\t} else if (*s != ' ' && *s != '\\t') {\n\t\t\t\t\tgoto next;\n\t\t\t\t} else {\n\t\t\t\t\twhile (*s == ' ' || *s == '\\t')\n\t\t\t\t\t\ts++;\n\t\t\t\t\tq = s;\n\t\t\t\t\twhile (*q != '\\0'\n\t\t\t\t\t    && *q != '%'\n\t\t\t\t\t    && *q != '\\n'\n\t\t\t\t\t    && *q != '\\r')\n\t\t\t\t\t\tq++;\n\t\t\t\t\twhile (q[-1] == ' ' || q[-1] == '\\t')\n\t\t\t\t\t\tq--;\n\t\t\t\t\tif (strncmp((char *) q - 5, \" lock\", 5) == 0)\n\t\t\t\t\t\tq -= 5;\n\t\t\t\t}\n\t\t\t\tif (selection) {\n\t\t\t\t\tfree(selection);\n\t\t\t\t\tselection = NULL;\n\t\t\t\t}\n\t\t\t\tif (q != s) {\n\t\t\t\t\tsep = *q;\n\t\t\t\t\t*q = '\\0';\n\t\t\t\t\tselection = (unsigned char *) strdup((char *) s);\n\t\t\t\t\t*q = sep;\n\t\t\t\t}\n\t\t\t\toffset = 0;\n\t\t\t\tgoto ignore;\n\t\t\t}\n\t\t\tgoto next;\n\t\t}\n\n\t\t/* treat the information fields */\ninfo:\n\t\tif (s[1] == ':' && (isalpha(*s) || *s == '+')) {\n\t\t\tc = *s;\n\t\t\tswitch (c) {\n\t\t\tcase 'I':\t\t/* treat as a pseudo-comment */\n\t\t\t\ts += 2;\n\t\t\t\tl -= 2;\n\t\t\t\tgoto pscom;\n\t\t\tcase 'X':\n\t\t\t\tswitch (state) {\n\t\t\t\tcase 1:\n\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t\"Line %d: X: found in tune header - K:C added\\n\",\n\t\t\t\t\t\tlinenum);\n\t\t\t\t\ttxt_add((unsigned char *) \"K:C\", 3);\n\t\t\t\t\ttxt_add_eos(fname, linenum);\n\t\t\t\t\ttxt_add_eos(fname, linenum);\t/* empty line */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\ttxt_add_eos(fname, linenum);\t/* no empty line - minor error */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (selection) {\n\t\t\t\t\tskip = !tune_select(s);\n\t\t\t\t\tif (skip)\n\t\t\t\t\t\tgoto ignore;\n\t\t\t\t}\n\t\t\t\tstate = 1;\n\t\t\t\tstrcpy(prefix_sav, prefix);\n\t\t\t\tlatin_sav = latin;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\tbreak;\n\t\t\tcase 'H':\n\t\t\t\thisto = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (state == 0\t\t\t/* if global */\n\t\t\t\t && strchr(\"dKPQsVWw\", *s) != NULL)\n\t\t\t\t\tgoto ignore;\n\t\t\t\tif (*s == 'K')\n\t\t\t\t\tstate = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttxt_add(s, 2);\n\t\t\ts += 2;\n\t\t\tl -= 2;\n\t\t\twhile (*s == ' ' || *s == '\\t') {\n\t\t\t\ts++;\n\t\t\t\tl--;\n\t\t\t}\n\t\t\tstr_cnv_p = 1;\n\t\t\tgoto next;\n\t\t}\n\n\t\t/* treat the music lines */\n\t\tif (state == 0)\t\t\t\t/* if not in tune */\n\t\t\tgoto ignore;\nnext:\n\t\tif (str_cnv_p)\n\t\t\ttxt_add_cnv(s, l, !begin_end);\n\t\telse\n\t\t\ttxt_add(s, l);\n\t\tif (begin_end)\n\t\t\ttxt_add((unsigned char *) \"\\n\", 1);\n\t\telse\nnext_eol:\n\t\t\ttxt_add_eos(fname, linenum);\nignore:\n\t\ts = p;\n\t}\n\tif (begin_end)\n\t\tfprintf(stderr,\n\t\t\t\"Line %d: No %%%%end after %%%%begin\\n\",\n\t\t\tlinenum);\n\tif (ftype == FE_FMT)\n\t\treturn;\n\tif (state == 1)\n\t\tfprintf(stderr,\n\t\t\t\"Line %d: Unexpected EOF in header definition\\n\",\n\t\t\tlinenum);\n\tabc_eof();\n}", "target": 1, "idx": 10914}
{"commit_id": "435a3e337bd9d4e11af61cf8b8afca067bf1a8aa", "project": "opencv", "func": "bool  Jpeg2KDecoder::readHeader()\n{\n    bool result = false;\n\n    close();\n    jas_stream_t* stream = jas_stream_fopen( m_filename.c_str(), \"rb\" );\n    m_stream = stream;\n\n    if( stream )\n    {\n        jas_image_t* image = jas_image_decode( stream, -1, 0 );\n        m_image = image;\n        if( image ) {\n            CV_Assert(0 == (jas_image_tlx(image)) && \"not supported\");\n            CV_Assert(0 == (jas_image_tly(image)) && \"not supported\");\n            m_width = jas_image_width( image );\n            m_height = jas_image_height( image );\n\n            int cntcmpts = 0; // count the known components\n            int numcmpts = jas_image_numcmpts( image );\n            int depth = 0;\n            for( int i = 0; i < numcmpts; i++ )\n            {\n                int depth_i = jas_image_cmptprec( image, i );\n                CV_Assert(depth == 0 || depth == depth_i); // component data type mismatch\n                depth = MAX(depth, depth_i);\n                if( jas_image_cmpttype( image, i ) > 2 )\n                    continue;\n                int sgnd = jas_image_cmptsgnd(image, i);\n                int xstart = jas_image_cmpttlx(image, i);\n                int xend = jas_image_cmptbrx(image, i);\n                int xstep = jas_image_cmpthstep(image, i);\n                int ystart = jas_image_cmpttly(image, i);\n                int yend = jas_image_cmptbry(image, i);\n                int ystep = jas_image_cmptvstep(image, i);\n                CV_Assert(sgnd == 0 && \"not supported\");\n                CV_Assert(xstart == 0 && \"not supported\");\n                CV_Assert(ystart == 0 && \"not supported\");\n                CV_Assert(xstep == 1 && \"not supported\");\n                CV_Assert(ystep == 1 && \"not supported\");\n                CV_Assert(xend == m_width);\n                CV_Assert(yend == m_height);\n                cntcmpts++;\n            }\n\n            if( cntcmpts )\n            {\n                CV_Assert(depth == 8 || depth == 16);\n                CV_Assert(cntcmpts == 1 || cntcmpts == 3);\n                m_type = CV_MAKETYPE(depth <= 8 ? CV_8U : CV_16U, cntcmpts > 1 ? 3 : 1);\n                result = true;\n            }\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}", "target": 1, "idx": 10915}
{"commit_id": "c1fbf8ab5d73cff5e1f45236995857c75ba4128d", "project": "zcash", "func": "boost::optional<SaplingNotePlaintext> SaplingNotePlaintext::decrypt(\n    const SaplingEncCiphertext &ciphertext,\n    const uint256 &ivk,\n    const uint256 &epk,\n    const uint256 &cmu\n)\n{\n    auto pt = AttemptSaplingEncDecryption(ciphertext, ivk, epk);\n    if (!pt) {\n        return boost::none;\n    }\n\n    // Deserialize from the plaintext\n    SaplingNotePlaintext ret;\n    try {\n        CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n        ss << pt.get();\n        ss >> ret;\n        assert(ss.size() == 0);\n    } catch (const boost::thread_interrupted&) {\n        throw;\n    } catch (...) {\n        return boost::none;\n    }\n\n    uint256 pk_d;\n    if (!librustzcash_ivk_to_pkd(ivk.begin(), ret.d.data(), pk_d.begin())) {\n        return boost::none;\n    }\n\n    uint256 cmu_expected;\n    if (!librustzcash_sapling_compute_cm(\n        ret.d.data(),\n        pk_d.begin(),\n        ret.value(),\n        ret.rcm.begin(),\n        cmu_expected.begin()\n    ))\n    {\n        return boost::none;\n    }\n\n    if (cmu_expected != cmu) {\n        return boost::none;\n    }\n\n    return ret;\n}", "target": 1, "idx": 10916}
{"commit_id": "2113179835b37549f245ac7c05ff2b96276893e4", "project": "wireshark", "func": "static gint\ndissect_mp4_mfhd_body(tvbuff_t *tvb, gint offset, gint len _U_,\n        packet_info *pinfo _U_, guint depth _U_, proto_tree *tree)\n{\n    gint offset_start;\n\n    offset_start = offset;\n    proto_tree_add_item(tree, hf_mp4_full_box_ver,\n            tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset += 1;\n    proto_tree_add_item(tree, hf_mp4_full_box_flags,\n            tvb, offset, 3, ENC_BIG_ENDIAN);\n    offset += 3;\n\n    proto_tree_add_item(tree, hf_mp4_mfhd_seq_num,\n            tvb, offset, 4, ENC_BIG_ENDIAN);\n    offset += 4;\n\n    return offset-offset_start;\n}", "target": 2, "idx": 10917}
{"commit_id": "4c0faba32fddbd0745cbfaf1e1aeb3da5d35b9fc", "project": "dbry/WavPack", "func": "int ParseDsdiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)\n{\n    int64_t infilesize, total_samples;\n    DFFFileHeader dff_file_header;\n    DFFChunkHeader dff_chunk_header;\n    uint32_t bcount;\n\n    infilesize = DoGetFileSize (infile);\n    memcpy (&dff_file_header, fourcc, 4);\n\n    if ((!DoReadFile (infile, ((char *) &dff_file_header) + 4, sizeof (DFFFileHeader) - 4, &bcount) ||\n        bcount != sizeof (DFFFileHeader) - 4) || strncmp (dff_file_header.formType, \"DSD \", 4)) {\n            error_line (\"%s is not a valid .DFF file!\", infilename);\n            return WAVPACK_SOFT_ERROR;\n    }\n    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n        !WavpackAddWrapper (wpc, &dff_file_header, sizeof (DFFFileHeader))) {\n            error_line (\"%s\", WavpackGetErrorMessage (wpc));\n            return WAVPACK_SOFT_ERROR;\n    }\n\n#if 1   // this might be a little too picky...\n    WavpackBigEndianToNative (&dff_file_header, DFFFileHeaderFormat);\n\n    if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) &&\n        dff_file_header.ckDataSize && dff_file_header.ckDataSize + 1 && dff_file_header.ckDataSize + 12 != infilesize) {\n            error_line (\"%s is not a valid .DFF file (by total size)!\", infilename);\n            return WAVPACK_SOFT_ERROR;\n    }\n\n    if (debug_logging_mode)\n        error_line (\"file header indicated length = %lld\", dff_file_header.ckDataSize);\n\n#endif\n\n    // loop through all elements of the DSDIFF header\n    // (until the data chuck) and copy them to the output file\n\n    while (1) {\n        if (!DoReadFile (infile, &dff_chunk_header, sizeof (DFFChunkHeader), &bcount) ||\n            bcount != sizeof (DFFChunkHeader)) {\n                error_line (\"%s is not a valid .DFF file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n        }\n        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n            !WavpackAddWrapper (wpc, &dff_chunk_header, sizeof (DFFChunkHeader))) {\n                error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                return WAVPACK_SOFT_ERROR;\n        }\n\n        WavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat);\n\n        if (debug_logging_mode)\n            error_line (\"chunk header indicated length = %lld\", dff_chunk_header.ckDataSize);\n\n        if (!strncmp (dff_chunk_header.ckID, \"FVER\", 4)) {\n            uint32_t version;\n\n            if (dff_chunk_header.ckDataSize != sizeof (version) ||\n                !DoReadFile (infile, &version, sizeof (version), &bcount) ||\n                bcount != sizeof (version)) {\n                    error_line (\"%s is not a valid .DFF file!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, &version, sizeof (version))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            WavpackBigEndianToNative (&version, \"L\");\n\n            if (debug_logging_mode)\n                error_line (\"dsdiff file version = 0x%08x\", version);\n        }\n        else if (!strncmp (dff_chunk_header.ckID, \"PROP\", 4)) {\n            char *prop_chunk;\n\n            if (dff_chunk_header.ckDataSize < 4 || dff_chunk_header.ckDataSize > 1024) {\n                error_line (\"%s is not a valid .DFF file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            if (debug_logging_mode)\n                error_line (\"got PROP chunk of %d bytes total\", (int) dff_chunk_header.ckDataSize);\n\n            prop_chunk = malloc ((size_t) dff_chunk_header.ckDataSize);\n\n            if (!DoReadFile (infile, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize, &bcount) ||\n                bcount != dff_chunk_header.ckDataSize) {\n                    error_line (\"%s is not a valid .DFF file!\", infilename);\n                    free (prop_chunk);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize)) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    free (prop_chunk);\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            if (!strncmp (prop_chunk, \"SND \", 4)) {\n                char *cptr = prop_chunk + 4, *eptr = prop_chunk + dff_chunk_header.ckDataSize;\n                uint16_t numChannels = 0, chansSpecified, chanMask = 0;\n                uint32_t sampleRate;\n\n                while (eptr - cptr >= sizeof (dff_chunk_header)) {\n                    memcpy (&dff_chunk_header, cptr, sizeof (dff_chunk_header));\n                    cptr += sizeof (dff_chunk_header);\n                    WavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat);\n\n                    if (dff_chunk_header.ckDataSize > 0 && dff_chunk_header.ckDataSize <= eptr - cptr) {\n                        if (!strncmp (dff_chunk_header.ckID, \"FS  \", 4) && dff_chunk_header.ckDataSize == 4) {\n                            memcpy (&sampleRate, cptr, sizeof (sampleRate));\n                            WavpackBigEndianToNative (&sampleRate, \"L\");\n                            cptr += dff_chunk_header.ckDataSize;\n\n                            if (debug_logging_mode)\n                                error_line (\"got sample rate of %u Hz\", sampleRate);\n                        }\n                        else if (!strncmp (dff_chunk_header.ckID, \"CHNL\", 4) && dff_chunk_header.ckDataSize >= 2) {\n                            memcpy (&numChannels, cptr, sizeof (numChannels));\n                            WavpackBigEndianToNative (&numChannels, \"S\");\n                            cptr += sizeof (numChannels);\n\n                            chansSpecified = (int)(dff_chunk_header.ckDataSize - sizeof (numChannels)) / 4;\n\n                            if (numChannels < chansSpecified || numChannels < 1 || numChannels > 256) {\n                                error_line (\"%s is not a valid .DFF file!\", infilename);\n                                free (prop_chunk);\n                                return WAVPACK_SOFT_ERROR;\n                            }\n\n                            while (chansSpecified--) {\n                                if (!strncmp (cptr, \"SLFT\", 4) || !strncmp (cptr, \"MLFT\", 4))\n                                    chanMask |= 0x1;\n                                else if (!strncmp (cptr, \"SRGT\", 4) || !strncmp (cptr, \"MRGT\", 4))\n                                    chanMask |= 0x2;\n                                else if (!strncmp (cptr, \"LS  \", 4))\n                                    chanMask |= 0x10;\n                                else if (!strncmp (cptr, \"RS  \", 4))\n                                    chanMask |= 0x20;\n                                else if (!strncmp (cptr, \"C   \", 4))\n                                    chanMask |= 0x4;\n                                else if (!strncmp (cptr, \"LFE \", 4))\n                                    chanMask |= 0x8;\n                                else\n                                    if (debug_logging_mode)\n                                        error_line (\"undefined channel ID %c%c%c%c\", cptr [0], cptr [1], cptr [2], cptr [3]);\n\n                                cptr += 4;\n                            }\n\n                            if (debug_logging_mode)\n                                error_line (\"%d channels, mask = 0x%08x\", numChannels, chanMask);\n                        }\n                        else if (!strncmp (dff_chunk_header.ckID, \"CMPR\", 4) && dff_chunk_header.ckDataSize >= 4) {\n                            if (strncmp (cptr, \"DSD \", 4)) {\n                                error_line (\"DSDIFF files must be uncompressed, not \\\"%c%c%c%c\\\"!\",\n                                    cptr [0], cptr [1], cptr [2], cptr [3]);\n                                free (prop_chunk);\n                                return WAVPACK_SOFT_ERROR;\n                            }\n\n                            cptr += dff_chunk_header.ckDataSize;\n                        }\n                        else {\n                            if (debug_logging_mode)\n                                error_line (\"got PROP/SND chunk type \\\"%c%c%c%c\\\" of %d bytes\", dff_chunk_header.ckID [0],\n                                    dff_chunk_header.ckID [1], dff_chunk_header.ckID [2], dff_chunk_header.ckID [3], dff_chunk_header.ckDataSize);\n\n                            cptr += dff_chunk_header.ckDataSize;\n                        }\n                    }\n                    else {\n                        error_line (\"%s is not a valid .DFF file!\", infilename);\n                        free (prop_chunk);\n                        return WAVPACK_SOFT_ERROR;\n                    }\n                }\n\n                if (chanMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {\n                    error_line (\"this DSDIFF file already has channel order information!\");\n                    free (prop_chunk);\n                    return WAVPACK_SOFT_ERROR;\n                }\n                else if (chanMask)\n                    config->channel_mask = chanMask;\n\n                config->bits_per_sample = 8;\n                config->bytes_per_sample = 1;\n                config->num_channels = numChannels;\n                config->sample_rate = sampleRate / 8;\n                config->qmode |= QMODE_DSD_MSB_FIRST;\n            }\n            else if (debug_logging_mode)\n                error_line (\"got unknown PROP chunk type \\\"%c%c%c%c\\\" of %d bytes\",\n                    prop_chunk [0], prop_chunk [1], prop_chunk [2], prop_chunk [3], dff_chunk_header.ckDataSize);\n\n            free (prop_chunk);\n        }\n        else if (!strncmp (dff_chunk_header.ckID, \"DSD \", 4)) {\n\n            if (!config->num_channels) {\n                error_line (\"%s is not a valid .DFF file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            total_samples = dff_chunk_header.ckDataSize / config->num_channels;\n            break;\n        }\n        else {          // just copy unknown chunks to output file\n\n            int bytes_to_copy = (int)(((dff_chunk_header.ckDataSize) + 1) & ~(int64_t)1);\n            char *buff;\n\n            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {\n                error_line (\"%s is not a valid .DFF file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            buff = malloc (bytes_to_copy);\n\n            if (debug_logging_mode)\n                error_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\",\n                    dff_chunk_header.ckID [0], dff_chunk_header.ckID [1], dff_chunk_header.ckID [2],\n                    dff_chunk_header.ckID [3], dff_chunk_header.ckDataSize);\n\n            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||\n                bcount != bytes_to_copy ||\n                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    free (buff);\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            free (buff);\n        }\n    }\n\n    if (debug_logging_mode)\n        error_line (\"setting configuration with %lld samples\", total_samples);\n\n    if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {\n        error_line (\"%s: %s\", infilename, WavpackGetErrorMessage (wpc));\n        return WAVPACK_SOFT_ERROR;\n    }\n\n    return WAVPACK_NO_ERROR;\n}", "target": 1, "idx": 10918}
{"commit_id": "b98b0bc8c431e3ceb4b26b0dfc8db509518fb290", "project": "torvalds/linux", "func": "int sock_setsockopt(struct socket *sock, int level, int optname,\n\t\t    char __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint val;\n\tint valbool;\n\tstruct linger ling;\n\tint ret = 0;\n\n\t/*\n\t *\tOptions without arguments\n\t */\n\n\tif (optname == SO_BINDTODEVICE)\n\t\treturn sock_setbindtodevice(sk, optval, optlen);\n\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\n\tvalbool = val ? 1 : 0;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase SO_DEBUG:\n\t\tif (val && !capable(CAP_NET_ADMIN))\n\t\t\tret = -EACCES;\n\t\telse\n\t\t\tsock_valbool_flag(sk, SOCK_DBG, valbool);\n\t\tbreak;\n\tcase SO_REUSEADDR:\n\t\tsk->sk_reuse = (valbool ? SK_CAN_REUSE : SK_NO_REUSE);\n\t\tbreak;\n\tcase SO_REUSEPORT:\n\t\tsk->sk_reuseport = valbool;\n\t\tbreak;\n\tcase SO_TYPE:\n\tcase SO_PROTOCOL:\n\tcase SO_DOMAIN:\n\tcase SO_ERROR:\n\t\tret = -ENOPROTOOPT;\n\t\tbreak;\n\tcase SO_DONTROUTE:\n\t\tsock_valbool_flag(sk, SOCK_LOCALROUTE, valbool);\n\t\tbreak;\n\tcase SO_BROADCAST:\n\t\tsock_valbool_flag(sk, SOCK_BROADCAST, valbool);\n\t\tbreak;\n\tcase SO_SNDBUF:\n\t\t/* Don't error on this BSD doesn't and if you think\n\t\t * about it this is right. Otherwise apps have to\n\t\t * play 'guess the biggest size' games. RCVBUF/SNDBUF\n\t\t * are treated in BSD as hints\n\t\t */\n\t\tval = min_t(u32, val, sysctl_wmem_max);\nset_sndbuf:\n\t\tsk->sk_userlocks |= SOCK_SNDBUF_LOCK;\n\t\tsk->sk_sndbuf = max_t(int, val * 2, SOCK_MIN_SNDBUF);\n\t\t/* Wake up sending tasks if we upped the value. */\n\t\tsk->sk_write_space(sk);\n\t\tbreak;\n\n\tcase SO_SNDBUFFORCE:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tgoto set_sndbuf;\n\n\tcase SO_RCVBUF:\n\t\t/* Don't error on this BSD doesn't and if you think\n\t\t * about it this is right. Otherwise apps have to\n\t\t * play 'guess the biggest size' games. RCVBUF/SNDBUF\n\t\t * are treated in BSD as hints\n\t\t */\n\t\tval = min_t(u32, val, sysctl_rmem_max);\nset_rcvbuf:\n\t\tsk->sk_userlocks |= SOCK_RCVBUF_LOCK;\n\t\t/*\n\t\t * We double it on the way in to account for\n\t\t * \"struct sk_buff\" etc. overhead.   Applications\n\t\t * assume that the SO_RCVBUF setting they make will\n\t\t * allow that much actual data to be received on that\n\t\t * socket.\n\t\t *\n\t\t * Applications are unaware that \"struct sk_buff\" and\n\t\t * other overheads allocate from the receive buffer\n\t\t * during socket buffer allocation.\n\t\t *\n\t\t * And after considering the possible alternatives,\n\t\t * returning the value we actually used in getsockopt\n\t\t * is the most desirable behavior.\n\t\t */\n\t\tsk->sk_rcvbuf = max_t(int, val * 2, SOCK_MIN_RCVBUF);\n\t\tbreak;\n\n\tcase SO_RCVBUFFORCE:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tgoto set_rcvbuf;\n\n\tcase SO_KEEPALIVE:\n#ifdef CONFIG_INET\n\t\tif (sk->sk_protocol == IPPROTO_TCP &&\n\t\t    sk->sk_type == SOCK_STREAM)\n\t\t\ttcp_set_keepalive(sk, valbool);\n#endif\n\t\tsock_valbool_flag(sk, SOCK_KEEPOPEN, valbool);\n\t\tbreak;\n\n\tcase SO_OOBINLINE:\n\t\tsock_valbool_flag(sk, SOCK_URGINLINE, valbool);\n\t\tbreak;\n\n\tcase SO_NO_CHECK:\n\t\tsk->sk_no_check_tx = valbool;\n\t\tbreak;\n\n\tcase SO_PRIORITY:\n\t\tif ((val >= 0 && val <= 6) ||\n\t\t    ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))\n\t\t\tsk->sk_priority = val;\n\t\telse\n\t\t\tret = -EPERM;\n\t\tbreak;\n\n\tcase SO_LINGER:\n\t\tif (optlen < sizeof(ling)) {\n\t\t\tret = -EINVAL;\t/* 1003.1g */\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_from_user(&ling, optval, sizeof(ling))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (!ling.l_onoff)\n\t\t\tsock_reset_flag(sk, SOCK_LINGER);\n\t\telse {\n#if (BITS_PER_LONG == 32)\n\t\t\tif ((unsigned int)ling.l_linger >= MAX_SCHEDULE_TIMEOUT/HZ)\n\t\t\t\tsk->sk_lingertime = MAX_SCHEDULE_TIMEOUT;\n\t\t\telse\n#endif\n\t\t\t\tsk->sk_lingertime = (unsigned int)ling.l_linger * HZ;\n\t\t\tsock_set_flag(sk, SOCK_LINGER);\n\t\t}\n\t\tbreak;\n\n\tcase SO_BSDCOMPAT:\n\t\tsock_warn_obsolete_bsdism(\"setsockopt\");\n\t\tbreak;\n\n\tcase SO_PASSCRED:\n\t\tif (valbool)\n\t\t\tset_bit(SOCK_PASSCRED, &sock->flags);\n\t\telse\n\t\t\tclear_bit(SOCK_PASSCRED, &sock->flags);\n\t\tbreak;\n\n\tcase SO_TIMESTAMP:\n\tcase SO_TIMESTAMPNS:\n\t\tif (valbool)  {\n\t\t\tif (optname == SO_TIMESTAMP)\n\t\t\t\tsock_reset_flag(sk, SOCK_RCVTSTAMPNS);\n\t\t\telse\n\t\t\t\tsock_set_flag(sk, SOCK_RCVTSTAMPNS);\n\t\t\tsock_set_flag(sk, SOCK_RCVTSTAMP);\n\t\t\tsock_enable_timestamp(sk, SOCK_TIMESTAMP);\n\t\t} else {\n\t\t\tsock_reset_flag(sk, SOCK_RCVTSTAMP);\n\t\t\tsock_reset_flag(sk, SOCK_RCVTSTAMPNS);\n\t\t}\n\t\tbreak;\n\n\tcase SO_TIMESTAMPING:\n\t\tif (val & ~SOF_TIMESTAMPING_MASK) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (val & SOF_TIMESTAMPING_OPT_ID &&\n\t\t    !(sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID)) {\n\t\t\tif (sk->sk_protocol == IPPROTO_TCP &&\n\t\t\t    sk->sk_type == SOCK_STREAM) {\n\t\t\t\tif ((1 << sk->sk_state) &\n\t\t\t\t    (TCPF_CLOSE | TCPF_LISTEN)) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsk->sk_tskey = tcp_sk(sk)->snd_una;\n\t\t\t} else {\n\t\t\t\tsk->sk_tskey = 0;\n\t\t\t}\n\t\t}\n\t\tsk->sk_tsflags = val;\n\t\tif (val & SOF_TIMESTAMPING_RX_SOFTWARE)\n\t\t\tsock_enable_timestamp(sk,\n\t\t\t\t\t      SOCK_TIMESTAMPING_RX_SOFTWARE);\n\t\telse\n\t\t\tsock_disable_timestamp(sk,\n\t\t\t\t\t       (1UL << SOCK_TIMESTAMPING_RX_SOFTWARE));\n\t\tbreak;\n\n\tcase SO_RCVLOWAT:\n\t\tif (val < 0)\n\t\t\tval = INT_MAX;\n\t\tsk->sk_rcvlowat = val ? : 1;\n\t\tbreak;\n\n\tcase SO_RCVTIMEO:\n\t\tret = sock_set_timeout(&sk->sk_rcvtimeo, optval, optlen);\n\t\tbreak;\n\n\tcase SO_SNDTIMEO:\n\t\tret = sock_set_timeout(&sk->sk_sndtimeo, optval, optlen);\n\t\tbreak;\n\n\tcase SO_ATTACH_FILTER:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(struct sock_fprog)) {\n\t\t\tstruct sock_fprog fprog;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&fprog, optval, sizeof(fprog)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_attach_filter(&fprog, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_ATTACH_BPF:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(u32)) {\n\t\t\tu32 ufd;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&ufd, optval, sizeof(ufd)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_attach_bpf(ufd, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_ATTACH_REUSEPORT_CBPF:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(struct sock_fprog)) {\n\t\t\tstruct sock_fprog fprog;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&fprog, optval, sizeof(fprog)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_reuseport_attach_filter(&fprog, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_ATTACH_REUSEPORT_EBPF:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(u32)) {\n\t\t\tu32 ufd;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&ufd, optval, sizeof(ufd)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_reuseport_attach_bpf(ufd, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_DETACH_FILTER:\n\t\tret = sk_detach_filter(sk);\n\t\tbreak;\n\n\tcase SO_LOCK_FILTER:\n\t\tif (sock_flag(sk, SOCK_FILTER_LOCKED) && !valbool)\n\t\t\tret = -EPERM;\n\t\telse\n\t\t\tsock_valbool_flag(sk, SOCK_FILTER_LOCKED, valbool);\n\t\tbreak;\n\n\tcase SO_PASSSEC:\n\t\tif (valbool)\n\t\t\tset_bit(SOCK_PASSSEC, &sock->flags);\n\t\telse\n\t\t\tclear_bit(SOCK_PASSSEC, &sock->flags);\n\t\tbreak;\n\tcase SO_MARK:\n\t\tif (!ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))\n\t\t\tret = -EPERM;\n\t\telse\n\t\t\tsk->sk_mark = val;\n\t\tbreak;\n\n\tcase SO_RXQ_OVFL:\n\t\tsock_valbool_flag(sk, SOCK_RXQ_OVFL, valbool);\n\t\tbreak;\n\n\tcase SO_WIFI_STATUS:\n\t\tsock_valbool_flag(sk, SOCK_WIFI_STATUS, valbool);\n\t\tbreak;\n\n\tcase SO_PEEK_OFF:\n\t\tif (sock->ops->set_peek_off)\n\t\t\tret = sock->ops->set_peek_off(sk, val);\n\t\telse\n\t\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\n\tcase SO_NOFCS:\n\t\tsock_valbool_flag(sk, SOCK_NOFCS, valbool);\n\t\tbreak;\n\n\tcase SO_SELECT_ERR_QUEUE:\n\t\tsock_valbool_flag(sk, SOCK_SELECT_ERR_QUEUE, valbool);\n\t\tbreak;\n\n#ifdef CONFIG_NET_RX_BUSY_POLL\n\tcase SO_BUSY_POLL:\n\t\t/* allow unprivileged users to decrease the value */\n\t\tif ((val > sk->sk_ll_usec) && !capable(CAP_NET_ADMIN))\n\t\t\tret = -EPERM;\n\t\telse {\n\t\t\tif (val < 0)\n\t\t\t\tret = -EINVAL;\n\t\t\telse\n\t\t\t\tsk->sk_ll_usec = val;\n\t\t}\n\t\tbreak;\n#endif\n\n\tcase SO_MAX_PACING_RATE:\n\t\tsk->sk_max_pacing_rate = val;\n\t\tsk->sk_pacing_rate = min(sk->sk_pacing_rate,\n\t\t\t\t\t sk->sk_max_pacing_rate);\n\t\tbreak;\n\n\tcase SO_INCOMING_CPU:\n\t\tsk->sk_incoming_cpu = val;\n\t\tbreak;\n\n\tcase SO_CNX_ADVICE:\n\t\tif (val == 1)\n\t\t\tdst_negative_advice(sk);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\treturn ret;\n}", "target": 2, "idx": 10919}
{"commit_id": "c00fc9d3003eb06226b58b6a48555f1456ee2475", "project": "facebook/hhvm", "func": "static String HHVM_FUNCTION(bcadd, const String& left, const String& right,\n                            int64_t scale /* = -1 */) {\n  scale = adjust_scale(scale);\n  bc_num first, second, result;\n  bc_init_num(&first);\n  bc_init_num(&second);\n  bc_init_num(&result);\n  php_str2num(&first, (char*)left.data());\n  php_str2num(&second, (char*)right.data());\n  bc_add(first, second, &result, scale);\n  if (result->n_scale > scale) {\n    result->n_scale = scale;\n  }\n  String ret(bc_num2str(result), AttachString);\n  bc_free_num(&first);\n  bc_free_num(&second);\n  bc_free_num(&result);\n  return ret;\n}", "target": 3, "idx": 10920}
{"commit_id": "0272305f91763b5ce119a2c7a0e0084d8241a58d", "project": "ImageMagick", "func": "static Image *ReadSIXELImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    *sixel_buffer;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  register char\n    *p;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  size_t\n    length;\n\n  ssize_t\n    i,\n    j,\n    y;\n\n  unsigned char\n    *sixel_pixels,\n    *sixel_palette;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read SIXEL file.\n  */\n  length=MagickPathExtent;\n  sixel_buffer=(char *) AcquireQuantumMemory((size_t) length+MagickPathExtent,\n    sizeof(*sixel_buffer));\n  p=sixel_buffer;\n  if (sixel_buffer != (char *) NULL)\n    while (ReadBlobString(image,p) != (char *) NULL)\n    {\n      if ((*p == '#') && ((p == sixel_buffer) || (*(p-1) == '\\n')))\n        continue;\n      if ((*p == '}') && (*(p+1) == ';'))\n        break;\n      p+=strlen(p);\n      if ((size_t) (p-sixel_buffer+MagickPathExtent) < length)\n        continue;\n      length<<=1;\n      sixel_buffer=(char *) ResizeQuantumMemory(sixel_buffer,length+\n        MagickPathExtent,sizeof(*sixel_buffer));\n      if (sixel_buffer == (char *) NULL)\n        break;\n      p=sixel_buffer+strlen(sixel_buffer);\n    }\n  if (sixel_buffer == (char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  sixel_buffer[length]='\\0';\n  /*\n    Decode SIXEL\n  */\n  if (sixel_decode((unsigned char *) sixel_buffer,&sixel_pixels,&image->columns,&image->rows,&sixel_palette,&image->colors) == MagickFalse)\n    {\n      sixel_buffer=(char *) RelinquishMagickMemory(sixel_buffer);\n      ThrowReaderException(CorruptImageError,\"CorruptImage\");\n    }\n  sixel_buffer=(char *) RelinquishMagickMemory(sixel_buffer);\n  image->depth=24;\n  image->storage_class=PseudoClass;\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    {\n      sixel_pixels=(unsigned char *) RelinquishMagickMemory(sixel_pixels);\n      sixel_palette=(unsigned char *) RelinquishMagickMemory(sixel_palette);\n      return(DestroyImageList(image));\n    }\n\n  if (AcquireImageColormap(image,image->colors, exception) == MagickFalse)\n    {\n      sixel_pixels=(unsigned char *) RelinquishMagickMemory(sixel_pixels);\n      sixel_palette=(unsigned char *) RelinquishMagickMemory(sixel_palette);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  for (i = 0; i < (ssize_t) image->colors; ++i) {\n    image->colormap[i].red   = ScaleCharToQuantum(sixel_palette[i * 4 + 0]);\n    image->colormap[i].green = ScaleCharToQuantum(sixel_palette[i * 4 + 1]);\n    image->colormap[i].blue  = ScaleCharToQuantum(sixel_palette[i * 4 + 2]);\n  }\n\n  j=0;\n  if (image_info->ping == MagickFalse)\n    {\n      /*\n        Read image pixels.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          j=(ssize_t) sixel_pixels[y * image->columns + x];\n          SetPixelIndex(image,j,q);\n          q+=GetPixelChannels(image);\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n      }\n      if (y < (ssize_t) image->rows)\n        {\n          sixel_pixels=(unsigned char *) RelinquishMagickMemory(sixel_pixels);\n          sixel_palette=(unsigned char *) RelinquishMagickMemory(sixel_palette);\n          ThrowReaderException(CorruptImageError,\"NotEnoughPixelData\");\n        }\n    }\n  /*\n    Relinquish resources.\n  */\n  sixel_pixels=(unsigned char *) RelinquishMagickMemory(sixel_pixels);\n  sixel_palette=(unsigned char *) RelinquishMagickMemory(sixel_palette);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}", "target": 2, "idx": 10921}
{"commit_id": "a2dff1b59ea8c8ec10680f9e8e5593e4b38554a1", "project": "sass/libsass", "func": "output_iterator replace_invalid(octet_iterator start, octet_iterator end, output_iterator out, uint32_t replacement)\n    {\n        while (start != end) {\n            octet_iterator sequence_start = start;\n            internal::utf_error err_code = utf8::internal::validate_next(start, end);\n            switch (err_code) {\n                case internal::UTF8_OK :\n                    for (octet_iterator it = sequence_start; it != start; ++it)\n                        *out++ = *it;\n                    break;\n                case internal::NOT_ENOUGH_ROOM:\n                    out = utf8::append (replacement, out);\n                    start = end;\n                    break;\n                case internal::INVALID_LEAD:\n                    out = utf8::append (replacement, out);\n                    ++start;\n                    break;\n                case internal::INCOMPLETE_SEQUENCE:\n                case internal::OVERLONG_SEQUENCE:\n                case internal::INVALID_CODE_POINT:\n                    out = utf8::append (replacement, out);\n                    ++start;\n                    // just one replacement mark for the sequence\n                    while (start != end && utf8::internal::is_trail(*start))\n                        ++start;\n                    break;\n            }\n        }\n        return out;\n    }", "target": 1, "idx": 10922}
{"commit_id": "d03a3020de69143b1fe8129d75e55f14951dd192", "project": "android", "func": "void gatt_process_prep_write_rsp(tGATT_TCB& tcb, tGATT_CLCB* p_clcb,\n                                 uint8_t op_code, uint16_t len,\n                                 uint8_t* p_data) {\n  uint8_t* p = p_data;\n\n  tGATT_VALUE value = {\n      .conn_id = p_clcb->conn_id, .auth_req = GATT_AUTH_REQ_NONE,\n  };\n\n  VLOG(1) << StringPrintf(\"value resp op_code = %s len = %d\",\n                          gatt_dbg_op_name(op_code), len);\n\n  if (len < GATT_PREP_WRITE_RSP_MIN_LEN ||\n      len > GATT_PREP_WRITE_RSP_MIN_LEN + sizeof(value.value)) {\n    LOG(ERROR) << \"illegal prepare write response length, discard\";\n    gatt_end_operation(p_clcb, GATT_INVALID_PDU, &value);\n    return;\n  }\n\n  STREAM_TO_UINT16(value.handle, p);\n  STREAM_TO_UINT16(value.offset, p);\n\n  value.len = len - GATT_PREP_WRITE_RSP_MIN_LEN;\n\n  memcpy(value.value, p, value.len);\n\n  bool subtype_is_write_prepare = (p_clcb->op_subtype == GATT_WRITE_PREPARE);\n\n  if (!gatt_check_write_long_terminate(tcb, p_clcb, &value)) {\n    gatt_send_prepare_write(tcb, p_clcb);\n    return;\n  }\n\n  // We now know that we have not terminated, or else we would have returned\n  // early.  We free the buffer only if the subtype is not equal to\n  // GATT_WRITE_PREPARE, so checking here is adequate to prevent UAF.\n  if (subtype_is_write_prepare) {\n    /* application should verify handle offset\n       and value are matched or not */\n    gatt_end_operation(p_clcb, p_clcb->status, &value);\n  }\n}", "target": 2, "idx": 10923}
{"commit_id": "86ee8b5c6a5737f35a650fcf370d9d0f5823e531", "project": "pcmacdon/jsish", "func": "static Jsi_RC jsi_ArrayUnshiftCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n\n    Jsi_Obj *obj = _this->d.obj;\n    if (obj->modifying)\n      return Jsi_LogError(\"already modifying\");\n    int argc = Jsi_ValueGetLength(interp, args);\n    int curlen = jsi_SizeOfArray(interp, obj);\n    if (argc <= 0) {\n        Jsi_ValueMakeNumber(interp, ret, 0);\n        return JSI_OK;\n    }\n    Jsi_ObjListifyArray(interp, obj);\n    if (Jsi_ObjArraySizer(interp, obj, curlen+argc)<=0) \n        return Jsi_LogError(\"too long\");\n    memmove(obj->arr+argc, obj->arr, (curlen)*sizeof(Jsi_Value*));\n    obj->arrCnt += argc;\n    int i;\n    for (i = 0; i < argc; ++i) {\n        Jsi_Value *ov = Jsi_ValueArrayIndex(interp, args, i);\n        obj->arr[i] = NULL;\n        if (!ov) { Jsi_LogBug(\"Arguments Error\"); continue; }\n        obj->arr[i] = ov;\n        Jsi_IncrRefCount(interp, ov);\n    }\n    Jsi_ObjSetLength(interp, obj, curlen+argc);\n    \n    Jsi_ValueMakeNumber(interp, ret, jsi_SizeOfArray(interp, obj));\n    return JSI_OK;\n}", "target": 1, "idx": 10924}
{"commit_id": "e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d", "project": "jasper-software/jasper", "func": "int jp2_box_put(jp2_box_t *box, jas_stream_t *out)\n{\n\tjas_stream_t *tmpstream;\n\tbool extlen;\n\tbool dataflag;\n\n\ttmpstream = 0;\n\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (box->ops->putdata) {\n\t\t\tif ((*box->ops->putdata)(box, tmpstream)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tbox->len = jas_stream_tell(tmpstream) + JP2_BOX_HDRLEN(false);\n\t\tjas_stream_rewind(tmpstream);\n\t}\n\textlen = (box->len >= (((uint_fast64_t)1) << 32)) != 0;\n\tif (jp2_putuint32(out, extlen ? 1 : box->len)) {\n\t\tgoto error;\n\t}\n\tif (jp2_putuint32(out, box->type)) {\n\t\tgoto error;\n\t}\n\tif (extlen) {\n\t\tif (jp2_putuint64(out, box->len)) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (dataflag) {\n\t\tif (jas_stream_copy(out, tmpstream, box->len -\n\t\t  JP2_BOX_HDRLEN(false))) {\n\t\t\tjas_eprintf(\"cannot copy box data\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\treturn 0;\n\nerror:\n\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn -1;\n}", "target": 1, "idx": 10925}
{"commit_id": "7c57e7d94cb84544f97472761b2d95d99291a564", "project": "Legrandin/pycryptodome", "func": "static int AESNI_decrypt(const BlockBase *bb, const uint8_t *in, uint8_t *out, size_t data_len)\n{\n    unsigned rounds;\n    __m128i r[14+1];\n    const struct block_state *state;\n    unsigned k;\n\n    if ((bb == NULL) || (in == NULL) || (out == NULL))\n        return ERR_NULL;\n\n    state = &((AESNI_State*)bb)->algo_state;\n    rounds = state->rounds;\n\n    if (rounds > 14)\n        return ERR_NR_ROUNDS;\n\n    for (k=0; k<=rounds; k++) {\n        r[k] = state->drk[k];\n    }\n\n    /** Decrypt 8 blocks (128 bytes) in parallel, when possible **/\n    for (; data_len >= 8*16; data_len -= 8*16) {\n        __m128i ct[8], data[8];\n        unsigned j;\n\n        ct[0] = _mm_loadu_si128((__m128i*)in); in+=16;\n        ct[1] = _mm_loadu_si128((__m128i*)in); in+=16;\n        ct[2] = _mm_loadu_si128((__m128i*)in); in+=16;\n        ct[3] = _mm_loadu_si128((__m128i*)in); in+=16;\n        ct[4] = _mm_loadu_si128((__m128i*)in); in+=16;\n        ct[5] = _mm_loadu_si128((__m128i*)in); in+=16;\n        ct[6] = _mm_loadu_si128((__m128i*)in); in+=16;\n        ct[7] = _mm_loadu_si128((__m128i*)in); in+=16;\n\n        data[0] = _mm_xor_si128(ct[0], r[0]);\n        data[1] = _mm_xor_si128(ct[1], r[0]);\n        data[2] = _mm_xor_si128(ct[2], r[0]);\n        data[3] = _mm_xor_si128(ct[3], r[0]);\n        data[4] = _mm_xor_si128(ct[4], r[0]);\n        data[5] = _mm_xor_si128(ct[5], r[0]);\n        data[6] = _mm_xor_si128(ct[6], r[0]);\n        data[7] = _mm_xor_si128(ct[7], r[0]);\n\n        for (j=1; j<10; j++) {\n            data[0] = _mm_aesdec_si128(data[0], r[j]);\n            data[1] = _mm_aesdec_si128(data[1], r[j]);\n            data[2] = _mm_aesdec_si128(data[2], r[j]);\n            data[3] = _mm_aesdec_si128(data[3], r[j]);\n            data[4] = _mm_aesdec_si128(data[4], r[j]);\n            data[5] = _mm_aesdec_si128(data[5], r[j]);\n            data[6] = _mm_aesdec_si128(data[6], r[j]);\n            data[7] = _mm_aesdec_si128(data[7], r[j]);\n        }\n    \n        for (; j<rounds; j++) {\n            data[0] = _mm_aesdec_si128(data[0], r[j]);\n            data[1] = _mm_aesdec_si128(data[1], r[j]);\n            data[2] = _mm_aesdec_si128(data[2], r[j]);\n            data[3] = _mm_aesdec_si128(data[3], r[j]);\n            data[4] = _mm_aesdec_si128(data[4], r[j]);\n            data[5] = _mm_aesdec_si128(data[5], r[j]);\n            data[6] = _mm_aesdec_si128(data[6], r[j]);\n            data[7] = _mm_aesdec_si128(data[7], r[j]);\n        }\n        \n        data[0] = _mm_aesdeclast_si128(data[0], r[rounds]);\n        data[1] = _mm_aesdeclast_si128(data[1], r[rounds]);\n        data[2] = _mm_aesdeclast_si128(data[2], r[rounds]);\n        data[3] = _mm_aesdeclast_si128(data[3], r[rounds]);\n        data[4] = _mm_aesdeclast_si128(data[4], r[rounds]);\n        data[5] = _mm_aesdeclast_si128(data[5], r[rounds]);\n        data[6] = _mm_aesdeclast_si128(data[6], r[rounds]);\n        data[7] = _mm_aesdeclast_si128(data[7], r[rounds]);\n\n        _mm_storeu_si128((__m128i*)out, data[0]); out+=16;\n        _mm_storeu_si128((__m128i*)out, data[1]); out+=16;\n        _mm_storeu_si128((__m128i*)out, data[2]); out+=16;\n        _mm_storeu_si128((__m128i*)out, data[3]); out+=16;\n        _mm_storeu_si128((__m128i*)out, data[4]); out+=16;\n        _mm_storeu_si128((__m128i*)out, data[5]); out+=16;\n        _mm_storeu_si128((__m128i*)out, data[6]); out+=16;\n        _mm_storeu_si128((__m128i*)out, data[7]); out+=16;\n    }\n\n    /** There are 7 blocks or fewer left **/\n    for (;data_len>=BLOCK_SIZE; data_len-=BLOCK_SIZE, in+=BLOCK_SIZE, out+=BLOCK_SIZE) {\n        __m128i ct, data;\n        unsigned i;\n\n        ct = _mm_loadu_si128((__m128i*)in);\n        data = _mm_xor_si128(ct, r[0]);\n        for (i=1; i<10; i++) {\n            data = _mm_aesdec_si128(data, r[i]);\n        }\n        for (i=10; i<rounds; i+=2) {\n            data = _mm_aesdec_si128(data, r[i]);\n            data = _mm_aesdec_si128(data, r[i+1]);\n        }\n        data = _mm_aesdeclast_si128(data, r[rounds]);\n        _mm_storeu_si128((__m128i*)out, data);\n    }\n\n    if (data_len) {\n        return ERR_NOT_ENOUGH_DATA;\n    }\n\n    return 0;\n}", "target": 2, "idx": 10926}
{"commit_id": "239139d2ae6a81ae9ba499ad78b56d9b2931538a", "project": "tensorflow", "func": "Status GetTensorArray(OpKernelContext* ctx, TensorArray** tensor_array) {\n  string container;\n  string ta_handle;\n  if (ctx->input_dtype(0) != DT_RESOURCE) {\n    TF_RETURN_IF_ERROR(GetHandle(ctx, &container, &ta_handle));\n    ResourceMgr* rm = ctx->resource_manager();\n    if (rm == nullptr) return errors::Internal(\"No resource manager.\");\n    ScopedStepContainer* sc = ctx->step_container();\n    if (sc == nullptr) return errors::Internal(\"No step container.\");\n    TF_RETURN_IF_ERROR(sc->Lookup(rm, container + ta_handle, tensor_array));\n    return OkStatus();\n  } else {\n    return LookupResource(ctx, HandleFromInput(ctx, 0), tensor_array);\n  }\n}", "target": 2, "idx": 10927}
{"commit_id": "e264f04ae825a5d97758130cf8eec99862517e7e", "project": "facebook/hhvm", "func": "static bool couldRecur(const Variant& v, const ArrayData* arr) {\n  return v.isReferenced() ||\n    arr->kind() == ArrayData::kGlobalsKind ||\n    arr->kind() == ArrayData::kProxyKind;\n}", "target": 3, "idx": 10928}
{"commit_id": "b17d5e860f30e8be2caeb0022b63be4c76660178", "project": "ONLYOFFICE/core", "func": "int          GetU16BE (const unsigned int& nPos, bool *pbSuccess)\n        {\n            //*pbSuccess = true;\n\n            if ( m_nLen < 2 || nPos > (m_nLen - 2) )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            int nRes = m_sFile[ nPos ];\n            nRes = (nRes << 8) + m_sFile[ nPos + 1 ];\n            return nRes;\n        }", "target": 3, "idx": 10929}
{"commit_id": "1995266727fa8143897e89b55f5d3c79aa828420", "project": "torvalds/linux", "func": "int nfsd_setuser(struct svc_rqst *rqstp, struct svc_export *exp)\n{\n\tstruct group_info *rqgi;\n\tstruct group_info *gi;\n\tstruct cred *new;\n\tint i;\n\tint flags = nfsexp_flags(rqstp, exp);\n\n\tvalidate_process_creds();\n\n\t/* discard any old override before preparing the new set */\n\trevert_creds(get_cred(current_real_cred()));\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->fsuid = rqstp->rq_cred.cr_uid;\n\tnew->fsgid = rqstp->rq_cred.cr_gid;\n\n\trqgi = rqstp->rq_cred.cr_group_info;\n\n\tif (flags & NFSEXP_ALLSQUASH) {\n\t\tnew->fsuid = exp->ex_anon_uid;\n\t\tnew->fsgid = exp->ex_anon_gid;\n\t\tgi = groups_alloc(0);\n\t\tif (!gi)\n\t\t\tgoto oom;\n\t} else if (flags & NFSEXP_ROOTSQUASH) {\n\t\tif (uid_eq(new->fsuid, GLOBAL_ROOT_UID))\n\t\t\tnew->fsuid = exp->ex_anon_uid;\n\t\tif (gid_eq(new->fsgid, GLOBAL_ROOT_GID))\n\t\t\tnew->fsgid = exp->ex_anon_gid;\n\n\t\tgi = groups_alloc(rqgi->ngroups);\n\t\tif (!gi)\n\t\t\tgoto oom;\n\n\t\tfor (i = 0; i < rqgi->ngroups; i++) {\n\t\t\tif (gid_eq(GLOBAL_ROOT_GID, rqgi->gid[i]))\n\t\t\t\tgi->gid[i] = exp->ex_anon_gid;\n\t\t\telse\n\t\t\t\tgi->gid[i] = rqgi->gid[i];\n\t\t}\n\n\t\t/* Each thread allocates its own gi, no race */\n\t\tgroups_sort(gi);\n\t} else {\n\t\tgi = get_group_info(rqgi);\n\t}\n\n\tif (uid_eq(new->fsuid, INVALID_UID))\n\t\tnew->fsuid = exp->ex_anon_uid;\n\tif (gid_eq(new->fsgid, INVALID_GID))\n\t\tnew->fsgid = exp->ex_anon_gid;\n\n\tset_groups(new, gi);\n\tput_group_info(gi);\n\n\tif (!uid_eq(new->fsuid, GLOBAL_ROOT_UID))\n\t\tnew->cap_effective = cap_drop_nfsd_set(new->cap_effective);\n\telse\n\t\tnew->cap_effective = cap_raise_nfsd_set(new->cap_effective,\n\t\t\t\t\t\t\tnew->cap_permitted);\n\tvalidate_process_creds();\n\tput_cred(override_creds(new));\n\tput_cred(new);\n\tvalidate_process_creds();\n\treturn 0;\n\noom:\n\tabort_creds(new);\n\treturn -ENOMEM;\n}", "target": 2, "idx": 10930}
{"commit_id": "ebe48d368e97d007bfeb76fcb065d6cfc4c96645", "project": "torvalds/linux", "func": "int esp6_output_head(struct xfrm_state *x, struct sk_buff *skb, struct esp_info *esp)\n{\n\tu8 *tail;\n\tint nfrags;\n\tint esph_offset;\n\tstruct page *page;\n\tstruct sk_buff *trailer;\n\tint tailen = esp->tailen;\n\tunsigned int allocsz;\n\n\tif (x->encap) {\n\t\tint err = esp6_output_encap(x, skb, esp);\n\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tallocsz = ALIGN(skb->data_len + tailen, L1_CACHE_BYTES);\n\tif (allocsz > ESP_SKB_FRAG_MAXSIZE)\n\t\tgoto cow;\n\n\tif (!skb_cloned(skb)) {\n\t\tif (tailen <= skb_tailroom(skb)) {\n\t\t\tnfrags = 1;\n\t\t\ttrailer = skb;\n\t\t\ttail = skb_tail_pointer(trailer);\n\n\t\t\tgoto skip_cow;\n\t\t} else if ((skb_shinfo(skb)->nr_frags < MAX_SKB_FRAGS)\n\t\t\t   && !skb_has_frag_list(skb)) {\n\t\t\tint allocsize;\n\t\t\tstruct sock *sk = skb->sk;\n\t\t\tstruct page_frag *pfrag = &x->xfrag;\n\n\t\t\tesp->inplace = false;\n\n\t\t\tallocsize = ALIGN(tailen, L1_CACHE_BYTES);\n\n\t\t\tspin_lock_bh(&x->lock);\n\n\t\t\tif (unlikely(!skb_page_frag_refill(allocsize, pfrag, GFP_ATOMIC))) {\n\t\t\t\tspin_unlock_bh(&x->lock);\n\t\t\t\tgoto cow;\n\t\t\t}\n\n\t\t\tpage = pfrag->page;\n\t\t\tget_page(page);\n\n\t\t\ttail = page_address(page) + pfrag->offset;\n\n\t\t\tesp_output_fill_trailer(tail, esp->tfclen, esp->plen, esp->proto);\n\n\t\t\tnfrags = skb_shinfo(skb)->nr_frags;\n\n\t\t\t__skb_fill_page_desc(skb, nfrags, page, pfrag->offset,\n\t\t\t\t\t     tailen);\n\t\t\tskb_shinfo(skb)->nr_frags = ++nfrags;\n\n\t\t\tpfrag->offset = pfrag->offset + allocsize;\n\n\t\t\tspin_unlock_bh(&x->lock);\n\n\t\t\tnfrags++;\n\n\t\t\tskb->len += tailen;\n\t\t\tskb->data_len += tailen;\n\t\t\tskb->truesize += tailen;\n\t\t\tif (sk && sk_fullsock(sk))\n\t\t\t\trefcount_add(tailen, &sk->sk_wmem_alloc);\n\n\t\t\tgoto out;\n\t\t}\n\t}\n\ncow:\n\tesph_offset = (unsigned char *)esp->esph - skb_transport_header(skb);\n\n\tnfrags = skb_cow_data(skb, tailen, &trailer);\n\tif (nfrags < 0)\n\t\tgoto out;\n\ttail = skb_tail_pointer(trailer);\n\tesp->esph = (struct ip_esp_hdr *)(skb_transport_header(skb) + esph_offset);\n\nskip_cow:\n\tesp_output_fill_trailer(tail, esp->tfclen, esp->plen, esp->proto);\n\tpskb_put(skb, trailer, tailen);\n\nout:\n\treturn nfrags;\n}", "target": 2, "idx": 10931}
{"commit_id": "d0fab10ed2a86698937e3c3fed2f10bd9bb5e731", "project": "vim", "func": "static void\nqf_update_buffer(qf_info_T *qi, qfline_T *old_last)\n{\n    buf_T\t*buf;\n    win_T\t*win;\n    aco_save_T\taco;\n\n    // Check if a buffer for the quickfix list exists.  Update it.\n    buf = qf_find_buf(qi);\n    if (buf != NULL)\n    {\n\tlinenr_T\told_line_count = buf->b_ml.ml_line_count;\n\tint\t\tqf_winid = 0;\n\n\tif (IS_LL_STACK(qi))\n\t{\n\t    if (curwin->w_llist == qi)\n\t\twin = curwin;\n\t    else\n\t    {\n\t\t// Find the file window (non-quickfix) with this location list\n\t\twin = qf_find_win_with_loclist(qi);\n\t\tif (win == NULL)\n\t\t    // File window is not found. Find the location list window.\n\t\t    win = qf_find_win(qi);\n\t\tif (win == NULL)\n\t\t    return;\n\t    }\n\t    qf_winid = win->w_id;\n\t}\n\n\t// autocommands may cause trouble\n\tincr_quickfix_busy();\n\n\tif (old_last == NULL)\n\t    // set curwin/curbuf to buf and save a few things\n\t    aucmd_prepbuf(&aco, buf);\n\n\tqf_update_win_titlevar(qi);\n\n\tqf_fill_buffer(qf_get_curlist(qi), buf, old_last, qf_winid);\n\t++CHANGEDTICK(buf);\n\n\tif (old_last == NULL)\n\t{\n\t    (void)qf_win_pos_update(qi, 0);\n\n\t    // restore curwin/curbuf and a few other things\n\t    aucmd_restbuf(&aco);\n\t}\n\n\t// Only redraw when added lines are visible.  This avoids flickering\n\t// when the added lines are not visible.\n\tif ((win = qf_find_win(qi)) != NULL && old_line_count < win->w_botline)\n\t    redraw_buf_later(buf, UPD_NOT_VALID);\n\n\t// always called after incr_quickfix_busy()\n\tdecr_quickfix_busy();\n    }\n}", "target": 2, "idx": 10932}
{"commit_id": "68f67b1a3a4d319543692afb5bd5b191ec984287", "project": "appneta/tcpreplay", "func": "int\nrewrite(input_addr* new_remoteip, struct mac_addr* new_remotemac, input_addr* myip, struct mac_addr* mymac, char* file, unsigned int new_src_port)\n{\n\n    ether_hdr* etherhdr; \n    ipv4_hdr *iphdr;\n    tcp_hdr *tcphdr;\n    input_addr local_ip; \n    input_addr remote_ip; \n    unsigned int size_ip;\n    unsigned int size_tcp; \n    char* newfile = \"newfile.pcap\";\n    char ErrBuff [1024];\n    int pkt_counter;\n    const u_char *packet;\n    struct pcap_pkthdr *header;\n    pcap_dumper_t *dumpfile;\n    input_addr sip;  /* Source IP */ \n    unsigned int flags;\n    int local_packets = 0;\n    bool initstep1 = false;  /* keep track of successful handshake step */\n    bool warned = false;\n\n    local_ip.byte1=0;\n    local_ip.byte2=0;\n    local_ip.byte3=0;\n    local_ip.byte4=0;\n\n    remote_ip.byte1=0;\n    remote_ip.byte2=0;\n    remote_ip.byte3=0;\n    remote_ip.byte4=0;\n\n    pcap_t *pcap = set_offline_filter(file); \n    if (!pcap){\n        fprintf (stderr, \"Cannot open PCAP file '%s' for reading\\n\", file);\n        fprintf(stderr, \"%s\\n\",ErrBuff);\n        return PCAP_OPEN_ERROR;\n    }\n\n    dumpfile = pcap_dump_open(pcap, newfile);\n    if (!dumpfile) {\n        fprintf (stderr, \"Cannot open PCAP file '%s' for writing\\n\", newfile);\n        return PCAP_OPEN_ERROR;\n    }\n\n    /*Modify each packet's IP & MAC based on the passed args then do a checksum of each packet*/\n    for (pkt_counter = 0; safe_pcap_next_ex(pcap, &header, &packet) > 0; pkt_counter++){\n\n        if (!warned && header->len > header->caplen) {\n            fprintf(stderr, \"warning: packet capture truncated to %d byte packets\\n\",\n                    header->caplen);\n            warned = true;\n        }\n        etherhdr = (ether_hdr*)(packet);\n        iphdr = (ipv4_hdr *)(packet + SIZE_ETHERNET);\n        size_ip = iphdr->ip_hl << 2; \n        if (size_ip < 20) {\n            printf(\"ERROR: Invalid IP header length: %u bytes\\n\", size_ip);\n            return ERROR;\n        }\n        tcphdr = (tcp_hdr *)(packet + SIZE_ETHERNET + size_ip);\n        size_tcp = tcphdr->th_off*4;\n        if (size_tcp < 20) {\n            printf(\"ERROR: Invalid TCP header length: %u bytes\\n\", size_tcp);\n            return ERROR;\n        }\n        /* payload = (u_char *)(packet + SIZE_ETHERNET + size_ip + size_tcp); */\n\n        sip = iphdr->ip_src;\n        flags = tcphdr->th_flags;\n\n        /* set IPs who's local and who's remote based on the SYN flag */\n        if(flags == TH_SYN){\n            local_ip = iphdr->ip_src; \n            remote_ip = iphdr->ip_dst; \n            initstep1 = true; /* This flag is set to signify the first encounter of the SYN within the pacp*/\n        }\n\n        if(compip(&local_ip, &remote_ip, &sip)==LOCAL_IP_MATCH){\n            /* Set the source MAC */\n            etherhdr->ether_shost[0] = mymac->byte1;\n            etherhdr->ether_shost[1] = mymac->byte2;\n            etherhdr->ether_shost[2] = mymac->byte3;\n            etherhdr->ether_shost[3] = mymac->byte4;\n            etherhdr->ether_shost[4] = mymac->byte5;\n            etherhdr->ether_shost[5] = mymac->byte6;\n\n            /* Set the source IP */\n            iphdr->ip_src = *myip;\n            /* Set the destination IP */\n            iphdr->ip_dst = *new_remoteip;\n\n            /* Set the destination MAC */\n            etherhdr->ether_dhost[0] = new_remotemac->byte1;\n            etherhdr->ether_dhost[1] = new_remotemac->byte2;\n            etherhdr->ether_dhost[2] = new_remotemac->byte3;\n            etherhdr->ether_dhost[3] = new_remotemac->byte4;\n            etherhdr->ether_dhost[4] = new_remotemac->byte5;\n            etherhdr->ether_dhost[5] = new_remotemac->byte6;\n\n            /* This is to change the source port, whether it is specified as random or as a port # by the user */\n            tcphdr->th_sport = htons(new_src_port);\n        }\n        else if(compip(&local_ip, &remote_ip, &sip)==REMOTE_IP_MATCH){\n\n            /* Set the destination MAC */\n            etherhdr->ether_dhost[0] = mymac->byte1;\n            etherhdr->ether_dhost[1] = mymac->byte2;\n            etherhdr->ether_dhost[2] = mymac->byte3;\n            etherhdr->ether_dhost[3] = mymac->byte4;\n            etherhdr->ether_dhost[4] = mymac->byte5;\n            etherhdr->ether_dhost[5] = mymac->byte6;\n            /* Set the destination IP */\n            iphdr->ip_dst = *myip;\n            /* Set the source IP */\n            iphdr->ip_src = *new_remoteip;\n            /* Set the source MAC */\n            etherhdr->ether_shost[0] = new_remotemac->byte1;\n            etherhdr->ether_shost[1] = new_remotemac->byte2;\n            etherhdr->ether_shost[2] = new_remotemac->byte3;\n            etherhdr->ether_shost[3] = new_remotemac->byte4;\n            etherhdr->ether_shost[4] = new_remotemac->byte5;\n            etherhdr->ether_shost[5] = new_remotemac->byte6;\n\n            /* This is to change the source port, whether it is specified as random or as a port # by the user */\n            tcphdr->th_dport = htons(new_src_port);\n        }\n\n        /*Calculate & fix checksum for newly edited-packet*/\n        fix_all_checksum_liveplay(iphdr);\n\n        if(initstep1){ /*only start rewriting new pcap with SYN packets on wards*/\n            local_packets ++;\n            pcap_dump((u_char *)dumpfile, header, packet);\n        }\n    } /* end of while loop */\n\n    pcap_close (pcap);\n    pcap_dump_close(dumpfile);\n    return local_packets;\n}", "target": 2, "idx": 10933}
{"commit_id": "92938e5d149669033aecdfb3d1396948d49d1887", "project": "xen-project/xen", "func": "static bool hvm_wait_for_io(struct hvm_ioreq_vcpu *sv, ioreq_t *p)\n{\n    unsigned int prev_state = STATE_IOREQ_NONE;\n\n    while ( sv->pending )\n    {\n        unsigned int state = p->state;\n\n        smp_rmb();\n\n    recheck:\n        if ( unlikely(state == STATE_IOREQ_NONE) )\n        {\n            /*\n             * The only reason we should see this case is when an\n             * emulator is dying and it races with an I/O being\n             * requested.\n             */\n            hvm_io_assist(sv, ~0ul);\n            break;\n        }\n\n        if ( unlikely(state < prev_state) )\n        {\n            gdprintk(XENLOG_ERR, \"Weird HVM ioreq state transition %u -> %u\\n\",\n                     prev_state, state);\n            sv->pending = false;\n            domain_crash(sv->vcpu->domain);\n            return false; /* bail */\n        }\n\n        switch ( prev_state = state )\n        {\n        case STATE_IORESP_READY: /* IORESP_READY -> NONE */\n            p->state = STATE_IOREQ_NONE;\n            hvm_io_assist(sv, p->data);\n            break;\n        case STATE_IOREQ_READY:  /* IOREQ_{READY,INPROCESS} -> IORESP_READY */\n        case STATE_IOREQ_INPROCESS:\n            wait_on_xen_event_channel(sv->ioreq_evtchn,\n                                      ({ state = p->state;\n                                         smp_rmb();\n                                         state != prev_state; }));\n            goto recheck;\n        default:\n            gdprintk(XENLOG_ERR, \"Weird HVM iorequest state %u\\n\", state);\n            sv->pending = false;\n            domain_crash(sv->vcpu->domain);\n            return false; /* bail */\n        }\n    }\n\n    return true;\n}", "target": 1, "idx": 10934}
{"commit_id": "d653f1604b54532f11b45dca1fa164b4a1f15e2d", "project": "brechtsanders/xlsxio", "func": "DLL_EXPORT_XLSXIO xlsxioreadersheetlist xlsxioread_sheetlist_open (xlsxioreader handle)\n{\n  //determine main sheet name\n  XML_Char* mainsheetfile = NULL;\n  iterate_files_by_contenttype(handle->zip, xlsx_content_type, xlsxioread_find_main_sheet_file_callback, &mainsheetfile, NULL);\n  if (!mainsheetfile)\n    iterate_files_by_contenttype(handle->zip, xlsm_content_type, xlsxioread_find_main_sheet_file_callback, &mainsheetfile, NULL);\n  if (!mainsheetfile)\n    iterate_files_by_contenttype(handle->zip, xltx_content_type, xlsxioread_find_main_sheet_file_callback, &mainsheetfile, NULL);\n  if (!mainsheetfile)\n    iterate_files_by_contenttype(handle->zip, xltm_content_type, xlsxioread_find_main_sheet_file_callback, &mainsheetfile, NULL);\n  if (!mainsheetfile)\n    return NULL;\n  //process contents of main sheet\n  xlsxioreadersheetlist result;\n  if ((result = (xlsxioreadersheetlist)malloc(sizeof(struct xlsxio_read_sheetlist_struct))) == NULL)\n    return NULL;\n  result->handle = handle;\n  result->sheetcallbackdata.xmlparser = NULL;\n  result->sheetcallbackdata.callback = xlsxioread_list_sheets_resumable_callback;\n  result->sheetcallbackdata.callbackdata = result;\n  result->xmlparser = NULL;\n  result->nextsheetname = NULL;\n  if ((result->zipfile = XML_Char_openzip(handle->zip, mainsheetfile, 0)) != NULL) {\n    result->xmlparser = expat_process_zip_file_suspendable(result->zipfile, main_sheet_list_expat_callback_element_start, NULL, NULL, &result->sheetcallbackdata);\n  }\n  //clean up\n  free(mainsheetfile);\n  return result;\n}", "target": 2, "idx": 10935}
{"commit_id": "d6bbe53a96b031ab8b53d20241825ddf9e8bf8f1", "project": "libtiff", "func": "static int EstimateStripByteCounts(TIFF *tif, TIFFDirEntry *dir,\n                                   uint16_t dircount)\n{\n    static const char module[] = \"EstimateStripByteCounts\";\n\n    TIFFDirEntry *dp;\n    TIFFDirectory *td = &tif->tif_dir;\n    uint32_t strip;\n\n    /* Do not try to load stripbytecount as we will compute it */\n    if (!_TIFFFillStrilesInternal(tif, 0))\n        return -1;\n\n    /* Before allocating a huge amount of memory for corrupted files, check if\n     * size of requested memory is not greater than file size. */\n    uint64_t filesize = TIFFGetFileSize(tif);\n    uint64_t allocsize = (uint64_t)td->td_nstrips * sizeof(uint64_t);\n    if (allocsize > filesize)\n    {\n        TIFFWarningExtR(tif, module,\n                        \"Requested memory size for StripByteCounts of %\" PRIu64\n                        \" is greather than filesize %\" PRIu64\n                        \". Memory not allocated\",\n                        allocsize, filesize);\n        return -1;\n    }\n\n    if (td->td_stripbytecount_p)\n        _TIFFfreeExt(tif, td->td_stripbytecount_p);\n    td->td_stripbytecount_p = (uint64_t *)_TIFFCheckMalloc(\n        tif, td->td_nstrips, sizeof(uint64_t), \"for \\\"StripByteCounts\\\" array\");\n    if (td->td_stripbytecount_p == NULL)\n        return -1;\n\n    if (td->td_compression != COMPRESSION_NONE)\n    {\n        uint64_t space;\n        uint64_t filesize;\n        uint16_t n;\n        filesize = TIFFGetFileSize(tif);\n        if (!(tif->tif_flags & TIFF_BIGTIFF))\n            space = sizeof(TIFFHeaderClassic) + 2 + dircount * 12 + 4;\n        else\n            space = sizeof(TIFFHeaderBig) + 8 + dircount * 20 + 8;\n        /* calculate amount of space used by indirect values */\n        for (dp = dir, n = dircount; n > 0; n--, dp++)\n        {\n            uint32_t typewidth;\n            uint64_t datasize;\n            typewidth = TIFFDataWidth((TIFFDataType)dp->tdir_type);\n            if (typewidth == 0)\n            {\n                TIFFErrorExtR(\n                    tif, module,\n                    \"Cannot determine size of unknown tag type %\" PRIu16,\n                    dp->tdir_type);\n                return -1;\n            }\n            if (dp->tdir_count > UINT64_MAX / typewidth)\n                return -1;\n            datasize = (uint64_t)typewidth * dp->tdir_count;\n            if (!(tif->tif_flags & TIFF_BIGTIFF))\n            {\n                if (datasize <= 4)\n                    datasize = 0;\n            }\n            else\n            {\n                if (datasize <= 8)\n                    datasize = 0;\n            }\n            if (space > UINT64_MAX - datasize)\n                return -1;\n            space += datasize;\n        }\n        if (filesize < space)\n            /* we should perhaps return in error ? */\n            space = filesize;\n        else\n            space = filesize - space;\n        if (td->td_planarconfig == PLANARCONFIG_SEPARATE)\n            space /= td->td_samplesperpixel;\n        for (strip = 0; strip < td->td_nstrips; strip++)\n            td->td_stripbytecount_p[strip] = space;\n        /*\n         * This gross hack handles the case were the offset to\n         * the last strip is past the place where we think the strip\n         * should begin.  Since a strip of data must be contiguous,\n         * it's safe to assume that we've overestimated the amount\n         * of data in the strip and trim this number back accordingly.\n         */\n        strip--;\n        if (td->td_stripoffset_p[strip] >\n            UINT64_MAX - td->td_stripbytecount_p[strip])\n            return -1;\n        if (td->td_stripoffset_p[strip] + td->td_stripbytecount_p[strip] >\n            filesize)\n        {\n            if (td->td_stripoffset_p[strip] >= filesize)\n            {\n                /* Not sure what we should in that case... */\n                td->td_stripbytecount_p[strip] = 0;\n            }\n            else\n            {\n                td->td_stripbytecount_p[strip] =\n                    filesize - td->td_stripoffset_p[strip];\n            }\n        }\n    }\n    else if (isTiled(tif))\n    {\n        uint64_t bytespertile = TIFFTileSize64(tif);\n\n        for (strip = 0; strip < td->td_nstrips; strip++)\n            td->td_stripbytecount_p[strip] = bytespertile;\n    }\n    else\n    {\n        uint64_t rowbytes = TIFFScanlineSize64(tif);\n        uint32_t rowsperstrip = td->td_imagelength / td->td_stripsperimage;\n        for (strip = 0; strip < td->td_nstrips; strip++)\n        {\n            if (rowbytes > 0 && rowsperstrip > UINT64_MAX / rowbytes)\n                return -1;\n            td->td_stripbytecount_p[strip] = rowbytes * rowsperstrip;\n        }\n    }\n    TIFFSetFieldBit(tif, FIELD_STRIPBYTECOUNTS);\n    if (!TIFFFieldSet(tif, FIELD_ROWSPERSTRIP))\n        td->td_rowsperstrip = td->td_imagelength;\n    return 1;\n}", "target": 1, "idx": 10936}
{"commit_id": "dfd0743f1d9ea76931510ed150334d571fbab49d", "project": "torvalds/linux", "func": "struct tee_shm *tee_shm_get_from_id(struct tee_context *ctx, int id)\n{\n\tstruct tee_device *teedev;\n\tstruct tee_shm *shm;\n\n\tif (!ctx)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tteedev = ctx->teedev;\n\tmutex_lock(&teedev->mutex);\n\tshm = idr_find(&teedev->idr, id);\n\t/*\n\t * If the tee_shm was found in the IDR it must have a refcount\n\t * larger than 0 due to the guarantee in tee_shm_put() below. So\n\t * it's safe to use refcount_inc().\n\t */\n\tif (!shm || shm->ctx != ctx)\n\t\tshm = ERR_PTR(-EINVAL);\n\telse\n\t\trefcount_inc(&shm->refcount);\n\tmutex_unlock(&teedev->mutex);\n\treturn shm;\n}", "target": 2, "idx": 10937}
{"commit_id": "2d782cdaa2112c10b8dd5e7a93c134b2ada9c1a6", "project": "radareorg/radare2", "func": "RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {\n\tint i;\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tRList *segments = r_list_newf (free);\n\tfor (i = 0; i < bin->ne_header->SegCount; i++) {\n\t\tRBinSection *bs = R_NEW0 (RBinSection);\n\t\tif (!bs) {\n\t\t\treturn segments;\n\t\t}\n\t\tNE_image_segment_entry *se = &bin->segment_entries[i];\n\t\tbs->size = se->length;\n\t\tbs->vsize = se->minAllocSz ? se->minAllocSz : 64000;\n\t\tbs->bits = R_SYS_BITS_16;\n\t\tbs->is_data = se->flags & IS_DATA;\n\t\tbs->perm = __translate_perms (se->flags);\n\t\tbs->paddr = (ut64)se->offset * bin->alignment;\n\t\tbs->name = r_str_newf (\"%s.%\" PFMT64d, se->flags & IS_MOVEABLE ? \"MOVEABLE\" : \"FIXED\", bs->paddr);\n\t\tbs->is_segment = true;\n\t\tr_list_append (segments, bs);\n\t}\n\tbin->segments = segments;\n\treturn segments;\n}", "target": 2, "idx": 10938}
{"commit_id": "c992857618db99776917f10bf4f2345a5fdc78b0", "project": "redis", "func": "void *zmalloc(size_t size) {\n    ASSERT_NO_SIZE_OVERFLOW(size);\n    void *ptr = malloc(size+PREFIX_SIZE);\n\n    if (!ptr) zmalloc_oom_handler(size);\n#ifdef HAVE_MALLOC_SIZE\n    update_zmalloc_stat_alloc(zmalloc_size(ptr));\n    return ptr;\n#else\n    *((size_t*)ptr) = size;\n    update_zmalloc_stat_alloc(size+PREFIX_SIZE);\n    return (char*)ptr+PREFIX_SIZE;\n#endif\n}", "target": 1, "idx": 10939}
{"commit_id": "1c88bbd728da6bff8f4533bcfdb0dfef4ed8038b", "project": "wernsey/bitmap", "func": "BmFont *bm_get_font(Bitmap *b) {\n    assert(b);\n\treturn b->font;\n}", "target": 2, "idx": 10940}
{"commit_id": "ab04483ee1a846d6b74b2e6248e980152baec3f6", "project": "cacalabs/libcaca", "func": "static void *export_html3(caca_canvas_t const *cv, size_t *bytes)\n{\n    char *data, *cur;\n    int x, y, len;\n    int has_multi_cell_row = 0;\n    unsigned char *cell_boundary_bitmap;\n\n    /* Table */\n    cell_boundary_bitmap = (unsigned char *) malloc((cv->width + 7) / 8);\n    if(cell_boundary_bitmap)\n        memset((void *) cell_boundary_bitmap, 0, (cv->width + 7) / 8);\n    for(y = 0; y < cv->height; y++)\n    {\n        uint32_t *lineattr = cv->attrs + y * cv->width;\n        uint32_t *linechar = cv->chars + y * cv->width;\n\n        for(x = 1; x < cv->width; x++)\n            if((! (cell_boundary_bitmap\n                   ?\n                   (cell_boundary_bitmap[x / 8] & (1 << (x % 8)))\n                   :\n                   has_multi_cell_row))\n               &&\n               (((linechar[x - 1] == CACA_MAGIC_FULLWIDTH)\n                 &&\n                 (! caca_utf32_is_fullwidth(linechar[x])))\n                ||\n                (caca_attr_to_ansi_bg(lineattr[x - 1])\n                 !=\n                 caca_attr_to_ansi_bg(lineattr[x]))\n                ||\n                ((caca_attr_to_ansi_bg(lineattr[x]) < 0x10)\n                 ?\n                 (_caca_attr_to_rgb24bg(lineattr[x - 1])\n                  !=\n                  _caca_attr_to_rgb24bg(lineattr[x]))\n                 :\n                 0)))\n            {\n                has_multi_cell_row = 1;\n                if(cell_boundary_bitmap)\n                    cell_boundary_bitmap[x / 8] |= 1 << (x % 8);\n            }\n    }\n\n    /* The HTML table markup: less than 1000 bytes\n     * A line: 10 chars for \"<tr></tr>\\n\"\n     * A glyph: up to 48 chars for \"<td bgcolor=\\\"#xxxxxx\\\"><tt><font color=\\\"#xxxxxx\\\">\"\n     *          up to 36 chars for \"<b><i><u><blink></blink></u></i></b>\"\n     *          up to 10 chars for \"&#xxxxxxx;\" (far less for pure ASCII)\n     *          17 chars for \"</font></tt></td>\" */\n    *bytes = 1000 + cv->height * (10 + cv->width * (48 + 36 + 10 + 17));\n    cur = data = malloc(*bytes);\n\n    cur += sprintf(cur, \"<table border=\\\"0\\\" cellpadding=\\\"0\\\" cellspacing=\\\"0\\\" summary=\\\"[libcaca canvas export]\\\">\\n\");\n\n    for(y = 0; y < cv->height; y++)\n    {\n        uint32_t *lineattr = cv->attrs + y * cv->width;\n        uint32_t *linechar = cv->chars + y * cv->width;\n\n        cur += sprintf(cur, \"<tr>\");\n\n        for(x = 0; x < cv->width; x += len)\n        {\n            int i, needfont = 0;\n            int nonblank = 0;\n\n            /* Use colspan option to factor cells with same attributes\n             * (see below) */\n            len = 1;\n            while((x + len < cv->width)\n                  &&\n                  ((y\n                    &&\n                    (linechar[x + len] > 0x00000020)\n                    &&\n                    ((linechar[x + len] < 0x0000007f)\n                     ||\n                     (linechar[x + len] > 0x000000a0)))\n                   ||\n                   (! (cell_boundary_bitmap\n                       ?\n                       (cell_boundary_bitmap[(x + len) / 8] & (1 << ((x + len) % 8)))\n                       :\n                       has_multi_cell_row))\n                   ||\n                   (linechar[x + len] == CACA_MAGIC_FULLWIDTH)\n                   ||\n                   (cv->height == 1))\n                  &&\n                  ((linechar[x + len - 1] != CACA_MAGIC_FULLWIDTH)\n                   ||\n                   caca_utf32_is_fullwidth(linechar[x + len]))\n                  &&\n                  (caca_attr_to_ansi_bg(lineattr[x + len])\n                   ==\n                   caca_attr_to_ansi_bg(lineattr[x]))\n                  &&\n                  ((caca_attr_to_ansi_bg(lineattr[x]) < 0x10)\n                   ?\n                   (_caca_attr_to_rgb24bg(lineattr[x + len])\n                    ==\n                    _caca_attr_to_rgb24bg(lineattr[x]))\n                   :\n                   1))\n                len++;\n\n            for(i = 0; i < len; i++)\n                if(! ((linechar[x + i] <= 0x00000020)\n                      ||\n                      ((linechar[x + i] >= 0x0000007f)\n                       &&\n                       (linechar[x + i] <= 0x000000a0))))\n                    nonblank = 1;\n\n            cur += sprintf(cur, \"<td\");\n\n            if(caca_attr_to_ansi_bg(lineattr[x]) < 0x10)\n                cur += sprintf(cur, \" bgcolor=\\\"#%.06lx\\\"\", (unsigned long int)\n                               _caca_attr_to_rgb24bg(lineattr[x]));\n\n            if(has_multi_cell_row && (len > 1))\n            {\n                int colspan;\n\n                colspan = len;\n                if(cell_boundary_bitmap)\n                    for(i = 0; i < len; i ++)\n                        if(i\n                           &&\n                           ! (cell_boundary_bitmap[(x + i) / 8]\n                              &\n                              (1 << ((x + i) % 8))))\n                            colspan --;\n                if(colspan > 1)\n                    cur += sprintf(cur, \" colspan=\\\"%d\\\"\", colspan);\n            }\n\n            cur += sprintf(cur, \">\");\n\n            cur += sprintf(cur, \"<tt>\");\n\n            for(i = 0; i < len; i++)\n            {\n                if(nonblank\n                   &&\n                   ((! i)\n                    ||\n                    (lineattr[x + i] != lineattr[x + i - 1])))\n                {\n                    needfont = (caca_attr_to_ansi_fg(lineattr[x + i])\n                                !=\n                                CACA_DEFAULT);\n\n                    if(needfont)\n                        cur += sprintf(cur, \"<font color=\\\"#%.06lx\\\">\",\n                                       (unsigned long int)\n                                       _caca_attr_to_rgb24fg(lineattr[x + i]));\n\n                    if(lineattr[x + i] & CACA_BOLD)\n                        cur += sprintf(cur, \"<b>\");\n                    if(lineattr[x + i] & CACA_ITALICS)\n                        cur += sprintf(cur, \"<i>\");\n                    if(lineattr[x + i] & CACA_UNDERLINE)\n                        cur += sprintf(cur, \"<u>\");\n                    if(lineattr[x + i] & CACA_BLINK)\n                        cur += sprintf(cur, \"<blink>\");\n                }\n\n                if(linechar[x + i] == CACA_MAGIC_FULLWIDTH)\n                    ;\n                else if((linechar[x + i] <= 0x00000020)\n                        ||\n                        ((linechar[x + i] >= 0x0000007f)\n                         &&\n                         (linechar[x + i] <= 0x000000a0)))\n                {\n                    /* Control characters and space converted to\n                     * U+00A0 NO-BREAK SPACE, a.k.a. \"&nbsp;\" in HTML,\n                     * but we use the equivalent numeric character\n                     * reference &#160; so this will work in plain\n                     * XHTML with no DTD too. */\n                    cur += sprintf(cur, \"&#160;\");\n                }\n                else if(linechar[x + i] == '&')\n                    cur += sprintf(cur, \"&amp;\");\n                else if(linechar[x + i] == '<')\n                    cur += sprintf(cur, \"&lt;\");\n                else if(linechar[x + i] == '>')\n                    cur += sprintf(cur, \"&gt;\");\n                else if(linechar[x + i] == '\\\"')\n                    cur += sprintf(cur, \"&quot;\");\n                else if(linechar[x + i] == '\\'')\n                    cur += sprintf(cur, \"&#39;\");\n                else if(linechar[x + i] < 0x00000080)\n                    cur += write_u8(cur, (uint8_t)linechar[x + i]);\n                else if((linechar[x + i] <= 0x0010fffd)\n                        &&\n                        ((linechar[x + i] & 0x0000fffe) != 0x0000fffe)\n                        &&\n                        ((linechar[x + i] < 0x0000d800)\n                         ||\n                         (linechar[x + i] > 0x0000dfff)))\n                    cur += sprintf(cur, \"&#%i;\", (unsigned int)linechar[x + i]);\n                else\n                    /* non-character codepoints become U+FFFD\n                     * REPLACEMENT CHARACTER */\n                    cur += sprintf(cur, \"&#%i;\", (unsigned int)0x0000fffd);\n\n                if (nonblank\n                    &&\n                    (((i + 1) == len)\n                     ||\n                     (lineattr[x + i + 1] != lineattr[x + i])))\n                {\n                    if(lineattr[x + i] & CACA_BLINK)\n                        cur += sprintf(cur, \"</blink>\");\n                    if(lineattr[x + i] & CACA_UNDERLINE)\n                        cur += sprintf(cur, \"</u>\");\n                    if(lineattr[x + i] & CACA_ITALICS)\n                        cur += sprintf(cur, \"</i>\");\n                    if(lineattr[x + i] & CACA_BOLD)\n                        cur += sprintf(cur, \"</b>\");\n\n                    if(needfont)\n                        cur += sprintf(cur, \"</font>\");\n                }\n            }\n\n            cur += sprintf(cur, \"</tt>\");\n            cur += sprintf(cur, \"</td>\");\n        }\n        cur += sprintf(cur, \"</tr>\\n\");\n    }\n\n    /* Footer */\n    cur += sprintf(cur, \"</table>\\n\");\n\n    /* Free working memory */\n    if (cell_boundary_bitmap)\n        free((void *) cell_boundary_bitmap);\n\n    /* Crop to really used size */\n    debug(\"html3 export: alloc %lu bytes, realloc %lu\",\n          (unsigned long int)*bytes, (unsigned long int)(cur - data));\n    *bytes = (uintptr_t)(cur - data);\n    data = realloc(data, *bytes);\n\n    return data;\n}", "target": 2, "idx": 10941}
{"commit_id": "779309744222a736eba0f1731e8162fce6288d4e", "project": "freetype/freetype2", "func": "FT_LOCAL_DEF( FT_Error )\n  sfnt_init_face( FT_Stream      stream,\n                  TT_Face        face,\n                  FT_Int         face_instance_index,\n                  FT_Int         num_params,\n                  FT_Parameter*  params )\n  {\n    FT_Error      error;\n    FT_Memory     memory = face->root.memory;\n    FT_Library    library = face->root.driver->root.library;\n    SFNT_Service  sfnt;\n    FT_Int        face_index;\n\n\n    /* for now, parameters are unused */\n    FT_UNUSED( num_params );\n    FT_UNUSED( params );\n\n\n    sfnt = (SFNT_Service)face->sfnt;\n    if ( !sfnt )\n    {\n      sfnt = (SFNT_Service)FT_Get_Module_Interface( library, \"sfnt\" );\n      if ( !sfnt )\n      {\n        FT_ERROR(( \"sfnt_init_face: cannot access `sfnt' module\\n\" ));\n        return FT_THROW( Missing_Module );\n      }\n\n      face->sfnt       = sfnt;\n      face->goto_table = sfnt->goto_table;\n    }\n\n    FT_FACE_FIND_GLOBAL_SERVICE( face, face->psnames, POSTSCRIPT_CMAPS );\n\n#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n    if ( !face->mm )\n    {\n      /* we want the MM interface from the `truetype' module only */\n      FT_Module  tt_module = FT_Get_Module( library, \"truetype\" );\n\n\n      face->mm = ft_module_get_service( tt_module,\n                                        FT_SERVICE_ID_MULTI_MASTERS,\n                                        0 );\n    }\n\n    if ( !face->var )\n    {\n      /* we want the metrics variations interface */\n      /* from the `truetype' module only          */\n      FT_Module  tt_module = FT_Get_Module( library, \"truetype\" );\n\n\n      face->var = ft_module_get_service( tt_module,\n                                         FT_SERVICE_ID_METRICS_VARIATIONS,\n                                         0 );\n    }\n#endif\n\n    FT_TRACE2(( \"SFNT driver\\n\" ));\n\n    error = sfnt_open_font( stream, face );\n    if ( error )\n      return error;\n\n    /* Stream may have changed in sfnt_open_font. */\n    stream = face->root.stream;\n\n    FT_TRACE2(( \"sfnt_init_face: %08p, %d\\n\", face, face_instance_index ));\n\n    face_index = FT_ABS( face_instance_index ) & 0xFFFF;\n\n    /* value -(N+1) requests information on index N */\n    if ( face_instance_index < 0 )\n      face_index--;\n\n    if ( face_index >= face->ttc_header.count )\n    {\n      if ( face_instance_index >= 0 )\n        return FT_THROW( Invalid_Argument );\n      else\n        face_index = 0;\n    }\n\n    if ( FT_STREAM_SEEK( face->ttc_header.offsets[face_index] ) )\n      return error;\n\n    /* check whether we have a valid TrueType file */\n    error = sfnt->load_font_dir( face, stream );\n    if ( error )\n      return error;\n\n#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n    {\n      FT_ULong  fvar_len;\n\n      FT_ULong  version;\n      FT_ULong  offset;\n\n      FT_UShort  num_axes;\n      FT_UShort  axis_size;\n      FT_UShort  num_instances;\n      FT_UShort  instance_size;\n\n      FT_Int  instance_index;\n\n      FT_Byte*  default_values  = NULL;\n      FT_Byte*  instance_values = NULL;\n\n\n      face->is_default_instance = 1;\n\n      instance_index = FT_ABS( face_instance_index ) >> 16;\n\n      /* test whether current face is a GX font with named instances */\n      if ( face->goto_table( face, TTAG_fvar, stream, &fvar_len ) ||\n           fvar_len < 20                                          ||\n           FT_READ_ULONG( version )                               ||\n           FT_READ_USHORT( offset )                               ||\n           FT_STREAM_SKIP( 2 ) /* reserved */                     ||\n           FT_READ_USHORT( num_axes )                             ||\n           FT_READ_USHORT( axis_size )                            ||\n           FT_READ_USHORT( num_instances )                        ||\n           FT_READ_USHORT( instance_size )                        )\n      {\n        version       = 0;\n        offset        = 0;\n        num_axes      = 0;\n        axis_size     = 0;\n        num_instances = 0;\n        instance_size = 0;\n      }\n\n      /* check that the data is bound by the table length */\n      if ( version != 0x00010000UL                    ||\n           axis_size != 20                            ||\n           num_axes == 0                              ||\n           /* `num_axes' limit implied by 16-bit `instance_size' */\n           num_axes > 0x3FFE                          ||\n           !( instance_size == 4 + 4 * num_axes ||\n              instance_size == 6 + 4 * num_axes )     ||\n           /* `num_instances' limit implied by limited range of name IDs */\n           num_instances > 0x7EFF                     ||\n           offset                          +\n             axis_size * num_axes          +\n             instance_size * num_instances > fvar_len )\n        num_instances = 0;\n      else\n        face->variation_support |= TT_FACE_FLAG_VAR_FVAR;\n\n      /*\n       *  As documented in the OpenType specification, an entry for the\n       *  default instance may be omitted in the named instance table.  In\n       *  particular this means that even if there is no named instance\n       *  table in the font we actually do have a named instance, namely the\n       *  default instance.\n       *\n       *  For consistency, we always want the default instance in our list\n       *  of named instances.  If it is missing, we try to synthesize it\n       *  later on.  Here, we have to adjust `num_instances' accordingly.\n       */\n\n      if ( !( FT_ALLOC( default_values, num_axes * 2 )  ||\n              FT_ALLOC( instance_values, num_axes * 2 ) ) )\n      {\n        /* the current stream position is 16 bytes after the table start */\n        FT_ULong  array_start = FT_STREAM_POS() - 16 + offset;\n        FT_ULong  default_value_offset, instance_offset;\n\n        FT_Byte*  p;\n        FT_UInt   i;\n\n\n        default_value_offset = array_start + 8;\n        p                    = default_values;\n\n        for ( i = 0; i < num_axes; i++ )\n        {\n          (void)FT_STREAM_READ_AT( default_value_offset, p, 2 );\n\n          default_value_offset += axis_size;\n          p                    += 2;\n        }\n\n        instance_offset = array_start + axis_size * num_axes + 4;\n\n        for ( i = 0; i < num_instances; i++ )\n        {\n          (void)FT_STREAM_READ_AT( instance_offset,\n                                   instance_values,\n                                   num_axes * 2 );\n\n          if ( !ft_memcmp( default_values, instance_values, num_axes * 2 ) )\n            break;\n\n          instance_offset += instance_size;\n        }\n\n        if ( i == num_instances )\n        {\n          /* no default instance in named instance table; */\n          /* we thus have to synthesize it                */\n          num_instances++;\n        }\n      }\n\n      FT_FREE( default_values );\n      FT_FREE( instance_values );\n\n      /* we don't support Multiple Master CFFs yet */\n      if ( face->goto_table( face, TTAG_glyf, stream, 0 ) &&\n           !face->goto_table( face, TTAG_CFF, stream, 0 ) )\n        num_instances = 0;\n\n      /* instance indices in `face_instance_index' start with index 1, */\n      /* thus `>' and not `>='                                         */\n      if ( instance_index > num_instances )\n      {\n        if ( face_instance_index >= 0 )\n          return FT_THROW( Invalid_Argument );\n        else\n          num_instances = 0;\n      }\n\n      face->root.style_flags = (FT_Long)num_instances << 16;\n    }\n#endif\n\n    face->root.num_faces  = face->ttc_header.count;\n    face->root.face_index = face_instance_index;\n\n    return error;\n  }", "target": 3, "idx": 10942}
{"commit_id": "4e56ad72ac1afb4e049a10f2d99e7512d7141f9d", "project": "gpac", "func": "GF_Err gf_odf_read_descriptor(GF_BitStream *bs, GF_Descriptor *desc, u32 DescSize)\n{\n\tu64 cookie = gf_bs_get_cookie(bs);\n\t//we allow 100 max desc in a hierarchy - see issue 2216\n\tif (cookie>100)\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\tgf_bs_set_cookie(bs, cookie+1);\n\tGF_Err e = gf_odf_read_descriptor_internal(bs, desc, DescSize);\n\tgf_bs_set_cookie(bs, cookie);\n\treturn e;\n}", "target": 2, "idx": 10943}
{"commit_id": "8d8b5b963fa64c7a2122d1bbfbb0bed46e813e59", "project": "lwindolf/liferea", "func": "static void\nupdate_job_run (updateJobPtr job)\n{\n\t/* Here we decide on the source type and the proper execution\n\t   methods which then do anything they want with the job and\n\t   pass the processed job to update_process_finished_job()\n\t   for result dequeuing */\n\n\t/* everything starting with '|' is a local command */\n\tif (*(job->request->source) == '|') {\n\t\tif (job->request->allowCommands) {\n\t\t\tdebug1 (DEBUG_UPDATE, \"Recognized local command: %s\", job->request->source);\n\t\t\tupdate_exec_cmd (job);\n\t\t} else {\n\t\t\tdebug1 (DEBUG_UPDATE, \"Refusing to run local command from unexpected source: %s\", job->request->source);\n\t\t\tjob->result->httpstatus = 403;  /* Forbidden. */\n\t\t\tupdate_process_finished_job (job);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* if it has a protocol \"://\" prefix, but not \"file://\" it is an URI */\n\tif (strstr (job->request->source, \"://\") && strncmp (job->request->source, \"file://\", 7)) {\n\t\tnetwork_process_request (job);\n\t\treturn;\n\t}\n\n\t/* otherwise it must be a local file... */\n\t{\n\t\tdebug1 (DEBUG_UPDATE, \"Recognized file URI: %s\", job->request->source);\n\t\tupdate_load_file (job);\n\t\treturn;\n\t}\n}", "target": 3, "idx": 10944}
{"commit_id": "7861fcad13c497728189feafb41cd57b5b50ea25", "project": "ArtifexSoftware/ghostpdl", "func": "static int\nsampled_data_continue(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    gs_sampled_data_enum *penum = senum;\n    gs_function_Sd_params_t * params =\n            (gs_function_Sd_params_t *)&penum->pfn->params;\n    int i, j, num_out = params->n;\n    int code = 0;\n    byte * data_ptr;\n    double sampled_data_value_max = (double)((1 << params->BitsPerSample) - 1);\n    int bps = bits2bytes(params->BitsPerSample), stack_depth_adjust = 0;\n\n    /*\n     * Check to make sure that the procedure produced the correct number of\n     * values.  If not, move the stack back to where it belongs and abort\n     */\n    if (num_out + O_STACK_PAD + penum->o_stack_depth != ref_stack_count(&o_stack)) {\n        stack_depth_adjust = ref_stack_count(&o_stack) - penum->o_stack_depth;\n\n        if (stack_depth_adjust < 0) {\n            /*\n             * If we get to here then there were major problems.  The function\n             * removed too many items off of the stack.  We had placed extra\n             * (unused) stack stack space to allow for this but the function\n             * exceeded even that.  Data on the stack may have been lost.\n             * The only thing that we can do is move the stack pointer back and\n             * hope.  (We have not seen real Postscript files that have this\n             * problem.)\n             */\n            push(-stack_depth_adjust);\n            ifree_object(penum->pfn, \"sampled_data_continue(pfn)\");\n            ifree_object(penum, \"sampled_data_continue((enum)\");\n            return_error(gs_error_undefinedresult);\n        }\n    }\n\n    /* Save data from the given function */\n    data_ptr = cube_ptr_from_index(params, penum->indexes);\n    for (i=0; i < num_out; i++) {\n        ulong cv;\n        double value;\n        double rmin = params->Range[2 * i];\n        double rmax = params->Range[2 * i + 1];\n\n        code = real_param(op + i - num_out + 1, &value);\n        if (code < 0) {\n            esp -= estack_storage;\n            return code;\n        }\n        if (value < rmin)\n            value = rmin;\n        else if (value > rmax)\n            value = rmax;\n        value = (value - rmin) / (rmax - rmin);\t\t/* Convert to 0 to 1.0 */\n        cv = (int) (value * sampled_data_value_max + 0.5);\n        for (j = 0; j < bps; j++)\n            data_ptr[bps * i + j] = (byte)(cv >> ((bps - 1 - j) * 8));\t/* MSB first */\n    }\n    pop(num_out);\t\t    /* Move op to base of result values */\n\n    /* Check if we are done collecting data. */\n\n    if (increment_cube_indexes(params, penum->indexes)) {\n        if (stack_depth_adjust == 0)\n            pop(O_STACK_PAD);\t    /* Remove spare stack space */\n        else\n            pop(stack_depth_adjust - num_out);\n        /* Execute the closing procedure, if given */\n        code = 0;\n        if (esp_finish_proc != 0)\n            code = esp_finish_proc(i_ctx_p);\n\n        return code;\n    } else {\n        if (stack_depth_adjust) {\n            stack_depth_adjust -= num_out;\n            if ((O_STACK_PAD - stack_depth_adjust) < 0) {\n                stack_depth_adjust = -(O_STACK_PAD - stack_depth_adjust);\n                check_op(stack_depth_adjust);\n                pop(stack_depth_adjust);\n            }\n            else {\n                check_ostack(O_STACK_PAD - stack_depth_adjust);\n                push(O_STACK_PAD - stack_depth_adjust);\n                for (i=0;i<O_STACK_PAD - stack_depth_adjust;i++)\n                    make_null(op - i);\n            }\n        }\n    }\n\n    /* Now get the data for the next location */\n\n    return sampled_data_sample(i_ctx_p);\n}", "target": 1, "idx": 10945}
{"commit_id": "3f6fe4dfef6f57e768260b48166c27d148f3015f", "project": "tensorflow", "func": "void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const Tensor& filter = context->input(1);\n    const Tensor& out_backprop = context->input(2);\n\n    // Determine relevant sizes from input and filters.\n    int stride_rows = 0, stride_cols = 0;\n    int rate_rows = 0, rate_cols = 0;\n    int64 pad_top = 0, pad_left = 0;\n    int64 out_rows = 0, out_cols = 0;\n    ParseSizes(context, strides_, rates_, padding_, &stride_rows, &stride_cols,\n               &rate_rows, &rate_cols, &pad_top, &pad_left, &out_rows,\n               &out_cols);\n    if (!context->status().ok()) return;\n\n    // Verify that the incoming gradient tensor has the expected size\n    // [ batch, out_rows, out_cols, depth ]\n    const int batch = input.dim_size(0);\n    const int depth = input.dim_size(3);\n    OP_REQUIRES(context,\n                batch == out_backprop.dim_size(0) &&\n                    out_rows == out_backprop.dim_size(1) &&\n                    out_cols == out_backprop.dim_size(2) &&\n                    depth == out_backprop.dim_size(3),\n                errors::InvalidArgument(\"out_backprop has incompatible size.\"));\n\n    // The computed filter_backprop has the same dimensions as the filter:\n    // [ batch, input_rows, input_cols, depth ]\n    Tensor* filter_backprop = nullptr;\n    OP_REQUIRES_OK(\n        context, context->allocate_output(0, filter.shape(), &filter_backprop));\n\n    // If there is nothing to compute, return.\n    if (filter.shape().num_elements() == 0) {\n      return;\n    }\n\n    functor::DilationBackpropFilter<Device, T>()(\n        context->eigen_device<Device>(), input.tensor<T, 4>(),\n        filter.tensor<T, 3>(), out_backprop.tensor<T, 4>(), stride_rows,\n        stride_cols, rate_rows, rate_cols, pad_top, pad_left,\n        filter_backprop->tensor<T, 3>());\n  }", "target": 0, "idx": 10946}
{"commit_id": "41e6f7d6ba67b61d911f9b1d76325cd79224753d", "project": "vim", "func": "int\nbuf_contents_changed(buf_T *buf)\n{\n    buf_T\t*newbuf;\n    int\t\tdiffer = TRUE;\n    linenr_T\tlnum;\n    aco_save_T\taco;\n    exarg_T\tea;\n\n    // Allocate a buffer without putting it in the buffer list.\n    newbuf = buflist_new(NULL, NULL, (linenr_T)1, BLN_DUMMY);\n    if (newbuf == NULL)\n\treturn TRUE;\n\n    // Force the 'fileencoding' and 'fileformat' to be equal.\n    if (prep_exarg(&ea, buf) == FAIL)\n    {\n\twipe_buffer(newbuf, FALSE);\n\treturn TRUE;\n    }\n\n    // Set curwin/curbuf to buf and save a few things.\n    aucmd_prepbuf(&aco, newbuf);\n    if (curbuf != newbuf)\n    {\n\t// Failed to find a window for \"newbuf\".\n\twipe_buffer(newbuf, FALSE);\n\treturn TRUE;\n    }\n\n    // We don't want to trigger autocommands now, they may have nasty\n    // side-effects like wiping buffers\n    block_autocmds();\n    if (ml_open(curbuf) == OK\n\t    && readfile(buf->b_ffname, buf->b_fname,\n\t\t\t\t  (linenr_T)0, (linenr_T)0, (linenr_T)MAXLNUM,\n\t\t\t\t\t    &ea, READ_NEW | READ_DUMMY) == OK)\n    {\n\t// compare the two files line by line\n\tif (buf->b_ml.ml_line_count == curbuf->b_ml.ml_line_count)\n\t{\n\t    differ = FALSE;\n\t    for (lnum = 1; lnum <= curbuf->b_ml.ml_line_count; ++lnum)\n\t\tif (STRCMP(ml_get_buf(buf, lnum, FALSE), ml_get(lnum)) != 0)\n\t\t{\n\t\t    differ = TRUE;\n\t\t    break;\n\t\t}\n\t}\n    }\n    vim_free(ea.cmd);\n\n    // restore curwin/curbuf and a few other things\n    aucmd_restbuf(&aco);\n\n    if (curbuf != newbuf)\t// safety check\n\twipe_buffer(newbuf, FALSE);\n\n    unblock_autocmds();\n\n    return differ;\n}", "target": 2, "idx": 10947}
{"commit_id": "348d7722c1e90c7811b43b0eed5c2aca2cb8a717", "project": "gpac", "func": "GF_Err latm_dmx_process(GF_Filter *filter)\n{\n\tGF_LATMDmxCtx *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck, *dst_pck;\n\tu32 pos;\n\tu8 *data=NULL, *output;\n\tu32 pck_size=0, prev_pck_size;\n\tu64 cts = GF_FILTER_NO_TS;\n\n\tif (ctx->in_error)\n\t\treturn ctx->in_error;\n\n\t//always reparse duration\n\tif (!ctx->duration.num)\n\t\tlatm_dmx_check_dur(filter, ctx);\n\n\tif (ctx->opid && !ctx->is_playing)\n\t\treturn GF_OK;\n\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (!pck) {\n\t\tif (gf_filter_pid_is_eos(ctx->ipid)) {\n\t\t\tif (!ctx->latm_buffer_size) {\n\t\t\t\tif (ctx->opid)\n\t\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\t\tctx->src_pck = NULL;\n\t\t\t\treturn GF_EOS;\n\t\t\t}\n\t\t} else {\n\t\t\treturn GF_OK;\n\t\t}\n\t} else {\n\t\tdata = (char *) gf_filter_pck_get_data(pck, &pck_size);\n\t}\n\n\t//input pid sets some timescale - we flushed pending data , update cts\n\tif (ctx->timescale && pck) {\n\t\tcts = gf_filter_pck_get_cts(pck);\n\t\t//init cts at first packet\n\t\tif (!ctx->cts && (cts != GF_FILTER_NO_TS))\n\t\t\tctx->cts = cts;\n\t}\n\n\tprev_pck_size = ctx->latm_buffer_size;\n\n\tif (pck && !ctx->resume_from) {\n\t\tif (ctx->latm_buffer_size + pck_size > ctx->latm_buffer_alloc) {\n\t\t\tctx->latm_buffer_alloc = ctx->latm_buffer_size + pck_size;\n\t\t\tctx->latm_buffer = gf_realloc(ctx->latm_buffer, ctx->latm_buffer_alloc);\n\t\t}\n\t\tmemcpy(ctx->latm_buffer + ctx->latm_buffer_size, data, pck_size);\n\t\tctx->latm_buffer_size += pck_size;\n\t}\n\n\tif (!ctx->bs) ctx->bs = gf_bs_new(ctx->latm_buffer, ctx->latm_buffer_size, GF_BITSTREAM_READ);\n\telse gf_bs_reassign_buffer(ctx->bs, ctx->latm_buffer, ctx->latm_buffer_size);\n\n\tif (ctx->resume_from) {\n\t\tgf_bs_seek(ctx->bs, ctx->resume_from-1);\n\t\tctx->resume_from = 0;\n\t}\n\n\tif (cts == GF_FILTER_NO_TS)\n\t\tprev_pck_size = 0;\n\n\n\twhile (1) {\n\t\tpos = (u32) gf_bs_get_position(ctx->bs);\n\t\tu8 latm_buffer[LATM_DMX_MAX_SIZE];\n\t\tu32 latm_frame_size = LATM_DMX_MAX_SIZE;\n\t\tif (!latm_dmx_sync_frame_bs(ctx->bs,&ctx->acfg, &latm_frame_size, latm_buffer, NULL)) break;\n\n\t\tif (ctx->in_seek) {\n\t\t\tu64 nb_samples_at_seek = (u64) (ctx->start_range * GF_M4ASampleRates[ctx->sr_idx]);\n\t\t\tif (ctx->cts + ctx->dts_inc >= nb_samples_at_seek) {\n\t\t\t\t//u32 samples_to_discard = (ctx->cts + ctx->dts_inc) - nb_samples_at_seek;\n\t\t\t\tctx->in_seek = GF_FALSE;\n\t\t\t}\n\t\t}\n\n\t\tlatm_dmx_check_pid(filter, ctx);\n\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->resume_from = pos+1;\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\tif (!ctx->in_seek) {\n\t\t\tGF_FilterSAPType sap = GF_FILTER_SAP_1;\n\n\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, latm_frame_size, &output);\n\t\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\n\t\t\tmemcpy(output, latm_buffer, latm_frame_size);\n\n\t\t\tgf_filter_pck_set_cts(dst_pck, ctx->cts);\n\t\t\tgf_filter_pck_set_duration(dst_pck, ctx->dts_inc);\n\t\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);\n\n\t\t\t/*xHE-AAC, check RAP*/\n\t\t\tif (ctx->acfg.base_object_type==GF_CODECID_USAC) {\n\t\t\t\tif (latm_frame_size && (output[0] & 0x80) && !ctx->prev_sap) {\n\t\t\t\t\tsap = GF_FILTER_SAP_1;\n\t\t\t\t\tctx->prev_sap = GF_TRUE;\n\t\t\t\t} else {\n\t\t\t\t\tsap = GF_FILTER_SAP_NONE;\n\t\t\t\t\tctx->prev_sap = GF_FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_filter_pck_set_sap(dst_pck, sap);\n\n\t\t\tgf_filter_pck_send(dst_pck);\n\t\t}\n\t\tlatm_dmx_update_cts(ctx);\n\n\t\tif (prev_pck_size) {\n\t\t\tpos = (u32) gf_bs_get_position(ctx->bs);\n\t\t\tif (prev_pck_size<=pos) {\n\t\t\t\tprev_pck_size=0;\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\t\tctx->src_pck = pck;\n\t\t\t\tif (pck)\n\t\t\t\t\tgf_filter_pck_ref_props(&ctx->src_pck);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pck) {\n\t\tpos = (u32) gf_bs_get_position(ctx->bs);\n\t\tassert(ctx->latm_buffer_size >= pos);\n\t\tmemmove(ctx->latm_buffer, ctx->latm_buffer+pos, ctx->latm_buffer_size - pos);\n\t\tctx->latm_buffer_size -= pos;\n\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\tassert(!ctx->resume_from);\n\t} else {\n\t\tctx->latm_buffer_size = 0;\n\t\treturn latm_dmx_process(filter);\n\t}\n\treturn GF_OK;\n}", "target": 2, "idx": 10948}
{"commit_id": "8939398b82006ba1fec4ed491339fc075f43fc7c", "project": "abrt", "func": "static void ParseCommon(map_string_t *settings, const char *conf_filename)\n{\n    const char *value;\n\n    value = get_map_string_item_or_NULL(settings, \"WatchCrashdumpArchiveDir\");\n    if (value)\n    {\n        g_settings_sWatchCrashdumpArchiveDir = xstrdup(value);\n        remove_map_string_item(settings, \"WatchCrashdumpArchiveDir\");\n    }\n\n    value = get_map_string_item_or_NULL(settings, \"MaxCrashReportsSize\");\n    if (value)\n    {\n        char *end;\n        errno = 0;\n        unsigned long ul = strtoul(value, &end, 10);\n        if (errno || end == value || *end != '\\0' || ul > INT_MAX)\n            error_msg(\"Error parsing %s setting: '%s'\", \"MaxCrashReportsSize\", value);\n        else\n            g_settings_nMaxCrashReportsSize = ul;\n        remove_map_string_item(settings, \"MaxCrashReportsSize\");\n    }\n\n    value = get_map_string_item_or_NULL(settings, \"DumpLocation\");\n    if (value)\n    {\n        g_settings_dump_location = xstrdup(value);\n        remove_map_string_item(settings, \"DumpLocation\");\n    }\n    else\n        g_settings_dump_location = xstrdup(DEFAULT_DUMP_LOCATION);\n\n    value = get_map_string_item_or_NULL(settings, \"DeleteUploaded\");\n    if (value)\n    {\n        g_settings_delete_uploaded = string_to_bool(value);\n        remove_map_string_item(settings, \"DeleteUploaded\");\n    }\n\n    value = get_map_string_item_or_NULL(settings, \"AutoreportingEnabled\");\n    if (value)\n    {\n        g_settings_autoreporting = string_to_bool(value);\n        remove_map_string_item(settings, \"AutoreportingEnabled\");\n    }\n\n    value = get_map_string_item_or_NULL(settings, \"AutoreportingEvent\");\n    if (value)\n    {\n        g_settings_autoreporting_event = xstrdup(value);\n        remove_map_string_item(settings, \"AutoreportingEvent\");\n    }\n    else\n        g_settings_autoreporting_event = xstrdup(\"report_uReport\");\n\n    value = get_map_string_item_or_NULL(settings, \"ShortenedReporting\");\n    if (value)\n    {\n        g_settings_shortenedreporting = string_to_bool(value);\n        remove_map_string_item(settings, \"ShortenedReporting\");\n    }\n    else\n        g_settings_shortenedreporting = 0;\n\n    value = get_map_string_item_or_NULL(settings, \"PrivateReports\");\n    if (value)\n    {\n        g_settings_privatereports = string_to_bool(value);\n        remove_map_string_item(settings, \"PrivateReports\");\n    }\n\n    GHashTableIter iter;\n    const char *name;\n    /*char *value; - already declared */\n    init_map_string_iter(&iter, settings);\n    while (next_map_string_iter(&iter, &name, &value))\n    {\n        error_msg(\"Unrecognized variable '%s' in '%s'\", name, conf_filename);\n    }\n}", "target": 1, "idx": 10949}
{"commit_id": "77c955200ddd1761d6ed7a6c1578349fedbb55e4", "project": "android", "func": "void* sk_malloc_flags(size_t size, unsigned flags) {\n#ifndef SK_SUPPORT_LEGACY_MALLOC_PORTING_LAYER\n    if (flags & SK_MALLOC_ZERO_INITIALIZE) {\n        return (flags & SK_MALLOC_THROW) ? moz_xcalloc(size, 1) : calloc(size, 1);\n    }\n#endif\n    return (flags & SK_MALLOC_THROW) ? moz_xmalloc(size) : malloc(size);\n}", "target": 2, "idx": 10950}
{"commit_id": "ec412aa4583ad71ecabb967d3c77162760169d1f", "project": "libexif", "func": "static void\nexif_mnote_data_canon_load (ExifMnoteData *ne,\n\tconst unsigned char *buf, unsigned int buf_size)\n{\n\tExifMnoteDataCanon *n = (ExifMnoteDataCanon *) ne;\n\tExifShort c;\n\tsize_t i, tcount, o, datao;\n\n\tif (!n || !buf || !buf_size) {\n\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteCanon\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\tdatao = 6 + n->offset;\n\tif (CHECKOVERFLOW(datao, buf_size, 2)) {\n\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteCanon\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\n\t/* Read the number of tags */\n\tc = exif_get_short (buf + datao, n->order);\n\tdatao += 2;\n\n\t/* Remove any old entries */\n\texif_mnote_data_canon_clear (n);\n\n\t/* Reserve enough space for all the possible MakerNote tags */\n\tn->entries = exif_mem_alloc (ne->mem, sizeof (MnoteCanonEntry) * c);\n\tif (!n->entries) {\n\t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteCanon\", sizeof (MnoteCanonEntry) * c);\n\t\treturn;\n\t}\n\n\t/* Parse the entries */\n\ttcount = 0;\n\tfor (i = c, o = datao; i; --i, o += 12) {\n\t\tsize_t s;\n\n\t\tmemset(&n->entries[tcount], 0, sizeof(MnoteCanonEntry));\n\t\tif (CHECKOVERFLOW(o,buf_size,12)) {\n\t\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t\"ExifMnoteCanon\", \"Short MakerNote\");\n\t\t\tbreak;\n\t\t}\n\n\t\tn->entries[tcount].tag        = exif_get_short (buf + o, n->order);\n\t\tn->entries[tcount].format     = exif_get_short (buf + o + 2, n->order);\n\t\tn->entries[tcount].components = exif_get_long (buf + o + 4, n->order);\n\t\tn->entries[tcount].order      = n->order;\n\n\t\texif_log (ne->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteCanon\",\n\t\t\t\"Loading entry 0x%x ('%s')...\", n->entries[tcount].tag,\n\t\t\t mnote_canon_tag_get_name (n->entries[tcount].tag));\n\n\t\t/* Check if we overflow the multiplication. Use buf_size as the max size for integer overflow detection,\n\t\t * we will check the buffer sizes closer later. */\n\t\tif (\texif_format_get_size (n->entries[tcount].format) &&\n\t\t\tbuf_size / exif_format_get_size (n->entries[tcount].format) < n->entries[tcount].components\n\t\t) {\n\t\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifMnoteCanon\", \"Tag size overflow detected (%u * %lu)\", exif_format_get_size (n->entries[tcount].format), n->entries[tcount].components);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Size? If bigger than 4 bytes, the actual data is not\n\t\t * in the entry but somewhere else (offset).\n\t\t */\n\t\ts = exif_format_get_size (n->entries[tcount].format) * \n\t\t\t\t\t\t\t\t  n->entries[tcount].components;\n\t\tn->entries[tcount].size = s;\n\t\tif (!s) {\n\t\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifMnoteCanon\",\n\t\t\t\t  \"Invalid zero-length tag size\");\n\t\t\tcontinue;\n\n\t\t} else {\n\t\t\tsize_t dataofs = o + 8;\n\t\t\tif (s > 4) dataofs = exif_get_long (buf + dataofs, n->order) + 6;\n\n\t\t\tif (CHECKOVERFLOW(dataofs, buf_size, s)) {\n\t\t\t\texif_log (ne->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\t\t\"ExifMnoteCanon\",\n\t\t\t\t\t\"Tag data past end of buffer (%u > %u)\",\n\t\t\t\t\t(unsigned)(dataofs + s), buf_size);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tn->entries[tcount].data = exif_mem_alloc (ne->mem, s);\n\t\t\tif (!n->entries[tcount].data) {\n\t\t\t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteCanon\", s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmemcpy (n->entries[tcount].data, buf + dataofs, s);\n\t\t}\n\n\t\t/* Tag was successfully parsed */\n\t\t++tcount;\n\t}\n\t/* Store the count of successfully parsed tags */\n\tn->count = tcount;\n}", "target": 2, "idx": 10951}
{"commit_id": "0ff832d31470471803b175cfff4e40c1b08ee779", "project": "aawc/unrar", "func": "void CommandData::ParseArg(wchar *Arg)\n{\n  if (IsSwitch(*Arg) && !NoMoreSwitches)\n    if (Arg[1]=='-' && Arg[2]==0)\n      NoMoreSwitches=true;\n    else\n      ProcessSwitch(Arg+1);\n  else\n    if (*Command==0)\n    {\n      wcsncpyz(Command,Arg,ASIZE(Command));\n\n\n      *Command=toupperw(*Command);\n      // 'I' and 'S' commands can contain case sensitive strings after\n      // the first character, so we must not modify their case.\n      // 'S' can contain SFX name, which case is important in Unix.\n      if (*Command!='I' && *Command!='S')\n        wcsupper(Command);\n    }\n    else\n      if (*ArcName==0)\n        wcsncpyz(ArcName,Arg,ASIZE(ArcName));\n      else\n      {\n        // Check if last character is the path separator.\n        size_t Length=wcslen(Arg);\n        wchar EndChar=Length==0 ? 0:Arg[Length-1];\n        bool EndSeparator=IsDriveDiv(EndChar) || IsPathDiv(EndChar);\n\n        wchar CmdChar=toupperw(*Command);\n        bool Add=wcschr(L\"AFUM\",CmdChar)!=NULL;\n        bool Extract=CmdChar=='X' || CmdChar=='E';\n        if (EndSeparator && !Add)\n          wcsncpyz(ExtrPath,Arg,ASIZE(ExtrPath));\n        else\n          if ((Add || CmdChar=='T') && (*Arg!='@' || ListMode==RCLM_REJECT_LISTS))\n            FileArgs.AddString(Arg);\n          else\n          {\n            FindData FileData;\n            bool Found=FindFile::FastFind(Arg,&FileData);\n            if ((!Found || ListMode==RCLM_ACCEPT_LISTS) && \n                ListMode!=RCLM_REJECT_LISTS && *Arg=='@' && !IsWildcard(Arg))\n            {\n              FileLists=true;\n\n              ReadTextFile(Arg+1,&FileArgs,false,true,FilelistCharset,true,true,true);\n\n            }\n            else\n              if (Found && FileData.IsDir && Extract && *ExtrPath==0)\n              {\n                wcsncpyz(ExtrPath,Arg,ASIZE(ExtrPath));\n                AddEndSlash(ExtrPath,ASIZE(ExtrPath));\n              }\n              else\n                FileArgs.AddString(Arg);\n          }\n      }\n}", "target": 2, "idx": 10952}
{"commit_id": "8dbb21dfde14221dab09b6b9c7719b9067c1f06e", "project": "wireshark", "func": "static gchar *dissect_7bit_string (tvbuff_t *tvb, gint offset, gint length, guchar *byte_rest)\n{\n  guchar *encoded, *decoded;\n  guchar  rest = 0, bits = 1;\n  gint    len = 0, i;\n\n  if (length <= 0) {\n    decoded = \"\";\n  } else {\n    encoded = (guchar *)tvb_memdup (wmem_packet_scope(), tvb, offset, length);\n    decoded = (guchar *)wmem_alloc0 (wmem_packet_scope(), (size_t)(length * 1.2) + 1);\n    for (i = 0; i < length; i++) {\n      decoded[len++] = encoded[i] >> bits | rest;\n      rest = (encoded[i] << (7 - bits) & 0x7F);\n      if (bits == 7) {\n        decoded[len++] = rest;\n        bits = 1;\n        rest = 0;\n      } else {\n        bits++;\n      }\n    }\n  }\n\n  if (byte_rest) {\n    *byte_rest = rest;\n  }\n\n  return (gchar *) decoded;\n}", "target": 2, "idx": 10953}
{"commit_id": "385097a3675749cbc9e97c085c0e5dfe4269ca51", "project": "torvalds/linux", "func": "static int nfc_genl_deactivate_target(struct sk_buff *skb,\n\t\t\t\t      struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tu32 device_idx, target_idx;\n\tint rc;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_TARGET_INDEX])\n\t\treturn -EINVAL;\n\n\tdevice_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(device_idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\ttarget_idx = nla_get_u32(info->attrs[NFC_ATTR_TARGET_INDEX]);\n\n\trc = nfc_deactivate_target(dev, target_idx, NFC_TARGET_MODE_SLEEP);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}", "target": 1, "idx": 10954}
{"commit_id": "e0a5a02b0fc1900a69d6c37ed0aab36fb8494e6d", "project": "the-tcpdump-group/tcpdump", "func": "static const u_char *\nikev1_attrmap_print(netdissect_options *ndo,\n\t\t    const u_char *p, const u_char *ep2,\n\t\t    const struct attrmap *map, size_t nmap)\n{\n\tint totlen;\n\tuint32_t t, v;\n\n\tND_TCHECK(p[0]);\n\tif (p[0] & 0x80)\n\t\ttotlen = 4;\n\telse {\n\t\tND_TCHECK_16BITS(&p[2]);\n\t\ttotlen = 4 + EXTRACT_16BITS(&p[2]);\n\t}\n\tif (ep2 < p + totlen) {\n\t\tND_PRINT((ndo,\"[|attr]\"));\n\t\treturn ep2 + 1;\n\t}\n\n\tND_TCHECK_16BITS(&p[0]);\n\tND_PRINT((ndo,\"(\"));\n\tt = EXTRACT_16BITS(&p[0]) & 0x7fff;\n\tif (map && t < nmap && map[t].type)\n\t\tND_PRINT((ndo,\"type=%s \", map[t].type));\n\telse\n\t\tND_PRINT((ndo,\"type=#%d \", t));\n\tif (p[0] & 0x80) {\n\t\tND_PRINT((ndo,\"value=\"));\n\t\tND_TCHECK_16BITS(&p[2]);\n\t\tv = EXTRACT_16BITS(&p[2]);\n\t\tif (map && t < nmap && v < map[t].nvalue && map[t].value[v])\n\t\t\tND_PRINT((ndo,\"%s\", map[t].value[v]));\n\t\telse {\n\t\t\tif (!rawprint(ndo, (const uint8_t *)&p[2], 2)) {\n\t\t\t\tND_PRINT((ndo,\")\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tND_PRINT((ndo,\"len=%d value=\", totlen - 4));\n\t\tif (!rawprint(ndo, (const uint8_t *)&p[4], totlen - 4)) {\n\t\t\tND_PRINT((ndo,\")\"));\n\t\t\tgoto trunc;\n\t\t}\n\t}\n\tND_PRINT((ndo,\")\"));\n\treturn p + totlen;\n\ntrunc:\n\treturn NULL;\n}", "target": 3, "idx": 10955}
{"commit_id": "85d7215d9b3e0d5a8433fc31aec4f2966821051e", "project": "notepad-plus-plus", "func": "bool NppParameters::load()\n{\n\tL_END = L_EXTERNAL;\n\tbool isAllLaoded = true;\n\n\t_isx64 = sizeof(void *) == 8;\n\n\t// Make localConf.xml path\n\tgeneric_string localConfPath(_nppPath);\n\tpathAppend(localConfPath, localConfFile);\n\n\t// Test if localConf.xml exist\n\t_isLocal = (PathFileExists(localConfPath.c_str()) == TRUE);\n\n\t// Under vista and windows 7, the usage of doLocalConf.xml is not allowed\n\t// if Notepad++ is installed in \"program files\" directory, because of UAC\n\tif (_isLocal)\n\t{\n\t\t// We check if OS is Vista or greater version\n\t\tif (_winVersion >= WV_VISTA)\n\t\t{\n\t\t\tgeneric_string progPath = getSpecialFolderLocation(CSIDL_PROGRAM_FILES);\n\t\t\tTCHAR nppDirLocation[MAX_PATH];\n\t\t\twcscpy_s(nppDirLocation, _nppPath.c_str());\n\t\t\t::PathRemoveFileSpec(nppDirLocation);\n\n\t\t\tif  (progPath == nppDirLocation)\n\t\t\t\t_isLocal = false;\n\t\t}\n\t}\n\n\t_pluginRootDir = _nppPath;\n\tpathAppend(_pluginRootDir, TEXT(\"plugins\"));\n\n\t//\n\t// the 3rd priority: general default configuration\n\t//\n\tgeneric_string nppPluginRootParent;\n\tif (_isLocal)\n\t{\n\t\t_userPath = nppPluginRootParent = _nppPath;\n\t\t_userPluginConfDir = _pluginRootDir;\n\t\tpathAppend(_userPluginConfDir, TEXT(\"Config\"));\n\t}\n\telse\n\t{\n\t\t_userPath = getSpecialFolderLocation(CSIDL_APPDATA);\n\n\t\tpathAppend(_userPath, TEXT(\"Notepad++\"));\n\t\tif (!PathFileExists(_userPath.c_str()))\n\t\t\t::CreateDirectory(_userPath.c_str(), NULL);\n\n\t\t_appdataNppDir = _userPluginConfDir = _userPath;\n\t\tpathAppend(_userPluginConfDir, TEXT(\"plugins\"));\n\t\tif (!PathFileExists(_userPluginConfDir.c_str()))\n\t\t\t::CreateDirectory(_userPluginConfDir.c_str(), NULL);\n\t\tpathAppend(_userPluginConfDir, TEXT(\"Config\"));\n\t\tif (!PathFileExists(_userPluginConfDir.c_str()))\n\t\t\t::CreateDirectory(_userPluginConfDir.c_str(), NULL);\n\n\t\t// For PluginAdmin to launch the wingup with UAC\n\t\tsetElevationRequired(true);\n\t}\n\n\t_pluginConfDir = _pluginRootDir; // for plugin list home\n\tpathAppend(_pluginConfDir, TEXT(\"Config\"));\n\n\tif (!PathFileExists(nppPluginRootParent.c_str()))\n\t\t::CreateDirectory(nppPluginRootParent.c_str(), NULL);\n\tif (!PathFileExists(_pluginRootDir.c_str()))\n\t\t::CreateDirectory(_pluginRootDir.c_str(), NULL);\n\n\t_sessionPath = _userPath; // Session stock the absolute file path, it should never be on cloud\n\n\t// Detection cloud settings\n\tgeneric_string cloudChoicePath{_userPath};\n\tcloudChoicePath += TEXT(\"\\\\cloud\\\\choice\");\n\n\t//\n\t// the 2nd priority: cloud Choice Path\n\t//\n\tif (::PathFileExists(cloudChoicePath.c_str()))\n\t{\n\t\t// Read cloud choice\n\t\tstd::string cloudChoiceStr = getFileContent(cloudChoicePath.c_str());\n\t\tWcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();\n\t\tstd::wstring cloudChoiceStrW = wmc.char2wchar(cloudChoiceStr.c_str(), SC_CP_UTF8);\n\n\t\tif (!cloudChoiceStrW.empty() && ::PathFileExists(cloudChoiceStrW.c_str()))\n\t\t{\n\t\t\t_userPath = cloudChoiceStrW;\n\t\t\t_nppGUI._cloudPath = cloudChoiceStrW;\n\t\t\t_initialCloudChoice = _nppGUI._cloudPath;\n\t\t}\n\t}\n\n\t//\n\t// the 1st priority: custom settings dir via command line argument\n\t//\n\tif (!_cmdSettingsDir.empty())\n\t{\n\t\tif (!::PathIsDirectory(_cmdSettingsDir.c_str()))\n\t\t{\n\t\t\t// The following text is not translatable.\n\t\t\t// _pNativeLangSpeaker is initialized AFTER _userPath being dterminated because nativeLang.xml is from from _userPath.\n\t\t\tgeneric_string errMsg = TEXT(\"The given path\\r\");\n\t\t\terrMsg += _cmdSettingsDir;\n\t\t\terrMsg += TEXT(\"\\nvia command line \\\"-settingsDir=\\\" is not a valid directory.\\rThis argument will be ignored.\");\n\t\t\t::MessageBox(NULL, errMsg.c_str(), TEXT(\"Invalid directory\"), MB_OK);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t_userPath = _cmdSettingsDir;\n\t\t\t_sessionPath = _userPath; // reset session path\n\t\t}\n\t}\n\n\t//-------------------------------------//\n\t// Transparent function for w2k and xp //\n\t//-------------------------------------//\n\tHMODULE hUser32 = ::GetModuleHandle(TEXT(\"User32\"));\n\tif (hUser32)\n\t\t_transparentFuncAddr = (WNDPROC)::GetProcAddress(hUser32, \"SetLayeredWindowAttributes\");\n\n\t//---------------------------------------------//\n\t// Dlg theme texture function for xp and vista //\n\t//---------------------------------------------//\n\t_hUXTheme = ::LoadLibraryEx(TEXT(\"uxtheme.dll\"), nullptr, LOAD_LIBRARY_SEARCH_SYSTEM32);\n\tif (_hUXTheme)\n\t\t_enableThemeDialogTextureFuncAddr = (WNDPROC)::GetProcAddress(_hUXTheme, \"EnableThemeDialogTexture\");\n\n\t//--------------------------//\n\t// langs.xml : for per user //\n\t//--------------------------//\n\tgeneric_string langs_xml_path(_userPath);\n\tpathAppend(langs_xml_path, TEXT(\"langs.xml\"));\n\n\tBOOL doRecover = FALSE;\n\tif (::PathFileExists(langs_xml_path.c_str()))\n\t{\n\t\tWIN32_FILE_ATTRIBUTE_DATA attributes;\n\n\t\tif (GetFileAttributesEx(langs_xml_path.c_str(), GetFileExInfoStandard, &attributes) != 0)\n\t\t{\n\t\t\tif (attributes.nFileSizeLow == 0 && attributes.nFileSizeHigh == 0)\n\t\t\t{\n\t\t\t\tif (_pNativeLangSpeaker)\n\t\t\t\t{\n\t\t\t\t\tdoRecover = _pNativeLangSpeaker->messageBox(\"LoadLangsFailed\",\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tTEXT(\"Load langs.xml failed!\\rDo you want to recover your langs.xml?\"),\n\t\t\t\t\t\tTEXT(\"Configurator\"),\n\t\t\t\t\t\tMB_YESNO);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdoRecover = ::MessageBox(NULL, TEXT(\"Load langs.xml failed!\\rDo you want to recover your langs.xml?\"), TEXT(\"Configurator\"), MB_YESNO);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t\tdoRecover = true;\n\n\tif (doRecover)\n\t{\n\t\tgeneric_string srcLangsPath(_nppPath);\n\t\tpathAppend(srcLangsPath, TEXT(\"langs.model.xml\"));\n\t\t::CopyFile(srcLangsPath.c_str(), langs_xml_path.c_str(), FALSE);\n\t}\n\n\t_pXmlDoc = new TiXmlDocument(langs_xml_path);\n\n\n\tbool loadOkay = _pXmlDoc->LoadFile();\n\tif (!loadOkay)\n\t{\n\t\tif (_pNativeLangSpeaker)\n\t\t{\n\t\t\t_pNativeLangSpeaker->messageBox(\"LoadLangsFailedFinal\",\n\t\t\t\tNULL,\n\t\t\t\tTEXT(\"Load langs.xml failed!\"),\n\t\t\t\tTEXT(\"Configurator\"),\n\t\t\t\tMB_OK);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t::MessageBox(NULL, TEXT(\"Load langs.xml failed!\"), TEXT(\"Configurator\"), MB_OK);\n\t\t}\n\n\t\tdelete _pXmlDoc;\n\t\t_pXmlDoc = nullptr;\n\t\tisAllLaoded = false;\n\t}\n\telse\n\t\tgetLangKeywordsFromXmlTree();\n\n\t//---------------------------//\n\t// config.xml : for per user //\n\t//---------------------------//\n\tgeneric_string configPath(_userPath);\n\tpathAppend(configPath, TEXT(\"config.xml\"));\n\n\tgeneric_string srcConfigPath(_nppPath);\n\tpathAppend(srcConfigPath, TEXT(\"config.model.xml\"));\n\n\tif (!::PathFileExists(configPath.c_str()))\n\t\t::CopyFile(srcConfigPath.c_str(), configPath.c_str(), FALSE);\n\n\t_pXmlUserDoc = new TiXmlDocument(configPath);\n\tloadOkay = _pXmlUserDoc->LoadFile();\n\t\n\tif (!loadOkay)\n\t{\n\t\tTiXmlDeclaration* decl = new TiXmlDeclaration(TEXT(\"1.0\"), TEXT(\"UTF-8\"), TEXT(\"\"));\n\t\t_pXmlUserDoc->LinkEndChild(decl);\n\t}\n\telse\n\t{\n\t\tgetUserParametersFromXmlTree();\n\t}\n\n\t//----------------------------//\n\t// stylers.xml : for per user //\n\t//----------------------------//\n\n\t_stylerPath = _userPath;\n\tpathAppend(_stylerPath, TEXT(\"stylers.xml\"));\n\n\tif (!PathFileExists(_stylerPath.c_str()))\n\t{\n\t\tgeneric_string srcStylersPath(_nppPath);\n\t\tpathAppend(srcStylersPath, TEXT(\"stylers.model.xml\"));\n\n\t\t::CopyFile(srcStylersPath.c_str(), _stylerPath.c_str(), TRUE);\n\t}\n\n\tif (_nppGUI._themeName.empty() || (!PathFileExists(_nppGUI._themeName.c_str())))\n\t\t_nppGUI._themeName.assign(_stylerPath);\n\n\t_pXmlUserStylerDoc = new TiXmlDocument(_nppGUI._themeName.c_str());\n\n\tloadOkay = _pXmlUserStylerDoc->LoadFile();\n\tif (!loadOkay)\n\t{\n\t\tif (_pNativeLangSpeaker)\n\t\t{\n\t\t\t_pNativeLangSpeaker->messageBox(\"LoadStylersFailed\",\n\t\t\t\tNULL,\n\t\t\t\tTEXT(\"Load \\\"$STR_REPLACE$\\\" failed!\"),\n\t\t\t\tTEXT(\"Load stylers.xml failed\"),\n\t\t\t\tMB_OK,\n\t\t\t\t0,\n\t\t\t\t_stylerPath.c_str());\n\t\t}\n\t\telse\n\t\t{\n\t\t\t::MessageBox(NULL, _stylerPath.c_str(), TEXT(\"Load stylers.xml failed\"), MB_OK);\n\t\t}\n\t\tdelete _pXmlUserStylerDoc;\n\t\t_pXmlUserStylerDoc = NULL;\n\t\tisAllLaoded = false;\n\t}\n\telse\n\t\tgetUserStylersFromXmlTree();\n\n\t_themeSwitcher._stylesXmlPath = _stylerPath;\n\t// Firstly, add the default theme\n\t_themeSwitcher.addDefaultThemeFromXml(_stylerPath);\n\n\t//-----------------------------------//\n\t// userDefineLang.xml : for per user //\n\t//-----------------------------------//\n\t_userDefineLangsFolderPath = _userDefineLangPath = _userPath;\n\tpathAppend(_userDefineLangPath, TEXT(\"userDefineLang.xml\"));\n\tpathAppend(_userDefineLangsFolderPath, TEXT(\"userDefineLangs\"));\n\n\tstd::vector<generic_string> udlFiles;\n\tgetFilesInFolder(udlFiles, TEXT(\"*.xml\"), _userDefineLangsFolderPath);\n\n\t_pXmlUserLangDoc = new TiXmlDocument(_userDefineLangPath);\n\tloadOkay = _pXmlUserLangDoc->LoadFile();\n\tif (!loadOkay)\n\t{\n\t\tdelete _pXmlUserLangDoc;\n\t\t_pXmlUserLangDoc = nullptr;\n\t\tisAllLaoded = false;\n\t}\n\telse\n\t{\n\t\tauto r = addUserDefineLangsFromXmlTree(_pXmlUserLangDoc);\n\t\tif (r.second - r.first > 0)\n\t\t\t_pXmlUserLangsDoc.push_back(UdlXmlFileState(_pXmlUserLangDoc, false, r));\n\t}\n\n\tfor (const auto& i : udlFiles)\n\t{\n\t\tauto udlDoc = new TiXmlDocument(i);\n\t\tloadOkay = udlDoc->LoadFile();\n\t\tif (!loadOkay)\n\t\t{\n\t\t\tdelete udlDoc;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tauto r = addUserDefineLangsFromXmlTree(udlDoc);\n\t\t\tif (r.second - r.first > 0)\n\t\t\t\t_pXmlUserLangsDoc.push_back(UdlXmlFileState(udlDoc, false, r));\n\t\t}\n\t}\n\n\t//----------------------------------------------//\n\t// nativeLang.xml : for per user\t\t\t\t//\n\t// In case of absence of user's nativeLang.xml, //\n\t// We'll look in the Notepad++ Dir.\t\t\t //\n\t//----------------------------------------------//\n\n\tgeneric_string nativeLangPath;\n\tnativeLangPath = _userPath;\n\tpathAppend(nativeLangPath, TEXT(\"nativeLang.xml\"));\n\n\t// LocalizationSwitcher should use always user path\n\t_localizationSwitcher._nativeLangPath = nativeLangPath;\n\n\tif (!_startWithLocFileName.empty()) // localization argument detected, use user wished localization\n\t{\n\t\t// overwrite nativeLangPath variable\n\t\tnativeLangPath = _nppPath;\n\t\tpathAppend(nativeLangPath, TEXT(\"localization\\\\\"));\n\t\tpathAppend(nativeLangPath, _startWithLocFileName);\n\t}\n\telse // use %appdata% location, or (if absence then) npp installed location\n\t{\n\t\tif (!PathFileExists(nativeLangPath.c_str()))\n\t\t{\n\t\t\tnativeLangPath = _nppPath;\n\t\t\tpathAppend(nativeLangPath, TEXT(\"nativeLang.xml\"));\n\t\t}\n\t}\n\n\n\t_pXmlNativeLangDocA = new TiXmlDocumentA();\n\n\tloadOkay = _pXmlNativeLangDocA->LoadUnicodeFilePath(nativeLangPath.c_str());\n\tif (!loadOkay)\n\t{\n\t\tdelete _pXmlNativeLangDocA;\n\t\t_pXmlNativeLangDocA = nullptr;\n\t\tisAllLaoded = false;\n\t}\n\n\t//---------------------------------//\n\t// toolbarIcons.xml : for per user //\n\t//---------------------------------//\n\tgeneric_string toolbarIconsPath(_userPath);\n\tpathAppend(toolbarIconsPath, TEXT(\"toolbarIcons.xml\"));\n\n\t_pXmlToolIconsDoc = new TiXmlDocument(toolbarIconsPath);\n\tloadOkay = _pXmlToolIconsDoc->LoadFile();\n\tif (!loadOkay)\n\t{\n\t\tdelete _pXmlToolIconsDoc;\n\t\t_pXmlToolIconsDoc = nullptr;\n\t\tisAllLaoded = false;\n\t}\n\n\t//------------------------------//\n\t// shortcuts.xml : for per user //\n\t//------------------------------//\n\t_shortcutsPath = _userPath;\n\tpathAppend(_shortcutsPath, TEXT(\"shortcuts.xml\"));\n\n\tif (!PathFileExists(_shortcutsPath.c_str()))\n\t{\n\t\tgeneric_string srcShortcutsPath(_nppPath);\n\t\tpathAppend(srcShortcutsPath, TEXT(\"shortcuts.xml\"));\n\n\t\t::CopyFile(srcShortcutsPath.c_str(), _shortcutsPath.c_str(), TRUE);\n\t}\n\n\t_pXmlShortcutDoc = new TiXmlDocument(_shortcutsPath);\n\tloadOkay = _pXmlShortcutDoc->LoadFile();\n\tif (!loadOkay)\n\t{\n\t\tdelete _pXmlShortcutDoc;\n\t\t_pXmlShortcutDoc = nullptr;\n\t\tisAllLaoded = false;\n\t}\n\telse\n\t{\n\t\tgetShortcutsFromXmlTree();\n\t\tgetMacrosFromXmlTree();\n\t\tgetUserCmdsFromXmlTree();\n\n\t\t// fill out _scintillaModifiedKeys :\n\t\t// those user defined Scintilla key will be used remap Scintilla Key Array\n\t\tgetScintKeysFromXmlTree();\n\t}\n\n\t//---------------------------------//\n\t// contextMenu.xml : for per user //\n\t//---------------------------------//\n\t_contextMenuPath = _userPath;\n\tpathAppend(_contextMenuPath, TEXT(\"contextMenu.xml\"));\n\n\tif (!PathFileExists(_contextMenuPath.c_str()))\n\t{\n\t\tgeneric_string srcContextMenuPath(_nppPath);\n\t\tpathAppend(srcContextMenuPath, TEXT(\"contextMenu.xml\"));\n\n\t\t::CopyFile(srcContextMenuPath.c_str(), _contextMenuPath.c_str(), TRUE);\n\t}\n\n\t_pXmlContextMenuDocA = new TiXmlDocumentA();\n\tloadOkay = _pXmlContextMenuDocA->LoadUnicodeFilePath(_contextMenuPath.c_str());\n\tif (!loadOkay)\n\t{\n\t\tdelete _pXmlContextMenuDocA;\n\t\t_pXmlContextMenuDocA = nullptr;\n\t\tisAllLaoded = false;\n\t}\n\n\t//----------------------------//\n\t// session.xml : for per user //\n\t//----------------------------//\n\n\tpathAppend(_sessionPath, TEXT(\"session.xml\"));\n\n\t// Don't load session.xml if not required in order to speed up!!\n\tconst NppGUI & nppGUI = (NppParameters::getInstance()).getNppGUI();\n\tif (nppGUI._rememberLastSession)\n\t{\n\t\tTiXmlDocument* pXmlSessionDoc = new TiXmlDocument(_sessionPath);\n\n\t\tloadOkay = pXmlSessionDoc->LoadFile();\n\t\tif (!loadOkay)\n\t\t\tisAllLaoded = false;\n\t\telse\n\t\t\tgetSessionFromXmlTree(pXmlSessionDoc, _session);\n\n\t\tdelete pXmlSessionDoc;\n\n\t\tfor (size_t i = 0, len = _pXmlExternalLexerDoc.size() ; i < len ; ++i)\n\t\t\tif (_pXmlExternalLexerDoc[i])\n\t\t\t\tdelete _pXmlExternalLexerDoc[i];\n\t}\n\n\t//-------------------------------------------------------------//\n\t// enableSelectFgColor.xml : for per user                      //\n\t// This empty xml file is optional - user adds this empty file //\n\t// manually in order to set selected text's foreground color.  //\n\t//-------------------------------------------------------------//\n\tgeneric_string enableSelectFgColorPath = _userPath;\n\tpathAppend(enableSelectFgColorPath, TEXT(\"enableSelectFgColor.xml\"));\n\n\tif (PathFileExists(enableSelectFgColorPath.c_str()))\n\t{\n\t\t_isSelectFgColorEnabled = true;\n\t}\n\n\n\tgeneric_string filePath, filePath2, issueFileName;\n\n\tfilePath = _nppPath;\n\tissueFileName = nppLogNetworkDriveIssue;\n\tissueFileName += TEXT(\".xml\");\n\tpathAppend(filePath, issueFileName);\n\t_doNppLogNetworkDriveIssue = (PathFileExists(filePath.c_str()) == TRUE);\n\tif (!_doNppLogNetworkDriveIssue)\n\t{\n\t\tfilePath2 = _userPath;\n\t\tpathAppend(filePath2, issueFileName);\n\t\t_doNppLogNetworkDriveIssue = (PathFileExists(filePath2.c_str()) == TRUE);\n\t}\n\n\tfilePath = _nppPath;\n\tissueFileName = nppLogNulContentCorruptionIssue;\n\tissueFileName += TEXT(\".xml\");\n\tpathAppend(filePath, issueFileName);\n\t_doNppLogNulContentCorruptionIssue = (PathFileExists(filePath.c_str()) == TRUE);\n\tif (!_doNppLogNulContentCorruptionIssue)\n\t{\n\t\tfilePath2 = _userPath;\n\t\tpathAppend(filePath2, issueFileName);\n\t\t_doNppLogNulContentCorruptionIssue = (PathFileExists(filePath2.c_str()) == TRUE);\n\t}\n\n\n\n\n\treturn isAllLaoded;\n}", "target": 1, "idx": 10956}
{"commit_id": "338f1fc0ee3ca929387448fe464579d6113fa76a", "project": "vim", "func": "void\nnormal_cmd(\n    oparg_T\t*oap,\n    int\t\ttoplevel UNUSED)\t// TRUE when called from main()\n{\n    cmdarg_T\tca;\t\t\t// command arguments\n    int\t\tc;\n    int\t\tctrl_w = FALSE;\t\t// got CTRL-W command\n    int\t\told_col = curwin->w_curswant;\n    int\t\tneed_flushbuf = FALSE;\t// need to call out_flush()\n    pos_T\told_pos;\t\t// cursor position before command\n    int\t\tmapped_len;\n    static int\told_mapped_len = 0;\n    int\t\tidx;\n    int\t\tset_prevcount = FALSE;\n    int\t\tsave_did_cursorhold = did_cursorhold;\n\n    CLEAR_FIELD(ca);\t// also resets ca.retval\n    ca.oap = oap;\n\n    // Use a count remembered from before entering an operator.  After typing\n    // \"3d\" we return from normal_cmd() and come back here, the \"3\" is\n    // remembered in \"opcount\".\n    ca.opcount = opcount;\n\n    // If there is an operator pending, then the command we take this time\n    // will terminate it. Finish_op tells us to finish the operation before\n    // returning this time (unless the operation was cancelled).\n#ifdef CURSOR_SHAPE\n    c = finish_op;\n#endif\n    finish_op = (oap->op_type != OP_NOP);\n#ifdef CURSOR_SHAPE\n    if (finish_op != c)\n    {\n\tui_cursor_shape();\t\t// may show different cursor shape\n# ifdef FEAT_MOUSESHAPE\n\tupdate_mouseshape(-1);\n# endif\n    }\n#endif\n    may_trigger_modechanged();\n\n    // When not finishing an operator and no register name typed, reset the\n    // count.\n    if (!finish_op && !oap->regname)\n    {\n\tca.opcount = 0;\n#ifdef FEAT_EVAL\n\tset_prevcount = TRUE;\n#endif\n    }\n\n    // Restore counts from before receiving K_CURSORHOLD.  This means after\n    // typing \"3\", handling K_CURSORHOLD and then typing \"2\" we get \"32\", not\n    // \"3 * 2\".\n    if (oap->prev_opcount > 0 || oap->prev_count0 > 0)\n    {\n\tca.opcount = oap->prev_opcount;\n\tca.count0 = oap->prev_count0;\n\toap->prev_opcount = 0;\n\toap->prev_count0 = 0;\n    }\n\n    mapped_len = typebuf_maplen();\n\n    State = MODE_NORMAL_BUSY;\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = FALSE;\t// allow scrolling here\n#endif\n\n#ifdef FEAT_EVAL\n    // Set v:count here, when called from main() and not a stuffed\n    // command, so that v:count can be used in an expression mapping\n    // when there is no count. Do set it for redo.\n    if (toplevel && readbuf1_empty())\n\tset_vcount_ca(&ca, &set_prevcount);\n#endif\n\n    /*\n     * Get the command character from the user.\n     */\n    c = safe_vgetc();\n    LANGMAP_ADJUST(c, get_real_state() != MODE_SELECT);\n\n    // If a mapping was started in Visual or Select mode, remember the length\n    // of the mapping.  This is used below to not return to Insert mode for as\n    // long as the mapping is being executed.\n    if (restart_edit == 0)\n\told_mapped_len = 0;\n    else if (old_mapped_len\n\t\t|| (VIsual_active && mapped_len == 0 && typebuf_maplen() > 0))\n\told_mapped_len = typebuf_maplen();\n\n    if (c == NUL)\n\tc = K_ZERO;\n\n    // In Select mode, typed text replaces the selection.\n    if (VIsual_active\n\t    && VIsual_select\n\t    && (vim_isprintc(c) || c == NL || c == CAR || c == K_KENTER))\n    {\n\tint len;\n\n\t// Fake a \"c\"hange command.  When \"restart_edit\" is set (e.g., because\n\t// 'insertmode' is set) fake a \"d\"elete command, Insert mode will\n\t// restart automatically.\n\t// Insert the typed character in the typeahead buffer, so that it can\n\t// be mapped in Insert mode.  Required for \":lmap\" to work.\n\tlen = ins_char_typebuf(vgetc_char, vgetc_mod_mask);\n\n\t// When recording and gotchars() was called the character will be\n\t// recorded again, remove the previous recording.\n\tif (KeyTyped)\n\t    ungetchars(len);\n\n\tif (restart_edit != 0)\n\t    c = 'd';\n\telse\n\t    c = 'c';\n\tmsg_nowait = TRUE;\t// don't delay going to insert mode\n\told_mapped_len = 0;\t// do go to Insert mode\n    }\n\n    // If the window was made so small that nothing shows, make it at least one\n    // line and one column when typing a command.\n    if (KeyTyped && !KeyStuffed)\n\twin_ensure_size();\n\n#ifdef FEAT_CMDL_INFO\n    need_flushbuf = add_to_showcmd(c);\n#endif\n\n    // Get the command count\n    c = normal_cmd_get_count(&ca, c, toplevel, set_prevcount, &ctrl_w,\n\t\t\t\t\t\t\t&need_flushbuf);\n\n    // Find the command character in the table of commands.\n    // For CTRL-W we already got nchar when looking for a count.\n    if (ctrl_w)\n    {\n\tca.nchar = c;\n\tca.cmdchar = Ctrl_W;\n    }\n    else\n\tca.cmdchar = c;\n    idx = find_command(ca.cmdchar);\n    if (idx < 0)\n    {\n\t// Not a known command: beep.\n\tclearopbeep(oap);\n\tgoto normal_end;\n    }\n\n    if ((nv_cmds[idx].cmd_flags & NV_NCW)\n\t\t\t\t&& (check_text_locked(oap) || curbuf_locked()))\n\t// this command is not allowed now\n\tgoto normal_end;\n\n    // In Visual/Select mode, a few keys are handled in a special way.\n    if (VIsual_active)\n    {\n\t// when 'keymodel' contains \"stopsel\" may stop Select/Visual mode\n\tif (km_stopsel\n\t\t&& (nv_cmds[idx].cmd_flags & NV_STS)\n\t\t&& !(mod_mask & MOD_MASK_SHIFT))\n\t{\n\t    end_visual_mode();\n\t    redraw_curbuf_later(INVERTED);\n\t}\n\n\t// Keys that work different when 'keymodel' contains \"startsel\"\n\tif (km_startsel)\n\t{\n\t    if (nv_cmds[idx].cmd_flags & NV_SS)\n\t    {\n\t\tunshift_special(&ca);\n\t\tidx = find_command(ca.cmdchar);\n\t\tif (idx < 0)\n\t\t{\n\t\t    // Just in case\n\t\t    clearopbeep(oap);\n\t\t    goto normal_end;\n\t\t}\n\t    }\n\t    else if ((nv_cmds[idx].cmd_flags & NV_SSS)\n\t\t\t\t\t       && (mod_mask & MOD_MASK_SHIFT))\n\t\tmod_mask &= ~MOD_MASK_SHIFT;\n\t}\n    }\n\n#ifdef FEAT_RIGHTLEFT\n    if (curwin->w_p_rl && KeyTyped && !KeyStuffed\n\t\t\t\t\t  && (nv_cmds[idx].cmd_flags & NV_RL))\n    {\n\t// Invert horizontal movements and operations.  Only when typed by the\n\t// user directly, not when the result of a mapping or \"x\" translated\n\t// to \"dl\".\n\tswitch (ca.cmdchar)\n\t{\n\t    case 'l':\t    ca.cmdchar = 'h'; break;\n\t    case K_RIGHT:   ca.cmdchar = K_LEFT; break;\n\t    case K_S_RIGHT: ca.cmdchar = K_S_LEFT; break;\n\t    case K_C_RIGHT: ca.cmdchar = K_C_LEFT; break;\n\t    case 'h':\t    ca.cmdchar = 'l'; break;\n\t    case K_LEFT:    ca.cmdchar = K_RIGHT; break;\n\t    case K_S_LEFT:  ca.cmdchar = K_S_RIGHT; break;\n\t    case K_C_LEFT:  ca.cmdchar = K_C_RIGHT; break;\n\t    case '>':\t    ca.cmdchar = '<'; break;\n\t    case '<':\t    ca.cmdchar = '>'; break;\n\t}\n\tidx = find_command(ca.cmdchar);\n    }\n#endif\n\n    // Get additional characters if we need them.\n    if (normal_cmd_needs_more_chars(&ca, nv_cmds[idx].cmd_flags))\n\tidx = normal_cmd_get_more_chars(idx, &ca, &need_flushbuf);\n\n#ifdef FEAT_CMDL_INFO\n    // Flush the showcmd characters onto the screen so we can see them while\n    // the command is being executed.  Only do this when the shown command was\n    // actually displayed, otherwise this will slow down a lot when executing\n    // mappings.\n    if (need_flushbuf)\n\tout_flush();\n#endif\n    if (ca.cmdchar != K_IGNORE)\n    {\n\tif (ex_normal_busy)\n\t    did_cursorhold = save_did_cursorhold;\n\telse\n\t    did_cursorhold = FALSE;\n    }\n\n    State = MODE_NORMAL;\n\n    if (ca.nchar == ESC)\n    {\n\tclearop(oap);\n\tif (restart_edit == 0 && goto_im())\n\t    restart_edit = 'a';\n\tgoto normal_end;\n    }\n\n    if (ca.cmdchar != K_IGNORE)\n    {\n\tmsg_didout = FALSE;    // don't scroll screen up for normal command\n\tmsg_col = 0;\n    }\n\n    old_pos = curwin->w_cursor;\t\t// remember where cursor was\n\n    // When 'keymodel' contains \"startsel\" some keys start Select/Visual\n    // mode.\n    if (!VIsual_active && km_startsel)\n    {\n\tif (nv_cmds[idx].cmd_flags & NV_SS)\n\t{\n\t    start_selection();\n\t    unshift_special(&ca);\n\t    idx = find_command(ca.cmdchar);\n\t}\n\telse if ((nv_cmds[idx].cmd_flags & NV_SSS)\n\t\t\t\t\t   && (mod_mask & MOD_MASK_SHIFT))\n\t{\n\t    start_selection();\n\t    mod_mask &= ~MOD_MASK_SHIFT;\n\t}\n    }\n\n    // Execute the command!\n    // Call the command function found in the commands table.\n    ca.arg = nv_cmds[idx].cmd_arg;\n    (nv_cmds[idx].cmd_func)(&ca);\n\n    // If we didn't start or finish an operator, reset oap->regname, unless we\n    // need it later.\n    if (!finish_op\n\t    && !oap->op_type\n\t    && (idx < 0 || !(nv_cmds[idx].cmd_flags & NV_KEEPREG)))\n    {\n\tclearop(oap);\n#ifdef FEAT_EVAL\n\treset_reg_var();\n#endif\n    }\n\n    // Get the length of mapped chars again after typing a count, second\n    // character or \"z333<cr>\".\n    if (old_mapped_len > 0)\n\told_mapped_len = typebuf_maplen();\n\n    // If an operation is pending, handle it.  But not for K_IGNORE or\n    // K_MOUSEMOVE.\n    if (ca.cmdchar != K_IGNORE && ca.cmdchar != K_MOUSEMOVE)\n\tdo_pending_operator(&ca, old_col, FALSE);\n\n    // Wait for a moment when a message is displayed that will be overwritten\n    // by the mode message.\n    if (normal_cmd_need_to_wait_for_msg(&ca, &old_pos))\n\tnormal_cmd_wait_for_msg();\n\n    // Finish up after executing a Normal mode command.\nnormal_end:\n\n    msg_nowait = FALSE;\n\n#ifdef FEAT_EVAL\n    if (finish_op)\n\treset_reg_var();\n#endif\n\n    // Reset finish_op, in case it was set\n#ifdef CURSOR_SHAPE\n    c = finish_op;\n#endif\n    finish_op = FALSE;\n    may_trigger_modechanged();\n#ifdef CURSOR_SHAPE\n    // Redraw the cursor with another shape, if we were in Operator-pending\n    // mode or did a replace command.\n    if (c || ca.cmdchar == 'r')\n    {\n\tui_cursor_shape();\t\t// may show different cursor shape\n# ifdef FEAT_MOUSESHAPE\n\tupdate_mouseshape(-1);\n# endif\n    }\n#endif\n\n#ifdef FEAT_CMDL_INFO\n    if (oap->op_type == OP_NOP && oap->regname == 0\n\t    && ca.cmdchar != K_CURSORHOLD)\n\tclear_showcmd();\n#endif\n\n    checkpcmark();\t\t// check if we moved since setting pcmark\n    vim_free(ca.searchbuf);\n\n    if (has_mbyte)\n\tmb_adjust_cursor();\n\n    if (curwin->w_p_scb && toplevel)\n    {\n\tvalidate_cursor();\t// may need to update w_leftcol\n\tdo_check_scrollbind(TRUE);\n    }\n\n    if (curwin->w_p_crb && toplevel)\n    {\n\tvalidate_cursor();\t// may need to update w_leftcol\n\tdo_check_cursorbind();\n    }\n\n#ifdef FEAT_TERMINAL\n    // don't go to Insert mode if a terminal has a running job\n    if (term_job_running(curbuf->b_term))\n\trestart_edit = 0;\n#endif\n\n    // May restart edit(), if we got here with CTRL-O in Insert mode (but not\n    // if still inside a mapping that started in Visual mode).\n    // May switch from Visual to Select mode after CTRL-O command.\n    if (       oap->op_type == OP_NOP\n\t    && ((restart_edit != 0 && !VIsual_active && old_mapped_len == 0)\n\t\t|| restart_VIsual_select == 1)\n\t    && !(ca.retval & CA_COMMAND_BUSY)\n\t    && stuff_empty()\n\t    && oap->regname == 0)\n    {\n\tif (restart_VIsual_select == 1)\n\t{\n\t    VIsual_select = TRUE;\n\t    may_trigger_modechanged();\n\t    showmode();\n\t    restart_VIsual_select = 0;\n\t    VIsual_select_reg = 0;\n\t}\n\tif (restart_edit != 0 && !VIsual_active && old_mapped_len == 0)\n\t    (void)edit(restart_edit, FALSE, 1L);\n    }\n\n    if (restart_VIsual_select == 2)\n\trestart_VIsual_select = 1;\n\n    // Save count before an operator for next time.\n    opcount = ca.opcount;\n}", "target": 2, "idx": 10957}
{"commit_id": "4d45a96e57fbabf00a7378b337d0ddcace6f38c1", "project": "ArtifexSoftware/mujs", "func": "static js_Ast *multiplicative(js_State *J)\n{\n\tjs_Ast *a = unary(J);\n\tSAVEREC();\nloop:\n\tINCREC();\n\tif (jsP_accept(J, '*')) { a = EXP2(MUL, a, unary(J)); goto loop; }\n\tif (jsP_accept(J, '/')) { a = EXP2(DIV, a, unary(J)); goto loop; }\n\tif (jsP_accept(J, '%')) { a = EXP2(MOD, a, unary(J)); goto loop; }\n\tPOPREC();\n\treturn a;\n}", "target": 1, "idx": 10958}
{"commit_id": "6297a117d77fa3a0df2e21ca926a92c231819cd5", "project": "php/php-src", "func": "static int php_stream_temp_close(php_stream *stream, int close_handle TSRMLS_DC)\n{\n\tphp_stream_temp_data *ts = (php_stream_temp_data*)stream->abstract;\n\tint ret;\n\n\tassert(ts != NULL);\n\n\tif (ts->innerstream) {\n\t\tret = php_stream_free_enclosed(ts->innerstream, PHP_STREAM_FREE_CLOSE | (close_handle ? 0 : PHP_STREAM_FREE_PRESERVE_HANDLE));\n\t} else {\n\t\tret = 0;\n\t}\n\n\tif (ts->meta) {\n\t\tzval_ptr_dtor(&ts->meta);\n\t}\n\n\tefree(ts);\n\n\treturn ret;\n}", "target": 2, "idx": 10959}
{"commit_id": "66cb1320242db9ce2954a539dc2d5410bf033dbd", "project": "chromium", "func": "void ElementAnimations::NotifyPlayersAnimationTakeover(\n    base::TimeTicks monotonic_time,\n    TargetProperty::Type target_property,\n    double animation_start_time,\n    std::unique_ptr<AnimationCurve> curve) {\n  DCHECK(curve);\n  ElementAnimations::PlayersList::Iterator it(players_list_.get());\n  AnimationPlayer* player;\n  while ((player = it.GetNext()) != nullptr) {\n    std::unique_ptr<AnimationCurve> animation_curve = curve->Clone();\n    player->NotifyAnimationTakeover(monotonic_time, target_property,\n                                    animation_start_time,\n                                    std::move(animation_curve));\n  }\n}", "target": 2, "idx": 10960}
{"commit_id": "2c9a8fcc73a151608634d3e712973d192027c271", "project": "facebook/hhvm", "func": "String StringUtil::Implode(const Variant& items, const String& delim,\n                           const bool checkIsContainer /* = true */) {\n  if (checkIsContainer && !isContainer(items)) {\n    throw_param_is_not_container();\n  }\n  int size = getContainerSize(items);\n  if (size == 0) return empty_string();\n\n  req::vector<String> sitems;\n  sitems.reserve(size);\n  size_t len = 0;\n  size_t lenDelim = delim.size();\n  for (ArrayIter iter(items); iter; ++iter) {\n    sitems.emplace_back(iter.second().toString());\n    len += sitems.back().size() + lenDelim;\n  }\n  len -= lenDelim; // always one delimiter less than count of items\n  assert(sitems.size() == size);\n\n  String s = String(len, ReserveString);\n  char *buffer = s.mutableData();\n  const char *sdelim = delim.data();\n  char *p = buffer;\n  String &init_str = sitems[0];\n  int init_len = init_str.size();\n  memcpy(p, init_str.data(), init_len);\n  p += init_len;\n  for (int i = 1; i < size; i++) {\n    String &item = sitems[i];\n    memcpy(p, sdelim, lenDelim);\n    p += lenDelim;\n    int lenItem = item.size();\n    memcpy(p, item.data(), lenItem);\n    p += lenItem;\n  }\n  assert(p - buffer == len);\n  s.setSize(len);\n  return s;\n}", "target": 3, "idx": 10961}
{"commit_id": "f231ec511b9a09f43f49b2c7bb7c60b8046276b1", "project": "veyon", "func": "bool WindowsServiceControl::install( const QString& filePath, const QString& displayName  )\n{\n\tconst auto binaryPath = QStringLiteral(\"\\\"%1\\\"\").arg( QString( filePath ).replace( QLatin1Char('\"'), QString() ) );\n\n\tm_serviceHandle = CreateService(\n\t\t\t\tm_serviceManager,\t\t// SCManager database\n\t\t\t\tWindowsCoreFunctions::toConstWCharArray( m_name ),\t// name of service\n\t\t\t\tWindowsCoreFunctions::toConstWCharArray( displayName ),// name to display\n\t\t\t\tSERVICE_ALL_ACCESS,\t// desired access\n\t\t\t\tSERVICE_WIN32_OWN_PROCESS,\n\t\t\t\t// service type\n\t\t\t\tSERVICE_AUTO_START,\t// start type\n\t\t\t\tSERVICE_ERROR_NORMAL,\t// error control type\n\t\t\t\tWindowsCoreFunctions::toConstWCharArray( binaryPath ),\t\t// service's binary\n\t\t\t\tnullptr,\t\t\t// no load ordering group\n\t\t\t\tnullptr,\t\t\t// no tag identifier\n\t\t\t\tL\"Tcpip\\0RpcSs\\0\\0\",\t\t// dependencies\n\t\t\t\tnullptr,\t\t\t// LocalSystem account\n\t\t\t\tnullptr );\t\t\t// no password\n\n\tif( m_serviceHandle == nullptr )\n\t{\n\t\tconst auto error = GetLastError();\n\t\tif( error == ERROR_SERVICE_EXISTS )\n\t\t{\n\t\t\tvCritical() << qUtf8Printable( tr( \"The service \\\"%1\\\" is already installed.\" ).arg( m_name ) );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvCritical() << qUtf8Printable( tr( \"The service \\\"%1\\\" could not be installed.\" ).arg( m_name ) );\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tSC_ACTION serviceActions;\n\tserviceActions.Delay = 10000;\n\tserviceActions.Type = SC_ACTION_RESTART;\n\n\tSERVICE_FAILURE_ACTIONS serviceFailureActions;\n\tserviceFailureActions.dwResetPeriod = 0;\n\tserviceFailureActions.lpRebootMsg = nullptr;\n\tserviceFailureActions.lpCommand = nullptr;\n\tserviceFailureActions.lpsaActions = &serviceActions;\n\tserviceFailureActions.cActions = 1;\n\tChangeServiceConfig2( m_serviceHandle, SERVICE_CONFIG_FAILURE_ACTIONS, &serviceFailureActions );\n\n\t// Everything went fine\n\tvInfo() << qUtf8Printable( tr( \"The service \\\"%1\\\" has been installed successfully.\" ).arg( m_name ) );\n\n\treturn true;\n}", "target": 2, "idx": 10962}
{"commit_id": "6c44312f465014eb409d766a9828b7f101f6251c", "project": "wireshark", "func": "void\nproto_register_bzr(void)\n{\n    static hf_register_info hf[] = {\n        { &hf_bzr_packet_kind,\n          { \"Packet kind\", \"bzr.kind\", FT_UINT8, BASE_DEC,\n            VALS(message_part_kind), 0x0, NULL, HFILL },\n        },\n        { &hf_bzr_packet_protocol_version,\n          { \"Protocol version\", \"bzr.protocol_version\", FT_STRING, BASE_NONE,\n            NULL, 0x0, NULL, HFILL },\n        },\n        { &hf_bzr_prefixed_bencode,\n          { \"Bencode packet\", \"bzr.bencode\", FT_NONE, BASE_NONE, NULL, 0x0,\n            \"Serialized structure of integers, dictionaries, strings and \"\n            \"lists.\", HFILL },\n        },\n        { &hf_bzr_prefixed_bencode_len,\n          { \"Bencode packet length\", \"bzr.bencode.length\", FT_UINT32,\n            BASE_HEX, NULL, 0x0, NULL, HFILL },\n        },\n        { &hf_bzr_bytes,\n          { \"Prefixed bytes\", \"bzr.bytes\", FT_NONE, BASE_NONE, NULL, 0x0,\n            \"Bytes field with prefixed 32-bit length\", HFILL },\n        },\n        { &hf_bzr_bytes_data,\n          { \"Prefixed bytes data\", \"bzr.bytes.data\", FT_BYTES, BASE_NONE,\n            NULL, 0x0, NULL, HFILL },\n        },\n        { &hf_bzr_bytes_length,\n          { \"Prefixed bytes length\", \"bzr.bytes.length\", FT_UINT32, BASE_HEX,\n            NULL, 0x0, NULL, HFILL },\n        },\n        { &hf_bzr_result,\n          { \"Result\", \"bzr.result\", FT_UINT8, BASE_HEX,\n            VALS(message_results), 0x0,\n            \"Command result (success or failure with error message)\", HFILL\n          },\n        },\n    };\n\n    static gint *ett[] = {\n        &ett_bzr,\n        &ett_prefixed_bencode,\n        &ett_prefixed_bytes,\n    };\n\n    module_t *bzr_module;\n    proto_bzr = proto_register_protocol(\"Bazaar Smart Protocol\", \"Bazaar\", \"bzr\");\n    register_dissector(\"bzr\", dissect_bzr, proto_bzr);\n    proto_register_field_array(proto_bzr, hf, array_length(hf));\n    proto_register_subtree_array(ett, array_length(ett));\n\n    bzr_module = prefs_register_protocol(proto_bzr, NULL);\n\n    prefs_register_bool_preference(bzr_module, \"desegment\",\n                                   \"Reassemble Bazaar messages spanning multiple TCP segments\",\n                                   \"Whether the Bazaar dissector should reassemble messages spanning multiple TCP segments.\"\n                                   \" To use this option, you must also enable \\\"Allow subdissectors to reassemble TCP streams\\\"\"\n                                   \" in the TCP protocol settings.\",\n                                   &bzr_desegment);\n}", "target": 2, "idx": 10963}
{"commit_id": "4713de399170a22ccad1833383561a18df1eda85", "project": "brackeen/ok-file-formats", "func": "static bool ok_csv_circular_buffer_expand(ok_csv_circular_buffer *buffer) {\n    size_t new_capacity = buffer->capacity * 2;\n    uint8_t *new_data = malloc(new_capacity);\n    if (!new_data) {\n        return false;\n    }\n    const size_t readable1 = ok_csv_circular_buffer_readable(buffer);\n    const size_t readable2 = buffer->length - readable1;\n    memcpy(new_data, buffer->data + buffer->start, readable1);\n    memcpy(new_data + readable1, buffer->data, readable2);\n    free(buffer->data);\n    buffer->data = new_data;\n    buffer->capacity = new_capacity;\n    buffer->start = 0;\n    return true;\n}", "target": 2, "idx": 10964}
{"commit_id": "912288442cb2f431bf3c8cb097a5de83bc6dbac1", "project": "torvalds/linux", "func": "static unsigned int rpcrdma_max_call_header_size(unsigned int maxsegs)\n{\n\tunsigned int size;\n\n\t/* Fixed header fields and list discriminators */\n\tsize = RPCRDMA_HDRLEN_MIN;\n\n\t/* Maximum Read list size */\n\tsize += maxsegs * rpcrdma_readchunk_maxsz * sizeof(__be32);\n\n\t/* Minimal Read chunk size */\n\tsize += sizeof(__be32);\t/* segment count */\n\tsize += rpcrdma_segment_maxsz * sizeof(__be32);\n\tsize += sizeof(__be32);\t/* list discriminator */\n\n\treturn size;\n}", "target": 1, "idx": 10965}
{"commit_id": "42d40581dd919fb134c07027ca1ce0844c670daf", "project": "lua", "func": "void luaV_concat (lua_State *L, int total) {\n  if (total == 1)\n    return;  /* \"all\" values already concatenated */\n  do {\n    StkId top = L->top;\n    int n = 2;  /* number of elements handled in this pass (at least 2) */\n    if (!(ttisstring(s2v(top - 2)) || cvt2str(s2v(top - 2))) ||\n        !tostring(L, s2v(top - 1)))\n      luaT_tryconcatTM(L);\n    else if (isemptystr(s2v(top - 1)))  /* second operand is empty? */\n      cast_void(tostring(L, s2v(top - 2)));  /* result is first operand */\n    else if (isemptystr(s2v(top - 2))) {  /* first operand is empty string? */\n      setobjs2s(L, top - 2, top - 1);  /* result is second op. */\n    }\n    else {\n      /* at least two non-empty string values; get as many as possible */\n      size_t tl = vslen(s2v(top - 1));\n      TString *ts;\n      /* collect total length and number of strings */\n      for (n = 1; n < total && tostring(L, s2v(top - n - 1)); n++) {\n        size_t l = vslen(s2v(top - n - 1));\n        if (l_unlikely(l >= (MAX_SIZE/sizeof(char)) - tl)) {\n          L->top = top - total;  /* pop strings to avoid wasting stack */\n          luaG_runerror(L, \"string length overflow\");\n        }\n        tl += l;\n      }\n      if (tl <= LUAI_MAXSHORTLEN) {  /* is result a short string? */\n        char buff[LUAI_MAXSHORTLEN];\n        copy2buff(top, n, buff);  /* copy strings to buffer */\n        ts = luaS_newlstr(L, buff, tl);\n      }\n      else {  /* long string; copy strings directly to final result */\n        ts = luaS_createlngstrobj(L, tl);\n        copy2buff(top, n, getstr(ts));\n      }\n      setsvalue2s(L, top - n, ts);  /* create result */\n    }\n    total -= n-1;  /* got 'n' strings to create 1 new */\n    L->top = top - (n - 1);  /* popped 'n' strings and pushed one */\n  } while (total > 1);  /* repeat until only 1 result left */\n}", "target": 2, "idx": 10966}
{"commit_id": "4923de56ec94fff7770df259ab7f2288a74feb41", "project": "tensorflow", "func": "void ReshapeSparseTensor(OpKernelContext *context,\n                         const Tensor &input_indices_in,\n                         const Tensor &input_shape_in,\n                         const Tensor &target_shape_in, int output_indices_idx,\n                         int output_shape_idx) {\n  OP_REQUIRES(context, TensorShapeUtils::IsMatrix(input_indices_in.shape()),\n              errors::InvalidArgument(\n                  \"Input indices should be a matrix but received shape \",\n                  input_indices_in.shape().DebugString()));\n  OP_REQUIRES(context, TensorShapeUtils::IsVector(input_shape_in.shape()),\n              errors::InvalidArgument(\n                  \"Input shape should be a vector but received shape \",\n                  input_shape_in.shape().DebugString()));\n  OP_REQUIRES(context, TensorShapeUtils::IsVector(target_shape_in.shape()),\n              errors::InvalidArgument(\n                  \"Target shape should be a vector but received shape \",\n                  target_shape_in.shape().DebugString()));\n\n  const int64_t output_rank = target_shape_in.NumElements();\n  const TensorShape input_shape(input_shape_in.vec<int64>());\n  const int64_t dense_size = input_shape.num_elements();\n  const int64_t nnz = input_indices_in.shape().dim_size(0);\n\n  // Compute the output shape. Determine product of specified dimensions, and\n  // find the index of the unspecified one.\n  TensorShape output_shape;\n  int64_t product = 1;\n  int unknown_index = -1;\n  auto target_shape = target_shape_in.vec<int64>();\n  for (int d = 0; d < output_rank; ++d) {\n    const int64_t size = target_shape(d);\n    if (size == -1) {\n      OP_REQUIRES(\n          context, unknown_index == -1,\n          errors::InvalidArgument(\"only one output dimension may be -1, \"\n                                  \"not both \",\n                                  unknown_index, \" and \", d));\n      unknown_index = d;\n      output_shape.AddDim(1);\n    } else {\n      OP_REQUIRES(context, size >= 0,\n                  errors::InvalidArgument(\"size \", d,\n                                          \" must be non-negative, not \", size));\n      product *= size;\n      output_shape.AddDim(size);\n    }\n  }\n  if (unknown_index != -1) {\n    OP_REQUIRES(\n        context, product > 0,\n        errors::InvalidArgument(\"reshape cannot infer the missing \"\n                                \"input size for an empty tensor unless all \"\n                                \"specified input sizes are non-zero\"));\n    const int64_t missing = dense_size / product;\n    OP_REQUIRES(\n        context, product * missing == dense_size,\n        errors::InvalidArgument(\n            \"Input to reshape is a SparseTensor with \", dense_size,\n            \" dense values, but the requested shape requires a multiple of \",\n            product, \". input_shape=\", input_shape.DebugString(),\n            \" output_shape=\", output_shape.DebugString()));\n    output_shape.set_dim(unknown_index, missing);\n  }\n\n  OP_REQUIRES(\n      context, output_shape.num_elements() == dense_size,\n      errors::InvalidArgument(\"Input to reshape is a tensor with \", dense_size,\n                              \" dense values, but the requested shape has \",\n                              output_shape.num_elements(),\n                              \". input_shape=\", input_shape.DebugString(),\n                              \" output_shape=\", output_shape.DebugString()));\n\n  // Optimize for reshaping to the same shape.\n  if (input_shape == output_shape) {\n    context->set_output(output_indices_idx, input_indices_in);\n    context->set_output(output_shape_idx, input_shape_in);\n    return;\n  }\n\n  Tensor *result_shape = nullptr;\n  OP_REQUIRES_OK(context, context->allocate_output(output_shape_idx,\n                                                   TensorShape({output_rank}),\n                                                   &result_shape));\n  auto output_shape_vec = result_shape->vec<int64>();\n  for (int j = 0; j < output_shape.dims(); ++j) {\n    output_shape_vec(j) = output_shape.dim_size(j);\n  }\n\n  Tensor *result_indices = nullptr;\n  OP_REQUIRES_OK(context,\n                 context->allocate_output(output_indices_idx,\n                                          TensorShape({nnz, output_rank}),\n                                          &result_indices));\n  if (nnz > 0) {\n    OP_REQUIRES(\n        context, dense_size > 0 && product > 0,\n        errors::InvalidArgument(\n            \"Input tensor has \", nnz, \" non zero elements but input shape (\",\n            input_shape.DebugString(), \") or output shape (\",\n            output_shape.DebugString(), \") is empty\"));\n    OP_REQUIRES_OK(context, functor::ReshapeSparseTensorFunctor<Device>()(\n                                context, input_shape, output_shape,\n                                input_indices_in.matrix<int64>(),\n                                result_indices->matrix<int64>()));\n  }\n}", "target": 1, "idx": 10967}
{"commit_id": "30f4c7b52a4e2dc0d0b1bae487d90f5437c69d19", "project": "radareorg/radare2", "func": "struct r_bin_dyldcache_lib_t *r_bin_dyldcache_extract(struct r_bin_dyldcache_obj_t* bin, int idx, int *nlib) {\n\tut64 liboff, linkedit_offset;\n\tut64 dyld_vmbase;\n\tut32 addend = 0;\n\tstruct r_bin_dyldcache_lib_t *ret = NULL;\n\tstruct dyld_cache_image_info* image_infos = NULL;\n\tstruct mach_header *mh;\n\tut8 *data, *cmdptr;\n\tint cmd, libsz = 0;\n\tRBuffer* dbuf;\n\tchar *libname;\n\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tif (bin->size < 1) {\n\t\teprintf (\"Empty file? (%s)\\n\", bin->file? bin->file: \"(null)\");\n\t\treturn NULL;\n\t}\n\tif (bin->nlibs < 0 || idx < 0 || idx >= bin->nlibs) {\n\t\treturn NULL;\n\t}\n\t*nlib = bin->nlibs;\n\tret = R_NEW0 (struct r_bin_dyldcache_lib_t);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tif (bin->hdr.startaddr > bin->size) {\n\t    \teprintf (\"corrupted dyldcache\");\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\n\tif (bin->hdr.startaddr > bin->size || bin->hdr.baseaddroff > bin->size) {\n\t\teprintf (\"corrupted dyldcache\");\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\tint sz = bin->nlibs * sizeof (struct dyld_cache_image_info);\n\timage_infos = malloc (sz); //(struct dyld_cache_image_info*) (bin->b->buf + bin->hdr.startaddr);\n\tif (!image_infos) {\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\tr_buf_read_at (bin->b, bin->hdr.startaddr, (ut8*)image_infos, sz);\n\tdyld_vmbase = r_buf_read64le (bin->b, bin->hdr.baseaddroff);\n\tliboff = image_infos[idx].address - dyld_vmbase;\n\tif (liboff > bin->size) {\n\t\teprintf (\"Corrupted file\\n\");\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\tret->offset = liboff;\n\tint pfo = image_infos[idx].pathFileOffset;\n\tif (pfo < 0 || pfo > bin->size) {\n\t\teprintf (\"corrupted file: pathFileOffset > bin->size (%d)\\n\", pfo);\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\tlibname = r_buf_read_string (bin->b, pfo, 64);\n\t/* Locate lib hdr in cache */\n\tdata = bin->b->buf + liboff;\n\tmh = (struct mach_header *)data;\n\t/* Check it is mach-o */\n\tif (mh->magic != MH_MAGIC && mh->magic != MH_MAGIC_64) {\n\t\tif (mh->magic == 0xbebafeca) { //FAT binary\n\t\t\teprintf (\"FAT Binary\\n\");\n\t\t}\n\t\teprintf (\"Not mach-o\\n\");\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\t/* Write mach-o hdr */\n\tif (!(dbuf = r_buf_new ())) {\n\t\teprintf (\"new (dbuf)\\n\");\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\taddend = mh->magic == MH_MAGIC? sizeof (struct mach_header) : sizeof (struct mach_header_64);\n\tr_buf_set_bytes (dbuf, data, addend);\n\tcmdptr = data + addend;\n\t/* Write load commands */\n\tfor (cmd = 0; cmd < mh->ncmds; cmd++) {\n\t\tstruct load_command *lc = (struct load_command *)cmdptr;\n\t\tr_buf_append_bytes (dbuf, (ut8*)lc, lc->cmdsize);\n\t\tcmdptr += lc->cmdsize;\n\t}\n\tcmdptr = data + addend;\n\t/* Write segments */\n\tfor (cmd = linkedit_offset = 0; cmd < mh->ncmds; cmd++) {\n\t\tstruct load_command *lc = (struct load_command *)cmdptr;\n\t\tcmdptr += lc->cmdsize;\n\t\tswitch (lc->cmd) {\n\t\tcase LC_SEGMENT:\n\t\t\t{\n\t\t\t/* Write segment and patch offset */\n\t\t\tstruct segment_command *seg = (struct segment_command *)lc;\n\t\t\tint t = seg->filesize;\n\t\t\tif (seg->fileoff + seg->filesize > bin->size || seg->fileoff > bin->size) {\n\t\t\t\teprintf (\"malformed dyldcache\\n\");\n\t\t\t\tfree (ret);\n\t\t\t\tr_buf_free (dbuf);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tr_buf_append_bytes (dbuf, bin->b->buf+seg->fileoff, t);\n\t\t\tr_bin_dyldcache_apply_patch (dbuf, dbuf->length, (ut64)((size_t)&seg->fileoff - (size_t)data));\n\t\t\t/* Patch section offsets */\n\t\t\tint sect_offset = seg->fileoff - libsz;\n\t\t\tlibsz = dbuf->length;\n\t\t\tif (!strcmp (seg->segname, \"__LINKEDIT\")) {\n\t\t\t\tlinkedit_offset = sect_offset;\n\t\t\t}\n\t\t\tif (seg->nsects > 0) {\n\t\t\t\tstruct section *sects = (struct section *)((ut8 *)seg + sizeof(struct segment_command));\n\t\t\t\tint nsect;\n\t\t\t\tfor (nsect = 0; nsect < seg->nsects; nsect++) {\n\t\t\t\t\tif (sects[nsect].offset > libsz) {\n\t\t\t\t\t\tr_bin_dyldcache_apply_patch (dbuf, sects[nsect].offset - sect_offset,\n\t\t\t\t\t\t\t(ut64)((size_t)&sects[nsect].offset - (size_t)data));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_SYMTAB:\n\t\t\t{\n\t\t\tstruct symtab_command *st = (struct symtab_command *)lc;\n\t\t\tNZ_OFFSET (st->symoff);\n\t\t\tNZ_OFFSET (st->stroff);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYSYMTAB:\n\t\t\t{\n\t\t\tstruct dysymtab_command *st = (struct dysymtab_command *)lc;\n\t\t\tNZ_OFFSET (st->tocoff);\n\t\t\tNZ_OFFSET (st->modtaboff);\n\t\t\tNZ_OFFSET (st->extrefsymoff);\n\t\t\tNZ_OFFSET (st->indirectsymoff);\n\t\t\tNZ_OFFSET (st->extreloff);\n\t\t\tNZ_OFFSET (st->locreloff);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYLD_INFO:\n\t\tcase LC_DYLD_INFO_ONLY:\n\t\t\t{\n\t\t\tstruct dyld_info_command *st = (struct dyld_info_command *)lc;\n\t\t\tNZ_OFFSET (st->rebase_off);\n\t\t\tNZ_OFFSET (st->bind_off);\n\t\t\tNZ_OFFSET (st->weak_bind_off);\n\t\t\tNZ_OFFSET (st->lazy_bind_off);\n\t\t\tNZ_OFFSET (st->export_off);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* Fill r_bin_dyldcache_lib_t ret */\n\tret->b = dbuf;\n\tstrncpy (ret->path, libname, sizeof (ret->path) - 1);\n\tret->size = libsz;\n\treturn ret;\n}", "target": 1, "idx": 10968}
{"commit_id": "7789d99ac156adfd7bbf66e7824bd3e948a74cf7", "project": "dropbox/lepton", "func": "void allocate_channel_framebuffer(int desired_cmp,\n                                      BlockBasedImageBase<force_memory_optimized> *framebuffer,\n                                      bool memory_optimized=force_memory_optimized) const {\n        uint64_t total_req_blocks = 0;\n        for (int cmp = 0; cmp < (int)header_.size() && cmp < cmpc_; cmp++) {\n            total_req_blocks += header_[cmp].info_.bcv * header_[cmp].info_.bch;\n        }\n        for (int cmp = 0; cmp < (int)header_.size() && cmp < cmpc_; cmp++) {\n            int bc_allocated = header_[cmp].info_.bc;\n            int64_t max_cmp_bc = max_number_of_blocks;\n            max_cmp_bc *= header_[cmp].info_.bcv;\n            max_cmp_bc *= header_[cmp].info_.bch;\n            if (total_req_blocks) {\n                max_cmp_bc /= total_req_blocks;\n            }\n            if (bc_allocated > max_cmp_bc) {\n                int rem = 0;\n                if (header_[cmp].info_.bch) {\n                    rem = (max_cmp_bc % header_[cmp].info_.bch);\n                }\n                bc_allocated = max_cmp_bc - rem;\n            }\n            if (cmp == desired_cmp) {\n                framebuffer->init(header_[cmp].info_.bch,\n                                  header_[cmp].info_.bcv,\n                                  bc_allocated,\n                                  memory_optimized);\n                break;\n            }\n        }\n    }", "target": 1, "idx": 10969}
{"commit_id": "f9b62f9843c7b0afdaecabbcebf1dbba18599408", "project": "torvalds/linux", "func": "static inline void wilc_wfi_cfg_parse_ch_attr(u8 *buf, u32 len, u8 sta_ch)\n{\n\tstruct wilc_attr_entry *e;\n\tstruct wilc_attr_ch_list *ch_list;\n\tstruct wilc_attr_oper_ch *op_ch;\n\tu32 index = 0;\n\tu8 ch_list_idx = 0;\n\tu8 op_ch_idx = 0;\n\n\tif (sta_ch == WILC_INVALID_CHANNEL)\n\t\treturn;\n\n\twhile (index + sizeof(*e) <= len) {\n\t\tu16 attr_size;\n\n\t\te = (struct wilc_attr_entry *)&buf[index];\n\t\tattr_size = le16_to_cpu(e->attr_len);\n\n\t\tif (index + sizeof(*e) + attr_size > len)\n\t\t\treturn;\n\n\t\tif (e->attr_type == IEEE80211_P2P_ATTR_CHANNEL_LIST &&\n\t\t    attr_size >= (sizeof(struct wilc_attr_ch_list) - sizeof(*e)))\n\t\t\tch_list_idx = index;\n\t\telse if (e->attr_type == IEEE80211_P2P_ATTR_OPER_CHANNEL &&\n\t\t\t attr_size == (sizeof(struct wilc_attr_oper_ch) - sizeof(*e)))\n\t\t\top_ch_idx = index;\n\n\t\tif (ch_list_idx && op_ch_idx)\n\t\t\tbreak;\n\n\t\tindex += sizeof(*e) + attr_size;\n\t}\n\n\tif (ch_list_idx) {\n\t\tu16 attr_size;\n\t\tstruct wilc_ch_list_elem *e;\n\t\tint i;\n\n\t\tch_list = (struct wilc_attr_ch_list *)&buf[ch_list_idx];\n\t\tattr_size = le16_to_cpu(ch_list->attr_len);\n\t\tfor (i = 0; i < attr_size;) {\n\t\t\te = (struct wilc_ch_list_elem *)(ch_list->elem + i);\n\t\t\tif (e->op_class == WILC_WLAN_OPERATING_CLASS_2_4GHZ) {\n\t\t\t\tmemset(e->ch_list, sta_ch, e->no_of_channels);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti += e->no_of_channels;\n\t\t}\n\t}\n\n\tif (op_ch_idx) {\n\t\top_ch = (struct wilc_attr_oper_ch *)&buf[op_ch_idx];\n\t\top_ch->op_class = WILC_WLAN_OPERATING_CLASS_2_4GHZ;\n\t\top_ch->op_channel = sta_ch;\n\t}\n}", "target": 2, "idx": 10970}
{"commit_id": "ea70414984f297958684acee0bb037ac11fb30b8", "project": "libming", "func": "void\nparseSWF_FOCALGRADIENT (FILE * f, struct SWF_FOCALGRADIENT *gradient, int level)\n{\n  int i;\n  gradient->SpreadMode = readBits(f, 2);\n  gradient->InterpolationMode = readBits(f, 2);\n  gradient->NumGradients = readBits (f, 4);\n  if(gradient->NumGradients > 15) {\n\t  fprintf(stderr, \"%d gradients in SWF_FOCALGRADIENT, expected a max of 15\\n\", gradient->NumGradients );\n\t  gradient->NumGradients = 15;\n\t  /*exit(1);*/\n  }\n\n  for (i = 0; i < gradient->NumGradients; i++)\n    parseSWF_GRADIENTRECORD (f, &(gradient->GradientRecords[i]), level);\n  \n  gradient->FocalPoint = readUInt16(f); \n}", "target": 2, "idx": 10971}
{"commit_id": "fdda170e50b8af062cf5741e12c4fb5e57a2eacf", "project": "qemu", "func": "static void vmxnet3_complete_packet(VMXNET3State *s, int qidx, uint32_t tx_ridx)\n{\n    struct Vmxnet3_TxCompDesc txcq_descr;\n    PCIDevice *d = PCI_DEVICE(s);\n\n    VMXNET3_RING_DUMP(VMW_RIPRN, \"TXC\", qidx, &s->txq_descr[qidx].comp_ring);\n\n    memset(&txcq_descr, 0, sizeof(txcq_descr));\n    txcq_descr.txdIdx = tx_ridx;\n    txcq_descr.gen = vmxnet3_ring_curr_gen(&s->txq_descr[qidx].comp_ring);\n\n    vmxnet3_ring_write_curr_cell(d, &s->txq_descr[qidx].comp_ring, &txcq_descr);\n\n    /* Flush changes in TX descriptor before changing the counter value */\n    smp_wmb();\n\n    vmxnet3_inc_tx_completion_counter(s, qidx);\n    vmxnet3_trigger_interrupt(s, s->txq_descr[qidx].intr_idx);\n}", "target": 1, "idx": 10972}
{"commit_id": "04c2a47ffb13c29778e2a14e414ad4cb5a5db4b5", "project": "torvalds/linux", "func": "static int tc_new_tfilter(struct sk_buff *skb, struct nlmsghdr *n,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *tca[TCA_MAX + 1];\n\tchar name[IFNAMSIZ];\n\tstruct tcmsg *t;\n\tu32 protocol;\n\tu32 prio;\n\tbool prio_allocate;\n\tu32 parent;\n\tu32 chain_index;\n\tstruct Qdisc *q;\n\tstruct tcf_chain_info chain_info;\n\tstruct tcf_chain *chain;\n\tstruct tcf_block *block;\n\tstruct tcf_proto *tp;\n\tunsigned long cl;\n\tvoid *fh;\n\tint err;\n\tint tp_created;\n\tbool rtnl_held = false;\n\tu32 flags;\n\n\tif (!netlink_ns_capable(skb, net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\nreplay:\n\ttp_created = 0;\n\n\terr = nlmsg_parse_deprecated(n, sizeof(*t), tca, TCA_MAX,\n\t\t\t\t     rtm_tca_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tt = nlmsg_data(n);\n\tprotocol = TC_H_MIN(t->tcm_info);\n\tprio = TC_H_MAJ(t->tcm_info);\n\tprio_allocate = false;\n\tparent = t->tcm_parent;\n\ttp = NULL;\n\tcl = 0;\n\tblock = NULL;\n\tq = NULL;\n\tchain = NULL;\n\tflags = 0;\n\n\tif (prio == 0) {\n\t\t/* If no priority is provided by the user,\n\t\t * we allocate one.\n\t\t */\n\t\tif (n->nlmsg_flags & NLM_F_CREATE) {\n\t\t\tprio = TC_H_MAKE(0x80000000U, 0U);\n\t\t\tprio_allocate = true;\n\t\t} else {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid filter command with priority of zero\");\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\t/* Find head of filter chain. */\n\n\terr = __tcf_qdisc_find(net, &q, &parent, t->tcm_ifindex, false, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (tcf_proto_check_kind(tca[TCA_KIND], name)) {\n\t\tNL_SET_ERR_MSG(extack, \"Specified TC filter name too long\");\n\t\terr = -EINVAL;\n\t\tgoto errout;\n\t}\n\n\t/* Take rtnl mutex if rtnl_held was set to true on previous iteration,\n\t * block is shared (no qdisc found), qdisc is not unlocked, classifier\n\t * type is not specified, classifier is not unlocked.\n\t */\n\tif (rtnl_held ||\n\t    (q && !(q->ops->cl_ops->flags & QDISC_CLASS_OPS_DOIT_UNLOCKED)) ||\n\t    !tcf_proto_is_unlocked(name)) {\n\t\trtnl_held = true;\n\t\trtnl_lock();\n\t}\n\n\terr = __tcf_qdisc_cl_find(q, parent, &cl, t->tcm_ifindex, extack);\n\tif (err)\n\t\tgoto errout;\n\n\tblock = __tcf_block_find(net, q, cl, t->tcm_ifindex, t->tcm_block_index,\n\t\t\t\t extack);\n\tif (IS_ERR(block)) {\n\t\terr = PTR_ERR(block);\n\t\tgoto errout;\n\t}\n\tblock->classid = parent;\n\n\tchain_index = tca[TCA_CHAIN] ? nla_get_u32(tca[TCA_CHAIN]) : 0;\n\tif (chain_index > TC_ACT_EXT_VAL_MASK) {\n\t\tNL_SET_ERR_MSG(extack, \"Specified chain index exceeds upper limit\");\n\t\terr = -EINVAL;\n\t\tgoto errout;\n\t}\n\tchain = tcf_chain_get(block, chain_index, true);\n\tif (!chain) {\n\t\tNL_SET_ERR_MSG(extack, \"Cannot create specified filter chain\");\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\n\tmutex_lock(&chain->filter_chain_lock);\n\ttp = tcf_chain_tp_find(chain, &chain_info, protocol,\n\t\t\t       prio, prio_allocate);\n\tif (IS_ERR(tp)) {\n\t\tNL_SET_ERR_MSG(extack, \"Filter with specified priority/protocol not found\");\n\t\terr = PTR_ERR(tp);\n\t\tgoto errout_locked;\n\t}\n\n\tif (tp == NULL) {\n\t\tstruct tcf_proto *tp_new = NULL;\n\n\t\tif (chain->flushing) {\n\t\t\terr = -EAGAIN;\n\t\t\tgoto errout_locked;\n\t\t}\n\n\t\t/* Proto-tcf does not exist, create new one */\n\n\t\tif (tca[TCA_KIND] == NULL || !protocol) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Filter kind and protocol must be specified\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto errout_locked;\n\t\t}\n\n\t\tif (!(n->nlmsg_flags & NLM_F_CREATE)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Need both RTM_NEWTFILTER and NLM_F_CREATE to create a new filter\");\n\t\t\terr = -ENOENT;\n\t\t\tgoto errout_locked;\n\t\t}\n\n\t\tif (prio_allocate)\n\t\t\tprio = tcf_auto_prio(tcf_chain_tp_prev(chain,\n\t\t\t\t\t\t\t       &chain_info));\n\n\t\tmutex_unlock(&chain->filter_chain_lock);\n\t\ttp_new = tcf_proto_create(name, protocol, prio, chain,\n\t\t\t\t\t  rtnl_held, extack);\n\t\tif (IS_ERR(tp_new)) {\n\t\t\terr = PTR_ERR(tp_new);\n\t\t\tgoto errout_tp;\n\t\t}\n\n\t\ttp_created = 1;\n\t\ttp = tcf_chain_tp_insert_unique(chain, tp_new, protocol, prio,\n\t\t\t\t\t\trtnl_held);\n\t\tif (IS_ERR(tp)) {\n\t\t\terr = PTR_ERR(tp);\n\t\t\tgoto errout_tp;\n\t\t}\n\t} else {\n\t\tmutex_unlock(&chain->filter_chain_lock);\n\t}\n\n\tif (tca[TCA_KIND] && nla_strcmp(tca[TCA_KIND], tp->ops->kind)) {\n\t\tNL_SET_ERR_MSG(extack, \"Specified filter kind does not match existing one\");\n\t\terr = -EINVAL;\n\t\tgoto errout;\n\t}\n\n\tfh = tp->ops->get(tp, t->tcm_handle);\n\n\tif (!fh) {\n\t\tif (!(n->nlmsg_flags & NLM_F_CREATE)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Need both RTM_NEWTFILTER and NLM_F_CREATE to create a new filter\");\n\t\t\terr = -ENOENT;\n\t\t\tgoto errout;\n\t\t}\n\t} else if (n->nlmsg_flags & NLM_F_EXCL) {\n\t\ttfilter_put(tp, fh);\n\t\tNL_SET_ERR_MSG(extack, \"Filter already exists\");\n\t\terr = -EEXIST;\n\t\tgoto errout;\n\t}\n\n\tif (chain->tmplt_ops && chain->tmplt_ops != tp->ops) {\n\t\tNL_SET_ERR_MSG(extack, \"Chain template is set to a different filter kind\");\n\t\terr = -EINVAL;\n\t\tgoto errout;\n\t}\n\n\tif (!(n->nlmsg_flags & NLM_F_CREATE))\n\t\tflags |= TCA_ACT_FLAGS_REPLACE;\n\tif (!rtnl_held)\n\t\tflags |= TCA_ACT_FLAGS_NO_RTNL;\n\terr = tp->ops->change(net, skb, tp, cl, t->tcm_handle, tca, &fh,\n\t\t\t      flags, extack);\n\tif (err == 0) {\n\t\ttfilter_notify(net, skb, n, tp, block, q, parent, fh,\n\t\t\t       RTM_NEWTFILTER, false, rtnl_held);\n\t\ttfilter_put(tp, fh);\n\t\t/* q pointer is NULL for shared blocks */\n\t\tif (q)\n\t\t\tq->flags &= ~TCQ_F_CAN_BYPASS;\n\t}\n\nerrout:\n\tif (err && tp_created)\n\t\ttcf_chain_tp_delete_empty(chain, tp, rtnl_held, NULL);\nerrout_tp:\n\tif (chain) {\n\t\tif (tp && !IS_ERR(tp))\n\t\t\ttcf_proto_put(tp, rtnl_held, NULL);\n\t\tif (!tp_created)\n\t\t\ttcf_chain_put(chain);\n\t}\n\ttcf_block_release(q, block, rtnl_held);\n\n\tif (rtnl_held)\n\t\trtnl_unlock();\n\n\tif (err == -EAGAIN) {\n\t\t/* Take rtnl lock in case EAGAIN is caused by concurrent flush\n\t\t * of target chain.\n\t\t */\n\t\trtnl_held = true;\n\t\t/* Replay the request. */\n\t\tgoto replay;\n\t}\n\treturn err;\n\nerrout_locked:\n\tmutex_unlock(&chain->filter_chain_lock);\n\tgoto errout;\n}", "target": 2, "idx": 10973}
{"commit_id": "1142259bc23671d17a50f4fc366a18693fbe1744", "project": "ansilove/libansilove", "func": "int ansilove_ansi(struct ansilove_ctx *ctx, struct ansilove_options *options)\n{\n\tif (ctx == NULL || options == NULL) {\n\t\tif (ctx)\n\t\t\tctx->error = ANSILOVE_INVALID_PARAM;\n\n\t\treturn -1;\n\t}\n\n\t/* ladies and gentlemen, it's type declaration time */\n\tstruct fontStruct fontData;\n\n\t/* Default to 80 columns if columns option wasn't set */\n\toptions->columns = options->columns ? options->columns : 80;\n\n\tint16_t columns = options->columns;\n\n\tbool ced = false;\n\tbool transparent = false;\n\tbool workbench = false;\n\n\tconst char *errstr;\n\n\t/* font selection */\n\talSelectFont(&fontData, options->font);\n\n\t/* to deal with the bits flag, we declared handy bool types */\n\tswitch (options->mode) {\n\tcase ANSILOVE_MODE_CED:\n\t\tced = true;\n\t\tbreak;\n\tcase ANSILOVE_MODE_TRANSPARENT:\n\t\ttransparent = true;\n\t\tbreak;\n\tcase ANSILOVE_MODE_WORKBENCH:\n\t\tworkbench = true;\n\t\tbreak;\n\t}\n\n\t/* libgd image pointers */\n\tgdImagePtr canvas;\n\n\t/* ANSi processing loops */\n\tsize_t loop = 0;\n\tuint32_t ansi_sequence_loop;\n\n\t/* character definitions */\n\tuint8_t current_character, character;\n\tuint8_t ansi_sequence_character;\n\n\t/* default color values */\n\tuint32_t background = 0, foreground = 7;\n\n\t/* text attributes */\n\tbool bold = false, blink = false, invert = false;\n\n\t/* positions */\n\tint32_t column = 0, row = 0, columnMax = 0, rowMax = 0;\n\tint32_t saved_row = 0, saved_column = 0;\n\n\t/* sequence parsing variables */\n\tuint32_t seqValue, seq_line, seq_column;\n\tchar *seqGrab = NULL;\n\tchar *seqTok = NULL;\n\n\t/* ANSi buffer structure array definition */\n\tuint32_t structIndex = 0;\n\tstruct ansiChar *ansi_buffer;\n\n\t/* ANSi buffer dynamic memory allocation */\n\tansi_buffer = malloc(sizeof (struct ansiChar));\n\n\t/* ANSi interpreter */\n\twhile (loop < ctx->length) {\n\t\tcurrent_character = ctx->buffer[loop];\n\n\t\tif (column == options->columns) {\n\t\t\trow++;\n\t\t\tcolumn = 0;\n\t\t}\n\n\t\tswitch (current_character) {\n\t\tcase LF:\n\t\t\trow++;\n\t\t\tcolumn = 0;\n\t\t\tbreak;\n\t\tcase CR:\n\t\t\tbreak;\n\t\tcase TAB:\n\t\t\tcolumn += 8;\n\t\t\tbreak;\n\t\tcase SUB:\n\t\t\tloop = ctx->length;\n\t\t\tbreak;\n\t\tcase ESC: /* ANSi sequence */\n\t\t\tif ((loop+1 < ctx->length) && ctx->buffer[loop + 1] == 91) {\n\n\t\t\t\tuint32_t maxlength = fmin(ctx->length - loop + 1, ANSI_SEQUENCE_MAX_LENGTH);\n\t\t\t\tfor (ansi_sequence_loop = 0; ansi_sequence_loop < maxlength; ansi_sequence_loop++) {\n\t\t\t\t\tansi_sequence_character = ctx->buffer[loop + 2 + ansi_sequence_loop];\n\n\t\t\t\t\t/* cursor position */\n\t\t\t\t\tif (ansi_sequence_character == 'H' || ansi_sequence_character == 'f') {\n\t\t\t\t\t\t/* create substring from the sequence's content */\n\t\t\t\t\t\tseq_line = 1;\n\t\t\t\t\t\tseq_column = 1;\n\t\t\t\t\t\tseqGrab = strndup((char *)ctx->buffer + loop + 2, ansi_sequence_loop);\n\n\t\t\t\t\t\tif (!strncmp(seqGrab, \";\", 1)) {\n\t\t\t\t\t\t\tseq_line = 1;\n\t\t\t\t\t\t\tseqTok = strtok(seqGrab, \";\");\n\n\t\t\t\t\t\t\tif (seqTok)\n\t\t\t\t\t\t\t\tseq_column = strtonum(seqTok, 0, UINT32_MAX, &errstr);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tseqTok = strtok(seqGrab, \";\");\n\t\t\t\t\t\t\tif (seqTok)\n\t\t\t\t\t\t\t\tseq_line = strtonum(seqTok, 0, UINT32_MAX, &errstr);\n\n\t\t\t\t\t\t\tseqTok = strtok(NULL, \";\");\n\t\t\t\t\t\t\tif (seqTok)\n\t\t\t\t\t\t\t\tseq_column = strtonum(seqTok, 0, UINT32_MAX, &errstr);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* set the positions */\n\t\t\t\t\t\trow = seq_line-1;\n\t\t\t\t\t\tcolumn = seq_column-1;\n\n\t\t\t\t\t\tloop += ansi_sequence_loop+2;\n\t\t\t\t\t\tfree(seqGrab);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* cursor up */\n\t\t\t\t\tif (ansi_sequence_character == 'A') {\n\t\t\t\t\t\t/* create substring from the sequence's content */\n\t\t\t\t\t\tseqGrab = strndup((char *)ctx->buffer + loop + 2, ansi_sequence_loop);\n\n\t\t\t\t\t\t/* now get escape sequence's position value */\n\t\t\t\t\t\tuint32_t seq_line = strtonum(seqGrab, 0, UINT32_MAX, &errstr);\n\t\t\t\t\t\tfree(seqGrab);\n\n\t\t\t\t\t\trow -= seq_line ? seq_line : 1;\n\n\t\t\t\t\t\tif (row < 0)\n\t\t\t\t\t\t\trow = 0;\n\n\t\t\t\t\t\tloop += ansi_sequence_loop+2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* cursor down */\n\t\t\t\t\tif (ansi_sequence_character == 'B') {\n\t\t\t\t\t\t/* create substring from the sequence's content */\n\t\t\t\t\t\tseqGrab = strndup((char *)ctx->buffer + loop + 2, ansi_sequence_loop);\n\n\t\t\t\t\t\t/* now get escape sequence's position value */\n\t\t\t\t\t\tuint32_t seq_line = strtonum(seqGrab, 0, UINT32_MAX, &errstr);\n\t\t\t\t\t\tfree(seqGrab);\n\n\t\t\t\t\t\trow += seq_line ? seq_line : 1;\n\n\t\t\t\t\t\tloop += ansi_sequence_loop+2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* cursor forward */\n\t\t\t\t\tif (ansi_sequence_character == 'C') {\n\t\t\t\t\t\t/* create substring from the sequence's content */\n\t\t\t\t\t\tseqGrab = strndup((char *)ctx->buffer + loop + 2, ansi_sequence_loop);\n\n\t\t\t\t\t\t/* now get escape sequence's position value */\n\t\t\t\t\t\tuint32_t seq_column = strtonum(seqGrab, 0, UINT32_MAX, &errstr);\n\t\t\t\t\t\tfree(seqGrab);\n\n\t\t\t\t\t\tcolumn += seq_column ? seq_column : 1;\n\n\t\t\t\t\t\tif (column > options->columns)\n\t\t\t\t\t\t\tcolumn = options->columns;\n\n\t\t\t\t\t\tloop += ansi_sequence_loop+2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* cursor backward */\n\t\t\t\t\tif (ansi_sequence_character == 'D') {\n\t\t\t\t\t\t/* create substring from the sequence's content */\n\t\t\t\t\t\tseqGrab = strndup((char *)ctx->buffer + loop + 2, ansi_sequence_loop);\n\n\t\t\t\t\t\t/* now get escape sequence's content length */\n\t\t\t\t\t\tuint32_t seq_column = strtonum(seqGrab, 0, UINT32_MAX, &errstr);\n\t\t\t\t\t\tfree(seqGrab);\n\n\t\t\t\t\t\tcolumn -= seq_column ? seq_column : 1;\n\n\t\t\t\t\t\tif (column < 0)\n\t\t\t\t\t\t\tcolumn = 0;\n\n\t\t\t\t\t\tloop += ansi_sequence_loop+2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* save cursor position */\n\t\t\t\t\tif (ansi_sequence_character == 's') {\n\t\t\t\t\t\tsaved_row = row;\n\t\t\t\t\t\tsaved_column = column;\n\n\t\t\t\t\t\tloop += ansi_sequence_loop+2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* restore cursor position */\n\t\t\t\t\tif (ansi_sequence_character == 'u') {\n\t\t\t\t\t\trow = saved_row;\n\t\t\t\t\t\tcolumn = saved_column;\n\n\t\t\t\t\t\tloop += ansi_sequence_loop+2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* erase display */\n\t\t\t\t\tif (ansi_sequence_character == 'J') {\n\t\t\t\t\t\t/* create substring from the sequence's content */\n\t\t\t\t\t\tseqGrab = strndup((char *)ctx->buffer + loop + 2, ansi_sequence_loop);\n\n\t\t\t\t\t\t/* convert grab to an integer */\n\t\t\t\t\t\tuint32_t eraseDisplayInt = strtonum(seqGrab, 0, UINT32_MAX, &errstr);\n\t\t\t\t\t\tfree(seqGrab);\n\n\t\t\t\t\t\tif (eraseDisplayInt == 2) {\n\t\t\t\t\t\t\tcolumn = 0;\n\t\t\t\t\t\t\trow = 0;\n\n\t\t\t\t\t\t\tcolumnMax = 0;\n\t\t\t\t\t\t\trowMax = 0;\n\n\t\t\t\t\t\t\t/* reset ansi buffer */\n\t\t\t\t\t\t\tfree(ansi_buffer);\n\t\t\t\t\t\t\tansi_buffer = malloc(sizeof (struct ansiChar));\n\t\t\t\t\t\t\tstructIndex = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tloop += ansi_sequence_loop+2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* set graphics mode */\n\t\t\t\t\tif (ansi_sequence_character == 'm') {\n\t\t\t\t\t\t/* create substring from the sequence's content */\n\t\t\t\t\t\tseqGrab = strndup((char *)ctx->buffer + loop + 2, ansi_sequence_loop);\n\n\t\t\t\t\t\tseqTok = strtok(seqGrab, \";\");\n\t\t\t\t\t\twhile (seqTok) {\n\t\t\t\t\t\t\tseqValue = strtonum(seqTok, 0, UINT32_MAX, &errstr);\n\n\t\t\t\t\t\t\tif (seqValue == 0) {\n\t\t\t\t\t\t\t\tbackground = 0;\n\t\t\t\t\t\t\t\tforeground = 7;\n\t\t\t\t\t\t\t\tbold = false;\n\t\t\t\t\t\t\t\tblink = false;\n\t\t\t\t\t\t\t\tinvert = false;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (seqValue == 1) {\n\t\t\t\t\t\t\t\tif (!workbench) {\n\t\t\t\t\t\t\t\t\tforeground += 8;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbold = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (seqValue == 5)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (!workbench && options->icecolors)\n\t\t\t\t\t\t\t\t\tbackground += 8;\n\n\t\t\t\t\t\t\t\tblink = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (seqValue == 7)\n\t\t\t\t\t\t\t\tinvert = true;\n\n\t\t\t\t\t\t\tif (seqValue == 27)\n\t\t\t\t\t\t\t\tinvert = false;\n\n\t\t\t\t\t\t\tif (seqValue > 29 && seqValue < 38)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tforeground = seqValue - 30;\n\n\t\t\t\t\t\t\t\tif (bold)\n\t\t\t\t\t\t\t\t\tforeground += 8;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (seqValue > 39 && seqValue < 48)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tbackground = seqValue - 40;\n\n\t\t\t\t\t\t\t\tif (blink && options->icecolors)\n\t\t\t\t\t\t\t\t\tbackground += 8;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tseqTok = strtok(NULL, \";\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tloop += ansi_sequence_loop+2;\n\t\t\t\t\t\tfree(seqGrab);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* cursor (de)activation (Amiga ANSi) */\n\t\t\t\t\tif (ansi_sequence_character == 'p') {\n\t\t\t\t\t\tloop += ansi_sequence_loop+2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* skipping set mode and reset mode sequences */\n\t\t\t\t\tif (ansi_sequence_character == 'h' || ansi_sequence_character == 'l') {\n\t\t\t\t\t\tloop += ansi_sequence_loop+2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* skipping erase in line (EL) sequences */\n\t\t\t\t\tif (ansi_sequence_character == 'K') {\n\t\t\t\t\t\tloop += ansi_sequence_loop+2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* skipping PabloDraw 24-bit ANSI sequences */\n\t\t\t\t\tif (ansi_sequence_character == 't') {\n\t\t\t\t\t\tuint32_t color_R = 0, color_G = 0, color_B = 0;\n\n\t\t\t\t\t\t/* create substring from the sequence's content */\n\t\t\t\t\t\tseqGrab = strndup((char *)ctx->buffer + loop + 2, ansi_sequence_loop);\n\n\t\t\t\t\t\tseqTok = strtok(seqGrab, \";\");\n\t\t\t\t\t\tif (seqTok)\n\t\t\t\t\t\t\tseqValue = strtonum(seqTok, 0, UCHAR_MAX, &errstr);\n\n\t\t\t\t\t\tseqTok = strtok(NULL, \";\");\n\t\t\t\t\t\tcolor_R = seqTok ? strtonum(seqTok, 0, UCHAR_MAX, &errstr) & 0xff : 0;\n\t\t\t\t\t\tseqTok = strtok(NULL, \";\");\n\t\t\t\t\t\tcolor_G = seqTok ? strtonum(seqTok, 0, UCHAR_MAX, &errstr) & 0xff : 0;\n\t\t\t\t\t\tseqTok = strtok(NULL, \";\");\n\t\t\t\t\t\tcolor_B = seqTok ? strtonum(seqTok, 0, UCHAR_MAX, &errstr) & 0xff : 0;\n\n\t\t\t\t\t\tif (seqValue == 0)\n\t\t\t\t\t\t\tbackground = (color_R << 16) | (color_G << 8) | color_B;\n\n\t\t\t\t\t\tif (seqValue == 1)\n\t\t\t\t\t\t\tforeground = (color_R << 16) | (color_G << 8) | color_B;\n\n\t\t\t\t\t\toptions->truecolor = true;\n\n\t\t\t\t\t\tloop += ansi_sequence_loop+2;\n\t\t\t\t\t\tfree(seqGrab);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* record number of columns and lines used */\n\t\t\tif (column > columnMax)\n\t\t\t\tcolumnMax = column;\n\n\t\t\tif (row > rowMax)\n\t\t\t\trowMax = row;\n\n\t\t\t/* write current character in ansiChar structure */\n\t\t\tif (!fontData.isAmigaFont || (current_character != 12 && current_character != 13)) {\n\t\t\t\t/* reallocate structure array memory */\n\n\t\t\t\tansi_buffer = realloc(ansi_buffer, (structIndex + 1) * sizeof (struct ansiChar));\n\t\t\t\tif (ansi_buffer == NULL) {\n\t\t\t\t\tctx->error = ANSILOVE_MEMORY_ERROR;\n\t\t\t\t\tfree(ansi_buffer);\n\t\t\t\t\tansi_buffer = NULL;\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tif (invert) {\n\t\t\t\t\tansi_buffer[structIndex].background = foreground % 8;\n\t\t\t\t\tansi_buffer[structIndex].foreground = background + (foreground & 8);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tansi_buffer[structIndex].background = background;\n\t\t\t\t\tansi_buffer[structIndex].foreground = foreground;\n\t\t\t\t}\n\t\t\t\tansi_buffer[structIndex].character = current_character;\n\t\t\t\tansi_buffer[structIndex].column = column;\n\t\t\t\tansi_buffer[structIndex].row = row;\n\n\t\t\t\tstructIndex++;\n\t\t\t\tcolumn++;\n\t\t\t}\n\t\t}\n\n\t\tloop++;\n\t}\n\n\t/* allocate image buffer memory */\n\tcolumnMax++;\n\trowMax++;\n\n\tif (ced)\n\t\tcolumns = 78;\n\n\tif (options->diz)\n\t\tcolumns = fmin(columnMax, options->columns);\n\n\t/* create that damn thingy */\n\tif (!options->truecolor) {\n\t\tcanvas = gdImageCreate(columns * options->bits, (rowMax)*fontData.height);\n\t} else {\n\t\tcanvas = gdImageCreateTrueColor(columns * options->bits, (rowMax)*fontData.height);\n\t}\n\n\tif (!canvas) {\n\t\tctx->error = ANSILOVE_GD_ERROR;\n\t\tfree(ansi_buffer);\n\t\treturn -1;\n\t}\n\n\tuint32_t colors[16];\n\n\tuint32_t ced_background = 0, ced_foreground = 0;\n\n\tif (ced) {\n\t\tced_background = gdImageColorAllocate(canvas, 170, 170, 170);\n\t\tced_foreground = gdImageColorAllocate(canvas, 0, 0, 0);\n\t\tgdImageFill(canvas, 0, 0, ced_background);\n\t} else if (workbench) {\n\t\tgdImageFill(canvas, 0, 0, 0);\n\n\t\tfor (int i = 0; i < 16; i++) {\n\t\t\tcolors[i] = gdImageColorAllocate(canvas, workbench_palette[i*3],\n\t\t\t    workbench_palette[i*3+1],\n\t\t\t    workbench_palette[i*3+2]);\n\t\t}\n\t} else {\n\t\t/* Allocate standard ANSi color palette */\n\n\t\tfor (int i = 0; i < 16; i++) {\n\t\t\tcolors[i] = gdImageColorAllocate(canvas, ansi_palette[i*3],\n\t\t\t    ansi_palette[i*3+1],\n\t\t\t    ansi_palette[i*3+2]);\n\t\t}\n\t}\n\n\t/* even more definitions, sigh */\n\tuint32_t ansiBufferItems = structIndex;\n\n\t/* render ANSi */\n\tfor (loop = 0; loop < ansiBufferItems; loop++) {\n\t\t/* grab ANSi char from our structure array */\n\t\tbackground = ansi_buffer[loop].background;\n\t\tforeground = ansi_buffer[loop].foreground;\n\t\tcharacter = ansi_buffer[loop].character;\n\t\tcolumn = ansi_buffer[loop].column;\n\t\trow = ansi_buffer[loop].row;\n\n\t\tif (ced) {\n\t\t\tdrawchar(canvas, fontData.font_data, options->bits, fontData.height,\n\t\t\t    column, row, ced_background, ced_foreground, character);\n\t\t} else {\n\t\t\tif (background < 16)\n\t\t\t\tbackground = colors[background];\n\n\t\t\tif (foreground < 16)\n\t\t\t\tforeground = colors[foreground];\n\n\t\t\tdrawchar(canvas, fontData.font_data, options->bits, fontData.height,\n\t\t\t    column, row, background, foreground, character);\n\t\t}\n\n\t}\n\n\t/* transparent flag used? */\n\tif (transparent)\n\t\tgdImageColorTransparent(canvas, 0);\n\n\t/* create output image */\n\tif (output(ctx, options, canvas) != 0) {\n\t\tfree(ansi_buffer);\n\t\treturn -1;\n\t}\n\n\t/* free memory */\n\tfree(ansi_buffer);\n\n\treturn 0;\n}", "target": 1, "idx": 10974}
{"commit_id": "1c1dba62bd3e6fa9d0d0c0aa21926043b75382c7", "project": "CauldronDevelopmentLLC/cbang", "func": "std::string TarFileReader::extract(const string &_path) {\n  if (_path.empty()) THROW(\"path cannot be empty\");\n  if (!hasMore()) THROW(\"No more tar files\");\n\n  string path = _path;\n  if (SystemUtilities::isDirectory(path)) {\n    path += \"/\" + getFilename();\n\n    // Check that path is under the target directory\n    string a = SystemUtilities::getCanonicalPath(_path);\n    string b = SystemUtilities::getCanonicalPath(path);\n    if (!String::startsWith(b, a))\n      THROW(\"Tar path points outside of the extraction directory: \" << path);\n  }\n\n  LOG_DEBUG(5, \"Extracting: \" << path);\n\n  switch (getType()) {\n  case NORMAL_FILE: case CONTIGUOUS_FILE:\n    return extract(*SystemUtilities::oopen(path));\n  case DIRECTORY: SystemUtilities::ensureDirectory(path); break;\n  default: THROW(\"Unsupported tar file type \" << getType());\n  }\n\n  return getFilename();\n}", "target": 2, "idx": 10975}
{"commit_id": "fe9ed49dafa993e3af96b6a5a589efeea9bfb36f", "project": "libgd", "func": "BGD_DECLARE(gdImagePtr) gdImageCreateFromGd2Ctx (gdIOCtxPtr in)\n{\n\tint sx, sy;\n\tint i;\n\tint ncx, ncy, nc, cs, cx, cy;\n\tint x, y, ylo, yhi, xlo, xhi;\n\tint vers, fmt;\n\tt_chunk_info *chunkIdx = NULL;\t/* So we can gdFree it with impunity. */\n\tunsigned char *chunkBuf = NULL;\t/* So we can gdFree it with impunity. */\n\tint chunkNum = 0;\n\tint chunkMax = 0;\n\tuLongf chunkLen;\n\tint chunkPos = 0;\n\tint compMax = 0;\n\tint bytesPerPixel;\n\tchar *compBuf = NULL;\t\t/* So we can gdFree it with impunity. */\n\n\tgdImagePtr im;\n\n\t/* Get the header */\n\tim =\n\t    _gd2CreateFromFile (in, &sx, &sy, &cs, &vers, &fmt, &ncx, &ncy,\n\t                        &chunkIdx);\n\tif (im == NULL) {\n\t\t/* No need to free chunkIdx as _gd2CreateFromFile does it for us. */\n\t\treturn 0;\n\t}\n\n\tbytesPerPixel = im->trueColor ? 4 : 1;\n\tnc = ncx * ncy;\n\n\tif (gd2_compressed (fmt)) {\n\t\t/* Find the maximum compressed chunk size. */\n\t\tcompMax = 0;\n\t\tfor (i = 0; (i < nc); i++) {\n\t\t\tif (chunkIdx[i].size > compMax) {\n\t\t\t\tcompMax = chunkIdx[i].size;\n\t\t\t};\n\t\t};\n\t\tcompMax++;\n\n\t\t/* Allocate buffers */\n\t\tchunkMax = cs * bytesPerPixel * cs;\n\t\tchunkBuf = gdCalloc (chunkMax, 1);\n\t\tif (!chunkBuf) {\n\t\t\tgoto fail;\n\t\t}\n\t\tcompBuf = gdCalloc (compMax, 1);\n\t\tif (!compBuf) {\n\t\t\tgoto fail;\n\t\t}\n\n\t\tGD2_DBG (printf (\"Largest compressed chunk is %d bytes\\n\", compMax));\n\t};\n\n\t/*      if ( (ncx != sx / cs) || (ncy != sy / cs)) { */\n\t/*              goto fail2; */\n\t/*      }; */\n\n\t/* Read the data... */\n\tfor (cy = 0; (cy < ncy); cy++) {\n\t\tfor (cx = 0; (cx < ncx); cx++) {\n\n\t\t\tylo = cy * cs;\n\t\t\tyhi = ylo + cs;\n\t\t\tif (yhi > im->sy) {\n\t\t\t\tyhi = im->sy;\n\t\t\t};\n\n\t\t\tGD2_DBG (printf\n\t\t\t         (\"Processing Chunk %d (%d, %d), y from %d to %d\\n\",\n\t\t\t          chunkNum, cx, cy, ylo, yhi));\n\n\t\t\tif (gd2_compressed (fmt)) {\n\n\t\t\t\tchunkLen = chunkMax;\n\n\t\t\t\tif (!_gd2ReadChunk (chunkIdx[chunkNum].offset,\n\t\t\t\t                    compBuf,\n\t\t\t\t                    chunkIdx[chunkNum].size,\n\t\t\t\t                    (char *) chunkBuf, &chunkLen, in)) {\n\t\t\t\t\tGD2_DBG (printf (\"Error reading comproessed chunk\\n\"));\n\t\t\t\t\tgoto fail;\n\t\t\t\t};\n\n\t\t\t\tchunkPos = 0;\n\t\t\t};\n\n\t\t\tfor (y = ylo; (y < yhi); y++) {\n\n\t\t\t\txlo = cx * cs;\n\t\t\t\txhi = xlo + cs;\n\t\t\t\tif (xhi > im->sx) {\n\t\t\t\t\txhi = im->sx;\n\t\t\t\t};\n\t\t\t\t/*GD2_DBG(printf(\"y=%d: \",y)); */\n\t\t\t\tif (!gd2_compressed (fmt)) {\n\t\t\t\t\tfor (x = xlo; x < xhi; x++) {\n\n\t\t\t\t\t\tif (im->trueColor) {\n\t\t\t\t\t\t\tif (!gdGetInt (&im->tpixels[y][x], in)) {\n\t\t\t\t\t\t\t\tgd_error(\"gd2: EOF while reading\\n\");\n\t\t\t\t\t\t\t\tgdImageDestroy(im);\n\t\t\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tint ch;\n\t\t\t\t\t\t\tif (!gdGetByte (&ch, in)) {\n\t\t\t\t\t\t\t\tgd_error(\"gd2: EOF while reading\\n\");\n\t\t\t\t\t\t\t\tgdImageDestroy(im);\n\t\t\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tim->pixels[y][x] = ch;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (x = xlo; x < xhi; x++) {\n\t\t\t\t\t\tif (im->trueColor) {\n\t\t\t\t\t\t\t/* 2.0.1: work around a gcc bug by being verbose.\n\t\t\t\t\t\t\t   TBB */\n\t\t\t\t\t\t\tint a = chunkBuf[chunkPos++] << 24;\n\t\t\t\t\t\t\tint r = chunkBuf[chunkPos++] << 16;\n\t\t\t\t\t\t\tint g = chunkBuf[chunkPos++] << 8;\n\t\t\t\t\t\t\tint b = chunkBuf[chunkPos++];\n\t\t\t\t\t\t\t/* 2.0.11: tpixels */\n\t\t\t\t\t\t\tim->tpixels[y][x] = a + r + g + b;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tim->pixels[y][x] = chunkBuf[chunkPos++];\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t\t/*GD2_DBG(printf(\"\\n\")); */\n\t\t\t};\n\t\t\tchunkNum++;\n\t\t};\n\t};\n\n\tGD2_DBG (printf (\"Freeing memory\\n\"));\n\n\tgdFree (chunkBuf);\n\tgdFree (compBuf);\n\tgdFree (chunkIdx);\n\n\tGD2_DBG (printf (\"Done\\n\"));\n\n\treturn im;\n\nfail:\n\tgdImageDestroy (im);\n\tif (chunkBuf) {\n\t\tgdFree (chunkBuf);\n\t}\n\tif (compBuf) {\n\t\tgdFree (compBuf);\n\t}\n\tif (chunkIdx) {\n\t\tgdFree (chunkIdx);\n\t}\n\treturn 0;\n}", "target": 1, "idx": 10976}
{"commit_id": "42459e4273c2e47a3232cc16c4f4fff3b3a35c38", "project": "tensorflow", "func": "void Compute(OpKernelContext* ctx) override {\n    const Tensor& sorted_inputs_t = ctx->input(0);\n    const Tensor& values_t = ctx->input(1);\n\n    // inputs must be at least a matrix\n    OP_REQUIRES(\n        ctx, sorted_inputs_t.shape().dims() >= 2,\n        errors::InvalidArgument(\"sorted input argument must be a matrix\"));\n    // must have same batch dim_size for both\n    OP_REQUIRES(ctx, sorted_inputs_t.dim_size(0) == values_t.dim_size(0),\n                Status(error::INVALID_ARGUMENT,\n                       \"Leading dim_size of both tensors must match.\"));\n\n    // this is required because we do indexing in int32 on the GPU\n    OP_REQUIRES(ctx, values_t.NumElements() < std::numeric_limits<int>::max(),\n                Status(error::INVALID_ARGUMENT,\n                       \"values tensor size must less than INT_MAX\"));\n\n    Tensor* output_t;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, values_t.shape(), &output_t));\n\n    if (output_t->dtype() == DT_INT32) {\n      OP_REQUIRES(ctx,\n                  FastBoundsCheck(sorted_inputs_t.dim_size(1),\n                                  std::numeric_limits<int>::max()),\n                  errors::InvalidArgument(\"trailing dim_size must less than \"\n                                          \"INT_MAX for int32 output type, was \",\n                                          sorted_inputs_t.dim_size(1)));\n    }\n\n    auto output = output_t->template flat<OutType>();\n    const auto sorted_inputs = sorted_inputs_t.template flat<T>();\n    const auto values = values_t.template flat<T>();\n    OP_REQUIRES_OK(\n        ctx, functor::LowerBoundFunctor<Device, T, OutType>::Compute(\n                 ctx, sorted_inputs, values, sorted_inputs_t.dim_size(0),\n                 sorted_inputs_t.dim_size(1), values_t.dim_size(1), &output));\n  }", "target": 1, "idx": 10977}
{"commit_id": "760322a71ac9033e122ef1f4b1c62813021e5938", "project": "tensorflow", "func": "Status ImportNodes(ValueMapManager value_manager,\n                   const RepeatedPtrField<NodeDef>& nodes, OpBuilder& builder) {\n  Location unknown_loc = builder.getUnknownLoc();\n  MLIRContext* context = builder.getContext();\n\n  Type placeholder_ty = OpaqueTensorType::get(context);\n  Type control_ty = ControlType::get(context);\n  TFGraphDialect* tfgDialect =\n      cast<TFGraphDialect>(context->getLoadedDialect(\"tfg\"));\n  StringAttr device_attr = tfgDialect->getDeviceAttrIdentifier();\n  StringAttr name_attr = tfgDialect->getNameAttrIdentifier();\n  StringAttr fulltype_attr = tfgDialect->getFullTypeAttrIdentifier();\n  // Process every node and create a matching MLIR operation\n  for (const NodeDef& node : nodes) {\n    DVLOG(1) << \"Processing node \" << node.name() << \"\\n\";\n    if (node.op().empty()) return InvalidArgument(\"empty op type\");\n    OperationState state(unknown_loc, absl::StrCat(\"tfg.\", node.op()));\n    // Fetch the inputs, creating placeholder if an input hasn't been visited.\n    for (const std::string& input : node.input()) {\n      if (input.empty())\n        return InvalidArgument(\"Node '\", node.name(), \"' has an empty input\");\n      TF_ASSIGN_OR_RETURN(Value value,\n                          value_manager.GetValueOrCreatePlaceholder(input));\n      state.operands.push_back(value);\n    }\n    // Retrieve the entry in the nodes_map for this node and infer the result\n    // count from what was inferred during the first traversal above.\n    state.types.push_back(placeholder_ty);\n    state.types.push_back(control_ty);\n    // Handle attributes.\n    for (const auto& namedAttr : node.attr()) {\n      const std::string& name = namedAttr.first;\n      const AttrValue& tf_attr = namedAttr.second;\n      TF_ASSIGN_OR_RETURN(Attribute attr,\n                          ConvertAttributeValue(tf_attr, builder));\n      state.addAttribute(name, attr);\n    }\n    if (!node.device().empty())\n      state.addAttribute(device_attr, StringAttr::get(context, node.device()));\n    if (!node.name().empty())\n      state.addAttribute(name_attr, StringAttr::get(context, node.name()));\n    if (node.has_experimental_type()) {\n      TF_ASSIGN_OR_RETURN(tf_type::FullTypeAttr type,\n                          ConvertAttribute(node.experimental_type(), builder));\n      state.addAttribute(fulltype_attr, type);\n    }\n\n    Operation* op = builder.create(state);\n\n    StringRef node_name = node.name();\n    {\n      size_t colon_sep = node_name.find_first_of(':');\n      if (colon_sep != StringRef::npos)\n        node_name = node_name.take_front(colon_sep);\n    }\n    TF_RETURN_IF_ERROR(value_manager.DefineOperation(op, node_name));\n  }\n  // We don't expect any placeholder left at this point, fail if any.\n  for (Operation& op : *builder.getInsertionBlock()) {\n    if (op.getName().getStringRef() == \"tfg.__mlir_placeholder\") {\n      return InvalidArgument(absl::StrCat(\n          \"Couldn't import graph: placeholder left \",\n          op.getAttrOfType<StringAttr>(name_attr).getValue().str()));\n    }\n  }\n  return ::tensorflow::OkStatus();\n}", "target": 2, "idx": 10978}
{"commit_id": "d30a8bd191f17b61938fc87890bffc80049b0774", "project": "chromium", "func": "void TabHelper::OnInlineWebstoreInstall(content::RenderFrameHost* host,\n                                        int install_id,\n                                        int return_route_id,\n                                        const std::string& webstore_item_id,\n                                        const GURL& requestor_url,\n                                        int listeners_mask) {\n  // Check that the listener is reasonable. We should never get anything other\n  // than an install stage listener, a download listener, or both.\n  if ((listeners_mask & ~(api::webstore::INSTALL_STAGE_LISTENER |\n                          api::webstore::DOWNLOAD_PROGRESS_LISTENER)) != 0 ||\n      requestor_url.is_empty()) {\n    NOTREACHED();\n    return;\n  }\n\n  if (pending_inline_installations_.count(webstore_item_id) != 0) {\n    Send(new ExtensionMsg_InlineWebstoreInstallResponse(\n        return_route_id, install_id, false,\n        webstore_install::kInstallInProgressError,\n        webstore_install::INSTALL_IN_PROGRESS));\n    return;\n  }\n\n  pending_inline_installations_.insert(webstore_item_id);\n  // Inform the Webstore API that an inline install is happening, in case the\n  // page requested status updates.\n  ExtensionRegistry* registry = ExtensionRegistry::Get(profile_);\n  if (registry->disabled_extensions().Contains(webstore_item_id) &&\n      (ExtensionPrefs::Get(profile_)->GetDisableReasons(webstore_item_id) &\n           Extension::DISABLE_PERMISSIONS_INCREASE) != 0) {\n      // The extension was disabled due to permissions increase. Prompt for\n      // re-enable.\n      // TODO(devlin): We should also prompt for re-enable for other reasons,\n      // like user-disabled.\n      // For clarity, explicitly end any prior reenable process.\n      extension_reenabler_.reset();\n      extension_reenabler_ = ExtensionReenabler::PromptForReenable(\n          registry->disabled_extensions().GetByID(webstore_item_id), profile_,\n          web_contents(), requestor_url,\n          base::Bind(&TabHelper::OnReenableComplete,\n                     weak_ptr_factory_.GetWeakPtr(), install_id,\n                     return_route_id, webstore_item_id));\n  } else {\n    // TODO(devlin): We should adddress the case of the extension already\n    // being installed and enabled.\n    bool observe_download_progress =\n        (listeners_mask & api::webstore::DOWNLOAD_PROGRESS_LISTENER) != 0;\n    bool observe_install_stage =\n        (listeners_mask & api::webstore::INSTALL_STAGE_LISTENER) != 0;\n    if (observe_install_stage || observe_download_progress) {\n      DCHECK_EQ(0u, install_observers_.count(webstore_item_id));\n      install_observers_[webstore_item_id] =\n          base::MakeUnique<InlineInstallObserver>(\n              this, web_contents()->GetBrowserContext(), return_route_id,\n              webstore_item_id, observe_download_progress,\n              observe_install_stage);\n    }\n\n    WebstoreStandaloneInstaller::Callback callback = base::Bind(\n        &TabHelper::OnInlineInstallComplete, weak_ptr_factory_.GetWeakPtr(),\n        install_id, return_route_id, webstore_item_id);\n    scoped_refptr<WebstoreInlineInstaller> installer(\n        webstore_inline_installer_factory_->CreateInstaller(\n            web_contents(), host, webstore_item_id, requestor_url, callback));\n    installer->BeginInstall();\n  }\n}", "target": 2, "idx": 10979}
{"commit_id": "7ee6a39c6a1939b376545f030a5efd6f90913583", "project": "foxcpp/maddy", "func": "struct error_obj run_pam_auth(const char *username, char *password) {\n    // PAM frees pam_response for us.\n    struct pam_response *reply = malloc(sizeof(struct pam_response));\n    if (reply == NULL) {\n        struct error_obj ret_val;\n        ret_val.status = 2;\n        ret_val.func_name = \"malloc\";\n        ret_val.error_msg = \"Out of memory\";\n        return ret_val;\n    }\n    reply->resp = password;\n    reply->resp_retcode = 0;\n\n    const struct pam_conv local_conv = { conv_func, reply };\n    pam_handle_t *local_auth = NULL;\n    int status = pam_start(\"maddy\", username, &local_conv, &local_auth);\n    if (status != PAM_SUCCESS) {\n        struct error_obj ret_val;\n        ret_val.status = 2;\n        ret_val.func_name = \"pam_start\";\n        ret_val.error_msg = pam_strerror(local_auth, status);\n        return ret_val;\n    }\n\n    status = pam_authenticate(local_auth, PAM_SILENT|PAM_DISALLOW_NULL_AUTHTOK);\n    if (status != PAM_SUCCESS) {\n        struct error_obj ret_val;\n        if (status == PAM_AUTH_ERR || status == PAM_USER_UNKNOWN) {\n            ret_val.status = 1;\n        } else {\n            ret_val.status = 2;\n        }\n        ret_val.func_name = \"pam_authenticate\";\n        ret_val.error_msg = pam_strerror(local_auth, status);\n        return ret_val;\n    }\n\n    status = pam_acct_mgmt(local_auth, PAM_SILENT|PAM_DISALLOW_NULL_AUTHTOK);\n    if (status != PAM_SUCCESS) {\n        struct error_obj ret_val;\n        if (status == PAM_AUTH_ERR || status == PAM_USER_UNKNOWN || status == PAM_NEW_AUTHTOK_REQD) {\n            ret_val.status = 1;\n        } else {\n            ret_val.status = 2;\n        }\n        ret_val.func_name = \"pam_acct_mgmt\";\n        ret_val.error_msg = pam_strerror(local_auth, status);\n        return ret_val;\n    }\n\n    status = pam_end(local_auth, status);\n    if (status != PAM_SUCCESS) {\n        struct error_obj ret_val;\n        ret_val.status = 2;\n        ret_val.func_name = \"pam_end\";\n        ret_val.error_msg = pam_strerror(local_auth, status);\n        return ret_val;\n    }\n\n    struct error_obj ret_val;\n    ret_val.status = 0;\n    ret_val.func_name = NULL;\n    ret_val.error_msg = NULL;\n    return ret_val;\n}", "target": 1, "idx": 10980}
{"commit_id": "7ee6a39c6a1939b376545f030a5efd6f90913583", "project": "foxcpp/maddy", "func": "struct error_obj run_pam_auth(const char *username, char *password) {\n    // PAM frees pam_response for us.\n    struct pam_response *reply = malloc(sizeof(struct pam_response));\n    if (reply == NULL) {\n        struct error_obj ret_val;\n        ret_val.status = 2;\n        ret_val.func_name = \"malloc\";\n        ret_val.error_msg = \"Out of memory\";\n        return ret_val;\n    }\n    reply->resp = password;\n    reply->resp_retcode = 0;\n\n    const struct pam_conv local_conv = { conv_func, reply };\n    pam_handle_t *local_auth = NULL;\n    int status = pam_start(\"maddy\", username, &local_conv, &local_auth);\n    if (status != PAM_SUCCESS) {\n        struct error_obj ret_val;\n        ret_val.status = 2;\n        ret_val.func_name = \"pam_start\";\n        ret_val.error_msg = pam_strerror(local_auth, status);\n        return ret_val;\n    }\n\n    status = pam_authenticate(local_auth, PAM_SILENT|PAM_DISALLOW_NULL_AUTHTOK);\n    if (status != PAM_SUCCESS) {\n        struct error_obj ret_val;\n        if (status == PAM_AUTH_ERR || status == PAM_USER_UNKNOWN) {\n            ret_val.status = 1;\n        } else {\n            ret_val.status = 2;\n        }\n        ret_val.func_name = \"pam_authenticate\";\n        ret_val.error_msg = pam_strerror(local_auth, status);\n        return ret_val;\n    }\n\n    status = pam_acct_mgmt(local_auth, PAM_SILENT|PAM_DISALLOW_NULL_AUTHTOK);\n    if (status != PAM_SUCCESS) {\n        struct error_obj ret_val;\n        if (status == PAM_AUTH_ERR || status == PAM_USER_UNKNOWN || status == PAM_NEW_AUTHTOK_REQD) {\n            ret_val.status = 1;\n        } else {\n            ret_val.status = 2;\n        }\n        ret_val.func_name = \"pam_acct_mgmt\";\n        ret_val.error_msg = pam_strerror(local_auth, status);\n        return ret_val;\n    }\n\n    status = pam_end(local_auth, status);\n    if (status != PAM_SUCCESS) {\n        struct error_obj ret_val;\n        ret_val.status = 2;\n        ret_val.func_name = \"pam_end\";\n        ret_val.error_msg = pam_strerror(local_auth, status);\n        return ret_val;\n    }\n\n    struct error_obj ret_val;\n    ret_val.status = 0;\n    ret_val.func_name = NULL;\n    ret_val.error_msg = NULL;\n    return ret_val;\n}", "target": 1, "idx": 10981}
{"commit_id": "b499389da21d89d32deff500376c5ee4f8f0b04c", "project": "android", "func": "FLAC__bool read_metadata_vorbiscomment_(FLAC__StreamDecoder *decoder, FLAC__StreamMetadata_VorbisComment *obj, unsigned length)\n{\n\tFLAC__uint32 i;\n\n\tFLAC__ASSERT(FLAC__bitreader_is_consumed_byte_aligned(decoder->private_->input));\n\n\t/* read vendor string */\n\tif (length >= 8) {\n\t\tlength -= 8; /* vendor string length + num comments entries alone take 8 bytes */\n\t\tFLAC__ASSERT(FLAC__STREAM_METADATA_VORBIS_COMMENT_ENTRY_LENGTH_LEN == 32);\n\t\tif (!FLAC__bitreader_read_uint32_little_endian(decoder->private_->input, &obj->vendor_string.length))\n\t\t\treturn false; /* read_callback_ sets the state for us */\n\t\tif (obj->vendor_string.length > 0) {\n\t\t\tif (length < obj->vendor_string.length) {\n\t\t\t\tobj->vendor_string.length = 0;\n\t\t\t\tobj->vendor_string.entry = 0;\n\t\t\t\tgoto skip;\n\t\t\t}\n\t\t\telse\n\t\t\t\tlength -= obj->vendor_string.length;\n\t\t\tif (0 == (obj->vendor_string.entry = safe_malloc_add_2op_(obj->vendor_string.length, /*+*/1))) {\n\t\t\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!FLAC__bitreader_read_byte_block_aligned_no_crc(decoder->private_->input, obj->vendor_string.entry, obj->vendor_string.length))\n\t\t\t\treturn false; /* read_callback_ sets the state for us */\n\t\t\tobj->vendor_string.entry[obj->vendor_string.length] = '\\0';\n\t\t}\n\t\telse\n\t\t\tobj->vendor_string.entry = 0;\n\n\t\t/* read num comments */\n\t\tFLAC__ASSERT(FLAC__STREAM_METADATA_VORBIS_COMMENT_NUM_COMMENTS_LEN == 32);\n\t\tif (!FLAC__bitreader_read_uint32_little_endian(decoder->private_->input, &obj->num_comments))\n\t\t\treturn false; /* read_callback_ sets the state for us */\n\n\t\t/* read comments */\n\t\tif (obj->num_comments > 100000) {\n\t\t\t/* Possibly malicious file. */\n\t\t\tobj->num_comments = 0;\n\t\t\treturn false;\n\t\t}\n\t\tif (obj->num_comments > 0) {\n\t\t\tif (0 == (obj->comments = safe_malloc_mul_2op_p(obj->num_comments, /*times*/sizeof(FLAC__StreamMetadata_VorbisComment_Entry)))) {\n\t\t\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR;\n\t\t\t\tobj->num_comments = 0;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (i = 0; i < obj->num_comments; i++) {\n\t\t\t\t/* Initialize here just to make sure. */\n\t\t\t\tobj->comments[i].length = 0;\n\t\t\t\tobj->comments[i].entry = 0;\n\n\t\t\t\tFLAC__ASSERT(FLAC__STREAM_METADATA_VORBIS_COMMENT_ENTRY_LENGTH_LEN == 32);\n\t\t\t\tif (length < 4) {\n\t\t\t\t\tobj->num_comments = i;\n\t\t\t\t\tgoto skip;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tlength -= 4;\n\t\t\t\tif (!FLAC__bitreader_read_uint32_little_endian(decoder->private_->input, &obj->comments[i].length))\n\t\t\t\t\treturn false; /* read_callback_ sets the state for us */\n\t\t\t\tif (obj->comments[i].length > 0) {\n\t\t\t\t\tif (length < obj->comments[i].length) {\n\t\t\t\t\t\tobj->num_comments = i;\n\t\t\t\t\t\tgoto skip;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tlength -= obj->comments[i].length;\n\t\t\t\t\tif (0 == (obj->comments[i].entry = safe_malloc_add_2op_(obj->comments[i].length, /*+*/1))) {\n\t\t\t\t\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tmemset (obj->comments[i].entry, 0, obj->comments[i].length) ;\n\t\t\t\t\tif (!FLAC__bitreader_read_byte_block_aligned_no_crc(decoder->private_->input, obj->comments[i].entry, obj->comments[i].length)) {\n\t\t\t\t\t\tobj->num_comments = i;\n\t\t\t\t\t\tgoto skip;\n\t\t\t\t\t}\n\t\t\t\t\tobj->comments[i].entry[obj->comments[i].length] = '\\0';\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tobj->comments[i].entry = 0;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tobj->comments = 0;\n\t}\n\n  skip:\n\tif (length > 0) {\n\t\t/* This will only happen on files with invalid data in comments */\n\t\tif(!FLAC__bitreader_skip_byte_block_aligned_no_crc(decoder->private_->input, length))\n\t\t\treturn false; /* read_callback_ sets the state for us */\n\t}\n\n\treturn true;\n}", "target": 3, "idx": 10982}
{"commit_id": "945a9a8e448b65bec055d37eba58f711b39f66f0", "project": "torvalds/linux", "func": "struct pvr2_hdw *pvr2_hdw_create(struct usb_interface *intf,\n\t\t\t\t const struct usb_device_id *devid)\n{\n\tunsigned int idx,cnt1,cnt2,m;\n\tstruct pvr2_hdw *hdw = NULL;\n\tint valid_std_mask;\n\tstruct pvr2_ctrl *cptr;\n\tstruct usb_device *usb_dev;\n\tconst struct pvr2_device_desc *hdw_desc;\n\t__u8 ifnum;\n\tstruct v4l2_queryctrl qctrl;\n\tstruct pvr2_ctl_info *ciptr;\n\n\tusb_dev = interface_to_usbdev(intf);\n\n\thdw_desc = (const struct pvr2_device_desc *)(devid->driver_info);\n\n\tif (hdw_desc == NULL) {\n\t\tpvr2_trace(PVR2_TRACE_INIT, \"pvr2_hdw_create: No device description pointer, unable to continue.\");\n\t\tpvr2_trace(PVR2_TRACE_INIT,\n\t\t\t   \"If you have a new device type, please contact Mike Isely <isely@pobox.com> to get it included in the driver\");\n\t\tgoto fail;\n\t}\n\n\thdw = kzalloc(sizeof(*hdw),GFP_KERNEL);\n\tpvr2_trace(PVR2_TRACE_INIT,\"pvr2_hdw_create: hdw=%p, type \\\"%s\\\"\",\n\t\t   hdw,hdw_desc->description);\n\tpvr2_trace(PVR2_TRACE_INFO, \"Hardware description: %s\",\n\t\thdw_desc->description);\n\tif (hdw_desc->flag_is_experimental) {\n\t\tpvr2_trace(PVR2_TRACE_INFO, \"**********\");\n\t\tpvr2_trace(PVR2_TRACE_INFO,\n\t\t\t   \"***WARNING*** Support for this device (%s) is experimental.\",\n\t\t\t\t\t\t\t      hdw_desc->description);\n\t\tpvr2_trace(PVR2_TRACE_INFO,\n\t\t\t   \"Important functionality might not be entirely working.\");\n\t\tpvr2_trace(PVR2_TRACE_INFO,\n\t\t\t   \"Please consider contacting the driver author to help with further stabilization of the driver.\");\n\t\tpvr2_trace(PVR2_TRACE_INFO, \"**********\");\n\t}\n\tif (!hdw) goto fail;\n\n\ttimer_setup(&hdw->quiescent_timer, pvr2_hdw_quiescent_timeout, 0);\n\n\ttimer_setup(&hdw->decoder_stabilization_timer,\n\t\t    pvr2_hdw_decoder_stabilization_timeout, 0);\n\n\ttimer_setup(&hdw->encoder_wait_timer, pvr2_hdw_encoder_wait_timeout,\n\t\t    0);\n\n\ttimer_setup(&hdw->encoder_run_timer, pvr2_hdw_encoder_run_timeout, 0);\n\n\thdw->master_state = PVR2_STATE_DEAD;\n\n\tinit_waitqueue_head(&hdw->state_wait_data);\n\n\thdw->tuner_signal_stale = !0;\n\tcx2341x_fill_defaults(&hdw->enc_ctl_state);\n\n\t/* Calculate which inputs are OK */\n\tm = 0;\n\tif (hdw_desc->flag_has_analogtuner) m |= 1 << PVR2_CVAL_INPUT_TV;\n\tif (hdw_desc->digital_control_scheme != PVR2_DIGITAL_SCHEME_NONE) {\n\t\tm |= 1 << PVR2_CVAL_INPUT_DTV;\n\t}\n\tif (hdw_desc->flag_has_svideo) m |= 1 << PVR2_CVAL_INPUT_SVIDEO;\n\tif (hdw_desc->flag_has_composite) m |= 1 << PVR2_CVAL_INPUT_COMPOSITE;\n\tif (hdw_desc->flag_has_fmradio) m |= 1 << PVR2_CVAL_INPUT_RADIO;\n\thdw->input_avail_mask = m;\n\thdw->input_allowed_mask = hdw->input_avail_mask;\n\n\t/* If not a hybrid device, pathway_state never changes.  So\n\t   initialize it here to what it should forever be. */\n\tif (!(hdw->input_avail_mask & (1 << PVR2_CVAL_INPUT_DTV))) {\n\t\thdw->pathway_state = PVR2_PATHWAY_ANALOG;\n\t} else if (!(hdw->input_avail_mask & (1 << PVR2_CVAL_INPUT_TV))) {\n\t\thdw->pathway_state = PVR2_PATHWAY_DIGITAL;\n\t}\n\n\thdw->control_cnt = CTRLDEF_COUNT;\n\thdw->control_cnt += MPEGDEF_COUNT;\n\thdw->controls = kcalloc(hdw->control_cnt, sizeof(struct pvr2_ctrl),\n\t\t\t\tGFP_KERNEL);\n\tif (!hdw->controls) goto fail;\n\thdw->hdw_desc = hdw_desc;\n\thdw->ir_scheme_active = hdw->hdw_desc->ir_scheme;\n\tfor (idx = 0; idx < hdw->control_cnt; idx++) {\n\t\tcptr = hdw->controls + idx;\n\t\tcptr->hdw = hdw;\n\t}\n\tfor (idx = 0; idx < 32; idx++) {\n\t\thdw->std_mask_ptrs[idx] = hdw->std_mask_names[idx];\n\t}\n\tfor (idx = 0; idx < CTRLDEF_COUNT; idx++) {\n\t\tcptr = hdw->controls + idx;\n\t\tcptr->info = control_defs+idx;\n\t}\n\n\t/* Ensure that default input choice is a valid one. */\n\tm = hdw->input_avail_mask;\n\tif (m) for (idx = 0; idx < (sizeof(m) << 3); idx++) {\n\t\tif (!((1UL << idx) & m)) continue;\n\t\thdw->input_val = idx;\n\t\tbreak;\n\t}\n\n\t/* Define and configure additional controls from cx2341x module. */\n\thdw->mpeg_ctrl_info = kcalloc(MPEGDEF_COUNT,\n\t\t\t\t      sizeof(*(hdw->mpeg_ctrl_info)),\n\t\t\t\t      GFP_KERNEL);\n\tif (!hdw->mpeg_ctrl_info) goto fail;\n\tfor (idx = 0; idx < MPEGDEF_COUNT; idx++) {\n\t\tcptr = hdw->controls + idx + CTRLDEF_COUNT;\n\t\tciptr = &(hdw->mpeg_ctrl_info[idx].info);\n\t\tciptr->desc = hdw->mpeg_ctrl_info[idx].desc;\n\t\tciptr->name = mpeg_ids[idx].strid;\n\t\tciptr->v4l_id = mpeg_ids[idx].id;\n\t\tciptr->skip_init = !0;\n\t\tciptr->get_value = ctrl_cx2341x_get;\n\t\tciptr->get_v4lflags = ctrl_cx2341x_getv4lflags;\n\t\tciptr->is_dirty = ctrl_cx2341x_is_dirty;\n\t\tif (!idx) ciptr->clear_dirty = ctrl_cx2341x_clear_dirty;\n\t\tqctrl.id = ciptr->v4l_id;\n\t\tcx2341x_ctrl_query(&hdw->enc_ctl_state,&qctrl);\n\t\tif (!(qctrl.flags & V4L2_CTRL_FLAG_READ_ONLY)) {\n\t\t\tciptr->set_value = ctrl_cx2341x_set;\n\t\t}\n\t\tstrscpy(hdw->mpeg_ctrl_info[idx].desc, qctrl.name,\n\t\t\tsizeof(hdw->mpeg_ctrl_info[idx].desc));\n\t\tciptr->default_value = qctrl.default_value;\n\t\tswitch (qctrl.type) {\n\t\tdefault:\n\t\tcase V4L2_CTRL_TYPE_INTEGER:\n\t\t\tciptr->type = pvr2_ctl_int;\n\t\t\tciptr->def.type_int.min_value = qctrl.minimum;\n\t\t\tciptr->def.type_int.max_value = qctrl.maximum;\n\t\t\tbreak;\n\t\tcase V4L2_CTRL_TYPE_BOOLEAN:\n\t\t\tciptr->type = pvr2_ctl_bool;\n\t\t\tbreak;\n\t\tcase V4L2_CTRL_TYPE_MENU:\n\t\t\tciptr->type = pvr2_ctl_enum;\n\t\t\tciptr->def.type_enum.value_names =\n\t\t\t\tcx2341x_ctrl_get_menu(&hdw->enc_ctl_state,\n\t\t\t\t\t\t\t\tciptr->v4l_id);\n\t\t\tfor (cnt1 = 0;\n\t\t\t     ciptr->def.type_enum.value_names[cnt1] != NULL;\n\t\t\t     cnt1++) { }\n\t\t\tciptr->def.type_enum.count = cnt1;\n\t\t\tbreak;\n\t\t}\n\t\tcptr->info = ciptr;\n\t}\n\n\t// Initialize control data regarding video standard masks\n\tvalid_std_mask = pvr2_std_get_usable();\n\tfor (idx = 0; idx < 32; idx++) {\n\t\tif (!(valid_std_mask & (1UL << idx))) continue;\n\t\tcnt1 = pvr2_std_id_to_str(\n\t\t\thdw->std_mask_names[idx],\n\t\t\tsizeof(hdw->std_mask_names[idx])-1,\n\t\t\t1UL << idx);\n\t\thdw->std_mask_names[idx][cnt1] = 0;\n\t}\n\tcptr = pvr2_hdw_get_ctrl_by_id(hdw,PVR2_CID_STDAVAIL);\n\tif (cptr) {\n\t\tmemcpy(&hdw->std_info_avail,cptr->info,\n\t\t       sizeof(hdw->std_info_avail));\n\t\tcptr->info = &hdw->std_info_avail;\n\t\thdw->std_info_avail.def.type_bitmask.bit_names =\n\t\t\thdw->std_mask_ptrs;\n\t\thdw->std_info_avail.def.type_bitmask.valid_bits =\n\t\t\tvalid_std_mask;\n\t}\n\tcptr = pvr2_hdw_get_ctrl_by_id(hdw,PVR2_CID_STDCUR);\n\tif (cptr) {\n\t\tmemcpy(&hdw->std_info_cur,cptr->info,\n\t\t       sizeof(hdw->std_info_cur));\n\t\tcptr->info = &hdw->std_info_cur;\n\t\thdw->std_info_cur.def.type_bitmask.bit_names =\n\t\t\thdw->std_mask_ptrs;\n\t\thdw->std_info_cur.def.type_bitmask.valid_bits =\n\t\t\tvalid_std_mask;\n\t}\n\tcptr = pvr2_hdw_get_ctrl_by_id(hdw,PVR2_CID_STDDETECT);\n\tif (cptr) {\n\t\tmemcpy(&hdw->std_info_detect,cptr->info,\n\t\t       sizeof(hdw->std_info_detect));\n\t\tcptr->info = &hdw->std_info_detect;\n\t\thdw->std_info_detect.def.type_bitmask.bit_names =\n\t\t\thdw->std_mask_ptrs;\n\t\thdw->std_info_detect.def.type_bitmask.valid_bits =\n\t\t\tvalid_std_mask;\n\t}\n\n\thdw->cropcap_stale = !0;\n\thdw->eeprom_addr = -1;\n\thdw->unit_number = -1;\n\thdw->v4l_minor_number_video = -1;\n\thdw->v4l_minor_number_vbi = -1;\n\thdw->v4l_minor_number_radio = -1;\n\thdw->ctl_write_buffer = kmalloc(PVR2_CTL_BUFFSIZE,GFP_KERNEL);\n\tif (!hdw->ctl_write_buffer) goto fail;\n\thdw->ctl_read_buffer = kmalloc(PVR2_CTL_BUFFSIZE,GFP_KERNEL);\n\tif (!hdw->ctl_read_buffer) goto fail;\n\thdw->ctl_write_urb = usb_alloc_urb(0,GFP_KERNEL);\n\tif (!hdw->ctl_write_urb) goto fail;\n\thdw->ctl_read_urb = usb_alloc_urb(0,GFP_KERNEL);\n\tif (!hdw->ctl_read_urb) goto fail;\n\n\tif (v4l2_device_register(&intf->dev, &hdw->v4l2_dev) != 0) {\n\t\tpvr2_trace(PVR2_TRACE_ERROR_LEGS,\n\t\t\t   \"Error registering with v4l core, giving up\");\n\t\tgoto fail;\n\t}\n\tmutex_lock(&pvr2_unit_mtx);\n\tdo {\n\t\tfor (idx = 0; idx < PVR_NUM; idx++) {\n\t\t\tif (unit_pointers[idx]) continue;\n\t\t\thdw->unit_number = idx;\n\t\t\tunit_pointers[idx] = hdw;\n\t\t\tbreak;\n\t\t}\n\t} while (0);\n\tmutex_unlock(&pvr2_unit_mtx);\n\n\tINIT_WORK(&hdw->workpoll, pvr2_hdw_worker_poll);\n\n\tif (hdw->unit_number == -1)\n\t\tgoto fail;\n\n\tcnt1 = 0;\n\tcnt2 = scnprintf(hdw->name+cnt1,sizeof(hdw->name)-cnt1,\"pvrusb2\");\n\tcnt1 += cnt2;\n\tif (hdw->unit_number >= 0) {\n\t\tcnt2 = scnprintf(hdw->name+cnt1,sizeof(hdw->name)-cnt1,\"_%c\",\n\t\t\t\t ('a' + hdw->unit_number));\n\t\tcnt1 += cnt2;\n\t}\n\tif (cnt1 >= sizeof(hdw->name)) cnt1 = sizeof(hdw->name)-1;\n\thdw->name[cnt1] = 0;\n\n\tpvr2_trace(PVR2_TRACE_INIT,\"Driver unit number is %d, name is %s\",\n\t\t   hdw->unit_number,hdw->name);\n\n\thdw->tuner_type = -1;\n\thdw->flag_ok = !0;\n\n\thdw->usb_intf = intf;\n\thdw->usb_dev = usb_dev;\n\n\tusb_make_path(hdw->usb_dev, hdw->bus_info, sizeof(hdw->bus_info));\n\n\tifnum = hdw->usb_intf->cur_altsetting->desc.bInterfaceNumber;\n\tusb_set_interface(hdw->usb_dev,ifnum,0);\n\n\tmutex_init(&hdw->ctl_lock_mutex);\n\tmutex_init(&hdw->big_lock_mutex);\n\n\treturn hdw;\n fail:\n\tif (hdw) {\n\t\tdel_timer_sync(&hdw->quiescent_timer);\n\t\tdel_timer_sync(&hdw->decoder_stabilization_timer);\n\t\tdel_timer_sync(&hdw->encoder_run_timer);\n\t\tdel_timer_sync(&hdw->encoder_wait_timer);\n\t\tflush_work(&hdw->workpoll);\n\t\tv4l2_device_unregister(&hdw->v4l2_dev);\n\t\tusb_free_urb(hdw->ctl_read_urb);\n\t\tusb_free_urb(hdw->ctl_write_urb);\n\t\tkfree(hdw->ctl_read_buffer);\n\t\tkfree(hdw->ctl_write_buffer);\n\t\tkfree(hdw->controls);\n\t\tkfree(hdw->mpeg_ctrl_info);\n\t\tkfree(hdw);\n\t}\n\treturn NULL;\n}", "target": 2, "idx": 10983}
{"commit_id": "065b175952c344d00a4af9cc9f5d28e964ce33fd", "project": "wazuh", "func": "int ReadExecConfig()\n{\n    int i = 0, j = 0, dup_entry = 0;\n    FILE *fp;\n    FILE *process_file;\n    char buffer[OS_MAXSTR + 1];\n\n    /* Clean up */\n    for (i = 0; i <= exec_size + 1; i++) {\n        memset(exec_names[i], '\\0', OS_FLSIZE + 1);\n        memset(exec_cmd[i], '\\0', OS_FLSIZE + 1);\n        exec_timeout[i] = 0;\n    }\n    exec_size = 0;\n\n    /* Open file */\n    fp = fopen(DEFAULTAR, \"r\");\n    if (!fp) {\n        merror(FOPEN_ERROR, DEFAULTAR, errno, strerror(errno));\n        return (0);\n    }\n\n    /* Read config */\n    while (fgets(buffer, OS_MAXSTR, fp) != NULL) {\n        char *str_pt;\n        char *tmp_str;\n\n        str_pt = buffer;\n\n        // The command name must not start with '!'\n\n        if (buffer[0] == '!') {\n            merror(EXEC_INV_CONF, DEFAULTAR);\n            continue;\n        }\n\n        /* Clean up the buffer */\n        tmp_str = strstr(buffer, \" - \");\n        if (!tmp_str) {\n            merror(EXEC_INV_CONF, DEFAULTAR);\n            continue;\n        }\n        *tmp_str = '\\0';\n        tmp_str += 3;\n\n        /* Set the name */\n        strncpy(exec_names[exec_size], str_pt, OS_FLSIZE);\n        exec_names[exec_size][OS_FLSIZE] = '\\0';\n\n        str_pt = tmp_str;\n\n        /* Search for ' ' and - */\n        tmp_str = strstr(tmp_str, \" - \");\n        if (!tmp_str) {\n            merror(EXEC_INV_CONF, DEFAULTAR);\n            continue;\n        }\n        *tmp_str = '\\0';\n        tmp_str += 3;\n\n        // Directory traversal test\n\n        if (w_ref_parent_folder(str_pt)) {\n            merror(\"Active response command '%s' vulnerable to directory traversal attack. Ignoring.\", str_pt);\n            exec_cmd[exec_size][0] = '\\0';\n        } else {\n            /* Write the full command path */\n            snprintf(exec_cmd[exec_size], OS_FLSIZE,\n                     \"%s/%s\",\n                     AR_BINDIR,\n                     str_pt);\n            process_file = fopen(exec_cmd[exec_size], \"r\");\n            if (!process_file) {\n                if (f_time_reading) {\n                    minfo(\"Active response command not present: '%s'. \"\n                            \"Not using it on this system.\",\n                            exec_cmd[exec_size]);\n                }\n\n                exec_cmd[exec_size][0] = '\\0';\n            } else {\n                fclose(process_file);\n            }\n        }\n\n        str_pt = tmp_str;\n        tmp_str = strchr(tmp_str, '\\n');\n        if (tmp_str) {\n            *tmp_str = '\\0';\n        }\n\n        /* Get the exec timeout */\n        exec_timeout[exec_size] = atoi(str_pt);\n\n        /* Check if name is duplicated */\n        dup_entry = 0;\n        for (j = 0; j < exec_size; j++) {\n            if (strcmp(exec_names[j], exec_names[exec_size]) == 0) {\n                if (exec_cmd[j][0] == '\\0') {\n                    strncpy(exec_cmd[j], exec_cmd[exec_size], OS_FLSIZE);\n                    exec_cmd[j][OS_FLSIZE] = '\\0';\n                    dup_entry = 1;\n                    break;\n                } else if (exec_cmd[exec_size][0] == '\\0') {\n                    dup_entry = 1;\n                }\n            }\n        }\n\n        if (dup_entry) {\n            exec_cmd[exec_size][0] = '\\0';\n            exec_names[exec_size][0] = '\\0';\n            exec_timeout[exec_size] = 0;\n        } else {\n            exec_size++;\n        }\n    }\n\n    fclose(fp);\n    f_time_reading = 0;\n\n    return (1);\n}", "target": 2, "idx": 10984}
{"commit_id": "3c9fa24ca7c9c47605672916491f79e8ccacb9e6", "project": "torvalds/linux", "func": "static int linear_read_system(struct x86_emulate_ctxt *ctxt, ulong linear,\n\t\t\t      void *data, unsigned size)\n{\n\treturn ctxt->ops->read_std(ctxt, linear, data, size, &ctxt->exception, true);\n}", "target": 2, "idx": 10985}
{"commit_id": "7d63fb3af87aa67aa7d24466e792f9d7c57d8e79", "project": "torvalds/linux", "func": "int\nswiotlb_late_init_with_default_size(size_t default_size)\n{\n\tunsigned long bytes, req_nslabs = io_tlb_nslabs;\n\tunsigned char *vstart = NULL;\n\tunsigned int order;\n\tint rc = 0;\n\n\tif (!io_tlb_nslabs) {\n\t\tio_tlb_nslabs = (default_size >> IO_TLB_SHIFT);\n\t\tio_tlb_nslabs = ALIGN(io_tlb_nslabs, IO_TLB_SEGSIZE);\n\t}\n\n\t/*\n\t * Get IO TLB memory from the low pages\n\t */\n\torder = get_order(io_tlb_nslabs << IO_TLB_SHIFT);\n\tio_tlb_nslabs = SLABS_PER_PAGE << order;\n\tbytes = io_tlb_nslabs << IO_TLB_SHIFT;\n\n\twhile ((SLABS_PER_PAGE << order) > IO_TLB_MIN_SLABS) {\n\t\tvstart = (void *)__get_free_pages(GFP_DMA | __GFP_NOWARN,\n\t\t\t\t\t\t  order);\n\t\tif (vstart)\n\t\t\tbreak;\n\t\torder--;\n\t}\n\n\tif (!vstart) {\n\t\tio_tlb_nslabs = req_nslabs;\n\t\treturn -ENOMEM;\n\t}\n\tif (order != get_order(bytes)) {\n\t\tpr_warn(\"only able to allocate %ld MB\\n\",\n\t\t\t(PAGE_SIZE << order) >> 20);\n\t\tio_tlb_nslabs = SLABS_PER_PAGE << order;\n\t}\n\trc = swiotlb_late_init_with_tbl(vstart, io_tlb_nslabs);\n\tif (rc)\n\t\tfree_pages((unsigned long)vstart, order);\n\n\treturn rc;\n}", "target": 1, "idx": 10986}
{"commit_id": "2cb40c4d5feeaa09325522bd7d97910f1b59e379", "project": "polkit", "func": "static void\npolkit_unix_group_set_property (GObject      *object,\n                               guint         prop_id,\n                               const GValue *value,\n                               GParamSpec   *pspec)\n{\n  PolkitUnixGroup *unix_group = POLKIT_UNIX_GROUP (object);\n  gint val;\n\n  switch (prop_id)\n    {\n    case PROP_GID:\n      val = g_value_get_int (value);\n      g_return_if_fail (val != -1);\n      unix_group->gid = val;\n      break;\n\n    default:\n      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);\n      break;\n    }\n}", "target": 2, "idx": 10987}
{"commit_id": "0523c79d6e63858c990821a990edcb82cf8af284", "project": "radareorg/radare2", "func": "static const ut8 *parse_attr_value(const ut8 *obuf, int obuf_len,\n\t\tRBinDwarfAttrDef *def, RBinDwarfAttrValue *value,\n\t\tconst RBinDwarfCompUnitHdr *hdr,\n\t\tconst ut8 *debug_str, size_t debug_str_len) {\n\n\tconst ut8 *buf = obuf;\n\tconst ut8 *buf_end = obuf + obuf_len;\n\tsize_t j;\n\n\tr_return_val_if_fail(def && value && hdr && obuf && obuf_len >= 1, NULL);\n\n\tvalue->attr_form = def->attr_form;\n\tvalue->attr_name = def->attr_name;\n\tvalue->block.data = NULL;\n\tvalue->string.content = NULL;\n\tvalue->string.offset = 0;\n\n\tswitch (def->attr_form) {\n\tcase DW_FORM_addr:\n\t\tswitch (hdr->address_size) {\n\t\tcase 1:\n\t\t\tvalue->address = READ8 (buf);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tvalue->address = READ16 (buf);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tvalue->address = READ32 (buf);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tvalue->address = READ64 (buf);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\teprintf (\"DWARF: Unexpected pointer size: %u\\n\", (unsigned)hdr->address_size);\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_data1:\n\t\tvalue->data = READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_data2:\n\t\tvalue->data = READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_data4:\n\t\tvalue->data = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_data8:\n\t\tvalue->data = READ64 (buf);\n\t\tbreak;\n\tcase DW_FORM_data16: // TODO Fix this, right now I just read the data, but I need to make storage for it\n\t\tvalue->data = READ64 (buf);\n\t\tvalue->data = READ64 (buf);\n\t\tbreak;\n\tcase DW_FORM_sdata:\n\t\tbuf = r_leb128 (buf, buf_end - buf, &value->sdata);\n\t\tbreak;\n\tcase DW_FORM_udata:\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->data);\n\t\tbreak;\n\tcase DW_FORM_string:\n\t\tvalue->string.content = *buf ? strdup ((const char *)buf) : NULL;\n\t\tbuf += (strlen ((const char *)buf) + 1);\n\t\tbreak;\n\tcase DW_FORM_block1:\n\t\tvalue->block.length = READ8 (buf);\n\t\tvalue->block.data = calloc (sizeof (ut8), value->block.length + 1);\n\t\tif (!value->block.data) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (value->block.data) {\n\t\t\tfor (j = 0; j < value->block.length; j++) {\n\t\t\t\tvalue->block.data[j] = READ (buf, ut8);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_block2:\n\t\tvalue->block.length = READ16 (buf);\n\t\tif (value->block.length > 0) {\n\t\t\tvalue->block.data = calloc (sizeof (ut8), value->block.length);\n\t\t\tif (!value->block.data) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tfor (j = 0; j < value->block.length; j++) {\n\t\t\t\tvalue->block.data[j] = READ (buf, ut8);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_block4:\n\t\tvalue->block.length = READ32 (buf);\n\t\tif (value->block.length > 0) {\n\t\t\tut8 *data = calloc (sizeof (ut8), value->block.length);\n\t\t\tif (!data) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tfor (j = 0; j < value->block.length; j++) {\n\t\t\t\tdata[j] = READ (buf, ut8);\n\t\t\t}\n\t\t\tvalue->block.data = data;\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_block: // variable length ULEB128\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->block.length);\n\t\tif (!buf || buf >= buf_end) {\n\t\t\treturn NULL;\n\t\t}\n\t\tvalue->block.data = calloc (sizeof (ut8), value->block.length);\n\t\tif (value->block.data) {\n\t\t\tfor (j = 0; j < value->block.length; j++) {\n\t\t\t\tvalue->block.data[j] = READ (buf, ut8);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_flag:\n\t\tvalue->flag = READ (buf, ut8);\n\t\tbreak;\n\t// offset in .debug_str\n\tcase DW_FORM_strp:\n\t\tvalue->string.offset = dwarf_read_piece(hdr->is_64bit, &buf, buf_end);\n\t\tif (debug_str && value->string.offset < debug_str_len) {\n\t\t\tvalue->string.content =\n\t\t\t\tstrdup ((const char *)(debug_str + value->string.offset));\n\t\t} else {\n\t\t\tvalue->string.content = NULL; // Means malformed DWARF, should we print error message?\n\t\t}\n\t\tbreak;\n\t// offset in .debug_info\n\tcase DW_FORM_ref_addr:\n\t\tvalue->reference = dwarf_read_piece(hdr->is_64bit, &buf, buf_end);\n\t\tbreak;\n\t// This type of reference is an offset from the first byte of the compilation\n\t// header for the compilation unit containing the reference\n\tcase DW_FORM_ref1:\n\t\tvalue->reference = hdr->unit_offset + READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref2:\n\t\tvalue->reference = hdr->unit_offset + READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref4:\n\t\tvalue->reference = hdr->unit_offset + READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref8:\n\t\tvalue->reference = hdr->unit_offset + READ64 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref_udata:\n\t\t// uleb128 is enough to fit into ut64?\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->reference);\n\t\tvalue->reference += hdr->unit_offset;\n\t\tbreak;\n\t// offset in a section other than .debug_info or .debug_str\n\tcase DW_FORM_sec_offset:\n\t\tvalue->reference = dwarf_read_piece(hdr->is_64bit, &buf, buf_end);\n\t\tbreak;\n\tcase DW_FORM_exprloc:\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->block.length);\n\t\tif (!buf || buf >= buf_end) {\n\t\t\treturn NULL;\n\t\t}\n\t\tvalue->block.data = calloc (sizeof (ut8), value->block.length);\n\t\tif (!value->block.data) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (value->block.data) {\n\t\t\tfor (j = 0; j < value->block.length; j++) {\n\t\t\t\tvalue->block.data[j] = READ (buf, ut8);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t// this means that the flag is present, nothing is read\n\tcase DW_FORM_flag_present: \n\t\tvalue->flag = true;\n\t\tbreak;\n\tcase DW_FORM_ref_sig8:\n\t\tvalue->reference = READ64 (buf);\n\t\tbreak;\n\t// offset into .debug_line_str section, can't parse the section now, so we just skip\n\tcase DW_FORM_strx:\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->string.offset);\n\t\tbreak;\n\tcase DW_FORM_strx1:\n\t\tvalue->string.offset = READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_strx2:\n\t\tvalue->string.offset = READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_strx3: // TODO Add 3 byte int read\n\t\tbuf += 3;\n\t\tbreak;\n\tcase DW_FORM_strx4:\n\t\tvalue->string.offset = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_implicit_const:\n\t\tvalue->sdata = def->special;\n\t\tbreak;\n\t/*  addrx* forms : The index is relative to the value of the\n\t\tDW_AT_addr_base attribute of the associated compilation unit. \n\t    index into an array of addresses in the .debug_addr section.*/\n\tcase DW_FORM_addrx:\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->address);\n\t\tbreak;\n\tcase DW_FORM_addrx1:\n\t\tvalue->address = READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_addrx2:\n\t\tvalue->address = READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_addrx3:\n\t// I need to add 3byte endianess free read here TODO\n\t\tbuf += 3;\n\t\tbreak;\n\tcase DW_FORM_addrx4:\n\t\tvalue->address = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_line_ptr: // offset in a section .debug_line_str\n\tcase DW_FORM_strp_sup: // offset in a section .debug_line_str\n\t\tvalue->string.offset = dwarf_read_piece(hdr->is_64bit, &buf, buf_end);\n\t\tbreak;\n\t// offset in the supplementary object file\n\tcase DW_FORM_ref_sup4:\n\t\tvalue->reference = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref_sup8:\n\t\tvalue->reference = READ64 (buf);\n\t\tbreak;\n\t// An index into the .debug_loclists\n\tcase DW_FORM_loclistx:\n\t // An index into the .debug_rnglists\n\tcase DW_FORM_rnglistx:\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->address);\n\t\tbreak;\n\tdefault:\n\t\teprintf (\"Unknown DW_FORM 0x%02\" PFMT64x \"\\n\", def->attr_form);\n\t\tvalue->data = 0;\n\t\treturn NULL;\n\t}\n\treturn buf;\n}", "target": 1, "idx": 10988}
{"commit_id": "0558f33c06bb910e2879e355192227a8e8f0219d", "project": "torvalds/linux", "func": "static void sas_resume_port(struct asd_sas_phy *phy)\n{\n\tstruct domain_device *dev;\n\tstruct asd_sas_port *port = phy->port;\n\tstruct sas_ha_struct *sas_ha = phy->ha;\n\tstruct sas_internal *si = to_sas_internal(sas_ha->core.shost->transportt);\n\n\tif (si->dft->lldd_port_formed)\n\t\tsi->dft->lldd_port_formed(phy);\n\n\tif (port->suspended)\n\t\tport->suspended = 0;\n\telse {\n\t\t/* we only need to handle \"link returned\" actions once */\n\t\treturn;\n\t}\n\n\t/* if the port came back:\n\t * 1/ presume every device came back\n\t * 2/ force the next revalidation to check all expander phys\n\t */\n\tlist_for_each_entry(dev, &port->dev_list, dev_list_node) {\n\t\tint i, rc;\n\n\t\trc = sas_notify_lldd_dev_found(dev);\n\t\tif (rc) {\n\t\t\tsas_unregister_dev(port, dev);\n\t\t\tsas_destruct_devices(port);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (dev->dev_type == SAS_EDGE_EXPANDER_DEVICE || dev->dev_type == SAS_FANOUT_EXPANDER_DEVICE) {\n\t\t\tdev->ex_dev.ex_change_count = -1;\n\t\t\tfor (i = 0; i < dev->ex_dev.num_phys; i++) {\n\t\t\t\tstruct ex_phy *phy = &dev->ex_dev.ex_phy[i];\n\n\t\t\t\tphy->phy_change_count = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tsas_discover_event(port, DISCE_RESUME);\n}", "target": 1, "idx": 10989}
{"commit_id": "f35fd27ec641c42d6b115bfa595e483ec58188d2", "project": "libjpeg-turbo", "func": "METHODDEF(void)\nstart_input_ppm(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  int c;\n  unsigned int w, h, maxval;\n  boolean need_iobuffer, use_raw_buffer, need_rescale;\n\n  if (getc(source->pub.input_file) != 'P')\n    ERREXIT(cinfo, JERR_PPM_NOT);\n\n  c = getc(source->pub.input_file); /* subformat discriminator character */\n\n  /* detect unsupported variants (ie, PBM) before trying to read header */\n  switch (c) {\n  case '2':                     /* it's a text-format PGM file */\n  case '3':                     /* it's a text-format PPM file */\n  case '5':                     /* it's a raw-format PGM file */\n  case '6':                     /* it's a raw-format PPM file */\n    break;\n  default:\n    ERREXIT(cinfo, JERR_PPM_NOT);\n    break;\n  }\n\n  /* fetch the remaining header info */\n  w = read_pbm_integer(cinfo, source->pub.input_file, 65535);\n  h = read_pbm_integer(cinfo, source->pub.input_file, 65535);\n  maxval = read_pbm_integer(cinfo, source->pub.input_file, 65535);\n\n  if (w <= 0 || h <= 0 || maxval <= 0) /* error check */\n    ERREXIT(cinfo, JERR_PPM_NOT);\n\n  cinfo->data_precision = BITS_IN_JSAMPLE; /* we always rescale data to this */\n  cinfo->image_width = (JDIMENSION)w;\n  cinfo->image_height = (JDIMENSION)h;\n  source->maxval = maxval;\n\n  /* initialize flags to most common settings */\n  need_iobuffer = TRUE;         /* do we need an I/O buffer? */\n  use_raw_buffer = FALSE;       /* do we map input buffer onto I/O buffer? */\n  need_rescale = TRUE;          /* do we need a rescale array? */\n\n  switch (c) {\n  case '2':                     /* it's a text-format PGM file */\n    if (cinfo->in_color_space == JCS_UNKNOWN)\n      cinfo->in_color_space = JCS_GRAYSCALE;\n    TRACEMS2(cinfo, 1, JTRC_PGM_TEXT, w, h);\n    if (cinfo->in_color_space == JCS_GRAYSCALE)\n      source->pub.get_pixel_rows = get_text_gray_row;\n    else if (IsExtRGB(cinfo->in_color_space))\n      source->pub.get_pixel_rows = get_text_gray_rgb_row;\n    else if (cinfo->in_color_space == JCS_CMYK)\n      source->pub.get_pixel_rows = get_text_gray_cmyk_row;\n    else\n      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    need_iobuffer = FALSE;\n    break;\n\n  case '3':                     /* it's a text-format PPM file */\n    if (cinfo->in_color_space == JCS_UNKNOWN)\n      cinfo->in_color_space = JCS_EXT_RGB;\n    TRACEMS2(cinfo, 1, JTRC_PPM_TEXT, w, h);\n    if (IsExtRGB(cinfo->in_color_space))\n      source->pub.get_pixel_rows = get_text_rgb_row;\n    else if (cinfo->in_color_space == JCS_CMYK)\n      source->pub.get_pixel_rows = get_text_rgb_cmyk_row;\n    else\n      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    need_iobuffer = FALSE;\n    break;\n\n  case '5':                     /* it's a raw-format PGM file */\n    if (cinfo->in_color_space == JCS_UNKNOWN)\n      cinfo->in_color_space = JCS_GRAYSCALE;\n    TRACEMS2(cinfo, 1, JTRC_PGM, w, h);\n    if (maxval > 255) {\n      if (cinfo->in_color_space == JCS_GRAYSCALE)\n        source->pub.get_pixel_rows = get_word_gray_row;\n      else\n        ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    } else if (maxval == MAXJSAMPLE && sizeof(JSAMPLE) == sizeof(U_CHAR) &&\n               cinfo->in_color_space == JCS_GRAYSCALE) {\n      source->pub.get_pixel_rows = get_raw_row;\n      use_raw_buffer = TRUE;\n      need_rescale = FALSE;\n    } else {\n      if (cinfo->in_color_space == JCS_GRAYSCALE)\n        source->pub.get_pixel_rows = get_scaled_gray_row;\n      else if (IsExtRGB(cinfo->in_color_space))\n        source->pub.get_pixel_rows = get_gray_rgb_row;\n      else if (cinfo->in_color_space == JCS_CMYK)\n        source->pub.get_pixel_rows = get_gray_cmyk_row;\n      else\n        ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    }\n    break;\n\n  case '6':                     /* it's a raw-format PPM file */\n    if (cinfo->in_color_space == JCS_UNKNOWN)\n      cinfo->in_color_space = JCS_EXT_RGB;\n    TRACEMS2(cinfo, 1, JTRC_PPM, w, h);\n    if (maxval > 255) {\n      if (IsExtRGB(cinfo->in_color_space))\n        source->pub.get_pixel_rows = get_word_rgb_row;\n      else\n        ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    } else if (maxval == MAXJSAMPLE && sizeof(JSAMPLE) == sizeof(U_CHAR) &&\n#if RGB_RED == 0 && RGB_GREEN == 1 && RGB_BLUE == 2 && RGB_PIXELSIZE == 3\n               (cinfo->in_color_space == JCS_EXT_RGB ||\n                cinfo->in_color_space == JCS_RGB)) {\n#else\n               cinfo->in_color_space == JCS_EXT_RGB) {\n#endif\n      source->pub.get_pixel_rows = get_raw_row;\n      use_raw_buffer = TRUE;\n      need_rescale = FALSE;\n    } else {\n      if (IsExtRGB(cinfo->in_color_space))\n        source->pub.get_pixel_rows = get_rgb_row;\n      else if (cinfo->in_color_space == JCS_CMYK)\n        source->pub.get_pixel_rows = get_rgb_cmyk_row;\n      else\n        ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    }\n    break;\n  }\n\n  if (IsExtRGB(cinfo->in_color_space))\n    cinfo->input_components = rgb_pixelsize[cinfo->in_color_space];\n  else if (cinfo->in_color_space == JCS_GRAYSCALE)\n    cinfo->input_components = 1;\n  else if (cinfo->in_color_space == JCS_CMYK)\n    cinfo->input_components = 4;\n\n  /* Allocate space for I/O buffer: 1 or 3 bytes or words/pixel. */\n  if (need_iobuffer) {\n    if (c == '6')\n      source->buffer_width = (size_t)w * 3 *\n        ((maxval <= 255) ? sizeof(U_CHAR) : (2 * sizeof(U_CHAR)));\n    else\n      source->buffer_width = (size_t)w *\n        ((maxval <= 255) ? sizeof(U_CHAR) : (2 * sizeof(U_CHAR)));\n    source->iobuffer = (U_CHAR *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                  source->buffer_width);\n  }\n\n  /* Create compressor input buffer. */\n  if (use_raw_buffer) {\n    /* For unscaled raw-input case, we can just map it onto the I/O buffer. */\n    /* Synthesize a JSAMPARRAY pointer structure */\n    source->pixrow = (JSAMPROW)source->iobuffer;\n    source->pub.buffer = &source->pixrow;\n    source->pub.buffer_height = 1;\n  } else {\n    /* Need to translate anyway, so make a separate sample buffer. */\n    source->pub.buffer = (*cinfo->mem->alloc_sarray)\n      ((j_common_ptr)cinfo, JPOOL_IMAGE,\n       (JDIMENSION)w * cinfo->input_components, (JDIMENSION)1);\n    source->pub.buffer_height = 1;\n  }\n\n  /* Compute the rescaling array if required. */\n  if (need_rescale) {\n    long val, half_maxval;\n\n    /* On 16-bit-int machines we have to be careful of maxval = 65535 */\n    source->rescale = (JSAMPLE *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                  (size_t)(((long)MAX(maxval, 255) + 1L) *\n                                           sizeof(JSAMPLE)));\n    half_maxval = maxval / 2;\n    for (val = 0; val <= (long)maxval; val++) {\n      /* The multiplication here must be done in 32 bits to avoid overflow */\n      source->rescale[val] = (JSAMPLE)((val * MAXJSAMPLE + half_maxval) /\n                                        maxval);\n    }\n  }\n}", "target": 1, "idx": 10990}
{"commit_id": "d5f95aa066f878b0aef6a64e60b61e8626e664cd", "project": "pjsip/pjproject", "func": "static pj_bool_t ssock_on_accept_complete (pj_ssl_sock_t *ssock_parent,\n\t\t\t\t\t   pj_sock_t newsock,\n\t\t\t\t\t   void *newconn,\n\t\t\t\t\t   const pj_sockaddr_t *src_addr,\n\t\t\t\t\t   int src_addr_len,\n\t\t\t\t\t   pj_status_t accept_status)\n{\n    pj_ssl_sock_t *ssock;\n#ifndef SSL_SOCK_IMP_USE_OWN_NETWORK\n    pj_activesock_cb asock_cb;\n#endif\n    pj_activesock_cfg asock_cfg;\n    unsigned i;\n    pj_status_t status;\n\n#ifndef SSL_SOCK_IMP_USE_OWN_NETWORK\n    PJ_UNUSED_ARG(newconn);\n#endif\n\n    if (accept_status != PJ_SUCCESS) {\n\tif (ssock_parent->param.cb.on_accept_complete2) {\n\t    (*ssock_parent->param.cb.on_accept_complete2)(ssock_parent, NULL,\n\t\t\t\t\t\t    \t  src_addr,\n\t\t\t\t\t\t    \t  src_addr_len,\n\t\t\t\t\t\t    \t  accept_status);\n\t}\n\treturn PJ_TRUE;\n    }\n\n    /* Create new SSL socket instance */\n    status = pj_ssl_sock_create(ssock_parent->pool,\n\t\t\t\t&ssock_parent->newsock_param, &ssock);\n    if (status != PJ_SUCCESS)\n\tgoto on_return;\n\n    /* Set parent and add ref count (avoid parent destroy during handshake) */\n    ssock->parent = ssock_parent;\n    if (ssock->parent->param.grp_lock)\n\tpj_grp_lock_add_ref(ssock->parent->param.grp_lock);\n\n    /* Update new SSL socket attributes */\n    ssock->sock = newsock;\n    ssock->is_server = PJ_TRUE;\n    if (ssock_parent->cert) {\n\tstatus = pj_ssl_sock_set_certificate(ssock, ssock->pool, \n\t\t\t\t\t     ssock_parent->cert);\n\tif (status != PJ_SUCCESS)\n\t    goto on_return;\n    }\n\n    /* Set local address */\n    ssock->addr_len = src_addr_len;\n    pj_sockaddr_cp(&ssock->local_addr, &ssock_parent->local_addr);\n\n    /* Set remote address */\n    pj_sockaddr_cp(&ssock->rem_addr, src_addr);\n\n    /* Create SSL context */\n    status = ssl_create(ssock);\n    if (status != PJ_SUCCESS)\n\tgoto on_return;\n\n    /* Prepare read buffer */\n    ssock->asock_rbuf = (void**)pj_pool_calloc(ssock->pool, \n\t\t\t\t\t       ssock->param.async_cnt,\n\t\t\t\t\t       sizeof(void*));\n    if (!ssock->asock_rbuf) {\n\tstatus = PJ_ENOMEM;\n\tgoto on_return;\n    }\n\n    for (i = 0; i<ssock->param.async_cnt; ++i) {\n\tssock->asock_rbuf[i] = (void*) pj_pool_alloc(\n\t\t\t\t\t    ssock->pool, \n\t\t\t\t\t    ssock->param.read_buffer_size + \n\t\t\t\t\t    sizeof(read_data_t*));\n\tif (!ssock->asock_rbuf[i]) {\n\t    status = PJ_ENOMEM;\n\t    goto on_return;\n\t}\n    }\n\n    /* If listener socket has group lock, automatically create group lock\n     * for the new socket.\n     */\n    if (ssock_parent->param.grp_lock) {\n\tpj_grp_lock_t *glock;\n\n\tstatus = pj_grp_lock_create(ssock->pool, NULL, &glock);\n\tif (status != PJ_SUCCESS)\n\t    goto on_return;\n\n\tpj_grp_lock_add_ref(glock);\n\tssock->param.grp_lock = glock;\n\tpj_grp_lock_add_handler(ssock->param.grp_lock, ssock->pool, ssock,\n\t\t\t\tssl_on_destroy);\n    }\n\n#ifdef SSL_SOCK_IMP_USE_OWN_NETWORK\n    status = network_setup_connection(ssock, newconn);\n    if (status != PJ_SUCCESS)\n\tgoto on_return;\n\n#else\n    /* Apply QoS, if specified */\n    status = pj_sock_apply_qos2(ssock->sock, ssock->param.qos_type,\n\t\t\t\t&ssock->param.qos_params, 1, \n\t\t\t\tssock->pool->obj_name, NULL);\n    if (status != PJ_SUCCESS && !ssock->param.qos_ignore_error)\n\tgoto on_return;\n\n    /* Apply socket options, if specified */\n    if (ssock->param.sockopt_params.cnt) {\n\tstatus = pj_sock_setsockopt_params(ssock->sock, \n\t\t\t\t\t   &ssock->param.sockopt_params);\n\tif (status != PJ_SUCCESS && !ssock->param.sockopt_ignore_error)\n\t    goto on_return;\n    }\n\n    /* Create active socket */\n    pj_activesock_cfg_default(&asock_cfg);\n    asock_cfg.grp_lock = ssock->param.grp_lock;\n    asock_cfg.async_cnt = ssock->param.async_cnt;\n    asock_cfg.concurrency = ssock->param.concurrency;\n    asock_cfg.whole_data = PJ_TRUE;\n\n    pj_bzero(&asock_cb, sizeof(asock_cb));\n    asock_cb.on_data_read = asock_on_data_read;\n    asock_cb.on_data_sent = asock_on_data_sent;\n\n    status = pj_activesock_create(ssock->pool,\n\t\t\t\t  ssock->sock, \n\t\t\t\t  ssock->param.sock_type,\n\t\t\t\t  &asock_cfg,\n\t\t\t\t  ssock->param.ioqueue, \n\t\t\t\t  &asock_cb,\n\t\t\t\t  ssock,\n\t\t\t\t  &ssock->asock);\n\n    if (status != PJ_SUCCESS)\n\tgoto on_return;\n\n    /* Start read */\n    status = pj_activesock_start_read2(ssock->asock, ssock->pool, \n\t\t\t\t       (unsigned)ssock->param.read_buffer_size,\n\t\t\t\t       ssock->asock_rbuf,\n\t\t\t\t       PJ_IOQUEUE_ALWAYS_ASYNC);\n    if (status != PJ_SUCCESS)\n\tgoto on_return;\n#endif\n\n    /* Update local address */\n    status = get_localaddr(ssock, &ssock->local_addr, &ssock->addr_len);\n    if (status != PJ_SUCCESS) {\n\t/* This fails on few envs, e.g: win IOCP, just tolerate this and\n\t * use parent local address instead.\n\t */\n\tpj_sockaddr_cp(&ssock->local_addr, &ssock_parent->local_addr);\n    }\n\n    /* Prepare write/send state */\n    pj_assert(ssock->send_buf.max_len == 0);\n    ssock->send_buf.buf = (char*)\n\t\t\t  pj_pool_alloc(ssock->pool, \n\t\t\t\t\tssock->param.send_buffer_size);\n    if (!ssock->send_buf.buf)\n        return PJ_ENOMEM;\n\n    ssock->send_buf.max_len = ssock->param.send_buffer_size;\n    ssock->send_buf.start = ssock->send_buf.buf;\n    ssock->send_buf.len = 0;\n\n    /* Start handshake timer */\n    if (ssock->param.timer_heap && (ssock->param.timeout.sec != 0 ||\n\tssock->param.timeout.msec != 0))\n    {\n\tpj_assert(ssock->timer.id == TIMER_NONE);\n\tstatus = pj_timer_heap_schedule_w_grp_lock(ssock->param.timer_heap, \n\t\t\t\t\t\t   &ssock->timer,\n\t\t\t\t\t\t   &ssock->param.timeout,\n\t\t\t\t\t\t   TIMER_HANDSHAKE_TIMEOUT,\n\t\t\t\t\t\t   ssock->param.grp_lock);\n\tif (status != PJ_SUCCESS) {\n\t    ssock->timer.id = TIMER_NONE;\n\t    status = PJ_SUCCESS;\n\t}\n    }\n\n    /* Start SSL handshake */\n    ssock->ssl_state = SSL_STATE_HANDSHAKING;\n    ssl_set_state(ssock, PJ_TRUE);\n    status = ssl_do_handshake(ssock);\n\non_return:\n    if (ssock && status != PJ_EPENDING) {\n\ton_handshake_complete(ssock, status);\n    }\n\n    /* Must return PJ_TRUE whatever happened, as we must continue listening */\n    return PJ_TRUE;\n}", "target": 1, "idx": 10991}
{"commit_id": "f2d3be2a8741234faaa96f5fd05fdfdc75779a79", "project": "rpm-software-management/rpm", "func": "static int fsmVerify(const char *path, rpmfi fi, const struct stat *fsb)\n{\n    int rc;\n    int saveerrno = errno;\n    struct stat dsb;\n    mode_t mode = rpmfiFMode(fi);\n\n    rc = fsmStat(path, 1, &dsb);\n    if (rc)\n\treturn rc;\n\n    if (S_ISREG(mode)) {\n\t/* HP-UX (and other os'es) don't permit unlink on busy files. */\n\tchar *rmpath = rstrscat(NULL, path, \"-RPMDELETE\", NULL);\n\trc = fsmRename(path, rmpath);\n\t/* XXX shouldn't we take unlink return code here? */\n\tif (!rc)\n\t    (void) fsmUnlink(rmpath);\n\telse\n\t    rc = RPMERR_UNLINK_FAILED;\n\tfree(rmpath);\n        return (rc ? rc : RPMERR_ENOENT);\t/* XXX HACK */\n    } else if (S_ISDIR(mode)) {\n        if (S_ISDIR(dsb.st_mode)) return 0;\n        if (S_ISLNK(dsb.st_mode)) {\n\t    uid_t luid = dsb.st_uid;\n            rc = fsmStat(path, 0, &dsb);\n            if (rc == RPMERR_ENOENT) rc = 0;\n            if (rc) return rc;\n            errno = saveerrno;\n\t    /* Only permit directory symlinks by target owner and root */\n            if (S_ISDIR(dsb.st_mode) && (luid == 0 || luid == fsb->st_uid))\n\t\t    return 0;\n        }\n    } else if (S_ISLNK(mode)) {\n        if (S_ISLNK(dsb.st_mode)) {\n            char buf[8 * BUFSIZ];\n            size_t len;\n            rc = fsmReadLink(path, buf, 8 * BUFSIZ, &len);\n            errno = saveerrno;\n            if (rc) return rc;\n            if (rstreq(rpmfiFLink(fi), buf)) return 0;\n        }\n    } else if (S_ISFIFO(mode)) {\n        if (S_ISFIFO(dsb.st_mode)) return 0;\n    } else if (S_ISCHR(mode) || S_ISBLK(mode)) {\n        if ((S_ISCHR(dsb.st_mode) || S_ISBLK(dsb.st_mode)) &&\n            (dsb.st_rdev == rpmfiFRdev(fi))) return 0;\n    } else if (S_ISSOCK(mode)) {\n        if (S_ISSOCK(dsb.st_mode)) return 0;\n    }\n    /* XXX shouldn't do this with commit/undo. */\n    rc = fsmUnlink(path);\n    if (rc == 0)\trc = RPMERR_ENOENT;\n    return (rc ? rc : RPMERR_ENOENT);\t/* XXX HACK */\n}", "target": 2, "idx": 10992}
{"commit_id": "a4892df306e0532487f1634ba6d4c6d4bb381c7f", "project": "jpirko/libndp", "func": "static int ndp_sock_open(struct ndp *ndp)\n{\n\tint sock;\n\t//struct icmp6_filter flt;\n\tint ret;\n\tint err;\n\tint val;\n\n\tsock = socket(PF_INET6, SOCK_RAW, IPPROTO_ICMPV6);\n\tif (sock == -1) {\n\t\terr(ndp, \"Failed to create ICMP6 socket.\");\n\t\treturn -errno;\n\t}\n\n\tval = 1;\n\tret = setsockopt(sock, IPPROTO_IPV6, IPV6_RECVPKTINFO,\n\t\t\t &val, sizeof(val));\n\tif (ret == -1) {\n\t\terr(ndp, \"Failed to setsockopt IPV6_RECVPKTINFO.\");\n\t\terr = -errno;\n\t\tgoto close_sock;\n\t}\n\n\tval = 255;\n\tret = setsockopt(sock, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,\n\t\t\t &val, sizeof(val));\n\tif (ret == -1) {\n\t\terr(ndp, \"Failed to setsockopt IPV6_MULTICAST_HOPS.\");\n\t\terr = -errno;\n\t\tgoto close_sock;\n\t}\n\n\tval = 1;\n\tret = setsockopt(sock, IPPROTO_IPV6, IPV6_RECVHOPLIMIT,\n\t\t\t &val, sizeof(val));\n\tif (ret == -1) {\n\t\terr(ndp, \"Failed to setsockopt IPV6_RECVHOPLIMIT,.\");\n\t\terr = -errno;\n\t\tgoto close_sock;\n\t}\n\n\tndp->sock = sock;\n\treturn 0;\nclose_sock:\n\tclose(sock);\n\treturn err;\n}", "target": 2, "idx": 10993}
{"commit_id": "6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d", "project": "dbry/WavPack", "func": "int ParseRiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)\n{\n    int is_rf64 = !strncmp (fourcc, \"RF64\", 4), got_ds64 = 0;\n    int64_t total_samples = 0, infilesize;\n    RiffChunkHeader riff_chunk_header;\n    ChunkHeader chunk_header;\n    WaveHeader WaveHeader;\n    DS64Chunk ds64_chunk;\n    uint32_t bcount;\n\n    CLEAR (WaveHeader);\n    CLEAR (ds64_chunk);\n    infilesize = DoGetFileSize (infile);\n\n    if (!is_rf64 && infilesize >= 4294967296LL && !(config->qmode & QMODE_IGNORE_LENGTH)) {\n        error_line (\"can't handle .WAV files larger than 4 GB (non-standard)!\");\n        return WAVPACK_SOFT_ERROR;\n    }\n\n    memcpy (&riff_chunk_header, fourcc, 4);\n\n    if ((!DoReadFile (infile, ((char *) &riff_chunk_header) + 4, sizeof (RiffChunkHeader) - 4, &bcount) ||\n        bcount != sizeof (RiffChunkHeader) - 4 || strncmp (riff_chunk_header.formType, \"WAVE\", 4))) {\n            error_line (\"%s is not a valid .WAV file!\", infilename);\n            return WAVPACK_SOFT_ERROR;\n    }\n    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n        !WavpackAddWrapper (wpc, &riff_chunk_header, sizeof (RiffChunkHeader))) {\n            error_line (\"%s\", WavpackGetErrorMessage (wpc));\n            return WAVPACK_SOFT_ERROR;\n    }\n\n    // loop through all elements of the RIFF wav header\n    // (until the data chuck) and copy them to the output file\n\n    while (1) {\n        if (!DoReadFile (infile, &chunk_header, sizeof (ChunkHeader), &bcount) ||\n            bcount != sizeof (ChunkHeader)) {\n                error_line (\"%s is not a valid .WAV file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n        }\n        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n            !WavpackAddWrapper (wpc, &chunk_header, sizeof (ChunkHeader))) {\n                error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                return WAVPACK_SOFT_ERROR;\n        }\n\n        WavpackLittleEndianToNative (&chunk_header, ChunkHeaderFormat);\n\n        if (!strncmp (chunk_header.ckID, \"ds64\", 4)) {\n            if (chunk_header.ckSize < sizeof (DS64Chunk) ||\n                !DoReadFile (infile, &ds64_chunk, sizeof (DS64Chunk), &bcount) ||\n                bcount != sizeof (DS64Chunk)) {\n                    error_line (\"%s is not a valid .WAV file!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, &ds64_chunk, sizeof (DS64Chunk))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            got_ds64 = 1;\n            WavpackLittleEndianToNative (&ds64_chunk, DS64ChunkFormat);\n\n            if (debug_logging_mode)\n                error_line (\"DS64: riffSize = %lld, dataSize = %lld, sampleCount = %lld, table_length = %d\",\n                    (long long) ds64_chunk.riffSize64, (long long) ds64_chunk.dataSize64,\n                    (long long) ds64_chunk.sampleCount64, ds64_chunk.tableLength);\n\n            if (ds64_chunk.tableLength * sizeof (CS64Chunk) != chunk_header.ckSize - sizeof (DS64Chunk)) {\n                error_line (\"%s is not a valid .WAV file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            while (ds64_chunk.tableLength--) {\n                CS64Chunk cs64_chunk;\n                if (!DoReadFile (infile, &cs64_chunk, sizeof (CS64Chunk), &bcount) ||\n                    bcount != sizeof (CS64Chunk) ||\n                    (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                    !WavpackAddWrapper (wpc, &cs64_chunk, sizeof (CS64Chunk)))) {\n                        error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                        return WAVPACK_SOFT_ERROR;\n                }\n            }\n        }\n        else if (!strncmp (chunk_header.ckID, \"fmt \", 4)) {     // if it's the format chunk, we want to get some info out of there and\n            int supported = TRUE, format;                        // make sure it's a .wav file we can handle\n\n            if (chunk_header.ckSize < 16 || chunk_header.ckSize > sizeof (WaveHeader) ||\n                !DoReadFile (infile, &WaveHeader, chunk_header.ckSize, &bcount) ||\n                bcount != chunk_header.ckSize) {\n                    error_line (\"%s is not a valid .WAV file!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, &WaveHeader, chunk_header.ckSize)) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            WavpackLittleEndianToNative (&WaveHeader, WaveHeaderFormat);\n\n            if (debug_logging_mode) {\n                error_line (\"format tag size = %d\", chunk_header.ckSize);\n                error_line (\"FormatTag = %x, NumChannels = %d, BitsPerSample = %d\",\n                    WaveHeader.FormatTag, WaveHeader.NumChannels, WaveHeader.BitsPerSample);\n                error_line (\"BlockAlign = %d, SampleRate = %d, BytesPerSecond = %d\",\n                    WaveHeader.BlockAlign, WaveHeader.SampleRate, WaveHeader.BytesPerSecond);\n\n                if (chunk_header.ckSize > 16)\n                    error_line (\"cbSize = %d, ValidBitsPerSample = %d\", WaveHeader.cbSize,\n                        WaveHeader.ValidBitsPerSample);\n\n                if (chunk_header.ckSize > 20)\n                    error_line (\"ChannelMask = %x, SubFormat = %d\",\n                        WaveHeader.ChannelMask, WaveHeader.SubFormat);\n            }\n\n            if (chunk_header.ckSize > 16 && WaveHeader.cbSize == 2)\n                config->qmode |= QMODE_ADOBE_MODE;\n\n            format = (WaveHeader.FormatTag == 0xfffe && chunk_header.ckSize == 40) ?\n                WaveHeader.SubFormat : WaveHeader.FormatTag;\n\n            config->bits_per_sample = (chunk_header.ckSize == 40 && WaveHeader.ValidBitsPerSample) ?\n                WaveHeader.ValidBitsPerSample : WaveHeader.BitsPerSample;\n\n            if (format != 1 && format != 3)\n                supported = FALSE;\n\n            if (format == 3 && config->bits_per_sample != 32)\n                supported = FALSE;\n\n            if (!WaveHeader.NumChannels || WaveHeader.NumChannels > 256 ||\n                WaveHeader.BlockAlign / WaveHeader.NumChannels < (config->bits_per_sample + 7) / 8 ||\n                WaveHeader.BlockAlign / WaveHeader.NumChannels > 4 ||\n                WaveHeader.BlockAlign % WaveHeader.NumChannels)\n                    supported = FALSE;\n\n            if (config->bits_per_sample < 1 || config->bits_per_sample > 32)\n                supported = FALSE;\n\n            if (!supported) {\n                error_line (\"%s is an unsupported .WAV format!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            if (chunk_header.ckSize < 40) {\n                if (!config->channel_mask && !(config->qmode & QMODE_CHANS_UNASSIGNED)) {\n                    if (WaveHeader.NumChannels <= 2)\n                        config->channel_mask = 0x5 - WaveHeader.NumChannels;\n                    else if (WaveHeader.NumChannels <= 18)\n                        config->channel_mask = (1 << WaveHeader.NumChannels) - 1;\n                    else\n                        config->channel_mask = 0x3ffff;\n                }\n            }\n            else if (WaveHeader.ChannelMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {\n                error_line (\"this WAV file already has channel order information!\");\n                return WAVPACK_SOFT_ERROR;\n            }\n            else if (WaveHeader.ChannelMask)\n                config->channel_mask = WaveHeader.ChannelMask;\n\n            if (format == 3)\n                config->float_norm_exp = 127;\n            else if ((config->qmode & QMODE_ADOBE_MODE) &&\n                WaveHeader.BlockAlign / WaveHeader.NumChannels == 4) {\n                    if (WaveHeader.BitsPerSample == 24)\n                        config->float_norm_exp = 127 + 23;\n                    else if (WaveHeader.BitsPerSample == 32)\n                        config->float_norm_exp = 127 + 15;\n            }\n\n            if (debug_logging_mode) {\n                if (config->float_norm_exp == 127)\n                    error_line (\"data format: normalized 32-bit floating point\");\n                else if (config->float_norm_exp)\n                    error_line (\"data format: 32-bit floating point (Audition %d:%d float type 1)\",\n                        config->float_norm_exp - 126, 150 - config->float_norm_exp);\n                else\n                    error_line (\"data format: %d-bit integers stored in %d byte(s)\",\n                        config->bits_per_sample, WaveHeader.BlockAlign / WaveHeader.NumChannels);\n            }\n        }\n        else if (!strncmp (chunk_header.ckID, \"data\", 4)) {             // on the data chunk, get size and exit loop\n\n            int64_t data_chunk_size = (got_ds64 && chunk_header.ckSize == (uint32_t) -1) ?\n                ds64_chunk.dataSize64 : chunk_header.ckSize;\n\n\n            if (!WaveHeader.NumChannels || (is_rf64 && !got_ds64)) {   // make sure we saw \"fmt\" and \"ds64\" chunks (if required)\n                error_line (\"%s is not a valid .WAV file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) && infilesize - data_chunk_size > 16777216) {\n                error_line (\"this .WAV file has over 16 MB of extra RIFF data, probably is corrupt!\");\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            if (config->qmode & QMODE_IGNORE_LENGTH) {\n                if (infilesize && DoGetFilePosition (infile) != -1)\n                    total_samples = (infilesize - DoGetFilePosition (infile)) / WaveHeader.BlockAlign;\n                else\n                    total_samples = -1;\n            }\n            else {\n                total_samples = data_chunk_size / WaveHeader.BlockAlign;\n\n                if (got_ds64 && total_samples != ds64_chunk.sampleCount64) {\n                    error_line (\"%s is not a valid .WAV file!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                if (!total_samples) {\n                    error_line (\"this .WAV file has no audio samples, probably is corrupt!\");\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                if (total_samples > MAX_WAVPACK_SAMPLES) {\n                    error_line (\"%s has too many samples for WavPack!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n                }\n            }\n\n            config->bytes_per_sample = WaveHeader.BlockAlign / WaveHeader.NumChannels;\n            config->num_channels = WaveHeader.NumChannels;\n            config->sample_rate = WaveHeader.SampleRate;\n            break;\n        }\n        else {          // just copy unknown chunks to output file\n\n            int bytes_to_copy = (chunk_header.ckSize + 1) & ~1L;\n            char *buff;\n\n            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {\n                error_line (\"%s is not a valid .WAV file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            buff = malloc (bytes_to_copy);\n\n            if (debug_logging_mode)\n                error_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\",\n                    chunk_header.ckID [0], chunk_header.ckID [1], chunk_header.ckID [2],\n                    chunk_header.ckID [3], chunk_header.ckSize);\n\n            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||\n                bcount != bytes_to_copy ||\n                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    free (buff);\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            free (buff);\n        }\n    }\n\n    if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {\n        error_line (\"%s: %s\", infilename, WavpackGetErrorMessage (wpc));\n        return WAVPACK_SOFT_ERROR;\n    }\n\n    return WAVPACK_NO_ERROR;\n}", "target": 1, "idx": 10994}
{"commit_id": "e2745d741ec11f395d41c0aafa24df9dec136399", "project": "wireshark", "func": "static void\nieee_80211_add_tagged_parameters (tvbuff_t *tvb, int offset, packet_info *pinfo,\n                                  proto_tree *tree, int tagged_parameters_len, int ftype)\n{\n  int next_len;\n  beacon_padding = 0; /* this is for the beacon padding confused with ssid fix */\n  while (tagged_parameters_len > 0) {\n    /* TODO make callers optionally specify the list of valid IE IDs? */\n    if ((next_len=add_tagged_field (pinfo, tree, tvb, offset, ftype, NULL, 0)) == 0)\n      break;\n    if (next_len > tagged_parameters_len) {\n      /* XXX - flag this as an error? */\n      next_len = tagged_parameters_len;\n    }\n    offset                += next_len;\n    tagged_parameters_len -= next_len;\n  }\n}", "target": 1, "idx": 10995}
{"commit_id": "112767e8b178fc82dec3cf82a1ca14d802cdb8ec", "project": "gpac", "func": "GF_Err gf_bt_loader_run_intern(GF_BTParser *parser, GF_Command *init_com, Bool initial_run)\n{\n\tchar *str;\n\tGF_Node *node, *vrml_root_node;\n\tBool force_new_com;\n\tGF_Route *r;\n\tBool has_id;\n\tchar szDEFName[1000];\n\n\tvrml_root_node = NULL;\n\thas_id = 0;\n\n\tif (init_com)\n\t\tparser->in_com = 0 ;\n\n\tparser->cur_com = init_com;\n\n\tforce_new_com = (parser->load->flags & GF_SM_LOAD_CONTEXT_READY) ? 1 : 0;\n\n\n\t/*create a default root node for all VRML nodes*/\n\tif (parser->is_wrl && !parser->top_nodes) {\n\t\tif (initial_run ) {\n#ifndef GPAC_DISABLE_X3D\n\t\t\tvrml_root_node = gf_node_new(parser->load->scene_graph, (parser->load->flags & GF_SM_LOAD_MPEG4_STRICT) ? TAG_MPEG4_Group : TAG_X3D_Group);\n#else\n\t\t\tvrml_root_node = gf_node_new(parser->load->scene_graph, TAG_MPEG4_Group);\n#endif\n\t\t\tgf_node_register(vrml_root_node, NULL);\n\t\t\tgf_node_init(vrml_root_node);\n\t\t\tgf_sg_set_root_node(parser->load->scene_graph, vrml_root_node);\n\t\t} else {\n\t\t\tvrml_root_node = gf_sg_get_root_node(parser->load->scene_graph);\n\t\t}\n\t}\n\n\tif (!parser->in_com)\n\t\tparser->stream_id = parser->load->force_es_id;\n\n\t/*parse all top-level items*/\n\twhile (!parser->last_error) {\n\t\tstr = gf_bt_get_next(parser, 0);\n\t\tif (parser->done) break;\n\n\t\tif (!strcmp(str, \"\")) {\n\t\t\t//empty string, force moving to next char\n\t\t\tif (parser->line_pos<parser->line_size) parser->line_pos++;\n\t\t}\n\t\t/*X3D specific things (ignored for now)*/\n\t\telse if (!strcmp(str, \"PROFILE\")) gf_bt_force_line(parser);\n\t\telse if (!strcmp(str, \"COMPONENT\")) gf_bt_force_line(parser);\n\t\telse if (!strcmp(str, \"META\")) gf_bt_force_line(parser);\n\t\telse if (!strcmp(str, \"IMPORT\") || !strcmp(str, \"EXPORT\")) {\n\t\t\tgf_bt_report(parser, GF_NOT_SUPPORTED, \"X3D IMPORT/EXPORT not implemented\");\n\t\t\tbreak;\n\t\t}\n\n\t\t/*IOD*/\n\t\telse if (!strcmp(str, \"InitialObjectDescriptor\") || !strcmp(str, \"ObjectDescriptor\")) {\n\t\t\tparser->load->ctx->root_od = (GF_ObjectDescriptor *) gf_bt_parse_descriptor(parser, str);\n\t\t}\n\t\t/*explicit command*/\n\t\telse if (!strcmp(str, \"AT\") || !strcmp(str, \"RAP\")) {\n\t\t\tparser->au_is_rap = 0;\n\t\t\tif (!strcmp(str, \"RAP\")) {\n\t\t\t\tparser->au_is_rap = 1;\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tif (strcmp(str, \"AT\")) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"AT expected got %s\", str);\n\t\t\t\t\tparser->last_error = GF_BAD_PARAM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tforce_new_com = 0;\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tif (str[0] == 'D') {\n\t\t\t\tparser->au_time += atoi(&str[1]);\n\t\t\t} else {\n\t\t\t\tif (sscanf(str, \"%u\", &parser->au_time) != 1) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"Number expected got %s\", str);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (parser->last_error) break;\n\t\t\t/*reset all contexts*/\n\t\t\tif (parser->od_au && (parser->od_au->timing != parser->au_time)) parser->od_au = NULL;\n\t\t\tif (parser->bifs_au && (parser->bifs_au->timing != parser->au_time)) {\n\t\t\t\tgf_bt_check_unresolved_nodes(parser);\n\t\t\t\tparser->bifs_au = NULL;\n\t\t\t}\n\n\t\t\tparser->stream_id = 0;\n\t\t\t/*fix for mp4tool bt which doesn't support RAP signaling: assume the first AU\n\t\t\tis always RAP*/\n\t\t\tif (!parser->au_time) parser->au_is_rap = 1;\n\n\t\t\tparser->in_com = 1;\n\n\t\t\tif (!gf_bt_check_code(parser, '{')) {\n\t\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\t\tif (!strcmp(str, \"IN\")) {\n\t\t\t\t\tgf_bt_parse_int(parser, \"IN\", (SFInt32*)&parser->stream_id);\n\t\t\t\t\tif (parser->last_error) break;\n\t\t\t\t}\n\t\t\t\tif (!gf_bt_check_code(parser, '{')) {\n\t\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"{ expected\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*done loading init frame*/\n\t\t\tif (init_com && parser->au_time) break;\n\t\t}\n\t\telse if (!strcmp(str, \"PROTO\") || !strcmp(str, \"EXTERNPROTO\")) {\n\t\t\tgf_bt_parse_proto(parser, str, init_com ? init_com->new_proto_list : NULL);\n\t\t}\n\t\t/*compatibility for old bt (mp4tool) in ProtoLibs*/\n\t\telse if (!strcmp(str, \"NULL\")) {\n\t\t}\n\t\telse if (!strcmp(str, \"DEF\")) {\n\t\t\tstr = gf_bt_get_next(parser, 0);\n\t\t\tstrcpy(szDEFName, str);\n\t\t\thas_id = 1;\n\t\t}\n\t\telse if (!strcmp(str, \"ROUTE\")) {\n\t\t\tGF_Command *com = NULL;\n\t\t\tif (!parser->top_nodes && parser->bifs_au && !parser->is_wrl) {\n\t\t\t\t/*if doing a scene replace, we need route insert stuff*/\n\t\t\t\tcom = gf_sg_command_new(parser->load->scene_graph, GF_SG_ROUTE_INSERT);\n\t\t\t\tgf_list_add(parser->bifs_au->commands, com);\n\t\t\t\tgf_list_add(parser->inserted_routes, com);\n\t\t\t}\n\n\t\t\tr = gf_bt_parse_route(parser, 1, 0, com);\n\t\t\tif (has_id) {\n\t\t\t\tu32 rID = gf_bt_get_route(parser, szDEFName);\n\t\t\t\tif (!rID) rID = gf_bt_get_next_route_id(parser);\n\t\t\t\tif (com) {\n\t\t\t\t\tcom->RouteID = rID;\n\t\t\t\t\tcom->def_name = gf_strdup(szDEFName);\n\t\t\t\t\tgf_sg_set_max_defined_route_id(parser->load->scene_graph, rID);\n\t\t\t\t} else if (r) {\n\t\t\t\t\tgf_sg_route_set_id(r, rID);\n\t\t\t\t\tgf_sg_route_set_name(r, szDEFName);\n\t\t\t\t}\n\t\t\t\thas_id = 0;\n\t\t\t}\n\t\t}\n\t\t/*OD commands*/\n\t\telse if (!strcmp(str, \"UPDATE\") || !strcmp(str, \"REMOVE\")) {\n\t\t\tBool is_base_stream = parser->stream_id ? 0 : 1;\n\t\t\tif (!parser->stream_id || parser->stream_id==parser->bifs_es->ESID) parser->stream_id = parser->base_od_id;\n\n\t\t\tif (parser->od_es && (parser->od_es->ESID != parser->stream_id)) {\n\t\t\t\tGF_StreamContext *prev = parser->od_es;\n\t\t\t\tparser->od_es = gf_sm_stream_new(parser->load->ctx, (u16) parser->stream_id, GF_STREAM_OD, GF_CODECID_OD_V1);\n\t\t\t\t/*force new AU if stream changed*/\n\t\t\t\tif (parser->od_es != prev) {\n\t\t\t\t\tparser->bifs_au = NULL;\n\t\t\t\t\tparser->od_au = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!parser->od_es) parser->od_es = gf_sm_stream_new(parser->load->ctx, (u16) parser->stream_id, GF_STREAM_OD, GF_CODECID_OD_V1);\n\t\t\tif (!parser->od_au) parser->od_au = gf_sm_stream_au_new(parser->od_es, parser->au_time, 0, parser->au_is_rap);\n\t\t\tgf_bt_parse_od_command(parser, str);\n\t\t\tif (is_base_stream) parser->stream_id= 0;\n\t\t}\n\t\t/*BIFS commands*/\n\t\telse if (!strcmp(str, \"REPLACE\") || !strcmp(str, \"INSERT\") || !strcmp(str, \"APPEND\") || !strcmp(str, \"DELETE\")\n\t\t         /*BIFS extended commands*/\n\t\t         || !strcmp(str, \"GLOBALQP\") || !strcmp(str, \"MULTIPLEREPLACE\") || !strcmp(str, \"MULTIPLEINDREPLACE\") || !strcmp(str, \"XDELETE\") || !strcmp(str, \"DELETEPROTO\") || !strcmp(str, \"INSERTPROTO\")\n\t\t         || !strcmp(str, \"XREPLACE\")\n\t\t        ) {\n\t\t\tBool is_base_stream = parser->stream_id ? 0 : 1;\n\n\t\t\tif (!parser->stream_id) parser->stream_id = parser->base_bifs_id;\n\t\t\tif (!parser->stream_id || (parser->od_es && (parser->stream_id==parser->od_es->ESID)) ) parser->stream_id = parser->base_bifs_id;\n\n\t\t\tif (parser->bifs_es->ESID != parser->stream_id) {\n\t\t\t\tGF_StreamContext *prev = parser->bifs_es;\n\t\t\t\tparser->bifs_es = gf_sm_stream_new(parser->load->ctx, (u16) parser->stream_id, GF_STREAM_SCENE, GF_CODECID_BIFS);\n\t\t\t\t/*force new AU if stream changed*/\n\t\t\t\tif (parser->bifs_es != prev) {\n\t\t\t\t\tgf_bt_check_unresolved_nodes(parser);\n\t\t\t\t\tparser->bifs_au = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (force_new_com) {\n\t\t\t\tforce_new_com = 0;\n\t\t\t\tparser->bifs_au = gf_list_last(parser->bifs_es->AUs);\n\t\t\t\tparser->au_time = (u32) (parser->bifs_au ? parser->bifs_au->timing : 0) + 1;\n\t\t\t\tparser->bifs_au = NULL;\n\t\t\t}\n\n\t\t\tif (!parser->bifs_au) parser->bifs_au = gf_sm_stream_au_new(parser->bifs_es, parser->au_time, 0, parser->au_is_rap);\n\t\t\tgf_bt_parse_bifs_command(parser, str, parser->bifs_au->commands);\n\t\t\tif (is_base_stream) parser->stream_id= 0;\n\t\t}\n\t\t/*implicit BIFS command on SFTopNodes only*/\n\t\telse if (!strcmp(str, \"OrderedGroup\")\n\t\t         || !strcmp(str, \"Group\")\n\t\t         || !strcmp(str, \"Layer2D\")\n\t\t         || !strcmp(str, \"Layer3D\")\n\t\t         /* VRML parsing: all nodes are allowed*/\n\t\t         || parser->is_wrl\n\t\t        )\n\t\t{\n\n\t\t\tnode = gf_bt_sf_node(parser, str, vrml_root_node, has_id ? szDEFName : NULL);\n\t\t\thas_id = 0;\n\t\t\tif (!node) break;\n\t\t\tif (parser->top_nodes) {\n\t\t\t\tgf_list_add(parser->top_nodes, node);\n\t\t\t} else if (!vrml_root_node) {\n\t\t\t\tif (init_com) init_com->node = node;\n\t\t\t\telse if (parser->load->flags & GF_SM_LOAD_CONTEXT_READY) {\n\t\t\t\t\tGF_Command *com = gf_sg_command_new(parser->load->scene_graph, GF_SG_SCENE_REPLACE);\n\t\t\t\t\tassert(!parser->bifs_au);\n\t\t\t\t\tassert(parser->bifs_es);\n\t\t\t\t\tparser->bifs_au = gf_sm_stream_au_new(parser->bifs_es, 0, 0, 1);\n\t\t\t\t\tgf_list_add(parser->bifs_au->commands, com);\n\t\t\t\t\tcom->node = node;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgf_node_insert_child(vrml_root_node, node, -1);\n\t\t\t}\n\n\t\t\t/*\n\t\t\tif (!gf_sg_get_root_node(parser->load->scene_graph)) {\n\t\t\t\tgf_node_register(node, NULL);\n\t\t\t\tgf_sg_set_root_node(parser->load->scene_graph, node);\n\t\t\t}\n\t\t\t*/\n\t\t}\n\n\t\t/*if in command, check command end*/\n\t\telse {\n\t\t\t/*check command end*/\n\t\t\tif (/*in_com && */gf_bt_check_code(parser, '}')) parser->in_com = 0;\n\t\t\telse if (strlen(str)) {\n\t\t\t\tgf_bt_report(parser, GF_BAD_PARAM, \"%s: Unknown top-level element\", str);\n\t\t\t}\n\t\t\tparser->au_is_rap = 0;\n\t\t}\n\t}\n\tgf_bt_resolve_routes(parser, 0);\n\tgf_bt_check_unresolved_nodes(parser);\n\n\t/*load scripts*/\n\twhile (gf_list_count(parser->scripts)) {\n\t\tGF_Node *n = (GF_Node *)gf_list_get(parser->scripts, 0);\n\t\tgf_list_rem(parser->scripts, 0);\n\t\tgf_sg_script_load(n);\n\t}\n\treturn parser->last_error;\n}", "target": 1, "idx": 10996}
{"commit_id": "4dca6ea1d9432052afb06baf2e3ae78188a4410b", "project": "torvalds/linux", "func": "static struct key *construct_key_and_link(struct keyring_search_context *ctx,\n\t\t\t\t\t  const char *callout_info,\n\t\t\t\t\t  size_t callout_len,\n\t\t\t\t\t  void *aux,\n\t\t\t\t\t  struct key *dest_keyring,\n\t\t\t\t\t  unsigned long flags)\n{\n\tstruct key_user *user;\n\tstruct key *key;\n\tint ret;\n\n\tkenter(\"\");\n\n\tif (ctx->index_key.type == &key_type_keyring)\n\t\treturn ERR_PTR(-EPERM);\n\n\tret = construct_get_dest_keyring(&dest_keyring);\n\tif (ret)\n\t\tgoto error;\n\n\tuser = key_user_lookup(current_fsuid());\n\tif (!user) {\n\t\tret = -ENOMEM;\n\t\tgoto error_put_dest_keyring;\n\t}\n\n\tret = construct_alloc_key(ctx, dest_keyring, flags, user, &key);\n\tkey_user_put(user);\n\n\tif (ret == 0) {\n\t\tret = construct_key(key, callout_info, callout_len, aux,\n\t\t\t\t    dest_keyring);\n\t\tif (ret < 0) {\n\t\t\tkdebug(\"cons failed\");\n\t\t\tgoto construction_failed;\n\t\t}\n\t} else if (ret == -EINPROGRESS) {\n\t\tret = 0;\n\t} else {\n\t\tgoto error_put_dest_keyring;\n\t}\n\n\tkey_put(dest_keyring);\n\tkleave(\" = key %d\", key_serial(key));\n\treturn key;\n\nconstruction_failed:\n\tkey_negate_and_link(key, key_negative_timeout, NULL, NULL);\n\tkey_put(key);\nerror_put_dest_keyring:\n\tkey_put(dest_keyring);\nerror:\n\tkleave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}", "target": 0, "idx": 10997}
{"commit_id": "6b8b42585886c59a008015083282aae434349094", "project": "torvalds/linux", "func": "static int dr_domain_init_resources(struct mlx5dr_domain *dmn)\n{\n\tint ret;\n\n\tdmn->ste_ctx = mlx5dr_ste_get_ctx(dmn->info.caps.sw_format_ver);\n\tif (!dmn->ste_ctx) {\n\t\tmlx5dr_err(dmn, \"SW Steering on this device is unsupported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tret = mlx5_core_alloc_pd(dmn->mdev, &dmn->pdn);\n\tif (ret) {\n\t\tmlx5dr_err(dmn, \"Couldn't allocate PD, ret: %d\", ret);\n\t\treturn ret;\n\t}\n\n\tdmn->uar = mlx5_get_uars_page(dmn->mdev);\n\tif (IS_ERR(dmn->uar)) {\n\t\tmlx5dr_err(dmn, \"Couldn't allocate UAR\\n\");\n\t\tret = PTR_ERR(dmn->uar);\n\t\tgoto clean_pd;\n\t}\n\n\tdmn->ste_icm_pool = mlx5dr_icm_pool_create(dmn, DR_ICM_TYPE_STE);\n\tif (!dmn->ste_icm_pool) {\n\t\tmlx5dr_err(dmn, \"Couldn't get icm memory\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto clean_uar;\n\t}\n\n\tdmn->action_icm_pool = mlx5dr_icm_pool_create(dmn, DR_ICM_TYPE_MODIFY_ACTION);\n\tif (!dmn->action_icm_pool) {\n\t\tmlx5dr_err(dmn, \"Couldn't get action icm memory\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto free_ste_icm_pool;\n\t}\n\n\tret = mlx5dr_send_ring_alloc(dmn);\n\tif (ret) {\n\t\tmlx5dr_err(dmn, \"Couldn't create send-ring\\n\");\n\t\tgoto free_action_icm_pool;\n\t}\n\n\treturn 0;\n\nfree_action_icm_pool:\n\tmlx5dr_icm_pool_destroy(dmn->action_icm_pool);\nfree_ste_icm_pool:\n\tmlx5dr_icm_pool_destroy(dmn->ste_icm_pool);\nclean_uar:\n\tmlx5_put_uars_page(dmn->mdev, dmn->uar);\nclean_pd:\n\tmlx5_core_dealloc_pd(dmn->mdev, dmn->pdn);\n\n\treturn ret;\n}", "target": 1, "idx": 10998}
{"commit_id": "19b61392c5a852b4e8a0bf35aecb969983c5932d", "project": "torvalds/linux", "func": "int dw_spi_add_host(struct device *dev, struct dw_spi *dws)\n{\n\tstruct spi_controller *master;\n\tint ret;\n\n\tBUG_ON(dws == NULL);\n\n\tmaster = spi_alloc_master(dev, 0);\n\tif (!master)\n\t\treturn -ENOMEM;\n\n\tdws->master = master;\n\tdws->type = SSI_MOTO_SPI;\n\tdws->dma_inited = 0;\n\tdws->dma_addr = (dma_addr_t)(dws->paddr + DW_SPI_DR);\n\tspin_lock_init(&dws->buf_lock);\n\n\tspi_controller_set_devdata(master, dws);\n\n\tret = request_irq(dws->irq, dw_spi_irq, IRQF_SHARED, dev_name(dev),\n\t\t\t  master);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"can not get IRQ\\n\");\n\t\tgoto err_free_master;\n\t}\n\n\tmaster->use_gpio_descriptors = true;\n\tmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_LOOP;\n\tmaster->bits_per_word_mask =  SPI_BPW_RANGE_MASK(4, 16);\n\tmaster->bus_num = dws->bus_num;\n\tmaster->num_chipselect = dws->num_cs;\n\tmaster->setup = dw_spi_setup;\n\tmaster->cleanup = dw_spi_cleanup;\n\tmaster->set_cs = dw_spi_set_cs;\n\tmaster->transfer_one = dw_spi_transfer_one;\n\tmaster->handle_err = dw_spi_handle_err;\n\tmaster->max_speed_hz = dws->max_freq;\n\tmaster->dev.of_node = dev->of_node;\n\tmaster->dev.fwnode = dev->fwnode;\n\tmaster->flags = SPI_MASTER_GPIO_SS;\n\tmaster->auto_runtime_pm = true;\n\n\tif (dws->set_cs)\n\t\tmaster->set_cs = dws->set_cs;\n\n\t/* Basic HW init */\n\tspi_hw_init(dev, dws);\n\n\tif (dws->dma_ops && dws->dma_ops->dma_init) {\n\t\tret = dws->dma_ops->dma_init(dws);\n\t\tif (ret) {\n\t\t\tdev_warn(dev, \"DMA init failed\\n\");\n\t\t\tdws->dma_inited = 0;\n\t\t} else {\n\t\t\tmaster->can_dma = dws->dma_ops->can_dma;\n\t\t}\n\t}\n\n\tret = devm_spi_register_controller(dev, master);\n\tif (ret) {\n\t\tdev_err(&master->dev, \"problem registering spi master\\n\");\n\t\tgoto err_dma_exit;\n\t}\n\n\tdw_spi_debugfs_init(dws);\n\treturn 0;\n\nerr_dma_exit:\n\tif (dws->dma_ops && dws->dma_ops->dma_exit)\n\t\tdws->dma_ops->dma_exit(dws);\n\tspi_enable_chip(dws, 0);\n\tfree_irq(dws->irq, master);\nerr_free_master:\n\tspi_controller_put(master);\n\treturn ret;\n}", "target": 1, "idx": 10999}
{"commit_id": "4ed59265fbbd636dc2fbbf325f8ea37ed300a6d9", "project": "ruven/iipsrv", "func": "void JTL::send( Session* session, int resolution, int tile ){\n\n  Timer function_timer;\n\n  if( session->loglevel >= 3 ) (*session->logfile) << \"JTL handler reached\" << endl;\n\n\n  // Make sure we have set our image\n  this->session = session;\n  checkImage();\n\n\n  // Time this command\n  if( session->loglevel >= 2 ) command_timer.start();\n\n\n  // Need to know the number of resolutions\n  int num_res = (*session->image)->getNumResolutions();\n\n\n  // If we have requested a rotation, remap the tile index to rotated coordinates\n  if( (int)((session->view)->getRotation()) % 360 == 90 ){\n\n  }\n  else if( (int)((session->view)->getRotation()) % 360 == 270 ){\n\n  }\n  else if( (int)((session->view)->getRotation()) % 360 == 180 ){\n    unsigned int im_width = (*session->image)->image_widths[num_res-resolution-1];\n    unsigned int im_height = (*session->image)->image_heights[num_res-resolution-1];\n    unsigned int tw = (*session->image)->getTileWidth();\n    //    unsigned int th = (*session->image)->getTileHeight();\n    int ntiles = (int) ceil( (double)im_width/tw ) * (int) ceil( (double)im_height/tw );\n    tile = ntiles - tile - 1;\n  }\n\n\n  // Sanity check\n  if( (resolution<0) || (tile<0) || (resolution>=num_res) ){\n    ostringstream error;\n    error << \"JTL :: Invalid resolution/tile number: \" << resolution << \",\" << tile;\n    throw error.str();\n  }\n\n\n  // Determine which output encoding to use\n  CompressionType ct = session->view->output_format;\n  Compressor *compressor;\n  if( session->view->output_format == JPEG ) compressor = session->jpeg;\n#ifdef HAVE_PNG\n  else if( session->view->output_format == PNG ) compressor = session->png;\n#endif\n  else compressor = session->jpeg;\n\n\n  TileManager tilemanager( session->tileCache, *session->image, session->watermark, compressor, session->logfile, session->loglevel );\n\n\n  // First calculate histogram if we have asked for either binarization,\n  //  histogram equalization or contrast stretching\n  if( session->view->requireHistogram() && (*session->image)->histogram.size()==0 ){\n\n    if( session->loglevel >= 4 ) function_timer.start();\n\n    // Retrieve an uncompressed version of our smallest tile\n    // which should be sufficient for calculating the histogram\n    RawTile thumbnail = tilemanager.getTile( 0, 0, 0, session->view->yangle, session->view->getLayers(), UNCOMPRESSED );\n\n    // Calculate histogram\n    (*session->image)->histogram =\n      session->processor->histogram( thumbnail, (*session->image)->max, (*session->image)->min );\n\n    if( session->loglevel >= 4 ){\n      *(session->logfile) << \"JTL :: Calculated histogram in \"\n\t\t\t  << function_timer.getTime() << \" microseconds\" << endl;\n    }\n\n    // Insert the histogram into our image cache\n    const string key = (*session->image)->getImagePath();\n    imageCacheMapType::iterator i = session->imageCache->find(key);\n    if( i != session->imageCache->end() ) (i->second).histogram = (*session->image)->histogram;\n  }\n\n\n\n  // Request uncompressed tile if raw pixel data is required for processing\n  if( (*session->image)->getNumBitsPerPixel() > 8 || (*session->image)->getColourSpace() == CIELAB\n      || (*session->image)->getNumChannels() == 2 || (*session->image)->getNumChannels() > 3\n      || ( (session->view->colourspace==GREYSCALE || session->view->colourspace==BINARY) && (*session->image)->getNumChannels()==3 &&\n\t   (*session->image)->getNumBitsPerPixel()==8 )\n      || session->view->floatProcessing() || session->view->equalization\n      || session->view->getRotation() != 0.0 || session->view->flip != 0\n      ) ct = UNCOMPRESSED;\n\n\n  // Set the physical output resolution for this particular view and zoom level\n  if( (*session->image)->dpi_x > 0 && (*session->image)->dpi_y > 0 ){\n    unsigned int im_width = (*session->image)->image_widths[num_res-resolution-1];\n    unsigned int im_height = (*session->image)->image_heights[num_res-resolution-1];\n    float dpi_x = (*session->image)->dpi_x * ( (float)im_width / (float)(*session->image)->getImageWidth() );\n    float dpi_y = (*session->image)->dpi_y * ( (float)im_height / (float)(*session->image)->getImageHeight() );\n    compressor->setResolution( dpi_x, dpi_y, (*session->image)->dpi_units );\n\n    if( session->loglevel >= 5 ){\n      *(session->logfile) << \"JTL :: Setting physical resolution of tile to \" <<  dpi_x << \" x \" << dpi_y\n\t\t\t  << ( ((*session->image)->dpi_units==1) ? \" pixels/inch\" : \" pixels/cm\" ) << endl;\n    }\n  }\n\n\n  // Embed ICC profile\n  if( session->view->embedICC() && ((*session->image)->getMetadata(\"icc\").size()>0) ){\n    if( session->loglevel >= 3 ){\n      *(session->logfile) << \"JTL :: Embedding ICC profile with size \"\n\t\t\t  << (*session->image)->getMetadata(\"icc\").size() << \" bytes\" << endl;\n    }\n    compressor->setICCProfile( (*session->image)->getMetadata(\"icc\") );\n  }\n\n\n  RawTile rawtile = tilemanager.getTile( resolution, tile, session->view->xangle,\n\t\t\t\t\t session->view->yangle, session->view->getLayers(), ct );\n\n\n  int len = rawtile.dataLength;\n\n  if( session->loglevel >= 2 ){\n    *(session->logfile) << \"JTL :: Tile size: \" << rawtile.width << \" x \" << rawtile.height << endl\n\t\t\t<< \"JTL :: Channels per sample: \" << rawtile.channels << endl\n\t\t\t<< \"JTL :: Bits per channel: \" << rawtile.bpc << endl\n\t\t\t<< \"JTL :: Data size is \" << len << \" bytes\" << endl;\n  }\n\n\n  // Convert CIELAB to sRGB\n  if( (*session->image)->getColourSpace() == CIELAB ){\n\n    if( session->loglevel >= 4 ){\n      *(session->logfile) << \"JTL :: Converting from CIELAB->sRGB\";\n      function_timer.start();\n    }\n    session->processor->LAB2sRGB( rawtile );\n    if( session->loglevel >= 4 ){\n      *(session->logfile) << \" in \" << function_timer.getTime() << \" microseconds\" << endl;\n    }\n  }\n\n\n  // Only use our float pipeline if necessary\n  if( rawtile.bpc > 8 || session->view->floatProcessing() ){\n\n    // Make a copy of our max and min as we may change these\n    vector <float> min = (*session->image)->min;\n    vector <float> max = (*session->image)->max;\n\n    // Change our image max and min if we have asked for a contrast stretch\n    if( session->view->contrast == -1 ){\n\n      // Find first non-zero bin in histogram\n      unsigned int n0 = 0;\n      while( (*session->image)->histogram[n0] == 0 ) ++n0;\n\n      // Find highest bin\n      unsigned int n1 = (*session->image)->histogram.size() - 1;\n      while( (*session->image)->histogram[n1] == 0 ) --n1;\n\n      // Histogram has been calculated using 8 bits, so scale up to native bit depth\n      if( rawtile.bpc > 8 && rawtile.sampleType == FIXEDPOINT ){\n\tn0 = n0 << (rawtile.bpc-8);\n\tn1 = n1 << (rawtile.bpc-8);\n      }\n\n      min.assign( rawtile.bpc, (float)n0 );\n      max.assign( rawtile.bpc, (float)n1 );\n\n      // Reset our contrast\n      session->view->contrast = 1.0;\n\n      if( session->loglevel >= 5 ){\n\t*(session->logfile) << \"JTL :: Applying contrast stretch for image range of \"\n\t\t\t    << n0 << \" - \" << n1 << endl;\n      }\n    }\n\n\n    // Apply normalization and float conversion\n    if( session->loglevel >= 4 ){\n      *(session->logfile) << \"JTL :: Normalizing and converting to float\";\n      function_timer.start();\n    }\n    session->processor->normalize( rawtile, max, min );\n    if( session->loglevel >= 4 ){\n      *(session->logfile) << \" in \" << function_timer.getTime() << \" microseconds\" << endl;\n    }\n\n\n    // Apply hill shading if requested\n    if( session->view->shaded ){\n      if( session->loglevel >= 4 ){\n\t*(session->logfile) << \"JTL :: Applying hill-shading\";\n\tfunction_timer.start();\n      }\n      session->processor->shade( rawtile, session->view->shade[0], session->view->shade[1] );\n      if( session->loglevel >= 4 ){\n\t*(session->logfile) << \" in \" << function_timer.getTime() << \" microseconds\" << endl;\n      }\n    }\n\n\n    // Apply color twist if requested\n    if( session->view->ctw.size() ){\n      if( session->loglevel >= 4 ){\n\t*(session->logfile) << \"JTL :: Applying color twist\";\n\tfunction_timer.start();\n      }\n      session->processor->twist( rawtile, session->view->ctw );\n      if( session->loglevel >= 4 ){\n\t*(session->logfile) << \" in \" << function_timer.getTime() << \" microseconds\" << endl;\n      }\n    }\n\n\n    // Apply any gamma or log transform\n    if( session->view->gamma != 1.0 ){\n\n      float gamma = session->view->gamma;\n      if( session->loglevel >= 4 ) function_timer.start();\n\n      // Check whether we have asked for logarithm\n      if( gamma == -1 ) session->processor->log( rawtile );\n      else session->processor->gamma( rawtile, gamma );\n\n      if( session->loglevel >= 4 ){\n\tif( gamma == -1 ) *(session->logfile) << \"JTL :: Applying logarithm transform in \";\n\telse *(session->logfile) << \"JTL :: Applying gamma of \" << gamma << \" in \";\n\t*(session->logfile) << function_timer.getTime() << \" microseconds\" << endl;\n      }\n    }\n\n\n    // Apply inversion if requested\n    if( session->view->inverted ){\n      if( session->loglevel >= 4 ){\n\t*(session->logfile) << \"JTL :: Applying inversion\";\n\tfunction_timer.start();\n      }\n      session->processor->inv( rawtile );\n      if( session->loglevel >= 4 ){\n\t*(session->logfile) << \" in \" << function_timer.getTime() << \" microseconds\" << endl;\n      }\n    }\n\n\n    // Apply color mapping if requested\n    if( session->view->cmapped ){\n      if( session->loglevel >= 4 ){\n\t*(session->logfile) << \"JTL :: Applying color map\";\n\tfunction_timer.start();\n      }\n      session->processor->cmap( rawtile, session->view->cmap );\n      if( session->loglevel >= 4 ){\n\t*(session->logfile) << \" in \" << function_timer.getTime() << \" microseconds\" << endl;\n      }\n    }\n\n\n    // Apply any contrast adjustments and/or clip to 8bit from 16 or 32 bit\n    float contrast = session->view->contrast;\n    if( session->loglevel >= 4 ){\n      *(session->logfile) << \"JTL :: Applying contrast of \" << contrast << \" and converting to 8 bit\";\n      function_timer.start();\n    }\n    session->processor->contrast( rawtile, contrast );\n    if( session->loglevel >= 4 ){\n      *(session->logfile) << \" in \" << function_timer.getTime() << \" microseconds\" << endl;\n    }\n\n  }\n\n\n  // Reduce to 1 or 3 bands if we have an alpha channel or a multi-band image and have requested a JPEG tile\n  // For PNG, strip extra bands if we have more than 4 present\n  if( ( (session->view->output_format == JPEG) && (rawtile.channels == 2 || rawtile.channels > 3) ) ||\n      ( (session->view->output_format == PNG) && (rawtile.channels > 4) ) ){\n\n    unsigned int bands = (rawtile.channels==2) ? 1 : 3;\n    if( session->loglevel >= 4 ){\n      *(session->logfile) << \"JTL :: Flattening channels to \" << bands;\n      function_timer.start();\n    }\n    session->processor->flatten( rawtile, bands );\n    if( session->loglevel >= 4 ){\n      *(session->logfile) << \" in \" << function_timer.getTime() << \" microseconds\" << endl;\n    }\n  }\n\n\n  // Convert to greyscale if requested\n  if( (*session->image)->getColourSpace() == sRGB && session->view->colourspace == GREYSCALE ){\n    if( session->loglevel >= 4 ){\n      *(session->logfile) << \"JTL :: Converting to greyscale\";\n      function_timer.start();\n    }\n    session->processor->greyscale( rawtile );\n    if( session->loglevel >= 4 ){\n      *(session->logfile) << \" in \" << function_timer.getTime() << \" microseconds\" << endl;\n    }\n  }\n\n\n  // Convert to binary (bi-level) if requested\n  if( (*session->image)->getColourSpace() != BINARY && session->view->colourspace == BINARY ){\n    if( session->loglevel >= 4 ){\n      *(session->logfile) << \"JTL :: Converting to binary with threshold \";\n      function_timer.start();\n    }\n    unsigned int threshold = session->processor->threshold( (*session->image)->histogram );\n    session->processor->binary( rawtile, threshold );\n    if( session->loglevel >= 4 ){\n      *(session->logfile) << threshold << \" in \" << function_timer.getTime() << \" microseconds\" << endl;\n    }\n  }\n\n\n  // Apply histogram equalization\n  if( session->view->equalization ){\n    if( session->loglevel >= 4 ) function_timer.start();\n    // Perform histogram equalization\n    session->processor->equalize( rawtile, (*session->image)->histogram );\n    if( session->loglevel >= 4 ){\n      *(session->logfile) << \"JTL :: Applying histogram equalization in \"\n                          << function_timer.getTime() << \" microseconds\" << endl;\n    }\n  }\n\n\n  // Apply flip\n  if( session->view->flip != 0 ){\n    Timer flip_timer;\n    if( session->loglevel >= 5 ){\n      flip_timer.start();\n    }\n\n    session->processor->flip( rawtile, session->view->flip  );\n\n    if( session->loglevel >= 5 ){\n      *(session->logfile) << \"JTL :: Flipping image \";\n      if( session->view->flip == 1 ) *(session->logfile) << \"horizontally\";\n      else *(session->logfile) << \"vertically\";\n      *(session->logfile) << \" in \" << flip_timer.getTime() << \" microseconds\" << endl;\n    }\n  }\n\n\n  // Apply rotation - can apply this safely after gamma and contrast adjustment\n  if( session->view->getRotation() != 0.0 ){\n    float rotation = session->view->getRotation();\n    if( session->loglevel >= 4 ){\n      *(session->logfile) << \"JTL :: Rotating image by \" << rotation << \" degrees\";\n      function_timer.start();\n    }\n    session->processor->rotate( rawtile, rotation );\n    if( session->loglevel >= 4 ){\n      *(session->logfile) << \" in \" << function_timer.getTime() << \" microseconds\" << endl;\n    }\n  }\n\n\n  // Compress to requested output format\n  if( rawtile.compressionType == UNCOMPRESSED ){\n    if( session->loglevel >= 4 ){\n      *(session->logfile) << \"JTL :: Encoding UNCOMPRESSED tile\";\n      function_timer.start();\n    }\n    len = compressor->Compress( rawtile );\n    if( session->loglevel >= 4 ){\n      *(session->logfile) << \" in \" << function_timer.getTime() << \" microseconds to \"\n                          << rawtile.dataLength << \" bytes\" << endl;\n\n    }\n  }\n\n\n#ifndef DEBUG\n\n  // Send HTTP header\n  stringstream header;\n  header << session->response->createHTTPHeader( compressor->getMimeType(), (*session->image)->getTimestamp(), len );\n  if( session->out->putStr( (const char*) header.str().c_str(), header.tellp() ) == -1 ){\n    if( session->loglevel >= 1 ){\n      *(session->logfile) << \"JTL :: Error writing HTTP header\" << endl;\n    }\n  }\n\n#endif\n\n\n  if( session->out->putStr( static_cast<const char*>(rawtile.data), len ) != len ){\n   if( session->loglevel >= 1 ){\n     *(session->logfile) << \"JTL :: Error writing JPEG tile\" << endl;\n   }\n  }\n\n\n  if( session->out->flush() == -1 ) {\n    if( session->loglevel >= 1 ){\n      *(session->logfile) << \"JTL :: Error flushing JPEG tile\" << endl;\n    }\n  }\n\n\n  // Inform our response object that we have sent something to the client\n  session->response->setImageSent();\n\n  // Total JTL response time\n  if( session->loglevel >= 2 ){\n    *(session->logfile) << \"JTL :: Total command time \" << command_timer.getTime() << \" microseconds\" << endl;\n  }\n\n}", "target": 2, "idx": 11000}
{"commit_id": "e8d5f92b8d30bb4ade76494490c3c065e12411b1", "project": "torvalds/linux", "func": "static struct usb_function *gprinter_alloc(struct usb_function_instance *fi)\n{\n\tstruct printer_dev\t*dev;\n\tstruct f_printer_opts\t*opts;\n\n\topts = container_of(fi, struct f_printer_opts, func_inst);\n\n\tmutex_lock(&opts->lock);\n\tif (opts->minor >= minors) {\n\t\tmutex_unlock(&opts->lock);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev) {\n\t\tmutex_unlock(&opts->lock);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tkref_init(&dev->kref);\n\t++opts->refcnt;\n\tdev->minor = opts->minor;\n\tdev->pnp_string = opts->pnp_string;\n\tdev->q_len = opts->q_len;\n\tmutex_unlock(&opts->lock);\n\n\tdev->function.name = \"printer\";\n\tdev->function.bind = printer_func_bind;\n\tdev->function.setup = printer_func_setup;\n\tdev->function.unbind = printer_func_unbind;\n\tdev->function.set_alt = printer_func_set_alt;\n\tdev->function.disable = printer_func_disable;\n\tdev->function.req_match = gprinter_req_match;\n\tdev->function.free_func = gprinter_free;\n\n\tINIT_LIST_HEAD(&dev->tx_reqs);\n\tINIT_LIST_HEAD(&dev->rx_reqs);\n\tINIT_LIST_HEAD(&dev->rx_buffers);\n\tINIT_LIST_HEAD(&dev->tx_reqs_active);\n\tINIT_LIST_HEAD(&dev->rx_reqs_active);\n\n\tspin_lock_init(&dev->lock);\n\tmutex_init(&dev->lock_printer_io);\n\tinit_waitqueue_head(&dev->rx_wait);\n\tinit_waitqueue_head(&dev->tx_wait);\n\tinit_waitqueue_head(&dev->tx_flush_wait);\n\n\tdev->interface = -1;\n\tdev->printer_cdev_open = 0;\n\tdev->printer_status = PRINTER_NOT_ERROR;\n\tdev->current_rx_req = NULL;\n\tdev->current_rx_bytes = 0;\n\tdev->current_rx_buf = NULL;\n\n\treturn &dev->function;\n}", "target": 1, "idx": 11001}
{"commit_id": "dfd0743f1d9ea76931510ed150334d571fbab49d", "project": "torvalds/linux", "func": "struct tee_shm *tee_shm_register(struct tee_context *ctx, unsigned long addr,\n\t\t\t\t size_t length, u32 flags)\n{\n\tstruct tee_device *teedev = ctx->teedev;\n\tconst u32 req_user_flags = TEE_SHM_DMA_BUF | TEE_SHM_USER_MAPPED;\n\tconst u32 req_kernel_flags = TEE_SHM_DMA_BUF | TEE_SHM_KERNEL_MAPPED;\n\tstruct tee_shm *shm;\n\tvoid *ret;\n\tint rc;\n\tint num_pages;\n\tunsigned long start;\n\n\tif (flags != req_user_flags && flags != req_kernel_flags)\n\t\treturn ERR_PTR(-ENOTSUPP);\n\n\tif (!tee_device_get(teedev))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!teedev->desc->ops->shm_register ||\n\t    !teedev->desc->ops->shm_unregister) {\n\t\ttee_device_put(teedev);\n\t\treturn ERR_PTR(-ENOTSUPP);\n\t}\n\n\tteedev_ctx_get(ctx);\n\n\tshm = kzalloc(sizeof(*shm), GFP_KERNEL);\n\tif (!shm) {\n\t\tret = ERR_PTR(-ENOMEM);\n\t\tgoto err;\n\t}\n\n\trefcount_set(&shm->refcount, 1);\n\tshm->flags = flags | TEE_SHM_REGISTER;\n\tshm->ctx = ctx;\n\tshm->id = -1;\n\taddr = untagged_addr(addr);\n\tstart = rounddown(addr, PAGE_SIZE);\n\tshm->offset = addr - start;\n\tshm->size = length;\n\tnum_pages = (roundup(addr + length, PAGE_SIZE) - start) / PAGE_SIZE;\n\tshm->pages = kcalloc(num_pages, sizeof(*shm->pages), GFP_KERNEL);\n\tif (!shm->pages) {\n\t\tret = ERR_PTR(-ENOMEM);\n\t\tgoto err;\n\t}\n\n\tif (flags & TEE_SHM_USER_MAPPED) {\n\t\trc = pin_user_pages_fast(start, num_pages, FOLL_WRITE,\n\t\t\t\t\t shm->pages);\n\t} else {\n\t\tstruct kvec *kiov;\n\t\tint i;\n\n\t\tkiov = kcalloc(num_pages, sizeof(*kiov), GFP_KERNEL);\n\t\tif (!kiov) {\n\t\t\tret = ERR_PTR(-ENOMEM);\n\t\t\tgoto err;\n\t\t}\n\n\t\tfor (i = 0; i < num_pages; i++) {\n\t\t\tkiov[i].iov_base = (void *)(start + i * PAGE_SIZE);\n\t\t\tkiov[i].iov_len = PAGE_SIZE;\n\t\t}\n\n\t\trc = get_kernel_pages(kiov, num_pages, 0, shm->pages);\n\t\tkfree(kiov);\n\t}\n\tif (rc > 0)\n\t\tshm->num_pages = rc;\n\tif (rc != num_pages) {\n\t\tif (rc >= 0)\n\t\t\trc = -ENOMEM;\n\t\tret = ERR_PTR(rc);\n\t\tgoto err;\n\t}\n\n\tmutex_lock(&teedev->mutex);\n\tshm->id = idr_alloc(&teedev->idr, shm, 1, 0, GFP_KERNEL);\n\tmutex_unlock(&teedev->mutex);\n\n\tif (shm->id < 0) {\n\t\tret = ERR_PTR(shm->id);\n\t\tgoto err;\n\t}\n\n\trc = teedev->desc->ops->shm_register(ctx, shm, shm->pages,\n\t\t\t\t\t     shm->num_pages, start);\n\tif (rc) {\n\t\tret = ERR_PTR(rc);\n\t\tgoto err;\n\t}\n\n\treturn shm;\nerr:\n\tif (shm) {\n\t\tif (shm->id >= 0) {\n\t\t\tmutex_lock(&teedev->mutex);\n\t\t\tidr_remove(&teedev->idr, shm->id);\n\t\t\tmutex_unlock(&teedev->mutex);\n\t\t}\n\t\trelease_registered_pages(shm);\n\t}\n\tkfree(shm);\n\tteedev_ctx_put(ctx);\n\ttee_device_put(teedev);\n\treturn ret;\n}", "target": 2, "idx": 11002}
{"commit_id": "1812352d767ccf5431aa440123e2e260a4db2726", "project": "ffmpeg", "func": "static int cbs_jpeg_split_fragment(CodedBitstreamContext *ctx,\n                                   CodedBitstreamFragment *frag,\n                                   int header)\n{\n    AVBufferRef *data_ref;\n    uint8_t *data;\n    size_t data_size;\n    int unit, start, end, marker, next_start, next_marker;\n    int err, i, j, length;\n\n    if (frag->data_size < 4) {\n        // Definitely too short to be meaningful.\n        return AVERROR_INVALIDDATA;\n    }\n\n    for (i = 0; i + 1 < frag->data_size && frag->data[i] != 0xff; i++);\n    if (i > 0) {\n        av_log(ctx->log_ctx, AV_LOG_WARNING, \"Discarding %d bytes at \"\n               \"beginning of image.\\n\", i);\n    }\n    for (++i; i + 1 < frag->data_size && frag->data[i] == 0xff; i++);\n    if (i + 1 >= frag->data_size && frag->data[i]) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n               \"no SOI marker found.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    marker = frag->data[i];\n    if (marker != JPEG_MARKER_SOI) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: first \"\n               \"marker is %02x, should be SOI.\\n\", marker);\n        return AVERROR_INVALIDDATA;\n    }\n    for (++i; i + 1 < frag->data_size && frag->data[i] == 0xff; i++);\n    if (i + 1 >= frag->data_size) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n               \"no image content found.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    marker = frag->data[i];\n    start  = i + 1;\n\n    for (unit = 0;; unit++) {\n        if (marker == JPEG_MARKER_EOI) {\n            break;\n        } else if (marker == JPEG_MARKER_SOS) {\n            for (i = start; i + 1 < frag->data_size; i++) {\n                if (frag->data[i] != 0xff)\n                    continue;\n                end = i;\n                for (++i; i + 1 < frag->data_size &&\n                          frag->data[i] == 0xff; i++);\n                if (i + 1 >= frag->data_size) {\n                    next_marker = -1;\n                } else {\n                    if (frag->data[i] == 0x00)\n                        continue;\n                    next_marker = frag->data[i];\n                    next_start  = i + 1;\n                }\n                break;\n            }\n        } else {\n            i = start;\n            if (i + 2 > frag->data_size) {\n                av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n                       \"truncated at %02x marker.\\n\", marker);\n                return AVERROR_INVALIDDATA;\n            }\n            length = AV_RB16(frag->data + i);\n            if (i + length > frag->data_size) {\n                av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n                       \"truncated at %02x marker segment.\\n\", marker);\n                return AVERROR_INVALIDDATA;\n            }\n            end = start + length;\n\n            i = end;\n            if (frag->data[i] != 0xff) {\n                next_marker = -1;\n            } else {\n                for (++i; i + 1 < frag->data_size &&\n                          frag->data[i] == 0xff; i++);\n                if (i + 1 >= frag->data_size) {\n                    next_marker = -1;\n                } else {\n                    next_marker = frag->data[i];\n                    next_start  = i + 1;\n                }\n            }\n        }\n\n        if (marker == JPEG_MARKER_SOS) {\n            length = AV_RB16(frag->data + start);\n\n            if (length > end - start)\n                return AVERROR_INVALIDDATA;\n\n            data_ref = NULL;\n            data     = av_malloc(end - start +\n                                 AV_INPUT_BUFFER_PADDING_SIZE);\n            if (!data)\n                return AVERROR(ENOMEM);\n\n            memcpy(data, frag->data + start, length);\n            for (i = start + length, j = length; i < end; i++, j++) {\n                if (frag->data[i] == 0xff) {\n                    while (frag->data[i] == 0xff)\n                        ++i;\n                    data[j] = 0xff;\n                } else {\n                    data[j] = frag->data[i];\n                }\n            }\n            data_size = j;\n\n            memset(data + data_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n\n        } else {\n            data      = frag->data + start;\n            data_size = end - start;\n            data_ref  = frag->data_ref;\n        }\n\n        err = ff_cbs_insert_unit_data(ctx, frag, unit, marker,\n                                      data, data_size, data_ref);\n        if (err < 0)\n            return err;\n\n        if (next_marker == -1)\n            break;\n        marker = next_marker;\n        start  = next_start;\n    }\n\n    return 0;\n}", "target": 3, "idx": 11003}
{"commit_id": "dee11ec440d7908d1daf69f40a3324b27cf213ba", "project": "jasper-software/jasper", "func": "static int jpc_dec_tiledecode(jpc_dec_t *dec, jpc_dec_tile_t *tile)\n{\n\tint i;\n\tint j;\n\tjpc_dec_tcomp_t *tcomp;\n\tjpc_dec_rlvl_t *rlvl;\n\tjpc_dec_band_t *band;\n\tint compno;\n\tint rlvlno;\n\tint bandno;\n\tint adjust;\n\tint v;\n\tjpc_dec_ccp_t *ccp;\n\tjpc_dec_cmpt_t *cmpt;\n\n\tif (jpc_dec_decodecblks(dec, tile)) {\n\t\tjas_eprintf(\"jpc_dec_decodecblks failed\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Perform dequantization. */\n\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t  ++compno, ++tcomp) {\n\t\tccp = &tile->cp->ccps[compno];\n\t\tfor (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno < tcomp->numrlvls;\n\t\t  ++rlvlno, ++rlvl) {\n\t\t\tif (!rlvl->bands) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (bandno = 0, band = rlvl->bands;\n\t\t\t  bandno < rlvl->numbands; ++bandno, ++band) {\n\t\t\t\tif (!band->data) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tjpc_undo_roi(band->data, band->roishift, ccp->roishift -\n\t\t\t\t  band->roishift, band->numbps);\n\t\t\t\tif (tile->realmode) {\n\t\t\t\t\tjas_matrix_asl(band->data, JPC_FIX_FRACBITS);\n\t\t\t\t\tjpc_dequantize(band->data, band->absstepsize);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Apply an inverse wavelet transform if necessary. */\n\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t  ++compno, ++tcomp) {\n\t\tccp = &tile->cp->ccps[compno];\n\t\tjpc_tsfb_synthesize(tcomp->tsfb, tcomp->data);\n\t}\n\n\n\t/* Apply an inverse intercomponent transform if necessary. */\n\tswitch (tile->cp->mctid) {\n\tcase JPC_MCT_RCT:\n\t\tif (dec->numcomps < 3) {\n\t\t\tjas_eprintf(\"RCT requires at least three components\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (!jas_image_cmpt_domains_same(dec->image)) {\n\t\t\tjas_eprintf(\"RCT requires all components have the same domain\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_irct(tile->tcomps[0].data, tile->tcomps[1].data,\n\t\t  tile->tcomps[2].data);\n\t\tbreak;\n\tcase JPC_MCT_ICT:\n\t\tif (dec->numcomps < 3) {\n\t\t\tjas_eprintf(\"ICT requires at least three components\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (!jas_image_cmpt_domains_same(dec->image)) {\n\t\t\tjas_eprintf(\"RCT requires all components have the same domain\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_iict(tile->tcomps[0].data, tile->tcomps[1].data,\n\t\t  tile->tcomps[2].data);\n\t\tbreak;\n\t}\n\n\t/* Perform rounding and convert to integer values. */\n\tif (tile->realmode) {\n\t\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t\t  ++compno, ++tcomp) {\n\t\t\tfor (i = 0; i < jas_matrix_numrows(tcomp->data); ++i) {\n\t\t\t\tfor (j = 0; j < jas_matrix_numcols(tcomp->data); ++j) {\n\t\t\t\t\tv = jas_matrix_get(tcomp->data, i, j);\n\t\t\t\t\tv = jpc_fix_round(v);\n\t\t\t\t\tjas_matrix_set(tcomp->data, i, j, jpc_fixtoint(v));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Perform level shift. */\n\tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <\n\t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tadjust = cmpt->sgnd ? 0 : (1 << (cmpt->prec - 1));\n\t\tfor (i = 0; i < jas_matrix_numrows(tcomp->data); ++i) {\n\t\t\tfor (j = 0; j < jas_matrix_numcols(tcomp->data); ++j) {\n\t\t\t\t*jas_matrix_getref(tcomp->data, i, j) += adjust;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Perform clipping. */\n\tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <\n\t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tjpc_fix_t mn;\n\t\tjpc_fix_t mx;\n\t\tmn = cmpt->sgnd ? (-(1 << (cmpt->prec - 1))) : (0);\n\t\tmx = cmpt->sgnd ? ((1 << (cmpt->prec - 1)) - 1) : ((1 <<\n\t\t  cmpt->prec) - 1);\n\t\tjas_matrix_clip(tcomp->data, mn, mx);\n\t}\n\n\t/* XXX need to free tsfb struct */\n\n\t/* Write the data for each component of the image. */\n\tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <\n\t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tif (jas_image_writecmpt(dec->image, compno, tcomp->xstart -\n\t\t  JPC_CEILDIV(dec->xstart, cmpt->hstep), tcomp->ystart -\n\t\t  JPC_CEILDIV(dec->ystart, cmpt->vstep), jas_matrix_numcols(\n\t\t  tcomp->data), jas_matrix_numrows(tcomp->data), tcomp->data)) {\n\t\t\tjas_eprintf(\"write component failed\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}", "target": 2, "idx": 11004}
{"commit_id": "702c4227e8b6169f781e4bb5ae4b5733f51ab126", "project": "GNOME/gimp", "func": "GimpImage *\nxcf_load_stream (Gimp          *gimp,\n                 GInputStream  *input,\n                 GFile         *input_file,\n                 GimpProgress  *progress,\n                 GError       **error)\n{\n  XcfInfo      info  = { 0, };\n  const gchar *filename;\n  GimpImage   *image = NULL;\n  gchar        id[14];\n  gboolean     success;\n\n  g_return_val_if_fail (GIMP_IS_GIMP (gimp), NULL);\n  g_return_val_if_fail (G_IS_INPUT_STREAM (input), NULL);\n  g_return_val_if_fail (input_file == NULL || G_IS_FILE (input_file), NULL);\n  g_return_val_if_fail (progress == NULL || GIMP_IS_PROGRESS (progress), NULL);\n  g_return_val_if_fail (error == NULL || *error == NULL, NULL);\n\n  if (input_file)\n    filename = gimp_file_get_utf8_name (input_file);\n  else\n    filename = _(\"Memory Stream\");\n\n  info.gimp             = gimp;\n  info.input            = input;\n  info.seekable         = G_SEEKABLE (input);\n  info.bytes_per_offset = 4;\n  info.progress         = progress;\n  info.file             = input_file;\n  info.compression      = COMPRESS_NONE;\n\n  if (progress)\n    gimp_progress_start (progress, FALSE, _(\"Opening '%s'\"), filename);\n\n  success = TRUE;\n\n  xcf_read_int8 (&info, (guint8 *) id, 14);\n\n  if (! g_str_has_prefix (id, \"gimp xcf \"))\n    {\n      success = FALSE;\n    }\n  else if (strcmp (id + 9, \"file\") == 0)\n    {\n      info.file_version = 0;\n    }\n  else if (id[9]  == 'v' &&\n           id[13] == '\\0')\n    {\n      info.file_version = atoi (id + 10);\n    }\n  else\n    {\n      success = FALSE;\n    }\n\n  if (info.file_version >= 11)\n    info.bytes_per_offset = 8;\n\n  if (success)\n    {\n      if (info.file_version >= 0 &&\n          info.file_version < G_N_ELEMENTS (xcf_loaders))\n        {\n          image = (*(xcf_loaders[info.file_version])) (gimp, &info, error);\n\n          if (! image)\n            success = FALSE;\n\n          g_input_stream_close (info.input, NULL, NULL);\n        }\n      else\n        {\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"XCF error: unsupported XCF file version %d \"\n                         \"encountered\"), info.file_version);\n          success = FALSE;\n        }\n    }\n\n  if (progress)\n    gimp_progress_end (progress);\n\n  return image;\n}", "target": 1, "idx": 11005}
{"commit_id": "c8bcd9c5be24fb9e6132e97da5a35e55a83e36b9", "project": "torvalds/linux", "func": "static void __proc_set_tty(struct tty_struct *tty)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tty->ctrl_lock, flags);\n\t/*\n\t * The session and fg pgrp references will be non-NULL if\n\t * tiocsctty() is stealing the controlling tty\n\t */\n\tput_pid(tty->session);\n\tput_pid(tty->pgrp);\n\ttty->pgrp = get_pid(task_pgrp(current));\n\ttty->session = get_pid(task_session(current));\n\tspin_unlock_irqrestore(&tty->ctrl_lock, flags);\n\tif (current->signal->tty) {\n\t\ttty_debug(tty, \"current tty %s not NULL!!\\n\",\n\t\t\t  current->signal->tty->name);\n\t\ttty_kref_put(current->signal->tty);\n\t}\n\tput_pid(current->signal->tty_old_pgrp);\n\tcurrent->signal->tty = tty_kref_get(tty);\n\tcurrent->signal->tty_old_pgrp = NULL;\n}", "target": 1, "idx": 11006}
{"commit_id": "c5f30c70e48786e1aef8c815f35e406a6c4fb3ae", "project": "Samsung/mTower", "func": "struct bignum *crypto_bignum_allocate(size_t size_bits)\n{\n\tsize_t sz = mpa_StaticVarSizeInU32(size_bits) *\tsizeof(uint32_t);\n\t// struct mpa_numbase_struct *bn = calloc(1, sz);\n\tstruct mpa_numbase_struct *bn= TEE_Malloc(sz, TEE_MALLOC_FILL_ZERO);\n\tif (!bn)\n\t\treturn NULL;\n\tbn->alloc = sz - MPA_NUMBASE_METADATA_SIZE_IN_U32 * sizeof(uint32_t);\n\treturn (struct bignum *)bn;\n}", "target": 2, "idx": 11007}
{"commit_id": "f5008996ea06ebc6278071e3083af675ef807b84", "project": "kernel/git/mszeredi/fuse", "func": "int fuse_inode_uncached_io_start(struct fuse_inode *fi, struct fuse_backing *fb)\n{\n\tstruct fuse_backing *oldfb;\n\tint err = 0;\n\n\tspin_lock(&fi->lock);\n\t/* deny conflicting backing files on same fuse inode */\n\toldfb = fuse_inode_backing(fi);\n\tif (fb && oldfb && oldfb != fb) {\n\t\terr = -EBUSY;\n\t\tgoto unlock;\n\t}\n\tif (fi->iocachectr > 0) {\n\t\terr = -ETXTBSY;\n\t\tgoto unlock;\n\t}\n\tfi->iocachectr--;\n\n\t/* fuse inode holds a single refcount of backing file */\n\tif (fb && !oldfb) {\n\t\toldfb = fuse_inode_backing_set(fi, fb);\n\t\tWARN_ON_ONCE(oldfb != NULL);\n\t} else {\n\t\tfuse_backing_put(fb);\n\t}\nunlock:\n\tspin_unlock(&fi->lock);\n\treturn err;\n}", "target": 2, "idx": 11008}
{"commit_id": "157712b2f5f89b19ef2497ea89c5938eb29529da", "project": "wireshark", "func": "static int\ntry_dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, volatile int offset, proto_tree *tree, gint nest_level)\n{\n    int                start_offset;\n    gint8              ber_class;\n    gboolean           pc, ind;\n    gint32             tag;\n    guint32            len;\n    int                hdr_len;\n    proto_item        *item      = NULL;\n    proto_tree        *next_tree = NULL;\n    guint8             c;\n    guint32            i;\n    gboolean           is_printable;\n    volatile gboolean  is_decoded_as;\n    proto_item        *pi, *cause;\n    asn1_ctx_t         asn1_ctx;\n\n    if (nest_level > BER_MAX_NESTING) {\n        /* Assume that we have a malformed packet. */\n        THROW(ReportedBoundsError);\n    }\n\n    start_offset = offset;\n    asn1_ctx_init(&asn1_ctx, ASN1_ENC_BER, TRUE, pinfo);\n\n    offset = get_ber_identifier(tvb, offset, &ber_class, &pc, &tag);\n    offset = get_ber_length(tvb, offset, &len, &ind);\n\n    if (len > (guint32)tvb_reported_length_remaining(tvb, offset)) {\n        /* hmm   maybe something bad happened or the frame is short;\n           since these are not vital outputs just return instead of\n           throwing an exception.\n         */\n\n        if (show_internal_ber_fields) {\n            offset = dissect_ber_identifier(pinfo, tree, tvb, start_offset, &ber_class, &pc, &tag);\n            offset = dissect_ber_length(pinfo, tree, tvb, offset, &len, NULL);\n        }\n        ber_add_large_length_error(pinfo, tree, tvb, offset, len);\n        return tvb_reported_length(tvb);\n    }\n/* we don't care about the class only on the constructor flag */\n    switch (pc) {\n\n    case FALSE: /* this is not constructed */\n\n        switch (ber_class) { /* we do care about the class */\n        case BER_CLASS_UNI: /* it a Universal tag - we can decode it */\n            switch (tag) {\n            case BER_UNI_TAG_EOC:\n                /* XXX: shouldn't really get here */\n                break;\n            case BER_UNI_TAG_INTEGER:\n                offset = dissect_ber_integer(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_INTEGER, NULL);\n                break;\n            case BER_UNI_TAG_REAL:\n                offset = dissect_ber_real(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_REAL, NULL);\n                break;\n            case BER_UNI_TAG_BITSTRING:\n                offset = dissect_ber_bitstring(FALSE, &asn1_ctx, tree, tvb, start_offset, NULL, hf_ber_unknown_BITSTRING, -1, NULL);\n                break;\n            case BER_UNI_TAG_ENUMERATED:\n                offset = dissect_ber_integer(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_ENUMERATED, NULL);\n                break;\n            case BER_UNI_TAG_GraphicString:\n                offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_GraphicString, NULL);\n                break;\n            case BER_UNI_TAG_OCTETSTRING:\n                is_decoded_as = FALSE;\n                if (decode_octetstring_as_ber && (len >= 2)) {\n                    volatile int ber_offset = 0;\n                    guint32 ber_len = 0;\n                    TRY {\n                        ber_offset = get_ber_identifier(tvb, offset, NULL, &pc, NULL);\n                        ber_offset = get_ber_length(tvb, ber_offset, &ber_len, NULL);\n                    } CATCH_ALL {\n                    }\n                    ENDTRY;\n                    if (pc && (ber_len > 0) && (ber_len + (ber_offset - offset) == len)) {\n                        /* Decoded a constructed ASN.1 tag with a length indicating this\n                         * could be BER encoded data.  Try dissecting as unknown BER.\n                         */\n                        is_decoded_as = TRUE;\n                        if (show_internal_ber_fields) {\n                            offset = dissect_ber_identifier(pinfo, tree, tvb, start_offset, NULL, NULL, NULL);\n                            offset = dissect_ber_length(pinfo, tree, tvb, offset, NULL, NULL);\n                        }\n                        item = ber_proto_tree_add_item(pinfo, tree, hf_ber_unknown_BER_OCTETSTRING, tvb, offset, len, ENC_NA);\n                        next_tree = proto_item_add_subtree(item, ett_ber_octet_string);\n                        offset = try_dissect_unknown_ber(pinfo, tvb, offset, next_tree, nest_level+1);\n                    }\n                }\n                if (!is_decoded_as) {\n                    offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_OCTETSTRING, NULL);\n                }\n                break;\n            case BER_UNI_TAG_OID:\n                offset = dissect_ber_object_identifier_str(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_OID, NULL);\n                break;\n            case BER_UNI_TAG_RELATIVE_OID:\n                offset = dissect_ber_relative_oid_str(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_relative_OID, NULL);\n                break;\n            case BER_UNI_TAG_NumericString:\n                offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_NumericString, NULL);\n                break;\n            case BER_UNI_TAG_PrintableString:\n                offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_PrintableString, NULL);\n                break;\n            case BER_UNI_TAG_TeletexString:\n                offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_TeletexString, NULL);\n                break;\n            case BER_UNI_TAG_VisibleString:\n                offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_VisibleString, NULL);\n                break;\n            case BER_UNI_TAG_GeneralString:\n                offset = dissect_ber_GeneralString(&asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_GeneralString, NULL, 0);\n                break;\n            case BER_UNI_TAG_BMPString:\n                offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_BMPString, NULL);\n                break;\n            case BER_UNI_TAG_UniversalString:\n                offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_UniversalString, NULL);\n                break;\n            case BER_UNI_TAG_IA5String:\n                offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_IA5String, NULL);\n                break;\n            case BER_UNI_TAG_UTCTime:\n                offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_UTCTime, NULL);\n                break;\n            case BER_UNI_TAG_NULL:\n                proto_tree_add_item(tree, hf_ber_null_tag, tvb, offset, len, ENC_NA);\n                break;\n            case BER_UNI_TAG_UTF8String:\n                offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_UTF8String, NULL);\n                break;\n            case BER_UNI_TAG_GeneralizedTime:\n                offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_GeneralizedTime, NULL);\n                break;\n            case BER_UNI_TAG_BOOLEAN:\n                offset = dissect_ber_boolean(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_BOOLEAN, NULL);\n                break;\n            default:\n                offset = dissect_ber_identifier(pinfo, tree, tvb, start_offset, &ber_class, &pc, &tag);\n                offset = dissect_ber_length(pinfo, tree, tvb, offset, &len, NULL);\n                cause = proto_tree_add_string_format_value(\n                    tree, hf_ber_error, tvb, offset, len, \"unknown_universal_tag\",\n                    \"can not handle universal tag:%d\",\n                    tag);\n                expert_add_info(pinfo, cause, &ei_ber_universal_tag_unknown);\n                offset += len;\n            }\n            break;\n        case BER_CLASS_APP:\n        case BER_CLASS_CON:\n        case BER_CLASS_PRI:\n        default:\n            /* we dissect again if show_internal_ber_fields is set */\n            if (show_internal_ber_fields) {\n                offset = dissect_ber_identifier(pinfo, tree, tvb, start_offset, &ber_class, &pc, &tag);\n                offset = dissect_ber_length(pinfo, tree, tvb, offset, &len, NULL);\n            }\n\n            /* we can't dissect this directly as it is specific */\n            pi = proto_tree_add_none_format(tree, hf_ber_unknown_BER_primitive, tvb, offset, len,\n                                            \"[%s %d] \", val_to_str_const(ber_class, ber_class_codes, \"Unknown\"), tag);\n\n            is_decoded_as = FALSE;\n            if (decode_primitive_as_ber && (len >= 2)) {\n                volatile int ber_offset = 0;\n                guint32 ber_len = 0;\n                TRY {\n                    ber_offset = get_ber_identifier(tvb, offset, NULL, &pc, NULL);\n                    ber_offset = get_ber_length(tvb, ber_offset, &ber_len, NULL);\n                } CATCH_ALL {\n                }\n                ENDTRY;\n                if (pc && (ber_len > 0) && (ber_len + (ber_offset - offset) == len)) {\n                    /* Decoded a constructed ASN.1 tag with a length indicating this\n                     * could be BER encoded data.  Try dissecting as unknown BER.\n                     */\n                    is_decoded_as = TRUE;\n                    proto_item_append_text (pi, \"[BER encoded]\");\n                    next_tree = proto_item_add_subtree(pi, ett_ber_primitive);\n                    offset = try_dissect_unknown_ber(pinfo, tvb, offset, next_tree, nest_level+1);\n                }\n            }\n\n            if (!is_decoded_as && len) {\n                /* we may want to do better and show the bytes */\n                is_printable = TRUE;\n                for (i=0; i<len; i++) {\n                    c = tvb_get_guint8(tvb, offset+i);\n\n                    if (is_printable && !g_ascii_isprint(c))\n                        is_printable = FALSE;\n\n                    proto_item_append_text(pi, \"%02x\", c);\n                }\n\n                if (is_printable) { /* give a nicer representation if it looks like a string */\n                    proto_item_append_text(pi, \" (\");\n                    for (i=0; i<len; i++) {\n                        proto_item_append_text(pi, \"%c\", tvb_get_guint8(tvb, offset+i));\n                    }\n                    proto_item_append_text(pi, \")\");\n                }\n                offset += len;\n            }\n\n            break;\n        }", "target": 2, "idx": 11009}
{"commit_id": "b61d35eaccc0a7ddeff8a1c3abfcd0a43ccf210b", "project": "ImageMagick", "func": "static void TIFFGetProperties(TIFF *tiff,Image *image,ExceptionInfo *exception)\n{\n  char\n    message[MagickPathExtent],\n    *text;\n\n  uint32\n    count,\n    length,\n    type;\n\n  unsigned long\n    *tietz;\n\n  if ((TIFFGetField(tiff,TIFFTAG_ARTIST,&text) == 1) &&\n      (text != (char *) NULL))\n    (void) SetImageProperty(image,\"tiff:artist\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_COPYRIGHT,&text) == 1) &&\n      (text != (char *) NULL))\n    (void) SetImageProperty(image,\"tiff:copyright\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_DATETIME,&text) == 1) &&\n      (text != (char *) NULL))\n    (void) SetImageProperty(image,\"tiff:timestamp\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_DOCUMENTNAME,&text) == 1) &&\n      (text != (char *) NULL))\n    (void) SetImageProperty(image,\"tiff:document\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_HOSTCOMPUTER,&text) == 1) &&\n      (text != (char *) NULL))\n    (void) SetImageProperty(image,\"tiff:hostcomputer\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_IMAGEDESCRIPTION,&text) == 1) &&\n      (text != (char *) NULL))\n    (void) SetImageProperty(image,\"comment\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_MAKE,&text) == 1) &&\n      (text != (char *) NULL))\n    (void) SetImageProperty(image,\"tiff:make\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_MODEL,&text) == 1) &&\n      (text != (char *) NULL))\n    (void) SetImageProperty(image,\"tiff:model\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_OPIIMAGEID,&count,&text) == 1) &&\n      (text != (char *) NULL))\n    {\n      if (count >= MagickPathExtent)\n        count=MagickPathExtent-1;\n      (void) CopyMagickString(message,text,count+1);\n      (void) SetImageProperty(image,\"tiff:image-id\",message,exception);\n    }\n  if ((TIFFGetField(tiff,TIFFTAG_PAGENAME,&text) == 1) &&\n      (text != (char *) NULL))\n    (void) SetImageProperty(image,\"label\",text,exception);\n  if ((TIFFGetField(tiff,TIFFTAG_SOFTWARE,&text) == 1) &&\n      (text != (char *) NULL))\n    (void) SetImageProperty(image,\"tiff:software\",text,exception);\n  if ((TIFFGetField(tiff,33423,&count,&text) == 1) &&\n      (text != (char *) NULL))\n    {\n      if (count >= MagickPathExtent)\n        count=MagickPathExtent-1;\n      (void) CopyMagickString(message,text,count+1);\n      (void) SetImageProperty(image,\"tiff:kodak-33423\",message,exception);\n    }\n  if ((TIFFGetField(tiff,36867,&count,&text) == 1) &&\n      (text != (char *) NULL))\n    {\n      if (count >= MagickPathExtent)\n        count=MagickPathExtent-1;\n      (void) CopyMagickString(message,text,count+1);\n      (void) SetImageProperty(image,\"tiff:kodak-36867\",message,exception);\n    }\n  if (TIFFGetField(tiff,TIFFTAG_SUBFILETYPE,&type) == 1)\n    switch (type)\n    {\n      case 0x01:\n      {\n        (void) SetImageProperty(image,\"tiff:subfiletype\",\"REDUCEDIMAGE\",\n          exception);\n        break;\n      }\n      case 0x02:\n      {\n        (void) SetImageProperty(image,\"tiff:subfiletype\",\"PAGE\",exception);\n        break;\n      }\n      case 0x04:\n      {\n        (void) SetImageProperty(image,\"tiff:subfiletype\",\"MASK\",exception);\n        break;\n      }\n      default:\n        break;\n    }\n  if ((TIFFGetField(tiff,37706,&length,&tietz) == 1) &&\n      (tietz != (unsigned long *) NULL))\n    {\n      (void) FormatLocaleString(message,MagickPathExtent,\"%lu\",tietz[0]);\n      (void) SetImageProperty(image,\"tiff:tietz_offset\",message,exception);\n    }\n}", "target": 1, "idx": 11010}
{"commit_id": "5ddda15d89f5ac82f4416208c5319ace4aecdc36", "project": "mc2-project/opaque-sql", "func": "void ecall_project(uint8_t *condition, size_t condition_length,\n                   uint8_t *input_rows, size_t input_rows_length,\n                   uint8_t **output_rows, size_t *output_rows_length) {\n  // Guard against operating on arbitrary enclave memory\n  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);\n  sgx_lfence();\n\n  try {\n    project(condition, condition_length,\n            input_rows, input_rows_length,\n            output_rows, output_rows_length);\n  } catch (const std::runtime_error &e) {\n    ocall_throw(e.what());\n  }\n}", "target": 2, "idx": 11011}
{"commit_id": "1a4722a89ee85be74af5086a7027b3ad1e0a55e8", "project": "php/php-src", "func": "gdImagePtr gdImageScaleTwoPass(const gdImagePtr src, const unsigned int src_width, const unsigned int src_height, const unsigned int new_width, const unsigned int new_height)\n{\n\tgdImagePtr tmp_im;\n\tgdImagePtr dst;\n\n\t/* Convert to truecolor if it isn't; this code requires it. */\n\tif (!src->trueColor) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\n\ttmp_im = gdImageCreateTrueColor(new_width, src_height);\n\tif (tmp_im == NULL) {\n\t\treturn NULL;\n\t}\n\tgdImageSetInterpolationMethod(tmp_im, src->interpolation_id);\n\t_gdScaleHoriz(src, src_width, src_height, tmp_im, new_width, src_height);\n\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (dst == NULL) {\n\t\tgdImageDestroy(tmp_im);\n\t\treturn NULL;\n\t}\n\tgdImageSetInterpolationMethod(dst, src->interpolation_id);\n\t_gdScaleVert(tmp_im, new_width, src_height, dst, new_width, new_height);\n\tgdImageDestroy(tmp_im);\n\n\treturn dst;\n}", "target": 2, "idx": 11012}
{"commit_id": "0a85029d694f992f3631e2f249e4999daee15cbf", "project": "gpac", "func": "GF_Err gf_isom_oinf_read_entry(void *entry, GF_BitStream *bs)\n{\n\tGF_OperatingPointsInformation* ptr = (GF_OperatingPointsInformation *)entry;\n\tu32 i, j, count;\n\n\tif (!ptr) return GF_BAD_PARAM;\n\tptr->scalability_mask = gf_bs_read_u16(bs);\n\tgf_bs_read_int(bs, 2);//reserved\n\tcount = gf_bs_read_int(bs, 6);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_ProfileTierLevel *ptl;\n\t\tGF_SAFEALLOC(ptl, LHEVC_ProfileTierLevel);\n\t\tif (!ptl) return GF_OUT_OF_MEM;\n\t\tptl->general_profile_space = gf_bs_read_int(bs, 2);\n\t\tptl->general_tier_flag= gf_bs_read_int(bs, 1);\n\t\tptl->general_profile_idc = gf_bs_read_int(bs, 5);\n\t\tptl->general_profile_compatibility_flags = gf_bs_read_u32(bs);\n\t\tptl->general_constraint_indicator_flags = gf_bs_read_long_int(bs, 48);\n\t\tptl->general_level_idc = gf_bs_read_u8(bs);\n\t\tgf_list_add(ptr->profile_tier_levels, ptl);\n\t}\n\tcount = gf_bs_read_u16(bs);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_OperatingPoint *op;\n\t\tGF_SAFEALLOC(op, LHEVC_OperatingPoint);\n\t\tif (!op) return GF_OUT_OF_MEM;\n\t\top->output_layer_set_idx = gf_bs_read_u16(bs);\n\t\top->max_temporal_id = gf_bs_read_u8(bs);\n\t\top->layer_count = gf_bs_read_u8(bs);\n\t\tif (op->layer_count > GF_ARRAY_LENGTH(op->layers_info)) {\n\t\t\tgf_free(op);\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tfor (j = 0; j < op->layer_count; j++) {\n\t\t\top->layers_info[j].ptl_idx = gf_bs_read_u8(bs);\n\t\t\top->layers_info[j].layer_id = gf_bs_read_int(bs, 6);\n\t\t\top->layers_info[j].is_outputlayer = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;\n\t\t\top->layers_info[j].is_alternate_outputlayer = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;\n\t\t}\n\t\top->minPicWidth = gf_bs_read_u16(bs);\n\t\top->minPicHeight = gf_bs_read_u16(bs);\n\t\top->maxPicWidth = gf_bs_read_u16(bs);\n\t\top->maxPicHeight = gf_bs_read_u16(bs);\n\t\top->maxChromaFormat = gf_bs_read_int(bs, 2);\n\t\top->maxBitDepth = gf_bs_read_int(bs, 3) + 8;\n\t\tgf_bs_read_int(bs, 1);//reserved\n\t\top->frame_rate_info_flag = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;\n\t\top->bit_rate_info_flag = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;\n\t\tif (op->frame_rate_info_flag) {\n\t\t\top->avgFrameRate = gf_bs_read_u16(bs);\n\t\t\tgf_bs_read_int(bs, 6); //reserved\n\t\t\top->constantFrameRate = gf_bs_read_int(bs, 2);\n\t\t}\n\t\tif (op->bit_rate_info_flag) {\n\t\t\top->maxBitRate = gf_bs_read_u32(bs);\n\t\t\top->avgBitRate = gf_bs_read_u32(bs);\n\t\t}\n\t\tgf_list_add(ptr->operating_points, op);\n\t}\n\tcount = gf_bs_read_u8(bs);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_DependentLayer *dep;\n\t\tGF_SAFEALLOC(dep, LHEVC_DependentLayer);\n\t\tif (!dep) return GF_OUT_OF_MEM;\n\t\tdep->dependent_layerID = gf_bs_read_u8(bs);\n\t\tdep->num_layers_dependent_on = gf_bs_read_u8(bs);\n\t\tif (dep->num_layers_dependent_on > GF_ARRAY_LENGTH(dep->dependent_on_layerID)) {\n\t\t\tgf_free(dep);\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tfor (j = 0; j < dep->num_layers_dependent_on; j++)\n\t\t\tdep->dependent_on_layerID[j] = gf_bs_read_u8(bs);\n\t\tfor (j = 0; j < 16; j++) {\n\t\t\tif (ptr->scalability_mask & (1 << j))\n\t\t\t\tdep->dimension_identifier[j] = gf_bs_read_u8(bs);\n\t\t}\n\t\tgf_list_add(ptr->dependency_layers, dep);\n\t}\n\n\treturn GF_OK;\n}", "target": 1, "idx": 11013}
{"commit_id": "7e112c1563632f57cfa1c4fa964987f823da17fa", "project": "chromium", "func": "void FillFormField(const FormFieldData& data,\n                   bool is_initiating_node,\n                   blink::WebFormControlElement* field) {\n  // Nothing to fill.\n  if (data.value.empty())\n    return;\n\n  if (!data.is_autofilled)\n    return;\n\n  WebInputElement* input_element = toWebInputElement(field);\n  if (IsCheckableElement(input_element)) {\n    input_element->setChecked(data.is_checked, true);\n  } else {\n    base::string16 value = data.value;\n    if (IsTextInput(input_element) || IsMonthInput(input_element)) {\n      // If the maxlength attribute contains a negative value, maxLength()\n      // returns the default maxlength value.\n      TruncateString(&value, input_element->maxLength());\n    }\n    field->setValue(value, true);\n  }\n  // Setting the form might trigger JavaScript, which is capable of\n  // destroying the frame.\n  if (!field->document().frame())\n    return;\n\n  field->setAutofilled(true);\n\n  if (is_initiating_node &&\n      ((IsTextInput(input_element) || IsMonthInput(input_element)) ||\n       IsTextAreaElement(*field))) {\n    int length = field->value().length();\n    field->setSelectionRange(length, length);\n    // Clear the current IME composition (the underline), if there is one.\n    field->document().frame()->unmarkText();\n  }\n}", "target": 2, "idx": 11014}
{"commit_id": "415b73b1a400a994a86e6f29709aa0271e895dd5", "project": "chromium", "func": "bool SetProperty(v8::Isolate* isolate,\n                 v8::Local<v8::Object> object,\n                 KeyType key,\n                 v8::Local<v8::Value> value) {\n  auto maybe =\n      object->DefineOwnProperty(isolate->GetCurrentContext(), key, value);\n  return !maybe.IsNothing() && maybe.FromJust();\n}", "target": 2, "idx": 11015}
{"commit_id": "e07c8b4784234383cb5ddcf1133ea91a772506e2", "project": "poppler", "func": "void GfxColorSpace::setDisplayProfileName(GooString *name) {\n  if (displayProfile != nullptr) {\n    error(errInternal, -1, \"The display color profile can only be set before any rendering is done.\");\n    return;\n  }\n  delete displayProfileName;\n  displayProfileName = name->copy();\n}", "target": 1, "idx": 11016}
{"commit_id": "e84d8353f1347e1f26f0a95770d92ba14e6ede38", "project": "admesh", "func": "void\nstl_update_connects_remove_1(stl_file *stl, int facet_num) {\n  int j;\n\n  if (\n    stl->error ||\n    facet_num < 0\n  ) return;\n\n  /* Update list of connected edges */\n  j = ((stl->neighbors_start[facet_num].neighbor[0] == -1) +\n       (stl->neighbors_start[facet_num].neighbor[1] == -1) +\n       (stl->neighbors_start[facet_num].neighbor[2] == -1));\n  if(j == 0) {\t\t       /* Facet has 3 neighbors */\n    stl->stats.connected_facets_3_edge -= 1;\n  } else if(j == 1) {\t     /* Facet has 2 neighbors */\n    stl->stats.connected_facets_2_edge -= 1;\n  } else if(j == 2) {\t     /* Facet has 1 neighbor  */\n    stl->stats.connected_facets_1_edge -= 1;\n  }\n}", "target": 2, "idx": 11017}
{"commit_id": "3ce424e45411cf5a13105e0386b6ecf6eeb4f66f", "project": "torvalds/linux", "func": "static void vmx_set_msr_bitmap(struct kvm_vcpu *vcpu)\n{\n\tunsigned long *msr_bitmap;\n\n\tif (is_guest_mode(vcpu))\n\t\tmsr_bitmap = vmx_msr_bitmap_nested;\n\telse if (cpu_has_secondary_exec_ctrls() &&\n\t\t (vmcs_read32(SECONDARY_VM_EXEC_CONTROL) &\n\t\t  SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE)) {\n\t\tif (is_long_mode(vcpu))\n\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode_x2apic;\n\t\telse\n\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy_x2apic;\n\t} else {\n\t\tif (is_long_mode(vcpu))\n\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode;\n\t\telse\n\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy;\n\t}\n\n\tvmcs_write64(MSR_BITMAP, __pa(msr_bitmap));\n}", "target": 2, "idx": 11018}
{"commit_id": "ce07d891a0891d3c0d0c2d73d577490486b809e1", "project": "torvalds/linux", "func": "static void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n{\n\tLIST_HEAD(tmp_list);\n\tstruct mount *p;\n\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_mount_unlock(mnt);\n\n\t/* Gather the mounts to umount */\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tp->mnt.mnt_flags |= MNT_UMOUNT;\n\t\tlist_move(&p->mnt_list, &tmp_list);\n\t}\n\n\t/* Hide the mounts from mnt_mounts */\n\tlist_for_each_entry(p, &tmp_list, mnt_list) {\n\t\tlist_del_init(&p->mnt_child);\n\t}\n\n\t/* Add propogated mounts to the tmp_list */\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_umount(&tmp_list);\n\n\twhile (!list_empty(&tmp_list)) {\n\t\tbool disconnect;\n\t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n\t\tlist_del_init(&p->mnt_expire);\n\t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n\t\tif (how & UMOUNT_SYNC)\n\t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\n\t\tdisconnect = !IS_MNT_LOCKED_AND_LAZY(p);\n\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,\n\t\t\t\t disconnect ? &unmounted : NULL);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tif (!disconnect) {\n\t\t\t\t/* Don't forget about p */\n\t\t\t\tlist_add_tail(&p->mnt_child, &p->mnt_parent->mnt_mounts);\n\t\t\t} else {\n\t\t\t\tumount_mnt(p);\n\t\t\t}\n\t\t}\n\t\tchange_mnt_propagation(p, MS_PRIVATE);\n\t}\n}", "target": 1, "idx": 11019}
{"commit_id": "17743798d81238ab13050e8e2833699b54e15467", "project": "torvalds/linux", "func": "static int hugetlb_sysctl_handler_common(bool obey_mempolicy,\n\t\t\t struct ctl_table *table, int write,\n\t\t\t void *buffer, size_t *length, loff_t *ppos)\n{\n\tstruct hstate *h = &default_hstate;\n\tunsigned long tmp = h->max_huge_pages;\n\tint ret;\n\n\tif (!hugepages_supported())\n\t\treturn -EOPNOTSUPP;\n\n\tret = proc_hugetlb_doulongvec_minmax(table, write, buffer, length, ppos,\n\t\t\t\t\t     &tmp);\n\tif (ret)\n\t\tgoto out;\n\n\tif (write)\n\t\tret = __nr_hugepages_store_common(obey_mempolicy, h,\n\t\t\t\t\t\t  NUMA_NO_NODE, tmp, *length);\nout:\n\treturn ret;\n}", "target": 1, "idx": 11020}
{"commit_id": "8f87c7c03da55f9c79bd92e67fa2c94b2a7ce5cf", "project": "OpenSIPS/opensips", "func": "static int stream_process(struct sip_msg * msg, struct sdp_stream_cell *cell,\n\t\t\tstr * s, str* ss, regex_t* re, int op,int description)\n{\n\tstatic sdp_payload_attr_t static_payloads[] = {\n\t/* as per http://www.iana.org/assignments/rtp-parameters/rtp-parameters.xml */\n\t{ NULL,0,{ \"0\",1},{\"PCMU\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /* 0 - PCMU/8000  */\n\t{ NULL,0,{ \"3\",1},{ \"GSM\",3},{ \"8000\",4},{NULL,0},{NULL,0} },   /* 3 -  GSM/8000  */\n\t{ NULL,0,{ \"4\",1},{\"G723\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /* 4 - G723/8000  */\n\t{ NULL,0,{ \"5\",1},{\"DVI4\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /* 5 - DVI4/8000  */\n\t{ NULL,0,{ \"6\",1},{\"DVI4\",4},{\"16000\",5},{NULL,0},{NULL,0} },   /* 6 - DVI4/16000 */\n\t{ NULL,0,{ \"7\",1},{ \"LPC\",3},{ \"8000\",4},{NULL,0},{NULL,0} },   /* 7 -  LPC/8000  */\n\t{ NULL,0,{ \"8\",1},{\"PCMA\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /* 8 - PCMA/8000  */\n\t{ NULL,0,{ \"9\",1},{\"G722\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /* 9 - G722/8000  */\n\t{ NULL,0,{\"10\",2},{ \"L16\",3},{\"44100\",5},{NULL,0},{NULL,0} },   /*10 -  L16/44100 */\n\t{ NULL,0,{\"11\",2},{ \"L16\",3},{\"44100\",5},{NULL,0},{NULL,0} },   /*11 -  L16/44100 */\n\t{ NULL,0,{\"12\",2},{\"QCELP\",5},{\"8000\",4},{NULL,0},{NULL,0} },   /*12 -QCELP/8000  */\n\t{ NULL,0,{\"13\",2},{  \"CN\",2},{ \"8000\",4},{NULL,0},{NULL,0} },   /*13 -   CN/8000  */\n\t{ NULL,0,{\"14\",2},{ \"MPA\",3},{\"90000\",5},{NULL,0},{NULL,0} },   /*14 -  MPA/90000 */\n\t{ NULL,0,{\"15\",2},{\"G728\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /*15 - G728/8000  */\n\t{ NULL,0,{\"16\",2},{\"DVI4\",4},{\"11025\",5},{NULL,0},{NULL,0} },   /*16 - DVI4/11025 */\n\t{ NULL,0,{\"17\",2},{\"DVI4\",4},{\"22050\",5},{NULL,0},{NULL,0} },   /*17 - DVI4/22050 */\n\t{ NULL,0,{\"18\",2},{\"G729\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /*18 - G729/8000  */\n\t{ NULL,0,{\"25\",2},{\"CelB\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /*25 - CelB/8000  */\n\t{ NULL,0,{\"26\",2},{\"JPEG\",4},{\"90000\",5},{NULL,0},{NULL,0} },   /*26 - JPEG/90000 */\n\t{ NULL,0,{\"28\",2},{  \"nv\",2},{\"90000\",5},{NULL,0},{NULL,0} },   /*28 -   nv/90000 */\n\t{ NULL,0,{\"31\",2},{\"H261\",4},{\"90000\",5},{NULL,0},{NULL,0} },   /*31 - H261/90000 */\n\t{ NULL,0,{\"32\",2},{ \"MPV\",3},{\"90000\",5},{NULL,0},{NULL,0} },   /*32 -  MPV/90000 */\n\t{ NULL,0,{\"33\",2},{\"MP2T\",4},{\"90000\",5},{NULL,0},{NULL,0} },   /*33 - MP2T/90000 */\n\t{ NULL,0,{\"34\",2},{\"H263\",4},{\"90000\",5},{NULL,0},{NULL,0} },   /*34 - H263/90000 */\n\t{ NULL,0,{\"t38\",3},{\"t38\",3},{     \"\",0},{NULL,0},{NULL,0} },   /*T38- fax        */\n\t{ NULL,0,{NULL,0},{  NULL,0},{   NULL,0},{NULL,0},{NULL,0} }\n\t};\n\tsdp_payload_attr_t *payload;\n\tchar *cur, *tmp, *buff, temp;\n\tstruct lump * lmp;\n\tstr found;\n\tint ret, i,match, buff_len, is_static;\n\tregmatch_t pmatch;\n\n\n\tlmp = get_associated_lump(msg, cell);\n\tif( lmp == NULL)\n\t{\n\t\tLM_ERR(\"There is no lump for this sdp cell\\n\");\n\t\treturn -1;\n\t}\n\n\t/* is stream deleted ?? */\n\tif (lmp->len == 0)\n\t\treturn -1;\n\n\n\tbuff_len = 0;\n\tret = 0;\n\n\tbuff = pkg_malloc(lmp->len+1);\n\tif( buff == NULL)\n\t{\n\t\tLM_ERR(\"Out of memory\\n\");\n\t\treturn -1;\n\t}\n\n\t/* search through each payload */\n\tis_static = 0;\n\tpayload = cell->payload_attr;\n\n\twhile(payload)\n\t{\n\t\tif( payload->rtp_enc.s == NULL\n\t\t || (payload->rtp_clock.s == NULL && ss != NULL)\n\t\t || payload->rtp_payload.s == NULL)\n\t\t{\n\t\t\tgoto next_payload;\n\t\t}\n\n\t\tmatch = 0;\n\n\t\tif( description == DESC_REGEXP ||description == DESC_REGEXP_COMPLEMENT )\n\t\t{\n\t\t\t/* try to match a regexp */\n\t\t\tif (is_static) {\n\t\t\t\tmatch = regexec( re, payload->rtp_enc.s, 1, &pmatch, 0) == 0;\n\t\t\t} else {\n\t\t\t\ttemp = payload->rtp_enc.s[payload->rtp_enc.len];\n\t\t\t\tpayload->rtp_enc.s[payload->rtp_enc.len] = 0;\n\t\t\t\tmatch = regexec( re, payload->rtp_enc.s, 1, &pmatch, 0) == 0;\n\t\t\t\tpayload->rtp_enc.s[payload->rtp_enc.len] = temp;\n\t\t\t}\n\t\t}\n\n\t\tif( description == DESC_REGEXP_COMPLEMENT)\n\t\t\tmatch = !match;\n\n\t\tif( description == DESC_NAME  )\n\t\t{\n\t\t\tmatch = s->len == payload->rtp_enc.len &&\n\t\t\tstrncasecmp( s->s, payload->rtp_enc.s ,\tpayload->rtp_enc.len) == 0;\n\t\t}\n\n\t\tif( description == DESC_NAME_AND_CLOCK)\n\t\t{\n\t\t\t/* try to match name and clock if there is one */\n\t\t\tmatch = s->len == payload->rtp_enc.len &&\n\t\t\tstrncasecmp( s->s, payload->rtp_enc.s ,\n\t\t\t\tpayload->rtp_enc.len) == 0\n\t\t\t&&\n\t\t\t(ss == NULL || ( ss->len == payload->rtp_clock.len &&\n\t\t\tstrncasecmp( ss->s, payload->rtp_clock.s ,\n\t\t\t\tpayload->rtp_clock.len) == 0\n\t\t\t) );\n\t\t}\n\n\t\t/* if found, search its index in the m= line */\n\t\tif (match) {\n\n\t\t\tmatch = 0;\n\n\t\t\tcur = lmp->u.value;\n\t\t\twhile( !match && cur < lmp->u.value + lmp->len)\n\t\t\t{\n\t\t\t\t/* find the end of the number */\n\t\t\t\tfound.s = cur;\n\n\t\t\t\twhile(  cur < lmp->u.value + lmp->len &&  *cur != ' ' )\n\t\t\t\t\tcur++;\n\n\t\t\t\tfound.len = cur - found.s;\n\n\t\t\t\t/* does it matches payload number */\n\t\t\t\tif ( found.len == payload->rtp_payload.len &&\n\t\t\t\tstrncmp( found.s,payload->rtp_payload.s,found.len) == 0) {\n\t\t\t\t\tmatch = 1;\n\t\t\t\t} else {\n\t\t\t\t\t/* continue on searching => skip spaces\n\t\t\t\t\t   if there still are any */\n\t\t\t\t\twhile( cur < lmp->u.value + lmp->len && * cur == ' '  )\n\t\t\t\t\t\tcur++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* have we found both payload and index */\n\t\t\tif (match) {\n\n\t\t\t\tif(op == FIND)\n\t\t\t\t{\n\t\t\t\t\tret = 1;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\t\tif( op == DELETE && !is_static )\n\t\t\t\t{\n\t\t\t\t\t/* find the full 'a=...' entry */\n\n\t\t\t\t\tif( delete_sdp_line( msg, payload->rtp_enc.s, cell) < 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tLM_ERR(\"Unable to add delete lump for a=\\n\");\n\t\t\t\t\t\tret = -1;\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\n\t\t\t\t\tif( delete_sdp_line( msg, payload->fmtp_string.s, cell) < 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tLM_ERR(\"Unable to add delete lump for a=\\n\");\n\t\t\t\t\t\tret = -1;\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t{\n\t\t\t\t\t/* take the previous whitespaces as well */\n\t\t\t\t\twhile (found.s > lmp->u.value && *(found.s - 1) == ' ') {\n\t\t\t\t\t\tfound.s--;\n\t\t\t\t\t\tfound.len++;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* when trimming the very last payload, avoid trailing ws */\n\t\t\t\t\tif (cur == lmp->u.value + lmp->len) {\n\t\t\t\t\t\ttmp = found.s;\n\t\t\t\t\t\twhile (*(--tmp) == ' ') {\n\t\t\t\t\t\t\tfound.s--;\n\t\t\t\t\t\t\tfound.len++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* delete the string and update iterators */\n\t\t\t\t\tfor(tmp=found.s ; tmp< lmp->u.value + lmp->len ; tmp++ )\n\t\t\t\t\t\t*tmp  = *(tmp+found.len);\n\n\t\t\t\t\t//cur -= found.len;\n\t\t\t\t\tlmp->len -= found.len;\n\t\t\t\t}\n\n\t\t\t\t/* add the deleted number into a buffer to be addded later */\n\t\t\t\tif( op == ADD_TO_FRONT  || op == ADD_TO_BACK)\n\t\t\t\t{\n\t\t\t\t\tmemcpy(&buff[buff_len],\" \",1);\n\t\t\t\t\tbuff_len++;\n\n\t\t\t\t\tmemcpy(&buff[buff_len],payload->rtp_payload.s,\n\t\t\t\t\t\tpayload->rtp_payload.len);\n\n\t\t\t\t\tbuff_len += payload->rtp_payload.len;\n\t\t\t\t}\n\n\t\t\t\tret = 1;\n\t\t\t}\n\n\t\t}\n\n\t\t/* next payload */\n\tnext_payload:\n\t\tif (!is_static) {\n\t\t\tpayload = payload->next;\n\t\t\tif (payload==NULL) {\n\t\t\t\tpayload = static_payloads;\n\t\t\t\tis_static = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tpayload ++;\n\t\t\tif (payload->rtp_payload.s==NULL)\n\t\t\t\tpayload=NULL;\n\t\t}\n\t}\n\n\n\tif( op == ADD_TO_FRONT && buff_len >0 )\n\t{\n\t\tlmp->u.value = (char*)pkg_realloc(lmp->u.value, lmp->len+buff_len);\n\t\tif(!lmp->u.value) {\n\t\t\tLM_ERR(\"No more pkg memory\\n\");\n\t\t\tret = -1;\n\t\t\tgoto end;\n\t\t}\n\n\t\tfor( i = lmp->len -1 ; i>=0;i--)\n\t\t\tlmp->u.value[i+buff_len] = lmp->u.value[i];\n\n\t\tmemcpy(lmp->u.value,buff,buff_len);\n\n\t\tlmp->len += buff_len;\n\n\t}\n\n\tif( op == ADD_TO_BACK && buff_len >0 )\n\t{\n\n\t\tlmp->u.value = (char*)pkg_realloc(lmp->u.value, lmp->len+buff_len);\n\t\tif(!lmp->u.value) {\n\t\t\tLM_ERR(\"No more pkg memory\\n\");\n\t\t\tret = -1;\n\t\t\tgoto end;\n\t\t}\n\n\t\tmemcpy(&lmp->u.value[lmp->len],buff,buff_len);\n\n\t\tlmp->len += buff_len;\n\n\t}\n\n\t/* if we ended up with a 0-length lump, then it means that all payloads\n\t * have been deleted, therefore we need to disable the media stream */\n\tif (lmp->len == 0) {\n\t\t/* replace the media port with 0 - we also replace the spaces before\n\t\t * and after the port, to make sure we have a larger buffer */\n\t\tlmp = del_lump(msg, cell->port.s - msg->buf - 1, cell->port.len + 2, 0);\n\t\tif (!lmp) {\n\t\t\tLM_ERR(\"could not add lump to disable stream!\\n\");\n\t\t\tgoto end;\n\t\t}\n\t\ttmp = pkg_malloc(3);\n\t\tif (!tmp) {\n\t\t\tLM_ERR(\"oom for port 0\\n\");\n\t\t\tgoto end;\n\t\t}\n\t\tmemcpy(tmp, \" 0 \", 3);\n\t\tif (!insert_new_lump_after(lmp, tmp, 3, 0))\n\t\t\tLM_ERR(\"could not insert lump to disable stream!\\n\");\n\t}\n\nend:\n\tpkg_free(buff);\n\treturn ret;\n}", "target": 2, "idx": 11021}
{"commit_id": "cf801a25074f76dc3ae62d8ec53ace75f56ce2cd", "project": "wireshark", "func": "static int\ndissect_ldss_transfer (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\n{\n\tconversation_t *transfer_conv;\n\tldss_transfer_info_t *transfer_info;\n\tstruct tcpinfo *transfer_tcpinfo;\n\tproto_tree *ti, *line_tree = NULL, *ldss_tree = NULL;\n\tnstime_t broadcast_response_time;\n\n\t/* Reject the packet if data is NULL */\n\tif (data == NULL)\n\t\treturn 0;\n\ttransfer_tcpinfo = (struct tcpinfo *)data;\n\n\tcol_set_str(pinfo->cinfo, COL_PROTOCOL, \"LDSS\");\n\n\t/* Look for the transfer conversation; this was created during\n\t * earlier broadcast dissection (see prepare_ldss_transfer_conv) */\n\ttransfer_conv = find_conversation (pinfo->num, &pinfo->src, &pinfo->dst,\n\t\t\t\t\t   PT_TCP, pinfo->srcport, pinfo->destport, 0);\n\tDISSECTOR_ASSERT(transfer_conv);\n\ttransfer_info = (ldss_transfer_info_t *)conversation_get_proto_data(transfer_conv, proto_ldss);\n\tDISSECTOR_ASSERT(transfer_info);\n\n\t/* For a pull, the first packet in the TCP connection is the file request.\n\t * First packet is identified by relative seq/ack numbers of 1.\n\t * File request only appears on a pull (triggered by an offer - see above\n\t * about broadcasts) */\n\tif (transfer_tcpinfo->seq == 1 &&\n\t    transfer_tcpinfo->lastackseq == 1 &&\n\t    transfer_info->broadcast->message_id == MESSAGE_ID_WILLSEND) {\n\t\t/* LDSS pull transfers look a lot like HTTP.\n\t\t * Sample request:\n\t\t * md5:01234567890123...\n\t\t * Size: 2550\n\t\t * Start: 0\n\t\t * Compression: 0\n\t\t * (remote end sends the file identified by the digest) */\n\t\tguint offset = 0;\n\n\t\tcol_set_str(pinfo->cinfo, COL_INFO, \"LDSS File Transfer (Requesting file - pull)\");\n\n\t\tif (transfer_info->req == NULL) {\n\t\t\ttransfer_info->req = wmem_new0(wmem_file_scope(), ldss_file_request_t);\n\t\t\ttransfer_info->req->file = wmem_new0(wmem_file_scope(), ldss_file_t);\n\t\t}\n\n\t\tti = proto_tree_add_item(tree, proto_ldss,\n\t\t\t\ttvb, 0, tvb_reported_length(tvb), ENC_NA);\n\t\tldss_tree = proto_item_add_subtree(ti, ett_ldss_transfer);\n\n\t\t/* Populate digest data into the file struct in the request */\n\t\ttransfer_info->file = transfer_info->req->file;\n\n\t\t/* Grab each line from the packet, there should be 4 but lets\n\t\t * not walk off the end looking for more. */\n\t\twhile (tvb_offset_exists(tvb, offset)) {\n\t\t\tgint next_offset;\n\t\t\tconst guint8 *line;\n\t\t\tint linelen;\n\t\t\tguint digest_type_len = 0;\n\n\t\t\tlinelen = tvb_find_line_end(tvb, offset, -1, &next_offset, FALSE);\n\n\t\t\t/* Include new-line in line */\n\t\t\tline = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, linelen, ENC_ASCII);\n\n\t\t\tline_tree = proto_tree_add_subtree(ldss_tree, tvb, offset, linelen,\n\t\t\t\t\t\t\t ett_ldss_transfer_req, NULL,\n\t\t\t\t\t\t\t tvb_format_text(tvb, offset, next_offset-offset));\n\n\t\t\tif (strncmp(line,\"md5:\",4)==0) {\n\t\t\t\tdigest_type_len = 4;\n\t\t\t\ttransfer_info->file->digest_type = DIGEST_TYPE_MD5;\n\t\t\t}\n\t\t\telse if (strncmp(line, \"sha1:\", 5)==0) {\n\t\t\t\tdigest_type_len = 5;\n\t\t\t\ttransfer_info->file->digest_type = DIGEST_TYPE_SHA1;\n\t\t\t}\n\t\t\telse if (strncmp(line, \"sha256:\", 7)==0) {\n\t\t\t\tdigest_type_len = 7;\n\t\t\t\ttransfer_info->file->digest_type = DIGEST_TYPE_SHA256;\n\t\t\t}\n\t\t\telse if (strncmp(line, \"unknown:\", 8)==0) {\n\t\t\t\tdigest_type_len = 8;\n\t\t\t\ttransfer_info->file->digest_type = DIGEST_TYPE_UNKNOWN;\n\t\t\t}\n\t\t\telse if (strncmp(line, \"Size: \", 6)==0) {\n\t\t\t\t/* Sample size line:\n\t\t\t\t * Size: 2550\\n */\n\t\t\t\ttransfer_info->req->size = g_ascii_strtoull(line+6, NULL, 10);\n\t\t\t\tti = proto_tree_add_uint64(line_tree, hf_ldss_size,\n\t\t\t\t\t\ttvb, offset+6, linelen-6, transfer_info->req->size);\n\t\t\t\tPROTO_ITEM_SET_GENERATED(ti);\n\t\t\t}\n\t\t\telse if (strncmp(line, \"Start: \", 7)==0) {\n\t\t\t\t/* Sample offset line:\n\t\t\t\t * Start: 0\\n */\n\t\t\t\ttransfer_info->req->offset = g_ascii_strtoull(line+7, NULL, 10);\n\t\t\t\tti = proto_tree_add_uint64(line_tree, hf_ldss_offset,\n\t\t\t\t\t\ttvb, offset+7, linelen-7, transfer_info->req->offset);\n\t\t\t\tPROTO_ITEM_SET_GENERATED(ti);\n\t\t\t}\n\t\t\telse if (strncmp(line, \"Compression: \", 13)==0) {\n\t\t\t\t/* Sample compression line:\n\t\t\t\t * Compression: 0\\n */\n\t\t\t\ttransfer_info->req->compression = (gint8)strtol(line+13, NULL, 10); /* XXX - bad cast */\n\t\t\t\tti = proto_tree_add_uint(line_tree, hf_ldss_compression,\n\t\t\t\t\t\ttvb, offset+13, linelen-13, transfer_info->req->compression);\n\t\t\t\tPROTO_ITEM_SET_GENERATED(ti);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tproto_tree_add_expert(line_tree, pinfo, &ei_ldss_unrecognized_line, tvb, offset, linelen);\n\t\t\t}\n\n\t\t\tif (digest_type_len > 0) {\n\t\t\t\tproto_item *tii = NULL;\n\n\t\t\t\t/* Sample digest-type/digest line:\n\t\t\t\t * md5:0123456789ABCDEF\\n */\n\t\t\t\tif (!transfer_info->file->digest) {\n\t\t\t\t\tGByteArray *digest_bytes;\n\n\t\t\t\t\tdigest_bytes = g_byte_array_new();\n\t\t\t\t\thex_str_to_bytes(\n\t\t\t\t\t\t\ttvb_get_ptr(tvb, offset+digest_type_len, linelen-digest_type_len),\n\t\t\t\t\t\t\tdigest_bytes, FALSE);\n\n\t\t\t\t\tif(digest_bytes->len >= DIGEST_LEN)\n\t\t\t\t\t\tdigest_bytes->len = (DIGEST_LEN-1);\n\t\t\t\t\t/* Ensure the digest is zero-padded */\n\t\t\t\t\ttransfer_info->file->digest = (guint8 *)wmem_alloc0(wmem_file_scope(), DIGEST_LEN);\n\t\t\t\t\tmemcpy(transfer_info->file->digest, digest_bytes->data, digest_bytes->len);\n\n\t\t\t\t\tg_byte_array_free(digest_bytes, TRUE);\n\t\t\t\t}\n\n\t\t\t\ttii = proto_tree_add_uint(line_tree, hf_ldss_digest_type,\n\t\t\t\t\t\ttvb, offset, digest_type_len, transfer_info->file->digest_type);\n\t\t\t\tPROTO_ITEM_SET_GENERATED(tii);\n\t\t\t\ttii = proto_tree_add_bytes(line_tree, hf_ldss_digest,\n\t\t\t\t\t\ttvb, offset+digest_type_len, MIN(linelen-digest_type_len, DIGEST_LEN),\n\t\t\t\t\t\ttransfer_info->file->digest);\n\t\t\t\tPROTO_ITEM_SET_GENERATED(tii);\n\t\t\t}\n\n\t\t\toffset = next_offset;\n\t\t}\n\n\t\t/* Link forwards to the response for this pull. */\n\t\tif (transfer_info->resp_num != 0) {\n\t\t\tti = proto_tree_add_uint(ldss_tree, hf_ldss_response_in,\n\t\t\t\t\t\t tvb, 0, 0, transfer_info->resp_num);\n\t\t\tPROTO_ITEM_SET_GENERATED(ti);\n\t\t}\n\n\t\ttransfer_info->req->num = pinfo->num;\n\t\ttransfer_info->req->ts = pinfo->abs_ts;\n\t}\n\t/* Remaining packets are the file response */\n\telse {\n\t\tguint64 size;\n\t\tguint64 offset;\n\t\tguint8 compression;\n\n\t\t/* size, digest, compression come from the file request for a pull but\n\t\t * they come from the broadcast for a push. Pushes don't bother\n\t\t * with a file request - they just send the data. We have to get file\n\t\t * info from the offer broadcast which triggered this transfer.\n\t\t * If we cannot find the file request, default to the broadcast. */\n\t\tif (transfer_info->broadcast->message_id == MESSAGE_ID_WILLSEND &&\n\t\t    transfer_info->req != NULL) {\n\t\t\ttransfer_info->file = transfer_info->req->file;\n\t\t\tsize = transfer_info->req->size;\n\t\t\toffset = transfer_info->req->offset;\n\t\t\tcompression = transfer_info->req->compression;\n\t\t}\n\t\telse {\n\t\t\ttransfer_info->file = transfer_info->broadcast->file;\n\t\t\tsize = transfer_info->broadcast->size;\n\t\t\toffset = transfer_info->broadcast->offset;\n\t\t\tcompression = transfer_info->broadcast->compression;\n\t\t}\n\n\t\t/* Remaining data in this TCP connection is all file data.\n\t\t * Always desegment if the size is 0 (ie. unknown)\n\t\t */\n\t\tif (pinfo->can_desegment) {\n\t\t\tif (size == 0 || tvb_captured_length(tvb) < size) {\n\t\t\t\tpinfo->desegment_offset = 0;\n\t\t\t\tpinfo->desegment_len = DESEGMENT_UNTIL_FIN;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\t/* OK. Now we have the whole file that was transferred. */\n\t\ttransfer_info->resp_num = pinfo->num;\n\t\ttransfer_info->resp_ts = pinfo->abs_ts;\n\n\t\tcol_add_fstr(pinfo->cinfo, COL_INFO, \"LDSS File Transfer (Sending file - %s)\",\n\t\t\t\t     transfer_info->broadcast->message_id == MESSAGE_ID_WILLSEND\n\t\t\t\t     ? \"pull\"\n\t\t\t\t     : \"push\");\n\n\t\tti = proto_tree_add_item(tree, proto_ldss,\n\t\t\t\ttvb, 0, tvb_reported_length(tvb), ENC_NA);\n\t\tldss_tree = proto_item_add_subtree(ti, ett_ldss_transfer);\n\t\tproto_tree_add_bytes_format(ldss_tree, hf_ldss_file_data,\n\t\t\t\ttvb, 0, tvb_captured_length(tvb), NULL,\n\t\t\t\tcompression == COMPRESSION_GZIP\n\t\t\t\t? \"Gzip compressed data: %d bytes\"\n\t\t\t\t: \"File data: %d bytes\",\n\t\t\t\ttvb_captured_length(tvb));\n#ifdef HAVE_ZLIB\n\t\t/* Be nice and uncompress the file data. */\n\t\tif (compression == COMPRESSION_GZIP) {\n\t\t\ttvbuff_t *uncomp_tvb;\n\t\t\tuncomp_tvb = tvb_child_uncompress(tvb, tvb, 0, tvb_captured_length(tvb));\n\t\t\tif (uncomp_tvb != NULL) {\n\t\t\t\t/* XXX: Maybe not a good idea to add a data_source for\n\t\t\t\t   what may very well be a large buffer since then\n\t\t\t\t   the full uncompressed buffer will be shown in a tab\n\t\t\t\t   in the hex bytes pane ?\n\t\t\t\t   However, if we don't, bytes in an unrelated tab will\n\t\t\t\t   be highlighted.\n\t\t\t\t */\n\t\t\t\tadd_new_data_source(pinfo, uncomp_tvb, \"Uncompressed Data\");\n\t\t\t\tproto_tree_add_bytes_format_value(ldss_tree, hf_ldss_file_data,\n\t\t\t\t\t\tuncomp_tvb, 0, tvb_captured_length(uncomp_tvb),\n\t\t\t\t\t\tNULL, \"Uncompressed data: %d bytes\",\n\t\t\t\t\t\ttvb_captured_length(uncomp_tvb));\n\t\t\t}\n\t\t}\n#endif\n\t\tti = proto_tree_add_uint(ldss_tree, hf_ldss_digest_type,\n\t\t\t\ttvb, 0, 0, transfer_info->file->digest_type);\n\t\tPROTO_ITEM_SET_GENERATED(ti);\n\t\tif (transfer_info->file->digest != NULL) {\n\t\t\t/* This is ugly. You can't add bytes of nonzero length and have\n\t\t\t * filtering work correctly unless you give a valid location in\n\t\t\t * the packet. This hack pretends the first 32 bytes of the packet\n\t\t\t * are the digest, which they aren't: they're actually the first 32\n\t\t\t * bytes of the file that was sent. */\n\t\t\tti = proto_tree_add_bytes(ldss_tree, hf_ldss_digest,\n\t\t\t\t\ttvb, 0, DIGEST_LEN, transfer_info->file->digest);\n\t\t}\n\t\tPROTO_ITEM_SET_GENERATED(ti);\n\t\tti = proto_tree_add_uint64(ldss_tree, hf_ldss_size,\n\t\t\t\ttvb, 0, 0, size);\n\t\tPROTO_ITEM_SET_GENERATED(ti);\n\t\tti = proto_tree_add_uint64(ldss_tree, hf_ldss_offset,\n\t\t\t\ttvb, 0, 0, offset);\n\t\tPROTO_ITEM_SET_GENERATED(ti);\n\t\tti = proto_tree_add_uint(ldss_tree, hf_ldss_compression,\n\t\t\t\ttvb, 0, 0, compression);\n\t\tPROTO_ITEM_SET_GENERATED(ti);\n\t\t/* Link to the request for a pull. */\n\t\tif (transfer_info->broadcast->message_id == MESSAGE_ID_WILLSEND &&\n\t\t\t\ttransfer_info->req != NULL &&\n\t\t\t\ttransfer_info->req->num != 0) {\n\t\t\tti = proto_tree_add_uint(ldss_tree, hf_ldss_response_to,\n\t\t\t\t\ttvb, 0, 0, transfer_info->req->num);\n\t\t\tPROTO_ITEM_SET_GENERATED(ti);\n\t\t}\n\t}\n\n\t/* Print the pull response time */\n\tif (transfer_info->broadcast->message_id == MESSAGE_ID_WILLSEND &&\n\t    transfer_info->req != NULL &&\n\t    transfer_info->resp_num != 0) {\n\t\tnstime_t pull_response_time;\n\t\tnstime_delta(&pull_response_time, &transfer_info->resp_ts,\n\t\t\t     &transfer_info->req->ts);\n\t\tti = proto_tree_add_time(ldss_tree, hf_ldss_transfer_response_time,\n\t\t\t\t\t tvb, 0, 0, &pull_response_time);\n\t\tPROTO_ITEM_SET_GENERATED(ti);\n\t}\n\n\t/* Link the transfer back to the initiating broadcast. Response time is\n\t * calculated as the time from broadcast to completed transfer. */\n\tti = proto_tree_add_uint(ldss_tree, hf_ldss_initiated_by,\n\t\t\t\t tvb, 0, 0, transfer_info->broadcast->num);\n\tPROTO_ITEM_SET_GENERATED(ti);\n\n\tif (transfer_info->resp_num != 0) {\n\t\tnstime_delta(&broadcast_response_time, &transfer_info->resp_ts,\n\t\t\t     &transfer_info->broadcast->ts);\n\t\tti = proto_tree_add_time(ldss_tree, hf_ldss_transfer_completed_in,\n\t\t\t\t\t tvb, 0, 0, &broadcast_response_time);\n\t\tPROTO_ITEM_SET_GENERATED(ti);\n\t}\n\n\t/* This conv got its addr2/port2 set by the TCP dissector because a TCP\n\t * connection was established. Make a new one to handle future connections\n\t * to the addr/port mentioned in the broadcast, because that socket is\n\t * still open. */\n\tif (transfer_tcpinfo->seq == 1 &&\n\t    transfer_tcpinfo->lastackseq == 1) {\n\n\t\tprepare_ldss_transfer_conv(transfer_info->broadcast);\n\t}\n\n\treturn tvb_captured_length(tvb);\n}", "target": 2, "idx": 11022}
{"commit_id": "37d7c953fead2b9ffe168fc6ac38c92b602773d8", "project": "jerryscript-project/jerryscript", "func": "ecma_value_t\nopfunc_private_set (ecma_value_t base, /**< this object */\n                    ecma_value_t property, /**< property name */\n                    ecma_value_t value) /**< ecma value */\n{\n  ecma_value_t base_obj = ecma_op_to_object (base);\n\n  if (ECMA_IS_VALUE_ERROR (base_obj))\n  {\n    return base_obj;\n  }\n\n  ecma_object_t *obj_p = ecma_get_object_from_value (base_obj);\n  ecma_string_t *prop_name_p = ecma_get_string_from_value (property);\n  ecma_string_t *private_key_p = NULL;\n\n  ecma_property_t *prop_p = opfunc_find_private_element (obj_p, prop_name_p, &private_key_p, true);\n\n  ecma_value_t result;\n\n  if (prop_p == NULL)\n  {\n    result = ecma_raise_type_error (ECMA_ERR_CANNOT_WRITE_PRIVATE_MEMBER_TO_AN_OBJECT_WHOSE_CLASS_DID_NOT_DECLARE_IT);\n  }\n  else if (*prop_p & ECMA_PROPERTY_FLAG_DATA)\n  {\n    JERRY_ASSERT (ecma_prop_name_is_symbol (private_key_p));\n\n    if (private_key_p->u.hash & ECMA_SYMBOL_FLAG_PRIVATE_INSTANCE_METHOD)\n    {\n      result = ecma_raise_type_error (ECMA_ERR_PRIVATE_METHOD_IS_NOT_WRITABLE);\n    }\n    else\n    {\n      ecma_value_assign_value (&ECMA_PROPERTY_VALUE_PTR (prop_p)->value, value);\n      result = ecma_copy_value (value);\n    }\n  }\n  else\n  {\n    ecma_getter_setter_pointers_t *get_set_pair_p = ecma_get_named_accessor_property (ECMA_PROPERTY_VALUE_PTR (prop_p));\n\n    if (get_set_pair_p->setter_cp == JMEM_CP_NULL)\n    {\n      result = ecma_raise_type_error (ECMA_ERR_PRIVATE_FIELD_WAS_DEFINED_WITHOUT_A_SETTER);\n    }\n    else\n    {\n      ecma_object_t *setter_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->setter_cp);\n\n      result = ecma_op_function_call (setter_p, base, &value, 1);\n    }\n  }\n\n  ecma_deref_object (obj_p);\n\n  return result;\n}", "target": 1, "idx": 11023}
{"commit_id": "07dbcc3d9644b18e05c1776db2a57fe04d780965", "project": "weidai11/cryptopp", "func": "bool Inflator::DecodeBody()\n{\n\tbool blockEnd = false;\n\tswitch (m_blockType)\n\t{\n\tcase 0:\t// stored\n\t\tCRYPTOPP_ASSERT(m_reader.BitsBuffered() == 0);\n\t\twhile (!m_inQueue.IsEmpty() && !blockEnd)\n\t\t{\n\t\t\tsize_t size;\n\t\t\tconst byte *block = m_inQueue.Spy(size);\n\t\t\tsize = UnsignedMin(m_storedLen, size);\n\t\t\tCRYPTOPP_ASSERT(size <= 0xffff);\n\n\t\t\tOutputString(block, size);\n\t\t\tm_inQueue.Skip(size);\n\t\t\tm_storedLen = m_storedLen - (word16)size;\n\t\t\tif (m_storedLen == 0)\n\t\t\t\tblockEnd = true;\n\t\t}\n\t\tbreak;\n\tcase 1:\t// fixed codes\n\tcase 2:\t// dynamic codes\n\t\tstatic const unsigned int lengthStarts[] = {\n\t\t\t3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n\t\t\t35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258};\n\t\tstatic const unsigned int lengthExtraBits[] = {\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,\n\t\t\t3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0};\n\t\tstatic const unsigned int distanceStarts[] = {\n\t\t\t1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n\t\t\t257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n\t\t\t8193, 12289, 16385, 24577};\n\t\tstatic const unsigned int distanceExtraBits[] = {\n\t\t\t0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,\n\t\t\t7, 7, 8, 8, 9, 9, 10, 10, 11, 11,\n\t\t\t12, 12, 13, 13};\n\n\t\tconst HuffmanDecoder& literalDecoder = GetLiteralDecoder();\n\t\tconst HuffmanDecoder& distanceDecoder = GetDistanceDecoder();\n\n\t\tswitch (m_nextDecode)\n\t\t{\n\t\tcase LITERAL:\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tif (!literalDecoder.Decode(m_reader, m_literal))\n\t\t\t\t{\n\t\t\t\t\tm_nextDecode = LITERAL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (m_literal < 256)\n\t\t\t\t\tOutputByte((byte)m_literal);\n\t\t\t\telse if (m_literal == 256)\t// end of block\n\t\t\t\t{\n\t\t\t\t\tblockEnd = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (m_literal > 285)\n\t\t\t\t\t\tthrow BadBlockErr();\n\t\t\t\t\tunsigned int bits;\n\t\tcase LENGTH_BITS:\n\t\t\t\t\tbits = lengthExtraBits[m_literal-257];\n\t\t\t\t\tif (!m_reader.FillBuffer(bits))\n\t\t\t\t\t{\n\t\t\t\t\t\tm_nextDecode = LENGTH_BITS;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tm_literal = m_reader.GetBits(bits) + lengthStarts[m_literal-257];\n\t\tcase DISTANCE:\n\t\t\t\t\tif (!distanceDecoder.Decode(m_reader, m_distance))\n\t\t\t\t\t{\n\t\t\t\t\t\tm_nextDecode = DISTANCE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\tcase DISTANCE_BITS:\n\t\t\t\t\t// TODO: this surfaced during fuzzing. What do we do???\n\t\t\t\t\tCRYPTOPP_ASSERT(m_distance < COUNTOF(distanceExtraBits));\n\t\t\t\t\tif (m_distance >= COUNTOF(distanceExtraBits))\n\t\t\t\t\t\tthrow BadDistanceErr();\n\t\t\t\t\tbits = distanceExtraBits[m_distance];\n\t\t\t\t\tif (!m_reader.FillBuffer(bits))\n\t\t\t\t\t{\n\t\t\t\t\t\tm_nextDecode = DISTANCE_BITS;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// TODO: this surfaced during fuzzing. What do we do???\n\t\t\t\t\tCRYPTOPP_ASSERT(m_distance < COUNTOF(distanceStarts));\n\t\t\t\t\tif (m_distance >= COUNTOF(distanceStarts))\n\t\t\t\t\t\tthrow BadDistanceErr();\n\t\t\t\t\tm_distance = m_reader.GetBits(bits) + distanceStarts[m_distance];\n\t\t\t\t\tOutputPast(m_literal, m_distance);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tCRYPTOPP_ASSERT(0);\n\t\t}\n\t}\n\tif (blockEnd)\n\t{\n\t\tif (m_eof)\n\t\t{\n\t\t\tFlushOutput();\n\t\t\tm_reader.SkipBits(m_reader.BitsBuffered()%8);\n\t\t\tif (m_reader.BitsBuffered())\n\t\t\t{\n\t\t\t\t// undo too much lookahead\n\t\t\t\tSecBlockWithHint<byte, 4> buffer(m_reader.BitsBuffered() / 8);\n\t\t\t\tfor (unsigned int i=0; i<buffer.size(); i++)\n\t\t\t\t\tbuffer[i] = (byte)m_reader.GetBits(8);\n\t\t\t\tm_inQueue.Unget(buffer, buffer.size());\n\t\t\t}\n\t\t\tm_state = POST_STREAM;\n\t\t}\n\t\telse\n\t\t\tm_state = WAIT_HEADER;\n\t}\n\treturn blockEnd;\n}", "target": 1, "idx": 11024}
{"commit_id": "fcd3b30552bf03a384b1a16f9bb8db029c111356", "project": "KDE/discover", "func": "QString KNSResource::longDescription()\n{\n    QString ret = m_entry.summary();\n    if (m_entry.shortSummary().isEmpty()) {\n        const int newLine = ret.indexOf(QLatin1Char('\\n'));\n        if (newLine<0)\n            ret.clear();\n        else\n            ret = ret.mid(newLine+1).trimmed();\n    }\n    ret.remove(QLatin1Char('\\r'));\n    ret.replace(QStringLiteral(\"[li]\"), QStringLiteral(\"\\n* \"));\n    // Get rid of all BBCode markup we don't handle above\n    ret.remove(QRegularExpression(QStringLiteral(\"\\\\[\\\\/?[a-z]*\\\\]\")));\n    // Find anything that looks like a link (but which also is not some html\n    // tag value or another already) and make it a link\n    static const QRegularExpression urlRegExp(QStringLiteral(\"(^|\\\\s)(http[-a-zA-Z0-9@:%_\\\\+.~#?&//=]{2,256}\\\\.[a-z]{2,4}\\\\b(\\\\/[-a-zA-Z0-9@:;%_\\\\+.~#?&//=]*)?)\"), QRegularExpression::CaseInsensitiveOption);\n    ret.replace(urlRegExp, QStringLiteral(\"<a href=\\\"\\\\2\\\">\\\\2</a>\"));\n    return ret;\n}", "target": 2, "idx": 11025}
{"commit_id": "ca2a5ac02fbbadd0a21fabba779c1ea69173d10b", "project": "LibVNC/libvncserver", "func": "void\nHandleFileDownloadCancelRequest(rfbClientPtr cl, rfbTightClientPtr rtcp)\n{\n\tint n = 0;\n\tchar *reason = NULL;\n\trfbClientToServerTightMsg msg;\n\n\tmemset(&msg, 0, sizeof(rfbClientToServerTightMsg));\n\t\n\tif((n = rfbReadExact(cl, ((char *)&msg)+1, sz_rfbFileDownloadCancelMsg-1)) <= 0) {\n\t\t\n\t\tif (n < 0)\n\t\t\trfbLog(\"File [%s]: Method [%s]: Error while reading \"\n\t\t\t\t\t\"FileDownloadCancelMsg\\n\", __FILE__, __FUNCTION__);\n\t\t\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\n\tmsg.fdc.reasonLen = Swap16IfLE(msg.fdc.reasonLen);\n\n\tif(msg.fdc.reasonLen == 0) {\n\t\trfbLog(\"File [%s]: Method [%s]: reason length received is Zero\\n\",\n\t\t\t\t__FILE__, __FUNCTION__);\n\t\treturn;\n\t}\n\t\n\treason = (char*) calloc(msg.fdc.reasonLen + 1, sizeof(char));\n\tif(reason == NULL) {\n\t\trfbLog(\"File [%s]: Method [%s]: Fatal Error: Memory alloc failed\\n\", \n\t\t\t\t__FILE__, __FUNCTION__);\n\t\treturn;\n\t}\n\n\tif((n = rfbReadExact(cl, reason, msg.fdc.reasonLen)) <= 0) {\n\t\t\n\t\tif (n < 0)\n\t\t\trfbLog(\"File [%s]: Method [%s]: Error while reading \"\n\t\t\t\t\t\"FileDownloadCancelMsg\\n\", __FILE__, __FUNCTION__);\n\t\t\n\t    rfbCloseClient(cl);\n\t    free(reason);\n\t    return;\n\t}\n\n\trfbLog(\"File [%s]: Method [%s]: File Download Cancel Request received:\"\n\t\t\t\t\t\" reason <%s>\\n\", __FILE__, __FUNCTION__, reason);\n\t\n\tpthread_mutex_lock(&fileDownloadMutex);\n\tCloseUndoneFileTransfer(cl, rtcp);\n\tpthread_mutex_unlock(&fileDownloadMutex);\n\t\n\tif(reason != NULL) {\n\t\tfree(reason);\n\t\treason = NULL;\n\t}\n\n}", "target": 2, "idx": 11026}
{"commit_id": "7a4591fd4f065f4fa903593bc39b2f79530a74b8", "project": "tensorflow", "func": "void Compute(OpKernelContext* ctx) override {\n    const auto splits = ctx->input(0).flat<int64_t>();\n    const auto values = ctx->input(1).flat<Tidx>();\n    const Tensor& size_t = ctx->input(2);\n    const auto weights = ctx->input(3).flat<T>();\n    const int64_t weights_size = weights.size();\n\n    OP_REQUIRES(ctx, size_t.dims() == 0,\n                errors::InvalidArgument(\"Shape must be rank 0 but is rank \",\n                                        size_t.dims()));\n    Tidx size = size_t.scalar<Tidx>()();\n    OP_REQUIRES(\n        ctx, size >= 0,\n        errors::InvalidArgument(\"size (\", size, \") must be non-negative\"));\n\n    int num_rows = splits.size() - 1;\n    int num_values = values.size();\n    int batch_idx = 0;\n\n    OP_REQUIRES(ctx, splits.size() > 0,\n                errors::InvalidArgument(\"Splits must be non-empty\"));\n\n    OP_REQUIRES(ctx, splits(0) == 0,\n                errors::InvalidArgument(\"Splits must start with 0, not with \",\n                                        splits(0)));\n\n    OP_REQUIRES(ctx, splits(num_rows) == num_values,\n                errors::InvalidArgument(\n                    \"Splits must end with the number of values, got \",\n                    splits(num_rows), \" instead of \", num_values));\n\n    Tensor* out_t;\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_output(0, TensorShape({num_rows, size}), &out_t));\n    functor::SetZeroFunctor<Device, T> fill;\n    fill(ctx->eigen_device<Device>(), out_t->flat<T>());\n    const auto out = out_t->matrix<T>();\n\n    for (int idx = 0; idx < num_values; ++idx) {\n      while (idx >= splits(batch_idx)) {\n        batch_idx++;\n      }\n      Tidx bin = values(idx);\n      OP_REQUIRES(ctx, bin >= 0,\n                  errors::InvalidArgument(\"Input must be non-negative\"));\n      if (bin < size) {\n        if (binary_output_) {\n          out(batch_idx - 1, bin) = T(1);\n        } else {\n          T value = (weights_size > 0) ? weights(idx) : T(1);\n          out(batch_idx - 1, bin) += value;\n        }\n      }\n    }\n  }", "target": 1, "idx": 11027}
{"commit_id": "9e7695bbee18525eaa6d12b32230313ae8a36a81", "project": "wireshark", "func": "static guint16\ndissect_sccp_variable_parameter(tvbuff_t *tvb, packet_info *pinfo,\n                                proto_tree *sccp_tree, proto_tree *tree,\n                                guint8 parameter_type, int offset, sccp_decode_context_t* sccp_info)\n{\n  guint16     parameter_length;\n  guint8      length_length;\n  proto_item *pi;\n\n  if (parameter_type != PARAMETER_LONG_DATA) {\n    parameter_length = tvb_get_guint8(tvb, offset);\n    length_length = PARAMETER_LENGTH_LENGTH;\n  } else {\n    /* Long data parameter has 16 bit length */\n    parameter_length = tvb_get_letohs(tvb, offset);\n    length_length = PARAMETER_LONG_DATA_LENGTH_LENGTH;\n  }\n\n  pi = proto_tree_add_uint_format(sccp_tree, hf_sccp_param_length, tvb, offset,\n                                  length_length, parameter_length, \"%s length: %d\",\n                                  val_to_str(parameter_type, sccp_parameter_values,\n                                             \"Unknown: %d\"),\n                                  parameter_length);\n  if (!sccp_show_length) {\n    /* The user doesn't want to see it... */\n    PROTO_ITEM_SET_HIDDEN(pi);\n  }\n\n  offset += length_length;\n\n  dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree, parameter_type, offset,\n                         parameter_length, sccp_info);\n\n  return(parameter_length + length_length);\n}", "target": 2, "idx": 11028}
{"commit_id": "de5494af4815a4c9328536c72741229b7de88e7f", "project": "torvalds/linux", "func": "static int mbochs_probe(struct mdev_device *mdev)\n{\n\tint avail_mbytes = atomic_read(&mbochs_avail_mbytes);\n\tconst struct mbochs_type *type =\n\t\t&mbochs_types[mdev_get_type_group_id(mdev)];\n\tstruct device *dev = mdev_dev(mdev);\n\tstruct mdev_state *mdev_state;\n\tint ret = -ENOMEM;\n\n\tdo {\n\t\tif (avail_mbytes < type->mbytes)\n\t\t\treturn -ENOSPC;\n\t} while (!atomic_try_cmpxchg(&mbochs_avail_mbytes, &avail_mbytes,\n\t\t\t\t     avail_mbytes - type->mbytes));\n\n\tmdev_state = kzalloc(sizeof(struct mdev_state), GFP_KERNEL);\n\tif (mdev_state == NULL)\n\t\tgoto err_avail;\n\tvfio_init_group_dev(&mdev_state->vdev, &mdev->dev, &mbochs_dev_ops);\n\n\tmdev_state->vconfig = kzalloc(MBOCHS_CONFIG_SPACE_SIZE, GFP_KERNEL);\n\tif (mdev_state->vconfig == NULL)\n\t\tgoto err_mem;\n\n\tmdev_state->memsize = type->mbytes * 1024 * 1024;\n\tmdev_state->pagecount = mdev_state->memsize >> PAGE_SHIFT;\n\tmdev_state->pages = kcalloc(mdev_state->pagecount,\n\t\t\t\t    sizeof(struct page *),\n\t\t\t\t    GFP_KERNEL);\n\tif (!mdev_state->pages)\n\t\tgoto err_mem;\n\n\tdev_info(dev, \"%s: %s, %d MB, %ld pages\\n\", __func__,\n\t\t type->name, type->mbytes, mdev_state->pagecount);\n\n\tmutex_init(&mdev_state->ops_lock);\n\tmdev_state->mdev = mdev;\n\tINIT_LIST_HEAD(&mdev_state->dmabufs);\n\tmdev_state->next_id = 1;\n\n\tmdev_state->type = type;\n\tmdev_state->edid_regs.max_xres = type->max_x;\n\tmdev_state->edid_regs.max_yres = type->max_y;\n\tmdev_state->edid_regs.edid_offset = MBOCHS_EDID_BLOB_OFFSET;\n\tmdev_state->edid_regs.edid_max_size = sizeof(mdev_state->edid_blob);\n\tmbochs_create_config_space(mdev_state);\n\tmbochs_reset(mdev_state);\n\n\tret = vfio_register_group_dev(&mdev_state->vdev);\n\tif (ret)\n\t\tgoto err_mem;\n\tdev_set_drvdata(&mdev->dev, mdev_state);\n\treturn 0;\nerr_mem:\n\tkfree(mdev_state->pages);\n\tkfree(mdev_state->vconfig);\n\tkfree(mdev_state);\nerr_avail:\n\tatomic_add(type->mbytes, &mbochs_avail_mbytes);\n\treturn ret;\n}", "target": 1, "idx": 11029}
{"commit_id": "5d88cd89795352b5df54cc0ebb6a0076b8c89ee4", "project": "danfruehauf/NetworkManager-ssh", "func": "static gboolean\nexport (NMVpnEditorPlugin *iface,\n        const char *path,\n        NMConnection *connection,\n        GError **error)\n{\n\tNMSettingConnection *s_con;\n\tNMSettingVpn *s_vpn;\n\tFILE *f;\n\tconst char *value;\n\tconst char *auth_type = NULL;\n\tconst char *key_file = NULL;\n\tconst char *gateway = NULL;\n\tconst char *port = NULL;\n\tconst char *local_ip = NULL;\n\tconst char *remote_ip = NULL;\n\tconst char *netmask = NULL;\n\tconst char *local_ip_6 = NULL;\n\tconst char *remote_ip_6 = NULL;\n\tconst char *netmask_6 = NULL;\n\tconst char *remote_dev = NULL;\n\tconst char *mtu = NULL;\n\tconst char *remote_username = NULL;\n\tchar *device_type = NULL;\n\tchar *tunnel_type = NULL;\n\tchar *ifconfig_cmd_local_6 = NULL;\n\tchar *ifconfig_cmd_remote_6 = NULL;\n\tchar *preferred_authentication = NULL;\n\tunsigned password_prompt_nr = 0;\n\tgboolean ipv6 = FALSE;\n\tgboolean success = FALSE;\n\n\ts_con = NM_SETTING_CONNECTION (nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION));\n\tg_assert (s_con);\n\n\ts_vpn = (NMSettingVpn *) nm_connection_get_setting (connection, NM_TYPE_SETTING_VPN);\n\n\tf = fopen (path, \"w\");\n\tif (!f) {\n\t\tg_set_error (error, 0, 0, \"could not open file for writing\");\n\t\treturn FALSE;\n\t}\n\n\tvalue = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_REMOTE);\n\tif (value && strlen (value))\n\t\tgateway = value;\n\telse {\n\t\tg_set_error (error, 0, 0, \"connection was incomplete (missing gateway)\");\n\t\tgoto done;\n\t}\n\n\tvalue = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_REMOTE_IP);\n\tif (value && strlen (value))\n\t\tremote_ip = value;\n\telse {\n\t\tg_set_error (error, 0, 0, \"connection was incomplete (missing remote IP)\");\n\t\tgoto done;\n\t}\n\n\tvalue = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_LOCAL_IP);\n\tif (value && strlen (value))\n\t\tlocal_ip = value;\n\telse {\n\t\tg_set_error (error, 0, 0, \"connection was incomplete (missing local IP)\");\n\t\tgoto done;\n\t}\n\n\tvalue = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_NETMASK);\n\tif (value && strlen (value))\n\t\tnetmask = value;\n\telse {\n\t\tg_set_error (error, 0, 0, \"connection was incomplete (missing netmask)\");\n\t\tgoto done;\n\t}\n\n\t/* Auth type */\n\tauth_type = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_AUTH_TYPE);\n\tif (auth_type) {\n\t\tif (!strncmp (auth_type, NM_SSH_AUTH_TYPE_PASSWORD, strlen(NM_SSH_AUTH_TYPE_PASSWORD))) {\n\t\t\tpassword_prompt_nr = 1;\n\t\t\tpreferred_authentication = g_strdup(\"password\");\n\t\t} else if (!strncmp (auth_type, NM_SSH_AUTH_TYPE_KEY, strlen(NM_SSH_AUTH_TYPE_KEY))) {\n\t\t\tkey_file = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_KEY_FILE);\n\t\t\tpreferred_authentication = g_strdup(\"publickey\");\n\t\t} else { // (!strncmp (auth_type, NM_SSH_AUTH_TYPE_SSH_AGENT, strlen(NM_SSH_AUTH_TYPE_SSH_AGENT))) {\n\t\t\t// Nothing to be done for ssh-agent, the wise choice...\n\t\t\tpreferred_authentication = g_strdup(\"publickey\");\n\t\t}\n\t}\n\t/* Auth type */\n\n\t/* Advanced values start */\n\tvalue = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_PORT);\n\tif (value && strlen (value))\n\t\tport = value;\n\telse\n\t\tport = g_strdup_printf(\"%d\", NM_SSH_DEFAULT_PORT);\n\n\tvalue = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_TUNNEL_MTU);\n\tif (value && strlen (value))\n\t\tmtu = value;\n\telse\n\t\tmtu = g_strdup_printf(\"%d\", NM_SSH_DEFAULT_MTU);\n\n\tvalue = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_REMOTE_DEV);\n\tif (value && strlen (value))\n\t\tremote_dev = value;\n\telse\n\t\tremote_dev = g_strdup_printf(\"%d\", NM_SSH_DEFAULT_REMOTE_DEV);\n\n\tvalue = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_REMOTE_USERNAME);\n\tif (value && strlen (value))\n\t\tremote_username = value;\n\telse\n\t\tremote_username = g_strdup(NM_SSH_DEFAULT_REMOTE_USERNAME);\n\n\tvalue = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_TAP_DEV);\n\tif (value && IS_YES(value)) {\n\t\tdevice_type = g_strdup(\"tap\");\n\t\ttunnel_type = g_strdup(\"ethernet\");\n\t} else {\n\t\tdevice_type = g_strdup(\"tun\");\n\t\ttunnel_type = g_strdup(\"point-to-point\");\n\t}\n\n\tvalue = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_IP_6);\n\tif (value && IS_YES(value)) {\n\t\tipv6 = TRUE;\n\n\t\tvalue = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_REMOTE_IP_6);\n\t\tif (value && strlen (value))\n\t\t\tremote_ip_6 = value;\n\t\telse {\n\t\t\tg_set_error (error, 0, 0, \"connection was incomplete (missing IPv6 remote IP)\");\n\t\t\tgoto done;\n\t\t}\n\t\n\t\tvalue = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_LOCAL_IP_6);\n\t\tif (value && strlen (value))\n\t\t\tlocal_ip_6 = value;\n\t\telse {\n\t\t\tg_set_error (error, 0, 0, \"connection was incomplete (missing IPv6 local IP)\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tvalue = nm_setting_vpn_get_data_item (s_vpn, NM_SSH_KEY_NETMASK_6);\n\t\tif (value && strlen (value))\n\t\t\tnetmask_6 = value;\n\t\telse {\n\t\t\tg_set_error (error, 0, 0, \"connection was incomplete (missing IPv6 netmask)\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tifconfig_cmd_local_6 = g_strdup_printf(\"%s $DEV_TYPE$LOCAL_DEV add $LOCAL_IP_6/$NETMASK_6\", IFCONFIG);\n\t\tifconfig_cmd_remote_6 = g_strdup_printf(\"%s $DEV_TYPE$REMOTE_DEV add $REMOTE_IP_6/$NETMASK_6\", IFCONFIG);\n\t} else {\n\t\tipv6 = FALSE;\n\t\tifconfig_cmd_local_6 = g_strdup(\"\");\n\t\tifconfig_cmd_remote_6 = g_strdup(\"\");\n\t}\n\n\t/* Advanced values end */\n\n\t/* Serialize everything to a file */\n\tfprintf (f, \"#!/bin/bash\\n\");\n\t/* Make my life easier and just add the AUTH_TYPE= key, not used though */\n\tfprintf (f, \"%s=%s\\n\", AUTH_TYPE_KEY, auth_type);\n\tif (key_file) {\n\t\tfprintf (f, \"%s=%s\\n\", KEY_FILE_KEY, key_file);\n\t}\n\tfprintf (f, \"%s=%s\\n\", REMOTE_KEY, gateway);\n\tfprintf (f, \"%s=%s\\n\", REMOTE_USERNAME_KEY, remote_username);\n\tfprintf (f, \"%s=%s\\n\", REMOTE_IP_KEY, remote_ip);\n\tfprintf (f, \"%s=%s\\n\", LOCAL_IP_KEY, local_ip);\n\tfprintf (f, \"%s=%s\\n\", NETMASK_KEY, netmask);\n\tif (ipv6) {\n\t\tfprintf (f, \"%s=%s\\n\", IP_6_KEY, YES);\n\t\tfprintf (f, \"%s=%s\\n\", REMOTE_IP_6_KEY, remote_ip_6);\n\t\tfprintf (f, \"%s=%s\\n\", LOCAL_IP_6_KEY, local_ip_6);\n\t\tfprintf (f, \"%s=%s\\n\", NETMASK_6_KEY, netmask_6);\n\t}\n\tfprintf (f, \"%s=%s\\n\", PORT_KEY, port);\n\tfprintf (f, \"%s=%s\\n\", MTU_KEY, mtu);\n\tfprintf (f, \"%s=%s\\n\", REMOTE_DEV_KEY, remote_dev);\n\n\t/* Assign tun/tap */\n\tfprintf (f, \"%s=%s\\n\", DEV_TYPE_KEY, device_type);\n\tfprintf (f, \"%s=%s\\n\", TUNNEL_TYPE_KEY, tunnel_type);\n\n\t/* Add a little of bash script to probe for a free tun/tap device */\n\tfprintf (f, \"for i in `seq 0 255`; do ! %s $DEV_TYPE$i >& /dev/null && LOCAL_DEV=$i && break; done\", IFCONFIG);\n\n\t/* The generic lines that will perform the connection */\n\tfprintf (f, \"\\n\");\n\tfprintf(f, \"ssh -f %s -o PreferredAuthentications=%s -o NumberOfPasswordPrompts=%d -o Tunnel=$TUNNEL_TYPE -o ServerAliveInterval=10 -o TCPKeepAlive=yes -o TunnelDevice=$LOCAL_DEV:$REMOTE_DEV -o User=$REMOTE_USERNAME -o Port=$PORT -o HostName=$REMOTE $REMOTE \\\"%s $DEV_TYPE$REMOTE_DEV $REMOTE_IP netmask $NETMASK pointopoint $LOCAL_IP; %s\\\" && \\\\\\n\",\n\t\t(key_file ? g_strconcat(\"-i \", key_file, NULL) : \"\"),\n\t\tpreferred_authentication,\n\t\tpassword_prompt_nr,\n\t\tIFCONFIG,\n\t\tifconfig_cmd_remote_6);\n\tfprintf(f, \"%s $DEV_TYPE$LOCAL_DEV $LOCAL_IP netmask $NETMASK pointopoint $REMOTE_IP; %s\\n\", IFCONFIG, ifconfig_cmd_local_6);\n\n\tsuccess = TRUE;\n\n\tg_free(device_type);\n\tg_free(tunnel_type);\n\tg_free(ifconfig_cmd_local_6);\n\tg_free(ifconfig_cmd_remote_6);\n\tg_free(preferred_authentication);\n\ndone:\n\tfclose (f);\n\treturn success;\n}", "target": 3, "idx": 11030}
{"commit_id": "b45cb1b665a14b0175b9cb1502ef7168e1fe0d5d", "project": "jsummers/imageworsener", "func": "static void iwjpeg_scan_exif_ifd(struct iwjpegrcontext *rctx,\n\tstruct iw_exif_state *e, iw_uint32 ifd)\n{\n\tunsigned int tag_count;\n\tunsigned int i;\n\tunsigned int tag_pos;\n\tunsigned int tag_id;\n\tunsigned int v;\n\tdouble v_dbl;\n\n\tif(ifd<8 || e->d_len<18 || ifd>e->d_len-18) return;\n\n\ttag_count = get_exif_ui16(e, ifd);\n\tif(tag_count>1000) return; // Sanity check.\n\n\tfor(i=0;i<tag_count;i++) {\n\t\ttag_pos = ifd+2+i*12;\n\t\tif(tag_pos+12 > e->d_len) return; // Avoid overruns.\n\t\ttag_id = get_exif_ui16(e, tag_pos);\n\n\t\tswitch(tag_id) {\n\t\tcase 274: // 274 = Orientation\n\t\t\tif(get_exif_tag_int_value(e,tag_pos,&v)) {\n\t\t\t\trctx->exif_orientation = v;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 296: // 296 = ResolutionUnit\n\t\t\tif(get_exif_tag_int_value(e,tag_pos,&v)) {\n\t\t\t\trctx->exif_density_unit = v;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 282: // 282 = XResolution\n\t\t\tif(get_exif_tag_dbl_value(e,tag_pos,&v_dbl)) {\n\t\t\t\trctx->exif_density_x = v_dbl;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 283: // 283 = YResolution\n\t\t\tif(get_exif_tag_dbl_value(e,tag_pos,&v_dbl)) {\n\t\t\t\trctx->exif_density_y = v_dbl;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}", "target": 1, "idx": 11031}
{"commit_id": "8de9e376ce531fe7f3c8b0aa4876d15b479b7311", "project": "znc", "func": "ModHandle CModules::OpenModule(const CString& sModule, const CString& sModPath,\n                               CModInfo& Info, CString& sRetMsg) {\n    // Some sane defaults in case anything errors out below\n    sRetMsg.clear();\n\n    if (!ValidateModuleName(sModule, sRetMsg)) {\n        return nullptr;\n    }\n\n    // The second argument to dlopen() has a long history. It seems clear\n    // that (despite what the man page says) we must include either of\n    // RTLD_NOW and RTLD_LAZY and either of RTLD_GLOBAL and RTLD_LOCAL.\n    //\n    // RTLD_NOW vs. RTLD_LAZY: We use RTLD_NOW to avoid ZNC dying due to\n    // failed symbol lookups later on. Doesn't really seem to have much of a\n    // performance impact.\n    //\n    // RTLD_GLOBAL vs. RTLD_LOCAL: If perl is loaded with RTLD_LOCAL and later\n    // on loads own modules (which it apparently does with RTLD_LAZY), we will\n    // die in a name lookup since one of perl's symbols isn't found. That's\n    // worse than any theoretical issue with RTLD_GLOBAL.\n    ModHandle p = dlopen((sModPath).c_str(), RTLD_NOW | RTLD_GLOBAL);\n\n    if (!p) {\n        // dlerror() returns pointer to static buffer, which may be overwritten\n        // very soon with another dl call also it may just return null.\n        const char* cDlError = dlerror();\n        CString sDlError = cDlError ? cDlError : t_s(\"Unknown error\");\n        sRetMsg = t_f(\"Unable to open module {1}: {2}\")(sModule, sDlError);\n        return nullptr;\n    }\n\n    const CModuleEntry* (*fpZNCModuleEntry)() = nullptr;\n    // man dlsym(3) explains this\n    *reinterpret_cast<void**>(&fpZNCModuleEntry) = dlsym(p, \"ZNCModuleEntry\");\n    if (!fpZNCModuleEntry) {\n        dlclose(p);\n        sRetMsg = t_f(\"Could not find ZNCModuleEntry in module {1}\")(sModule);\n        return nullptr;\n    }\n    const CModuleEntry* pModuleEntry = fpZNCModuleEntry();\n\n    if (std::strcmp(pModuleEntry->pcVersion, VERSION_STR) ||\n        std::strcmp(pModuleEntry->pcVersionExtra, VERSION_EXTRA)) {\n        sRetMsg = t_f(\n            \"Version mismatch for module {1}: core is {2}, module is built for \"\n            \"{3}. Recompile this module.\")(\n            sModule, VERSION_STR VERSION_EXTRA,\n            CString(pModuleEntry->pcVersion) + pModuleEntry->pcVersionExtra);\n        dlclose(p);\n        return nullptr;\n    }\n\n    if (std::strcmp(pModuleEntry->pcCompileOptions,\n                    ZNC_COMPILE_OPTIONS_STRING)) {\n        sRetMsg = t_f(\n            \"Module {1} is built incompatibly: core is '{2}', module is '{3}'. \"\n            \"Recompile this module.\")(sModule, ZNC_COMPILE_OPTIONS_STRING,\n                                      pModuleEntry->pcCompileOptions);\n        dlclose(p);\n        return nullptr;\n    }\n\n    CTranslationDomainRefHolder translation(\"znc-\" + sModule);\n    pModuleEntry->fpFillModInfo(Info);\n\n    sRetMsg = \"\";\n    return p;\n}", "target": 2, "idx": 11032}
{"commit_id": "360e95d45ac4123255a4c796db96337f332160ad", "project": "OpenSC", "func": "static int sc_pkcs15emu_sc_hsm_init (sc_pkcs15_card_t * p15card)\n{\n\tsc_card_t *card = p15card->card;\n\tsc_hsm_private_data_t *priv = (sc_hsm_private_data_t *) card->drv_data;\n\tsc_file_t *file = NULL;\n\tsc_path_t path;\n\tu8 filelist[MAX_EXT_APDU_LENGTH];\n\tint filelistlength;\n\tint r, i;\n\tsc_cvc_t devcert;\n\tstruct sc_app_info *appinfo;\n\tstruct sc_pkcs15_auth_info pin_info;\n\tstruct sc_pkcs15_object pin_obj;\n\tstruct sc_pin_cmd_data pindata;\n\tu8 efbin[1024];\n\tu8 *ptr;\n\tsize_t len;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tappinfo = calloc(1, sizeof(struct sc_app_info));\n\n\tif (appinfo == NULL) {\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\n\tappinfo->aid = sc_hsm_aid;\n\n\tappinfo->ddo.aid = sc_hsm_aid;\n\tp15card->app = appinfo;\n\n\tsc_path_set(&path, SC_PATH_TYPE_DF_NAME, sc_hsm_aid.value, sc_hsm_aid.len, 0, 0);\n\tr = sc_select_file(card, &path, &file);\n\tLOG_TEST_RET(card->ctx, r, \"Could not select SmartCard-HSM application\");\n\n\tp15card->card->version.hw_major = 24;\t/* JCOP 2.4.1r3 */\n\tp15card->card->version.hw_minor = 13;\n\tif (file && file->prop_attr && file->prop_attr_len >= 2) {\n\t\tp15card->card->version.fw_major = file->prop_attr[file->prop_attr_len - 2];\n\t\tp15card->card->version.fw_minor = file->prop_attr[file->prop_attr_len - 1];\n\t}\n\n\tsc_file_free(file);\n\n\t/* Read device certificate to determine serial number */\n\tif (priv->EF_C_DevAut && priv->EF_C_DevAut_len) {\n\t\tptr = priv->EF_C_DevAut;\n\t\tlen = priv->EF_C_DevAut_len;\n\t} else {\n\t\tlen = sizeof efbin;\n\t\tr = read_file(p15card, (u8 *) \"\\x2F\\x02\", efbin, &len, 1);\n\t\tLOG_TEST_RET(card->ctx, r, \"Skipping optional EF.C_DevAut\");\n\n\t\tif (len > 0) {\n\t\t\t/* save EF_C_DevAut for further use */\n\t\t\tptr = realloc(priv->EF_C_DevAut, len);\n\t\t\tif (ptr) {\n\t\t\t\tmemcpy(ptr, efbin, len);\n\t\t\t\tpriv->EF_C_DevAut = ptr;\n\t\t\t\tpriv->EF_C_DevAut_len = len;\n\t\t\t}\n\t\t}\n\n\t\tptr = efbin;\n\t}\n\n\tmemset(&devcert, 0 ,sizeof(devcert));\n\tr = sc_pkcs15emu_sc_hsm_decode_cvc(p15card, (const u8 **)&ptr, &len, &devcert);\n\tLOG_TEST_RET(card->ctx, r, \"Could not decode EF.C_DevAut\");\n\n\tsc_pkcs15emu_sc_hsm_read_tokeninfo(p15card);\n\n\tif (p15card->tokeninfo->label == NULL) {\n\t\tif (p15card->card->type == SC_CARD_TYPE_SC_HSM_GOID\n\t\t\t\t|| p15card->card->type == SC_CARD_TYPE_SC_HSM_SOC) {\n\t\t\tp15card->tokeninfo->label = strdup(\"GoID\");\n\t\t} else {\n\t\t\tp15card->tokeninfo->label = strdup(\"SmartCard-HSM\");\n\t\t}\n\t\tif (p15card->tokeninfo->label == NULL)\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\n\tif ((p15card->tokeninfo->manufacturer_id != NULL) && !strcmp(\"(unknown)\", p15card->tokeninfo->manufacturer_id)) {\n\t\tfree(p15card->tokeninfo->manufacturer_id);\n\t\tp15card->tokeninfo->manufacturer_id = NULL;\n\t}\n\n\tif (p15card->tokeninfo->manufacturer_id == NULL) {\n\t\tif (p15card->card->type == SC_CARD_TYPE_SC_HSM_GOID\n\t\t\t\t|| p15card->card->type == SC_CARD_TYPE_SC_HSM_SOC) {\n\t\t\tp15card->tokeninfo->manufacturer_id = strdup(\"Bundesdruckerei GmbH\");\n\t\t} else {\n\t\t\tp15card->tokeninfo->manufacturer_id = strdup(\"www.CardContact.de\");\n\t\t}\n\t\tif (p15card->tokeninfo->manufacturer_id == NULL)\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\n\tappinfo->label = strdup(p15card->tokeninfo->label);\n\tif (appinfo->label == NULL)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\n\tlen = strnlen(devcert.chr, sizeof devcert.chr);\t\t/* Strip last 5 digit sequence number from CHR */\n\tassert(len >= 8);\n\tlen -= 5;\n\n\tp15card->tokeninfo->serial_number = calloc(len + 1, 1);\n\tif (p15card->tokeninfo->serial_number == NULL)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\n\tmemcpy(p15card->tokeninfo->serial_number, devcert.chr, len);\n\t*(p15card->tokeninfo->serial_number + len) = 0;\n\n\tsc_hsm_set_serialnr(card, p15card->tokeninfo->serial_number);\n\n\tsc_pkcs15emu_sc_hsm_free_cvc(&devcert);\n\n\tmemset(&pin_info, 0, sizeof(pin_info));\n\tmemset(&pin_obj, 0, sizeof(pin_obj));\n\n\tpin_info.auth_id.len = 1;\n\tpin_info.auth_id.value[0] = 1;\n\tpin_info.path.aid = sc_hsm_aid;\n\tpin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;\n\tpin_info.attrs.pin.reference = 0x81;\n\tpin_info.attrs.pin.flags = SC_PKCS15_PIN_FLAG_LOCAL|SC_PKCS15_PIN_FLAG_INITIALIZED|SC_PKCS15_PIN_FLAG_EXCHANGE_REF_DATA;\n\tpin_info.attrs.pin.type = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;\n\tpin_info.attrs.pin.min_length = 6;\n\tpin_info.attrs.pin.stored_length = 0;\n\tpin_info.attrs.pin.max_length = 15;\n\tpin_info.attrs.pin.pad_char = '\\0';\n\tpin_info.tries_left = 3;\n\tpin_info.max_tries = 3;\n\n\tpin_obj.auth_id.len = 1;\n\tpin_obj.auth_id.value[0] = 2;\n\tstrlcpy(pin_obj.label, \"UserPIN\", sizeof(pin_obj.label));\n\tpin_obj.flags = SC_PKCS15_CO_FLAG_PRIVATE|SC_PKCS15_CO_FLAG_MODIFIABLE;\n\n\tr = sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);\n\tif (r < 0)\n\t\tLOG_FUNC_RETURN(card->ctx, r);\n\n\tmemset(&pin_info, 0, sizeof(pin_info));\n\tmemset(&pin_obj, 0, sizeof(pin_obj));\n\n\tpin_info.auth_id.len = 1;\n\tpin_info.auth_id.value[0] = 2;\n\tpin_info.path.aid = sc_hsm_aid;\n\tpin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;\n\tpin_info.attrs.pin.reference = 0x88;\n\tpin_info.attrs.pin.flags = SC_PKCS15_PIN_FLAG_LOCAL|SC_PKCS15_PIN_FLAG_INITIALIZED|SC_PKCS15_PIN_FLAG_UNBLOCK_DISABLED|SC_PKCS15_PIN_FLAG_SO_PIN;\n\tpin_info.attrs.pin.type = SC_PKCS15_PIN_TYPE_BCD;\n\tpin_info.attrs.pin.min_length = 16;\n\tpin_info.attrs.pin.stored_length = 0;\n\tpin_info.attrs.pin.max_length = 16;\n\tpin_info.attrs.pin.pad_char = '\\0';\n\tpin_info.tries_left = 15;\n\tpin_info.max_tries = 15;\n\n\tstrlcpy(pin_obj.label, \"SOPIN\", sizeof(pin_obj.label));\n\tpin_obj.flags = SC_PKCS15_CO_FLAG_PRIVATE;\n\n\tr = sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);\n\tif (r < 0)\n\t\tLOG_FUNC_RETURN(card->ctx, r);\n\n\n\tif (card->type == SC_CARD_TYPE_SC_HSM_SOC\n\t\t\t|| card->type == SC_CARD_TYPE_SC_HSM_GOID) {\n\t\t/* SC-HSM of this type always has a PIN-Pad */\n\t\tr = SC_SUCCESS;\n\t} else {\n\t\tmemset(&pindata, 0, sizeof(pindata));\n\t\tpindata.cmd = SC_PIN_CMD_GET_INFO;\n\t\tpindata.pin_type = SC_AC_CHV;\n\t\tpindata.pin_reference = 0x85;\n\n\t\tr = sc_pin_cmd(card, &pindata, NULL);\n\t}\n\tif (r == SC_ERROR_DATA_OBJECT_NOT_FOUND) {\n\t\tmemset(&pindata, 0, sizeof(pindata));\n\t\tpindata.cmd = SC_PIN_CMD_GET_INFO;\n\t\tpindata.pin_type = SC_AC_CHV;\n\t\tpindata.pin_reference = 0x86;\n\n\t\tr = sc_pin_cmd(card, &pindata, NULL);\n\t}\n\n\tif ((r != SC_ERROR_DATA_OBJECT_NOT_FOUND) && (r != SC_ERROR_INCORRECT_PARAMETERS))\n\t\tcard->caps |= SC_CARD_CAP_PROTECTED_AUTHENTICATION_PATH;\n\n\n\tfilelistlength = sc_list_files(card, filelist, sizeof(filelist));\n\tLOG_TEST_RET(card->ctx, filelistlength, \"Could not enumerate file and key identifier\");\n\n\tfor (i = 0; i < filelistlength; i += 2) {\n\t\tswitch(filelist[i]) {\n\t\tcase KEY_PREFIX:\n\t\t\tr = sc_pkcs15emu_sc_hsm_add_prkd(p15card, filelist[i + 1]);\n\t\t\tbreak;\n\t\tcase DCOD_PREFIX:\n\t\t\tr = sc_pkcs15emu_sc_hsm_add_dcod(p15card, filelist[i + 1]);\n\t\t\tbreak;\n\t\tcase CD_PREFIX:\n\t\t\tr = sc_pkcs15emu_sc_hsm_add_cd(p15card, filelist[i + 1]);\n\t\t\tbreak;\n\t\t}\n\t\tif (r != SC_SUCCESS) {\n\t\t\tsc_log(card->ctx, \"Error %d adding elements to framework\", r);\n\t\t}\n\t}\n\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}", "target": 1, "idx": 11033}
{"commit_id": "6a07c2156a07ef307b6dcf3c2ca8571a5f1af7a6", "project": "nginx/njs", "func": "njs_int_t\nnjs_function_lambda_call(njs_vm_t *vm, void *promise_cap, void *async_ctx)\n{\n    uint32_t               n;\n    njs_int_t              ret;\n    njs_frame_t            *frame;\n    njs_value_t            *args, **local, *value;\n    njs_value_t            **cur_local, **cur_closures, **cur_temp;\n    njs_function_t         *function;\n    njs_declaration_t      *declr;\n    njs_function_lambda_t  *lambda;\n\n    frame = (njs_frame_t *) vm->top_frame;\n    function = frame->native.function;\n\n    njs_assert(function->context == NULL);\n\n    if (function->global && !function->closure_copied) {\n        ret = njs_function_capture_global_closures(vm, function);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return NJS_ERROR;\n        }\n    }\n\n    lambda = function->u.lambda;\n\n    args = vm->top_frame->arguments;\n    local = vm->top_frame->local + function->args_offset;\n\n    /* Move all arguments. */\n\n    for (n = 0; n < function->args_count; n++) {\n        if (!njs_is_valid(args)) {\n            njs_set_undefined(args);\n        }\n\n        *local++ = args++;\n    }\n\n    /* Store current level. */\n\n    cur_local = vm->levels[NJS_LEVEL_LOCAL];\n    cur_closures = vm->levels[NJS_LEVEL_CLOSURE];\n    cur_temp = vm->levels[NJS_LEVEL_TEMP];\n\n    /* Replace current level. */\n\n    vm->levels[NJS_LEVEL_LOCAL] = vm->top_frame->local;\n    vm->levels[NJS_LEVEL_CLOSURE] = njs_function_closures(function);\n    vm->levels[NJS_LEVEL_TEMP] = frame->native.temp;\n\n    if (lambda->rest_parameters) {\n        ret = njs_function_rest_parameters_init(vm, &frame->native);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return NJS_ERROR;\n        }\n    }\n\n    /* Self */\n\n    if (lambda->self != NJS_INDEX_NONE) {\n        value = njs_scope_value(vm, lambda->self);\n\n        if (!njs_is_valid(value)) {\n            njs_set_function(value, function);\n        }\n    }\n\n    vm->active_frame = frame;\n\n    /* Closures */\n\n    n = lambda->ndeclarations;\n\n    while (n != 0) {\n        n--;\n\n        declr = &lambda->declarations[n];\n        value = njs_scope_value(vm, declr->index);\n\n        *value = *declr->value;\n\n        function = njs_function_value_copy(vm, value);\n        if (njs_slow_path(function == NULL)) {\n            return NJS_ERROR;\n        }\n\n        ret = njs_function_capture_closure(vm, function, function->u.lambda);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n    }\n\n    ret = njs_vmcode_interpreter(vm, lambda->start, promise_cap, async_ctx);\n\n    /* Restore current level. */\n    vm->levels[NJS_LEVEL_LOCAL] = cur_local;\n    vm->levels[NJS_LEVEL_CLOSURE] = cur_closures;\n    vm->levels[NJS_LEVEL_TEMP] = cur_temp;\n\n    return ret;\n}", "target": 3, "idx": 11034}
{"commit_id": "6b2bc41935e53b0034fe5948aeeab4f32e80f30f", "project": "FreeRDP", "func": "static BOOL update_read_icon_info(wStream* s, ICON_INFO* iconInfo)\n{\n\tBYTE* newBitMask;\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, iconInfo->cacheEntry); /* cacheEntry (2 bytes) */\n\tStream_Read_UINT8(s, iconInfo->cacheId);     /* cacheId (1 byte) */\n\tStream_Read_UINT8(s, iconInfo->bpp);         /* bpp (1 byte) */\n\n\tif ((iconInfo->bpp < 1) || (iconInfo->bpp > 32))\n\t{\n\t\tWLog_ERR(TAG, \"invalid bpp value %\" PRIu32 \"\", iconInfo->bpp);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, iconInfo->width);  /* width (2 bytes) */\n\tStream_Read_UINT16(s, iconInfo->height); /* height (2 bytes) */\n\n\t/* cbColorTable is only present when bpp is 1, 4 or 8 */\n\tswitch (iconInfo->bpp)\n\t{\n\t\tcase 1:\n\t\tcase 4:\n\t\tcase 8:\n\t\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\t\treturn FALSE;\n\n\t\t\tStream_Read_UINT16(s, iconInfo->cbColorTable); /* cbColorTable (2 bytes) */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\ticonInfo->cbColorTable = 0;\n\t\t\tbreak;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, iconInfo->cbBitsMask);  /* cbBitsMask (2 bytes) */\n\tStream_Read_UINT16(s, iconInfo->cbBitsColor); /* cbBitsColor (2 bytes) */\n\n\t/* bitsMask */\n\tnewBitMask = (BYTE*)realloc(iconInfo->bitsMask, iconInfo->cbBitsMask);\n\n\tif (!newBitMask)\n\t{\n\t\tfree(iconInfo->bitsMask);\n\t\ticonInfo->bitsMask = NULL;\n\t\treturn FALSE;\n\t}\n\n\ticonInfo->bitsMask = newBitMask;\n\tif (Stream_GetRemainingLength(s) < iconInfo->cbBitsMask)\n\t\treturn FALSE;\n\tStream_Read(s, iconInfo->bitsMask, iconInfo->cbBitsMask);\n\n\t/* colorTable */\n\tif (iconInfo->colorTable == NULL)\n\t{\n\t\tif (iconInfo->cbColorTable)\n\t\t{\n\t\t\ticonInfo->colorTable = (BYTE*)malloc(iconInfo->cbColorTable);\n\n\t\t\tif (!iconInfo->colorTable)\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\telse if (iconInfo->cbColorTable)\n\t{\n\t\tBYTE* new_tab;\n\t\tnew_tab = (BYTE*)realloc(iconInfo->colorTable, iconInfo->cbColorTable);\n\n\t\tif (!new_tab)\n\t\t{\n\t\t\tfree(iconInfo->colorTable);\n\t\t\ticonInfo->colorTable = NULL;\n\t\t\treturn FALSE;\n\t\t}\n\n\t\ticonInfo->colorTable = new_tab;\n\t}\n\telse\n\t{\n\t\tfree(iconInfo->colorTable);\n\t\ticonInfo->colorTable = NULL;\n\t}\n\n\tif (iconInfo->colorTable)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < iconInfo->cbColorTable)\n\t\t\treturn FALSE;\n\t\tStream_Read(s, iconInfo->colorTable, iconInfo->cbColorTable);\n\t}\n\n\t/* bitsColor */\n\tnewBitMask = (BYTE*)realloc(iconInfo->bitsColor, iconInfo->cbBitsColor);\n\n\tif (!newBitMask)\n\t{\n\t\tfree(iconInfo->bitsColor);\n\t\ticonInfo->bitsColor = NULL;\n\t\treturn FALSE;\n\t}\n\n\ticonInfo->bitsColor = newBitMask;\n\tif (Stream_GetRemainingLength(s) < iconInfo->cbBitsColor)\n\t\treturn FALSE;\n\tStream_Read(s, iconInfo->bitsColor, iconInfo->cbBitsColor);\n\treturn TRUE;\n}", "target": 1, "idx": 11035}
{"commit_id": "8fc52d77d6f66c438c98d536e2309b5fd13f90de", "project": "php/php-src", "func": "static void dom_load_html(INTERNAL_FUNCTION_PARAMETERS, int mode) /* {{{ */\n{\n\tzval *id;\n\txmlDoc *docp = NULL, *newdoc;\n\tdom_object *intern;\n\tdom_doc_propsptr doc_prop;\n\tchar *source;\n\tint source_len, refcount, ret;\n\tlong options = 0;\n\thtmlParserCtxtPtr ctxt;\n\n\tid = getThis();\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|l\", &source, &source_len, &options) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (!source_len) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Empty string supplied as input\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (mode == DOM_LOAD_FILE) {\n\t\tif (CHECK_NULL_PATH(source, source_len)) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid file source\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tctxt = htmlCreateFileParserCtxt(source, NULL);\n\t} else {\n\t\tsource_len = xmlStrlen(source);\n\t\tctxt = htmlCreateMemoryParserCtxt(source, source_len);\n\t}\n\n\tif (!ctxt) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (options) {\n\t\thtmlCtxtUseOptions(ctxt, options);\n\t}\n\n\tctxt->vctxt.error = php_libxml_ctx_error;\n\tctxt->vctxt.warning = php_libxml_ctx_warning;\n\tif (ctxt->sax != NULL) {\n\t\tctxt->sax->error = php_libxml_ctx_error;\n\t\tctxt->sax->warning = php_libxml_ctx_warning;\n\t}\n\thtmlParseDocument(ctxt);\n\tnewdoc = ctxt->myDoc;\n\thtmlFreeParserCtxt(ctxt);\n\n\tif (!newdoc)\n\t\tRETURN_FALSE;\n\n\tif (id != NULL && instanceof_function(Z_OBJCE_P(id), dom_document_class_entry TSRMLS_CC)) {\n\t\tintern = (dom_object *)zend_object_store_get_object(id TSRMLS_CC);\n\t\tif (intern != NULL) {\n\t\t\tdocp = (xmlDocPtr) dom_object_get_node(intern);\n\t\t\tdoc_prop = NULL;\n\t\t\tif (docp != NULL) {\n\t\t\t\tphp_libxml_decrement_node_ptr((php_libxml_node_object *) intern TSRMLS_CC);\n\t\t\t\tdoc_prop = intern->document->doc_props;\n\t\t\t\tintern->document->doc_props = NULL;\n\t\t\t\trefcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern TSRMLS_CC);\n\t\t\t\tif (refcount != 0) {\n\t\t\t\t\tdocp->_private = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tintern->document = NULL;\n\t\t\tif (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, newdoc TSRMLS_CC) == -1) {\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tintern->document->doc_props = doc_prop;\n\t\t}\n\n\t\tphp_libxml_increment_node_ptr((php_libxml_node_object *)intern, (xmlNodePtr)newdoc, (void *)intern TSRMLS_CC);\n\n\t\tRETURN_TRUE;\n\t} else {\n\t\tDOM_RET_OBJ((xmlNodePtr) newdoc, &ret, NULL);\n\t}\n}", "target": 1, "idx": 11036}
{"commit_id": "915d975b2ffa58a14bfcf16fafe00c41315949ff", "project": "kernel/git/netdev/net", "func": "static void *kmalloc_reserve(unsigned int *size, gfp_t flags, int node,\n\t\t\t     bool *pfmemalloc)\n{\n\tbool ret_pfmemalloc = false;\n\tsize_t obj_size;\n\tvoid *obj;\n\n\tobj_size = SKB_HEAD_ALIGN(*size);\n\tif (obj_size <= SKB_SMALL_HEAD_CACHE_SIZE &&\n\t    !(flags & KMALLOC_NOT_NORMAL_BITS)) {\n\t\tobj = kmem_cache_alloc_node(skb_small_head_cache,\n\t\t\t\tflags | __GFP_NOMEMALLOC | __GFP_NOWARN,\n\t\t\t\tnode);\n\t\t*size = SKB_SMALL_HEAD_CACHE_SIZE;\n\t\tif (obj || !(gfp_pfmemalloc_allowed(flags)))\n\t\t\tgoto out;\n\t\t/* Try again but now we are using pfmemalloc reserves */\n\t\tret_pfmemalloc = true;\n\t\tobj = kmem_cache_alloc_node(skb_small_head_cache, flags, node);\n\t\tgoto out;\n\t}\n\n\tobj_size = kmalloc_size_roundup(obj_size);\n\t/* The following cast might truncate high-order bits of obj_size, this\n\t * is harmless because kmalloc(obj_size >= 2^32) will fail anyway.\n\t */\n\t*size = (unsigned int)obj_size;\n\n\t/*\n\t * Try a regular allocation, when that fails and we're not entitled\n\t * to the reserves, fail.\n\t */\n\tobj = kmalloc_node_track_caller(obj_size,\n\t\t\t\t\tflags | __GFP_NOMEMALLOC | __GFP_NOWARN,\n\t\t\t\t\tnode);\n\tif (obj || !(gfp_pfmemalloc_allowed(flags)))\n\t\tgoto out;\n\n\t/* Try again but now we are using pfmemalloc reserves */\n\tret_pfmemalloc = true;\n\tobj = kmalloc_node_track_caller(obj_size, flags, node);\n\nout:\n\tif (pfmemalloc)\n\t\t*pfmemalloc = ret_pfmemalloc;\n\n\treturn obj;\n}", "target": 1, "idx": 11037}
{"commit_id": "96e9506ae9e252c548665152d1b8968297128307", "project": "akrennmair/newsbeuter", "func": "std::string controller::bookmark(\n\t\tconst std::string& url,\n\t\tconst std::string& title,\n\t\tconst std::string& description,\n\t\tconst std::string& feed_title)\n{\n\tstd::string bookmark_cmd = cfg.get_configvalue(\"bookmark-cmd\");\n\tbool is_interactive = cfg.get_configvalue_as_bool(\"bookmark-interactive\");\n\tif (bookmark_cmd.length() > 0) {\n\t\tstd::string cmdline = strprintf::fmt(\"%s '%s' '%s' '%s' '%s'\",\n\t\t                                       bookmark_cmd,\n\t\t                                       utils::replace_all(url,\"'\", \"%27\"),\n\t\t                                       utils::replace_all(title,\"'\", \"%27\"),\n\t\t                                       utils::replace_all(description,\"'\", \"%27\"),\n\t\t                                       utils::replace_all(feed_title,\"'\", \"%27\"));\n\n\t\tLOG(level::DEBUG, \"controller::bookmark: cmd = %s\", cmdline);\n\n\t\tif (is_interactive) {\n\t\t\tv->push_empty_formaction();\n\t\t\tstfl::reset();\n\t\t\tutils::run_interactively(cmdline, \"controller::bookmark\");\n\t\t\tv->pop_current_formaction();\n\t\t\treturn \"\";\n\t\t} else {\n\t\t\tchar * my_argv[4];\n\t\t\tmy_argv[0] = const_cast<char *>(\"/bin/sh\");\n\t\t\tmy_argv[1] = const_cast<char *>(\"-c\");\n\t\t\tmy_argv[2] = const_cast<char *>(cmdline.c_str());\n\t\t\tmy_argv[3] = nullptr;\n\t\t\treturn utils::run_program(my_argv, \"\");\n\t\t}\n\t} else {\n\t\treturn _(\"bookmarking support is not configured. Please set the configuration variable `bookmark-cmd' accordingly.\");\n\t}\n}", "target": 2, "idx": 11038}
{"commit_id": "ff82911cd3f69f028f2537825c9720ff78bc3f19", "project": "qemu", "func": "static NBDRequestData *nbd_request_get(NBDClient *client)\n{\n    NBDRequestData *req;\n\n    assert(client->nb_requests <= MAX_NBD_REQUESTS - 1);\n    client->nb_requests++;\n\n    req = g_new0(NBDRequestData, 1);\n    nbd_client_get(client);\n    req->client = client;\n    return req;\n}", "target": 1, "idx": 11039}
{"commit_id": "0ebc1064e4874d5987722a2ddbc18f94aa53b211", "project": "torvalds/linux", "func": "static int nf_tables_newrule(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t     const struct nlattr * const nla[])\n{\n\tstruct nftables_pernet *nft_net = nft_pernet(info->net);\n\tstruct netlink_ext_ack *extack = info->extack;\n\tunsigned int size, i, n, ulen = 0, usize = 0;\n\tu8 genmask = nft_genmask_next(info->net);\n\tstruct nft_rule *rule, *old_rule = NULL;\n\tstruct nft_expr_info *expr_info = NULL;\n\tu8 family = info->nfmsg->nfgen_family;\n\tstruct nft_flow_rule *flow = NULL;\n\tstruct net *net = info->net;\n\tstruct nft_userdata *udata;\n\tstruct nft_table *table;\n\tstruct nft_chain *chain;\n\tstruct nft_trans *trans;\n\tu64 handle, pos_handle;\n\tstruct nft_expr *expr;\n\tstruct nft_ctx ctx;\n\tstruct nlattr *tmp;\n\tint err, rem;\n\n\tlockdep_assert_held(&nft_net->commit_mutex);\n\n\ttable = nft_table_lookup(net, nla[NFTA_RULE_TABLE], family, genmask,\n\t\t\t\t NETLINK_CB(skb).portid);\n\tif (IS_ERR(table)) {\n\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_TABLE]);\n\t\treturn PTR_ERR(table);\n\t}\n\n\tif (nla[NFTA_RULE_CHAIN]) {\n\t\tchain = nft_chain_lookup(net, table, nla[NFTA_RULE_CHAIN],\n\t\t\t\t\t genmask);\n\t\tif (IS_ERR(chain)) {\n\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_CHAIN]);\n\t\t\treturn PTR_ERR(chain);\n\t\t}\n\n\t} else if (nla[NFTA_RULE_CHAIN_ID]) {\n\t\tchain = nft_chain_lookup_byid(net, table, nla[NFTA_RULE_CHAIN_ID],\n\t\t\t\t\t      genmask);\n\t\tif (IS_ERR(chain)) {\n\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_CHAIN_ID]);\n\t\t\treturn PTR_ERR(chain);\n\t\t}\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tif (nft_chain_is_bound(chain))\n\t\treturn -EOPNOTSUPP;\n\n\tif (nla[NFTA_RULE_HANDLE]) {\n\t\thandle = be64_to_cpu(nla_get_be64(nla[NFTA_RULE_HANDLE]));\n\t\trule = __nft_rule_lookup(chain, handle);\n\t\tif (IS_ERR(rule)) {\n\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_HANDLE]);\n\t\t\treturn PTR_ERR(rule);\n\t\t}\n\n\t\tif (info->nlh->nlmsg_flags & NLM_F_EXCL) {\n\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_HANDLE]);\n\t\t\treturn -EEXIST;\n\t\t}\n\t\tif (info->nlh->nlmsg_flags & NLM_F_REPLACE)\n\t\t\told_rule = rule;\n\t\telse\n\t\t\treturn -EOPNOTSUPP;\n\t} else {\n\t\tif (!(info->nlh->nlmsg_flags & NLM_F_CREATE) ||\n\t\t    info->nlh->nlmsg_flags & NLM_F_REPLACE)\n\t\t\treturn -EINVAL;\n\t\thandle = nf_tables_alloc_handle(table);\n\n\t\tif (nla[NFTA_RULE_POSITION]) {\n\t\t\tpos_handle = be64_to_cpu(nla_get_be64(nla[NFTA_RULE_POSITION]));\n\t\t\told_rule = __nft_rule_lookup(chain, pos_handle);\n\t\t\tif (IS_ERR(old_rule)) {\n\t\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_POSITION]);\n\t\t\t\treturn PTR_ERR(old_rule);\n\t\t\t}\n\t\t} else if (nla[NFTA_RULE_POSITION_ID]) {\n\t\t\told_rule = nft_rule_lookup_byid(net, chain, nla[NFTA_RULE_POSITION_ID]);\n\t\t\tif (IS_ERR(old_rule)) {\n\t\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_POSITION_ID]);\n\t\t\t\treturn PTR_ERR(old_rule);\n\t\t\t}\n\t\t}\n\t}\n\n\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, chain, nla);\n\n\tn = 0;\n\tsize = 0;\n\tif (nla[NFTA_RULE_EXPRESSIONS]) {\n\t\texpr_info = kvmalloc_array(NFT_RULE_MAXEXPRS,\n\t\t\t\t\t   sizeof(struct nft_expr_info),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!expr_info)\n\t\t\treturn -ENOMEM;\n\n\t\tnla_for_each_nested(tmp, nla[NFTA_RULE_EXPRESSIONS], rem) {\n\t\t\terr = -EINVAL;\n\t\t\tif (nla_type(tmp) != NFTA_LIST_ELEM)\n\t\t\t\tgoto err_release_expr;\n\t\t\tif (n == NFT_RULE_MAXEXPRS)\n\t\t\t\tgoto err_release_expr;\n\t\t\terr = nf_tables_expr_parse(&ctx, tmp, &expr_info[n]);\n\t\t\tif (err < 0) {\n\t\t\t\tNL_SET_BAD_ATTR(extack, tmp);\n\t\t\t\tgoto err_release_expr;\n\t\t\t}\n\t\t\tsize += expr_info[n].ops->size;\n\t\t\tn++;\n\t\t}\n\t}\n\t/* Check for overflow of dlen field */\n\terr = -EFBIG;\n\tif (size >= 1 << 12)\n\t\tgoto err_release_expr;\n\n\tif (nla[NFTA_RULE_USERDATA]) {\n\t\tulen = nla_len(nla[NFTA_RULE_USERDATA]);\n\t\tif (ulen > 0)\n\t\t\tusize = sizeof(struct nft_userdata) + ulen;\n\t}\n\n\terr = -ENOMEM;\n\trule = kzalloc(sizeof(*rule) + size + usize, GFP_KERNEL_ACCOUNT);\n\tif (rule == NULL)\n\t\tgoto err_release_expr;\n\n\tnft_activate_next(net, rule);\n\n\trule->handle = handle;\n\trule->dlen   = size;\n\trule->udata  = ulen ? 1 : 0;\n\n\tif (ulen) {\n\t\tudata = nft_userdata(rule);\n\t\tudata->len = ulen - 1;\n\t\tnla_memcpy(udata->data, nla[NFTA_RULE_USERDATA], ulen);\n\t}\n\n\texpr = nft_expr_first(rule);\n\tfor (i = 0; i < n; i++) {\n\t\terr = nf_tables_newexpr(&ctx, &expr_info[i], expr);\n\t\tif (err < 0) {\n\t\t\tNL_SET_BAD_ATTR(extack, expr_info[i].attr);\n\t\t\tgoto err_release_rule;\n\t\t}\n\n\t\tif (expr_info[i].ops->validate)\n\t\t\tnft_validate_state_update(table, NFT_VALIDATE_NEED);\n\n\t\texpr_info[i].ops = NULL;\n\t\texpr = nft_expr_next(expr);\n\t}\n\n\tif (chain->flags & NFT_CHAIN_HW_OFFLOAD) {\n\t\tflow = nft_flow_rule_create(net, rule);\n\t\tif (IS_ERR(flow)) {\n\t\t\terr = PTR_ERR(flow);\n\t\t\tgoto err_release_rule;\n\t\t}\n\t}\n\n\tif (!nft_use_inc(&chain->use)) {\n\t\terr = -EMFILE;\n\t\tgoto err_release_rule;\n\t}\n\n\tif (info->nlh->nlmsg_flags & NLM_F_REPLACE) {\n\t\terr = nft_delrule(&ctx, old_rule);\n\t\tif (err < 0)\n\t\t\tgoto err_destroy_flow_rule;\n\n\t\ttrans = nft_trans_rule_add(&ctx, NFT_MSG_NEWRULE, rule);\n\t\tif (trans == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_destroy_flow_rule;\n\t\t}\n\t\tlist_add_tail_rcu(&rule->list, &old_rule->list);\n\t} else {\n\t\ttrans = nft_trans_rule_add(&ctx, NFT_MSG_NEWRULE, rule);\n\t\tif (!trans) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_destroy_flow_rule;\n\t\t}\n\n\t\tif (info->nlh->nlmsg_flags & NLM_F_APPEND) {\n\t\t\tif (old_rule)\n\t\t\t\tlist_add_rcu(&rule->list, &old_rule->list);\n\t\t\telse\n\t\t\t\tlist_add_tail_rcu(&rule->list, &chain->rules);\n\t\t } else {\n\t\t\tif (old_rule)\n\t\t\t\tlist_add_tail_rcu(&rule->list, &old_rule->list);\n\t\t\telse\n\t\t\t\tlist_add_rcu(&rule->list, &chain->rules);\n\t\t}\n\t}\n\tkvfree(expr_info);\n\n\tif (flow)\n\t\tnft_trans_flow_rule(trans) = flow;\n\n\tif (table->validate_state == NFT_VALIDATE_DO)\n\t\treturn nft_table_validate(net, table);\n\n\treturn 0;\n\nerr_destroy_flow_rule:\n\tnft_use_dec_restore(&chain->use);\n\tif (flow)\n\t\tnft_flow_rule_destroy(flow);\nerr_release_rule:\n\tnft_rule_expr_deactivate(&ctx, rule, NFT_TRANS_PREPARE_ERROR);\n\tnf_tables_rule_destroy(&ctx, rule);\nerr_release_expr:\n\tfor (i = 0; i < n; i++) {\n\t\tif (expr_info[i].ops) {\n\t\t\tmodule_put(expr_info[i].ops->type->owner);\n\t\t\tif (expr_info[i].ops->type->release_ops)\n\t\t\t\texpr_info[i].ops->type->release_ops(expr_info[i].ops);\n\t\t}\n\t}\n\tkvfree(expr_info);\n\n\treturn err;\n}", "target": 2, "idx": 11040}
{"commit_id": "2cb5985bf47bdc8bea78d28483ed224abdd33dc6", "project": "wireshark", "func": "static int\ndissect_u3v(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\n{\n    gint offset = 0;\n    proto_tree *u3v_tree = NULL, *ccd_tree_flag, *u3v_telegram_tree = NULL, *ccd_tree = NULL;\n    gint data_length = 0;\n    gint req_id = 0;\n    gint command_id = -1;\n    gint status = 0;\n    guint prefix = 0;\n    proto_item *ti = NULL;\n    proto_item *item = NULL;\n    const char *command_string;\n    usb_conv_info_t *usb_conv_info;\n    gint stream_detected = FALSE;\n    gint control_detected = FALSE;\n    u3v_conv_info_t *u3v_conv_info = NULL;\n    gencp_transaction_t *gencp_trans = NULL;\n\n    usb_conv_info = (usb_conv_info_t *)data;\n\n    /* decide if this packet belongs to U3V protocol */\n    u3v_conv_info = (u3v_conv_info_t *)usb_conv_info->class_data;\n\n    if (!u3v_conv_info) {\n        u3v_conv_info = wmem_new0(wmem_file_scope(), u3v_conv_info_t);\n        usb_conv_info->class_data = u3v_conv_info;\n        usb_conv_info->class_data_type = USB_CONV_U3V;\n    } else if (usb_conv_info->class_data_type != USB_CONV_U3V) {\n        /* Don't dissect if another USB type is in the conversation */\n        return 0;\n    }\n\n    prefix = tvb_get_letohl(tvb, 0);\n    if ((tvb_reported_length(tvb) >= 4) && ( ( U3V_CONTROL_PREFIX == prefix ) || ( U3V_EVENT_PREFIX == prefix ) ) ) {\n        control_detected = TRUE;\n    }\n\n    if (((tvb_reported_length(tvb) >= 4) && (( U3V_STREAM_LEADER_PREFIX == prefix ) || ( U3V_STREAM_TRAILER_PREFIX == prefix )))\n         || (usb_conv_info->endpoint == u3v_conv_info->ep_stream)) {\n        stream_detected = TRUE;\n    }\n\n    /* initialize interface class/subclass in case no descriptors have been dissected yet */\n    if ( control_detected || stream_detected){\n        if ( usb_conv_info->interfaceClass  == IF_CLASS_UNKNOWN &&\n             usb_conv_info->interfaceSubclass  == IF_SUBCLASS_UNKNOWN){\n            usb_conv_info->interfaceClass = IF_CLASS_MISCELLANEOUS;\n            usb_conv_info->interfaceSubclass = IF_SUBCLASS_MISC_U3V;\n        }\n    }\n\n    if ( control_detected ) {\n        /* Set the protocol column */\n        col_set_str(pinfo->cinfo, COL_PROTOCOL, \"U3V\");\n\n        /* Clear out stuff in the info column */\n        col_clear(pinfo->cinfo, COL_INFO);\n\n        /* Adds \"USB3Vision\" heading to protocol tree */\n        /* We will add fields to this using the u3v_tree pointer */\n        ti = proto_tree_add_item(tree, proto_u3v, tvb, offset, -1, ENC_NA);\n        u3v_tree = proto_item_add_subtree(ti, ett_u3v);\n\n        prefix = tvb_get_letohl(tvb, offset);\n        command_id = tvb_get_letohs(tvb, offset+6);\n\n        /* decode CCD ( DCI/DCE command data layout) */\n        if ((prefix == U3V_CONTROL_PREFIX || prefix == U3V_EVENT_PREFIX) && ((command_id % 2) == 0)) {\n            command_string = val_to_str(command_id,command_names,\"Unknown Command (0x%x)\");\n            item = proto_tree_add_item(u3v_tree, hf_u3v_ccd_cmd, tvb, offset, 8, ENC_NA);\n            proto_item_append_text(item, \": %s\", command_string);\n            ccd_tree = proto_item_add_subtree(item, ett_u3v_cmd);\n\n            /* Add the prefix code: */\n            proto_tree_add_item(ccd_tree, hf_u3v_gencp_prefix, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            offset += 4;\n\n            /* Add the flags */\n            item = proto_tree_add_item(ccd_tree, hf_u3v_flag, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n            ccd_tree_flag  = proto_item_add_subtree(item, ett_u3v_flags);\n            proto_tree_add_item(ccd_tree_flag, hf_u3v_acknowledge_required_flag, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n\n            offset += 2;\n            col_append_fstr(pinfo->cinfo, COL_INFO, \"> %s \", command_string);\n        } else if (prefix == U3V_CONTROL_PREFIX && ((command_id % 2) == 1)) {\n            command_string = val_to_str(command_id,command_names,\"Unknown Acknowledge (0x%x)\");\n            item = proto_tree_add_item(u3v_tree, hf_u3v_ccd_ack, tvb, offset, 8, ENC_NA);\n            proto_item_append_text(item, \": %s\", command_string);\n            ccd_tree = proto_item_add_subtree(item, ett_u3v_ack);\n\n            /* Add the prefix code: */\n            proto_tree_add_item(ccd_tree, hf_u3v_gencp_prefix, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n            offset += 4;\n\n            /* Add the status: */\n            proto_tree_add_item(ccd_tree, hf_u3v_status, tvb, offset, 2,ENC_LITTLE_ENDIAN);\n            status = tvb_get_letohs(tvb, offset);\n            offset += 2;\n            col_append_fstr(pinfo->cinfo, COL_INFO, \"< %s %s\",\n                    command_string,\n                    val_to_str(status, status_names_short, \"Unknown status (0x%04X)\"));\n        } else {\n            return 0;\n        }\n\n        /* Add the command id*/\n        proto_tree_add_item(ccd_tree, hf_u3v_command_id, tvb, offset, 2,ENC_LITTLE_ENDIAN);\n        offset += 2;\n\n        /* Parse the second part of both the command and the acknowledge header:\n        0          15 16         31\n        -------- -------- -------- --------\n        |     status      |   acknowledge   |\n        -------- -------- -------- --------\n        |     length      |      req_id     |\n        -------- -------- -------- --------\n\n        Add the data length\n        Number of valid data bytes in this message, not including this header. This\n        represents the number of bytes of payload appended after this header */\n\n        proto_tree_add_item(ccd_tree, hf_u3v_length, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n        data_length = tvb_get_letohs(tvb, offset);\n        offset += 2;\n\n        /* Add the request ID */\n        proto_tree_add_item(ccd_tree, hf_u3v_request_id, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n        req_id = tvb_get_letohs(tvb, offset);\n        offset += 2;\n\n        /* Add telegram subtree */\n        u3v_telegram_tree = proto_item_add_subtree(u3v_tree, ett_u3v);\n\n        if (!PINFO_FD_VISITED(pinfo)) {\n              if ((command_id % 2) == 0) {\n                    /* This is a command */\n                    gencp_trans = wmem_new(wmem_file_scope(), gencp_transaction_t);\n                    gencp_trans->cmd_frame = pinfo->fd->num;\n                    gencp_trans->ack_frame = 0;\n                    gencp_trans->cmd_time = pinfo->fd->abs_ts;\n                    /* add reference to current packet */\n                    p_add_proto_data(wmem_file_scope(), pinfo, proto_u3v, req_id, gencp_trans);\n                    /* add reference to current */\n                    u3v_conv_info->trans_info = gencp_trans;\n                } else {\n                    gencp_trans = u3v_conv_info->trans_info;\n                    if (gencp_trans) {\n                        gencp_trans->ack_frame = pinfo->fd->num;\n                        /* add reference to current packet */\n                        p_add_proto_data(wmem_file_scope(), pinfo, proto_u3v, req_id, gencp_trans);\n                    }\n                }\n         } else {\n            gencp_trans = (gencp_transaction_t*)p_get_proto_data(wmem_file_scope(),pinfo, proto_u3v, req_id);\n         }\n\n        if (!gencp_trans) {\n            /* create a \"fake\" gencp_trans structure */\n            gencp_trans = wmem_new(wmem_packet_scope(), gencp_transaction_t);\n            gencp_trans->cmd_frame = 0;\n            gencp_trans->ack_frame = 0;\n            gencp_trans->cmd_time = pinfo->fd->abs_ts;\n        }\n\n        /* dissect depending on command? */\n        switch (command_id) {\n        case U3V_READMEM_CMD:\n            dissect_u3v_read_mem_cmd(u3v_telegram_tree, tvb, pinfo, offset, data_length,u3v_conv_info,gencp_trans);\n            break;\n        case U3V_WRITEMEM_CMD:\n            dissect_u3v_write_mem_cmd(u3v_telegram_tree, tvb, pinfo, offset, data_length,u3v_conv_info,gencp_trans);\n            break;\n        case U3V_EVENT_CMD:\n            dissect_u3v_event_cmd(u3v_telegram_tree, tvb, pinfo, offset, data_length);\n            break;\n        case U3V_READMEM_ACK:\n            if ( U3V_STATUS_GENCP_SUCCESS == status ) {\n                dissect_u3v_read_mem_ack(u3v_telegram_tree, tvb, pinfo, offset, data_length,u3v_conv_info,gencp_trans);\n            }\n            break;\n        case U3V_WRITEMEM_ACK:\n            dissect_u3v_write_mem_ack(u3v_telegram_tree, tvb, pinfo, offset, data_length, u3v_conv_info,gencp_trans);\n            break;\n        case U3V_PENDING_ACK:\n            dissect_u3v_pending_ack(u3v_telegram_tree, tvb, pinfo, offset, data_length, u3v_conv_info,gencp_trans);\n            break;\n        default:\n            proto_tree_add_item(u3v_telegram_tree, hf_u3v_payloaddata, tvb, offset, data_length, ENC_NA);\n            break;\n        }\n        return data_length + 12;\n    } else if ( stream_detected ) {\n        /* this is streaming data */\n\n        /* init this stream configuration */\n        u3v_conv_info = (u3v_conv_info_t *)usb_conv_info->class_data;\n        u3v_conv_info->ep_stream = usb_conv_info->endpoint;\n\n        /* Set the protocol column */\n        col_set_str(pinfo->cinfo, COL_PROTOCOL, \"U3V\");\n\n        /* Clear out stuff in the info column */\n        col_clear(pinfo->cinfo, COL_INFO);\n\n        /* Adds \"USB3Vision\" heading to protocol tree */\n        /* We will add fields to this using the u3v_tree pointer */\n        ti = proto_tree_add_item(tree, proto_u3v, tvb, offset, -1, ENC_NA);\n        u3v_tree = proto_item_add_subtree(ti, ett_u3v);\n\n        if(tvb_captured_length(tvb) >=4) {\n            prefix = tvb_get_letohl(tvb, offset);\n            switch (prefix) {\n            case U3V_STREAM_LEADER_PREFIX:\n                dissect_u3v_stream_leader(u3v_tree, tvb, pinfo, usb_conv_info);\n                break;\n            case U3V_STREAM_TRAILER_PREFIX:\n                dissect_u3v_stream_trailer(u3v_tree, tvb, pinfo, usb_conv_info);\n                break;\n            default:\n                dissect_u3v_stream_payload(u3v_tree, tvb, pinfo, usb_conv_info);\n                break;\n            }\n        }\n        return tvb_captured_length(tvb);\n    }\n    return 0;\n}", "target": 1, "idx": 11041}
{"commit_id": "7b30443dac7bb9138275c909549110191bcbcae9", "project": "android", "func": "void btm_ble_start_sync_request(uint8_t sid, RawAddress addr, uint16_t skip,\n                                uint16_t timeout) {\n  tBLE_ADDR_TYPE address_type = BLE_ADDR_RANDOM;\n  tINQ_DB_ENT* p_i = btm_inq_db_find(addr);\n  if (p_i) {\n    address_type = p_i->inq_info.results.ble_addr_type;  // Random\n  }\n  btm_random_pseudo_to_identity_addr(&addr, &address_type);\n  address_type &= ~BLE_ADDR_TYPE_ID_BIT;\n  uint8_t options = 0;\n  uint8_t cte_type = 7;\n  int index = btm_ble_get_psync_index(sid, addr);\n\n  if (index == MAX_SYNC_TRANSACTION) {\n    LOG_ERROR(\"Failed to get sync transfer index\");\n    return;\n  }\n\n  tBTM_BLE_PERIODIC_SYNC* p = &btm_ble_pa_sync_cb.p_sync[index];\n  p->sync_state = PERIODIC_SYNC_PENDING;\n\n  if (BleScanningManager::IsInitialized()) {\n    BleScanningManager::Get()->PeriodicScanStart(options, sid, address_type,\n                                                 addr, skip, timeout, cte_type);\n  }\n\n  alarm_set(sync_timeout_alarm, SYNC_TIMEOUT, btm_ble_start_sync_timeout, NULL);\n}", "target": 2, "idx": 11042}
{"commit_id": "e045199c7c9c5433d7f1461a741ed539a75cbfad", "project": "xen-project/xen", "func": "int evtchn_allocate_port(struct domain *d, evtchn_port_t port)\n{\n    if ( port > d->max_evtchn_port || port >= max_evtchns(d) )\n        return -ENOSPC;\n\n    if ( port_is_valid(d, port) )\n    {\n        const struct evtchn *chn = evtchn_from_port(d, port);\n\n        if ( chn->state != ECS_FREE || evtchn_is_busy(d, chn) )\n            return -EBUSY;\n    }\n    else\n    {\n        struct evtchn *chn;\n        struct evtchn **grp;\n\n        if ( !group_from_port(d, port) )\n        {\n            grp = xzalloc_array(struct evtchn *, BUCKETS_PER_GROUP);\n            if ( !grp )\n                return -ENOMEM;\n            group_from_port(d, port) = grp;\n        }\n\n        chn = alloc_evtchn_bucket(d, port);\n        if ( !chn )\n            return -ENOMEM;\n        bucket_from_port(d, port) = chn;\n\n        /*\n         * d->valid_evtchns is used to check whether the bucket can be\n         * accessed without the per-domain lock. Therefore,\n         * d->valid_evtchns should be seen *after* the new bucket has\n         * been setup.\n         */\n        smp_wmb();\n        write_atomic(&d->valid_evtchns, d->valid_evtchns + EVTCHNS_PER_BUCKET);\n    }\n\n    write_atomic(&d->active_evtchns, d->active_evtchns + 1);\n\n    return 0;\n}", "target": 2, "idx": 11043}
{"commit_id": "879f7080d7e141f415c79eaa3a8ac4a3dad0348b", "project": "openssl", "func": "static int tree_link_nodes(X509_POLICY_LEVEL *curr,\n                           const X509_POLICY_CACHE *cache,\n                           X509_POLICY_TREE *tree)\n{\n    int i;\n\n    for (i = 0; i < sk_X509_POLICY_DATA_num(cache->data); i++) {\n        X509_POLICY_DATA *data = sk_X509_POLICY_DATA_value(cache->data, i);\n\n        /* Look for matching nodes in previous level */\n        if (!tree_link_matching_nodes(curr, data, tree))\n            return 0;\n    }\n    return 1;\n}", "target": 2, "idx": 11044}
{"commit_id": "5a07975ad0a36708c6b0a5b9fea1ff811d0b0c1f", "project": "torvalds/linux", "func": "static int digi_startup(struct usb_serial *serial)\n{\n\tstruct device *dev = &serial->interface->dev;\n\tstruct digi_serial *serial_priv;\n\tint ret;\n\tint i;\n\n\t/* check whether the device has the expected number of endpoints */\n\tif (serial->num_port_pointers < serial->type->num_ports + 1) {\n\t\tdev_err(dev, \"OOB endpoints missing\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tfor (i = 0; i < serial->type->num_ports + 1 ; i++) {\n\t\tif (!serial->port[i]->read_urb) {\n\t\t\tdev_err(dev, \"bulk-in endpoint missing\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tif (!serial->port[i]->write_urb) {\n\t\t\tdev_err(dev, \"bulk-out endpoint missing\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tserial_priv = kzalloc(sizeof(*serial_priv), GFP_KERNEL);\n\tif (!serial_priv)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&serial_priv->ds_serial_lock);\n\tserial_priv->ds_oob_port_num = serial->type->num_ports;\n\tserial_priv->ds_oob_port = serial->port[serial_priv->ds_oob_port_num];\n\n\tret = digi_port_init(serial_priv->ds_oob_port,\n\t\t\t\t\t\tserial_priv->ds_oob_port_num);\n\tif (ret) {\n\t\tkfree(serial_priv);\n\t\treturn ret;\n\t}\n\n\tusb_set_serial_data(serial, serial_priv);\n\n\treturn 0;\n}", "target": 1, "idx": 11045}
{"commit_id": "a7de776fdf7518d74522168f1c0960241f18e110", "project": "openlink/virtuoso-opensource", "func": "int\nssl_needs_ins_cast (state_slot_t * ssl, dbe_column_t * col)\n{\n  if (ssl->ssl_is_callret)\n    return 1;\n  if (DV_WIDE == col->col_sqt.sqt_dtp && (DV_ANY == ssl->ssl_dc_dtp && DV_WIDE == ssl->ssl_sqt.sqt_dtp))\n    return 0;\n  if (DV_STRING == col->col_sqt.sqt_dtp && (DV_ANY == ssl->ssl_dc_dtp && DV_STRING == ssl->ssl_sqt.sqt_dtp))\n    return 0;\n  if (ssl->ssl_dc_dtp == dtp_canonical[col->col_sqt.sqt_dtp])\n    {\n      switch (dtp_canonical[col->col_sqt.sqt_dtp])\n\t{\n\tcase DV_LONG_INT:\n\tcase DV_IRI_ID:\n\tcase DV_SINGLE_FLOAT:\n\tcase DV_DOUBLE_FLOAT:\n\tcase DV_NUMERIC:\n\tcase DV_DATETIME:\n\tcase DV_DATE:\n\tcase DV_TIMESTAMP:\n\tcase DV_TIME:\n\t  return 0;\n\t}\n    }\n  return 1;\n}", "target": 2, "idx": 11046}
{"commit_id": "39ce47f219b09c380b81f89fe54ac586c8db6bde", "project": "curl", "func": "static void suboption(struct Curl_easy *data)\n{\n  struct curl_slist *v;\n  unsigned char temp[2048];\n  ssize_t bytes_written;\n  size_t len;\n  int err;\n  char varname[128] = \"\";\n  char varval[128] = \"\";\n  struct TELNET *tn = data->req.p.telnet;\n  struct connectdata *conn = data->conn;\n\n  printsub(data, '<', (unsigned char *)tn->subbuffer, CURL_SB_LEN(tn) + 2);\n  switch(CURL_SB_GET(tn)) {\n    case CURL_TELOPT_TTYPE:\n      len = strlen(tn->subopt_ttype) + 4 + 2;\n      msnprintf((char *)temp, sizeof(temp),\n                \"%c%c%c%c%s%c%c\", CURL_IAC, CURL_SB, CURL_TELOPT_TTYPE,\n                CURL_TELQUAL_IS, tn->subopt_ttype, CURL_IAC, CURL_SE);\n      bytes_written = swrite(conn->sock[FIRSTSOCKET], temp, len);\n      if(bytes_written < 0) {\n        err = SOCKERRNO;\n        failf(data,\"Sending data failed (%d)\",err);\n      }\n      printsub(data, '>', &temp[2], len-2);\n      break;\n    case CURL_TELOPT_XDISPLOC:\n      len = strlen(tn->subopt_xdisploc) + 4 + 2;\n      msnprintf((char *)temp, sizeof(temp),\n                \"%c%c%c%c%s%c%c\", CURL_IAC, CURL_SB, CURL_TELOPT_XDISPLOC,\n                CURL_TELQUAL_IS, tn->subopt_xdisploc, CURL_IAC, CURL_SE);\n      bytes_written = swrite(conn->sock[FIRSTSOCKET], temp, len);\n      if(bytes_written < 0) {\n        err = SOCKERRNO;\n        failf(data,\"Sending data failed (%d)\",err);\n      }\n      printsub(data, '>', &temp[2], len-2);\n      break;\n    case CURL_TELOPT_NEW_ENVIRON:\n      msnprintf((char *)temp, sizeof(temp),\n                \"%c%c%c%c\", CURL_IAC, CURL_SB, CURL_TELOPT_NEW_ENVIRON,\n                CURL_TELQUAL_IS);\n      len = 4;\n\n      for(v = tn->telnet_vars; v; v = v->next) {\n        size_t tmplen = (strlen(v->data) + 1);\n        /* Add the variable only if it fits */\n        if(len + tmplen < (int)sizeof(temp)-6) {\n          if(sscanf(v->data, \"%127[^,],%127s\", varname, varval) == 2) {\n            msnprintf((char *)&temp[len], sizeof(temp) - len,\n                      \"%c%s%c%s\", CURL_NEW_ENV_VAR, varname,\n                      CURL_NEW_ENV_VALUE, varval);\n            len += tmplen;\n          }\n        }\n      }\n      msnprintf((char *)&temp[len], sizeof(temp) - len,\n                \"%c%c\", CURL_IAC, CURL_SE);\n      len += 2;\n      bytes_written = swrite(conn->sock[FIRSTSOCKET], temp, len);\n      if(bytes_written < 0) {\n        err = SOCKERRNO;\n        failf(data,\"Sending data failed (%d)\",err);\n      }\n      printsub(data, '>', &temp[2], len-2);\n      break;\n  }\n  return;\n}", "target": 0, "idx": 11047}
{"commit_id": "1c0808d580da09fdec5a9a74ff09e103ea058dd4", "project": "h2o", "func": "int close_connection(h2o_http2_conn_t *conn)\n{\n    conn->state = H2O_HTTP2_CONN_STATE_IS_CLOSING;\n\n    if (conn->_write.buf_in_flight != NULL || h2o_timeout_is_linked(&conn->_write.timeout_entry)) {\n        /* there is a pending write, let on_write_complete actually close the connection */\n    } else {\n        close_connection_now(conn);\n        return -1;\n    }\n    return 0;\n}", "target": 2, "idx": 11048}
{"commit_id": "ade71fb544391b2e33e1859645726bfee0d5eaaf", "project": "GNOME/glib", "func": "inline static GVariantSerialised\ng_variant_to_serialised (GVariant *value)\n{\n  g_assert (value->state & STATE_SERIALISED);\n  {\n    GVariantSerialised serialised = {\n      value->type_info,\n      (gpointer) value->contents.serialised.data,\n      value->size,\n      value->depth,\n      value->contents.serialised.ordered_offsets_up_to,\n    };\n    return serialised;\n  }\n}", "target": 1, "idx": 11049}
{"commit_id": "4944c92761e0a14f04868cbcf4f4e86fd4b7a4a9", "project": "koral--/android-gif-drawable", "func": "void DDGifSlurp(GifInfo *info, bool decode, bool exitAfterFrame) {\n\tGifRecordType RecordType;\n\tGifByteType *ExtData;\n\tint ExtFunction;\n\tGifFileType *gifFilePtr;\n\tgifFilePtr = info->gifFilePtr;\n\tuint_fast32_t lastAllocatedGCBIndex = 0;\n\tdo {\n\t\tif (DGifGetRecordType(gifFilePtr, &RecordType) == GIF_ERROR) {\n\t\t\tbreak;\n\t\t}\n\t\tbool isInitialPass = !decode && !exitAfterFrame;\n\t\tswitch (RecordType) {\n\t\t\tcase IMAGE_DESC_RECORD_TYPE:\n\n\t\t\t\tif (DGifGetImageDesc(gifFilePtr, isInitialPass) == GIF_ERROR) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (isInitialPass) {\n\t\t\t\t\tint_fast32_t widthOverflow = gifFilePtr->Image.Width - gifFilePtr->SWidth;\n\t\t\t\t\tint_fast32_t heightOverflow = gifFilePtr->Image.Height - gifFilePtr->SHeight;\n\t\t\t\t\tif (widthOverflow > 0 || heightOverflow > 0) {\n\t\t\t\t\t\tgifFilePtr->SWidth += widthOverflow;\n\t\t\t\t\t\tgifFilePtr->SHeight += heightOverflow;\n\t\t\t\t\t}\n\t\t\t\t\tSavedImage *sp = &gifFilePtr->SavedImages[gifFilePtr->ImageCount - 1];\n\t\t\t\t\tint_fast32_t topOverflow = gifFilePtr->Image.Top + gifFilePtr->Image.Height - gifFilePtr->SHeight;\n\t\t\t\t\tif (topOverflow > 0) {\n\t\t\t\t\t\tsp->ImageDesc.Top -= topOverflow;\n\t\t\t\t\t}\n\n\t\t\t\t\tint_fast32_t leftOverflow = gifFilePtr->Image.Left + gifFilePtr->Image.Width - gifFilePtr->SWidth;\n\t\t\t\t\tif (leftOverflow > 0) {\n\t\t\t\t\t\tsp->ImageDesc.Left -= leftOverflow;\n\t\t\t\t\t}\n\t\t\t\t\tif (!updateGCB(info, &lastAllocatedGCBIndex)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (decode) {\n\t\t\t\t\tconst uint_fast32_t newRasterSize = gifFilePtr->Image.Width * gifFilePtr->Image.Height;\n\t\t\t\t\tif (newRasterSize == 0) {\n\t\t\t\t\t\tfree(info->rasterBits);\n\t\t\t\t\t\tinfo->rasterBits = NULL;\n\t\t\t\t\t\tinfo->rasterSize = newRasterSize;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tconst int_fast32_t widthOverflow = gifFilePtr->Image.Width - info->originalWidth;\n\t\t\t\t\tconst int_fast32_t heightOverflow = gifFilePtr->Image.Height - info->originalHeight;\n\t\t\t\t\tif (newRasterSize > info->rasterSize || widthOverflow > 0 || heightOverflow > 0) {\n\t\t\t\t\t\tvoid *tmpRasterBits = reallocarray(info->rasterBits, newRasterSize, sizeof(GifPixelType));\n\t\t\t\t\t\tif (tmpRasterBits == NULL) {\n\t\t\t\t\t\t\tgifFilePtr->Error = D_GIF_ERR_NOT_ENOUGH_MEM;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinfo->rasterBits = tmpRasterBits;\n\t\t\t\t\t\tinfo->rasterSize = newRasterSize;\n\t\t\t\t\t}\n\t\t\t\t\tif (gifFilePtr->Image.Interlace) {\n\t\t\t\t\t\tuint_fast16_t i, j;\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * The way an interlaced image should be read -\n\t\t\t\t\t\t * offsets and jumps...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tuint_fast8_t InterlacedOffset[] = {0, 4, 2, 1};\n\t\t\t\t\t\tuint_fast8_t InterlacedJumps[] = {8, 8, 4, 2};\n\t\t\t\t\t\t/* Need to perform 4 passes on the image */\n\t\t\t\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\t\t\t\tfor (j = InterlacedOffset[i]; j < gifFilePtr->Image.Height; j += InterlacedJumps[i]) {\n\t\t\t\t\t\t\t\tif (DGifGetLine(gifFilePtr, info->rasterBits + j * gifFilePtr->Image.Width, gifFilePtr->Image.Width) == GIF_ERROR)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (DGifGetLine(gifFilePtr, info->rasterBits, gifFilePtr->Image.Width * gifFilePtr->Image.Height) == GIF_ERROR) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (info->sampleSize > 1) {\n\t\t\t\t\t\tunsigned char *dst = info->rasterBits;\n\t\t\t\t\t\tunsigned char *src = info->rasterBits;\n\t\t\t\t\t\tunsigned char *const srcEndImage = info->rasterBits + gifFilePtr->Image.Width * gifFilePtr->Image.Height;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tunsigned char *srcNextLineStart = src + gifFilePtr->Image.Width * info->sampleSize;\n\t\t\t\t\t\t\tunsigned char *const srcEndLine = src + gifFilePtr->Image.Width;\n\t\t\t\t\t\t\tunsigned char *dstEndLine = dst + gifFilePtr->Image.Width / info->sampleSize;\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\t*dst = *src;\n\t\t\t\t\t\t\t\tdst++;\n\t\t\t\t\t\t\t\tsrc += info->sampleSize;\n\t\t\t\t\t\t\t} while (src < srcEndLine);\n\t\t\t\t\t\t\tdst = dstEndLine;\n\t\t\t\t\t\t\tsrc = srcNextLineStart;\n\t\t\t\t\t\t} while (src < srcEndImage);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (DGifGetCodeNext(gifFilePtr, &ExtData) == GIF_ERROR) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (ExtData != NULL);\n\t\t\t\t\tif (exitAfterFrame) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase EXTENSION_RECORD_TYPE:\n\t\t\t\tif (DGifGetExtension(gifFilePtr, &ExtFunction, &ExtData) == GIF_ERROR) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (isInitialPass) {\n\t\t\t\t\tupdateGCB(info, &lastAllocatedGCBIndex);\n\t\t\t\t\tif (readExtensions(ExtFunction, ExtData, info) == GIF_ERROR) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (ExtData != NULL) {\n\t\t\t\t\tif (DGifGetExtensionNext(gifFilePtr, &ExtData) == GIF_ERROR) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (isInitialPass && readExtensions(ExtFunction, ExtData, info) == GIF_ERROR) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase TERMINATE_RECORD_TYPE:\n\t\t\t\tbreak;\n\n\t\t\tdefault: /* Should be trapped by DGifGetRecordType */\n\t\t\t\tbreak;\n\t\t}\n\t} while (RecordType != TERMINATE_RECORD_TYPE);\n\n\tinfo->rewindFunction(info);\n}", "target": 2, "idx": 11050}
{"commit_id": "dfb4357da6ddbdf57d583ba64361c9d792b0e0b1", "project": "kernel/git/tip/tip", "func": "static void expire_timers(struct timer_base *base, struct hlist_head *head)\n{\n\twhile (!hlist_empty(head)) {\n\t\tstruct timer_list *timer;\n\t\tvoid (*fn)(unsigned long);\n\t\tunsigned long data;\n\n\t\ttimer = hlist_entry(head->first, struct timer_list, entry);\n\n\t\tbase->running_timer = timer;\n\t\tdetach_timer(timer, true);\n\n\t\tfn = timer->function;\n\t\tdata = timer->data;\n\n\t\tif (timer->flags & TIMER_IRQSAFE) {\n\t\t\tspin_unlock(&base->lock);\n\t\t\tcall_timer_fn(timer, fn, data);\n\t\t\tspin_lock(&base->lock);\n\t\t} else {\n\t\t\tspin_unlock_irq(&base->lock);\n\t\t\tcall_timer_fn(timer, fn, data);\n\t\t\tspin_lock_irq(&base->lock);\n\t\t}\n\t}\n}", "target": 1, "idx": 11051}
{"commit_id": "5dd7b86b84a864b834c6fa3d7f9f51c87efa99d4", "project": "tensorflow", "func": "Status TensorSliceWriter::SaveData(const T* data, int64_t num_elements,\n                                   SavedSlice* ss) {\n  size_t max_bytes_per_element =\n      MaxBytesPerElementOrZero(DataTypeToEnum<T>::value);\n  if (max_bytes_per_element == 0) {\n    return errors::InvalidArgument(\n        \"Tensor slice serialization not implemented for dtype \",\n        DataTypeToEnum<T>::value);\n  }\n  size_t size_bound = ss->ByteSize() + kTensorProtoHeaderBytes +\n                      (max_bytes_per_element * num_elements);\n  if (size_bound > kMaxMessageBytes) {\n    return errors::InvalidArgument(\n        \"Tensor slice is too large to serialize (conservative estimate: \",\n        size_bound, \" bytes)\");\n  }\n  Fill(data, num_elements, ss->mutable_data());\n  DCHECK_GE(ss->ByteSize(), 0);\n  DCHECK_LE(ss->ByteSize(), size_bound);\n  return OkStatus();\n}", "target": 1, "idx": 11052}
{"commit_id": "4e70f4476c0c543559f971faecdd5f1300cddb0a", "project": "xen-project/xen", "func": "static int free_l3_table(struct page_info *page)\n{\n    struct domain *d = page_get_owner(page);\n    unsigned long pfn = mfn_x(page_to_mfn(page));\n    l3_pgentry_t *pl3e;\n    int rc = 0;\n    unsigned int partial_flags = page->partial_flags,\n        i = page->nr_validated_ptes - !(partial_flags & PTF_partial_set);\n\n    pl3e = map_domain_page(_mfn(pfn));\n\n    for ( ; ; )\n    {\n        rc = put_page_from_l3e(pl3e[i], pfn, partial_flags);\n        if ( rc < 0 )\n            break;\n\n        partial_flags = 0;\n        if ( rc == 0 )\n            pl3e[i] = unadjust_guest_l3e(pl3e[i], d);\n\n        if ( !i-- )\n            break;\n\n        if ( hypercall_preempt_check() )\n        {\n            rc = -EINTR;\n            break;\n        }\n    }\n\n    unmap_domain_page(pl3e);\n\n    if ( rc == -ERESTART )\n    {\n        page->nr_validated_ptes = i;\n        page->partial_flags = PTF_partial_set;\n    }\n    else if ( rc == -EINTR && i < L3_PAGETABLE_ENTRIES - 1 )\n    {\n        page->nr_validated_ptes = i + !(partial_flags & PTF_partial_set);\n        page->partial_flags = partial_flags;\n        rc = -ERESTART;\n    }\n    return rc > 0 ? 0 : rc;\n}", "target": 1, "idx": 11053}
{"commit_id": "c9a51565214eece8f1053089739aea73145bfd6b", "project": "jqlang/jq", "func": "int jvp_number_cmp(jv a, jv b) {\n  assert(JVP_HAS_KIND(a, JV_KIND_NUMBER));\n  assert(JVP_HAS_KIND(b, JV_KIND_NUMBER));\n\n#ifdef USE_DECNUM\n  if (JVP_HAS_FLAGS(a, JVP_FLAGS_NUMBER_LITERAL) && JVP_HAS_FLAGS(b, JVP_FLAGS_NUMBER_LITERAL)) {\n    struct {\n      decNumber number;\n      decNumberUnit units[1];\n    } res;\n\n    decNumberCompare(&res.number,\n                     jvp_dec_number_ptr(a),\n                     jvp_dec_number_ptr(b),\n                     DEC_CONTEXT()\n                     );\n    if (decNumberIsZero(&res.number)) {\n      return 0;\n    } else if (decNumberIsNegative(&res.number)) {\n      return -1;\n    } else {\n      return 1;\n    }\n  }\n#endif\n  double da = jv_number_value(a), db = jv_number_value(b);\n  if (da < db) {\n    return -1;\n  } else if (da == db) {\n    return 0;\n  } else {\n    return 1;\n  }\n}", "target": 1, "idx": 11054}
{"commit_id": "d182d8f6ba3071503d96ce17395c9d55871f0242", "project": "GNOME/libxslt", "func": "static int\nxsltNumberFormatGetMultipleLevel(xsltTransformContextPtr context,\n\t\t\t\t xmlNodePtr node,\n\t\t\t\t xsltCompMatchPtr countPat,\n\t\t\t\t xsltCompMatchPtr fromPat,\n\t\t\t\t double *array,\n\t\t\t\t int max)\n{\n    int amount = 0;\n    int cnt;\n    xmlNodePtr ancestor;\n    xmlNodePtr preceding;\n    xmlXPathParserContextPtr parser;\n\n    context->xpathCtxt->node = node;\n    parser = xmlXPathNewParserContext(NULL, context->xpathCtxt);\n    if (parser) {\n\t/* ancestor-or-self::*[count] */\n\tfor (ancestor = node;\n\t     (ancestor != NULL) && (ancestor->type != XML_DOCUMENT_NODE);\n\t     ancestor = xmlXPathNextAncestor(parser, ancestor)) {\n\n\t    if ((fromPat != NULL) &&\n\t\txsltTestCompMatchList(context, ancestor, fromPat))\n\t\tbreak; /* for */\n\n\t    if (xsltTestCompMatchCount(context, ancestor, countPat, node)) {\n\t\t/* count(preceding-sibling::*) */\n\t\tcnt = 1;\n\t\tfor (preceding =\n                        xmlXPathNextPrecedingSibling(parser, ancestor);\n\t\t     preceding != NULL;\n\t\t     preceding =\n\t\t        xmlXPathNextPrecedingSibling(parser, preceding)) {\n\n\t            if (xsltTestCompMatchCount(context, preceding, countPat,\n                                               node))\n\t\t\tcnt++;\n\t\t}\n\t\tarray[amount++] = (double)cnt;\n\t\tif (amount >= max)\n\t\t    break; /* for */\n\t    }\n\t}\n\txmlXPathFreeParserContext(parser);\n    }\n    return amount;\n}", "target": 2, "idx": 11055}
{"commit_id": "fac35ba763ed07ba93154c95ffc0c4a55023707f", "project": "kernel/git/bpf/bpf-next", "func": "static struct page *follow_pmd_mask(struct vm_area_struct *vma,\n\t\t\t\t    unsigned long address, pud_t *pudp,\n\t\t\t\t    unsigned int flags,\n\t\t\t\t    struct follow_page_context *ctx)\n{\n\tpmd_t *pmd, pmdval;\n\tspinlock_t *ptl;\n\tstruct page *page;\n\tstruct mm_struct *mm = vma->vm_mm;\n\n\tpmd = pmd_offset(pudp, address);\n\t/*\n\t * The READ_ONCE() will stabilize the pmdval in a register or\n\t * on the stack so that it will stop changing under the code.\n\t */\n\tpmdval = READ_ONCE(*pmd);\n\tif (pmd_none(pmdval))\n\t\treturn no_page_table(vma, flags);\n\tif (pmd_huge(pmdval) && is_vm_hugetlb_page(vma)) {\n\t\tpage = follow_huge_pmd_pte(vma, address, flags);\n\t\tif (page)\n\t\t\treturn page;\n\t\treturn no_page_table(vma, flags);\n\t}\n\tif (is_hugepd(__hugepd(pmd_val(pmdval)))) {\n\t\tpage = follow_huge_pd(vma, address,\n\t\t\t\t      __hugepd(pmd_val(pmdval)), flags,\n\t\t\t\t      PMD_SHIFT);\n\t\tif (page)\n\t\t\treturn page;\n\t\treturn no_page_table(vma, flags);\n\t}\nretry:\n\tif (!pmd_present(pmdval)) {\n\t\t/*\n\t\t * Should never reach here, if thp migration is not supported;\n\t\t * Otherwise, it must be a thp migration entry.\n\t\t */\n\t\tVM_BUG_ON(!thp_migration_supported() ||\n\t\t\t\t  !is_pmd_migration_entry(pmdval));\n\n\t\tif (likely(!(flags & FOLL_MIGRATION)))\n\t\t\treturn no_page_table(vma, flags);\n\n\t\tpmd_migration_entry_wait(mm, pmd);\n\t\tpmdval = READ_ONCE(*pmd);\n\t\t/*\n\t\t * MADV_DONTNEED may convert the pmd to null because\n\t\t * mmap_lock is held in read mode\n\t\t */\n\t\tif (pmd_none(pmdval))\n\t\t\treturn no_page_table(vma, flags);\n\t\tgoto retry;\n\t}\n\tif (pmd_devmap(pmdval)) {\n\t\tptl = pmd_lock(mm, pmd);\n\t\tpage = follow_devmap_pmd(vma, address, pmd, flags, &ctx->pgmap);\n\t\tspin_unlock(ptl);\n\t\tif (page)\n\t\t\treturn page;\n\t}\n\tif (likely(!pmd_trans_huge(pmdval)))\n\t\treturn follow_page_pte(vma, address, pmd, flags, &ctx->pgmap);\n\n\tif ((flags & FOLL_NUMA) && pmd_protnone(pmdval))\n\t\treturn no_page_table(vma, flags);\n\nretry_locked:\n\tptl = pmd_lock(mm, pmd);\n\tif (unlikely(pmd_none(*pmd))) {\n\t\tspin_unlock(ptl);\n\t\treturn no_page_table(vma, flags);\n\t}\n\tif (unlikely(!pmd_present(*pmd))) {\n\t\tspin_unlock(ptl);\n\t\tif (likely(!(flags & FOLL_MIGRATION)))\n\t\t\treturn no_page_table(vma, flags);\n\t\tpmd_migration_entry_wait(mm, pmd);\n\t\tgoto retry_locked;\n\t}\n\tif (unlikely(!pmd_trans_huge(*pmd))) {\n\t\tspin_unlock(ptl);\n\t\treturn follow_page_pte(vma, address, pmd, flags, &ctx->pgmap);\n\t}\n\tif (flags & FOLL_SPLIT_PMD) {\n\t\tint ret;\n\t\tpage = pmd_page(*pmd);\n\t\tif (is_huge_zero_page(page)) {\n\t\t\tspin_unlock(ptl);\n\t\t\tret = 0;\n\t\t\tsplit_huge_pmd(vma, pmd, address);\n\t\t\tif (pmd_trans_unstable(pmd))\n\t\t\t\tret = -EBUSY;\n\t\t} else {\n\t\t\tspin_unlock(ptl);\n\t\t\tsplit_huge_pmd(vma, pmd, address);\n\t\t\tret = pte_alloc(mm, pmd) ? -ENOMEM : 0;\n\t\t}\n\n\t\treturn ret ? ERR_PTR(ret) :\n\t\t\tfollow_page_pte(vma, address, pmd, flags, &ctx->pgmap);\n\t}\n\tpage = follow_trans_huge_pmd(vma, address, pmd, flags);\n\tspin_unlock(ptl);\n\tctx->page_mask = HPAGE_PMD_NR - 1;\n\treturn page;\n}", "target": 2, "idx": 11056}
{"commit_id": "2cb40c4d5feeaa09325522bd7d97910f1b59e379", "project": "polkit", "func": "void\npolkit_unix_user_set_uid (PolkitUnixUser *user,\n                          gint uid)\n{\n  g_return_if_fail (POLKIT_IS_UNIX_USER (user));\n  g_return_if_fail (uid != -1);\n  user->uid = uid;\n}", "target": 2, "idx": 11057}
{"commit_id": "ad01e3608293a548bedf87704f35e4c0529804d3", "project": "caryll/otfcc", "func": "sds utf16le_to_utf8(const uint8_t *inb, int inlenb) {\n\tuint16_t *in = (uint16_t *)inb;\n\tuint16_t *inend;\n\tuint32_t c, d, inlen;\n\tint bits;\n\n\tif ((inlenb % 2) == 1) (inlenb)--;\n\tinlen = inlenb / 2;\n\tinend = in + inlen;\n\t// pass 1: calculate bytes used for output\n\tuint32_t bytesNeeded = 0;\n\twhile (in < inend) {\n\t\tc = *in++;\n\t\tif ((c & 0xFC00) == 0xD800) { // surrogates\n\t\t\tif (in >= inend) {        // (in > inend) shouldn't happens\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\td = *in++;\n\t\t\tif ((d & 0xFC00) == 0xDC00) {\n\t\t\t\tc &= 0x03FF;\n\t\t\t\tc <<= 10;\n\t\t\t\tc |= d & 0x03FF;\n\t\t\t\tc += 0x10000;\n\t\t\t}\n\t\t}\n\t\tif (c < 0x80) {\n\t\t\tbytesNeeded += 1;\n\t\t} else if (c < 0x800) {\n\t\t\tbytesNeeded += 2;\n\t\t} else if (c < 0x10000) {\n\t\t\tbytesNeeded += 3;\n\t\t} else {\n\t\t\tbytesNeeded += 4;\n\t\t}\n\t}\n\tin = (uint16_t *)inb;\n\tsds out = sdsnewlen(NULL, bytesNeeded);\n\tsds out0 = out;\n\n\twhile (in < inend) {\n\t\tc = *in++;\n\t\tif ((c & 0xFC00) == 0xD800) {\n\t\t\tif (in >= inend) { break; }\n\t\t\td = *in++;\n\t\t\tif ((d & 0xFC00) == 0xDC00) {\n\t\t\t\tc &= 0x03FF;\n\t\t\t\tc <<= 10;\n\t\t\t\tc |= d & 0x03FF;\n\t\t\t\tc += 0x10000;\n\t\t\t}\n\t\t}\n\n\t\tif (c < 0x80) {\n\t\t\t*out++ = c;\n\t\t\tbits = -6;\n\t\t} else if (c < 0x800) {\n\t\t\t*out++ = ((c >> 6) & 0x1F) | 0xC0;\n\t\t\tbits = 0;\n\t\t} else if (c < 0x10000) {\n\t\t\t*out++ = ((c >> 12) & 0x0F) | 0xE0;\n\t\t\tbits = 6;\n\t\t} else {\n\t\t\t*out++ = ((c >> 18) & 0x07) | 0xF0;\n\t\t\tbits = 12;\n\t\t}\n\n\t\tfor (; bits >= 0; bits -= 6) {\n\t\t\t*out++ = ((c >> bits) & 0x3F) | 0x80;\n\t\t}\n\t}\n\treturn out0;\n}", "target": 1, "idx": 11058}
{"commit_id": "0da8b8b801f9276359262f1ef8274c7812d3dfda", "project": "php/php-src", "func": "static void php_html_entities(INTERNAL_FUNCTION_PARAMETERS, int all)\n{\n\tchar *str, *hint_charset = NULL;\n\tint str_len, hint_charset_len = 0;\n\tsize_t new_len;\n\tlong flags = ENT_COMPAT;\n\tchar *replaced;\n\tzend_bool double_encode = 1;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|ls!b\", &str, &str_len, &flags, &hint_charset, &hint_charset_len, &double_encode) == FAILURE) {\n\t\treturn;\n\t}\n\n\treplaced = php_escape_html_entities_ex(str, str_len, &new_len, all, (int) flags, hint_charset, double_encode TSRMLS_CC);\n\tif (new_len > INT_MAX) {\n\t\tefree(replaced);\n\t\tRETURN_FALSE;\n\t}\n\tRETVAL_STRINGL(replaced, (int)new_len, 0);\n}", "target": 2, "idx": 11059}
{"commit_id": "8323a7fe1e47d562ebf384aa99633e3df74a01c4", "project": "appneta/tcpreplay", "func": "int\nget_l2len(const u_char *pktdata, const int datalen, const int datalink)\n{\n    int l2_len = 0;\n\n    assert(pktdata);\n    assert(datalen);\n\n    switch (datalink) {\n    case DLT_RAW:\n        /* pktdata IS the ip header! */\n        break;\n\n    case DLT_JUNIPER_ETHER:\n        if (datalen < 4) {\n            l2_len = -1;\n            break;\n        }\n\n        if (memcmp(pktdata, JUNIPER_PCAP_MAGIC, 3)) {\n            warnx(\"No Magic Number found during L2 lookup: %s (0x%x)\",\n                  pcap_datalink_val_to_description(datalink), datalink);\n            l2_len = -1;\n            break;\n        }\n\n        if ((pktdata[3] & JUNIPER_FLAG_NO_L2) == JUNIPER_FLAG_NO_L2) {\n            /* no L2 header present */\n            l2_len = 0;\n            break;\n        }\n\n        if ((pktdata[3] & JUNIPER_FLAG_EXT) == JUNIPER_FLAG_EXT) {\n            if (datalen < 6) {\n                /* datalen too short */\n                l2_len = -1;\n                break;\n            }\n            l2_len = ntohs(*((uint16_t*)&pktdata[4]));\n            l2_len += 6;        /* MGC + flags + ext_total_len */\n        } else {\n            l2_len = 4;         /* MGC + flags */\n        }\n        /* fall through */\n    case DLT_EN10MB:\n        if ((size_t)datalen >= sizeof(eth_hdr_t) + l2_len) {\n            uint16_t ether_type = ntohs(((eth_hdr_t*)(pktdata + l2_len))->ether_type);\n\n            l2_len += sizeof(eth_hdr_t);\n            while (ether_type == ETHERTYPE_VLAN) {\n                if ((size_t)datalen < sizeof(vlan_hdr_t) + l2_len) {\n                    l2_len = -1;\n                    break;\n                }\n                vlan_hdr_t *vlan_hdr = (vlan_hdr_t *)(pktdata + l2_len);\n                ether_type = ntohs(vlan_hdr->vlan_tpid);\n                l2_len += 4;\n            }\n        }\n\n        if (datalen < l2_len)\n            l2_len = -1;\n\n        break;\n\n    case DLT_PPP_SERIAL:\n        if (datalen >= 4) {\n            l2_len = 4;\n        }\n        break;\n\n    case DLT_C_HDLC:\n        if (datalen >= CISCO_HDLC_LEN) {\n            l2_len = CISCO_HDLC_LEN;\n        }\n        break;\n\n    case DLT_LINUX_SLL:\n        if (datalen >= SLL_HDR_LEN) {\n            l2_len = SLL_HDR_LEN;\n        }\n        break;\n\n    default:\n        errx(-1, \"Unable to process unsupported DLT type: %s (0x%x)\", \n             pcap_datalink_val_to_description(datalink), datalink);\n        return -1; /* we shouldn't get here */\n    }\n\n    return l2_len;\n}", "target": 2, "idx": 11060}
{"commit_id": "1eb08bcd4634ae42ec45e8284923ac048beaa4c3", "project": "redis", "func": "static int b_unpack (lua_State *L) {\n  Header h;\n  const char *fmt = luaL_checkstring(L, 1);\n  size_t ld;\n  const char *data = luaL_checklstring(L, 2, &ld);\n  size_t pos = luaL_optinteger(L, 3, 1) - 1;\n  int n = 0;  /* number of results */\n  defaultoptions(&h);\n  while (*fmt) {\n    int opt = *fmt++;\n    size_t size = optsize(L, opt, &fmt);\n    pos += gettoalign(pos, &h, opt, size);\n    luaL_argcheck(L, pos+size <= ld, 2, \"data string too short\");\n    /* stack space for item + next position */\n    luaL_checkstack(L, 2, \"too many results\");\n    switch (opt) {\n      case 'b': case 'B': case 'h': case 'H':\n      case 'l': case 'L': case 'T': case 'i':  case 'I': {  /* integer types */\n        int issigned = islower(opt);\n        lua_Number res = getinteger(data+pos, h.endian, issigned, size);\n        lua_pushnumber(L, res); n++;\n        break;\n      }\n      case 'x': {\n        break;\n      }\n      case 'f': {\n        float f;\n        memcpy(&f, data+pos, size);\n        correctbytes((char *)&f, sizeof(f), h.endian);\n        lua_pushnumber(L, f); n++;\n        break;\n      }\n      case 'd': {\n        double d;\n        memcpy(&d, data+pos, size);\n        correctbytes((char *)&d, sizeof(d), h.endian);\n        lua_pushnumber(L, d); n++;\n        break;\n      }\n      case 'c': {\n        if (size == 0) {\n          if (n == 0 || !lua_isnumber(L, -1))\n            luaL_error(L, \"format 'c0' needs a previous size\");\n          size = lua_tonumber(L, -1);\n          lua_pop(L, 1); n--;\n          luaL_argcheck(L, size <= ld && pos <= ld - size,\n                           2, \"data string too short\");\n        }\n        lua_pushlstring(L, data+pos, size); n++;\n        break;\n      }\n      case 's': {\n        const char *e = (const char *)memchr(data+pos, '\\0', ld - pos);\n        if (e == NULL)\n          luaL_error(L, \"unfinished string in data\");\n        size = (e - (data+pos)) + 1;\n        lua_pushlstring(L, data+pos, size - 1); n++;\n        break;\n      }\n      default: controloptions(L, opt, &fmt, &h);\n    }\n    pos += size;\n  }\n  lua_pushinteger(L, pos + 1);  /* next position */\n  return n + 1;\n}", "target": 3, "idx": 11061}
{"commit_id": "d3c6ce463ac91ecbeb2128beb475d31d3ca6ef42", "project": "android", "func": "static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)\n{\n    const char *perm = \"add\";\n\n    if (uid >= AID_APP) {\n        return 0; /* Don't allow apps to register services */\n    }\n\n    return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;\n}", "target": 2, "idx": 11062}
{"commit_id": "e9ce0d64faf19fa4e9c260250fbdf25e3c11e152", "project": "radareorg/radare2", "func": "R_API RBinJavaAttrInfo *r_bin_java_line_number_table_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tut64 curpos, offset = 0;\n\tRBinJavaLineNumberAttribute *lnattr;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\toffset += 6;\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_LINE_NUMBER_TABLE_ATTR;\n\tattr->info.line_number_table_attr.line_number_table_length = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.line_number_table_attr.line_number_table = r_list_newf (free);\n\n\tut32 linenum_len = attr->info.line_number_table_attr.line_number_table_length;\n\tRList *linenum_list = attr->info.line_number_table_attr.line_number_table;\n\tfor (i = 0; i < linenum_len; i++) {\n\t\tcurpos = buf_offset + offset;\n\t\t// printf (\"%llx %llx \\n\", curpos, sz);\n\t\t// XXX if (curpos + 8 >= sz) break;\n\t\tlnattr = R_NEW0 (RBinJavaLineNumberAttribute);\n\t\tif (!lnattr) {\n\t\t\tbreak;\n\t\t}\n\t\t// wtf it works\n\t\tif (offset - 2 > sz) {\n\t\t\tbreak;\n\t\t}\n\t\tlnattr->start_pc = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlnattr->line_number = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlnattr->file_offset = curpos;\n\t\tlnattr->size = 4;\n\t\tr_list_append (linenum_list, lnattr);\n\t}\n\tattr->size = offset;\n\treturn attr;\n}", "target": 1, "idx": 11063}
{"commit_id": "82e31755e55fbcea6a9dfaae5fe4860ade17cbc0", "project": "torvalds/linux", "func": "static int ax25_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tax25_cb *ax25;\n\tax25_dev *ax25_dev;\n\n\tif (sk == NULL)\n\t\treturn 0;\n\n\tsock_hold(sk);\n\tlock_sock(sk);\n\tsock_orphan(sk);\n\tax25 = sk_to_ax25(sk);\n\tax25_dev = ax25->ax25_dev;\n\n\tif (sk->sk_type == SOCK_SEQPACKET) {\n\t\tswitch (ax25->state) {\n\t\tcase AX25_STATE_0:\n\t\t\trelease_sock(sk);\n\t\t\tax25_disconnect(ax25, 0);\n\t\t\tlock_sock(sk);\n\t\t\tax25_destroy_socket(ax25);\n\t\t\tbreak;\n\n\t\tcase AX25_STATE_1:\n\t\tcase AX25_STATE_2:\n\t\t\tax25_send_control(ax25, AX25_DISC, AX25_POLLON, AX25_COMMAND);\n\t\t\trelease_sock(sk);\n\t\t\tax25_disconnect(ax25, 0);\n\t\t\tlock_sock(sk);\n\t\t\tif (!sock_flag(ax25->sk, SOCK_DESTROY))\n\t\t\t\tax25_destroy_socket(ax25);\n\t\t\tbreak;\n\n\t\tcase AX25_STATE_3:\n\t\tcase AX25_STATE_4:\n\t\t\tax25_clear_queues(ax25);\n\t\t\tax25->n2count = 0;\n\n\t\t\tswitch (ax25->ax25_dev->values[AX25_VALUES_PROTOCOL]) {\n\t\t\tcase AX25_PROTO_STD_SIMPLEX:\n\t\t\tcase AX25_PROTO_STD_DUPLEX:\n\t\t\t\tax25_send_control(ax25,\n\t\t\t\t\t\t  AX25_DISC,\n\t\t\t\t\t\t  AX25_POLLON,\n\t\t\t\t\t\t  AX25_COMMAND);\n\t\t\t\tax25_stop_t2timer(ax25);\n\t\t\t\tax25_stop_t3timer(ax25);\n\t\t\t\tax25_stop_idletimer(ax25);\n\t\t\t\tbreak;\n#ifdef CONFIG_AX25_DAMA_SLAVE\n\t\t\tcase AX25_PROTO_DAMA_SLAVE:\n\t\t\t\tax25_stop_t3timer(ax25);\n\t\t\t\tax25_stop_idletimer(ax25);\n\t\t\t\tbreak;\n#endif\n\t\t\t}\n\t\t\tax25_calculate_t1(ax25);\n\t\t\tax25_start_t1timer(ax25);\n\t\t\tax25->state = AX25_STATE_2;\n\t\t\tsk->sk_state                = TCP_CLOSE;\n\t\t\tsk->sk_shutdown            |= SEND_SHUTDOWN;\n\t\t\tsk->sk_state_change(sk);\n\t\t\tsock_set_flag(sk, SOCK_DESTROY);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tsk->sk_state     = TCP_CLOSE;\n\t\tsk->sk_shutdown |= SEND_SHUTDOWN;\n\t\tsk->sk_state_change(sk);\n\t\tax25_destroy_socket(ax25);\n\t}\n\tif (ax25_dev) {\n\t\tdel_timer_sync(&ax25->timer);\n\t\tdel_timer_sync(&ax25->t1timer);\n\t\tdel_timer_sync(&ax25->t2timer);\n\t\tdel_timer_sync(&ax25->t3timer);\n\t\tdel_timer_sync(&ax25->idletimer);\n\t\tdev_put_track(ax25_dev->dev, &ax25_dev->dev_tracker);\n\t\tax25_dev_put(ax25_dev);\n\t}\n\n\tsock->sk   = NULL;\n\trelease_sock(sk);\n\tsock_put(sk);\n\n\treturn 0;\n}", "target": 1, "idx": 11064}
{"commit_id": "33e63d19e5496c151bad69f65cdbc7cba2b4c211", "project": "wireshark", "func": "static gboolean compare_by_guid(gconstpointer guid_a, gconstpointer guid_b) {\n  return memcmp(guid_a, guid_b, sizeof(endpoint_guid)) == 0;\n}", "target": 1, "idx": 11065}
{"commit_id": "b900cc28fcbb4cf5a32ab62f80b59292e1c85b4b", "project": "nginx", "func": "void\nngx_gmtime(time_t t, ngx_tm_t *tp)\n{\n    ngx_int_t   yday;\n    ngx_uint_t  sec, min, hour, mday, mon, year, wday, days, leap;\n\n    /* the calculation is valid for positive time_t only */\n\n    if (t < 0) {\n        t = 0;\n    }\n\n    days = t / 86400;\n    sec = t % 86400;\n\n    /*\n     * no more than 4 year digits supported,\n     * truncate to December 31, 9999, 23:59:59\n     */\n\n    if (days > 2932896) {\n        days = 2932896;\n        sec = 86399;\n    }\n\n    /* January 1, 1970 was Thursday */\n\n    wday = (4 + days) % 7;\n\n    hour = sec / 3600;\n    sec %= 3600;\n    min = sec / 60;\n    sec %= 60;\n\n    /*\n     * the algorithm based on Gauss' formula,\n     * see src/core/ngx_parse_time.c\n     */\n\n    /* days since March 1, 1 BC */\n    days = days - (31 + 28) + 719527;\n\n    /*\n     * The \"days\" should be adjusted to 1 only, however, some March 1st's go\n     * to previous year, so we adjust them to 2.  This causes also shift of the\n     * last February days to next year, but we catch the case when \"yday\"\n     * becomes negative.\n     */\n\n    year = (days + 2) * 400 / (365 * 400 + 100 - 4 + 1);\n\n    yday = days - (365 * year + year / 4 - year / 100 + year / 400);\n\n    if (yday < 0) {\n        leap = (year % 4 == 0) && (year % 100 || (year % 400 == 0));\n        yday = 365 + leap + yday;\n        year--;\n    }\n\n    /*\n     * The empirical formula that maps \"yday\" to month.\n     * There are at least 10 variants, some of them are:\n     *     mon = (yday + 31) * 15 / 459\n     *     mon = (yday + 31) * 17 / 520\n     *     mon = (yday + 31) * 20 / 612\n     */\n\n    mon = (yday + 31) * 10 / 306;\n\n    /* the Gauss' formula that evaluates days before the month */\n\n    mday = yday - (367 * mon / 12 - 30) + 1;\n\n    if (yday >= 306) {\n\n        year++;\n        mon -= 10;\n\n        /*\n         * there is no \"yday\" in Win32 SYSTEMTIME\n         *\n         * yday -= 306;\n         */\n\n    } else {\n\n        mon += 2;\n\n        /*\n         * there is no \"yday\" in Win32 SYSTEMTIME\n         *\n         * yday += 31 + 28 + leap;\n         */\n    }\n\n    tp->ngx_tm_sec = (ngx_tm_sec_t) sec;\n    tp->ngx_tm_min = (ngx_tm_min_t) min;\n    tp->ngx_tm_hour = (ngx_tm_hour_t) hour;\n    tp->ngx_tm_mday = (ngx_tm_mday_t) mday;\n    tp->ngx_tm_mon = (ngx_tm_mon_t) mon;\n    tp->ngx_tm_year = (ngx_tm_year_t) year;\n    tp->ngx_tm_wday = (ngx_tm_wday_t) wday;\n}", "target": 3, "idx": 11066}
{"commit_id": "03498cf4e0319d8836aba96ce8a817beaabb441e", "project": "libming", "func": "void printDefineFont2(FILE *f)\n{\n  int flags, nGlyphs, namelen, off, i, fillBits, lineBits;\n  unsigned int *offset;\n\n  flags = readUInt8(f);\n\n  readUInt8(f); /* \"reserved\" */\n\n  namelen = readUInt8(f);\n\n  printf(\"%sFont Name: \", indent());\n\n  for(; namelen>0; --namelen)\n    putchar((unsigned char)readUInt8(f));\n\n  putchar('\\n');\n\n  nGlyphs = readUInt16(f);\n  printf(\"%snumber of glyphs: %i\\n\\n\", indent(), nGlyphs);\n\n  offset = (unsigned int *)malloc(nGlyphs*sizeof(int));\n\n  /* offset table */\n\n  for(i=0; i<nGlyphs; ++i)\n  {\n    if(flags & FONTINFO2_WIDEOFFSETS)\n      off = readUInt32(f);\n    else\n      off = readUInt16(f);\n\n    offset[i] = off-nGlyphs*4-4;\n    printf(\"%sOffset%i: %i\\n\", indent(), i, offset[i]);\n  }\n\n  /* shape table */\n  for(i=0; i<nGlyphs; ++i)\n  {\n    byteAlign();\n    printf(\"%sGlyph %i:\\n\", indent(), i);\n\n    fillBits = readBits(f, 4);\n    lineBits = readBits(f, 4);\n\n    byteAlign();\n    while(printShapeRec(f, &fillBits, &lineBits, 2)) ;\n\n    putchar('\\n');\n  }\n\n  /* code table */\n  for(i=0; i<nGlyphs; ++i)\n  {\n    if(flags & FONTINFO2_WIDECODES)\n      printf(\"%sglyph code %i: %i\\n\", indent(), i, readUInt16(f));\n    else\n      printf(\"%sglyph code %i: %i\\n\", indent(), i, readUInt8(f));\n  }\n\n  if(flags & FONTINFO2_HASLAYOUT)\n  {\n    int kernCount, code1, code2;\n\n    printf(\"%sascender height: %i\\n\", indent(), readSInt16(f));\n    printf(\"%sdescender height: %i\\n\", indent(), readSInt16(f));\n    printf(\"%sleading height: %i\\n\", indent(), readSInt16(f));\n\n    for(i=0; i<nGlyphs; ++i)\n      printf(\"\\tadvance %i: %i\\n\", i, readSInt16(f));\n\n    for(i=0; i<nGlyphs; ++i)\n    {\n      printf(\"%sbounds %i: \", indent(), i);\n      printRect(f);\n      putchar('\\n');\n    }\n\n    kernCount = readUInt16(f);\n\n    for(i=0; i<kernCount; ++i)\n    {\n      code1 = (flags & FONTINFO2_WIDECODES) ? readUInt16(f) : readUInt8(f);\n      code2 = (flags & FONTINFO2_WIDECODES) ? readUInt16(f) : readUInt8(f);\n      printf(\"%s(%i,%i): adjustment = %i\\n\", indent(), code1, code2, readSInt16(f));\n    }\n  }\n\n  putchar('\\n');\n}", "target": 2, "idx": 11067}
{"commit_id": "4df356bd28114ff2962e92be40e5e740d3fd6ceb", "project": "julianhille/MuhammaraJS", "func": "EStatusCode PDFDocumentHandler::WriteStreamObject(PDFStreamInput* inStream, IObjectWritePolicy* inWritePolicy)\n{\n\t/*\n\t1. Create stream dictionary, copy all elements of input stream but Length (which may be the same...but due to internals may not)\n\t2. Create PDFStream with this dictionary and use its output stream to write the result\n\t*/\n\tRefCountPtr<PDFDictionary> streamDictionary(inStream->QueryStreamDictionary());\n\tDictionaryContext* newStreamDictionary = mObjectsContext->StartDictionary();\n\n\tMapIterator<PDFNameToPDFObjectMap> it(streamDictionary->GetIterator());\n\tEStatusCode status = PDFHummus::eSuccess;\n\tbool readingDecrypted = false;\n\tIByteReader* streamReader = NULL;\n\n\t/*\n\t*\tTo support unencrypted pdf output, mostly used for debugging, (and maybe i should put a general flag there),\n\t*\tadd ability here to copy by rewriting the streams...when possible.\n\t*/\n\tif(!mObjectsContext->IsCompressingStreams()) {\n\t\tstreamReader = mParser->StartReadingFromStream(inStream);\n\t\treadingDecrypted = streamReader != NULL;\n\t}\t\n\tif(!readingDecrypted) {\n\t\tstreamReader = mParser->StartReadingFromStreamForPlainCopying(inStream);\n\t}\n\n\tif (streamReader == NULL) {\n               status = PDFHummus::eFailure;\n\t}\n\t\n\twhile (it.MoveNext() && PDFHummus::eSuccess == status)\n\t{\n\t\tif (it.GetKey()->GetValue() != \"Length\" && (!readingDecrypted || it.GetKey()->GetValue() != \"Filter\")) {\n\t\t\tstatus = newStreamDictionary->WriteKey(it.GetKey()->GetValue());\n\t\t\tif (PDFHummus::eSuccess == status)\n\t\t\t\tstatus = WriteObjectByType(it.GetValue(), eTokenSeparatorEndLine, inWritePolicy);\n\t\t}\n\t}\n\n\tif (status != PDFHummus::eSuccess)\n\t{\n\t\tTRACE_LOG(\"PDFDocumentHandler::WriteStreamObject, failed to write stream dictionary\");\n\t\treturn PDFHummus::eFailure;\n\t}\n\n\tPDFStream* newStream = readingDecrypted ?\n\t\tmObjectsContext->StartPDFStream(newStreamDictionary) :\n\t\tmObjectsContext->StartUnfilteredPDFStream(newStreamDictionary);\n\tOutputStreamTraits outputTraits(newStream->GetWriteStream());\n\n\tstatus = outputTraits.CopyToOutputStream(streamReader);\n\tif (status != PDFHummus::eSuccess)\n\t{\n\t\tTRACE_LOG(\"PDFDocumentHandler::WriteStreamObject, failed to copy stream\");\n\t\tdelete newStream;\n\t\tdelete streamReader;\n\t\treturn PDFHummus::eFailure;\n\t}\n\n\tmObjectsContext->EndPDFStream(newStream);\n\tdelete newStream;\n\tdelete streamReader;\n\treturn status;\n}", "target": 2, "idx": 11068}
{"commit_id": "1dcd10aceabbc03bf571ea32b892c522cbe923de", "project": "the-tcpdump-group/tcpdump", "func": "void\nmpls_print(netdissect_options *ndo, const u_char *bp, u_int length)\n{\n\tconst u_char *p;\n\tuint32_t label_entry;\n\tuint16_t label_stack_depth = 0;\n\tenum mpls_packet_type pt = PT_UNKNOWN;\n\n\tp = bp;\n\tND_PRINT((ndo, \"MPLS\"));\n\tdo {\n\t\tND_TCHECK2(*p, sizeof(label_entry));\n\t\tif (length < sizeof(label_entry)) {\n\t\t\tND_PRINT((ndo, \"[|MPLS], length %u\", length));\n\t\t\treturn;\n\t\t}\n\t\tlabel_entry = EXTRACT_32BITS(p);\n\t\tND_PRINT((ndo, \"%s(label %u\",\n\t\t       (label_stack_depth && ndo->ndo_vflag) ? \"\\n\\t\" : \" \",\n       \t\t       MPLS_LABEL(label_entry)));\n\t\tlabel_stack_depth++;\n\t\tif (ndo->ndo_vflag &&\n\t\t    MPLS_LABEL(label_entry) < sizeof(mpls_labelname) / sizeof(mpls_labelname[0]))\n\t\t\tND_PRINT((ndo, \" (%s)\", mpls_labelname[MPLS_LABEL(label_entry)]));\n\t\tND_PRINT((ndo, \", exp %u\", MPLS_EXP(label_entry)));\n\t\tif (MPLS_STACK(label_entry))\n\t\t\tND_PRINT((ndo, \", [S]\"));\n\t\tND_PRINT((ndo, \", ttl %u)\", MPLS_TTL(label_entry)));\n\n\t\tp += sizeof(label_entry);\n\t\tlength -= sizeof(label_entry);\n\t} while (!MPLS_STACK(label_entry));\n\n\t/*\n\t * Try to figure out the packet type.\n\t */\n\tswitch (MPLS_LABEL(label_entry)) {\n\n\tcase 0:\t/* IPv4 explicit NULL label */\n\tcase 3:\t/* IPv4 implicit NULL label */\n\t\tpt = PT_IPV4;\n\t\tbreak;\n\n\tcase 2:\t/* IPv6 explicit NULL label */\n\t\tpt = PT_IPV6;\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * Generally there's no indication of protocol in MPLS label\n\t\t * encoding.\n\t\t *\n\t\t * However, draft-hsmit-isis-aal5mux-00.txt describes a\n\t\t * technique for encapsulating IS-IS and IP traffic on the\n\t\t * same ATM virtual circuit; you look at the first payload\n\t\t * byte to determine the network layer protocol, based on\n\t\t * the fact that\n\t\t *\n\t\t *\t1) the first byte of an IP header is 0x45-0x4f\n\t\t *\t   for IPv4 and 0x60-0x6f for IPv6;\n\t\t *\n\t\t *\t2) the first byte of an OSI CLNP packet is 0x81,\n\t\t *\t   the first byte of an OSI ES-IS packet is 0x82,\n\t\t *\t   and the first byte of an OSI IS-IS packet is\n\t\t *\t   0x83;\n\t\t *\n\t\t * so the network layer protocol can be inferred from the\n\t\t * first byte of the packet, if the protocol is one of the\n\t\t * ones listed above.\n\t\t *\n\t\t * Cisco sends control-plane traffic MPLS-encapsulated in\n\t\t * this fashion.\n\t\t */\n\t\tND_TCHECK(*p);\n\t\tif (length < 1) {\n\t\t\t/* nothing to print */\n\t\t\treturn;\n\t\t}\n\t\tswitch(*p) {\n\n\t\tcase 0x45:\n\t\tcase 0x46:\n\t\tcase 0x47:\n\t\tcase 0x48:\n\t\tcase 0x49:\n\t\tcase 0x4a:\n\t\tcase 0x4b:\n\t\tcase 0x4c:\n\t\tcase 0x4d:\n\t\tcase 0x4e:\n\t\tcase 0x4f:\n\t\t\tpt = PT_IPV4;\n\t\t\tbreak;\n\n\t\tcase 0x60:\n\t\tcase 0x61:\n\t\tcase 0x62:\n\t\tcase 0x63:\n\t\tcase 0x64:\n\t\tcase 0x65:\n\t\tcase 0x66:\n\t\tcase 0x67:\n\t\tcase 0x68:\n\t\tcase 0x69:\n\t\tcase 0x6a:\n\t\tcase 0x6b:\n\t\tcase 0x6c:\n\t\tcase 0x6d:\n\t\tcase 0x6e:\n\t\tcase 0x6f:\n\t\t\tpt = PT_IPV6;\n\t\t\tbreak;\n\n\t\tcase 0x81:\n\t\tcase 0x82:\n\t\tcase 0x83:\n\t\t\tpt = PT_OSI;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* ok bail out - we did not figure out what it is*/\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Print the payload.\n\t */\n\tif (pt == PT_UNKNOWN) {\n\t\tif (!ndo->ndo_suppress_default_print)\n\t\t\tND_DEFAULTPRINT(p, length);\n\t\treturn;\n\t}\n\tND_PRINT((ndo, ndo->ndo_vflag ? \"\\n\\t\" : \" \"));\n\tswitch (pt) {\n\n\tcase PT_IPV4:\n\t\tip_print(ndo, p, length);\n\t\tbreak;\n\n\tcase PT_IPV6:\n\t\tip6_print(ndo, p, length);\n\t\tbreak;\n\n\tcase PT_OSI:\n\t\tisoclns_print(ndo, p, length);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \"[|MPLS]\"));\n}", "target": 3, "idx": 11069}
{"commit_id": "020176f688d9efec68f1ce1b100e052bff1cfc2e", "project": "wez/atomicparsley", "func": "void APar_ShowObjectProfileInfo(uint8_t track_type, TrackInfo *track_info) {\n  if (track_info->contains_esds) {\n    switch (track_info->ObjectTypeIndication) {\n    // 0x00 es Lambada/Verboten/Forbidden\n    case 0x01:\n    case 0x02: {\n      fprintf(stdout, \"  MPEG-4 Systems (BIFS/ObjDesc)\");\n      break;\n    }\n    case 0x03: {\n      fprintf(stdout, \"  Interaction Stream\");\n      break;\n    }\n    case 0x04: {\n      fprintf(stdout, \"  MPEG-4 Systems Extended BIFS\");\n      break;\n    }\n    case 0x05: {\n      fprintf(stdout, \"  MPEG-4 Systems AFX\");\n      break;\n    }\n    case 0x06: {\n      fprintf(stdout, \"  Font Data Stream\");\n      break;\n    }\n    case 0x08: {\n      fprintf(stdout, \"  Synthesized Texture Stream\");\n      break;\n    }\n    case 0x07: {\n      fprintf(stdout, \"  Streaming Text Stream\");\n      break;\n    }\n    // 0x09-0x1F reserved\n    case 0x20: {\n      APar_ShowMPEG4VisualProfileInfo(track_info);\n      break;\n    }\n\n    case 0x40: { // vererable mpeg-4 aac\n      APar_ShowMPEG4AACProfileInfo(track_info);\n      break;\n    }\n\n    // 0x41-0x5F reserved\n    case 0x60: {\n      fprintf(stdout,\n              \"  MPEG-2 Visual Simple Profile\"); //'Visual ISO/IEC 13818-2\n                                                 // Simple Profile'\n      break;\n    }\n    case 0x61: {\n      fprintf(stdout, \"  MPEG-2 Visual Main Profile\"); //'Visual ISO/IEC 13818-2\n                                                       // Main Profile'\n      break;\n    }\n    case 0x62: {\n      fprintf(\n          stdout,\n          \"  MPEG-2 Visual SNR Profile\"); //'Visual ISO/IEC 13818-2 SNR Profile'\n      break;\n    }\n    case 0x63: {\n      fprintf(stdout,\n              \"  MPEG-2 Visual Spatial Profile\"); //'Visual ISO/IEC 13818-2\n                                                  // Spatial Profile'\n      break;\n    }\n    case 0x64: {\n      fprintf(stdout, \"  MPEG-2 Visual High Profile\"); //'Visual ISO/IEC 13818-2\n                                                       // High Profile'\n      break;\n    }\n    case 0x65: {\n      fprintf(stdout, \"  MPEG-2 Visual 4:2:2 Profile\"); //'Visual ISO/IEC\n                                                        // 13818-2 422 Profile'\n      break;\n    }\n    case 0x66: {\n      fprintf(\n          stdout,\n          \"  MPEG-2 AAC Main Profile\"); //'Audio ISO/IEC 13818-7 Main Profile'\n      break;\n    }\n    case 0x67: {\n      fprintf(stdout,\n              \"  MPEG-2 AAC Low Complexity Profile\"); // Audio ISO/IEC 13818-7\n                                                      // LowComplexity Profile\n      break;\n    }\n    case 0x68: {\n      fprintf(\n          stdout,\n          \"  MPEG-2 AAC Scaleable Sample Rate Profile\"); //'Audio ISO/IEC\n                                                         // 13818-7 Scaleable\n                                                         // Sampling Rate\n                                                         // Profile'\n      break;\n    }\n    case 0x69: {\n      fprintf(stdout, \"  MPEG-2 Audio\"); //'Audio ISO/IEC 13818-3'\n      break;\n    }\n    case 0x6A: {\n      fprintf(stdout, \"  MPEG-1 Visual\"); //'Visual ISO/IEC 11172-2'\n      break;\n    }\n    case 0x6B: {\n      fprintf(stdout, \"  MPEG-1 Audio\"); //'Audio ISO/IEC 11172-3'\n      break;\n    }\n    case 0x6C: {\n      fprintf(stdout, \"  JPEG\"); //'Visual ISO/IEC 10918-1'\n      break;\n    }\n    case 0x6D: {\n      fprintf(stdout, \"  PNG\"); // http://www.mp4ra.org/object.html\n      break;\n    }\n    case 0x6E: {\n      fprintf(stdout, \"  JPEG2000\"); //'Visual ISO/IEC 15444-1'\n      break;\n    }\n    case 0xA0: {\n      fprintf(stdout, \"  3GPP2 EVRC Voice\"); // http://www.mp4ra.org/object.html\n      break;\n    }\n    case 0xA1: {\n      fprintf(stdout, \"  3GPP2 SMV Voice\"); // http://www.mp4ra.org/object.html\n      break;\n    }\n    case 0xA2: {\n      fprintf(\n          stdout,\n          \"  3GPP2 Compact Multimedia Format\"); // http://www.mp4ra.org/object.html\n      break;\n    }\n\n    // 0xC0-0xE0 user private\n    case 0xE1: {\n      fprintf(stdout,\n              \"  3GPP2 QCELP (14K Voice)\"); // http://www.mp4ra.org/object.html\n      break;\n    }\n      // 0xE2-0xFE user private\n      // 0xFF no object type specified\n\n    default: {\n      // so many profiles, so little desire to list them all (in 14496-2 which I\n      // don't have)\n      if (movie_info.contains_iods && iods_info.audio_profile == 0xFE) {\n        fprintf(stdout,\n                \"  Private user object: 0x%X\",\n                track_info->ObjectTypeIndication);\n      } else {\n        fprintf(\n            stdout,\n            \"  Object Type Indicator: 0x%X  Description Ojbect Type ID: 0x%X\\n\",\n            track_info->ObjectTypeIndication,\n            track_info->descriptor_object_typeID);\n      }\n      break;\n    }\n    }\n\n  } else if (track_type == AVC1_TRACK) {\n    // profiles & levels are in the 14496-10 pdf (which I don't have access to),\n    // so... http://lists.mpegif.org/pipermail/mp4-tech/2006-January/006255.html\n    // http://iphome.hhi.de/suehring/tml/doc/lenc/html/configfile_8c-source.html\n    // 66=baseline, 77=main, 88=extended; 100=High, 110=High 10, 122=High 4:2:2,\n    // 144=High 4:4:4\n\n    switch (track_info->profile) {\n    case 66: {\n      fprintf(stdout, \"  AVC Baseline Profile\");\n      break;\n    }\n    case 77: {\n      fprintf(stdout, \"  AVC Main Profile\");\n      break;\n    }\n    case 88: {\n      fprintf(stdout, \"  AVC Extended Profile\");\n      break;\n    }\n    case 100: {\n      fprintf(stdout, \"  AVC High Profile\");\n      break;\n    }\n    case 110: {\n      fprintf(stdout, \"  AVC High 10 Profile\");\n      break;\n    }\n    case 122: {\n      fprintf(stdout, \"  AVC High 4:2:2 Profile\");\n      break;\n    }\n    case 144: {\n      fprintf(stdout, \"  AVC High 4:4:4 Profile\");\n      break;\n    }\n    default: {\n      fprintf(stdout, \"  Unknown Profile: %u\", track_info->profile);\n      break;\n    }\n    } // end profile switch\n\n    // Don't have access to levels either, but working off of:\n    // http://iphome.hhi.de/suehring/tml/doc/lenc/html/configfile_8c-source.html\n\n    // and the 15 levels it says here:\n    // http://www.chiariglione.org/mpeg/technologies/mp04-avc/index.htm (1b in\n    // http://en.wikipedia.org/wiki/H.264 seems nonsensical) working backwards,\n    // we get... a simple 2 digit number (with '20' just drop the 0; with 21,\n    // put in a decimal)\n    if (track_info->level > 0) {\n      switch (track_info->level) {\n      case 10:\n      case 20:\n      case 30:\n      case 40:\n      case 50: {\n        fprintf(stdout, \",  Level %u\", track_info->level / 10);\n        break;\n      }\n      case 11:\n      case 12:\n      case 13:\n      case 21:\n      case 22:\n      case 31:\n      case 32:\n      case 41:\n      case 42:\n      case 51: {\n        fprintf(stdout,\n                \",  Level %u.%u\",\n                track_info->level / 10,\n                track_info->level % 10);\n        break;\n      }\n      default: {\n        fprintf(stdout,\n                \", Unknown level %u.%u\",\n                track_info->level / 10,\n                track_info->level % 10);\n      }\n\n      } // end switch\n    }   // end level if\n  } else if (track_type == S_AMR_TRACK) {\n    char amr_modes[500] = {};\n    if (track_info->track_codec == 0x73616D72 ||\n        track_info->track_codec == 0x73617762) {\n      if (track_info->amr_modes & 0x0001)\n        mem_append(\"0\", amr_modes);\n      if (track_info->amr_modes & 0x0002)\n        mem_append(\"1\", amr_modes);\n      if (track_info->amr_modes & 0x0004)\n        mem_append(\"2\", amr_modes);\n      if (track_info->amr_modes & 0x0008)\n        mem_append(\"3\", amr_modes);\n      if (track_info->amr_modes & 0x0010)\n        mem_append(\"4\", amr_modes);\n      if (track_info->amr_modes & 0x0020)\n        mem_append(\"5\", amr_modes);\n      if (track_info->amr_modes & 0x0040)\n        mem_append(\"6\", amr_modes);\n      if (track_info->amr_modes & 0x0080)\n        mem_append(\"7\", amr_modes);\n      if (track_info->amr_modes & 0x0100)\n        mem_append(\"8\", amr_modes);\n      if (strlen(amr_modes) == 0)\n        memcpy(amr_modes, \"none\", 4);\n    } else if (track_info->track_codec == 0x73766D72) {\n      if (track_info->amr_modes & 0x0001)\n        mem_append(\"VMR-WB Mode 0, \", amr_modes);\n      if (track_info->amr_modes & 0x0002)\n        mem_append(\"VMR-WB Mode 1, \", amr_modes);\n      if (track_info->amr_modes & 0x0004)\n        mem_append(\"VMR-WB Mode 2, \", amr_modes);\n      if (track_info->amr_modes & 0x0008)\n        mem_append(\"VMR-WB Mode 3 (AMR-WB interoperable mode), \", amr_modes);\n      if (track_info->amr_modes & 0x0010)\n        mem_append(\"VMR-WB Mode 4, \", amr_modes);\n      if (track_info->amr_modes & 0x0020)\n        mem_append(\"VMR-WB Mode 2 with maximum half-rate, \", amr_modes);\n      if (track_info->amr_modes & 0x0040)\n        mem_append(\"VMR-WB Mode 4 with maximum half-rate, \", amr_modes);\n      uint16_t amr_modes_len = strlen(amr_modes);\n      if (amr_modes_len > 0)\n        memset(amr_modes + (amr_modes_len - 1), 0, 2);\n    }\n\n    if (track_info->track_codec == 0x73616D72) { // samr\n      fprintf(stdout,\n              \"  AMR Narrow-Band. Modes: %s. Encoder vendor code: %s\\n\",\n              amr_modes,\n              track_info->encoder_name);\n    } else if (track_info->track_codec == 0x73617762) { // sawb\n      fprintf(stdout,\n              \"  AMR Wide-Band. Modes: %s. Encoder vendor code: %s\\n\",\n              amr_modes,\n              track_info->encoder_name);\n    } else if (track_info->track_codec == 0x73617770) { // sawp\n      fprintf(stdout,\n              \"  AMR Wide-Band WB+. Encoder vendor code: %s\\n\",\n              track_info->encoder_name);\n    } else if (track_info->track_codec == 0x73766D72) { // svmr\n      fprintf(stdout,\n              \"  AMR VBR Wide-Band. Encoder vendor code: %s\\n\",\n              track_info->encoder_name);\n    }\n  } else if (track_type == EVRC_TRACK) {\n    fprintf(stdout,\n            \"  EVRC (Enhanced Variable Rate Coder). Encoder vendor code: %s\\n\",\n            track_info->encoder_name);\n\n  } else if (track_type == QCELP_TRACK) {\n    fprintf(stdout,\n            \"  QCELP (Qualcomm Code Excited Linear Prediction). Encoder vendor \"\n            \"code: %s\\n\",\n            track_info->encoder_name);\n\n  } else if (track_type == S263_TRACK) {\n    if (track_info->profile == 0) {\n      fprintf(stdout,\n              \"  H.263 Baseline Profile, Level %u. Encoder vendor code: %s\",\n              track_info->level,\n              track_info->encoder_name);\n    } else {\n      fprintf(stdout,\n              \"  H.263 Profile: %u, Level %u. Encoder vendor code: %s\",\n              track_info->profile,\n              track_info->level,\n              track_info->encoder_name);\n    }\n  }\n  if (track_type == AUDIO_TRACK) {\n    if (track_info->section5_length == 0) {\n      fprintf(stdout, \"    channels: (%u)\\n\", track_info->channels);\n    } else {\n      fprintf(stdout, \"    channels: [%u]\\n\", track_info->channels);\n    }\n  }\n}", "target": 1, "idx": 11070}
{"commit_id": "3095060f479b86288e31c79ecbc5131a66bcd2f9", "project": "openbsd/src", "func": "static void\ndo_ssh2_kex(void)\n{\n\tchar *myproposal[PROPOSAL_MAX] = { KEX_SERVER };\n\tstruct kex *kex;\n\tint r;\n\n\tmyproposal[PROPOSAL_KEX_ALGS] = compat_kex_proposal(\n\t    options.kex_algorithms);\n\tmyproposal[PROPOSAL_ENC_ALGS_CTOS] = compat_cipher_proposal(\n\t    options.ciphers);\n\tmyproposal[PROPOSAL_ENC_ALGS_STOC] = compat_cipher_proposal(\n\t    options.ciphers);\n\tmyproposal[PROPOSAL_MAC_ALGS_CTOS] =\n\t    myproposal[PROPOSAL_MAC_ALGS_STOC] = options.macs;\n\n\tif (options.compression == COMP_NONE) {\n\t\tmyproposal[PROPOSAL_COMP_ALGS_CTOS] =\n\t\t    myproposal[PROPOSAL_COMP_ALGS_STOC] = \"none\";\n\t}\n\n\tif (options.rekey_limit || options.rekey_interval)\n\t\tpacket_set_rekey_limits(options.rekey_limit,\n\t\t    (time_t)options.rekey_interval);\n\n\tmyproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] = compat_pkalg_proposal(\n\t    list_hostkey_types());\n\n\t/* start key exchange */\n\tif ((r = kex_setup(active_state, myproposal)) != 0)\n\t\tfatal(\"kex_setup: %s\", ssh_err(r));\n\tkex = active_state->kex;\n#ifdef WITH_OPENSSL\n\tkex->kex[KEX_DH_GRP1_SHA1] = kexdh_server;\n\tkex->kex[KEX_DH_GRP14_SHA1] = kexdh_server;\n\tkex->kex[KEX_DH_GRP14_SHA256] = kexdh_server;\n\tkex->kex[KEX_DH_GRP16_SHA512] = kexdh_server;\n\tkex->kex[KEX_DH_GRP18_SHA512] = kexdh_server;\n\tkex->kex[KEX_DH_GEX_SHA1] = kexgex_server;\n\tkex->kex[KEX_DH_GEX_SHA256] = kexgex_server;\n\tkex->kex[KEX_ECDH_SHA2] = kexecdh_server;\n#endif\n\tkex->kex[KEX_C25519_SHA256] = kexc25519_server;\n\tkex->server = 1;\n\tkex->client_version_string=client_version_string;\n\tkex->server_version_string=server_version_string;\n\tkex->load_host_public_key=&get_hostkey_public_by_type;\n\tkex->load_host_private_key=&get_hostkey_private_by_type;\n\tkex->host_key_index=&get_hostkey_index;\n\tkex->sign = sshd_hostkey_sign;\n\n\tdispatch_run(DISPATCH_BLOCK, &kex->done, active_state);\n\n\tsession_id2 = kex->session_id;\n\tsession_id2_len = kex->session_id_len;\n\n#ifdef DEBUG_KEXDH\n\t/* send 1st encrypted/maced/compressed message */\n\tpacket_start(SSH2_MSG_IGNORE);\n\tpacket_put_cstring(\"markus\");\n\tpacket_send();\n\tpacket_write_wait();\n#endif\n\tdebug(\"KEX done\");\n}", "target": 2, "idx": 11071}
{"commit_id": "0215324a66af949be39b34be2d55143232c1cb71", "project": "redis", "func": "static void *createArrayObject(const redisReadTask *task, size_t elements) {\n    redisReply *r, *parent;\n\n    r = createReplyObject(task->type);\n    if (r == NULL)\n        return NULL;\n\n    if (elements > 0) {\n        if (SIZE_MAX / sizeof(redisReply*) < elements) return NULL;  /* Don't overflow */\n        r->element = hi_calloc(elements,sizeof(redisReply*));\n        if (r->element == NULL) {\n            freeReplyObject(r);\n            return NULL;\n        }\n    }\n\n    r->elements = elements;\n\n    if (task->parent) {\n        parent = task->parent->obj;\n        assert(parent->type == REDIS_REPLY_ARRAY ||\n               parent->type == REDIS_REPLY_MAP ||\n               parent->type == REDIS_REPLY_SET ||\n               parent->type == REDIS_REPLY_PUSH);\n        parent->element[task->idx] = r;\n    }\n    return r;\n}", "target": 2, "idx": 11072}
{"commit_id": "75b0cea7bf307f362057cc778efe89af4c615354", "project": "torvalds/linux", "func": "static ssize_t acpi_table_aml_write(struct config_item *cfg,\n\t\t\t\t    const void *data, size_t size)\n{\n\tconst struct acpi_table_header *header = data;\n\tstruct acpi_table *table;\n\tint ret = security_locked_down(LOCKDOWN_ACPI_TABLES);\n\n\tif (ret)\n\t\treturn ret;\n\n\ttable = container_of(cfg, struct acpi_table, cfg);\n\n\tif (table->header) {\n\t\tpr_err(\"table already loaded\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (header->length != size) {\n\t\tpr_err(\"invalid table length\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (memcmp(header->signature, ACPI_SIG_SSDT, 4)) {\n\t\tpr_err(\"invalid table signature\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttable = container_of(cfg, struct acpi_table, cfg);\n\n\ttable->header = kmemdup(header, header->length, GFP_KERNEL);\n\tif (!table->header)\n\t\treturn -ENOMEM;\n\n\tret = acpi_load_table(table->header, &table->index);\n\tif (ret) {\n\t\tkfree(table->header);\n\t\ttable->header = NULL;\n\t}\n\n\treturn ret;\n}", "target": 1, "idx": 11073}
{"commit_id": "58f9befca1fa172068effad7f2ea5a9d6a7b0cca", "project": "vim", "func": "static int\nnv_z_get_count(cmdarg_T *cap, int *nchar_arg)\n{\n    int\t\tnchar = *nchar_arg;\n    long\tn;\n\n    // \"z123{nchar}\": edit the count before obtaining {nchar}\n    if (checkclearop(cap->oap))\n\treturn FALSE;\n    n = nchar - '0';\n\n    for (;;)\n    {\n#ifdef USE_ON_FLY_SCROLL\n\tdont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n\t++no_mapping;\n\t++allow_keys;   // no mapping for nchar, but allow key codes\n\tnchar = plain_vgetc();\n\tLANGMAP_ADJUST(nchar, TRUE);\n\t--no_mapping;\n\t--allow_keys;\n\t(void)add_to_showcmd(nchar);\n\n\tif (nchar == K_DEL || nchar == K_KDEL)\n\t    n /= 10;\n\telse if (VIM_ISDIGIT(nchar))\n\t{\n\t    if (n > LONG_MAX / 10)\n\t    {\n\t\tclearopbeep(cap->oap);\n\t\tbreak;\n\t    }\n\t    n = n * 10 + (nchar - '0');\n\t}\n\telse if (nchar == CAR)\n\t{\n#ifdef FEAT_GUI\n\t    need_mouse_correct = TRUE;\n#endif\n\t    win_setheight((int)n);\n\t    break;\n\t}\n\telse if (nchar == 'l'\n\t\t|| nchar == 'h'\n\t\t|| nchar == K_LEFT\n\t\t|| nchar == K_RIGHT)\n\t{\n\t    cap->count1 = n ? n * cap->count1 : cap->count1;\n\t    *nchar_arg = nchar;\n\t    return TRUE;\n\t}\n\telse\n\t{\n\t    clearopbeep(cap->oap);\n\t    break;\n\t}\n    }\n    cap->oap->op_type = OP_NOP;\n    return FALSE;\n}", "target": 0, "idx": 11074}
{"commit_id": "97aa7d7cfd2027f6ba7ce42caf8b798541b9cdc6", "project": "ImageMagick", "func": "static Image *ReadHDRImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    format[MaxTextExtent],\n    keyword[MaxTextExtent],\n    tag[MaxTextExtent],\n    value[MaxTextExtent];\n\n  double\n    gamma;\n\n  Image\n    *image;\n\n  int\n    c;\n\n  MagickBooleanType\n    status,\n    value_expected;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *p;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *end,\n    pixel[4],\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Decode image header.\n  */\n  image->columns=0;\n  image->rows=0;\n  *format='\\0';\n  c=ReadBlobByte(image);\n  if (c == EOF)\n    {\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  while (isgraph(c) && (image->columns == 0) && (image->rows == 0))\n  {\n    if (c == (int) '#')\n      {\n        char\n          *comment;\n\n        register char\n          *p;\n\n        size_t\n          length;\n\n        /*\n          Read comment-- any text between # and end-of-line.\n        */\n        length=MaxTextExtent;\n        comment=AcquireString((char *) NULL);\n        for (p=comment; comment != (char *) NULL; p++)\n        {\n          c=ReadBlobByte(image);\n          if ((c == EOF) || (c == (int) '\\n'))\n            break;\n          if ((size_t) (p-comment+1) >= length)\n            {\n              *p='\\0';\n              length<<=1;\n              comment=(char *) ResizeQuantumMemory(comment,length+\n                MaxTextExtent,sizeof(*comment));\n              if (comment == (char *) NULL)\n                break;\n              p=comment+strlen(comment);\n            }\n          *p=(char) c;\n        }\n        if (comment == (char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        *p='\\0';\n        (void) SetImageProperty(image,\"comment\",comment,exception);\n        comment=DestroyString(comment);\n        c=ReadBlobByte(image);\n      }\n    else\n      if (isalnum(c) == MagickFalse)\n        c=ReadBlobByte(image);\n      else\n        {\n          register char\n            *p;\n\n          /*\n            Determine a keyword and its value.\n          */\n          p=keyword;\n          do\n          {\n            if ((size_t) (p-keyword) < (MaxTextExtent-1))\n              *p++=c;\n            c=ReadBlobByte(image);\n          } while (isalnum(c) || (c == '_'));\n          *p='\\0';\n          value_expected=MagickFalse;\n          while ((isspace((int) ((unsigned char) c)) != 0) || (c == '='))\n          {\n            if (c == '=')\n              value_expected=MagickTrue;\n            c=ReadBlobByte(image);\n          }\n          if (LocaleCompare(keyword,\"Y\") == 0)\n            value_expected=MagickTrue;\n          if (value_expected == MagickFalse)\n            continue;\n          p=value;\n          while ((c != '\\n') && (c != '\\0') && (c != EOF))\n          {\n            if ((size_t) (p-value) < (MaxTextExtent-1))\n              *p++=c;\n            c=ReadBlobByte(image);\n          }\n          *p='\\0';\n          /*\n            Assign a value to the specified keyword.\n          */\n          switch (*keyword)\n          {\n            case 'F':\n            case 'f':\n            {\n              if (LocaleCompare(keyword,\"format\") == 0)\n                {\n                  (void) CopyMagickString(format,value,MaxTextExtent);\n                  break;\n                }\n              (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n            case 'G':\n            case 'g':\n            {\n              if (LocaleCompare(keyword,\"gamma\") == 0)\n                {\n                  image->gamma=StringToDouble(value,(char **) NULL);\n                  break;\n                }\n              (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n            case 'P':\n            case 'p':\n            {\n              if (LocaleCompare(keyword,\"primaries\") == 0)\n                {\n                  float\n                    chromaticity[6],\n                    white_point[2];\n\n                  if (sscanf(value,\"%g %g %g %g %g %g %g %g\",&chromaticity[0],\n                      &chromaticity[1],&chromaticity[2],&chromaticity[3],\n                      &chromaticity[4],&chromaticity[5],&white_point[0],\n                      &white_point[1]) == 8)\n                    {\n                      image->chromaticity.red_primary.x=chromaticity[0];\n                      image->chromaticity.red_primary.y=chromaticity[1];\n                      image->chromaticity.green_primary.x=chromaticity[2];\n                      image->chromaticity.green_primary.y=chromaticity[3];\n                      image->chromaticity.blue_primary.x=chromaticity[4];\n                      image->chromaticity.blue_primary.y=chromaticity[5];\n                      image->chromaticity.white_point.x=white_point[0],\n                      image->chromaticity.white_point.y=white_point[1];\n                    }\n                  break;\n                }\n              (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n            case 'Y':\n            case 'y':\n            {\n              char\n                target[] = \"Y\";\n\n              if (strcmp(keyword,target) == 0)\n                {\n                  int\n                    height,\n                    width;\n\n                  if (sscanf(value,\"%d +X %d\",&height,&width) == 2)\n                    {\n                      image->columns=(size_t) width;\n                      image->rows=(size_t) height;\n                    }\n                  break;\n                }\n              (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n            default:\n            {\n              (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n          }\n        }\n    if ((image->columns == 0) && (image->rows == 0))\n      while (isspace((int) ((unsigned char) c)) != 0)\n        c=ReadBlobByte(image);\n  }\n  if ((LocaleCompare(format,\"32-bit_rle_rgbe\") != 0) &&\n      (LocaleCompare(format,\"32-bit_rle_xyze\") != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n  (void) SetImageColorspace(image,RGBColorspace,exception);\n  if (LocaleCompare(format,\"32-bit_rle_xyze\") == 0)\n    (void) SetImageColorspace(image,XYZColorspace,exception);\n  image->compression=(image->columns < 8) || (image->columns > 0x7ffff) ?\n    NoCompression : RLECompression;\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Read RGBE (red+green+blue+exponent) pixels.\n  */\n  pixels=(unsigned char *) AcquireQuantumMemory(image->columns,4*\n    sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    if (image->compression != RLECompression)\n      {\n        count=ReadBlob(image,4*image->columns*sizeof(*pixels),pixels);\n        if (count != (ssize_t) (4*image->columns*sizeof(*pixels)))\n          break;\n      }\n    else\n      {\n        count=ReadBlob(image,4*sizeof(*pixel),pixel);\n        if (count != 4)\n          break;\n        if ((size_t) ((((size_t) pixel[2]) << 8) | pixel[3]) != image->columns)\n          {\n            (void) memcpy(pixels,pixel,4*sizeof(*pixel));\n            count=ReadBlob(image,4*(image->columns-1)*sizeof(*pixels),pixels+4);\n            image->compression=NoCompression;\n          }\n        else\n          {\n            p=pixels;\n            for (i=0; i < 4; i++)\n            {\n              end=&pixels[(i+1)*image->columns];\n              while (p < end)\n              {\n                count=ReadBlob(image,2*sizeof(*pixel),pixel);\n                if (count < 1)\n                  break;\n                if (pixel[0] > 128)\n                  {\n                    count=(ssize_t) pixel[0]-128;\n                    if ((count == 0) || (count > (ssize_t) (end-p)))\n                      break;\n                    while (count-- > 0)\n                      *p++=pixel[1];\n                  }\n                else\n                  {\n                    count=(ssize_t) pixel[0];\n                    if ((count == 0) || (count > (ssize_t) (end-p)))\n                      break;\n                    *p++=pixel[1];\n                    if (--count > 0)\n                      {\n                        count=ReadBlob(image,(size_t) count*sizeof(*p),p);\n                        if (count < 1)\n                          break;\n                        p+=count;\n                      }\n                  }\n              }\n            }\n          }\n      }\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    i=0;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (image->compression == RLECompression)\n        {\n          pixel[0]=pixels[x];\n          pixel[1]=pixels[x+image->columns];\n          pixel[2]=pixels[x+2*image->columns];\n          pixel[3]=pixels[x+3*image->columns];\n        }\n      else\n        {\n          pixel[0]=pixels[i++];\n          pixel[1]=pixels[i++];\n          pixel[2]=pixels[i++];\n          pixel[3]=pixels[i++];\n        }\n      SetPixelRed(image,0,q);\n      SetPixelGreen(image,0,q);\n      SetPixelBlue(image,0,q);\n      if (pixel[3] != 0)\n        {\n          gamma=pow(2.0,pixel[3]-(128.0+8.0));\n          SetPixelRed(image,ClampToQuantum(QuantumRange*gamma*pixel[0]),q);\n          SetPixelGreen(image,ClampToQuantum(QuantumRange*gamma*pixel[1]),q);\n          SetPixelBlue(image,ClampToQuantum(QuantumRange*gamma*pixel[2]),q);\n        }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}", "target": 1, "idx": 11075}
{"commit_id": "f3fe91fc65d17687822ed8f376f2e54b97f18291", "project": "appneta/tcpreplay", "func": "int\ndo_checksum(tcpedit_t *tcpedit, uint8_t *data, int proto, int payload_len) {\n    ipv4_hdr_t *ipv4;\n    ipv6_hdr_t *ipv6;\n    tcp_hdr_t *tcp;\n    udp_hdr_t *udp;\n    icmpv4_hdr_t *icmp;\n    icmpv6_hdr_t *icmp6;\n    u_char *layer;\n    int ip_hl;\n    int sum;\n\n    sum = 0;\n    ipv4 = NULL;\n    ipv6 = NULL;\n    assert(data);\n\n    if (!data || payload_len < (int)sizeof(*ipv4) || payload_len > 0xffff) {\n        tcpedit_setwarn(tcpedit, \"%s\", \"Unable to checksum packet with no L3+ data\");\n        return TCPEDIT_WARN;\n    }\n\n    ipv4 = (ipv4_hdr_t *)data;\n    if (ipv4->ip_v == 6) {\n        if (payload_len < sizeof(*ipv6)) {\n            tcpedit_setwarn(tcpedit, \"%s\", \"Unable to checksum IPv6 packet with insufficient data\");\n            return TCPEDIT_WARN;\n        }\n\n        ipv6 = (ipv6_hdr_t *)data;\n        ipv4 = NULL;\n\n        proto = get_ipv6_l4proto(ipv6, payload_len + sizeof(ipv6_hdr_t));\n        dbgx(3, \"layer4 proto is 0x%hx\", (uint16_t)proto);\n\n        layer = (u_char*)get_layer4_v6(ipv6, payload_len + sizeof(ipv6_hdr_t));\n        if (!layer) {\n            tcpedit_setwarn(tcpedit, \"%s\", \"Packet to short for checksum\");\n            return TCPEDIT_WARN;\n        }\n\n        ip_hl = layer - (u_char*)data;\n        dbgx(3, \"ip_hl proto is 0x%d\", ip_hl);\n\n        payload_len -= (ip_hl - TCPR_IPV6_H);\n    } else {\n        ip_hl = ipv4->ip_hl << 2;\n    }\n\n    switch (proto) {\n        case IPPROTO_TCP:\n            if (payload_len < (int)sizeof(tcp_hdr_t)) {\n                tcpedit_setwarn(tcpedit, \"%s\", \"Unable to checksum TCP with insufficient L4 data\");\n                return TCPEDIT_WARN;\n            }\n\n            tcp = (tcp_hdr_t *)(data + ip_hl);\n#ifdef STUPID_SOLARIS_CHECKSUM_BUG\n            tcp->th_sum = tcp->th_off << 2;\n            return (TCPEDIT_OK);\n#endif\n            tcp->th_sum = 0;\n\n            /* Note, we do both src & dst IP's at the same time, that's why the\n             * length is 2x a single IP\n             */\n            if (ipv6 != NULL) {\n                sum = do_checksum_math((uint16_t *)&ipv6->ip_src, 32);\n            } else {\n                sum = do_checksum_math((uint16_t *)&ipv4->ip_src, 8);\n            }\n            sum += ntohs(IPPROTO_TCP + payload_len);\n            sum += do_checksum_math((uint16_t *)tcp, payload_len);\n            tcp->th_sum = CHECKSUM_CARRY(sum);\n            break;\n\n        case IPPROTO_UDP:\n            if (payload_len < (int)sizeof(udp_hdr_t)) {\n                tcpedit_setwarn(tcpedit, \"%s\", \"Unable to checksum UDP with insufficient L4 data\");\n                return TCPEDIT_WARN;\n            }\n            udp = (udp_hdr_t *)(data + ip_hl);\n            /* No need to recalculate UDP checksums if already 0 */\n            if (udp->uh_sum == 0)\n                break;\n            udp->uh_sum = 0;\n            if (ipv6 != NULL) {\n                sum = do_checksum_math((uint16_t *)&ipv6->ip_src, 32);\n            } else {\n                sum = do_checksum_math((uint16_t *)&ipv4->ip_src, 8);\n            }\n            sum += ntohs(IPPROTO_UDP + payload_len);\n            sum += do_checksum_math((uint16_t *)udp, payload_len);\n            udp->uh_sum = CHECKSUM_CARRY(sum);\n            break;\n\n        case IPPROTO_ICMP:\n            if (payload_len < (int)sizeof(icmpv4_hdr_t)) {\n                tcpedit_setwarn(tcpedit, \"%s\", \"Unable to checksum ICMP with insufficient L4 data\");\n                return TCPEDIT_WARN;\n            }\n            icmp = (icmpv4_hdr_t *)(data + ip_hl);\n            icmp->icmp_sum = 0;\n            if (ipv6 != NULL) {\n                sum = do_checksum_math((uint16_t *)&ipv6->ip_src, 32);\n                icmp->icmp_sum = CHECKSUM_CARRY(sum);\n            }\n            sum += do_checksum_math((uint16_t *)icmp, payload_len);\n            icmp->icmp_sum = CHECKSUM_CARRY(sum);\n            break;\n\n        case IPPROTO_ICMP6:\n            if (payload_len < (int)sizeof(icmpv6_hdr_t)) {\n                tcpedit_setwarn(tcpedit, \"%s\", \"Unable to checksum ICMP6 with insufficient L4 data\");\n                return TCPEDIT_WARN;\n            }\n            icmp6 = (icmpv6_hdr_t *)(data + ip_hl);\n            icmp6->icmp_sum = 0;\n            if (ipv6 != NULL) {\n                sum = do_checksum_math((u_int16_t *)&ipv6->ip_src, 32);\n            }\n            sum += ntohs(IPPROTO_ICMP6 + payload_len);\n            sum += do_checksum_math((u_int16_t *)icmp6, payload_len);\n            icmp6->icmp_sum = CHECKSUM_CARRY(sum);\n            break;\n\n        case IPPROTO_IP:\n            if (ipv4) {\n                ipv4->ip_sum = 0;\n                sum = do_checksum_math((uint16_t *)data, ip_hl);\n                ipv4->ip_sum = CHECKSUM_CARRY(sum);\n            }\n            break;\n\n        case IPPROTO_IGMP:\n        case IPPROTO_GRE:\n        case IPPROTO_OSPF:\n        case IPPROTO_OSPF_LSA:\n        case IPPROTO_VRRP:\n        case TCPR_PROTO_CDP:\n        case TCPR_PROTO_ISL:\n        default:\n            tcpedit_setwarn(tcpedit, \"Unsupported protocol for checksum: 0x%x\", proto);\n            return TCPEDIT_WARN;\n    }\n\n    return TCPEDIT_OK;\n}", "target": 1, "idx": 11076}
{"commit_id": "886cd1d2314755adb1f4cdb99c16ff00830f0331", "project": "exempi", "func": "bool TradQT_Manager::ParseCachedBoxes ( const MOOV_Manager & moovMgr )\n{\n\tMOOV_Manager::BoxInfo udtaInfo;\n\tMOOV_Manager::BoxRef  udtaRef = moovMgr.GetBox ( \"moov/udta\", &udtaInfo );\n\tif ( udtaRef == 0 ) return false;\n\n\tfor ( XMP_Uns32 i = 0; i < udtaInfo.childCount; ++i ) {\n\n\t\tMOOV_Manager::BoxInfo currInfo;\n\t\tMOOV_Manager::BoxRef  currRef = moovMgr.GetNthChild ( udtaRef, i, &currInfo );\n\t\tif ( currRef == 0 ) break;\t// Sanity check, should not happen.\n\t\tif ( (currInfo.boxType >> 24) != 0xA9 ) continue;\n\t\tif ( currInfo.contentSize < 2+2+1 ) continue;\t// Want enough for a non-empty value.\n\t\t\n\t\tInfoMapPos newInfo = this->parsedBoxes.insert ( this->parsedBoxes.end(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tInfoMap::value_type ( currInfo.boxType, ParsedBoxInfo ( currInfo.boxType ) ) );\n\t\tstd::vector<ValueInfo> * newValues = &newInfo->second.values;\n\t\t\n\t\tXMP_Uns8 * boxPtr = (XMP_Uns8*) currInfo.content;\n\t\tXMP_Uns8 * boxEnd = boxPtr + currInfo.contentSize;\n\t\tXMP_Uns16 miniLen, macLang;\n\n\t\tfor ( ; boxPtr < boxEnd-4; boxPtr += miniLen ) {\n\n\t\t\tminiLen = 4 + GetUns16BE ( boxPtr );\t// ! Include header in local miniLen.\n\t\t\tmacLang  = GetUns16BE ( boxPtr+2);\n\t\t\tif ( (miniLen <= 4) || (miniLen > (boxEnd - boxPtr)) )\n\t\t\t\tbreak;\t// Ignore bad or empty values.\n\t\t\t\n\t\t\tXMP_StringPtr valuePtr = (char*)(boxPtr+4);\n\t\t\tsize_t valueLen = miniLen - 4;\n\n\t\t\tnewValues->push_back ( ValueInfo() );\n\t\t\tValueInfo * newValue = &newValues->back();\n\t\t\t\n\t\t\t// Only set the XMP language if the Mac script is known, i.e. the value can be converted.\n\t\t\t\n\t\t\tnewValue->macLang = macLang;\n\t\t\tif ( IsMacLangKnown ( macLang ) ) newValue->xmpLang = GetXMPLang ( macLang );\n\t\t\tnewValue->macValue.assign ( valuePtr, valueLen );\n\n\t\t}\n\n\t}\n\t\n\treturn (! this->parsedBoxes.empty());\n\n}", "target": 1, "idx": 11077}
{"commit_id": "95610818918f6f11fe7d23aca1380e6c0fac2af0", "project": "android", "func": "void RilSapSocket::sendResponse(MsgHeader* hdr) {\n    size_t encoded_size = 0;\n    uint32_t written_size;\n    size_t buffer_size = 0;\n    pb_ostream_t ostream;\n    bool success = false;\n\n    pthread_mutex_lock(&write_lock);\n\n    if ((success = pb_get_encoded_size(&encoded_size, MsgHeader_fields,\n        hdr)) && encoded_size <= INT32_MAX && commandFd != -1) {\n        buffer_size = encoded_size + sizeof(uint32_t);\n        uint8_t* buffer = (uint8_t*)malloc(buffer_size);\n        if (!buffer) {\n            RLOGE(\"sendResponse: OOM\");\n            pthread_mutex_unlock(&write_lock);\n            return;\n        }\n        written_size = htonl((uint32_t) encoded_size);\n        ostream = pb_ostream_from_buffer(buffer, buffer_size);\n        pb_write(&ostream, (uint8_t *)&written_size, sizeof(written_size));\n        success = pb_encode(&ostream, MsgHeader_fields, hdr);\n\n        if (success) {\n            RLOGD(\"Size: %d (0x%x) Size as written: 0x%x\", encoded_size, encoded_size,\n        written_size);\n            log_hex(\"onRequestComplete\", &buffer[sizeof(written_size)], encoded_size);\n            RLOGI(\"[%d] < SAP RESPONSE type: %d. id: %d. error: %d\",\n        hdr->token, hdr->type, hdr->id,hdr->error );\n\n            if ( 0 != blockingWrite_helper(commandFd, buffer, buffer_size)) {\n                RLOGE(\"Error %d while writing to fd\", errno);\n            } else {\n                RLOGD(\"Write successful\");\n            }\n        } else {\n            RLOGE(\"Error while encoding response of type %d id %d buffer_size: %d: %s.\",\n            hdr->type, hdr->id, buffer_size, PB_GET_ERROR(&ostream));\n        }\n        free(buffer);\n    } else {\n    RLOGE(\"Not sending response type %d: encoded_size: %u. commandFd: %d. encoded size result: %d\",\n        hdr->type, encoded_size, commandFd, success);\n    }\n\n    pthread_mutex_unlock(&write_lock);\n}", "target": 2, "idx": 11078}
{"commit_id": "cf6da6b79080a8c16984102fdc85f7ce28dca613", "project": "python-pillow/Pillow", "func": "static int\nj2k_decode_entry(Imaging im, ImagingCodecState state)\n{\n    JPEG2KDECODESTATE *context = (JPEG2KDECODESTATE *) state->context;\n    opj_stream_t *stream = NULL;\n    opj_image_t *image = NULL;\n    opj_codec_t *codec = NULL;\n    opj_dparameters_t params;\n    OPJ_COLOR_SPACE color_space;\n    j2k_unpacker_t unpack = NULL;\n    size_t buffer_size = 0, tile_bytes = 0;\n    unsigned n, tile_height, tile_width;\n    int components;\n\n\n    stream = opj_stream_create(BUFFER_SIZE, OPJ_TRUE);\n\n    if (!stream) {\n        state->errcode = IMAGING_CODEC_BROKEN;\n        state->state = J2K_STATE_FAILED;\n        goto quick_exit;\n    }\n\n    opj_stream_set_read_function(stream, j2k_read);\n    opj_stream_set_skip_function(stream, j2k_skip);\n\n    /* OpenJPEG 2.0 doesn't have OPJ_VERSION_MAJOR */\n#ifndef OPJ_VERSION_MAJOR\n    opj_stream_set_user_data(stream, state);\n#else\n    opj_stream_set_user_data(stream, state, NULL);\n\n    /* Hack: if we don't know the length, the largest file we can\n       possibly support is 4GB.  We can't go larger than this, because\n       OpenJPEG truncates this value for the final box in the file, and\n       the box lengths in OpenJPEG are currently 32 bit. */\n    if (context->length < 0)\n        opj_stream_set_user_data_length(stream, 0xffffffff);\n    else\n        opj_stream_set_user_data_length(stream, context->length);\n#endif\n\n    /* Setup decompression context */\n    context->error_msg = NULL;\n\n    opj_set_default_decoder_parameters(&params);\n    params.cp_reduce = context->reduce;\n    params.cp_layer = context->layers;\n\n    codec = opj_create_decompress(context->format);\n\n    if (!codec) {\n        state->errcode = IMAGING_CODEC_BROKEN;\n        state->state = J2K_STATE_FAILED;\n        goto quick_exit;\n    }\n\n    opj_set_error_handler(codec, j2k_error, context);\n    opj_setup_decoder(codec, &params);\n\n    if (!opj_read_header(stream, codec, &image)) {\n        state->errcode = IMAGING_CODEC_BROKEN;\n        state->state = J2K_STATE_FAILED;\n        goto quick_exit;\n    }\n\n    /* Check that this image is something we can handle */\n    if (image->numcomps < 1 || image->numcomps > 4\n        || image->color_space == OPJ_CLRSPC_UNKNOWN) {\n        state->errcode = IMAGING_CODEC_BROKEN;\n        state->state = J2K_STATE_FAILED;\n        goto quick_exit;\n    }\n\n    for (n = 1; n < image->numcomps; ++n) {\n        if (image->comps[n].dx != 1 || image->comps[n].dy != 1) {\n            state->errcode = IMAGING_CODEC_BROKEN;\n            state->state = J2K_STATE_FAILED;\n            goto quick_exit;\n        }\n    }\n\n    /*\n         Colorspace    Number of components    PIL mode\n       ------------------------------------------------------\n         sRGB          3                       RGB\n         sRGB          4                       RGBA\n         gray          1                       L or I\n         gray          2                       LA\n         YCC           3                       YCbCr\n\n\n       If colorspace is unspecified, we assume:\n\n           Number of components   Colorspace\n         -----------------------------------------\n           1                      gray\n           2                      gray (+ alpha)\n           3                      sRGB\n           4                      sRGB (+ alpha)\n\n    */\n\n    /* Find the correct unpacker */\n    color_space = image->color_space;\n\n    if (color_space == OPJ_CLRSPC_UNSPECIFIED) {\n        switch (image->numcomps) {\n        case 1: case 2: color_space = OPJ_CLRSPC_GRAY; break;\n        case 3: case 4: color_space = OPJ_CLRSPC_SRGB; break;\n        }\n    }\n\n    for (n = 0; n < sizeof(j2k_unpackers) / sizeof (j2k_unpackers[0]); ++n) {\n        if (color_space == j2k_unpackers[n].color_space\n            && image->numcomps == j2k_unpackers[n].components\n            && strcmp (im->mode, j2k_unpackers[n].mode) == 0) {\n            unpack = j2k_unpackers[n].unpacker;\n            break;\n        }\n    }\n\n    if (!unpack) {\n        state->errcode = IMAGING_CODEC_BROKEN;\n        state->state = J2K_STATE_FAILED;\n        goto quick_exit;\n    }\n\n    /* Decode the image tile-by-tile; this means we only need use as much\n       memory as is required for one tile's worth of components. */\n    for (;;) {\n        JPEG2KTILEINFO tile_info;\n        OPJ_BOOL should_continue;\n        unsigned correction = (1 << params.cp_reduce) - 1;\n\n        if (!opj_read_tile_header(codec,\n                                  stream,\n                                  &tile_info.tile_index,\n                                  &tile_info.data_size,\n                                  &tile_info.x0, &tile_info.y0,\n                                  &tile_info.x1, &tile_info.y1,\n                                  &tile_info.nb_comps,\n                                  &should_continue)) {\n            state->errcode = IMAGING_CODEC_BROKEN;\n            state->state = J2K_STATE_FAILED;\n            goto quick_exit;\n        }\n\n        if (!should_continue)\n            break;\n\n        /* Adjust the tile co-ordinates based on the reduction (OpenJPEG\n           doesn't do this for us) */\n        tile_info.x0 = (tile_info.x0 + correction) >> context->reduce;\n        tile_info.y0 = (tile_info.y0 + correction) >> context->reduce;\n        tile_info.x1 = (tile_info.x1 + correction) >> context->reduce;\n        tile_info.y1 = (tile_info.y1 + correction) >> context->reduce;\n\n        /* Check the tile bounds; if the tile is outside the image area,\n           or if it has a negative width or height (i.e. the coordinates are\n           swapped), bail. */\n        if (tile_info.x0 >= tile_info.x1\n            || tile_info.y0 >= tile_info.y1\n            || tile_info.x0 < image->x0\n            || tile_info.y0 < image->y0\n            || tile_info.x1 - image->x0 > im->xsize\n            || tile_info.y1 - image->y0 > im->ysize) {\n            state->errcode = IMAGING_CODEC_BROKEN;\n            state->state = J2K_STATE_FAILED;\n            goto quick_exit;\n        }\n\n        /* Sometimes the tile_info.datasize we get back from openjpeg\n           is is less than numcomps*w*h, and we overflow in the\n           shuffle stage */\n\n        tile_width = tile_info.x1 - tile_info.x0;\n        tile_height = tile_info.y1 - tile_info.y0;\n        components = tile_info.nb_comps == 3 ? 4 : tile_info.nb_comps;\n        if (( tile_width > UINT_MAX / components ) ||\n            ( tile_height > UINT_MAX / components ) ||\n            ( tile_width > UINT_MAX / (tile_height * components )) ||\n            ( tile_height > UINT_MAX / (tile_width * components ))) {\n            state->errcode = IMAGING_CODEC_BROKEN;\n            state->state = J2K_STATE_FAILED;\n            goto quick_exit;\n        }\n\n        tile_bytes = tile_width * tile_height * components;\n\n        if (tile_bytes > tile_info.data_size) {\n            tile_info.data_size = tile_bytes;\n        }\n\n        if (buffer_size < tile_info.data_size) {\n            /* malloc check ok, overflow and tile size sanity check above */\n            UINT8 *new = realloc (state->buffer, tile_info.data_size);\n            if (!new) {\n                state->errcode = IMAGING_CODEC_MEMORY;\n                state->state = J2K_STATE_FAILED;\n                goto quick_exit;\n            }\n            state->buffer = new;\n            buffer_size = tile_info.data_size;\n        }\n\n\n        if (!opj_decode_tile_data(codec,\n                                  tile_info.tile_index,\n                                  (OPJ_BYTE *)state->buffer,\n                                  tile_info.data_size,\n                                  stream)) {\n            state->errcode = IMAGING_CODEC_BROKEN;\n            state->state = J2K_STATE_FAILED;\n            goto quick_exit;\n        }\n\n        unpack(image, &tile_info, state->buffer, im);\n    }\n\n    if (!opj_end_decompress(codec, stream)) {\n        state->errcode = IMAGING_CODEC_BROKEN;\n        state->state = J2K_STATE_FAILED;\n        goto quick_exit;\n    }\n\n    state->state = J2K_STATE_DONE;\n    state->errcode = IMAGING_CODEC_END;\n\n    if (context->pfile) {\n        if(fclose(context->pfile)){\n            context->pfile = NULL;\n        }\n    }\n\n quick_exit:\n    if (codec)\n        opj_destroy_codec(codec);\n    if (image)\n        opj_image_destroy(image);\n    if (stream)\n        opj_stream_destroy(stream);\n\n    return -1;\n}", "target": 1, "idx": 11079}
{"commit_id": "9b54d816e00425c3a517514e0d677bb3cec49258", "project": "torvalds/linux", "func": "int blkcg_init_queue(struct request_queue *q)\n{\n\tstruct blkcg_gq *new_blkg, *blkg;\n\tbool preloaded;\n\tint ret;\n\n\tnew_blkg = blkg_alloc(&blkcg_root, q, GFP_KERNEL);\n\tif (!new_blkg)\n\t\treturn -ENOMEM;\n\n\tpreloaded = !radix_tree_preload(GFP_KERNEL);\n\n\t/*\n\t * Make sure the root blkg exists and count the existing blkgs.  As\n\t * @q is bypassing at this point, blkg_lookup_create() can't be\n\t * used.  Open code insertion.\n\t */\n\trcu_read_lock();\n\tspin_lock_irq(q->queue_lock);\n\tblkg = blkg_create(&blkcg_root, q, new_blkg);\n\tspin_unlock_irq(q->queue_lock);\n\trcu_read_unlock();\n\n\tif (preloaded)\n\t\tradix_tree_preload_end();\n\n\tif (IS_ERR(blkg))\n\t\treturn PTR_ERR(blkg);\n\n\tq->root_blkg = blkg;\n\tq->root_rl.blkg = blkg;\n\n\tret = blk_throtl_init(q);\n\tif (ret) {\n\t\tspin_lock_irq(q->queue_lock);\n\t\tblkg_destroy_all(q);\n\t\tspin_unlock_irq(q->queue_lock);\n\t}\n\treturn ret;\n}", "target": 2, "idx": 11080}
{"commit_id": "2a2f11c227bdf292b3a2900ad04139d301b56ac4", "project": "torvalds/linux", "func": "static int netlbl_cipsov4_add_common(struct genl_info *info,\n\t\t\t\t     struct cipso_v4_doi *doi_def)\n{\n\tstruct nlattr *nla;\n\tint nla_rem;\n\tu32 iter = 0;\n\n\tdoi_def->doi = nla_get_u32(info->attrs[NLBL_CIPSOV4_A_DOI]);\n\n\tif (nla_validate_nested(info->attrs[NLBL_CIPSOV4_A_TAGLST],\n\t\t\t\tNLBL_CIPSOV4_A_MAX,\n\t\t\t\tnetlbl_cipsov4_genl_policy) != 0)\n\t\treturn -EINVAL;\n\n\tnla_for_each_nested(nla, info->attrs[NLBL_CIPSOV4_A_TAGLST], nla_rem)\n\t\tif (nla->nla_type == NLBL_CIPSOV4_A_TAG) {\n\t\t\tif (iter >= CIPSO_V4_TAG_MAXCNT)\n\t\t\t\treturn -EINVAL;\n\t\t\tdoi_def->tags[iter++] = nla_get_u8(nla);\n\t\t}\n\twhile (iter < CIPSO_V4_TAG_MAXCNT)\n\t\tdoi_def->tags[iter++] = CIPSO_V4_TAG_INVALID;\n\n\treturn 0;\n}", "target": 3, "idx": 11081}
{"commit_id": "72ec933663f738d8e166979aa7fd5590b2104a07", "project": "gdraheim/zziplib", "func": "zzip__new__ ZZIP_MEM_DISK *\nzzip_mem_disk_fdopen(int fd)\n{\n    ZZIP_DISK *disk = zzip_disk_mmap(fd);\n    if (! disk)\n    { \n       debug2(\"can not open disk fd %i\", fd);\n       return 0;\n    }\n    ___ ZZIP_MEM_DISK *dir = zzip_mem_disk_new();\n    if (zzip_mem_disk_load(dir, disk) == -1)\n    {\n       debug2(\"unable to load disk fd %s\", fd);\n    }\n    return dir;\n    ____;\n}", "target": 1, "idx": 11082}
{"commit_id": "b534e304568585707c4a92422aeca25cf908ff02", "project": "the-tcpdump-group/tcpdump", "func": "u_int\njuniper_es_print(netdissect_options *ndo,\n                 const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n        struct juniper_ipsec_header {\n            uint8_t sa_index[2];\n            uint8_t ttl;\n            uint8_t type;\n            uint8_t spi[4];\n            uint8_t src_ip[4];\n            uint8_t dst_ip[4];\n        };\n        u_int rewrite_len,es_type_bundle;\n        const struct juniper_ipsec_header *ih;\n\n        l2info.pictype = DLT_JUNIPER_ES;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n\n        p+=l2info.header_len;\n        ih = (const struct juniper_ipsec_header *)p;\n\n        ND_TCHECK(*ih);\n        switch (ih->type) {\n        case JUNIPER_IPSEC_O_ESP_ENCRYPT_ESP_AUTHEN_TYPE:\n        case JUNIPER_IPSEC_O_ESP_ENCRYPT_AH_AUTHEN_TYPE:\n            rewrite_len = 0;\n            es_type_bundle = 1;\n            break;\n        case JUNIPER_IPSEC_O_ESP_AUTHENTICATION_TYPE:\n        case JUNIPER_IPSEC_O_AH_AUTHENTICATION_TYPE:\n        case JUNIPER_IPSEC_O_ESP_ENCRYPTION_TYPE:\n            rewrite_len = 16;\n            es_type_bundle = 0;\n            break;\n        default:\n            ND_PRINT((ndo, \"ES Invalid type %u, length %u\",\n                   ih->type,\n                   l2info.length));\n            return l2info.header_len;\n        }\n\n        l2info.length-=rewrite_len;\n        p+=rewrite_len;\n\n        if (ndo->ndo_eflag) {\n            if (!es_type_bundle) {\n                ND_PRINT((ndo, \"ES SA, index %u, ttl %u type %s (%u), spi %u, Tunnel %s > %s, length %u\\n\",\n                       EXTRACT_16BITS(&ih->sa_index),\n                       ih->ttl,\n                       tok2str(juniper_ipsec_type_values,\"Unknown\",ih->type),\n                       ih->type,\n                       EXTRACT_32BITS(&ih->spi),\n                       ipaddr_string(ndo, &ih->src_ip),\n                       ipaddr_string(ndo, &ih->dst_ip),\n                       l2info.length));\n            } else {\n                ND_PRINT((ndo, \"ES SA, index %u, ttl %u type %s (%u), length %u\\n\",\n                       EXTRACT_16BITS(&ih->sa_index),\n                       ih->ttl,\n                       tok2str(juniper_ipsec_type_values,\"Unknown\",ih->type),\n                       ih->type,\n                       l2info.length));\n            }\n        }\n\n        ip_print(ndo, p, l2info.length);\n        return l2info.header_len;\n\ntrunc:\n\tND_PRINT((ndo, \"[|juniper_services]\"));\n\treturn l2info.header_len;\n}", "target": 3, "idx": 11083}
{"commit_id": "7eeb638f32d9d18f184e8a5d60dda92e53857346", "project": "Exiv2/exiv2", "func": "DataLocId CiffComponent::dataLocation(uint16_t tag)\n    {\n        switch (tag & 0xc000) {\n        case 0x0000: return valueData;\n        case 0x4000: return directoryData;\n        default: throw Error(kerCorruptedMetadata);\n        }\n    }", "target": 1, "idx": 11084}
{"commit_id": "cb0b99f0672d8446585d26e998343dceca17d1ce", "project": "vim", "func": "int\nadjust_plines_for_skipcol(win_T *wp)\n{\n    if (wp->w_skipcol == 0)\n\treturn 0;\n\n    int width = wp->w_width - win_col_off(wp);\n    int w2 = width + win_col_off2(wp);\n    if (wp->w_skipcol >= width && w2 > 0)\n\treturn (wp->w_skipcol - width) / w2 + 1;\n\n    return 0;\n}", "target": 0, "idx": 11085}
{"commit_id": "0c17eb33c0a7fad1796ce23b8bbc32067f511aed", "project": "Exiv2/exiv2", "func": "DataBuf packIfdId(const ExifData& exifData,\n                            IfdId     ifdId,\n                            ByteOrder byteOrder)\n    {\n        const uint16_t size = 1024;\n        DataBuf buf(size);\n        std::memset(buf.pData_, 0x0, buf.size_);\n\n        uint16_t len = 0;\n        const ExifData::const_iterator b = exifData.begin();\n        const ExifData::const_iterator e = exifData.end();\n        for (ExifData::const_iterator i = b; i != e; ++i) {\n            if (i->ifdId() != ifdId) continue;\n            const uint16_t s = i->tag()*2 + static_cast<uint16_t>(i->size());\n            if (s <= size) {\n                if (len < s) len = s;\n                i->copy(buf.pData_ + i->tag()*2, byteOrder);\n            }\n        }\n        // Round the size to make it even.\n        buf.size_ = len + len%2;\n        return buf;\n    }", "target": 1, "idx": 11086}
{"commit_id": "b52fe2dbb3e655eb1483000adfab68a219549e13", "project": "torvalds/linux", "func": "static int dwc3_qcom_probe(struct platform_device *pdev)\n{\n\tstruct device_node\t*np = pdev->dev.of_node;\n\tstruct device\t\t*dev = &pdev->dev;\n\tstruct dwc3_qcom\t*qcom;\n\tstruct resource\t\t*res, *parent_res = NULL;\n\tint\t\t\tret, i;\n\tbool\t\t\tignore_pipe_clk;\n\n\tqcom = devm_kzalloc(&pdev->dev, sizeof(*qcom), GFP_KERNEL);\n\tif (!qcom)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, qcom);\n\tqcom->dev = &pdev->dev;\n\n\tif (has_acpi_companion(dev)) {\n\t\tqcom->acpi_pdata = acpi_device_get_match_data(dev);\n\t\tif (!qcom->acpi_pdata) {\n\t\t\tdev_err(&pdev->dev, \"no supporting ACPI device data\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tqcom->resets = devm_reset_control_array_get_optional_exclusive(dev);\n\tif (IS_ERR(qcom->resets)) {\n\t\tret = PTR_ERR(qcom->resets);\n\t\tdev_err(&pdev->dev, \"failed to get resets, err=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = reset_control_assert(qcom->resets);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to assert resets, err=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tusleep_range(10, 1000);\n\n\tret = reset_control_deassert(qcom->resets);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to deassert resets, err=%d\\n\", ret);\n\t\tgoto reset_assert;\n\t}\n\n\tret = dwc3_qcom_clk_init(qcom, of_clk_get_parent_count(np));\n\tif (ret) {\n\t\tdev_err(dev, \"failed to get clocks\\n\");\n\t\tgoto reset_assert;\n\t}\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\n\tif (np) {\n\t\tparent_res = res;\n\t} else {\n\t\tparent_res = kmemdup(res, sizeof(struct resource), GFP_KERNEL);\n\t\tif (!parent_res)\n\t\t\treturn -ENOMEM;\n\n\t\tparent_res->start = res->start +\n\t\t\tqcom->acpi_pdata->qscratch_base_offset;\n\t\tparent_res->end = parent_res->start +\n\t\t\tqcom->acpi_pdata->qscratch_base_size;\n\n\t\tif (qcom->acpi_pdata->is_urs) {\n\t\t\tqcom->urs_usb = dwc3_qcom_create_urs_usb_platdev(dev);\n\t\t\tif (IS_ERR_OR_NULL(qcom->urs_usb)) {\n\t\t\t\tdev_err(dev, \"failed to create URS USB platdev\\n\");\n\t\t\t\tif (!qcom->urs_usb)\n\t\t\t\t\treturn -ENODEV;\n\t\t\t\telse\n\t\t\t\t\treturn PTR_ERR(qcom->urs_usb);\n\t\t\t}\n\t\t}\n\t}\n\n\tqcom->qscratch_base = devm_ioremap_resource(dev, parent_res);\n\tif (IS_ERR(qcom->qscratch_base)) {\n\t\tret = PTR_ERR(qcom->qscratch_base);\n\t\tgoto clk_disable;\n\t}\n\n\tret = dwc3_qcom_setup_irq(pdev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to setup IRQs, err=%d\\n\", ret);\n\t\tgoto clk_disable;\n\t}\n\n\t/*\n\t * Disable pipe_clk requirement if specified. Used when dwc3\n\t * operates without SSPHY and only HS/FS/LS modes are supported.\n\t */\n\tignore_pipe_clk = device_property_read_bool(dev,\n\t\t\t\t\"qcom,select-utmi-as-pipe-clk\");\n\tif (ignore_pipe_clk)\n\t\tdwc3_qcom_select_utmi_clk(qcom);\n\n\tif (np)\n\t\tret = dwc3_qcom_of_register_core(pdev);\n\telse\n\t\tret = dwc3_qcom_acpi_register_core(pdev);\n\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register DWC3 Core, err=%d\\n\", ret);\n\t\tgoto depopulate;\n\t}\n\n\tret = dwc3_qcom_interconnect_init(qcom);\n\tif (ret)\n\t\tgoto depopulate;\n\n\tqcom->mode = usb_get_dr_mode(&qcom->dwc3->dev);\n\n\t/* enable vbus override for device mode */\n\tif (qcom->mode == USB_DR_MODE_PERIPHERAL)\n\t\tdwc3_qcom_vbus_override_enable(qcom, true);\n\n\t/* register extcon to override sw_vbus on Vbus change later */\n\tret = dwc3_qcom_register_extcon(qcom);\n\tif (ret)\n\t\tgoto interconnect_exit;\n\n\tdevice_init_wakeup(&pdev->dev, 1);\n\tqcom->is_suspended = false;\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\tpm_runtime_forbid(dev);\n\n\treturn 0;\n\ninterconnect_exit:\n\tdwc3_qcom_interconnect_exit(qcom);\ndepopulate:\n\tif (np)\n\t\tof_platform_depopulate(&pdev->dev);\n\telse\n\t\tplatform_device_put(pdev);\nclk_disable:\n\tfor (i = qcom->num_clocks - 1; i >= 0; i--) {\n\t\tclk_disable_unprepare(qcom->clks[i]);\n\t\tclk_put(qcom->clks[i]);\n\t}\nreset_assert:\n\treset_control_assert(qcom->resets);\n\n\treturn ret;\n}", "target": 1, "idx": 11087}
{"commit_id": "00a25b9469f825a57dc3558ce10561ef38a3405e", "project": "libsndfile", "func": "void\nsfe_apply_metadata_changes (const char * filenames [2], const METADATA_INFO * info)\n{\tSNDFILE *infile = NULL, *outfile = NULL ;\n\tSF_INFO sfinfo ;\n\tMETADATA_INFO tmpinfo ;\n\tint error_code = 0 ;\n\n\tmemset (&sfinfo, 0, sizeof (sfinfo)) ;\n\tmemset (&tmpinfo, 0, sizeof (tmpinfo)) ;\n\n\tif (filenames [1] == NULL)\n\t\tinfile = outfile = sf_open (filenames [0], SFM_RDWR, &sfinfo) ;\n\telse\n\t{\tinfile = sf_open (filenames [0], SFM_READ, &sfinfo) ;\n\n\t\t/* Output must be WAV. */\n\t\tsfinfo.format = SF_FORMAT_WAV | (SF_FORMAT_SUBMASK & sfinfo.format) ;\n\t\toutfile = sf_open (filenames [1], SFM_WRITE, &sfinfo) ;\n\t\t} ;\n\n\tif (infile == NULL)\n\t{\tprintf (\"Error : Not able to open input file '%s' : %s\\n\", filenames [0], sf_strerror (infile)) ;\n\t\terror_code = 1 ;\n\t\tgoto cleanup_exit ;\n\t\t} ;\n\n\tif (outfile == NULL)\n\t{\tprintf (\"Error : Not able to open output file '%s' : %s\\n\", filenames [1], sf_strerror (outfile)) ;\n\t\terror_code = 1 ;\n\t\tgoto cleanup_exit ;\n\t\t} ;\n\n\tif (info->has_bext_fields && merge_broadcast_info (infile, outfile, sfinfo.format, info))\n\t{\terror_code = 1 ;\n\t\tgoto cleanup_exit ;\n\t\t} ;\n\n\tif (infile != outfile)\n\t{\tint infileminor = SF_FORMAT_SUBMASK & sfinfo.format ;\n\n\t\t/* If the input file is not the same as the output file, copy the data. */\n\t\tif ((infileminor == SF_FORMAT_DOUBLE) || (infileminor == SF_FORMAT_FLOAT))\n\t\t{\tif (sfe_copy_data_fp (outfile, infile, sfinfo.channels, SF_FALSE) != 0)\n\t\t\t{\tprintf (\"Error : Not able to decode input file '%s'\\n\", filenames [0]) ;\n\t\t\t\terror_code = 1 ;\n\t\t\t\tgoto cleanup_exit ;\n\t\t\t\t} ;\n\t\t\t}\n\t\telse\n\t\t\tsfe_copy_data_int (outfile, infile, sfinfo.channels) ;\n\t\t} ;\n\n\tupdate_strings (outfile, info) ;\n\ncleanup_exit :\n\n\tif (outfile != NULL && outfile != infile)\n\t\tsf_close (outfile) ;\n\n\tif (infile != NULL)\n\t\tsf_close (infile) ;\n\n\tif (error_code)\n\t\texit (error_code) ;\n\n\treturn ;\n}", "target": 2, "idx": 11088}
{"commit_id": "cb4ef0b09200c720dfdb07e097092dd105450343", "project": "envoyproxy/envoy", "func": "bool BrotliDecompressorImpl::process(Common::BrotliContext& ctx, Buffer::Instance& output_buffer) {\n  BrotliDecoderResult result;\n  result = BrotliDecoderDecompressStream(state_.get(), &ctx.avail_in_, &ctx.next_in_,\n                                         &ctx.avail_out_, &ctx.next_out_, nullptr);\n  if (result == BROTLI_DECODER_RESULT_ERROR) {\n    // TODO(rojkov): currently the Brotli library doesn't specify possible errors in its API. Add\n    // more detailed stats when they are documented.\n    stats_.brotli_error_.inc();\n    return false;\n  }\n\n  if (Runtime::runtimeFeatureEnabled(\n          \"envoy.reloadable_features.enable_compression_bomb_protection\") &&\n      (output_buffer.length() > ctx.max_output_size_)) {\n    stats_.brotli_error_.inc();\n    return false;\n  }\n\n  ctx.updateOutput(output_buffer);\n\n  return true;\n}", "target": 2, "idx": 11089}
{"commit_id": "ff489d95a9006be080ad14feb378f2b4dac35552", "project": "tensorflow", "func": "TfLiteStatus EvalHybridPerChannel(TfLiteContext* context, TfLiteNode* node,\n                                  TfLiteConvParams* params, OpData* data,\n                                  const TfLiteTensor* input,\n                                  const TfLiteTensor* filter,\n                                  const TfLiteTensor* bias,\n                                  TfLiteTensor* im2col, TfLiteTensor* output) {\n  float output_activation_min, output_activation_max;\n  CalculateActivationRange(params->activation, &output_activation_min,\n                           &output_activation_max);\n\n  const int batch_size = SizeOfDimension(input, 0);\n  TF_LITE_ENSURE(context, batch_size != 0);\n  const int input_size = NumElements(input) / batch_size;\n  TfLiteTensor* quantized_input_tensor;\n  TF_LITE_ENSURE_OK(context,\n                    GetTemporarySafe(context, node, data->input_quantized_index,\n                                     &quantized_input_tensor));\n  int8_t* quantized_input_ptr_batch =\n      GetTensorData<int8_t>(quantized_input_tensor);\n  TfLiteTensor* scaling_factors_tensor;\n  TF_LITE_ENSURE_OK(context,\n                    GetTemporarySafe(context, node, data->scaling_factors_index,\n                                     &scaling_factors_tensor));\n  float* scaling_factors_ptr = GetTensorData<float>(scaling_factors_tensor);\n  TfLiteTensor* input_offset_tensor;\n  TF_LITE_ENSURE_OK(context,\n                    GetTemporarySafe(context, node, data->input_offset_index,\n                                     &input_offset_tensor));\n  int32_t* input_offset_ptr = GetTensorData<int32_t>(input_offset_tensor);\n\n  for (int b = 0; b < batch_size; ++b) {\n    const int offset = b * input_size;\n    tensor_utils::AsymmetricQuantizeFloats(\n        GetTensorData<float>(input) + offset, input_size,\n        quantized_input_ptr_batch + offset, &scaling_factors_ptr[b],\n        &input_offset_ptr[b]);\n  }\n\n  int8_t* im2col_ptr = nullptr;\n  int8_t* filter_ptr = nullptr;\n  if (im2col != nullptr) {\n    im2col_ptr = im2col->data.int8;\n  }\n  filter_ptr = filter->data.int8;\n  const auto* affine_quantization =\n      reinterpret_cast<TfLiteAffineQuantization*>(filter->quantization.params);\n\n  KernelType effective_kernel_type = kernel_type;\n  // We have to fallback to reference execution path when im2col is needed but\n  // disabled because to-be-allocated temporary im2col tensor is too large.\n  // See b/178743262 for the detailed motivation.\n  if (data->im2col_oversized) {\n    effective_kernel_type = kReference;\n  }\n\n  ConvParams op_params;\n  op_params.padding_type = PaddingType::kSame;\n  op_params.padding_values.width = data->padding.width;\n  op_params.padding_values.height = data->padding.height;\n  op_params.dilation_width_factor = params->dilation_width_factor;\n  op_params.dilation_height_factor = params->dilation_height_factor;\n  op_params.stride_width = params->stride_width;\n  op_params.stride_height = params->stride_height;\n  op_params.float_activation_min = output_activation_min;\n  op_params.float_activation_max = output_activation_max;\n  switch (effective_kernel_type) {\n    case kReference:\n      reference_ops::HybridConvPerChannel(\n          op_params, scaling_factors_ptr, GetTensorShape(input),\n          quantized_input_ptr_batch, GetTensorShape(filter), filter_ptr,\n          GetTensorShape(bias), GetTensorData<float>(bias),\n          GetTensorShape(output), GetTensorData<float>(output),\n          GetTensorShape(im2col), im2col_ptr, affine_quantization->scale->data,\n          input_offset_ptr);\n      break;\n    case kGenericOptimized:\n    case kMultithreadOptimized:\n    case kCblasOptimized: {\n      TfLiteTensor* row_sums;\n      TF_LITE_ENSURE_OK(\n          context,\n          GetTemporarySafe(context, node, data->row_sums_index, &row_sums));\n      TfLiteTensor* scratch;\n      TF_LITE_ENSURE_OK(\n          context,\n          GetTemporarySafe(context, node, data->accum_scratch_index, &scratch));\n      optimized_ops::HybridConvPerChannel(\n          op_params, scaling_factors_ptr, GetTensorShape(input),\n          quantized_input_ptr_batch, GetTensorShape(filter), filter_ptr,\n          GetTensorShape(bias), GetTensorData<float>(bias),\n          GetTensorShape(output), GetTensorData<float>(output),\n          GetTensorShape(im2col), im2col_ptr, affine_quantization->scale->data,\n          input_offset_ptr, GetTensorShape(scratch),\n          GetTensorData<int32>(scratch), GetTensorData<int32_t>(row_sums),\n          &data->compute_hybrid_row_sums,\n          CpuBackendContext::GetFromContext(context));\n      data->compute_hybrid_row_sums = false;\n      break;\n    }\n  }\n\n  return kTfLiteOk;\n}", "target": 0, "idx": 11090}
{"commit_id": "dda81f0505217a95db065e6bf9cc2d81eb902417", "project": "php/php-src", "func": "static int phar_extract_file(zend_bool overwrite, phar_entry_info *entry, char *dest, int dest_len, char **error TSRMLS_DC) /* {{{ */\n{\n\tphp_stream_statbuf ssb;\n\tint len;\n\tphp_stream *fp;\n\tchar *fullpath;\n\tconst char *slash;\n\tmode_t mode;\n\tcwd_state new_state;\n\tchar *filename;\n\tsize_t filename_len;\n\n\tif (entry->is_mounted) {\n\t\t/* silently ignore mounted entries */\n\t\treturn SUCCESS;\n\t}\n\n\tif (entry->filename_len >= sizeof(\".phar\")-1 && !memcmp(entry->filename, \".phar\", sizeof(\".phar\")-1)) {\n\t\treturn SUCCESS;\n\t}\n\t/* strip .. from path and restrict it to be under dest directory */\n\tnew_state.cwd = (char*)malloc(2);\n\tnew_state.cwd[0] = DEFAULT_SLASH;\n\tnew_state.cwd[1] = '\\0';\n\tnew_state.cwd_length = 1;\n\tif (virtual_file_ex(&new_state, entry->filename, NULL, CWD_EXPAND TSRMLS_CC) != 0 ||\n\t\t\tnew_state.cwd_length <= 1) {\n\t\tif (EINVAL == errno && entry->filename_len > 50) {\n\t\t\tchar *tmp = estrndup(entry->filename, 50);\n\t\t\tspprintf(error, 4096, \"Cannot extract \\\"%s...\\\" to \\\"%s...\\\", extracted filename is too long for filesystem\", tmp, dest);\n\t\t\tefree(tmp);\n\t\t} else {\n\t\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\", internal error\", entry->filename);\n\t\t}\n\t\tfree(new_state.cwd);\n\t\treturn FAILURE;\n\t}\n\tfilename = new_state.cwd + 1;\n\tfilename_len = new_state.cwd_length - 1;\n#ifdef PHP_WIN32\n\t/* unixify the path back, otherwise non zip formats might be broken */\n\t{\n\t\tint cnt = filename_len;\n\n\t\tdo {\n\t\t\tif ('\\\\' == filename[cnt]) {\n\t\t\t\tfilename[cnt] = '/';\n\t\t\t}\n\t\t} while (cnt-- >= 0);\n\t}\n#endif\n\n\tlen = spprintf(&fullpath, 0, \"%s/%s\", dest, filename);\n\n\tif (len >= MAXPATHLEN) {\n\t\tchar *tmp;\n\t\t/* truncate for error message */\n\t\tfullpath[50] = '\\0';\n\t\tif (entry->filename_len > 50) {\n\t\t\ttmp = estrndup(entry->filename, 50);\n\t\t\tspprintf(error, 4096, \"Cannot extract \\\"%s...\\\" to \\\"%s...\\\", extracted filename is too long for filesystem\", tmp, fullpath);\n\t\t\tefree(tmp);\n\t\t} else {\n\t\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\" to \\\"%s...\\\", extracted filename is too long for filesystem\", entry->filename, fullpath);\n\t\t}\n\t\tefree(fullpath);\n\t\tfree(new_state.cwd);\n\t\treturn FAILURE;\n\t}\n\n\tif (!len) {\n\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\", internal error\", entry->filename);\n\t\tefree(fullpath);\n\t\tfree(new_state.cwd);\n\t\treturn FAILURE;\n\t}\n\n\tif (PHAR_OPENBASEDIR_CHECKPATH(fullpath)) {\n\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\" to \\\"%s\\\", openbasedir/safe mode restrictions in effect\", entry->filename, fullpath);\n\t\tefree(fullpath);\n\t\tfree(new_state.cwd);\n\t\treturn FAILURE;\n\t}\n\n\t/* let see if the path already exists */\n\tif (!overwrite && SUCCESS == php_stream_stat_path(fullpath, &ssb)) {\n\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\" to \\\"%s\\\", path already exists\", entry->filename, fullpath);\n\t\tefree(fullpath);\n\t\tfree(new_state.cwd);\n\t\treturn FAILURE;\n\t}\n\n\t/* perform dirname */\n\tslash = zend_memrchr(filename, '/', filename_len);\n\n\tif (slash) {\n\t\tfullpath[dest_len + (slash - filename) + 1] = '\\0';\n\t} else {\n\t\tfullpath[dest_len] = '\\0';\n\t}\n\n\tif (FAILURE == php_stream_stat_path(fullpath, &ssb)) {\n\t\tif (entry->is_dir) {\n\t\t\tif (!php_stream_mkdir(fullpath, entry->flags & PHAR_ENT_PERM_MASK,  PHP_STREAM_MKDIR_RECURSIVE, NULL)) {\n\t\t\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\", could not create directory \\\"%s\\\"\", entry->filename, fullpath);\n\t\t\t\tefree(fullpath);\n\t\t\t\tfree(new_state.cwd);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!php_stream_mkdir(fullpath, 0777,  PHP_STREAM_MKDIR_RECURSIVE, NULL)) {\n\t\t\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\", could not create directory \\\"%s\\\"\", entry->filename, fullpath);\n\t\t\t\tefree(fullpath);\n\t\t\t\tfree(new_state.cwd);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (slash) {\n\t\tfullpath[dest_len + (slash - filename) + 1] = '/';\n\t} else {\n\t\tfullpath[dest_len] = '/';\n\t}\n\n\tfilename = NULL;\n\tfree(new_state.cwd);\n\t/* it is a standalone directory, job done */\n\tif (entry->is_dir) {\n\t\tefree(fullpath);\n\t\treturn SUCCESS;\n\t}\n\n#if PHP_API_VERSION < 20100412\n\tfp = php_stream_open_wrapper(fullpath, \"w+b\", REPORT_ERRORS|ENFORCE_SAFE_MODE, NULL);\n#else\n\tfp = php_stream_open_wrapper(fullpath, \"w+b\", REPORT_ERRORS, NULL);\n#endif\n\n\tif (!fp) {\n\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\", could not open for writing \\\"%s\\\"\", entry->filename, fullpath);\n\t\tefree(fullpath);\n\t\treturn FAILURE;\n\t}\n\n\tif (!phar_get_efp(entry, 0 TSRMLS_CC)) {\n\t\tif (FAILURE == phar_open_entry_fp(entry, error, 1 TSRMLS_CC)) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\" to \\\"%s\\\", unable to open internal file pointer: %s\", entry->filename, fullpath, *error);\n\t\t\t} else {\n\t\t\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\" to \\\"%s\\\", unable to open internal file pointer\", entry->filename, fullpath);\n\t\t\t}\n\t\t\tefree(fullpath);\n\t\t\tphp_stream_close(fp);\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\n\tif (FAILURE == phar_seek_efp(entry, 0, SEEK_SET, 0, 0 TSRMLS_CC)) {\n\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\" to \\\"%s\\\", unable to seek internal file pointer\", entry->filename, fullpath);\n\t\tefree(fullpath);\n\t\tphp_stream_close(fp);\n\t\treturn FAILURE;\n\t}\n\n\tif (SUCCESS != phar_stream_copy_to_stream(phar_get_efp(entry, 0 TSRMLS_CC), fp, entry->uncompressed_filesize, NULL)) {\n\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\" to \\\"%s\\\", copying contents failed\", entry->filename, fullpath);\n\t\tefree(fullpath);\n\t\tphp_stream_close(fp);\n\t\treturn FAILURE;\n\t}\n\n\tphp_stream_close(fp);\n\tmode = (mode_t) entry->flags & PHAR_ENT_PERM_MASK;\n\n\tif (FAILURE == VCWD_CHMOD(fullpath, mode)) {\n\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\" to \\\"%s\\\", setting file permissions failed\", entry->filename, fullpath);\n\t\tefree(fullpath);\n\t\treturn FAILURE;\n\t}\n\n\tefree(fullpath);\n\treturn SUCCESS;\n}", "target": 2, "idx": 11091}
{"commit_id": "11f3710417d026ea2f4fcf362d866342c5274185", "project": "torvalds/linux", "func": "static int ovl_rename2(struct inode *olddir, struct dentry *old,\n\t\t       struct inode *newdir, struct dentry *new,\n\t\t       unsigned int flags)\n{\n\tint err;\n\tenum ovl_path_type old_type;\n\tenum ovl_path_type new_type;\n\tstruct dentry *old_upperdir;\n\tstruct dentry *new_upperdir;\n\tstruct dentry *olddentry;\n\tstruct dentry *newdentry;\n\tstruct dentry *trap;\n\tbool old_opaque;\n\tbool new_opaque;\n\tbool new_create = false;\n\tbool cleanup_whiteout = false;\n\tbool overwrite = !(flags & RENAME_EXCHANGE);\n\tbool is_dir = d_is_dir(old);\n\tbool new_is_dir = false;\n\tstruct dentry *opaquedir = NULL;\n\tconst struct cred *old_cred = NULL;\n\tstruct cred *override_cred = NULL;\n\n\terr = -EINVAL;\n\tif (flags & ~(RENAME_EXCHANGE | RENAME_NOREPLACE))\n\t\tgoto out;\n\n\tflags &= ~RENAME_NOREPLACE;\n\n\terr = ovl_check_sticky(old);\n\tif (err)\n\t\tgoto out;\n\n\t/* Don't copy up directory trees */\n\told_type = ovl_path_type(old);\n\terr = -EXDEV;\n\tif (OVL_TYPE_MERGE_OR_LOWER(old_type) && is_dir)\n\t\tgoto out;\n\n\tif (new->d_inode) {\n\t\terr = ovl_check_sticky(new);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (d_is_dir(new))\n\t\t\tnew_is_dir = true;\n\n\t\tnew_type = ovl_path_type(new);\n\t\terr = -EXDEV;\n\t\tif (!overwrite && OVL_TYPE_MERGE_OR_LOWER(new_type) && new_is_dir)\n\t\t\tgoto out;\n\n\t\terr = 0;\n\t\tif (!OVL_TYPE_UPPER(new_type) && !OVL_TYPE_UPPER(old_type)) {\n\t\t\tif (ovl_dentry_lower(old)->d_inode ==\n\t\t\t    ovl_dentry_lower(new)->d_inode)\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (OVL_TYPE_UPPER(new_type) && OVL_TYPE_UPPER(old_type)) {\n\t\t\tif (ovl_dentry_upper(old)->d_inode ==\n\t\t\t    ovl_dentry_upper(new)->d_inode)\n\t\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tif (ovl_dentry_is_opaque(new))\n\t\t\tnew_type = __OVL_PATH_UPPER;\n\t\telse\n\t\t\tnew_type = __OVL_PATH_UPPER | __OVL_PATH_PURE;\n\t}\n\n\terr = ovl_want_write(old);\n\tif (err)\n\t\tgoto out;\n\n\terr = ovl_copy_up(old);\n\tif (err)\n\t\tgoto out_drop_write;\n\n\terr = ovl_copy_up(new->d_parent);\n\tif (err)\n\t\tgoto out_drop_write;\n\tif (!overwrite) {\n\t\terr = ovl_copy_up(new);\n\t\tif (err)\n\t\t\tgoto out_drop_write;\n\t}\n\n\told_opaque = !OVL_TYPE_PURE_UPPER(old_type);\n\tnew_opaque = !OVL_TYPE_PURE_UPPER(new_type);\n\n\tif (old_opaque || new_opaque) {\n\t\terr = -ENOMEM;\n\t\toverride_cred = prepare_creds();\n\t\tif (!override_cred)\n\t\t\tgoto out_drop_write;\n\n\t\t/*\n\t\t * CAP_SYS_ADMIN for setting xattr on whiteout, opaque dir\n\t\t * CAP_DAC_OVERRIDE for create in workdir\n\t\t * CAP_FOWNER for removing whiteout from sticky dir\n\t\t * CAP_FSETID for chmod of opaque dir\n\t\t * CAP_CHOWN for chown of opaque dir\n\t\t */\n\t\tcap_raise(override_cred->cap_effective, CAP_SYS_ADMIN);\n\t\tcap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);\n\t\tcap_raise(override_cred->cap_effective, CAP_FOWNER);\n\t\tcap_raise(override_cred->cap_effective, CAP_FSETID);\n\t\tcap_raise(override_cred->cap_effective, CAP_CHOWN);\n\t\told_cred = override_creds(override_cred);\n\t}\n\n\tif (overwrite && OVL_TYPE_MERGE_OR_LOWER(new_type) && new_is_dir) {\n\t\topaquedir = ovl_check_empty_and_clear(new);\n\t\terr = PTR_ERR(opaquedir);\n\t\tif (IS_ERR(opaquedir)) {\n\t\t\topaquedir = NULL;\n\t\t\tgoto out_revert_creds;\n\t\t}\n\t}\n\n\tif (overwrite) {\n\t\tif (old_opaque) {\n\t\t\tif (new->d_inode || !new_opaque) {\n\t\t\t\t/* Whiteout source */\n\t\t\t\tflags |= RENAME_WHITEOUT;\n\t\t\t} else {\n\t\t\t\t/* Switch whiteouts */\n\t\t\t\tflags |= RENAME_EXCHANGE;\n\t\t\t}\n\t\t} else if (is_dir && !new->d_inode && new_opaque) {\n\t\t\tflags |= RENAME_EXCHANGE;\n\t\t\tcleanup_whiteout = true;\n\t\t}\n\t}\n\n\told_upperdir = ovl_dentry_upper(old->d_parent);\n\tnew_upperdir = ovl_dentry_upper(new->d_parent);\n\n\ttrap = lock_rename(new_upperdir, old_upperdir);\n\n\n\tolddentry = lookup_one_len(old->d_name.name, old_upperdir,\n\t\t\t\t   old->d_name.len);\n\terr = PTR_ERR(olddentry);\n\tif (IS_ERR(olddentry))\n\t\tgoto out_unlock;\n\n\terr = -ESTALE;\n\tif (olddentry != ovl_dentry_upper(old))\n\t\tgoto out_dput_old;\n\n\tnewdentry = lookup_one_len(new->d_name.name, new_upperdir,\n\t\t\t\t   new->d_name.len);\n\terr = PTR_ERR(newdentry);\n\tif (IS_ERR(newdentry))\n\t\tgoto out_dput_old;\n\n\terr = -ESTALE;\n\tif (ovl_dentry_upper(new)) {\n\t\tif (opaquedir) {\n\t\t\tif (newdentry != opaquedir)\n\t\t\t\tgoto out_dput;\n\t\t} else {\n\t\t\tif (newdentry != ovl_dentry_upper(new))\n\t\t\t\tgoto out_dput;\n\t\t}\n\t} else {\n\t\tnew_create = true;\n\t\tif (!d_is_negative(newdentry) &&\n\t\t    (!new_opaque || !ovl_is_whiteout(newdentry)))\n\t\t\tgoto out_dput;\n\t}\n\n\tif (olddentry == trap)\n\t\tgoto out_dput;\n\tif (newdentry == trap)\n\t\tgoto out_dput;\n\n\tif (is_dir && !old_opaque && new_opaque) {\n\t\terr = ovl_set_opaque(olddentry);\n\t\tif (err)\n\t\t\tgoto out_dput;\n\t}\n\tif (!overwrite && new_is_dir && old_opaque && !new_opaque) {\n\t\terr = ovl_set_opaque(newdentry);\n\t\tif (err)\n\t\t\tgoto out_dput;\n\t}\n\n\tif (old_opaque || new_opaque) {\n\t\terr = ovl_do_rename(old_upperdir->d_inode, olddentry,\n\t\t\t\t    new_upperdir->d_inode, newdentry,\n\t\t\t\t    flags);\n\t} else {\n\t\t/* No debug for the plain case */\n\t\tBUG_ON(flags & ~RENAME_EXCHANGE);\n\t\terr = vfs_rename(old_upperdir->d_inode, olddentry,\n\t\t\t\t new_upperdir->d_inode, newdentry,\n\t\t\t\t NULL, flags);\n\t}\n\n\tif (err) {\n\t\tif (is_dir && !old_opaque && new_opaque)\n\t\t\tovl_remove_opaque(olddentry);\n\t\tif (!overwrite && new_is_dir && old_opaque && !new_opaque)\n\t\t\tovl_remove_opaque(newdentry);\n\t\tgoto out_dput;\n\t}\n\n\tif (is_dir && old_opaque && !new_opaque)\n\t\tovl_remove_opaque(olddentry);\n\tif (!overwrite && new_is_dir && !old_opaque && new_opaque)\n\t\tovl_remove_opaque(newdentry);\n\n\t/*\n\t * Old dentry now lives in different location. Dentries in\n\t * lowerstack are stale. We cannot drop them here because\n\t * access to them is lockless. This could be only pure upper\n\t * or opaque directory - numlower is zero. Or upper non-dir\n\t * entry - its pureness is tracked by flag opaque.\n\t */\n\tif (old_opaque != new_opaque) {\n\t\tovl_dentry_set_opaque(old, new_opaque);\n\t\tif (!overwrite)\n\t\t\tovl_dentry_set_opaque(new, old_opaque);\n\t}\n\n\tif (cleanup_whiteout)\n\t\tovl_cleanup(old_upperdir->d_inode, newdentry);\n\n\tovl_dentry_version_inc(old->d_parent);\n\tovl_dentry_version_inc(new->d_parent);\n\nout_dput:\n\tdput(newdentry);\nout_dput_old:\n\tdput(olddentry);\nout_unlock:\n\tunlock_rename(new_upperdir, old_upperdir);\nout_revert_creds:\n\tif (old_opaque || new_opaque) {\n\t\trevert_creds(old_cred);\n\t\tput_cred(override_cred);\n\t}\nout_drop_write:\n\tovl_drop_write(old);\nout:\n\tdput(opaquedir);\n\treturn err;\n}", "target": 1, "idx": 11092}
{"commit_id": "58a6822d7140137ce957c6d2fc20bae1374186c1", "project": "android", "func": "WORD32  impeg2d_dec_p_mb_params(dec_state_t *ps_dec)\n{\n    stream_t *ps_stream = &ps_dec->s_bit_stream;\n    UWORD16 u2_mb_addr_incr;\n    UWORD16 u2_total_len;\n    UWORD16 u2_len;\n    UWORD16 u2_mb_type;\n    UWORD32 u4_next_word;\n    const dec_mb_params_t *ps_dec_mb_params;\n    if(impeg2d_bit_stream_nxt(ps_stream,1) == 1)\n    {\n        impeg2d_bit_stream_flush(ps_stream,1);\n\n    }\n    else\n    {\n        u2_mb_addr_incr = impeg2d_get_mb_addr_incr(ps_stream);\n        if(0 == ps_dec->u2_first_mb)\n        {\n            /****************************************************************/\n            /* If the 2nd member of a field picture pair is a P picture and */\n            /* the first one was an I picture, there cannot be any skipped  */\n            /* MBs in the second field picture                              */\n            /****************************************************************/\n            /*\n            if((dec->picture_structure != FRAME_PICTURE) &&\n                (dec->f->FieldFuncCall != 0) &&\n                (dec->las->u1_last_coded_vop_type == I))\n            {\n                core0_err_handler((void *)(VOLParams),\n                    ITTMPEG2_ERR_INVALID_MB_SKIP);\n            }\n            */\n            /****************************************************************/\n            /* In MPEG-2, the last MB of the row cannot be skipped and the  */\n            /* MBAddrIncr cannot be such that it will take the current MB   */\n            /* beyond the current row                                       */\n            /* In MPEG-1, the slice could start and end anywhere and is not */\n            /* restricted to a row like in MPEG-2. Hence this check should  */\n            /* not be done for MPEG-1 streams.                              */\n            /****************************************************************/\n            if(ps_dec->u2_is_mpeg2 && ((ps_dec->u2_mb_x + u2_mb_addr_incr) > ps_dec->u2_num_horiz_mb) )\n            {\n                u2_mb_addr_incr    = ps_dec->u2_num_horiz_mb - ps_dec->u2_mb_x;\n            }\n\n            impeg2d_dec_skip_mbs(ps_dec, (UWORD16)(u2_mb_addr_incr - 1));\n        }\n\n    }\n    u4_next_word = (UWORD16)impeg2d_bit_stream_nxt(ps_stream,16);\n    /*-----------------------------------------------------------------------*/\n    /* MB type                                                               */\n    /*-----------------------------------------------------------------------*/\n    {\n        u2_mb_type   = ps_dec->pu2_mb_type[BITS((UWORD16)u4_next_word,15,10)];\n        u2_len      = BITS(u2_mb_type,15,8);\n        u2_total_len = u2_len;\n        u4_next_word = (UWORD16)LSW((UWORD16)u4_next_word << u2_len);\n    }\n    /*-----------------------------------------------------------------------*/\n    /* motion type                                                           */\n    /*-----------------------------------------------------------------------*/\n    {\n        if((u2_mb_type & MB_FORW_OR_BACK) &&  ps_dec->u2_read_motion_type)\n        {\n            WORD32 i4_motion_type;\n            ps_dec->u2_motion_type = BITS((UWORD16)u4_next_word,15,14);\n            u2_total_len        += MB_MOTION_TYPE_LEN;\n            u4_next_word        = (UWORD16)LSW((UWORD16)u4_next_word << MB_MOTION_TYPE_LEN);\n            i4_motion_type     = ps_dec->u2_motion_type;\n\n            if((i4_motion_type == 0) ||\n                (i4_motion_type == 4) ||\n                (i4_motion_type >  7))\n            {\n                //TODO : VANG Check for validity\n                i4_motion_type = 1;\n            }\n\n        }\n    }\n    /*-----------------------------------------------------------------------*/\n    /* dct type                                                              */\n    /*-----------------------------------------------------------------------*/\n    {\n        if((u2_mb_type & MB_CODED) && ps_dec->u2_read_dct_type)\n        {\n            ps_dec->u2_field_dct = BIT((UWORD16)u4_next_word,15);\n            u2_total_len += MB_DCT_TYPE_LEN;\n            u4_next_word = (UWORD16)LSW((UWORD16)u4_next_word << MB_DCT_TYPE_LEN);\n        }\n    }\n    /*-----------------------------------------------------------------------*/\n    /* Quant scale code                                                      */\n    /*-----------------------------------------------------------------------*/\n    if(u2_mb_type & MB_QUANT)\n    {\n        UWORD16 u2_quant_scale_code;\n        u2_quant_scale_code = BITS((UWORD16)u4_next_word,15,11);\n\n        ps_dec->u1_quant_scale = (ps_dec->u2_q_scale_type) ?\n            gau1_impeg2_non_linear_quant_scale[u2_quant_scale_code] : (u2_quant_scale_code << 1);\n        u2_total_len += MB_QUANT_SCALE_CODE_LEN;\n    }\n    impeg2d_bit_stream_flush(ps_stream,u2_total_len);\n    /*-----------------------------------------------------------------------*/\n    /* Set the function pointers                                             */\n    /*-----------------------------------------------------------------------*/\n    ps_dec->u2_coded_mb    = (UWORD16)(u2_mb_type & MB_CODED);\n\n    if(u2_mb_type & MB_FORW_OR_BACK)\n    {\n\n        UWORD16 refPic      = !(u2_mb_type & MB_MV_FORW);\n        UWORD16 index       = (ps_dec->u2_motion_type);\n        ps_dec->u2_prev_intra_mb    = 0;\n        ps_dec->e_mb_pred         = (e_pred_direction_t)refPic;\n        ps_dec_mb_params = &ps_dec->ps_func_forw_or_back[index];\n        ps_dec->s_mb_type = ps_dec_mb_params->s_mb_type;\n        if(NULL == ps_dec_mb_params->pf_func_mb_params)\n            return -1;\n        ps_dec_mb_params->pf_func_mb_params(ps_dec);\n\n    }\n    else if(u2_mb_type & MB_TYPE_INTRA)\n    {\n        ps_dec->u2_prev_intra_mb    = 1;\n        impeg2d_dec_intra_mb(ps_dec);\n\n    }\n    else\n    {\n        ps_dec->u2_prev_intra_mb    = 0;\n        ps_dec->e_mb_pred = FORW;\n        ps_dec->u2_motion_type = 0;\n        impeg2d_dec_0mv_coded_mb(ps_dec);\n    }\n\n    /*-----------------------------------------------------------------------*/\n    /* decode cbp                                                            */\n    /*-----------------------------------------------------------------------*/\n    if((u2_mb_type & MB_TYPE_INTRA))\n    {\n        ps_dec->u2_cbp  = 0x3f;\n        ps_dec->u2_prev_intra_mb    = 1;\n    }\n    else\n    {\n        ps_dec->u2_prev_intra_mb  = 0;\n        ps_dec->u2_def_dc_pred[Y_LUMA] = 128 << ps_dec->u2_intra_dc_precision;\n        ps_dec->u2_def_dc_pred[U_CHROMA] = 128 << ps_dec->u2_intra_dc_precision;\n        ps_dec->u2_def_dc_pred[V_CHROMA] = 128 << ps_dec->u2_intra_dc_precision;\n        if((ps_dec->u2_coded_mb))\n        {\n            UWORD16 cbpValue;\n            cbpValue  = gau2_impeg2d_cbp_code[impeg2d_bit_stream_nxt(ps_stream,MB_CBP_LEN)];\n            ps_dec->u2_cbp  = cbpValue & 0xFF;\n            impeg2d_bit_stream_flush(ps_stream,(cbpValue >> 8) & 0x0FF);\n        }\n        else\n        {\n            ps_dec->u2_cbp  = 0;\n        }\n    }\n    return 0;\n}", "target": 3, "idx": 11093}
{"commit_id": "08aec2b4dfd7f709b6e3d511411ffcc83ed4efbe", "project": "zchunk", "func": "static bool read_lead(zckCtx *zck) {\n    VALIDATE_READ_BOOL(zck);\n\n    int lead = 5 + 2*MAX_COMP_SIZE;\n\n    char *header = zmalloc(lead);\n    if (!header) {\n\t    zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n\t    return false;\n    }\n    size_t length = 0;\n\n    if(read_data(zck, header, lead) < lead) {\n        free(header);\n        set_error(zck, \"Short read\");\n        return false;\n    }\n\n    if(memcmp(header, \"\\0ZHR1\", 5) == 0) {\n        zck->header_only = true;\n    } else if(memcmp(header, \"\\0ZCK1\", 5) != 0) {\n        free(header);\n        set_error(zck, \"Invalid lead, perhaps this is not a zck file?\");\n        return false;\n    }\n    length += 5;\n\n    /* Read hash type for header and full digest and initialize check hash */\n    int hash_type = 0;\n    if(!compint_to_int(zck, &hash_type, header+length, &length, lead)) {\n        free(header);\n        return false;\n    }\n    if(zck->prep_hash_type > -1 && zck->prep_hash_type != hash_type) {\n        free(header);\n        set_error(zck, \"Hash type (%i) doesn't match requested hash type \"\n                  \"(%i)\", hash_type, zck->prep_hash_type);\n        return false;\n    }\n    if(!hash_setup(zck, &(zck->hash_type), hash_type)) {\n        free(header);\n        return false;\n    }\n    zck_log(ZCK_LOG_DEBUG, \"Setting header and full digest hash type to %s\",\n            zck_hash_name_from_type(hash_type));\n\n    /* Read header size */\n    size_t header_length = 0;\n    if(!compint_to_size(zck, &header_length, header+length, &length, lead)) {\n        free(header);\n        hash_reset(&(zck->hash_type));\n        return false;\n    }\n    if(header_length > SIZE_MAX) {\n        free(header);\n        set_error(zck, \"Header length of %li invalid\", header_length);\n        hash_reset(&(zck->hash_type));\n        return false;\n    }\n    zck->header_length = header_length;\n\n    /* Set header digest location */\n    zck->hdr_digest_loc = length;\n\n    /* Verify that we're not going to overflow */\n    if(length > length + zck->hash_type.digest_size) {\n        zck_log(ZCK_LOG_ERROR, \"Integer overflow when reading lead\");\n        return false;\n    }\n\n    /* Read header digest */\n    zck_log(ZCK_LOG_DEBUG, \"Reading header digest\");\n    header = zrealloc(header, length + zck->hash_type.digest_size);\n    if (!header) {\n        zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n        return false;\n    }\n    size_t to_read = 0;\n    if(lead < length + zck->hash_type.digest_size)\n        to_read = length + zck->hash_type.digest_size - lead;\n    if(read_data(zck, header + lead, to_read) < to_read) {\n        free(header);\n        zck->header_length = 0;\n        zck->hdr_digest_loc = 0;\n        hash_reset(&(zck->hash_type));\n        return false;\n    }\n    lead += to_read;\n\n    if(zck->prep_digest &&\n       memcmp(zck->prep_digest, header + length, zck->hash_type.digest_size) != 0) {\n        zck->header_length = 0;\n        zck->hdr_digest_loc = 0;\n        hash_reset(&(zck->hash_type));\n        set_error(zck,\n                  \"Header digest doesn't match requested header digest\"\n                  \"Expected: %sActual: %s\",\n                  get_digest_string(zck->prep_digest,\n                                    zck->hash_type.digest_size),\n                  get_digest_string(header + length,\n                                    zck->hash_type.digest_size));\n        free(header);\n        return false;\n    }\n    zck->header_digest = zmalloc(zck->hash_type.digest_size);\n    if (!zck->header_digest) {\n\t    zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n\t    free(header);\n\t    return false;\n    }\n    memcpy(zck->header_digest, header + length, zck->hash_type.digest_size);\n    length += zck->hash_type.digest_size;\n\n    /* Check whether full header length matches specified header length */\n    if(zck->prep_hdr_size > -1 &&\n       (size_t)zck->prep_hdr_size != zck->header_length + length) {\n        free(header);\n        zck->header_length = 0;\n        zck->hdr_digest_loc = 0;\n        hash_reset(&(zck->hash_type));\n        free(zck->header_digest);\n        zck->header_digest = NULL;\n        set_error(\n            zck,\n            \"Header length (%llu) doesn't match requested header length (%llu)\",\n            (long long unsigned) zck->header_length + length,\n            (long long unsigned) zck->prep_hdr_size\n        );\n        return false;\n    }\n    /* Store pre-header */\n    zck->header = header;\n    zck->header_size = lead;\n    zck->lead_string = header;\n    zck->lead_size = length;\n    zck_log(\n        ZCK_LOG_DEBUG,\n        \"Parsed lead: %llu bytes\",\n        (long long unsigned) length\n    );\n    return true;\n}", "target": 2, "idx": 11094}
{"commit_id": "1171e7c047bf79e7c93342bb6a812c9edd86aa84", "project": "android", "func": "status_t BnOMX::onTransact(\n    uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {\n    switch (code) {\n        case LIVES_LOCALLY:\n        {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n            node_id node = (node_id)data.readInt32();\n            pid_t pid = (pid_t)data.readInt32();\n            reply->writeInt32(livesLocally(node, pid));\n\n            return OK;\n        }\n\n        case LIST_NODES:\n        {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            List<ComponentInfo> list;\n            listNodes(&list);\n\n            reply->writeInt32(list.size());\n            for (List<ComponentInfo>::iterator it = list.begin();\n                 it != list.end(); ++it) {\n                ComponentInfo &cur = *it;\n\n                reply->writeString8(cur.mName);\n                reply->writeInt32(cur.mRoles.size());\n                for (List<String8>::iterator role_it = cur.mRoles.begin();\n                     role_it != cur.mRoles.end(); ++role_it) {\n                    reply->writeString8(*role_it);\n                }\n            }\n\n            return NO_ERROR;\n        }\n\n        case ALLOCATE_NODE:\n        {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            const char *name = data.readCString();\n\n            sp<IOMXObserver> observer =\n                interface_cast<IOMXObserver>(data.readStrongBinder());\n\n            node_id node;\n\n            status_t err = allocateNode(name, observer, &node);\n            reply->writeInt32(err);\n            if (err == OK) {\n                reply->writeInt32((int32_t)node);\n            }\n\n            return NO_ERROR;\n        }\n\n        case FREE_NODE:\n        {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n\n            reply->writeInt32(freeNode(node));\n\n            return NO_ERROR;\n        }\n\n        case SEND_COMMAND:\n        {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n\n            OMX_COMMANDTYPE cmd =\n                static_cast<OMX_COMMANDTYPE>(data.readInt32());\n\n            OMX_S32 param = data.readInt32();\n            reply->writeInt32(sendCommand(node, cmd, param));\n\n            return NO_ERROR;\n        }\n\n        case GET_PARAMETER:\n        case SET_PARAMETER:\n        case GET_CONFIG:\n        case SET_CONFIG:\n        case SET_INTERNAL_OPTION:\n        {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_INDEXTYPE index = static_cast<OMX_INDEXTYPE>(data.readInt32());\n\n            size_t size = data.readInt64();\n\n            status_t err = NO_MEMORY;\n            void *params = calloc(size, 1);\n            if (params) {\n                err = data.read(params, size);\n                if (err != OK) {\n                    android_errorWriteLog(0x534e4554, \"26914474\");\n                } else {\n                    switch (code) {\n                        case GET_PARAMETER:\n                            err = getParameter(node, index, params, size);\n                            break;\n                        case SET_PARAMETER:\n                            err = setParameter(node, index, params, size);\n                            break;\n                        case GET_CONFIG:\n                            err = getConfig(node, index, params, size);\n                            break;\n                        case SET_CONFIG:\n                            err = setConfig(node, index, params, size);\n                            break;\n                        case SET_INTERNAL_OPTION:\n                        {\n                            InternalOptionType type =\n                                (InternalOptionType)data.readInt32();\n\n                            err = setInternalOption(node, index, type, params, size);\n                            break;\n                        }\n\n                        default:\n                            TRESPASS();\n                    }\n                }\n            }\n\n            reply->writeInt32(err);\n\n            if ((code == GET_PARAMETER || code == GET_CONFIG) && err == OK) {\n                reply->write(params, size);\n            }\n\n            free(params);\n            params = NULL;\n\n            return NO_ERROR;\n        }\n\n        case GET_STATE:\n        {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_STATETYPE state = OMX_StateInvalid;\n\n            status_t err = getState(node, &state);\n            reply->writeInt32(state);\n            reply->writeInt32(err);\n\n            return NO_ERROR;\n        }\n\n        case ENABLE_GRAPHIC_BUFFERS:\n        {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            OMX_BOOL enable = (OMX_BOOL)data.readInt32();\n\n            status_t err = enableGraphicBuffers(node, port_index, enable);\n            reply->writeInt32(err);\n\n            return NO_ERROR;\n        }\n\n        case GET_GRAPHIC_BUFFER_USAGE:\n        {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n\n            OMX_U32 usage = 0;\n            status_t err = getGraphicBufferUsage(node, port_index, &usage);\n            reply->writeInt32(err);\n            reply->writeInt32(usage);\n\n            return NO_ERROR;\n        }\n\n        case USE_BUFFER:\n        {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            sp<IMemory> params =\n                interface_cast<IMemory>(data.readStrongBinder());\n\n            buffer_id buffer;\n            status_t err = useBuffer(node, port_index, params, &buffer);\n            reply->writeInt32(err);\n\n            if (err == OK) {\n                reply->writeInt32((int32_t)buffer);\n            }\n\n            return NO_ERROR;\n        }\n\n        case USE_GRAPHIC_BUFFER:\n        {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();\n            data.read(*graphicBuffer);\n\n            buffer_id buffer;\n            status_t err = useGraphicBuffer(\n                    node, port_index, graphicBuffer, &buffer);\n            reply->writeInt32(err);\n\n            if (err == OK) {\n                reply->writeInt32((int32_t)buffer);\n            }\n\n            return NO_ERROR;\n        }\n\n        case UPDATE_GRAPHIC_BUFFER_IN_META:\n        {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();\n            data.read(*graphicBuffer);\n            buffer_id buffer = (buffer_id)data.readInt32();\n\n            status_t err = updateGraphicBufferInMeta(\n                    node, port_index, graphicBuffer, buffer);\n            reply->writeInt32(err);\n\n            return NO_ERROR;\n        }\n\n        case CREATE_INPUT_SURFACE:\n        {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n\n            sp<IGraphicBufferProducer> bufferProducer;\n            status_t err = createInputSurface(node, port_index,\n                    &bufferProducer);\n\n            reply->writeInt32(err);\n\n            if (err == OK) {\n                reply->writeStrongBinder(bufferProducer->asBinder());\n            }\n\n            return NO_ERROR;\n        }\n\n        case SIGNAL_END_OF_INPUT_STREAM:\n        {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n\n            status_t err = signalEndOfInputStream(node);\n            reply->writeInt32(err);\n\n            return NO_ERROR;\n        }\n\n        case STORE_META_DATA_IN_BUFFERS:\n        {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            OMX_BOOL enable = (OMX_BOOL)data.readInt32();\n\n            status_t err = storeMetaDataInBuffers(node, port_index, enable);\n            reply->writeInt32(err);\n\n            return NO_ERROR;\n        }\n\n        case PREPARE_FOR_ADAPTIVE_PLAYBACK:\n        {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            OMX_BOOL enable = (OMX_BOOL)data.readInt32();\n            OMX_U32 max_width = data.readInt32();\n            OMX_U32 max_height = data.readInt32();\n\n            status_t err = prepareForAdaptivePlayback(\n                    node, port_index, enable, max_width, max_height);\n            reply->writeInt32(err);\n\n            return NO_ERROR;\n        }\n\n        case CONFIGURE_VIDEO_TUNNEL_MODE:\n        {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            OMX_BOOL tunneled = (OMX_BOOL)data.readInt32();\n            OMX_U32 audio_hw_sync = data.readInt32();\n\n            native_handle_t *sideband_handle = NULL;\n            status_t err = configureVideoTunnelMode(\n                    node, port_index, tunneled, audio_hw_sync, &sideband_handle);\n            reply->writeInt32(err);\n            if(err == OK){\n                reply->writeNativeHandle(sideband_handle);\n            }\n\n            return NO_ERROR;\n        }\n\n        case ALLOC_BUFFER:\n        {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            if (!isSecure(node) || port_index != 0 /* kPortIndexInput */) {\n                ALOGE(\"b/24310423\");\n                reply->writeInt32(INVALID_OPERATION);\n                return NO_ERROR;\n            }\n\n            size_t size = data.readInt64();\n\n            buffer_id buffer;\n            void *buffer_data;\n            status_t err = allocateBuffer(\n                    node, port_index, size, &buffer, &buffer_data);\n            reply->writeInt32(err);\n\n            if (err == OK) {\n                reply->writeInt32((int32_t)buffer);\n                reply->writeInt64((uintptr_t)buffer_data);\n            }\n\n            return NO_ERROR;\n        }\n\n        case ALLOC_BUFFER_WITH_BACKUP:\n        {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            sp<IMemory> params =\n                interface_cast<IMemory>(data.readStrongBinder());\n\n            buffer_id buffer;\n            status_t err = allocateBufferWithBackup(\n                    node, port_index, params, &buffer);\n\n            reply->writeInt32(err);\n\n            if (err == OK) {\n                reply->writeInt32((int32_t)buffer);\n            }\n\n            return NO_ERROR;\n        }\n\n        case FREE_BUFFER:\n        {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            buffer_id buffer = (buffer_id)data.readInt32();\n            reply->writeInt32(freeBuffer(node, port_index, buffer));\n\n            return NO_ERROR;\n        }\n\n        case FILL_BUFFER:\n        {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            buffer_id buffer = (buffer_id)data.readInt32();\n            reply->writeInt32(fillBuffer(node, buffer));\n\n            return NO_ERROR;\n        }\n\n        case EMPTY_BUFFER:\n        {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            buffer_id buffer = (buffer_id)data.readInt32();\n            OMX_U32 range_offset = data.readInt32();\n            OMX_U32 range_length = data.readInt32();\n            OMX_U32 flags = data.readInt32();\n            OMX_TICKS timestamp = data.readInt64();\n\n            reply->writeInt32(\n                    emptyBuffer(\n                        node, buffer, range_offset, range_length,\n                        flags, timestamp));\n\n            return NO_ERROR;\n        }\n\n        case GET_EXTENSION_INDEX:\n        {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            const char *parameter_name = data.readCString();\n\n            OMX_INDEXTYPE index;\n            status_t err = getExtensionIndex(node, parameter_name, &index);\n\n            reply->writeInt32(err);\n\n            if (err == OK) {\n                reply->writeInt32(index);\n            }\n\n            return OK;\n        }\n\n        default:\n            return BBinder::onTransact(code, data, reply, flags);\n    }\n}", "target": 3, "idx": 11095}
{"commit_id": "e52393740334443ae0206cab2d7caef381646725", "project": "neomutt", "func": "void imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_backtick)\n{\n  const char *quote = \"`\\\"\\\\\";\n  if (!quote_backtick)\n    quote++;\n\n  char *pt = dest;\n  const char *s = src;\n\n  *pt++ = '\"';\n  /* save room for trailing quote-char */\n  dlen -= 2;\n\n  for (; *s && dlen; s++)\n  {\n    if (strchr(quote, *s))\n    {\n      dlen -= 2;\n      if (dlen == 0)\n        break;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\"';\n  *pt = '\\0';\n}", "target": 3, "idx": 11096}
{"commit_id": "4b9a16764f2b12b611de9c34a50b4713d10ca401", "project": "virtualsquare/picotcp", "func": "static int tcp_parse_options(struct pico_frame *f)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)f->sock;\n    uint8_t *opt = f->transport_hdr + PICO_SIZE_TCPHDR;\n    uint32_t i = 0;\n    f->timestamp = 0;\n\n    if (f->buffer + f->buffer_len > f->transport_hdr + f->transport_len)\n        return -1;\n\n    while (i < (f->transport_len - PICO_SIZE_TCPHDR)) {\n        uint8_t type =  opt[i++];\n        uint8_t len;\n        if(i < (f->transport_len - PICO_SIZE_TCPHDR) && (type > 1))\n            len =  opt[i++];\n        else\n            len = 1;\n\n        if (f->payload && ((opt + i) > f->payload))\n            break;\n\n        if (len == 0) {\n            return -1;\n        }\n\n        tcp_dbg_options(\"Received option '%d', len = %d \\n\", type, len);\n        switch (type) {\n        case PICO_TCP_OPTION_NOOP:\n        case PICO_TCP_OPTION_END:\n            break;\n        case PICO_TCP_OPTION_WS:\n            tcp_parse_option_ws(t, len, opt, &i);\n            break;\n        case PICO_TCP_OPTION_SACK_OK:\n            tcp_parse_option_sack_ok(t, f, len, &i);\n            break;\n        case PICO_TCP_OPTION_MSS:\n            tcp_parse_option_mss(t, len, opt, &i);\n            break;\n        case PICO_TCP_OPTION_TIMESTAMP:\n            tcp_parse_option_timestamp(t, f, len, opt, &i);\n            break;\n\n        case PICO_TCP_OPTION_SACK:\n            tcp_rcv_sack(t, opt + i, len - 2);\n            i = i + len - 2;\n            break;\n        default:\n            tcp_dbg_options(\"TCP: received unsupported option %u\\n\", type);\n            i = i + len - 2;\n        }\n    }\n    return 0;\n}", "target": 2, "idx": 11097}
{"commit_id": "e362c0a34c814bebb78f5ec2fc3747475d1ed259", "project": "pcmacdon/jsish", "func": "static Jsi_RC jsi_ArraySpliceCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    int newlen, argc, istart, n, rhowmany, ilen, curlen;\n    Jsi_Value *va, *start, *howmany;\n    Jsi_Obj *nobj, *obj = _this->d.obj;\n    \n    start = Jsi_ValueArrayIndex(interp, args, 0);\n    howmany = Jsi_ValueArrayIndex(interp, args, 1);\n    argc = Jsi_ValueGetLength(interp, args);\n    istart = 0;\n    ilen = (argc>=2 ? argc - 2 : 0);\n    n = jsi_SizeOfArray(interp, obj);\n    curlen = n;\n    \n    if (!start)\n        return JSI_OK;\n\n    nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    Jsi_ValueMakeArrayObject(interp, ret, nobj);\n    Jsi_ObjSetLength(interp, nobj, 0);\n    \n    /* Determine start index. */\n    Jsi_Number nstart;\n    if (Jsi_GetNumberFromValue(interp, start, &nstart) != JSI_OK)\n      return JSI_ERROR;\n    istart = (int)nstart;\n    if (istart > n)\n        return JSI_OK;\n    if (istart < 0)\n        istart = (n+istart);\n    if (istart<0)\n        istart=0;\n      \n    Jsi_Number nhow;\n    rhowmany = n-istart;\n    if (howmany) {\n        if (Jsi_GetNumberFromValue(interp, howmany, &nhow) != JSI_OK) return JSI_ERROR;\n        rhowmany = (int)nhow;\n        if (rhowmany >= (n-istart))\n            rhowmany = n-istart;\n        if (rhowmany < 0)\n            rhowmany = (n-istart);\n        if (rhowmany<0)\n            return JSI_OK;\n    }\n    \n    if (curlen < 0) {\n        Jsi_ObjSetLength(interp, obj, curlen=0);\n    }\n    Jsi_ObjListifyArray(interp, obj);\n   \n    if (Jsi_ObjArraySizer(interp, nobj, rhowmany)<=0)\n      return JSI_ERROR;\n\n    /* Move elements to return object. */\n    int i, j, m;\n    for (m=0, j = 0, i = istart; m<rhowmany && m<curlen; m++, i++, j++)\n    {\n        if (!obj->arr[i]) continue;\n        nobj->arr[m] = obj->arr[i];\n        obj->arr[i] = NULL;\n    }\n    Jsi_ObjSetLength(interp, nobj, m);\n    \n    /* Shift remaining down. */\n    for (; rhowmany && i<curlen; i++)\n    {\n        obj->arr[i-rhowmany] = obj->arr[i];\n        obj->arr[i] = NULL;\n    }\n    curlen -= j;\n    /* Add elements. */\n    newlen = curlen + argc - (argc>=2?2:1);\n    if (Jsi_ObjArraySizer(interp, obj, newlen+3) <= 0) {\n        Jsi_ValueMakeUndef(interp, ret);\n        return Jsi_LogError(\"too long\");\n    }\n    if (ilen>0) {\n        for (i = curlen-1; i>=istart; i--) {\n            obj->arr[i+ilen] = obj->arr[i];\n            obj->arr[i] = NULL;\n        }\n        for (m=istart, i = 2; i<argc; m++,i++) {\n            va = Jsi_ValueArrayIndex(interp, args, i);\n            if (!va) continue;\n            obj->arr[m] = NULL;\n            Jsi_ValueDup2(interp, obj->arr+m, va);\n        }\n    }\n    Jsi_ObjSetLength(interp, obj, newlen);\n    return JSI_OK;\n}", "target": 1, "idx": 11098}
{"commit_id": "22192de5367fa0cee985917f092be4060b7c00b0", "project": "axiomatic-systems/Bento4", "func": "AP4_HdlrAtom::AP4_HdlrAtom(AP4_UI32        size, \n                           AP4_UI08        version,\n                           AP4_UI32        flags,\n                           AP4_ByteStream& stream) :\n    AP4_Atom(AP4_ATOM_TYPE_HDLR, size, version, flags)\n{\n    AP4_UI32 predefined;\n    stream.ReadUI32(predefined);\n    stream.ReadUI32(m_HandlerType);\n    stream.ReadUI32(m_Reserved[0]);\n    stream.ReadUI32(m_Reserved[1]);\n    stream.ReadUI32(m_Reserved[2]);\n    \n    // read the name unless it is empty\n    if (size < AP4_FULL_ATOM_HEADER_SIZE+20) return;\n    AP4_UI32 name_size = size-(AP4_FULL_ATOM_HEADER_SIZE+20);\n    char* name = new char[name_size+1];\n    if (name == NULL) return;\n    stream.Read(name, name_size);\n    name[name_size] = '\\0'; // force a null termination\n    // handle a special case: the Quicktime files have a pascal\n    // string here, but ISO MP4 files have a C string.\n    // we try to detect a pascal encoding and correct it.\n    if (name[0] == name_size-1) {\n        m_HandlerName = name+1;\n    } else {\n        m_HandlerName = name;\n    }\n    delete[] name;\n}", "target": 1, "idx": 11099}
{"commit_id": "daef4327fe0c75b0a90bb8627458feec7a301e1f", "project": "android", "func": "sp<IMemory> MetadataRetrieverClient::getFrameAtTime(int64_t timeUs, int option)\n{\n    ALOGV(\"getFrameAtTime: time(%lld us) option(%d)\", timeUs, option);\n    Mutex::Autolock lock(mLock);\n    Mutex::Autolock glock(sLock);\n    mThumbnail.clear();\n    if (mRetriever == NULL) {\n        ALOGE(\"retriever is not initialized\");\n        return NULL;\n    }\n    VideoFrame *frame = mRetriever->getFrameAtTime(timeUs, option);\n    if (frame == NULL) {\n        ALOGE(\"failed to capture a video frame\");\n        return NULL;\n    }\n    size_t size = sizeof(VideoFrame) + frame->mSize;\n    sp<MemoryHeapBase> heap = new MemoryHeapBase(size, 0, \"MetadataRetrieverClient\");\n    if (heap == NULL) {\n        ALOGE(\"failed to create MemoryDealer\");\n        delete frame;\n        return NULL;\n    }\n    mThumbnail = new MemoryBase(heap, 0, size);\n    if (mThumbnail == NULL) {\n        ALOGE(\"not enough memory for VideoFrame size=%u\", size);\n        delete frame;\n        return NULL;\n    }\n    VideoFrame *frameCopy = static_cast<VideoFrame *>(mThumbnail->pointer());\n    frameCopy->mWidth = frame->mWidth;\n    frameCopy->mHeight = frame->mHeight;\n    frameCopy->mDisplayWidth = frame->mDisplayWidth;\n    frameCopy->mDisplayHeight = frame->mDisplayHeight;\n    frameCopy->mSize = frame->mSize;\n    frameCopy->mRotationAngle = frame->mRotationAngle;\n    ALOGV(\"rotation: %d\", frameCopy->mRotationAngle);\n    frameCopy->mData = (uint8_t *)frameCopy + sizeof(VideoFrame);\n    memcpy(frameCopy->mData, frame->mData, frame->mSize);\n    frameCopy->mData = 0;\n    delete frame;  // Fix memory leakage\n    return mThumbnail;\n}", "target": 1, "idx": 11100}
{"commit_id": "f1e255d60ae66a9f672ff9a207ee6cd8e33d2679", "project": "torvalds/linux", "func": "static ssize_t yurex_read(struct file *file, char __user *buffer, size_t count,\n\t\t\t  loff_t *ppos)\n{\n\tstruct usb_yurex *dev;\n\tint len = 0;\n\tchar in_buffer[20];\n\tunsigned long flags;\n\n\tdev = file->private_data;\n\n\tmutex_lock(&dev->io_mutex);\n\tif (!dev->interface) {\t\t/* already disconnected */\n\t\tmutex_unlock(&dev->io_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tlen = snprintf(in_buffer, 20, \"%lld\\n\", dev->bbu);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\tmutex_unlock(&dev->io_mutex);\n\n\treturn simple_read_from_buffer(buffer, count, ppos, in_buffer, len);\n}", "target": 2, "idx": 11101}
{"commit_id": "49adc5d3f8c6bb75e55ebfeab109c5c37dea65e8", "project": "qemu", "func": "static void\npvscsi_convert_sglist(PVSCSIRequest *r)\n{\n    uint32_t chunk_size, elmcnt = 0;\n    uint64_t data_length = r->req.dataLen;\n    PVSCSISGState sg = r->sg;\n    while (data_length && elmcnt < PVSCSI_MAX_SG_ELEM) {\n        while (!sg.resid && elmcnt++ < PVSCSI_MAX_SG_ELEM) {\n            pvscsi_get_next_sg_elem(&sg);\n            trace_pvscsi_convert_sglist(r->req.context, r->sg.dataAddr,\n                                        r->sg.resid);\n        }\n        chunk_size = MIN(data_length, sg.resid);\n        if (chunk_size) {\n            qemu_sglist_add(&r->sgl, sg.dataAddr, chunk_size);\n        }\n\n        sg.dataAddr += chunk_size;\n        data_length -= chunk_size;\n        sg.resid -= chunk_size;\n    }\n}", "target": 1, "idx": 11102}
{"commit_id": "58a3122250d54de3a944c487776bcd4d1da4721e", "project": "FreeRDP", "func": "NTLM_AV_PAIR* ntlm_av_pair_get(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList, NTLM_AV_ID AvId,\n                               size_t* pcbAvPairListRemaining)\n{\n\tUINT16 id;\n\tsize_t cbAvPair = cbAvPairList;\n\tNTLM_AV_PAIR* pAvPair = pAvPairList;\n\n\tif (!ntlm_av_pair_check(pAvPair, cbAvPair))\n\t\tpAvPair = NULL;\n\n\twhile (pAvPair && ntlm_av_pair_get_id(pAvPair, cbAvPair, &id))\n\t{\n\t\tif (id == AvId)\n\t\t\tbreak;\n\t\tif (id == MsvAvEOL)\n\t\t{\n\t\t\tpAvPair = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tpAvPair = ntlm_av_pair_next(pAvPair, &cbAvPair);\n\t}\n\n\tif (!pAvPair)\n\t\tcbAvPair = 0;\n\tif (pcbAvPairListRemaining)\n\t\t*pcbAvPairListRemaining = cbAvPair;\n\n\treturn pAvPair;\n}", "target": 0, "idx": 11103}
{"commit_id": "a15378861368a4267c2c2c73b90db2849f943ebd", "project": "redis/hiredis", "func": "static int dictAdd(dict *ht, void *key, void *val) {\n    int index;\n    dictEntry *entry;\n\n    /* Get the index of the new element, or -1 if\n     * the element already exists. */\n    if ((index = _dictKeyIndex(ht, key)) == -1)\n        return DICT_ERR;\n\n    /* Allocates the memory and stores key */\n    entry = hi_malloc(sizeof(*entry));\n    entry->next = ht->table[index];\n    ht->table[index] = entry;\n\n    /* Set the hash entry fields. */\n    dictSetHashKey(ht, entry, key);\n    dictSetHashVal(ht, entry, val);\n    ht->used++;\n    return DICT_OK;\n}", "target": 2, "idx": 11104}
{"commit_id": "a15378861368a4267c2c2c73b90db2849f943ebd", "project": "redis/hiredis", "func": "static int redisLibeventAttach(redisAsyncContext *ac, struct event_base *base) {\n    redisContext *c = &(ac->c);\n    redisLibeventEvents *e;\n\n    /* Nothing should be attached when something is already attached */\n    if (ac->ev.data != NULL)\n        return REDIS_ERR;\n\n    /* Create container for context and r/w events */\n    e = (redisLibeventEvents*)hi_calloc(1, sizeof(*e));\n    e->context = ac;\n\n    /* Register functions to start/stop listening for events */\n    ac->ev.addRead = redisLibeventAddRead;\n    ac->ev.delRead = redisLibeventDelRead;\n    ac->ev.addWrite = redisLibeventAddWrite;\n    ac->ev.delWrite = redisLibeventDelWrite;\n    ac->ev.cleanup = redisLibeventCleanup;\n    ac->ev.data = e;\n\n    /* Initialize and install read/write events */\n    e->rev = event_new(base, c->fd, EV_READ, redisLibeventReadEvent, e);\n    e->wev = event_new(base, c->fd, EV_WRITE, redisLibeventWriteEvent, e);\n    event_add(e->rev, NULL);\n    event_add(e->wev, NULL);\n    return REDIS_OK;\n}", "target": 2, "idx": 11105}
{"commit_id": "15c2573daba9653a28f0c2d40f4419323a21a18c", "project": "zephyrproject-rtos/zephyr", "func": "static inline int is_in_region(u32_t r_index, u32_t start, u32_t size)\n{\n\tu32_t r_addr_start;\n\tu32_t r_addr_end;\n\tu32_t end;\n\n\tr_addr_start = SYSMPU->WORD[r_index][0];\n\tr_addr_end = SYSMPU->WORD[r_index][1];\n\n\tsize = size == 0 ? 0 : size - 1;\n\tif (__builtin_add_overflow(start, size, &end)) {\n\t\treturn 0;\n\t}\n\n\tif ((start >= r_addr_start) && (end <= r_addr_end)) {\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}", "target": 2, "idx": 11106}
{"commit_id": "aa6917772d2f32e5a7daab25a46c72df0b5ea406", "project": "rizinorg/rizin", "func": "static const ut8 *parse_die(const ut8 *buf, const ut8 *buf_end, RzBinDwarfDebugInfo *info, RzBinDwarfAbbrevDecl *abbrev,\n\tRzBinDwarfCompUnitHdr *hdr, RzBinDwarfDie *die, const ut8 *debug_str, size_t debug_str_len, bool big_endian) {\n\tsize_t i;\n\tconst char *comp_dir = NULL;\n\tut64 line_info_offset = UT64_MAX;\n\tif (abbrev->count) {\n\t\tfor (i = 0; i < abbrev->count - 1; i++) {\n\t\t\tmemset(&die->attr_values[i], 0, sizeof(die->attr_values[i]));\n\n\t\t\tbuf = parse_attr_value(buf, buf_end - buf, &abbrev->defs[i],\n\t\t\t\t&die->attr_values[i], hdr, debug_str, debug_str_len, big_endian);\n\n\t\t\tRzBinDwarfAttrValue *attribute = &die->attr_values[i];\n\n\t\t\tif (attribute->attr_name == DW_AT_comp_dir && (attribute->attr_form == DW_FORM_strp || attribute->attr_form == DW_FORM_string) && attribute->string.content) {\n\t\t\t\tcomp_dir = attribute->string.content;\n\t\t\t}\n\t\t\tif (attribute->attr_name == DW_AT_stmt_list) {\n\t\t\t\tif (attribute->kind == DW_AT_KIND_CONSTANT) {\n\t\t\t\t\tline_info_offset = attribute->uconstant;\n\t\t\t\t} else if (attribute->kind == DW_AT_KIND_REFERENCE) {\n\t\t\t\t\tline_info_offset = attribute->reference;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdie->count++;\n\t\t}\n\t}\n\n\t// If this is a compilation unit dir attribute, we want to cache it so the line info parsing\n\t// which will need this info can quickly look it up.\n\tif (comp_dir && line_info_offset != UT64_MAX) {\n\t\tchar *name = strdup(comp_dir);\n\t\tif (name) {\n\t\t\tif (!ht_up_insert(info->line_info_offset_comp_dir, line_info_offset, name)) {\n\t\t\t\tfree(name);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn buf;\n}", "target": 2, "idx": 11107}
{"commit_id": "75e5b4849b81e19e9efe1654b30d7f3151c33c2c", "project": "torvalds/linux", "func": "int\ncomposite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)\n{\n\tstruct usb_composite_dev\t*cdev = get_gadget_data(gadget);\n\tstruct usb_request\t\t*req = cdev->req;\n\tint\t\t\t\tvalue = -EOPNOTSUPP;\n\tint\t\t\t\tstatus = 0;\n\tu16\t\t\t\tw_index = le16_to_cpu(ctrl->wIndex);\n\tu8\t\t\t\tintf = w_index & 0xFF;\n\tu16\t\t\t\tw_value = le16_to_cpu(ctrl->wValue);\n\tu16\t\t\t\tw_length = le16_to_cpu(ctrl->wLength);\n\tstruct usb_function\t\t*f = NULL;\n\tu8\t\t\t\tendp;\n\n\tif (w_length > USB_COMP_EP0_BUFSIZ) {\n\t\tif (ctrl->bRequestType & USB_DIR_IN) {\n\t\t\t/* Cast away the const, we are going to overwrite on purpose. */\n\t\t\t__le16 *temp = (__le16 *)&ctrl->wLength;\n\n\t\t\t*temp = cpu_to_le16(USB_COMP_EP0_BUFSIZ);\n\t\t\tw_length = USB_COMP_EP0_BUFSIZ;\n\t\t} else {\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* partial re-init of the response message; the function or the\n\t * gadget might need to intercept e.g. a control-OUT completion\n\t * when we delegate to it.\n\t */\n\treq->zero = 0;\n\treq->context = cdev;\n\treq->complete = composite_setup_complete;\n\treq->length = 0;\n\tgadget->ep0->driver_data = cdev;\n\n\t/*\n\t * Don't let non-standard requests match any of the cases below\n\t * by accident.\n\t */\n\tif ((ctrl->bRequestType & USB_TYPE_MASK) != USB_TYPE_STANDARD)\n\t\tgoto unknown;\n\n\tswitch (ctrl->bRequest) {\n\n\t/* we handle all standard USB descriptors */\n\tcase USB_REQ_GET_DESCRIPTOR:\n\t\tif (ctrl->bRequestType != USB_DIR_IN)\n\t\t\tgoto unknown;\n\t\tswitch (w_value >> 8) {\n\n\t\tcase USB_DT_DEVICE:\n\t\t\tcdev->desc.bNumConfigurations =\n\t\t\t\tcount_configs(cdev, USB_DT_DEVICE);\n\t\t\tcdev->desc.bMaxPacketSize0 =\n\t\t\t\tcdev->gadget->ep0->maxpacket;\n\t\t\tif (gadget_is_superspeed(gadget)) {\n\t\t\t\tif (gadget->speed >= USB_SPEED_SUPER) {\n\t\t\t\t\tcdev->desc.bcdUSB = cpu_to_le16(0x0320);\n\t\t\t\t\tcdev->desc.bMaxPacketSize0 = 9;\n\t\t\t\t} else {\n\t\t\t\t\tcdev->desc.bcdUSB = cpu_to_le16(0x0210);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (gadget->lpm_capable)\n\t\t\t\t\tcdev->desc.bcdUSB = cpu_to_le16(0x0201);\n\t\t\t\telse\n\t\t\t\t\tcdev->desc.bcdUSB = cpu_to_le16(0x0200);\n\t\t\t}\n\n\t\t\tvalue = min(w_length, (u16) sizeof cdev->desc);\n\t\t\tmemcpy(req->buf, &cdev->desc, value);\n\t\t\tbreak;\n\t\tcase USB_DT_DEVICE_QUALIFIER:\n\t\t\tif (!gadget_is_dualspeed(gadget) ||\n\t\t\t    gadget->speed >= USB_SPEED_SUPER)\n\t\t\t\tbreak;\n\t\t\tdevice_qual(cdev);\n\t\t\tvalue = min_t(int, w_length,\n\t\t\t\tsizeof(struct usb_qualifier_descriptor));\n\t\t\tbreak;\n\t\tcase USB_DT_OTHER_SPEED_CONFIG:\n\t\t\tif (!gadget_is_dualspeed(gadget) ||\n\t\t\t    gadget->speed >= USB_SPEED_SUPER)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tcase USB_DT_CONFIG:\n\t\t\tvalue = config_desc(cdev, w_value);\n\t\t\tif (value >= 0)\n\t\t\t\tvalue = min(w_length, (u16) value);\n\t\t\tbreak;\n\t\tcase USB_DT_STRING:\n\t\t\tvalue = get_string(cdev, req->buf,\n\t\t\t\t\tw_index, w_value & 0xff);\n\t\t\tif (value >= 0)\n\t\t\t\tvalue = min(w_length, (u16) value);\n\t\t\tbreak;\n\t\tcase USB_DT_BOS:\n\t\t\tif (gadget_is_superspeed(gadget) ||\n\t\t\t    gadget->lpm_capable) {\n\t\t\t\tvalue = bos_desc(cdev);\n\t\t\t\tvalue = min(w_length, (u16) value);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase USB_DT_OTG:\n\t\t\tif (gadget_is_otg(gadget)) {\n\t\t\t\tstruct usb_configuration *config;\n\t\t\t\tint otg_desc_len = 0;\n\n\t\t\t\tif (cdev->config)\n\t\t\t\t\tconfig = cdev->config;\n\t\t\t\telse\n\t\t\t\t\tconfig = list_first_entry(\n\t\t\t\t\t\t\t&cdev->configs,\n\t\t\t\t\t\tstruct usb_configuration, list);\n\t\t\t\tif (!config)\n\t\t\t\t\tgoto done;\n\n\t\t\t\tif (gadget->otg_caps &&\n\t\t\t\t\t(gadget->otg_caps->otg_rev >= 0x0200))\n\t\t\t\t\totg_desc_len += sizeof(\n\t\t\t\t\t\tstruct usb_otg20_descriptor);\n\t\t\t\telse\n\t\t\t\t\totg_desc_len += sizeof(\n\t\t\t\t\t\tstruct usb_otg_descriptor);\n\n\t\t\t\tvalue = min_t(int, w_length, otg_desc_len);\n\t\t\t\tmemcpy(req->buf, config->descriptors[0], value);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\t/* any number of configs can work */\n\tcase USB_REQ_SET_CONFIGURATION:\n\t\tif (ctrl->bRequestType != 0)\n\t\t\tgoto unknown;\n\t\tif (gadget_is_otg(gadget)) {\n\t\t\tif (gadget->a_hnp_support)\n\t\t\t\tDBG(cdev, \"HNP available\\n\");\n\t\t\telse if (gadget->a_alt_hnp_support)\n\t\t\t\tDBG(cdev, \"HNP on another port\\n\");\n\t\t\telse\n\t\t\t\tVDBG(cdev, \"HNP inactive\\n\");\n\t\t}\n\t\tspin_lock(&cdev->lock);\n\t\tvalue = set_config(cdev, ctrl, w_value);\n\t\tspin_unlock(&cdev->lock);\n\t\tbreak;\n\tcase USB_REQ_GET_CONFIGURATION:\n\t\tif (ctrl->bRequestType != USB_DIR_IN)\n\t\t\tgoto unknown;\n\t\tif (cdev->config)\n\t\t\t*(u8 *)req->buf = cdev->config->bConfigurationValue;\n\t\telse\n\t\t\t*(u8 *)req->buf = 0;\n\t\tvalue = min(w_length, (u16) 1);\n\t\tbreak;\n\n\t/* function drivers must handle get/set altsetting */\n\tcase USB_REQ_SET_INTERFACE:\n\t\tif (ctrl->bRequestType != USB_RECIP_INTERFACE)\n\t\t\tgoto unknown;\n\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\tbreak;\n\t\tf = cdev->config->interface[intf];\n\t\tif (!f)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * If there's no get_alt() method, we know only altsetting zero\n\t\t * works. There is no need to check if set_alt() is not NULL\n\t\t * as we check this in usb_add_function().\n\t\t */\n\t\tif (w_value && !f->get_alt)\n\t\t\tbreak;\n\n\t\tspin_lock(&cdev->lock);\n\t\tvalue = f->set_alt(f, w_index, w_value);\n\t\tif (value == USB_GADGET_DELAYED_STATUS) {\n\t\t\tDBG(cdev,\n\t\t\t \"%s: interface %d (%s) requested delayed status\\n\",\n\t\t\t\t\t__func__, intf, f->name);\n\t\t\tcdev->delayed_status++;\n\t\t\tDBG(cdev, \"delayed_status count %d\\n\",\n\t\t\t\t\tcdev->delayed_status);\n\t\t}\n\t\tspin_unlock(&cdev->lock);\n\t\tbreak;\n\tcase USB_REQ_GET_INTERFACE:\n\t\tif (ctrl->bRequestType != (USB_DIR_IN|USB_RECIP_INTERFACE))\n\t\t\tgoto unknown;\n\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\tbreak;\n\t\tf = cdev->config->interface[intf];\n\t\tif (!f)\n\t\t\tbreak;\n\t\t/* lots of interfaces only need altsetting zero... */\n\t\tvalue = f->get_alt ? f->get_alt(f, w_index) : 0;\n\t\tif (value < 0)\n\t\t\tbreak;\n\t\t*((u8 *)req->buf) = value;\n\t\tvalue = min(w_length, (u16) 1);\n\t\tbreak;\n\tcase USB_REQ_GET_STATUS:\n\t\tif (gadget_is_otg(gadget) && gadget->hnp_polling_support &&\n\t\t\t\t\t\t(w_index == OTG_STS_SELECTOR)) {\n\t\t\tif (ctrl->bRequestType != (USB_DIR_IN |\n\t\t\t\t\t\t\tUSB_RECIP_DEVICE))\n\t\t\t\tgoto unknown;\n\t\t\t*((u8 *)req->buf) = gadget->host_request_flag;\n\t\t\tvalue = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * USB 3.0 additions:\n\t\t * Function driver should handle get_status request. If such cb\n\t\t * wasn't supplied we respond with default value = 0\n\t\t * Note: function driver should supply such cb only for the\n\t\t * first interface of the function\n\t\t */\n\t\tif (!gadget_is_superspeed(gadget))\n\t\t\tgoto unknown;\n\t\tif (ctrl->bRequestType != (USB_DIR_IN | USB_RECIP_INTERFACE))\n\t\t\tgoto unknown;\n\t\tvalue = 2;\t/* This is the length of the get_status reply */\n\t\tput_unaligned_le16(0, req->buf);\n\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\tbreak;\n\t\tf = cdev->config->interface[intf];\n\t\tif (!f)\n\t\t\tbreak;\n\t\tstatus = f->get_status ? f->get_status(f) : 0;\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tput_unaligned_le16(status & 0x0000ffff, req->buf);\n\t\tbreak;\n\t/*\n\t * Function drivers should handle SetFeature/ClearFeature\n\t * (FUNCTION_SUSPEND) request. function_suspend cb should be supplied\n\t * only for the first interface of the function\n\t */\n\tcase USB_REQ_CLEAR_FEATURE:\n\tcase USB_REQ_SET_FEATURE:\n\t\tif (!gadget_is_superspeed(gadget))\n\t\t\tgoto unknown;\n\t\tif (ctrl->bRequestType != (USB_DIR_OUT | USB_RECIP_INTERFACE))\n\t\t\tgoto unknown;\n\t\tswitch (w_value) {\n\t\tcase USB_INTRF_FUNC_SUSPEND:\n\t\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\t\tbreak;\n\t\t\tf = cdev->config->interface[intf];\n\t\t\tif (!f)\n\t\t\t\tbreak;\n\t\t\tvalue = 0;\n\t\t\tif (f->func_suspend)\n\t\t\t\tvalue = f->func_suspend(f, w_index >> 8);\n\t\t\tif (value < 0) {\n\t\t\t\tERROR(cdev,\n\t\t\t\t      \"func_suspend() returned error %d\\n\",\n\t\t\t\t      value);\n\t\t\t\tvalue = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\nunknown:\n\t\t/*\n\t\t * OS descriptors handling\n\t\t */\n\t\tif (cdev->use_os_string && cdev->os_desc_config &&\n\t\t    (ctrl->bRequestType & USB_TYPE_VENDOR) &&\n\t\t    ctrl->bRequest == cdev->b_vendor_code) {\n\t\t\tstruct usb_configuration\t*os_desc_cfg;\n\t\t\tu8\t\t\t\t*buf;\n\t\t\tint\t\t\t\tinterface;\n\t\t\tint\t\t\t\tcount = 0;\n\n\t\t\treq = cdev->os_desc_req;\n\t\t\treq->context = cdev;\n\t\t\treq->complete = composite_setup_complete;\n\t\t\tbuf = req->buf;\n\t\t\tos_desc_cfg = cdev->os_desc_config;\n\t\t\tw_length = min_t(u16, w_length, USB_COMP_EP0_OS_DESC_BUFSIZ);\n\t\t\tmemset(buf, 0, w_length);\n\t\t\tbuf[5] = 0x01;\n\t\t\tswitch (ctrl->bRequestType & USB_RECIP_MASK) {\n\t\t\tcase USB_RECIP_DEVICE:\n\t\t\t\tif (w_index != 0x4 || (w_value >> 8))\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[6] = w_index;\n\t\t\t\t/* Number of ext compat interfaces */\n\t\t\t\tcount = count_ext_compat(os_desc_cfg);\n\t\t\t\tbuf[8] = count;\n\t\t\t\tcount *= 24; /* 24 B/ext compat desc */\n\t\t\t\tcount += 16; /* header */\n\t\t\t\tput_unaligned_le32(count, buf);\n\t\t\t\tvalue = w_length;\n\t\t\t\tif (w_length > 0x10) {\n\t\t\t\t\tvalue = fill_ext_compat(os_desc_cfg, buf);\n\t\t\t\t\tvalue = min_t(u16, w_length, value);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase USB_RECIP_INTERFACE:\n\t\t\t\tif (w_index != 0x5 || (w_value >> 8))\n\t\t\t\t\tbreak;\n\t\t\t\tinterface = w_value & 0xFF;\n\t\t\t\tif (interface >= MAX_CONFIG_INTERFACES ||\n\t\t\t\t    !os_desc_cfg->interface[interface])\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[6] = w_index;\n\t\t\t\tcount = count_ext_prop(os_desc_cfg,\n\t\t\t\t\tinterface);\n\t\t\t\tput_unaligned_le16(count, buf + 8);\n\t\t\t\tcount = len_ext_prop(os_desc_cfg,\n\t\t\t\t\tinterface);\n\t\t\t\tput_unaligned_le32(count, buf);\n\t\t\t\tvalue = w_length;\n\t\t\t\tif (w_length > 0x0A) {\n\t\t\t\t\tvalue = fill_ext_prop(os_desc_cfg,\n\t\t\t\t\t\t\t      interface, buf);\n\t\t\t\t\tif (value >= 0)\n\t\t\t\t\t\tvalue = min_t(u16, w_length, value);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tgoto check_value;\n\t\t}\n\n\t\tVDBG(cdev,\n\t\t\t\"non-core control req%02x.%02x v%04x i%04x l%d\\n\",\n\t\t\tctrl->bRequestType, ctrl->bRequest,\n\t\t\tw_value, w_index, w_length);\n\n\t\t/* functions always handle their interfaces and endpoints...\n\t\t * punt other recipients (other, WUSB, ...) to the current\n\t\t * configuration code.\n\t\t */\n\t\tif (cdev->config) {\n\t\t\tlist_for_each_entry(f, &cdev->config->functions, list)\n\t\t\t\tif (f->req_match &&\n\t\t\t\t    f->req_match(f, ctrl, false))\n\t\t\t\t\tgoto try_fun_setup;\n\t\t} else {\n\t\t\tstruct usb_configuration *c;\n\t\t\tlist_for_each_entry(c, &cdev->configs, list)\n\t\t\t\tlist_for_each_entry(f, &c->functions, list)\n\t\t\t\t\tif (f->req_match &&\n\t\t\t\t\t    f->req_match(f, ctrl, true))\n\t\t\t\t\t\tgoto try_fun_setup;\n\t\t}\n\t\tf = NULL;\n\n\t\tswitch (ctrl->bRequestType & USB_RECIP_MASK) {\n\t\tcase USB_RECIP_INTERFACE:\n\t\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\t\tbreak;\n\t\t\tf = cdev->config->interface[intf];\n\t\t\tbreak;\n\n\t\tcase USB_RECIP_ENDPOINT:\n\t\t\tif (!cdev->config)\n\t\t\t\tbreak;\n\t\t\tendp = ((w_index & 0x80) >> 3) | (w_index & 0x0f);\n\t\t\tlist_for_each_entry(f, &cdev->config->functions, list) {\n\t\t\t\tif (test_bit(endp, f->endpoints))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (&f->list == &cdev->config->functions)\n\t\t\t\tf = NULL;\n\t\t\tbreak;\n\t\t}\ntry_fun_setup:\n\t\tif (f && f->setup)\n\t\t\tvalue = f->setup(f, ctrl);\n\t\telse {\n\t\t\tstruct usb_configuration\t*c;\n\n\t\t\tc = cdev->config;\n\t\t\tif (!c)\n\t\t\t\tgoto done;\n\n\t\t\t/* try current config's setup */\n\t\t\tif (c->setup) {\n\t\t\t\tvalue = c->setup(c, ctrl);\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\t/* try the only function in the current config */\n\t\t\tif (!list_is_singular(&c->functions))\n\t\t\t\tgoto done;\n\t\t\tf = list_first_entry(&c->functions, struct usb_function,\n\t\t\t\t\t     list);\n\t\t\tif (f->setup)\n\t\t\t\tvalue = f->setup(f, ctrl);\n\t\t}\n\n\t\tgoto done;\n\t}\n\ncheck_value:\n\t/* respond with data transfer before status phase? */\n\tif (value >= 0 && value != USB_GADGET_DELAYED_STATUS) {\n\t\treq->length = value;\n\t\treq->context = cdev;\n\t\treq->zero = value < w_length;\n\t\tvalue = composite_ep0_queue(cdev, req, GFP_ATOMIC);\n\t\tif (value < 0) {\n\t\t\tDBG(cdev, \"ep_queue --> %d\\n\", value);\n\t\t\treq->status = 0;\n\t\t\tcomposite_setup_complete(gadget->ep0, req);\n\t\t}\n\t} else if (value == USB_GADGET_DELAYED_STATUS && w_length != 0) {\n\t\tWARN(cdev,\n\t\t\t\"%s: Delayed status not supported for w_length != 0\",\n\t\t\t__func__);\n\t}\n\ndone:\n\t/* device either stalls (value < 0) or reports success */\n\treturn value;\n}", "target": 1, "idx": 11108}
{"commit_id": "eb0362808b4f9f1e2345a0cf203b8cc196d776d9", "project": "libexpat", "func": "static XML_Bool\nstoreRawNames(XML_Parser parser) {\n  TAG *tag = parser->m_tagStack;\n  while (tag) {\n    int bufSize;\n    int nameLen = sizeof(XML_Char) * (tag->name.strLen + 1);\n    size_t rawNameLen;\n    char *rawNameBuf = tag->buf + nameLen;\n    /* Stop if already stored.  Since m_tagStack is a stack, we can stop\n       at the first entry that has already been copied; everything\n       below it in the stack is already been accounted for in a\n       previous call to this function.\n    */\n    if (tag->rawName == rawNameBuf)\n      break;\n    /* For re-use purposes we need to ensure that the\n       size of tag->buf is a multiple of sizeof(XML_Char).\n    */\n    rawNameLen = ROUND_UP(tag->rawNameLength, sizeof(XML_Char));\n    /* Detect and prevent integer overflow. */\n    if (rawNameLen > (size_t)INT_MAX - nameLen)\n      return XML_FALSE;\n    bufSize = nameLen + (int)rawNameLen;\n    if (bufSize > tag->bufEnd - tag->buf) {\n      char *temp = (char *)REALLOC(parser, tag->buf, bufSize);\n      if (temp == NULL)\n        return XML_FALSE;\n      /* if tag->name.str points to tag->buf (only when namespace\n         processing is off) then we have to update it\n      */\n      if (tag->name.str == (XML_Char *)tag->buf)\n        tag->name.str = (XML_Char *)temp;\n      /* if tag->name.localPart is set (when namespace processing is on)\n         then update it as well, since it will always point into tag->buf\n      */\n      if (tag->name.localPart)\n        tag->name.localPart\n            = (XML_Char *)temp + (tag->name.localPart - (XML_Char *)tag->buf);\n      tag->buf = temp;\n      tag->bufEnd = temp + bufSize;\n      rawNameBuf = temp + nameLen;\n    }\n    memcpy(rawNameBuf, tag->rawName, tag->rawNameLength);\n    tag->rawName = rawNameBuf;\n    tag = tag->parent;\n  }\n  return XML_TRUE;\n}", "target": 3, "idx": 11109}
{"commit_id": "7bdf50bb4f5c54a4997c379092888546c97c3ebd", "project": "tensorflow", "func": "void UncompressElementOp::Compute(OpKernelContext* ctx) {\n  Tensor tensor = ctx->input(0);\n  const Variant& variant = tensor.scalar<Variant>()();\n  const CompressedElement* compressed = variant.get<CompressedElement>();\n  OP_REQUIRES(\n      ctx, compressed != nullptr,\n      errors::InvalidArgument(\n          \"Input does not contain a compressed element. Instead got tensor \",\n          tensor.DebugString()));\n\n  std::vector<Tensor> components;\n  OP_REQUIRES_OK(ctx, UncompressElement(*compressed, &components));\n  OP_REQUIRES(ctx, components.size() == output_types_.size(),\n              errors::FailedPrecondition(\"Expected \", output_types_.size(),\n                                         \" outputs from uncompress, but got \",\n                                         components.size()));\n  for (int i = 0; i < components.size(); ++i) {\n    OP_REQUIRES(\n        ctx, components[i].dtype() == output_types_[i],\n        errors::FailedPrecondition(\"Expected a tensor of type \",\n                                   DataTypeString(output_types_[i]),\n                                   \" but got a tensor of type \",\n                                   DataTypeString(components[i].dtype())));\n    ctx->set_output(i, components[i]);\n  }\n}", "target": 2, "idx": 11110}
{"commit_id": "721dc1305b2bfff92e5ca605dc1a47c61ce90b9f", "project": "ImageMagick", "func": "static Image *ReadSGIImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  MemoryInfo\n    *pixel_info;\n\n  register IndexPacket\n    *indexes;\n\n  register PixelPacket\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *p;\n\n  SGIInfo\n    iris_info;\n\n  size_t\n    bytes_per_pixel,\n    quantum;\n\n  ssize_t\n    count,\n    y,\n    z;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read SGI raster header.\n  */\n  iris_info.magic=ReadBlobMSBShort(image);\n  do\n  {\n    /*\n      Verify SGI identifier.\n    */\n    if (iris_info.magic != 0x01DA)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    iris_info.storage=(unsigned char) ReadBlobByte(image);\n    switch (iris_info.storage)\n    {\n      case 0x00: image->compression=NoCompression; break;\n      case 0x01: image->compression=RLECompression; break;\n      default:\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n    iris_info.bytes_per_pixel=(unsigned char) ReadBlobByte(image);\n    if ((iris_info.bytes_per_pixel == 0) || (iris_info.bytes_per_pixel > 2))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    iris_info.dimension=ReadBlobMSBShort(image);\n    if ((iris_info.dimension == 0) || (iris_info.dimension > 3)) \n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    iris_info.columns=ReadBlobMSBShort(image);\n    iris_info.rows=ReadBlobMSBShort(image);\n    iris_info.depth=ReadBlobMSBShort(image);\n    if ((iris_info.depth == 0) || (iris_info.depth > 4))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    iris_info.minimum_value=ReadBlobMSBLong(image);\n    iris_info.maximum_value=ReadBlobMSBLong(image);\n    iris_info.sans=ReadBlobMSBLong(image);\n    count=ReadBlob(image,sizeof(iris_info.name),(unsigned char *)\n      iris_info.name);\n    if ((size_t) count != sizeof(iris_info.name))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    iris_info.name[sizeof(iris_info.name)-1]='\\0';\n    if (*iris_info.name != '\\0')\n      (void) SetImageProperty(image,\"label\",iris_info.name);\n    iris_info.pixel_format=ReadBlobMSBLong(image);\n    if (iris_info.pixel_format != 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    count=ReadBlob(image,sizeof(iris_info.filler),iris_info.filler);\n    if ((size_t) count != sizeof(iris_info.filler))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    image->columns=iris_info.columns;\n    image->rows=iris_info.rows;\n    image->matte=iris_info.depth == 4 ? MagickTrue : MagickFalse;\n    image->depth=(size_t) MagickMin(iris_info.depth,MAGICKCORE_QUANTUM_DEPTH);\n    if (iris_info.pixel_format == 0)\n      image->depth=(size_t) MagickMin((size_t) 8*iris_info.bytes_per_pixel,\n        MAGICKCORE_QUANTUM_DEPTH);\n    if (iris_info.depth < 3)\n      {\n        image->storage_class=PseudoClass;\n        image->colors=(size_t) (iris_info.bytes_per_pixel > 1 ? 65535 : 256);\n      }\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    /*\n      Allocate SGI pixels.\n    */\n    bytes_per_pixel=(size_t) iris_info.bytes_per_pixel;\n    number_pixels=(MagickSizeType) iris_info.columns*iris_info.rows;\n    if ((4*bytes_per_pixel*number_pixels) != ((MagickSizeType) (size_t)\n        (4*bytes_per_pixel*number_pixels)))\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixel_info=AcquireVirtualMemory(iris_info.columns,iris_info.rows*4*\n      bytes_per_pixel*sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    if ((int) iris_info.storage != 0x01)\n      {\n        unsigned char\n          *scanline;\n\n        /*\n          Read standard image format.\n        */\n        scanline=(unsigned char *) AcquireQuantumMemory(iris_info.columns,\n          bytes_per_pixel*sizeof(*scanline));\n        if (scanline == (unsigned char *) NULL)\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        for (z=0; z < (ssize_t) iris_info.depth; z++)\n        {\n          p=pixels+bytes_per_pixel*z;\n          for (y=0; y < (ssize_t) iris_info.rows; y++)\n          {\n            (void) ReadBlob(image,bytes_per_pixel*iris_info.columns,scanline);\n            if (EOFBlob(image) != MagickFalse)\n              break;\n            if (bytes_per_pixel == 2)\n              for (x=0; x < (ssize_t) iris_info.columns; x++)\n              {\n                *p=scanline[2*x];\n                *(p+1)=scanline[2*x+1];\n                p+=8;\n              }\n            else\n              for (x=0; x < (ssize_t) iris_info.columns; x++)\n              {\n                *p=scanline[x];\n                p+=4;\n              }\n          }\n        }\n        scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n      }\n    else\n      {\n        MemoryInfo\n          *packet_info;\n\n        size_t\n          *runlength;\n\n        ssize_t\n          offset,\n          *offsets;\n\n        unsigned char\n          *packets;\n\n        unsigned int\n          data_order;\n\n        /*\n          Read runlength-encoded image format.\n        */\n        offsets=(ssize_t *) AcquireQuantumMemory((size_t) iris_info.rows,\n          iris_info.depth*sizeof(*offsets));\n        runlength=(size_t *) AcquireQuantumMemory(iris_info.rows,\n          iris_info.depth*sizeof(*runlength));\n        packet_info=AcquireVirtualMemory((size_t) iris_info.columns+10UL,4UL*\n          sizeof(*packets));\n        if ((offsets == (ssize_t *) NULL) ||\n            (runlength == (size_t *) NULL) ||\n            (packet_info == (MemoryInfo *) NULL))\n          {\n            offsets=(ssize_t *) RelinquishMagickMemory(offsets);\n            runlength=(size_t *) RelinquishMagickMemory(runlength);\n            if (packet_info != (MemoryInfo *) NULL)\n              packet_info=RelinquishVirtualMemory(packet_info);\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        packets=(unsigned char *) GetVirtualMemoryBlob(packet_info);\n        for (i=0; i < (ssize_t) (iris_info.rows*iris_info.depth); i++)\n          offsets[i]=(ssize_t) ReadBlobMSBSignedLong(image);\n        for (i=0; i < (ssize_t) (iris_info.rows*iris_info.depth); i++)\n        {\n          runlength[i]=ReadBlobMSBLong(image);\n          if (runlength[i] > (4*(size_t) iris_info.columns+10))\n            {\n              offsets=(ssize_t *) RelinquishMagickMemory(offsets);\n              runlength=(size_t *) RelinquishMagickMemory(runlength);\n              packet_info=RelinquishVirtualMemory(packet_info);\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            }\n        }\n        /*\n          Check data order.\n        */\n        offset=0;\n        data_order=0;\n        for (y=0; ((y < (ssize_t) iris_info.rows) && (data_order == 0)); y++)\n          for (z=0; ((z < (ssize_t) iris_info.depth) && (data_order == 0)); z++)\n          {\n            if (offsets[y+z*iris_info.rows] < offset)\n              data_order=1;\n            offset=offsets[y+z*iris_info.rows];\n          }\n        offset=(ssize_t) TellBlob(image);\n        if (data_order == 1)\n          {\n            for (z=0; z < (ssize_t) iris_info.depth; z++)\n            {\n              p=pixels;\n              for (y=0; y < (ssize_t) iris_info.rows; y++)\n              {\n                if (offset != offsets[y+z*iris_info.rows])\n                  {\n                    offset=offsets[y+z*iris_info.rows];\n                    offset=(ssize_t) SeekBlob(image,(MagickOffsetType) offset,\n                      SEEK_SET);\n                  }\n                (void) ReadBlob(image,(size_t) runlength[y+z*iris_info.rows],\n                  packets);\n                if (EOFBlob(image) != MagickFalse)\n                  break;\n                offset+=(ssize_t) runlength[y+z*iris_info.rows];\n                status=SGIDecode(bytes_per_pixel,(ssize_t)\n                  (runlength[y+z*iris_info.rows]/bytes_per_pixel),packets,\n                  (ssize_t) iris_info.columns,p+bytes_per_pixel*z);\n                if (status == MagickFalse)\n                  {\n                    offsets=(ssize_t *) RelinquishMagickMemory(offsets);\n                    runlength=(size_t *) RelinquishMagickMemory(runlength);\n                    packet_info=RelinquishVirtualMemory(packet_info);\n                    pixel_info=RelinquishVirtualMemory(pixel_info);\n                    ThrowReaderException(CorruptImageError,\n                      \"ImproperImageHeader\");\n                  }\n                p+=(iris_info.columns*4*bytes_per_pixel);\n              }\n            }\n          }\n        else\n          {\n            MagickOffsetType\n              position;\n\n            position=TellBlob(image);\n            p=pixels;\n            for (y=0; y < (ssize_t) iris_info.rows; y++)\n            {\n              for (z=0; z < (ssize_t) iris_info.depth; z++)\n              {\n                if (offset != offsets[y+z*iris_info.rows])\n                  {\n                    offset=offsets[y+z*iris_info.rows];\n                    offset=(ssize_t) SeekBlob(image,(MagickOffsetType) offset,\n                      SEEK_SET);\n                  }\n                (void) ReadBlob(image,(size_t) runlength[y+z*iris_info.rows],\n                  packets);\n                if (EOFBlob(image) != MagickFalse)\n                  break;\n                offset+=(ssize_t) runlength[y+z*iris_info.rows];\n                status=SGIDecode(bytes_per_pixel,(ssize_t)\n                  (runlength[y+z*iris_info.rows]/bytes_per_pixel),packets,\n                  (ssize_t) iris_info.columns,p+bytes_per_pixel*z);\n                if (status == MagickFalse)\n                  {\n                    offsets=(ssize_t *) RelinquishMagickMemory(offsets);\n                    runlength=(size_t *) RelinquishMagickMemory(runlength);\n                    packet_info=RelinquishVirtualMemory(packet_info);\n                    pixel_info=RelinquishVirtualMemory(pixel_info);\n                    ThrowReaderException(CorruptImageError,\n                      \"ImproperImageHeader\");\n                  }\n              }\n              p+=(iris_info.columns*4*bytes_per_pixel);\n            }\n            offset=(ssize_t) SeekBlob(image,position,SEEK_SET);\n          }\n        packet_info=RelinquishVirtualMemory(packet_info);\n        runlength=(size_t *) RelinquishMagickMemory(runlength);\n        offsets=(ssize_t *) RelinquishMagickMemory(offsets);\n      }\n    /*\n      Convert SGI raster image to pixel packets.\n    */\n    if (image->storage_class == DirectClass)\n      {\n        /*\n          Convert SGI image to DirectClass pixel packets.\n        */\n        if (bytes_per_pixel == 2)\n          {\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=pixels+(image->rows-y-1)*8*image->columns;\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelRed(q,ScaleShortToQuantum((unsigned short)\n                  ((*(p+0) << 8) | (*(p+1)))));\n                SetPixelGreen(q,ScaleShortToQuantum((unsigned short)\n                  ((*(p+2) << 8) | (*(p+3)))));\n                SetPixelBlue(q,ScaleShortToQuantum((unsigned short)\n                  ((*(p+4) << 8) | (*(p+5)))));\n                SetPixelOpacity(q,OpaqueOpacity);\n                if (image->matte != MagickFalse)\n                  SetPixelAlpha(q,ScaleShortToQuantum((unsigned short)\n                    ((*(p+6) << 8) | (*(p+7)))));\n                p+=8;\n                q++;\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        else\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=pixels+(image->rows-y-1)*4*image->columns;\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (PixelPacket *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelRed(q,ScaleCharToQuantum(*p));\n              q->green=ScaleCharToQuantum(*(p+1));\n              q->blue=ScaleCharToQuantum(*(p+2));\n              SetPixelOpacity(q,OpaqueOpacity);\n              if (image->matte != MagickFalse)\n                SetPixelAlpha(q,ScaleCharToQuantum(*(p+3)));\n              p+=4;\n              q++;\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n      }\n    else\n      {\n        /*\n          Create grayscale map.\n        */\n        if (AcquireImageColormap(image,image->colors) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        /*\n          Convert SGI image to PseudoClass pixel packets.\n        */\n        if (bytes_per_pixel == 2)\n          {\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=pixels+(image->rows-y-1)*8*image->columns;\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              indexes=GetAuthenticIndexQueue(image);\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                quantum=(*p << 8);\n                quantum|=(*(p+1));\n                SetPixelIndex(indexes+x,quantum);\n                p+=8;\n                q++;\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        else\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=pixels+(image->rows-y-1)*4*image->columns;\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (PixelPacket *) NULL)\n              break;\n            indexes=GetAuthenticIndexQueue(image);\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelIndex(indexes+x,*p);\n              p+=4;\n              q++;\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        (void) SyncImage(image);\n      }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    iris_info.magic=ReadBlobMSBShort(image);\n    if (iris_info.magic == 0x01DA)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (iris_info.magic == 0x01DA);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}", "target": 1, "idx": 11111}
{"commit_id": "c40f7d74c741a907cfaeb73a7697081881c497d0", "project": "torvalds/linux", "func": "static void update_blocked_averages(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct cfs_rq *cfs_rq;\n\tconst struct sched_class *curr_class;\n\tstruct rq_flags rf;\n\tbool done = true;\n\n\trq_lock_irqsave(rq, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * Iterates the task_group tree in a bottom up fashion, see\n\t * list_add_leaf_cfs_rq() for details.\n\t */\n\tfor_each_leaf_cfs_rq(rq, cfs_rq) {\n\t\tstruct sched_entity *se;\n\n\t\t/* throttled entities do not contribute to load */\n\t\tif (throttled_hierarchy(cfs_rq))\n\t\t\tcontinue;\n\n\t\tif (update_cfs_rq_load_avg(cfs_rq_clock_task(cfs_rq), cfs_rq))\n\t\t\tupdate_tg_load_avg(cfs_rq, 0);\n\n\t\t/* Propagate pending load changes to the parent, if any: */\n\t\tse = cfs_rq->tg->se[cpu];\n\t\tif (se && !skip_blocked_update(se))\n\t\t\tupdate_load_avg(cfs_rq_of(se), se, 0);\n\n\t\t/* Don't need periodic decay once load/util_avg are null */\n\t\tif (cfs_rq_has_blocked(cfs_rq))\n\t\t\tdone = false;\n\t}\n\n\tcurr_class = rq->curr->sched_class;\n\tupdate_rt_rq_load_avg(rq_clock_task(rq), rq, curr_class == &rt_sched_class);\n\tupdate_dl_rq_load_avg(rq_clock_task(rq), rq, curr_class == &dl_sched_class);\n\tupdate_irq_load_avg(rq, 0);\n\t/* Don't need periodic decay once load/util_avg are null */\n\tif (others_have_blocked(rq))\n\t\tdone = false;\n\n#ifdef CONFIG_NO_HZ_COMMON\n\trq->last_blocked_load_update_tick = jiffies;\n\tif (done)\n\t\trq->has_blocked_load = 0;\n#endif\n\trq_unlock_irqrestore(rq, &rf);\n}", "target": 3, "idx": 11112}
{"commit_id": "5d45b69b590cabc5127282d1ade3bca1598e5f5c", "project": "wireshark", "func": "static gint\ndissect_wccp2_alternate_assignment_info(tvbuff_t *tvb, int offset, gint length,\n                                        packet_info *pinfo, proto_tree *info_tree, wccp_address_table* addr_table)\n{\n  guint16 assignment_type;\n  guint16 assignment_length;\n  proto_item *tf=NULL;\n\n  guint32 n_routers;\n  guint i;\n  proto_tree *element_tree;\n  gint new_length;\n\n\n  if (length < ALT_ASSIGNMENT_INFO_MIN_LEN)\n    return length - ALT_ASSIGNMENT_INFO_MIN_LEN;\n\n\n  assignment_type = tvb_get_ntohs(tvb, offset);\n  proto_tree_add_item(info_tree, hf_alt_assignment_info_assignment_type, tvb, offset, 2, ENC_BIG_ENDIAN);\n  EAT_AND_CHECK(2,2);\n\n  assignment_length = tvb_get_ntohs(tvb, offset);\n  tf=proto_tree_add_item(info_tree, hf_alt_assignment_info_assignment_length, tvb, offset, 2, ENC_BIG_ENDIAN);\n  EAT(2);\n\n  if (length < assignment_length)\n    expert_add_info_format(pinfo, tf, &ei_wccp_assignment_length_bad,\n                           \"Assignment length is %d but only %d remain in the packet. Ignoring this for now\",\n                           assignment_length, length);\n\n  if (length > assignment_length)  {\n    expert_add_info_format(pinfo, tf, &ei_wccp_assignment_length_bad,\n                           \"Assignment length is %d but %d remain in the packet. Assuming that the assignment length is wrong and setting it to %d.\",\n                           assignment_length, length, length);\n  }\n\n  new_length=dissect_wccp2_assignment_key_element(tvb, offset, length, pinfo,  info_tree, addr_table);\n  CHECK_LENGTH_ADVANCE_OFFSET(new_length);\n\n  n_routers = tvb_get_ntohl(tvb, offset);\n  proto_tree_add_uint(info_tree, hf_alt_assignment_info_num_routers, tvb, offset, 4, n_routers);\n  EAT(4);\n\n  for (i = 0; i < n_routers; i++) {\n    if (length < 12)\n      return length - 12*(n_routers-i);\n\n    element_tree = proto_tree_add_subtree_format(info_tree, tvb, offset, 12,\n                             ett_router_alt_assignment_element, NULL,\n                             \"Router %d Assignment Element: IP address %s\", i,\n                             decode_wccp_encoded_address(tvb, offset, pinfo, info_tree, addr_table));\n\n    dissect_wccp2_router_assignment_element(tvb, offset, length , pinfo, element_tree, addr_table);\n    EAT(12);\n  }\n\n  switch (assignment_type) {\n  case WCCP2_HASH_ASSIGNMENT_TYPE:\n    return dissect_wccp2_hash_assignment_info(tvb, offset, length,\n                                              pinfo, info_tree, addr_table);\n  case WCCP2_MASK_ASSIGNMENT_TYPE:\n    return dissect_wccp2_mask_value_set_list(tvb, offset, length,\n                                             pinfo, info_tree, addr_table);\n  case WCCP2r1_ALT_MASK_ASSIGNMENT_TYPE:\n    return dissect_wccp2_alternate_mask_value_set_list(tvb, offset, length,\n                                                       pinfo, info_tree, addr_table);\n  default:\n    return length;\n  }\n}", "target": 2, "idx": 11113}
{"commit_id": "b19488c7154b902354cb26a27f11415d7799b0b2", "project": "wayland", "func": "uint32_t\nwl_map_insert_new(struct wl_map *map, uint32_t flags, void *data)\n{\n\tunion map_entry *start, *entry;\n\tstruct wl_array *entries;\n\tuint32_t base;\n\tuint32_t count;\n\n\tif (map->side == WL_MAP_CLIENT_SIDE) {\n\t\tentries = &map->client_entries;\n\t\tbase = 0;\n\t} else {\n\t\tentries = &map->server_entries;\n\t\tbase = WL_SERVER_ID_START;\n\t}\n\n\tif (map->free_list) {\n\t\tstart = entries->data;\n\t\tentry = &start[map->free_list >> 1];\n\t\tmap->free_list = entry->next;\n\t} else {\n\t\tentry = wl_array_add(entries, sizeof *entry);\n\t\tif (!entry)\n\t\t\treturn 0;\n\t\tstart = entries->data;\n\t}\n\n\t/* wl_array only grows, so if we have too many objects at\n\t * this point there's no way to clean up. We could be more\n\t * pro-active about trying to avoid this allocation, but\n\t * it doesn't really matter because at this point there is\n\t * nothing to be done but disconnect the client and delete\n\t * the whole array either way.\n\t */\n\tcount = entry - start;\n\tif (count > WL_MAP_MAX_OBJECTS) {\n\t\t/* entry->data is freshly malloced garbage, so we'd\n\t\t * better make it a NULL so wl_map_for_each doesn't\n\t\t * dereference it later. */\n\t\tentry->data = NULL;\n\t\treturn 0;\n\t}\n\tentry->data = data;\n\tentry->next |= (flags & 0x1) << 1;\n\n\treturn count + base;\n}", "target": 1, "idx": 11114}
{"commit_id": "1cc2182bcc81e185c14837e659d12b268cb99d63", "project": "php/php-src", "func": "void base64_decode_xmlrpc(struct buffer_st *bfr, const char *source, int length)\n{\n    int i;\n    int offset = 0;\n    int endoffile;\n    int count;\n\n    buffer_new(bfr);\n\n    for (i = 0; i < 255; i++) {\n\tdtable[i] = 0x80;\n    }\n    for (i = 'A'; i <= 'Z'; i++) {\n        dtable[i] = 0 + (i - 'A');\n    }\n    for (i = 'a'; i <= 'z'; i++) {\n        dtable[i] = 26 + (i - 'a');\n    }\n    for (i = '0'; i <= '9'; i++) {\n        dtable[i] = 52 + (i - '0');\n    }\n    dtable['+'] = 62;\n    dtable['/'] = 63;\n    dtable['='] = 0;\n\n    endoffile = 0;\n\n    /*CONSTANTCONDITION*/\n    while (1) {\n\tunsigned char a[4], b[4], o[3];\n\n\tfor (i = 0; i < 4; i++) {\n\t    int c;\n\t    while (1) {\n\t      c = *(source++);\n\t      offset++;\n\t      if (offset > length) endoffile = 1;\n\t      if (isspace(c) || c == '\\n' || c == '\\r') continue;\n\t      break;\n\t    }\n\n\t    if (endoffile) {\n\t      /*\n\t\tif (i > 0) {\n                    fprintf(stderr, \"Input file incomplete.\\n\");\n\t\t    exit(1);\n\t\t}\n\t      */\n\t\treturn;\n\t    }\n\n\t    if (dtable[(unsigned char)c] & 0x80) {\n\t      /*\n\t      fprintf(stderr, \"Offset %i length %i\\n\", offset, length);\n\t      fprintf(stderr, \"character '%c:%x:%c' in input file.\\n\", c, c, dtable[c]);\n\t      exit(1);\n\t      */\n\t      i--;\n\t      continue;\n\t    }\n\t    a[i] = (unsigned char) c;\n\t    b[i] = (unsigned char) dtable[c];\n\t}\n\to[0] = (b[0] << 2) | (b[1] >> 4);\n\to[1] = (b[1] << 4) | (b[2] >> 2);\n\to[2] = (b[2] << 6) | b[3];\n        i = a[2] == '=' ? 1 : (a[3] == '=' ? 2 : 3);\n\tcount = 0;\n\twhile (count < i) {\n\t  buffer_add(bfr, o[count++]);\n\t}\n\tif (i < 3) {\n\t    return;\n\t}\n    }\n}", "target": 2, "idx": 11115}
{"commit_id": "3b006ededaf351f1723aea6c727c9edd1b1fff9b", "project": "phaag/nfdump", "func": "static void Process_ipfix_template_add(exporter_ipfix_domain_t *exporter, void *DataPtr, uint32_t size_left, FlowSource_t *fs) {\ninput_translation_t *translation_table;\nipfix_template_record_t *ipfix_template_record;\nipfix_template_elements_std_t *NextElement;\nint i;\n\n\t// a template flowset can contain multiple records ( templates )\n\twhile ( size_left ) {\n\t\tuint32_t table_id, count, size_required;\n\t\tuint32_t num_extensions = 0;\n\n\t\tif ( size_left < 4 ) {\n\t\t\tLogError(\"Process_ipfix [%u] Template size error at %s line %u\" , \n\t\t\t\texporter->info.id, __FILE__, __LINE__, strerror (errno));\n\t\t\tsize_left = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// map next record.\n\t\tipfix_template_record = (ipfix_template_record_t *)DataPtr;\n\t\tsize_left \t\t-= 4;\n\n\t\ttable_id = ntohs(ipfix_template_record->TemplateID);\n\t\tcount\t = ntohs(ipfix_template_record->FieldCount);\n\n\t\tdbg_printf(\"\\n[%u] Template ID: %u\\n\", exporter->info.id, table_id);\n\t\tdbg_printf(\"FieldCount: %u buffersize: %u\\n\", count, size_left);\n\n\t\t// prepare\n\t\t// clear helper tables\n\t\tmemset((void *)cache.common_extensions, 0,  (Max_num_extensions+1)*sizeof(uint32_t));\n\t\tmemset((void *)cache.lookup_info, 0, 65536 * sizeof(struct element_param_s));\n\t\tfor (i=1; ipfix_element_map[i].id != 0; i++ ) {\n\t\t\tuint32_t Type = ipfix_element_map[i].id;\n\t\t\tif ( ipfix_element_map[i].id == ipfix_element_map[i-1].id )\n\t\t\t\tcontinue;\n\t\t\tcache.lookup_info[Type].index   = i;\n\t\t\t// other elements cleard be memset\n\t\t}\n\t\tcache.input_order = calloc(count, sizeof(struct order_s));\n\t\tif ( !cache.input_order ) {\n\t\t\tLogError(\"Process_ipfix: Panic! malloc(): %s line %d: %s\", __FILE__, __LINE__, strerror (errno));\n\t\t\tsize_left = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcache.input_count = count;\n\n\t\t// assume all elements in template are std elements. correct this value, if we find an enterprise element\n\t\tsize_required   = 4*count;\n\t\tif ( size_left < size_required ) {\n\t\t\t// if we fail this check, this flowset must be skipped.\n\t\t\tLogError(\"Process_ipfix: [%u] Not enough data for template elements! required: %i, left: %u\", \n\t\t\t\t\texporter->info.id, size_required, size_left);\n\t\t\tdbg_printf(\"ERROR: Not enough data for template elements! required: %i, left: %u\", size_required, size_left);\n\t\t\treturn;\n\t\t}\n\n\t\t// process all elements in this record\n\t\tNextElement \t = (ipfix_template_elements_std_t *)ipfix_template_record->elements;\n\t\tfor ( i=0; i<count; i++ ) {\n\t\t\tuint16_t Type, Length;\n\t\t\tuint32_t ext_id;\n\t\t\tint Enterprise;\n\t\n\t\t\tType   = ntohs(NextElement->Type);\n\t\t\tLength = ntohs(NextElement->Length);\n\t\t\tEnterprise = Type & 0x8000 ? 1 : 0;\n\t\t\tType = Type & 0x7FFF;\n\n\t\t\text_id = MapElement(Type, Length, i);\n\n\t\t\t// do we store this extension? enabled != 0\n\t\t\t// more than 1 v9 tag may map to an extension - so count this extension once only\n\t\t\tif ( ext_id && extension_descriptor[ext_id].enabled ) {\n\t\t\t\tif ( cache.common_extensions[ext_id] == 0 ) {\n\t\t\t\t\tcache.common_extensions[ext_id] = 1;\n\t\t\t\t\tnum_extensions++;\n\t\t\t\t}\n\t\t\t} \n\t\n\t\t\tif ( Enterprise ) {\n\t\t\t\tipfix_template_elements_e_t *e = (ipfix_template_elements_e_t *)NextElement;\n\t\t\t\tsize_required += 4;\t// ad 4 for enterprise value\n\t\t\t\tif ( size_left < size_required ) {\n\t\t\t\t\tLogError(\"Process_ipfix: [%u] Not enough data for template elements! required: %i, left: %u\", \n\t\t\t\t\t\t\texporter->info.id, size_required, size_left);\n\t\t\t\t\tdbg_printf(\"ERROR: Not enough data for template elements! required: %i, left: %u\", size_required, size_left);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif ( ntohl(e->EnterpriseNumber) == IPFIX_ReverseInformationElement ) {\n\t\t\t\t\tdbg_printf(\" [%i] Enterprise: 1, Type: %u, Length %u Reverse Information Element: %u\\n\", i, Type, Length, ntohl(e->EnterpriseNumber));\n\t\t\t\t} else {\n\t\t\t\t\tdbg_printf(\" [%i] Enterprise: 1, Type: %u, Length %u EnterpriseNumber: %u\\n\", i, Type, Length, ntohl(e->EnterpriseNumber));\n\t\t\t\t}\n\t\t\t\te++;\n\t\t\t\tNextElement = (ipfix_template_elements_std_t *)e;\n\t\t\t} else {\n\t\t\t\tdbg_printf(\" [%i] Enterprise: 0, Type: %u, Length %u\\n\", i, Type, Length);\n\t\t\t\tNextElement++;\n\t\t\t}\n\t\t}\n\n\t\tdbg_printf(\"Processed: %u\\n\", size_required);\n\n\t\t// compact input order and reorder sequencer\n\t\tif ( compact_input_order() ) {\n\t\t\t// valid template with common inout fields\n\n\t\t\t// as the router IP address extension is not part announced in a template, we need to deal with it here\n\t\t\tif ( extension_descriptor[EX_ROUTER_IP_v4].enabled ) {\n\t\t\t\tif ( cache.common_extensions[EX_ROUTER_IP_v4] == 0 ) {\n\t\t\t\t\tcache.common_extensions[EX_ROUTER_IP_v4] = 1;\n\t\t\t\t\tnum_extensions++;\n\t\t\t\t}\n\t\t\t\tdbg_printf(\"Add sending router IP address (%s) => Extension: %u\\n\", \n\t\t\t\t\tfs->sa_family == PF_INET6 ? \"ipv6\" : \"ipv4\", EX_ROUTER_IP_v4);\n\t\t\t}\n\t\n\t\t\t// XXX for now, we do not store router ID in IPFIX\n\t\t\textension_descriptor[EX_ROUTER_ID].enabled = 0;\n\n/*\t\n\t\t// as the router IP address extension is not part announced in a template, we need to deal with it here\n\t\tif ( extension_descriptor[EX_ROUTER_ID].enabled ) {\n\t\t\tif ( cache.common_extensions[EX_ROUTER_ID] == 0 ) {\n\t\t\t\tcache.common_extensions[EX_ROUTER_ID] = 1;\n\t\t\t\tnum_extensions++;\n\t\t\t}\n\t\t\tdbg_printf(\"Force add router ID (engine type/ID), Extension: %u\\n\", EX_ROUTER_ID);\n\t\t}\n*/\n\t\t\t// received time \n\t\t\tif ( extension_descriptor[EX_RECEIVED].enabled ) {\n\t\t\t\tif ( cache.common_extensions[EX_RECEIVED] == 0 ) {\n\t\t\t\t\tcache.common_extensions[EX_RECEIVED] = 1;\n\t\t\t\t\tnum_extensions++;\n\t\t\t\t}\n\t\t\t\tdbg_printf(\"Force add packet received time, Extension: %u\\n\", EX_RECEIVED);\n\t\t\t}\n\n#ifdef DEVEL\n\t\t{\n\t\t\tint i;\n\t\t\tfor (i=4; extension_descriptor[i].id; i++ ) {\n\t\t\t\tif ( cache.common_extensions[i] ) {\n\t\t\t\t\tprintf(\"Enabled extension: %i\\n\", i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\n\t\n\t\t\ttranslation_table = setup_translation_table(exporter, table_id);\n\t\t\tif (translation_table->extension_map_changed ) {\n\t\t\t\t// refresh he map in the ouput buffer\n\t\t\t\tdbg_printf(\"Translation Table changed! Add extension map ID: %i\\n\", translation_table->extension_info.map->map_id);\n\t\t\t\tAddExtensionMap(fs, translation_table->extension_info.map);\n\t\t\t\ttranslation_table->extension_map_changed = 0;\n\t\t\t\tdbg_printf(\"Translation Table added! map ID: %i\\n\", translation_table->extension_info.map->map_id);\n\t\t\t}\n\t\n\t\t\tif ( !reorder_sequencer(translation_table) ) {\n\t\t\t\tLogError(\"Process_ipfix: [%u] Failed to reorder sequencer. Remove table id: %u\", \n\t\t\t\t\t\t\texporter->info.id, table_id);\n\t\t\t\tremove_translation_table(fs, exporter, table_id);\n\t\t\t}\n\t\t} else {\n\t\t\tdbg_printf(\"Template does not contain any common fields - skip\\n\");\n\t\t}\n\t\t// update size left of this flowset\n\t\tsize_left -= size_required;\n\t\tDataPtr = DataPtr + size_required+4;\t// +4 for header\n\t\tif ( size_left < 4 ) {\n\t\t\t// pading\n\t\t\tdbg_printf(\"Skip %u bytes padding\\n\", size_left);\n\t\t\tsize_left = 0;\n\t\t}\n\t\tfree(cache.input_order);\n\t\tcache.input_order = NULL;\n\t}\n\n}", "target": 2, "idx": 11116}
{"commit_id": "fc4d8f594acfd97fc750403cca734671bb623afc", "project": "gpac", "func": "GF_Err ilst_item_box_dump(GF_Box *a, FILE * trace)\n{\n\tu32 val;\n\tBool no_dump = GF_FALSE;\n\tchar *name = \"UnknownBox\";\n\tGF_ListItemBox *itune = (GF_ListItemBox *)a;\n\tswitch (itune->type) {\n\tcase GF_ISOM_BOX_TYPE_0xA9NAM:\n\t\tname = \"NameBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_0xA9CMT:\n\t\tname = \"CommentBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_0xA9DAY:\n\t\tname = \"CreatedBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_0xA9ART:\n\t\tname = \"ArtistBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_0xA9TRK:\n\t\tname = \"TrackBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_0xA9ALB:\n\t\tname = \"AlbumBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_0xA9COM:\n\t\tname = \"CompositorBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_0xA9WRT:\n\t\tname = \"WriterBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_0xA9TOO:\n\t\tname = \"ToolBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_0xA9CPY:\n\t\tname = \"CopyrightBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_0xA9DES:\n\t\tname = \"DescriptionBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_0xA9GEN:\n\tcase GF_ISOM_BOX_TYPE_GNRE:\n\t\tname = \"GenreBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_aART:\n\t\tname = \"AlbumArtistBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_PGAP:\n\t\tname = \"GapelessBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DISK:\n\t\tname = \"DiskBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_TRKN:\n\t\tname = \"TrackNumberBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_TMPO:\n\t\tname = \"TempoBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_CPIL:\n\t\tname = \"CompilationBox\";\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_COVR:\n\t\tname = \"CoverArtBox\";\n\t\tno_dump = GF_TRUE;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_iTunesSpecificInfo:\n\t\tname = \"iTunesSpecificBox\";\n\t\tno_dump = GF_TRUE;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_0xA9GRP:\n\t\tname = \"GroupBox\";\n\t\tbreak;\n\tcase GF_ISOM_ITUNE_ENCODER:\n\t\tname = \"EncoderBox\";\n\t\tbreak;\n\t}\n\tgf_isom_box_dump_start(a, name, trace);\n\n\tif (!no_dump && itune->data) {\n\t\tGF_BitStream *bs;\n\t\tswitch (itune->type) {\n\t\tcase GF_ISOM_BOX_TYPE_DISK:\n\t\tcase GF_ISOM_BOX_TYPE_TRKN:\n\t\t\tbs = gf_bs_new(itune->data->data, itune->data->dataSize, GF_BITSTREAM_READ);\n\t\t\tgf_bs_read_int(bs, 16);\n\t\t\tval = gf_bs_read_int(bs, 16);\n\t\t\tif (itune->type==GF_ISOM_BOX_TYPE_DISK) {\n\t\t\t\tgf_fprintf(trace, \" DiskNumber=\\\"%d\\\" NbDisks=\\\"%d\\\" \", val, gf_bs_read_int(bs, 16) );\n\t\t\t} else {\n\t\t\t\tgf_fprintf(trace, \" TrackNumber=\\\"%d\\\" NbTracks=\\\"%d\\\" \", val, gf_bs_read_int(bs, 16) );\n\t\t\t}\n\t\t\tgf_bs_del(bs);\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_TMPO:\n\t\t\tbs = gf_bs_new(itune->data->data, itune->data->dataSize, GF_BITSTREAM_READ);\n\t\t\tgf_fprintf(trace, \" BPM=\\\"%d\\\" \", gf_bs_read_int(bs, 16) );\n\t\t\tgf_bs_del(bs);\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_CPIL:\n\t\t\tgf_fprintf(trace, \" IsCompilation=\\\"%s\\\" \", (itune->data && itune->data->data && itune->data->data[0]) ? \"yes\" : \"no\");\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_PGAP:\n\t\t\tgf_fprintf(trace, \" IsGapeless=\\\"%s\\\" \", (itune->data && itune->data->data && itune->data->data[0]) ? \"yes\" : \"no\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (strcmp(name, \"UnknownBox\") && itune->data && itune->data->data) {\n\t\t\t\tgf_fprintf(trace, \" value=\\\"\");\n\t\t\t\tif (itune->data && itune->data->data[0]) {\n\t\t\t\t\tdump_data_string(trace, itune->data->data, itune->data->dataSize);\n\t\t\t\t} else {\n\t\t\t\t\tdump_data(trace, itune->data->data, itune->data->dataSize);\n\t\t\t\t}\n\t\t\t\tgf_fprintf(trace, \"\\\" \");\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tgf_fprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(name, a, trace);\n\treturn GF_OK;\n}", "target": 1, "idx": 11117}
{"commit_id": "9002fd07327a91f35ba6c1307e71fa6fd4409b7f", "project": "openssl", "func": "int DH_check(const DH *dh, int *ret)\n{\n#ifdef FIPS_MODULE\n    return DH_check_params(dh, ret);\n#else\n    int ok = 0, r, q_good = 0;\n    BN_CTX *ctx = NULL;\n    BIGNUM *t1 = NULL, *t2 = NULL;\n    int nid = DH_get_nid((DH *)dh);\n\n    *ret = 0;\n    if (nid != NID_undef)\n        return 1;\n\n    /* Don't do any checks at all with an excessively large modulus */\n    if (BN_num_bits(dh->params.p) > OPENSSL_DH_CHECK_MAX_MODULUS_BITS) {\n        ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_LARGE);\n        *ret = DH_MODULUS_TOO_LARGE | DH_CHECK_P_NOT_PRIME;\n        return 0;\n    }\n\n    if (!DH_check_params(dh, ret))\n        return 0;\n\n    ctx = BN_CTX_new_ex(dh->libctx);\n    if (ctx == NULL)\n        goto err;\n    BN_CTX_start(ctx);\n    t1 = BN_CTX_get(ctx);\n    t2 = BN_CTX_get(ctx);\n    if (t2 == NULL)\n        goto err;\n\n    if (dh->params.q != NULL) {\n        if (BN_ucmp(dh->params.p, dh->params.q) > 0)\n            q_good = 1;\n        else\n            *ret |= DH_CHECK_INVALID_Q_VALUE;\n    }\n\n    if (q_good) {\n        if (BN_cmp(dh->params.g, BN_value_one()) <= 0)\n            *ret |= DH_NOT_SUITABLE_GENERATOR;\n        else if (BN_cmp(dh->params.g, dh->params.p) >= 0)\n            *ret |= DH_NOT_SUITABLE_GENERATOR;\n        else {\n            /* Check g^q == 1 mod p */\n            if (!BN_mod_exp(t1, dh->params.g, dh->params.q, dh->params.p, ctx))\n                goto err;\n            if (!BN_is_one(t1))\n                *ret |= DH_NOT_SUITABLE_GENERATOR;\n        }\n        r = BN_check_prime(dh->params.q, ctx, NULL);\n        if (r < 0)\n            goto err;\n        if (!r)\n            *ret |= DH_CHECK_Q_NOT_PRIME;\n        /* Check p == 1 mod q  i.e. q divides p - 1 */\n        if (!BN_div(t1, t2, dh->params.p, dh->params.q, ctx))\n            goto err;\n        if (!BN_is_one(t2))\n            *ret |= DH_CHECK_INVALID_Q_VALUE;\n        if (dh->params.j != NULL\n            && BN_cmp(dh->params.j, t1))\n            *ret |= DH_CHECK_INVALID_J_VALUE;\n    }\n\n    r = BN_check_prime(dh->params.p, ctx, NULL);\n    if (r < 0)\n        goto err;\n    if (!r)\n        *ret |= DH_CHECK_P_NOT_PRIME;\n    else if (dh->params.q == NULL) {\n        if (!BN_rshift1(t1, dh->params.p))\n            goto err;\n        r = BN_check_prime(t1, ctx, NULL);\n        if (r < 0)\n            goto err;\n        if (!r)\n            *ret |= DH_CHECK_P_NOT_SAFE_PRIME;\n    }\n    ok = 1;\n err:\n    BN_CTX_end(ctx);\n    BN_CTX_free(ctx);\n    return ok;\n#endif /* FIPS_MODULE */\n}", "target": 1, "idx": 11118}
{"commit_id": "1bc78d795cd5cad5525498658f414a11ea0a7e9c", "project": "the-tcpdump-group/tcpdump", "func": "static void\nprint_attr_string(netdissect_options *ndo,\n                  register const u_char *data, u_int length, u_short attr_code)\n{\n   register u_int i;\n\n   ND_TCHECK2(data[0],length);\n\n   switch(attr_code)\n   {\n      case TUNNEL_PASS:\n           if (length < 3)\n              goto trunc;\n           if (*data && (*data <=0x1F) )\n              ND_PRINT((ndo, \"Tag[%u] \", *data));\n           else\n              ND_PRINT((ndo, \"Tag[Unused] \"));\n           data++;\n           length--;\n           ND_PRINT((ndo, \"Salt %u \", EXTRACT_16BITS(data)));\n           data+=2;\n           length-=2;\n        break;\n      case TUNNEL_CLIENT_END:\n      case TUNNEL_SERVER_END:\n      case TUNNEL_PRIV_GROUP:\n      case TUNNEL_ASSIGN_ID:\n      case TUNNEL_CLIENT_AUTH:\n      case TUNNEL_SERVER_AUTH:\n           if (*data <= 0x1F)\n           {\n              if (length < 1)\n                 goto trunc;\n              if (*data)\n                ND_PRINT((ndo, \"Tag[%u] \", *data));\n              else\n                ND_PRINT((ndo, \"Tag[Unused] \"));\n              data++;\n              length--;\n           }\n        break;\n      case EGRESS_VLAN_NAME:\n           if (length < 1)\n              goto trunc;\n           ND_PRINT((ndo, \"%s (0x%02x) \",\n                  tok2str(rfc4675_tagged,\"Unknown tag\",*data),\n                  *data));\n           data++;\n           length--;\n        break;\n   }\n\n   for (i=0; i < length && *data; i++, data++)\n       ND_PRINT((ndo, \"%c\", (*data < 32 || *data > 126) ? '.' : *data));\n\n   return;\n\n   trunc:\n      ND_PRINT((ndo, \"%s\", tstr));\n}", "target": 3, "idx": 11119}
{"commit_id": "406ae7da30fb5fadacf0d646a4dc4ac0513a2dec", "project": "contiki-ng", "func": "db_result_t\nstorage_put_index(index_t *index)\n{\n  char filename[INDEX_NAME_LENGTH + 1];\n  int fd;\n  int r;\n  struct index_record record;\n  db_result_t result;\n\n  merge_strings(filename, index->rel->name, INDEX_NAME_SUFFIX);\n\n  fd = cfs_open(filename, CFS_WRITE | CFS_APPEND);\n  if(fd < 0) {\n    return DB_STORAGE_ERROR;\n  }\n\n  strcpy(record.attribute_name, index->attr->name);\n  memcpy(record.file_name, index->descriptor_file, sizeof(record.file_name));\n  record.type = index->type;\n\n  result = DB_OK;\n  r = cfs_write(fd, &record, sizeof(record));\n  if(r < sizeof(record)) {\n    result = DB_STORAGE_ERROR;\n  } else {\n    PRINTF(\"DB: Wrote an index record for %s.%s, type %d\\n\",\n      index->rel->name, index->attr->name, record.type);\n  }\n\n  cfs_close(fd);\n\n  return result;\n}", "target": 3, "idx": 11120}
{"commit_id": "ba919adb74ac368bf76b150a00347ded78b572dd", "project": "radareorg/radare2", "func": "static void cmd_anal_ucall_ref(RCore *core, ut64 addr) {\n\tRAnalFunction *fcn = r_anal_get_function_at (core->anal, addr);\n\tif (fcn) {\n\t\tr_cons_printf (\" ; %s\", fcn->name);\n\t} else {\n\t\tr_cons_printf (\" ; 0x%\" PFMT64x, addr);\n\t}\n}", "target": 3, "idx": 11121}
{"commit_id": "660ce5a89eb6766834bdc303d2ab3902aef99d3d", "project": "tensorflow", "func": "void Compute(OpKernelContext* context) override {\n    Tensor encoded_t = context->input(0);\n    OP_REQUIRES(\n        context, encoded_t.flat<Variant>().size() > 0,\n        errors::InvalidArgument(\"Input `encoded` must not be an empty variant \"\n                                \"tensor, but got \",\n                                encoded_t.DebugString()));\n    auto* encoded = encoded_t.flat<Variant>()(0).get<CompositeTensorVariant>();\n\n    // Check that the encoded TypeSpec is compatible with the expected TypeSpec.\n    // For now, we just check that the class matches.\n    //\n    // TODO(b/173744905): Update this to do a generic compatibility check. This\n    // would require replacing the current design, where Python subclasses of\n    // TypeSpec can override is_compatible, with a design where compatibility\n    // can be deterministically determined from the metadata.\n    auto expected_class = metadata_.type_spec_proto().type_spec_class();\n    auto actual_class = encoded->metadata().type_spec_proto().type_spec_class();\n    OP_REQUIRES(\n        context, expected_class == actual_class,\n        errors::InvalidArgument(\n            \"Expected a \", TypeSpecProto::TypeSpecClass_Name(expected_class),\n            \" (based on `type_spec`), but `encoded` contains a \",\n            TypeSpecProto::TypeSpecClass_Name(actual_class)));\n\n    // Extract the component tensors.\n    OpOutputList components;\n    OP_REQUIRES_OK(context, context->output_list(\"components\", &components));\n    int num_components = encoded->flat_components().size();\n\n    OP_REQUIRES(context, component_dtypes_.size() == num_components,\n                errors::InvalidArgument(\"Encoded value has \", num_components,\n                                        \" tensor components; expected \",\n                                        component_dtypes_.size(),\n                                        \" components based on type_spec\"));\n\n    for (int i = 0; i < component_dtypes_.size(); i++) {\n      const Tensor& component = encoded->flat_components()[i];\n      OP_REQUIRES(context, component_dtypes_[i] == component.dtype(),\n                  errors::InvalidArgument(\"Tensor component \", i, \" had dtype \",\n                                          DataType_Name(component.dtype()),\n                                          \"; expected dtype \",\n                                          DataType_Name(component_dtypes_[i])));\n      components.set(i, component);\n    }\n  }", "target": 1, "idx": 11122}
{"commit_id": "207cde1667d8c799a197b78ca8a5a14de8d5ca1e", "project": "esphome", "func": "void set_auth_username(std::string auth_username) { credentials_.username = std::move(auth_username); }", "target": 2, "idx": 11123}
{"commit_id": "a83773682e856ad6529ba6db8d1792e6d515d7f1", "project": "Cisco-Talos/clamav", "func": "int lzxd_decompress(struct lzxd_stream *lzx, off_t out_bytes) {\n  /* bitstream and huffman reading variables */\n  register unsigned int bit_buffer;\n  register int bits_left, i=0;\n  unsigned char *i_ptr, *i_end;\n  register unsigned short sym;\n\n  int match_length, length_footer, extra, verbatim_bits, bytes_todo;\n  int this_run, main_element, aligned_bits, j;\n  unsigned char *window, *runsrc, *rundest, buf[12];\n  unsigned int frame_size=0, end_frame, match_offset, window_posn;\n  unsigned int R0, R1, R2;\n\n  /* easy answers */\n  if (!lzx || (out_bytes < 0)) return MSPACK_ERR_ARGS;\n  if (lzx->error) return lzx->error;\n\n  /* flush out any stored-up bytes before we begin */\n  i = lzx->o_end - lzx->o_ptr;\n  if ((off_t) i > out_bytes) i = (int) out_bytes;\n  if (i) {\n    if (lzx->sys->write(lzx->output, lzx->o_ptr, i) != i) {\n      return lzx->error = MSPACK_ERR_WRITE;\n    }\n    lzx->o_ptr  += i;\n    lzx->offset += i;\n    out_bytes   -= i;\n  }\n  if (out_bytes == 0) return MSPACK_ERR_OK;\n\n  /* restore local state */\n  RESTORE_BITS;\n  window = lzx->window;\n  window_posn = lzx->window_posn;\n  R0 = lzx->R0;\n  R1 = lzx->R1;\n  R2 = lzx->R2;\n\n  end_frame = (unsigned int)((lzx->offset + out_bytes) / LZX_FRAME_SIZE) + 1;\n\n  while (lzx->frame < end_frame) {\n    /* have we reached the reset interval? (if there is one?) */\n    if (lzx->reset_interval && ((lzx->frame % lzx->reset_interval) == 0)) {\n      if (lzx->block_remaining) {\n\tD((\"%d bytes remaining at reset interval\", lzx->block_remaining))\n\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n      }\n\n      /* re-read the intel header and reset the huffman lengths */\n      lzxd_reset_state(lzx);\n      R0 = lzx->R0;\n      R1 = lzx->R1;\n      R2 = lzx->R2;\n    }\n\n    /* LZX DELTA format has chunk_size, not present in LZX format */\n    if (lzx->is_delta) {\n      ENSURE_BITS(16);\n      REMOVE_BITS(16);\n    }\n\n    /* read header if necessary */\n    if (!lzx->header_read) {\n      /* read 1 bit. if bit=0, intel filesize = 0.\n       * if bit=1, read intel filesize (32 bits) */\n      j = 0; READ_BITS(i, 1); if (i) { READ_BITS(i, 16); READ_BITS(j, 16); }\n      lzx->intel_filesize = (i << 16) | j;\n      lzx->header_read = 1;\n    } \n\n    /* calculate size of frame: all frames are 32k except the final frame\n     * which is 32kb or less. this can only be calculated when lzx->length\n     * has been filled in. */\n    frame_size = LZX_FRAME_SIZE;\n    if (lzx->length && (lzx->length - lzx->offset) < (off_t)frame_size) {\n      frame_size = lzx->length - lzx->offset;\n    }\n\n    /* decode until one more frame is available */\n    bytes_todo = lzx->frame_posn + frame_size - window_posn;\n    while (bytes_todo > 0) {\n      /* initialise new block, if one is needed */\n      if (lzx->block_remaining == 0) {\n\t/* realign if previous block was an odd-sized UNCOMPRESSED block */\n\tif ((lzx->block_type == LZX_BLOCKTYPE_UNCOMPRESSED) &&\n\t    (lzx->block_length & 1))\n\t{\n\t  READ_IF_NEEDED;\n\t  i_ptr++;\n\t}\n\n\t/* read block type (3 bits) and block length (24 bits) */\n\tREAD_BITS(lzx->block_type, 3);\n\tREAD_BITS(i, 16); READ_BITS(j, 8);\n\tlzx->block_remaining = lzx->block_length = (i << 8) | j;\n\t/*D((\"new block t%d len %u\", lzx->block_type, lzx->block_length))*/\n\n\t/* read individual block headers */\n\tswitch (lzx->block_type) {\n\tcase LZX_BLOCKTYPE_ALIGNED:\n\t  /* read lengths of and build aligned huffman decoding tree */\n\t  for (i = 0; i < 8; i++) { READ_BITS(j, 3); lzx->ALIGNED_len[i] = j; }\n\t  BUILD_TABLE(ALIGNED);\n\t  /* no break -- rest of aligned header is same as verbatim */\n\tcase LZX_BLOCKTYPE_VERBATIM:\n\t  /* read lengths of and build main huffman decoding tree */\n\t  READ_LENGTHS(MAINTREE, 0, 256);\n\t  READ_LENGTHS(MAINTREE, 256, LZX_NUM_CHARS + lzx->num_offsets);\n\t  BUILD_TABLE(MAINTREE);\n\t  /* if the literal 0xE8 is anywhere in the block... */\n\t  if (lzx->MAINTREE_len[0xE8] != 0) lzx->intel_started = 1;\n\t  /* read lengths of and build lengths huffman decoding tree */\n\t  READ_LENGTHS(LENGTH, 0, LZX_NUM_SECONDARY_LENGTHS);\n\t  BUILD_TABLE_MAYBE_EMPTY(LENGTH);\n\t  break;\n\n\tcase LZX_BLOCKTYPE_UNCOMPRESSED:\n\t  /* because we can't assume otherwise */\n\t  lzx->intel_started = 1;\n\n\t  /* read 1-16 (not 0-15) bits to align to bytes */\n\t  if (bits_left == 0) ENSURE_BITS(16);\n\t  bits_left = 0; bit_buffer = 0;\n\n\t  /* read 12 bytes of stored R0 / R1 / R2 values */\n\t  for (rundest = &buf[0], i = 0; i < 12; i++) {\n\t    READ_IF_NEEDED;\n\t    *rundest++ = *i_ptr++;\n\t  }\n\t  R0 = buf[0] | (buf[1] << 8) | (buf[2]  << 16) | (buf[3]  << 24);\n\t  R1 = buf[4] | (buf[5] << 8) | (buf[6]  << 16) | (buf[7]  << 24);\n\t  R2 = buf[8] | (buf[9] << 8) | (buf[10] << 16) | (buf[11] << 24);\n\t  break;\n\n\tdefault:\n\t  D((\"bad block type\"))\n\t  return lzx->error = MSPACK_ERR_DECRUNCH;\n\t}\n      }\n\n      /* decode more of the block:\n       * run = min(what's available, what's needed) */\n      this_run = lzx->block_remaining;\n      if (this_run > bytes_todo) this_run = bytes_todo;\n\n      /* assume we decode exactly this_run bytes, for now */\n      bytes_todo           -= this_run;\n      lzx->block_remaining -= this_run;\n\n      /* decode at least this_run bytes */\n      switch (lzx->block_type) {\n      case LZX_BLOCKTYPE_VERBATIM:\n\twhile (this_run > 0) {\n\t  READ_HUFFSYM(MAINTREE, main_element);\n\t  if (main_element < LZX_NUM_CHARS) {\n\t    /* literal: 0 to LZX_NUM_CHARS-1 */\n\t    window[window_posn++] = main_element;\n\t    this_run--;\n\t  }\n\t  else {\n\t    /* match: LZX_NUM_CHARS + ((slot<<3) | length_header (3 bits)) */\n\t    main_element -= LZX_NUM_CHARS;\n\n\t    /* get match length */\n\t    match_length = main_element & LZX_NUM_PRIMARY_LENGTHS;\n\t    if (match_length == LZX_NUM_PRIMARY_LENGTHS) {\n\t      if (lzx->LENGTH_empty) {\n                D((\"LENGTH symbol needed but tree is empty\"))\n                return lzx->error = MSPACK_ERR_DECRUNCH;\n              }\n\t      READ_HUFFSYM(LENGTH, length_footer);\n\t      match_length += length_footer;\n\t    }\n\t    match_length += LZX_MIN_MATCH;\n\n\t    /* get match offset */\n\t    switch ((match_offset = (main_element >> 3))) {\n\t    case 0: match_offset = R0;                                  break;\n\t    case 1: match_offset = R1; R1=R0;        R0 = match_offset; break;\n\t    case 2: match_offset = R2; R2=R0;        R0 = match_offset; break;\n\t    case 3: match_offset = 1;  R2=R1; R1=R0; R0 = match_offset; break;\n\t    default:\n\t      extra = (match_offset >= 36) ? 17 : extra_bits[match_offset];\n\t      READ_BITS(verbatim_bits, extra);\n\t      match_offset = position_base[match_offset] - 2 + verbatim_bits;\n\t      R2 = R1; R1 = R0; R0 = match_offset;\n\t    }\n\n\t    /* LZX DELTA uses max match length to signal even longer match */\n\t    if (match_length == LZX_MAX_MATCH && lzx->is_delta) {\n\t\tint extra_len = 0;\n\t\tENSURE_BITS(3); /* 4 entry huffman tree */\n\t\tif (PEEK_BITS(1) == 0) {\n\t\t    REMOVE_BITS(1); /* '0' -> 8 extra length bits */\n\t\t    READ_BITS(extra_len, 8);\n\t\t}\n\t\telse if (PEEK_BITS(2) == 2) {\n\t\t    REMOVE_BITS(2); /* '10' -> 10 extra length bits + 0x100 */\n\t\t    READ_BITS(extra_len, 10);\n\t\t    extra_len += 0x100;\n\t\t}\n\t\telse if (PEEK_BITS(3) == 6) {\n\t\t    REMOVE_BITS(3); /* '110' -> 12 extra length bits + 0x500 */\n\t\t    READ_BITS(extra_len, 12);\n\t\t    extra_len += 0x500;\n\t\t}\n\t\telse {\n\t\t    REMOVE_BITS(3); /* '111' -> 15 extra length bits */\n\t\t    READ_BITS(extra_len, 15);\n\t\t}\n\t\tmatch_length += extra_len;\n\t    }\n\n\t    if ((window_posn + match_length) > lzx->window_size) {\n\t      D((\"match ran over window wrap\"))\n\t      return lzx->error = MSPACK_ERR_DECRUNCH;\n\t    }\n\t    \n\t    /* copy match */\n\t    rundest = &window[window_posn];\n\t    i = match_length;\n\t    /* does match offset wrap the window? */\n\t    if (match_offset > window_posn) {\n\t      if (match_offset > lzx->offset &&\n\t\t  (match_offset - window_posn) > lzx->ref_data_size)\n\t      {\n\t\tD((\"match offset beyond LZX stream\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      /* j = length from match offset to end of window */\n\t      j = match_offset - window_posn;\n\t      if (j > (int) lzx->window_size) {\n\t\tD((\"match offset beyond window boundaries\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      runsrc = &window[lzx->window_size - j];\n\t      if (j < i) {\n\t\t/* if match goes over the window edge, do two copy runs */\n\t\ti -= j; while (j-- > 0) *rundest++ = *runsrc++;\n\t\trunsrc = window;\n\t      }\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\t    else {\n\t      runsrc = rundest - match_offset;\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\n\t    this_run    -= match_length;\n\t    window_posn += match_length;\n\t  }\n\t} /* while (this_run > 0) */\n\tbreak;\n\n      case LZX_BLOCKTYPE_ALIGNED:\n\twhile (this_run > 0) {\n\t  READ_HUFFSYM(MAINTREE, main_element);\n\t  if (main_element < LZX_NUM_CHARS) {\n\t    /* literal: 0 to LZX_NUM_CHARS-1 */\n\t    window[window_posn++] = main_element;\n\t    this_run--;\n\t  }\n\t  else {\n\t    /* match: LZX_NUM_CHARS + ((slot<<3) | length_header (3 bits)) */\n\t    main_element -= LZX_NUM_CHARS;\n\n\t    /* get match length */\n\t    match_length = main_element & LZX_NUM_PRIMARY_LENGTHS;\n\t    if (match_length == LZX_NUM_PRIMARY_LENGTHS) {\n              if (lzx->LENGTH_empty) {\n                D((\"LENGTH symbol needed but tree is empty\"))\n                return lzx->error = MSPACK_ERR_DECRUNCH;\n              } \n\t      READ_HUFFSYM(LENGTH, length_footer);\n\t      match_length += length_footer;\n\t    }\n\t    match_length += LZX_MIN_MATCH;\n\n\t    /* get match offset */\n\t    switch ((match_offset = (main_element >> 3))) {\n\t    case 0: match_offset = R0;                             break;\n\t    case 1: match_offset = R1; R1 = R0; R0 = match_offset; break;\n\t    case 2: match_offset = R2; R2 = R0; R0 = match_offset; break;\n\t    default:\n\t      extra = (match_offset >= 36) ? 17 : extra_bits[match_offset];\n\t      match_offset = position_base[match_offset] - 2;\n\t      if (extra > 3) {\n\t\t/* verbatim and aligned bits */\n\t\textra -= 3;\n\t\tREAD_BITS(verbatim_bits, extra);\n\t\tmatch_offset += (verbatim_bits << 3);\n\t\tREAD_HUFFSYM(ALIGNED, aligned_bits);\n\t\tmatch_offset += aligned_bits;\n\t      }\n\t      else if (extra == 3) {\n\t\t/* aligned bits only */\n\t\tREAD_HUFFSYM(ALIGNED, aligned_bits);\n\t\tmatch_offset += aligned_bits;\n\t      }\n\t      else if (extra > 0) { /* extra==1, extra==2 */\n\t\t/* verbatim bits only */\n\t\tREAD_BITS(verbatim_bits, extra);\n\t\tmatch_offset += verbatim_bits;\n\t      }\n\t      else /* extra == 0 */ {\n\t\t/* ??? not defined in LZX specification! */\n\t\tmatch_offset = 1;\n\t      }\n\t      /* update repeated offset LRU queue */\n\t      R2 = R1; R1 = R0; R0 = match_offset;\n\t    }\n\n\t    /* LZX DELTA uses max match length to signal even longer match */\n\t    if (match_length == LZX_MAX_MATCH && lzx->is_delta) {\n\t\tint extra_len = 0;\n\t\tENSURE_BITS(3); /* 4 entry huffman tree */\n\t\tif (PEEK_BITS(1) == 0) {\n\t\t    REMOVE_BITS(1); /* '0' -> 8 extra length bits */\n\t\t    READ_BITS(extra_len, 8);\n\t\t}\n\t\telse if (PEEK_BITS(2) == 2) {\n\t\t    REMOVE_BITS(2); /* '10' -> 10 extra length bits + 0x100 */\n\t\t    READ_BITS(extra_len, 10);\n\t\t    extra_len += 0x100;\n\t\t}\n\t\telse if (PEEK_BITS(3) == 6) {\n\t\t    REMOVE_BITS(3); /* '110' -> 12 extra length bits + 0x500 */\n\t\t    READ_BITS(extra_len, 12);\n\t\t    extra_len += 0x500;\n\t\t}\n\t\telse {\n\t\t    REMOVE_BITS(3); /* '111' -> 15 extra length bits */\n\t\t    READ_BITS(extra_len, 15);\n\t\t}\n\t\tmatch_length += extra_len;\n\t    }\n\n\t    if ((window_posn + match_length) > lzx->window_size) {\n\t      D((\"match ran over window wrap\"))\n\t      return lzx->error = MSPACK_ERR_DECRUNCH;\n\t    }\n\n\t    /* copy match */\n\t    rundest = &window[window_posn];\n\t    i = match_length;\n\t    /* does match offset wrap the window? */\n\t    if (match_offset > window_posn) {\n\t      if (match_offset > lzx->offset &&\n\t\t  (match_offset - window_posn) > lzx->ref_data_size)\n\t      {\n\t\tD((\"match offset beyond LZX stream\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      /* j = length from match offset to end of window */\n\t      j = match_offset - window_posn;\n\t      if (j > (int) lzx->window_size) {\n\t\tD((\"match offset beyond window boundaries\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      runsrc = &window[lzx->window_size - j];\n\t      if (j < i) {\n\t\t/* if match goes over the window edge, do two copy runs */\n\t\ti -= j; while (j-- > 0) *rundest++ = *runsrc++;\n\t\trunsrc = window;\n\t      }\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\t    else {\n\t      runsrc = rundest - match_offset;\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\n\t    this_run    -= match_length;\n\t    window_posn += match_length;\n\t  }\n\t} /* while (this_run > 0) */\n\tbreak;\n\n      case LZX_BLOCKTYPE_UNCOMPRESSED:\n\t/* as this_run is limited not to wrap a frame, this also means it\n\t * won't wrap the window (as the window is a multiple of 32k) */\n        if (window_posn + this_run > lzx->window_size) {\n                D((\"match ran over window boundary\"))\n                return lzx->error = MSPACK_ERR_DECRUNCH;\n        }\n\trundest = &window[window_posn];\n\twindow_posn += this_run;\n\n\twhile (this_run > 0) {\n\t  if ((i = i_end - i_ptr) == 0) {\n\t    READ_IF_NEEDED;\n\t  }\n\t  else {\n\t    if (i > this_run) i = this_run;\n\t    lzx->sys->copy(i_ptr, rundest, (size_t) i);\n\t    rundest  += i;\n\t    i_ptr    += i;\n\t    this_run -= i;\n\t  }\n\t}\n\tbreak;\n\n      default:\n\treturn lzx->error = MSPACK_ERR_DECRUNCH; /* might as well */\n      }\n\n      /* did the final match overrun our desired this_run length? */\n      if (this_run < 0) {\n\tif ((unsigned int)(-this_run) > lzx->block_remaining) {\n\t  D((\"overrun went past end of block by %d (%d remaining)\",\n\t     -this_run, lzx->block_remaining ))\n\t  return lzx->error = MSPACK_ERR_DECRUNCH;\n\t}\n\tlzx->block_remaining -= -this_run;\n      }\n    } /* while (bytes_todo > 0) */\n\n    /* streams don't extend over frame boundaries */\n    if ((window_posn - lzx->frame_posn) != frame_size) {\n      D((\"decode beyond output frame limits! %d != %d\",\n\t window_posn - lzx->frame_posn, frame_size))\n      return lzx->error = MSPACK_ERR_DECRUNCH;\n    }\n\n    /* re-align input bitstream */\n    if (bits_left > 0) ENSURE_BITS(16);\n    if (bits_left & 15) REMOVE_BITS(bits_left & 15);\n\n    /* check that we've used all of the previous frame first */\n    if (lzx->o_ptr != lzx->o_end) {\n      D((\"%ld avail bytes, new %d frame\",\n          (long)(lzx->o_end - lzx->o_ptr), frame_size))\n      return lzx->error = MSPACK_ERR_DECRUNCH;\n    }\n\n    /* does this intel block _really_ need decoding? */\n    if (lzx->intel_started && lzx->intel_filesize &&\n\t(lzx->frame <= 32768) && (frame_size > 10))\n    {\n      unsigned char *data    = &lzx->e8_buf[0];\n      unsigned char *dataend = &lzx->e8_buf[frame_size - 10];\n      signed int curpos      = lzx->intel_curpos;\n      signed int filesize    = lzx->intel_filesize;\n      signed int abs_off, rel_off;\n\n      /* copy e8 block to the e8 buffer and tweak if needed */\n      lzx->o_ptr = data;\n      lzx->sys->copy(&lzx->window[lzx->frame_posn], data, frame_size);\n\n      while (data < dataend) {\n\tif (*data++ != 0xE8) { curpos++; continue; }\n\tabs_off = data[0] | (data[1]<<8) | (data[2]<<16) | (data[3]<<24);\n\tif ((abs_off >= -curpos) && (abs_off < filesize)) {\n\t  rel_off = (abs_off >= 0) ? abs_off - curpos : abs_off + filesize;\n\t  data[0] = (unsigned char) rel_off;\n\t  data[1] = (unsigned char) (rel_off >> 8);\n\t  data[2] = (unsigned char) (rel_off >> 16);\n\t  data[3] = (unsigned char) (rel_off >> 24);\n\t}\n\tdata += 4;\n\tcurpos += 5;\n      }\n      lzx->intel_curpos += frame_size;\n    }\n    else {\n      lzx->o_ptr = &lzx->window[lzx->frame_posn];\n      if (lzx->intel_filesize) lzx->intel_curpos += frame_size;\n    }\n    lzx->o_end = &lzx->o_ptr[frame_size];\n\n    /* write a frame */\n    i = (out_bytes < (off_t)frame_size) ? (unsigned int)out_bytes : frame_size;\n    if (lzx->sys->write(lzx->output, lzx->o_ptr, i) != i) {\n      return lzx->error = MSPACK_ERR_WRITE;\n    }\n    lzx->o_ptr  += i;\n    lzx->offset += i;\n    out_bytes   -= i;\n\n    /* advance frame start position */\n    lzx->frame_posn += frame_size;\n    lzx->frame++;\n\n    /* wrap window / frame position pointers */\n    if (window_posn == lzx->window_size)     window_posn = 0;\n    if (lzx->frame_posn == lzx->window_size) lzx->frame_posn = 0;\n\n  } /* while (lzx->frame < end_frame) */\n\n  if (out_bytes) {\n    D((\"bytes left to output\"))\n    return lzx->error = MSPACK_ERR_DECRUNCH;\n  }\n\n  /* store local state */\n  STORE_BITS;\n  lzx->window_posn = window_posn;\n  lzx->R0 = R0;\n  lzx->R1 = R1;\n  lzx->R2 = R2;\n\n  return MSPACK_ERR_OK;\n}", "target": 2, "idx": 11124}
{"commit_id": "f1ae01d745200a258cdf62622f71754c37cb6c30", "project": "gpac", "func": "static s32 svc_parse_slice(GF_BitStream *bs, AVCState *avc, AVCSliceInfo *si)\n{\n\ts32 pps_id;\n\n\t/*s->current_picture.reference= h->nal_ref_idc != 0;*/\n\tgf_bs_read_ue_log(bs, \"first_mb_in_slice\");\n\tsi->slice_type = gf_bs_read_ue_log(bs, \"slice_type\");\n\tif (si->slice_type > 9) return -1;\n\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\tif ((pps_id<0) || (pps_id > 255))\n\t\treturn -1;\n\tsi->pps = &avc->pps[pps_id];\n\tsi->pps->id = pps_id;\n\tif (!si->pps->slice_group_count)\n\t\treturn -2;\n\tsi->sps = &avc->sps[si->pps->sps_id + GF_SVC_SSPS_ID_SHIFT];\n\tif (!si->sps->log2_max_frame_num)\n\t\treturn -2;\n\n\tsi->frame_num = gf_bs_read_int_log(bs, si->sps->log2_max_frame_num, \"frame_num\");\n\n\tsi->field_pic_flag = 0;\n\tif (si->sps->frame_mbs_only_flag) {\n\t\t/*s->picture_structure= PICT_FRAME;*/\n\t}\n\telse {\n\t\tsi->field_pic_flag = gf_bs_read_int_log(bs, 1, \"field_pic_flag\");\n\t\tif (si->field_pic_flag) si->bottom_field_flag = gf_bs_read_int_log(bs, 1, \"bottom_field_flag\");\n\t}\n\tif (si->nal_unit_type == GF_AVC_NALU_IDR_SLICE || si->NalHeader.idr_pic_flag)\n\t\tsi->idr_pic_id = gf_bs_read_ue_log(bs, \"idr_pic_id\");\n\n\tif (si->sps->poc_type == 0) {\n\t\tsi->poc_lsb = gf_bs_read_int_log(bs, si->sps->log2_max_poc_lsb, \"poc_lsb\");\n\t\tif (si->pps->pic_order_present && !si->field_pic_flag) {\n\t\t\tsi->delta_poc_bottom = gf_bs_read_se_log(bs, \"delta_poc_bottom\");\n\t\t}\n\t}\n\telse if ((si->sps->poc_type == 1) && !si->sps->delta_pic_order_always_zero_flag) {\n\t\tsi->delta_poc[0] = gf_bs_read_se_log(bs, \"delta_poc0\");\n\t\tif ((si->pps->pic_order_present == 1) && !si->field_pic_flag)\n\t\t\tsi->delta_poc[1] = gf_bs_read_se_log(bs, \"delta_poc1\");\n\t}\n\tif (si->pps->redundant_pic_cnt_present) {\n\t\tsi->redundant_pic_cnt = gf_bs_read_ue_log(bs, \"redundant_pic_cnt\");\n\t}\n\treturn 0;\n}", "target": 2, "idx": 11125}
{"commit_id": "9476ce1dd37d3c3218d5640b74c34c65e5f4efe5", "project": "openbsd/src", "func": "static void\nprocess_add_smartcard_key(SocketEntry *e)\n{\n\tchar *provider = NULL, *pin, canonical_provider[PATH_MAX];\n\tint r, i, version, count = 0, success = 0, confirm = 0;\n\tu_int seconds;\n\ttime_t death = 0;\n\tu_char type;\n\tstruct sshkey **keys = NULL, *k;\n\tIdentity *id;\n\tIdtab *tab;\n\n\tif ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\twhile (sshbuf_len(e->request)) {\n\t\tif ((r = sshbuf_get_u8(e->request, &type)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tswitch (type) {\n\t\tcase SSH_AGENT_CONSTRAIN_LIFETIME:\n\t\t\tif ((r = sshbuf_get_u32(e->request, &seconds)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tdeath = monotime() + seconds;\n\t\t\tbreak;\n\t\tcase SSH_AGENT_CONSTRAIN_CONFIRM:\n\t\t\tconfirm = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"process_add_smartcard_key: \"\n\t\t\t    \"Unknown constraint type %d\", type);\n\t\t\tgoto send;\n\t\t}\n\t}\n\tif (realpath(provider, canonical_provider) == NULL) {\n\t\tverbose(\"failed PKCS#11 add of \\\"%.100s\\\": realpath: %s\",\n\t\t    provider, strerror(errno));\n\t\tgoto send;\n\t}\n\tif (match_pattern_list(canonical_provider, pkcs11_whitelist, 0) != 1) {\n\t\tverbose(\"refusing PKCS#11 add of \\\"%.100s\\\": \"\n\t\t    \"provider not whitelisted\", canonical_provider);\n\t\tgoto send;\n\t}\n\tdebug(\"%s: add %.100s\", __func__, canonical_provider);\n\tif (lifetime && !death)\n\t\tdeath = monotime() + lifetime;\n\n\tcount = pkcs11_add_provider(canonical_provider, pin, &keys);\n\tfor (i = 0; i < count; i++) {\n\t\tk = keys[i];\n\t\tversion = k->type == KEY_RSA1 ? 1 : 2;\n\t\ttab = idtab_lookup(version);\n\t\tif (lookup_identity(k, version) == NULL) {\n\t\t\tid = xcalloc(1, sizeof(Identity));\n\t\t\tid->key = k;\n\t\t\tid->provider = xstrdup(canonical_provider);\n\t\t\tid->comment = xstrdup(canonical_provider); /* XXX */\n\t\t\tid->death = death;\n\t\t\tid->confirm = confirm;\n\t\t\tTAILQ_INSERT_TAIL(&tab->idlist, id, next);\n\t\t\ttab->nentries++;\n\t\t\tsuccess = 1;\n\t\t} else {\n\t\t\tsshkey_free(k);\n\t\t}\n\t\tkeys[i] = NULL;\n\t}\nsend:\n\tfree(pin);\n\tfree(provider);\n\tfree(keys);\n\tsend_status(e, success);\n}", "target": 2, "idx": 11126}
{"commit_id": "8284008aa8230a92ba08d547864353d3290e9bf9", "project": "poppler", "func": "Gfx::Gfx(XRef *xrefA, OutputDev *outA, int pageNum, Dict *resDict, Catalog *catalogA,\n\t double hDPI, double vDPI, PDFRectangle *box,\n\t PDFRectangle *cropBox, int rotate,\n\t GBool (*abortCheckCbkA)(void *data),\n\t void *abortCheckCbkDataA)\n#ifdef USE_CMS\n : iccColorSpaceCache(5)\n#endif\n{\n  int i;\n\n  xref = xrefA;\n  catalog = catalogA;\n  subPage = gFalse;\n  printCommands = globalParams->getPrintCommands();\n  profileCommands = globalParams->getProfileCommands();\n  textHaveCSPattern = gFalse;\n  drawText = gFalse;\n  maskHaveCSPattern = gFalse;\n  mcStack = NULL;\n\n  // start the resource stack\n  res = new GfxResources(xref, resDict, NULL);\n\n  // initialize\n  out = outA;\n  state = new GfxState(hDPI, vDPI, box, rotate, out->upsideDown());\n  stackHeight = 1;\n  pushStateGuard();\n  fontChanged = gFalse;\n  clip = clipNone;\n  ignoreUndef = 0;\n  out->startPage(pageNum, state);\n  out->setDefaultCTM(state->getCTM());\n  out->updateAll(state);\n  for (i = 0; i < 6; ++i) {\n    baseMatrix[i] = state->getCTM()[i];\n  }\n  formDepth = 0;\n  abortCheckCbk = abortCheckCbkA;\n  abortCheckCbkData = abortCheckCbkDataA;\n\n  // set crop box\n  if (cropBox) {\n    state->moveTo(cropBox->x1, cropBox->y1);\n    state->lineTo(cropBox->x2, cropBox->y1);\n    state->lineTo(cropBox->x2, cropBox->y2);\n    state->lineTo(cropBox->x1, cropBox->y2);\n    state->closePath();\n    state->clip();\n    out->clip(state);\n    state->clearPath();\n  }\n}", "target": 2, "idx": 11127}
{"commit_id": "1dcd10aceabbc03bf571ea32b892c522cbe923de", "project": "the-tcpdump-group/tcpdump", "func": "u_int\njuniper_atm1_print(netdissect_options *ndo,\n                   const struct pcap_pkthdr *h, register const u_char *p)\n{\n        int llc_hdrlen;\n\n        struct juniper_l2info_t l2info;\n\n        l2info.pictype = DLT_JUNIPER_ATM1;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n\n        p+=l2info.header_len;\n\n        if (l2info.cookie[0] == 0x80) { /* OAM cell ? */\n            oam_print(ndo, p, l2info.length, ATM_OAM_NOHEC);\n            return l2info.header_len;\n        }\n\n        if (EXTRACT_24BITS(p) == 0xfefe03 || /* NLPID encaps ? */\n            EXTRACT_24BITS(p) == 0xaaaa03) { /* SNAP encaps ? */\n\n            llc_hdrlen = llc_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL);\n            if (llc_hdrlen > 0)\n                return l2info.header_len;\n        }\n\n        if (p[0] == 0x03) { /* Cisco style NLPID encaps ? */\n            isoclns_print(ndo, p + 1, l2info.length - 1);\n            /* FIXME check if frame was recognized */\n            return l2info.header_len;\n        }\n\n        if (ip_heuristic_guess(ndo, p, l2info.length) != 0) /* last try - vcmux encaps ? */\n            return l2info.header_len;\n\n\treturn l2info.header_len;\n}", "target": 3, "idx": 11128}
{"commit_id": "ae8cb6437294ca99ba203607c0dd522db4dbf6b6", "project": "llvm/llvm-project", "func": "LogicalResult verifyAnalysis(Operation *op,\n                               const AnalysisState &state) const {\n    auto whileOp = cast<scf::WhileOp>(op);\n    const auto &options =\n        static_cast<const OneShotBufferizationOptions &>(state.getOptions());\n    if (options.allowReturnAllocs)\n      return success();\n\n    auto conditionOp = whileOp.getConditionOp();\n    for (const auto &it : llvm::enumerate(conditionOp.getArgs())) {\n      Block *block = conditionOp->getBlock();\n      if (!isa<TensorType>(it.value().getType()))\n        continue;\n      if (it.index() >= block->getNumArguments() ||\n          !state.areEquivalentBufferizedValues(it.value(),\n                                               block->getArgument(it.index())))\n        return conditionOp->emitError()\n               << \"Condition arg #\" << it.index()\n               << \" is not equivalent to the corresponding iter bbArg\";\n    }\n\n    auto yieldOp = whileOp.getYieldOp();\n    for (const auto &it : llvm::enumerate(yieldOp.getResults())) {\n      Block *block = yieldOp->getBlock();\n      if (!isa<TensorType>(it.value().getType()))\n        continue;\n      if (it.index() >= block->getNumArguments() ||\n          !state.areEquivalentBufferizedValues(it.value(),\n                                               block->getArgument(it.index())))\n        return yieldOp->emitError()\n               << \"Yield operand #\" << it.index()\n               << \" is not equivalent to the corresponding iter bbArg\";\n    }\n\n    return success();\n  }", "target": 1, "idx": 11129}
{"commit_id": "b0cf030b30a9b63e678fee294321642beb42b724", "project": "wireshark", "func": "static gint get_native_type_cdr_alignment(guint64 member_kind, gint encapsulation_version) {\n  guint align = 0;\n\n  switch (member_kind) {\n  case RTI_CDR_TYPE_OBJECT_TYPE_KIND_BOOLEAN_TYPE: {\n    align = 1;\n    break;\n  }\n  case RTI_CDR_TYPE_OBJECT_TYPE_KIND_CHAR_8_TYPE:\n  case RTI_CDR_TYPE_OBJECT_TYPE_KIND_BYTE_TYPE: {\n    align = 1;\n    break;\n  }\n  case RTI_CDR_TYPE_OBJECT_TYPE_KIND_INT_16_TYPE: {\n    align = 2;\n    break;\n  }\n  case RTI_CDR_TYPE_OBJECT_TYPE_KIND_UINT_16_TYPE: {\n    align = 2;\n    break;\n  }\n  case RTI_CDR_TYPE_OBJECT_TYPE_KIND_ENUMERATION_TYPE:\n  case RTI_CDR_TYPE_OBJECT_TYPE_KIND_INT_32_TYPE: {\n    align = 4;\n    break;\n  }\n  case RTI_CDR_TYPE_OBJECT_TYPE_KIND_UINT_32_TYPE: {\n    align = 4;\n    break;\n  }\n  case RTI_CDR_TYPE_OBJECT_TYPE_KIND_INT_64_TYPE: {\n    align = (encapsulation_version == 1) ? 8 : 4;\n    break;\n  }\n  case RTI_CDR_TYPE_OBJECT_TYPE_KIND_UINT_64_TYPE: {\n    align = (encapsulation_version == 1) ? 8 : 4;\n    break;\n  }\n  case RTI_CDR_TYPE_OBJECT_TYPE_KIND_FLOAT_32_TYPE: {\n    align = 4;\n    break;\n  }\n  case RTI_CDR_TYPE_OBJECT_TYPE_KIND_FLOAT_64_TYPE: {\n    align = (encapsulation_version == 1) ? 8 : 4;\n    break;\n  }\n  case RTI_CDR_TYPE_OBJECT_TYPE_KIND_FLOAT_128_TYPE: {\n    align = (encapsulation_version == 1) ? 8 : 4;\n    break;\n  }\n  default: {\n    align = 1;\n    break;\n  }\n  }\n  return align;\n}", "target": 1, "idx": 11130}
{"commit_id": "7e6bc1f6cabcd30aba0b11219d8e01b952eacbb6", "project": "kernel/git/netdev/net", "func": "static int nft_setelem_parse_data(struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t\t  struct nft_data_desc *desc,\n\t\t\t\t  struct nft_data *data,\n\t\t\t\t  struct nlattr *attr)\n{\n\tu32 dtype;\n\tint err;\n\n\terr = nft_data_init(ctx, data, NFT_DATA_VALUE_MAXLEN, desc, attr);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (set->dtype == NFT_DATA_VERDICT)\n\t\tdtype = NFT_DATA_VERDICT;\n\telse\n\t\tdtype = NFT_DATA_VALUE;\n\n\tif (dtype != desc->type ||\n\t    set->dlen != desc->len) {\n\t\tnft_data_release(data, desc->type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "target": 2, "idx": 11131}
{"commit_id": "dc92574c10f3e2516ec6445b88c5d584f40df4e5", "project": "qpdf", "func": "void\nPl_ASCII85Decoder::flush()\n{\n    if (this->pos == 0)\n    {\n\tQTC::TC(\"libtests\", \"Pl_ASCII85Decoder no-op flush\");\n\treturn;\n    }\n    unsigned long lval = 0;\n    for (int i = 0; i < 5; ++i)\n    {\n\tlval *= 85;\n\tlval += (this->inbuf[i] - 33U);\n    }\n\n    unsigned char outbuf[4];\n    memset(outbuf, 0, 4);\n    for (int i = 3; i >= 0; --i)\n    {\n\toutbuf[i] = lval & 0xff;\n\tlval >>= 8;\n    }\n\n    QTC::TC(\"libtests\", \"Pl_ASCII85Decoder partial flush\",\n\t    (this->pos == 5) ? 0 : 1);\n    // Reset before calling getNext()->write in case that throws an\n    // exception.\n    auto t = this->pos - 1;\n    this->pos = 0;\n    memset(this->inbuf, 117, 5);\n\n    getNext()->write(outbuf, t);\n}", "target": 1, "idx": 11132}
{"commit_id": "388ecce75d05e11fc8496aa4857b91245007d26e", "project": "gpac", "func": "GF_Err url_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s;\n\n\tif (ptr->size) {\n\t\tptr->location = (char*)gf_malloc((u32) ptr->size);\n\t\tif (! ptr->location) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->location, (u32)ptr->size);\n\t\tif (ptr->location[ptr->size-1]) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] url box location is not 0-terminated\\n\" ));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\treturn GF_OK;\n}", "target": 2, "idx": 11133}
{"commit_id": "f85bc674b2a2256a364fe796351bc1971e106005", "project": "radareorg/radare2", "func": "R_API RConfigNode* r_config_set(RConfig *cfg, const char *name, const char *value) {\n\tRConfigNode *node = NULL;\n\tchar *ov = NULL;\n\tut64 oi;\n\tif (!cfg || STRNULL (name)) {\n\t\treturn NULL;\n\t}\n\tnode = r_config_node_get (cfg, name);\n\tif (node) {\n\t\tif (node->flags & CN_RO) {\n\t\t\teprintf (\"(error: '%s' config key is read only)\\n\", name);\n\t\t\treturn node;\n\t\t}\n\t\toi = node->i_value;\n\t\tif (node->value) {\n\t\t\tov = strdup (node->value);\n\t\t\tif (!ov) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t} else {\n\t\t\tfree (node->value);\n\t\t\tnode->value = strdup (\"\");\n\t\t}\n\t\tif (node->flags & CN_BOOL) {\n\t\t\tbool b = is_true (value);\n\t\t\tnode->i_value = (ut64) b? 1: 0;\n\t\t\tchar *value = strdup (r_str_bool (b));\n\t\t\tif (value) {\n\t\t\t\tfree (node->value);\n\t\t\t\tnode->value = value;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!value) {\n\t\t\t\tfree (node->value);\n\t\t\t\tnode->value = strdup (\"\");\n\t\t\t\tnode->i_value = 0;\n\t\t\t} else {\n\t\t\t\tif (node->value == value) {\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tchar *tmp = node->value;\n\t\t\t\tnode->value = strdup (value);\n\t\t\t\tfree (tmp);\n\t\t\t\tif (IS_DIGIT (*value)) {\n\t\t\t\t\tif (strchr (value, '/')) {\n\t\t\t\t\t\tnode->i_value = r_num_get (cfg->num, value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnode->i_value = r_num_math (cfg->num, value);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnode->i_value = 0;\n\t\t\t\t}\n\t\t\t\tnode->flags |= CN_INT;\n\t\t\t}\n\t\t}\n\t} else { // Create a new RConfigNode\n\t\toi = UT64_MAX;\n\t\tif (!cfg->lock) {\n\t\t\tnode = r_config_node_new (name, value);\n\t\t\tif (node) {\n\t\t\t\tif (value && is_bool (value)) {\n\t\t\t\t\tnode->flags |= CN_BOOL;\n\t\t\t\t\tnode->i_value = is_true (value)? 1: 0;\n\t\t\t\t}\n\t\t\t\tif (cfg->ht) {\n\t\t\t\t\tht_insert (cfg->ht, node->name, node);\n\t\t\t\t\tr_list_append (cfg->nodes, node);\n\t\t\t\t\tcfg->n_nodes++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\teprintf (\"r_config_set: unable to create a new RConfigNode\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"r_config_set: variable '%s' not found\\n\", name);\n\t\t}\n\t}\n\n\tif (node && node->setter) {\n\t\tint ret = node->setter (cfg->user, node);\n\t\tif (ret == false) {\n\t\t\tif (oi != UT64_MAX) {\n\t\t\t\tnode->i_value = oi;\n\t\t\t}\n\t\t\tfree (node->value);\n\t\t\tnode->value = strdup (ov? ov: \"\");\n\t\t}\n\t}\nbeach:\n\tfree (ov);\n\treturn node;\n}", "target": 1, "idx": 11134}
{"commit_id": "3245d354865def9d712bdffe61fa211ad6aa4081", "project": "fontforge", "func": "static const char *getsid(int sid,char **strings,int scnt,struct ttfinfo *info) {\n    if ( sid==-1 ) // Default value, indicating it's not present\nreturn( NULL );\n    else if (sid < 0) {\n        LogError(_(\"Bad sid %d (0 <= sid < %d)\\n\"), sid, scnt+nStdStrings);\n        if (info != NULL)\n            info->bad_cff = true;\n        return NULL;\n    }\n    else if ( sid<nStdStrings )\nreturn( cffnames[sid] );\n    else if ( sid-nStdStrings>scnt ) {\n\tLogError( _(\"Bad sid %d (must be less than %d)\\n\"), sid, scnt+nStdStrings );\n\tif ( info!=NULL ) info->bad_cff = true;\nreturn( NULL );\n    } else\nreturn( strings[sid-nStdStrings]);\n}", "target": 2, "idx": 11135}
{"commit_id": "584f396132aa19d21bb1e38ad9a5d428869290cb", "project": "ffmpeg", "func": "int dnn_execute_layer_math_binary(DnnOperand *operands, const int32_t *input_operand_indexes,\n                                 int32_t output_operand_index, const void *parameters)\n{\n    const DnnOperand *input = &operands[input_operand_indexes[0]];\n    DnnOperand *output = &operands[output_operand_index];\n    const DnnLayerMathBinaryParams *params = (const DnnLayerMathBinaryParams *)parameters;\n    int dims_count;\n    const float *src;\n    float *dst;\n\n    for (int i = 0; i < 4; ++i)\n        output->dims[i] = input->dims[i];\n\n    output->data_type = input->data_type;\n    output->length = calculate_operand_data_length(output);\n    if (output->length <= 0)\n        return DNN_ERROR;\n    output->data = av_realloc(output->data, output->length);\n    if (!output->data)\n        return DNN_ERROR;\n\n    dims_count = calculate_operand_dims_count(output);\n    src = input->data;\n    dst = output->data;\n\n    switch (params->bin_op) {\n    case DMBO_SUB:\n        if (params->input0_broadcast) {\n            for (int i = 0; i < dims_count; ++i) {\n                dst[i] = params->v - src[i];\n            }\n        } else if (params->input1_broadcast) {\n            for (int i = 0; i < dims_count; ++i) {\n                dst[i] = src[i] - params->v;\n            }\n        } else {\n            const DnnOperand *input1 = &operands[input_operand_indexes[1]];\n            const float *src1 = input1->data;\n            for (int i = 0; i < dims_count; ++i) {\n                dst[i] = src[i] - src1[i];\n            }\n        }\n        return 0;\n    case DMBO_ADD:\n        if (params->input0_broadcast || params->input1_broadcast) {\n            for (int i = 0; i < dims_count; ++i) {\n                dst[i] = params->v + src[i];\n            }\n        } else {\n            const DnnOperand *input1 = &operands[input_operand_indexes[1]];\n            const float *src1 = input1->data;\n            for (int i = 0; i < dims_count; ++i) {\n                dst[i] = src[i] + src1[i];\n            }\n        }\n        return 0;\n    case DMBO_MUL:\n        if (params->input0_broadcast || params->input1_broadcast) {\n            for (int i = 0; i < dims_count; ++i) {\n                dst[i] = params->v * src[i];\n            }\n        } else {\n            const DnnOperand *input1 = &operands[input_operand_indexes[1]];\n            const float *src1 = input1->data;\n            for (int i = 0; i < dims_count; ++i) {\n                dst[i] = src[i] * src1[i];\n            }\n        }\n        return 0;\n    case DMBO_REALDIV:\n        if (params->input0_broadcast) {\n            for (int i = 0; i < dims_count; ++i) {\n                dst[i] = params->v / src[i];\n            }\n        } else if (params->input1_broadcast) {\n            for (int i = 0; i < dims_count; ++i) {\n                dst[i] = src[i] / params->v;\n            }\n        } else {\n            const DnnOperand *input1 = &operands[input_operand_indexes[1]];\n            const float *src1 = input1->data;\n            for (int i = 0; i < dims_count; ++i) {\n                dst[i] = src[i] / src1[i];\n            }\n        }\n        return 0;\n    case DMBO_MINIMUM:\n        if (params->input0_broadcast || params->input1_broadcast) {\n            for (int i = 0; i < dims_count; ++i) {\n                dst[i] = FFMIN(params->v, src[i]);\n            }\n        } else {\n            const DnnOperand *input1 = &operands[input_operand_indexes[1]];\n            const float *src1 = input1->data;\n            for (int i = 0; i < dims_count; ++i) {\n                dst[i] = FFMIN(src[i], src1[i]);\n            }\n        }\n        return 0;\n    default:\n        return -1;\n    }\n}", "target": 2, "idx": 11136}
{"commit_id": "5462fd4725018567764c8f66bed98b7ee3e23006", "project": "ImageMagick", "func": "static Image *ReadXPMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    *grey,\n    key[MagickPathExtent],\n    target[MagickPathExtent],\n    *xpm_buffer;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    active,\n    status;\n\n  register char\n    *next,\n    *p,\n    *q;\n\n  register Quantum\n    *r;\n\n  register ssize_t\n    x;\n\n  size_t\n    length;\n\n  SplayTreeInfo\n    *xpm_colors;\n\n  ssize_t\n    count,\n    j,\n    y;\n\n  unsigned long\n    colors,\n    columns,\n    rows,\n    width;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read XPM file.\n  */\n  length=MagickPathExtent;\n  xpm_buffer=(char *) AcquireQuantumMemory((size_t) length,sizeof(*xpm_buffer));\n  if (xpm_buffer == (char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  *xpm_buffer='\\0';\n  p=xpm_buffer;\n  while (ReadBlobString(image,p) != (char *) NULL)\n  {\n    if ((*p == '#') && ((p == xpm_buffer) || (*(p-1) == '\\n')))\n      continue;\n    if ((*p == '}') && (*(p+1) == ';'))\n      break;\n    p+=strlen(p);\n    if ((size_t) (p-xpm_buffer+MagickPathExtent) < length)\n      continue;\n    length<<=1;\n    xpm_buffer=(char *) ResizeQuantumMemory(xpm_buffer,length+MagickPathExtent,\n      sizeof(*xpm_buffer));\n    if (xpm_buffer == (char *) NULL)\n      break;\n    p=xpm_buffer+strlen(xpm_buffer);\n  }\n  if (xpm_buffer == (char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  /*\n    Remove comments.\n  */\n  count=0;\n  width=0;\n  for (p=xpm_buffer; *p != '\\0'; p++)\n  {\n    if (*p != '\"')\n      continue;\n    count=(ssize_t) sscanf(p+1,\"%lu %lu %lu %lu\",&columns,&rows,&colors,&width);\n    image->columns=columns;\n    image->rows=rows;\n    image->colors=colors;\n    if (count == 4)\n      break;\n  }\n  if ((count != 4) || (width == 0) || (width > 3) ||\n      (image->columns == 0) || (image->rows == 0) ||\n      (image->colors == 0) || (image->colors > MaxColormapSize))\n    {\n      xpm_buffer=DestroyString(xpm_buffer);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  /*\n    Remove unquoted characters.\n  */\n  active=MagickFalse;\n  for (q=xpm_buffer; *p != '\\0'; )\n  {\n    if (*p++ == '\"')\n      {\n        if (active != MagickFalse)\n          *q++='\\n';\n        active=active != MagickFalse ? MagickFalse : MagickTrue;\n      }\n    if (active != MagickFalse)\n      *q++=(*p);\n  }\n  *q='\\0';\n  if (active != MagickFalse)\n    {\n      xpm_buffer=DestroyString(xpm_buffer);\n      ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n    }\n  /*\n    Initialize image structure.\n  */\n  xpm_colors=NewSplayTree(CompareXPMColor,RelinquishMagickMemory,\n    (void *(*)(void *)) NULL);\n  if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n    {\n      xpm_colors=DestroySplayTree(xpm_colors);\n      xpm_buffer=DestroyString(xpm_buffer);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  /*\n    Read image colormap.\n  */\n  image->depth=1;\n  next=NextXPMLine(xpm_buffer);\n  for (j=0; (j < (ssize_t) image->colors) && (next != (char *) NULL); j++)\n  {\n    char\n      symbolic[MagickPathExtent];\n\n    p=next;\n    next=NextXPMLine(p);\n    if (next == (char *) NULL)\n      break;\n    length=MagickMin((size_t) width,MagickPathExtent-1);\n    if (CopyXPMColor(key,p,length) != (ssize_t) length)\n      break;\n    status=AddValueToSplayTree(xpm_colors,ConstantString(key),(void *) j);\n    /*\n      Parse color.\n    */\n    (void) memset(target,0,sizeof(target));\n    (void) CopyMagickString(target,\"gray\",MagickPathExtent);\n    q=(char *) NULL;\n    if (strlen(p) > width)\n      q=ParseXPMColor(p+width,MagickTrue);\n    (void) memset(symbolic,0,sizeof(symbolic));\n    *symbolic='\\0';\n    if (q != (char *) NULL)\n      {\n        while ((isspace((int) ((unsigned char) *q)) == 0) && (*q != '\\0'))\n          q++;\n        if ((next-q) < 0)\n          break;\n        (void) CopyXPMColor(target,q,MagickMin((size_t) (next-q),\n          MagickPathExtent-1));\n        q=ParseXPMColor(target,MagickFalse);\n        (void) CopyXPMColor(symbolic,q,MagickMin((size_t) (next-q),\n          MagickPathExtent-1));\n        if (q != (char *) NULL)\n          *q='\\0';\n      }\n    StripString(target);\n    if (*symbolic != '\\0')\n      (void) AddValueToSplayTree(xpm_symbolic,ConstantString(target),\n        ConstantString(symbolic));\n    grey=strstr(target,\"grey\");\n    if (grey != (char *) NULL)\n      grey[2]='a';\n    if (LocaleCompare(target,\"none\") == 0)\n      {\n        image->storage_class=DirectClass;\n        image->alpha_trait=BlendPixelTrait;\n      }\n    status=QueryColorCompliance(target,XPMCompliance,&image->colormap[j],\n      exception);\n    if (status == MagickFalse)\n      break;\n    if (image->depth < image->colormap[j].depth)\n      image->depth=image->colormap[j].depth;\n  }\n  if (j < (ssize_t) image->colors)\n    {\n      xpm_colors=DestroySplayTree(xpm_colors);\n      xpm_buffer=DestroyString(xpm_buffer);\n      ThrowReaderException(CorruptImageError,\"CorruptImage\");\n    }\n  j=0;\n  if (image_info->ping == MagickFalse)\n    {\n      /*\n        Read image pixels.\n      */\n      status=SetImageExtent(image,image->columns,image->rows,exception);\n      if (status == MagickFalse)\n        {\n          xpm_colors=DestroySplayTree(xpm_colors);\n          xpm_buffer=DestroyString(xpm_buffer);\n          return(DestroyImageList(image));\n        }\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        p=NextXPMLine(p);\n        if (p == (char *) NULL)\n          break;\n        r=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (r == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          ssize_t\n            count;\n\n          count=CopyXPMColor(key,p,MagickMin(width,MagickPathExtent-1));\n          if (count != (ssize_t) width)\n            break;\n          j=(ssize_t) GetValueFromSplayTree(xpm_colors,key);\n          if (image->storage_class == PseudoClass)\n            SetPixelIndex(image,(Quantum) j,r);\n          SetPixelViaPixelInfo(image,image->colormap+j,r);\n          p+=count;\n          r+=GetPixelChannels(image);\n        }\n        if (x < (ssize_t) image->columns)\n          break;\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n      }\n      if (y < (ssize_t) image->rows)\n        {\n          xpm_colors=DestroySplayTree(xpm_colors);\n          xpm_buffer=DestroyString(xpm_buffer);\n          ThrowReaderException(CorruptImageError,\"NotEnoughPixelData\");\n        }\n    }\n  /*\n    Relinquish resources.\n  */\n  xpm_buffer=DestroyString(xpm_buffer);\n  xpm_colors=DestroySplayTree(xpm_colors);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}", "target": 2, "idx": 11137}
{"commit_id": "c2e197e4efc663ca55f393bf0e799848842286f3", "project": "php/php-src", "func": "static HashTable *spl_object_storage_get_gc(zval *obj, zval ***table, int *n TSRMLS_DC) /* {{{ */\n{\n\tspl_SplObjectStorage *intern = (spl_SplObjectStorage*)zend_object_store_get_object(obj TSRMLS_CC);\n\tspl_SplObjectStorageElement *element;\n\tHashTable *props;\n\tHashPosition pos;\n\tzval *gcdata_arr = NULL,\n\t\t **gcdata_arr_pp;\n\n\tprops = std_object_handlers.get_properties(obj TSRMLS_CC);\n\n\t*table = NULL;\n\t*n = 0;\n\n\t/* clean \\x00gcdata, as it may be out of date */\n\tif (zend_hash_find(props, \"\\x00gcdata\", sizeof(\"\\x00gcdata\"), (void**) &gcdata_arr_pp) == SUCCESS) {\n\t\tgcdata_arr = *gcdata_arr_pp;\n\t\tzend_hash_clean(Z_ARRVAL_P(gcdata_arr));\n\t}\n\n\tif (gcdata_arr == NULL) {\n\t\tMAKE_STD_ZVAL(gcdata_arr);\n\t\tarray_init(gcdata_arr);\n\t\t/* don't decrease refcount of members when destroying */\n\t\tZ_ARRVAL_P(gcdata_arr)->pDestructor = NULL;\n\n\t\t/* name starts with \\x00 to make tampering in user-land more difficult */\n\t\tzend_hash_add(props, \"\\x00gcdata\", sizeof(\"\\x00gcdata\"), &gcdata_arr, sizeof(gcdata_arr), NULL);\n\t}\n\n\tzend_hash_internal_pointer_reset_ex(&intern->storage, &pos);\n\twhile (zend_hash_get_current_data_ex(&intern->storage, (void **)&element, &pos) == SUCCESS) {\n\t\tadd_next_index_zval(gcdata_arr, element->obj);\n\t\tadd_next_index_zval(gcdata_arr, element->inf);\n\t\tzend_hash_move_forward_ex(&intern->storage, &pos);\n\t}\n\n\treturn props;\n}", "target": 2, "idx": 11138}
{"commit_id": "9c19a08b9daed6bae3071dd25742f59a59618823", "project": "php/php-src", "func": "static void php_snmp_error(zval *object, const char *docref TSRMLS_DC, int type, const char *format, ...)\n{\n\tva_list args;\n\tphp_snmp_object *snmp_object = NULL;\n\n\tif (object) {\n\t\tsnmp_object = (php_snmp_object *)zend_object_store_get_object(object TSRMLS_CC);\n\t\tif (type == PHP_SNMP_ERRNO_NOERROR) {\n\t\t\tmemset(snmp_object->snmp_errstr, 0, sizeof(snmp_object->snmp_errstr));\n\t\t} else {\n\t\t\tva_start(args, format);\n\t\t\tvsnprintf(snmp_object->snmp_errstr, sizeof(snmp_object->snmp_errstr) - 1, format, args);\n\t\t\tva_end(args);\n\t\t}\n\t\tsnmp_object->snmp_errno = type;\n\t}\n\n\tif (type == PHP_SNMP_ERRNO_NOERROR) {\n\t\treturn;\n\t}\n\n\tif (object && (snmp_object->exceptions_enabled & type)) {\n\t\tzend_throw_exception_ex(php_snmp_exception_ce, type TSRMLS_CC, \"%s\", snmp_object->snmp_errstr);\n\t} else {\n\t\tva_start(args, format);\n\t\tphp_verror(docref, \"\", E_WARNING, format, args TSRMLS_CC);\n\t\tva_end(args);\n\t}\n}", "target": 3, "idx": 11139}
{"commit_id": "5408a6d93f45bf1f7acd9ae5d44e0ebd77379e98", "project": "pcmacdon/jsish", "func": "static Jsi_RC jsi_ArrayReduceSubCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr, int op) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) \n        return Jsi_LogError(\"expected array\");\n    Jsi_RC rc = JSI_OK;\n    int i;\n    Jsi_Obj *obj;\n    Jsi_Value *func, *vpargs, *ini = Jsi_ValueArrayIndex(interp, args, 1);\n\n    func = Jsi_ValueArrayIndex(interp, args, 0);\n    if (!Jsi_ValueIsFunction(interp, func)) \n        return Jsi_LogError(\"expected function\");\n\n    Jsi_Value *nrPtr = Jsi_ValueNew1(interp);\n    obj = _this->d.obj;\n    Jsi_ObjListifyArray(interp, obj);\n    Jsi_Value *vobjs[4];\n    int n, rev = (op==2);\n    Jsi_Func *fptr = func->d.obj->d.fobj->func;\n    int maa = (fptr->argnames?fptr->argnames->argCnt:0);\n    if (maa>4)\n        maa = 4;\n\n    for (n = 0, i = (rev?obj->arrCnt-1:0); (rev?i>=0:i < (int)obj->arrCnt) && rc == JSI_OK; n++, i = (rev?i-1:i+1)) {\n        if (!obj->arr[i]) continue;\n        if (n==0 && !ini) {\n            ini = obj->arr[i];\n            continue;\n        }\n            \n        vobjs[0] = ini;\n        vobjs[1] = obj->arr[i];\n        vobjs[2] = (maa>2?Jsi_ValueNewNumber(interp, i):NULL);\n        vobjs[3] = _this;\n        vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, vobjs, maa, 0));\n        Jsi_IncrRefCount(interp, vpargs);\n        rc = Jsi_FunctionInvoke(interp, func, vpargs, &nrPtr, NULL);\n        Jsi_DecrRefCount(interp, vpargs);\n        if (rc != JSI_OK)\n            break;\n        ini = nrPtr;\n    }\n    if (rc == JSI_OK && ini)\n        Jsi_ValueCopy(interp, *ret, ini); \n    Jsi_DecrRefCount(interp, nrPtr);\n    return rc;\n\n}", "target": 3, "idx": 11140}
{"commit_id": "858c3f0079f987833fb22eba2c361d1a88ba4103", "project": "wireshark", "func": "guint32\ns7comm_decode_ud_cpu_szl_subfunc(tvbuff_t *tvb,\n                                    packet_info *pinfo,\n                                    proto_tree *data_tree,\n                                    guint8 type,                /* Type of data (request/response) */\n                                    guint8 ret_val,             /* Return value in data part */\n                                    guint16 len,                /* length given in data part */\n                                    guint16 dlength,            /* length of data part given in header */\n                                    guint8 data_unit_ref,       /* Data-unit-reference ID from parameter part, used for response fragment detection */\n                                    guint8 last_data_unit,      /* 0 is last, 1 is not last data unit, used for response fragment detection */\n                                    guint32 offset)             /* Offset on data part +4 */\n{\n    guint16 id;\n    guint16 idx;\n    guint16 list_len;\n    guint16 list_count;\n    guint16 i;\n    guint16 tbytes = 0;\n    proto_item *szl_item = NULL;\n    proto_tree *szl_item_tree = NULL;\n    proto_item *szl_item_entry = NULL;\n    const gchar* szl_index_description;\n\n    gboolean know_data = FALSE;\n    gboolean szl_decoded = FALSE;\n\n    if (type == S7COMM_UD_TYPE_REQ) {                   /*** Request ***/\n        id = tvb_get_ntohs(tvb, offset);\n        proto_tree_add_bitmask(data_tree, tvb, offset, hf_s7comm_userdata_szl_id,\n            ett_s7comm_userdata_szl_id, s7comm_userdata_szl_id_fields, ENC_BIG_ENDIAN);\n        offset += 2;\n        idx = tvb_get_ntohs(tvb, offset);\n        szl_item_entry = proto_tree_add_item(data_tree, hf_s7comm_userdata_szl_index, tvb, offset, 2, ENC_BIG_ENDIAN);\n        offset += 2;\n        szl_index_description = s7comm_get_szl_id_index_description_text(id, idx);\n        if (szl_index_description != NULL) {\n            proto_item_append_text(szl_item_entry, \" [%s]\", szl_index_description);\n        }\n        proto_item_append_text(data_tree, \" (SZL-ID: 0x%04x, Index: 0x%04x)\", id, idx);\n        col_append_fstr(pinfo->cinfo, COL_INFO, \" ID=0x%04x Index=0x%04x\" , id, idx);\n        know_data = TRUE;\n    } else if (type == S7COMM_UD_TYPE_RES) {            /*** Response ***/\n        /* When response OK, data follows */\n        if (ret_val == S7COMM_ITEM_RETVAL_DATA_OK) {\n            /* A fragmented response has a data-unit-ref <> 0 with Last-data-unit == 1\n             * It's only possible to decode the first response of a fragment, because\n             * only the first PDU contains the ID/Index header. Will result in an display-error when a PDU goes over more than 2 PDUs, but ... eeeek ... no better way to realize this.\n             * last_data_unit == 0 when it's the last unit\n             * last_data_unit == 1 when it's not the last unit\n             */\n            if (data_unit_ref != 0 && last_data_unit == 0) {\n                szl_item = proto_tree_add_item(data_tree, hf_s7comm_userdata_szl_tree, tvb, offset, len, ENC_NA);\n                szl_item_tree = proto_item_add_subtree(szl_item, ett_s7comm_szl);\n                proto_item_append_text(szl_item, \" [Fragment, continuation of previous data]\");\n\n                proto_tree_add_item(szl_item_tree, hf_s7comm_userdata_szl_data, tvb, offset, len, ENC_NA);\n                offset += len;\n                col_append_fstr(pinfo->cinfo, COL_INFO, \" SZL data fragment\");\n            } else {\n                id = tvb_get_ntohs(tvb, offset);\n                proto_tree_add_bitmask(data_tree, tvb, offset, hf_s7comm_userdata_szl_id,\n                    ett_s7comm_userdata_szl_id, s7comm_userdata_szl_id_fields, ENC_BIG_ENDIAN);\n                offset += 2;\n                idx = tvb_get_ntohs(tvb, offset);\n                szl_item_entry = proto_tree_add_item(data_tree, hf_s7comm_userdata_szl_index, tvb, offset, 2, ENC_BIG_ENDIAN);\n                offset += 2;\n                szl_index_description = s7comm_get_szl_id_index_description_text(id, idx);\n                if (szl_index_description != NULL) {\n                    proto_item_append_text(szl_item_entry, \" [%s]\", szl_index_description);\n                }\n                proto_item_append_text(data_tree, \" (SZL-ID: 0x%04x, Index: 0x%04x)\", id, idx);\n                col_append_fstr(pinfo->cinfo, COL_INFO, \" ID=0x%04x Index=0x%04x\" , id, idx);\n\n                /* SZL-Data, 4 Bytes header, 4 bytes id/index = 8 bytes */\n                list_len = tvb_get_ntohs(tvb, offset); /* Length of an list set in bytes */\n                proto_tree_add_uint(data_tree, hf_s7comm_userdata_szl_id_partlist_len, tvb, offset, 2, list_len);\n                offset += 2;\n                list_count = tvb_get_ntohs(tvb, offset); /* count of partlists */\n                proto_tree_add_uint(data_tree, hf_s7comm_userdata_szl_id_partlist_cnt, tvb, offset, 2, list_count);\n                /* Some SZL responses got more lists than fit one PDU (e.g. Diagnosepuffer) and must be read\n                 * out in several telegrams, so we have to check here if the list_count is above limits\n                 * of the length of data part. The remainding bytes will be print as raw bytes, because\n                 * it's not possible to decode this and following telegrams without knowing the previous requests.\n                 */\n                tbytes = 0;\n                if (list_len > 0) {\n                    if ((list_count * list_len) > (len - 8)) {\n                        list_count = (len - 8) / list_len;\n                        /* remind the number of trailing bytes */\n                        if (list_count > 0) {\n                            tbytes = (len - 8) % list_count;\n                        }\n                    }\n                }\n                offset += 2;\n                /* Add a Data element for each partlist */\n                if (len > 8) {      /* minimum length of a correct szl data part is 8 bytes */\n                    for (i = 1; i <= list_count; i++) {\n                        /* Add a separate tree for the SZL data */\n                        szl_item = proto_tree_add_item(data_tree, hf_s7comm_userdata_szl_tree, tvb, offset, list_len, ENC_NA);\n                        szl_item_tree = proto_item_add_subtree(szl_item, ett_s7comm_szl);\n                        proto_item_append_text(szl_item, \" (list count no. %d)\", i);\n\n                        szl_decoded = FALSE;\n                        /* lets try to decode some known szl-id and indexes */\n                        switch (id) {\n                            case 0x0000:\n                                offset = s7comm_decode_szl_id_xy00(tvb, szl_item_tree, id, idx, offset);\n                                szl_decoded = TRUE;\n                                break;\n                            case 0x0013:\n                                if (idx == 0x0000) {\n                                    offset = s7comm_decode_szl_id_0013_idx_0000(tvb, szl_item_tree, offset);\n                                    szl_decoded = TRUE;\n                                }\n                                break;\n                            case 0x0011:\n                            case 0x0111:\n                                if ((idx == 0x0001) || (idx == 0x0000)) {\n                                    offset = s7comm_decode_szl_id_0111_idx_0001(tvb, szl_item_tree, offset);\n                                    szl_decoded = TRUE;\n                                }\n                                break;\n                            case 0x0131:\n                                if (idx == 0x0001) {\n                                    offset = s7comm_decode_szl_id_0131_idx_0001(tvb, szl_item_tree, offset);\n                                    szl_decoded = TRUE;\n                                } else if (idx == 0x0002) {\n                                    offset = s7comm_decode_szl_id_0131_idx_0002(tvb, szl_item_tree, offset);\n                                    szl_decoded = TRUE;\n                                } else if (idx == 0x0003) {\n                                    offset = s7comm_decode_szl_id_0131_idx_0003(tvb, szl_item_tree, offset);\n                                    szl_decoded = TRUE;\n                                } else if (idx == 0x0004) {\n                                    offset = s7comm_decode_szl_id_0131_idx_0004(tvb, szl_item_tree, offset);\n                                    szl_decoded = TRUE;\n                                } else if (idx == 0x0006) {\n                                    offset = s7comm_decode_szl_id_0131_idx_0006(tvb, szl_item_tree, offset);\n                                    szl_decoded = TRUE;\n                                } else if (idx == 0x0010) {\n                                    offset = s7comm_decode_szl_id_0131_idx_0010(tvb, szl_item_tree, offset);\n                                    szl_decoded = TRUE;\n                                }\n                                break;\n                            case 0x0132:\n                                if (idx == 0x0001) {\n                                    offset = s7comm_decode_szl_id_0132_idx_0001(tvb, szl_item_tree, offset);\n                                    szl_decoded = TRUE;\n                                } else if (idx == 0x0002) {\n                                    offset = s7comm_decode_szl_id_0132_idx_0002(tvb, szl_item_tree, offset);\n                                    szl_decoded = TRUE;\n                                } else if (idx == 0x0004) {\n                                    offset = s7comm_decode_szl_id_0132_idx_0004(tvb, szl_item_tree, offset);\n                                    szl_decoded = TRUE;\n                                } else if (idx == 0x0005) {\n                                    offset = s7comm_decode_szl_id_0132_idx_0005(tvb, szl_item_tree, offset);\n                                    szl_decoded = TRUE;\n                                } else if (idx == 0x0006) {\n                                    offset = s7comm_decode_szl_id_0132_idx_0006(tvb, szl_item_tree, offset);\n                                    szl_decoded = TRUE;\n                                }\n                                break;\n                            case 0x0019:\n                            case 0x0119:\n                            case 0x0074:\n                            case 0x0174:\n                                    offset = s7comm_decode_szl_id_xy74_idx_0000(tvb, szl_item_tree, offset);\n                                    szl_decoded = TRUE;\n                                break;\n                            case 0x0124:\n                            case 0x0424:\n                                if (idx == 0x0000) {\n                                    offset = s7comm_decode_szl_id_0424_idx_0000(tvb, szl_item_tree, offset);\n                                    szl_decoded = TRUE;\n                                }\n                                break;\n                            default:\n                                szl_decoded = FALSE;\n                                break;\n                        }\n                        if (szl_decoded == FALSE) {\n                            proto_tree_add_item(szl_item_tree, hf_s7comm_userdata_szl_partial_list, tvb, offset, list_len, ENC_NA);\n                            offset += list_len;\n                        }\n                    } /* ...for */\n                }\n            }\n        } else {\n            col_append_fstr(pinfo->cinfo, COL_INFO, \" Return value:[%s]\", val_to_str(ret_val, s7comm_item_return_valuenames, \"Unknown return value:0x%02x\"));\n        }\n        know_data = TRUE;\n    }\n    /* add raw bytes of data part when SZL response doesn't fit one PDU */\n    if (know_data == TRUE && tbytes > 0) {\n        /* Add a separate tree for the SZL data fragment */\n        szl_item = proto_tree_add_item(data_tree, hf_s7comm_userdata_szl_tree, tvb, offset, tbytes, ENC_NA);\n        szl_item_tree = proto_item_add_subtree(szl_item, ett_s7comm_szl);\n        proto_item_append_text(szl_item, \" [Fragment, complete response doesn't fit one PDU]\");\n        proto_tree_add_item(szl_item_tree, hf_s7comm_userdata_szl_data, tvb, offset, tbytes, ENC_NA);\n        offset += tbytes;\n    }\n    if (know_data == FALSE && dlength > 4) {\n        proto_tree_add_item(data_tree, hf_s7comm_userdata_szl_data, tvb, offset, dlength - 4, ENC_NA);\n        offset += dlength;\n    }\n    return offset;\n}", "target": 1, "idx": 11141}
{"commit_id": "ec412aa4583ad71ecabb967d3c77162760169d1f", "project": "libexif", "func": "static void\nexif_mnote_data_pentax_load (ExifMnoteData *en,\n\t\tconst unsigned char *buf, unsigned int buf_size)\n{\n\tExifMnoteDataPentax *n = (ExifMnoteDataPentax *) en;\n\tsize_t i, tcount, o, datao, base = 0;\n\tExifShort c;\n\n\tif (!n || !buf || !buf_size) {\n\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteDataPentax\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\tdatao = 6 + n->offset;\n\tif (CHECKOVERFLOW(datao, buf_size, 8)) {\n\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteDataPentax\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\n\t/* Detect variant of Pentax/Casio MakerNote found */\n\tif (!memcmp(buf + datao, \"AOC\", 4)) {\n\t\tif ((buf[datao + 4] == 'I') && (buf[datao + 5] == 'I')) {\n\t\t\tn->version = pentaxV3;\n\t\t\tn->order = EXIF_BYTE_ORDER_INTEL;\n\t\t} else if ((buf[datao + 4] == 'M') && (buf[datao + 5] == 'M')) {\n\t\t\tn->version = pentaxV3;\n\t\t\tn->order = EXIF_BYTE_ORDER_MOTOROLA;\n\t\t} else {\n\t\t\t/* Uses Casio v2 tags */\n\t\t\tn->version = pentaxV2;\n\t\t}\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataPentax\",\n\t\t\t\"Parsing Pentax maker note v%d...\", (int)n->version);\n\t\tdatao += 4 + 2;\n\t\tbase = MNOTE_PENTAX2_TAG_BASE;\n\t} else if (!memcmp(buf + datao, \"QVC\", 4)) {\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataPentax\",\n\t\t\t\"Parsing Casio maker note v2...\");\n\t\tn->version = casioV2;\n\t\tbase = MNOTE_CASIO2_TAG_BASE;\n\t\tdatao += 4 + 2;\n\t} else {\n\t\t/* probably assert(!memcmp(buf + datao, \"\\x00\\x1b\", 2)) */\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataPentax\",\n\t\t\t\"Parsing Pentax maker note v1...\");\n\t\tn->version = pentaxV1;\n\t}\n\n\t/* Read the number of tags */\n\tc = exif_get_short (buf + datao, n->order);\n\tdatao += 2;\n\n\t/* Remove any old entries */\n\texif_mnote_data_pentax_clear (n);\n\n\t/* Reserve enough space for all the possible MakerNote tags */\n\tn->entries = exif_mem_alloc (en->mem, sizeof (MnotePentaxEntry) * c);\n\tif (!n->entries) {\n\t\tEXIF_LOG_NO_MEMORY(en->log, \"ExifMnoteDataPentax\", sizeof (MnotePentaxEntry) * c);\n\t\treturn;\n\t}\n\n\t/* Parse all c entries, storing ones that are successfully parsed */\n\ttcount = 0;\n\tfor (i = c, o = datao; i; --i, o += 12) {\n\t\tsize_t s;\n\n\t\tmemset(&n->entries[tcount], 0, sizeof(MnotePentaxEntry));\n\t\tif (CHECKOVERFLOW(o,buf_size,12)) {\n\t\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifMnoteDataPentax\", \"Short MakerNote\");\n\t\t\tbreak;\n\t\t}\n\n\t\tn->entries[tcount].tag        = exif_get_short (buf + o + 0, n->order) + base;\n\t\tn->entries[tcount].format     = exif_get_short (buf + o + 2, n->order);\n\t\tn->entries[tcount].components = exif_get_long  (buf + o + 4, n->order);\n\t\tn->entries[tcount].order      = n->order;\n\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnotePentax\",\n\t\t\t  \"Loading entry 0x%x ('%s')...\", n->entries[tcount].tag,\n\t\t\t  mnote_pentax_tag_get_name (n->entries[tcount].tag));\n\n\t\t/* Check if we overflow the multiplication. Use buf_size as the max size for integer overflow detection,\n\t\t * we will check the buffer sizes closer later. */\n\t\tif (\texif_format_get_size (n->entries[tcount].format) &&\n\t\t\tbuf_size / exif_format_get_size (n->entries[tcount].format) < n->entries[tcount].components\n\t\t) {\n\t\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifMnoteDataPentax\", \"Tag size overflow detected (%u * %lu)\", exif_format_get_size (n->entries[tcount].format), n->entries[tcount].components);\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Size? If bigger than 4 bytes, the actual data is not\n\t\t * in the entry but somewhere else (offset).\n\t\t */\n\t\ts = exif_format_get_size (n->entries[tcount].format) *\n                                      n->entries[tcount].components;\n\t\tn->entries[tcount].size = s;\n\t\tif (s) {\n\t\t\tsize_t dataofs = o + 8;\n\t\t\tif (s > 4)\n\t\t\t\t/* The data in this case is merely a pointer */\n\t\t\t   \tdataofs = exif_get_long (buf + dataofs, n->order) + 6;\n\n\t\t\tif (CHECKOVERFLOW(dataofs, buf_size, s)) {\n\t\t\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\t\t\t  \"ExifMnoteDataPentax\", \"Tag data past end \"\n\t\t\t\t\t  \"of buffer (%u > %u)\", (unsigned)(dataofs + s), buf_size);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tn->entries[tcount].data = exif_mem_alloc (en->mem, s);\n\t\t\tif (!n->entries[tcount].data) {\n\t\t\t\tEXIF_LOG_NO_MEMORY(en->log, \"ExifMnoteDataPentax\", s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmemcpy (n->entries[tcount].data, buf + dataofs, s);\n\t\t}\n\n\t\t/* Tag was successfully parsed */\n\t\t++tcount;\n\t}\n\t/* Store the count of successfully parsed tags */\n\tn->count = tcount;\n}", "target": 2, "idx": 11142}
{"commit_id": "b09c75dc2d4bf68ac447daa71e72365aa30231a9", "project": "gpac", "func": "GF_Err gf_isom_text_get_encoded_tx3g(GF_ISOFile *file, u32 track, u32 sidx, u32 sidx_offset, u8 **tx3g, u32 *tx3g_size)\n{\n\tGF_BitStream *bs;\n\tGF_TrackBox *trak;\n\tGF_Tx3gSampleEntryBox *a;\n\n\t*tx3g = NULL;\n\t*tx3g_size = 0;\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\ta = (GF_Tx3gSampleEntryBox *) gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sidx-1);\n\tif (!a) return GF_BAD_PARAM;\n\tif ((a->type != GF_ISOM_BOX_TYPE_TX3G) && (a->type != GF_ISOM_BOX_TYPE_TEXT)) return GF_BAD_PARAM;\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_isom_write_tx3g(a, bs, sidx, sidx_offset);\n\tgf_bs_get_content(bs, tx3g, tx3g_size);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}", "target": 1, "idx": 11143}
{"commit_id": "2e1198672759eda6e122ff38fcf6df06f27e0fe2", "project": "qemu", "func": "static void stellaris_enet_unrealize(DeviceState *dev, Error **errp)\n{\n    stellaris_enet_state *s = STELLARIS_ENET(dev);\n\n    memory_region_destroy(&s->mmio);\n}", "target": 2, "idx": 11144}
{"commit_id": "c753000eb31835c0664e528fbc99378ae0cbe950", "project": "gssapi/gss-ntlmssp", "func": "static int ntlm_decode_u16l_str_hdr(struct ntlm_ctx *ctx,\n                                    struct wire_field_hdr *str_hdr,\n                                    struct ntlm_buffer *buffer,\n                                    size_t payload_offs, char **str)\n{\n    char *in, *out = NULL;\n    uint16_t str_len;\n    uint32_t str_offs;\n    size_t outlen = 0;\n    int ret = 0;\n\n    str_len = le16toh(str_hdr->len);\n    if (str_len == 0) goto done;\n\n    str_offs = le32toh(str_hdr->offset);\n    if ((str_offs < payload_offs) ||\n        (str_offs > buffer->length) ||\n        (UINT32_MAX - str_offs < str_len) ||\n        (str_offs + str_len > buffer->length)) {\n        return ERR_DECODE;\n    }\n\n    in = (char *)&buffer->data[str_offs];\n\n    out = malloc(str_len * 2 + 1);\n    if (!out) return ENOMEM;\n\n    ret = ntlm_str_convert(ctx->to_oem, in, out, str_len, &outlen);\n\ndone:\n    if (ret) {\n        safefree(out);\n    } else {\n        /* make sure to terminate output string */\n        out[outlen] = '\\0';\n    }\n\n    *str = out;\n    return ret;\n}", "target": 1, "idx": 11145}
{"commit_id": "6c5211a0cef0cc2854eaa387e0eb036e012904d0", "project": "php/php-src", "func": "static void php_mcrypt_do_crypt(char* cipher, const char *key, int key_len, const char *data, int data_len, char *mode, const char *iv, int iv_len, int argc, int dencrypt, zval* return_value TSRMLS_DC) /* {{{ */\n{\n\tchar *cipher_dir_string;\n\tchar *module_dir_string;\n\tint block_size, max_key_length, use_key_length, i, count, iv_size;\n\tunsigned long int data_size;\n\tint *key_length_sizes;\n\tchar *key_s = NULL, *iv_s;\n\tchar *data_s;\n\tMCRYPT td;\n\n\tMCRYPT_GET_INI\n\n\ttd = mcrypt_module_open(cipher, cipher_dir_string, mode, module_dir_string);\n\tif (td == MCRYPT_FAILED) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, MCRYPT_OPEN_MODULE_FAILED);\n\t\tRETURN_FALSE;\n\t}\n\t/* Checking for key-length */\n\tmax_key_length = mcrypt_enc_get_key_size(td);\n\tif (key_len > max_key_length) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Size of key is too large for this algorithm\");\n\t}\n\tkey_length_sizes = mcrypt_enc_get_supported_key_sizes(td, &count);\n\tif (count == 0 && key_length_sizes == NULL) { /* all lengths 1 - k_l_s = OK */\n\t\tuse_key_length = key_len;\n\t\tkey_s = emalloc(use_key_length);\n\t\tmemset(key_s, 0, use_key_length);\n\t\tmemcpy(key_s, key, use_key_length);\n\t} else if (count == 1) {  /* only m_k_l = OK */\n\t\tkey_s = emalloc(key_length_sizes[0]);\n\t\tmemset(key_s, 0, key_length_sizes[0]);\n\t\tmemcpy(key_s, key, MIN(key_len, key_length_sizes[0]));\n\t\tuse_key_length = key_length_sizes[0];\n\t} else { /* dertermine smallest supported key > length of requested key */\n\t\tuse_key_length = max_key_length; /* start with max key length */\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tif (key_length_sizes[i] >= key_len &&\n\t\t\t\tkey_length_sizes[i] < use_key_length)\n\t\t\t{\n\t\t\t\tuse_key_length = key_length_sizes[i];\n\t\t\t}\n\t\t}\n\t\tkey_s = emalloc(use_key_length);\n\t\tmemset(key_s, 0, use_key_length);\n\t\tmemcpy(key_s, key, MIN(key_len, use_key_length));\n\t}\n\tmcrypt_free (key_length_sizes);\n\n\t/* Check IV */\n\tiv_s = NULL;\n\tiv_size = mcrypt_enc_get_iv_size (td);\n\n\t/* IV is required */\n\tif (mcrypt_enc_mode_has_iv(td) == 1) {\n\t\tif (argc == 5) {\n\t\t\tif (iv_size != iv_len) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, MCRYPT_IV_WRONG_SIZE);\n\t\t\t} else {\n\t\t\t\tiv_s = emalloc(iv_size + 1);\n\t\t\t\tmemcpy(iv_s, iv, iv_size);\n\t\t\t}\n\t\t} else if (argc == 4) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Attempt to use an empty IV, which is NOT recommend\");\n\t\t\tiv_s = emalloc(iv_size + 1);\n\t\t\tmemset(iv_s, 0, iv_size + 1);\n\t\t}\n\t}\n\n\t/* Check blocksize */\n\tif (mcrypt_enc_is_block_mode(td) == 1) { /* It's a block algorithm */\n\t\tblock_size = mcrypt_enc_get_block_size(td);\n\t\tdata_size = (((data_len - 1) / block_size) + 1) * block_size;\n\t\tdata_s = emalloc(data_size);\n\t\tmemset(data_s, 0, data_size);\n\t\tmemcpy(data_s, data, data_len);\n\t} else { /* It's not a block algorithm */\n\t\tdata_size = data_len;\n\t\tdata_s = emalloc(data_size);\n\t\tmemset(data_s, 0, data_size);\n\t\tmemcpy(data_s, data, data_len);\n\t}\n\n\tif (mcrypt_generic_init(td, key_s, use_key_length, iv_s) < 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_RECOVERABLE_ERROR, \"Mcrypt initialisation failed\");\n\t\tRETURN_FALSE;\n\t}\n\tif (dencrypt == MCRYPT_ENCRYPT) {\n\t\tmcrypt_generic(td, data_s, data_size);\n\t} else {\n\t\tmdecrypt_generic(td, data_s, data_size);\n\t}\n\n\tRETVAL_STRINGL(data_s, data_size, 1);\n\n\t/* freeing vars */\n\tmcrypt_generic_end(td);\n\tif (key_s != NULL) {\n\t\tefree (key_s);\n\t}\n\tif (iv_s != NULL) {\n\t\tefree (iv_s);\n\t}\n\tefree (data_s);\n}", "target": 3, "idx": 11146}
{"commit_id": "363b02dab09b3226f3bd1420dad9c72b79a42a76", "project": "torvalds/linux", "func": "static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct encrypted_key_payload *epayload = key->payload.data[0];\n\tstruct encrypted_key_payload *new_epayload;\n\tchar *buf;\n\tchar *new_master_desc = NULL;\n\tconst char *format = NULL;\n\tsize_t datalen = prep->datalen;\n\tint ret = 0;\n\n\tif (key_is_negative(key))\n\t\treturn -ENOKEY;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tbuf = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf[datalen] = 0;\n\tmemcpy(buf, prep->data, datalen);\n\tret = datablob_parse(buf, &format, &new_master_desc, NULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = valid_master_desc(new_master_desc, epayload->master_desc);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tnew_epayload = encrypted_key_alloc(key, epayload->format,\n\t\t\t\t\t   new_master_desc, epayload->datalen);\n\tif (IS_ERR(new_epayload)) {\n\t\tret = PTR_ERR(new_epayload);\n\t\tgoto out;\n\t}\n\n\t__ekey_init(new_epayload, epayload->format, new_master_desc,\n\t\t    epayload->datalen);\n\n\tmemcpy(new_epayload->iv, epayload->iv, ivsize);\n\tmemcpy(new_epayload->payload_data, epayload->payload_data,\n\t       epayload->payload_datalen);\n\n\trcu_assign_keypointer(key, new_epayload);\n\tcall_rcu(&epayload->rcu, encrypted_rcu_free);\nout:\n\tkzfree(buf);\n\treturn ret;\n}", "target": 2, "idx": 11147}
{"commit_id": "77b3fb4df0f126784d5fd4967c28ed40eb8d521b", "project": "squid-cache/squid", "func": "static int\nmake_month(const char *s)\n{\n    int i;\n    char month[3];\n\n    month[0] = xtoupper(*s);\n    if (!month[0])\n        return -1; // protects *(s + 1) below\n\n    month[1] = xtolower(*(s + 1));\n    if (!month[1])\n        return -1; // protects *(s + 2) below\n\n    month[2] = xtolower(*(s + 2));\n\n    for (i = 0; i < 12; i++)\n        if (!strncmp(month_names[i], month, 3))\n            return i;\n    return -1;\n}", "target": 2, "idx": 11148}
{"commit_id": "a9697dfeb672b0b9412c00c7d36d801e27ec85cb", "project": "DCMTK/dcmtk", "func": "static OFCondition\nparseUserInfo(DUL_USERINFO * userInfo,\n              unsigned char *buf,\n              unsigned long *itemLength,\n              unsigned char typeRQorAC,\n              unsigned long availData /* bytes left for in this PDU */)\n{\n    unsigned short userLength;\n    unsigned long length;\n    OFCondition cond = EC_Normal;\n    PRV_SCUSCPROLE *role;\n    SOPClassExtendedNegotiationSubItem *extNeg = NULL;\n    UserIdentityNegotiationSubItem *usrIdent = NULL;\n\n    // minimum allowed size is 4 byte (case where the length of the user data is 0),\n    // else we read past the buffer end\n    if (availData < 4)\n        return makeLengthError(\"user info\", availData, 4);\n\n    // skip item type (50H) field\n    userInfo->type = *buf++;\n    // skip unused (\"reserved\") field\n    userInfo->rsv1 = *buf++;\n    // get and remember announced length of user data\n    EXTRACT_SHORT_BIG(buf, userInfo->length);\n    // .. and skip over the two length field bytes\n    buf += 2;\n\n    // userLength contains announced length of full user item structure,\n    // will be used here to count down the available data later\n    userLength = userInfo->length;\n    // itemLength contains full length of the user item including the 4 bytes extra header (type, reserved + 2 for length)\n    *itemLength = userLength + 4;\n\n    // does this item claim to be larger than the available data?\n    if (availData < *itemLength)\n        return makeLengthError(\"user info\", availData, 0, userLength);\n\n    DCMNET_TRACE(\"Parsing user info field (\"\n            << STD_NAMESPACE hex << STD_NAMESPACE setfill('0') << STD_NAMESPACE setw(2) << (unsigned int)userInfo->type\n            << STD_NAMESPACE dec << \"), Length: \" << (unsigned long)userInfo->length);\n    // parse through different types of user items as long as we have data\n    while (userLength > 0) {\n        DCMNET_TRACE(\"Parsing remaining \" << (long)userLength << \" bytes of User Information\" << OFendl\n                << \"Next item type: \"\n                << STD_NAMESPACE hex << STD_NAMESPACE setfill('0') << STD_NAMESPACE setw(2) << (unsigned int)*buf);\n        switch (*buf) {\n        case DUL_TYPEMAXLENGTH:\n            cond = parseMaxPDU(&userInfo->maxLength, buf, &length, userLength);\n            if (cond.bad())\n                return cond;\n            buf += length;\n            if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n              return makeLengthError(\"maximum length sub-item\", userLength, length);\n            DCMNET_TRACE(\"Successfully parsed Maximum PDU Length\");\n            break;\n        case DUL_TYPEIMPLEMENTATIONCLASSUID:\n            cond = parseSubItem(&userInfo->implementationClassUID,\n                                buf, &length, userLength);\n            if (cond.bad())\n                return cond;\n            buf += length;\n            if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n              return makeLengthError(\"Implementation Class UID sub-item\", userLength, length);\n            break;\n\n        case DUL_TYPEASYNCOPERATIONS:\n            cond = parseDummy(buf, &length, userLength);\n            if (cond.bad())\n                return cond;\n            buf += length;\n            if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n              return makeLengthError(\"asynchronous operation user item type\", userLength, length);\n            break;\n        case DUL_TYPESCUSCPROLE:\n            role = (PRV_SCUSCPROLE*)malloc(sizeof(PRV_SCUSCPROLE));\n            if (role == NULL) return EC_MemoryExhausted;\n            cond = parseSCUSCPRole(role, buf, &length, userLength);\n            if (cond.bad())\n            {\n                free(role);\n                return cond;\n            }\n            LST_Enqueue(&userInfo->SCUSCPRoleList, (LST_NODE*)role);\n            buf += length;\n            if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n              return makeLengthError(\"SCP/SCU Role Selection sub-item\", userLength, length);\n            break;\n        case DUL_TYPEIMPLEMENTATIONVERSIONNAME:\n            cond = parseSubItem(&userInfo->implementationVersionName,\n                                buf, &length, userLength);\n            if (cond.bad()) return cond;\n            buf += length;\n            if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n              return makeLengthError(\"Implementation Version Name structure\", userLength, length);\n            break;\n\n        case DUL_TYPESOPCLASSEXTENDEDNEGOTIATION:\n            /* parse an extended negotiation sub-item */\n            extNeg = new SOPClassExtendedNegotiationSubItem;\n            if (extNeg == NULL)  return EC_MemoryExhausted;\n            cond = parseExtNeg(extNeg, buf, &length, userLength);\n            if (cond.bad()) return cond;\n            if (userInfo->extNegList == NULL)\n            {\n                userInfo->extNegList = new SOPClassExtendedNegotiationSubItemList;\n                if (userInfo->extNegList == NULL)  return EC_MemoryExhausted;\n            }\n            userInfo->extNegList->push_back(extNeg);\n            buf += length;\n            if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n              return makeLengthError(\"SOP Class Extended Negotiation sub-item\", userLength, length);\n            break;\n\n        case DUL_TYPENEGOTIATIONOFUSERIDENTITY_REQ:\n        case DUL_TYPENEGOTIATIONOFUSERIDENTITY_ACK:\n          if (typeRQorAC == DUL_TYPEASSOCIATERQ)\n            usrIdent = new UserIdentityNegotiationSubItemRQ();\n          else // assume DUL_TYPEASSOCIATEAC\n            usrIdent = new UserIdentityNegotiationSubItemAC();\n          if (usrIdent == NULL) return EC_MemoryExhausted;\n          cond = usrIdent->parseFromBuffer(buf, length /*return value*/, userLength);\n          if (cond.bad())\n          {\n            delete usrIdent;\n            return cond;\n          }\n          userInfo->usrIdent = usrIdent;\n          buf += length;\n          if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n            return makeLengthError(\"User Identity sub-item\", userLength, length);\n          break;\n        default:\n            // we hit an unknown user item that is not defined in the standard\n            // or still unknown to DCMTK\n            cond = parseDummy(buf, &length /* returns bytes \"handled\" by parseDummy */, userLength /* data available in bytes for user item */);\n            if (cond.bad())\n              return cond;\n            // skip the bytes read\n            buf += length;\n            // subtract bytes of parsed data from available data bytes\n            if (OFstatic_cast(unsigned short, length) != length\n                || !OFStandard::safeSubtract(userLength, OFstatic_cast(unsigned short, length), userLength))\n              return makeUnderflowError(\"unknown user item\", userLength, length);\n            break;\n        }\n    }\n\n    return EC_Normal;\n}", "target": 2, "idx": 11149}
{"commit_id": "5408a6d93f45bf1f7acd9ae5d44e0ebd77379e98", "project": "pcmacdon/jsish", "func": "static Jsi_RC jsi_ArrayConcatCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    Jsi_RC rc = JSI_OK;\n    int curlen, argc, nsiz;\n    Jsi_Obj *obj, *nobj;\n    Jsi_Value *va;\n\n    obj = _this->d.obj;\n    \n    argc = Jsi_ValueGetLength(interp, args);\n    curlen = jsi_SizeOfArray(interp, obj);\n    Jsi_ObjListifyArray(interp, obj);\n   \n    nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    nsiz = obj->arrMaxSize;\n    if (nsiz<=0) nsiz = 100;\n    if (Jsi_ObjArraySizer(interp, nobj, nsiz+1) <= 0) {\n        rc = JSI_ERROR;\n        Jsi_LogError(\"index too large: %d\", nsiz+1);\n        goto bail;\n    }\n\n    int i, j, m;\n    for (i = 0; i<curlen; i++)\n    {\n        if (!obj->arr[i]) continue;\n        nobj->arr[i] = NULL;\n        Jsi_ValueDup2(interp, nobj->arr+i, obj->arr[i]);\n    }\n    m = i;\n    for (i = 0; i < argc; i++) {\n         va = Jsi_ValueArrayIndex(interp, args, i);\n         if (va->vt == JSI_VT_OBJECT && Jsi_ObjIsArray(interp, va->d.obj)) {\n            int margc = Jsi_ValueGetLength(interp, va);\n            Jsi_Obj *mobj = va->d.obj;\n            Jsi_ObjListifyArray(interp, mobj);\n            if (Jsi_ObjArraySizer(interp, nobj, curlen += margc) <= 0) {\n                rc = JSI_ERROR;\n                Jsi_LogError(\"index too large: %d\", curlen);\n                goto bail;\n            }\n            for (j = 0; j<margc; j++, m++)\n            {\n                if (!mobj->arr[j]) continue;\n                nobj->arr[m] = NULL;\n                Jsi_ValueDup2(interp, nobj->arr+m, mobj->arr[j]);\n            }\n        } else {\n            if (Jsi_ObjArraySizer(interp, nobj, ++curlen) <= 0) {\n                rc = JSI_ERROR;\n                Jsi_LogError(\"index too large: %d\", curlen);\n                goto bail;\n            }\n            nobj->arr[m] = NULL;\n            Jsi_ValueDup2(interp, nobj->arr+m++, va);\n       }\n    }\n    Jsi_ObjSetLength(interp, nobj, curlen);\n    Jsi_ValueMakeArrayObject(interp, ret, nobj);\n    return JSI_OK;\n        \nbail:\n    Jsi_ValueMakeNull(interp, ret);\n    return rc;\n}", "target": 3, "idx": 11150}
{"commit_id": "2bdad6126778f907c0b98002bfebf0e611a3f5db", "project": "vim", "func": "static char_u *\nget_one_sourceline(source_cookie_T *sp)\n{\n    garray_T\t\tga;\n    int\t\t\tlen;\n    int\t\t\tc;\n    char_u\t\t*buf;\n#ifdef USE_CRNL\n    int\t\t\thas_cr;\t\t// CR-LF found\n#endif\n    int\t\t\thave_read = FALSE;\n\n    // use a growarray to store the sourced line\n    ga_init2(&ga, 1, 250);\n\n    // Loop until there is a finished line (or end-of-file).\n    ++sp->sourcing_lnum;\n    for (;;)\n    {\n\t// make room to read at least 120 (more) characters\n\tif (ga_grow(&ga, 120) == FAIL)\n\t    break;\n\tif (sp->source_from_buf)\n\t{\n\t    if (sp->buf_lnum >= sp->buflines.ga_len)\n\t\tbreak;\t\t    // all the lines are processed\n\t    ga_concat(&ga, ((char_u **)sp->buflines.ga_data)[sp->buf_lnum]);\n\t    sp->buf_lnum++;\n\t    if (ga_grow(&ga, 1) == FAIL)\n\t\tbreak;\n\t    buf = (char_u *)ga.ga_data;\n\t    buf[ga.ga_len++] = NUL;\n\t}\n\telse\n\t{\n\t    buf = (char_u *)ga.ga_data;\n\t    if (fgets((char *)buf + ga.ga_len, ga.ga_maxlen - ga.ga_len,\n\t\t\tsp->fp) == NULL)\n\t\tbreak;\n\t}\n\tlen = ga.ga_len + (int)STRLEN(buf + ga.ga_len);\n#ifdef USE_CRNL\n\t// Ignore a trailing CTRL-Z, when in Dos mode.\tOnly recognize the\n\t// CTRL-Z by its own, or after a NL.\n\tif (\t   (len == 1 || (len >= 2 && buf[len - 2] == '\\n'))\n\t\t&& sp->fileformat == EOL_DOS\n\t\t&& buf[len - 1] == Ctrl_Z)\n\t{\n\t    buf[len - 1] = NUL;\n\t    break;\n\t}\n#endif\n\n\thave_read = TRUE;\n\tga.ga_len = len;\n\n\t// If the line was longer than the buffer, read more.\n\tif (ga.ga_maxlen - ga.ga_len == 1 && buf[len - 1] != '\\n')\n\t    continue;\n\n\tif (len >= 1 && buf[len - 1] == '\\n')\t// remove trailing NL\n\t{\n#ifdef USE_CRNL\n\t    has_cr = (len >= 2 && buf[len - 2] == '\\r');\n\t    if (sp->fileformat == EOL_UNKNOWN)\n\t    {\n\t\tif (has_cr)\n\t\t    sp->fileformat = EOL_DOS;\n\t\telse\n\t\t    sp->fileformat = EOL_UNIX;\n\t    }\n\n\t    if (sp->fileformat == EOL_DOS)\n\t    {\n\t\tif (has_cr)\t    // replace trailing CR\n\t\t{\n\t\t    buf[len - 2] = '\\n';\n\t\t    --len;\n\t\t    --ga.ga_len;\n\t\t}\n\t\telse\t    // lines like \":map xx yy^M\" will have failed\n\t\t{\n\t\t    if (!sp->error)\n\t\t    {\n\t\t\tmsg_source(HL_ATTR(HLF_W));\n\t\t\temsg(_(\"W15: Warning: Wrong line separator, ^M may be missing\"));\n\t\t    }\n\t\t    sp->error = TRUE;\n\t\t    sp->fileformat = EOL_UNIX;\n\t\t}\n\t    }\n#endif\n\t    // The '\\n' is escaped if there is an odd number of ^V's just\n\t    // before it, first set \"c\" just before the 'V's and then check\n\t    // len&c parities (is faster than ((len-c)%2 == 0)) -- Acevedo\n\t    for (c = len - 2; c >= 0 && buf[c] == Ctrl_V; c--)\n\t\t;\n\t    if ((len & 1) != (c & 1))\t// escaped NL, read more\n\t    {\n\t\t++sp->sourcing_lnum;\n\t\tcontinue;\n\t    }\n\n\t    buf[len - 1] = NUL;\t\t// remove the NL\n\t}\n\n\t// Check for ^C here now and then, so recursive :so can be broken.\n\tline_breakcheck();\n\tbreak;\n    }\n\n    if (have_read)\n\treturn (char_u *)ga.ga_data;\n\n    vim_free(ga.ga_data);\n    return NULL;\n}", "target": 2, "idx": 11151}
{"commit_id": "3fe905cf674f8dbac8a89e58cee1b4850abf9530", "project": "Matthias-Wandel/jhead", "func": "static int RegenerateThumbnail(const char * FileName)\n{\n    char ThumbnailGenCommand[PATH_MAX*2+50];\n    if (ImageInfo.ThumbnailOffset == 0 || ImageInfo.ThumbnailAtEnd == FALSE){\n        // There is no thumbnail, or the thumbnail is not at the end.\n        return FALSE;\n    }\n\n    // Disallow characters in the filename that could be used to execute arbitrary\n    // shell commands with system() below.\n    if(strpbrk(FileName, \"\\\";'&|`\")) {\n        ErrNonfatal(\"Filename has invalid characters.\", 0, 0);\n        return FALSE;\n    }\n\n    snprintf(ThumbnailGenCommand, sizeof(ThumbnailGenCommand),\n        \"mogrify -thumbnail %dx%d -quality 80 \\\"%s\\\"\",\n        RegenThumbnail, RegenThumbnail, FileName);\n\n    if (system(ThumbnailGenCommand) == 0){\n        // Put the thumbnail back in the header\n        return ReplaceThumbnail(FileName);\n    }else{\n        ErrFatal(\"Unable to run 'mogrify' command\");\n        return FALSE;\n    }\n}", "target": 2, "idx": 11152}
{"commit_id": "76719d21eb1aff3ae8d2d4536d9dc118107631b4", "project": "wireshark", "func": "void\nproto_register_cbor(void)\n{\n\tstatic hf_register_info hf[] = {\n\t\t{ &hf_cbor_item_major_type,\n\t\t  { \"Major Type\", \"cbor.item.major_type\",\n\t\t    FT_UINT8, BASE_DEC, VALS(major_type_vals), 0xe0,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_cbor_item_integer_size,\n\t\t  { \"Size\", \"cbor.item.size\",\n\t\t    FT_UINT8, BASE_DEC, VALS(integer_size_vals), 0x1f,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_cbor_item_length_size,\n\t\t  { \"Size\", \"cbor.item.size\",\n\t\t    FT_UINT8, BASE_DEC, VALS(length_size_vals), 0x1f,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_cbor_item_length5,\n\t\t  { \"Length\", \"cbor.item.length5\",\n\t\t    FT_UINT8, BASE_DEC, NULL, 0x1f,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_cbor_item_length,\n\t\t  { \"Length\", \"cbor.item.length\",\n\t\t    FT_UINT64, BASE_DEC, NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_cbor_item_items5,\n\t\t  { \"Items\", \"cbor.item.items5\",\n\t\t    FT_UINT8, BASE_DEC, NULL, 0x1f,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_cbor_item_items,\n\t\t  { \"Items\", \"cbor.item.items\",\n\t\t    FT_UINT64, BASE_DEC, NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_cbor_item_pairs5,\n\t\t  { \"Pairs\", \"cbor.item.pairs\",\n\t\t    FT_UINT8, BASE_DEC, NULL, 0x1f,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_cbor_item_pairs,\n\t\t  { \"Pairs\", \"cbor.item.pairs\",\n\t\t    FT_UINT64, BASE_DEC, NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_cbor_item_float_simple_type,\n\t\t  { \"Type\", \"cbor.item.float_simple_type\",\n\t\t    FT_UINT8, BASE_DEC, VALS(float_simple_type_vals), 0x1f,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_cbor_item_unsigned_integer,\n\t\t  { \"Unsigned Integer\", \"cbor.item.unsigned_integer\",\n\t\t    FT_NONE, BASE_NONE, NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_cbor_item_negative_integer,\n\t\t  { \"Negative Integer\", \"cbor.item.negative_integer\",\n\t\t    FT_NONE, BASE_NONE, NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_cbor_item_text_string,\n\t\t  { \"Text String\", \"cbor.item.textstring\",\n\t\t    FT_NONE, BASE_NONE, NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_cbor_item_byte_string,\n\t\t  { \"Byte String\", \"cbor.item.bytestring\",\n\t\t    FT_NONE, BASE_NONE, NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_cbor_item_array,\n\t\t  { \"Array\", \"cbor.item.array\",\n\t\t    FT_NONE, BASE_NONE, NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_cbor_item_map,\n\t\t  { \"Map\", \"cbor.item.map\",\n\t\t    FT_NONE, BASE_NONE, NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_cbor_item_tag,\n\t\t  { \"Tag\", \"cbor.item.tag\",\n\t\t    FT_NONE, BASE_NONE, NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_cbor_item_float_simple,\n\t\t  { \"Floating-point or Simple\", \"cbor.item.float_or_simple\",\n\t\t    FT_NONE, BASE_NONE, NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_cbor_type_uint5,\n\t\t  { \"Unsigned Integer\", \"cbor.type.uint\",\n\t\t    FT_UINT8, BASE_DEC, NULL, 0x1f,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_cbor_type_uint,\n\t\t  { \"Unsigned Integer\", \"cbor.type.uint\",\n\t\t    FT_UINT64, BASE_DEC, NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_cbor_type_nint,\n\t\t  { \"Negative Integer\", \"cbor.type.nint\",\n\t\t    FT_INT64, BASE_DEC, NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_cbor_type_byte_string,\n\t\t  { \"Byte String\", \"cbor.type.bytestring\",\n\t\t    FT_BYTES, BASE_NONE, NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_cbor_type_byte_string_indef,\n\t\t  { \"Byte String (indefinite length)\", \"cbor.type.bytestring.indef\",\n\t\t    FT_NONE, BASE_NONE, NULL, 0x0,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_cbor_type_text_string,\n\t\t  { \"Text String\", \"cbor.type.textstring\",\n\t\t    FT_STRING, BASE_NONE, NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_cbor_type_text_string_indef,\n\t\t  { \"Text String (indefinite length)\", \"cbor.type.textstring.indef\",\n\t\t    FT_NONE, BASE_NONE, NULL, 0x0,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_cbor_type_tag5,\n\t\t  { \"Tag\", \"cbor.type.tag\",\n\t\t    FT_UINT8, BASE_DEC, VALS(tag32_vals), 0x1f,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_cbor_type_tag,\n\t\t  { \"Tag\", \"cbor.type.tag\",\n\t\t    FT_UINT64, BASE_DEC|BASE_VAL64_STRING, VALS64(tag64_vals), 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_cbor_type_simple_data5,\n\t\t  { \"Simple data\", \"cbor.type.simple_data\",\n\t\t    FT_UINT8, BASE_DEC, VALS(vals_simple_data), 0x1f,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_cbor_type_simple_data8,\n\t\t  { \"Simple data\", \"cbor.type.simple_data\",\n\t\t    FT_UINT8, BASE_DEC, VALS(vals_simple_data), 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_cbor_type_float16,\n\t\t  { \"Float 16 Bit\", \"cbor.type.float16\",\n\t\t    FT_FLOAT, BASE_NONE, NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_cbor_type_float32,\n\t\t  { \"Float 32 Bit\", \"cbor.type.float32\",\n\t\t    FT_FLOAT, BASE_NONE, NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_cbor_type_float64,\n\t\t  { \"Float 64 Bit\", \"cbor.type.float64\",\n\t\t    FT_DOUBLE, BASE_NONE, NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t};\n\n\tstatic gint *ett[] = {\n\t\t&ett_cbor,\n\t\t&ett_cbor_type,\n\t\t&ett_cbor_unsigned_integer,\n\t\t&ett_cbor_negative_integer,\n\t\t&ett_cbor_byte_string,\n\t\t&ett_cbor_byte_string_indef,\n\t\t&ett_cbor_text_string,\n\t\t&ett_cbor_text_string_indef,\n\t\t&ett_cbor_array,\n\t\t&ett_cbor_map,\n\t\t&ett_cbor_tag,\n\t\t&ett_cbor_float_simple\n\t};\n\n\tstatic ei_register_info ei[] = {\n\t\t{ &ei_cbor_invalid_minor_type,\n\t\t  { \"cbor.invalid_minor_type\", PI_MALFORMED, PI_WARN, \"Invalid minor type\", EXPFILL }},\n\t\t{ &ei_cbor_invalid_element,\n\t\t  { \"cbor.invalid_element\", PI_MALFORMED, PI_WARN, \"Invalid element\", EXPFILL }},\n\t\t{ &ei_cbor_too_long_length,\n\t\t  { \"cbor.too_long_length\", PI_MALFORMED, PI_WARN, \"Too long length\", EXPFILL }},\n\t\t{ &ei_cbor_max_recursion_depth_reached,\n\t\t  { \"cbor.max_recursion_depth_reached\", PI_PROTOCOL, PI_WARN, \"Maximum allowed recursion depth reached. Dissection stopped.\", EXPFILL }},\n\t};\n\n\texpert_module_t *expert_cbor;\n\n\tproto_cbor = proto_register_protocol(\"Concise Binary Object Representation\", \"CBOR\", \"cbor\");\n\tproto_register_field_array(proto_cbor, hf, array_length(hf));\n\tproto_register_subtree_array(ett, array_length(ett));\n\texpert_cbor = expert_register_protocol(proto_cbor);\n\texpert_register_field_array(expert_cbor, ei, array_length(ei));\n\n\tcbor_handle = register_dissector(\"cbor\", dissect_cbor, proto_cbor);\n\tcborseq_handle = register_dissector(\"cborseq\", dissect_cborseq, proto_cbor);\n}", "target": 2, "idx": 11153}
{"commit_id": "769714fcb569e7a4faff9530a2d9ac1f9d6e5680", "project": "keepkey/keepkey-firmware", "func": "void recovery_cipher_init(bool passphrase_protection, bool pin_protection,\n                          const char *language, const char *label, bool _enforce_wordlist,\n                          uint32_t _auto_lock_delay_ms, uint32_t _u2f_counter, bool _dry_run)\n{\n    enforce_wordlist = _enforce_wordlist;\n    dry_run = _dry_run;\n\n    if (!dry_run) {\n        if (pin_protection) {\n            if (!change_pin()) {\n                recovery_abort();\n                fsm_sendFailure(FailureType_Failure_ActionCancelled, \"PINs do not match\");\n                layoutHome();\n                return;\n            }\n        } else {\n            storage_setPin(\"\");\n        }\n\n        storage_setPassphraseProtected(passphrase_protection);\n        storage_setLanguage(language);\n        storage_setLabel(label);\n        storage_setAutoLockDelayMs(_auto_lock_delay_ms);\n        storage_setU2FCounter(_u2f_counter);\n    } else if (!pin_protect(\"Enter Your PIN\")) {\n        layoutHome();\n        return;\n    }\n\n    if (!confirm(ButtonRequestType_ButtonRequest_Other,\n                 dry_run ? \"Recovery Dry Run\" : \"Recovery\",\n                 \"When entering your recovery seed, use the substitution cipher \"\n                 \"and check that each word shows up correctly on the screen.\")) {\n        fsm_sendFailure(FailureType_Failure_ActionCancelled, \"Recovery cancelled\");\n        if (!dry_run)\n            storage_reset();\n        layoutHome();\n        return;\n    }\n\n    /* Clear mnemonic */\n    memset(mnemonic, 0, sizeof(mnemonic) / sizeof(char));\n\n    /* Set to recovery cipher mode and generate and show next cipher */\n    awaiting_character = true;\n    recovery_started = true;\n    next_character();\n}", "target": 2, "idx": 11154}
{"commit_id": "dfadac5e2b85dfed5076434e4152aed9fc4c80ac", "project": "chromium", "func": "v8::Local<v8::Value> V8ValueConverterImpl::ToV8Object(\n    v8::Isolate* isolate,\n    v8::Local<v8::Object> creation_context,\n    const base::DictionaryValue* val) const {\n  v8::Local<v8::Object> result(v8::Object::New(isolate));\n\n  // TODO(robwu): Callers should pass in the context.\n  v8::Local<v8::Context> context = isolate->GetCurrentContext();\n\n  for (base::DictionaryValue::Iterator iter(*val);\n       !iter.IsAtEnd(); iter.Advance()) {\n    const std::string& key = iter.key();\n    v8::Local<v8::Value> child_v8 =\n        ToV8ValueImpl(isolate, creation_context, &iter.value());\n    CHECK(!child_v8.IsEmpty());\n\n    v8::Maybe<bool> maybe = result->CreateDataProperty(\n        context,\n        v8::String::NewFromUtf8(isolate, key.c_str(), v8::String::kNormalString,\n                                key.length()),\n        child_v8);\n    if (!maybe.IsJust() || !maybe.FromJust())\n      LOG(ERROR) << \"Failed to set property with key \" << key;\n  }\n\n  return result;\n}", "target": 2, "idx": 11155}
{"commit_id": "160b1a618ad94988410dc81fce9189fcda5b7ff4", "project": "binutils-gdb", "func": "static void\nprint_symbol (bfd *        abfd,\n\t      asymbol *    sym,\n\t      bfd_vma      ssize,\n\t      bfd *        archive_bfd)\n{\n  symbol_info syminfo;\n  struct extended_symbol_info info;\n\n  PROGRESS (1);\n\n  format->print_symbol_filename (archive_bfd, abfd);\n\n  bfd_get_symbol_info (abfd, sym, &syminfo);\n\n  info.sinfo = &syminfo;\n  info.ssize = ssize;\n  /* Synthetic symbols do not have a full symbol type set of data available.\n     Nor do bfd/section.c:global_syms like *ABS*.  */\n  if ((sym->flags & (BSF_SECTION_SYM | BSF_SYNTHETIC)) != 0)\n    {\n      info.elfinfo = NULL;\n      info.coffinfo = NULL;\n    }\n  else\n    {\n      info.elfinfo = elf_symbol_from (abfd, sym);\n      info.coffinfo = coff_symbol_from (sym);\n    }\n\n  format->print_symbol_info (&info, abfd);\n\n  if (with_symbol_versions)\n    {\n      const char *  version_string = NULL;\n      bfd_boolean   hidden = FALSE;\n\n      if ((sym->flags & (BSF_SECTION_SYM | BSF_SYNTHETIC)) == 0)\n\tversion_string = bfd_get_symbol_version_string (abfd, sym, &hidden);\n\n      if (bfd_is_und_section (bfd_get_section (sym)))\n\thidden = TRUE;\n\n      if (version_string && *version_string != '\\0')\n\tprintf (hidden ? \"@%s\" : \"@@%s\", version_string);\n    }\n\n  if (line_numbers)\n    {\n      static asymbol **syms;\n      static long symcount;\n      const char *filename, *functionname;\n      unsigned int lineno;\n\n      /* We need to get the canonical symbols in order to call\n         bfd_find_nearest_line.  This is inefficient, but, then, you\n         don't have to use --line-numbers.  */\n      if (abfd != lineno_cache_bfd && syms != NULL)\n\t{\n\t  free (syms);\n\t  syms = NULL;\n\t}\n      if (syms == NULL)\n\t{\n\t  long symsize;\n\n\t  symsize = bfd_get_symtab_upper_bound (abfd);\n\t  if (symsize < 0)\n\t    bfd_fatal (bfd_get_filename (abfd));\n\t  syms = (asymbol **) xmalloc (symsize);\n\t  symcount = bfd_canonicalize_symtab (abfd, syms);\n\t  if (symcount < 0)\n\t    bfd_fatal (bfd_get_filename (abfd));\n\t  lineno_cache_bfd = abfd;\n\t}\n\n      if (bfd_is_und_section (bfd_get_section (sym)))\n\t{\n\t  static asection **secs;\n\t  static arelent ***relocs;\n\t  static long *relcount;\n\t  static unsigned int seccount;\n\t  unsigned int i;\n\t  const char *symname;\n\n\t  /* For an undefined symbol, we try to find a reloc for the\n             symbol, and print the line number of the reloc.  */\n\t  if (abfd != lineno_cache_rel_bfd && relocs != NULL)\n\t    {\n\t      for (i = 0; i < seccount; i++)\n\t\tif (relocs[i] != NULL)\n\t\t  free (relocs[i]);\n\t      free (secs);\n\t      free (relocs);\n\t      free (relcount);\n\t      secs = NULL;\n\t      relocs = NULL;\n\t      relcount = NULL;\n\t    }\n\n\t  if (relocs == NULL)\n\t    {\n\t      struct get_relocs_info rinfo;\n\n\t      seccount = bfd_count_sections (abfd);\n\n\t      secs = (asection **) xmalloc (seccount * sizeof *secs);\n\t      relocs = (arelent ***) xmalloc (seccount * sizeof *relocs);\n\t      relcount = (long *) xmalloc (seccount * sizeof *relcount);\n\n\t      rinfo.secs = secs;\n\t      rinfo.relocs = relocs;\n\t      rinfo.relcount = relcount;\n\t      rinfo.syms = syms;\n\t      bfd_map_over_sections (abfd, get_relocs, (void *) &rinfo);\n\t      lineno_cache_rel_bfd = abfd;\n\t    }\n\n\t  symname = bfd_asymbol_name (sym);\n\t  for (i = 0; i < seccount; i++)\n\t    {\n\t      long j;\n\n\t      for (j = 0; j < relcount[i]; j++)\n\t\t{\n\t\t  arelent *r;\n\n\t\t  r = relocs[i][j];\n\t\t  if (r->sym_ptr_ptr != NULL\n\t\t      && (*r->sym_ptr_ptr)->section == sym->section\n\t\t      && (*r->sym_ptr_ptr)->value == sym->value\n\t\t      && strcmp (symname,\n\t\t\t\t bfd_asymbol_name (*r->sym_ptr_ptr)) == 0\n\t\t      && bfd_find_nearest_line (abfd, secs[i], syms,\n\t\t\t\t\t\tr->address, &filename,\n\t\t\t\t\t\t&functionname, &lineno)\n\t\t      && filename != NULL)\n\t\t    {\n\t\t      /* We only print the first one we find.  */\n\t\t      printf (\"\\t%s:%u\", filename, lineno);\n\t\t      i = seccount;\n\t\t      break;\n\t\t    }\n\t\t}\n\t    }\n\t}\n      else if (bfd_get_section (sym)->owner == abfd)\n\t{\n\t  if ((bfd_find_line (abfd, syms, sym, &filename, &lineno)\n\t       || bfd_find_nearest_line (abfd, bfd_get_section (sym),\n\t\t\t\t\t syms, sym->value, &filename,\n\t\t\t\t\t &functionname, &lineno))\n\t      && filename != NULL\n\t      && lineno != 0)\n\t    printf (\"\\t%s:%u\", filename, lineno);\n\t}\n    }\n\n  putchar ('\\n');\n}", "target": 2, "idx": 11156}
{"commit_id": "c1e5ac16e77a21f87bdf3bc4dea61b037a17dddb", "project": "xkbcommon/libxkbcommon", "func": "ExprDef *\nExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)\n{\n    unsigned nSyms = darray_size(expr->keysym_list.syms);\n    unsigned numEntries = darray_size(append->keysym_list.syms);\n\n    darray_append(expr->keysym_list.symsMapIndex, nSyms);\n    darray_append(expr->keysym_list.symsNumEntries, numEntries);\n    darray_concat(expr->keysym_list.syms, append->keysym_list.syms);\n\n    FreeStmt((ParseCommon *) append);\n\n    return expr;\n}", "target": 2, "idx": 11157}
{"commit_id": "b534e304568585707c4a92422aeca25cf908ff02", "project": "the-tcpdump-group/tcpdump", "func": "u_int\njuniper_atm2_print(netdissect_options *ndo,\n                   const struct pcap_pkthdr *h, register const u_char *p)\n{\n        int llc_hdrlen;\n\n        struct juniper_l2info_t l2info;\n\n        l2info.pictype = DLT_JUNIPER_ATM2;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n\n        p+=l2info.header_len;\n\n        if (l2info.cookie[7] & ATM2_PKT_TYPE_MASK) { /* OAM cell ? */\n            oam_print(ndo, p, l2info.length, ATM_OAM_NOHEC);\n            return l2info.header_len;\n        }\n\n        ND_TCHECK2(p[0], 3);\n        if (EXTRACT_24BITS(p) == 0xfefe03 || /* NLPID encaps ? */\n            EXTRACT_24BITS(p) == 0xaaaa03) { /* SNAP encaps ? */\n\n            llc_hdrlen = llc_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL);\n            if (llc_hdrlen > 0)\n                return l2info.header_len;\n        }\n\n        if (l2info.direction != JUNIPER_BPF_PKT_IN && /* ether-over-1483 encaps ? */\n            (EXTRACT_32BITS(l2info.cookie) & ATM2_GAP_COUNT_MASK)) {\n            ether_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL);\n            return l2info.header_len;\n        }\n\n        if (p[0] == 0x03) { /* Cisco style NLPID encaps ? */\n            isoclns_print(ndo, p + 1, l2info.length - 1);\n            /* FIXME check if frame was recognized */\n            return l2info.header_len;\n        }\n\n        if(juniper_ppp_heuristic_guess(ndo, p, l2info.length) != 0) /* PPPoA vcmux encaps ? */\n            return l2info.header_len;\n\n        if (ip_heuristic_guess(ndo, p, l2info.length) != 0) /* last try - vcmux encaps ? */\n            return l2info.header_len;\n\n\treturn l2info.header_len;\n\ntrunc:\n\tND_PRINT((ndo, \"[|juniper_atm2]\"));\n\treturn l2info.header_len;\n}", "target": 3, "idx": 11158}
{"commit_id": "96398560f26aa07e8f2969d73c8197e6a6d10407", "project": "torvalds/linux", "func": "static int qdisc_graft(struct net_device *dev, struct Qdisc *parent,\n\t\t       struct sk_buff *skb, struct nlmsghdr *n, u32 classid,\n\t\t       struct Qdisc *new, struct Qdisc *old,\n\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct Qdisc *q = old;\n\tstruct net *net = dev_net(dev);\n\n\tif (parent == NULL) {\n\t\tunsigned int i, num_q, ingress;\n\n\t\tingress = 0;\n\t\tnum_q = dev->num_tx_queues;\n\t\tif ((q && q->flags & TCQ_F_INGRESS) ||\n\t\t    (new && new->flags & TCQ_F_INGRESS)) {\n\t\t\tnum_q = 1;\n\t\t\tingress = 1;\n\t\t\tif (!dev_ingress_queue(dev)) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Device does not have an ingress queue\");\n\t\t\t\treturn -ENOENT;\n\t\t\t}\n\t\t}\n\n\t\tif (dev->flags & IFF_UP)\n\t\t\tdev_deactivate(dev);\n\n\t\tqdisc_offload_graft_root(dev, new, old, extack);\n\n\t\tif (new && new->ops->attach && !ingress)\n\t\t\tgoto skip;\n\n\t\tfor (i = 0; i < num_q; i++) {\n\t\t\tstruct netdev_queue *dev_queue = dev_ingress_queue(dev);\n\n\t\t\tif (!ingress)\n\t\t\t\tdev_queue = netdev_get_tx_queue(dev, i);\n\n\t\t\told = dev_graft_qdisc(dev_queue, new);\n\t\t\tif (new && i > 0)\n\t\t\t\tqdisc_refcount_inc(new);\n\n\t\t\tif (!ingress)\n\t\t\t\tqdisc_put(old);\n\t\t}\n\nskip:\n\t\tif (!ingress) {\n\t\t\told = rtnl_dereference(dev->qdisc);\n\t\t\tif (new && !new->ops->attach)\n\t\t\t\tqdisc_refcount_inc(new);\n\t\t\trcu_assign_pointer(dev->qdisc, new ? : &noop_qdisc);\n\n\t\t\tnotify_and_destroy(net, skb, n, classid, old, new);\n\n\t\t\tif (new && new->ops->attach)\n\t\t\t\tnew->ops->attach(new);\n\t\t} else {\n\t\t\tnotify_and_destroy(net, skb, n, classid, old, new);\n\t\t}\n\n\t\tif (dev->flags & IFF_UP)\n\t\t\tdev_activate(dev);\n\t} else {\n\t\tconst struct Qdisc_class_ops *cops = parent->ops->cl_ops;\n\t\tunsigned long cl;\n\t\tint err;\n\n\t\t/* Only support running class lockless if parent is lockless */\n\t\tif (new && (new->flags & TCQ_F_NOLOCK) && !(parent->flags & TCQ_F_NOLOCK))\n\t\t\tqdisc_clear_nolock(new);\n\n\t\tif (!cops || !cops->graft)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tcl = cops->find(parent, classid);\n\t\tif (!cl) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Specified class not found\");\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tif (new && new->ops == &noqueue_qdisc_ops) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Cannot assign noqueue to a class\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\terr = cops->graft(parent, cl, new, &old, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t\tnotify_and_destroy(net, skb, n, classid, old, new);\n\t}\n\treturn 0;\n}", "target": 1, "idx": 11159}
{"commit_id": "6aeb75e6adfaed16e58780309613a578fe1ee90b", "project": "torvalds/linux", "func": "static void change_port_settings(struct tty_struct *tty,\n\t\tstruct edgeport_port *edge_port, struct ktermios *old_termios)\n{\n\tstruct device *dev = &edge_port->port->dev;\n\tstruct ump_uart_config *config;\n\tint baud;\n\tunsigned cflag;\n\tint status;\n\tint port_number = edge_port->port->port_number;\n\n\tconfig = kmalloc (sizeof (*config), GFP_KERNEL);\n\tif (!config) {\n\t\ttty->termios = *old_termios;\n\t\treturn;\n\t}\n\n\tcflag = tty->termios.c_cflag;\n\n\tconfig->wFlags = 0;\n\n\t/* These flags must be set */\n\tconfig->wFlags |= UMP_MASK_UART_FLAGS_RECEIVE_MS_INT;\n\tconfig->wFlags |= UMP_MASK_UART_FLAGS_AUTO_START_ON_ERR;\n\tconfig->bUartMode = (__u8)(edge_port->bUartMode);\n\n\tswitch (cflag & CSIZE) {\n\tcase CS5:\n\t\t    config->bDataBits = UMP_UART_CHAR5BITS;\n\t\t    dev_dbg(dev, \"%s - data bits = 5\\n\", __func__);\n\t\t    break;\n\tcase CS6:\n\t\t    config->bDataBits = UMP_UART_CHAR6BITS;\n\t\t    dev_dbg(dev, \"%s - data bits = 6\\n\", __func__);\n\t\t    break;\n\tcase CS7:\n\t\t    config->bDataBits = UMP_UART_CHAR7BITS;\n\t\t    dev_dbg(dev, \"%s - data bits = 7\\n\", __func__);\n\t\t    break;\n\tdefault:\n\tcase CS8:\n\t\t    config->bDataBits = UMP_UART_CHAR8BITS;\n\t\t    dev_dbg(dev, \"%s - data bits = 8\\n\", __func__);\n\t\t\t    break;\n\t}\n\n\tif (cflag & PARENB) {\n\t\tif (cflag & PARODD) {\n\t\t\tconfig->wFlags |= UMP_MASK_UART_FLAGS_PARITY;\n\t\t\tconfig->bParity = UMP_UART_ODDPARITY;\n\t\t\tdev_dbg(dev, \"%s - parity = odd\\n\", __func__);\n\t\t} else {\n\t\t\tconfig->wFlags |= UMP_MASK_UART_FLAGS_PARITY;\n\t\t\tconfig->bParity = UMP_UART_EVENPARITY;\n\t\t\tdev_dbg(dev, \"%s - parity = even\\n\", __func__);\n\t\t}\n\t} else {\n\t\tconfig->bParity = UMP_UART_NOPARITY;\n\t\tdev_dbg(dev, \"%s - parity = none\\n\", __func__);\n\t}\n\n\tif (cflag & CSTOPB) {\n\t\tconfig->bStopBits = UMP_UART_STOPBIT2;\n\t\tdev_dbg(dev, \"%s - stop bits = 2\\n\", __func__);\n\t} else {\n\t\tconfig->bStopBits = UMP_UART_STOPBIT1;\n\t\tdev_dbg(dev, \"%s - stop bits = 1\\n\", __func__);\n\t}\n\n\t/* figure out the flow control settings */\n\tif (cflag & CRTSCTS) {\n\t\tconfig->wFlags |= UMP_MASK_UART_FLAGS_OUT_X_CTS_FLOW;\n\t\tconfig->wFlags |= UMP_MASK_UART_FLAGS_RTS_FLOW;\n\t\tdev_dbg(dev, \"%s - RTS/CTS is enabled\\n\", __func__);\n\t} else {\n\t\tdev_dbg(dev, \"%s - RTS/CTS is disabled\\n\", __func__);\n\t\trestart_read(edge_port);\n\t}\n\n\t/*\n\t * if we are implementing XON/XOFF, set the start and stop\n\t * character in the device\n\t */\n\tconfig->cXon  = START_CHAR(tty);\n\tconfig->cXoff = STOP_CHAR(tty);\n\n\t/* if we are implementing INBOUND XON/XOFF */\n\tif (I_IXOFF(tty)) {\n\t\tconfig->wFlags |= UMP_MASK_UART_FLAGS_IN_X;\n\t\tdev_dbg(dev, \"%s - INBOUND XON/XOFF is enabled, XON = %2x, XOFF = %2x\\n\",\n\t\t\t__func__, config->cXon, config->cXoff);\n\t} else\n\t\tdev_dbg(dev, \"%s - INBOUND XON/XOFF is disabled\\n\", __func__);\n\n\t/* if we are implementing OUTBOUND XON/XOFF */\n\tif (I_IXON(tty)) {\n\t\tconfig->wFlags |= UMP_MASK_UART_FLAGS_OUT_X;\n\t\tdev_dbg(dev, \"%s - OUTBOUND XON/XOFF is enabled, XON = %2x, XOFF = %2x\\n\",\n\t\t\t__func__, config->cXon, config->cXoff);\n\t} else\n\t\tdev_dbg(dev, \"%s - OUTBOUND XON/XOFF is disabled\\n\", __func__);\n\n\ttty->termios.c_cflag &= ~CMSPAR;\n\n\t/* Round the baud rate */\n\tbaud = tty_get_baud_rate(tty);\n\tif (!baud) {\n\t\t/* pick a default, any default... */\n\t\tbaud = 9600;\n\t} else {\n\t\t/* Avoid a zero divisor. */\n\t\tbaud = min(baud, 461550);\n\t\ttty_encode_baud_rate(tty, baud, baud);\n\t}\n\n\tedge_port->baud_rate = baud;\n\tconfig->wBaudRate = (__u16)((461550L + baud/2) / baud);\n\n\t/* FIXME: Recompute actual baud from divisor here */\n\n\tdev_dbg(dev, \"%s - baud rate = %d, wBaudRate = %d\\n\", __func__, baud, config->wBaudRate);\n\n\tdev_dbg(dev, \"wBaudRate:   %d\\n\", (int)(461550L / config->wBaudRate));\n\tdev_dbg(dev, \"wFlags:    0x%x\\n\", config->wFlags);\n\tdev_dbg(dev, \"bDataBits:   %d\\n\", config->bDataBits);\n\tdev_dbg(dev, \"bParity:     %d\\n\", config->bParity);\n\tdev_dbg(dev, \"bStopBits:   %d\\n\", config->bStopBits);\n\tdev_dbg(dev, \"cXon:        %d\\n\", config->cXon);\n\tdev_dbg(dev, \"cXoff:       %d\\n\", config->cXoff);\n\tdev_dbg(dev, \"bUartMode:   %d\\n\", config->bUartMode);\n\n\t/* move the word values into big endian mode */\n\tcpu_to_be16s(&config->wFlags);\n\tcpu_to_be16s(&config->wBaudRate);\n\n\tstatus = send_cmd(edge_port->port->serial->dev, UMPC_SET_CONFIG,\n\t\t\t\t(__u8)(UMPM_UART1_PORT + port_number),\n\t\t\t\t0, (__u8 *)config, sizeof(*config));\n\tif (status)\n\t\tdev_dbg(dev, \"%s - error %d when trying to write config to device\\n\",\n\t\t\t__func__, status);\n\tkfree(config);\n}", "target": 1, "idx": 11160}
{"commit_id": "48760768611f6766bf9e7378bb7cc66cebd6e49d", "project": "gpac", "func": "static Bool naludmx_create_hevc_decoder_config(GF_NALUDmxCtx *ctx, u8 **dsi, u32 *dsi_size, u8 **dsi_enh, u32 *dsi_enh_size, u32 *max_width, u32 *max_height, u32 *max_enh_width, u32 *max_enh_height, GF_Fraction *sar, Bool *has_hevc_base)\n{\n#ifndef GPAC_DISABLE_HEVC\n\tu32 i, count;\n\tu8 layer_id;\n\tBool first = GF_TRUE;\n\tBool first_lhvc = GF_TRUE;\n\tGF_HEVCConfig *cfg;\n\tGF_HEVCConfig *hvcc;\n\tGF_HEVCConfig *lvcc;\n\tu32 max_w, max_h, max_ew, max_eh;\n\n\t*has_hevc_base = GF_FALSE;\n\n\n\tmax_w = max_h = 0;\n\tmax_ew = max_eh = 0;\n\tsar->num = sar->den = 0;\n\n\t//check we have one pps or sps in base layer\n\tcount = gf_list_count(ctx->sps);\n\tif (!count) return GF_FALSE;\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = gf_list_get(ctx->sps, i);\n\t\tlayer_id = ((sl->data[0] & 0x1) << 5) | (sl->data[1] >> 3);\n\t\tif (!layer_id) {\n\t\t\t*has_hevc_base = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcount = gf_list_count(ctx->pps);\n\tif (!count) return GF_FALSE;\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = gf_list_get(ctx->pps, i);\n\t\tlayer_id = ((sl->data[0] & 0x1) << 5) | (sl->data[1] >> 3);\n\t\tif (!layer_id) {\n\t\t\t*has_hevc_base = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\thvcc = gf_odf_hevc_cfg_new();\n\tlvcc = gf_odf_hevc_cfg_new();\n\thvcc->nal_unit_size = ctx->nal_length;\n\tlvcc->nal_unit_size = ctx->nal_length;\n\tlvcc->is_lhvc = GF_TRUE;\n\n\t//assign vps first so that they are serialized first\n\tcount = gf_list_count(ctx->vps);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = gf_list_get(ctx->vps, i);\n\t\tHEVC_VPS *vps = &ctx->hevc_state->vps[sl->id];\n\n\t\tif (!i) {\n\t\t\thvcc->avgFrameRate = lvcc->avgFrameRate = vps->rates[0].avg_pic_rate;\n\t\t\thvcc->constantFrameRate = lvcc->constantFrameRate = vps->rates[0].constant_pic_rate_idc;\n\t\t\thvcc->numTemporalLayers = lvcc->numTemporalLayers = vps->max_sub_layers;\n\t\t\thvcc->temporalIdNested = lvcc->temporalIdNested = vps->temporal_id_nesting;\n\t\t}\n\t\t//TODO set scalability mask\n\t\tif (!ctx->analyze)\n\t\t\tnaludmx_add_param_nalu((ctx->explicit || ! (*has_hevc_base) ) ? lvcc->param_array : hvcc->param_array, sl, GF_HEVC_NALU_VID_PARAM);\n\t}\n\n\tcount = gf_list_count(ctx->sps);\n\tfor (i=0; i<count; i++) {\n\t\tBool is_lhvc = GF_FALSE;\n\t\tGF_NALUFFParam *sl = gf_list_get(ctx->sps, i);\n\t\tHEVC_SPS *sps = &ctx->hevc_state->sps[sl->id];\n\t\tlayer_id = ((sl->data[0] & 0x1) << 5) | (sl->data[1] >> 3);\n\t\tif (!layer_id) *has_hevc_base = GF_TRUE;\n\n\t\tif (ctx->explicit || layer_id) {\n\t\t\tcfg = lvcc;\n\t\t\tis_lhvc = GF_TRUE;\n\t\t} else {\n\t\t\tcfg = hvcc;\n\t\t}\n\n\t\tif (first || (is_lhvc && first_lhvc) ) {\n\t\t\tcfg->configurationVersion = 1;\n\t\t\tcfg->profile_space = sps->ptl.profile_space;\n\t\t\tcfg->tier_flag = sps->ptl.tier_flag;\n\t\t\tcfg->profile_idc = sps->ptl.profile_idc;\n\t\t\tcfg->general_profile_compatibility_flags = sps->ptl.profile_compatibility_flag;\n\t\t\tcfg->progressive_source_flag = sps->ptl.general_progressive_source_flag;\n\t\t\tcfg->interlaced_source_flag = sps->ptl.general_interlaced_source_flag;\n\t\t\tcfg->non_packed_constraint_flag = sps->ptl.general_non_packed_constraint_flag;\n\t\t\tcfg->frame_only_constraint_flag = sps->ptl.general_frame_only_constraint_flag;\n\t\t\tcfg->constraint_indicator_flags = sps->ptl.general_reserved_44bits;\n\t\t\tcfg->level_idc = sps->ptl.level_idc;\n\t\t\tcfg->chromaFormat = sps->chroma_format_idc;\n\t\t\tcfg->luma_bit_depth = sps->bit_depth_luma;\n\t\t\tcfg->chroma_bit_depth = sps->bit_depth_chroma;\n\t\t\tctx->interlaced = cfg->interlaced_source_flag ? GF_TRUE : GF_FALSE;\n\n\t\t\tif (sps->aspect_ratio_info_present_flag && sps->sar_width && sps->sar_height) {\n\t\t\t\tsar->num = sps->sar_width;\n\t\t\t\tsar->den = sps->sar_height;\n\t\t\t}\n\n\t\t\t/*disable frame rate scan, most bitstreams have wrong values there*/\n\t\t\tif (ctx->notime && first && (!ctx->fps.num || !ctx->fps.den) && sps->has_timing_info\n\t\t\t\t/*if detected FPS is greater than 1000, assume wrong timing info*/\n\t\t\t\t&& (sps->time_scale <= 1000*sps->num_units_in_tick)\n\t\t\t) {\n\t\t\t\tctx->cur_fps.num = sps->time_scale;\n\t\t\t\tctx->cur_fps.den = sps->num_units_in_tick;\n\n\t\t\t\tif (!ctx->fps.num && ctx->dts==ctx->fps.den)\n\t\t\t\t\tctx->dts = ctx->cur_fps.den;\n\t\t\t}\n\t\t\tctx->fps = ctx->cur_fps;\n\t\t}\n\t\tfirst = GF_FALSE;\n\t\tif (is_lhvc) {\n\t\t\tfirst_lhvc = GF_FALSE;\n\t\t\tif (sps->width > max_ew) max_ew = sps->width;\n\t\t\tif (sps->height > max_eh) max_eh = sps->height;\n\t\t} else {\n\t\t\tif (sps->width > max_w) max_w = sps->width;\n\t\t\tif (sps->height > max_h) max_h = sps->height;\n\t\t}\n\t\tif (!ctx->analyze)\n\t\t\tnaludmx_add_param_nalu(cfg->param_array, sl, GF_HEVC_NALU_SEQ_PARAM);\n\t}\n\n\tcfg = ctx->explicit ? lvcc : hvcc;\n\tcount = gf_list_count(ctx->pps);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = gf_list_get(ctx->pps, i);\n\t\tlayer_id = ((sl->data[0] & 0x1) << 5) | (sl->data[1] >> 3);\n\t\tif (!layer_id) *has_hevc_base = GF_TRUE;\n\t\tif (!ctx->analyze)\n\t\t\tnaludmx_add_param_nalu(layer_id ? lvcc->param_array : cfg->param_array, sl, GF_HEVC_NALU_PIC_PARAM);\n\t}\n\n\t*dsi = *dsi_enh = NULL;\n\t*dsi_size = *dsi_enh_size = 0;\n\n\tif (ctx->explicit || ! (*has_hevc_base) ) {\n\t\tnaludmx_hevc_set_parall_type(ctx, lvcc);\n\t\tgf_odf_hevc_cfg_write(lvcc, dsi, dsi_size);\n\t\t*max_width = *max_enh_width = max_ew;\n\t\t*max_height = *max_enh_height = max_eh;\n\t} else {\n\t\tnaludmx_hevc_set_parall_type(ctx, hvcc);\n\t\tgf_odf_hevc_cfg_write(hvcc, dsi, dsi_size);\n\t\tif (gf_list_count(lvcc->param_array) ) {\n\t\t\tnaludmx_hevc_set_parall_type(ctx, lvcc);\n\t\t\tgf_odf_hevc_cfg_write(lvcc, dsi_enh, dsi_enh_size);\n\t\t}\n\t\t*max_width = max_w;\n\t\t*max_height = max_h;\n\t\t*max_enh_width = max_ew;\n\t\t*max_enh_height = max_eh;\n\t}\n\tcount = gf_list_count(hvcc->param_array);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParamArray *pa = gf_list_get(hvcc->param_array, i);\n\t\tgf_list_reset(pa->nalus);\n\t}\n\tcount = gf_list_count(lvcc->param_array);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParamArray *pa = gf_list_get(lvcc->param_array, i);\n\t\tgf_list_reset(pa->nalus);\n\t}\n\tgf_odf_hevc_cfg_del(hvcc);\n\tgf_odf_hevc_cfg_del(lvcc);\n#endif // GPAC_DISABLE_HEVC\n\treturn GF_TRUE;\n}", "target": 2, "idx": 11161}
{"commit_id": "da5c0f119203ad9728920456a0f52a6d850c01cd", "project": "torvalds/linux", "func": "int nfc_data_exchange(struct nfc_dev *dev, u32 target_idx, struct sk_buff *skb,\n\t\t      data_exchange_cb_t cb, void *cb_context)\n{\n\tint rc;\n\n\tpr_debug(\"dev_name=%s target_idx=%u skb->len=%u\\n\",\n\t\t dev_name(&dev->dev), target_idx, skb->len);\n\n\tdevice_lock(&dev->dev);\n\n\tif (dev->shutting_down) {\n\t\trc = -ENODEV;\n\t\tkfree_skb(skb);\n\t\tgoto error;\n\t}\n\n\tif (dev->rf_mode == NFC_RF_INITIATOR && dev->active_target != NULL) {\n\t\tif (dev->active_target->idx != target_idx) {\n\t\t\trc = -EADDRNOTAVAIL;\n\t\t\tkfree_skb(skb);\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (dev->ops->check_presence)\n\t\t\tdel_timer_sync(&dev->check_pres_timer);\n\n\t\trc = dev->ops->im_transceive(dev, dev->active_target, skb, cb,\n\t\t\t\t\t     cb_context);\n\n\t\tif (!rc && dev->ops->check_presence && !dev->shutting_down)\n\t\t\tmod_timer(&dev->check_pres_timer, jiffies +\n\t\t\t\t  msecs_to_jiffies(NFC_CHECK_PRES_FREQ_MS));\n\t} else if (dev->rf_mode == NFC_RF_TARGET && dev->ops->tm_send != NULL) {\n\t\trc = dev->ops->tm_send(dev, skb);\n\t} else {\n\t\trc = -ENOTCONN;\n\t\tkfree_skb(skb);\n\t\tgoto error;\n\t}\n\n\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1, "idx": 11162}
{"commit_id": "afc39bea36fd436e54262f150c009e8d72db5014", "project": "envoyproxy/envoy", "func": "void HttpGrpcAccessLog::emitLog(const Http::HeaderMap& request_headers,\n                                const Http::HeaderMap& response_headers,\n                                const Http::HeaderMap& response_trailers,\n                                const StreamInfo::StreamInfo& stream_info) {\n  // Common log properties.\n  // TODO(mattklein123): Populate sample_rate field.\n  envoy::data::accesslog::v2::HTTPAccessLogEntry log_entry;\n  GrpcCommon::Utility::extractCommonAccessLogProperties(*log_entry.mutable_common_properties(),\n                                                        stream_info);\n\n  if (stream_info.protocol()) {\n    switch (stream_info.protocol().value()) {\n    case Http::Protocol::Http10:\n      log_entry.set_protocol_version(envoy::data::accesslog::v2::HTTPAccessLogEntry::HTTP10);\n      break;\n    case Http::Protocol::Http11:\n      log_entry.set_protocol_version(envoy::data::accesslog::v2::HTTPAccessLogEntry::HTTP11);\n      break;\n    case Http::Protocol::Http2:\n      log_entry.set_protocol_version(envoy::data::accesslog::v2::HTTPAccessLogEntry::HTTP2);\n      break;\n    }\n  }\n\n  // HTTP request properties.\n  // TODO(mattklein123): Populate port field.\n  auto* request_properties = log_entry.mutable_request();\n  if (request_headers.Scheme() != nullptr) {\n    request_properties->set_scheme(std::string(request_headers.Scheme()->value().getStringView()));\n  }\n  if (request_headers.Host() != nullptr) {\n    request_properties->set_authority(std::string(request_headers.Host()->value().getStringView()));\n  }\n  if (request_headers.Path() != nullptr) {\n    request_properties->set_path(std::string(request_headers.Path()->value().getStringView()));\n  }\n  if (request_headers.UserAgent() != nullptr) {\n    request_properties->set_user_agent(\n        std::string(request_headers.UserAgent()->value().getStringView()));\n  }\n  if (request_headers.Referer() != nullptr) {\n    request_properties->set_referer(\n        std::string(request_headers.Referer()->value().getStringView()));\n  }\n  if (request_headers.ForwardedFor() != nullptr) {\n    request_properties->set_forwarded_for(\n        std::string(request_headers.ForwardedFor()->value().getStringView()));\n  }\n  if (request_headers.RequestId() != nullptr) {\n    request_properties->set_request_id(\n        std::string(request_headers.RequestId()->value().getStringView()));\n  }\n  if (request_headers.EnvoyOriginalPath() != nullptr) {\n    request_properties->set_original_path(\n        std::string(request_headers.EnvoyOriginalPath()->value().getStringView()));\n  }\n  request_properties->set_request_headers_bytes(request_headers.byteSize().value());\n  request_properties->set_request_body_bytes(stream_info.bytesReceived());\n  if (request_headers.Method() != nullptr) {\n    envoy::api::v2::core::RequestMethod method =\n        envoy::api::v2::core::RequestMethod::METHOD_UNSPECIFIED;\n    envoy::api::v2::core::RequestMethod_Parse(\n        std::string(request_headers.Method()->value().getStringView()), &method);\n    request_properties->set_request_method(method);\n  }\n  if (!request_headers_to_log_.empty()) {\n    auto* logged_headers = request_properties->mutable_request_headers();\n\n    for (const auto& header : request_headers_to_log_) {\n      const Http::HeaderEntry* entry = request_headers.get(header);\n      if (entry != nullptr) {\n        logged_headers->insert({header.get(), std::string(entry->value().getStringView())});\n      }\n    }\n  }\n\n  // HTTP response properties.\n  auto* response_properties = log_entry.mutable_response();\n  if (stream_info.responseCode()) {\n    response_properties->mutable_response_code()->set_value(stream_info.responseCode().value());\n  }\n  if (stream_info.responseCodeDetails()) {\n    response_properties->set_response_code_details(stream_info.responseCodeDetails().value());\n  }\n  response_properties->set_response_headers_bytes(response_headers.byteSize().value());\n  response_properties->set_response_body_bytes(stream_info.bytesSent());\n  if (!response_headers_to_log_.empty()) {\n    auto* logged_headers = response_properties->mutable_response_headers();\n\n    for (const auto& header : response_headers_to_log_) {\n      const Http::HeaderEntry* entry = response_headers.get(header);\n      if (entry != nullptr) {\n        logged_headers->insert({header.get(), std::string(entry->value().getStringView())});\n      }\n    }\n  }\n\n  if (!response_trailers_to_log_.empty()) {\n    auto* logged_headers = response_properties->mutable_response_trailers();\n\n    for (const auto& header : response_trailers_to_log_) {\n      const Http::HeaderEntry* entry = response_trailers.get(header);\n      if (entry != nullptr) {\n        logged_headers->insert({header.get(), std::string(entry->value().getStringView())});\n      }\n    }\n  }\n\n  tls_slot_->getTyped<ThreadLocalLogger>().logger_->log(std::move(log_entry));\n}", "target": 2, "idx": 11163}
{"commit_id": "a2e1064f288a353bc5fef7f79ccb7683759e775c", "project": "ImageMagick", "func": "static MagickBooleanType load_tile(Image *image,Image *tile_image,\n  XCFDocInfo *inDocInfo,XCFLayerInfo *inLayerInfo,size_t data_length,\n  ExceptionInfo *exception)\n{\n  ssize_t\n    y;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  ssize_t\n    count;\n\n  unsigned char\n    *graydata;\n\n  XCFPixelInfo\n    *xcfdata,\n    *xcfodata;\n\n  xcfdata=(XCFPixelInfo *) AcquireQuantumMemory(MagickMax(data_length,\n    tile_image->columns*tile_image->rows),sizeof(*xcfdata));\n  if (xcfdata == (XCFPixelInfo *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  xcfodata=xcfdata;\n  graydata=(unsigned char *) xcfdata;  /* used by gray and indexed */\n  count=ReadBlob(image,data_length,(unsigned char *) xcfdata);\n  if (count != (ssize_t) data_length)\n    ThrowBinaryException(CorruptImageError,\"NotEnoughPixelData\",\n      image->filename);\n  for (y=0; y < (ssize_t) tile_image->rows; y++)\n  {\n    q=GetAuthenticPixels(tile_image,0,y,tile_image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    if (inDocInfo->image_type == GIMP_GRAY)\n      {\n        for (x=0; x < (ssize_t) tile_image->columns; x++)\n        {\n          SetPixelGray(tile_image,ScaleCharToQuantum(*graydata),q);\n          SetPixelAlpha(tile_image,ScaleCharToQuantum((unsigned char)\n            inLayerInfo->alpha),q);\n          graydata++;\n          q+=GetPixelChannels(tile_image);\n        }\n      }\n    else\n      if (inDocInfo->image_type == GIMP_RGB)\n        {\n          for (x=0; x < (ssize_t) tile_image->columns; x++)\n          {\n            SetPixelRed(tile_image,ScaleCharToQuantum(xcfdata->red),q);\n            SetPixelGreen(tile_image,ScaleCharToQuantum(xcfdata->green),q);\n            SetPixelBlue(tile_image,ScaleCharToQuantum(xcfdata->blue),q);\n            SetPixelAlpha(tile_image,xcfdata->alpha == 255U ? TransparentAlpha :\n              ScaleCharToQuantum((unsigned char) inLayerInfo->alpha),q);\n            xcfdata++;\n            q+=GetPixelChannels(tile_image);\n          }\n        }\n     if (SyncAuthenticPixels(tile_image,exception) == MagickFalse)\n       break;\n  }\n  xcfodata=(XCFPixelInfo *) RelinquishMagickMemory(xcfodata);\n  return MagickTrue;\n}", "target": 1, "idx": 11164}
{"commit_id": "8e53abbc20d08ae3ec30c2054e1161314ad9501d", "project": "qemu", "func": "static int bochs_open(BlockDriverState *bs, QDict *options, int flags,\n                      Error **errp)\n{\n    BDRVBochsState *s = bs->opaque;\n    uint32_t i;\n    struct bochs_header bochs;\n    int ret;\n\n    bs->read_only = 1; // no write support yet\n\n    ret = bdrv_pread(bs->file, 0, &bochs, sizeof(bochs));\n    if (ret < 0) {\n        return ret;\n    }\n\n    if (strcmp(bochs.magic, HEADER_MAGIC) ||\n        strcmp(bochs.type, REDOLOG_TYPE) ||\n        strcmp(bochs.subtype, GROWING_TYPE) ||\n\t((le32_to_cpu(bochs.version) != HEADER_VERSION) &&\n\t(le32_to_cpu(bochs.version) != HEADER_V1))) {\n        error_setg(errp, \"Image not in Bochs format\");\n        return -EINVAL;\n    }\n\n    if (le32_to_cpu(bochs.version) == HEADER_V1) {\n        bs->total_sectors = le64_to_cpu(bochs.extra.redolog_v1.disk) / 512;\n    } else {\n        bs->total_sectors = le64_to_cpu(bochs.extra.redolog.disk) / 512;\n    }\n\n    /* Limit to 1M entries to avoid unbounded allocation. This is what is\n     * needed for the largest image that bximage can create (~8 TB). */\n    s->catalog_size = le32_to_cpu(bochs.catalog);\n    if (s->catalog_size > 0x100000) {\n        error_setg(errp, \"Catalog size is too large\");\n        return -EFBIG;\n    }\n\n    s->catalog_bitmap = g_malloc(s->catalog_size * 4);\n\n    ret = bdrv_pread(bs->file, le32_to_cpu(bochs.header), s->catalog_bitmap,\n                     s->catalog_size * 4);\n    if (ret < 0) {\n        goto fail;\n    }\n\n    for (i = 0; i < s->catalog_size; i++)\n\tle32_to_cpus(&s->catalog_bitmap[i]);\n\n    s->data_offset = le32_to_cpu(bochs.header) + (s->catalog_size * 4);\n\n    s->bitmap_blocks = 1 + (le32_to_cpu(bochs.bitmap) - 1) / 512;\n    s->extent_blocks = 1 + (le32_to_cpu(bochs.extent) - 1) / 512;\n\n    s->extent_size = le32_to_cpu(bochs.extent);\n    if (s->extent_size == 0) {\n        error_setg(errp, \"Extent size may not be zero\");\n        return -EINVAL;\n    } else if (s->extent_size > 0x800000) {\n        error_setg(errp, \"Extent size %\" PRIu32 \" is too large\",\n                   s->extent_size);\n        return -EINVAL;\n    }\n\n    if (s->catalog_size < bs->total_sectors / s->extent_size) {\n        error_setg(errp, \"Catalog size is too small for this disk size\");\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    qemu_co_mutex_init(&s->lock);\n    return 0;\n\nfail:\n    g_free(s->catalog_bitmap);\n    return ret;\n}", "target": 1, "idx": 11165}
{"commit_id": "c78e186739b50d156cb3da5d08d70294f0490853", "project": "bfabiszewski/libmobi", "func": "MOBI_RET mobi_parse_huffdic(const MOBIData *m, MOBIHuffCdic *huffcdic) {\n    MOBI_RET ret;\n    const size_t offset = mobi_get_kf8offset(m);\n    if (m->mh == NULL || m->mh->huff_rec_index == NULL || m->mh->huff_rec_count == NULL) {\n        debug_print(\"%s\", \"HUFF/CDIC records metadata not found in MOBI header\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    const size_t huff_rec_index = *m->mh->huff_rec_index + offset;\n    const size_t huff_rec_count = *m->mh->huff_rec_count;\n    if (huff_rec_count > HUFF_RECORD_MAXCNT) {\n        debug_print(\"Too many HUFF record (%zu)\\n\", huff_rec_count);\n        return MOBI_DATA_CORRUPT;\n    }\n    const MOBIPdbRecord *curr = mobi_get_record_by_seqnumber(m, huff_rec_index);\n    if (curr == NULL || huff_rec_count < 2) {\n        debug_print(\"%s\", \"HUFF/CDIC record not found\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    if (curr->size < HUFF_RECORD_MINSIZE) {\n        debug_print(\"HUFF record too short (%zu b)\\n\", curr->size);\n        return MOBI_DATA_CORRUPT;\n    }\n    ret = mobi_parse_huff(huffcdic, curr);\n    if (ret != MOBI_SUCCESS) {\n        debug_print(\"%s\", \"HUFF parsing failed\\n\");\n        return ret;\n    }\n    curr = curr->next;\n    /* allocate memory for symbols data in each CDIC record */\n    huffcdic->symbols = malloc((huff_rec_count - 1) * sizeof(*huffcdic->symbols));\n    if (huffcdic->symbols == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    /* get following CDIC records */\n    size_t i = 0;\n    while (i < huff_rec_count - 1) {\n        if (curr == NULL) {\n            debug_print(\"%s\\n\", \"CDIC record not found\");\n            return MOBI_DATA_CORRUPT;\n        }\n        ret = mobi_parse_cdic(huffcdic, curr, i++);\n        if (ret != MOBI_SUCCESS) {\n            debug_print(\"%s\", \"CDIC parsing failed\\n\");\n            return ret;\n        }\n        curr = curr->next;\n    }\n    if (huffcdic->index_count != huffcdic->index_read) {\n        debug_print(\"CDIC: wrong read index count: %zu, total: %zu\\n\", huffcdic->index_read, huffcdic->index_count);\n        return MOBI_DATA_CORRUPT;\n    }\n    return MOBI_SUCCESS;\n}", "target": 2, "idx": 11166}
{"commit_id": "7c4a5b89a0b5a57a64b601775b296abf77a9fe97", "project": "torvalds/linux", "func": "static struct task_struct *_pick_next_task_rt(struct rq *rq)\n{\n\tstruct sched_rt_entity *rt_se;\n\tstruct rt_rq *rt_rq  = &rq->rt;\n\n\tdo {\n\t\trt_se = pick_next_rt_entity(rt_rq);\n\t\tif (unlikely(!rt_se))\n\t\t\treturn NULL;\n\t\trt_rq = group_rt_rq(rt_se);\n\t} while (rt_rq);\n\n\treturn rt_task_of(rt_se);\n}", "target": 2, "idx": 11167}
{"commit_id": "23c9775fb6afb7be1472944e02396f29771dc8e2", "project": "wocommunity/wonder", "func": "int WebObjects_translate(request_rec *r) {\n   WebObjects_config *wc;\n   WOURLComponents url;\n   WOURLError urlerr;\n   WOURLError charcheck;\n\n   wc = (WebObjects_config *)ap_get_module_config(r->server->module_config, &WebObjects_module);\n\n   /* WOLog(WO_DBG,\"<WebObjects Apache Module> new translate: %s\",r->uri); */\n   if (strncmp(wc->WebObjects_alias, r->uri, strlen(wc->WebObjects_alias)) == 0) {\n      url = WOURLComponents_Initializer;\n\n#ifndef __PRESERVE_UNSAFE_URLS\n      // Make sure the URL does not contain forbidden characters (0x0D or 0x0A).\n      charcheck = WOValidateInitialURL( r->uri );\n      if ( charcheck != WOURLOK ) {\n         WOLog(WO_ERR, \"WebObjects_translate(): declining request due to forbidden URL characters\");\n         return DECLINED;\n      }\n#endif\n\n\n      urlerr = WOParseApplicationName(&url, r->uri);\n      if (urlerr != WOURLOK && !((urlerr == WOURLInvalidApplicationName) && ac_authorizeAppListing(&url))) {\n         /* WOLog(WO_DBG,\"<WebObjects Apache Module> translate - DECLINED: %s\",r->uri); */\n         return DECLINED;\n      }\n      if (!adaptorEnabled)\n      {\n         WOLog(WO_ERR, \"WebObjects_translate(): declining request due to initialization failure\");\n         return DECLINED;\n      }\n      /*\n       *\twe'll take it - mark our handler...\n       */\n      r->handler = (char *)ap_pstrdup(r->pool, WEBOBJECTS);\n      return OK;\n   }\n   /* WOLog(WO_DBG,\"<WebObjects Apache Module> translate - DECLINED: %s\",r->uri); */\n   return DECLINED;\n}", "target": 1, "idx": 11168}
{"commit_id": "7694a7de22c53a312ea98960fcafc6ec62046531", "project": "torvalds/linux", "func": "static int uapi_finalize(struct uverbs_api *uapi)\n{\n\tconst struct uverbs_api_write_method **data;\n\tunsigned long max_write_ex = 0;\n\tunsigned long max_write = 0;\n\tstruct radix_tree_iter iter;\n\tvoid __rcu **slot;\n\tint rc;\n\tint i;\n\n\tradix_tree_for_each_slot (slot, &uapi->radix, &iter, 0) {\n\t\tstruct uverbs_api_ioctl_method *method_elm =\n\t\t\trcu_dereference_protected(*slot, true);\n\n\t\tif (uapi_key_is_ioctl_method(iter.index)) {\n\t\t\trc = uapi_finalize_ioctl_method(uapi, method_elm,\n\t\t\t\t\t\t\titer.index);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\n\t\tif (uapi_key_is_write_method(iter.index))\n\t\t\tmax_write = max(max_write,\n\t\t\t\t\titer.index & UVERBS_API_ATTR_KEY_MASK);\n\t\tif (uapi_key_is_write_ex_method(iter.index))\n\t\t\tmax_write_ex =\n\t\t\t\tmax(max_write_ex,\n\t\t\t\t    iter.index & UVERBS_API_ATTR_KEY_MASK);\n\t}\n\n\tuapi->notsupp_method.handler = ib_uverbs_notsupp;\n\tuapi->num_write = max_write + 1;\n\tuapi->num_write_ex = max_write_ex + 1;\n\tdata = kmalloc_array(uapi->num_write + uapi->num_write_ex,\n\t\t\t     sizeof(*uapi->write_methods), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i != uapi->num_write + uapi->num_write_ex; i++)\n\t\tdata[i] = &uapi->notsupp_method;\n\tuapi->write_methods = data;\n\tuapi->write_ex_methods = data + uapi->num_write;\n\n\tradix_tree_for_each_slot (slot, &uapi->radix, &iter, 0) {\n\t\tif (uapi_key_is_write_method(iter.index))\n\t\t\tuapi->write_methods[iter.index &\n\t\t\t\t\t    UVERBS_API_ATTR_KEY_MASK] =\n\t\t\t\trcu_dereference_protected(*slot, true);\n\t\tif (uapi_key_is_write_ex_method(iter.index))\n\t\t\tuapi->write_ex_methods[iter.index &\n\t\t\t\t\t       UVERBS_API_ATTR_KEY_MASK] =\n\t\t\t\trcu_dereference_protected(*slot, true);\n\t}\n\n\treturn 0;\n}", "target": 1, "idx": 11169}
{"commit_id": "f60a85cad677c4f9bb4cadd764f1d106c38c7cf8", "project": "torvalds/linux", "func": "static int finish(void)\n{\n\tint magic = BPF_PRELOAD_END;\n\tstruct pid *tgid;\n\tloff_t pos = 0;\n\tssize_t n;\n\n\t/* send the last magic to UMD. It will do a normal exit. */\n\tn = kernel_write(umd_ops.info.pipe_to_umh,\n\t\t\t &magic, sizeof(magic), &pos);\n\tif (n != sizeof(magic))\n\t\treturn -EPIPE;\n\n\ttgid = umd_ops.info.tgid;\n\tif (tgid) {\n\t\twait_event(tgid->wait_pidfd, thread_group_exited(tgid));\n\t\tumd_cleanup_helper(&umd_ops.info);\n\t}\n\treturn 0;\n}", "target": 1, "idx": 11170}
{"commit_id": "726812fa2fa7ce16bcf58f6e115f65427a1c0950", "project": "ImageMagick", "func": "static MagickBooleanType DrawStrokePolygon(Image *image,\n  const DrawInfo *draw_info,const PrimitiveInfo *primitive_info,\n  ExceptionInfo *exception)\n{\n  DrawInfo\n    *clone_info;\n\n  MagickBooleanType\n    closed_path;\n\n  MagickStatusType\n    status;\n\n  PrimitiveInfo\n    *stroke_polygon;\n\n  register const PrimitiveInfo\n    *p,\n    *q;\n\n  /*\n    Draw stroked polygon.\n  */\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n      \"    begin draw-stroke-polygon\");\n  clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  clone_info->fill=draw_info->stroke;\n  if (clone_info->fill_pattern != (Image *) NULL)\n    clone_info->fill_pattern=DestroyImage(clone_info->fill_pattern);\n  if (clone_info->stroke_pattern != (Image *) NULL)\n    clone_info->fill_pattern=CloneImage(clone_info->stroke_pattern,0,0,\n      MagickTrue,exception);\n  clone_info->stroke.alpha=(MagickRealType) TransparentAlpha;\n  clone_info->stroke_width=0.0;\n  clone_info->fill_rule=NonZeroRule;\n  status=MagickTrue;\n  for (p=primitive_info; p->primitive != UndefinedPrimitive; p+=p->coordinates)\n  {\n    stroke_polygon=TraceStrokePolygon(draw_info,p);\n    status&=DrawPolygonPrimitive(image,clone_info,stroke_polygon,exception);\n    if (status == 0)\n      break;\n    stroke_polygon=(PrimitiveInfo *) RelinquishMagickMemory(stroke_polygon);\n    q=p+p->coordinates-1;\n    closed_path=(q->point.x == p->point.x) && (q->point.y == p->point.y) ?\n      MagickTrue : MagickFalse;\n    if ((draw_info->linecap == RoundCap) && (closed_path == MagickFalse))\n      {\n        DrawRoundLinecap(image,draw_info,p,exception);\n        DrawRoundLinecap(image,draw_info,q,exception);\n      }\n  }\n  clone_info=DestroyDrawInfo(clone_info);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n      \"    end draw-stroke-polygon\");\n  return(status != 0 ? MagickTrue : MagickFalse);\n}", "target": 2, "idx": 11171}
{"commit_id": "3037933448f60f9acb705997eae62013ecb81e0d", "project": "torvalds/linux", "func": "static int qfq_change_class(struct Qdisc *sch, u32 classid, u32 parentid,\n\t\t\t    struct nlattr **tca, unsigned long *arg,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct qfq_sched *q = qdisc_priv(sch);\n\tstruct qfq_class *cl = (struct qfq_class *)*arg;\n\tbool existing = false;\n\tstruct nlattr *tb[TCA_QFQ_MAX + 1];\n\tstruct qfq_aggregate *new_agg = NULL;\n\tu32 weight, lmax, inv_w;\n\tint err;\n\tint delta_w;\n\n\tif (tca[TCA_OPTIONS] == NULL) {\n\t\tpr_notice(\"qfq: no options\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = nla_parse_nested_deprecated(tb, TCA_QFQ_MAX, tca[TCA_OPTIONS],\n\t\t\t\t\t  qfq_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[TCA_QFQ_WEIGHT]) {\n\t\tweight = nla_get_u32(tb[TCA_QFQ_WEIGHT]);\n\t\tif (!weight || weight > (1UL << QFQ_MAX_WSHIFT)) {\n\t\t\tpr_notice(\"qfq: invalid weight %u\\n\", weight);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else\n\t\tweight = 1;\n\n\tif (tb[TCA_QFQ_LMAX])\n\t\tlmax = nla_get_u32(tb[TCA_QFQ_LMAX]);\n\telse\n\t\tlmax = psched_mtu(qdisc_dev(sch));\n\n\tif (lmax < QFQ_MIN_LMAX || lmax > (1UL << QFQ_MTU_SHIFT)) {\n\t\tpr_notice(\"qfq: invalid max length %u\\n\", lmax);\n\t\treturn -EINVAL;\n\t}\n\n\tinv_w = ONE_FP / weight;\n\tweight = ONE_FP / inv_w;\n\n\tif (cl != NULL &&\n\t    lmax == cl->agg->lmax &&\n\t    weight == cl->agg->class_weight)\n\t\treturn 0; /* nothing to change */\n\n\tdelta_w = weight - (cl ? cl->agg->class_weight : 0);\n\n\tif (q->wsum + delta_w > QFQ_MAX_WSUM) {\n\t\tpr_notice(\"qfq: total weight out of range (%d + %u)\\n\",\n\t\t\t  delta_w, q->wsum);\n\t\treturn -EINVAL;\n\t}\n\n\tif (cl != NULL) { /* modify existing class */\n\t\tif (tca[TCA_RATE]) {\n\t\t\terr = gen_replace_estimator(&cl->bstats, NULL,\n\t\t\t\t\t\t    &cl->rate_est,\n\t\t\t\t\t\t    NULL,\n\t\t\t\t\t\t    true,\n\t\t\t\t\t\t    tca[TCA_RATE]);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\texisting = true;\n\t\tgoto set_change_agg;\n\t}\n\n\t/* create and init new class */\n\tcl = kzalloc(sizeof(struct qfq_class), GFP_KERNEL);\n\tif (cl == NULL)\n\t\treturn -ENOBUFS;\n\n\tgnet_stats_basic_sync_init(&cl->bstats);\n\tcl->common.classid = classid;\n\tcl->deficit = lmax;\n\n\tcl->qdisc = qdisc_create_dflt(sch->dev_queue, &pfifo_qdisc_ops,\n\t\t\t\t      classid, NULL);\n\tif (cl->qdisc == NULL)\n\t\tcl->qdisc = &noop_qdisc;\n\n\tif (tca[TCA_RATE]) {\n\t\terr = gen_new_estimator(&cl->bstats, NULL,\n\t\t\t\t\t&cl->rate_est,\n\t\t\t\t\tNULL,\n\t\t\t\t\ttrue,\n\t\t\t\t\ttca[TCA_RATE]);\n\t\tif (err)\n\t\t\tgoto destroy_class;\n\t}\n\n\tif (cl->qdisc != &noop_qdisc)\n\t\tqdisc_hash_add(cl->qdisc, true);\n\nset_change_agg:\n\tsch_tree_lock(sch);\n\tnew_agg = qfq_find_agg(q, lmax, weight);\n\tif (new_agg == NULL) { /* create new aggregate */\n\t\tsch_tree_unlock(sch);\n\t\tnew_agg = kzalloc(sizeof(*new_agg), GFP_KERNEL);\n\t\tif (new_agg == NULL) {\n\t\t\terr = -ENOBUFS;\n\t\t\tgen_kill_estimator(&cl->rate_est);\n\t\t\tgoto destroy_class;\n\t\t}\n\t\tsch_tree_lock(sch);\n\t\tqfq_init_agg(q, new_agg, lmax, weight);\n\t}\n\tif (existing)\n\t\tqfq_deact_rm_from_agg(q, cl);\n\telse\n\t\tqdisc_class_hash_insert(&q->clhash, &cl->common);\n\tqfq_add_to_agg(q, new_agg, cl);\n\tsch_tree_unlock(sch);\n\tqdisc_class_hash_grow(sch, &q->clhash);\n\n\t*arg = (unsigned long)cl;\n\treturn 0;\n\ndestroy_class:\n\tqdisc_put(cl->qdisc);\n\tkfree(cl);\n\treturn err;\n}", "target": 2, "idx": 11172}
{"commit_id": "b3d821c4ae9ba62b3a194d9dcb5e99f17bd56908", "project": "gpac", "func": "static Fixed lsr_translate_scale(GF_LASeRCodec *lsr, u32 val)\n{\n\tif (val >> (lsr->coord_bits-1) ) {\n\t\ts64 v = val - (0x00000001UL << lsr->coord_bits);\n\t\treturn INT2FIX(v) / 256 ;\n\t} else {\n\t\treturn INT2FIX(val) / 256;\n\t}\n}", "target": 2, "idx": 11173}
{"commit_id": "1295ae4dbb52fe06b19733b0257e2340d7b63b8d", "project": "tensorflow", "func": "StatusOr<std::vector<int64_t>> GetStride(XlaOpKernelContext* ctx) {\n    std::vector<int64_t> stride;\n    if (ctx->num_inputs() == 1) {\n      stride = stride_;\n    } else {\n      const TensorShape stride_shape = ctx->InputShape(2);\n      // Validate input sizes.\n      if (!TensorShapeUtils::IsVector(stride_shape)) {\n        return errors::InvalidArgument(\"stride must be a vector, not shape \",\n                                       stride_shape.DebugString());\n      }\n      if (stride_shape.num_elements() != num_dims()) {\n        return errors::InvalidArgument(\n            \"Sliding window stride field must \"\n            \"specify \",\n            num_dims(), \" dimensions\");\n      }\n      auto status = ctx->ConstantInputAsIntVector(2, &stride);\n      if (!status.ok()) {\n        return status;\n      }\n    }\n    TF_RETURN_IF_ERROR(ValidateStrides(stride));\n    return stride;\n  }", "target": 2, "idx": 11174}
{"commit_id": "ba82be72cfd427b5d72ff21f929b3a6d8529c4df", "project": "GNOME/evolution-data-server", "func": "static gboolean\nconnect_to_server (CamelService *service,\n                   GCancellable *cancellable,\n                   GError **error)\n{\n\tCamelPOP3Store *store = CAMEL_POP3_STORE (service);\n\tCamelNetworkSettings *network_settings;\n\tCamelNetworkSecurityMethod method;\n\tCamelSettings *settings;\n\tCamelStream *stream = NULL;\n\tCamelPOP3Engine *pop3_engine = NULL;\n\tCamelPOP3Command *pc;\n\tGIOStream *base_stream;\n\tGIOStream *tls_stream;\n\tgboolean disable_extensions;\n\tgboolean success = TRUE;\n\tgchar *host;\n\tguint32 flags = 0;\n\tgint ret;\n\tGError *local_error = NULL;\n\n\tsettings = camel_service_ref_settings (service);\n\n\tnetwork_settings = CAMEL_NETWORK_SETTINGS (settings);\n\thost = camel_network_settings_dup_host (network_settings);\n\tmethod = camel_network_settings_get_security_method (network_settings);\n\n\tdisable_extensions = camel_pop3_settings_get_disable_extensions (\n\t\tCAMEL_POP3_SETTINGS (settings));\n\n\tg_object_unref (settings);\n\n\tbase_stream = camel_network_service_connect_sync (\n\t\tCAMEL_NETWORK_SERVICE (service), cancellable, error);\n\n\tif (base_stream != NULL) {\n\t\tstream = camel_stream_new (base_stream);\n\t\tg_object_unref (base_stream);\n\t} else {\n\t\tsuccess = FALSE;\n\t\tgoto exit;\n\t}\n\n\t/* parent class connect initialization */\n\tif (CAMEL_SERVICE_CLASS (camel_pop3_store_parent_class)->\n\t\tconnect_sync (service, cancellable, error) == FALSE) {\n\t\tg_object_unref (stream);\n\t\tsuccess = FALSE;\n\t\tgoto exit;\n\t}\n\n\tif (disable_extensions)\n\t\tflags |= CAMEL_POP3_ENGINE_DISABLE_EXTENSIONS;\n\n\tif (!(pop3_engine = camel_pop3_engine_new (stream, flags, cancellable, &local_error)) ||\n\t    local_error != NULL) {\n\t\tif (local_error)\n\t\t\tg_propagate_error (error, local_error);\n\t\telse\n\t\t\tg_set_error (\n\t\t\t\terror, CAMEL_ERROR, CAMEL_ERROR_GENERIC,\n\t\t\t\t_(\"Failed to read a valid greeting from POP server %s\"),\n\t\t\t\thost);\n\t\tg_object_unref (stream);\n\t\tsuccess = FALSE;\n\t\tgoto exit;\n\t}\n\n\tif (method != CAMEL_NETWORK_SECURITY_METHOD_STARTTLS_ON_STANDARD_PORT) {\n\t\tg_object_unref (stream);\n\t\tgoto exit;\n\t}\n\n\tif (!(pop3_engine->capa & CAMEL_POP3_CAP_STLS)) {\n\t\tg_set_error (\n\t\t\terror, CAMEL_ERROR, CAMEL_ERROR_GENERIC,\n\t\t\t_(\"Failed to connect to POP server %s in secure mode: %s\"),\n\t\t\thost, _(\"STLS not supported by server\"));\n\t\tgoto stls_exception;\n\t}\n\n\tpc = camel_pop3_engine_command_new (\n\t\tpop3_engine, 0, NULL, NULL,\n\t\tcancellable, error, \"STLS\\r\\n\");\n\twhile (camel_pop3_engine_iterate (pop3_engine, NULL, cancellable, NULL) > 0)\n\t\t;\n\n\tret = pc->state == CAMEL_POP3_COMMAND_OK;\n\tcamel_pop3_engine_command_free (pop3_engine, pc);\n\n\tif (ret == FALSE) {\n\t\tgchar *tmp;\n\n\t\ttmp = get_valid_utf8_error ((gchar *) pop3_engine->line);\n\t\tg_set_error (\n\t\t\terror, CAMEL_ERROR, CAMEL_ERROR_GENERIC,\n\t\t\t/* Translators: Last %s is an optional\n\t\t\t * explanation beginning with \": \" separator. */\n\t\t\t_(\"Failed to connect to POP server %s in secure mode%s\"),\n\t\t\thost, (tmp != NULL) ? tmp : \"\");\n\t\tg_free (tmp);\n\t\tgoto stls_exception;\n\t}\n\n\t/* Okay, now toggle SSL/TLS mode */\n\tbase_stream = camel_stream_ref_base_stream (stream);\n\ttls_stream = camel_network_service_starttls (\n\t\tCAMEL_NETWORK_SERVICE (service), base_stream, error);\n\tg_object_unref (base_stream);\n\n\tif (tls_stream != NULL) {\n\t\tcamel_stream_set_base_stream (stream, tls_stream);\n\t\t/* Truncate any left cached input from the insecure part of the session */\n\t\tcamel_pop3_stream_truncate (pop3_engine->stream);\n\t\tg_object_unref (tls_stream);\n\t} else {\n\t\tg_prefix_error (\n\t\t\terror,\n\t\t\t_(\"Failed to connect to POP server %s in secure mode: \"),\n\t\t\thost);\n\t\tgoto stls_exception;\n\t}\n\n\tg_clear_object (&stream);\n\n\t/* rfc2595, section 4 states that after a successful STLS\n\t * command, the client MUST discard prior CAPA responses */\n\tif (!camel_pop3_engine_reget_capabilities (pop3_engine, cancellable, error))\n\t\tgoto exception;\n\n\tgoto exit;\n\nstls_exception:\n\t/* As soon as we send a STLS command, all hope\n\t * is lost of a clean QUIT if problems arise. */\n\t/* if (clean_quit) {\n\t\t/ * try to disconnect cleanly * /\n\t\tpc = camel_pop3_engine_command_new (\n\t\t\tpop3_engine, 0, NULL, NULL,\n\t\t\tcancellable, NULL, \"QUIT\\r\\n\");\n\t\twhile (camel_pop3_engine_iterate (pop3_engine, NULL, cancellable, NULL) > 0)\n\t\t\t;\n\t\tcamel_pop3_engine_command_free (pop3_engine, pc);\n\t}*/\n\nexception:\n\tg_clear_object (&stream);\n\tg_clear_object (&pop3_engine);\n\n\tsuccess = FALSE;\n\nexit:\n\tg_free (host);\n\n\tg_mutex_lock (&store->priv->property_lock);\n\tif (pop3_engine != NULL)\n\t\tstore->priv->engine = g_object_ref (pop3_engine);\n\tg_mutex_unlock (&store->priv->property_lock);\n\n\tg_clear_object (&pop3_engine);\n\n\treturn success;\n}", "target": 1, "idx": 11175}
{"commit_id": "5566cdfedddef1f219aee33477d9c9690bf2f78b", "project": "AttorneyOnline/akashi", "func": "void AOClient::pktRemoveEvidence(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    if (!checkEvidenceAccess(area))\n        return;\n    bool is_int = false;\n    int idx = argv[0].toInt(&is_int);\n    if (is_int && idx < area->evidence().size() && idx >= 0) {\n        area->deleteEvidence(idx);\n    }\n    sendEvidenceList(area);\n}", "target": 1, "idx": 11176}
{"commit_id": "0a0b98734479aa5b3c671d5190e86273372cab95", "project": "torvalds/linux", "func": "int compat_get_timex(struct timex *txc, const struct compat_timex __user *utp)\n{\n\tstruct compat_timex tx32;\n\n\tmemset(txc, 0, sizeof(struct timex));\n\tif (copy_from_user(&tx32, utp, sizeof(struct compat_timex)))\n\t\treturn -EFAULT;\n\n\ttxc->modes = tx32.modes;\n\ttxc->offset = tx32.offset;\n\ttxc->freq = tx32.freq;\n\ttxc->maxerror = tx32.maxerror;\n\ttxc->esterror = tx32.esterror;\n\ttxc->status = tx32.status;\n\ttxc->constant = tx32.constant;\n\ttxc->precision = tx32.precision;\n\ttxc->tolerance = tx32.tolerance;\n\ttxc->time.tv_sec = tx32.time.tv_sec;\n\ttxc->time.tv_usec = tx32.time.tv_usec;\n\ttxc->tick = tx32.tick;\n\ttxc->ppsfreq = tx32.ppsfreq;\n\ttxc->jitter = tx32.jitter;\n\ttxc->shift = tx32.shift;\n\ttxc->stabil = tx32.stabil;\n\ttxc->jitcnt = tx32.jitcnt;\n\ttxc->calcnt = tx32.calcnt;\n\ttxc->errcnt = tx32.errcnt;\n\ttxc->stbcnt = tx32.stbcnt;\n\n\treturn 0;\n}", "target": 1, "idx": 11177}
{"commit_id": "d8d95291f16a8f18f8ffbd6322c14686897c5730", "project": "android", "func": "void EattChannelSetTxMTU(uint16_t tx_mtu) {\n    this->tx_mtu_ = std::min<uint16_t>(tx_mtu, EATT_MAX_TX_MTU);\n  }", "target": 3, "idx": 11178}
{"commit_id": "54e45702b648b7c0000e90b3e9b890e367e16ea8", "project": "torvalds/linux", "func": "struct ATTRIB *mi_enum_attr(struct mft_inode *mi, struct ATTRIB *attr)\n{\n\tconst struct MFT_REC *rec = mi->mrec;\n\tu32 used = le32_to_cpu(rec->used);\n\tu32 t32, off, asize;\n\tu16 t16;\n\n\tif (!attr) {\n\t\tu32 total = le32_to_cpu(rec->total);\n\n\t\toff = le16_to_cpu(rec->attr_off);\n\n\t\tif (used > total)\n\t\t\treturn NULL;\n\n\t\tif (off >= used || off < MFTRECORD_FIXUP_OFFSET_1 ||\n\t\t    !IS_ALIGNED(off, 4)) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* Skip non-resident records. */\n\t\tif (!is_rec_inuse(rec))\n\t\t\treturn NULL;\n\n\t\tattr = Add2Ptr(rec, off);\n\t} else {\n\t\t/* Check if input attr inside record. */\n\t\toff = PtrOffset(rec, attr);\n\t\tif (off >= used)\n\t\t\treturn NULL;\n\n\t\tasize = le32_to_cpu(attr->size);\n\t\tif (asize < SIZEOF_RESIDENT) {\n\t\t\t/* Impossible 'cause we should not return such attribute. */\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (off + asize < off) {\n\t\t\t/* overflow check */\n\t\t\treturn NULL;\n\t\t}\n\n\t\tattr = Add2Ptr(attr, asize);\n\t\toff += asize;\n\t}\n\n\tasize = le32_to_cpu(attr->size);\n\n\t/* Can we use the first field (attr->type). */\n\tif (off + 8 > used) {\n\t\tstatic_assert(ALIGN(sizeof(enum ATTR_TYPE), 8) == 8);\n\t\treturn NULL;\n\t}\n\n\tif (attr->type == ATTR_END) {\n\t\t/* End of enumeration. */\n\t\treturn NULL;\n\t}\n\n\t/* 0x100 is last known attribute for now. */\n\tt32 = le32_to_cpu(attr->type);\n\tif ((t32 & 0xf) || (t32 > 0x100))\n\t\treturn NULL;\n\n\t/* Check boundary. */\n\tif (off + asize > used)\n\t\treturn NULL;\n\n\t/* Check size of attribute. */\n\tif (!attr->non_res) {\n\t\tif (asize < SIZEOF_RESIDENT)\n\t\t\treturn NULL;\n\n\t\tt16 = le16_to_cpu(attr->res.data_off);\n\n\t\tif (t16 > asize)\n\t\t\treturn NULL;\n\n\t\tt32 = le32_to_cpu(attr->res.data_size);\n\t\tif (t16 + t32 > asize)\n\t\t\treturn NULL;\n\n\t\tif (attr->name_len &&\n\t\t    le16_to_cpu(attr->name_off) + sizeof(short) * attr->name_len > t16) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\treturn attr;\n\t}\n\n\t/* Check some nonresident fields. */\n\tif (attr->name_len &&\n\t    le16_to_cpu(attr->name_off) + sizeof(short) * attr->name_len >\n\t\t    le16_to_cpu(attr->nres.run_off)) {\n\t\treturn NULL;\n\t}\n\n\tif (attr->nres.svcn || !is_attr_ext(attr)) {\n\t\tif (asize + 8 < SIZEOF_NONRESIDENT)\n\t\t\treturn NULL;\n\n\t\tif (attr->nres.c_unit)\n\t\t\treturn NULL;\n\t} else if (asize + 8 < SIZEOF_NONRESIDENT_EX)\n\t\treturn NULL;\n\n\treturn attr;\n}", "target": 2, "idx": 11179}
{"commit_id": "05bbd147caccc60162d6fba9baaaf24befa281cd", "project": "rizinorg/rizin", "func": "static RzList *entries(RzBinFile *bf) {\n\tif (!bf) {\n\t\treturn NULL;\n\t}\n\tLuacBinInfo *bin_info_obj = GET_INTERNAL_BIN_INFO_OBJ(bf);\n\tif (!bin_info_obj) {\n\t\treturn NULL;\n\t}\n\n\treturn rz_list_clone(bin_info_obj->entry_list);\n}", "target": 2, "idx": 11180}
{"commit_id": "6d816e088c359866f9867057e04f244c608c42fe", "project": "torvalds/linux", "func": "static void io_rw_resubmit(struct callback_head *cb)\n{\n\tstruct io_kiocb *req = container_of(cb, struct io_kiocb, task_work);\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tint err;\n\n\terr = io_sq_thread_acquire_mm(ctx, req);\n\n\tif (io_resubmit_prep(req, err)) {\n\t\trefcount_inc(&req->refs);\n\t\tio_queue_async_work(req);\n\t}\n\n\tpercpu_ref_put(&ctx->refs);\n}", "target": 2, "idx": 11181}
{"commit_id": "360e95d45ac4123255a4c796db96337f332160ad", "project": "OpenSC", "func": "int read_file(struct sc_card *card, char *str_path, unsigned char **data, size_t *data_len)\n{\n\tstruct sc_path path;\n\tstruct sc_file *file;\n\tunsigned char *p;\n\tint ok = 0;\n\tint r;\n\tsize_t len;\n\n\tsc_format_path(str_path, &path);\n\tif (SC_SUCCESS != sc_select_file(card, &path, &file)) {\n\t\tgoto err;\n\t}\n\n\tlen = file && file->size > 0 ? file->size : 4096;\n\tp = realloc(*data, len);\n\tif (!p) {\n\t\tgoto err;\n\t}\n\t*data = p;\n\t*data_len = len;\n\n\tr = sc_read_binary(card, 0, p, len, 0);\n\tif (r < 0)\n\t\tgoto err;\n\n\t*data_len = r;\n\tok = 1;\n\nerr:\n\tsc_file_free(file);\n\n\treturn ok;\n}", "target": 1, "idx": 11182}
{"commit_id": "8e76aef72820435e766c7f339ed36da33da90c40", "project": "xen-project/xen", "func": "void pt_save_timer(struct vcpu *v)\n{\n    struct list_head *head = &v->arch.hvm.tm_list;\n    struct periodic_time *pt;\n\n    if ( v->pause_flags & VPF_blocked )\n        return;\n\n    pt_vcpu_lock(v);\n\n    list_for_each_entry ( pt, head, list )\n        if ( !pt->do_not_freeze )\n            stop_timer(&pt->timer);\n\n    pt_freeze_time(v);\n\n    pt_vcpu_unlock(v);\n}", "target": 1, "idx": 11183}
{"commit_id": "ff82911cd3f69f028f2537825c9720ff78bc3f19", "project": "qemu", "func": "int nbd_client_co_pwritev(BlockDriverState *bs, uint64_t offset,\n                          uint64_t bytes, QEMUIOVector *qiov, int flags)\n{\n    NBDClientSession *client = nbd_get_client_session(bs);\n    NBDRequest request = {\n        .type = NBD_CMD_WRITE,\n        .from = offset,\n        .len = bytes,\n    };\n    NBDReply reply;\n    ssize_t ret;\n\n    if (flags & BDRV_REQ_FUA) {\n        assert(client->nbdflags & NBD_FLAG_SEND_FUA);\n        request.flags |= NBD_CMD_FLAG_FUA;\n    }\n\n    assert(bytes <= NBD_MAX_BUFFER_SIZE);\n\n    nbd_coroutine_start(client, &request);\n    ret = nbd_co_send_request(bs, &request, qiov);\n    if (ret < 0) {\n        reply.error = -ret;\n    } else {\n        nbd_co_receive_reply(client, &request, &reply, NULL);\n    }\n    nbd_coroutine_end(bs, &request);\n    return -reply.error;\n}", "target": 1, "idx": 11184}
{"commit_id": "768d612f79822d30a1e7d132a4d4b05337ce42ec", "project": "torvalds/linux", "func": "void ext4_es_insert_delayed_block(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t\t  bool allocated)\n{\n\tstruct extent_status newes;\n\tint err1 = 0;\n\tint err2 = 0;\n\tstruct extent_status *es1 = NULL;\n\tstruct extent_status *es2 = NULL;\n\n\tif (EXT4_SB(inode->i_sb)->s_mount_state & EXT4_FC_REPLAY)\n\t\treturn;\n\n\tes_debug(\"add [%u/1) delayed to extent status tree of inode %lu\\n\",\n\t\t lblk, inode->i_ino);\n\n\tnewes.es_lblk = lblk;\n\tnewes.es_len = 1;\n\text4_es_store_pblock_status(&newes, ~0, EXTENT_STATUS_DELAYED);\n\ttrace_ext4_es_insert_delayed_block(inode, &newes, allocated);\n\n\text4_es_insert_extent_check(inode, &newes);\n\nretry:\n\tif (err1 && !es1)\n\t\tes1 = __es_alloc_extent(true);\n\tif ((err1 || err2) && !es2)\n\t\tes2 = __es_alloc_extent(true);\n\twrite_lock(&EXT4_I(inode)->i_es_lock);\n\n\terr1 = __es_remove_extent(inode, lblk, lblk, NULL, es1);\n\tif (err1 != 0)\n\t\tgoto error;\n\t/* Free preallocated extent if it didn't get used. */\n\tif (es1) {\n\t\tif (!es1->es_len)\n\t\t\t__es_free_extent(es1);\n\t\tes1 = NULL;\n\t}\n\n\terr2 = __es_insert_extent(inode, &newes, es2);\n\tif (err2 != 0)\n\t\tgoto error;\n\t/* Free preallocated extent if it didn't get used. */\n\tif (es2) {\n\t\tif (!es2->es_len)\n\t\t\t__es_free_extent(es2);\n\t\tes2 = NULL;\n\t}\n\n\tif (allocated)\n\t\t__insert_pending(inode, lblk);\nerror:\n\twrite_unlock(&EXT4_I(inode)->i_es_lock);\n\tif (err1 || err2)\n\t\tgoto retry;\n\n\text4_es_print_tree(inode);\n\text4_print_pending_tree(inode);\n\treturn;\n}", "target": 2, "idx": 11185}
{"commit_id": "83eaddab4378db256d00d295bda6ca997cd13a52", "project": "torvalds/linux", "func": "static struct sock *tcp_v6_syn_recv_sock(const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\t struct request_sock *req,\n\t\t\t\t\t struct dst_entry *dst,\n\t\t\t\t\t struct request_sock *req_unhash,\n\t\t\t\t\t bool *own_req)\n{\n\tstruct inet_request_sock *ireq;\n\tstruct ipv6_pinfo *newnp;\n\tconst struct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct ipv6_txoptions *opt;\n\tstruct tcp6_sock *newtcp6sk;\n\tstruct inet_sock *newinet;\n\tstruct tcp_sock *newtp;\n\tstruct sock *newsk;\n#ifdef CONFIG_TCP_MD5SIG\n\tstruct tcp_md5sig_key *key;\n#endif\n\tstruct flowi6 fl6;\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\t/*\n\t\t *\tv6 mapped\n\t\t */\n\n\t\tnewsk = tcp_v4_syn_recv_sock(sk, skb, req, dst,\n\t\t\t\t\t     req_unhash, own_req);\n\n\t\tif (!newsk)\n\t\t\treturn NULL;\n\n\t\tnewtcp6sk = (struct tcp6_sock *)newsk;\n\t\tinet_sk(newsk)->pinet6 = &newtcp6sk->inet6;\n\n\t\tnewinet = inet_sk(newsk);\n\t\tnewnp = inet6_sk(newsk);\n\t\tnewtp = tcp_sk(newsk);\n\n\t\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\t\tnewnp->saddr = newsk->sk_v6_rcv_saddr;\n\n\t\tinet_csk(newsk)->icsk_af_ops = &ipv6_mapped;\n\t\tnewsk->sk_backlog_rcv = tcp_v4_do_rcv;\n#ifdef CONFIG_TCP_MD5SIG\n\t\tnewtp->af_specific = &tcp_sock_ipv6_mapped_specific;\n#endif\n\n\t\tnewnp->ipv6_mc_list = NULL;\n\t\tnewnp->ipv6_ac_list = NULL;\n\t\tnewnp->ipv6_fl_list = NULL;\n\t\tnewnp->pktoptions  = NULL;\n\t\tnewnp->opt\t   = NULL;\n\t\tnewnp->mcast_oif   = tcp_v6_iif(skb);\n\t\tnewnp->mcast_hops  = ipv6_hdr(skb)->hop_limit;\n\t\tnewnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(skb));\n\t\tif (np->repflow)\n\t\t\tnewnp->flow_label = ip6_flowlabel(ipv6_hdr(skb));\n\n\t\t/*\n\t\t * No need to charge this sock to the relevant IPv6 refcnt debug socks count\n\t\t * here, tcp_create_openreq_child now does this for us, see the comment in\n\t\t * that function for the gory details. -acme\n\t\t */\n\n\t\t/* It is tricky place. Until this moment IPv4 tcp\n\t\t   worked with IPv6 icsk.icsk_af_ops.\n\t\t   Sync it now.\n\t\t */\n\t\ttcp_sync_mss(newsk, inet_csk(newsk)->icsk_pmtu_cookie);\n\n\t\treturn newsk;\n\t}\n\n\tireq = inet_rsk(req);\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto out_overflow;\n\n\tif (!dst) {\n\t\tdst = inet6_csk_route_req(sk, &fl6, req, IPPROTO_TCP);\n\t\tif (!dst)\n\t\t\tgoto out;\n\t}\n\n\tnewsk = tcp_create_openreq_child(sk, req, skb);\n\tif (!newsk)\n\t\tgoto out_nonewsk;\n\n\t/*\n\t * No need to charge this sock to the relevant IPv6 refcnt debug socks\n\t * count here, tcp_create_openreq_child now does this for us, see the\n\t * comment in that function for the gory details. -acme\n\t */\n\n\tnewsk->sk_gso_type = SKB_GSO_TCPV6;\n\tip6_dst_store(newsk, dst, NULL, NULL);\n\tinet6_sk_rx_dst_set(newsk, skb);\n\n\tnewtcp6sk = (struct tcp6_sock *)newsk;\n\tinet_sk(newsk)->pinet6 = &newtcp6sk->inet6;\n\n\tnewtp = tcp_sk(newsk);\n\tnewinet = inet_sk(newsk);\n\tnewnp = inet6_sk(newsk);\n\n\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\tnewsk->sk_v6_daddr = ireq->ir_v6_rmt_addr;\n\tnewnp->saddr = ireq->ir_v6_loc_addr;\n\tnewsk->sk_v6_rcv_saddr = ireq->ir_v6_loc_addr;\n\tnewsk->sk_bound_dev_if = ireq->ir_iif;\n\n\t/* Now IPv6 options...\n\n\t   First: no IPv4 options.\n\t */\n\tnewinet->inet_opt = NULL;\n\tnewnp->ipv6_mc_list = NULL;\n\tnewnp->ipv6_ac_list = NULL;\n\tnewnp->ipv6_fl_list = NULL;\n\n\t/* Clone RX bits */\n\tnewnp->rxopt.all = np->rxopt.all;\n\n\tnewnp->pktoptions = NULL;\n\tnewnp->opt\t  = NULL;\n\tnewnp->mcast_oif  = tcp_v6_iif(skb);\n\tnewnp->mcast_hops = ipv6_hdr(skb)->hop_limit;\n\tnewnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(skb));\n\tif (np->repflow)\n\t\tnewnp->flow_label = ip6_flowlabel(ipv6_hdr(skb));\n\n\t/* Clone native IPv6 options from listening socket (if any)\n\n\t   Yes, keeping reference count would be much more clever,\n\t   but we make one more one thing there: reattach optmem\n\t   to newsk.\n\t */\n\topt = ireq->ipv6_opt;\n\tif (!opt)\n\t\topt = rcu_dereference(np->opt);\n\tif (opt) {\n\t\topt = ipv6_dup_options(newsk, opt);\n\t\tRCU_INIT_POINTER(newnp->opt, opt);\n\t}\n\tinet_csk(newsk)->icsk_ext_hdr_len = 0;\n\tif (opt)\n\t\tinet_csk(newsk)->icsk_ext_hdr_len = opt->opt_nflen +\n\t\t\t\t\t\t    opt->opt_flen;\n\n\ttcp_ca_openreq_child(newsk, dst);\n\n\ttcp_sync_mss(newsk, dst_mtu(dst));\n\tnewtp->advmss = tcp_mss_clamp(tcp_sk(sk), dst_metric_advmss(dst));\n\n\ttcp_initialize_rcv_mss(newsk);\n\n\tnewinet->inet_daddr = newinet->inet_saddr = LOOPBACK4_IPV6;\n\tnewinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n#ifdef CONFIG_TCP_MD5SIG\n\t/* Copy over the MD5 key from the original socket */\n\tkey = tcp_v6_md5_do_lookup(sk, &newsk->sk_v6_daddr);\n\tif (key) {\n\t\t/* We're using one, so create a matching key\n\t\t * on the newsk structure. If we fail to get\n\t\t * memory, then we end up not copying the key\n\t\t * across. Shucks.\n\t\t */\n\t\ttcp_md5_do_add(newsk, (union tcp_md5_addr *)&newsk->sk_v6_daddr,\n\t\t\t       AF_INET6, key->key, key->keylen,\n\t\t\t       sk_gfp_mask(sk, GFP_ATOMIC));\n\t}\n#endif\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tinet_csk_prepare_forced_close(newsk);\n\t\ttcp_done(newsk);\n\t\tgoto out;\n\t}\n\t*own_req = inet_ehash_nolisten(newsk, req_to_sk(req_unhash));\n\tif (*own_req) {\n\t\ttcp_move_syn(newtp, req);\n\n\t\t/* Clone pktoptions received with SYN, if we own the req */\n\t\tif (ireq->pktopts) {\n\t\t\tnewnp->pktoptions = skb_clone(ireq->pktopts,\n\t\t\t\t\t\t      sk_gfp_mask(sk, GFP_ATOMIC));\n\t\t\tconsume_skb(ireq->pktopts);\n\t\t\tireq->pktopts = NULL;\n\t\t\tif (newnp->pktoptions) {\n\t\t\t\ttcp_v6_restore_cb(newnp->pktoptions);\n\t\t\t\tskb_set_owner_r(newnp->pktoptions, newsk);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newsk;\n\nout_overflow:\n\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nout_nonewsk:\n\tdst_release(dst);\nout:\n\ttcp_listendrop(sk);\n\treturn NULL;\n}", "target": 2, "idx": 11186}
{"commit_id": "5d37af364dc158aa387f7c8b2a05c90325c63dce", "project": "xen-project/xen", "func": "void load_system_tables(void)\n{\n\tunsigned int cpu = smp_processor_id();\n\tunsigned long stack_bottom = get_stack_bottom(),\n\t\tstack_top = stack_bottom & ~(STACK_SIZE - 1);\n\n\tstruct tss_struct *tss = &this_cpu(init_tss);\n\tstruct desc_struct *gdt =\n\t\tthis_cpu(gdt_table) - FIRST_RESERVED_GDT_ENTRY;\n\tstruct desc_struct *compat_gdt =\n\t\tthis_cpu(compat_gdt_table) - FIRST_RESERVED_GDT_ENTRY;\n\n\tconst struct desc_ptr gdtr = {\n\t\t.base = (unsigned long)gdt,\n\t\t.limit = LAST_RESERVED_GDT_BYTE,\n\t};\n\tconst struct desc_ptr idtr = {\n\t\t.base = (unsigned long)idt_tables[cpu],\n\t\t.limit = (IDT_ENTRIES * sizeof(idt_entry_t)) - 1,\n\t};\n\n\t*tss = (struct tss_struct){\n\t\t/* Main stack for interrupts/exceptions. */\n\t\t.rsp0 = stack_bottom,\n\n\t\t/* Ring 1 and 2 stacks poisoned. */\n\t\t.rsp1 = 0x8600111111111111ul,\n\t\t.rsp2 = 0x8600111111111111ul,\n\n\t\t/*\n\t\t * MCE, NMI and Double Fault handlers get their own stacks.\n\t\t * All others poisoned.\n\t\t */\n\t\t.ist = {\n\t\t\t[IST_MCE - 1] = stack_top + IST_MCE * PAGE_SIZE,\n\t\t\t[IST_DF  - 1] = stack_top + IST_DF  * PAGE_SIZE,\n\t\t\t[IST_NMI - 1] = stack_top + IST_NMI * PAGE_SIZE,\n\t\t\t[IST_DB  - 1] = stack_top + IST_DB  * PAGE_SIZE,\n\n\t\t\t[IST_MAX ... ARRAY_SIZE(tss->ist) - 1] =\n\t\t\t\t0x8600111111111111ul,\n\t\t},\n\n\t\t.bitmap = IOBMP_INVALID_OFFSET,\n\t};\n\n\t_set_tssldt_desc(\n\t\tgdt + TSS_ENTRY,\n\t\t(unsigned long)tss,\n\t\toffsetof(struct tss_struct, __cacheline_filler) - 1,\n\t\tSYS_DESC_tss_avail);\n\t_set_tssldt_desc(\n\t\tcompat_gdt + TSS_ENTRY,\n\t\t(unsigned long)tss,\n\t\toffsetof(struct tss_struct, __cacheline_filler) - 1,\n\t\tSYS_DESC_tss_busy);\n\n\tlgdt(&gdtr);\n\tlidt(&idtr);\n\tltr(TSS_ENTRY << 3);\n\tlldt(0);\n\n\tenable_each_ist(idt_tables[cpu]);\n\n\t/*\n\t * Bottom-of-stack must be 16-byte aligned!\n\t *\n\t * Defer checks until exception support is sufficiently set up.\n\t */\n\tBUILD_BUG_ON((sizeof(struct cpu_info) -\n\t\t      offsetof(struct cpu_info, guest_cpu_user_regs.es)) & 0xf);\n\tBUG_ON(system_state != SYS_STATE_early_boot && (stack_bottom & 0xf));\n}", "target": 2, "idx": 11187}
{"commit_id": "294f2fc6da27620a506e6c050241655459ccd6bd", "project": "torvalds/linux", "func": "static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,\n\t\t\t\t      struct bpf_insn *insn,\n\t\t\t\t      struct bpf_reg_state *dst_reg,\n\t\t\t\t      struct bpf_reg_state src_reg)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tu8 opcode = BPF_OP(insn->code);\n\tbool src_known, dst_known;\n\ts64 smin_val, smax_val;\n\tu64 umin_val, umax_val;\n\tu64 insn_bitness = (BPF_CLASS(insn->code) == BPF_ALU64) ? 64 : 32;\n\tu32 dst = insn->dst_reg;\n\tint ret;\n\n\tif (insn_bitness == 32) {\n\t\t/* Relevant for 32-bit RSH: Information can propagate towards\n\t\t * LSB, so it isn't sufficient to only truncate the output to\n\t\t * 32 bits.\n\t\t */\n\t\tcoerce_reg_to_size(dst_reg, 4);\n\t\tcoerce_reg_to_size(&src_reg, 4);\n\t}\n\n\tsmin_val = src_reg.smin_value;\n\tsmax_val = src_reg.smax_value;\n\tumin_val = src_reg.umin_value;\n\tumax_val = src_reg.umax_value;\n\tsrc_known = tnum_is_const(src_reg.var_off);\n\tdst_known = tnum_is_const(dst_reg->var_off);\n\n\tif ((src_known && (smin_val != smax_val || umin_val != umax_val)) ||\n\t    smin_val > smax_val || umin_val > umax_val) {\n\t\t/* Taint dst register if offset had invalid bounds derived from\n\t\t * e.g. dead branches.\n\t\t */\n\t\t__mark_reg_unknown(env, dst_reg);\n\t\treturn 0;\n\t}\n\n\tif (!src_known &&\n\t    opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND) {\n\t\t__mark_reg_unknown(env, dst_reg);\n\t\treturn 0;\n\t}\n\n\tswitch (opcode) {\n\tcase BPF_ADD:\n\t\tret = sanitize_val_alu(env, insn);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"R%d tried to add from different pointers or scalars\\n\", dst);\n\t\t\treturn ret;\n\t\t}\n\t\tscalar_min_max_add(dst_reg, &src_reg);\n\t\tbreak;\n\tcase BPF_SUB:\n\t\tret = sanitize_val_alu(env, insn);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"R%d tried to sub from different pointers or scalars\\n\", dst);\n\t\t\treturn ret;\n\t\t}\n\t\tscalar_min_max_sub(dst_reg, &src_reg);\n\t\tbreak;\n\tcase BPF_MUL:\n\t\tscalar_min_max_mul(dst_reg, &src_reg);\n\t\tbreak;\n\tcase BPF_AND:\n\t\tif (src_known && dst_known) {\n\t\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value &\n\t\t\t\t\t\t  src_reg.var_off.value);\n\t\t\tbreak;\n\t\t}\n\t\tscalar_min_max_and(dst_reg, &src_reg);\n\t\tbreak;\n\tcase BPF_OR:\n\t\tif (src_known && dst_known) {\n\t\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value |\n\t\t\t\t\t\t  src_reg.var_off.value);\n\t\t\tbreak;\n\t\t}\n\t\tscalar_min_max_or(dst_reg, &src_reg);\n\t\tbreak;\n\tcase BPF_LSH:\n\t\tif (umax_val >= insn_bitness) {\n\t\t\t/* Shifts greater than 31 or 63 are undefined.\n\t\t\t * This includes shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\tscalar_min_max_lsh(dst_reg, &src_reg);\n\t\tbreak;\n\tcase BPF_RSH:\n\t\tif (umax_val >= insn_bitness) {\n\t\t\t/* Shifts greater than 31 or 63 are undefined.\n\t\t\t * This includes shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\tscalar_min_max_rsh(dst_reg, &src_reg);\n\t\tbreak;\n\tcase BPF_ARSH:\n\t\tif (umax_val >= insn_bitness) {\n\t\t\t/* Shifts greater than 31 or 63 are undefined.\n\t\t\t * This includes shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\tscalar_min_max_arsh(dst_reg, &src_reg, insn_bitness);\n\t\tbreak;\n\tdefault:\n\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\tbreak;\n\t}\n\n\tif (BPF_CLASS(insn->code) != BPF_ALU64) {\n\t\t/* 32-bit ALU ops are (32,32)->32 */\n\t\tcoerce_reg_to_size(dst_reg, 4);\n\t}\n\n\t__update_reg_bounds(dst_reg);\n\t__reg_deduce_bounds(dst_reg);\n\t__reg_bound_offset(dst_reg);\n\treturn 0;\n}", "target": 1, "idx": 11188}
{"commit_id": "c6173f5fe66cdbab74f4f869311fe6aae2ba35f4", "project": "tensorflow", "func": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  OpData* op_data = reinterpret_cast<OpData*>(node->user_data);\n  int num_inputs = node->inputs->size;\n  // The number of outputs should be the same as number of inputs.\n  TF_LITE_ENSURE_EQ(context, node->outputs->size, num_inputs);\n\n  // Check subgraph indices and get subgraphs.\n  Subgraph* this_subgraph = reinterpret_cast<Subgraph*>(context->impl_);\n  auto* subgraphs = this_subgraph->GetSubgraphs();\n  TF_LITE_ENSURE(context, op_data->cond_subgraph_index < subgraphs->size());\n  TF_LITE_ENSURE(context, op_data->body_subgraph_index < subgraphs->size());\n\n  Subgraph* cond_subgraph = (*subgraphs)[op_data->cond_subgraph_index].get();\n  Subgraph* body_subgraph = (*subgraphs)[op_data->body_subgraph_index].get();\n\n  // Check input & output count of the condition subgraph.\n  TF_LITE_ENSURE_EQ(context, cond_subgraph->inputs().size(), num_inputs);\n  TF_LITE_ENSURE_EQ(context, cond_subgraph->outputs().size(), 1);\n\n  // Check input & output count of the body subgraph.\n  TF_LITE_ENSURE_EQ(context, body_subgraph->inputs().size(), num_inputs);\n  TF_LITE_ENSURE_EQ(context, body_subgraph->outputs().size(), num_inputs);\n\n  // Prepare and check the condition subgraph.\n  TF_LITE_ENSURE_OK(\n      context, CopyTensorsShapeAndType(\n                   context, this_subgraph, TfLiteIntArrayView(node->inputs),\n                   cond_subgraph, cond_subgraph->inputs(), true));\n  TF_LITE_ENSURE_OK(context, cond_subgraph->AllocateTensors());\n  TfLiteTensor* cond_output =\n      cond_subgraph->tensor(cond_subgraph->outputs()[0]);\n  // This should rarely happens. In most cases the output is static with shape\n  // [1]. However theoretically intermediate tensors in the cond subgraph\n  // can be dynamic.\n  if (IsDynamicTensor(cond_output)) {\n    op_data->cond_has_dynamic_output_tensors = true;\n  } else {\n    TF_LITE_ENSURE_STATUS(CheckCondOutput(context, cond_output));\n  }\n\n  // Prepare and check the body subgraph.\n  TF_LITE_ENSURE_OK(\n      context, CopyTensorsShapeAndType(\n                   context, this_subgraph, TfLiteIntArrayView(node->inputs),\n                   body_subgraph, body_subgraph->inputs(), true));\n  TF_LITE_ENSURE_OK(context, body_subgraph->AllocateTensors());\n  if (body_subgraph->HasDynamicTensors()) {\n    op_data->body_has_dynamic_output_tensors = true;\n  } else {\n    for (int i = 0; i < num_inputs; ++i) {\n      TfLiteTensor* body_input =\n          body_subgraph->tensor(body_subgraph->inputs()[i]);\n      TfLiteTensor* body_output =\n          body_subgraph->tensor(body_subgraph->outputs()[i]);\n      TF_LITE_ENSURE_TYPES_EQ(context, body_input->type, body_output->type);\n\n      TF_LITE_ENSURE(context, !IsDynamicTensor(body_output));\n      if (!TfLiteIntArrayEqual(body_input->dims, body_output->dims)) {\n        // If the output shape of the body subgraph is static w.r.t. a fixed\n        // input size, but it's different from input size, it's still considered\n        // dynamic. For example: If a subgraph keeps padding its input with a\n        // fixed padding, the output shape is static w.r.t the input shape and\n        // padding, but running it in a loop will keep bloating the tensor.\n        op_data->body_has_dynamic_output_tensors = true;\n        break;\n      }\n    }\n  }\n  for (int i = 0; i < num_inputs; ++i) {\n    TfLiteTensor* output;\n    TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, i, &output));\n    if (op_data->body_has_dynamic_output_tensors) {\n      SetTensorToDynamic(output);\n    } else {\n      TfLiteTensor* body_output =\n          body_subgraph->tensor(body_subgraph->outputs()[i]);\n      TfLiteIntArray* output_size = TfLiteIntArrayCopy(body_output->dims);\n      TF_LITE_ENSURE_OK(context,\n                        context->ResizeTensor(context, output, output_size));\n    }\n  }\n  return kTfLiteOk;\n}", "target": 2, "idx": 11189}
{"commit_id": "d00d8da5869a2608e97cfede094dfc5e11462a46", "project": "torvalds/linux", "func": "static struct port_buffer *get_inbuf(struct port *port)\n{\n\tstruct port_buffer *buf;\n\tunsigned int len;\n\n\tif (port->inbuf)\n\t\treturn port->inbuf;\n\n\tbuf = virtqueue_get_buf(port->in_vq, &len);\n\tif (buf) {\n\t\tbuf->len = min_t(size_t, len, buf->size);\n\t\tbuf->offset = 0;\n\t\tport->stats.bytes_received += len;\n\t}\n\treturn buf;\n}", "target": 2, "idx": 11190}
{"commit_id": "ee778252faebb721afba5a081dd6ad7eaf20eef3", "project": "michaelrsweet/htmldoc", "func": "static int\t\t\t/* I - New column */\nwrite_file(tree_t *t,\t\t/* I - Tree entry */\n           FILE   *fp,\t\t/* I - File to write to */\n           int    col)\t\t/* I - Current column */\n{\n  int\ti;\t\t\t/* Looping var */\n  uchar\t*ptr;\t\t\t/* Character pointer */\n\n\n  while (t != NULL)\n  {\n    if (t->markup == MARKUP_NONE)\n    {\n      if (t->preformatted)\n      {\n        for (ptr = t->data; *ptr != '\\0'; ptr ++)\n          fputs((char *)iso8859(*ptr), fp);\n\n\tif (t->data[0] && t->data[strlen((char *)t->data) - 1] == '\\n')\n          col = 0;\n\telse\n          col += strlen((char *)t->data);\n      }\n      else\n      {\n\tif ((col + (int)strlen((char *)t->data)) > 72 && col > 0)\n\t{\n          putc('\\n', fp);\n          col = 0;\n\t}\n\n        for (ptr = t->data; *ptr != '\\0'; ptr ++)\n          fputs((char *)iso8859(*ptr), fp);\n\n\tcol += strlen((char *)t->data);\n\n\tif (col > 72)\n\t{\n          putc('\\n', fp);\n          col = 0;\n\t}\n      }\n    }\n    else if (t->markup == MARKUP_COMMENT)\n      fprintf(fp, \"\\n<!--%s-->\\n\", t->data);\n    else if (t->markup > 0)\n    {\n      switch (t->markup)\n      {\n        case MARKUP_AREA :\n        case MARKUP_BR :\n        case MARKUP_CENTER :\n        case MARKUP_COMMENT :\n        case MARKUP_DD :\n        case MARKUP_DL :\n        case MARKUP_DT :\n        case MARKUP_H1 :\n        case MARKUP_H2 :\n        case MARKUP_H3 :\n        case MARKUP_H4 :\n        case MARKUP_H5 :\n        case MARKUP_H6 :\n        case MARKUP_HEAD :\n        case MARKUP_HR :\n        case MARKUP_LI :\n        case MARKUP_MAP :\n        case MARKUP_OL :\n        case MARKUP_P :\n        case MARKUP_PRE :\n        case MARKUP_TABLE :\n        case MARKUP_TITLE :\n        case MARKUP_TR :\n        case MARKUP_UL :\n\tcase MARKUP_DIR :\n\tcase MARKUP_MENU :\n            if (col > 0)\n            {\n              putc('\\n', fp);\n              col = 0;\n            }\n        default :\n            break;\n      }\n\n      col += fprintf(fp, \"<%s\", _htmlMarkups[t->markup]);\n      for (i = 0; i < t->nvars; i ++)\n      {\n\tif (col > 72 && !t->preformatted)\n\t{\n          putc('\\n', fp);\n          col = 0;\n\t}\n\n        if (col > 0)\n        {\n          putc(' ', fp);\n          col ++;\n        }\n\n\tif (t->vars[i].value == NULL)\n          col += fprintf(fp, \"%s\", t->vars[i].name);\n\telse if (strchr((char *)t->vars[i].value, '\\\"') != NULL)\n          col += fprintf(fp, \"%s=\\'%s\\'\", t->vars[i].name, t->vars[i].value);\n\telse\n          col += fprintf(fp, \"%s=\\\"%s\\\"\", t->vars[i].name, t->vars[i].value);\n      }\n\n      putc('>', fp);\n      col ++;\n\n      if (col > 72 && !t->preformatted)\n      {\n\tputc('\\n', fp);\n\tcol = 0;\n      }\n\n      if (t->child != NULL)\n      {\n\tcol = write_file(t->child, fp, col);\n\n\tif (col > 72 && !t->preformatted)\n\t{\n\t  putc('\\n', fp);\n\t  col = 0;\n\t}\n\n        col += fprintf(fp, \"</%s>\", _htmlMarkups[t->markup]);\n        switch (t->markup)\n        {\n          case MARKUP_AREA :\n          case MARKUP_BR :\n          case MARKUP_CENTER :\n          case MARKUP_COMMENT :\n          case MARKUP_DD :\n          case MARKUP_DL :\n          case MARKUP_DT :\n          case MARKUP_H1 :\n          case MARKUP_H2 :\n          case MARKUP_H3 :\n          case MARKUP_H4 :\n          case MARKUP_H5 :\n          case MARKUP_H6 :\n          case MARKUP_HEAD :\n          case MARKUP_HR :\n          case MARKUP_LI :\n          case MARKUP_MAP :\n          case MARKUP_OL :\n          case MARKUP_P :\n          case MARKUP_PRE :\n          case MARKUP_TABLE :\n          case MARKUP_TITLE :\n          case MARKUP_TR :\n          case MARKUP_UL :\n          case MARKUP_DIR :\n          case MARKUP_MENU :\n              putc('\\n', fp);\n              col = 0;\n          default :\n\t      break;\n        }\n      }\n    }\n\n    t = t->next;\n  }\n\n  return (col);\n}", "target": 2, "idx": 11191}
{"commit_id": "64f42c73efc58e88671ad76b6b6bc8e2b62713e1", "project": "php/php-src", "func": "mbfl_string *\nmbfl_ja_jp_hantozen(\n    mbfl_string *string,\n    mbfl_string *result,\n    int mode)\n{\n\tint n;\n\tunsigned char *p;\n\tconst mbfl_encoding *encoding;\n\tmbfl_memory_device device;\n\tmbfl_convert_filter *decoder = NULL;\n\tmbfl_convert_filter *encoder = NULL;\n\tmbfl_convert_filter *tl_filter = NULL;\n\tmbfl_convert_filter *next_filter = NULL;\n\tmbfl_filt_tl_jisx0201_jisx0208_param *param = NULL;\n\n\t/* validate parameters */\n\tif (string == NULL || result == NULL) {\n\t\treturn NULL;\n\t}\n\n\tencoding = mbfl_no2encoding(string->no_encoding);\n\tif (encoding == NULL) {\n\t\treturn NULL;\n\t}\n\n\tmbfl_memory_device_init(&device, string->len, 0);\n\tmbfl_string_init(result);\n\n\tresult->no_language = string->no_language;\n\tresult->no_encoding = string->no_encoding;\n\n\tdecoder = mbfl_convert_filter_new(\n\t\tmbfl_no_encoding_wchar,\n\t\tstring->no_encoding,\n\t\tmbfl_memory_device_output, 0, &device);\n\tif (decoder == NULL) {\n\t\tgoto out;\n\t}\n\tnext_filter = decoder;\n\n\tparam =\n\t\t(mbfl_filt_tl_jisx0201_jisx0208_param *)mbfl_malloc(sizeof(mbfl_filt_tl_jisx0201_jisx0208_param));\n\tif (param == NULL) {\n\t\tgoto out;\n\t}\n\n\tparam->mode = mode;\n\n\ttl_filter = mbfl_convert_filter_new2(\n\t\t&vtbl_tl_jisx0201_jisx0208,\n\t\t(int(*)(int, void*))next_filter->filter_function,\n\t\t(int(*)(void*))next_filter->filter_flush,\n\t\tnext_filter);\n\tif (tl_filter == NULL) {\n\t\tmbfl_free(param);\n\t\tgoto out;\n\t}\n\n\ttl_filter->opaque = param;\n\tnext_filter = tl_filter;\n\n\tencoder = mbfl_convert_filter_new(\n\t\tstring->no_encoding,\n\t\tmbfl_no_encoding_wchar,\n\t\t(int(*)(int, void*))next_filter->filter_function,\n\t\t(int(*)(void*))next_filter->filter_flush,\n\t\tnext_filter);\n\tif (encoder == NULL) {\n\t\tgoto out;\n\t}\n\n\t/* feed data */\n\tp = string->val;\n\tn = string->len;\n\tif (p != NULL) {\n\t\twhile (n > 0) {\n\t\t\tif ((*encoder->filter_function)(*p++, encoder) < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn--;\n\t\t}\n\t}\n\n\tmbfl_convert_filter_flush(encoder);\n\tresult = mbfl_memory_device_result(&device, result);\nout:\n\tif (tl_filter != NULL) {\n\t\tif (tl_filter->opaque != NULL) {\n\t\t\tmbfl_free(tl_filter->opaque);\n\t\t}\n\t\tmbfl_convert_filter_delete(tl_filter);\n\t}\n\n\tif (decoder != NULL) {\n\t\tmbfl_convert_filter_delete(decoder);\n\t}\n\n\tif (encoder != NULL) {\n\t\tmbfl_convert_filter_delete(encoder);\n\t}\n\n\treturn result;\n}", "target": 3, "idx": 11192}
{"commit_id": "07d86ca93db7e5cdf4743564d98292042ec21af7", "project": "torvalds/linux", "func": "int snd_usbmidi_create(struct snd_card *card,\n\t\t       struct usb_interface *iface,\n\t\t       struct list_head *midi_list,\n\t\t       const struct snd_usb_audio_quirk *quirk)\n{\n\tstruct snd_usb_midi *umidi;\n\tstruct snd_usb_midi_endpoint_info endpoints[MIDI_MAX_ENDPOINTS];\n\tint out_ports, in_ports;\n\tint i, err;\n\n\tumidi = kzalloc(sizeof(*umidi), GFP_KERNEL);\n\tif (!umidi)\n\t\treturn -ENOMEM;\n\tumidi->dev = interface_to_usbdev(iface);\n\tumidi->card = card;\n\tumidi->iface = iface;\n\tumidi->quirk = quirk;\n\tumidi->usb_protocol_ops = &snd_usbmidi_standard_ops;\n\tspin_lock_init(&umidi->disc_lock);\n\tinit_rwsem(&umidi->disc_rwsem);\n\tmutex_init(&umidi->mutex);\n\tumidi->usb_id = USB_ID(le16_to_cpu(umidi->dev->descriptor.idVendor),\n\t\t\t       le16_to_cpu(umidi->dev->descriptor.idProduct));\n\tsetup_timer(&umidi->error_timer, snd_usbmidi_error_timer,\n\t\t    (unsigned long)umidi);\n\n\t/* detect the endpoint(s) to use */\n\tmemset(endpoints, 0, sizeof(endpoints));\n\tswitch (quirk ? quirk->type : QUIRK_MIDI_STANDARD_INTERFACE) {\n\tcase QUIRK_MIDI_STANDARD_INTERFACE:\n\t\terr = snd_usbmidi_get_ms_info(umidi, endpoints);\n\t\tif (umidi->usb_id == USB_ID(0x0763, 0x0150)) /* M-Audio Uno */\n\t\t\tumidi->usb_protocol_ops =\n\t\t\t\t&snd_usbmidi_maudio_broken_running_status_ops;\n\t\tbreak;\n\tcase QUIRK_MIDI_US122L:\n\t\tumidi->usb_protocol_ops = &snd_usbmidi_122l_ops;\n\t\t/* fall through */\n\tcase QUIRK_MIDI_FIXED_ENDPOINT:\n\t\tmemcpy(&endpoints[0], quirk->data,\n\t\t       sizeof(struct snd_usb_midi_endpoint_info));\n\t\terr = snd_usbmidi_detect_endpoints(umidi, &endpoints[0], 1);\n\t\tbreak;\n\tcase QUIRK_MIDI_YAMAHA:\n\t\terr = snd_usbmidi_detect_yamaha(umidi, &endpoints[0]);\n\t\tbreak;\n\tcase QUIRK_MIDI_ROLAND:\n\t\terr = snd_usbmidi_detect_roland(umidi, &endpoints[0]);\n\t\tbreak;\n\tcase QUIRK_MIDI_MIDIMAN:\n\t\tumidi->usb_protocol_ops = &snd_usbmidi_midiman_ops;\n\t\tmemcpy(&endpoints[0], quirk->data,\n\t\t       sizeof(struct snd_usb_midi_endpoint_info));\n\t\terr = 0;\n\t\tbreak;\n\tcase QUIRK_MIDI_NOVATION:\n\t\tumidi->usb_protocol_ops = &snd_usbmidi_novation_ops;\n\t\terr = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);\n\t\tbreak;\n\tcase QUIRK_MIDI_RAW_BYTES:\n\t\tumidi->usb_protocol_ops = &snd_usbmidi_raw_ops;\n\t\t/*\n\t\t * Interface 1 contains isochronous endpoints, but with the same\n\t\t * numbers as in interface 0.  Since it is interface 1 that the\n\t\t * USB core has most recently seen, these descriptors are now\n\t\t * associated with the endpoint numbers.  This will foul up our\n\t\t * attempts to submit bulk/interrupt URBs to the endpoints in\n\t\t * interface 0, so we have to make sure that the USB core looks\n\t\t * again at interface 0 by calling usb_set_interface() on it.\n\t\t */\n\t\tif (umidi->usb_id == USB_ID(0x07fd, 0x0001)) /* MOTU Fastlane */\n\t\t\tusb_set_interface(umidi->dev, 0, 0);\n\t\terr = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);\n\t\tbreak;\n\tcase QUIRK_MIDI_EMAGIC:\n\t\tumidi->usb_protocol_ops = &snd_usbmidi_emagic_ops;\n\t\tmemcpy(&endpoints[0], quirk->data,\n\t\t       sizeof(struct snd_usb_midi_endpoint_info));\n\t\terr = snd_usbmidi_detect_endpoints(umidi, &endpoints[0], 1);\n\t\tbreak;\n\tcase QUIRK_MIDI_CME:\n\t\tumidi->usb_protocol_ops = &snd_usbmidi_cme_ops;\n\t\terr = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);\n\t\tbreak;\n\tcase QUIRK_MIDI_AKAI:\n\t\tumidi->usb_protocol_ops = &snd_usbmidi_akai_ops;\n\t\terr = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);\n\t\t/* endpoint 1 is input-only */\n\t\tendpoints[1].out_cables = 0;\n\t\tbreak;\n\tcase QUIRK_MIDI_FTDI:\n\t\tumidi->usb_protocol_ops = &snd_usbmidi_ftdi_ops;\n\n\t\t/* set baud rate to 31250 (48 MHz / 16 / 96) */\n\t\terr = usb_control_msg(umidi->dev, usb_sndctrlpipe(umidi->dev, 0),\n\t\t\t\t      3, 0x40, 0x60, 0, NULL, 0, 1000);\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t\terr = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);\n\t\tbreak;\n\tcase QUIRK_MIDI_CH345:\n\t\tumidi->usb_protocol_ops = &snd_usbmidi_ch345_broken_sysex_ops;\n\t\terr = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&umidi->dev->dev, \"invalid quirk type %d\\n\",\n\t\t\tquirk->type);\n\t\terr = -ENXIO;\n\t\tbreak;\n\t}\n\tif (err < 0) {\n\t\tkfree(umidi);\n\t\treturn err;\n\t}\n\n\t/* create rawmidi device */\n\tout_ports = 0;\n\tin_ports = 0;\n\tfor (i = 0; i < MIDI_MAX_ENDPOINTS; ++i) {\n\t\tout_ports += hweight16(endpoints[i].out_cables);\n\t\tin_ports += hweight16(endpoints[i].in_cables);\n\t}\n\terr = snd_usbmidi_create_rawmidi(umidi, out_ports, in_ports);\n\tif (err < 0) {\n\t\tkfree(umidi);\n\t\treturn err;\n\t}\n\n\t/* create endpoint/port structures */\n\tif (quirk && quirk->type == QUIRK_MIDI_MIDIMAN)\n\t\terr = snd_usbmidi_create_endpoints_midiman(umidi, &endpoints[0]);\n\telse\n\t\terr = snd_usbmidi_create_endpoints(umidi, endpoints);\n\tif (err < 0) {\n\t\treturn err;\n\t}\n\n\tusb_autopm_get_interface_no_resume(umidi->iface);\n\n\tlist_add_tail(&umidi->list, midi_list);\n\treturn 0;\n}", "target": 1, "idx": 11193}
{"commit_id": "4dca6ea1d9432052afb06baf2e3ae78188a4410b", "project": "torvalds/linux", "func": "static int construct_get_dest_keyring(struct key **_dest_keyring)\n{\n\tstruct request_key_auth *rka;\n\tconst struct cred *cred = current_cred();\n\tstruct key *dest_keyring = *_dest_keyring, *authkey;\n\tint ret;\n\n\tkenter(\"%p\", dest_keyring);\n\n\t/* find the appropriate keyring */\n\tif (dest_keyring) {\n\t\t/* the caller supplied one */\n\t\tkey_get(dest_keyring);\n\t} else {\n\t\tbool do_perm_check = true;\n\n\t\t/* use a default keyring; falling through the cases until we\n\t\t * find one that we actually have */\n\t\tswitch (cred->jit_keyring) {\n\t\tcase KEY_REQKEY_DEFL_DEFAULT:\n\t\tcase KEY_REQKEY_DEFL_REQUESTOR_KEYRING:\n\t\t\tif (cred->request_key_auth) {\n\t\t\t\tauthkey = cred->request_key_auth;\n\t\t\t\tdown_read(&authkey->sem);\n\t\t\t\trka = authkey->payload.data[0];\n\t\t\t\tif (!test_bit(KEY_FLAG_REVOKED,\n\t\t\t\t\t      &authkey->flags))\n\t\t\t\t\tdest_keyring =\n\t\t\t\t\t\tkey_get(rka->dest_keyring);\n\t\t\t\tup_read(&authkey->sem);\n\t\t\t\tif (dest_keyring) {\n\t\t\t\t\tdo_perm_check = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\tcase KEY_REQKEY_DEFL_THREAD_KEYRING:\n\t\t\tdest_keyring = key_get(cred->thread_keyring);\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_PROCESS_KEYRING:\n\t\t\tdest_keyring = key_get(cred->process_keyring);\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_SESSION_KEYRING:\n\t\t\trcu_read_lock();\n\t\t\tdest_keyring = key_get(\n\t\t\t\trcu_dereference(cred->session_keyring));\n\t\t\trcu_read_unlock();\n\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_USER_SESSION_KEYRING:\n\t\t\tdest_keyring =\n\t\t\t\tkey_get(cred->user->session_keyring);\n\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_USER_KEYRING:\n\t\t\tdest_keyring = key_get(cred->user->uid_keyring);\n\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_GROUP_KEYRING:\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\n\t\t/*\n\t\t * Require Write permission on the keyring.  This is essential\n\t\t * because the default keyring may be the session keyring, and\n\t\t * joining a keyring only requires Search permission.\n\t\t *\n\t\t * However, this check is skipped for the \"requestor keyring\" so\n\t\t * that /sbin/request-key can itself use request_key() to add\n\t\t * keys to the original requestor's destination keyring.\n\t\t */\n\t\tif (dest_keyring && do_perm_check) {\n\t\t\tret = key_permission(make_key_ref(dest_keyring, 1),\n\t\t\t\t\t     KEY_NEED_WRITE);\n\t\t\tif (ret) {\n\t\t\t\tkey_put(dest_keyring);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\t*_dest_keyring = dest_keyring;\n\tkleave(\" [dk %d]\", key_serial(dest_keyring));\n\treturn 0;\n}", "target": 0, "idx": 11194}
{"commit_id": "5d069dbe8aaf2a197142558b6fb2978189ba3454", "project": "torvalds/linux", "func": "static int create_new_entry(struct fuse_mount *fm, struct fuse_args *args,\n\t\t\t    struct inode *dir, struct dentry *entry,\n\t\t\t    umode_t mode)\n{\n\tstruct fuse_entry_out outarg;\n\tstruct inode *inode;\n\tstruct dentry *d;\n\tint err;\n\tstruct fuse_forget_link *forget;\n\n\tif (fuse_is_bad(dir))\n\t\treturn -EIO;\n\n\tforget = fuse_alloc_forget();\n\tif (!forget)\n\t\treturn -ENOMEM;\n\n\tmemset(&outarg, 0, sizeof(outarg));\n\targs->nodeid = get_node_id(dir);\n\targs->out_numargs = 1;\n\targs->out_args[0].size = sizeof(outarg);\n\targs->out_args[0].value = &outarg;\n\terr = fuse_simple_request(fm, args);\n\tif (err)\n\t\tgoto out_put_forget_req;\n\n\terr = -EIO;\n\tif (invalid_nodeid(outarg.nodeid) || fuse_invalid_attr(&outarg.attr))\n\t\tgoto out_put_forget_req;\n\n\tif ((outarg.attr.mode ^ mode) & S_IFMT)\n\t\tgoto out_put_forget_req;\n\n\tinode = fuse_iget(dir->i_sb, outarg.nodeid, outarg.generation,\n\t\t\t  &outarg.attr, entry_attr_timeout(&outarg), 0);\n\tif (!inode) {\n\t\tfuse_queue_forget(fm->fc, forget, outarg.nodeid, 1);\n\t\treturn -ENOMEM;\n\t}\n\tkfree(forget);\n\n\td_drop(entry);\n\td = d_splice_alias(inode, entry);\n\tif (IS_ERR(d))\n\t\treturn PTR_ERR(d);\n\n\tif (d) {\n\t\tfuse_change_entry_timeout(d, &outarg);\n\t\tdput(d);\n\t} else {\n\t\tfuse_change_entry_timeout(entry, &outarg);\n\t}\n\tfuse_dir_changed(dir);\n\treturn 0;\n\n out_put_forget_req:\n\tkfree(forget);\n\treturn err;\n}", "target": 1, "idx": 11195}
{"commit_id": "2b64ad928ef5f75fc93091677a78abfbd17ea07f", "project": "openlink/virtuoso-opensource", "func": "void\nsqlg_simple_fun_ref (sqlo_t * so, data_source_t ** head, df_elt_t * tb_dfe, dk_set_t cum_code)\n{\n  dpipe_node_t * dp = NULL;\n  dk_set_t post_fref_code = NULL;\n\n  sql_comp_t * sc = so->so_sc;\n  op_table_t * ot = tb_dfe->_.sub.ot;\n  dk_set_t temp_save = sc->sc_fun_ref_temps;\n  dk_set_t def_save = sc->sc_fun_ref_defaults;\n  dk_set_t def_ssls = sc->sc_fun_ref_default_ssls;\n\n  sc->sc_fun_ref_temps = NULL;\n  sc->sc_fun_ref_defaults = NULL;\n  sc->sc_fun_ref_default_ssls = NULL;\n\n  {\n    data_source_t * last = sql_node_last (*head);\n    SQL_NODE_INIT (fun_ref_node_t, fref, fun_ref_node_input, fun_ref_free);\n    sc->sc_fref = fref;\n    DO_SET (ST *, fref, &ot->ot_fun_refs)\n      {\n\tint ign;\n\tstate_slot_t * ssl = select_ref_generate (sc, fref, &post_fref_code, &cum_code, &ign);\n\tdf_elt_t * fref_dfe = sqlo_df (so, fref);\n\tfref_dfe->dfe_ssl = ssl;\n      }\n    END_DO_SET();\n    dp = sqlg_pre_code_dpipe (so, &cum_code, NULL);\n    if (dp)\n      {\n\tlast->src_continuations = dk_set_cons ((void*)dp, NULL);\n\tdp->src_gen.src_after_code = code_to_cv (so->so_sc, cum_code);\n\tdk_set_delete (&last->src_query->qr_nodes, (void*)dp);\n\tdk_set_ins_before (&last->src_query->qr_nodes, (void*)last, (void*)dp);\n      }\n    else\n      {\n\tlast->src_after_code = code_to_cv (so->so_sc, cum_code);\n      }\n    fref->src_gen.src_after_code = code_to_cv (sc, post_fref_code);\n    fref->fnr_default_values = dk_set_nreverse (sc->sc_fun_ref_defaults);\n    sc->sc_fun_ref_defaults = def_save;\n    fref->fnr_default_ssls = dk_set_nreverse (sc->sc_fun_ref_default_ssls);\n    sc->sc_fun_ref_default_ssls = def_ssls;\n    fref->fnr_temp_slots = sc->sc_fun_ref_temps;\n    sc->sc_fun_ref_temps = temp_save;\n    sqlg_place_fref (sc, head, fref, tb_dfe);\n  }\n}", "target": 2, "idx": 11196}
{"commit_id": "88e7b873da5d3e85d31b601c1560d2e24a1d7b25", "project": "gpac", "func": "static s32 gf_vvc_read_sps_bs_internal(GF_BitStream *bs, VVCState *vvc, u8 layer_id, u32 *vui_flag_pos)\n{\n\ts32 vps_id, sps_id;\n\tu32 i, CtbSizeY;\n\tVVC_SPS *sps;\n\tu8 sps_ptl_dpb_hrd_params_present_flag;\n\n\tif (vui_flag_pos) *vui_flag_pos = 0;\n\n\tsps_id = gf_bs_read_int_log(bs, 4, \"sps_id\");\n\tif ((sps_id<0) || (sps_id >= 16)) {\n\t\treturn -1;\n\t}\n\tvps_id = gf_bs_read_int_log(bs, 4, \"vps_id\");\n\tif ((vps_id<0) || (vps_id >= 16)) {\n\t\treturn -1;\n\t}\n\tif (!vps_id && !vvc->vps[0].state) {\n\t\tvvc->vps[0].state = 1;\n\t\tvvc->vps[0].num_ptl = 1;\n\t\tvvc->vps[0].max_layers = 1;\n\t\tvvc->vps[0].all_layers_independent = 1;\n\t}\n\n\tsps = &vvc->sps[sps_id];\n\tif (!sps->state) {\n\t\tsps->state = 1;\n\t\tsps->id = sps_id;\n\t\tsps->vps_id = vps_id;\n\t}\n\tsps->max_sublayers = 1 + gf_bs_read_int_log(bs, 3, \"max_sublayers_minus1\");\n\tsps->chroma_format_idc = gf_bs_read_int_log(bs, 2, \"chroma_format_idc\");\n\tsps->log2_ctu_size = 5 + gf_bs_read_int_log(bs, 2, \"log2_ctu_size_minus5\");\n\tCtbSizeY = 1<<sps->log2_ctu_size;\n\n\tsps_ptl_dpb_hrd_params_present_flag = gf_bs_read_int_log(bs, 1, \"sps_ptl_dpb_hrd_params_present_flag\");\n\tif (sps_ptl_dpb_hrd_params_present_flag) {\n\t\tVVC_ProfileTierLevel ptl, *p_ptl;\n\t\tif (sps->vps_id) {\n\t\t\tp_ptl = &ptl;\n\t\t} else {\n\t\t\tp_ptl = &vvc->vps[0].ptl[0];\n\t\t}\n\t\tmemset(p_ptl, 0, sizeof(VVC_ProfileTierLevel));\n\t\tp_ptl->pt_present = 1;\n\t\tp_ptl->ptl_max_tid = sps->max_sublayers-1;\n\t\tvvc_profile_tier_level(bs, p_ptl, 0);\n\t}\n\tsps->gdr_enabled = gf_bs_read_int_log(bs, 1, \"gdr_enabled\");\n\tsps->ref_pic_resampling = gf_bs_read_int_log(bs, 1, \"ref_pic_resampling\");\n\tif (sps->ref_pic_resampling)\n\t\tsps->res_change_in_clvs = gf_bs_read_int_log(bs, 1, \"res_change_in_clvs\");\n\tsps->width = gf_bs_read_ue_log(bs, \"width\");\n\tsps->height = gf_bs_read_ue_log(bs, \"height\");\n\tsps->conf_window = gf_bs_read_int_log(bs, 1, \"conformance_window_present_flag\");\n\tif (sps->conf_window) {\n\t\tu32 SubWidthC, SubHeightC;\n\t\tsps->cw_left = gf_bs_read_ue_log(bs, \"conformance_window_left\");\n\t\tsps->cw_right = gf_bs_read_ue_log(bs, \"conformance_window_right\");\n\t\tsps->cw_top = gf_bs_read_ue_log(bs, \"conformance_window_top\");\n\t\tsps->cw_bottom = gf_bs_read_ue_log(bs, \"conformance_window_bottom\");\n\n\n\t\tif (sps->chroma_format_idc == 1) {\n\t\t\tSubWidthC = SubHeightC = 2;\n\t\t} else if (sps->chroma_format_idc == 2) {\n\t\t\tSubWidthC = 2;\n\t\t\tSubHeightC = 1;\n\t\t} else {\n\t\t\tSubWidthC = SubHeightC = 1;\n\t\t}\n\t\tsps->width -= SubWidthC * (sps->cw_left + sps->cw_right);\n\t\tsps->height -= SubHeightC * (sps->cw_top + sps->cw_bottom);\n\t}\n\t\n\tsps->subpic_info_present = gf_bs_read_int_log(bs, 1, \"subpic_info_present\");\n\tif (sps->subpic_info_present) {\n\t\tsps->nb_subpics = 1 + gf_bs_read_ue_log(bs, \"nb_subpics_minus1\");\n\t\tif (sps->nb_subpics>1) {\n\t\t\tu32 tmpWidthVal, tmpHeightVal;\n\t\t\tsps->independent_subpic_flags = gf_bs_read_int_log(bs, 1, \"independent_subpic_flags\");\n\t\t\tsps->subpic_same_size = gf_bs_read_int_log(bs, 1, \"subpic_same_size\");\n\n\t\t\ttmpWidthVal = (sps->width + CtbSizeY-1) / CtbSizeY;\n\t\t\ttmpWidthVal = gf_get_bit_size(tmpWidthVal);\n\t\t\ttmpHeightVal = (sps->height + CtbSizeY-1) / CtbSizeY;\n\t\t\ttmpHeightVal = gf_get_bit_size(tmpHeightVal);\n\n\t\t\tfor (i=0; i<sps->nb_subpics; i++) {\n\t\t\t\tif( !sps->subpic_same_size || !i) {\n\t\t\t\t\tif (i && (sps->width > CtbSizeY))\n\t\t\t\t\t\tgf_bs_read_int_log(bs, tmpWidthVal, \"subpic_ctu_top_left_x\");\n\t\t\t\t\tif (i && (sps->height > CtbSizeY))\n\t\t\t\t\t\tgf_bs_read_int_log(bs, tmpHeightVal, \"subpic_ctu_top_left_y\");\n\t\t\t\t\tif ((i+1 < sps->nb_subpics) && (sps->width > CtbSizeY))\n\t\t\t\t\t\tgf_bs_read_int_log(bs, tmpWidthVal, \"subpic_width_minus1\");\n\t\t\t\t\tif ((i+1 < sps->nb_subpics) && (sps->height > CtbSizeY))\n\t\t\t\t\t\tgf_bs_read_int_log(bs, tmpHeightVal, \"subpic_height_minus1\");\n\t\t\t\t}\n\t\t\t\tif (!sps->independent_subpic_flags) {\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"subpic_treated_as_pic_flag\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"loop_filter_across_subpic_enabled_flag\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tsps->subpicid_len = gf_bs_read_ue_log(bs, \"subpic_id_len_minus1\") + 1;\n\t\t\tsps->subpicid_mapping_explicit = gf_bs_read_int_log(bs, 1, \"subpic_id_mapping_explicitly_signalled_flag\");\n\t\t\tif (sps->subpicid_mapping_explicit) {\n\t\t\t\tsps->subpicid_mapping_present = gf_bs_read_int_log(bs, 1, \"subpic_id_mapping_present_flag\");\n\t\t\t\tif (sps->subpicid_mapping_present) {\n\t\t\t\t\tfor (i=0; i<sps->nb_subpics; i++) {\n\t\t\t\t\t\tgf_bs_read_ue_log(bs, \"subpic_id\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tsps->nb_subpics = 1;\n\t}\n\tsps->bitdepth = gf_bs_read_ue_log(bs, \"bitdepth_minus8\") + 8;\n\tsps->entropy_coding_sync_enabled_flag = gf_bs_read_int_log(bs, 1, \"entropy_coding_sync_enabled_flag\");\n\tsps->entry_point_offsets_present_flag = gf_bs_read_int_log(bs, 1, \"entry_point_offsets_present_flag\");\n\tsps->log2_max_poc_lsb = 4 + gf_bs_read_int_log(bs, 4, \"log2_max_poc_lsb_minus4\");\n\tif ((sps->poc_msb_cycle_flag = gf_bs_read_int_log(bs, 1, \"poc_msb_cycle_flag\")))\n\t\tsps->poc_msb_cycle_len = 1 + gf_bs_read_ue_log(bs, \"poc_msb_cycle_len_minus1\");\n\n\tu8 sps_num_extra_ph_bits = 8 * gf_bs_read_int_log(bs, 2, \"sps_num_extra_ph_bytes\");\n\tfor (i=0; i<sps_num_extra_ph_bits; i++) {\n\t\tif (gf_bs_read_int_log_idx(bs, 1, \"extra_ph_bit_present_flag\", 1))\n\t\t\tsps->ph_num_extra_bits++;\n\t}\n\tu8 sps_num_extra_sh_bits = 8 * gf_bs_read_int_log(bs, 2, \"num_extra_sh_bytes\");\n\tfor (i=0; i<sps_num_extra_sh_bits; i++) {\n\t\tif (gf_bs_read_int_log_idx(bs, 1, \"extra_sh_bit_present_flag\", i))\n\t\t\tsps->sh_num_extra_bits++;\n\t}\n\n\tif (sps_ptl_dpb_hrd_params_present_flag) {\n\t\tu8 sps_sublayer_dpb_params_flag = 0;\n\t\tif (sps->max_sublayers>1) {\n\t\t\tsps_sublayer_dpb_params_flag = gf_bs_read_int_log(bs, 1, \"sps_sublayer_dpb_params_flag\");\n\t\t}\n\t\tfor (i=(sps_sublayer_dpb_params_flag ? 0 : sps->max_sublayers-1); i < sps->max_sublayers; i++ ) {\n\t\t\tgf_bs_read_ue_log_idx(bs, \"dpb_max_dec_pic_buffering_minus1\", i);\n\t\t\tgf_bs_read_ue_log_idx(bs, \"dpb_max_num_reorder_pics\", i);\n\t\t\tgf_bs_read_ue_log_idx(bs, \"dpb_max_latency_increase_plus1\", i);\n\t\t}\n\t}\n\tgf_bs_read_ue_log(bs, \"sps_log2_min_luma_coding_block_size_minus2\");\n\tsps->partition_constraints_override_enabled_flag = gf_bs_read_int_log(bs, 1, \"sps_partition_constraints_override_enabled_flag\");\n\tgf_bs_read_ue_log(bs, \"sps_log2_min_luma_coding_block_size_minus2\");\n\tu8 sps_max_mtt_hierarchy_depth_intra_slice_luma = gf_bs_read_ue_log(bs, \"sps_max_mtt_hierarchy_depth_intra_slice_luma\");\n\tif (sps_max_mtt_hierarchy_depth_intra_slice_luma != 0) {\n\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_max_bt_min_qt_intra_slice_luma\");\n\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_max_tt_min_qt_intra_slice_luma\");\n\t}\n\tu8 sps_qtbtt_dual_tree_intra_flag = 0;\n\tif (sps->chroma_format_idc) {\n\t\tsps_qtbtt_dual_tree_intra_flag = gf_bs_read_int_log(bs, 1, \"sps_qtbtt_dual_tree_intra_flag\");\n\t}\n\tif (sps_qtbtt_dual_tree_intra_flag) {\n\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_min_qt_min_cb_intra_slice_chroma\");\n\t\tu8 sps_max_mtt_hierarchy_depth_intra_slice_chroma = gf_bs_read_ue_log(bs, \"sps_max_mtt_hierarchy_depth_intra_slice_chroma\");\n\t\tif( sps_max_mtt_hierarchy_depth_intra_slice_chroma != 0) {\n\t\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_max_bt_min_qt_intra_slice_chroma\");\n\t\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_max_tt_min_qt_intra_slice_chroma\");\n\t\t}\n\t}\n\n\tgf_bs_read_ue_log(bs, \"sps_log2_diff_min_qt_min_cb_inter_slice\");\n\tu8 sps_max_mtt_hierarchy_depth_inter_slice = gf_bs_read_ue_log(bs, \"sps_max_mtt_hierarchy_depth_inter_slice\");\n\tif (sps_max_mtt_hierarchy_depth_inter_slice != 0) {\n\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_max_bt_min_qt_inter_slice\");\n\t\tgf_bs_read_ue_log(bs, \"sps_log2_diff_max_tt_min_qt_inter_slice\");\n\t}\n\tu8 max_luma_transform_size_64_flag = 0;\n\tif (CtbSizeY > 32) {\n\t\tmax_luma_transform_size_64_flag = gf_bs_read_int_log(bs, 1, \"sps_max_luma_transform_size_64_flag\");\n\t}\n\tsps->transform_skip_enabled_flag = gf_bs_read_int_log(bs, 1, \"sps_transform_skip_enabled_flag\");\n\n\tif (sps->transform_skip_enabled_flag) {\n\t\tgf_bs_read_ue_log(bs, \"sps_log2_transform_skip_max_size_minus2\");\n\t\tgf_bs_read_int_log(bs, 1, \"sps_bdpcm_enabled_flag\");\n\t}\n\tif (gf_bs_read_int_log(bs, 1, \"sps_mts_enabled_flag\")) {\n\t\tgf_bs_read_int_log(bs, 1, \"sps_explicit_mts_intra_enabled_flag\");\n\t\tgf_bs_read_int_log(bs, 1, \"sps_explicit_mts_inter_enabled_flag\");\n\t}\n\tBool lfnst_enabled_flag = gf_bs_read_int_log(bs, 1, \"sps_lfnst_enabled_flag\");\n\tsps->joint_cbcr_enabled_flag = 0;\n\tif (sps->chroma_format_idc) {\n\t\tsps->joint_cbcr_enabled_flag = gf_bs_read_int_log(bs, 1, \"sps_joint_cbcr_enabled_flag\");\n\t\tu8 sps_same_qp_table_for_chroma_flag = gf_bs_read_int_log(bs, 1, \"sps_same_qp_table_for_chroma_flag\");\n\t\tu32 numQpTables = sps_same_qp_table_for_chroma_flag ? 1 : (sps->joint_cbcr_enabled_flag ? 3 : 2);\n\t\tfor (i=0; i<numQpTables; i++) {\n\t\t\tgf_bs_read_se_log_idx(bs, \"sps_qp_table_start_minus26\", i);\n\t\t\tu32 j, sps_num_points_in_qp_table = 1 + gf_bs_read_ue_log_idx(bs, \"sps_num_points_in_qp_table_minus1\", i);\n\t\t\tfor (j=0; j<sps_num_points_in_qp_table; j++) {\n\t\t\t\tgf_bs_read_ue_log_idx2(bs, \"sps_delta_qp_in_val_minus1\", i, j);\n\t\t\t\tgf_bs_read_ue_log_idx2(bs, \"sps_delta_qp_diff_val\", i, j);\n\t\t\t}\n\t\t}\n\t}\n\tsps->sao_enabled_flag = gf_bs_read_int_log(bs, 1, \"sps_sao_enabled_flag\");\n\tsps->alf_enabled_flag = gf_bs_read_int_log(bs, 1, \"sps_alf_enabled_flag\");\n\tif (sps->alf_enabled_flag && sps->chroma_format_idc) {\n\t\tsps->ccalf_enabled_flag = gf_bs_read_int_log(bs, 1, \"sps_ccalf_enabled_flag\");\n\t}\n\tsps->lmcs_enabled_flag = gf_bs_read_int_log(bs, 1, \"sps_lmcs_enabled_flag\");\n\tsps->weighted_pred_flag = gf_bs_read_int_log(bs, 1, \"sps_weighted_pred_flag\");\n\tsps->weighted_bipred_flag = gf_bs_read_int_log(bs, 1, \"sps_weighted_bipred_flag\");\n\tsps->long_term_ref_pics_flag = gf_bs_read_int_log(bs, 1, \"sps_long_term_ref_pics_flag\");\n\tif (sps->vps_id>0)\n\t\tsps->inter_layer_prediction_enabled_flag = gf_bs_read_int_log(bs, 1, \"sps_inter_layer_prediction_enabled_flag\");\n\tsps->idr_rpl_present_flag = gf_bs_read_int_log(bs, 1, \"sps_idr_rpl_present_flag\");\n\tu32 sps_rpl1_same_as_rpl0 = gf_bs_read_int_log(bs, 1, \"sps_rpl1_same_as_rpl0_flag\") ? 1: 2;\n\tfor (i=0; i<sps_rpl1_same_as_rpl0; i++) {\n\t\tu32 j;\n\t\tsps->num_ref_pic_lists[i] = gf_bs_read_ue_log_idx(bs, \"sps_num_ref_pic_lists\", i);\n\t\tif (sps->num_ref_pic_lists[i] > 64) return -1;\n\t\tfor (j=0; j<sps->num_ref_pic_lists[i]; j++) {\n\t\t\ts32 res = vvc_parse_ref_pic_list_struct(bs, sps, i, j, &sps->rps[i][j]);\n\t\t\tif (res<0) return res;\n\t\t}\n\t}\n\tgf_bs_read_int_log(bs, 1, \"sps_ref_wraparound_enabled_flag\");\n\tsps->temporal_mvp_enabled_flag = gf_bs_read_int_log(bs, 1, \"sps_temporal_mvp_enabled_flag\");\n\tif (sps->temporal_mvp_enabled_flag) {\n\t\tgf_bs_read_int_log(bs, 1, \"sps_sbtmvp_enabled_flag\");\n\t}\n\tBool amvr_enabled = gf_bs_read_int_log(bs, 1, \"sps_amvr_enabled_flag\");\n\tsps->bdof_control_present_in_ph_flag = 0;\n\tif (gf_bs_read_int_log(bs, 1, \"sps_bdof_enabled_flag\")) {\n\t\tsps->bdof_control_present_in_ph_flag = gf_bs_read_int_log(bs, 1, \"sps_bdof_control_present_in_ph_flag\");\n\t}\n\tgf_bs_read_int_log(bs, 1, \"sps_smvd_enabled_flag\");\n\tsps->dmvr_control_present_in_ph_flag = 0;\n\tif (gf_bs_read_int_log(bs, 1, \"sps_dmvr_enabled_flag\")) {\n\t\tsps->dmvr_control_present_in_ph_flag = gf_bs_read_int_log(bs, 1, \"sps_dmvr_control_present_in_ph_flag\");\n\t}\n\tsps->mmvd_fullpel_only_enabled_flag = 0;\n\tif (gf_bs_read_int_log(bs, 1, \"sps_mmvd_enabled_flag\")) {\n\t\tsps->mmvd_fullpel_only_enabled_flag = gf_bs_read_int_log(bs, 1, \"sps_mmvd_fullpel_only_enabled_flag\");\n\t}\n\tu32 MaxNumMergeCand  = 6 - gf_bs_read_ue_log(bs, \"sps_six_minus_max_num_merge_cand\");\n\n\tsps->prof_control_present_in_ph_flag = 0;\n\tgf_bs_read_int_log(bs, 1, \"sps_sbt_enabled_flag\");\n\tif (gf_bs_read_int_log(bs, 1, \"sps_affine_enabled_flag\")) {\n\t\tgf_bs_read_ue_log(bs, \"sps_five_minus_max_num_subblock_merge_cand\");\n\t\tgf_bs_read_int_log(bs, 1, \"sps_6param_affine_enabled_flag\");\n\t\tif (amvr_enabled) {\n\t\t\tgf_bs_read_int_log(bs, 1, \"sps_affine_amvr_enabled_flag\");\n\t\t}\n\t\tif (gf_bs_read_int_log(bs, 1, \"sps_affine_prof_enabled_flag\")) {\n\t\t\tsps->prof_control_present_in_ph_flag = gf_bs_read_int_log(bs, 1, \"sps_prof_control_present_in_ph_flag\");\n\t\t}\n\t}\n\n\tgf_bs_read_int_log(bs, 1, \"sps_bcw_enabled_flag\");\n\tgf_bs_read_int_log(bs, 1, \"sps_ciip_enabled_flag\");\n\tif (MaxNumMergeCand >= 2) {\n\t\tBool gpm_enabled_flag = gf_bs_read_int_log(bs, 1, \"sps_gpm_enabled_flag\");\n\t\tif (gpm_enabled_flag && (MaxNumMergeCand >= 3)) {\n\t\t\tgf_bs_read_ue_log(bs, \"sps_max_num_merge_cand_minus_max_num_gpm_cand\");\n\t\t}\n\t}\n\tgf_bs_read_ue_log(bs, \"sps_log2_parallel_merge_level_minus2\");\n\n\tgf_bs_read_int_log(bs, 1, \"sps_isp_enabled_flag\");\n\tgf_bs_read_int_log(bs, 1, \"sps_mrl_enabled_flag\");\n\tgf_bs_read_int_log(bs, 1, \"sps_mip_enabled_flag\");\n\tif (sps->chroma_format_idc != 0) {\n\t\tgf_bs_read_int_log(bs, 1, \"sps_cclm_enabled_flag\");\n\t}\n\tif (sps->chroma_format_idc == 1) {\n\t\tgf_bs_read_int_log(bs, 1, \"sps_chroma_horizontal_collocated_flag\");\n\t\tgf_bs_read_int_log(bs, 1, \"sps_chroma_vertical_collocated_flag\");\n\t}\n\tBool act_enabled_flag = GF_FALSE;\n\tBool palette_enabled_flag = gf_bs_read_int_log(bs, 1, \"sps_palette_enabled_flag\");\n\tif ((sps->chroma_format_idc == 3) && !max_luma_transform_size_64_flag) {\n\t\tact_enabled_flag = gf_bs_read_int_log(bs, 1, \"sps_act_enabled_flag\");\n\t}\n\tif (sps->transform_skip_enabled_flag || palette_enabled_flag) {\n\t\tgf_bs_read_ue_log(bs, \"sps_min_qp_prime_ts\");\n\t}\n\tif (gf_bs_read_int_log(bs, 1, \"sps_ibc_enabled_flag\")) {\n\t\tgf_bs_read_ue_log(bs, \"sps_six_minus_max_num_ibc_merge_cand\");\n\t}\n\tif (gf_bs_read_int_log(bs, 1, \"sps_ladf_enabled_flag\")) {\n\t\tu32 num_ladf_intervals_minus2 = gf_bs_read_int_log(bs, 2, \"sps_num_ladf_intervals_minus2\");\n\t\tgf_bs_read_se_log(bs, \"sps_ladf_lowest_interval_qp_offset\");\n\t\tfor (i=0; i<num_ladf_intervals_minus2+1; i++) {\n\t\t\tgf_bs_read_se_log_idx(bs, \"sps_ladf_qp_offset\", i);\n\t\t\tgf_bs_read_ue_log_idx(bs, \"sps_ladf_delta_threshold_minus1\", i);\n\t\t}\n\t}\n\tsps->explicit_scaling_list_enabled_flag = gf_bs_read_int_log(bs, 1, \"sps_explicit_scaling_list_enabled_flag\");\n\tif (lfnst_enabled_flag && sps->explicit_scaling_list_enabled_flag) {\n\t\tgf_bs_read_int_log(bs, 1, \"sps_scaling_matrix_for_lfnst_disabled_flag\");\n\t}\n\tBool scaling_matrix_for_alternative_colour_space_disabled_flag = 0;\n\tif (act_enabled_flag && sps->explicit_scaling_list_enabled_flag) {\n\t\tscaling_matrix_for_alternative_colour_space_disabled_flag = gf_bs_read_int_log(bs, 1, \"sps_scaling_matrix_for_alternative_colour_space_disabled_flag\");\n\t}\n\tif (scaling_matrix_for_alternative_colour_space_disabled_flag) {\n\t\tgf_bs_read_int_log(bs, 1, \"sps_scaling_matrix_designated_colour_space_flag\");\n\t}\n\tsps->dep_quant_enabled_flag = gf_bs_read_int_log(bs, 1, \"sps_dep_quant_enabled_flag\");\n\tsps->sign_data_hiding_enabled_flag = gf_bs_read_int_log(bs, 1, \"sps_sign_data_hiding_enabled_flag\");\n\tsps->virtual_boundaries_enabled_flag = gf_bs_read_int_log(bs, 1, \"sps_virtual_boundaries_enabled_flag\");\n\tif (sps->virtual_boundaries_enabled_flag) {\n\t\tsps->virtual_boundaries_present_flag = gf_bs_read_int_log(bs, 1, \"sps_virtual_boundaries_present_flag\");\n\t\tif (sps->virtual_boundaries_present_flag) {\n\t\t\tu32 num_virtual_boundaries = gf_bs_read_ue_log(bs, \"sps_num_ver_virtual_boundaries\");\n\t\t\tfor (i=0; i<num_virtual_boundaries; i++) {\n\t\t\t\tgf_bs_read_ue_log_idx(bs, \"sps_virtual_boundary_pos_x_minus1\", i);\n\t\t\t}\n\t\t\tnum_virtual_boundaries = gf_bs_read_ue_log(bs, \"sps_num_hor_virtual_boundaries\");\n\t\t\tfor (i=0; i<num_virtual_boundaries; i++) {\n\t\t\t\tgf_bs_read_ue_log_idx(bs, \"sps_virtual_boundary_pos_y_minus1\", i);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (sps_ptl_dpb_hrd_params_present_flag) {\n\t\tif (gf_bs_read_int_log(bs, 1, \"sps_timing_hrd_params_present_flag\")) {\n\t\t\tBool general_nal_hrd_params_present_flag, general_vcl_hrd_params_present_flag, general_du_hrd_params_present_flag;\n\t\t\tu32 hrd_cpb_cnt_minus1=0;\n\t\t\tu32 sublayer_cpb_params_present_flag = 0;\n\t\t\tvvc_parse_general_timing_hrd_parameters(bs, sps, NULL, &general_nal_hrd_params_present_flag, &general_vcl_hrd_params_present_flag, &general_du_hrd_params_present_flag, &hrd_cpb_cnt_minus1);\n\t\t\tif (sps->max_sublayers > 1) {\n\t\t\t\tsublayer_cpb_params_present_flag = gf_bs_read_int_log(bs, 1, \"sps_sublayer_cpb_params_present_flag\");\n\t\t\t}\n\t\t\tu32 firstSubLayer = sublayer_cpb_params_present_flag ? 0 : sps->max_sublayers - 1;\n\t\t\tvvc_parse_ols_timing_hrd_parameters(bs, firstSubLayer, sps->max_sublayers-1, general_nal_hrd_params_present_flag, general_vcl_hrd_params_present_flag, general_du_hrd_params_present_flag, hrd_cpb_cnt_minus1);\n\n\t\t}\n\t}\n\n\tgf_bs_read_int_log(bs, 1, \"sps_field_seq_flag\");\n\tif (vui_flag_pos) {\n\t\t*vui_flag_pos = (u32)gf_bs_get_bit_offset(bs);\n\t}\n\t//all this to get to VUI !!!\n\tif (gf_bs_read_int_log(bs, 1, \"sps_vui_parameters_present_flag\")) {\n\t\tgf_bs_read_ue_log(bs, \"sps_vui_payload_size_minus1\");\n\t\twhile (!gf_bs_is_align(bs)) {\n\t\t\tgf_bs_read_int_log(bs, 1, \"sps_vui_alignment_zero_bit\");\n\t\t}\n\t\t//vui parameters\n\t\tBool vui_progressive_source_flag = gf_bs_read_int_log(bs, 1, \"vui_progressive_source_flag\");\n\t\tBool vui_interlaced_source_flag = gf_bs_read_int_log(bs, 1, \"vui_interlaced_source_flag\");\n\t\tgf_bs_read_int_log(bs, 1, \"vui_non_packed_constraint_flag\");\n\t\tgf_bs_read_int_log(bs, 1, \"vui_non_projected_constraint_flag\");\n\t\tsps->aspect_ratio_info_present_flag = gf_bs_read_int_log(bs, 1, \"vui_aspect_ratio_info_present_flag\");\n\t\tif (sps->aspect_ratio_info_present_flag) {\n\t\t\tgf_bs_read_int_log(bs, 1, \"vui_aspect_ratio_constant_flag\");\n\t\t\tsps->sar_idc = gf_bs_read_int_log(bs, 8, \"vui_aspect_ratio_idc\");\n\t\t\tif (sps->sar_idc== 0xFF) {\n\t\t\t\tsps->sar_width = gf_bs_read_int_log(bs, 16, \"vui_sar_width\");\n\t\t\t\tsps->sar_height = gf_bs_read_int_log(bs, 16, \"vui_sar_height\");\n\t\t\t}\n\t\t}\n\t\tsps->overscan_info_present_flag = gf_bs_read_int_log(bs, 1, \"vui_overscan_info_present_flag\");\n\t\tif (sps->overscan_info_present_flag) {\n\t\t\tgf_bs_read_int_log(bs, 1, \"vui_overscan_appropriate_flag\");\n\t\t}\n\t\tsps->colour_description_present_flag = gf_bs_read_int_log(bs, 1, \"vui_colour_description_present_flag\");\n\t\tif (sps->colour_description_present_flag) {\n\t\t\tsps->colour_primaries = gf_bs_read_int_log(bs, 8, \"vui_colour_primaries\");\n\t\t\tsps->transfer_characteristics = gf_bs_read_int_log(bs, 8, \"vui_transfer_characteristics\");\n\t\t\tsps->matrix_coefficients = gf_bs_read_int_log(bs, 8, \"vui_matrix_coeffs\");\n\t\t\tsps->video_full_range_flag = gf_bs_read_int_log(bs, 1, \"vui_full_range_flag\");\n\t\t}\n\t\tif (gf_bs_read_int_log(bs, 1, \" vui_chroma_loc_info_present_flag\")) {\n\t\t\tif (vui_progressive_source_flag && !vui_interlaced_source_flag) {\n\t\t\t\tgf_bs_read_ue_log(bs, \"vui_chroma_sample_loc_type_frame\");\n\t\t\t} else {\n\t\t\t\tgf_bs_read_ue_log(bs, \"vui_chroma_sample_loc_type_top_field\");\n\t\t\t\tgf_bs_read_ue_log(bs, \"vui_chroma_sample_loc_type_bottom_field\");\n\t\t\t}\n\t\t}\n\t\t//WE DON'T PARSE vui_payload_bit_equal_to_one because we dont parse the rest (sps extensions)\n\t\t//if needed, see rewrite_vui code\n\t}\n\n\tif (gf_bs_is_overflow(bs))\n\t\treturn -1;\n\treturn sps_id;\n}", "target": 2, "idx": 11197}
{"commit_id": "ef764dde1cca2f25d00686673d1bc89448819571", "project": "redis", "func": "static size_t optsize (lua_State *L, char opt, const char **fmt) {\n  switch (opt) {\n    case 'B': case 'b': return sizeof(char);\n    case 'H': case 'h': return sizeof(short);\n    case 'L': case 'l': return sizeof(long);\n    case 'T': return sizeof(size_t);\n    case 'f':  return sizeof(float);\n    case 'd':  return sizeof(double);\n    case 'x': return 1;\n    case 'c': return getnum(L, fmt, 1);\n    case 'i': case 'I': {\n      int sz = getnum(L, fmt, sizeof(int));\n      if (sz > MAXINTSIZE)\n        luaL_error(L, \"integral size %d is larger than limit of %d\",\n                       sz, MAXINTSIZE);\n      return sz;\n    }\n    default: return 0;  /* other cases do not need alignment */\n  }\n}", "target": 2, "idx": 11198}
{"commit_id": "98fdfc6df88b1e34a736d5e126e6c8139c8de1a6", "project": "nothings/stb", "func": "static float *get_window(vorb *f, int len)\n{\n   len <<= 1;\n   if (len == f->blocksize_0) return f->window[0];\n   if (len == f->blocksize_1) return f->window[1];\n   return NULL;\n}", "target": 2, "idx": 11199}
{"commit_id": "cfde94be1d4286bc47633c6e6eaf4e659bd78066", "project": "ArtifexSoftware/ghostpdl", "func": "static void *\ni_alloc_struct_array_immovable(gs_memory_t * mem, uint num_elements,\n                           gs_memory_type_ptr_t pstype, client_name_t cname)\n{\n    gs_ref_memory_t * const imem = (gs_ref_memory_t *)mem;\n    obj_header_t *obj;\n    ulong lsize;\n#ifdef MEMENTO\n    if (Memento_failThisEvent())\n        return NULL;\n#endif\n\n    ALLOC_CHECK_SIZE(mem,pstype);\n    if (alloc_array_check_size(num_elements, pstype->ssize, &lsize) == false)\n        return NULL;\n    obj = alloc_obj(imem, lsize, pstype, ALLOC_IMMOVABLE | ALLOC_DIRECT, cname);\n    if_debug7m('A', mem, \"[a%d|+<.]%s %s*(%lu=%u*%u) = 0x%lx\\n\",\n               alloc_trace_space(imem), client_name_string(cname),\n               struct_type_name_string(pstype),\n               (ulong) num_elements * pstype->ssize,\n               num_elements, pstype->ssize, (ulong) obj);\n    return (char *)obj;\n}", "target": 2, "idx": 11200}
{"commit_id": "0bb6961f18b8e832d88b490d421ca56cea16c45b", "project": "binutils-gdb", "func": "static void\npe_bfd_read_buildid (bfd *abfd)\n{\n  pe_data_type *pe = pe_data (abfd);\n  struct internal_extra_pe_aouthdr *extra = &pe->pe_opthdr;\n  asection *section;\n  bfd_byte *data = 0;\n  bfd_size_type dataoff;\n  unsigned int i;\n  bfd_vma addr = extra->DataDirectory[PE_DEBUG_DATA].VirtualAddress;\n  bfd_size_type size = extra->DataDirectory[PE_DEBUG_DATA].Size;\n\n  if (size == 0)\n    return;\n\n  addr += extra->ImageBase;\n\n  /* Search for the section containing the DebugDirectory.  */\n  for (section = abfd->sections; section != NULL; section = section->next)\n    {\n      if ((addr >= section->vma) && (addr < (section->vma + section->size)))\n        break;\n    }\n\n  if (section == NULL)\n    return;\n\n  if (!(section->flags & SEC_HAS_CONTENTS))\n    return;\n\n  dataoff = addr - section->vma;\n\n  /* PR 20605 and 22373: Make sure that the data is really there.\n     Note - since we are dealing with unsigned quantities we have\n     to be careful to check for potential overflows.  */\n  if (dataoff > section->size\n      || size > section->size\n      || dataoff + size > section->size)\n    {\n      _bfd_error_handler (_(\"%B: Error: Debug Data ends beyond end of debug directory.\"),\n\t\t\t  abfd);\n      return;\n    }\n  \n  /* Read the whole section. */\n  if (!bfd_malloc_and_get_section (abfd, section, &data))\n    {\n      if (data != NULL)\n\tfree (data);\n      return;\n    }\n\n  /* Search for a CodeView entry in the DebugDirectory */\n  for (i = 0; i < size / sizeof (struct external_IMAGE_DEBUG_DIRECTORY); i++)\n    {\n      struct external_IMAGE_DEBUG_DIRECTORY *ext\n\t= &((struct external_IMAGE_DEBUG_DIRECTORY *)(data + dataoff))[i];\n      struct internal_IMAGE_DEBUG_DIRECTORY idd;\n\n      _bfd_XXi_swap_debugdir_in (abfd, ext, &idd);\n\n      if (idd.Type == PE_IMAGE_DEBUG_TYPE_CODEVIEW)\n        {\n          char buffer[256 + 1];\n          CODEVIEW_INFO *cvinfo = (CODEVIEW_INFO *) buffer;\n\n          /*\n            The debug entry doesn't have to have to be in a section, in which\n            case AddressOfRawData is 0, so always use PointerToRawData.\n          */\n          if (_bfd_XXi_slurp_codeview_record (abfd,\n                                              (file_ptr) idd.PointerToRawData,\n                                              idd.SizeOfData, cvinfo))\n            {\n              struct bfd_build_id* build_id = bfd_alloc (abfd,\n                         sizeof (struct bfd_build_id) + cvinfo->SignatureLength);\n              if (build_id)\n                {\n                  build_id->size = cvinfo->SignatureLength;\n                  memcpy(build_id->data,  cvinfo->Signature,\n                         cvinfo->SignatureLength);\n                  abfd->build_id = build_id;\n                }\n            }\n          break;\n        }\n    }\n}", "target": 2, "idx": 11201}
{"commit_id": "3dd308911d7294bc6cff12f626b8467fe1555423", "project": "ros/ros_comm", "func": "bool \nXmlRpcUtil::nextTagIs(const char* tag, std::string const& xml, int* offset)\n{\n  if (xml.length() > size_t(__INT_MAX__)) return false;\n  if (*offset >= int(xml.length())) return false;\n  const char* cp = xml.c_str() + *offset;\n  int nc = 0;\n  while (*cp && isspace(*cp)) {\n    ++cp;\n    ++nc;\n  }\n\n  int len = int(strlen(tag));\n  if  (*cp && (strncmp(cp, tag, len) == 0)) {\n    *offset += nc + len;\n    return true;\n  }\n  return false;\n}", "target": 2, "idx": 11202}
{"commit_id": "ae614bf8ab42c9d0c7ac57ecdfdcbcfc4ff6c639", "project": "poppler", "func": "int DCTStream::getChars(int nChars, unsigned char *buffer)\n{\n    for (int i = 0; i < nChars;) {\n        if (current == limit) {\n            if (!readLine())\n                return i;\n        }\n        int left = limit - current;\n        if (left + i > nChars)\n            left = nChars - i;\n        memcpy(buffer + i, current, left);\n        current += left;\n        i += left;\n    }\n    return nChars;\n}", "target": 2, "idx": 11203}
{"commit_id": "25703a5cdbf3067ca4d4e75a0229762855548ecc", "project": "COVESA/dlt-daemon", "func": "DltReturnValue dlt_filter_load(DltFilter *filter, const char *filename, int verbose)\n{\n    if ((filter == NULL) || (filename == NULL))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    FILE *handle;\n    char str1[DLT_COMMON_BUFFER_LENGTH];\n    char apid[DLT_ID_SIZE], ctid[DLT_ID_SIZE];\n    char format[10];\n\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    handle = fopen(filename, \"r\");\n\n    if (handle == NULL) {\n        dlt_vlog(LOG_WARNING, \"Filter file %s cannot be opened!\\n\", filename);\n        return DLT_RETURN_ERROR;\n    }\n\n    sprintf(format, \"%c%ds\", '%', DLT_COMMON_BUFFER_LENGTH-1);\n\n    /* Reset filters */\n    filter->counter = 0;\n\n    while (!feof(handle)) {\n        str1[0] = 0;\n\n        if (fscanf(handle, format, str1) != 1)\n            break;\n\n        if (str1[0] == 0)\n            break;\n\n        printf(\" %s\", str1);\n\n        if (strcmp(str1, \"----\") == 0)\n            dlt_set_id(apid, \"\");\n        else\n            dlt_set_id(apid, str1);\n\n        str1[0] = 0;\n\n        if (fscanf(handle, format, str1) != 1)\n            break;\n\n        if (str1[0] == 0)\n            break;\n\n        printf(\" %s\\r\\n\", str1);\n\n        if (strcmp(str1, \"----\") == 0)\n            dlt_set_id(ctid, \"\");\n        else\n            dlt_set_id(ctid, str1);\n\n        if (filter->counter < DLT_FILTER_MAX) {\n            dlt_filter_add(filter, apid, ctid, verbose);\n        }\n        else {\n            dlt_vlog(LOG_WARNING,\n                     \"Maximum number (%d) of allowed filters reached, ignoring rest of filters!\\n\",\n                     DLT_FILTER_MAX);\n        }\n    }\n\n    fclose(handle);\n\n    return DLT_RETURN_OK;\n}", "target": 2, "idx": 11204}
{"commit_id": "961b10cdd71403072fb99401a45f3bef6ce53626", "project": "ArtifexSoftware/ghostpdl", "func": "static int\nxps_encode_font_char_imp(xps_font_t *font, int code)\n{\n    byte *table;\n\n    /* no cmap selected: return identity */\n    if (font->cmapsubtable <= 0)\n        return code;\n\n    table = font->data + font->cmapsubtable;\n\n    switch (u16(table))\n    {\n    case 0: /* Apple standard 1-to-1 mapping. */\n        return table[code + 6];\n\n    case 4: /* Microsoft/Adobe segmented mapping. */\n        {\n            int segCount2 = u16(table + 6);\n            byte *endCount = table + 14;\n            byte *startCount = endCount + segCount2 + 2;\n            byte *idDelta = startCount + segCount2;\n            byte *idRangeOffset = idDelta + segCount2;\n            byte *giddata;\n            int i2;\n\n            if (segCount2 < 3 || segCount2 > 65535 ||\n               idRangeOffset > font->data + font->length)\n               return gs_error_invalidfont;\n\n           for (i2 = 0; i2 < segCount2 - 3; i2 += 2)\n            {\n                int delta, roff;\n                int start = u16(startCount + i2);\n                int glyph;\n\n                if ( code < start )\n                    return 0;\n                if ( code > u16(endCount + i2) )\n                    continue;\n                delta = s16(idDelta + i2);\n                roff = s16(idRangeOffset + i2);\n                if ( roff == 0 )\n                {\n                    return ( code + delta ) & 0xffff; /* mod 65536 */\n                }\n                if ((giddata = (idRangeOffset + i2 + roff + ((code - start) << 1))) >\n                    font->data + font->length) {\n                    return code;\n                }\n                glyph = u16(giddata);\n                return (glyph == 0 ? 0 : glyph + delta);\n            }\n\n            /*\n             * The TrueType documentation says that the last range is\n             * always supposed to end with 0xffff, so this shouldn't\n             * happen; however, in some real fonts, it does.\n             */\n            return 0;\n        }\n\n    case 6: /* Single interval lookup. */\n        {\n            int firstCode = u16(table + 6);\n            int entryCount = u16(table + 8);\n            if ( code < firstCode || code >= firstCode + entryCount )\n                return 0;\n            return u16(table + 10 + ((code - firstCode) << 1));\n        }\n\n    case 10: /* Trimmed array (like 6) */\n        {\n            int startCharCode = u32(table + 12);\n            int numChars = u32(table + 16);\n            if ( code < startCharCode || code >= startCharCode + numChars )\n                return 0;\n            return u32(table + 20 + (code - startCharCode) * 4);\n        }\n\n    case 12: /* Segmented coverage. (like 4) */\n        {\n            int nGroups = u32(table + 12);\n            byte *group = table + 16;\n            int i;\n\n            for (i = 0; i < nGroups; i++)\n            {\n                int startCharCode = u32(group + 0);\n                int endCharCode = u32(group + 4);\n                int startGlyphID = u32(group + 8);\n                if ( code < startCharCode )\n                    return 0;\n                if ( code <= endCharCode )\n                    return startGlyphID + (code - startCharCode);\n                group += 12;\n            }\n\n            return 0;\n        }\n\n    case 2: /* High-byte mapping through table. */\n    case 8: /* Mixed 16-bit and 32-bit coverage (like 2) */\n    default:\n        gs_warn1(\"unknown cmap format: %d\\n\", u16(table));\n        return 0;\n    }\n\n    return 0;\n}", "target": 2, "idx": 11205}
{"commit_id": "a4ae828ee416a66d8c7bf5ee71d653c2cc6a26dd", "project": "python/cpython", "func": "static int\nUnpickler_set_memo(UnpicklerObject *self, PyObject *obj)\n{\n    PyObject **new_memo;\n    size_t new_memo_size = 0;\n\n    if (obj == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"attribute deletion is not supported\");\n        return -1;\n    }\n\n    if (Py_TYPE(obj) == &UnpicklerMemoProxyType) {\n        UnpicklerObject *unpickler =\n            ((UnpicklerMemoProxyObject *)obj)->unpickler;\n\n        new_memo_size = unpickler->memo_size;\n        new_memo = _Unpickler_NewMemo(new_memo_size);\n        if (new_memo == NULL)\n            return -1;\n\n        for (size_t i = 0; i < new_memo_size; i++) {\n            Py_XINCREF(unpickler->memo[i]);\n            new_memo[i] = unpickler->memo[i];\n        }\n    }\n    else if (PyDict_Check(obj)) {\n        Py_ssize_t i = 0;\n        PyObject *key, *value;\n\n        new_memo_size = PyDict_GET_SIZE(obj);\n        new_memo = _Unpickler_NewMemo(new_memo_size);\n        if (new_memo == NULL)\n            return -1;\n\n        while (PyDict_Next(obj, &i, &key, &value)) {\n            Py_ssize_t idx;\n            if (!PyLong_Check(key)) {\n                PyErr_SetString(PyExc_TypeError,\n                                \"memo key must be integers\");\n                goto error;\n            }\n            idx = PyLong_AsSsize_t(key);\n            if (idx == -1 && PyErr_Occurred())\n                goto error;\n            if (idx < 0) {\n                PyErr_SetString(PyExc_ValueError,\n                                \"memo key must be positive integers.\");\n                goto error;\n            }\n            if (_Unpickler_MemoPut(self, idx, value) < 0)\n                goto error;\n        }\n    }\n    else {\n        PyErr_Format(PyExc_TypeError,\n                     \"'memo' attribute must be an UnpicklerMemoProxy object\"\n                     \"or dict, not %.200s\", Py_TYPE(obj)->tp_name);\n        return -1;\n    }\n\n    _Unpickler_MemoCleanup(self);\n    self->memo_size = new_memo_size;\n    self->memo = new_memo;\n\n    return 0;\n\n  error:\n    if (new_memo_size) {\n        for (size_t i = new_memo_size - 1; i != SIZE_MAX; i--) {\n            Py_XDECREF(new_memo[i]);\n        }\n        PyMem_FREE(new_memo);\n    }\n    return -1;\n}", "target": 2, "idx": 11206}
{"commit_id": "cb4ef0b09200c720dfdb07e097092dd105450343", "project": "envoyproxy/envoy", "func": "BrotliContext::BrotliContext(uint32_t chunk_size, uint32_t max_output_size)\n    : max_output_size_{max_output_size}, chunk_size_{chunk_size},\n      chunk_ptr_{std::make_unique<uint8_t[]>(chunk_size)}, next_in_{}, next_out_{chunk_ptr_.get()},\n      avail_in_{0}, avail_out_{chunk_size} {}", "target": 2, "idx": 11207}
{"commit_id": "a4176ec356c73a46c07c181c6d04039fafa34a9f", "project": "torvalds/linux", "func": "static inline void brcmf_fweh_process_skb(struct brcmf_pub *drvr,\n\t\t\t\t\t  struct sk_buff *skb, u16 stype)\n{\n\tstruct brcmf_event *event_packet;\n\tu16 subtype, usr_stype;\n\n\t/* only process events when protocol matches */\n\tif (skb->protocol != cpu_to_be16(ETH_P_LINK_CTL))\n\t\treturn;\n\n\tif ((skb->len + ETH_HLEN) < sizeof(*event_packet))\n\t\treturn;\n\n\tevent_packet = (struct brcmf_event *)skb_mac_header(skb);\n\n\t/* check subtype if needed */\n\tif (unlikely(stype)) {\n\t\tsubtype = get_unaligned_be16(&event_packet->hdr.subtype);\n\t\tif (subtype != stype)\n\t\t\treturn;\n\t}\n\n\t/* check for BRCM oui match */\n\tif (memcmp(BRCM_OUI, &event_packet->hdr.oui[0],\n\t\t   sizeof(event_packet->hdr.oui)))\n\t\treturn;\n\n\t/* final match on usr_subtype */\n\tusr_stype = get_unaligned_be16(&event_packet->hdr.usr_subtype);\n\tif (usr_stype != BCMILCP_BCM_SUBTYPE_EVENT)\n\t\treturn;\n\n\tbrcmf_fweh_process_event(drvr, event_packet, skb->len + ETH_HLEN);\n}", "target": 2, "idx": 11208}
{"commit_id": "c65c8fdaaa257e0487ab0aaae9e8f6b439335945", "project": "cesanta/mongoose", "func": "int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,\n                   const char *dir) {\n  char offset[40] = \"\", name[200] = \"\", path[256];\n  mg_http_get_var(&hm->query, \"offset\", offset, sizeof(offset));\n  mg_http_get_var(&hm->query, \"name\", name, sizeof(name));\n  if (name[0] == '\\0') {\n    mg_http_reply(c, 400, \"\", \"%s\", \"name required\");\n    return -1;\n  } else {\n    FILE *fp;\n    long oft = strtol(offset, NULL, 0);\n    snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);\n    remove_double_dots(path);\n    LOG(LL_DEBUG, (\"%d bytes @ %ld [%s]\", (int) hm->body.len, oft, path));\n    if ((fp = fopen(path, oft == 0 ? \"wb\" : \"ab\")) == NULL) {\n      mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", path, errno);\n      return -2;\n    } else {\n      fwrite(hm->body.ptr, 1, hm->body.len, fp);\n      fclose(fp);\n      mg_http_reply(c, 200, \"\", \"\");\n      return (int) hm->body.len;\n    }\n  }\n}", "target": 3, "idx": 11209}
{"commit_id": "e52a436c0e1c5e9f7ef13428dba83194a800f4df", "project": "MapServer", "func": "char *FLTGetIsLikeComparisonExpression(FilterEncodingNode *psFilterNode)\n{\n  const size_t bufferSize = 1024;\n  char szBuffer[1024];\n  char szTmp[256];\n  char *pszValue = NULL;\n\n  const char *pszWild = NULL;\n  const char *pszSingle = NULL;\n  const char *pszEscape = NULL;\n  int  bCaseInsensitive = 0;\n\n  int nLength=0, i=0, iTmp=0;\n  FEPropertyIsLike* propIsLike;\n\n\n  if (!psFilterNode || !psFilterNode->pOther || !psFilterNode->psLeftNode ||\n      !psFilterNode->psRightNode || !psFilterNode->psRightNode->pszValue)\n    return NULL;\n\n  propIsLike = (FEPropertyIsLike *)psFilterNode->pOther;\n  pszWild = propIsLike->pszWildCard;\n  pszSingle = propIsLike->pszSingleChar;\n  pszEscape = propIsLike->pszEscapeChar;\n  bCaseInsensitive = propIsLike->bCaseInsensitive;\n\n  if (!pszWild || strlen(pszWild) == 0 ||\n      !pszSingle || strlen(pszSingle) == 0 ||\n      !pszEscape || strlen(pszEscape) == 0)\n    return NULL;\n\n\n  /* -------------------------------------------------------------------- */\n  /*      Use operand with regular expressions.                           */\n  /* -------------------------------------------------------------------- */\n  szBuffer[0] = '\\0';\n  sprintf(szTmp, \"%s\", \" (\\\"[\");\n  szTmp[4] = '\\0';\n\n  strlcat(szBuffer, szTmp, bufferSize);\n\n  /* attribute */\n  strlcat(szBuffer, psFilterNode->psLeftNode->pszValue, bufferSize);\n  szBuffer[strlen(szBuffer)] = '\\0';\n\n  /*#3521 */\n  if(bCaseInsensitive == 1)\n    sprintf(szTmp, \"%s\", \"]\\\" ~* /\");\n  else\n    sprintf(szTmp, \"%s\", \"]\\\" =~ /\");\n  szTmp[7] = '\\0';\n  strlcat(szBuffer, szTmp, bufferSize);\n  szBuffer[strlen(szBuffer)] = '\\0';\n\n\n  pszValue = psFilterNode->psRightNode->pszValue;\n  nLength = strlen(pszValue);\n  if( 1 + 2 * nLength + 1 + 1 >= sizeof(szTmp) )\n      return NULL;\n\n  iTmp =0;\n  if (nLength > 0 && pszValue[0] != pszWild[0] &&\n      pszValue[0] != pszSingle[0] &&\n      pszValue[0] != pszEscape[0]) {\n    szTmp[iTmp]= '^';\n    iTmp++;\n  }\n  for (i=0; i<nLength; i++) {\n    if (pszValue[i] != pszWild[0] &&\n        pszValue[i] != pszSingle[0] &&\n        pszValue[i] != pszEscape[0]) {\n      szTmp[iTmp] = pszValue[i];\n      iTmp++;\n      szTmp[iTmp] = '\\0';\n    } else if  (pszValue[i] == pszSingle[0]) {\n      szTmp[iTmp] = '.';\n      iTmp++;\n      szTmp[iTmp] = '\\0';\n    } else if  (pszValue[i] == pszEscape[0]) {\n      szTmp[iTmp] = '\\\\';\n      iTmp++;\n      szTmp[iTmp] = '\\0';\n\n    } else if (pszValue[i] == pszWild[0]) {\n      /* strcat(szBuffer, \"[0-9,a-z,A-Z,\\\\s]*\"); */\n      /* iBuffer+=17; */\n      szTmp[iTmp++] = '.';\n      szTmp[iTmp++] = '*';\n      szTmp[iTmp] = '\\0';\n    }\n  }\n  szTmp[iTmp] = '/';\n  szTmp[++iTmp] = '\\0';\n\n  strlcat(szBuffer, szTmp, bufferSize);\n  strlcat(szBuffer, \")\", bufferSize);\n  return msStrdup(szBuffer);\n}", "target": 3, "idx": 11210}
{"commit_id": "55667441c84fa5e0911a0aac44fb059c15ba6da2", "project": "torvalds/linux", "func": "static u32 fq_flow_idx(struct fq *fq, struct sk_buff *skb)\n{\n\tu32 hash = skb_get_hash_perturb(skb, &fq->perturbation);\n\n\treturn reciprocal_scale(hash, fq->flows_cnt);\n}", "target": 1, "idx": 11211}
{"commit_id": "cc080e9e9be16ccf26135d366d7d2b65209f1d56", "project": "torvalds/linux", "func": "static ssize_t fuse_dev_splice_read(struct file *in, loff_t *ppos,\n\t\t\t\t    struct pipe_inode_info *pipe,\n\t\t\t\t    size_t len, unsigned int flags)\n{\n\tint ret;\n\tint page_nr = 0;\n\tint do_wakeup = 0;\n\tstruct pipe_buffer *bufs;\n\tstruct fuse_copy_state cs;\n\tstruct fuse_dev *fud = fuse_get_dev(in);\n\n\tif (!fud)\n\t\treturn -EPERM;\n\n\tbufs = kmalloc(pipe->buffers * sizeof(struct pipe_buffer), GFP_KERNEL);\n\tif (!bufs)\n\t\treturn -ENOMEM;\n\n\tfuse_copy_init(&cs, 1, NULL);\n\tcs.pipebufs = bufs;\n\tcs.pipe = pipe;\n\tret = fuse_dev_do_read(fud->fc, in, &cs, len);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = 0;\n\tpipe_lock(pipe);\n\n\tif (!pipe->readers) {\n\t\tsend_sig(SIGPIPE, current, 0);\n\t\tif (!ret)\n\t\t\tret = -EPIPE;\n\t\tgoto out_unlock;\n\t}\n\n\tif (pipe->nrbufs + cs.nr_segs > pipe->buffers) {\n\t\tret = -EIO;\n\t\tgoto out_unlock;\n\t}\n\n\twhile (page_nr < cs.nr_segs) {\n\t\tint newbuf = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);\n\t\tstruct pipe_buffer *buf = pipe->bufs + newbuf;\n\n\t\tbuf->page = bufs[page_nr].page;\n\t\tbuf->offset = bufs[page_nr].offset;\n\t\tbuf->len = bufs[page_nr].len;\n\t\t/*\n\t\t * Need to be careful about this.  Having buf->ops in module\n\t\t * code can Oops if the buffer persists after module unload.\n\t\t */\n\t\tbuf->ops = &nosteal_pipe_buf_ops;\n\n\t\tpipe->nrbufs++;\n\t\tpage_nr++;\n\t\tret += buf->len;\n\n\t\tif (pipe->files)\n\t\t\tdo_wakeup = 1;\n\t}\n\nout_unlock:\n\tpipe_unlock(pipe);\n\n\tif (do_wakeup) {\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&pipe->wait))\n\t\t\twake_up_interruptible(&pipe->wait);\n\t\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n\t}\n\nout:\n\tfor (; page_nr < cs.nr_segs; page_nr++)\n\t\tpage_cache_release(bufs[page_nr].page);\n\n\tkfree(bufs);\n\treturn ret;\n}", "target": 1, "idx": 11212}
{"commit_id": "abd39c6ded9db53aa44c2540092bdd5fb6590fa8", "project": "torvalds/linux", "func": "void rsi_mac80211_detach(struct rsi_hw *adapter)\n{\n\tstruct ieee80211_hw *hw = adapter->hw;\n\tenum nl80211_band band;\n\n\tif (hw) {\n\t\tieee80211_stop_queues(hw);\n\t\tieee80211_unregister_hw(hw);\n\t\tieee80211_free_hw(hw);\n\t\tadapter->hw = NULL;\n\t}\n\n\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\tstruct ieee80211_supported_band *sband =\n\t\t\t\t\t&adapter->sbands[band];\n\n\t\tkfree(sband->channels);\n\t}\n\n#ifdef CONFIG_RSI_DEBUGFS\n\trsi_remove_dbgfs(adapter);\n\tkfree(adapter->dfsentry);\n#endif\n}", "target": 1, "idx": 11213}
{"commit_id": "5674b0057ff2903d43eaff802017eddf37c360f8", "project": "redis", "func": "int processMultibulkBuffer(client *c) {\n    char *newline = NULL;\n    int ok;\n    long long ll;\n\n    if (c->multibulklen == 0) {\n        /* The client should have been reset */\n        serverAssertWithInfo(c,NULL,c->argc == 0);\n\n        /* Multi bulk length cannot be read without a \\r\\n */\n        newline = strchr(c->querybuf+c->qb_pos,'\\r');\n        if (newline == NULL) {\n            if (sdslen(c->querybuf)-c->qb_pos > PROTO_INLINE_MAX_SIZE) {\n                addReplyError(c,\"Protocol error: too big mbulk count string\");\n                setProtocolError(\"too big mbulk count string\",c);\n            }\n            return C_ERR;\n        }\n\n        /* Buffer should also contain \\n */\n        if (newline-(c->querybuf+c->qb_pos) > (ssize_t)(sdslen(c->querybuf)-c->qb_pos-2))\n            return C_ERR;\n\n        /* We know for sure there is a whole line since newline != NULL,\n         * so go ahead and find out the multi bulk length. */\n        serverAssertWithInfo(c,NULL,c->querybuf[c->qb_pos] == '*');\n        ok = string2ll(c->querybuf+1+c->qb_pos,newline-(c->querybuf+1+c->qb_pos),&ll);\n        if (!ok || ll > 1024*1024) {\n            addReplyError(c,\"Protocol error: invalid multibulk length\");\n            setProtocolError(\"invalid mbulk count\",c);\n            return C_ERR;\n        } else if (ll > 10 && authRequired(c)) {\n            addReplyError(c, \"Protocol error: unauthenticated multibulk length\");\n            setProtocolError(\"unauth mbulk count\", c);\n            return C_ERR;\n        }\n\n        c->qb_pos = (newline-c->querybuf)+2;\n\n        if (ll <= 0) return C_OK;\n\n        c->multibulklen = ll;\n\n        /* Setup argv array on client structure */\n        if (c->argv) zfree(c->argv);\n        c->argv = zmalloc(sizeof(robj*)*c->multibulklen);\n        c->argv_len_sum = 0;\n    }\n\n    serverAssertWithInfo(c,NULL,c->multibulklen > 0);\n    while(c->multibulklen) {\n        /* Read bulk length if unknown */\n        if (c->bulklen == -1) {\n            newline = strchr(c->querybuf+c->qb_pos,'\\r');\n            if (newline == NULL) {\n                if (sdslen(c->querybuf)-c->qb_pos > PROTO_INLINE_MAX_SIZE) {\n                    addReplyError(c,\n                        \"Protocol error: too big bulk count string\");\n                    setProtocolError(\"too big bulk count string\",c);\n                    return C_ERR;\n                }\n                break;\n            }\n\n            /* Buffer should also contain \\n */\n            if (newline-(c->querybuf+c->qb_pos) > (ssize_t)(sdslen(c->querybuf)-c->qb_pos-2))\n                break;\n\n            if (c->querybuf[c->qb_pos] != '$') {\n                addReplyErrorFormat(c,\n                    \"Protocol error: expected '$', got '%c'\",\n                    c->querybuf[c->qb_pos]);\n                setProtocolError(\"expected $ but got something else\",c);\n                return C_ERR;\n            }\n\n            ok = string2ll(c->querybuf+c->qb_pos+1,newline-(c->querybuf+c->qb_pos+1),&ll);\n            if (!ok || ll < 0 ||\n                (!(c->flags & CLIENT_MASTER) && ll > server.proto_max_bulk_len)) {\n                addReplyError(c,\"Protocol error: invalid bulk length\");\n                setProtocolError(\"invalid bulk length\",c);\n                return C_ERR;\n            } else if (ll > 16384 && authRequired(c)) {\n                addReplyError(c, \"Protocol error: unauthenticated bulk length\");\n                setProtocolError(\"unauth bulk length\", c);\n                return C_ERR;\n            }\n\n            c->qb_pos = newline-c->querybuf+2;\n            if (ll >= PROTO_MBULK_BIG_ARG) {\n                /* If we are going to read a large object from network\n                 * try to make it likely that it will start at c->querybuf\n                 * boundary so that we can optimize object creation\n                 * avoiding a large copy of data.\n                 *\n                 * But only when the data we have not parsed is less than\n                 * or equal to ll+2. If the data length is greater than\n                 * ll+2, trimming querybuf is just a waste of time, because\n                 * at this time the querybuf contains not only our bulk. */\n                if (sdslen(c->querybuf)-c->qb_pos <= (size_t)ll+2) {\n                    sdsrange(c->querybuf,c->qb_pos,-1);\n                    c->qb_pos = 0;\n                    /* Hint the sds library about the amount of bytes this string is\n                     * going to contain. */\n                    c->querybuf = sdsMakeRoomFor(c->querybuf,ll+2-sdslen(c->querybuf));\n                }\n            }\n            c->bulklen = ll;\n        }\n\n        /* Read bulk argument */\n        if (sdslen(c->querybuf)-c->qb_pos < (size_t)(c->bulklen+2)) {\n            /* Not enough data (+2 == trailing \\r\\n) */\n            break;\n        } else {\n            /* Optimization: if the buffer contains JUST our bulk element\n             * instead of creating a new object by *copying* the sds we\n             * just use the current sds string. */\n            if (c->qb_pos == 0 &&\n                c->bulklen >= PROTO_MBULK_BIG_ARG &&\n                sdslen(c->querybuf) == (size_t)(c->bulklen+2))\n            {\n                c->argv[c->argc++] = createObject(OBJ_STRING,c->querybuf);\n                c->argv_len_sum += c->bulklen;\n                sdsIncrLen(c->querybuf,-2); /* remove CRLF */\n                /* Assume that if we saw a fat argument we'll see another one\n                 * likely... */\n                c->querybuf = sdsnewlen(SDS_NOINIT,c->bulklen+2);\n                sdsclear(c->querybuf);\n            } else {\n                c->argv[c->argc++] =\n                    createStringObject(c->querybuf+c->qb_pos,c->bulklen);\n                c->argv_len_sum += c->bulklen;\n                c->qb_pos += c->bulklen+2;\n            }\n            c->bulklen = -1;\n            c->multibulklen--;\n        }\n    }\n\n    /* We're done when c->multibulk == 0 */\n    if (c->multibulklen == 0) return C_OK;\n\n    /* Still not ready to process the command */\n    return C_ERR;\n}", "target": 2, "idx": 11214}
{"commit_id": "dad0bf9ce93fa40b667eccd3306783f4db4b932b", "project": "kernel/git/tip/tip", "func": "static void k_shift(struct vc_data *vc, unsigned char value, char up_flag)\n{\n\tint old_state = shift_state;\n\n\tif (rep)\n\t\treturn;\n\t/*\n\t * Mimic typewriter:\n\t * a CapsShift key acts like Shift but undoes CapsLock\n\t */\n\tif (value == KVAL(K_CAPSSHIFT)) {\n\t\tvalue = KVAL(K_SHIFT);\n\t\tif (!up_flag)\n\t\t\tclr_vc_kbd_led(kbd, VC_CAPSLOCK);\n\t}\n\n\tif (up_flag) {\n\t\t/*\n\t\t * handle the case that two shift or control\n\t\t * keys are depressed simultaneously\n\t\t */\n\t\tif (shift_down[value])\n\t\t\tshift_down[value]--;\n\t} else\n\t\tshift_down[value]++;\n\n\tif (shift_down[value])\n\t\tshift_state |= (1 << value);\n\telse\n\t\tshift_state &= ~(1 << value);\n\n\t/* kludge */\n\tif (up_flag && shift_state != old_state && npadch_active) {\n\t\tif (kbd->kbdmode == VC_UNICODE)\n\t\t\tto_utf8(vc, npadch_value);\n\t\telse\n\t\t\tput_queue(vc, npadch_value & 0xff);\n\t\tnpadch_active = false;\n\t}\n}", "target": 2, "idx": 11215}
{"commit_id": "b8dcfeb065bbfd777cdc5f5433da9a87f25e6ec6", "project": "chromium", "func": "bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* isolate, const LocalDOMWindow* accessingWindow, const Node* target, ExceptionState& exceptionState)\n{\n    if (!target)\n        return false;\n    return canAccessFrame(accessingWindow, target->document().getSecurityOrigin(), target->document().domWindow(), exceptionState);\n}", "target": 1, "idx": 11216}
{"commit_id": "2e83b79b2d6c78bf1b4aa227938a214dcbddc83f", "project": "torvalds/linux", "func": "int\nxfs_attr_shortform_list(xfs_attr_list_context_t *context)\n{\n\tattrlist_cursor_kern_t *cursor;\n\txfs_attr_sf_sort_t *sbuf, *sbp;\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\txfs_inode_t *dp;\n\tint sbsize, nsbuf, count, i;\n\tint error;\n\n\tASSERT(context != NULL);\n\tdp = context->dp;\n\tASSERT(dp != NULL);\n\tASSERT(dp->i_afp != NULL);\n\tsf = (xfs_attr_shortform_t *)dp->i_afp->if_u1.if_data;\n\tASSERT(sf != NULL);\n\tif (!sf->hdr.count)\n\t\treturn 0;\n\tcursor = context->cursor;\n\tASSERT(cursor != NULL);\n\n\ttrace_xfs_attr_list_sf(context);\n\n\t/*\n\t * If the buffer is large enough and the cursor is at the start,\n\t * do not bother with sorting since we will return everything in\n\t * one buffer and another call using the cursor won't need to be\n\t * made.\n\t * Note the generous fudge factor of 16 overhead bytes per entry.\n\t * If bufsize is zero then put_listent must be a search function\n\t * and can just scan through what we have.\n\t */\n\tif (context->bufsize == 0 ||\n\t    (XFS_ISRESET_CURSOR(cursor) &&\n             (dp->i_afp->if_bytes + sf->hdr.count * 16) < context->bufsize)) {\n\t\tfor (i = 0, sfe = &sf->list[0]; i < sf->hdr.count; i++) {\n\t\t\terror = context->put_listent(context,\n\t\t\t\t\t   sfe->flags,\n\t\t\t\t\t   sfe->nameval,\n\t\t\t\t\t   (int)sfe->namelen,\n\t\t\t\t\t   (int)sfe->valuelen,\n\t\t\t\t\t   &sfe->nameval[sfe->namelen]);\n\n\t\t\t/*\n\t\t\t * Either search callback finished early or\n\t\t\t * didn't fit it all in the buffer after all.\n\t\t\t */\n\t\t\tif (context->seen_enough)\n\t\t\t\tbreak;\n\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe);\n\t\t}\n\t\ttrace_xfs_attr_list_sf_all(context);\n\t\treturn 0;\n\t}\n\n\t/* do no more for a search callback */\n\tif (context->bufsize == 0)\n\t\treturn 0;\n\n\t/*\n\t * It didn't all fit, so we have to sort everything on hashval.\n\t */\n\tsbsize = sf->hdr.count * sizeof(*sbuf);\n\tsbp = sbuf = kmem_alloc(sbsize, KM_SLEEP | KM_NOFS);\n\n\t/*\n\t * Scan the attribute list for the rest of the entries, storing\n\t * the relevant info from only those that match into a buffer.\n\t */\n\tnsbuf = 0;\n\tfor (i = 0, sfe = &sf->list[0]; i < sf->hdr.count; i++) {\n\t\tif (unlikely(\n\t\t    ((char *)sfe < (char *)sf) ||\n\t\t    ((char *)sfe >= ((char *)sf + dp->i_afp->if_bytes)))) {\n\t\t\tXFS_CORRUPTION_ERROR(\"xfs_attr_shortform_list\",\n\t\t\t\t\t     XFS_ERRLEVEL_LOW,\n\t\t\t\t\t     context->dp->i_mount, sfe);\n\t\t\tkmem_free(sbuf);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\tsbp->entno = i;\n\t\tsbp->hash = xfs_da_hashname(sfe->nameval, sfe->namelen);\n\t\tsbp->name = sfe->nameval;\n\t\tsbp->namelen = sfe->namelen;\n\t\t/* These are bytes, and both on-disk, don't endian-flip */\n\t\tsbp->valuelen = sfe->valuelen;\n\t\tsbp->flags = sfe->flags;\n\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe);\n\t\tsbp++;\n\t\tnsbuf++;\n\t}\n\n\t/*\n\t * Sort the entries on hash then entno.\n\t */\n\txfs_sort(sbuf, nsbuf, sizeof(*sbuf), xfs_attr_shortform_compare);\n\n\t/*\n\t * Re-find our place IN THE SORTED LIST.\n\t */\n\tcount = 0;\n\tcursor->initted = 1;\n\tcursor->blkno = 0;\n\tfor (sbp = sbuf, i = 0; i < nsbuf; i++, sbp++) {\n\t\tif (sbp->hash == cursor->hashval) {\n\t\t\tif (cursor->offset == count) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount++;\n\t\t} else if (sbp->hash > cursor->hashval) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == nsbuf) {\n\t\tkmem_free(sbuf);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Loop putting entries into the user buffer.\n\t */\n\tfor ( ; i < nsbuf; i++, sbp++) {\n\t\tif (cursor->hashval != sbp->hash) {\n\t\t\tcursor->hashval = sbp->hash;\n\t\t\tcursor->offset = 0;\n\t\t}\n\t\terror = context->put_listent(context,\n\t\t\t\t\tsbp->flags,\n\t\t\t\t\tsbp->name,\n\t\t\t\t\tsbp->namelen,\n\t\t\t\t\tsbp->valuelen,\n\t\t\t\t\t&sbp->name[sbp->namelen]);\n\t\tif (error) {\n\t\t\tkmem_free(sbuf);\n\t\t\treturn error;\n\t\t}\n\t\tif (context->seen_enough)\n\t\t\tbreak;\n\t\tcursor->offset++;\n\t}\n\n\tkmem_free(sbuf);\n\treturn 0;\n}", "target": 1, "idx": 11217}
{"commit_id": "eccc170053e46b4ab1d9e7485c09e210be15bbd7", "project": "xen-project/xen", "func": "static inline void write_cr4(unsigned long val)\n{\n    struct cpu_info *info = get_cpu_info();\n\n    /* No global pages in case of PCIDs enabled! */\n    ASSERT(!(val & X86_CR4_PGE) || !(val & X86_CR4_PCIDE));\n\n    /*\n     * On hardware supporting FSGSBASE, the value in %cr4 is the kernel's\n     * choice for 64bit PV guests, which impacts whether Xen can use the\n     * instructions.\n     *\n     * The {rd,wr}{fs,gs}base() helpers use info->cr4 to work out whether it\n     * is safe to execute the {RD,WR}{FS,GS}BASE instruction, falling back to\n     * the MSR path if not.  Some users require interrupt safety.\n     *\n     * If FSGSBASE is currently or about to become clear, reflect this in\n     * info->cr4 before updating %cr4, so an interrupt which hits in the\n     * middle won't observe FSGSBASE set in info->cr4 but clear in %cr4.\n     */\n    info->cr4 = val & (info->cr4 | ~X86_CR4_FSGSBASE);\n\n    asm volatile ( \"mov %[val], %%cr4\"\n                   : \"+m\" (info->cr4) /* Force ordering without a barrier. */\n                   : [val] \"r\" (val) );\n\n    info->cr4 = val;\n}", "target": 2, "idx": 11218}
{"commit_id": "5b397d455d25a391ba346863830c1949627b4d08", "project": "yhirose/cpp-httplib", "func": "inline bool ClientImpl::write_request(Stream &strm, Request &req,\n                                      bool close_connection, Error &error) {\n  // Prepare additional headers\n  if (close_connection) {\n    if (!req.has_header(\"Connection\")) {\n      req.set_header(\"Connection\", \"close\");\n    }\n  }\n\n  if (!req.has_header(\"Host\")) {\n    if (is_ssl()) {\n      if (port_ == 443) {\n        req.set_header(\"Host\", host_);\n      } else {\n        req.set_header(\"Host\", host_and_port_);\n      }\n    } else {\n      if (port_ == 80) {\n        req.set_header(\"Host\", host_);\n      } else {\n        req.set_header(\"Host\", host_and_port_);\n      }\n    }\n  }\n\n  if (!req.has_header(\"Accept\")) { req.set_header(\"Accept\", \"*/*\"); }\n\n#ifndef CPPHTTPLIB_NO_DEFAULT_USER_AGENT\n  if (!req.has_header(\"User-Agent\")) {\n    auto agent = std::string(\"cpp-httplib/\") + CPPHTTPLIB_VERSION;\n    req.set_header(\"User-Agent\", agent);\n  }\n#endif\n\n  if (req.body.empty()) {\n    if (req.content_provider_) {\n      if (!req.is_chunked_content_provider_) {\n        if (!req.has_header(\"Content-Length\")) {\n          auto length = std::to_string(req.content_length_);\n          req.set_header(\"Content-Length\", length);\n        }\n      }\n    } else {\n      if (req.method == \"POST\" || req.method == \"PUT\" ||\n          req.method == \"PATCH\") {\n        req.set_header(\"Content-Length\", \"0\");\n      }\n    }\n  } else {\n    if (!req.has_header(\"Content-Type\")) {\n      req.set_header(\"Content-Type\", \"text/plain\");\n    }\n\n    if (!req.has_header(\"Content-Length\")) {\n      auto length = std::to_string(req.body.size());\n      req.set_header(\"Content-Length\", length);\n    }\n  }\n\n  if (!basic_auth_password_.empty() || !basic_auth_username_.empty()) {\n    if (!req.has_header(\"Authorization\")) {\n      req.headers.insert(make_basic_authentication_header(\n          basic_auth_username_, basic_auth_password_, false));\n    }\n  }\n\n  if (!proxy_basic_auth_username_.empty() &&\n      !proxy_basic_auth_password_.empty()) {\n    if (!req.has_header(\"Proxy-Authorization\")) {\n      req.headers.insert(make_basic_authentication_header(\n          proxy_basic_auth_username_, proxy_basic_auth_password_, true));\n    }\n  }\n\n  if (!bearer_token_auth_token_.empty()) {\n    if (!req.has_header(\"Authorization\")) {\n      req.headers.insert(make_bearer_token_authentication_header(\n          bearer_token_auth_token_, false));\n    }\n  }\n\n  if (!proxy_bearer_token_auth_token_.empty()) {\n    if (!req.has_header(\"Proxy-Authorization\")) {\n      req.headers.insert(make_bearer_token_authentication_header(\n          proxy_bearer_token_auth_token_, true));\n    }\n  }\n\n  // Request line and headers\n  {\n    detail::BufferStream bstrm;\n\n    const auto &path = url_encode_ ? detail::encode_url(req.path) : req.path;\n    bstrm.write_format(\"%s %s HTTP/1.1\\r\\n\", req.method.c_str(), path.c_str());\n\n    detail::write_headers(bstrm, req.headers);\n\n    // Flush buffer\n    auto &data = bstrm.get_buffer();\n    if (!detail::write_data(strm, data.data(), data.size())) {\n      error = Error::Write;\n      return false;\n    }\n  }\n\n  // Body\n  if (req.body.empty()) {\n    return write_content_with_provider(strm, req, error);\n  }\n\n  if (!detail::write_data(strm, req.body.data(), req.body.size())) {\n    error = Error::Write;\n    return false;\n  }\n\n  return true;\n}", "target": 2, "idx": 11219}
{"commit_id": "b761c9b652af2107cfbc33efd19be0ce41daa33e", "project": "tensorflow", "func": "Status CalculateOutputIndex(OpKernelContext* context, int dimension,\n                              const vector<INDEX_TYPE>& parent_output_index,\n                              INDEX_TYPE output_index_multiplier,\n                              INDEX_TYPE output_size,\n                              vector<INDEX_TYPE>* result) {\n    const RowPartitionTensor row_partition_tensor =\n        GetRowPartitionTensor(context, dimension);\n    auto partition_type = GetRowPartitionTypeByDimension(dimension);\n    switch (partition_type) {\n      case RowPartitionType::VALUE_ROWIDS:\n        CalculateOutputIndexValueRowID(\n            context, row_partition_tensor, parent_output_index,\n            output_index_multiplier, output_size, result);\n        return tensorflow::Status::OK();\n      case RowPartitionType::ROW_SPLITS:\n        CalculateOutputIndexRowSplit(\n            context, row_partition_tensor, parent_output_index,\n            output_index_multiplier, output_size, result);\n        return tensorflow::Status::OK();\n      default:\n        return errors::InvalidArgument(\n            \"Unsupported partition type:\",\n            RowPartitionTypeToString(partition_type));\n    }\n  }", "target": 1, "idx": 11220}
{"commit_id": "d7325bac173492b358417a0ad49fabad44447d52", "project": "ImageMagick", "func": "static MagickBooleanType ReadUncompressedRGB(Image *image, DDSInfo *dds_info,\n  ExceptionInfo *exception)\n{\n  PixelPacket\n    *q;\n\n  ssize_t\n    x, y;\n\n  unsigned short\n    color;\n\n  if (dds_info->pixelformat.rgb_bitcount == 8)\n    (void) SetImageType(image,GrayscaleType);\n  else if (dds_info->pixelformat.rgb_bitcount == 16 && !IsBitMask(\n    dds_info->pixelformat,0xf800,0x07e0,0x001f,0x0000))\n    ThrowBinaryException(CorruptImageError,\"ImageTypeNotSupported\",\n      image->filename);\n\n  for (y = 0; y < (ssize_t) dds_info->height; y++)\n  {\n    q = QueueAuthenticPixels(image, 0, y, dds_info->width, 1,exception);\n\n    if (q == (PixelPacket *) NULL)\n      return MagickFalse;\n\n    for (x = 0; x < (ssize_t) dds_info->width; x++)\n    {\n      if (dds_info->pixelformat.rgb_bitcount == 8)\n        SetPixelGray(q,ScaleCharToQuantum(ReadBlobByte(image)));\n      else if (dds_info->pixelformat.rgb_bitcount == 16)\n        {\n           color=ReadBlobShort(image);\n           SetPixelRed(q,ScaleCharToQuantum((unsigned char)\n             (((color >> 11)/31.0)*255)));\n           SetPixelGreen(q,ScaleCharToQuantum((unsigned char)\n             ((((unsigned short)(color << 5) >> 10)/63.0)*255)));\n           SetPixelBlue(q,ScaleCharToQuantum((unsigned char)\n             ((((unsigned short)(color << 11) >> 11)/31.0)*255)));\n        }\n      else\n        {\n          SetPixelBlue(q,ScaleCharToQuantum((unsigned char)\n            ReadBlobByte(image)));\n          SetPixelGreen(q,ScaleCharToQuantum((unsigned char)\n            ReadBlobByte(image)));\n          SetPixelRed(q,ScaleCharToQuantum((unsigned char)\n            ReadBlobByte(image)));\n          if (dds_info->pixelformat.rgb_bitcount == 32)\n            (void) ReadBlobByte(image);\n        }\n      SetPixelAlpha(q,QuantumRange);\n      q++;\n    }\n \n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      return MagickFalse;\n  }\n\n  return(SkipRGBMipmaps(image,dds_info,3,exception));\n}", "target": 1, "idx": 11221}
{"commit_id": "619df528295ef564592a898d58b560c3f3176e21", "project": "pcmacdon/jsish", "func": "Jsi_Func *jsi_FuncMake(jsi_Pstate *pstate, Jsi_ScopeStrs *args, Jsi_OpCodes *ops,\n    jsi_Pline* line, const char *name, int flags)\n{\n    Jsi_Interp *interp = pstate->interp;\n    Jsi_ScopeStrs *localvar = jsi_ScopeGetVarlist(pstate);\n    Jsi_Func *f = jsi_FuncNew(interp);\n    jsi_Lexer *l = pstate->lexer;\n    f->isArrow = flags&1;\n    if (f->isArrow && interp->noES6) {\n        Jsi_LogError(\"es6 feature: arrow function '%s'\", name);\n        pstate->err_count++;\n    }\n    f->isSet = flags&2;\n    f->isGet = flags&4;\n    f->type = FC_NORMAL;\n    f->opcodes = ops;\n    f->argnames = args;\n    f->localnames = localvar;\n    f->bodyline = *line;\n    f->retType = (Jsi_otype)args->retType;\n    if (l->ltype == LT_STRING)\n        f->bodyStr = l->d.str;\n    f->endPos = l->cur;\n    f->startPos = -1; // Have to get these from newline count.\n    if (f->retType & JSI_TT_UNDEFINED)\n        Jsi_LogWarn(\"invalid use of 'undefined' in a return type: %s\", name?name:\"\");\n    \n    pstate->argType = 0;\n    if (localvar && args && (!interp->noCheck)) {\n        int i, j;\n        for (i=0; i<args->count; i++) {\n            char *anam = args->args[i].name;\n            if (Jsi_IsReserved(interp, anam, 0)) {\n                if (line)\n                    interp->parseLine = line;\n                Jsi_LogError(\"function %s():  reserved parameter name '%s'\", name?name:\"\", anam);\n                if (line)\n                    interp->parseLine = NULL;\n                pstate->err_count++;\n                break;\n            }\n            for (j=0; j<args->count; j++) {\n                if (i != j && !Jsi_Strcmp(anam, args->args[j].name)) {\n                    if (line)\n                        interp->parseLine = line;\n                    Jsi_LogError(\"function %s():  duplicate parameter name '%s'\", name?name:\"\", anam);\n                    if (line)\n                        interp->parseLine = NULL;\n                    pstate->err_count++;\n                }\n            }\n            for (j=0; j<localvar->count; j++) {\n                if (!Jsi_Strcmp(localvar->args[j].name, args->args[i].name)) {\n                    if (line)\n                        interp->parseLine = line;\n                    Jsi_LogError(\"function %s():  parameter name conflicts with local '%s'\", name?name:\"\", localvar->args[j].name);\n                    if (line)\n                        interp->parseLine = NULL;\n                    pstate->err_count++;\n                }\n            }\n        }\n    }\n    if (name) {\n        if ((name[0] == 'a' && !Jsi_Strcmp(name,\"assert\"))\n            || (name[0] == 'L' && (!Jsi_Strcmp(name,\"LogDebug\") || !Jsi_Strcmp(name,\"LogTrace\") || !Jsi_Strcmp(name,\"LogTest\")))) {\n                if (line)\n                    interp->parseLine = line;\n                Jsi_LogError(\"invalid redefine of builtin: %s\", name);\n                if (line)\n                    interp->parseLine = NULL;\n                pstate->err_count++;\n        }\n        f->name = Jsi_KeyAdd(interp, name);\n        if (!interp->noCheck) {\n            \n            if (f->retType && !(f->retType&JSI_TT_VOID) && ops && ops->code_len && ops->codes[ops->code_len-1].op != OP_RET) {\n                if (line)\n                    interp->parseLine = line;\n                Jsi_LogWarn(\"missing return at end of function '%s'\", name);\n                if (line)\n                    interp->parseLine = NULL;\n                //if (interp->typeCheck.error)\n                 //   pstate->err_count++;\n            }\n             \n            Jsi_Func *fo = (Jsi_Func*)Jsi_HashGet(interp->staticFuncsTbl, (void*)name, 0);\n            \n            // Forward declaration signature compare (indicated by an empty body).\n            if (interp->typeCheck.funcdecl && fo && fo->opcodes && fo->opcodes->code_len == 1 && fo->opcodes->codes->op == OP_NOP) {\n                if (!jsi_FuncSigsMatch(pstate, f, fo)) {\n                    if (line)\n                        interp->parseLine = line;\n                    Jsi_LogWarn(\"possible signature mismatch for function '%s' at %.120s:%d\", name, fo->filePtr->fileName, fo->bodyline.first_line);\n                    if (line)\n                        interp->parseLine = NULL;\n                    jsi_TypeMismatch(interp);\n                }\n                //printf(\"OLD: %s\\n\", name);\n            }\n            Jsi_HashSet(interp->staticFuncsTbl, name, f);\n        }\n    }\n    return f;\n}", "target": 1, "idx": 11222}
{"commit_id": "c7e46e948ebe2d4a532539c7e714cdf655b84521", "project": "gpac", "func": "static void fill_isom_es_ifce(M2TSSource *source, GF_ESInterface *ifce, GF_ISOFile *mp4, u32 track_num, u32 bifs_use_pes, Bool compute_max_size)\n{\n\tGF_ESIMP4 *priv;\n\tchar *_lan;\n\tGF_ESD *esd;\n\tBool is_hevc=GF_FALSE;\n\tu64 avg_rate, duration;\n\ts32 ref_count;\n\ts64 mediaOffset;\n\n\tGF_SAFEALLOC(priv, GF_ESIMP4);\n\tif (!priv) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_APP, (\"Failed to allocate MP4 input handler\\n\"));\n\t\treturn;\n\t}\n\n\tpriv->mp4 = mp4;\n\tpriv->track = track_num;\n\tpriv->mtype = gf_isom_get_media_type(priv->mp4, priv->track);\n\tpriv->mstype = gf_isom_get_media_subtype(priv->mp4, priv->track, 1);\n\tpriv->loop = source->real_time ? GF_TRUE : GF_FALSE;\n\tpriv->sample_count = gf_isom_get_sample_count(mp4, track_num);\n\tsource->samples_count += priv->sample_count;\n\tif (priv->sample_count>1)\n\t\tsource->nb_real_streams++;\n\n\tpriv->source = source;\n\tmemset(ifce, 0, sizeof(GF_ESInterface));\n\tifce->stream_id = gf_isom_get_track_id(mp4, track_num);\n\n\tesd = gf_media_map_esd(mp4, track_num);\n\n\tif (esd) {\n\t\tifce->stream_type = esd->decoderConfig->streamType;\n\t\tifce->object_type_indication = esd->decoderConfig->objectTypeIndication;\n\t\tif (esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->dataLength) {\n\t\t\tswitch (esd->decoderConfig->objectTypeIndication) {\n\t\t\tcase GPAC_OTI_AUDIO_AAC_MPEG4:\n\t\t\tcase GPAC_OTI_AUDIO_AAC_MPEG2_MP:\n\t\t\tcase GPAC_OTI_AUDIO_AAC_MPEG2_LCP:\n\t\t\tcase GPAC_OTI_AUDIO_AAC_MPEG2_SSRP:\n\t\t\tcase GPAC_OTI_VIDEO_MPEG4_PART2:\n\t\t\t\tifce->decoder_config = (char *)gf_malloc(sizeof(char)*esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\t\tifce->decoder_config_size = esd->decoderConfig->decoderSpecificInfo->dataLength;\n\t\t\t\tmemcpy(ifce->decoder_config, esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\t\tif (esd->decoderConfig->objectTypeIndication == GPAC_OTI_VIDEO_MPEG4_PART2) {\n\t\t\t\t\tpriv->dsi = (char *)gf_malloc(sizeof(char)*esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\t\t\tpriv->dsi_size = esd->decoderConfig->decoderSpecificInfo->dataLength;\n\t\t\t\t\tmemcpy(priv->dsi, esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GPAC_OTI_VIDEO_HEVC:\n\t\t\tcase GPAC_OTI_VIDEO_LHVC:\n\t\t\t\tis_hevc=GF_TRUE;\n\t\t\tcase GPAC_OTI_VIDEO_AVC:\n\t\t\tcase GPAC_OTI_VIDEO_SVC:\n\t\t\tcase GPAC_OTI_VIDEO_MVC:\n\t\t\t\tgf_isom_set_nalu_extract_mode(mp4, track_num, GF_ISOM_NALU_EXTRACT_LAYER_ONLY | GF_ISOM_NALU_EXTRACT_INBAND_PS_FLAG | GF_ISOM_NALU_EXTRACT_ANNEXB_FLAG | GF_ISOM_NALU_EXTRACT_VDRD_FLAG);\n\t\t\t\tbreak;\n\t\t\tcase GPAC_OTI_SCENE_VTT_MP4:\n\t\t\t\tifce->decoder_config = (char *)gf_malloc(sizeof(char)*esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\t\tifce->decoder_config_size = esd->decoderConfig->decoderSpecificInfo->dataLength;\n\t\t\t\tmemcpy(ifce->decoder_config, esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tgf_odf_desc_del((GF_Descriptor *)esd);\n\t}\n\tgf_isom_get_media_language(mp4, track_num, &_lan);\n\tif (!_lan || !strcmp(_lan, \"und\")) {\n\t\tifce->lang = 0;\n\t} else {\n\t\tifce->lang = GF_4CC(_lan[0],_lan[1],_lan[2],' ');\n\t}\n\tif (_lan) {\n\t\tgf_free(_lan);\n\t}\n\n\tifce->timescale = gf_isom_get_media_timescale(mp4, track_num);\n\tifce->duration = gf_isom_get_media_timescale(mp4, track_num);\n\tavg_rate = gf_isom_get_media_data_size(mp4, track_num);\n\tif (!avg_rate) return;\n\tavg_rate *= ifce->timescale * 8;\n\tif (0!=(duration=gf_isom_get_media_duration(mp4, track_num)))\n\t\tavg_rate /= duration;\n\n\tif (gf_isom_has_time_offset(mp4, track_num)) ifce->caps |= GF_ESI_SIGNAL_DTS;\n\n\tifce->bit_rate = (u32) avg_rate;\n\tifce->duration = (Double) (s64) gf_isom_get_media_duration(mp4, track_num);\n\tifce->duration /= ifce->timescale;\n\n\tGF_SAFEALLOC(ifce->sl_config, GF_SLConfig);\n\tif (!ifce->sl_config) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_APP, (\"Failed to allocate interface SLConfig\\n\"));\n\t\treturn;\n\t}\n\n\tifce->sl_config->tag = GF_ODF_SLC_TAG;\n\tifce->sl_config->useAccessUnitStartFlag = 1;\n\tifce->sl_config->useAccessUnitEndFlag = 1;\n\tifce->sl_config->useRandomAccessPointFlag = 1;\n\tifce->sl_config->useTimestampsFlag = 1;\n\tifce->sl_config->timestampLength = 33;\n\tifce->sl_config->timestampResolution = ifce->timescale;\n\n\t/*test mode in which time stamps are 90khz and not coded but copied over from PES header*/\n\tif (bifs_use_pes==2) {\n\t\tifce->sl_config->timestampLength = 0;\n\t\tifce->sl_config->timestampResolution = 90000;\n\t}\n\n#ifdef GPAC_DISABLE_ISOM_WRITE\n\tfprintf(stderr, \"Warning: GPAC was compiled without ISOM Write support, can't set SL Config!\\n\");\n#else\n\tgf_isom_set_extraction_slc(mp4, track_num, 1, ifce->sl_config);\n#endif\n\n\tifce->input_ctrl = mp4_input_ctrl;\n\tif (priv != ifce->input_udta) {\n\t\tif (ifce->input_udta)\n\t\t\tgf_free(ifce->input_udta);\n\t\tifce->input_udta = priv;\n\t}\n\n\n\tif (! gf_isom_get_edit_list_type(mp4, track_num, &mediaOffset)) {\n\t\tpriv->ts_offset = mediaOffset;\n\t}\n\n\tif (gf_isom_has_time_offset(mp4, track_num)==2) {\n\t\tpriv->cts_dts_shift = gf_isom_get_cts_to_dts_shift(mp4, track_num);\n\t}\n\n\tifce->depends_on_stream = 0;\n\tref_count = gf_isom_get_reference_count(mp4, track_num, GF_ISOM_REF_SCAL);\n\tif (ref_count > 0) {\n\t\tgf_isom_get_reference_ID(mp4, track_num, GF_ISOM_REF_SCAL, (u32) ref_count, &ifce->depends_on_stream);\n\t} else if (is_hevc) {\n\t\tref_count = gf_isom_get_reference_count(mp4, track_num, GF_ISOM_REF_BASE);\n\t\tif (ref_count > 0) {\n\t\t\tgf_isom_get_reference_ID(mp4, track_num, GF_ISOM_REF_BASE, (u32) ref_count, &ifce->depends_on_stream);\n\t\t}\n\t}\n\n\tif (compute_max_size) {\n\t\tu32 i;\n\t\tfor (i=0; i < priv->sample_count; i++) {\n\t\t\tu32 s = gf_isom_get_sample_size(mp4, track_num, i+1);\n\t\t\tif (s>source->max_sample_size) source->max_sample_size = s;\n\t\t}\n\t}\n\n}", "target": 1, "idx": 11223}
{"commit_id": "340f0eb7f3673e8aacaf0a96cbfcd4d12a405521", "project": "SELinuxProject/selinux", "func": "int __cil_resolve_ast_node_helper(struct cil_tree_node *node, uint32_t *finished, void *extra_args)\n{\n\tint rc = SEPOL_OK;\n\tstruct cil_args_resolve *args = extra_args;\n\tenum cil_pass pass = args->pass;\n\tstruct cil_tree_node *block = args->block;\n\tstruct cil_tree_node *macro = args->macro;\n\tstruct cil_tree_node *optional = args->optional;\n\tstruct cil_tree_node *boolif = args->boolif;\n\n\tif (node == NULL) {\n\t\tgoto exit;\n\t}\n\n\tif (block != NULL) {\n\t\tif (node->flavor == CIL_CAT ||\n\t\t    node->flavor == CIL_SENS) {\n\t\t\tcil_tree_log(node, CIL_ERR, \"%s statement is not allowed in blocks\", cil_node_to_string(node));\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (macro != NULL) {\n\t\tif (node->flavor == CIL_BLOCK ||\n\t\t    node->flavor == CIL_BLOCKINHERIT ||\n\t\t    node->flavor == CIL_BLOCKABSTRACT ||\n\t\t    node->flavor == CIL_MACRO) {\n\t\t\tcil_tree_log(node, CIL_ERR, \"%s statement is not allowed in macros\", cil_node_to_string(node));\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (optional != NULL) {\n\t\tif (node->flavor == CIL_TUNABLE ||\n\t\t\tnode->flavor == CIL_IN ||\n\t\t\tnode->flavor == CIL_BLOCK ||\n\t\t\tnode->flavor == CIL_BLOCKABSTRACT ||\n\t\t    node->flavor == CIL_MACRO) {\n\t\t\tcil_tree_log(node, CIL_ERR, \"%s statement is not allowed in optionals\", cil_node_to_string(node));\n\t\t\trc = SEPOL_ERR;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (boolif != NULL) {\n\t\tif (node->flavor != CIL_TUNABLEIF &&\n\t\t\tnode->flavor != CIL_CALL &&\n\t\t\tnode->flavor != CIL_CONDBLOCK &&\n\t\t\tnode->flavor != CIL_AVRULE &&\n\t\t\tnode->flavor != CIL_TYPE_RULE &&\n\t\t\tnode->flavor != CIL_NAMETYPETRANSITION) {\n\t\t\trc = SEPOL_ERR;\n\t\t} else if (node->flavor == CIL_AVRULE) {\n\t\t\tstruct cil_avrule *rule = node->data;\n\t\t\tif (rule->rule_kind == CIL_AVRULE_NEVERALLOW) {\n\t\t\t\trc = SEPOL_ERR;\n\t\t\t}\n\t\t}\n\t\tif (rc == SEPOL_ERR) {\n\t\t\tif (((struct cil_booleanif*)boolif->data)->preserved_tunable) {\n\t\t\t\tcil_tree_log(node, CIL_ERR, \"%s statement is not allowed in booleanifs (tunableif treated as a booleanif)\", cil_node_to_string(node));\n\t\t\t} else {\n\t\t\t\tcil_tree_log(node, CIL_ERR, \"%s statement is not allowed in booleanifs\", cil_node_to_string(node));\n\t\t\t}\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (node->flavor == CIL_MACRO) {\n\t\tif (pass != CIL_PASS_TIF && pass != CIL_PASS_MACRO) {\n\t\t\t*finished = CIL_TREE_SKIP_HEAD;\n\t\t\trc = SEPOL_OK;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (node->flavor == CIL_BLOCK && ((((struct cil_block*)node->data)->is_abstract == CIL_TRUE) && (pass > CIL_PASS_BLKABS))) {\n\t\t*finished = CIL_TREE_SKIP_HEAD;\n\t\trc = SEPOL_OK;\n\t\tgoto exit;\n\t}\n\n\trc = __cil_resolve_ast_node(node, extra_args);\n\tif (rc == SEPOL_ENOENT) {\n\t\tenum cil_log_level lvl = CIL_ERR;\n\n\t\tif (optional != NULL) {\n\t\t\tlvl = CIL_INFO;\n\n\t\t\tstruct cil_optional *opt = (struct cil_optional *)optional->data;\n\t\t\tstruct cil_tree_node *opt_node = NODE(opt);;\n\t\t\t/* disable an optional if something failed to resolve */\n\t\t\topt->enabled = CIL_FALSE;\n\t\t\tcil_tree_log(node, lvl, \"Failed to resolve %s statement\", cil_node_to_string(node));\n\t\t\tcil_tree_log(opt_node, lvl, \"Disabling optional '%s'\", opt->datum.name);\n\t\t\trc = SEPOL_OK;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tcil_tree_log(node, lvl, \"Failed to resolve %s statement\", cil_node_to_string(node));\n\t\tgoto exit;\n\t}\n\n\treturn rc;\n\nexit:\n\treturn rc;\n}", "target": 0, "idx": 11224}
{"commit_id": "bb41b6619210d998f1abacc43ee20acc985249a4", "project": "wireshark", "func": "static int\ndissect_modbus_request(tvbuff_t *tvb, packet_info *pinfo, proto_tree *modbus_tree, guint8 function_code, gint payload_start, gint payload_len, modbus_pkt_info_t *pkt_info)\n{\n    proto_tree    *group_tree;\n    gint          byte_cnt, group_offset, ii;\n    guint8        mei_code;\n    guint16       reg_base=0, diagnostic_code;\n    guint32       group_byte_cnt, group_word_cnt;\n\n    if (!pkt_info) {\n        return 0;\n    }\n\n    switch (function_code) {\n\n        case READ_COILS:\n        case READ_DISCRETE_INPUTS:\n            proto_tree_add_item(modbus_tree, hf_modbus_reference, tvb, payload_start, 2, ENC_BIG_ENDIAN);\n            proto_tree_add_item(modbus_tree, hf_modbus_bitcnt, tvb, payload_start + 2, 2, ENC_BIG_ENDIAN);\n            break;\n\n        case READ_HOLDING_REGS:\n        case READ_INPUT_REGS:\n            proto_tree_add_item(modbus_tree, hf_modbus_reference, tvb, payload_start, 2, ENC_BIG_ENDIAN);\n            proto_tree_add_item(modbus_tree, hf_modbus_wordcnt, tvb, payload_start + 2, 2, ENC_BIG_ENDIAN);\n            break;\n\n        case WRITE_SINGLE_COIL:\n            proto_tree_add_item(modbus_tree, hf_modbus_reference, tvb, payload_start, 2, ENC_BIG_ENDIAN);\n            dissect_modbus_data(tvb, pinfo, modbus_tree, function_code, payload_start + 2, 1, pkt_info->register_format, reg_base, 0);\n            proto_tree_add_item(modbus_tree, hf_modbus_padding, tvb, payload_start + 3, 1, ENC_NA);\n            break;\n\n        case WRITE_SINGLE_REG:\n            proto_tree_add_item(modbus_tree, hf_modbus_reference, tvb, payload_start, 2, ENC_BIG_ENDIAN);\n            dissect_modbus_data(tvb, pinfo, modbus_tree, function_code, payload_start + 2, 2, pkt_info->register_format, reg_base, 0);\n            break;\n\n        case READ_EXCEPT_STAT:\n            /* Do Nothing  */\n            break;\n\n        case DIAGNOSTICS:\n            diagnostic_code = tvb_get_ntohs(tvb, payload_start);\n            proto_tree_add_uint(modbus_tree, hf_modbus_diag_sf, tvb, payload_start, 2, diagnostic_code);\n            switch(diagnostic_code)\n            {\n                case RETURN_QUERY_DATA:\n                    if (payload_len > 2)\n                        proto_tree_add_item(modbus_tree, hf_modbus_diag_return_query_data_request, tvb, payload_start+2, payload_len-2, ENC_NA);\n                    break;\n                case RESTART_COMMUNICATION_OPTION:\n                    proto_tree_add_item(modbus_tree, hf_modbus_diag_restart_communication_option, tvb, payload_start+2, 2, ENC_BIG_ENDIAN);\n                    break;\n                case CHANGE_ASCII_INPUT_DELIMITER:\n                    proto_tree_add_item(modbus_tree, hf_modbus_diag_ascii_input_delimiter, tvb, payload_start+2, 1, ENC_BIG_ENDIAN);\n                    break;\n                case RETURN_DIAGNOSTIC_REGISTER:           /* 00 00 Data Field */\n                case FORCE_LISTEN_ONLY_MODE:               /* 00 00 Data Field */\n                case CLEAR_COUNTERS_AND_DIAG_REG:          /* 00 00 Data Field */\n                case RETURN_BUS_MESSAGE_COUNT:             /* 00 00 Data Field */\n                case RETURN_BUS_COMM_ERROR_COUNT:          /* 00 00 Data Field */\n                case RETURN_BUS_EXCEPTION_ERROR_COUNT:     /* 00 00 Data Field */\n                case RETURN_SLAVE_MESSAGE_COUNT:           /* 00 00 Data Field */\n                case RETURN_SLAVE_NO_RESPONSE_COUNT:       /* 00 00 Data Field */\n                case RETURN_SLAVE_NAK_COUNT:               /* 00 00 Data Field */\n                case RETURN_SLAVE_BUSY_COUNT:              /* 00 00 Data Field */\n                case RETURN_BUS_CHAR_OVERRUN_COUNT:        /* 00 00 Data Field */\n                case CLEAR_OVERRUN_COUNTER_AND_FLAG:\n                default:\n                    if (payload_len > 2)\n                        dissect_modbus_data(tvb, pinfo, modbus_tree, function_code, payload_start+2, payload_len-2, pkt_info->register_format, reg_base, 0);\n                    break;\n            }\n            break;\n        case WRITE_MULT_COILS:\n            proto_tree_add_item(modbus_tree, hf_modbus_reference, tvb, payload_start, 2, ENC_BIG_ENDIAN);\n            proto_tree_add_item(modbus_tree, hf_modbus_bitcnt, tvb, payload_start + 2, 2, ENC_BIG_ENDIAN);\n            byte_cnt = (guint32)tvb_get_guint8(tvb, payload_start + 4);\n            proto_tree_add_uint(modbus_tree, hf_modbus_bytecnt, tvb, payload_start + 4, 1, byte_cnt);\n            dissect_modbus_data(tvb, pinfo, modbus_tree, function_code, payload_start + 5, byte_cnt, pkt_info->register_format, reg_base, 0);\n            break;\n\n        case WRITE_MULT_REGS:\n            reg_base = tvb_get_ntohs(tvb, payload_start);\n            proto_tree_add_item(modbus_tree, hf_modbus_reference, tvb, payload_start, 2, ENC_BIG_ENDIAN);\n            proto_tree_add_item(modbus_tree, hf_modbus_wordcnt, tvb, payload_start + 2, 2, ENC_BIG_ENDIAN);\n            byte_cnt = (guint32)tvb_get_guint8(tvb, payload_start + 4);\n            proto_tree_add_uint(modbus_tree, hf_modbus_bytecnt, tvb, payload_start + 4, 1, byte_cnt);\n            dissect_modbus_data(tvb, pinfo, modbus_tree, function_code, payload_start + 5, byte_cnt, pkt_info->register_format, reg_base, 0);\n            break;\n\n        case READ_FILE_RECORD:\n            byte_cnt = (guint32)tvb_get_guint8(tvb, payload_start);\n            proto_tree_add_uint(modbus_tree, hf_modbus_bytecnt, tvb, payload_start, 1,\n                    byte_cnt);\n\n            /* add subtrees to describe each group of packet */\n            group_offset = payload_start + 1;\n            for (ii = 0; ii < byte_cnt / 7; ii++) {\n                group_tree = proto_tree_add_subtree_format( modbus_tree, tvb, group_offset, 7,\n                        ett_group_hdr, NULL, \"Group %u\", ii);\n                proto_tree_add_item(group_tree, hf_modbus_reftype, tvb, group_offset, 1, ENC_BIG_ENDIAN);\n                proto_tree_add_item(group_tree, hf_modbus_lreference, tvb, group_offset + 1, 4, ENC_BIG_ENDIAN);\n                proto_tree_add_item(group_tree, hf_modbus_wordcnt, tvb, group_offset + 5, 2, ENC_BIG_ENDIAN);\n                group_offset += 7;\n            }\n            break;\n\n        case WRITE_FILE_RECORD:\n            byte_cnt = (guint32)tvb_get_guint8(tvb, payload_start);\n            proto_tree_add_uint(modbus_tree, hf_modbus_bytecnt, tvb, payload_start, 1, byte_cnt);\n\n            /* add subtrees to describe each group of packet */\n            group_offset = payload_start + 1;\n            ii = 0;\n            while (byte_cnt > 0) {\n                group_word_cnt = tvb_get_ntohs(tvb, group_offset + 5);\n                group_byte_cnt = (2 * group_word_cnt) + 7;\n                group_tree = proto_tree_add_subtree_format( modbus_tree, tvb, group_offset,\n                        group_byte_cnt, ett_group_hdr, NULL, \"Group %u\", ii);\n                proto_tree_add_item(group_tree, hf_modbus_reftype, tvb, group_offset, 1, ENC_BIG_ENDIAN);\n                proto_tree_add_item(group_tree, hf_modbus_lreference, tvb, group_offset + 1, 4, ENC_BIG_ENDIAN);\n                proto_tree_add_uint(group_tree, hf_modbus_wordcnt, tvb, group_offset + 5, 2, group_word_cnt);\n                dissect_modbus_data(tvb, pinfo, group_tree, function_code, group_offset + 7, group_byte_cnt - 7, pkt_info->register_format, reg_base, 0);\n                group_offset += group_byte_cnt;\n                byte_cnt -= group_byte_cnt;\n                ii++;\n            }\n            break;\n\n        case MASK_WRITE_REG:\n            proto_tree_add_item(modbus_tree, hf_modbus_reference, tvb, payload_start, 2, ENC_BIG_ENDIAN);\n            proto_tree_add_item(modbus_tree, hf_modbus_andmask, tvb, payload_start + 2, 2, ENC_BIG_ENDIAN);\n            proto_tree_add_item(modbus_tree, hf_modbus_ormask, tvb, payload_start + 4, 2, ENC_BIG_ENDIAN);\n            break;\n\n        case READ_WRITE_REG:\n            proto_tree_add_item(modbus_tree, hf_modbus_readref, tvb, payload_start, 2, ENC_BIG_ENDIAN);\n            proto_tree_add_item(modbus_tree, hf_modbus_readwordcnt, tvb, payload_start + 2, 2, ENC_BIG_ENDIAN);\n            proto_tree_add_item(modbus_tree, hf_modbus_writeref, tvb, payload_start + 4, 2, ENC_BIG_ENDIAN);\n            proto_tree_add_item(modbus_tree, hf_modbus_writewordcnt, tvb, payload_start + 6, 2, ENC_BIG_ENDIAN);\n            byte_cnt = (guint32)tvb_get_guint8(tvb, payload_start + 8);\n            proto_tree_add_uint(modbus_tree, hf_modbus_bytecnt, tvb, payload_start + 8, 1, byte_cnt);\n            dissect_modbus_data(tvb, pinfo, modbus_tree, function_code, payload_start + 9, byte_cnt, pkt_info->register_format, reg_base, 0);\n            break;\n\n        case READ_FIFO_QUEUE:\n            proto_tree_add_item(modbus_tree, hf_modbus_reference, tvb, payload_start, 2, ENC_BIG_ENDIAN);\n            break;\n\n        case ENCAP_INTERFACE_TRANSP:\n            proto_tree_add_item(modbus_tree, hf_modbus_mei, tvb, payload_start, 1, ENC_BIG_ENDIAN);\n            mei_code = tvb_get_guint8(tvb, payload_start);\n            switch (mei_code)\n            {\n                case READ_DEVICE_ID:\n                    proto_tree_add_item(modbus_tree, hf_modbus_read_device_id, tvb, payload_start+1, 1, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(modbus_tree, hf_modbus_object_id, tvb, payload_start+2, 1, ENC_BIG_ENDIAN);\n                    break;\n\n                case CANOPEN_REQ_RESP:\n                    /* CANopen protocol not part of the Modbus/TCP specification */\n                default:\n                    if (payload_len > 1)\n                        dissect_modbus_data(tvb, pinfo, modbus_tree, function_code, payload_start, payload_len-1, pkt_info->register_format, reg_base, 0);\n                    break;\n            }\n\n            break;\n\n        case REPORT_SLAVE_ID:\n        default:\n            if (payload_len > 0)\n                dissect_modbus_data(tvb, pinfo, modbus_tree, function_code, payload_start, payload_len, pkt_info->register_format, reg_base, 0);\n            break;\n\n    } /* Function Code */\n\n    return tvb_captured_length(tvb);\n}", "target": 2, "idx": 11225}
{"commit_id": "8a7d4cf9820ea16fabd25a6379351b4dc291204b", "project": "u-boot", "func": "int fdt_find_regions(const void *fdt, char * const inc[], int inc_count,\n\t\t     char * const exc_prop[], int exc_prop_count,\n\t\t     struct fdt_region region[], int max_regions,\n\t\t     char *path, int path_len, int add_string_tab)\n{\n\tint stack[FDT_MAX_DEPTH] = { 0 };\n\tchar *end;\n\tint nextoffset = 0;\n\tuint32_t tag;\n\tint count = 0;\n\tint start = -1;\n\tint depth = -1;\n\tint want = 0;\n\tint base = fdt_off_dt_struct(fdt);\n\tbool expect_end = false;\n\n\tend = path;\n\t*end = '\\0';\n\tdo {\n\t\tconst struct fdt_property *prop;\n\t\tconst char *name;\n\t\tconst char *str;\n\t\tint include = 0;\n\t\tint stop_at = 0;\n\t\tint offset;\n\t\tint len;\n\n\t\toffset = nextoffset;\n\t\ttag = fdt_next_tag(fdt, offset, &nextoffset);\n\t\tstop_at = nextoffset;\n\n\t\t/* If we see two root nodes, something is wrong */\n\t\tif (expect_end && tag != FDT_END)\n\t\t\treturn -FDT_ERR_BADLAYOUT;\n\n\t\tswitch (tag) {\n\t\tcase FDT_PROP:\n\t\t\tinclude = want >= 2;\n\t\t\tstop_at = offset;\n\t\t\tprop = fdt_get_property_by_offset(fdt, offset, NULL);\n\t\t\tstr = fdt_string(fdt, fdt32_to_cpu(prop->nameoff));\n\t\t\tif (!str)\n\t\t\t\treturn -FDT_ERR_BADSTRUCTURE;\n\t\t\tif (str_in_list(str, exc_prop, exc_prop_count))\n\t\t\t\tinclude = 0;\n\t\t\tbreak;\n\n\t\tcase FDT_NOP:\n\t\t\tinclude = want >= 2;\n\t\t\tstop_at = offset;\n\t\t\tbreak;\n\n\t\tcase FDT_BEGIN_NODE:\n\t\t\tdepth++;\n\t\t\tif (depth == FDT_MAX_DEPTH)\n\t\t\t\treturn -FDT_ERR_BADSTRUCTURE;\n\t\t\tname = fdt_get_name(fdt, offset, &len);\n\n\t\t\t/* The root node must have an empty name */\n\t\t\tif (!depth && *name)\n\t\t\t\treturn -FDT_ERR_BADLAYOUT;\n\t\t\tif (end - path + 2 + len >= path_len)\n\t\t\t\treturn -FDT_ERR_NOSPACE;\n\t\t\tif (end != path + 1)\n\t\t\t\t*end++ = '/';\n\t\t\tstrcpy(end, name);\n\t\t\tend += len;\n\t\t\tstack[depth] = want;\n\t\t\tif (want == 1)\n\t\t\t\tstop_at = offset;\n\t\t\tif (str_in_list(path, inc, inc_count))\n\t\t\t\twant = 2;\n\t\t\telse if (want)\n\t\t\t\twant--;\n\t\t\telse\n\t\t\t\tstop_at = offset;\n\t\t\tinclude = want;\n\t\t\tbreak;\n\n\t\tcase FDT_END_NODE:\n\t\t\t/* Depth must never go below -1 */\n\t\t\tif (depth < 0)\n\t\t\t\treturn -FDT_ERR_BADSTRUCTURE;\n\t\t\tinclude = want;\n\t\t\twant = stack[depth--];\n\t\t\twhile (end > path && *--end != '/')\n\t\t\t\t;\n\t\t\t*end = '\\0';\n\t\t\tif (depth == -1)\n\t\t\t\texpect_end = true;\n\t\t\tbreak;\n\n\t\tcase FDT_END:\n\t\t\tinclude = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (include && start == -1) {\n\t\t\t/* Should we merge with previous? */\n\t\t\tif (count && count <= max_regions &&\n\t\t\t    offset == region[count - 1].offset +\n\t\t\t\t\tregion[count - 1].size - base)\n\t\t\t\tstart = region[--count].offset - base;\n\t\t\telse\n\t\t\t\tstart = offset;\n\t\t}\n\n\t\tif (!include && start != -1) {\n\t\t\tif (count < max_regions) {\n\t\t\t\tregion[count].offset = base + start;\n\t\t\t\tregion[count].size = stop_at - start;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tstart = -1;\n\t\t}\n\t} while (tag != FDT_END);\n\n\tif (nextoffset != fdt_size_dt_struct(fdt))\n\t\treturn -FDT_ERR_BADLAYOUT;\n\n\t/* Add a region for the END tag and the string table */\n\tif (count < max_regions) {\n\t\tregion[count].offset = base + start;\n\t\tregion[count].size = nextoffset - start;\n\t\tif (add_string_tab)\n\t\t\tregion[count].size += fdt_size_dt_strings(fdt);\n\t}\n\tcount++;\n\n\treturn count;\n}", "target": 2, "idx": 11226}
{"commit_id": "ff82911cd3f69f028f2537825c9720ff78bc3f19", "project": "qemu", "func": "static void nbd_recv_coroutines_enter_all(BlockDriverState *bs)\n{\n    NBDClientSession *s = nbd_get_client_session(bs);\n    int i;\n\n    for (i = 0; i < MAX_NBD_REQUESTS; i++) {\n        if (s->recv_coroutine[i]) {\n            qemu_coroutine_enter(s->recv_coroutine[i]);\n        }\n    }\n    BDRV_POLL_WHILE(bs, s->read_reply_co);\n}", "target": 1, "idx": 11227}
{"commit_id": "cfa94cbf10302bedc779703f874ee2e8387a0721", "project": "mz-automation/libiec61850", "func": "static int\nparseNormalModeParameters(IsoPresentation* self, uint8_t* buffer, int totalLength, int bufPos)\n{\n    int endPos = bufPos + totalLength;\n\n    self->calledPresentationSelector.size = 0;\n    self->callingPresentationSelector.size = 0;\n\n    bool hasUserData = false;\n\n    while (bufPos < endPos) {\n        uint8_t tag = buffer[bufPos++];\n        int len;\n\n        if (bufPos == endPos) {\n            if (DEBUG_PRES)\n                printf(\"PRES: invalid message\\n\");\n            return -1;\n        }\n\n        bufPos = BerDecoder_decodeLength(buffer, &len, bufPos, endPos);\n\n        if (bufPos < 0) {\n            if (DEBUG_PRES)\n                printf(\"PRES: wrong parameter length\\n\");\n            return -1;\n        }\n\n        switch (tag) {\n        case 0x81: /* calling-presentation-selector */\n\n            if (len > 16) {\n                if (DEBUG_PRES)\n                    printf(\"PRES: calling-presentation-sel too large\\n\");\n            }\n            else {\n                self->callingPresentationSelector.size = len;\n                int i;\n                for (i = 0; i < len; i++)\n                    self->callingPresentationSelector.value[i] = buffer[bufPos + i];\n            }\n\n            bufPos += len;\n            break;\n\n        case 0x82: /* called-presentation-selector */\n\n            if (len > 16) {\n                if (DEBUG_PRES)\n                    printf(\"PRES: called-presentation-sel too large\\n\");\n            }\n            else {\n                self->calledPresentationSelector.size = len;\n                int i;\n                for (i = 0; i < len; i++)\n                    self->calledPresentationSelector.value[i] = buffer[bufPos + i];\n            }\n\n            bufPos += len;\n            break;\n\n        case 0x83: /* responding-presentation-selector */\n\n            if (len > 16) {\n                if (DEBUG_PRES)\n                    printf(\"PRES: responding-presentation-sel too large\\n\");\n            }\n\n            bufPos += len;\n            break;\n\n        case 0xa4: /* presentation-context-definition list */\n            if (DEBUG_PRES)\n                printf(\"PRES: pcd list\\n\");\n            bufPos = parsePresentationContextDefinitionList(self, buffer, len, bufPos);\n\n            if (bufPos < 0)\n                return -1;\n\n            break;\n\n        case 0xa5: /* context-definition-result-list */\n\n            bufPos += len;\n            break;\n\n        case 0x61: /* user data */\n            if (DEBUG_PRES)\n                printf(\"PRES: user-data\\n\");\n\n            bufPos = parseFullyEncodedData(self, buffer, len, bufPos);\n\n            if (bufPos < 0)\n                return -1;\n\n            if (self->nextPayload.size > 0)\n                hasUserData = true;\n\n            break;\n\n        case 0x00: /* indefinite length end tag -> ignore */\n            break;\n\n        default:\n            if (DEBUG_PRES)\n                printf(\"PRES: unknown tag in normal-mode\\n\");\n            bufPos += len;\n            break;\n        }\n    }\n\n    if (hasUserData == false) {\n        if (DEBUG_PRES)\n            printf(\"PRES: user-data is missing\\n\");\n\n        return -1;\n    }\n\n    return bufPos;\n}", "target": 2, "idx": 11228}
{"commit_id": "bc4812d31a67d5e2f973fbfaf950d6118226cf36", "project": "pjsip/pjproject", "func": "static pj_status_t decode_uint_attr(pj_pool_t *pool, \n                                    const pj_uint8_t *buf, \n                                    const pj_stun_msg_hdr *msghdr, \n                                    void **p_attr)\n{\n    pj_stun_uint_attr *attr;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_uint_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    /* Check that the attribute length is valid */\n    if (attr->hdr.length != 4)\n        return PJNATH_ESTUNINATTRLEN;\n\n    attr->value = GETVAL32H(buf, 4);\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}", "target": 1, "idx": 11229}
{"commit_id": "12db8078ba17a8ffc5cc2429fb506988f0f11b44", "project": "jasper-software/jasper", "func": "static int ras_putdatastd(jas_stream_t *out, ras_hdr_t *hdr, jas_image_t *image,  int numcmpts, int *cmpts)\n{\n\tint rowsize;\n\tint pad;\n\tunsigned int z;\n\tint nz;\n\tint c;\n\tint x;\n\tint y;\n\tint v;\n\tjas_matrix_t *data[3];\n\tint i;\n\n\tassert(numcmpts <= 3);\n\n\tif (RAS_ISRGB(hdr) && numcmpts < 3) {\n\t\t/* need 3 components for RGB */\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < 3; ++i) {\n\t\tdata[i] = 0;\n\t}\n\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tif (!(data[i] = jas_matrix_create(jas_image_height(image),\n\t\t  jas_image_width(image)))) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\trowsize = RAS_ROWSIZE(hdr);\n\tpad = rowsize - (hdr->width * hdr->depth + 7) / 8;\n\n\thdr->length = hdr->height * rowsize;\n\n\tfor (y = 0; y < hdr->height; y++) {\n\t\tfor (i = 0; i < numcmpts; ++i) {\n\t\t\tif (jas_image_readcmpt(image, cmpts[i], 0, y,\n\t\t\t\t\tjas_image_width(image), 1, data[i])) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tz = 0;\n\t\tnz = 0;\n\t\tfor (x = 0; x < hdr->width; x++) {\n\t\t\tz <<= hdr->depth;\n\t\t\tif (RAS_ISRGB(hdr)) {\n\t\t\t\tv = RAS_RED((jas_matrix_getv(data[0], x))) |\n\t\t\t\t  RAS_GREEN((jas_matrix_getv(data[1], x))) |\n\t\t\t\t  RAS_BLUE((jas_matrix_getv(data[2], x)));\n\t\t\t} else {\n\t\t\t\tv = (jas_matrix_getv(data[0], x));\n\t\t\t}\n\t\t\tz |= v & RAS_ONES(hdr->depth);\n\t\t\tnz += hdr->depth;\n\t\t\twhile (nz >= 8) {\n\t\t\t\tc = (z >> (nz - 8)) & 0xff;\n\t\t\t\tif (jas_stream_putc(out, c) == EOF) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tnz -= 8;\n\t\t\t\tz &= RAS_ONES(nz);\n\t\t\t}\n\t\t}\n\t\tif (nz > 0) {\n\t\t\tc = (z >> (8 - nz)) & RAS_ONES(nz);\n\t\t\tif (jas_stream_putc(out, c) == EOF) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tif (pad % 2) {\n\t\t\tif (jas_stream_putc(out, 0) == EOF) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tjas_matrix_destroy(data[i]);\n\t\tdata[i] = 0;\n\t}\n\n\treturn 0;\n\nerror:\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tif (data[i]) {\n\t\t\tjas_matrix_destroy(data[i]);\n\t\t}\n\t}\n\treturn -1;\n}", "target": 1, "idx": 11230}
{"commit_id": "9c78a04df4e44ef6487eee99c4258397f4fdca55", "project": "libjpeg-turbo", "func": "METHODDEF(JDIMENSION)\nget_word_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading raw-word-format PPM files with any maxval */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    register unsigned int temp;\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    *ptr++ = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    *ptr++ = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    *ptr++ = rescale[temp];\n  }\n  return 1;\n}", "target": 1, "idx": 11231}
{"commit_id": "d0a7e85dfeb519951fb8a8d70f73f30d41cdd3d9", "project": "afichet/openexr-viewer", "func": "FramebufferModel::~FramebufferModel() {}", "target": 3, "idx": 11232}
{"commit_id": "8c62a08faf89663e5633dc5036cd8695c80f1075", "project": "vim", "func": "static void\nf_py3eval(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*str;\n    char_u\tbuf[NUMBUFLEN];\n\n    if (check_restricted() || check_secure())\n\treturn;\n\n    if (p_pyx == 0)\n\tp_pyx = 3;\n\n    str = tv_get_string_buf(&argvars[0], buf);\n    do_py3eval(str, rettv);\n}", "target": 1, "idx": 11233}
{"commit_id": "6113eac95a9df634fbc858be542c4a0456bfe7b9", "project": "eclipse/mosquitto", "func": "int handle__publish(struct mosquitto *context)\n{\n\tuint8_t dup;\n\tint rc = 0;\n\tint rc2;\n\tuint8_t header = context->in_packet.command;\n\tint res = 0;\n\tstruct mosquitto_msg_store *msg, *stored = NULL;\n\tstruct mosquitto_client_msg *cmsg_stored = NULL;\n\tsize_t len;\n\tuint16_t slen;\n\tchar *topic_mount;\n\tmosquitto_property *properties = NULL;\n\tmosquitto_property *p, *p_prev;\n\tmosquitto_property *msg_properties_last;\n\tuint32_t message_expiry_interval = 0;\n\tint topic_alias = -1;\n\tuint8_t reason_code = 0;\n\tuint16_t mid = 0;\n\n\tif(context->state != mosq_cs_active){\n\t\treturn MOSQ_ERR_PROTOCOL;\n\t}\n\n\tmsg = mosquitto__calloc(1, sizeof(struct mosquitto_msg_store));\n\tif(msg == NULL){\n\t\treturn MOSQ_ERR_NOMEM;\n\t}\n\n\tdup = (header & 0x08)>>3;\n\tmsg->qos = (header & 0x06)>>1;\n\tif(dup == 1 && msg->qos == 0){\n\t\tlog__printf(NULL, MOSQ_LOG_INFO,\n\t\t\t\t\"Invalid PUBLISH (QoS=0 and DUP=1) from %s, disconnecting.\", context->id);\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t}\n\tif(msg->qos == 3){\n\t\tlog__printf(NULL, MOSQ_LOG_INFO,\n\t\t\t\t\"Invalid QoS in PUBLISH from %s, disconnecting.\", context->id);\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t}\n\tif(msg->qos > context->max_qos){\n\t\tlog__printf(NULL, MOSQ_LOG_INFO,\n\t\t\t\t\"Too high QoS in PUBLISH from %s, disconnecting.\", context->id);\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_QOS_NOT_SUPPORTED;\n\t}\n\tmsg->retain = (header & 0x01);\n\n\tif(msg->retain && db.config->retain_available == false){\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_RETAIN_NOT_SUPPORTED;\n\t}\n\n\tif(packet__read_string(&context->in_packet, &msg->topic, &slen)){\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t}\n\tif(!slen && context->protocol != mosq_p_mqtt5){\n\t\t/* Invalid publish topic, disconnect client. */\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t}\n\n\tif(msg->qos > 0){\n\t\tif(packet__read_uint16(&context->in_packet, &mid)){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t\t}\n\t\tif(mid == 0){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn MOSQ_ERR_PROTOCOL;\n\t\t}\n\t\t/* It is important to have a separate copy of mid, because msg may be\n\t\t * freed before we want to send a PUBACK/PUBREC. */\n\t\tmsg->source_mid = mid;\n\t}\n\n\t/* Handle properties */\n\tif(context->protocol == mosq_p_mqtt5){\n\t\trc = property__read_all(CMD_PUBLISH, &context->in_packet, &properties);\n\t\tif(rc){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn rc;\n\t\t}\n\n\t\tp = properties;\n\t\tp_prev = NULL;\n\t\tmsg->properties = NULL;\n\t\tmsg_properties_last = NULL;\n\t\twhile(p){\n\t\t\tswitch(p->identifier){\n\t\t\t\tcase MQTT_PROP_CONTENT_TYPE:\n\t\t\t\tcase MQTT_PROP_CORRELATION_DATA:\n\t\t\t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n\t\t\t\tcase MQTT_PROP_RESPONSE_TOPIC:\n\t\t\t\tcase MQTT_PROP_USER_PROPERTY:\n\t\t\t\t\tif(msg->properties){\n\t\t\t\t\t\tmsg_properties_last->next = p;\n\t\t\t\t\t\tmsg_properties_last = p;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmsg->properties = p;\n\t\t\t\t\t\tmsg_properties_last = p;\n\t\t\t\t\t}\n\t\t\t\t\tif(p_prev){\n\t\t\t\t\t\tp_prev->next = p->next;\n\t\t\t\t\t\tp = p_prev->next;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tproperties = p->next;\n\t\t\t\t\t\tp = properties;\n\t\t\t\t\t}\n\t\t\t\t\tmsg_properties_last->next = NULL;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MQTT_PROP_TOPIC_ALIAS:\n\t\t\t\t\ttopic_alias = p->value.i16;\n\t\t\t\t\tp_prev = p;\n\t\t\t\t\tp = p->next;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n\t\t\t\t\tmessage_expiry_interval = p->value.i32;\n\t\t\t\t\tp_prev = p;\n\t\t\t\t\tp = p->next;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n\t\t\t\t\tp_prev = p;\n\t\t\t\t\tp = p->next;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tp = p->next;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tmosquitto_property_free_all(&properties);\n\n\tif(topic_alias == 0 || (context->listener && topic_alias > context->listener->max_topic_alias)){\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_TOPIC_ALIAS_INVALID;\n\t}else if(topic_alias > 0){\n\t\tif(msg->topic){\n\t\t\trc = alias__add(context, msg->topic, (uint16_t)topic_alias);\n\t\t\tif(rc){\n\t\t\t\tdb__msg_store_free(msg);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}else{\n\t\t\trc = alias__find(context, &msg->topic, (uint16_t)topic_alias);\n\t\t\tif(rc){\n\t\t\t\tdb__msg_store_free(msg);\n\t\t\t\treturn MOSQ_ERR_PROTOCOL;\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef WITH_BRIDGE\n\trc = bridge__remap_topic_in(context, &msg->topic);\n\tif(rc){\n\t\tdb__msg_store_free(msg);\n\t\treturn rc;\n\t}\n\n#endif\n\tif(mosquitto_pub_topic_check(msg->topic) != MOSQ_ERR_SUCCESS){\n\t\t/* Invalid publish topic, just swallow it. */\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t}\n\n\tmsg->payloadlen = context->in_packet.remaining_length - context->in_packet.pos;\n\tG_PUB_BYTES_RECEIVED_INC(msg->payloadlen);\n\tif(context->listener && context->listener->mount_point){\n\t\tlen = strlen(context->listener->mount_point) + strlen(msg->topic) + 1;\n\t\ttopic_mount = mosquitto__malloc(len+1);\n\t\tif(!topic_mount){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t}\n\t\tsnprintf(topic_mount, len, \"%s%s\", context->listener->mount_point, msg->topic);\n\t\ttopic_mount[len] = '\\0';\n\n\t\tmosquitto__free(msg->topic);\n\t\tmsg->topic = topic_mount;\n\t}\n\n\tif(msg->payloadlen){\n\t\tif(db.config->message_size_limit && msg->payloadlen > db.config->message_size_limit){\n\t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Dropped too large PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", context->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic, (long)msg->payloadlen);\n\t\t\treason_code = MQTT_RC_PACKET_TOO_LARGE;\n\t\t\tgoto process_bad_message;\n\t\t}\n\t\tmsg->payload = mosquitto__malloc(msg->payloadlen+1);\n\t\tif(msg->payload == NULL){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t}\n\t\t/* Ensure payload is always zero terminated, this is the reason for the extra byte above */\n\t\t((uint8_t *)msg->payload)[msg->payloadlen] = 0;\n\n\t\tif(packet__read_bytes(&context->in_packet, msg->payload, msg->payloadlen)){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t\t}\n\t}\n\n\t/* Check for topic access */\n\trc = mosquitto_acl_check(context, msg->topic, msg->payloadlen, msg->payload, msg->qos, msg->retain, MOSQ_ACL_WRITE);\n\tif(rc == MOSQ_ERR_ACL_DENIED){\n\t\tlog__printf(NULL, MOSQ_LOG_DEBUG,\n\t\t\t\t\"Denied PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\",\n\t\t\t\tcontext->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic,\n\t\t\t\t(long)msg->payloadlen);\n\t\treason_code = MQTT_RC_NOT_AUTHORIZED;\n\t\tgoto process_bad_message;\n\t}else if(rc != MOSQ_ERR_SUCCESS){\n\t\tdb__msg_store_free(msg);\n\t\treturn rc;\n\t}\n\n\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Received PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", context->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic, (long)msg->payloadlen);\n\n\tif(!strncmp(msg->topic, \"$CONTROL/\", 9)){\n#ifdef WITH_CONTROL\n\t\trc = control__process(context, msg);\n\t\tdb__msg_store_free(msg);\n\t\treturn rc;\n#else\n\t\treason_code = MQTT_RC_IMPLEMENTATION_SPECIFIC;\n\t\tgoto process_bad_message;\n#endif\n\t}\n\n\t{\n\t\trc = plugin__handle_message(context, msg);\n\t\tif(rc == MOSQ_ERR_ACL_DENIED){\n\t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG,\n\t\t\t\t\t\"Denied PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\",\n\t\t\t\t\tcontext->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic,\n\t\t\t\t\t(long)msg->payloadlen);\n\n\t\t\treason_code = MQTT_RC_NOT_AUTHORIZED;\n\t\t\tgoto process_bad_message;\n\t\t}else if(rc != MOSQ_ERR_SUCCESS){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tif(msg->qos > 0){\n\t\tdb__message_store_find(context, msg->source_mid, &cmsg_stored);\n\t}\n\n\tif(cmsg_stored && cmsg_stored->store && msg->source_mid != 0 &&\n\t\t\t(cmsg_stored->store->qos != msg->qos\n\t\t\t || cmsg_stored->store->payloadlen != msg->payloadlen\n\t\t\t || strcmp(cmsg_stored->store->topic, msg->topic)\n\t\t\t || memcmp(cmsg_stored->store->payload, msg->payload, msg->payloadlen) )){\n\n\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Reused message ID %u from %s detected. Clearing from storage.\", msg->source_mid, context->id);\n\t\tdb__message_remove_incoming(context, msg->source_mid);\n\t\tcmsg_stored = NULL;\n\t}\n\n\tif(!cmsg_stored){\n\t\tif(msg->qos == 0\n\t\t\t\t|| db__ready_for_flight(context, mosq_md_in, msg->qos)\n\t\t\t\t){\n\n\t\t\tdup = 0;\n\t\t\trc = db__message_store(context, msg, message_expiry_interval, 0, mosq_mo_client);\n\t\t\tif(rc) return rc;\n\t\t}else{\n\t\t\t/* Client isn't allowed any more incoming messages, so fail early */\n\t\t\treason_code = MQTT_RC_QUOTA_EXCEEDED;\n\t\t\tgoto process_bad_message;\n\t\t}\n\t\tstored = msg;\n\t\tmsg = NULL;\n\t\tdup = 0;\n\t}else{\n\t\tdb__msg_store_free(msg);\n\t\tmsg = NULL;\n\t\tstored = cmsg_stored->store;\n\t\tcmsg_stored->dup++;\n\t\tdup = cmsg_stored->dup;\n\t}\n\n\tswitch(stored->qos){\n\t\tcase 0:\n\t\t\trc2 = sub__messages_queue(context->id, stored->topic, stored->qos, stored->retain, &stored);\n\t\t\tif(rc2 > 0) rc = 1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tutil__decrement_receive_quota(context);\n\t\t\trc2 = sub__messages_queue(context->id, stored->topic, stored->qos, stored->retain, &stored);\n\t\t\t/* stored may now be free, so don't refer to it */\n\t\t\tif(rc2 == MOSQ_ERR_SUCCESS || context->protocol != mosq_p_mqtt5){\n\t\t\t\tif(send__puback(context, mid, 0, NULL)) rc = 1;\n\t\t\t}else if(rc2 == MOSQ_ERR_NO_SUBSCRIBERS){\n\t\t\t\tif(send__puback(context, mid, MQTT_RC_NO_MATCHING_SUBSCRIBERS, NULL)) rc = 1;\n\t\t\t}else{\n\t\t\t\trc = rc2;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif(dup == 0){\n\t\t\t\tres = db__message_insert(context, stored->source_mid, mosq_md_in, stored->qos, stored->retain, stored, NULL, false);\n\t\t\t}else{\n\t\t\t\tres = 0;\n\t\t\t}\n\n\t\t\t/* db__message_insert() returns 2 to indicate dropped message\n\t\t\t * due to queue. This isn't an error so don't disconnect them. */\n\t\t\t/* FIXME - this is no longer necessary due to failing early above */\n\t\t\tif(!res){\n\t\t\t\tif(dup == 0 || dup == 1){\n\t\t\t\t\trc2 = send__pubrec(context, stored->source_mid, 0, NULL);\n\t\t\t\t\tif(rc2) rc = rc2;\n\t\t\t\t}else{\n\t\t\t\t\treturn MOSQ_ERR_PROTOCOL;\n\t\t\t\t}\n\t\t\t}else if(res == 1){\n\t\t\t\trc = 1;\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\tdb__message_write_queued_in(context);\n\treturn rc;\nprocess_bad_message:\n\trc = 1;\n\tif(msg){\n\t\tswitch(msg->qos){\n\t\t\tcase 0:\n\t\t\t\trc = MOSQ_ERR_SUCCESS;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\trc = send__puback(context, msg->source_mid, reason_code, NULL);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\trc = send__pubrec(context, msg->source_mid, reason_code, NULL);\n\t\t\t\tbreak;\n\t\t}\n\t\tdb__msg_store_free(msg);\n\t}\n\tif(context->out_packet_count >= db.config->max_queued_messages){\n\t\trc = MQTT_RC_QUOTA_EXCEEDED;\n\t}\n\treturn rc;\n}", "target": 2, "idx": 11234}
{"commit_id": "96047e0e6166407c40cc19f4e94fb35cd7624391", "project": "gpac", "func": "GF_Err mpgviddmx_process(GF_Filter *filter)\n{\n\tGF_MPGVidDmxCtx *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck, *dst_pck;\n\tu64 byte_offset;\n\ts64 vosh_start = -1;\n\ts64 vosh_end = -1;\n\tGF_Err e;\n\tchar *data;\n\tu8 *start;\n\tu32 pck_size;\n\ts32 remain;\n\n\t//always reparse duration\n\tif (!ctx->duration.num)\n\t\tmpgviddmx_check_dur(filter, ctx);\n\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (!pck) {\n\t\tif (gf_filter_pid_is_eos(ctx->ipid)) {\n\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_TRUE);\n\t\t\tif (ctx->opid)\n\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\tctx->src_pck = NULL;\n\t\t\treturn GF_EOS;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\tdata = (char *) gf_filter_pck_get_data(pck, &pck_size);\n\tbyte_offset = gf_filter_pck_get_byte_offset(pck);\n\n\tstart = data;\n\tremain = pck_size;\n\n\t//input pid sets some timescale - we flushed pending data , update cts\n\tif (!ctx->resume_from && ctx->timescale) {\n\t\tu64 ts = gf_filter_pck_get_cts(pck);\n\t\tif (ts != GF_FILTER_NO_TS) {\n\t\t\tif (!ctx->cts || !ctx->recompute_cts)\n\t\t\t\tctx->cts = ts;\n\t\t}\n\t\tts = gf_filter_pck_get_dts(pck);\n\t\tif (ts != GF_FILTER_NO_TS) {\n\t\t\tif (!ctx->dts || !ctx->recompute_cts)\n\t\t\t\tctx->dts = ts;\n\n\t\t\tif (!ctx->prev_dts) ctx->prev_dts = ts;\n\t\t\telse if (ctx->prev_dts != ts) {\n\t\t\t\tu64 diff = ts;\n\t\t\t\tdiff -= ctx->prev_dts;\n\t\t\t\tif (!ctx->cur_fps.den) ctx->cur_fps.den = (u32) diff;\n\t\t\t\telse if (ctx->cur_fps.den > diff)\n\t\t\t\t\tctx->cur_fps.den = (u32) diff;\n\t\t\t}\n\t\t}\n\t\tgf_filter_pck_get_framing(pck, &ctx->input_is_au_start, &ctx->input_is_au_end);\n\t\t//this will force CTS recomput of each frame\n\t\tif (ctx->recompute_cts) ctx->input_is_au_start = GF_FALSE;\n\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\tctx->src_pck = pck;\n\t\tgf_filter_pck_ref_props(&ctx->src_pck);\n\t}\n\n\t//we stored some data to find the complete vosh, aggregate this packet with current one\n\tif (!ctx->resume_from && ctx->hdr_store_size) {\n\t\tif (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size) {\n\t\t\tctx->hdr_store_alloc = ctx->hdr_store_size + pck_size;\n\t\t\tctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);\n\t\t}\n\t\tmemcpy(ctx->hdr_store + ctx->hdr_store_size, data, sizeof(char)*pck_size);\n\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\tif (byte_offset >= ctx->hdr_store_size)\n\t\t\t\tbyte_offset -= ctx->hdr_store_size;\n\t\t\telse\n\t\t\t\tbyte_offset = GF_FILTER_NO_BO;\n\t\t}\n\t\tctx->hdr_store_size += pck_size;\n\t\tstart = data = ctx->hdr_store;\n\t\tremain = pck_size = ctx->hdr_store_size;\n\t}\n\n\tif (ctx->resume_from) {\n\t\tif (gf_filter_pid_would_block(ctx->opid))\n\t\t\treturn GF_OK;\n\n\t\t//resume from data copied internally\n\t\tif (ctx->hdr_store_size) {\n\t\t\tassert(ctx->resume_from <= ctx->hdr_store_size);\n\t\t\tstart = data = ctx->hdr_store + ctx->resume_from;\n\t\t\tremain = pck_size = ctx->hdr_store_size - ctx->resume_from;\n\t\t} else {\n\t\t\tassert(remain >= (s32) ctx->resume_from);\n\t\t\tstart += ctx->resume_from;\n\t\t\tremain -= ctx->resume_from;\n\t\t}\n\t\tctx->resume_from = 0;\n\t}\n\n\tif (!ctx->bs) {\n\t\tctx->bs = gf_bs_new(start, remain, GF_BITSTREAM_READ);\n\t} else {\n\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t}\n\tif (!ctx->vparser) {\n\t\tctx->vparser = gf_m4v_parser_bs_new(ctx->bs, ctx->is_mpg12);\n\t}\n\n\n\twhile (remain) {\n\t\tBool full_frame;\n\t\tu8 *pck_data;\n\t\ts32 current;\n\t\tu8 sc_type, forced_sc_type=0;\n\t\tBool sc_type_forced = GF_FALSE;\n\t\tBool skip_pck = GF_FALSE;\n\t\tu8 ftype;\n\t\tu32 tinc;\n\t\tu64 size=0;\n\t\tu64 fstart;\n\t\tBool is_coded;\n\t\tu32 bytes_from_store = 0;\n\t\tu32 hdr_offset = 0;\n\t\tBool copy_last_bytes = GF_FALSE;\n\n\t\t//not enough bytes to parse start code\n\t\tif (remain<5) {\n\t\t\tmemcpy(ctx->hdr_store, start, remain);\n\t\t\tctx->bytes_in_header = remain;\n\t\t\tbreak;\n\t\t}\n\t\tcurrent = -1;\n\n\t\t//we have some potential bytes of a start code in the store, copy some more bytes and check if valid start code.\n\t\t//if not, dispatch these bytes as continuation of the data\n\t\tif (ctx->bytes_in_header) {\n\n\t\t\tmemcpy(ctx->hdr_store + ctx->bytes_in_header, start, 8 - ctx->bytes_in_header);\n\t\t\tcurrent = mpgviddmx_next_start_code(ctx->hdr_store, 8);\n\n\t\t\t//no start code in stored buffer\n\t\t\tif ((current<0) || (current >= (s32) ctx->bytes_in_header) )  {\n\t\t\t\tif (ctx->opid) {\n\t\t\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->bytes_in_header, &pck_data);\n\t\t\t\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\t\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t\t\t\tgf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);\n\t\t\t\t\tgf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);\n\t\t\t\t\tmemcpy(pck_data, ctx->hdr_store, ctx->bytes_in_header);\n\t\t\t\t\tgf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);\n\n\t\t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset - ctx->bytes_in_header);\n\t\t\t\t\t}\n\n\t\t\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\t\t\t\t}\n\n\t\t\t\tif (current<0) current = -1;\n\t\t\t\telse current -= ctx->bytes_in_header;\n\t\t\t\tctx->bytes_in_header = 0;\n\t\t\t} else {\n\t\t\t\t//we have a valid start code, check which byte in our store or in the packet payload is the start code type\n\t\t\t\t//and remember its location to reinit the parser from there\n\t\t\t\thdr_offset = 4 - ctx->bytes_in_header + current;\n\t\t\t\t//bytes still to dispatch\n\t\t\t\tbytes_from_store = ctx->bytes_in_header;\n\t\t\t\tctx->bytes_in_header = 0;\n\t\t\t\tif (!hdr_offset) {\n\t\t\t\t\tforced_sc_type = ctx->hdr_store[current+3];\n\t\t\t\t} else {\n\t\t\t\t\tforced_sc_type = start[hdr_offset-1];\n\t\t\t\t}\n\t\t\t\tsc_type_forced = GF_TRUE;\n\t\t\t}\n\t\t}\n\t\t//no starcode in store, look for startcode in packet\n\t\tif (current == -1) {\n\t\t\t//locate next start code\n\t\t\tcurrent = mpgviddmx_next_start_code(start, remain);\n\t\t\t//no start code, dispatch the block\n\t\t\tif (current<0) {\n\t\t\t\tu8 b3, b2, b1;\n\t\t\t\tif (! ctx->frame_started) {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[MPGVid] no start code in block and no frame started, discarding data\\n\" ));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsize = remain;\n\t\t\t\tb3 = start[remain-3];\n\t\t\t\tb2 = start[remain-2];\n\t\t\t\tb1 = start[remain-1];\n\t\t\t\t//we may have a startcode at the end of the packet, store it and don't dispatch the last 3 bytes !\n\t\t\t\tif (!b1 || !b2 || !b3) {\n\t\t\t\t\tcopy_last_bytes = GF_TRUE;\n\t\t\t\t\tassert(size >= 3);\n\t\t\t\t\tsize -= 3;\n\t\t\t\t\tctx->bytes_in_header = 3;\n\t\t\t\t}\n\n\t\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data);\n\t\t\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t\t\tmemcpy(pck_data, start, (size_t) size);\n\t\t\t\tgf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);\n\t\t\t\tgf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);\n\t\t\t\tgf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);\n\n\t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset);\n\t\t\t\t}\n\n\t\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\t\t\t\tif (copy_last_bytes) {\n\t\t\t\t\tmemcpy(ctx->hdr_store, start+remain-3, 3);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tassert(current>=0);\n\n\t\t//if we are in the middle of parsing the vosh, skip over bytes remaining from previous obj not parsed\n\t\tif ((vosh_start>=0) && current) {\n\t\t\tassert(remain>=current);\n\t\t\tstart += current;\n\t\t\tremain -= current;\n\t\t\tcurrent = 0;\n\t\t}\n\t\t//also skip if no output pid\n\t\tif (!ctx->opid && current) {\n\t\t\tassert(remain>=current);\n\t\t\tstart += current;\n\t\t\tremain -= current;\n\t\t\tcurrent = 0;\n\t\t}\n\t\t//dispatch remaining bytes\n\t\tif (current>0) {\n\t\t\t//flush remaining\n\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, current, &pck_data);\n\t\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t\tgf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);\n\t\t\tgf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);\n\t\t\tgf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_TRUE);\n\t\t\t//bytes were partly in store, partly in packet\n\t\t\tif (bytes_from_store) {\n\t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset - bytes_from_store);\n\t\t\t\t}\n\t\t\t\tassert(bytes_from_store>=(u32) current);\n\t\t\t\tbytes_from_store -= current;\n\t\t\t\tmemcpy(pck_data, ctx->hdr_store, current);\n\t\t\t} else {\n\t\t\t\t//bytes were only in packet\n\t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset);\n\t\t\t\t}\n\t\t\t\tmemcpy(pck_data, start, current);\n\t\t\t\tassert(remain>=current);\n\t\t\t\tstart += current;\n\t\t\t\tremain -= current;\n\t\t\t\tcurrent = 0;\n\t\t\t}\n\t\t\tgf_filter_pck_set_carousel_version(dst_pck, 1);\n\n\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\t\t}\n\n\t\t//parse headers\n\n\t\t//we have a start code loaded, eg the data packet does not have a full start code at the beginning\n\t\tif (sc_type_forced) {\n\t\t\tgf_bs_reassign_buffer(ctx->bs, start + hdr_offset, remain - hdr_offset);\n\t\t\tsc_type = forced_sc_type;\n\t\t} else {\n\t\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t\t\tgf_bs_read_int(ctx->bs, 24);\n\t\t\tsc_type = gf_bs_read_int(ctx->bs, 8);\n\t\t}\n\n\t\tif (ctx->is_mpg12) {\n\t\t\tswitch (sc_type) {\n\t\t\tcase M2V_SEQ_START_CODE:\n\t\t\tcase M2V_EXT_START_CODE:\n\t\t\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t\t\t\te = gf_m4v_parse_config(ctx->vparser, &ctx->dsi);\n\t\t\t\t//not enough data, accumulate until we can parse the full header\n\t\t\t\tif (e==GF_EOS) {\n\t\t\t\t\tif (vosh_start<0) vosh_start = 0;\n\t\t\t\t\tif (data == ctx->hdr_store) {\n\t\t\t\t\t\tmemmove(ctx->hdr_store, start, remain);\n\t\t\t\t\t\tctx->hdr_store_size = remain;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {\n\t\t\t\t\t\t\tctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - vosh_start);\n\t\t\t\t\t\t\tctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );\n\t\t\t\t\t\tctx->hdr_store_size += pck_size - (u32) vosh_start;\n\t\t\t\t\t}\n\t\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t} else if (e != GF_OK) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MPGVid] Failed to parse VOS header: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\t} else {\n\t\t\t\t\tmpgviddmx_check_pid(filter, ctx, 0, NULL);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase M2V_PIC_START_CODE:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t} else {\n\t\t\tu8 PL;\n\t\t\tswitch (sc_type) {\n\t\t\tcase M4V_VOS_START_CODE:\n\t\t\t\tctx->dsi.VideoPL = (u8) gf_bs_read_u8(ctx->bs);\n\t\t\t\tvosh_start = start - (u8 *)data;\n\t\t\t\tskip_pck = GF_TRUE;\n\t\t\t\tassert(remain>=5);\n\t\t\t\tstart += 5;\n\t\t\t\tremain -= 5;\n\t\t\t\tbreak;\n\t\t\tcase M4V_VOL_START_CODE:\n\t\t\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t\t\t\tPL = ctx->dsi.VideoPL;\n\t\t\t\te = gf_m4v_parse_config(ctx->vparser, &ctx->dsi);\n\t\t\t\tctx->dsi.VideoPL = PL;\n\t\t\t\t//not enough data, accumulate until we can parse the full header\n\t\t\t\tif (e==GF_EOS) {\n\t\t\t\t\tif (vosh_start<0) vosh_start = 0;\n\t\t\t\t\tif (data == ctx->hdr_store) {\n\t\t\t\t\t\tmemmove(ctx->hdr_store, start, remain);\n\t\t\t\t\t\tctx->hdr_store_size = remain;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {\n\t\t\t\t\t\t\tctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - (u32) vosh_start);\n\t\t\t\t\t\t\tctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );\n\t\t\t\t\t\tctx->hdr_store_size += pck_size - (u32) vosh_start;\n\t\t\t\t\t}\n\t\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t} else if (e != GF_OK) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MPGVid] Failed to parse VOS header: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\t} else {\n\t\t\t\t\tu32 obj_size = (u32) gf_m4v_get_object_start(ctx->vparser);\n\t\t\t\t\tif (vosh_start<0) vosh_start = 0;\n\t\t\t\t\tvosh_end = start - (u8 *)data + obj_size;\n\t\t\t\t\tvosh_end -= vosh_start;\n\t\t\t\t\tmpgviddmx_check_pid(filter, ctx,(u32)  vosh_end, data+vosh_start);\n\t\t\t\t\tskip_pck = GF_TRUE;\n\t\t\t\t\tassert(remain>=(s32) obj_size);\n\t\t\t\t\tstart += obj_size;\n\t\t\t\t\tremain -= obj_size;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase M4V_VOP_START_CODE:\n\t\t\tcase M4V_GOV_START_CODE:\n\t\t\t\tbreak;\n\n\t\t\tcase M4V_VO_START_CODE:\n\t\t\tcase M4V_VISOBJ_START_CODE:\n\t\t\tdefault:\n\t\t\t\tif (vosh_start>=0) {\n\t\t\t\t\tskip_pck = GF_TRUE;\n\t\t\t\t\tassert(remain>=4);\n\t\t\t\t\tstart += 4;\n\t\t\t\t\tremain -= 4;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (skip_pck) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!ctx->opid) {\n\t\t\tassert(remain>=4);\n\t\t\tstart += 4;\n\t\t\tremain -= 4;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->resume_from = (u32) ((char *)start -  (char *)data);\n\t\t\treturn GF_OK;\n\t\t}\n\t\t//at this point, we no longer reaggregate packets\n\t\tctx->hdr_store_size = 0;\n\n\t\tif (ctx->in_seek) {\n\t\t\tu64 nb_frames_at_seek = (u64) (ctx->start_range * ctx->cur_fps.num);\n\t\t\tif (ctx->cts + ctx->cur_fps.den >= nb_frames_at_seek) {\n\t\t\t\t//u32 samples_to_discard = (ctx->cts + ctx->dts_inc) - nb_samples_at_seek;\n\t\t\t\tctx->in_seek = GF_FALSE;\n\t\t\t}\n\t\t}\n\t\t//may happen that after all our checks, only 4 bytes are left, continue to store these 4 bytes\n\t\tif (remain<5)\n\t\t\tcontinue;\n\n\t\t//good to go\n\t\tgf_m4v_parser_reset(ctx->vparser, sc_type_forced ? forced_sc_type + 1 : 0);\n\t\tsize = 0;\n\t\te = gf_m4v_parse_frame(ctx->vparser, &ctx->dsi, &ftype, &tinc, &size, &fstart, &is_coded);\n\t\t//true if we strip VO and VISOBJ assert(!fstart);\n\n\t\t//we skipped bytes already in store + end of start code present in packet, so the size of the first object\n\t\t//needs adjustement\n\t\tif (bytes_from_store) {\n\t\t\tsize += bytes_from_store + hdr_offset;\n\t\t}\n\n\t\tif ((e == GF_EOS) && !ctx->input_is_au_end) {\n\t\t\tu8 b3 = start[remain-3];\n\t\t\tu8 b2 = start[remain-2];\n\t\t\tu8 b1 = start[remain-1];\n\n\t\t\t//we may have a startcode at the end of the packet, store it and don't dispatch the last 3 bytes !\n\t\t\tif (!b1 || !b2 || !b3) {\n\t\t\t\tcopy_last_bytes = GF_TRUE;\n\t\t\t\tassert(size >= 3);\n\t\t\t\tsize -= 3;\n\t\t\t\tctx->bytes_in_header = 3;\n\t\t\t}\n\t\t\tfull_frame = GF_FALSE;\n\t\t} else {\n\t\t\tfull_frame = GF_TRUE;\n\t\t}\n\n\t\tif (!is_coded) {\n\t\t\t/*if prev is B and we're parsing a packed bitstream discard n-vop*/\n\t\t\tif (ctx->forced_packed && ctx->b_frames) {\n\t\t\t\tctx->is_packed = GF_TRUE;\n\t\t\t\tassert(remain>=size);\n\t\t\t\tstart += size;\n\t\t\t\tremain -= (s32) size;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*policy is to import at variable frame rate, skip*/\n\t\t\tif (ctx->vfr) {\n\t\t\t\tctx->is_vfr = GF_TRUE;\n\t\t\t\tmpgviddmx_update_time(ctx);\n\t\t\t\tassert(remain>=size);\n\t\t\t\tstart += size;\n\t\t\t\tremain -= (s32) size;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*policy is to keep non coded frame (constant frame rate), add*/\n\t\t}\n\n\t\tif (ftype==2) {\n\t\t\t//count number of B-frames since last ref\n\t\t\tctx->b_frames++;\n\t\t\tctx->nb_b++;\n\t\t} else {\n\t\t\t//flush all pending packets\n\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_FALSE);\n\t\t\t//remeber the CTS of the last ref\n\t\t\tctx->last_ref_cts = ctx->cts;\n\t\t\tif (ctx->max_b < ctx->b_frames) ctx->max_b = ctx->b_frames;\n\t\t\t\n\t\t\tctx->b_frames = 0;\n\t\t\tif (ftype)\n\t\t\t\tctx->nb_p++;\n\t\t\telse\n\t\t\t\tctx->nb_i++;\n\t\t}\n\t\tctx->nb_frames++;\n\n\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data);\n\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t//bytes come from both our store and the data packet\n\t\tif (bytes_from_store) {\n\t\t\tmemcpy(pck_data, ctx->hdr_store+current, bytes_from_store);\n\t\t\tassert(size >= bytes_from_store);\n\t\t\tsize -= bytes_from_store;\n\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset - bytes_from_store);\n\t\t\t}\n\t\t\tmemcpy(pck_data + bytes_from_store, start, (size_t) size);\n\t\t} else {\n\t\t\t//bytes only come the data packet\n\t\t\tmemcpy(pck_data, start, (size_t) size);\n\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset + start - (u8 *) data);\n\t\t\t}\n\t\t}\n\t\tassert(pck_data[0] == 0);\n\t\tassert(pck_data[1] == 0);\n\t\tassert(pck_data[2] == 0x01);\n\n\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, (full_frame || ctx->input_is_au_end) ? GF_TRUE : GF_FALSE);\n\t\tgf_filter_pck_set_cts(dst_pck, ctx->cts);\n\t\tgf_filter_pck_set_dts(dst_pck, ctx->dts);\n\t\tif (ctx->input_is_au_start) {\n\t\t\tctx->input_is_au_start = GF_FALSE;\n\t\t} else {\n\t\t\t//we use the carousel flag temporarly to indicate the cts must be recomputed\n\t\t\tgf_filter_pck_set_carousel_version(dst_pck, 1);\n\t\t}\n\t\tgf_filter_pck_set_sap(dst_pck, ftype ? GF_FILTER_SAP_NONE : GF_FILTER_SAP_1);\n\t\tgf_filter_pck_set_duration(dst_pck, ctx->cur_fps.den);\n\t\tif (ctx->in_seek) gf_filter_pck_set_seek_flag(dst_pck, GF_TRUE);\n\t\tctx->frame_started = GF_TRUE;\n\n\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\n\t\tmpgviddmx_update_time(ctx);\n\n\t\tif (!full_frame) {\n\t\t\tif (copy_last_bytes) {\n\t\t\t\tmemcpy(ctx->hdr_store, start+remain-3, 3);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tassert(remain>=size);\n\t\tstart += size;\n\t\tremain -= (s32) size;\n\t}\n\tgf_filter_pid_drop_packet(ctx->ipid);\n\n\treturn GF_OK;\n}", "target": 1, "idx": 11235}
{"commit_id": "f51fcd59a8bbeb60eaf8ae0e398556be2fa3317a", "project": "rsyslog/libfastjson", "func": "static int printbuf_extend(struct printbuf *p, int min_size)\n{\n\tchar *t;\n\tint new_size;\n\n\tif (p->size >= min_size)\n\t\treturn 0;\n\n\t/* Prevent signed integer overflows with large buffers. */\n\tif (min_size > INT_MAX - 8)\n\t\treturn -1;\n\tif (p->size > INT_MAX / 2)\n\t\tnew_size = min_size + 8;\n\telse {\n\t\tnew_size = p->size * 2;\n\t\tif (new_size < min_size + 8)\n\t\t\tnew_size = min_size + 8;\n\t}\n#ifdef PRINTBUF_DEBUG\n\tMC_DEBUG(\"printbuf_memappend: realloc \"\n\t  \"bpos=%d min_size=%d old_size=%d new_size=%d\\n\",\n\t  p->bpos, min_size, p->size, new_size);\n#endif /* PRINTBUF_DEBUG */\n\tif(!(t = (char*)realloc(p->buf, new_size)))\n\t\treturn -1;\n\tp->size = new_size;\n\tp->buf = t;\n\treturn 0;\n}", "target": 2, "idx": 11236}
{"commit_id": "3eb6764acd2d708f6873c177a77f9bef3b266fa9", "project": "libuv", "func": "static void uv__rwlock_fallback_destroy(uv_rwlock_t* rwlock) {\n  DeleteCriticalSection(&rwlock->fallback_.read_lock_.cs);\n  CloseHandle(rwlock->fallback_.write_lock_.sem);\n}", "target": 2, "idx": 11237}
{"commit_id": "35cd5ba367515ffbd274ca529c5e946447f4ba48", "project": "xen-project/xen", "func": "static int nvmx_handle_vmptrld(struct cpu_user_regs *regs)\n{\n    struct vcpu *v = current;\n    struct vmx_inst_decoded decode;\n    struct nestedvcpu *nvcpu = &vcpu_nestedhvm(v);\n    unsigned long gpa = 0;\n    int rc;\n\n    rc = decode_vmx_inst(regs, &decode, &gpa, 0);\n    if ( rc != X86EMUL_OKAY )\n        return rc;\n\n    if ( gpa == vcpu_2_nvmx(v).vmxon_region_pa || gpa & 0xfff )\n    {\n        vmfail_invalid(regs);\n        goto out;\n    }\n\n    if ( nvcpu->nv_vvmcxaddr != gpa )\n        nvmx_purge_vvmcs(v);\n\n    if ( nvcpu->nv_vvmcxaddr == INVALID_PADDR )\n    {\n        bool_t writable;\n        void *vvmcx = hvm_map_guest_frame_rw(paddr_to_pfn(gpa), 1, &writable);\n\n        if ( vvmcx )\n        {\n            if ( writable )\n            {\n                struct vmcs_struct *vvmcs = vvmcx;\n\n                if ( ((vvmcs->vmcs_revision_id ^ vmx_basic_msr) &\n                                         VMX_BASIC_REVISION_MASK) ||\n                     (!cpu_has_vmx_vmcs_shadowing &&\n                      (vvmcs->vmcs_revision_id & ~VMX_BASIC_REVISION_MASK)) )\n                {\n                    hvm_unmap_guest_frame(vvmcx, 1);\n                    vmfail(regs, VMX_INSN_VMPTRLD_INCORRECT_VMCS_ID);\n\n                    return X86EMUL_OKAY;\n                }\n                nvcpu->nv_vvmcx = vvmcx;\n                nvcpu->nv_vvmcxaddr = gpa;\n                v->arch.hvm.vmx.vmcs_shadow_maddr =\n                    mfn_to_maddr(domain_page_map_to_mfn(vvmcx));\n            }\n            else\n            {\n                hvm_unmap_guest_frame(vvmcx, 1);\n                vvmcx = NULL;\n            }\n        }\n        if ( !vvmcx ||\n             !map_io_bitmap_all(v) ||\n             !_map_msr_bitmap(v) )\n        {\n            vmfail_valid(regs, VMX_INSN_VMPTRLD_INVALID_PHYADDR);\n            goto out;\n        }\n    }\n\n    if ( cpu_has_vmx_vmcs_shadowing )\n        nvmx_set_vmcs_pointer(v, nvcpu->nv_vvmcx);\n\n    vmsucceed(regs);\n\nout:\n    return X86EMUL_OKAY;\n}", "target": 2, "idx": 11238}
{"commit_id": "1c88bbd728da6bff8f4533bcfdb0dfef4ed8038b", "project": "wernsey/bitmap", "func": "int bm_height(Bitmap *b) {\n\tassert(b);\n    return b->h;\n}", "target": 2, "idx": 11239}
{"commit_id": "26c8b29ee12f20cf63866b87b9a3c41fab9153c5", "project": "GNOME/glib", "func": "GSettingsBackend *\ng_keyfile_settings_backend_new (const gchar *filename,\n                                const gchar *root_path,\n                                const gchar *root_group)\n{\n  g_return_val_if_fail (filename != NULL, NULL);\n  g_return_val_if_fail (root_path != NULL, NULL);\n  g_return_val_if_fail (g_str_has_prefix (root_path, \"/\"), NULL);\n  g_return_val_if_fail (g_str_has_suffix (root_path, \"/\"), NULL);\n  g_return_val_if_fail (strstr (root_path, \"//\") == NULL, NULL);\n\n  return G_SETTINGS_BACKEND (g_object_new (G_TYPE_KEYFILE_SETTINGS_BACKEND,\n                                           \"filename\", filename,\n                                           \"root-path\", root_path,\n                                           \"root-group\", root_group,\n                                           NULL));\n}", "target": 2, "idx": 11240}
{"commit_id": "9c87439d9afa14a365ff13e73adc809cb2c3d97b", "project": "sparklemotion/nokogiri", "func": "static VALUE read_memory(int argc, VALUE *argv, VALUE klass)\n{\n  VALUE content;\n  VALUE parse_options;\n  xmlRelaxNGParserCtxtPtr ctx;\n  xmlRelaxNGPtr schema;\n  VALUE errors;\n  VALUE rb_schema;\n  int scanned_args = 0;\n\n  scanned_args = rb_scan_args(argc, argv, \"11\", &content, &parse_options);\n  if (scanned_args == 1) {\n    parse_options = rb_const_get(rb_const_get(mNokogiriXml, rb_intern(\"ParseOptions\")), rb_intern(\"DEFAULT_SCHEMA\"));\n  }\n\n  ctx = xmlRelaxNGNewMemParserCtxt((const char *)StringValuePtr(content), (int)RSTRING_LEN(content));\n\n  errors = rb_ary_new();\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n\n#ifdef HAVE_XMLRELAXNGSETPARSERSTRUCTUREDERRORS\n  xmlRelaxNGSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n\n  schema = xmlRelaxNGParse(ctx);\n\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlRelaxNGFreeParserCtxt(ctx);\n\n  if(NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if(error)\n      Nokogiri_error_raise(NULL, error);\n    else\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n\n    return Qnil;\n  }\n\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n  rb_iv_set(rb_schema, \"@parse_options\", parse_options);\n\n  return rb_schema;\n}", "target": 0, "idx": 11241}
{"commit_id": "dd88504804e186029f845a166dc5c31695e2cca2", "project": "projectacrn/acrn-hypervisor", "func": "static void\nvirtio_hyper_dmabuf_deinit(struct vmctx *ctx, struct pci_vdev *dev, char *opts)\n{\n\tif (kstatus == VIRTIO_DEV_STARTED) {\n\t\tDPRINTF(\"virtio_hyper_dmabuf: deinitializing\\n\");\n\t\tvirtio_hyper_dmabuf_k_stop();\n\t\tvirtio_hyper_dmabuf_k_reset();\n\t\tkstatus = VIRTIO_DEV_INITIAL;\n\t\tif (vbs_k_hyper_dmabuf_fd >= 0) {\n\t\t\tclose(vbs_k_hyper_dmabuf_fd);\n\t\t}\n\t\tvbs_k_hyper_dmabuf_fd = -1;\n\t}\n\n\tif (dev->arg) {\n\t\tvirtio_hyper_dmabuf_reset(dev->arg);\n\t\tfree((struct virtio_hyper_dmabuf *)dev->arg);\n\t}\n}", "target": 2, "idx": 11242}
{"commit_id": "612e309bfffd6f9b8ad7cdccda3019fc0865f3b4", "project": "OpenIDC/mod_auth_openidc", "func": "int oidc_handle_redirect_uri_request(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\n\tif (oidc_proto_is_redirect_authorization_response(r, c)) {\n\n\t\t/* this is an authorization response from the OP using the Basic Client profile or a Hybrid flow*/\n\t\treturn oidc_handle_redirect_authorization_response(r, c, session);\n\n\t} else if (oidc_proto_is_post_authorization_response(r, c)) {\n\n\t\t/* this is an authorization response using the fragment(+POST) response_mode with the Implicit Client profile */\n\t\treturn oidc_handle_post_authorization_response(r, c, session);\n\n\t} else if (oidc_is_discovery_response(r, c)) {\n\n\t\t/* this is response from the OP discovery page */\n\t\treturn oidc_handle_discovery_response(r, c);\n\n\t} else if (oidc_util_request_has_parameter(r, \"logout\")) {\n\n\t\t/* handle logout */\n\t\treturn oidc_handle_logout(r, c, session);\n\n\t} else if (oidc_util_request_has_parameter(r, \"jwks\")) {\n\n\t\t/* handle JWKs request */\n\t\treturn oidc_handle_jwks(r, c);\n\n\t} else if (oidc_util_request_has_parameter(r, \"session\")) {\n\n\t\t/* handle session management request */\n\t\treturn oidc_handle_session_management(r, c, session);\n\n\t} else if (oidc_util_request_has_parameter(r, \"refresh\")) {\n\n\t\t/* handle refresh token request */\n\t\treturn oidc_handle_refresh_token_request(r, c, session);\n\n\t} else if (oidc_util_request_has_parameter(r, \"request_uri\")) {\n\n\t\t/* handle request object by reference request */\n\t\treturn oidc_handle_request_uri(r, c);\n\n\t} else if (oidc_util_request_has_parameter(r, \"remove_at_cache\")) {\n\n\t\t/* handle request to invalidate access token cache */\n\t\treturn oidc_handle_remove_at_cache(r, c);\n\n\t} else if ((r->args == NULL) || (apr_strnatcmp(r->args, \"\") == 0)) {\n\n\t\t/* this is a \"bare\" request to the redirect URI, indicating implicit flow using the fragment response_mode */\n\t\treturn oidc_proto_javascript_implicit(r, c);\n\t}\n\n\t/* this is not an authorization response or logout request */\n\n\t/* check for \"error\" response */\n\tif (oidc_util_request_has_parameter(r, \"error\")) {\n\n//\t\tchar *error = NULL, *descr = NULL;\n//\t\toidc_util_get_request_parameter(r, \"error\", &error);\n//\t\toidc_util_get_request_parameter(r, \"error_description\", &descr);\n//\n//\t\t/* send user facing error to browser */\n//\t\treturn oidc_util_html_send_error(r, error, descr, DONE);\n\t\toidc_handle_redirect_authorization_response(r, c, session);\n\t}\n\n\t/* something went wrong */\n\treturn oidc_util_html_send_error(r, c->error_template, \"Invalid Request\",\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"The OpenID Connect callback URL received an invalid request\"),\n\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n}", "target": 2, "idx": 11243}
{"commit_id": "2d6a0e9de03ee658a9adc3bfb2f0ca55dff1e478", "project": "torvalds/linux", "func": "static int catc_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct device *dev = &intf->dev;\n\tstruct usb_device *usbdev = interface_to_usbdev(intf);\n\tstruct net_device *netdev;\n\tstruct catc *catc;\n\tu8 broadcast[ETH_ALEN];\n\tint pktsz, ret;\n\n\tif (usb_set_interface(usbdev,\n\t\t\tintf->altsetting->desc.bInterfaceNumber, 1)) {\n\t\tdev_err(dev, \"Can't set altsetting 1.\\n\");\n\t\treturn -EIO;\n\t}\n\n\tnetdev = alloc_etherdev(sizeof(struct catc));\n\tif (!netdev)\n\t\treturn -ENOMEM;\n\n\tcatc = netdev_priv(netdev);\n\n\tnetdev->netdev_ops = &catc_netdev_ops;\n\tnetdev->watchdog_timeo = TX_TIMEOUT;\n\tnetdev->ethtool_ops = &ops;\n\n\tcatc->usbdev = usbdev;\n\tcatc->netdev = netdev;\n\n\tspin_lock_init(&catc->tx_lock);\n\tspin_lock_init(&catc->ctrl_lock);\n\n\tinit_timer(&catc->timer);\n\tcatc->timer.data = (long) catc;\n\tcatc->timer.function = catc_stats_timer;\n\n\tcatc->ctrl_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tcatc->tx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tcatc->rx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tcatc->irq_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif ((!catc->ctrl_urb) || (!catc->tx_urb) || \n\t    (!catc->rx_urb) || (!catc->irq_urb)) {\n\t\tdev_err(&intf->dev, \"No free urbs available.\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto fail_free;\n\t}\n\n\t/* The F5U011 has the same vendor/product as the netmate but a device version of 0x130 */\n\tif (le16_to_cpu(usbdev->descriptor.idVendor) == 0x0423 && \n\t    le16_to_cpu(usbdev->descriptor.idProduct) == 0xa &&\n\t    le16_to_cpu(catc->usbdev->descriptor.bcdDevice) == 0x0130) {\n\t\tdev_dbg(dev, \"Testing for f5u011\\n\");\n\t\tcatc->is_f5u011 = 1;\t\t\n\t\tatomic_set(&catc->recq_sz, 0);\n\t\tpktsz = RX_PKT_SZ;\n\t} else {\n\t\tpktsz = RX_MAX_BURST * (PKT_SZ + 2);\n\t}\n\t\n\tusb_fill_control_urb(catc->ctrl_urb, usbdev, usb_sndctrlpipe(usbdev, 0),\n\t\tNULL, NULL, 0, catc_ctrl_done, catc);\n\n\tusb_fill_bulk_urb(catc->tx_urb, usbdev, usb_sndbulkpipe(usbdev, 1),\n\t\tNULL, 0, catc_tx_done, catc);\n\n\tusb_fill_bulk_urb(catc->rx_urb, usbdev, usb_rcvbulkpipe(usbdev, 1),\n\t\tcatc->rx_buf, pktsz, catc_rx_done, catc);\n\n\tusb_fill_int_urb(catc->irq_urb, usbdev, usb_rcvintpipe(usbdev, 2),\n                catc->irq_buf, 2, catc_irq_done, catc, 1);\n\n\tif (!catc->is_f5u011) {\n\t\tu32 *buf;\n\t\tint i;\n\n\t\tdev_dbg(dev, \"Checking memory size\\n\");\n\n\t\tbuf = kmalloc(4, GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail_free;\n\t\t}\n\n\t\t*buf = 0x12345678;\n\t\tcatc_write_mem(catc, 0x7a80, buf, 4);\n\t\t*buf = 0x87654321;\n\t\tcatc_write_mem(catc, 0xfa80, buf, 4);\n\t\tcatc_read_mem(catc, 0x7a80, buf, 4);\n\t  \n\t\tswitch (*buf) {\n\t\tcase 0x12345678:\n\t\t\tcatc_set_reg(catc, TxBufCount, 8);\n\t\t\tcatc_set_reg(catc, RxBufCount, 32);\n\t\t\tdev_dbg(dev, \"64k Memory\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(&intf->dev,\n\t\t\t\t \"Couldn't detect memory size, assuming 32k\\n\");\n\t\tcase 0x87654321:\n\t\t\tcatc_set_reg(catc, TxBufCount, 4);\n\t\t\tcatc_set_reg(catc, RxBufCount, 16);\n\t\t\tdev_dbg(dev, \"32k Memory\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tkfree(buf);\n\t  \n\t\tdev_dbg(dev, \"Getting MAC from SEEROM.\\n\");\n\t  \n\t\tcatc_get_mac(catc, netdev->dev_addr);\n\t\t\n\t\tdev_dbg(dev, \"Setting MAC into registers.\\n\");\n\t  \n\t\tfor (i = 0; i < 6; i++)\n\t\t\tcatc_set_reg(catc, StationAddr0 - i, netdev->dev_addr[i]);\n\t\t\n\t\tdev_dbg(dev, \"Filling the multicast list.\\n\");\n\t  \n\t\teth_broadcast_addr(broadcast);\n\t\tcatc_multicast(broadcast, catc->multicast);\n\t\tcatc_multicast(netdev->dev_addr, catc->multicast);\n\t\tcatc_write_mem(catc, 0xfa80, catc->multicast, 64);\n\t\t\n\t\tdev_dbg(dev, \"Clearing error counters.\\n\");\n\t\t\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tcatc_set_reg(catc, EthStats + i, 0);\n\t\tcatc->last_stats = jiffies;\n\t\t\n\t\tdev_dbg(dev, \"Enabling.\\n\");\n\t\t\n\t\tcatc_set_reg(catc, MaxBurst, RX_MAX_BURST);\n\t\tcatc_set_reg(catc, OpModes, OpTxMerge | OpRxMerge | OpLenInclude | Op3MemWaits);\n\t\tcatc_set_reg(catc, LEDCtrl, LEDLink);\n\t\tcatc_set_reg(catc, RxUnit, RxEnable | RxPolarity | RxMultiCast);\n\t} else {\n\t\tdev_dbg(dev, \"Performing reset\\n\");\n\t\tcatc_reset(catc);\n\t\tcatc_get_mac(catc, netdev->dev_addr);\n\t\t\n\t\tdev_dbg(dev, \"Setting RX Mode\\n\");\n\t\tcatc->rxmode[0] = RxEnable | RxPolarity | RxMultiCast;\n\t\tcatc->rxmode[1] = 0;\n\t\tf5u011_rxmode(catc, catc->rxmode);\n\t}\n\tdev_dbg(dev, \"Init done.\\n\");\n\tprintk(KERN_INFO \"%s: %s USB Ethernet at usb-%s-%s, %pM.\\n\",\n\t       netdev->name, (catc->is_f5u011) ? \"Belkin F5U011\" : \"CATC EL1210A NetMate\",\n\t       usbdev->bus->bus_name, usbdev->devpath, netdev->dev_addr);\n\tusb_set_intfdata(intf, catc);\n\n\tSET_NETDEV_DEV(netdev, &intf->dev);\n\tret = register_netdev(netdev);\n\tif (ret)\n\t\tgoto fail_clear_intfdata;\n\n\treturn 0;\n\nfail_clear_intfdata:\n\tusb_set_intfdata(intf, NULL);\nfail_free:\n\tusb_free_urb(catc->ctrl_urb);\n\tusb_free_urb(catc->tx_urb);\n\tusb_free_urb(catc->rx_urb);\n\tusb_free_urb(catc->irq_urb);\n\tfree_netdev(netdev);\n\treturn ret;\n}", "target": 2, "idx": 11244}
{"commit_id": "b62dc5e7825bc195efe3041d5b3a9f1528359e1c", "project": "vim", "func": "int\nbuflist_findpat(\n    char_u\t*pattern,\n    char_u\t*pattern_end,\t// pointer to first char after pattern\n    int\t\tunlisted,\t// find unlisted buffers\n    int\t\tdiffmode UNUSED, // find diff-mode buffers only\n    int\t\tcurtab_only)\t// find buffers in current tab only\n{\n    buf_T\t*buf;\n    int\t\tmatch = -1;\n    int\t\tfind_listed;\n    char_u\t*pat;\n    char_u\t*patend;\n    int\t\tattempt;\n    char_u\t*p;\n    int\t\ttoggledollar;\n\n    // \"%\" is current file, \"%%\" or \"#\" is alternate file\n    if ((pattern_end == pattern + 1 && (*pattern == '%' || *pattern == '#'))\n\t    || (in_vim9script() && pattern_end == pattern + 2\n\t\t\t\t    && pattern[0] == '%' && pattern[1] == '%'))\n    {\n\tif (*pattern == '#' || pattern_end == pattern + 2)\n\t    match = curwin->w_alt_fnum;\n\telse\n\t    match = curbuf->b_fnum;\n#ifdef FEAT_DIFF\n\tif (diffmode && !diff_mode_buf(buflist_findnr(match)))\n\t    match = -1;\n#endif\n    }\n\n    /*\n     * Try four ways of matching a listed buffer:\n     * attempt == 0: without '^' or '$' (at any position)\n     * attempt == 1: with '^' at start (only at position 0)\n     * attempt == 2: with '$' at end (only match at end)\n     * attempt == 3: with '^' at start and '$' at end (only full match)\n     * Repeat this for finding an unlisted buffer if there was no matching\n     * listed buffer.\n     */\n    else\n    {\n\tpat = file_pat_to_reg_pat(pattern, pattern_end, NULL, FALSE);\n\tif (pat == NULL)\n\t    return -1;\n\tpatend = pat + STRLEN(pat) - 1;\n\ttoggledollar = (patend > pat && *patend == '$');\n\n\t// First try finding a listed buffer.  If not found and \"unlisted\"\n\t// is TRUE, try finding an unlisted buffer.\n\tfind_listed = TRUE;\n\tfor (;;)\n\t{\n\t    for (attempt = 0; attempt <= 3; ++attempt)\n\t    {\n\t\tregmatch_T\tregmatch;\n\n\t\t// may add '^' and '$'\n\t\tif (toggledollar)\n\t\t    *patend = (attempt < 2) ? NUL : '$'; // add/remove '$'\n\t\tp = pat;\n\t\tif (*p == '^' && !(attempt & 1))\t // add/remove '^'\n\t\t    ++p;\n\t\tregmatch.regprog = vim_regcomp(p, magic_isset() ? RE_MAGIC : 0);\n\n\t\tFOR_ALL_BUFS_FROM_LAST(buf)\n\t\t{\n\t\t    if (regmatch.regprog == NULL)\n\t\t    {\n\t\t\t// invalid pattern, possibly after switching engine\n\t\t\tvim_free(pat);\n\t\t\treturn -1;\n\t\t    }\n\t\t    if (buf->b_p_bl == find_listed\n#ifdef FEAT_DIFF\n\t\t\t    && (!diffmode || diff_mode_buf(buf))\n#endif\n\t\t\t    && buflist_match(&regmatch, buf, FALSE) != NULL)\n\t\t    {\n\t\t\tif (curtab_only)\n\t\t\t{\n\t\t\t    // Ignore the match if the buffer is not open in\n\t\t\t    // the current tab.\n\t\t\t    win_T\t*wp;\n\n\t\t\t    FOR_ALL_WINDOWS(wp)\n\t\t\t\tif (wp->w_buffer == buf)\n\t\t\t\t    break;\n\t\t\t    if (wp == NULL)\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (match >= 0)\t\t// already found a match\n\t\t\t{\n\t\t\t    match = -2;\n\t\t\t    break;\n\t\t\t}\n\t\t\tmatch = buf->b_fnum;\t// remember first match\n\t\t    }\n\t\t}\n\n\t\tvim_regfree(regmatch.regprog);\n\t\tif (match >= 0)\t\t\t// found one match\n\t\t    break;\n\t    }\n\n\t    // Only search for unlisted buffers if there was no match with\n\t    // a listed buffer.\n\t    if (!unlisted || !find_listed || match != -1)\n\t\tbreak;\n\t    find_listed = FALSE;\n\t}\n\n\tvim_free(pat);\n    }\n\n    if (match == -2)\n\tsemsg(_(e_more_than_one_match_for_str), pattern);\n    else if (match < 0)\n\tsemsg(_(e_no_matching_buffer_for_str), pattern);\n    return match;\n}", "target": 1, "idx": 11245}
{"commit_id": "b2eab95e07cb5819375a50358d4806a8813b6e50", "project": "gpac", "func": "GF_EXPORT\nGF_AV1Config *gf_isom_av1_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tif (gf_isom_get_reference_count(the_file, trackNumber, GF_ISOM_REF_TBAS)) {\n\t\tu32 ref_track;\n\t\tGF_Err e = gf_isom_get_reference(the_file, trackNumber, GF_ISOM_REF_TBAS, 1, &ref_track);\n\t\tif (e == GF_OK) {\n\t\t\ttrackNumber = ref_track;\n\t\t}\n\t}\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex - 1);\n\tif (!entry || !entry->av1_config|| !entry->av1_config->config) return NULL;\n\treturn AV1_DuplicateConfig(entry->av1_config->config);\n}", "target": 1, "idx": 11246}
{"commit_id": "79e48650320e6fba48369fccf13fd045315b19b8", "project": "torvalds/linux", "func": "int x25_negotiate_facilities(struct sk_buff *skb, struct sock *sk,\n\t\tstruct x25_facilities *new, struct x25_dte_facilities *dte)\n{\n\tstruct x25_sock *x25 = x25_sk(sk);\n\tstruct x25_facilities *ours = &x25->facilities;\n\tstruct x25_facilities theirs;\n\tint len;\n\n\tmemset(&theirs, 0, sizeof(theirs));\n\tmemcpy(new, ours, sizeof(*new));\n\tmemset(dte, 0, sizeof(*dte));\n\n\tlen = x25_parse_facilities(skb, &theirs, dte, &x25->vc_facil_mask);\n\tif (len < 0)\n\t\treturn len;\n\n\t/*\n\t *\tThey want reverse charging, we won't accept it.\n\t */\n\tif ((theirs.reverse & 0x01 ) && (ours->reverse & 0x01)) {\n\t\tSOCK_DEBUG(sk, \"X.25: rejecting reverse charging request\\n\");\n\t\treturn -1;\n\t}\n\n\tnew->reverse = theirs.reverse;\n\n\tif (theirs.throughput) {\n\t\tint theirs_in =  theirs.throughput & 0x0f;\n\t\tint theirs_out = theirs.throughput & 0xf0;\n\t\tint ours_in  = ours->throughput & 0x0f;\n\t\tint ours_out = ours->throughput & 0xf0;\n\t\tif (!ours_in || theirs_in < ours_in) {\n\t\t\tSOCK_DEBUG(sk, \"X.25: inbound throughput negotiated\\n\");\n\t\t\tnew->throughput = (new->throughput & 0xf0) | theirs_in;\n\t\t}\n\t\tif (!ours_out || theirs_out < ours_out) {\n\t\t\tSOCK_DEBUG(sk,\n\t\t\t\t\"X.25: outbound throughput negotiated\\n\");\n\t\t\tnew->throughput = (new->throughput & 0x0f) | theirs_out;\n\t\t}\n\t}\n\n\tif (theirs.pacsize_in && theirs.pacsize_out) {\n\t\tif (theirs.pacsize_in < ours->pacsize_in) {\n\t\t\tSOCK_DEBUG(sk, \"X.25: packet size inwards negotiated down\\n\");\n\t\t\tnew->pacsize_in = theirs.pacsize_in;\n\t\t}\n\t\tif (theirs.pacsize_out < ours->pacsize_out) {\n\t\t\tSOCK_DEBUG(sk, \"X.25: packet size outwards negotiated down\\n\");\n\t\t\tnew->pacsize_out = theirs.pacsize_out;\n\t\t}\n\t}\n\n\tif (theirs.winsize_in && theirs.winsize_out) {\n\t\tif (theirs.winsize_in < ours->winsize_in) {\n\t\t\tSOCK_DEBUG(sk, \"X.25: window size inwards negotiated down\\n\");\n\t\t\tnew->winsize_in = theirs.winsize_in;\n\t\t}\n\t\tif (theirs.winsize_out < ours->winsize_out) {\n\t\t\tSOCK_DEBUG(sk, \"X.25: window size outwards negotiated down\\n\");\n\t\t\tnew->winsize_out = theirs.winsize_out;\n\t\t}\n\t}\n\n\treturn len;\n}", "target": 2, "idx": 11247}
{"commit_id": "37c88107679d36c419572732b4af6e18bb2f7dce", "project": "android", "func": "static int remove_bond(const bt_bdaddr_t *bd_addr)\n{\n    if (is_restricted_mode() && !btif_storage_is_restricted_device(bd_addr))\n        return BT_STATUS_SUCCESS;\n\n    /* sanity check */\n    if (interface_ready() == FALSE)\n        return BT_STATUS_NOT_READY;\n\n    return btif_dm_remove_bond(bd_addr);\n}", "target": 2, "idx": 11248}
{"commit_id": "de594e47659029316bbf9391efb79da0a1a08e08", "project": "qemu", "func": "static void lsi_execute_script(LSIState *s)\n{\n    PCIDevice *pci_dev = PCI_DEVICE(s);\n    uint32_t insn;\n    uint32_t addr, addr_high;\n    int opcode;\n    int insn_processed = 0;\n\n    s->istat1 |= LSI_ISTAT1_SRUN;\nagain:\n    if (++insn_processed > LSI_MAX_INSN) {\n        /* Some windows drivers make the device spin waiting for a memory\n           location to change.  If we have been executed a lot of code then\n           assume this is the case and force an unexpected device disconnect.\n           This is apparently sufficient to beat the drivers into submission.\n         */\n        if (!(s->sien0 & LSI_SIST0_UDC)) {\n            qemu_log_mask(LOG_GUEST_ERROR,\n                          \"lsi_scsi: inf. loop with UDC masked\");\n        }\n        lsi_script_scsi_interrupt(s, LSI_SIST0_UDC, 0);\n        lsi_disconnect(s);\n        trace_lsi_execute_script_stop();\n        return;\n    }\n    insn = read_dword(s, s->dsp);\n    if (!insn) {\n        /* If we receive an empty opcode increment the DSP by 4 bytes\n           instead of 8 and execute the next opcode at that location */\n        s->dsp += 4;\n        goto again;\n    }\n    addr = read_dword(s, s->dsp + 4);\n    addr_high = 0;\n    trace_lsi_execute_script(s->dsp, insn, addr);\n    s->dsps = addr;\n    s->dcmd = insn >> 24;\n    s->dsp += 8;\n    switch (insn >> 30) {\n    case 0: /* Block move.  */\n        if (s->sist1 & LSI_SIST1_STO) {\n            trace_lsi_execute_script_blockmove_delayed();\n            lsi_stop_script(s);\n            break;\n        }\n        s->dbc = insn & 0xffffff;\n        s->rbc = s->dbc;\n        /* ??? Set ESA.  */\n        s->ia = s->dsp - 8;\n        if (insn & (1 << 29)) {\n            /* Indirect addressing.  */\n            addr = read_dword(s, addr);\n        } else if (insn & (1 << 28)) {\n            uint32_t buf[2];\n            int32_t offset;\n            /* Table indirect addressing.  */\n\n            /* 32-bit Table indirect */\n            offset = sextract32(addr, 0, 24);\n            pci_dma_read(pci_dev, s->dsa + offset, buf, 8);\n            /* byte count is stored in bits 0:23 only */\n            s->dbc = cpu_to_le32(buf[0]) & 0xffffff;\n            s->rbc = s->dbc;\n            addr = cpu_to_le32(buf[1]);\n\n            /* 40-bit DMA, upper addr bits [39:32] stored in first DWORD of\n             * table, bits [31:24] */\n            if (lsi_dma_40bit(s))\n                addr_high = cpu_to_le32(buf[0]) >> 24;\n            else if (lsi_dma_ti64bit(s)) {\n                int selector = (cpu_to_le32(buf[0]) >> 24) & 0x1f;\n                switch (selector) {\n                case 0 ... 0x0f:\n                    /* offset index into scratch registers since\n                     * TI64 mode can use registers C to R */\n                    addr_high = s->scratch[2 + selector];\n                    break;\n                case 0x10:\n                    addr_high = s->mmrs;\n                    break;\n                case 0x11:\n                    addr_high = s->mmws;\n                    break;\n                case 0x12:\n                    addr_high = s->sfs;\n                    break;\n                case 0x13:\n                    addr_high = s->drs;\n                    break;\n                case 0x14:\n                    addr_high = s->sbms;\n                    break;\n                case 0x15:\n                    addr_high = s->dbms;\n                    break;\n                default:\n                    qemu_log_mask(LOG_GUEST_ERROR,\n                          \"lsi_scsi: Illegal selector specified (0x%x > 0x15) \"\n                          \"for 64-bit DMA block move\", selector);\n                    break;\n                }\n            }\n        } else if (lsi_dma_64bit(s)) {\n            /* fetch a 3rd dword if 64-bit direct move is enabled and\n               only if we're not doing table indirect or indirect addressing */\n            s->dbms = read_dword(s, s->dsp);\n            s->dsp += 4;\n            s->ia = s->dsp - 12;\n        }\n        if ((s->sstat1 & PHASE_MASK) != ((insn >> 24) & 7)) {\n            trace_lsi_execute_script_blockmove_badphase(\n                    scsi_phase_name(s->sstat1),\n                    scsi_phase_name(insn >> 24));\n            lsi_script_scsi_interrupt(s, LSI_SIST0_MA, 0);\n            break;\n        }\n        s->dnad = addr;\n        s->dnad64 = addr_high;\n        switch (s->sstat1 & 0x7) {\n        case PHASE_DO:\n            s->waiting = LSI_DMA_SCRIPTS;\n            lsi_do_dma(s, 1);\n            if (s->waiting)\n                s->waiting = LSI_DMA_IN_PROGRESS;\n            break;\n        case PHASE_DI:\n            s->waiting = LSI_DMA_SCRIPTS;\n            lsi_do_dma(s, 0);\n            if (s->waiting)\n                s->waiting = LSI_DMA_IN_PROGRESS;\n            break;\n        case PHASE_CMD:\n            lsi_do_command(s);\n            break;\n        case PHASE_ST:\n            lsi_do_status(s);\n            break;\n        case PHASE_MO:\n            lsi_do_msgout(s);\n            break;\n        case PHASE_MI:\n            lsi_do_msgin(s);\n            break;\n        default:\n            qemu_log_mask(LOG_UNIMP, \"lsi_scsi: Unimplemented phase %s\\n\",\n                          scsi_phase_name(s->sstat1));\n        }\n        s->dfifo = s->dbc & 0xff;\n        s->ctest5 = (s->ctest5 & 0xfc) | ((s->dbc >> 8) & 3);\n        s->sbc = s->dbc;\n        s->rbc -= s->dbc;\n        s->ua = addr + s->dbc;\n        break;\n\n    case 1: /* IO or Read/Write instruction.  */\n        opcode = (insn >> 27) & 7;\n        if (opcode < 5) {\n            uint32_t id;\n\n            if (insn & (1 << 25)) {\n                id = read_dword(s, s->dsa + sextract32(insn, 0, 24));\n            } else {\n                id = insn;\n            }\n            id = (id >> 16) & 0xf;\n            if (insn & (1 << 26)) {\n                addr = s->dsp + sextract32(addr, 0, 24);\n            }\n            s->dnad = addr;\n            switch (opcode) {\n            case 0: /* Select */\n                s->sdid = id;\n                if (s->scntl1 & LSI_SCNTL1_CON) {\n                    trace_lsi_execute_script_io_alreadyreselected();\n                    s->dsp = s->dnad;\n                    break;\n                }\n                s->sstat0 |= LSI_SSTAT0_WOA;\n                s->scntl1 &= ~LSI_SCNTL1_IARB;\n                if (!scsi_device_find(&s->bus, 0, id, 0)) {\n                    lsi_bad_selection(s, id);\n                    break;\n                }\n                trace_lsi_execute_script_io_selected(id,\n                                             insn & (1 << 3) ? \" ATN\" : \"\");\n                /* ??? Linux drivers compain when this is set.  Maybe\n                   it only applies in low-level mode (unimplemented).\n                lsi_script_scsi_interrupt(s, LSI_SIST0_CMP, 0); */\n                s->select_tag = id << 8;\n                s->scntl1 |= LSI_SCNTL1_CON;\n                if (insn & (1 << 3)) {\n                    s->socl |= LSI_SOCL_ATN;\n                    s->sbcl |= LSI_SBCL_ATN;\n                }\n                s->sbcl |= LSI_SBCL_BSY;\n                lsi_set_phase(s, PHASE_MO);\n                s->waiting = LSI_NOWAIT;\n                break;\n            case 1: /* Disconnect */\n                trace_lsi_execute_script_io_disconnect();\n                s->scntl1 &= ~LSI_SCNTL1_CON;\n                /* FIXME: this is not entirely correct; the target need not ask\n                 * for reselection until it has to send data, while here we force a\n                 * reselection as soon as the bus is free.  The correct flow would\n                 * reselect before lsi_transfer_data and disconnect as soon as\n                 * DMA ends.\n                 */\n                if (!s->current) {\n                    lsi_request *p = get_pending_req(s);\n                    if (p) {\n                        lsi_reselect(s, p);\n                    }\n                }\n                break;\n            case 2: /* Wait Reselect */\n                if (s->istat0 & LSI_ISTAT0_SIGP) {\n                    s->dsp = s->dnad;\n                } else if (!lsi_irq_on_rsl(s)) {\n                        lsi_wait_reselect(s);\n                }\n                break;\n            case 3: /* Set */\n                trace_lsi_execute_script_io_set(\n                        insn & (1 << 3) ? \" ATN\" : \"\",\n                        insn & (1 << 6) ? \" ACK\" : \"\",\n                        insn & (1 << 9) ? \" TM\" : \"\",\n                        insn & (1 << 10) ? \" CC\" : \"\");\n                if (insn & (1 << 3)) {\n                    s->socl |= LSI_SOCL_ATN;\n                    s->sbcl |= LSI_SBCL_ATN;\n                    lsi_set_phase(s, PHASE_MO);\n                }\n\n                if (insn & (1 << 6)) {\n                    s->sbcl |= LSI_SBCL_ACK;\n                }\n\n                if (insn & (1 << 9)) {\n                    qemu_log_mask(LOG_UNIMP,\n                        \"lsi_scsi: Target mode not implemented\\n\");\n                }\n                if (insn & (1 << 10))\n                    s->carry = 1;\n                break;\n            case 4: /* Clear */\n                trace_lsi_execute_script_io_clear(\n                        insn & (1 << 3) ? \" ATN\" : \"\",\n                        insn & (1 << 6) ? \" ACK\" : \"\",\n                        insn & (1 << 9) ? \" TM\" : \"\",\n                        insn & (1 << 10) ? \" CC\" : \"\");\n                if (insn & (1 << 3)) {\n                    s->socl &= ~LSI_SOCL_ATN;\n                    s->sbcl &= ~LSI_SBCL_ATN;\n                }\n\n                if (insn & (1 << 6)) {\n                    s->sbcl &= ~LSI_SBCL_ACK;\n                }\n\n                if (insn & (1 << 10))\n                    s->carry = 0;\n                break;\n            }\n        } else {\n            uint8_t op0;\n            uint8_t op1;\n            uint8_t data8;\n            int reg;\n            int operator;\n\n            static const char *opcode_names[3] =\n                {\"Write\", \"Read\", \"Read-Modify-Write\"};\n            static const char *operator_names[8] =\n                {\"MOV\", \"SHL\", \"OR\", \"XOR\", \"AND\", \"SHR\", \"ADD\", \"ADC\"};\n\n            reg = ((insn >> 16) & 0x7f) | (insn & 0x80);\n            data8 = (insn >> 8) & 0xff;\n            opcode = (insn >> 27) & 7;\n            operator = (insn >> 24) & 7;\n            trace_lsi_execute_script_io_opcode(\n                    opcode_names[opcode - 5], reg,\n                    operator_names[operator], data8, s->sfbr,\n                    (insn & (1 << 23)) ? \" SFBR\" : \"\");\n            op0 = op1 = 0;\n            switch (opcode) {\n            case 5: /* From SFBR */\n                op0 = s->sfbr;\n                op1 = data8;\n                break;\n            case 6: /* To SFBR */\n                if (operator)\n                    op0 = lsi_reg_readb(s, reg);\n                op1 = data8;\n                break;\n            case 7: /* Read-modify-write */\n                if (operator)\n                    op0 = lsi_reg_readb(s, reg);\n                if (insn & (1 << 23)) {\n                    op1 = s->sfbr;\n                } else {\n                    op1 = data8;\n                }\n                break;\n            }\n\n            switch (operator) {\n            case 0: /* move */\n                op0 = op1;\n                break;\n            case 1: /* Shift left */\n                op1 = op0 >> 7;\n                op0 = (op0 << 1) | s->carry;\n                s->carry = op1;\n                break;\n            case 2: /* OR */\n                op0 |= op1;\n                break;\n            case 3: /* XOR */\n                op0 ^= op1;\n                break;\n            case 4: /* AND */\n                op0 &= op1;\n                break;\n            case 5: /* SHR */\n                op1 = op0 & 1;\n                op0 = (op0 >> 1) | (s->carry << 7);\n                s->carry = op1;\n                break;\n            case 6: /* ADD */\n                op0 += op1;\n                s->carry = op0 < op1;\n                break;\n            case 7: /* ADC */\n                op0 += op1 + s->carry;\n                if (s->carry)\n                    s->carry = op0 <= op1;\n                else\n                    s->carry = op0 < op1;\n                break;\n            }\n\n            switch (opcode) {\n            case 5: /* From SFBR */\n            case 7: /* Read-modify-write */\n                lsi_reg_writeb(s, reg, op0);\n                break;\n            case 6: /* To SFBR */\n                s->sfbr = op0;\n                break;\n            }\n        }\n        break;\n\n    case 2: /* Transfer Control.  */\n        {\n            int cond;\n            int jmp;\n\n            if ((insn & 0x002e0000) == 0) {\n                trace_lsi_execute_script_tc_nop();\n                break;\n            }\n            if (s->sist1 & LSI_SIST1_STO) {\n                trace_lsi_execute_script_tc_delayedselect_timeout();\n                lsi_stop_script(s);\n                break;\n            }\n            cond = jmp = (insn & (1 << 19)) != 0;\n            if (cond == jmp && (insn & (1 << 21))) {\n                trace_lsi_execute_script_tc_compc(s->carry == jmp);\n                cond = s->carry != 0;\n            }\n            if (cond == jmp && (insn & (1 << 17))) {\n                trace_lsi_execute_script_tc_compp(scsi_phase_name(s->sstat1),\n                        jmp ? '=' : '!', scsi_phase_name(insn >> 24));\n                cond = (s->sstat1 & PHASE_MASK) == ((insn >> 24) & 7);\n            }\n            if (cond == jmp && (insn & (1 << 18))) {\n                uint8_t mask;\n\n                mask = (~insn >> 8) & 0xff;\n                trace_lsi_execute_script_tc_compd(\n                        s->sfbr, mask, jmp ? '=' : '!', insn & mask);\n                cond = (s->sfbr & mask) == (insn & mask);\n            }\n            if (cond == jmp) {\n                if (insn & (1 << 23)) {\n                    /* Relative address.  */\n                    addr = s->dsp + sextract32(addr, 0, 24);\n                }\n                switch ((insn >> 27) & 7) {\n                case 0: /* Jump */\n                    trace_lsi_execute_script_tc_jump(addr);\n                    s->adder = addr;\n                    s->dsp = addr;\n                    break;\n                case 1: /* Call */\n                    trace_lsi_execute_script_tc_call(addr);\n                    s->temp = s->dsp;\n                    s->dsp = addr;\n                    break;\n                case 2: /* Return */\n                    trace_lsi_execute_script_tc_return(s->temp);\n                    s->dsp = s->temp;\n                    break;\n                case 3: /* Interrupt */\n                    trace_lsi_execute_script_tc_interrupt(s->dsps);\n                    if ((insn & (1 << 20)) != 0) {\n                        s->istat0 |= LSI_ISTAT0_INTF;\n                        lsi_update_irq(s);\n                    } else {\n                        lsi_script_dma_interrupt(s, LSI_DSTAT_SIR);\n                    }\n                    break;\n                default:\n                    trace_lsi_execute_script_tc_illegal();\n                    lsi_script_dma_interrupt(s, LSI_DSTAT_IID);\n                    break;\n                }\n            } else {\n                trace_lsi_execute_script_tc_cc_failed();\n            }\n        }\n        break;\n\n    case 3:\n        if ((insn & (1 << 29)) == 0) {\n            /* Memory move.  */\n            uint32_t dest;\n            /* ??? The docs imply the destination address is loaded into\n               the TEMP register.  However the Linux drivers rely on\n               the value being presrved.  */\n            dest = read_dword(s, s->dsp);\n            s->dsp += 4;\n            lsi_memcpy(s, dest, addr, insn & 0xffffff);\n        } else {\n            uint8_t data[7];\n            int reg;\n            int n;\n            int i;\n\n            if (insn & (1 << 28)) {\n                addr = s->dsa + sextract32(addr, 0, 24);\n            }\n            n = (insn & 7);\n            reg = (insn >> 16) & 0xff;\n            if (insn & (1 << 24)) {\n                pci_dma_read(pci_dev, addr, data, n);\n                trace_lsi_execute_script_mm_load(reg, n, addr, *(int *)data);\n                for (i = 0; i < n; i++) {\n                    lsi_reg_writeb(s, reg + i, data[i]);\n                }\n            } else {\n                trace_lsi_execute_script_mm_store(reg, n, addr);\n                for (i = 0; i < n; i++) {\n                    data[i] = lsi_reg_readb(s, reg + i);\n                }\n                pci_dma_write(pci_dev, addr, data, n);\n            }\n        }\n    }\n    if (s->istat1 & LSI_ISTAT1_SRUN && s->waiting == LSI_NOWAIT) {\n        if (s->dcntl & LSI_DCNTL_SSM) {\n            lsi_script_dma_interrupt(s, LSI_DSTAT_SSI);\n        } else {\n            goto again;\n        }\n    }\n    trace_lsi_execute_script_stop();\n}", "target": 0, "idx": 11249}
{"commit_id": "6669de1b235843968e88844ca6d3c8dec4b01a9e", "project": "vim", "func": "static int\nsug_filltree(spellinfo_T *spin, slang_T *slang)\n{\n    char_u\t*byts;\n    idx_T\t*idxs;\n    int\t\tdepth;\n    idx_T\tarridx[MAXWLEN];\n    int\t\tcuri[MAXWLEN];\n    char_u\ttword[MAXWLEN];\n    char_u\ttsalword[MAXWLEN];\n    int\t\tc;\n    idx_T\tn;\n    unsigned\twords_done = 0;\n    int\t\twordcount[MAXWLEN];\n\n    // We use si_foldroot for the soundfolded trie.\n    spin->si_foldroot = wordtree_alloc(spin);\n    if (spin->si_foldroot == NULL)\n\treturn FAIL;\n\n    // let tree_add_word() know we're adding to the soundfolded tree\n    spin->si_sugtree = TRUE;\n\n    /*\n     * Go through the whole case-folded tree, soundfold each word and put it\n     * in the trie.  Bail out if the tree is empty.\n     */\n    byts = slang->sl_fbyts;\n    idxs = slang->sl_fidxs;\n    if (byts == NULL || idxs == NULL)\n\treturn FAIL;\n\n    arridx[0] = 0;\n    curi[0] = 1;\n    wordcount[0] = 0;\n\n    depth = 0;\n    while (depth >= 0 && !got_int)\n    {\n\tif (curi[depth] > byts[arridx[depth]])\n\t{\n\t    // Done all bytes at this node, go up one level.\n\t    idxs[arridx[depth]] = wordcount[depth];\n\t    if (depth > 0)\n\t\twordcount[depth - 1] += wordcount[depth];\n\n\t    --depth;\n\t    line_breakcheck();\n\t}\n\telse\n\t{\n\n\t    // Do one more byte at this node.\n\t    n = arridx[depth] + curi[depth];\n\t    ++curi[depth];\n\n\t    c = byts[n];\n\t    if (c == 0)\n\t    {\n\t\t// Sound-fold the word.\n\t\ttword[depth] = NUL;\n\t\tspell_soundfold(slang, tword, TRUE, tsalword);\n\n\t\t// We use the \"flags\" field for the MSB of the wordnr,\n\t\t// \"region\" for the LSB of the wordnr.\n\t\tif (tree_add_word(spin, tsalword, spin->si_foldroot,\n\t\t\t\twords_done >> 16, words_done & 0xffff,\n\t\t\t\t\t\t\t   0) == FAIL)\n\t\t    return FAIL;\n\n\t\t++words_done;\n\t\t++wordcount[depth];\n\n\t\t// Reset the block count each time to avoid compression\n\t\t// kicking in.\n\t\tspin->si_blocks_cnt = 0;\n\n\t\t// Skip over any other NUL bytes (same word with different\n\t\t// flags).  But don't go over the end.\n\t\twhile (n + 1 < slang->sl_fbyts_len && byts[n + 1] == 0)\n\t\t{\n\t\t    ++n;\n\t\t    ++curi[depth];\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// Normal char, go one level deeper.\n\t\ttword[depth++] = c;\n\t\tarridx[depth] = idxs[n];\n\t\tcuri[depth] = 1;\n\t\twordcount[depth] = 0;\n\t    }\n\t}\n    }\n\n    smsg(_(\"Total number of words: %d\"), words_done);\n\n    return OK;\n}", "target": 1, "idx": 11250}
{"commit_id": "81406c0c1d45f75fcc7972ed974d2597abb0b9e9", "project": "php/php-src", "func": "php_stream *php_stream_zip_open(char *filename, char *path, char *mode STREAMS_DC TSRMLS_DC)\n{\n\tstruct zip_file *zf = NULL;\n\tint err = 0;\n\n\tphp_stream *stream = NULL;\n\tstruct php_zip_stream_data_t *self;\n\tstruct zip *stream_za;\n\n\tif (strncmp(mode,\"r\", strlen(\"r\")) != 0) {\n\t\treturn NULL;\n\t}\n\n\tif (filename) {\n\t\tif (ZIP_OPENBASEDIR_CHECKPATH(filename)) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* duplicate to make the stream za independent (esp. for MSHUTDOWN) */\n\t\tstream_za = zip_open(filename, ZIP_CREATE, &err);\n\t\tif (!stream_za) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tzf = zip_fopen(stream_za, path, 0);\n\t\tif (zf) {\n\t\t\tself = emalloc(sizeof(*self));\n\n\t\t\tself->za = stream_za;\n\t\t\tself->zf = zf;\n\t\t\tself->stream = NULL;\n\t\t\tself->cursor = 0;\n\t\t\tstream = php_stream_alloc(&php_stream_zipio_ops, self, NULL, mode);\n\t\t\tstream->orig_path = estrdup(path);\n\t\t} else {\n\t\t\tzip_close(stream_za);\n\t\t}\n\t}\n\n\tif (!stream) {\n\t\treturn NULL;\n\t} else {\n\t\treturn stream;\n\t}\n\n}", "target": 2, "idx": 11251}
{"commit_id": "8d7b0958cdb505047e5a66029468b8d12b8a7add", "project": "systemd", "func": "int journal_file_rotate(\n                JournalFile **f,\n                MMapCache *mmap_cache,\n                JournalFileFlags file_flags,\n                uint64_t compress_threshold_bytes,\n                Set *deferred_closes) {\n\n        _cleanup_free_ char *path = NULL;\n        JournalFile *new_file = NULL;\n        int r;\n\n        assert(f);\n        assert(*f);\n\n        journal_file_write_final_tag(*f);\n        r = journal_file_archive(*f, &path);\n        if (r < 0)\n                return r;\n\n        set_clear_with_destructor(deferred_closes, journal_file_offline_close);\n\n        r = journal_file_open(\n                        /* fd= */ -1,\n                        path,\n                        (*f)->open_flags,\n                        file_flags,\n                        (*f)->mode,\n                        compress_threshold_bytes,\n                        /* metrics= */ NULL,\n                        mmap_cache,\n                        /* template= */ *f,\n                        &new_file);\n\n        journal_file_initiate_close(*f, deferred_closes);\n        *f = new_file;\n\n        return r;\n}", "target": 1, "idx": 11252}
{"commit_id": "987dd68f71a7d8276cef3b6c3d578fd4845b5699", "project": "ghostlander/Phoenixcoin", "func": "bool CWallet::CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey)\n{\n    {\n        LOCK2(cs_main, cs_wallet);\n        printf(\"CommitTransaction:\\n%s\", wtxNew.ToString().c_str());\n        {\n            // This is only to keep the database open to defeat the auto-flush for the\n            // duration of this scope.  This is the only place where this optimization\n            // maybe makes sense; please don't do it anywhere else.\n            CWalletDB* pwalletdb = fFileBacked ? new CWalletDB(strWalletFile,\"r\") : NULL;\n\n            // Take key pair from key pool so it won't be used again\n            reservekey.KeepKey();\n\n            // Add tx to wallet, because if it has change it's also ours,\n            // otherwise just for transaction history.\n            AddToWallet(wtxNew);\n\n            // Mark old coins as spent\n            set<CWalletTx*> setCoins;\n            BOOST_FOREACH(const CTxIn& txin, wtxNew.vin)\n            {\n                CWalletTx &coin = mapWallet[txin.prevout.hash];\n                coin.BindWallet(this);\n                coin.MarkSpent(txin.prevout.n);\n                coin.WriteToDisk();\n                NotifyTransactionChanged(this, coin.GetHash(), CT_UPDATED);\n            }\n\n            if (fFileBacked)\n                delete pwalletdb;\n        }\n\n        // Track how many getdata requests our transaction gets\n        mapRequestCount[wtxNew.GetHash()] = 0;\n\n        // Broadcast\n        CTxDB txdb(\"r\");\n        if(!wtxNew.AcceptToMemoryPool(txdb, true, false)) {\n            // This must not fail. The transaction has already been signed and recorded.\n            printf(\"CommitTransaction() : Error: Transaction not valid\");\n            return false;\n        }\n        wtxNew.RelayWalletTransaction();\n    }\n    return true;\n}", "target": 2, "idx": 11253}
{"commit_id": "045a31b95509c8f25f5f04ec5e0dec5cd09f2c5f", "project": "torvalds/linux", "func": "static struct device_node *\ntegra_xusb_find_port_node(struct tegra_xusb_padctl *padctl, const char *type,\n\t\t\t  unsigned int index)\n{\n\tstruct device_node *ports, *np;\n\tchar *name;\n\n\tports = of_get_child_by_name(padctl->dev->of_node, \"ports\");\n\tif (!ports)\n\t\treturn NULL;\n\n\tname = kasprintf(GFP_KERNEL, \"%s-%u\", type, index);\n\tif (!name) {\n\t\tof_node_put(ports);\n\t\treturn NULL;\n\t}\n\tnp = of_get_child_by_name(ports, name);\n\tkfree(name);\n\tof_node_put(ports);\n\n\treturn np;\n}", "target": 1, "idx": 11254}
{"commit_id": "d96a6b8bcc7439fa7e3876207aa0a8e79c8451b6", "project": "Cisco-Talos/clamav", "func": "static int xar_hash_check(int hash, const void * result, const void * expected)\n{\n    int len;\n\n    if (!result || !expected)\n        return 1;\n    switch (hash) {\n    case XAR_CKSUM_SHA1:\n        len = CLI_HASHLEN_SHA1;\n        break;\n    case XAR_CKSUM_MD5:\n        len = CLI_HASHLEN_MD5;\n        break;\n    case XAR_CKSUM_OTHER:\n    case XAR_CKSUM_NONE:\n    default:\n        return 1;\n    }\n    return memcmp(result, expected, len);\n}", "target": 1, "idx": 11255}
{"commit_id": "a7bfbd93812950b7444841431e8e297e62cb524e", "project": "znc", "func": "void CConfig::Write(CFile& File, unsigned int iIndentation) {\n    CString sIndentation = CString(iIndentation, '\\t');\n\n    auto SingleLine = [](const CString& s) {\n        return s.Replace_n(\"\\r\", \"\").Replace_n(\"\\n\", \"\");\n    };\n\n    for (const auto& it : m_ConfigEntries) {\n        for (const CString& sValue : it.second) {\n            File.Write(SingleLine(sIndentation + it.first + \" = \" + sValue) +\n                       \"\\n\");\n        }\n    }\n\n    for (const auto& it : m_SubConfigs) {\n        for (const auto& it2 : it.second) {\n            File.Write(\"\\n\");\n\n            File.Write(SingleLine(sIndentation + \"<\" + it.first + \" \" +\n                                  it2.first + \">\") +\n                       \"\\n\");\n            it2.second.m_pSubConfig->Write(File, iIndentation + 1);\n            File.Write(SingleLine(sIndentation + \"</\" + it.first + \">\") + \"\\n\");\n        }\n    }\n}", "target": 1, "idx": 11256}
{"commit_id": "9eaa6c2a823c1d2b58913506a15f9474bf857a3d", "project": "xelerance/Openswan", "func": "err_t verify_signed_hash(const struct RSA_public_key *k\n                         , u_char *s, unsigned int s_max_octets\n                         , u_char **psig\n                         , size_t hash_len\n                         , const u_char *sig_val, size_t sig_len)\n{\n    unsigned int padlen;\n\n    /* actual exponentiation; see PKCS#1 v2.0 5.1 */\n    {\n\tchunk_t temp_s;\n\tMP_INT c;\n\n\tn_to_mpz(&c, sig_val, sig_len);\n\toswcrypto.mod_exp(&c, &c, &k->e, &k->n);\n\n\ttemp_s = mpz_to_n(&c, sig_len);\t/* back to octets */\n        if(s_max_octets < sig_len) {\n            return \"2\"\"exponentiation failed; too many octets\";\n        }\n\tmemcpy(s, temp_s.ptr, sig_len);\n\tpfree(temp_s.ptr);\n\tmpz_clear(&c);\n    }\n\n    /* check signature contents */\n    /* verify padding (not including any DER digest info! */\n    padlen = sig_len - 3 - hash_len;\n    /* now check padding */\n\n    DBG(DBG_CRYPT,\n\tDBG_dump(\"verify_sh decrypted SIG1:\", s, sig_len));\n    DBG(DBG_CRYPT, DBG_log(\"pad_len calculated: %d hash_len: %d\", padlen, (int)hash_len));\n\n    /* skip padding */\n    if(s[0]    != 0x00\n       || s[1] != 0x01\n       || s[padlen+2] != 0x00) {\n\treturn \"3\"\"SIG padding does not check out\";\n    }\n\n    /* signature starts after ASN wrapped padding [00,01,FF..FF,00] */\n    (*psig) = s + padlen + 3;\n\n    /* verify padding contents */\n    {\n        const u_char *p;\n        size_t cnt_ffs = 0;\n\n        for (p = s+2; p < s+padlen+2; p++)\n            if (*p == 0xFF)\n                cnt_ffs ++;\n\n        if (cnt_ffs != padlen)\n            return \"4\" \"invalid Padding String\";\n    }\n\n    /* return SUCCESS */\n    return NULL;\n}", "target": 2, "idx": 11257}
{"commit_id": "f9569c086ff29259c73790db9cbf39fe8fb9d862", "project": "libarchive", "func": "static int\nread_children(struct archive_read *a, struct file_info *parent)\n{\n\tstruct iso9660 *iso9660;\n\tconst unsigned char *b, *p;\n\tstruct file_info *multi;\n\tsize_t step, skip_size;\n\n\tiso9660 = (struct iso9660 *)(a->format->data);\n\t/* flush any remaining bytes from the last round to ensure\n\t * we're positioned */\n\tif (iso9660->entry_bytes_unconsumed) {\n\t\t__archive_read_consume(a, iso9660->entry_bytes_unconsumed);\n\t\tiso9660->entry_bytes_unconsumed = 0;\n\t}\n\tif (iso9660->current_position > parent->offset) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"Ignoring out-of-order directory (%s) %jd > %jd\",\n\t\t    parent->name.s,\n\t\t    (intmax_t)iso9660->current_position,\n\t\t    (intmax_t)parent->offset);\n\t\treturn (ARCHIVE_WARN);\n\t}\n\tif (parent->offset + parent->size > iso9660->volume_size) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"Directory is beyond end-of-media: %s\",\n\t\t    parent->name.s);\n\t\treturn (ARCHIVE_WARN);\n\t}\n\tif (iso9660->current_position < parent->offset) {\n\t\tint64_t skipsize;\n\n\t\tskipsize = parent->offset - iso9660->current_position;\n\t\tskipsize = __archive_read_consume(a, skipsize);\n\t\tif (skipsize < 0)\n\t\t\treturn ((int)skipsize);\n\t\tiso9660->current_position = parent->offset;\n\t}\n\n\tstep = (size_t)(((parent->size + iso9660->logical_block_size -1) /\n\t    iso9660->logical_block_size) * iso9660->logical_block_size);\n\tb = __archive_read_ahead(a, step, NULL);\n\tif (b == NULL) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"Failed to read full block when scanning \"\n\t\t    \"ISO9660 directory list\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tiso9660->current_position += step;\n\tmulti = NULL;\n\tskip_size = step;\n\twhile (step) {\n\t\tp = b;\n\t\tb += iso9660->logical_block_size;\n\t\tstep -= iso9660->logical_block_size;\n\t\tfor (; *p != 0 && p < b && p + *p <= b; p += *p) {\n\t\t\tstruct file_info *child;\n\n\t\t\t/* N.B.: these special directory identifiers\n\t\t\t * are 8 bit \"values\" even on a\n\t\t\t * Joliet CD with UCS-2 (16bit) encoding.\n\t\t\t */\n\n\t\t\t/* Skip '.' entry. */\n\t\t\tif (*(p + DR_name_len_offset) == 1\n\t\t\t    && *(p + DR_name_offset) == '\\0')\n\t\t\t\tcontinue;\n\t\t\t/* Skip '..' entry. */\n\t\t\tif (*(p + DR_name_len_offset) == 1\n\t\t\t    && *(p + DR_name_offset) == '\\001')\n\t\t\t\tcontinue;\n\t\t\tchild = parse_file_info(a, parent, p, b - p);\n\t\t\tif (child == NULL) {\n\t\t\t\t__archive_read_consume(a, skip_size);\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\tif (child->cl_offset == 0 &&\n\t\t\t    (child->multi_extent || multi != NULL)) {\n\t\t\t\tstruct content *con;\n\n\t\t\t\tif (multi == NULL) {\n\t\t\t\t\tmulti = child;\n\t\t\t\t\tmulti->contents.first = NULL;\n\t\t\t\t\tmulti->contents.last =\n\t\t\t\t\t    &(multi->contents.first);\n\t\t\t\t}\n\t\t\t\tcon = malloc(sizeof(struct content));\n\t\t\t\tif (con == NULL) {\n\t\t\t\t\tarchive_set_error(\n\t\t\t\t\t    &a->archive, ENOMEM,\n\t\t\t\t\t    \"No memory for multi extent\");\n\t\t\t\t\t__archive_read_consume(a, skip_size);\n\t\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t\t}\n\t\t\t\tcon->offset = child->offset;\n\t\t\t\tcon->size = child->size;\n\t\t\t\tcon->next = NULL;\n\t\t\t\t*multi->contents.last = con;\n\t\t\t\tmulti->contents.last = &(con->next);\n\t\t\t\tif (multi == child) {\n\t\t\t\t\tif (add_entry(a, iso9660, child)\n\t\t\t\t\t    != ARCHIVE_OK)\n\t\t\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t\t} else {\n\t\t\t\t\tmulti->size += child->size;\n\t\t\t\t\tif (!child->multi_extent)\n\t\t\t\t\t\tmulti = NULL;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tif (add_entry(a, iso9660, child) != ARCHIVE_OK)\n\t\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t}\n\n\t__archive_read_consume(a, skip_size);\n\n\t/* Read data which recorded by RRIP \"CE\" extension. */\n\tif (read_CE(a, iso9660) != ARCHIVE_OK)\n\t\treturn (ARCHIVE_FATAL);\n\n\treturn (ARCHIVE_OK);\n}", "target": 1, "idx": 11258}
{"commit_id": "b222c66cdd7c3203d917c80ba615082d309d80c3", "project": "keepkey/keepkey-firmware", "func": "void handle_debug_usb_rx(const void *msg, size_t len)\n{\n    if (msg_tiny_flag) {\n        msg_read_tiny(msg, len);\n    } else {\n        usb_rx_helper(msg, len, DEBUG_MSG);\n    }\n}", "target": 3, "idx": 11259}
{"commit_id": "926cde5f3e4d2504ed161ed0cb771ac7cad6fd11", "project": "qemu", "func": "static void esp_do_dma(ESPState *s)\n{\n    uint32_t len;\n    int to_device;\n\n    len = s->dma_left;\n    if (s->do_cmd) {\n        trace_esp_do_dma(s->cmdlen, len);\n        assert (s->cmdlen <= sizeof(s->cmdbuf) &&\n                len <= sizeof(s->cmdbuf) - s->cmdlen);\n        s->dma_memory_read(s->dma_opaque, &s->cmdbuf[s->cmdlen], len);\n        return;\n    }\n    if (s->async_len == 0) {\n        /* Defer until data is available.  */\n        return;\n    }\n    if (len > s->async_len) {\n        len = s->async_len;\n    }\n    to_device = (s->ti_size < 0);\n    if (to_device) {\n        s->dma_memory_read(s->dma_opaque, s->async_buf, len);\n    } else {\n        s->dma_memory_write(s->dma_opaque, s->async_buf, len);\n    }\n    s->dma_left -= len;\n    s->async_buf += len;\n    s->async_len -= len;\n    if (to_device)\n        s->ti_size += len;\n    else\n        s->ti_size -= len;\n    if (s->async_len == 0) {\n        scsi_req_continue(s->current_req);\n        /* If there is still data to be read from the device then\n           complete the DMA operation immediately.  Otherwise defer\n           until the scsi layer has completed.  */\n        if (to_device || s->dma_left != 0 || s->ti_size == 0) {\n            return;\n        }\n    }\n\n    /* Partially filled a scsi buffer. Complete immediately.  */\n    esp_dma_done(s);\n}", "target": 1, "idx": 11260}
{"commit_id": "5b3bceca875e4ea4ed9d14c20b20ce46c92c13c6", "project": "facebook/wangle", "func": "int64_t LineBasedFrameDecoder::findEndOfLine(IOBufQueue& buf) {\n  Cursor c(buf.front());\n  for (uint32_t i = 0; i < maxLength_ && i < buf.chainLength(); i++) {\n    auto b = c.read<char>();\n    if (b == '\\n' && terminatorType_ != TerminatorType::CARRIAGENEWLINE) {\n      return i;\n    } else if (\n        terminatorType_ != TerminatorType::NEWLINE && b == '\\r' &&\n        !c.isAtEnd() && *c.peekBytes().data() == '\\n') {\n      return i;\n    }\n  }\n\n  return -1;\n}", "target": 3, "idx": 11261}
{"commit_id": "f17dae31ebf6ea7af8c512165d9b954c2a6ea46e", "project": "gpac", "func": "GF_Err gnrv_box_dump(GF_Box *a, FILE * trace)\n{\n\tGF_GenericVisualSampleEntryBox *p = (GF_GenericVisualSampleEntryBox *)a;\n\tif (p->EntryType) {\n\t\ta->type = p->EntryType;\n\t\t//don't allow UNKN or UUID as type (possible buffer overflow when typecasting to GF_UnknownBox)\n\t\tif ((a->type==GF_ISOM_BOX_TYPE_UNKNOWN) || (a->type==GF_ISOM_BOX_TYPE_UUID))\n\t\t\ta->type = GF_4CC('u','k','n','w');\n\t}\n\tgf_isom_box_dump_start(a, \"VisualSampleDescriptionBox\", trace);\n\tgf_fprintf(trace, \"DataReferenceIndex=\\\"%d\\\" Version=\\\"%d\\\" Revision=\\\"%d\\\" Vendor=\\\"%d\\\" TemporalQuality=\\\"%d\\\" SpacialQuality=\\\"%d\\\" Width=\\\"%d\\\" Height=\\\"%d\\\" HorizontalResolution=\\\"%d\\\" VerticalResolution=\\\"%d\\\" CompressorName=\\\"%s\\\" BitDepth=\\\"%d\\\"\",\n\t        p->dataReferenceIndex, p->version, p->revision, p->vendor, p->temporal_quality, p->spatial_quality, p->Width, p->Height, p->horiz_res, p->vert_res, isalnum(p->compressor_name[0]) ? p->compressor_name : p->compressor_name+1, p->bit_depth);\n\n\ta->type = GF_ISOM_BOX_TYPE_GNRV;\n\tgnr_dump_exts(p->data, p->data_size, trace);\n\n\tgf_isom_box_dump_done(\"VisualSampleDescriptionBox\", a, trace);\n\treturn GF_OK;\n}", "target": 2, "idx": 11262}
{"commit_id": "54d83fc74aa9ec72794373cb47432c5f7fb1a309", "project": "torvalds/linux", "func": "static inline bool unconditional(const struct arpt_entry *e)\n{\n\tstatic const struct arpt_arp uncond;\n\n\treturn e->target_offset == sizeof(struct arpt_entry) &&\n\t       memcmp(&e->arp, &uncond, sizeof(uncond)) == 0;\n}", "target": 2, "idx": 11263}
{"commit_id": "0ff832d31470471803b175cfff4e40c1b08ee779", "project": "aawc/unrar", "func": "bool Unpack::ProcessDecoded(UnpackThreadData &D)\n{\n  UnpackDecodedItem *Item=D.Decoded,*Border=D.Decoded+D.DecodedSize;\n  while (Item<Border)\n  {\n    UnpPtr&=MaxWinMask;\n    if (((WriteBorder-UnpPtr) & MaxWinMask)<MAX_INC_LZ_MATCH && WriteBorder!=UnpPtr)\n    {\n      UnpWriteBuf();\n      if (WrittenFileSize>DestUnpSize)\n        return false;\n    }\n\n    if (Item->Type==UNPDT_LITERAL)\n    {\n#if defined(LITTLE_ENDIAN) && defined(ALLOW_MISALIGNED)\n      if (Item->Length==3 && UnpPtr<MaxWinSize-4)\n      {\n        *(uint32 *)(Window+UnpPtr)=*(uint32 *)Item->Literal;\n        UnpPtr+=4;\n      }\n      else\n#endif\n        for (uint I=0;I<=Item->Length;I++)\n          Window[UnpPtr++ & MaxWinMask]=Item->Literal[I];\n    }\n    else\n      if (Item->Type==UNPDT_MATCH)\n      {\n        InsertOldDist(Item->Distance);\n        LastLength=Item->Length;\n        CopyString(Item->Length,Item->Distance);\n      }\n      else\n        if (Item->Type==UNPDT_REP)\n        {\n          uint Distance=OldDist[Item->Distance];\n          for (uint I=Item->Distance;I>0;I--)\n            OldDist[I]=OldDist[I-1];\n          OldDist[0]=Distance;\n          LastLength=Item->Length;\n          CopyString(Item->Length,Distance);\n        }\n        else\n          if (Item->Type==UNPDT_FULLREP)\n          {\n            if (LastLength!=0)\n              CopyString(LastLength,OldDist[0]);\n          }\n          else\n            if (Item->Type==UNPDT_FILTER)\n            {\n              UnpackFilter Filter;\n              \n              Filter.Type=(byte)Item->Length;\n              Filter.BlockStart=Item->Distance;\n\n              Item++;\n\n              Filter.Channels=(byte)Item->Length;\n              Filter.BlockLength=Item->Distance;\n\n              AddFilter(Filter);\n            }\n    Item++;\n  }\n  return true;\n}", "target": 2, "idx": 11264}
{"commit_id": "b9dd46188edc2f0d1f37328637860bb65a771124", "project": "torvalds/linux", "func": "static int sanity_check_raw_super(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct buffer_head *bh)\n{\n\tstruct f2fs_super_block *raw_super = (struct f2fs_super_block *)\n\t\t\t\t\t(bh->b_data + F2FS_SUPER_OFFSET);\n\tstruct super_block *sb = sbi->sb;\n\tunsigned int blocksize;\n\n\tif (F2FS_SUPER_MAGIC != le32_to_cpu(raw_super->magic)) {\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\"Magic Mismatch, valid(0x%x) - read(0x%x)\",\n\t\t\tF2FS_SUPER_MAGIC, le32_to_cpu(raw_super->magic));\n\t\treturn 1;\n\t}\n\n\t/* Currently, support only 4KB page cache size */\n\tif (F2FS_BLKSIZE != PAGE_SIZE) {\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\"Invalid page_cache_size (%lu), supports only 4KB\\n\",\n\t\t\tPAGE_SIZE);\n\t\treturn 1;\n\t}\n\n\t/* Currently, support only 4KB block size */\n\tblocksize = 1 << le32_to_cpu(raw_super->log_blocksize);\n\tif (blocksize != F2FS_BLKSIZE) {\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\"Invalid blocksize (%u), supports only 4KB\\n\",\n\t\t\tblocksize);\n\t\treturn 1;\n\t}\n\n\t/* check log blocks per segment */\n\tif (le32_to_cpu(raw_super->log_blocks_per_seg) != 9) {\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\"Invalid log blocks per segment (%u)\\n\",\n\t\t\tle32_to_cpu(raw_super->log_blocks_per_seg));\n\t\treturn 1;\n\t}\n\n\t/* Currently, support 512/1024/2048/4096 bytes sector size */\n\tif (le32_to_cpu(raw_super->log_sectorsize) >\n\t\t\t\tF2FS_MAX_LOG_SECTOR_SIZE ||\n\t\tle32_to_cpu(raw_super->log_sectorsize) <\n\t\t\t\tF2FS_MIN_LOG_SECTOR_SIZE) {\n\t\tf2fs_msg(sb, KERN_INFO, \"Invalid log sectorsize (%u)\",\n\t\t\tle32_to_cpu(raw_super->log_sectorsize));\n\t\treturn 1;\n\t}\n\tif (le32_to_cpu(raw_super->log_sectors_per_block) +\n\t\tle32_to_cpu(raw_super->log_sectorsize) !=\n\t\t\tF2FS_MAX_LOG_SECTOR_SIZE) {\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\"Invalid log sectors per block(%u) log sectorsize(%u)\",\n\t\t\tle32_to_cpu(raw_super->log_sectors_per_block),\n\t\t\tle32_to_cpu(raw_super->log_sectorsize));\n\t\treturn 1;\n\t}\n\n\t/* check reserved ino info */\n\tif (le32_to_cpu(raw_super->node_ino) != 1 ||\n\t\tle32_to_cpu(raw_super->meta_ino) != 2 ||\n\t\tle32_to_cpu(raw_super->root_ino) != 3) {\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\"Invalid Fs Meta Ino: node(%u) meta(%u) root(%u)\",\n\t\t\tle32_to_cpu(raw_super->node_ino),\n\t\t\tle32_to_cpu(raw_super->meta_ino),\n\t\t\tle32_to_cpu(raw_super->root_ino));\n\t\treturn 1;\n\t}\n\n\tif (le32_to_cpu(raw_super->segment_count) > F2FS_MAX_SEGMENT) {\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\"Invalid segment count (%u)\",\n\t\t\tle32_to_cpu(raw_super->segment_count));\n\t\treturn 1;\n\t}\n\n\t/* check CP/SIT/NAT/SSA/MAIN_AREA area boundary */\n\tif (sanity_check_area_boundary(sbi, bh))\n\t\treturn 1;\n\n\treturn 0;\n}", "target": 2, "idx": 11265}
{"commit_id": "b20ab6c7acb3be1393461eb650ca8fa4660c937e", "project": "pdfium", "func": "OPJ_BOOL opj_dwt_decode_real(opj_tcd_tilecomp_t* restrict tilec, OPJ_UINT32 numres)\n{\n\topj_v4dwt_t h;\n\topj_v4dwt_t v;\n\n\topj_tcd_resolution_t* res = tilec->resolutions;\n\n\tOPJ_UINT32 rw = (OPJ_UINT32)(res->x1 - res->x0);\t/* width of the resolution level computed */\n\tOPJ_UINT32 rh = (OPJ_UINT32)(res->y1 - res->y0);\t/* height of the resolution level computed */\n\n\tOPJ_UINT32 w = (OPJ_UINT32)(tilec->x1 - tilec->x0);\n\n\tOPJ_UINT32 mr = opj_dwt_max_resolution(res, numres);\n\n\tif (mr >= ((OPJ_UINT32)-5)) {\n\t\treturn OPJ_FALSE;\n\t}\n\tmr += 5;\n\n\tif (((OPJ_UINT32)-1) / (OPJ_UINT32)sizeof(opj_v4_t) < mr) {\n\t\treturn OPJ_FALSE;\n\t}\n\th.wavelet = (opj_v4_t*) opj_aligned_malloc(mr * sizeof(opj_v4_t));\n\tif (!h.wavelet) {\n\t\t/* FIXME event manager error callback */\n\t\treturn OPJ_FALSE;\n\t}\n\tv.wavelet = h.wavelet;\n\n\twhile( --numres) {\n\t\tOPJ_FLOAT32 * restrict aj = (OPJ_FLOAT32*) tilec->data;\n\t\tOPJ_UINT32 bufsize = (OPJ_UINT32)((tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0));\n\t\tOPJ_INT32 j;\n\n\t\th.sn = (OPJ_INT32)rw;\n\t\tv.sn = (OPJ_INT32)rh;\n\n\t\t++res;\n\n\t\trw = (OPJ_UINT32)(res->x1 - res->x0);\t/* width of the resolution level computed */\n\t\trh = (OPJ_UINT32)(res->y1 - res->y0);\t/* height of the resolution level computed */\n\n\t\th.dn = (OPJ_INT32)(rw - (OPJ_UINT32)h.sn);\n\t\th.cas = res->x0 % 2;\n\n\t\tfor(j = (OPJ_INT32)rh; j > 3; j -= 4) {\n\t\t\tOPJ_INT32 k;\n\t\t\topj_v4dwt_interleave_h(&h, aj, (OPJ_INT32)w, (OPJ_INT32)bufsize);\n\t\t\topj_v4dwt_decode(&h);\n\n\t\t\tfor(k = (OPJ_INT32)rw; --k >= 0;){\n\t\t\t\taj[k               ] = h.wavelet[k].f[0];\n\t\t\t\taj[k+(OPJ_INT32)w  ] = h.wavelet[k].f[1];\n\t\t\t\taj[k+(OPJ_INT32)w*2] = h.wavelet[k].f[2];\n\t\t\t\taj[k+(OPJ_INT32)w*3] = h.wavelet[k].f[3];\n\t\t\t}\n\n\t\t\taj += w*4;\n\t\t\tbufsize -= w*4;\n\t\t}\n\n\t\tif (rh & 0x03) {\n\t\t\tOPJ_INT32 k;\n\t\t\tj = rh & 0x03;\n\t\t\topj_v4dwt_interleave_h(&h, aj, (OPJ_INT32)w, (OPJ_INT32)bufsize);\n\t\t\topj_v4dwt_decode(&h);\n\t\t\tfor(k = (OPJ_INT32)rw; --k >= 0;){\n\t\t\t\tswitch(j) {\n\t\t\t\t\tcase 3: aj[k+(OPJ_INT32)w*2] = h.wavelet[k].f[2];\n\t\t\t\t\tcase 2: aj[k+(OPJ_INT32)w  ] = h.wavelet[k].f[1];\n\t\t\t\t\tcase 1: aj[k               ] = h.wavelet[k].f[0];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tv.dn = (OPJ_INT32)(rh - (OPJ_UINT32)v.sn);\n\t\tv.cas = res->y0 % 2;\n\n\t\taj = (OPJ_FLOAT32*) tilec->data;\n\t\tfor(j = (OPJ_INT32)rw; j > 3; j -= 4){\n\t\t\tOPJ_UINT32 k;\n\n\t\t\topj_v4dwt_interleave_v(&v, aj, (OPJ_INT32)w, 4);\n\t\t\topj_v4dwt_decode(&v);\n\n\t\t\tfor(k = 0; k < rh; ++k){\n\t\t\t\tmemcpy(&aj[k*w], &v.wavelet[k], 4 * sizeof(OPJ_FLOAT32));\n\t\t\t}\n\t\t\taj += 4;\n\t\t}\n\n\t\tif (rw & 0x03){\n\t\t\tOPJ_UINT32 k;\n\n\t\t\tj = rw & 0x03;\n\n\t\t\topj_v4dwt_interleave_v(&v, aj, (OPJ_INT32)w, j);\n\t\t\topj_v4dwt_decode(&v);\n\n\t\t\tfor(k = 0; k < rh; ++k){\n\t\t\t\tmemcpy(&aj[k*w], &v.wavelet[k], (size_t)j * sizeof(OPJ_FLOAT32));\n\t\t\t}\n\t\t}\n\t}\n\n\topj_aligned_free(h.wavelet);\n\treturn OPJ_TRUE;\n}", "target": 2, "idx": 11266}
{"commit_id": "94df772485c92866ca417d92137747b2e3b0a917", "project": "DaveGamble/cJSON", "func": "static const char *parse_string(cJSON *item,const char *str,const char **ep)\n{\n\tconst char *ptr=str+1,*end_ptr=str+1;char *ptr2;char *out;int len=0;unsigned uc,uc2;\n\tif (*str!='\\\"') {*ep=str;return 0;}\t/* not a string! */\n\n\twhile (*end_ptr!='\\\"' && *end_ptr && ++len)\n\t{\n\t    if (*end_ptr++ == '\\\\')\n\t    {\n\t\tif (*end_ptr == '\\0')\n\t\t{\n\t\t    /* prevent buffer overflow when last input character is a backslash */\n\t\t    return 0;\n\t\t}\n\t\tend_ptr++;\t/* Skip escaped quotes. */\n\t    }\n\t}\n\n\tout=(char*)cJSON_malloc(len+1);\t/* This is how long we need for the string, roughly. */\n\tif (!out) return 0;\n\titem->valuestring=out; /* assign here so out will be deleted during cJSON_Delete() later */\n\titem->type=cJSON_String;\n\t\n\tptr=str+1;ptr2=out;\n\twhile (ptr < end_ptr)\n\t{\n\t\tif (*ptr!='\\\\') *ptr2++=*ptr++;\n\t\telse\n\t\t{\n\t\t\tptr++;\n\t\t\tswitch (*ptr)\n\t\t\t{\n\t\t\t\tcase 'b': *ptr2++='\\b';\tbreak;\n\t\t\t\tcase 'f': *ptr2++='\\f';\tbreak;\n\t\t\t\tcase 'n': *ptr2++='\\n';\tbreak;\n\t\t\t\tcase 'r': *ptr2++='\\r';\tbreak;\n\t\t\t\tcase 't': *ptr2++='\\t';\tbreak;\n\t\t\t\tcase 'u':\t /* transcode utf16 to utf8. */\n\t\t\t\t\tuc=parse_hex4(ptr+1);ptr+=4;\t/* get the unicode char. */\n\t\t\t\t\tif (ptr >= end_ptr) {*ep=str;return 0;}\t/* invalid */\n\t\t\t\t\t\n\t\t\t\t\tif ((uc>=0xDC00 && uc<=0xDFFF) || uc==0)    {*ep=str;return 0;}\t/* check for invalid.   */\n\t\t\t\t\t\n\t\t\t\t\tif (uc>=0xD800 && uc<=0xDBFF)\t/* UTF16 surrogate pairs.\t*/\n\t\t\t\t\t{\n\t\t\t\t\t\tif (ptr+6 > end_ptr)    {*ep=str;return 0;}\t/* invalid */\n\t\t\t\t\t\tif (ptr[1]!='\\\\' || ptr[2]!='u')    {*ep=str;return 0;}\t/* missing second-half of surrogate.    */\n\t\t\t\t\t\tuc2=parse_hex4(ptr+3);ptr+=6;\n\t\t\t\t\t\tif (uc2<0xDC00 || uc2>0xDFFF)       {*ep=str;return 0;}\t/* invalid second-half of surrogate.    */\n\t\t\t\t\t\tuc=0x10000 + (((uc&0x3FF)<<10) | (uc2&0x3FF));\n\t\t\t\t\t}\n\n\t\t\t\t\tlen=4;if (uc<0x80) len=1;else if (uc<0x800) len=2;else if (uc<0x10000) len=3; ptr2+=len;\n\t\t\t\t\t\n\t\t\t\t\tswitch (len) {\n\t\t\t\t\t\tcase 4: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;\n\t\t\t\t\t\tcase 3: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;\n\t\t\t\t\t\tcase 2: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;\n\t\t\t\t\t\tcase 1: *--ptr2 =(uc | firstByteMark[len]);\n\t\t\t\t\t}\n\t\t\t\t\tptr2+=len;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:  *ptr2++=*ptr; break;\n\t\t\t}\n\t\t\tptr++;\n\t\t}\n\t}\n\t*ptr2=0;\n\tif (*ptr=='\\\"') ptr++;\n\treturn ptr;\n}", "target": 3, "idx": 11267}
{"commit_id": "142180c0e297ef500daf8328e7ea3020e33a3639", "project": "nextcloud/desktop", "func": "void WebEnginePage::setUrl(const QUrl &url) {\n    QWebEnginePage::setUrl(url);\n}", "target": 1, "idx": 11268}
{"commit_id": "4ec0ef3a82125efc36173062a50624550a900ae0", "project": "torvalds/linux", "func": "static int iowarrior_probe(struct usb_interface *interface,\n\t\t\t   const struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev(interface);\n\tstruct iowarrior *dev = NULL;\n\tstruct usb_host_interface *iface_desc;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tint i;\n\tint retval = -ENOMEM;\n\n\t/* allocate memory for our device state and initialize it */\n\tdev = kzalloc(sizeof(struct iowarrior), GFP_KERNEL);\n\tif (dev == NULL) {\n\t\tdev_err(&interface->dev, \"Out of memory\\n\");\n\t\treturn retval;\n\t}\n\n\tmutex_init(&dev->mutex);\n\n\tatomic_set(&dev->intr_idx, 0);\n\tatomic_set(&dev->read_idx, 0);\n\tspin_lock_init(&dev->intr_idx_lock);\n\tatomic_set(&dev->overflow_flag, 0);\n\tinit_waitqueue_head(&dev->read_wait);\n\tatomic_set(&dev->write_busy, 0);\n\tinit_waitqueue_head(&dev->write_wait);\n\n\tdev->udev = udev;\n\tdev->interface = interface;\n\n\tiface_desc = interface->cur_altsetting;\n\tdev->product_id = le16_to_cpu(udev->descriptor.idProduct);\n\n\tif (iface_desc->desc.bNumEndpoints < 1) {\n\t\tdev_err(&interface->dev, \"Invalid number of endpoints\\n\");\n\t\tretval = -EINVAL;\n\t\tgoto error;\n\t}\n\n\t/* set up the endpoint information */\n\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\n\t\tendpoint = &iface_desc->endpoint[i].desc;\n\n\t\tif (usb_endpoint_is_int_in(endpoint))\n\t\t\tdev->int_in_endpoint = endpoint;\n\t\tif (usb_endpoint_is_int_out(endpoint))\n\t\t\t/* this one will match for the IOWarrior56 only */\n\t\t\tdev->int_out_endpoint = endpoint;\n\t}\n\t/* we have to check the report_size often, so remember it in the endianness suitable for our machine */\n\tdev->report_size = usb_endpoint_maxp(dev->int_in_endpoint);\n\tif ((dev->interface->cur_altsetting->desc.bInterfaceNumber == 0) &&\n\t    (dev->product_id == USB_DEVICE_ID_CODEMERCS_IOW56))\n\t\t/* IOWarrior56 has wMaxPacketSize different from report size */\n\t\tdev->report_size = 7;\n\n\t/* create the urb and buffer for reading */\n\tdev->int_in_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!dev->int_in_urb) {\n\t\tdev_err(&interface->dev, \"Couldn't allocate interrupt_in_urb\\n\");\n\t\tgoto error;\n\t}\n\tdev->int_in_buffer = kmalloc(dev->report_size, GFP_KERNEL);\n\tif (!dev->int_in_buffer) {\n\t\tdev_err(&interface->dev, \"Couldn't allocate int_in_buffer\\n\");\n\t\tgoto error;\n\t}\n\tusb_fill_int_urb(dev->int_in_urb, dev->udev,\n\t\t\t usb_rcvintpipe(dev->udev,\n\t\t\t\t\tdev->int_in_endpoint->bEndpointAddress),\n\t\t\t dev->int_in_buffer, dev->report_size,\n\t\t\t iowarrior_callback, dev,\n\t\t\t dev->int_in_endpoint->bInterval);\n\t/* create an internal buffer for interrupt data from the device */\n\tdev->read_queue =\n\t    kmalloc(((dev->report_size + 1) * MAX_INTERRUPT_BUFFER),\n\t\t    GFP_KERNEL);\n\tif (!dev->read_queue) {\n\t\tdev_err(&interface->dev, \"Couldn't allocate read_queue\\n\");\n\t\tgoto error;\n\t}\n\t/* Get the serial-number of the chip */\n\tmemset(dev->chip_serial, 0x00, sizeof(dev->chip_serial));\n\tusb_string(udev, udev->descriptor.iSerialNumber, dev->chip_serial,\n\t\t   sizeof(dev->chip_serial));\n\tif (strlen(dev->chip_serial) != 8)\n\t\tmemset(dev->chip_serial, 0x00, sizeof(dev->chip_serial));\n\n\t/* Set the idle timeout to 0, if this is interface 0 */\n\tif (dev->interface->cur_altsetting->desc.bInterfaceNumber == 0) {\n\t    usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t    0x0A,\n\t\t\t    USB_TYPE_CLASS | USB_RECIP_INTERFACE, 0,\n\t\t\t    0, NULL, 0, USB_CTRL_SET_TIMEOUT);\n\t}\n\t/* allow device read and ioctl */\n\tdev->present = 1;\n\n\t/* we can register the device now, as it is ready */\n\tusb_set_intfdata(interface, dev);\n\n\tretval = usb_register_dev(interface, &iowarrior_class);\n\tif (retval) {\n\t\t/* something prevented us from registering this driver */\n\t\tdev_err(&interface->dev, \"Not able to get a minor for this device.\\n\");\n\t\tusb_set_intfdata(interface, NULL);\n\t\tgoto error;\n\t}\n\n\tdev->minor = interface->minor;\n\n\t/* let the user know what node this device is now attached to */\n\tdev_info(&interface->dev, \"IOWarrior product=0x%x, serial=%s interface=%d \"\n\t\t \"now attached to iowarrior%d\\n\", dev->product_id, dev->chip_serial,\n\t\t iface_desc->desc.bInterfaceNumber, dev->minor - IOWARRIOR_MINOR_BASE);\n\treturn retval;\n\nerror:\n\tiowarrior_delete(dev);\n\treturn retval;\n}", "target": 1, "idx": 11269}
{"commit_id": "ee9166eb3b41846661a39b662dc7ebe8b5e15139", "project": "vim", "func": "static int\nins_compl_get_exp(pos_T *ini)\n{\n    static ins_compl_next_state_T   st;\n    static int\t\t\t    st_cleared = FALSE;\n    int\t\ti;\n    int\t\tfound_new_match;\n    int\t\ttype = ctrl_x_mode;\n\n    if (!compl_started)\n    {\n\tbuf_T *buf;\n\n\tFOR_ALL_BUFFERS(buf)\n\t    buf->b_scanned = 0;\n\tif (!st_cleared)\n\t{\n\t    CLEAR_FIELD(st);\n\t    st_cleared = TRUE;\n\t}\n\tst.found_all = FALSE;\n\tst.ins_buf = curbuf;\n\tvim_free(st.e_cpt_copy);\n\t// Make a copy of 'complete', if case the buffer is wiped out.\n\tst.e_cpt_copy = vim_strsave((compl_cont_status & CONT_LOCAL)\n\t\t\t\t\t    ? (char_u *)\".\" : curbuf->b_p_cpt);\n\tst.e_cpt = st.e_cpt_copy == NULL ? (char_u *)\"\" : st.e_cpt_copy;\n\tst.last_match_pos = st.first_match_pos = *ini;\n    }\n    else if (st.ins_buf != curbuf && !buf_valid(st.ins_buf))\n\tst.ins_buf = curbuf;  // In case the buffer was wiped out.\n\n    compl_old_match = compl_curr_match;\t// remember the last current match\n    st.cur_match_pos = (compl_dir_forward())\n\t\t\t\t? &st.last_match_pos : &st.first_match_pos;\n\n    // For ^N/^P loop over all the flags/windows/buffers in 'complete'.\n    for (;;)\n    {\n\tfound_new_match = FAIL;\n\tst.set_match_pos = FALSE;\n\n\t// For ^N/^P pick a new entry from e_cpt if compl_started is off,\n\t// or if found_all says this entry is done.  For ^X^L only use the\n\t// entries from 'complete' that look in loaded buffers.\n\tif ((ctrl_x_mode_normal() || ctrl_x_mode_line_or_eval())\n\t\t\t\t\t&& (!compl_started || st.found_all))\n\t{\n\t    int status = process_next_cpt_value(&st, &type, ini);\n\n\t    if (status == INS_COMPL_CPT_END)\n\t\tbreak;\n\t    if (status == INS_COMPL_CPT_CONT)\n\t\tcontinue;\n\t}\n\n\t// If complete() was called then compl_pattern has been reset.  The\n\t// following won't work then, bail out.\n\tif (compl_pattern == NULL)\n\t    break;\n\n\t// get the next set of completion matches\n\tfound_new_match = get_next_completion_match(type, &st, ini);\n\n\t// break the loop for specialized modes (use 'complete' just for the\n\t// generic ctrl_x_mode == CTRL_X_NORMAL) or when we've found a new\n\t// match\n\tif ((ctrl_x_mode_not_default() && !ctrl_x_mode_line_or_eval())\n\t\t\t\t\t\t|| found_new_match != FAIL)\n\t{\n\t    if (got_int)\n\t\tbreak;\n\t    // Fill the popup menu as soon as possible.\n\t    if (type != -1)\n\t\tins_compl_check_keys(0, FALSE);\n\n\t    if ((ctrl_x_mode_not_default()\n\t\t\t&& !ctrl_x_mode_line_or_eval()) || compl_interrupted)\n\t\tbreak;\n\t    compl_started = TRUE;\n\t}\n\telse\n\t{\n\t    // Mark a buffer scanned when it has been scanned completely\n\t    if (buf_valid(st.ins_buf) && (type == 0 || type == CTRL_X_PATH_PATTERNS))\n\t\tst.ins_buf->b_scanned = TRUE;\n\n\t    compl_started = FALSE;\n\t}\n    }\n    compl_started = TRUE;\n\n    if ((ctrl_x_mode_normal() || ctrl_x_mode_line_or_eval())\n\t    && *st.e_cpt == NUL)\t\t// Got to end of 'complete'\n\tfound_new_match = FAIL;\n\n    i = -1;\t\t// total of matches, unknown\n    if (found_new_match == FAIL || (ctrl_x_mode_not_default()\n\t\t\t\t\t       && !ctrl_x_mode_line_or_eval()))\n\ti = ins_compl_make_cyclic();\n\n    if (compl_old_match != NULL)\n    {\n\t// If several matches were added (FORWARD) or the search failed and has\n\t// just been made cyclic then we have to move compl_curr_match to the\n\t// next or previous entry (if any) -- Acevedo\n\tcompl_curr_match = compl_dir_forward() ? compl_old_match->cp_next\n\t\t\t\t\t\t    : compl_old_match->cp_prev;\n\tif (compl_curr_match == NULL)\n\t    compl_curr_match = compl_old_match;\n    }\n    may_trigger_modechanged();\n\n    return i;\n}", "target": 2, "idx": 11270}
{"commit_id": "a014f4c224a7b21f1c648257d1fd1128413129aa", "project": "PowerDNS/pdns", "func": "int AXFRRetriever::getChunk(Resolver::res_t &res) // Implementation is making sure RFC2845 4.4 is followed.\n{\n  if(d_soacount > 1)\n    return false;\n\n  // d_sock is connected and is about to spit out a packet\n  int len=getLength();\n  if(len<0)\n    throw ResolverException(\"EOF trying to read axfr chunk from remote TCP client\");\n\n  if (d_maxReceivedBytes > 0 && (d_maxReceivedBytes - d_receivedBytes) < (size_t) len)\n    throw ResolverException(\"Reached the maximum number of received bytes during AXFR\");\n\n  timeoutReadn(len);\n\n  d_receivedBytes += (uint16_t) len;\n\n  MOADNSParser mdp(d_buf.get(), len);\n\n  int err = parseResult(mdp, \"\", 0, 0, &res);\n  if(err) \n    throw ResolverException(\"AXFR chunk error: \" + RCode::to_s(err));\n\n  BOOST_FOREACH(const MOADNSParser::answers_t::value_type& answer, mdp.d_answers)\n    if (answer.first.d_type == QType::SOA)\n      d_soacount++;\n \n  if(!d_tsigkeyname.empty()) { // TSIG verify message\n    // If we have multiple messages, we need to concatenate them together. We also need to make sure we know the location of \n    // the TSIG record so we can remove it in makeTSIGMessageFromTSIGPacket\n    d_signData.append(d_buf.get(), len);\n    if (mdp.getTSIGPos() == 0)\n      d_tsigPos += len;\n    else \n      d_tsigPos += mdp.getTSIGPos();\n\n    string theirMac;\n    bool checkTSIG = false;\n    \n    BOOST_FOREACH(const MOADNSParser::answers_t::value_type& answer, mdp.d_answers) {\n      if (answer.first.d_type == QType::SOA)  // A SOA is either the first or the last record. We need to check TSIG if that's the case.\n        checkTSIG = true;\n      \n      if(answer.first.d_type == QType::TSIG) {\n        shared_ptr<TSIGRecordContent> trc = boost::dynamic_pointer_cast<TSIGRecordContent>(answer.first.d_content);\n        theirMac = trc->d_mac;\n        d_trc.d_time = trc->d_time;\n        checkTSIG = true;\n      }\n    }\n\n    if( ! checkTSIG && d_nonSignedMessages > 99) { // We're allowed to get 100 digest without a TSIG.\n      throw ResolverException(\"No TSIG message received in last 100 messages of AXFR transfer.\");\n    }\n\n    if (checkTSIG) {\n      if (theirMac.empty())\n        throw ResolverException(\"No TSIG on AXFR response from \"+d_remote.toStringWithPort()+\" , should be signed with TSIG key '\"+d_tsigkeyname+\"'\");\n\n      string message;\n      if (!d_prevMac.empty()) {\n        message = makeTSIGMessageFromTSIGPacket(d_signData, d_tsigPos, d_tsigkeyname, d_trc, d_prevMac, true, d_signData.size()-len);\n      } else {\n        message = makeTSIGMessageFromTSIGPacket(d_signData, d_tsigPos, d_tsigkeyname, d_trc, d_trc.d_mac, false);\n      }\n\n      TSIGHashEnum algo;\n      if (!getTSIGHashEnum(d_trc.d_algoName, algo)) {\n        throw ResolverException(\"Unsupported TSIG HMAC algorithm \" + d_trc.d_algoName);\n      }\n\n      string ourMac=calculateHMAC(d_tsigsecret, message, algo);\n\n      // ourMac[0]++; // sabotage == for testing :-)\n      if(ourMac != theirMac) {\n        throw ResolverException(\"Signature failed to validate on AXFR response from \"+d_remote.toStringWithPort()+\" signed with TSIG key '\"+d_tsigkeyname+\"'\");\n      }\n\n      // Reset and store some values for the next chunks. \n      d_prevMac = theirMac;\n      d_nonSignedMessages = 0;\n      d_signData.clear();\n      d_tsigPos = 0;\n    }\n    else\n      d_nonSignedMessages++;\n  }\n  \n  return true;\n}", "target": 1, "idx": 11271}
{"commit_id": "64105057d03df64841e3aaaaf05e84c069969f55", "project": "libtiff", "func": "static uint16_t countInkNamesString(TIFF *tif, uint32_t slen, const char *s)\n{\n    uint16_t i = 0;\n\n    if (slen > 0)\n    {\n        const char *ep = s + slen;\n        const char *cp = s;\n        do\n        {\n            for (; cp < ep && *cp != '\\0'; cp++)\n            {\n            }\n            if (cp >= ep)\n                goto bad;\n            cp++; /* skip \\0 */\n            i++;\n        } while (cp < ep);\n        return (i);\n    }\nbad:\n    TIFFErrorExtR(tif, \"TIFFSetField\",\n                  \"%s: Invalid InkNames value; no NUL at given buffer end \"\n                  \"location %\" PRIu32 \", after %\" PRIu16 \" ink\",\n                  tif->tif_name, slen, i);\n    return (0);\n}", "target": 1, "idx": 11272}
{"commit_id": "055e547478a11a6360c7ce05e2afc3e366968a12", "project": "torvalds/linux", "func": "struct clock_source *dce80_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\n\tif (!clk_src)\n\t\treturn NULL;\n\n\tif (dce110_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\n\tkfree(clk_src);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 1, "idx": 11273}
{"commit_id": "40d373ede795443ae6f2f756e9fb1f4f4ae90bbe", "project": "wireapp/wire-avs", "func": "int audio_level_json(struct list *levell,\n\t\t     const char *userid_self, const char *clientid_self,\n\t\t     char **json_str, char **anon_str)\n{\n\tstruct json_object *jobj;\n\tstruct json_object *jarr;\n\tchar uid_anon[ANON_ID_LEN];\n\tchar cid_anon[ANON_CLIENT_LEN];\n\tstruct mbuf *pmb = NULL;\n\tint err = 0;\n\tstruct le *le;\n\n\tif (!levell || !json_str)\n\t\treturn EINVAL;\n\t\n\tjobj = jzon_alloc_object();\n\tif (!jobj)\n\t\treturn ENOMEM;\n\n\tjarr = jzon_alloc_array();\n\tif (!jarr) {\n\t\terr = ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (anon_str) {\n\t\tpmb = mbuf_alloc(512);\n\t\tmbuf_printf(pmb, \"%zu levels: \", list_count(levell));\n\t}\n\t\n\tLIST_FOREACH(levell, le) {\n\t\tstruct audio_level *a = le->data;\n\t\tstruct json_object *ja;\n\t\tconst char *userid = a->userid;\n\t\tconst char *clientid = a->clientid;\n\n\t\tif (a->is_self) {\n\t\t\tif (userid_self)\n\t\t\t\tuserid = userid_self;\n\t\t\tif (clientid_self)\n\t\t\t\tclientid = clientid_self;\n\t\t}\n\n\t\tja = jzon_alloc_object();\n\t\tif (ja) {\n\t\t\tjzon_add_str(ja, \"userid\", \"%s\", userid);\n\t\t\tjzon_add_str(ja, \"clientid\", \"%s\", clientid);\n\t\t\tjzon_add_int(ja, \"audio_level\",\n\t\t\t\t     (int32_t)a->aulevel_smooth);\n\t\t\tjzon_add_int(ja, \"audio_level_now\",\n\t\t\t\t     (int32_t)a->aulevel);\n\t\t}\n\t\tjson_object_array_add(jarr, ja);\n\n\t\t/* add to info string */\n\t\tif (pmb) {\n\t\t\tanon_id(uid_anon, userid);\n\t\t\tanon_client(cid_anon, clientid);\n\t\t\tmbuf_printf(pmb, \"{[%s.%s] audio_level: %d/%d}\",\n\t\t\t\t    uid_anon, cid_anon,\n\t\t\t\t    a->aulevel_smooth, a->aulevel);\n\t\t\tif (le != levell->tail)\n\t\t\t\tmbuf_printf(pmb, \",\");\n\t\t}\t\t\n\t}\n\tjson_object_object_add(jobj, \"audio_levels\", jarr);\n\n\tif (pmb) {\n\t\tpmb->pos = 0;\n\t\tmbuf_strdup(pmb, anon_str, pmb->end);\n\t\tmem_deref(pmb);\n\t}\n\n\tjzon_encode(json_str, jobj);\n out:\t\n\tmem_deref(jobj);\n\n\treturn err;\n}", "target": 3, "idx": 11274}
{"commit_id": "7404a914b0cafe046703c8381903a80d3def8f8b", "project": "FRRouting/frr", "func": "int bgp_nlri_parse_label(struct peer *peer, struct attr *attr,\n\t\t\t struct bgp_nlri *packet)\n{\n\tuint8_t *pnt;\n\tuint8_t *lim;\n\tstruct prefix p;\n\tint psize = 0;\n\tint prefixlen;\n\tafi_t afi;\n\tsafi_t safi;\n\tbool addpath_capable;\n\tuint32_t addpath_id;\n\tmpls_label_t label = MPLS_INVALID_LABEL;\n\tuint8_t llen;\n\n\tpnt = packet->nlri;\n\tlim = pnt + packet->length;\n\tafi = packet->afi;\n\tsafi = packet->safi;\n\taddpath_id = 0;\n\n\taddpath_capable = bgp_addpath_encode_rx(peer, afi, safi);\n\n\tfor (; pnt < lim; pnt += psize) {\n\t\t/* Clear prefix structure. */\n\t\tmemset(&p, 0, sizeof(p));\n\n\t\tif (addpath_capable) {\n\n\t\t\t/* When packet overflow occurs return immediately. */\n\t\t\tif (pnt + BGP_ADDPATH_ID_LEN > lim)\n\t\t\t\treturn BGP_NLRI_PARSE_ERROR_PACKET_OVERFLOW;\n\n\t\t\tmemcpy(&addpath_id, pnt, BGP_ADDPATH_ID_LEN);\n\t\t\taddpath_id = ntohl(addpath_id);\n\t\t\tpnt += BGP_ADDPATH_ID_LEN;\n\n\t\t\tif (pnt >= lim)\n\t\t\t\treturn BGP_NLRI_PARSE_ERROR_PACKET_OVERFLOW;\n\t\t}\n\n\t\t/* Fetch prefix length. */\n\t\tprefixlen = *pnt++;\n\t\tp.family = afi2family(packet->afi);\n\t\tpsize = PSIZE(prefixlen);\n\n\t\t/* sanity check against packet data */\n\t\tif ((pnt + psize) > lim) {\n\t\t\tflog_err(\n\t\t\t\tEC_BGP_UPDATE_RCV,\n\t\t\t\t\"%s [Error] Update packet error / L-U (prefix length %d exceeds packet size %u)\",\n\t\t\t\tpeer->host, prefixlen, (uint)(lim - pnt));\n\t\t\treturn BGP_NLRI_PARSE_ERROR_PACKET_OVERFLOW;\n\t\t}\n\n\t\t/* Fill in the labels */\n\t\tllen = bgp_nlri_get_labels(peer, pnt, psize, &label);\n\t\tif (llen == 0) {\n\t\t\tflog_err(\n\t\t\t\tEC_BGP_UPDATE_RCV,\n\t\t\t\t\"%s [Error] Update packet error (wrong label length 0)\",\n\t\t\t\tpeer->host);\n\t\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\tBGP_NOTIFY_UPDATE_INVAL_NETWORK);\n\t\t\treturn BGP_NLRI_PARSE_ERROR_LABEL_LENGTH;\n\t\t}\n\t\tp.prefixlen = prefixlen - BSIZE(llen);\n\n\t\t/* There needs to be at least one label */\n\t\tif (prefixlen < 24) {\n\t\t\tflog_err(EC_BGP_UPDATE_RCV,\n\t\t\t\t \"%s [Error] Update packet error (wrong label length %d)\",\n\t\t\t\t peer->host, prefixlen);\n\t\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\tBGP_NOTIFY_UPDATE_INVAL_NETWORK);\n\t\t\treturn BGP_NLRI_PARSE_ERROR_LABEL_LENGTH;\n\t\t}\n\n\t\tif ((afi == AFI_IP && p.prefixlen > IPV4_MAX_BITLEN)\n\t\t    || (afi == AFI_IP6 && p.prefixlen > IPV6_MAX_BITLEN))\n\t\t\treturn BGP_NLRI_PARSE_ERROR_PREFIX_LENGTH;\n\n\t\t/* Fetch prefix from NLRI packet */\n\t\tmemcpy(&p.u.prefix, pnt + llen, psize - llen);\n\n\t\t/* Check address. */\n\t\tif (afi == AFI_IP && safi == SAFI_LABELED_UNICAST) {\n\t\t\tif (IN_CLASSD(ntohl(p.u.prefix4.s_addr))) {\n\t\t\t\t/* From RFC4271 Section 6.3:\n\t\t\t\t *\n\t\t\t\t * If a prefix in the NLRI field is semantically\n\t\t\t\t * incorrect\n\t\t\t\t * (e.g., an unexpected multicast IP address),\n\t\t\t\t * an error SHOULD\n\t\t\t\t * be logged locally, and the prefix SHOULD be\n\t\t\t\t * ignored.\n\t\t\t\t  */\n\t\t\t\tflog_err(\n\t\t\t\t\tEC_BGP_UPDATE_RCV,\n\t\t\t\t\t\"%s: IPv4 labeled-unicast NLRI is multicast address %pI4, ignoring\",\n\t\t\t\t\tpeer->host, &p.u.prefix4);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* Check address. */\n\t\tif (afi == AFI_IP6 && safi == SAFI_LABELED_UNICAST) {\n\t\t\tif (IN6_IS_ADDR_LINKLOCAL(&p.u.prefix6)) {\n\t\t\t\tflog_err(\n\t\t\t\t\tEC_BGP_UPDATE_RCV,\n\t\t\t\t\t\"%s: IPv6 labeled-unicast NLRI is link-local address %pI6, ignoring\",\n\t\t\t\t\tpeer->host, &p.u.prefix6);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (IN6_IS_ADDR_MULTICAST(&p.u.prefix6)) {\n\t\t\t\tflog_err(\n\t\t\t\t\tEC_BGP_UPDATE_RCV,\n\t\t\t\t\t\"%s: IPv6 unicast NLRI is multicast address %pI6, ignoring\",\n\t\t\t\t\tpeer->host, &p.u.prefix6);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (attr) {\n\t\t\tbgp_update(peer, &p, addpath_id, attr, packet->afi,\n\t\t\t\t   safi, ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL,\n\t\t\t\t   NULL, &label, 1, 0, NULL);\n\t\t} else {\n\t\t\tbgp_withdraw(peer, &p, addpath_id, packet->afi,\n\t\t\t\t     SAFI_UNICAST, ZEBRA_ROUTE_BGP,\n\t\t\t\t     BGP_ROUTE_NORMAL, NULL, &label, 1, NULL);\n\t\t}\n\t}\n\n\t/* Packet length consistency check. */\n\tif (pnt != lim) {\n\t\tflog_err(\n\t\t\tEC_BGP_UPDATE_RCV,\n\t\t\t\"%s [Error] Update packet error / L-U (%td data remaining after parsing)\",\n\t\t\tpeer->host, lim - pnt);\n\t\treturn BGP_NLRI_PARSE_ERROR_PACKET_LENGTH;\n\t}\n\n\treturn BGP_NLRI_PARSE_OK;\n}", "target": 2, "idx": 11275}
{"commit_id": "14e606db148d6ebcaae20f1e1d6d71903ca4a556", "project": "ImageMagick", "func": "static MagickBooleanType WriteHDRImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  char\n    header[MagickPathExtent];\n\n  const char\n    *property;\n\n  MagickBooleanType\n    status;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    pixel[4],\n    *pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  if (IsRGBColorspace(image->colorspace) == MagickFalse)\n    (void) TransformImageColorspace(image,RGBColorspace,exception);\n  /*\n    Write header.\n  */\n  (void) ResetMagickMemory(header,' ',MagickPathExtent);\n  length=CopyMagickString(header,\"#?RGBE\\n\",MagickPathExtent);\n  (void) WriteBlob(image,length,(unsigned char *) header);\n  property=GetImageProperty(image,\"comment\",exception);\n  if ((property != (const char *) NULL) &&\n      (strchr(property,'\\n') == (char *) NULL))\n    {\n      count=FormatLocaleString(header,MagickPathExtent,\"#%s\\n\",property);\n      (void) WriteBlob(image,(size_t) count,(unsigned char *) header);\n    }\n  property=GetImageProperty(image,\"hdr:exposure\",exception);\n  if (property != (const char *) NULL)\n    {\n      count=FormatLocaleString(header,MagickPathExtent,\"EXPOSURE=%g\\n\",\n        strtod(property,(char **) NULL));\n      (void) WriteBlob(image,(size_t) count,(unsigned char *) header);\n    }\n  if (image->gamma != 0.0)\n    {\n      count=FormatLocaleString(header,MagickPathExtent,\"GAMMA=%g\\n\",\n        image->gamma);\n      (void) WriteBlob(image,(size_t) count,(unsigned char *) header);\n    }\n  count=FormatLocaleString(header,MagickPathExtent,\n    \"PRIMARIES=%g %g %g %g %g %g %g %g\\n\",\n    image->chromaticity.red_primary.x,image->chromaticity.red_primary.y,\n    image->chromaticity.green_primary.x,image->chromaticity.green_primary.y,\n    image->chromaticity.blue_primary.x,image->chromaticity.blue_primary.y,\n    image->chromaticity.white_point.x,image->chromaticity.white_point.y);\n  (void) WriteBlob(image,(size_t) count,(unsigned char *) header);\n  length=CopyMagickString(header,\"FORMAT=32-bit_rle_rgbe\\n\\n\",MagickPathExtent);\n  (void) WriteBlob(image,length,(unsigned char *) header);\n  count=FormatLocaleString(header,MagickPathExtent,\"-Y %.20g +X %.20g\\n\",\n    (double) image->rows,(double) image->columns);\n  (void) WriteBlob(image,(size_t) count,(unsigned char *) header);\n  /*\n    Write HDR pixels.\n  */\n  pixels=(unsigned char *) AcquireQuantumMemory(image->columns+128,4*\n    sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(pixels,0,4*(image->columns+128)*sizeof(*pixels));\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    if ((image->columns >= 8) && (image->columns <= 0x7ffff))\n      {\n        pixel[0]=2;\n        pixel[1]=2;\n        pixel[2]=(unsigned char) (image->columns >> 8);\n        pixel[3]=(unsigned char) (image->columns & 0xff);\n        count=WriteBlob(image,4*sizeof(*pixel),pixel);\n        if (count != (ssize_t) (4*sizeof(*pixel)))\n          break;\n      }\n    i=0;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        gamma;\n\n      pixel[0]=0;\n      pixel[1]=0;\n      pixel[2]=0;\n      pixel[3]=0;\n      gamma=QuantumScale*GetPixelRed(image,p);\n      if ((QuantumScale*GetPixelGreen(image,p)) > gamma)\n        gamma=QuantumScale*GetPixelGreen(image,p);\n      if ((QuantumScale*GetPixelBlue(image,p)) > gamma)\n        gamma=QuantumScale*GetPixelBlue(image,p);\n      if (gamma > MagickEpsilon)\n        {\n          int\n            exponent;\n\n          gamma=frexp(gamma,&exponent)*256.0/gamma;\n          pixel[0]=(unsigned char) (gamma*QuantumScale*GetPixelRed(image,p));\n          pixel[1]=(unsigned char) (gamma*QuantumScale*GetPixelGreen(image,p));\n          pixel[2]=(unsigned char) (gamma*QuantumScale*GetPixelBlue(image,p));\n          pixel[3]=(unsigned char) (exponent+128);\n        }\n      if ((image->columns >= 8) && (image->columns <= 0x7ffff))\n        {\n          pixels[x]=pixel[0];\n          pixels[x+image->columns]=pixel[1];\n          pixels[x+2*image->columns]=pixel[2];\n          pixels[x+3*image->columns]=pixel[3];\n        }\n      else\n        {\n          pixels[i++]=pixel[0];\n          pixels[i++]=pixel[1];\n          pixels[i++]=pixel[2];\n          pixels[i++]=pixel[3];\n        }\n      p+=GetPixelChannels(image);\n    }\n    if ((image->columns >= 8) && (image->columns <= 0x7ffff))\n      {\n        for (i=0; i < 4; i++)\n          length=HDRWriteRunlengthPixels(image,&pixels[i*image->columns]);\n      }\n    else\n      {\n        count=WriteBlob(image,4*image->columns*sizeof(*pixels),pixels);\n        if (count != (ssize_t) (4*image->columns*sizeof(*pixels)))\n          break;\n      }\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}", "target": 1, "idx": 11276}
{"commit_id": "74fafb7f11b06747f69f182ad5e3769b665eea7a", "project": "inspircd", "func": "CommandAuthenticate(Module* Creator, SimpleExtItem<SaslAuthenticator>& ext, GenericCap& Cap)\n\t\t: Command(Creator, \"AUTHENTICATE\", 1), authExt(ext), cap(Cap)\n\t{\n\t\tworks_before_reg = true;\n\t\tallow_empty_last_param = false;\n\t}", "target": 1, "idx": 11277}
{"commit_id": "73615161c01fcfbbc7216cf502cabb12c1598ee4", "project": "RIOT-OS/RIOT", "func": "void gnrc_sixlowpan_iphc_recv(gnrc_pktsnip_t *sixlo, void *rbuf_ptr,\n                              unsigned page)\n{\n    assert(sixlo != NULL);\n    gnrc_pktsnip_t *ipv6, *netif;\n    gnrc_netif_t *iface;\n    ipv6_hdr_t *ipv6_hdr;\n    uint8_t *iphc_hdr = sixlo->data;\n    size_t payload_offset;\n    size_t uncomp_hdr_len = sizeof(ipv6_hdr_t);\n    gnrc_sixlowpan_frag_rb_t *rbuf = rbuf_ptr;\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_VRB\n    gnrc_sixlowpan_frag_vrb_t *vrbe = NULL;\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_VRB */\n\n    if (rbuf != NULL) {\n        ipv6 = rbuf->pkt;\n        assert(ipv6 != NULL);\n        if ((ipv6->size < sizeof(ipv6_hdr_t)) &&\n            (gnrc_pktbuf_realloc_data(ipv6, sizeof(ipv6_hdr_t)) != 0)) {\n            DEBUG(\"6lo iphc: no space to decompress IPHC\\n\");\n            _recv_error_release(sixlo, ipv6, rbuf);\n            return;\n        }\n    }\n    else {\n        ipv6 = gnrc_pktbuf_add(NULL, NULL, sizeof(ipv6_hdr_t),\n                               GNRC_NETTYPE_IPV6);\n        if (ipv6 == NULL) {\n            gnrc_pktbuf_release(sixlo);\n            return;\n        }\n    }\n\n    assert(ipv6->size >= sizeof(ipv6_hdr_t));\n\n    netif = gnrc_pktsnip_search_type(sixlo, GNRC_NETTYPE_NETIF);\n    assert(netif != NULL);\n    iface = gnrc_netif_hdr_get_netif(netif->data);\n    payload_offset = _iphc_ipv6_decode(iphc_hdr, netif->data, iface,\n                                       ipv6->data);\n    if (payload_offset == 0) {\n        /* unable to parse IPHC header */\n        _recv_error_release(sixlo, ipv6, rbuf);\n        return;\n    }\n#ifdef MODULE_GNRC_SIXLOWPAN_IPHC_NHC\n    if (iphc_hdr[IPHC1_IDX] & SIXLOWPAN_IPHC1_NH) {\n        bool nhc_header = true;\n        ipv6_hdr = ipv6->data;\n        size_t prev_nh_offset = (&ipv6_hdr->nh) - ((uint8_t *)ipv6->data);\n\n        while (nhc_header) {\n            switch (iphc_hdr[payload_offset] & NHC_ID_MASK) {\n                case NHC_IPV6_EXT_ID:\n                case NHC_IPV6_EXT_ID_ALT:\n                    payload_offset = _iphc_nhc_ipv6_decode(sixlo,\n                                                           payload_offset,\n                                                           rbuf,\n                                                           &prev_nh_offset,\n                                                           ipv6,\n                                                           &uncomp_hdr_len);\n                    if (payload_offset == 0) {\n                        _recv_error_release(sixlo, ipv6, rbuf);\n                        return;\n                    }\n                    /* prev_nh_offset is set to 0 if next header is not\n                     * compressed (== NH flag in compression header not set) */\n                    nhc_header = (prev_nh_offset > 0);\n                    break;\n                case NHC_UDP_ID: {\n                    payload_offset = _iphc_nhc_udp_decode(sixlo,\n                                                          payload_offset,\n                                                          rbuf,\n                                                          prev_nh_offset,\n                                                          ipv6,\n                                                          &uncomp_hdr_len);\n                    if (payload_offset == 0) {\n                        _recv_error_release(sixlo, ipv6, rbuf);\n                        return;\n                    }\n                    /* no NHC after UDP header */\n                    nhc_header = false;\n                    break;\n                }\n                default:\n                    nhc_header = false;\n                    break;\n            }\n        }\n    }\n#endif\n    uint16_t payload_len;\n    if (rbuf != NULL) {\n        /* for a fragmented datagram we know the overall length already */\n        if (_is_rfrag(sixlo)) {\n            DEBUG(\"6lo iphc: calculating payload length for SFR\\n\");\n            DEBUG(\" - rbuf->super.datagram_size: %u\\n\",\n                  rbuf->super.datagram_size);\n            DEBUG(\" - payload_offset: %u\\n\", (unsigned)payload_offset);\n            DEBUG(\" - uncomp_hdr_len: %u\\n\", (unsigned)uncomp_hdr_len);\n            /* set IPv6 header payload length field to the length of whatever is\n             * left after removing the 6LoWPAN header and adding uncompressed\n             * headers */\n            payload_len = (rbuf->super.datagram_size - payload_offset) +\n                          (uncomp_hdr_len - sizeof(ipv6_hdr_t));\n            DEBUG(\"   => %u\\n\", payload_len);\n            /* adapt datagram size for uncompressed datagram */\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_SFR\n            /* guard required because SFR-specific field of vrbe is accessed */\n            rbuf->offset_diff += (uncomp_hdr_len - payload_offset);\n            rbuf->super.datagram_size += rbuf->offset_diff;\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_VRB */\n        }\n        else {\n            /* for a fragmented datagram we know the overall length already */\n            payload_len = (uint16_t)(rbuf->super.datagram_size - sizeof(ipv6_hdr_t));\n        }\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_VRB\n        DEBUG(\"6lo iphc: VRB present, trying to create entry for dst %s\\n\",\n              ipv6_addr_to_str(addr_str, &ipv6_hdr->dst, sizeof(addr_str)));\n        /* re-assign IPv6 header in case realloc changed the address */\n        ipv6_hdr = ipv6->data;\n        /* only create virtual reassembly buffer entry from IPv6 destination if\n         * the current first fragment is the only received fragment in the\n         * reassembly buffer so far and the hop-limit is larger than 1\n         */\n        if ((rbuf->super.current_size <= sixlo->size) && (ipv6_hdr->hl > 1U) &&\n            /* and there is enough slack for changing compression */\n            (rbuf->super.current_size <= iface->sixlo.max_frag_size) &&\n            (vrbe = gnrc_sixlowpan_frag_vrb_from_route(&rbuf->super, iface,\n                                                       ipv6))) {\n            /* add netif header to `ipv6` so its flags can be used when\n             * forwarding the fragment */\n            sixlo = gnrc_pkt_delete(sixlo, netif);\n            ipv6 = gnrc_pkt_append(ipv6, netif);\n            /* provide space to copy remaining payload */\n            if (gnrc_pktbuf_realloc_data(ipv6, uncomp_hdr_len + sixlo->size -\n                                         payload_offset) != 0) {\n                DEBUG(\"6lo iphc: no space left to copy payload\\n\");\n                gnrc_sixlowpan_frag_vrb_rm(vrbe);\n                _recv_error_release(sixlo, ipv6, rbuf);\n                return;\n            }\n        }\n        /* reallocate to copy complete payload */\n        else if (gnrc_pktbuf_realloc_data(ipv6, rbuf->super.datagram_size) != 0) {\n            DEBUG(\"6lo iphc: no space left to reassemble payload\\n\");\n            _recv_error_release(sixlo, ipv6, rbuf);\n            return;\n        }\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_VRB */\n    }\n    else {\n        /* set IPv6 header payload length field to the length of whatever is left\n         * after removing the 6LoWPAN header and adding uncompressed headers */\n        payload_len = (sixlo->size + uncomp_hdr_len -\n                       payload_offset - sizeof(ipv6_hdr_t));\n    }\n    if (rbuf == NULL) {\n        /* (rbuf == NULL) => forwarding is not affected by this */\n        if (gnrc_pktbuf_realloc_data(ipv6, uncomp_hdr_len + payload_len) != 0) {\n            DEBUG(\"6lo iphc: no space left to copy payload\\n\");\n            _recv_error_release(sixlo, ipv6, rbuf);\n            return;\n        }\n    }\n    else {\n        if (ipv6->size < (uncomp_hdr_len + (sixlo->size - payload_offset))) {\n            DEBUG(\"6lo iphc: not enough space to copy payload.\\n\");\n            DEBUG(\"6lo iphc: potentially malicious datagram size received.\\n\");\n            _recv_error_release(sixlo, ipv6, rbuf);\n            return;\n        }\n    }\n\n    /* re-assign IPv6 header in case realloc changed the address */\n    ipv6_hdr = ipv6->data;\n    ipv6_hdr->len = byteorder_htons(payload_len);\n    memcpy(((uint8_t *)ipv6->data) + uncomp_hdr_len,\n           ((uint8_t *)sixlo->data) + payload_offset,\n           sixlo->size - payload_offset);\n    if (rbuf != NULL) {\n        rbuf->super.current_size += (uncomp_hdr_len - payload_offset);\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_VRB\n        if (vrbe != NULL) {\n            int res = -1;\n            DEBUG(\"6lo iphc: found route, trying to forward\\n\");\n            ipv6_hdr->hl--;\n            vrbe->super.current_size = rbuf->super.current_size;\n            if ((ipv6 = _encode_frag_for_forwarding(ipv6, vrbe))) {\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_SFR\n                /* guard required because SFR-specific field of vrbe is\n                 * accessed */\n                if (_is_rfrag(sixlo)) {\n                    vrbe->in_netif = iface;\n                    /* calculate offset difference due to compression */\n                    vrbe->offset_diff = ((int)gnrc_pkt_len(ipv6->next)) -\n                                        sixlo->size;\n                }\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_SFR */\n                if ((res = _forward_frag(ipv6, sixlo->next, vrbe, page)) == 0) {\n                    DEBUG(\"6lo iphc: successfully recompressed and forwarded \"\n                          \"1st fragment\\n\");\n                    /* empty list, as it should be in VRB now */\n                    rbuf->super.ints = NULL;\n                }\n            }\n            if ((ipv6 == NULL) || (res < 0)) {\n                /* TODO: There is a potential to fall-back to classic reassembly\n                 * when ipv6 != NULL. However, since `ipv6` was reversed in\n                 * `_encode_frag_for_forwarding`, that step needs to be reversed\n                 * or a version of the old ipv6 needs to be held in the buffer.\n                 * For now, just drop the packet all together in an error case\n                 */\n                gnrc_sixlowpan_frag_vrb_rm(vrbe);\n            }\n            gnrc_pktbuf_release(sixlo);\n            /* don't remove `rbuf->pkt` (aka ipv6) as it was forwarded */\n            gnrc_sixlowpan_frag_rb_remove(rbuf);\n            return;\n        }\n        DEBUG(\"6lo iphc: no route found, reassemble datagram normally\\n\");\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_VRB */\n    }\n    else {\n        sixlo = gnrc_pkt_delete(sixlo, netif);\n        ipv6 = gnrc_pkt_append(ipv6, netif);\n        gnrc_sixlowpan_dispatch_recv(ipv6, NULL, page);\n    }\n    gnrc_pktbuf_release(sixlo);\n    return;\n}", "target": 3, "idx": 11278}
{"commit_id": "acc192347665943ca674acf117e4f74a88436922", "project": "android", "func": "FLACParser::FLACParser(\n        const sp<DataSource> &dataSource,\n        const sp<MetaData> &fileMetadata,\n        const sp<MetaData> &trackMetadata)\n    : mDataSource(dataSource),\n      mFileMetadata(fileMetadata),\n      mTrackMetadata(trackMetadata),\n      mInitCheck(false),\n      mMaxBufferSize(0),\n      mGroup(NULL),\n      mCopy(copyTrespass),\n      mDecoder(NULL),\n      mCurrentPos(0LL),\n      mEOF(false),\n      mStreamInfoValid(false),\n      mWriteRequested(false),\n      mWriteCompleted(false),\n      mErrorStatus((FLAC__StreamDecoderErrorStatus) -1)\n{\n    ALOGV(\"FLACParser::FLACParser\");\n    memset(&mStreamInfo, 0, sizeof(mStreamInfo));\n    memset(&mWriteHeader, 0, sizeof(mWriteHeader));\n    mInitCheck = init();\n}", "target": 2, "idx": 11279}
{"commit_id": "8f62b4761711d036fd8964df256b938c809b7fca", "project": "jasper-software/jasper", "func": "int main(int argc, char **argv)\n{\n\tint fmtid;\n\tint id;\n\tchar *infile;\n\tjas_stream_t *instream;\n\tjas_image_t *image;\n\tint width;\n\tint height;\n\tint depth;\n\tint numcmpts;\n\tint verbose;\n\tchar *fmtname;\n\tint debug;\n\n\tif (jas_init()) {\n\t\tabort();\n\t}\n\n\tcmdname = argv[0];\n\n\tinfile = 0;\n\tverbose = 0;\n\tdebug = 0;\n\n\t/* Parse the command line options. */\n\twhile ((id = jas_getopt(argc, argv, opts)) >= 0) {\n\t\tswitch (id) {\n\t\tcase OPT_VERBOSE:\n\t\t\tverbose = 1;\n\t\t\tbreak;\n\t\tcase OPT_VERSION:\n\t\t\tprintf(\"%s\\n\", JAS_VERSION);\n\t\t\texit(EXIT_SUCCESS);\n\t\t\tbreak;\n\t\tcase OPT_DEBUG:\n\t\t\tdebug = atoi(jas_optarg);\n\t\t\tbreak;\n\t\tcase OPT_INFILE:\n\t\t\tinfile = jas_optarg;\n\t\t\tbreak;\n\t\tcase OPT_HELP:\n\t\tdefault:\n\t\t\tusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tjas_setdbglevel(debug);\n\n\t/* Open the image file. */\n\tif (infile) {\n\t\t/* The image is to be read from a file. */\n\t\tif (!(instream = jas_stream_fopen(infile, \"rb\"))) {\n\t\t\tfprintf(stderr, \"cannot open input image file %s\\n\", infile);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t} else {\n\t\t/* The image is to be read from standard input. */\n\t\tif (!(instream = jas_stream_fdopen(0, \"rb\"))) {\n\t\t\tfprintf(stderr, \"cannot open standard input\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tif ((fmtid = jas_image_getfmt(instream)) < 0) {\n\t\tfprintf(stderr, \"unknown image format\\n\");\n\t}\n\n\t/* Decode the image. */\n\tif (!(image = jas_image_decode(instream, fmtid, 0))) {\n\t\tjas_stream_close(instream);\n\t\tfprintf(stderr, \"cannot load image\\n\");\n\t\treturn EXIT_FAILURE;\n\t}\n\n\t/* Close the image file. */\n\tjas_stream_close(instream);\n\n\tnumcmpts = jas_image_numcmpts(image);\n\twidth = jas_image_cmptwidth(image, 0);\n\theight = jas_image_cmptheight(image, 0);\n\tdepth = jas_image_cmptprec(image, 0);\n\tif (!(fmtname = jas_image_fmttostr(fmtid))) {\n\t\tabort();\n\t}\n\tprintf(\"%s %d %d %d %d %ld\\n\", fmtname, numcmpts, width, height, depth, (long) jas_image_rawsize(image));\n\n\tjas_image_destroy(image);\n\tjas_image_clearfmts();\n\n\treturn EXIT_SUCCESS;\n}", "target": 1, "idx": 11280}
{"commit_id": "b6aae4d8e7c8a6ddd21646f94fef1bf7f22c3f32", "project": "389ds/389-ds-base", "func": "int\ndse_bind(Slapi_PBlock *pb) /* JCM There should only be one exit point from this function! */\n{\n    ber_tag_t method;    /* The bind method */\n    struct berval *cred; /* The bind credentials */\n    Slapi_Value **bvals;\n    struct dse *pdse;\n    Slapi_Attr *attr;\n    Slapi_DN *sdn = NULL;\n    Slapi_Entry *ec = NULL;\n\n    /*Get the parameters*/\n    if (slapi_pblock_get(pb, SLAPI_PLUGIN_PRIVATE, &pdse) < 0 ||\n        slapi_pblock_get(pb, SLAPI_BIND_TARGET_SDN, &sdn) < 0 ||\n        slapi_pblock_get(pb, SLAPI_BIND_METHOD, &method) < 0 ||\n        slapi_pblock_get(pb, SLAPI_BIND_CREDENTIALS, &cred) < 0) {\n        slapi_send_ldap_result(pb, LDAP_OPERATIONS_ERROR, NULL, NULL, 0, NULL);\n        return SLAPI_BIND_FAIL;\n    }\n\n    /* always allow noauth simple binds */\n    if (method == LDAP_AUTH_SIMPLE && cred->bv_len == 0) {\n        /*\n         * report success to client, but return\n         * SLAPI_BIND_FAIL so we don't\n         * authorize based on noauth credentials\n         */\n        slapi_send_ldap_result(pb, LDAP_SUCCESS, NULL, NULL, 0, NULL);\n        return (SLAPI_BIND_FAIL);\n    }\n\n    ec = dse_get_entry_copy(pdse, sdn, DSE_USE_LOCK);\n    if (ec == NULL) {\n        slapi_pblock_set(pb, SLAPI_PB_RESULT_TEXT, \"Entry does not exist\");\n        slapi_send_ldap_result(pb, LDAP_INVALID_CREDENTIALS, NULL, NULL, 0, NULL);\n        return (SLAPI_BIND_FAIL);\n    }\n\n    switch (method) {\n    case LDAP_AUTH_SIMPLE: {\n        Slapi_Value cv;\n        if (slapi_entry_attr_find(ec, \"userpassword\", &attr) != 0) {\n            slapi_pblock_set(pb, SLAPI_PB_RESULT_TEXT, \"Entry does not have userpassword set\");\n            slapi_send_ldap_result(pb, LDAP_INVALID_CREDENTIALS, NULL, NULL, 0, NULL);\n            slapi_entry_free(ec);\n            return SLAPI_BIND_FAIL;\n        }\n        bvals = attr_get_present_values(attr);\n\n        slapi_value_init_berval(&cv, cred);\n        if (slapi_pw_find_sv(bvals, &cv) != 0) {\n            slapi_pblock_set(pb, SLAPI_PB_RESULT_TEXT, \"Invalid credentials\");\n            slapi_send_ldap_result(pb, LDAP_INVALID_CREDENTIALS, NULL, NULL, 0, NULL);\n            slapi_entry_free(ec);\n            value_done(&cv);\n            return SLAPI_BIND_FAIL;\n        }\n        value_done(&cv);\n    } break;\n\n    default:\n        slapi_send_ldap_result(pb, LDAP_STRONG_AUTH_NOT_SUPPORTED, NULL, \"auth method not supported\", 0, NULL);\n        slapi_entry_free(ec);\n        return SLAPI_BIND_FAIL;\n    }\n    slapi_entry_free(ec);\n    /* success:  front end will send result */\n    return SLAPI_BIND_SUCCESS;\n}", "target": 1, "idx": 11281}
{"commit_id": "7f283ff806b2031f407db64c4d3edcda8fb9f9f5", "project": "tensorflow", "func": "void Compute(OpKernelContext* ctx) override {\n    const Tensor& a = ctx->input(0);\n    const Tensor& b = ctx->input(1);\n    OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(a.shape()),\n                errors::InvalidArgument(\"a is not a matrix\"));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(b.shape()),\n                errors::InvalidArgument(\"b is not a matrix\"));\n\n    const int m = transpose_a_ ? a.dim_size(1) : a.dim_size(0);\n    const int k = transpose_a_ ? a.dim_size(0) : a.dim_size(1);\n    const int n = transpose_b_ ? b.dim_size(0) : b.dim_size(1);\n    const int k2 = transpose_b_ ? b.dim_size(1) : b.dim_size(0);\n\n    OP_REQUIRES(ctx, k == k2,\n                errors::InvalidArgument(\n                    \"Matrix size incompatible: a: \", a.shape().DebugString(),\n                    \", b: \", b.shape().DebugString()));\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({m, n}), &output));\n\n    if (k == 0) {\n      // If the inner dimension k in the matrix multiplication is zero, we fill\n      // the output with zeros.\n      functor::SetZeroFunctor<CPUDevice, float> f;\n      f(ctx->eigen_device<CPUDevice>(), output->flat<float>());\n      return;\n    }\n\n    auto out = output->matrix<float>();\n\n    std::unique_ptr<Tensor> a_float;\n    std::unique_ptr<Tensor> b_float;\n    if (!a_is_sparse_ && !b_is_sparse_) {\n      auto left = &a;\n      auto right = &b;\n      // TODO(agarwal): multi-thread the conversions from bfloat16 to float.\n      if (std::is_same<TL, bfloat16>::value) {\n        a_float.reset(new Tensor(DT_FLOAT, a.shape()));\n        BFloat16ToFloat(a.flat<bfloat16>().data(),\n                        a_float->flat<float>().data(), a.NumElements());\n        left = a_float.get();\n      }\n      if (std::is_same<TR, bfloat16>::value) {\n        b_float.reset(new Tensor(DT_FLOAT, b.shape()));\n        BFloat16ToFloat(b.flat<bfloat16>().data(),\n                        b_float->flat<float>().data(), b.NumElements());\n        right = b_float.get();\n      }\n      Eigen::array<Eigen::IndexPair<Eigen::DenseIndex>, 1> dim_pair;\n      dim_pair[0].first = transpose_a_ ? 0 : 1;\n      dim_pair[0].second = transpose_b_ ? 1 : 0;\n\n      out.device(ctx->template eigen_device<CPUDevice>()) =\n          left->matrix<float>().contract(right->matrix<float>(), dim_pair);\n      return;\n    }\n\n    auto left = &a;\n    auto right = &b;\n    bool transpose_output = false;\n    bool transpose_a = transpose_a_;\n    bool transpose_b = transpose_b_;\n    if (!a_is_sparse_) {\n      // Swap the order of multiplications using the identity:\n      // A * B = (B' *  A')'.\n      std::swap(left, right);\n      std::swap(transpose_a, transpose_b);\n      transpose_a = !transpose_a;\n      transpose_b = !transpose_b;\n      transpose_output = !transpose_output;\n    }\n\n    std::unique_ptr<Tensor> right_tr;\n    if (transpose_b) {\n      // TODO(agarwal): avoid transposing the matrix here and directly handle\n      // transpose in CreateDenseSlices.\n      OP_REQUIRES(ctx, right->dim_size(0) != 0,\n                  errors::InvalidArgument(\"b has an entry 0 in it's shape.\"));\n      OP_REQUIRES(ctx, right->dim_size(1) != 0,\n                  errors::InvalidArgument(\"b has an entry 0 in it's shape.\"));\n      right_tr.reset(\n          new Tensor(right->dtype(),\n                     TensorShape({right->dim_size(1), right->dim_size(0)})));\n\n      const auto perm = dsizes_10();\n      if (transpose_output) {\n        right_tr->matrix<TL>().device(ctx->template eigen_device<CPUDevice>()) =\n            right->matrix<TL>().shuffle(perm);\n      } else {\n        right_tr->matrix<TR>().device(ctx->template eigen_device<CPUDevice>()) =\n            right->matrix<TR>().shuffle(perm);\n      }\n      right = right_tr.get();\n    }\n\n    if (transpose_output) {\n      DoMatMul<TR, TL>::Compute(&this->cache_tr_, left->matrix<TR>(),\n                                right->matrix<TL>(), transpose_a,\n                                ctx->device()->tensorflow_cpu_worker_threads(),\n                                transpose_output, &out);\n    } else {\n      DoMatMul<TL, TR>::Compute(&this->cache_nt_, left->matrix<TL>(),\n                                right->matrix<TR>(), transpose_a,\n                                ctx->device()->tensorflow_cpu_worker_threads(),\n                                transpose_output, &out);\n    }\n  }", "target": 0, "idx": 11282}
{"commit_id": "6aa825e480d48127b480b08d13adf70033237097", "project": "facebook/hermes", "func": "ExecutionStatus lazyCompile(Runtime &runtime) {\n    if (LLVM_UNLIKELY(isLazy())) {\n      return lazyCompileImpl(runtime);\n    }\n    return ExecutionStatus::RETURNED;\n  }", "target": 3, "idx": 11283}
{"commit_id": "5d37af364dc158aa387f7c8b2a05c90325c63dce", "project": "xen-project/xen", "func": "static inline void disable_each_ist(idt_entry_t *idt)\n{\n    set_ist(&idt[TRAP_double_fault],  IST_NONE);\n    set_ist(&idt[TRAP_nmi],           IST_NONE);\n    set_ist(&idt[TRAP_machine_check], IST_NONE);\n    set_ist(&idt[TRAP_debug],         IST_NONE);\n}", "target": 2, "idx": 11284}
{"commit_id": "0a00c43d64c58a85e6250120f2377302675b0fe3", "project": "facebook/proxygen", "func": "void timeoutExpired() noexcept override {\n      if (counter > 0 && httpSessionStats) {\n        switch (rateLimitTarget) {\n          case RateLimitTarget::CONTROL_MSGS:\n            httpSessionStats->recordControlMsgsInInterval(counter);\n            break;\n          case RateLimitTarget::DIRECT_ERROR_HANDLING:\n            // No stats for this one\n            break;\n          case RateLimitTarget::HEADERS:\n            httpSessionStats->recordHeadersInInterval(counter);\n            break;\n        }\n      }\n      counter = 0;\n    }", "target": 2, "idx": 11285}
{"commit_id": "615c02e3d3ee5daa62f8780e43d28bb631b55df8", "project": "nextcloud/desktop", "func": "void JsonApiJob::start()\n{\n    additionalParams().addQueryItem(QLatin1String(\"format\"), QLatin1String(\"json\"));\n    SimpleApiJob::start();\n}", "target": 1, "idx": 11286}
{"commit_id": "62b6433a81ee7ed6e0ac2d6b09ac85b885046ac3", "project": "fontforge", "func": "static void readcffset(FILE *ttf,struct topdicts *dict,struct ttfinfo *info) {\n    int len = dict->glyphs.cnt;\n    int i;\n    int format, cnt, j, first;\n\n    i = 0;\n    if ( dict->charsetoff==0 ) {\n\t/* ISO Adobe charset */\n\tdict->charset = malloc(len*sizeof(uint16));\n\tfor ( i=0; i<len && i<=228; ++i )\n\t    dict->charset[i] = i;\n    } else if ( dict->charsetoff==1 ) {\n\t/* Expert charset */\n\tdict->charset = malloc((len<162?162:len)*sizeof(uint16));\n\tdict->charset[0] = 0;\t\t/* .notdef */\n\tdict->charset[1] = 1;\n\tfor ( i=2; i<len && i<=238-227; ++i )\n\t    dict->charset[i] = i+227;\n\tdict->charset[12] = 13;\n\tdict->charset[13] = 14;\n\tdict->charset[14] = 15;\n\tdict->charset[15] = 99;\n\tfor ( i=16; i<len && i<=248-223; ++i )\n\t    dict->charset[i] = i+223;\n\tdict->charset[25] = 27;\n\tdict->charset[26] = 28;\n\tfor ( i=27; i<len && i<=266-222; ++i )\n\t    dict->charset[i] = i+222;\n\tdict->charset[44] = 109;\n\tdict->charset[45] = 110;\n\tfor ( i=46; i<len && i<=318-221; ++i )\n\t    dict->charset[i] = i+221;\n\tdict->charset[96] = 158;\n\tdict->charset[97] = 155;\n\tdict->charset[98] = 163;\n\tfor ( i=99; i<len && i<=326-220; ++i )\n\t    dict->charset[i] = i+220;\n\tdict->charset[107] = 150;\n\tdict->charset[108] = 164;\n\tdict->charset[109] = 169;\n\tfor ( i=110; i<len && i<=378-217; ++i )\n\t    dict->charset[i] = i+217;\n    } else if ( dict->charsetoff==2 ) {\n\t/* Expert subset charset */\n\tdict->charset = malloc((len<130?130:len)*sizeof(uint16));\n\tdict->charset[0] = 0;\t\t/* .notdef */\n\tdict->charset[1] = 1;\n\tfor ( i=2; i<len && i<=238-227; ++i )\n\t    dict->charset[i] = i+227;\n\tdict->charset[12] = 13;\n\tdict->charset[13] = 14;\n\tdict->charset[14] = 15;\n\tdict->charset[15] = 99;\n\tfor ( i=16; i<len && i<=248-223; ++i )\n\t    dict->charset[i] = i+223;\n\tdict->charset[25] = 27;\n\tdict->charset[26] = 28;\n\tfor ( i=27; i<len && i<=266-222; ++i )\n\t    dict->charset[i] = i+222;\n\tdict->charset[44] = 109;\n\tdict->charset[45] = 110;\n\tfor ( i=46; i<len && i<=272-221; ++i )\n\t    dict->charset[i] = i+221;\n\tdict->charset[51] = 300;\n\tdict->charset[52] = 301;\n\tdict->charset[53] = 302;\n\tdict->charset[54] = 305;\n\tdict->charset[55] = 314;\n\tdict->charset[56] = 315;\n\tdict->charset[57] = 158;\n\tdict->charset[58] = 155;\n\tdict->charset[59] = 163;\n\tfor ( i=60; i<len && i<=326-260; ++i )\n\t    dict->charset[i] = i+260;\n\tdict->charset[67] = 150;\n\tdict->charset[68] = 164;\n\tdict->charset[69] = 169;\n\tfor ( i=110; i<len && i<=346-217; ++i )\n\t    dict->charset[i] = i+217;\n    } else {\n\tdict->charset = malloc(len*sizeof(uint16));\n\tdict->charset[0] = 0;\t\t/* .notdef */\n\tfseek(ttf,dict->cff_start+dict->charsetoff,SEEK_SET);\n\tformat = getc(ttf);\n\tif ( format==0 ) {\n\t    for ( i=1; i<len; ++i )\n\t\tdict->charset[i] = getushort(ttf);\n\t} else if ( format==1 ) {\n\t    for ( i = 1; i<len; ) {\n\t\tfirst = dict->charset[i++] = getushort(ttf);\n\t\tcnt = getc(ttf);\n\t\tfor ( j=0; j<cnt && i<len; ++j )\n\t\t    dict->charset[i++] = ++first;\n\t    }\n\t} else if ( format==2 ) {\n\t    for ( i = 1; i<len; ) {\n\t\tfirst = dict->charset[i++] = getushort(ttf);\n\t\tcnt = getushort(ttf);\n\t\tfor ( j=0; j<cnt; ++j )\n\t\t    dict->charset[i++] = ++first;\n\t    }\n\t} else {\n\t    LogError( _(\"Unexpected charset format in cff: %d\\n\"), format );\n\t    if ( info!=NULL ) info->bad_cff = true;\n\t}\n    }\n    while ( i<len ) dict->charset[i++] = 0;\n}", "target": 2, "idx": 11287}
{"commit_id": "dc96cdc27fb53e8595af67aaf68001033c808e42", "project": "libsixel", "func": "static void\ndiffuse_burkes(unsigned char *data, int width, int height,\n               int x, int y, int depth, int error)\n{\n    int pos;\n\n    pos = y * width + x;\n\n    /* Burkes' Method\n     *                  curr    4/16    2/16\n     *  1/16    2/16    4/16    2/16    1/16\n     */\n    if (pos < (height - 1) * width - 2) {\n        error_diffuse(data, pos + width * 0 + 1, depth, error, 1, 4, width * height);\n        error_diffuse(data, pos + width * 0 + 2, depth, error, 1, 8, width * height);\n        error_diffuse(data, pos + width * 1 - 2, depth, error, 1, 16, width * height);\n        error_diffuse(data, pos + width * 1 - 1, depth, error, 1, 8, width * height);\n        error_diffuse(data, pos + width * 1 + 0, depth, error, 1, 4, width * height);\n        error_diffuse(data, pos + width * 1 + 1, depth, error, 1, 8, width * height);\n        error_diffuse(data, pos + width * 1 + 2, depth, error, 1, 16, width * height);\n    }\n}", "target": 2, "idx": 11288}
{"commit_id": "27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2", "project": "torvalds/linux", "func": "netdev_tx_t hns_nic_net_xmit_hw(struct net_device *ndev,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tstruct hns_nic_ring_data *ring_data)\n{\n\tstruct hns_nic_priv *priv = netdev_priv(ndev);\n\tstruct hnae_ring *ring = ring_data->ring;\n\tstruct device *dev = ring_to_dev(ring);\n\tstruct netdev_queue *dev_queue;\n\tstruct skb_frag_struct *frag;\n\tint buf_num;\n\tint seg_num;\n\tdma_addr_t dma;\n\tint size, next_to_use;\n\tint i;\n\n\tswitch (priv->ops.maybe_stop_tx(&skb, &buf_num, ring)) {\n\tcase -EBUSY:\n\t\tring->stats.tx_busy++;\n\t\tgoto out_net_tx_busy;\n\tcase -ENOMEM:\n\t\tring->stats.sw_err_cnt++;\n\t\tnetdev_err(ndev, \"no memory to xmit!\\n\");\n\t\tgoto out_err_tx_ok;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* no. of segments (plus a header) */\n\tseg_num = skb_shinfo(skb)->nr_frags + 1;\n\tnext_to_use = ring->next_to_use;\n\n\t/* fill the first part */\n\tsize = skb_headlen(skb);\n\tdma = dma_map_single(dev, skb->data, size, DMA_TO_DEVICE);\n\tif (dma_mapping_error(dev, dma)) {\n\t\tnetdev_err(ndev, \"TX head DMA map failed\\n\");\n\t\tring->stats.sw_err_cnt++;\n\t\tgoto out_err_tx_ok;\n\t}\n\tpriv->ops.fill_desc(ring, skb, size, dma, seg_num == 1 ? 1 : 0,\n\t\t\t    buf_num, DESC_TYPE_SKB, ndev->mtu);\n\n\t/* fill the fragments */\n\tfor (i = 1; i < seg_num; i++) {\n\t\tfrag = &skb_shinfo(skb)->frags[i - 1];\n\t\tsize = skb_frag_size(frag);\n\t\tdma = skb_frag_dma_map(dev, frag, 0, size, DMA_TO_DEVICE);\n\t\tif (dma_mapping_error(dev, dma)) {\n\t\t\tnetdev_err(ndev, \"TX frag(%d) DMA map failed\\n\", i);\n\t\t\tring->stats.sw_err_cnt++;\n\t\t\tgoto out_map_frag_fail;\n\t\t}\n\t\tpriv->ops.fill_desc(ring, skb_frag_page(frag), size, dma,\n\t\t\t\t    seg_num - 1 == i ? 1 : 0, buf_num,\n\t\t\t\t    DESC_TYPE_PAGE, ndev->mtu);\n\t}\n\n\t/*complete translate all packets*/\n\tdev_queue = netdev_get_tx_queue(ndev, skb->queue_mapping);\n\tnetdev_tx_sent_queue(dev_queue, skb->len);\n\n\tnetif_trans_update(ndev);\n\tndev->stats.tx_bytes += skb->len;\n\tndev->stats.tx_packets++;\n\n\twmb(); /* commit all data before submit */\n\tassert(skb->queue_mapping < priv->ae_handle->q_num);\n\thnae_queue_xmit(priv->ae_handle->qs[skb->queue_mapping], buf_num);\n\tring->stats.tx_pkts++;\n\tring->stats.tx_bytes += skb->len;\n\n\treturn NETDEV_TX_OK;\n\nout_map_frag_fail:\n\n\twhile (ring->next_to_use != next_to_use) {\n\t\tunfill_desc(ring);\n\t\tif (ring->next_to_use != next_to_use)\n\t\t\tdma_unmap_page(dev,\n\t\t\t\t       ring->desc_cb[ring->next_to_use].dma,\n\t\t\t\t       ring->desc_cb[ring->next_to_use].length,\n\t\t\t\t       DMA_TO_DEVICE);\n\t\telse\n\t\t\tdma_unmap_single(dev,\n\t\t\t\t\t ring->desc_cb[next_to_use].dma,\n\t\t\t\t\t ring->desc_cb[next_to_use].length,\n\t\t\t\t\t DMA_TO_DEVICE);\n\t}\n\nout_err_tx_ok:\n\n\tdev_kfree_skb_any(skb);\n\treturn NETDEV_TX_OK;\n\nout_net_tx_busy:\n\n\tnetif_stop_subqueue(ndev, skb->queue_mapping);\n\n\t/* Herbert's original patch had:\n\t *  smp_mb__after_netif_stop_queue();\n\t * but since that doesn't exist yet, just open code it.\n\t */\n\tsmp_mb();\n\treturn NETDEV_TX_BUSY;\n}", "target": 2, "idx": 11289}
{"commit_id": "e7f2356665c2569191a946b6fc35b437f0ae1384", "project": "php/php-src", "func": "void gdImageFillToBorder (gdImagePtr im, int x, int y, int border, int color)\n{\n\tint lastBorder;\n\t/* Seek left */\n\tint leftLimit = -1, rightLimit;\n\tint i, restoreAlphaBlending = 0;\n\n\tif (border < 0) {\n\t\t/* Refuse to fill to a non-solid border */\n\t\treturn;\n\t}\n\n\trestoreAlphaBlending = im->alphaBlendingFlag;\n\tim->alphaBlendingFlag = 0;\n\n\tif (x >= im->sx) {\n\t\tx = im->sx - 1;\n\t} else if (x < 0) {\n\t\tx = 0;\n\t}\n\tif (y >= im->sy) {\n\t\ty = im->sy - 1;\n\t} else if (y < 0) {\n\t\ty = 0;\n\t}\n\n\tfor (i = x; i >= 0; i--) {\n\t\tif (gdImageGetPixel(im, i, y) == border) {\n\t\t\tbreak;\n\t\t}\n\t\tgdImageSetPixel(im, i, y, color);\n\t\tleftLimit = i;\n\t}\n\tif (leftLimit == -1) {\n\t\tim->alphaBlendingFlag = restoreAlphaBlending;\n\t\treturn;\n\t}\n\t/* Seek right */\n\trightLimit = x;\n\tfor (i = (x + 1); i < im->sx; i++) {\n\t\tif (gdImageGetPixel(im, i, y) == border) {\n\t\t\tbreak;\n\t\t}\n\t\tgdImageSetPixel(im, i, y, color);\n\t\trightLimit = i;\n\t}\n\t/* Look at lines above and below and start paints */\n\t/* Above */\n\tif (y > 0) {\n\t\tlastBorder = 1;\n\t\tfor (i = leftLimit; i <= rightLimit; i++) {\n\t\t\tint c = gdImageGetPixel(im, i, y - 1);\n\t\t\tif (lastBorder) {\n\t\t\t\tif ((c != border) && (c != color)) {\n\t\t\t\t\tgdImageFillToBorder(im, i, y - 1, border, color);\n\t\t\t\t\tlastBorder = 0;\n\t\t\t\t}\n\t\t\t} else if ((c == border) || (c == color)) {\n\t\t\t\tlastBorder = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Below */\n\tif (y < ((im->sy) - 1)) {\n\t\tlastBorder = 1;\n\t\tfor (i = leftLimit; i <= rightLimit; i++) {\n\t\t\tint c = gdImageGetPixel(im, i, y + 1);\n\n\t\t\tif (lastBorder) {\n\t\t\t\tif ((c != border) && (c != color)) {\n\t\t\t\t\tgdImageFillToBorder(im, i, y + 1, border, color);\n\t\t\t\t\tlastBorder = 0;\n\t\t\t\t}\n\t\t\t} else if ((c == border) || (c == color)) {\n\t\t\t\tlastBorder = 1;\n\t\t\t}\n\t\t}\n\t}\n\tim->alphaBlendingFlag = restoreAlphaBlending;\n}", "target": 2, "idx": 11290}
{"commit_id": "a9107feeb4b8275b78965b36bf21b92d5724699e", "project": "flatpak", "func": "static gboolean\nsetup_seccomp (FlatpakBwrap   *bwrap,\n               const char     *arch,\n               gulong          allowed_personality,\n               FlatpakRunFlags run_flags,\n               GError        **error)\n{\n  gboolean multiarch = (run_flags & FLATPAK_RUN_FLAG_MULTIARCH) != 0;\n  gboolean devel = (run_flags & FLATPAK_RUN_FLAG_DEVEL) != 0;\n\n  __attribute__((cleanup (cleanup_seccomp))) scmp_filter_ctx seccomp = NULL;\n\n  /**** BEGIN NOTE ON CODE SHARING\n   *\n   * There are today a number of different Linux container\n   * implementations.  That will likely continue for long into the\n   * future.  But we can still try to share code, and it's important\n   * to do so because it affects what library and application writers\n   * can do, and we should support code portability between different\n   * container tools.\n   *\n   * This syscall blacklist is copied from linux-user-chroot, which was in turn\n   * clearly influenced by the Sandstorm.io blacklist.\n   *\n   * If you make any changes here, I suggest sending the changes along\n   * to other sandbox maintainers.  Using the libseccomp list is also\n   * an appropriate venue:\n   * https://groups.google.com/forum/#!topic/libseccomp\n   *\n   * A non-exhaustive list of links to container tooling that might\n   * want to share this blacklist:\n   *\n   *  https://github.com/sandstorm-io/sandstorm\n   *    in src/sandstorm/supervisor.c++\n   *  https://github.com/flatpak/flatpak.git\n   *    in common/flatpak-run.c\n   *  https://git.gnome.org/browse/linux-user-chroot\n   *    in src/setup-seccomp.c\n   *\n   **** END NOTE ON CODE SHARING\n   */\n  struct\n  {\n    int                  scall;\n    struct scmp_arg_cmp *arg;\n  } syscall_blacklist[] = {\n    /* Block dmesg */\n    {SCMP_SYS (syslog)},\n    /* Useless old syscall */\n    {SCMP_SYS (uselib)},\n    /* Don't allow disabling accounting */\n    {SCMP_SYS (acct)},\n    /* 16-bit code is unnecessary in the sandbox, and modify_ldt is a\n       historic source of interesting information leaks. */\n    {SCMP_SYS (modify_ldt)},\n    /* Don't allow reading current quota use */\n    {SCMP_SYS (quotactl)},\n\n    /* Don't allow access to the kernel keyring */\n    {SCMP_SYS (add_key)},\n    {SCMP_SYS (keyctl)},\n    {SCMP_SYS (request_key)},\n\n    /* Scary VM/NUMA ops */\n    {SCMP_SYS (move_pages)},\n    {SCMP_SYS (mbind)},\n    {SCMP_SYS (get_mempolicy)},\n    {SCMP_SYS (set_mempolicy)},\n    {SCMP_SYS (migrate_pages)},\n\n    /* Don't allow subnamespace setups: */\n    {SCMP_SYS (unshare)},\n    {SCMP_SYS (mount)},\n    {SCMP_SYS (pivot_root)},\n    {SCMP_SYS (clone), &SCMP_A0 (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)},\n\n    /* Don't allow faking input to the controlling tty (CVE-2017-5226) */\n    {SCMP_SYS (ioctl), &SCMP_A1 (SCMP_CMP_MASKED_EQ, 0xFFFFFFFFu, (int) TIOCSTI)},\n  };\n\n  struct\n  {\n    int                  scall;\n    struct scmp_arg_cmp *arg;\n  } syscall_nondevel_blacklist[] = {\n    /* Profiling operations; we expect these to be done by tools from outside\n     * the sandbox.  In particular perf has been the source of many CVEs.\n     */\n    {SCMP_SYS (perf_event_open)},\n    /* Don't allow you to switch to bsd emulation or whatnot */\n    {SCMP_SYS (personality), &SCMP_A0 (SCMP_CMP_NE, allowed_personality)},\n    {SCMP_SYS (ptrace)}\n  };\n  /* Blacklist all but unix, inet, inet6 and netlink */\n  struct\n  {\n    int             family;\n    FlatpakRunFlags flags_mask;\n  } socket_family_whitelist[] = {\n    /* NOTE: Keep in numerical order */\n    { AF_UNSPEC, 0 },\n    { AF_LOCAL, 0 },\n    { AF_INET, 0 },\n    { AF_INET6, 0 },\n    { AF_NETLINK, 0 },\n    { AF_CAN, FLATPAK_RUN_FLAG_CANBUS },\n    { AF_BLUETOOTH, FLATPAK_RUN_FLAG_BLUETOOTH },\n  };\n  int last_allowed_family;\n  int i, r;\n  g_auto(GLnxTmpfile) seccomp_tmpf  = { 0, };\n\n  seccomp = seccomp_init (SCMP_ACT_ALLOW);\n  if (!seccomp)\n    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Initialize seccomp failed\"));\n\n  if (arch != NULL)\n    {\n      uint32_t arch_id = 0;\n      const uint32_t *extra_arches = NULL;\n\n      if (strcmp (arch, \"i386\") == 0)\n        {\n          arch_id = SCMP_ARCH_X86;\n        }\n      else if (strcmp (arch, \"x86_64\") == 0)\n        {\n          arch_id = SCMP_ARCH_X86_64;\n          extra_arches = seccomp_x86_64_extra_arches;\n        }\n      else if (strcmp (arch, \"arm\") == 0)\n        {\n          arch_id = SCMP_ARCH_ARM;\n        }\n#ifdef SCMP_ARCH_AARCH64\n      else if (strcmp (arch, \"aarch64\") == 0)\n        {\n          arch_id = SCMP_ARCH_AARCH64;\n          extra_arches = seccomp_aarch64_extra_arches;\n        }\n#endif\n\n      /* We only really need to handle arches on multiarch systems.\n       * If only one arch is supported the default is fine */\n      if (arch_id != 0)\n        {\n          /* This *adds* the target arch, instead of replacing the\n             native one. This is not ideal, because we'd like to only\n             allow the target arch, but we can't really disallow the\n             native arch at this point, because then bubblewrap\n             couldn't continue running. */\n          r = seccomp_arch_add (seccomp, arch_id);\n          if (r < 0 && r != -EEXIST)\n            return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to add architecture to seccomp filter\"));\n\n          if (multiarch && extra_arches != NULL)\n            {\n              unsigned i;\n              for (i = 0; extra_arches[i] != 0; i++)\n                {\n                  r = seccomp_arch_add (seccomp, extra_arches[i]);\n                  if (r < 0 && r != -EEXIST)\n                    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to add multiarch architecture to seccomp filter\"));\n                }\n            }\n        }\n    }\n\n  /* TODO: Should we filter the kernel keyring syscalls in some way?\n   * We do want them to be used by desktop apps, but they could also perhaps\n   * leak system stuff or secrets from other apps.\n   */\n\n  for (i = 0; i < G_N_ELEMENTS (syscall_blacklist); i++)\n    {\n      int scall = syscall_blacklist[i].scall;\n      if (syscall_blacklist[i].arg)\n        r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (EPERM), scall, 1, *syscall_blacklist[i].arg);\n      else\n        r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (EPERM), scall, 0);\n      if (r < 0 && r == -EFAULT /* unknown syscall */)\n        return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to block syscall %d\"), scall);\n    }\n\n  if (!devel)\n    {\n      for (i = 0; i < G_N_ELEMENTS (syscall_nondevel_blacklist); i++)\n        {\n          int scall = syscall_nondevel_blacklist[i].scall;\n          if (syscall_nondevel_blacklist[i].arg)\n            r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (EPERM), scall, 1, *syscall_nondevel_blacklist[i].arg);\n          else\n            r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (EPERM), scall, 0);\n\n          if (r < 0 && r == -EFAULT /* unknown syscall */)\n            return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to block syscall %d\"), scall);\n        }\n    }\n\n  /* Socket filtering doesn't work on e.g. i386, so ignore failures here\n   * However, we need to user seccomp_rule_add_exact to avoid libseccomp doing\n   * something else: https://github.com/seccomp/libseccomp/issues/8 */\n  last_allowed_family = -1;\n  for (i = 0; i < G_N_ELEMENTS (socket_family_whitelist); i++)\n    {\n      int family = socket_family_whitelist[i].family;\n      int disallowed;\n\n      if (socket_family_whitelist[i].flags_mask != 0 &&\n          (socket_family_whitelist[i].flags_mask & run_flags) != socket_family_whitelist[i].flags_mask)\n        continue;\n\n      for (disallowed = last_allowed_family + 1; disallowed < family; disallowed++)\n        {\n          /* Blacklist the in-between valid families */\n          seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_EQ, disallowed));\n        }\n      last_allowed_family = family;\n    }\n  /* Blacklist the rest */\n  seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_GE, last_allowed_family + 1));\n\n  if (!glnx_open_anonymous_tmpfile (O_RDWR | O_CLOEXEC, &seccomp_tmpf, error))\n    return FALSE;\n\n  if (seccomp_export_bpf (seccomp, seccomp_tmpf.fd) != 0)\n    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to export bpf\"));\n\n  lseek (seccomp_tmpf.fd, 0, SEEK_SET);\n\n  flatpak_bwrap_add_args_data_fd (bwrap,\n                                  \"--seccomp\", glnx_steal_fd (&seccomp_tmpf.fd), NULL);\n\n  return TRUE;\n}", "target": 3, "idx": 11291}
{"commit_id": "2b501045c65cf2ecc660b81ef019ce6552085982", "project": "gluster/glusterfs", "func": "int\nnotify(xlator_t *this, int32_t event, void *data, ...)\n{\n    int i = 0;\n    int32_t ret = 0;\n    fuse_private_t *private = NULL;\n    gf_boolean_t start_thread = _gf_false;\n    gf_boolean_t event_graph = _gf_true;\n    glusterfs_graph_t *graph = NULL;\n    struct pollfd pfd = {0};\n\n    private = this->private;\n\n    graph = data;\n\n    switch (event) {\n        case GF_EVENT_GRAPH_NEW:\n            break;\n\n        case GF_EVENT_CHILD_UP:\n        case GF_EVENT_CHILD_DOWN:\n        case GF_EVENT_CHILD_CONNECTING: {\n            if (graph) {\n                ret = fuse_graph_setup(this, graph);\n                if (ret)\n                    gf_log(this->name, GF_LOG_WARNING,\n                           \"failed to setup the graph\");\n            }\n\n            if ((event == GF_EVENT_CHILD_UP) ||\n                (event == GF_EVENT_CHILD_DOWN)) {\n                pthread_mutex_lock(&private->sync_mutex);\n                {\n                    private->event_recvd = 1;\n                    pthread_cond_broadcast(&private->sync_cond);\n                }\n                pthread_mutex_unlock(&private->sync_mutex);\n            }\n\n            pthread_mutex_lock(&private->sync_mutex);\n            {\n                if (!private->fuse_thread_started) {\n                    private->fuse_thread_started = 1;\n                    start_thread = _gf_true;\n                }\n            }\n            pthread_mutex_unlock(&private->sync_mutex);\n\n            if (start_thread) {\n                private->fuse_thread = GF_CALLOC(private->reader_thread_count,\n                                                 sizeof(pthread_t),\n                                                 gf_fuse_mt_pthread_t);\n                for (i = 0; i < private->reader_thread_count; i++) {\n                    ret = gf_thread_create(&private->fuse_thread[i], NULL,\n                                           fuse_thread_proc, this, \"fuseproc\");\n                    if (ret != 0) {\n                        gf_log(this->name, GF_LOG_DEBUG,\n                               \"pthread_create() failed (%s)\", strerror(errno));\n                        break;\n                    }\n                }\n            }\n\n            break;\n        }\n\n        case GF_EVENT_AUTH_FAILED: {\n            /* Authentication failure is an error and glusterfs should stop */\n            gf_log(this->name, GF_LOG_ERROR,\n                   \"Server authentication failed. Shutting down.\");\n            pthread_mutex_lock(&private->sync_mutex);\n            {\n                /*Wait for mount to finish*/\n                if (!private->mount_finished) {\n                    pfd.fd = private->status_pipe[0];\n                    pfd.events = POLLIN | POLLHUP | POLLERR;\n                    if (poll(&pfd, 1, -1) < 0) {\n                        gf_log(this->name, GF_LOG_ERROR, \"poll error %s\",\n                               strerror(errno));\n                        goto auth_fail_unlock;\n                    }\n                    if (pfd.revents & POLLIN) {\n                        if (fuse_get_mount_status(this) != 0) {\n                            goto auth_fail_unlock;\n                        }\n                        private->mount_finished = _gf_true;\n                    } else if (pfd.revents) {\n                        gf_log(this->name, GF_LOG_ERROR,\n                               \"mount pipe closed without status\");\n                        goto auth_fail_unlock;\n                    }\n                }\n            }\n        auth_fail_unlock:\n            pthread_mutex_unlock(&private->sync_mutex);\n            fini(this);\n            break;\n        }\n\n        default:\n            /* Set the event_graph to false so that event\n               debug msg would not try to access invalid graph->id\n               while data object is not matched to graph object\n               for ex in case of upcall event data object represents\n               gf_upcall object\n            */\n            event_graph = _gf_false;\n            break;\n    }\n\n    gf_log(\"fuse\", GF_LOG_DEBUG, \"got event %d on graph %d\", event,\n           ((graph && event_graph) ? graph->id : -1));\n    return ret;\n}", "target": 2, "idx": 11292}
{"commit_id": "f7d8a19f9a056a05c5c509fa65af472a322abfee", "project": "torvalds/linux", "func": "int kvm_create_lapic(struct kvm_vcpu *vcpu, int timer_advance_ns)\n{\n\tstruct kvm_lapic *apic;\n\n\tASSERT(vcpu != NULL);\n\n\tapic = kzalloc(sizeof(*apic), GFP_KERNEL_ACCOUNT);\n\tif (!apic)\n\t\tgoto nomem;\n\n\tvcpu->arch.apic = apic;\n\n\tapic->regs = (void *)get_zeroed_page(GFP_KERNEL_ACCOUNT);\n\tif (!apic->regs) {\n\t\tprintk(KERN_ERR \"malloc apic regs error for vcpu %x\\n\",\n\t\t       vcpu->vcpu_id);\n\t\tgoto nomem_free_apic;\n\t}\n\tapic->vcpu = vcpu;\n\n\thrtimer_init(&apic->lapic_timer.timer, CLOCK_MONOTONIC,\n\t\t     HRTIMER_MODE_ABS_HARD);\n\tapic->lapic_timer.timer.function = apic_timer_fn;\n\tif (timer_advance_ns == -1) {\n\t\tapic->lapic_timer.timer_advance_ns = LAPIC_TIMER_ADVANCE_NS_INIT;\n\t\tlapic_timer_advance_dynamic = true;\n\t} else {\n\t\tapic->lapic_timer.timer_advance_ns = timer_advance_ns;\n\t\tlapic_timer_advance_dynamic = false;\n\t}\n\n\t/*\n\t * Stuff the APIC ENABLE bit in lieu of temporarily incrementing\n\t * apic_hw_disabled; the full RESET value is set by kvm_lapic_reset().\n\t */\n\tvcpu->arch.apic_base = MSR_IA32_APICBASE_ENABLE;\n\tstatic_branch_inc(&apic_sw_disabled.key); /* sw disabled at reset */\n\tkvm_iodevice_init(&apic->dev, &apic_mmio_ops);\n\n\treturn 0;\nnomem_free_apic:\n\tkfree(apic);\n\tvcpu->arch.apic = NULL;\nnomem:\n\treturn -ENOMEM;\n}", "target": 1, "idx": 11293}
{"commit_id": "3119b232c9c453c98d8fa8b6ae4e37ba18117cd4", "project": "VirusTotal/yara", "func": "int read_escaped_char(\n    yyscan_t yyscanner,\n    uint8_t* escaped_char)\n{\n  char text[4] = {0, 0, 0, 0};\n\n  text[0] = '\\\\';\n  text[1] = RE_YY_INPUT(yyscanner);\n\n  if (text[1] == EOF || text[1] == 0)\n    return 0;\n\n  if (text[1] == 'x')\n  {\n    text[2] = RE_YY_INPUT(yyscanner);\n\n    if (!isxdigit(text[2]))\n      return 0;\n\n    text[3] = RE_YY_INPUT(yyscanner);\n\n    if (!isxdigit(text[3]))\n      return 0;\n  }\n\n  *escaped_char = escaped_char_value(text);\n\n  return 1;\n}", "target": 2, "idx": 11294}
{"commit_id": "e11f0f90a626f93899687b1cc909ee37dd6c5809", "project": "torvalds/linux", "func": "int snd_pcm_info(struct snd_pcm_substream *substream, struct snd_pcm_info *info)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tstruct snd_pcm *pcm = substream->pcm;\n\tstruct snd_pcm_str *pstr = substream->pstr;\n\n\tmemset(info, 0, sizeof(*info));\n\tinfo->card = pcm->card->number;\n\tinfo->device = pcm->device;\n\tinfo->stream = substream->stream;\n\tinfo->subdevice = substream->number;\n\tstrlcpy(info->id, pcm->id, sizeof(info->id));\n\tstrlcpy(info->name, pcm->name, sizeof(info->name));\n\tinfo->dev_class = pcm->dev_class;\n\tinfo->dev_subclass = pcm->dev_subclass;\n\tinfo->subdevices_count = pstr->substream_count;\n\tinfo->subdevices_avail = pstr->substream_count - pstr->substream_opened;\n\tstrlcpy(info->subname, substream->name, sizeof(info->subname));\n\truntime = substream->runtime;\n\n\treturn 0;\n}", "target": 2, "idx": 11295}
{"commit_id": "00d5e9e9fb377f52ab7696f25c1dbc011ef0244d", "project": "wireshark", "func": "static guint\ndissect_compressed_beamforming_and_cqi(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)\n{\n  int byte_count = 0;\n  guint64 mimo_cntl = tvb_get_letoh40(tvb, offset);\n  int nc = 0, nr = 0, i;\n  int bw, grouping, codebook, feedback, bit_offset, scidx;\n  int phi_bits = 0, psi_bits = 0;\n  proto_tree *snr_tree = NULL, *feedback_tree = NULL;\n  int start_offset;\n  int ru_start_index, ru_end_index;\n\n  nc = (int)((mimo_cntl & 0x07) + 1);\n  nr = (int)(((mimo_cntl >> 3) & 0x07) + 1);\n  bw = (int)((mimo_cntl >> 6) & 0x03);\n  grouping = (int)((mimo_cntl >> 8) & 0x01);\n  codebook = (int)((mimo_cntl >> 9) & 0x01);\n  feedback = (int)((mimo_cntl >> 10) & 0x03);\n  ru_start_index = (int)((mimo_cntl >> 16) & 0x7F);\n  ru_end_index = (int)((mimo_cntl >> 23) & 0x7F);\n\n  proto_tree_add_bitmask_with_flags(tree, tvb, offset,\n    hf_ieee80211_he_mimo_control_field, ett_ff_he_mimo_control,\n    he_mimo_control_headers, ENC_LITTLE_ENDIAN,\n    BMT_NO_APPEND);\n  offset += 5;\n\n  snr_tree = proto_tree_add_subtree(tree, tvb, offset, nc,\n                ett_ff_he_mimo_beamforming_report_snr, NULL,\n                \"Average Signal to Noise Ratio\");\n\n  for (i = 0; i < nc; i++) {\n    gint8 snr = tvb_get_guint8(tvb, offset);\n\n    proto_tree_add_uint_format(snr_tree,\n        hf_ieee80211_he_compressed_beamforming_report_snr, tvb, offset, 1,\n        snr, \"Stream %d: %s%0.2fdB (0x%02x)\", i, (snr == 127 ? \">=\" :\n                                                  (snr == -128 ? \"<=\" : \"\")),\n                                             (float)((float)88 + snr)/4,\n                                             (guint8)snr);\n    offset++;\n  }\n\n  /*\n   * The rest of the data consists of the compressed beamforming matrices, one\n   * for each SCIDX per group. Each matrix consists of phi and psi angles\n   * encoded using the number of bits specified using the codebook field.\n   *\n   * The matrices contain a number entries related to Nr -1 & Nc except when\n   * Nr == Nc, and then it is Nr -1 x Nc -1, with Nr - 1 phi angles, Nc - 1\n   * psi angles, Nr - 2 phi angles, Nc - 2 psi angles ...\n   */\n  if (feedback == 0) {  /* SU */\n    if (codebook == 0) {\n      phi_bits = 2; psi_bits = 4;\n    } else {\n      phi_bits = 4; psi_bits = 6;\n    }\n  } else if (feedback == 1) { /* MU */\n    if (grouping == 1) {\n      phi_bits = 9; psi_bits = 7;\n    } else {\n      if (codebook == 0) {\n        phi_bits = 5; psi_bits = 7;\n      } else {\n        phi_bits = 7; psi_bits = 9;\n      }\n    }\n  }  /* DO something about CQI etc. */\n\n  feedback_tree = proto_tree_add_subtree(tree, tvb, offset, -1,\n                        ett_ff_he_mimo_feedback_matrices, NULL,\n                        \"Feedback Matrices\");\n\n  start_offset = offset;\n  bit_offset = offset * 8;\n  scidx = SCIDX_END_SENTINAL;\n  while ((scidx = next_he_scidx(scidx, bw, grouping, feedback,\n          ru_start_index, ru_end_index)) != (int)SCIDX_END_SENTINAL) {\n    int prev_bit_offset = bit_offset;\n    bit_offset = dissect_he_feedback_matrix(feedback_tree, tvb, offset,\n                        bit_offset, scidx, nr, nc, phi_bits, psi_bits);\n    if (bit_offset <= prev_bit_offset) {\n      expert_add_info(pinfo, tree, &ei_ieee80211_bad_length);\n      break;\n    }\n\n    offset = bit_offset / 8;\n  }\n\n  offset = (bit_offset + 7) / 8;\n  proto_item_set_len(feedback_tree, offset - start_offset);\n\n  /* Sometimes the FCS is in the buffer as well ... */\n  byte_count = tvb_reported_length_remaining(tvb, offset);\n  if (byte_count > 0)\n    offset += byte_count; /* Should fix the real problem */\n\n  return offset;\n}", "target": 2, "idx": 11296}
{"commit_id": "5408a6d93f45bf1f7acd9ae5d44e0ebd77379e98", "project": "pcmacdon/jsish", "func": "static Jsi_RC jsi_ArrayFindSubCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr, int op) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) \n        return Jsi_LogError(\"expected array\");\n    Jsi_Obj *obj;\n    uint i;\n    Jsi_RC rc = JSI_OK;\n    Jsi_Value *func, *vpargs, *sthis = Jsi_ValueArrayIndex(interp, args, 1);\n\n    func = Jsi_ValueArrayIndex(interp, args, 0);\n    if (!Jsi_ValueIsFunction(interp, func)) \n        return Jsi_LogError(\"expected function\");\n    Jsi_Value *nthis = NULL;\n    if (!sthis)\n        sthis = nthis = Jsi_ValueNew1(interp);\n\n    obj = _this->d.obj;\n    Jsi_ObjListifyArray(interp, obj);\n    int fval = 0;\n    Jsi_Value *nrPtr = Jsi_ValueNew1(interp);\n    Jsi_Value *vobjs[3];\n    Jsi_Func *fptr = func->d.obj->d.fobj->func;\n    int maa = (fptr->argnames?fptr->argnames->argCnt:0);\n    if (maa>3)\n        maa = 3;\n    for (i = 0; i < obj->arrCnt && rc == JSI_OK; i++) {\n        if (!obj->arr[i]) continue;\n        vobjs[0] = obj->arr[i];\n        vobjs[1] = (maa>1?Jsi_ValueNewNumber(interp, i):NULL);\n        vobjs[2] = _this;\n        vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, vobjs, maa, 0));\n        Jsi_IncrRefCount(interp, vpargs);\n        rc = Jsi_FunctionInvoke(interp, func, vpargs, &nrPtr, sthis);\n        Jsi_DecrRefCount(interp, vpargs);\n        if (rc != JSI_OK)\n            break;\n        fval = Jsi_ValueIsTrue(interp, nrPtr);\n        Jsi_ValueMakeUndef(interp, &nrPtr);\n        if (op == 3) {\n            if (!fval) break;\n        } else if (fval)\n            break;\n    }\n    if (rc == JSI_OK) {\n        if (op == 1 && fval) // Find\n            Jsi_ValueCopy(interp, *ret, obj->arr[i]); \n        else if (op == 2 || op == 3) // Some/Every\n            Jsi_ValueMakeBool(interp, ret, fval);\n        else if (op == 4)\n            Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)(fval?(int)i:-1));\n    }\n    if (nthis)\n        Jsi_DecrRefCount(interp, nthis);\n    Jsi_DecrRefCount(interp, nrPtr);\n    return rc;\n\n}", "target": 3, "idx": 11297}
{"commit_id": "ef4a29a62ab48b8dc235f4af52cfd6319eda9a6a", "project": "thorfdbg/libjpeg", "func": "void ACSequentialScan::DecodeBlock(LONG *block,\n                                   LONG &prevdc,LONG &prevdiff,\n                                   UBYTE small,UBYTE large,UBYTE kx,UBYTE dc,UBYTE ac)\n{\n  // DC coding\n  if (m_ucScanStart == 0 && m_bResidual == false) {\n    LONG diff;\n    struct QMContextSet::DCContextZeroSet &cz = m_Context[dc].Classify(prevdiff,small,large);\n    // Check whether the difference is nonzero.\n    if (m_Coder.Get(cz.S0)) {\n      LONG sz;\n      bool sign = m_Coder.Get(cz.SS); // sign coding, is true for negative.\n      //\n      //\n      // Positive and negative are encoded in different contexts.\n      // Decode the magnitude cathegory.\n      if (m_Coder.Get((sign)?(cz.SN):(cz.SP))) {\n        int  i = 0;\n        LONG m = 2;\n        \n        while(m_Coder.Get(m_Context[dc].DCMagnitude.X[i])) {\n          m <<= 1;\n          if(++i >= QMContextSet::DCContextMagnitudeSet::MagnitudeContexts)\n            JPG_THROW(MALFORMED_STREAM,\"ACSequentialScan::DecodeBlock\",\n                      \"QMDecoder is out of sync\");\n        }\n        //\n        // Get the MSB to decode.\n        m >>= 1;\n        sz  = m;\n        //\n        // Refinement coding of remaining bits.\n        while((m >>= 1)) {\n          if (m_Coder.Get(m_Context[dc].DCMagnitude.M[i])) {\n            sz |= m;\n          }\n        }\n      } else {\n        sz = 0;\n      }\n      //\n      // Done, finally, include the sign and the offset.\n      if (sign) {\n        diff = -sz - 1;\n      } else {\n        diff = sz + 1;\n      }\n    } else {\n      // Difference is zero.\n      diff = 0;\n    }\n\n    prevdiff = diff;\n    if (m_bDifferential) {\n      prevdc   = diff;\n    } else {\n      prevdc  += diff;\n    }\n    block[0] = prevdc << m_ucLowBit; // point transformation\n  }\n\n  if (m_ucScanStop) {\n    // AC coding. No block skipping used here.\n    int k = (m_ucScanStart)?(m_ucScanStart):((m_bResidual)?0:1);\n    //\n    // EOB decoding.\n    while(k <= m_ucScanStop && !m_Coder.Get(m_Context[ac].ACZero[k-1].SE)) {\n      LONG sz;\n      bool sign;\n      //\n      // Not yet EOB. Run coding in S0: Skip over zeros.\n      while(!m_Coder.Get(m_Context[ac].ACZero[k-1].S0)) {\n        k++;\n        if (k > m_ucScanStop)\n          JPG_THROW(MALFORMED_STREAM,\"ACSequentialScan::DecodeBlock\",\n                    \"QMDecoder is out of sync\");\n      }\n      //\n      // Now decode the sign of the coefficient.\n      // This happens in the uniform context.\n      sign = m_Coder.Get(m_Context[ac].Uniform);\n      //\n      // Decode the magnitude.\n      if (m_Coder.Get(m_Context[ac].ACZero[k-1].SP)) {\n        // X1 coding, identical to SN and SP.\n        if (m_Coder.Get(m_Context[ac].ACZero[k-1].SP)) {\n          int  i = 0;\n          LONG m = 4;\n          struct QMContextSet::ACContextMagnitudeSet &acm = (k > kx)?(m_Context[ac].ACMagnitudeHigh):(m_Context[ac].ACMagnitudeLow);\n          \n          while(m_Coder.Get(acm.X[i])) {\n            m <<= 1;\n            if(++i >= QMContextSet::ACContextMagnitudeSet::MagnitudeContexts)\n              JPG_THROW(MALFORMED_STREAM,\"ACSequentialScan::DecodeBlock\",\n                        \"QMDecoder is out of sync\");\n          }\n          //\n          // Get the MSB to decode\n          m >>= 1;\n          sz  = m;\n          //\n          // Proceed to refinement.\n          while((m >>= 1)) {\n            if (m_Coder.Get(acm.M[i])) {\n              sz |= m;\n            }\n          }\n        } else {\n          sz = 1;\n        }\n      } else {\n        sz = 0;\n      }\n      //\n      // Done. Finally, include sign and offset.\n      sz++;\n      if (sign) \n        sz = -sz;\n      block[DCT::ScanOrder[k]] = sz << m_ucLowBit;\n      //\n      // Proceed to the next block.\n      k++;\n    }\n  }\n}", "target": 1, "idx": 11298}
{"commit_id": "5443b57cc54f2e46b35246637be26a69e9f493e1", "project": "android", "func": "SoftAACEncoder::~SoftAACEncoder() {\n    onReset();\n\n    if (mEncoderHandle) {\n        CHECK_EQ(VO_ERR_NONE, mApiHandle->Uninit(mEncoderHandle));\n        mEncoderHandle = NULL;\n    }\n\n    delete mApiHandle;\n    mApiHandle = NULL;\n\n    delete mMemOperator;\n    mMemOperator = NULL;\n}", "target": 2, "idx": 11299}
{"commit_id": "d515b4b4a300479cdf1a6e0d1bb95bc1f9fee514", "project": "the-tcpdump-group/tcpdump", "func": "static int\ndecode_multicast_vpn(netdissect_options *ndo,\n                     const u_char *pptr, char *buf, u_int buflen)\n{\n        uint8_t route_type, route_length, addr_length, sg_length;\n        u_int offset;\n\n\tND_TCHECK2(pptr[0], 2);\n        route_type = *pptr++;\n        route_length = *pptr++;\n\n        snprintf(buf, buflen, \"Route-Type: %s (%u), length: %u\",\n                 tok2str(bgp_multicast_vpn_route_type_values,\n                         \"Unknown\", route_type),\n                 route_type, route_length);\n\n        switch(route_type) {\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_INTRA_AS_I_PMSI:\n            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN);\n            offset = strlen(buf);\n            snprintf(buf + offset, buflen - offset, \", RD: %s, Originator %s\",\n                     bgp_vpn_rd_print(ndo, pptr),\n                     bgp_vpn_ip_print(ndo, pptr + BGP_VPN_RD_LEN,\n                                      (route_length - BGP_VPN_RD_LEN) << 3));\n            break;\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_INTER_AS_I_PMSI:\n            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN + 4);\n            offset = strlen(buf);\n\t    snprintf(buf + offset, buflen - offset, \", RD: %s, Source-AS %s\",\n\t\tbgp_vpn_rd_print(ndo, pptr),\n\t\tas_printf(ndo, astostr, sizeof(astostr),\n\t\tEXTRACT_32BITS(pptr + BGP_VPN_RD_LEN)));\n            break;\n\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_S_PMSI:\n            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN);\n            offset = strlen(buf);\n            snprintf(buf + offset, buflen - offset, \", RD: %s\",\n                     bgp_vpn_rd_print(ndo, pptr));\n            pptr += BGP_VPN_RD_LEN;\n\n            sg_length = bgp_vpn_sg_print(ndo, pptr, buf, buflen);\n            addr_length =  route_length - sg_length;\n\n            ND_TCHECK2(pptr[0], addr_length);\n            offset = strlen(buf);\n            snprintf(buf + offset, buflen - offset, \", Originator %s\",\n                     bgp_vpn_ip_print(ndo, pptr, addr_length << 3));\n            break;\n\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_ACTIVE:\n            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN);\n            offset = strlen(buf);\n            snprintf(buf + offset, buflen - offset, \", RD: %s\",\n                     bgp_vpn_rd_print(ndo, pptr));\n            pptr += BGP_VPN_RD_LEN;\n\n            bgp_vpn_sg_print(ndo, pptr, buf, buflen);\n            break;\n\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_SHARED_TREE_JOIN: /* fall through */\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_TREE_JOIN:\n            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN + 4);\n            offset = strlen(buf);\n\t    snprintf(buf + offset, buflen - offset, \", RD: %s, Source-AS %s\",\n\t\tbgp_vpn_rd_print(ndo, pptr),\n\t\tas_printf(ndo, astostr, sizeof(astostr),\n\t\tEXTRACT_32BITS(pptr + BGP_VPN_RD_LEN)));\n            pptr += BGP_VPN_RD_LEN + 4;\n\n            bgp_vpn_sg_print(ndo, pptr, buf, buflen);\n            break;\n\n            /*\n             * no per route-type printing yet.\n             */\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_INTRA_AS_SEG_LEAF:\n        default:\n            break;\n        }\n\n        return route_length + 2;\n\ntrunc:\n\treturn -2;\n}", "target": 3, "idx": 11300}
{"commit_id": "9c23f9bb5fe435b28245ba8ac65aa0ca6b902c04", "project": "vim", "func": "ufunc_T *\ndefine_function(exarg_T *eap, char_u *name_arg, char_u **line_to_free)\n{\n    int\t\tj;\n    int\t\tc;\n    int\t\tsaved_did_emsg;\n    char_u\t*name = name_arg;\n    int\t\tis_global = FALSE;\n    char_u\t*p;\n    char_u\t*arg;\n    char_u\t*whitep;\n    char_u\t*line_arg = NULL;\n    garray_T\tnewargs;\n    garray_T\targtypes;\n    garray_T\tdefault_args;\n    garray_T\tnewlines;\n    int\t\tvarargs = FALSE;\n    int\t\tflags = 0;\n    char_u\t*ret_type = NULL;\n    ufunc_T\t*fp = NULL;\n    int\t\tfp_allocated = FALSE;\n    int\t\tfree_fp = FALSE;\n    int\t\toverwrite = FALSE;\n    dictitem_T\t*v;\n    funcdict_T\tfudi;\n    static int\tfunc_nr = 0;\t    // number for nameless function\n    int\t\tparen;\n    hashitem_T\t*hi;\n    linenr_T\tsourcing_lnum_top;\n    int\t\tvim9script = in_vim9script();\n    imported_T\t*import = NULL;\n\n    /*\n     * \":function\" without argument: list functions.\n     */\n    if (ends_excmd2(eap->cmd, eap->arg))\n    {\n\tif (!eap->skip)\n\t    list_functions(NULL);\n\tset_nextcmd(eap, eap->arg);\n\treturn NULL;\n    }\n\n    /*\n     * \":function /pat\": list functions matching pattern.\n     */\n    if (*eap->arg == '/')\n    {\n\tp = skip_regexp(eap->arg + 1, '/', TRUE);\n\tif (!eap->skip)\n\t{\n\t    regmatch_T\tregmatch;\n\n\t    c = *p;\n\t    *p = NUL;\n\t    regmatch.regprog = vim_regcomp(eap->arg + 1, RE_MAGIC);\n\t    *p = c;\n\t    if (regmatch.regprog != NULL)\n\t    {\n\t\tregmatch.rm_ic = p_ic;\n\t\tlist_functions(&regmatch);\n\t\tvim_regfree(regmatch.regprog);\n\t    }\n\t}\n\tif (*p == '/')\n\t    ++p;\n\tset_nextcmd(eap, p);\n\treturn NULL;\n    }\n\n    ga_init(&newargs);\n    ga_init(&argtypes);\n    ga_init(&default_args);\n\n    /*\n     * Get the function name.  There are these situations:\n     * func\t    normal function name\n     *\t\t    \"name\" == func, \"fudi.fd_dict\" == NULL\n     * dict.func    new dictionary entry\n     *\t\t    \"name\" == NULL, \"fudi.fd_dict\" set,\n     *\t\t    \"fudi.fd_di\" == NULL, \"fudi.fd_newkey\" == func\n     * dict.func    existing dict entry with a Funcref\n     *\t\t    \"name\" == func, \"fudi.fd_dict\" set,\n     *\t\t    \"fudi.fd_di\" set, \"fudi.fd_newkey\" == NULL\n     * dict.func    existing dict entry that's not a Funcref\n     *\t\t    \"name\" == NULL, \"fudi.fd_dict\" set,\n     *\t\t    \"fudi.fd_di\" set, \"fudi.fd_newkey\" == NULL\n     * s:func\t    script-local function name\n     * g:func\t    global function name, same as \"func\"\n     */\n    p = eap->arg;\n    if (name_arg != NULL)\n    {\n\t// nested function, argument is (args).\n\tparen = TRUE;\n\tCLEAR_FIELD(fudi);\n    }\n    else\n    {\n\tname = save_function_name(&p, &is_global, eap->skip,\n\t\t\t\t\t\t       TFN_NO_AUTOLOAD, &fudi);\n\tparen = (vim_strchr(p, '(') != NULL);\n\tif (name == NULL && (fudi.fd_dict == NULL || !paren) && !eap->skip)\n\t{\n\t    /*\n\t     * Return on an invalid expression in braces, unless the expression\n\t     * evaluation has been cancelled due to an aborting error, an\n\t     * interrupt, or an exception.\n\t     */\n\t    if (!aborting())\n\t    {\n\t\tif (!eap->skip && fudi.fd_newkey != NULL)\n\t\t    semsg(_(e_dictkey), fudi.fd_newkey);\n\t\tvim_free(fudi.fd_newkey);\n\t\treturn NULL;\n\t    }\n\t    else\n\t\teap->skip = TRUE;\n\t}\n    }\n\n    // An error in a function call during evaluation of an expression in magic\n    // braces should not cause the function not to be defined.\n    saved_did_emsg = did_emsg;\n    did_emsg = FALSE;\n\n    /*\n     * \":function func\" with only function name: list function.\n     */\n    if (!paren)\n    {\n\tif (!ends_excmd(*skipwhite(p)))\n\t{\n\t    semsg(_(e_trailing_arg), p);\n\t    goto ret_free;\n\t}\n\tset_nextcmd(eap, p);\n\tif (eap->nextcmd != NULL)\n\t    *p = NUL;\n\tif (!eap->skip && !got_int)\n\t{\n\t    fp = find_func(name, is_global, NULL);\n\t    if (fp == NULL && ASCII_ISUPPER(*eap->arg))\n\t    {\n\t\tchar_u *up = untrans_function_name(name);\n\n\t\t// With Vim9 script the name was made script-local, if not\n\t\t// found try again with the original name.\n\t\tif (up != NULL)\n\t\t    fp = find_func(up, FALSE, NULL);\n\t    }\n\n\t    if (fp != NULL)\n\t    {\n\t\tlist_func_head(fp, TRUE);\n\t\tfor (j = 0; j < fp->uf_lines.ga_len && !got_int; ++j)\n\t\t{\n\t\t    if (FUNCLINE(fp, j) == NULL)\n\t\t\tcontinue;\n\t\t    msg_putchar('\\n');\n\t\t    msg_outnum((long)(j + 1));\n\t\t    if (j < 9)\n\t\t\tmsg_putchar(' ');\n\t\t    if (j < 99)\n\t\t\tmsg_putchar(' ');\n\t\t    msg_prt_line(FUNCLINE(fp, j), FALSE);\n\t\t    out_flush();\t// show a line at a time\n\t\t    ui_breakcheck();\n\t\t}\n\t\tif (!got_int)\n\t\t{\n\t\t    msg_putchar('\\n');\n\t\t    if (fp->uf_def_status != UF_NOT_COMPILED)\n\t\t\tmsg_puts(\"   enddef\");\n\t\t    else\n\t\t\tmsg_puts(\"   endfunction\");\n\t\t}\n\t    }\n\t    else\n\t\temsg_funcname(N_(\"E123: Undefined function: %s\"), eap->arg);\n\t}\n\tgoto ret_free;\n    }\n\n    /*\n     * \":function name(arg1, arg2)\" Define function.\n     */\n    p = skipwhite(p);\n    if (*p != '(')\n    {\n\tif (!eap->skip)\n\t{\n\t    semsg(_(\"E124: Missing '(': %s\"), eap->arg);\n\t    goto ret_free;\n\t}\n\t// attempt to continue by skipping some text\n\tif (vim_strchr(p, '(') != NULL)\n\t    p = vim_strchr(p, '(');\n    }\n\n    if ((vim9script || eap->cmdidx == CMD_def) && VIM_ISWHITE(p[-1]))\n    {\n\tsemsg(_(e_no_white_space_allowed_before_str_str), \"(\", p - 1);\n\tgoto ret_free;\n    }\n\n    // In Vim9 script only global functions can be redefined.\n    if (vim9script && eap->forceit && !is_global)\n    {\n\temsg(_(e_nobang));\n\tgoto ret_free;\n    }\n\n    ga_init2(&newlines, (int)sizeof(char_u *), 10);\n\n    if (!eap->skip && name_arg == NULL)\n    {\n\t// Check the name of the function.  Unless it's a dictionary function\n\t// (that we are overwriting).\n\tif (name != NULL)\n\t    arg = name;\n\telse\n\t    arg = fudi.fd_newkey;\n\tif (arg != NULL && (fudi.fd_di == NULL\n\t\t\t\t     || (fudi.fd_di->di_tv.v_type != VAR_FUNC\n\t\t\t\t && fudi.fd_di->di_tv.v_type != VAR_PARTIAL)))\n\t{\n\t    char_u  *name_base = arg;\n\t    int\t    i;\n\n\t    if (*arg == K_SPECIAL)\n\t    {\n\t\tname_base = vim_strchr(arg, '_');\n\t\tif (name_base == NULL)\n\t\t    name_base = arg + 3;\n\t\telse\n\t\t    ++name_base;\n\t    }\n\t    for (i = 0; name_base[i] != NUL && (i == 0\n\t\t\t\t\t? eval_isnamec1(name_base[i])\n\t\t\t\t\t: eval_isnamec(name_base[i])); ++i)\n\t\t;\n\t    if (name_base[i] != NUL)\n\t\temsg_funcname((char *)e_invarg2, arg);\n\n\t    // In Vim9 script a function cannot have the same name as a\n\t    // variable.\n\t    if (vim9script && *arg == K_SPECIAL\n\t\t&& eval_variable(name_base, (int)STRLEN(name_base), NULL, NULL,\n\t\t\t EVAL_VAR_NOAUTOLOAD + EVAL_VAR_IMPORT\n\t\t\t\t\t\t     + EVAL_VAR_NO_FUNC) == OK)\n\t    {\n\t\tsemsg(_(e_redefining_script_item_str), name_base);\n\t\tgoto ret_free;\n\t    }\n\t}\n\t// Disallow using the g: dict.\n\tif (fudi.fd_dict != NULL && fudi.fd_dict->dv_scope == VAR_DEF_SCOPE)\n\t{\n\t    emsg(_(\"E862: Cannot use g: here\"));\n\t    goto ret_free;\n\t}\n    }\n\n    // This may get more lines and make the pointers into the first line\n    // invalid.\n    ++p;\n    if (get_function_args(&p, ')', &newargs,\n\t\t\teap->cmdidx == CMD_def ? &argtypes : NULL, FALSE,\n\t\t\t NULL, &varargs, &default_args, eap->skip,\n\t\t\t eap, line_to_free) == FAIL)\n\tgoto errret_2;\n    whitep = p;\n\n    if (eap->cmdidx == CMD_def)\n    {\n\t// find the return type: :def Func(): type\n\tif (*skipwhite(p) == ':')\n\t{\n\t    if (*p != ':')\n\t    {\n\t\tsemsg(_(e_no_white_space_allowed_before_colon_str), p);\n\t\tp = skipwhite(p);\n\t    }\n\t    else if (!IS_WHITE_OR_NUL(p[1]))\n\t\tsemsg(_(e_white_space_required_after_str_str), \":\", p);\n\t    ret_type = skipwhite(p + 1);\n\t    p = skip_type(ret_type, FALSE);\n\t    if (p > ret_type)\n\t    {\n\t\tret_type = vim_strnsave(ret_type, p - ret_type);\n\t\twhitep = p;\n\t\tp = skipwhite(p);\n\t    }\n\t    else\n\t    {\n\t\tsemsg(_(e_expected_type_str), ret_type);\n\t\tret_type = NULL;\n\t    }\n\t}\n\tp = skipwhite(p);\n    }\n    else\n\t// find extra arguments \"range\", \"dict\", \"abort\" and \"closure\"\n\tfor (;;)\n\t{\n\t    whitep = p;\n\t    p = skipwhite(p);\n\t    if (STRNCMP(p, \"range\", 5) == 0)\n\t    {\n\t\tflags |= FC_RANGE;\n\t\tp += 5;\n\t    }\n\t    else if (STRNCMP(p, \"dict\", 4) == 0)\n\t    {\n\t\tflags |= FC_DICT;\n\t\tp += 4;\n\t    }\n\t    else if (STRNCMP(p, \"abort\", 5) == 0)\n\t    {\n\t\tflags |= FC_ABORT;\n\t\tp += 5;\n\t    }\n\t    else if (STRNCMP(p, \"closure\", 7) == 0)\n\t    {\n\t\tflags |= FC_CLOSURE;\n\t\tp += 7;\n\t\tif (current_funccal == NULL)\n\t\t{\n\t\t    emsg_funcname(N_(\"E932: Closure function should not be at top level: %s\"),\n\t\t\t    name == NULL ? (char_u *)\"\" : name);\n\t\t    goto erret;\n\t\t}\n\t    }\n\t    else\n\t\tbreak;\n\t}\n\n    // When there is a line break use what follows for the function body.\n    // Makes 'exe \"func Test()\\n...\\nendfunc\"' work.\n    if (*p == '\\n')\n\tline_arg = p + 1;\n    else if (*p != NUL\n\t    && !(*p == '\"' && (!vim9script || eap->cmdidx == CMD_function)\n\t\t\t\t\t\t     && eap->cmdidx != CMD_def)\n\t    && !(VIM_ISWHITE(*whitep) && *p == '#'\n\t\t\t\t     && (vim9script || eap->cmdidx == CMD_def))\n\t    && !eap->skip\n\t    && !did_emsg)\n\tsemsg(_(e_trailing_arg), p);\n\n    /*\n     * Read the body of the function, until \"}\", \":endfunction\" or \":enddef\" is\n     * found.\n     */\n    if (KeyTyped)\n    {\n\t// Check if the function already exists, don't let the user type the\n\t// whole function before telling him it doesn't work!  For a script we\n\t// need to skip the body to be able to find what follows.\n\tif (!eap->skip && !eap->forceit)\n\t{\n\t    if (fudi.fd_dict != NULL && fudi.fd_newkey == NULL)\n\t\temsg(_(e_funcdict));\n\t    else if (name != NULL && find_func(name, is_global, NULL) != NULL)\n\t\temsg_funcname(e_funcexts, name);\n\t}\n\n\tif (!eap->skip && did_emsg)\n\t    goto erret;\n\n\tmsg_putchar('\\n');\t    // don't overwrite the function name\n\tcmdline_row = msg_row;\n    }\n\n    // Save the starting line number.\n    sourcing_lnum_top = SOURCING_LNUM;\n\n    // Do not define the function when getting the body fails and when\n    // skipping.\n    if (get_function_body(eap, &newlines, line_arg, line_to_free) == FAIL\n\t    || eap->skip)\n\tgoto erret;\n\n    /*\n     * If there are no errors, add the function\n     */\n    if (fudi.fd_dict == NULL)\n    {\n\thashtab_T\t*ht;\n\n\tv = find_var(name, &ht, TRUE);\n\tif (v != NULL && v->di_tv.v_type == VAR_FUNC)\n\t{\n\t    emsg_funcname(N_(\"E707: Function name conflicts with variable: %s\"),\n\t\t\t\t\t\t\t\t\tname);\n\t    goto erret;\n\t}\n\n\tfp = find_func_even_dead(name, is_global, NULL);\n\tif (vim9script)\n\t{\n\t    char_u *uname = untrans_function_name(name);\n\n\t    import = find_imported(uname == NULL ? name : uname, 0, NULL);\n\t}\n\n\tif (fp != NULL || import != NULL)\n\t{\n\t    int dead = fp != NULL && (fp->uf_flags & FC_DEAD);\n\n\t    // Function can be replaced with \"function!\" and when sourcing the\n\t    // same script again, but only once.\n\t    // A name that is used by an import can not be overruled.\n\t    if (import != NULL\n\t\t    || (!dead && !eap->forceit\n\t\t\t&& (fp->uf_script_ctx.sc_sid != current_sctx.sc_sid\n\t\t\t  || fp->uf_script_ctx.sc_seq == current_sctx.sc_seq)))\n\t    {\n\t\tSOURCING_LNUM = sourcing_lnum_top;\n\t\tif (vim9script)\n\t\t    emsg_funcname(e_name_already_defined_str, name);\n\t\telse\n\t\t    emsg_funcname(e_funcexts, name);\n\t\tgoto erret;\n\t    }\n\t    if (fp->uf_calls > 0)\n\t    {\n\t\temsg_funcname(\n\t\t\tN_(\"E127: Cannot redefine function %s: It is in use\"),\n\t\t\t\t\t\t\t\t\tname);\n\t\tgoto erret;\n\t    }\n\t    if (fp->uf_refcount > 1)\n\t    {\n\t\t// This function is referenced somewhere, don't redefine it but\n\t\t// create a new one.\n\t\t--fp->uf_refcount;\n\t\tfp->uf_flags |= FC_REMOVED;\n\t\tfp = NULL;\n\t\toverwrite = TRUE;\n\t    }\n\t    else\n\t    {\n\t\tchar_u *exp_name = fp->uf_name_exp;\n\n\t\t// redefine existing function, keep the expanded name\n\t\tVIM_CLEAR(name);\n\t\tfp->uf_name_exp = NULL;\n\t\tfunc_clear_items(fp);\n\t\tfp->uf_name_exp = exp_name;\n\t\tfp->uf_flags &= ~FC_DEAD;\n#ifdef FEAT_PROFILE\n\t\tfp->uf_profiling = FALSE;\n\t\tfp->uf_prof_initialized = FALSE;\n#endif\n\t\tfp->uf_def_status = UF_NOT_COMPILED;\n\t    }\n\t}\n    }\n    else\n    {\n\tchar\tnumbuf[20];\n\n\tfp = NULL;\n\tif (fudi.fd_newkey == NULL && !eap->forceit)\n\t{\n\t    emsg(_(e_funcdict));\n\t    goto erret;\n\t}\n\tif (fudi.fd_di == NULL)\n\t{\n\t    // Can't add a function to a locked dictionary\n\t    if (value_check_lock(fudi.fd_dict->dv_lock, eap->arg, FALSE))\n\t\tgoto erret;\n\t}\n\t    // Can't change an existing function if it is locked\n\telse if (value_check_lock(fudi.fd_di->di_tv.v_lock, eap->arg, FALSE))\n\t    goto erret;\n\n\t// Give the function a sequential number.  Can only be used with a\n\t// Funcref!\n\tvim_free(name);\n\tsprintf(numbuf, \"%d\", ++func_nr);\n\tname = vim_strsave((char_u *)numbuf);\n\tif (name == NULL)\n\t    goto erret;\n    }\n\n    if (fp == NULL)\n    {\n\tif (fudi.fd_dict == NULL && vim_strchr(name, AUTOLOAD_CHAR) != NULL)\n\t{\n\t    int\t    slen, plen;\n\t    char_u  *scriptname;\n\n\t    // Check that the autoload name matches the script name.\n\t    j = FAIL;\n\t    if (SOURCING_NAME != NULL)\n\t    {\n\t\tscriptname = autoload_name(name);\n\t\tif (scriptname != NULL)\n\t\t{\n\t\t    p = vim_strchr(scriptname, '/');\n\t\t    plen = (int)STRLEN(p);\n\t\t    slen = (int)STRLEN(SOURCING_NAME);\n\t\t    if (slen > plen && fnamecmp(p,\n\t\t\t\t\t    SOURCING_NAME + slen - plen) == 0)\n\t\t\tj = OK;\n\t\t    vim_free(scriptname);\n\t\t}\n\t    }\n\t    if (j == FAIL)\n\t    {\n\t\tlinenr_T save_lnum = SOURCING_LNUM;\n\n\t\tSOURCING_LNUM = sourcing_lnum_top;\n\t\tsemsg(_(\"E746: Function name does not match script file name: %s\"), name);\n\t\tSOURCING_LNUM = save_lnum;\n\t\tgoto erret;\n\t    }\n\t}\n\n\tfp = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);\n\tif (fp == NULL)\n\t    goto erret;\n\tfp_allocated = TRUE;\n\n\tif (fudi.fd_dict != NULL)\n\t{\n\t    if (fudi.fd_di == NULL)\n\t    {\n\t\t// add new dict entry\n\t\tfudi.fd_di = dictitem_alloc(fudi.fd_newkey);\n\t\tif (fudi.fd_di == NULL)\n\t\t{\n\t\t    vim_free(fp);\n\t\t    fp = NULL;\n\t\t    goto erret;\n\t\t}\n\t\tif (dict_add(fudi.fd_dict, fudi.fd_di) == FAIL)\n\t\t{\n\t\t    vim_free(fudi.fd_di);\n\t\t    vim_free(fp);\n\t\t    fp = NULL;\n\t\t    goto erret;\n\t\t}\n\t    }\n\t    else\n\t\t// overwrite existing dict entry\n\t\tclear_tv(&fudi.fd_di->di_tv);\n\t    fudi.fd_di->di_tv.v_type = VAR_FUNC;\n\t    fudi.fd_di->di_tv.vval.v_string = vim_strsave(name);\n\n\t    // behave like \"dict\" was used\n\t    flags |= FC_DICT;\n\t}\n    }\n    fp->uf_args = newargs;\n    fp->uf_def_args = default_args;\n    fp->uf_ret_type = &t_any;\n    fp->uf_func_type = &t_func_any;\n\n    if (eap->cmdidx == CMD_def)\n    {\n\tint\t    lnum_save = SOURCING_LNUM;\n\tcstack_T    *cstack = eap->cstack;\n\n\tfp->uf_def_status = UF_TO_BE_COMPILED;\n\n\t// error messages are for the first function line\n\tSOURCING_LNUM = sourcing_lnum_top;\n\n\t// The function may use script variables from the context.\n\tfunction_using_block_scopes(fp, cstack);\n\n\tif (parse_argument_types(fp, &argtypes, varargs) == FAIL)\n\t{\n\t    SOURCING_LNUM = lnum_save;\n\t    free_fp = fp_allocated;\n\t    goto erret;\n\t}\n\tvarargs = FALSE;\n\n\t// parse the return type, if any\n\tif (parse_return_type(fp, ret_type) == FAIL)\n\t{\n\t    SOURCING_LNUM = lnum_save;\n\t    free_fp = fp_allocated;\n\t    goto erret;\n\t}\n\tSOURCING_LNUM = lnum_save;\n    }\n    else\n\tfp->uf_def_status = UF_NOT_COMPILED;\n\n    if (fp_allocated)\n    {\n\t// insert the new function in the function list\n\tset_ufunc_name(fp, name);\n\tif (overwrite)\n\t{\n\t    hi = hash_find(&func_hashtab, name);\n\t    hi->hi_key = UF2HIKEY(fp);\n\t}\n\telse if (hash_add(&func_hashtab, UF2HIKEY(fp)) == FAIL)\n\t{\n\t    free_fp = TRUE;\n\t    goto erret;\n\t}\n\tfp->uf_refcount = 1;\n    }\n\n    fp->uf_lines = newlines;\n    newlines.ga_data = NULL;\n    if ((flags & FC_CLOSURE) != 0)\n    {\n\tif (register_closure(fp) == FAIL)\n\t    goto erret;\n    }\n    else\n\tfp->uf_scoped = NULL;\n\n#ifdef FEAT_PROFILE\n    if (prof_def_func())\n\tfunc_do_profile(fp);\n#endif\n    fp->uf_varargs = varargs;\n    if (sandbox)\n\tflags |= FC_SANDBOX;\n    if (vim9script && !ASCII_ISUPPER(*fp->uf_name))\n\tflags |= FC_VIM9;\n    fp->uf_flags = flags;\n    fp->uf_calls = 0;\n    fp->uf_cleared = FALSE;\n    fp->uf_script_ctx = current_sctx;\n    fp->uf_script_ctx_version = current_sctx.sc_version;\n    fp->uf_script_ctx.sc_lnum += sourcing_lnum_top;\n    if (is_export)\n    {\n\tfp->uf_flags |= FC_EXPORT;\n\t// let ex_export() know the export worked.\n\tis_export = FALSE;\n    }\n\n    if (eap->cmdidx == CMD_def)\n\tset_function_type(fp);\n    else if (fp->uf_script_ctx.sc_version == SCRIPT_VERSION_VIM9)\n\t// :func does not use Vim9 script syntax, even in a Vim9 script file\n\tfp->uf_script_ctx.sc_version = SCRIPT_VERSION_MAX;\n\n    goto ret_free;\n\nerret:\n    ga_clear_strings(&newargs);\n    ga_clear_strings(&default_args);\n    if (fp != NULL)\n    {\n\tga_init(&fp->uf_args);\n\tga_init(&fp->uf_def_args);\n    }\nerrret_2:\n    ga_clear_strings(&newlines);\n    if (fp != NULL)\n\tVIM_CLEAR(fp->uf_arg_types);\n    if (free_fp)\n    {\n\tvim_free(fp);\n\tfp = NULL;\n    }\nret_free:\n    ga_clear_strings(&argtypes);\n    vim_free(fudi.fd_newkey);\n    if (name != name_arg)\n\tvim_free(name);\n    vim_free(ret_type);\n    did_emsg |= saved_did_emsg;\n\n    return fp;\n}", "target": 2, "idx": 11301}
{"commit_id": "1a4722a89ee85be74af5086a7027b3ad1e0a55e8", "project": "php/php-src", "func": "gdImagePtr gdImageScaleTwoPass(const gdImagePtr src, const unsigned int src_width, const unsigned int src_height, const unsigned int new_width, const unsigned int new_height)\n{\n\tgdImagePtr tmp_im;\n\tgdImagePtr dst;\n\n\t/* Convert to truecolor if it isn't; this code requires it. */\n\tif (!src->trueColor) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\n\ttmp_im = gdImageCreateTrueColor(new_width, src_height);\n\tif (tmp_im == NULL) {\n\t\treturn NULL;\n\t}\n\tgdImageSetInterpolationMethod(tmp_im, src->interpolation_id);\n\t_gdScaleHoriz(src, src_width, src_height, tmp_im, new_width, src_height);\n\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (dst == NULL) {\n\t\tgdImageDestroy(tmp_im);\n\t\treturn NULL;\n\t}\n\tgdImageSetInterpolationMethod(dst, src->interpolation_id);\n\t_gdScaleVert(tmp_im, new_width, src_height, dst, new_width, new_height);\n\tgdImageDestroy(tmp_im);\n\n\treturn dst;\n}", "target": 2, "idx": 11302}
{"commit_id": "ea13945f3c2dc2c21e30e2731bf2782384307a13", "project": "gpac", "func": "void stbl_del(GF_Box *s)\n{\n\tGF_SampleTableBox *ptr = (GF_SampleTableBox *)s;\n\tif (ptr == NULL) return;\n\n\tif (ptr->ChunkOffset) gf_isom_box_del(ptr->ChunkOffset);\n\tif (ptr->CompositionOffset) gf_isom_box_del((GF_Box *) ptr->CompositionOffset);\n\tif (ptr->CompositionToDecode) gf_isom_box_del((GF_Box *) ptr->CompositionToDecode);\n\tif (ptr->DegradationPriority) gf_isom_box_del((GF_Box *) ptr->DegradationPriority);\n\tif (ptr->SampleDescription) gf_isom_box_del((GF_Box *) ptr->SampleDescription);\n\tif (ptr->SampleSize) gf_isom_box_del((GF_Box *) ptr->SampleSize);\n\tif (ptr->SampleToChunk) gf_isom_box_del((GF_Box *) ptr->SampleToChunk);\n\tif (ptr->ShadowSync) gf_isom_box_del((GF_Box *) ptr->ShadowSync);\n\tif (ptr->SyncSample) gf_isom_box_del((GF_Box *) ptr->SyncSample);\n\tif (ptr->TimeToSample) gf_isom_box_del((GF_Box *) ptr->TimeToSample);\n\tif (ptr->SampleDep) gf_isom_box_del((GF_Box *) ptr->SampleDep);\n\tif (ptr->PaddingBits) gf_isom_box_del((GF_Box *) ptr->PaddingBits);\n\tif (ptr->sub_samples) gf_isom_box_array_del(ptr->sub_samples);\n\tif (ptr->sampleGroups) gf_isom_box_array_del(ptr->sampleGroups);\n\tif (ptr->sampleGroupsDescription) gf_isom_box_array_del(ptr->sampleGroupsDescription);\n\n\tif (ptr->sai_sizes) gf_isom_box_array_del(ptr->sai_sizes);\n\tif (ptr->sai_offsets) gf_isom_box_array_del(ptr->sai_offsets);\n\tif (ptr->traf_map) {\n\t\tif (ptr->traf_map->sample_num) gf_free(ptr->traf_map->sample_num);\n\t\tgf_free(ptr->traf_map);\n\t}\n\n\tgf_free(ptr);\n}", "target": 1, "idx": 11303}
{"commit_id": "3a5474f9102cbdc10fbd9e7b1b2c8d3f3f45d91b", "project": "milkytracker/MilkyTracker", "func": "mp_sint32 LoaderXM::load(XMFileBase& f, XModule* module)\n{\n\tmp_ubyte insData[230];\t\t\n\tmp_sint32 smpReloc[MP_MAXINSSAMPS];\n\tmp_ubyte nbu[MP_MAXINSSAMPS];\n\tmp_uint32 fileSize = 0;\n\t\t\t\n\tmodule->cleanUp();\n\n\t// this will make code much easier to read\n\tTXMHeader*\t\theader = &module->header;\n\tTXMInstrument*\tinstr  = module->instr;\n\tTXMSample*\t\tsmp\t   = module->smp;\n\tTXMPattern*\t\tphead  = module->phead;\t\n\n\t// we're already out of memory here\n\tif (!phead || !instr || !smp)\n\t\treturn MP_OUT_OF_MEMORY;\n\t\n\tfileSize = f.sizeWithBaseOffset();\n\t\n\tf.read(&header->sig,1,17);\n\tf.read(&header->name,1,20);\n\tf.read(&header->whythis1a,1,1);\n\theader->whythis1a=0;\n\tf.read(&header->tracker,1,20);\n\tf.readWords(&header->ver,1);\n\t\n\tif (header->ver != 0x102 && \n\t\theader->ver != 0x103 && // untested\n\t\theader->ver != 0x104)\n\t\treturn MP_LOADER_FAILED;\n\t\n\tf.readDwords(&header->hdrsize,1);\n\t\n\theader->hdrsize-=4;\n\t\n\tmp_uint32 hdrSize = 0x110;\n\tif (header->hdrsize > hdrSize)\n\t\thdrSize = header->hdrsize;\n\t\t\t\t\n\tmp_ubyte* hdrBuff = new mp_ubyte[hdrSize];\n\tmemset(hdrBuff, 0, hdrSize);\n\t\n\tf.read(hdrBuff, 1, header->hdrsize);\n\t\n\theader->ordnum = LittleEndian::GET_WORD(hdrBuff);\n\theader->restart = LittleEndian::GET_WORD(hdrBuff+2);\n\theader->channum = LittleEndian::GET_WORD(hdrBuff+4);\n\theader->patnum = LittleEndian::GET_WORD(hdrBuff+6);\n\theader->insnum = LittleEndian::GET_WORD(hdrBuff+8);\n\theader->freqtab = LittleEndian::GET_WORD(hdrBuff+10);\n\theader->tempo = LittleEndian::GET_WORD(hdrBuff+12);\n\theader->speed = LittleEndian::GET_WORD(hdrBuff+14);\n\tmemcpy(header->ord, hdrBuff+16, 256);\n\tif(header->ordnum > MP_MAXORDERS)\n\t\theader->ordnum = MP_MAXORDERS;\n\tif(header->insnum > MP_MAXINS)\n\t\treturn MP_LOADER_FAILED;\n\n\tdelete[] hdrBuff;\n\t\n\theader->mainvol=255;\n\theader->flags = XModule::MODULE_XMNOTECLIPPING | \n\t\tXModule::MODULE_XMARPEGGIO | \n\t\tXModule::MODULE_XMPORTANOTEBUFFER | \n\t\tXModule::MODULE_XMVOLCOLUMNVIBRATO;\n\n\theader->uppernotebound = 119;\n\t\n\tmp_sint32 i,y,sc;\n\tfor (i=0;i<32;i++) header->pan[i]=0x80;\n\t\n\t// old version?\n\tif (header->ver == 0x102 || header->ver == 0x103)\n\t{\n\t\tmp_sint32 s = 0;\n\t\tmp_sint32 e = 0;\n\t\tfor (y=0;y<header->insnum;y++) {\n\t\t\t\n\t\t\tf.readDwords(&instr[y].size,1);\n\t\t\tf.read(&instr[y].name,1,22);\t\t\n\t\t\tf.read(&instr[y].type,1,1);\n\t\t\tmp_uword numSamples = 0;\n\t\t\tf.readWords(&numSamples,1);\n\t\t\tif(numSamples > MP_MAXINSSAMPS)\n\t\t\t\treturn MP_LOADER_FAILED;\n\t\t\tinstr[y].samp = numSamples;\n\n\t\t\tif (instr[y].size == 29)\n\t\t\t{\n#ifdef MILKYTRACKER\n\t\t\t\ts+=16;\n#endif\n\t\t\t\tfor (mp_sint32 i = 0; i < 120; i++)\n\t\t\t\t\tinstr[y].snum[i] = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tf.readDwords(&instr[y].shsize,1);\n\n\t\t\tmemset(insData, 0, 230);\n\t\t\t\n\t\t\tif (instr[y].size - 33 > 230)\n\t\t\t\treturn MP_OUT_OF_MEMORY;\n\t\t\t\n\t\t\tf.read(insData, 1, instr[y].size - 33);\n\t\t\t\t\t\t\n\t\t\tif (instr[y].samp) {\n\t\t\t\tmp_ubyte* insDataPtr = insData;\n\t\t\t\t\n\t\t\t\tmemcpy(nbu, insDataPtr, MP_MAXINSSAMPS);\n\t\t\t\tinsDataPtr+=MP_MAXINSSAMPS;\n\t\t\t\t\n\t\t\t\tTEnvelope venv;\n\t\t\t\tTEnvelope penv;\n\t\t\t\tmemset(&venv,0,sizeof(venv));\n\t\t\t\tmemset(&penv,0,sizeof(penv));\n\t\t\t\t\n\t\t\t\tmp_sint32 k;\n\t\t\t\tfor (k = 0; k < XM_ENVELOPENUMPOINTS; k++)\n\t\t\t\t{\n\t\t\t\t\tvenv.env[k][0] = LittleEndian::GET_WORD(insDataPtr);\n\t\t\t\t\tvenv.env[k][1] = LittleEndian::GET_WORD(insDataPtr+2);\n\t\t\t\t\tinsDataPtr+=4;\n\t\t\t\t}\n\t\t\t\tfor (k = 0; k < XM_ENVELOPENUMPOINTS; k++)\n\t\t\t\t{\n\t\t\t\t\tpenv.env[k][0] = LittleEndian::GET_WORD(insDataPtr);\n\t\t\t\t\tpenv.env[k][1] = LittleEndian::GET_WORD(insDataPtr+2);\n\t\t\t\t\tinsDataPtr+=4;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvenv.num = *insDataPtr++;\t\n\t\t\t\tif (venv.num > XM_ENVELOPENUMPOINTS) venv.num = XM_ENVELOPENUMPOINTS;\n\t\t\t\tpenv.num = *insDataPtr++;\t\n\t\t\t\tif (penv.num > XM_ENVELOPENUMPOINTS) penv.num = XM_ENVELOPENUMPOINTS;\n\t\t\t\tvenv.sustain = *insDataPtr++;\n\t\t\t\tvenv.loops = *insDataPtr++;\n\t\t\t\tvenv.loope = *insDataPtr++;\n\t\t\t\tpenv.sustain = *insDataPtr++;\n\t\t\t\tpenv.loops = *insDataPtr++;\n\t\t\t\tpenv.loope = *insDataPtr++;\n\t\t\t\tvenv.type = *insDataPtr++;\n\t\t\t\tpenv.type = *insDataPtr++;\t\t\t\t\n\t\t\t\t\n\t\t\t\tmp_ubyte vibtype, vibsweep, vibdepth, vibrate;\n\t\t\t\tmp_uword volfade;\n\t\t\t\t\n\t\t\t\tvibtype = *insDataPtr++;\n\t\t\t\tvibsweep = *insDataPtr++;\n\t\t\t\tvibdepth = *insDataPtr++;\n\t\t\t\tvibrate = *insDataPtr++;\n\t\t\t\t\n\t\t\t\tvibdepth<<=1;\n\t\t\t\t\n\t\t\t\tvolfade = LittleEndian::GET_WORD(insDataPtr);\n\t\t\t\tinsDataPtr+=2;\n\t\t\t\tvolfade<<=1;\n\t\t\t\t\n\t\t\t\t//instr[y].res = LittleEndian::GET_WORD(insDataPtr);\n\t\t\t\tinsDataPtr+=2;\n\t\t\t\t\n\t\t\t\tfor (mp_sint32 l=0;l<XM_ENVELOPENUMPOINTS;l++) {\n\t\t\t\t\tvenv.env[l][1]<<=2;\n\t\t\t\t\tpenv.env[l][1]<<=2;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!module->addVolumeEnvelope(venv)) \n\t\t\t\t\treturn MP_OUT_OF_MEMORY;\n\t\t\t\tif (!module->addPanningEnvelope(penv)) \n\t\t\t\t\treturn MP_OUT_OF_MEMORY;\n\t\t\t\t\n\t\t\t\tmp_sint32 g=0, sc;\n\t\t\t\tfor (sc=0;sc<instr[y].samp;sc++) {\n\t\t\t\t\t\n\t\t\t\t\tsmp[g+s].flags=3;\n\t\t\t\t\tsmp[g+s].venvnum=e+1;\n\t\t\t\t\tsmp[g+s].penvnum=e+1;\n\t\t\t\t\t\n\t\t\t\t\tsmp[g+s].vibtype=vibtype;\n\t\t\t\t\tsmp[g+s].vibsweep=vibsweep;\n\t\t\t\t\tsmp[g+s].vibdepth=vibdepth;\n\t\t\t\t\tsmp[g+s].vibrate=vibrate;\n\t\t\t\t\tsmp[g+s].volfade=volfade;\n\t\t\t\t\t\n\t\t\t\t\t// not sure why I did that, actually doesn't make sense\n\t\t\t\t\t//if (!(venv.type&1)) smp[g+s].volfade=0;\n\t\t\t\t\t\n\t\t\t\t\tf.readDwords(&smp[g+s].samplen,1);\n\t\t\t\t\tf.readDwords(&smp[g+s].loopstart,1);\n\t\t\t\t\tf.readDwords(&smp[g+s].looplen,1);\n\t\t\t\t\tsmp[g+s].vol=XModule::vol64to255(f.readByte());\n\t\t\t\t\t//f.read(&smp[g+s].vol,1,1);\n\t\t\t\t\tf.read(&smp[g+s].finetune,1,1);\n\t\t\t\t\tf.read(&smp[g+s].type,1,1);\n#ifdef VERBOSE\n\t\t\t\t\tprintf(\"Before: %i, After: %i\\n\", smp[g+s].type, smp[g+s].type & (3+16));\n#endif\n\t\t\t\t\tf.read(&smp[g+s].pan,1,1);\n\t\t\t\t\tf.read(&smp[g+s].relnote,1,1);\n\t\t\t\t\tf.read(&smp[g+s].res,1,1);\n\t\t\t\t\tf.read(&smp[g+s].name,1,22);\n\t\t\t\t\t\n\t\t\t\t\tchar line[30];\n\t\t\t\t\tmemset(line, 0, sizeof(line));\n\t\t\t\t\tXModule::convertStr(line, smp[g+s].name, 23, false);\t\t\t\t\t\n\t\t\t\t\tif (line[0])\n\t\t\t\t\t\tmodule->addSongMessageLine(line);\n\t\t\t\t\t\n\t\t\t\t\t// ignore empty samples\n#ifndef MILKYTRACKER\n\t\t\t\t\t// ignore empty samples when not being a tracker\n\t\t\t\t\tif (smp[g+s].samplen) {\n\t\t\t\t\t\tsmpReloc[sc] = g;\n\t\t\t\t\t\tg++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tsmpReloc[sc] = -1;\n#else\n\t\t\t\t\tsmpReloc[sc] = g;\n\t\t\t\t\tg++;\n#endif\n\t\t\t\t}\n\n\t\t\t\tinstr[y].samp = g;\n\n\t\t\t\tfor (sc = 0; sc < MP_MAXINSSAMPS; sc++) {\n\t\t\t\t\tif (smpReloc[nbu[sc]] == -1)\n\t\t\t\t\t\tinstr[y].snum[sc] = -1;\n\t\t\t\t\telse\n\t\t\t\t\t\tinstr[y].snum[sc] = smpReloc[nbu[sc]]+s;\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t\te++;\n\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (mp_sint32 i = 0; i < 120; i++)\n\t\t\t\t\tinstr[y].snum[i] = -1;\n\t\t\t}\n\n#ifdef MILKYTRACKER\n\t\t\ts+=16;\n#else\n\t\t\ts+=instr[y].samp;\n#endif\t\t\t\t\n\t\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\theader->smpnum=s;\n\t\theader->volenvnum=e;\n\t\theader->panenvnum=e;\n\t}\n\t\n\tfor (y=0;y<header->patnum;y++) {\n\t\t\n\t\tif (header->ver == 0x104 || header->ver == 0x103)\n\t\t{\n\t\t\tf.readDwords(&phead[y].len,1);\n\t\t\tf.read(&phead[y].ptype,1,1);\n\t\t\tf.readWords(&phead[y].rows,1);\n\t\t\tf.readWords(&phead[y].patdata,1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tf.readDwords(&phead[y].len,1);\n\t\t\tf.read(&phead[y].ptype,1,1);\n\t\t\tphead[y].rows = (mp_uword)f.readByte()+1;\n\t\t\tf.readWords(&phead[y].patdata,1);\t\t\t\n\t\t}\n\t\t\n\t\tphead[y].effnum=2;\n\t\tphead[y].channum=(mp_ubyte)header->channum;\n\t\t\n\t\tphead[y].patternData = new mp_ubyte[phead[y].rows*header->channum*6];\n\t\t\n\t\t// out of memory?\n\t\tif (phead[y].patternData == NULL)\n\t\t{\n\t\t\treturn MP_OUT_OF_MEMORY;\n\t\t}\n\t\t\n\t\tmemset(phead[y].patternData,0,phead[y].rows*header->channum*6);\n\t\t\n\t\tif (phead[y].patdata) {\n\t\t\tmp_ubyte *buffer = new mp_ubyte[phead[y].patdata];\n\t\t\t\n\t\t\t// out of memory?\n\t\t\tif (buffer == NULL)\n\t\t\t{\n\t\t\t\treturn MP_OUT_OF_MEMORY;\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tf.read(buffer,1,phead[y].patdata);\n\t\t\t\n\t\t\t//printf(\"%i\\n\", phead[y].patdata);\n\t\t\t\n\t\t\tmp_sint32 pc = 0, bc = 0;\n\t\t\tfor (mp_sint32 r=0;r<phead[y].rows;r++) {\n\t\t\t\tfor (mp_sint32 c=0;c<header->channum;c++) {\n\t\t\t\t\t\n\t\t\t\t\tmp_ubyte slot[5];\n\t\t\t\t\tmemset(slot,0,5);\n\t\t\t\t\t\n\t\t\t\t\tif ((buffer[pc]&128)) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tmp_ubyte pb = buffer[pc];\n\t\t\t\t\t\tpc++;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ((pb&1)) {\n\t\t\t\t\t\t\t//phead[y].patternData[bc]=buffer[pc];\n\t\t\t\t\t\t\tslot[0]=buffer[pc];\n\t\t\t\t\t\t\tpc++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ((pb&2)) {\n\t\t\t\t\t\t\t//phead[y].patternData[bc+1]=buffer[pc];\n\t\t\t\t\t\t\tslot[1]=buffer[pc];\n\t\t\t\t\t\t\tpc++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ((pb&4)) {\n\t\t\t\t\t\t\t//phead[y].patternData[bc+2]=buffer[pc];\n\t\t\t\t\t\t\tslot[2]=buffer[pc];\n\t\t\t\t\t\t\tpc++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ((pb&8)) {\n\t\t\t\t\t\t\t//phead[y].patternData[bc+3]=buffer[pc];\n\t\t\t\t\t\t\tslot[3]=buffer[pc];\n\t\t\t\t\t\t\tpc++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ((pb&16)) {\n\t\t\t\t\t\t\t//phead[y].patternData[bc+4]=buffer[pc];\n\t\t\t\t\t\t\tslot[4]=buffer[pc];\n\t\t\t\t\t\t\tpc++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t//memcpy(phead[y].patternData+bc,buffer+pc,5);\n\t\t\t\t\t\tmemcpy(slot,buffer+pc,5);\n\t\t\t\t\t\tpc+=5;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tchar gl=0;\n\t\t\t\t\tfor (mp_sint32 i=0;i<XModule::numValidXMEffects;i++)\n\t\t\t\t\t\tif (slot[3]==XModule::validXMEffects[i]) gl=1;\n\t\t\t\t\t\n\t\t\t\t\tif (!gl) slot[3]=slot[4]=0;\n\t\t\t\t\t\n\t\t\t\t\tif ((slot[3]==0xC)||(slot[3]==0x10)) {\n\t\t\t\t\t\tslot[4] = XModule::vol64to255(slot[4]);\n\t\t\t\t\t\t/*mp_sint32 bl = slot[4];\n\t\t\t\t\t\tif (bl>64) bl=64;\n\t\t\t\t\t\tslot[4]=(bl*261120)>>16;*/\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif ((!slot[3])&&(slot[4])) slot[3]=0x20;\n\t\t\t\t\t\n\t\t\t\t\tif (slot[3]==0xE) {\n\t\t\t\t\t\tslot[3]=(slot[4]>>4)+0x30;\n\t\t\t\t\t\tslot[4]=slot[4]&0xf;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (slot[3]==0x21) {\n\t\t\t\t\t\tslot[3]=(slot[4]>>4)+0x40;\n\t\t\t\t\t\tslot[4]=slot[4]&0xf;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (slot[0]==97) slot[0]=XModule::NOTE_OFF;\n\t\t\t\t\t\n\t\t\t\t\tphead[y].patternData[bc]=slot[0];\n\t\t\t\t\tphead[y].patternData[bc+1]=slot[1];\n\t\t\t\t\t\n\t\t\t\t\tXModule::convertXMVolumeEffects(slot[2], phead[y].patternData[bc+2], phead[y].patternData[bc+3]);\n\n\t\t\t\t\tphead[y].patternData[bc+4]=slot[3];\n\t\t\t\t\tphead[y].patternData[bc+5]=slot[4];\n\t\t\t\t\t\n\t\t\t\t\t/*if ((y==3)&&(c==2)) {\n\t\t\t\t\t\tfor (mp_sint32 bl=0;bl<6;bl++) cprintf(\"%x \",phead[y].patternData[bc+bl]);\n\t\t\t\t\tcprintf(\"\\r\\n\");\n\t\t\t\t\tgetch();\n\t\t\t\t\t};*/\n\t\t\t\t\t\n\t\t\t\t\t/*printf(\"Note : %i\\r\\n\",phead[y].patternData[bc]);\n\t\t\t\t\tprintf(\"Ins  : %i\\r\\n\",phead[y].patternData[bc+1]);\n\t\t\t\t\tprintf(\"Vol  : %i\\r\\n\",phead[y].patternData[bc+2]);\n\t\t\t\t\tprintf(\"Eff  : %i\\r\\n\",phead[y].patternData[bc+3]);\n\t\t\t\t\tprintf(\"Effop: %i\\r\\n\",phead[y].patternData[bc+4]);\n\t\t\t\t\tgetch();*/\n\t\t\t\t\t\n\t\t\t\t\tbc+=6;\n\t\t\t\t} // for c\n\t\t\t\t\t\n\t\t\t} // for r\n\t\t\t\t\n\t\t\tdelete[] buffer;\n\t\t}\n\t\t\t\n\t}\n\t\t\n\tif (header->ver == 0x104)\n\t{\n\t\tmp_sint32 s = 0;\n\t\tmp_sint32 e = 0;\n\t\tfor (y=0;y<header->insnum;y++) {\n\n\t\t\t// fixes MOOH.XM loading problems\n\t\t\t// seems to store more instruments in the header than in the actual file\n\t\t\tif (f.posWithBaseOffset() >= fileSize)\n\t\t\t\tbreak;\n\t\t\n\t\t\t//TXMInstrument* ins = &instr[y];\n\t\t\n\t\t\tf.readDwords(&instr[y].size,1);\n\t\t\t\n\t\t\tif (instr[y].size >= 4 && instr[y].size < 29)\n\t\t\t{\n\t\t\t\tmp_ubyte buffer[29];\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tf.read(buffer, 1, instr[y].size - 4);\n\t\t\t\tmemcpy(instr[y].name, buffer, 22);\n\t\t\t\tinstr[y].type = buffer[22];\n\t\t\t\tinstr[y].samp = LittleEndian::GET_WORD(buffer + 23);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tf.read(&instr[y].name,1,22);\t\t\n\t\t\t\tf.read(&instr[y].type,1,1);\n\t\t\t\tf.readWords(&instr[y].samp,1);\n\t\t\t}\n\t\t\tif (instr[y].samp > MP_MAXINSSAMPS)\n\t\t\t\treturn MP_LOADER_FAILED;\n\n\t\t\t//printf(\"%i, %i\\n\", instr[y].size, instr[y].samp);\n\n\t\t\tif (instr[y].size <= 29)\n\t\t\t{\n#ifdef MILKYTRACKER\n\t\t\t\ts+=16;\n#endif\n\t\t\t\tfor (mp_sint32 i = 0; i < 120; i++)\n\t\t\t\t\tinstr[y].snum[i] = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tf.readDwords(&instr[y].shsize,1);\n#ifdef VERBOSE\n\t\t\tprintf(\"%i/%i: %i, %i, %i, %s\\n\",y,header->insnum-1,instr[y].size,instr[y].shsize,instr[y].samp,instr[y].name);\t\t\t\n#endif\n\t\t\tmemset(insData, 0, 230);\n\t\t\t\n\t\t\tif (instr[y].size - 33 > 230)\n\t\t\t{\n\t\t\t\t//return -7;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tf.read(insData, 1, instr[y].size - 33);\n\t\t\t\n\t\t\t/*printf(\"%i\\r\\n\",instr[y].size);\n\t\t\tprintf(\"%s\\r\\n\",instr[y].name);\n\t\t\tprintf(\"%i\\r\\n\",instr[y].type);\n\t\t\tprintf(\"%i\\r\\n\",instr[y].samp);\n\t\t\tprintf(\"%i\\r\\n\",instr[y].shsize);*/\n\t\t\t//getch();\n\t\t\t\t\t\n\t\t\tmemset(smpReloc, 0, sizeof(smpReloc));\n\t\t\t\n\t\t\tif (instr[y].samp) {\n\t\t\t\tmp_ubyte* insDataPtr = insData;\n\t\t\t\t\n\t\t\t\t//f.read(&nbu,1,96);\n\t\t\t\t\n\t\t\t\tmemcpy(nbu, insDataPtr, MP_MAXINSSAMPS);\n\t\t\t\tinsDataPtr+=MP_MAXINSSAMPS;\n\t\t\t\t\n\t\t\t\tTEnvelope venv;\n\t\t\t\tTEnvelope penv;\n\t\t\t\tmemset(&venv,0,sizeof(venv));\n\t\t\t\tmemset(&penv,0,sizeof(penv));\n\t\t\t\t\n\t\t\t\tmp_sint32 k;\n\t\t\t\tfor (k = 0; k < XM_ENVELOPENUMPOINTS; k++)\n\t\t\t\t{\n\t\t\t\t\tvenv.env[k][0] = LittleEndian::GET_WORD(insDataPtr);\n\t\t\t\t\tvenv.env[k][1] = LittleEndian::GET_WORD(insDataPtr+2);\n\t\t\t\t\tinsDataPtr+=4;\n\t\t\t\t}\n\t\t\t\tfor (k = 0; k < XM_ENVELOPENUMPOINTS; k++)\n\t\t\t\t{\n\t\t\t\t\tpenv.env[k][0] = LittleEndian::GET_WORD(insDataPtr);\n\t\t\t\t\tpenv.env[k][1] = LittleEndian::GET_WORD(insDataPtr+2);\n\t\t\t\t\tinsDataPtr+=4;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvenv.num = *insDataPtr++;\t\n\t\t\t\tif (venv.num > XM_ENVELOPENUMPOINTS) venv.num = XM_ENVELOPENUMPOINTS;\n\t\t\t\tpenv.num = *insDataPtr++;\t\t\t\t\t\n\t\t\t\tif (penv.num > XM_ENVELOPENUMPOINTS) penv.num = XM_ENVELOPENUMPOINTS;\n\t\t\t\tvenv.sustain = *insDataPtr++;\n\t\t\t\tvenv.loops = *insDataPtr++;\n\t\t\t\tvenv.loope = *insDataPtr++;\n\t\t\t\tpenv.sustain = *insDataPtr++;\n\t\t\t\tpenv.loops = *insDataPtr++;\n\t\t\t\tpenv.loope = *insDataPtr++;\n\t\t\t\tvenv.type = *insDataPtr++;\n\t\t\t\tpenv.type = *insDataPtr++;\t\t\t\t\n\t\t\t\t\n\t\t\t\tmp_ubyte vibtype, vibsweep, vibdepth, vibrate;\n\t\t\t\tmp_uword volfade;\n\t\t\t\t\n\t\t\t\tvibtype = *insDataPtr++;\n\t\t\t\tvibsweep = *insDataPtr++;\n\t\t\t\tvibdepth = *insDataPtr++;\n\t\t\t\tvibrate = *insDataPtr++;\n\t\t\t\t\n\t\t\t\tvibdepth<<=1;\n\t\t\t\t\n\t\t\t\t//f.readWords(&volfade,1);\n\t\t\t\tvolfade = LittleEndian::GET_WORD(insDataPtr);\n\t\t\t\tinsDataPtr+=2;\n\t\t\t\tvolfade<<=1;\n\t\t\t\t\n\t\t\t\t//instr[y].res = LittleEndian::GET_WORD(insDataPtr);\n\t\t\t\tinsDataPtr+=2;\n\t\t\t\t\n\t\t\t\tfor (mp_sint32 l=0;l<XM_ENVELOPENUMPOINTS;l++) {\n\t\t\t\t\tvenv.env[l][1]<<=2;\n\t\t\t\t\tpenv.env[l][1]<<=2;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!module->addVolumeEnvelope(venv)) \n\t\t\t\t\treturn MP_OUT_OF_MEMORY;\n\t\t\t\tif (!module->addPanningEnvelope(penv)) \n\t\t\t\t\treturn MP_OUT_OF_MEMORY;\n\t\t\t\t\n\t\t\t\tmp_sint32 g=0, sc;\n\t\t\t\tfor (sc=0;sc<instr[y].samp;sc++) {\n\t\t\t\t\t//TXMSample* smpl = &smp[g+s];\n\t\t\t\t\t\n\t\t\t\t\tsmp[g+s].flags=3;\n\t\t\t\t\tsmp[g+s].venvnum=e+1;\n\t\t\t\t\tsmp[g+s].penvnum=e+1;\n\t\t\t\t\t\n\t\t\t\t\tsmp[g+s].vibtype=vibtype;\n\t\t\t\t\tsmp[g+s].vibsweep=vibsweep;\n\t\t\t\t\tsmp[g+s].vibdepth=vibdepth;\n\t\t\t\t\tsmp[g+s].vibrate=vibrate;\n\t\t\t\t\tsmp[g+s].volfade=volfade;\n\t\t\t\t\t\n\t\t\t\t\t// not sure why I did that, actually doesn't make sense\n\t\t\t\t\t//if (!(venv.type&1)) smp[g+s].volfade=0;\n\t\t\t\t\t\n\t\t\t\t\tf.readDwords(&smp[g+s].samplen,1);\n\t\t\t\t\t\n\t\t\t\t\tf.readDwords(&smp[g+s].loopstart,1);\n\t\t\t\t\tf.readDwords(&smp[g+s].looplen,1);\n\t\t\t\t\tsmp[g+s].vol=XModule::vol64to255(f.readByte());\n\t\t\t\t\t//f.read(&smp[g+s].vol,1,1);\n\t\t\t\t\tf.read(&smp[g+s].finetune,1,1);\n\t\t\t\t\tf.read(&smp[g+s].type,1,1);\n#ifdef VERBOSE\n\t\t\t\t\tprintf(\"Before: %i, After: %i\\n\", smp[g+s].type, smp[g+s].type & (3+16));\n#endif\n\t\t\t\t\tf.read(&smp[g+s].pan,1,1);\n\t\t\t\t\tf.read(&smp[g+s].relnote,1,1);\n\t\t\t\t\tf.read(&smp[g+s].res,1,1);\n\t\t\t\t\tf.read(&smp[g+s].name,1,22);\n\n\t\t\t\t\tchar line[30];\n\t\t\t\t\tmemset(line, 0, sizeof(line));\n\t\t\t\t\tXModule::convertStr(line, smp[g+s].name, 23, false);\t\t\t\t\t\n\t\t\t\t\tif (line[0])\n\t\t\t\t\t\tmodule->addSongMessageLine(line);\n\t\t\t\t\t\n#ifndef MILKYTRACKER\n\t\t\t\t\t// ignore empty samples when not being a tracker\n\t\t\t\t\tif (smp[g+s].samplen) {\n\t\t\t\t\t\tsmpReloc[sc] = g;\n\t\t\t\t\t\tg++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tsmpReloc[sc] = -1;\n#else\n\t\t\t\t\tsmpReloc[sc] = g;\n\t\t\t\t\tg++;\n#endif\n\t\t\t\t}\n\n\t\t\t\tinstr[y].samp = g;\n\n\t\t\t\tfor (sc = 0; sc < MP_MAXINSSAMPS; sc++) {\t\t\t\t\t\n\t\t\t\t\tif (smpReloc[nbu[sc]] == -1)\n\t\t\t\t\t\tinstr[y].snum[sc] = -1;\n\t\t\t\t\telse\n\t\t\t\t\t\tinstr[y].snum[sc] = smpReloc[nbu[sc]]+s;\n\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\tfor (sc=0;sc<instr[y].samp;sc++) {\n\t\t\t\t\n\t\t\t\t\tif (smp[s].samplen)\n\t\t\t\t\t{\n\t\t\t\t\t\tbool adpcm = (smp[s].res == 0xAD);\n\t\t\t\t\t\n\t\t\t\t\t\tmp_uint32 oldSize = smp[s].samplen;\n\t\t\t\t\t\tif (smp[s].type&16) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsmp[s].samplen>>=1;\n\t\t\t\t\t\t\tsmp[s].loopstart>>=1;\n\t\t\t\t\t\t\tsmp[s].looplen>>=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tmp_sint32 result = module->loadModuleSample(f, s, \n\t\t\t\t\t\t\t\t\t\t\t\t\t adpcm ? XModule::ST_PACKING_ADPCM : XModule::ST_DELTA, \n\t\t\t\t\t\t\t\t\t\t\t\t\t adpcm ? (XModule::ST_PACKING_ADPCM | XModule::ST_16BIT) : (XModule::ST_DELTA | XModule::ST_16BIT), \n\t\t\t\t\t\t\t\t\t\t\t\t\t oldSize);\n\t\t\t\t\t\tif (result != MP_OK)\n\t\t\t\t\t\t\treturn result;\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (adpcm)\n\t\t\t\t\t\t\tsmp[s].res = 0;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\ts++;\n\t\t\t\t\t\n\t\t\t\t\tif (s>=MP_MAXSAMPLES)\n\t\t\t\t\t\treturn MP_OUT_OF_MEMORY;\n\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t\te++;\n\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (mp_sint32 i = 0; i < 120; i++)\n\t\t\t\t\tinstr[y].snum[i] = -1;\n\t\t\t}\n\n#ifdef MILKYTRACKER\n\t\t\ts+=16 - instr[y].samp;\n#endif\t\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\theader->smpnum=s;\n\t\theader->volenvnum=e;\n\t\theader->panenvnum=e;\t\t\n\t\t\n\t}\n\telse\n\t{\n\t\tmp_sint32 s = 0;\n\t\tfor (y=0;y<header->insnum;y++) {\n\t\t\tfor (sc=0;sc<instr[y].samp;sc++) {\n\n\t\t\t\tif (smp[s].samplen)\n\t\t\t\t{\n\t\t\t\t\tmp_uint32 oldSize = smp[s].samplen;\n\t\t\t\t\tif (smp[s].type&16) \n\t\t\t\t\t{\n\t\t\t\t\t\tsmp[s].samplen>>=1;\n\t\t\t\t\t\tsmp[s].loopstart>>=1;\n\t\t\t\t\t\tsmp[s].looplen>>=1;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tmp_sint32 result = module->loadModuleSample(f, s, XModule::ST_DELTA, XModule::ST_DELTA | XModule::ST_16BIT, oldSize);\n\t\t\t\t\tif (result != MP_OK)\n\t\t\t\t\t\treturn result;\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ts++;\n\t\t\t\t\n\t\t\t\tif (s>=MP_MAXSAMPLES)\n\t\t\t\t\treturn MP_OUT_OF_MEMORY;\t\t\t\t\n\t\t\t}\n\t\t\t\n#ifdef MILKYTRACKER\n\t\t\ts+=16 - instr[y].samp;\n#endif\n\t\t\t\n\t\t}\t\t\n\t}\n\t\n\t// convert modplug stereo samples\n\tfor (mp_sint32 s = 0; s < header->smpnum; s++)\n\t{\n\t\tif (smp[s].type & 32)\n\t\t{\t\t\n\t\t\t// that's what's allowed, stupid modplug tracker\n\t\t\tsmp[s].type &= 3+16;\t\t\t\t\t\n\n\t\t\tif (smp[s].sample == NULL)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tif (!(smp[s].type&16)) {\t\t\t\n\t\t\t\tsmp[s].samplen>>=1;\n\t\t\t\tsmp[s].loopstart>>=1;\n\t\t\t\tsmp[s].looplen>>=1;\n\t\t\t\t\n\t\t\t\tmp_sbyte* sample = (mp_sbyte*)smp[s].sample;\n\t\t\t\tmp_sint32 samplen = smp[s].samplen;\n\t\t\t\tfor (mp_sint32 i = 0; i < samplen; i++)\n\t\t\t\t{\n\t\t\t\t\tmp_sint32 s = ((mp_sint32)sample[i] + (mp_sint32)sample[i + samplen]) >> 1;\n\t\t\t\t\tif (s < -128) s = -128;\n\t\t\t\t\tif (s > 127) s = 127;\n\t\t\t\t\tsample[i] = (mp_sbyte)s;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsmp[s].samplen>>=1;\n\t\t\t\tsmp[s].loopstart>>=1;\n\t\t\t\tsmp[s].looplen>>=1;\n\t\t\t\t\n\t\t\t\tmp_sword* sample = (mp_sword*)smp[s].sample;\n\t\t\t\tmp_sint32 samplen = smp[s].samplen;\n\t\t\t\tfor (mp_sint32 i = 0; i < samplen; i++)\n\t\t\t\t{\n\t\t\t\t\tmp_sint32 s = ((mp_sint32)sample[i] + (mp_sint32)sample[i + samplen]) >> 1;\n\t\t\t\t\tif (s < -32768) s = -32768;\n\t\t\t\t\tif (s > 32767) s = 32767;\n\t\t\t\t\tsample[i] = (mp_sword)s;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// correct loop type 0x03 (undefined)\n\t\t// will become ping pong loop\n\t\t// note that FT2 will refuse to load XM files with such a loop type\n\t\tif ((smp[s].type & 0x3) == 0x3)\n\t\t\tsmp[s].type&=~1;\t\t\n\t}\n\n\t// correct number of patterns if necessary, otherwise the post processing will remove\n\t// the \"invalid\" patterns from the order list\n\tbool addPatterns = false;\n\tfor (i = 0; i < header->ordnum; i++)\n\t\tif (header->ord[i]+1 > header->patnum)\n\t\t{\n\t\t\theader->patnum = header->ord[i]+1;\t\n\t\t\taddPatterns = true;\n\t\t}\n\t\n\t// if the pattern number has been adjusted, add some empty patterns\n\tif (addPatterns)\n\t{\n\t\tfor (i = 0; i < header->patnum; i++)\n\t\t\tif (phead[i].patternData == NULL)\n\t\t\t{\n\t\t\t\tphead[i].rows = 64;\n\t\t\t\tphead[i].effnum = 2;\n\t\t\t\tphead[i].channum = (mp_ubyte)header->channum;\n\n\t\t\t\tphead[i].patternData = new mp_ubyte[phead[i].rows*header->channum*6];\n\t\t\t\n\t\t\t\t// out of memory?\n\t\t\t\tif (phead[i].patternData == NULL)\n\t\t\t\t{\n\t\t\t\t\treturn MP_OUT_OF_MEMORY;\n\t\t\t\t}\n\t\t\n\t\t\t\tmemset(phead[i].patternData,0,phead[i].rows*header->channum*6);\n\t\t\t}\n\t}\n\t\n\t// check for MODPLUG extensions\n\tif (f.posWithBaseOffset() + 8 <= fileSize)\n\t{\n\t\tchar buffer[4];\n\t\tf.read(buffer, 1, 4);\n\t\tif (memcmp(buffer, \"text\", 4) == 0)\n\t\t{\n\t\t\tmp_uint32 len = f.readDword();\n\t\t\tmodule->allocateSongMessage(len+1);\n\t\t\t\n\t\t\tmemset(module->message, 0, len+1);\n\t\t\t\n\t\t\tf.read(module->message, 1, len);\n\t\t}\n\t}\n\t\n\tmodule->postProcessSamples();\n\t\n\treturn MP_OK;\n}", "target": 2, "idx": 11304}
{"commit_id": "e396648e48c57e2d53988d3fd4465b068b96c89a", "project": "gpac", "func": "static u16 swf_get_16(SWFReader *read)\n{\n\treturn gf_bs_read_u16_le(read->bs);\n}", "target": 1, "idx": 11305}
{"commit_id": "2e874e80cba0152201aff6a4d0dc407997d10a7f", "project": "juce-framework/JUCE", "func": "void runTest() override\n    {\n        beginTest (\"ZIP\");\n\n        StringArray entryNames { \"first\", \"second\", \"third\" };\n        auto data = createZipMemoryBlock (entryNames);\n        MemoryInputStream mi (data, false);\n        ZipFile zip (mi);\n\n        expectEquals (zip.getNumEntries(), entryNames.size());\n\n        for (auto& entryName : entryNames)\n        {\n            auto* entry = zip.getEntry (entryName);\n            std::unique_ptr<InputStream> input (zip.createStreamForEntry (*entry));\n            expectEquals (input->readEntireStreamAsString(), entryName);\n        }\n\n        beginTest (\"ZipSlip\");\n        runZipSlipTest();\n    }", "target": 1, "idx": 11306}
{"commit_id": "57df9e8a9f9ae1aafdde9b86b10ad907627a87dc", "project": "vim", "func": "static void\nblock_insert(\n    oparg_T\t\t*oap,\n    char_u\t\t*s,\n    int\t\t\tb_insert,\n    struct block_def\t*bdp)\n{\n    int\t\tts_val;\n    int\t\tcount = 0;\t// extra spaces to replace a cut TAB\n    int\t\tspaces = 0;\t// non-zero if cutting a TAB\n    colnr_T\toffset;\t\t// pointer along new line\n    colnr_T\tstartcol;\t// column where insert starts\n    unsigned\ts_len;\t\t// STRLEN(s)\n    char_u\t*newp, *oldp;\t// new, old lines\n    linenr_T\tlnum;\t\t// loop var\n    int\t\toldstate = State;\n\n    State = INSERT;\t\t// don't want REPLACE for State\n    s_len = (unsigned)STRLEN(s);\n\n    for (lnum = oap->start.lnum + 1; lnum <= oap->end.lnum; lnum++)\n    {\n\tblock_prep(oap, bdp, lnum, TRUE);\n\tif (bdp->is_short && b_insert)\n\t    continue;\t// OP_INSERT, line ends before block start\n\n\toldp = ml_get(lnum);\n\n\tif (b_insert)\n\t{\n\t    ts_val = bdp->start_char_vcols;\n\t    spaces = bdp->startspaces;\n\t    if (spaces != 0)\n\t\tcount = ts_val - 1; // we're cutting a TAB\n\t    offset = bdp->textcol;\n\t}\n\telse // append\n\t{\n\t    ts_val = bdp->end_char_vcols;\n\t    if (!bdp->is_short) // spaces = padding after block\n\t    {\n\t\tspaces = (bdp->endspaces ? ts_val - bdp->endspaces : 0);\n\t\tif (spaces != 0)\n\t\t    count = ts_val - 1; // we're cutting a TAB\n\t\toffset = bdp->textcol + bdp->textlen - (spaces != 0);\n\t    }\n\t    else // spaces = padding to block edge\n\t    {\n\t\t// if $ used, just append to EOL (ie spaces==0)\n\t\tif (!bdp->is_MAX)\n\t\t    spaces = (oap->end_vcol - bdp->end_vcol) + 1;\n\t\tcount = spaces;\n\t\toffset = bdp->textcol + bdp->textlen;\n\t    }\n\t}\n\n\tif (has_mbyte && spaces > 0)\n\t    // avoid copying part of a multi-byte character\n\t    offset -= (*mb_head_off)(oldp, oldp + offset);\n\n\tif (spaces < 0)  // can happen when the cursor was moved\n\t    spaces = 0;\n\n\t// Make sure the allocated size matches what is actually copied below.\n\tnewp = alloc(STRLEN(oldp) + spaces + s_len\n\t\t    + (spaces > 0 && !bdp->is_short ? ts_val - spaces : 0)\n\t\t\t\t\t\t\t\t  + count + 1);\n\tif (newp == NULL)\n\t    continue;\n\n\t// copy up to shifted part\n\tmch_memmove(newp, oldp, (size_t)offset);\n\toldp += offset;\n\n\t// insert pre-padding\n\tvim_memset(newp + offset, ' ', (size_t)spaces);\n\tstartcol = offset + spaces;\n\n\t// copy the new text\n\tmch_memmove(newp + startcol, s, (size_t)s_len);\n\toffset += s_len;\n\n\tif (spaces > 0 && !bdp->is_short)\n\t{\n\t    if (*oldp == TAB)\n\t    {\n\t\t// insert post-padding\n\t\tvim_memset(newp + offset + spaces, ' ',\n\t\t\t\t\t\t    (size_t)(ts_val - spaces));\n\t\t// we're splitting a TAB, don't copy it\n\t\toldp++;\n\t\t// We allowed for that TAB, remember this now\n\t\tcount++;\n\t    }\n\t    else\n\t\t// Not a TAB, no extra spaces\n\t\tcount = spaces;\n\t}\n\n\tif (spaces > 0)\n\t    offset += count;\n\tSTRMOVE(newp + offset, oldp);\n\n\tml_replace(lnum, newp, FALSE);\n\n\tif (b_insert)\n\t    // correct any text properties\n\t    inserted_bytes(lnum, startcol, s_len);\n\n\tif (lnum == oap->end.lnum)\n\t{\n\t    // Set \"']\" mark to the end of the block instead of the end of\n\t    // the insert in the first line.\n\t    curbuf->b_op_end.lnum = oap->end.lnum;\n\t    curbuf->b_op_end.col = offset;\n\t}\n    } // for all lnum\n\n    changed_lines(oap->start.lnum + 1, 0, oap->end.lnum + 1, 0L);\n\n    State = oldstate;\n}", "target": 3, "idx": 11307}
{"commit_id": "1bb93d4fce9f1d764ba57bf5ac154af515b3fc83", "project": "upx", "func": "bool\nPackLinuxElf64::canPack()\n{\n    union {\n        unsigned char buf[sizeof(Elf64_Ehdr) + 14*sizeof(Elf64_Phdr)];\n        //struct { Elf64_Ehdr ehdr; Elf64_Phdr phdr; } e;\n    } u;\n    COMPILE_TIME_ASSERT(sizeof(u) <= 1024)\n\n    fi->readx(u.buf, sizeof(u.buf));\n    fi->seek(0, SEEK_SET);\n    Elf64_Ehdr const *const ehdr = (Elf64_Ehdr *) u.buf;\n\n    // now check the ELF header\n    if (checkEhdr(ehdr) != 0)\n        return false;\n\n    // additional requirements for linux/elf386\n    if (get_te16(&ehdr->e_ehsize) != sizeof(*ehdr)) {\n        throwCantPack(\"invalid Ehdr e_ehsize; try '--force-execve'\");\n        return false;\n    }\n    if (e_phoff != sizeof(*ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantPack(\"non-contiguous Ehdr/Phdr; try '--force-execve'\");\n        return false;\n    }\n\n    // The first PT_LOAD64 must cover the beginning of the file (0==p_offset).\n    Elf64_Phdr const *phdr = phdri;\n    for (unsigned j=0; j < e_phnum; ++phdr, ++j) {\n        if (j >= 14) {\n            throwCantPack(\"too many ElfXX_Phdr; try '--force-execve'\");\n            return false;\n        }\n        unsigned const p_type = get_te32(&phdr->p_type);\n        if (1!=exetype && PT_LOAD64 == p_type) { // 1st PT_LOAD\n            exetype = 1;\n            load_va = get_te64(&phdr->p_vaddr);  // class data member\n            upx_uint64_t const p_offset = get_te64(&phdr->p_offset);\n            upx_uint64_t const off = ~page_mask & load_va;\n            if (off && off == p_offset) { // specific hint\n                throwCantPack(\"Go-language PT_LOAD: try hemfix.c, or try '--force-execve'\");\n                // Fixing it inside upx fails because packExtent() reads original file.\n                return false;\n            }\n            if (0 != p_offset) { // 1st PT_LOAD must cover Ehdr and Phdr\n                throwCantPack(\"first PT_LOAD.p_offset != 0; try '--force-execve'\");\n                return false;\n            }\n            hatch_off = ~3ul & (3+ get_te64(&phdr->p_memsz));\n            break;\n        }\n    }\n    // We want to compress position-independent executable (gcc -pie)\n    // main programs, but compressing a shared library must be avoided\n    // because the result is no longer usable.  In theory, there is no way\n    // to tell them apart: both are just ET_DYN.  Also in theory,\n    // neither the presence nor the absence of any particular symbol name\n    // can be used to tell them apart; there are counterexamples.\n    // However, we will use the following heuristic suggested by\n    // Peter S. Mazinger <ps.m@gmx.net> September 2005:\n    // If a ET_DYN has __libc_start_main as a global undefined symbol,\n    // then the file is a position-independent executable main program\n    // (that depends on libc.so.6) and is eligible to be compressed.\n    // Otherwise (no __libc_start_main as global undefined): skip it.\n    // Also allow  __uClibc_main  and  __uClibc_start_main .\n\n    if (Elf64_Ehdr::ET_DYN==get_te16(&ehdr->e_type)) {\n        // The DT_SYMTAB has no designated length.  Read the whole file.\n        alloc_file_image(file_image, file_size);\n        fi->seek(0, SEEK_SET);\n        fi->readx(file_image, file_size);\n        memcpy(&ehdri, ehdr, sizeof(Elf64_Ehdr));\n        phdri= (Elf64_Phdr *)((size_t)e_phoff + file_image);  // do not free() !!\n        shdri= (Elf64_Shdr *)((size_t)e_shoff + file_image);  // do not free() !!\n\n        sec_strndx = NULL;\n        shstrtab = NULL;\n        if (e_shnum) {\n            unsigned const e_shstrndx = get_te16(&ehdr->e_shstrndx);\n            if (e_shstrndx) {\n                if (e_shnum <= e_shstrndx) {\n                    char msg[40]; snprintf(msg, sizeof(msg),\n                        \"bad e_shstrndx %#x >= e_shnum %d\", e_shstrndx, e_shnum);\n                    throwCantPack(msg);\n                }\n                sec_strndx = &shdri[e_shstrndx];\n                upx_uint64_t sh_offset = get_te64(&sec_strndx->sh_offset);\n                if ((u64_t)file_size <= sh_offset) {\n                    char msg[50]; snprintf(msg, sizeof(msg),\n                        \"bad .e_shstrndx->sh_offset %#lx\", (long unsigned)sh_offset);\n                    throwCantPack(msg);\n                }\n                shstrtab = (char const *)(sh_offset + file_image);\n            }\n            sec_dynsym = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM);\n            if (sec_dynsym) {\n                upx_uint64_t const sh_link = get_te64(&sec_dynsym->sh_link);\n                if (e_shnum <= sh_link) {\n                    char msg[50]; snprintf(msg, sizeof(msg),\n                        \"bad SHT_DYNSYM.sh_link %#lx\", (long unsigned)sh_link);\n                }\n                sec_dynstr = &shdri[sh_link];\n            }\n\n            if (sec_strndx) {\n                unsigned const sh_name = get_te32(&sec_strndx->sh_name);\n                if (Elf64_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type)\n                || (u32_t)file_size <= (sizeof(\".shstrtab\")\n                    + sh_name + (shstrtab - (const char *)&file_image[0]))\n                || (sh_name\n                  && 0!=strcmp((char const *)\".shstrtab\", &shstrtab[sh_name]))\n                ) {\n                    throwCantPack(\"bad e_shstrtab\");\n                }\n            }\n        }\n\n        Elf64_Phdr const *pload_x0(0);  // first eXecutable PT_LOAD\n        phdr= phdri;\n        for (int j= e_phnum; --j>=0; ++phdr)\n        if (Elf64_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {\n            dynseg= (Elf64_Dyn const *)(check_pt_dynamic(phdr) + file_image);\n            invert_pt_dynamic(dynseg);\n        }\n        else if (PT_LOAD64==get_te32(&phdr->p_type)) {\n            if (!pload_x0\n            &&  Elf32_Phdr::PF_X & get_te32(&phdr->p_flags)\n            ) {\n                pload_x0 = phdr;\n            }\n            check_pt_load(phdr);\n        }\n        // elf_find_dynamic() returns 0 if 0==dynseg.\n        dynstr=          (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB);\n        dynsym=     (Elf64_Sym const *)elf_find_dynamic(Elf64_Dyn::DT_SYMTAB);\n\n        if (opt->o_unix.force_pie\n        ||       Elf64_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf64_Dyn::DT_FLAGS_1)\n        ||  calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_RELA),\n                                  (int)elf_unsigned_dynamic(Elf64_Dyn::DT_RELASZ))\n        ||  calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_JMPREL),\n                                  (int)elf_unsigned_dynamic(Elf64_Dyn::DT_PLTRELSZ))) {\n            is_pie = true;\n            goto proceed;  // calls C library init for main program\n        }\n\n        // Heuristic HACK for shared libraries (compare Darwin (MacOS) Dylib.)\n        // If there is an existing DT_INIT, and if everything that the dynamic\n        // linker ld-linux needs to perform relocations before calling DT_INIT\n        // resides below the first SHT_EXECINSTR Section in one PT_LOAD, then\n        // compress from the first executable Section to the end of that PT_LOAD.\n        // We must not alter anything that ld-linux might touch before it calls\n        // the DT_INIT function.\n        //\n        // Obviously this hack requires that the linker script put pieces\n        // into good positions when building the original shared library,\n        // and also requires ld-linux to behave.\n\n        if (elf_find_dynamic(upx_dt_init)) {\n            if (elf_has_dynamic(Elf64_Dyn::DT_TEXTREL)) {\n                throwCantPack(\"DT_TEXTREL found; re-compile with -fPIC\");\n                goto abandon;\n            }\n            if (!(Elf64_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf64_Dyn::DT_FLAGS_1))) {\n                // not explicitly PIE main program\n                if (Elf64_Ehdr::EM_AARCH64 == e_machine  // Android is common\n                &&  !opt->o_unix.android_shlib  // but not explicit\n                ) {\n                    opt->info_mode++;\n                    info(\"note: use --android-shlib if appropriate\");\n                    opt->info_mode--;\n                }\n            }\n            Elf64_Shdr const *shdr = shdri;\n            xct_va = ~0ull;\n            if (e_shnum) {\n                for (int j= e_shnum; --j>=0; ++shdr) {\n                    unsigned const sh_type = get_te32(&shdr->sh_type);\n                    if (Elf64_Shdr::SHF_EXECINSTR & get_te64(&shdr->sh_flags)) {\n                        xct_va = umin(xct_va, get_te64(&shdr->sh_addr));\n                    }\n                    // Hook the first slot of DT_PREINIT_ARRAY or DT_INIT_ARRAY.\n                    if ((     Elf64_Dyn::DT_PREINIT_ARRAY==upx_dt_init\n                        &&  Elf64_Shdr::SHT_PREINIT_ARRAY==sh_type)\n                    ||  (     Elf64_Dyn::DT_INIT_ARRAY   ==upx_dt_init\n                        &&  Elf64_Shdr::SHT_INIT_ARRAY   ==sh_type) ) {\n                        unsigned user_init_ava = get_te32(&shdr->sh_addr);\n                        user_init_off = get_te64(&shdr->sh_offset);\n                        if ((u64_t)file_size <= user_init_off) {\n                            char msg[70]; snprintf(msg, sizeof(msg),\n                                \"bad Elf64_Shdr[%d].sh_offset %#x\",\n                                -1+ e_shnum - j, user_init_off);\n                            throwCantPack(msg);\n                        }\n                        // Check that &file_image[user_init_off] has\n                        // *_RELATIVE relocation, and fetch user_init_va.\n                        // If Elf64_Rela then the actual value is in Rela.r_addend.\n                        int z_rel = dt_table[Elf64_Dyn::DT_RELA];\n                        int z_rsz = dt_table[Elf64_Dyn::DT_RELASZ];\n                        if (z_rel && z_rsz) {\n                            unsigned rel_off = get_te64(&dynseg[-1+ z_rel].d_val);\n                            Elf64_Rela *rp = (Elf64_Rela *)&file_image[rel_off];\n                            unsigned relsz   = get_te64(&dynseg[-1+ z_rsz].d_val);\n                            Elf64_Rela *last = (Elf64_Rela *)(relsz + (char *)rp);\n                            for (; rp < last; ++rp) {\n                                unsigned r_va = get_te64(&rp->r_offset);\n                                if (r_va == user_init_ava) { // found the Elf64_Rela\n                                    unsigned r_info = get_te64(&rp->r_info);\n                                    unsigned r_type = ELF64_R_TYPE(r_info);\n                                    if (Elf64_Ehdr::EM_AARCH64 == e_machine\n                                    &&  R_AARCH64_RELATIVE == r_type) {\n                                        user_init_va = get_te64(&rp->r_addend);\n                                    }\n                                    else if (Elf64_Ehdr::EM_AARCH64 == e_machine\n                                    &&  R_AARCH64_ABS64 == r_type) {\n                                        user_init_va = get_te64(&file_image[user_init_off]);\n                                    }\n                                    else {\n                                        char msg[50]; snprintf(msg, sizeof(msg),\n                                            \"bad relocation %#x DT_INIT_ARRAY[0]\",\n                                            r_info);\n                                        throwCantPack(msg);\n                                    }\n                                    break;\n                                }\n                            }\n                        }\n                        unsigned const p_filesz = get_te64(&pload_x0->p_filesz);\n                        if (!((user_init_va - xct_va) < p_filesz)) {\n                            // Not in executable portion of first executable PT_LOAD.\n                            if (0==user_init_va && opt->o_unix.android_shlib) {\n                                // Android allows (0 ==> skip) ?\n                                upx_dt_init = 0;  // force steal of 'extra' DT_NULL\n                                // XXX: FIXME: depends on SHT_DYNAMIC coming later\n                            }\n                            else {\n                                char msg[70]; snprintf(msg, sizeof(msg),\n                                    \"bad init address %#x in Elf64_Shdr[%d].%#x\\n\",\n                                    (unsigned)user_init_va, -1+ e_shnum - j, user_init_off);\n                                throwCantPack(msg);\n                            }\n                        }\n                    }\n                    // By default /usr/bin/ld leaves 4 extra DT_NULL to support pre-linking.\n                    // Take one as a last resort.\n                    if ((Elf64_Dyn::DT_INIT==upx_dt_init || !upx_dt_init)\n                    &&  Elf64_Shdr::SHT_DYNAMIC == sh_type) {\n                        unsigned const n = get_te64(&shdr->sh_size) / sizeof(Elf64_Dyn);\n                        Elf64_Dyn *dynp = (Elf64_Dyn *)&file_image[get_te64(&shdr->sh_offset)];\n                        for (; Elf64_Dyn::DT_NULL != dynp->d_tag; ++dynp) {\n                            if (upx_dt_init == get_te64(&dynp->d_tag)) {\n                                break;  // re-found DT_INIT\n                            }\n                        }\n                        if ((1+ dynp) < (n+ dynseg)) { // not the terminator, so take it\n                            user_init_va = get_te64(&dynp->d_val);  // 0 if (0==upx_dt_init)\n                            set_te64(&dynp->d_tag, upx_dt_init = Elf64_Dyn::DT_INIT);\n                            user_init_off = (char const *)&dynp->d_val - (char const *)&file_image[0];\n                        }\n                    }\n                }\n            }\n            else { // no Sections; use heuristics\n                upx_uint64_t const strsz  = elf_unsigned_dynamic(Elf64_Dyn::DT_STRSZ);\n                upx_uint64_t const strtab = elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB);\n                upx_uint64_t const relsz  = elf_unsigned_dynamic(Elf64_Dyn::DT_RELSZ);\n                upx_uint64_t const rel    = elf_unsigned_dynamic(Elf64_Dyn::DT_REL);\n                upx_uint64_t const init   = elf_unsigned_dynamic(upx_dt_init);\n                if ((init == (relsz + rel   ) && rel    == (strsz + strtab))\n                ||  (init == (strsz + strtab) && strtab == (relsz + rel   ))\n                ) {\n                    xct_va = init;\n                    user_init_va = init;\n                    user_init_off = elf_get_offset_from_address(init);\n                }\n            }\n            // Rely on 0==elf_unsigned_dynamic(tag) if no such tag.\n            upx_uint64_t const va_gash = elf_unsigned_dynamic(Elf64_Dyn::DT_GNU_HASH);\n            upx_uint64_t const va_hash = elf_unsigned_dynamic(Elf64_Dyn::DT_HASH);\n            unsigned y = 0;\n            if ((y=1, xct_va < va_gash)  ||  (y=2, (0==va_gash && xct_va < va_hash))\n            ||  (y=3, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB))\n            ||  (y=4, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_SYMTAB))\n            ||  (y=5, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_REL))\n            ||  (y=6, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_RELA))\n            ||  (y=7, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_JMPREL))\n            ||  (y=8, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERDEF))\n            ||  (y=9, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERSYM))\n            ||  (y=10, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERNEEDED)) ) {\n                static char const *which[] = {\n                    \"unknown\",\n                    \"DT_GNU_HASH\",\n                    \"DT_HASH\",\n                    \"DT_STRTAB\",\n                    \"DT_SYMTAB\",\n                    \"DT_REL\",\n                    \"DT_RELA\",\n                    \"DT_JMPREL\",\n                    \"DT_VERDEF\",\n                    \"DT_VERSYM\",\n                    \"DT_VERNEEDED\",\n                };\n                char buf[30]; snprintf(buf, sizeof(buf), \"%s above stub\", which[y]);\n                throwCantPack(buf);\n                goto abandon;\n            }\n            if (!opt->o_unix.android_shlib) {\n                phdr = phdri;\n                for (unsigned j= 0; j < e_phnum; ++phdr, ++j) {\n                    upx_uint64_t const vaddr = get_te64(&phdr->p_vaddr);\n                    if (PT_NOTE64 == get_te32(&phdr->p_type)\n                    && xct_va < vaddr) {\n                        char buf[40]; snprintf(buf, sizeof(buf),\n                           \"PT_NOTE %#lx above stub\", (unsigned long)vaddr);\n                        throwCantPack(buf);\n                        goto abandon;\n                    }\n                }\n            }\n            xct_off = elf_get_offset_from_address(xct_va);\n            if (opt->debug.debug_level) {\n                fprintf(stderr, \"shlib canPack: xct_va=%#lx  xct_off=%#lx\\n\",\n                    (long)xct_va, (long)xct_off);\n            }\n            goto proceed;  // But proper packing depends on checking xct_va.\n        }\n        else\n            throwCantPack(\"need DT_INIT; try \\\"void _init(void){}\\\"\");\nabandon:\n        return false;\nproceed: ;\n    }\n    // XXX Theoretically the following test should be first,\n    // but PackUnix::canPack() wants 0!=exetype ?\n    if (!super::canPack())\n        return false;\n    assert(exetype == 1);\n    exetype = 0;\n\n    // set options\n    opt->o_unix.blocksize = blocksize = file_size;\n    return true;\n}", "target": 1, "idx": 11308}
{"commit_id": "a5d1721c8e3e62c30eb05609ece152fa689dbc35", "project": "fluent/fluent-bit", "func": "flb_sds_t flb_msgpack_raw_to_avro_sds(const void *in_buf, size_t in_size, struct flb_avro_fields *ctx)\n{\n    msgpack_unpacked result;\n    msgpack_object *root;\n\n    size_t avro_buffer_size = in_size * 3;\n    char *out_buff = flb_malloc(avro_buffer_size);\n    if (!out_buff) {\n        flb_errno();\n        return NULL;\n    }\n\n    avro_writer_t awriter;\n    flb_debug(\"in flb_msgpack_raw_to_avro_sds\\n\");\n    flb_debug(\"schemaID:%s:\\n\", ctx->schema_id);\n    flb_debug(\"schema string:%s:\\n\", ctx->schema_str);\n\n    size_t schema_json_len = flb_sds_len(ctx->schema_str);\n\n    avro_value_t  aobject;\n\n    assert(in_buf != NULL);\n\n    avro_value_iface_t  *aclass = NULL;\n    avro_schema_t aschema;\n\n    aclass = flb_avro_init(&aobject, (char *)ctx->schema_str, schema_json_len, &aschema);\n\n    if (!aclass) {\n        flb_error(\"Failed init avro:%s:n\", avro_strerror());\n        flb_free(out_buff);\n        return NULL;\n    }\n\n    msgpack_unpacked_init(&result);\n    if (msgpack_unpack_next(&result, in_buf, in_size, NULL) != MSGPACK_UNPACK_SUCCESS) {\n        flb_error(\"msgpack_unpack problem\\n\");\n        avro_value_decref(&aobject);\n        avro_value_iface_decref(aclass);\n        avro_schema_decref(aschema);\n        flb_free(out_buff);\n        return NULL;\n    }\n\n    root = &result.data;\n\n    // create the avro object\n    // then serialize it into a buffer for the downstream\n    flb_debug(\"calling flb_msgpack_to_avro\\n\");\n\n    if (flb_msgpack_to_avro(&aobject, root) != FLB_TRUE) {\n        flb_errno();\n        flb_error(\"Failed msgpack to avro\\n\");\n        msgpack_unpacked_destroy(&result);\n        avro_value_decref(&aobject);\n        avro_value_iface_decref(aclass);\n        avro_schema_decref(aschema);\n        flb_free(out_buff);\n        return NULL;\n    }\n\n    flb_debug(\"before avro_writer_memory\\n\");\n    awriter = avro_writer_memory(out_buff, avro_buffer_size);\n    if (awriter == NULL) {\n        flb_error(\"Unable to init avro writer\\n\");\n        msgpack_unpacked_destroy(&result);\n        avro_value_decref(&aobject);\n        avro_value_iface_decref(aclass);\n        avro_schema_decref(aschema);\n        flb_free(out_buff);\n        return NULL;\n    }\n\n    // write the magic byte stuff\n    //  write one bye of \\0\n    //  this is followed by\n    //  16 bytes of the schemaid where the schemaid is in hex\n    //  in this implementation the schemaid is the md5hash of the avro schema\n    int rval;\n    rval = avro_write(awriter, \"\\0\", 1);\n    if (rval != 0) {\n        flb_error(\"Unable to write magic byte\\n\");\n        avro_writer_free(awriter);\n        avro_value_decref(&aobject);\n        avro_value_iface_decref(aclass);\n        avro_schema_decref(aschema);\n        msgpack_unpacked_destroy(&result);\n        flb_free(out_buff);\n        return NULL;\n    }\n\n    // write the schemaid\n    // its md5hash of the avro schema\n    // it looks like this c4b52aaf22429c7f9eb8c30270bc1795\n    const char *pos = ctx->schema_id;\n    unsigned char val[16];\n    size_t count;\n    for (count = 0; count < sizeof val/sizeof *val; count++) {\n            sscanf(pos, \"%2hhx\", &val[count]);\n            pos += 2;\n    }\n    \n    // write it into a buffer which can be passed to librdkafka\n    rval = avro_write(awriter, val, 16);\n    if (rval != 0) {\n        flb_error(\"Unable to write schemaid\\n\");\n        avro_writer_free(awriter);\n        avro_value_decref(&aobject);\n        avro_value_iface_decref(aclass);\n        avro_schema_decref(aschema);\n        msgpack_unpacked_destroy(&result);\n        flb_free(out_buff);\n        return NULL;\n    }\n\n\tif (avro_value_write(awriter, &aobject)) {\n\t\tflb_error(\"Unable to write avro value to memory buffer\\nMessage: %s\\n\", avro_strerror());\n        avro_writer_free(awriter);\n        avro_value_decref(&aobject);\n        avro_value_iface_decref(aclass);\n        avro_schema_decref(aschema);\n        msgpack_unpacked_destroy(&result);\n        flb_free(out_buff);\n\t\treturn NULL;\n\t}\n\n    flb_debug(\"before avro_writer_flush\\n\");\n\n    avro_writer_flush(awriter);\n\n    int64_t bytes_written = avro_writer_tell(awriter);\n\n    // by here the entire object should be fully serialized into the sds buffer\n    avro_writer_free(awriter);\n    avro_value_decref(&aobject);\n\tavro_value_iface_decref(aclass);\n    avro_schema_decref(aschema);\n    msgpack_unpacked_destroy(&result);\n \n    flb_debug(\"after memory free:bytes written:%zu:\\n\", bytes_written);\n\n    flb_sds_t ret =  flb_sds_create_len(out_buff, bytes_written);\n\n    flb_free(out_buff);\n\n    flb_debug(\"shrunk flb sds:\\n\");\n    flb_debug(\"sds len:%zu:\\n\", flb_sds_len(ret));\n    flb_debug(\"sds alloc:%zu:\\n\", flb_sds_alloc(ret));\n    flb_debug(\"sds avail:%zu:\\n\", flb_sds_avail(ret));\n\n    return ret;\n\n}", "target": 2, "idx": 11309}
{"commit_id": "37deefd01f0875e133ea967122e3a5e421b8fcd9", "project": "uNetworking/uWebSockets", "func": "char *Hub::inflate(char *data, size_t &length) {\n    dynamicInflationBuffer.clear();\n\n    inflationStream.next_in = (Bytef *) data;\n    inflationStream.avail_in = length;\n\n    int err;\n    do {\n        inflationStream.next_out = (Bytef *) inflationBuffer;\n        inflationStream.avail_out = LARGE_BUFFER_SIZE;\n        err = ::inflate(&inflationStream, Z_FINISH);\n        if (!inflationStream.avail_in) {\n            break;\n        }\n\n        dynamicInflationBuffer.append(inflationBuffer, LARGE_BUFFER_SIZE - inflationStream.avail_out);\n    } while (err == Z_BUF_ERROR && dynamicInflationBuffer.length() <= INFLATE_LESS_THAN_ROUGHLY);\n\n    inflateReset(&inflationStream);\n\n    if ((err != Z_BUF_ERROR && err != Z_OK) || dynamicInflationBuffer.length() > INFLATE_LESS_THAN_ROUGHLY) {\n        length = 0;\n        return nullptr;\n    }\n\n    if (dynamicInflationBuffer.length()) {\n        dynamicInflationBuffer.append(inflationBuffer, LARGE_BUFFER_SIZE - inflationStream.avail_out);\n\n        length = dynamicInflationBuffer.length();\n        return (char *) dynamicInflationBuffer.data();\n    }\n\n    length = LARGE_BUFFER_SIZE - inflationStream.avail_out;\n    return inflationBuffer;\n}", "target": 1, "idx": 11310}
{"commit_id": "aed5d0919830c02e490f669fc36bd9af42e632d6", "project": "flatpak", "func": "static gboolean\nrepo_pull_one_untrusted (OstreeRepo          *self,\n                         const char          *remote_name,\n                         const char          *url,\n                         const char         **dirs_to_pull,\n                         const char          *ref,\n                         const char          *checksum,\n                         OstreeAsyncProgress *progress,\n                         GCancellable        *cancellable,\n                         GError             **error)\n{\n  /* The latter flag was introduced in https://github.com/ostreedev/ostree/pull/926 */\n  const OstreeRepoPullFlags flags = OSTREE_REPO_PULL_FLAGS_UNTRUSTED |OSTREE_REPO_PULL_FLAGS_BAREUSERONLY_FILES;\n  GVariantBuilder builder;\n  g_auto(GLnxConsoleRef) console = { 0, };\n  g_autoptr(OstreeAsyncProgress) console_progress = NULL;\n  gboolean res;\n  g_variant_builder_init (&builder, G_VARIANT_TYPE (\"a{sv}\"));\n  const char *refs[2] = { NULL, NULL };\n  const char *commits[2] = { NULL, NULL };\n\n  if (progress == NULL)\n    {\n      glnx_console_lock (&console);\n      if (console.is_tty)\n        {\n          console_progress = ostree_async_progress_new_and_connect (default_progress_changed, &console);\n          progress = console_progress;\n        }\n    }\n\n  refs[0] = ref;\n  commits[0] = checksum;\n\n  g_variant_builder_add (&builder, \"{s@v}\", \"flags\",\n                         g_variant_new_variant (g_variant_new_int32 (flags)));\n  g_variant_builder_add (&builder, \"{s@v}\", \"refs\",\n                         g_variant_new_variant (g_variant_new_strv ((const char * const *) refs, -1)));\n  g_variant_builder_add (&builder, \"{s@v}\", \"override-commit-ids\",\n                         g_variant_new_variant (g_variant_new_strv ((const char * const *) commits, -1)));\n  g_variant_builder_add (&builder, \"{s@v}\", \"override-remote-name\",\n                         g_variant_new_variant (g_variant_new_string (remote_name)));\n  g_variant_builder_add (&builder, \"{s@v}\", \"gpg-verify\",\n                         g_variant_new_variant (g_variant_new_boolean (TRUE)));\n  g_variant_builder_add (&builder, \"{s@v}\", \"gpg-verify-summary\",\n                         g_variant_new_variant (g_variant_new_boolean (TRUE)));\n  g_variant_builder_add (&builder, \"{s@v}\", \"inherit-transaction\",\n                         g_variant_new_variant (g_variant_new_boolean (TRUE)));\n  g_variant_builder_add (&builder, \"{s@v}\", \"update-frequency\",\n                         g_variant_new_variant (g_variant_new_uint32 (FLATPAK_DEFAULT_UPDATE_FREQUENCY)));\n\n  if (dirs_to_pull)\n    {\n      g_variant_builder_add (&builder, \"{s@v}\", \"subdirs\",\n                             g_variant_new_variant (g_variant_new_strv ((const char * const *)dirs_to_pull, -1)));\n      g_variant_builder_add (&builder, \"{s@v}\", \"disable-static-deltas\",\n                             g_variant_new_variant (g_variant_new_boolean (TRUE)));\n    }\n\n  res = ostree_repo_pull_with_options (self, url, g_variant_builder_end (&builder),\n                                       progress, cancellable, error);\n\n  if (progress)\n    ostree_async_progress_finish (progress);\n\n  return res;\n}", "target": 2, "idx": 11311}
{"commit_id": "35306eb23814444bd4021f8a1c3047d3cb0c8b2b", "project": "kernel/git/netdev/net", "func": "static void copy_peercred(struct sock *sk, struct sock *peersk)\n{\n\tconst struct cred *old_cred;\n\tstruct pid *old_pid;\n\n\tif (sk < peersk) {\n\t\tspin_lock(&sk->sk_peer_lock);\n\t\tspin_lock_nested(&peersk->sk_peer_lock, SINGLE_DEPTH_NESTING);\n\t} else {\n\t\tspin_lock(&peersk->sk_peer_lock);\n\t\tspin_lock_nested(&sk->sk_peer_lock, SINGLE_DEPTH_NESTING);\n\t}\n\told_pid = sk->sk_peer_pid;\n\told_cred = sk->sk_peer_cred;\n\tsk->sk_peer_pid  = get_pid(peersk->sk_peer_pid);\n\tsk->sk_peer_cred = get_cred(peersk->sk_peer_cred);\n\n\tspin_unlock(&sk->sk_peer_lock);\n\tspin_unlock(&peersk->sk_peer_lock);\n\n\tput_pid(old_pid);\n\tput_cred(old_cred);\n}", "target": 1, "idx": 11312}
{"commit_id": "25703a5cdbf3067ca4d4e75a0229762855548ecc", "project": "COVESA/dlt-daemon", "func": "DltReturnValue dlt_filter_load(DltFilter *filter, const char *filename, int verbose)\n{\n    if ((filter == NULL) || (filename == NULL))\n        return DLT_RETURN_WRONG_PARAMETER;\n\n    FILE *handle;\n    char str1[DLT_COMMON_BUFFER_LENGTH];\n    char apid[DLT_ID_SIZE], ctid[DLT_ID_SIZE];\n    char format[10];\n\n    PRINT_FUNCTION_VERBOSE(verbose);\n\n    handle = fopen(filename, \"r\");\n\n    if (handle == NULL) {\n        dlt_vlog(LOG_WARNING, \"Filter file %s cannot be opened!\\n\", filename);\n        return DLT_RETURN_ERROR;\n    }\n\n    sprintf(format, \"%c%ds\", '%', DLT_COMMON_BUFFER_LENGTH-1);\n\n    /* Reset filters */\n    filter->counter = 0;\n\n    while (!feof(handle)) {\n        str1[0] = 0;\n\n        if (fscanf(handle, format, str1) != 1)\n            break;\n\n        if (str1[0] == 0)\n            break;\n\n        printf(\" %s\", str1);\n\n        if (strcmp(str1, \"----\") == 0)\n            dlt_set_id(apid, \"\");\n        else\n            dlt_set_id(apid, str1);\n\n        str1[0] = 0;\n\n        if (fscanf(handle, format, str1) != 1)\n            break;\n\n        if (str1[0] == 0)\n            break;\n\n        printf(\" %s\\r\\n\", str1);\n\n        if (strcmp(str1, \"----\") == 0)\n            dlt_set_id(ctid, \"\");\n        else\n            dlt_set_id(ctid, str1);\n\n        if (filter->counter < DLT_FILTER_MAX) {\n            dlt_filter_add(filter, apid, ctid, verbose);\n        }\n        else {\n            dlt_vlog(LOG_WARNING,\n                     \"Maximum number (%d) of allowed filters reached, ignoring rest of filters!\\n\",\n                     DLT_FILTER_MAX);\n        }\n    }\n\n    fclose(handle);\n\n    return DLT_RETURN_OK;\n}", "target": 2, "idx": 11313}
{"commit_id": "50220dead1650609206efe91f0cc116132d59b3f", "project": "torvalds/linux", "func": "static void hid_input_field(struct hid_device *hid, struct hid_field *field,\n\t\t\t    __u8 *data, int interrupt)\n{\n\tunsigned n;\n\tunsigned count = field->report_count;\n\tunsigned offset = field->report_offset;\n\tunsigned size = field->report_size;\n\t__s32 min = field->logical_minimum;\n\t__s32 max = field->logical_maximum;\n\t__s32 *value;\n\n\tvalue = kmalloc(sizeof(__s32) * count, GFP_ATOMIC);\n\tif (!value)\n\t\treturn;\n\n\tfor (n = 0; n < count; n++) {\n\n\t\tvalue[n] = min < 0 ?\n\t\t\tsnto32(hid_field_extract(hid, data, offset + n * size,\n\t\t\t       size), size) :\n\t\t\thid_field_extract(hid, data, offset + n * size, size);\n\n\t\t/* Ignore report if ErrorRollOver */\n\t\tif (!(field->flags & HID_MAIN_ITEM_VARIABLE) &&\n\t\t    value[n] >= min && value[n] <= max &&\n\t\t    value[n] - min < field->maxusage &&\n\t\t    field->usage[value[n] - min].hid == HID_UP_KEYBOARD + 1)\n\t\t\tgoto exit;\n\t}\n\n\tfor (n = 0; n < count; n++) {\n\n\t\tif (HID_MAIN_ITEM_VARIABLE & field->flags) {\n\t\t\thid_process_event(hid, field, &field->usage[n], value[n], interrupt);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (field->value[n] >= min && field->value[n] <= max\n\t\t\t&& field->value[n] - min < field->maxusage\n\t\t\t&& field->usage[field->value[n] - min].hid\n\t\t\t&& search(value, field->value[n], count))\n\t\t\t\thid_process_event(hid, field, &field->usage[field->value[n] - min], 0, interrupt);\n\n\t\tif (value[n] >= min && value[n] <= max\n\t\t\t&& value[n] - min < field->maxusage\n\t\t\t&& field->usage[value[n] - min].hid\n\t\t\t&& search(field->value, value[n], count))\n\t\t\t\thid_process_event(hid, field, &field->usage[value[n] - min], 1, interrupt);\n\t}\n\n\tmemcpy(field->value, value, count * sizeof(__s32));\nexit:\n\tkfree(value);\n}", "target": 1, "idx": 11314}
{"commit_id": "5d069dbe8aaf2a197142558b6fb2978189ba3454", "project": "torvalds/linux", "func": "static int fuse_writepages(struct address_space *mapping,\n\t\t\t   struct writeback_control *wbc)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_fill_wb_data data;\n\tint err;\n\n\terr = -EIO;\n\tif (fuse_is_bad(inode))\n\t\tgoto out;\n\n\tdata.inode = inode;\n\tdata.wpa = NULL;\n\tdata.ff = NULL;\n\n\terr = -ENOMEM;\n\tdata.orig_pages = kcalloc(fc->max_pages,\n\t\t\t\t  sizeof(struct page *),\n\t\t\t\t  GFP_NOFS);\n\tif (!data.orig_pages)\n\t\tgoto out;\n\n\terr = write_cache_pages(mapping, wbc, fuse_writepages_fill, &data);\n\tif (data.wpa) {\n\t\tWARN_ON(!data.wpa->ia.ap.num_pages);\n\t\tfuse_writepages_send(&data);\n\t}\n\tif (data.ff)\n\t\tfuse_file_put(data.ff, false, false);\n\n\tkfree(data.orig_pages);\nout:\n\treturn err;\n}", "target": 1, "idx": 11315}
{"commit_id": "e4b777c7b7c144cd16a0ea96108267b1004fe6c9", "project": "hpjansson/chafa", "func": "static gif_result\ngif_internal_decode_frame(gif_animation *gif,\n                          unsigned int frame,\n                          bool clear_image)\n{\n        unsigned int index = 0;\n        const unsigned char *gif_data, *gif_end;\n        ssize_t gif_bytes;\n        unsigned int width, height, offset_x, offset_y;\n        unsigned int flags, colour_table_size, interlace;\n        unsigned int *colour_table;\n        unsigned int *frame_data = 0;\t// Set to 0 for no warnings\n        unsigned int *frame_scanline;\n        ssize_t save_buffer_position;\n        unsigned int return_value = 0;\n        unsigned int x, y, decode_y, burst_bytes;\n        register unsigned char colour;\n\n        /* If the GIF has no frame data, frame holders will not be allocated in\n         * gif_initialise() */\n        if (gif->frames == NULL) {\n                return GIF_INSUFFICIENT_DATA;\n        }\n\n        /* Ensure this frame is supposed to be decoded */\n        if (gif->frames[frame].display == false) {\n                return GIF_OK;\n        }\n\n        /* Ensure the frame is in range to decode */\n        if (frame > gif->frame_count_partial) {\n                return GIF_INSUFFICIENT_DATA;\n        }\n\n        /* done if frame is already decoded */\n        if ((!clear_image) &&\n            ((int)frame == gif->decoded_frame)) {\n                return GIF_OK;\n        }\n\n        /* Get the start of our frame data and the end of the GIF data */\n        gif_data = gif->gif_data + gif->frames[frame].frame_pointer;\n        gif_end = gif->gif_data + gif->buffer_size;\n        gif_bytes = (gif_end - gif_data);\n\n        /*\n         * Ensure there is a minimal amount of data to proceed.  The shortest\n         * block of data is a 10-byte image descriptor + 1-byte gif trailer\n         */\n        if (gif_bytes < 12) {\n                return GIF_INSUFFICIENT_FRAME_DATA;\n        }\n\n        /* Save the buffer position */\n        save_buffer_position = gif->buffer_position;\n        gif->buffer_position = gif_data - gif->gif_data;\n\n        /* Skip any extensions because they have allready been processed */\n        if ((return_value = gif_skip_frame_extensions(gif)) != GIF_OK) {\n                goto gif_decode_frame_exit;\n        }\n        gif_data = (gif->gif_data + gif->buffer_position);\n        gif_bytes = (gif_end - gif_data);\n\n        /* Ensure we have enough data for the 10-byte image descriptor + 1-byte\n         * gif trailer\n         */\n        if (gif_bytes < 12) {\n                return_value = GIF_INSUFFICIENT_FRAME_DATA;\n                goto gif_decode_frame_exit;\n        }\n\n        /* 10-byte Image Descriptor is:\n         *\n         *\t+0\tCHAR\tImage Separator (0x2c)\n         *\t+1\tSHORT\tImage Left Position\n         *\t+3\tSHORT\tImage Top Position\n         *\t+5\tSHORT\tWidth\n         *\t+7\tSHORT\tHeight\n         *\t+9\tCHAR\t__Packed Fields__\n         *\t\t\t1BIT\tLocal Colour Table Flag\n         *\t\t\t1BIT\tInterlace Flag\n         *\t\t\t1BIT\tSort Flag\n         *\t\t\t2BITS\tReserved\n         *\t\t\t3BITS\tSize of Local Colour Table\n         */\n        if (gif_data[0] != GIF_IMAGE_SEPARATOR) {\n                return_value = GIF_DATA_ERROR;\n                goto gif_decode_frame_exit;\n        }\n        offset_x = gif_data[1] | (gif_data[2] << 8);\n        offset_y = gif_data[3] | (gif_data[4] << 8);\n        width = gif_data[5] | (gif_data[6] << 8);\n        height = gif_data[7] | (gif_data[8] << 8);\n\n        /* Boundary checking - shouldn't ever happen except unless the data has\n         * been modified since initialisation.\n         */\n        if ((offset_x + width > gif->width) ||\n            (offset_y + height > gif->height)) {\n                return_value = GIF_DATA_ERROR;\n                goto gif_decode_frame_exit;\n        }\n\n        /* Decode the flags */\n        flags = gif_data[9];\n        colour_table_size = 2 << (flags & GIF_COLOUR_TABLE_SIZE_MASK);\n        interlace = flags & GIF_INTERLACE_MASK;\n\n        /* Advance data pointer to next block either colour table or image\n         * data.\n         */\n        gif_data += 10;\n        gif_bytes = (gif_end - gif_data);\n\n        /* Set up the colour table */\n        if (flags & GIF_COLOUR_TABLE_MASK) {\n                if (gif_bytes < (int)(3 * colour_table_size)) {\n                        return_value = GIF_INSUFFICIENT_FRAME_DATA;\n                        goto gif_decode_frame_exit;\n                }\n                colour_table = gif->local_colour_table;\n                if (!clear_image) {\n                        for (index = 0; index < colour_table_size; index++) {\n                                /* Gif colour map contents are r,g,b.\n                                 *\n                                 * We want to pack them bytewise into the\n                                 * colour table, such that the red component\n                                 * is in byte 0 and the alpha component is in\n                                 * byte 3.\n                                 */\n                                unsigned char *entry =\n                                        (unsigned char *) &colour_table[index];\n\n                                entry[0] = gif_data[0];\t/* r */\n                                entry[1] = gif_data[1];\t/* g */\n                                entry[2] = gif_data[2];\t/* b */\n                                entry[3] = 0xff;\t/* a */\n\n                                gif_data += 3;\n                        }\n                } else {\n                        gif_data += 3 * colour_table_size;\n                }\n                gif_bytes = (gif_end - gif_data);\n        } else {\n                colour_table = gif->global_colour_table;\n        }\n\n        /* Ensure sufficient data remains */\n        if (gif_bytes < 1) {\n                return_value = GIF_INSUFFICIENT_FRAME_DATA;\n                goto gif_decode_frame_exit;\n        }\n\n        /* check for an end marker */\n        if (gif_data[0] == GIF_TRAILER) {\n                return_value = GIF_OK;\n                goto gif_decode_frame_exit;\n        }\n\n        /* Get the frame data */\n        assert(gif->bitmap_callbacks.bitmap_get_buffer);\n        frame_data = (void *)gif->bitmap_callbacks.bitmap_get_buffer(gif->frame_image);\n        if (!frame_data) {\n                return GIF_INSUFFICIENT_MEMORY;\n        }\n\n        /* If we are clearing the image we just clear, if not decode */\n        if (!clear_image) {\n                lzw_result res;\n                const uint8_t *stack_base;\n                const uint8_t *stack_pos;\n\n                /* Ensure we have enough data for a 1-byte LZW code size +\n                 * 1-byte gif trailer\n                 */\n                if (gif_bytes < 2) {\n                        return_value = GIF_INSUFFICIENT_FRAME_DATA;\n                        goto gif_decode_frame_exit;\n                }\n\n                /* If we only have a 1-byte LZW code size + 1-byte gif trailer,\n                 * we're finished\n                 */\n                if ((gif_bytes == 2) && (gif_data[1] == GIF_TRAILER)) {\n                        return_value = GIF_OK;\n                        goto gif_decode_frame_exit;\n                }\n\n                /* If the previous frame's disposal method requires we restore\n                 * the background colour or this is the first frame, clear\n                 * the frame data\n                 */\n                if ((frame == 0) || (gif->decoded_frame == GIF_INVALID_FRAME)) {\n                        memset((char*)frame_data,\n                               GIF_TRANSPARENT_COLOUR,\n                               gif->width * gif->height * sizeof(int));\n                        gif->decoded_frame = frame;\n                        /* The line below would fill the image with its\n                         * background color, but because GIFs support\n                         * transparency we likely wouldn't want to do that. */\n                        /* memset((char*)frame_data, colour_table[gif->background_index], gif->width * gif->height * sizeof(int)); */\n                } else if ((frame != 0) &&\n                           (gif->frames[frame - 1].disposal_method == GIF_FRAME_CLEAR)) {\n                        return_value = gif_internal_decode_frame(gif,\n                                                                 (frame - 1),\n                                                                 true);\n                        if (return_value != GIF_OK) {\n                                goto gif_decode_frame_exit;\n                        }\n\n                } else if ((frame != 0) &&\n                           (gif->frames[frame - 1].disposal_method == GIF_FRAME_RESTORE)) {\n                        /*\n                         * If the previous frame's disposal method requires we\n                         * restore the previous image, find the last image set\n                         * to \"do not dispose\" and get that frame data\n                         */\n                        int last_undisposed_frame = frame - 2;\n                        while ((last_undisposed_frame >= 0) &&\n                               (gif->frames[last_undisposed_frame].disposal_method == GIF_FRAME_RESTORE)) {\n                                last_undisposed_frame--;\n                        }\n\n                        /* If we don't find one, clear the frame data */\n                        if (last_undisposed_frame == -1) {\n                                /* see notes above on transparency\n                                 * vs. background color\n                                 */\n                                memset((char*)frame_data,\n                                       GIF_TRANSPARENT_COLOUR,\n                                       gif->width * gif->height * sizeof(int));\n                        } else {\n                                return_value = gif_internal_decode_frame(gif, last_undisposed_frame, false);\n                                if (return_value != GIF_OK) {\n                                        goto gif_decode_frame_exit;\n                                }\n                                /* Get this frame's data */\n                                assert(gif->bitmap_callbacks.bitmap_get_buffer);\n                                frame_data = (void *)gif->bitmap_callbacks.bitmap_get_buffer(gif->frame_image);\n                                if (!frame_data) {\n                                        return GIF_INSUFFICIENT_MEMORY;\n                                }\n                        }\n                }\n                gif->decoded_frame = frame;\n                gif->buffer_position = (gif_data - gif->gif_data) + 1;\n\n                /* Initialise the LZW decoding */\n                res = lzw_decode_init(gif->lzw_ctx, gif->gif_data,\n                                gif->buffer_size, gif->buffer_position,\n                                gif_data[0], &stack_base, &stack_pos);\n                if (res != LZW_OK) {\n                        return gif_error_from_lzw(res);\n                }\n\n                /* Decompress the data */\n                for (y = 0; y < height; y++) {\n                        if (interlace) {\n                                decode_y = gif_interlaced_line(height, y) + offset_y;\n                        } else {\n                                decode_y = y + offset_y;\n                        }\n                        frame_scanline = frame_data + offset_x + (decode_y * gif->width);\n\n                        /* Rather than decoding pixel by pixel, we try to burst\n                         * out streams of data to remove the need for end-of\n                         * data checks every pixel.\n                         */\n                        x = width;\n                        while (x > 0) {\n                                burst_bytes = (stack_pos - stack_base);\n                                if (burst_bytes > 0) {\n                                        if (burst_bytes > x) {\n                                                burst_bytes = x;\n                                        }\n                                        x -= burst_bytes;\n                                        while (burst_bytes-- > 0) {\n                                                colour = *--stack_pos;\n                                                if (((gif->frames[frame].transparency) &&\n                                                     (colour != gif->frames[frame].transparency_index)) ||\n                                                    (!gif->frames[frame].transparency)) {\n                                                        *frame_scanline = colour_table[colour];\n                                                }\n                                                frame_scanline++;\n                                        }\n                                } else {\n                                        res = lzw_decode(gif->lzw_ctx, &stack_pos);\n                                        if (res != LZW_OK) {\n                                                /* Unexpected end of frame, try to recover */\n                                                if (res == LZW_OK_EOD) {\n                                                        return_value = GIF_OK;\n                                                } else {\n                                                        return_value = gif_error_from_lzw(res);\n                                                }\n                                                goto gif_decode_frame_exit;\n                                        }\n                                }\n                        }\n                }\n        } else {\n                /* Clear our frame */\n                if (gif->frames[frame].disposal_method == GIF_FRAME_CLEAR) {\n                        for (y = 0; y < height; y++) {\n                                frame_scanline = frame_data + offset_x + ((offset_y + y) * gif->width);\n                                if (gif->frames[frame].transparency) {\n                                        memset(frame_scanline,\n                                               GIF_TRANSPARENT_COLOUR,\n                                               width * 4);\n                                } else {\n                                        memset(frame_scanline,\n                                               colour_table[gif->background_index],\n                                               width * 4);\n                                }\n                        }\n                }\n        }\ngif_decode_frame_exit:\n\n        /* Check if we should test for optimisation */\n        if (gif->frames[frame].virgin) {\n                if (gif->bitmap_callbacks.bitmap_test_opaque) {\n                        gif->frames[frame].opaque = gif->bitmap_callbacks.bitmap_test_opaque(gif->frame_image);\n                } else {\n                        gif->frames[frame].opaque = false;\n                }\n                gif->frames[frame].virgin = false;\n        }\n\n        if (gif->bitmap_callbacks.bitmap_set_opaque) {\n                gif->bitmap_callbacks.bitmap_set_opaque(gif->frame_image, gif->frames[frame].opaque);\n        }\n\n        if (gif->bitmap_callbacks.bitmap_modified) {\n                gif->bitmap_callbacks.bitmap_modified(gif->frame_image);\n        }\n\n        /* Restore the buffer position */\n        gif->buffer_position = save_buffer_position;\n\n        return return_value;\n}", "target": 1, "idx": 11316}
{"commit_id": "779b648c5f6aa9b33f4728f79dd4d0efec0bf860", "project": "upx", "func": "void\nPackLinuxElf32::PackLinuxElf32help1(InputFile *f)\n{\n    e_type  = get_te16(&ehdri.e_type);\n    e_phnum = get_te16(&ehdri.e_phnum);\n    e_shnum = get_te16(&ehdri.e_shnum);\n    unsigned const e_phentsize = get_te16(&ehdri.e_phentsize);\n    if (memcmp((char const *)&ehdri, \"\\x7f\\x45\\x4c\\x46\", 4)  // \"\\177ELF\"\n    || ehdri.e_ident[Elf32_Ehdr::EI_CLASS]!=Elf32_Ehdr::ELFCLASS32\n    || sizeof(Elf32_Phdr) != e_phentsize\n    || (Elf32_Ehdr::ELFDATA2MSB == ehdri.e_ident[Elf32_Ehdr::EI_DATA]\n            && &N_BELE_RTP::be_policy != bele)\n    || (Elf32_Ehdr::ELFDATA2LSB == ehdri.e_ident[Elf32_Ehdr::EI_DATA]\n            && &N_BELE_RTP::le_policy != bele)) {\n        e_phoff = 0;\n        e_shoff = 0;\n        sz_phdrs = 0;\n        return;\n    }\n    if (0==e_phnum) throwCantUnpack(\"0==e_phnum\");\n    e_phoff = get_te32(&ehdri.e_phoff);\n    unsigned const last_Phdr = e_phoff + e_phnum * usizeof(Elf32_Phdr);\n    if (last_Phdr < e_phoff  // wrap-around\n    ||  e_phoff != sizeof(Elf32_Ehdr)  // must be contiguous\n    ||  (unsigned long)file_size < last_Phdr) {\n        throwCantUnpack(\"bad e_phoff\");\n    }\n    e_shoff = get_te32(&ehdri.e_shoff);\n    unsigned const last_Shdr = e_shoff + e_shnum * usizeof(Elf32_Shdr);\n    if (last_Shdr < e_shoff  // wrap-around\n    ||  (e_shnum && e_shoff < last_Phdr)\n    ||  (unsigned long)file_size < last_Shdr) {\n        if (opt->cmd == CMD_COMPRESS) {\n            throwCantUnpack(\"bad e_shoff\");\n        }\n    }\n    sz_phdrs = e_phnum * e_phentsize;\n\n    if (f && Elf32_Ehdr::ET_DYN!=e_type) {\n        unsigned const len = sz_phdrs + e_phoff;\n        alloc_file_image(file_image, len);\n        f->seek(0, SEEK_SET);\n        f->readx(file_image, len);\n        phdri= (Elf32_Phdr       *)(e_phoff + file_image);  // do not free() !!\n    }\n    if (f && Elf32_Ehdr::ET_DYN==e_type) {\n        // The DT_SYMTAB has no designated length.  Read the whole file.\n        alloc_file_image(file_image, file_size);\n        f->seek(0, SEEK_SET);\n        f->readx(file_image, file_size);\n        phdri= (Elf32_Phdr *)(e_phoff + file_image);  // do not free() !!\n        shdri= (Elf32_Shdr *)(e_shoff + file_image);  // do not free() !!\n        if (opt->cmd != CMD_COMPRESS) {\n            shdri = nullptr;\n        }\n        sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);\n        if (sec_dynsym) {\n            unsigned t = get_te32(&sec_dynsym->sh_link);\n            if (e_shnum <= t)\n                throwCantPack(\"bad dynsym->sh_link\");\n            sec_dynstr = &shdri[t];\n        }\n\n        Elf32_Phdr const *phdr= phdri;\n        for (int j = e_phnum; --j>=0; ++phdr)\n        if (Elf32_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {\n            unsigned offset = check_pt_dynamic(phdr);\n            dynseg= (Elf32_Dyn const *)(offset + file_image);\n            invert_pt_dynamic(dynseg,\n                umin(get_te32(&phdr->p_filesz), file_size - offset));\n        }\n        else if (is_LOAD32(phdr)) {\n            check_pt_load(phdr);\n        }\n        // elf_find_dynamic() returns 0 if 0==dynseg.\n        dynstr =      (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);\n        dynsym = (Elf32_Sym const *)elf_find_dynamic(Elf32_Dyn::DT_SYMTAB);\n        gashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_GNU_HASH);\n        hashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_HASH);\n        if (3& ((upx_uintptr_t)dynsym | (upx_uintptr_t)gashtab | (upx_uintptr_t)hashtab)) {\n            throwCantPack(\"unaligned DT_SYMTAB, DT_GNU_HASH, or DT_HASH/n\");\n        }\n        jni_onload_sym = elf_lookup(\"JNI_OnLoad\");\n        if (jni_onload_sym) {\n            jni_onload_va = get_te32(&jni_onload_sym->st_value);\n            jni_onload_va = 0;  // FIXME not understood; need example\n        }\n    }\n}", "target": 1, "idx": 11317}
{"commit_id": "35d2969ea3c7d32aee78066b1f3cf61a0d935a4e", "project": "torvalds/linux", "func": "int avc_ca_pmt(struct firedtv *fdtv, char *msg, int length)\n{\n\tstruct avc_command_frame *c = (void *)fdtv->avc_data;\n\tstruct avc_response_frame *r = (void *)fdtv->avc_data;\n\tint list_management;\n\tint program_info_length;\n\tint pmt_cmd_id;\n\tint read_pos;\n\tint write_pos;\n\tint es_info_length;\n\tint crc32_csum;\n\tint ret;\n\n\tif (unlikely(avc_debug & AVC_DEBUG_APPLICATION_PMT))\n\t\tdebug_pmt(msg, length);\n\n\tmutex_lock(&fdtv->avc_mutex);\n\n\tc->ctype   = AVC_CTYPE_CONTROL;\n\tc->subunit = AVC_SUBUNIT_TYPE_TUNER | fdtv->subunit;\n\tc->opcode  = AVC_OPCODE_VENDOR;\n\n\tif (msg[0] != EN50221_LIST_MANAGEMENT_ONLY) {\n\t\tdev_info(fdtv->device, \"forcing list_management to ONLY\\n\");\n\t\tmsg[0] = EN50221_LIST_MANAGEMENT_ONLY;\n\t}\n\t/* We take the cmd_id from the programme level only! */\n\tlist_management = msg[0];\n\tprogram_info_length = ((msg[4] & 0x0f) << 8) + msg[5];\n\tif (program_info_length > 0)\n\t\tprogram_info_length--; /* Remove pmt_cmd_id */\n\tpmt_cmd_id = msg[6];\n\n\tc->operand[0] = SFE_VENDOR_DE_COMPANYID_0;\n\tc->operand[1] = SFE_VENDOR_DE_COMPANYID_1;\n\tc->operand[2] = SFE_VENDOR_DE_COMPANYID_2;\n\tc->operand[3] = SFE_VENDOR_OPCODE_HOST2CA;\n\tc->operand[4] = 0; /* slot */\n\tc->operand[5] = SFE_VENDOR_TAG_CA_PMT; /* ca tag */\n\tc->operand[6] = 0; /* more/last */\n\t/* Use three bytes for length field in case length > 127 */\n\tc->operand[10] = list_management;\n\tc->operand[11] = 0x01; /* pmt_cmd=OK_descramble */\n\n\t/* TS program map table */\n\n\tc->operand[12] = 0x02; /* Table id=2 */\n\tc->operand[13] = 0x80; /* Section syntax + length */\n\n\tc->operand[15] = msg[1]; /* Program number */\n\tc->operand[16] = msg[2];\n\tc->operand[17] = msg[3]; /* Version number and current/next */\n\tc->operand[18] = 0x00; /* Section number=0 */\n\tc->operand[19] = 0x00; /* Last section number=0 */\n\tc->operand[20] = 0x1f; /* PCR_PID=1FFF */\n\tc->operand[21] = 0xff;\n\tc->operand[22] = (program_info_length >> 8); /* Program info length */\n\tc->operand[23] = (program_info_length & 0xff);\n\n\t/* CA descriptors at programme level */\n\tread_pos = 6;\n\twrite_pos = 24;\n\tif (program_info_length > 0) {\n\t\tpmt_cmd_id = msg[read_pos++];\n\t\tif (pmt_cmd_id != 1 && pmt_cmd_id != 4)\n\t\t\tdev_err(fdtv->device,\n\t\t\t\t\"invalid pmt_cmd_id %d\\n\", pmt_cmd_id);\n\t\tif (program_info_length > sizeof(c->operand) - 4 - write_pos) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tmemcpy(&c->operand[write_pos], &msg[read_pos],\n\t\t       program_info_length);\n\t\tread_pos += program_info_length;\n\t\twrite_pos += program_info_length;\n\t}\n\twhile (read_pos + 4 < length) {\n\t\tif (write_pos + 4 >= sizeof(c->operand) - 4) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tc->operand[write_pos++] = msg[read_pos++];\n\t\tc->operand[write_pos++] = msg[read_pos++];\n\t\tc->operand[write_pos++] = msg[read_pos++];\n\t\tes_info_length =\n\t\t\t((msg[read_pos] & 0x0f) << 8) + msg[read_pos + 1];\n\t\tread_pos += 2;\n\t\tif (es_info_length > 0)\n\t\t\tes_info_length--; /* Remove pmt_cmd_id */\n\t\tc->operand[write_pos++] = es_info_length >> 8;\n\t\tc->operand[write_pos++] = es_info_length & 0xff;\n\t\tif (es_info_length > 0) {\n\t\t\tif (read_pos >= length) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tpmt_cmd_id = msg[read_pos++];\n\t\t\tif (pmt_cmd_id != 1 && pmt_cmd_id != 4)\n\t\t\t\tdev_err(fdtv->device, \"invalid pmt_cmd_id %d at stream level\\n\",\n\t\t\t\t\tpmt_cmd_id);\n\n\t\t\tif (es_info_length > sizeof(c->operand) - 4 - write_pos ||\n\t\t\t    es_info_length > length - read_pos) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tmemcpy(&c->operand[write_pos], &msg[read_pos],\n\t\t\t       es_info_length);\n\t\t\tread_pos += es_info_length;\n\t\t\twrite_pos += es_info_length;\n\t\t}\n\t}\n\twrite_pos += 4; /* CRC */\n\n\tc->operand[7] = 0x82;\n\tc->operand[8] = (write_pos - 10) >> 8;\n\tc->operand[9] = (write_pos - 10) & 0xff;\n\tc->operand[14] = write_pos - 15;\n\n\tcrc32_csum = crc32_be(0, &c->operand[10], c->operand[12] - 1);\n\tc->operand[write_pos - 4] = (crc32_csum >> 24) & 0xff;\n\tc->operand[write_pos - 3] = (crc32_csum >> 16) & 0xff;\n\tc->operand[write_pos - 2] = (crc32_csum >>  8) & 0xff;\n\tc->operand[write_pos - 1] = (crc32_csum >>  0) & 0xff;\n\tpad_operands(c, write_pos);\n\n\tfdtv->avc_data_length = ALIGN(3 + write_pos, 4);\n\tret = avc_write(fdtv);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (r->response != AVC_RESPONSE_ACCEPTED) {\n\t\tdev_err(fdtv->device,\n\t\t\t\"CA PMT failed with response 0x%x\\n\", r->response);\n\t\tret = -EACCES;\n\t}\nout:\n\tmutex_unlock(&fdtv->avc_mutex);\n\n\treturn ret;\n}", "target": 1, "idx": 11318}
{"commit_id": "c24968734abfed81c8f93dc5f44a7b7a9aecadfa", "project": "torvalds/linux", "func": "static int virtio_gpu_object_shmem_init(struct virtio_gpu_device *vgdev,\n\t\t\t\t\tstruct virtio_gpu_object *bo,\n\t\t\t\t\tstruct virtio_gpu_mem_entry **ents,\n\t\t\t\t\tunsigned int *nents)\n{\n\tbool use_dma_api = !virtio_has_dma_quirk(vgdev->vdev);\n\tstruct virtio_gpu_object_shmem *shmem = to_virtio_gpu_shmem(bo);\n\tstruct scatterlist *sg;\n\tint si, ret;\n\n\tret = drm_gem_shmem_pin(&bo->base);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\t/*\n\t * virtio_gpu uses drm_gem_shmem_get_sg_table instead of\n\t * drm_gem_shmem_get_pages_sgt because virtio has it's own set of\n\t * dma-ops. This is discouraged for other drivers, but should be fine\n\t * since virtio_gpu doesn't support dma-buf import from other devices.\n\t */\n\tshmem->pages = drm_gem_shmem_get_sg_table(&bo->base);\n\tif (IS_ERR(shmem->pages)) {\n\t\tdrm_gem_shmem_unpin(&bo->base);\n\t\treturn PTR_ERR(shmem->pages);\n\t}\n\n\tif (use_dma_api) {\n\t\tret = dma_map_sgtable(vgdev->vdev->dev.parent,\n\t\t\t\t      shmem->pages, DMA_TO_DEVICE, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t*nents = shmem->mapped = shmem->pages->nents;\n\t} else {\n\t\t*nents = shmem->pages->orig_nents;\n\t}\n\n\t*ents = kvmalloc_array(*nents,\n\t\t\t       sizeof(struct virtio_gpu_mem_entry),\n\t\t\t       GFP_KERNEL);\n\tif (!(*ents)) {\n\t\tDRM_ERROR(\"failed to allocate ent list\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (use_dma_api) {\n\t\tfor_each_sgtable_dma_sg(shmem->pages, sg, si) {\n\t\t\t(*ents)[si].addr = cpu_to_le64(sg_dma_address(sg));\n\t\t\t(*ents)[si].length = cpu_to_le32(sg_dma_len(sg));\n\t\t\t(*ents)[si].padding = 0;\n\t\t}\n\t} else {\n\t\tfor_each_sgtable_sg(shmem->pages, sg, si) {\n\t\t\t(*ents)[si].addr = cpu_to_le64(sg_phys(sg));\n\t\t\t(*ents)[si].length = cpu_to_le32(sg->length);\n\t\t\t(*ents)[si].padding = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}", "target": 1, "idx": 11319}
{"commit_id": "5faf80cd53ecfd16b636d653483144cd12004f46", "project": "ckolivas/lrzip", "func": "int main(int argc, char *argv[])\n{\n\tbool lrzcat = false, compat = false, recurse = false;\n\tbool options_file = false, conf_file_compression_set = false; /* for environment and tracking of compression setting */\n\tstruct timeval start_time, end_time;\n\tstruct sigaction handler;\n\tdouble seconds,total_time; // for timers\n\tbool nice_set = false;\n\tint c, i;\n\tint hours,minutes;\n\textern int optind;\n\tchar *eptr, *av; /* for environment */\n\tchar *endptr = NULL;\n\n        control = &base_control;\n\n\tinitialise_control(control);\n\n\tav = basename(argv[0]);\n\tif (!strcmp(av, \"lrunzip\"))\n\t\tcontrol->flags |= FLAG_DECOMPRESS;\n\telse if (!strcmp(av, \"lrzcat\")) {\n\t\tcontrol->flags |= FLAG_DECOMPRESS | FLAG_STDOUT;\n\t\tlrzcat = true;\n\t} else if (!strcmp(av, \"lrz\")) {\n\t\t/* Called in gzip compatible command line mode */\n\t\tcontrol->flags &= ~FLAG_SHOW_PROGRESS;\n\t\tcontrol->flags &= ~FLAG_KEEP_FILES;\n\t\tcompat = true;\n\t\tlong_options[1].name = \"stdout\";\n\t\tlong_options[11].name = \"keep\";\n\t}\n\n\t/* generate crc table */\n\tCrcGenerateTable();\n\n\t/* Get Preloaded Defaults from lrzip.conf\n\t * Look in ., $HOME/.lrzip/, /etc/lrzip.\n\t * If LRZIP=NOCONFIG is set, then ignore config\n\t * If lrzip.conf sets a compression mode, options_file will be true.\n\t * This will allow for a test to permit an override of compression mode.\n\t * If there is an override, then all compression settings will be reset\n\t * and command line switches will prevail, including for --lzma.\n\t */\n\teptr = getenv(\"LRZIP\");\n\tif (eptr == NULL)\n\t\toptions_file = read_config(control);\n\telse if (!strstr(eptr,\"NOCONFIG\"))\n\t\toptions_file = read_config(control);\n\tif (options_file && (control->flags & FLAG_NOT_LZMA))\t\t/* if some compression set in lrzip.conf    */\n\t\tconf_file_compression_set = true;\t\t\t/* need this to allow command line override */\n\n\twhile ((c = getopt_long(argc, argv, compat ? coptions : loptions, long_options, &i)) != -1) {\n\t\tswitch (c) {\n\t\tcase 'b':\n\t\tcase 'g':\n\t\tcase 'l':\n\t\tcase 'n':\n\t\tcase 'z':\n\t\t\t/* If some compression was chosen in lrzip.conf, allow this one time\n\t\t\t * because conf_file_compression_set will be true\n\t\t\t */\n\t\t\tif ((control->flags & FLAG_NOT_LZMA) && conf_file_compression_set == false)\n\t\t\t\tfailure(\"Can only use one of -l, -b, -g, -z or -n\\n\");\n\t\t\t/* Select Compression Mode */\n\t\t\tcontrol->flags &= ~FLAG_NOT_LZMA; /* must clear all compressions first */\n\t\t\tif (c == 'b')\n\t\t\t\tcontrol->flags |= FLAG_BZIP2_COMPRESS;\n\t\t\telse if (c == 'g')\n\t\t\t\tcontrol->flags |= FLAG_ZLIB_COMPRESS;\n\t\t\telse if (c == 'l')\n\t\t\t\tcontrol->flags |= FLAG_LZO_COMPRESS;\n\t\t\telse if (c == 'n')\n\t\t\t\tcontrol->flags |= FLAG_NO_COMPRESS;\n\t\t\telse if (c == 'z')\n\t\t\t\tcontrol->flags |= FLAG_ZPAQ_COMPRESS;\n\t\t\t/* now FLAG_NOT_LZMA will evaluate as true */\n\t\t\tconf_file_compression_set = false;\n\t\t\tbreak;\n\t\tcase '/':\t\t\t\t\t\t\t/* LZMA Compress selected */\n\t\t\tcontrol->flags &= ~FLAG_NOT_LZMA;\t\t\t/* clear alternate compression flags */\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tif (compat) {\n\t\t\t\tcontrol->flags |= FLAG_KEEP_FILES;\n\t\t\t\tset_stdout(control);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* FALLTHRU */\n\t\tcase 'C':\n\t\t\tcontrol->flags |= FLAG_CHECK;\n\t\t\tcontrol->flags |= FLAG_HASH;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tcontrol->flags |= FLAG_DECOMPRESS;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tcontrol->flags &= ~FLAG_KEEP_FILES;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tcontrol->flags |= FLAG_ENCRYPT;\n\t\t\tcontrol->passphrase = optarg;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tcontrol->flags |= FLAG_FORCE_REPLACE;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage(compat);\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 'H':\n\t\t\tcontrol->flags |= FLAG_HASH;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tcontrol->flags |= FLAG_INFO;\n\t\t\tcontrol->flags &= ~FLAG_DECOMPRESS;\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tif (compat) {\n\t\t\t\tcontrol->flags |= FLAG_KEEP_FILES;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* FALLTHRU */\n\t\tcase 'K':\n\t\t\tcontrol->flags |= FLAG_KEEP_BROKEN;\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tif (compat) {\n\t\t\t\tlicense();\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tcontrol->compression_level = strtol(optarg, &endptr, 10);\n\t\t\tif (control->compression_level < 1 || control->compression_level > 9)\n\t\t\t\tfailure(\"Invalid compression level (must be 1-9)\\n\");\n\t\t\tif (*endptr)\n\t\t\t\tfailure(\"Extra characters after compression level: \\'%s\\'\\n\", endptr);\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tcontrol->ramsize = strtol(optarg, &endptr, 10) * 1024 * 1024 * 100;\n\t\t\tif (*endptr)\n\t\t\t\tfailure(\"Extra characters after ramsize: \\'%s\\'\\n\", endptr);\n\t\t\tbreak;\n\t\tcase 'N':\n\t\t\tnice_set = true;\n\t\t\tcontrol->nice_val = strtol(optarg, &endptr, 10);\n\t\t\tif (control->nice_val < PRIO_MIN || control->nice_val > PRIO_MAX)\n\t\t\t\tfailure(\"Invalid nice value (must be %d...%d)\\n\", PRIO_MIN, PRIO_MAX);\n\t\t\tif (*endptr)\n\t\t\t\tfailure(\"Extra characters after nice level: \\'%s\\'\\n\", endptr);\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tif (control->outdir)\n\t\t\t\tfailure(\"Cannot have -o and -O together\\n\");\n\t\t\tif (unlikely(STDOUT))\n\t\t\t\tfailure(\"Cannot specify an output filename when outputting to stdout\\n\");\n\t\t\tcontrol->outname = optarg;\n\t\t\tdealloc(control->suffix);\n\t\t\tcontrol->suffix = strdup(\"\");\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tif (control->outname)\t/* can't mix -o and -O */\n\t\t\t\tfailure(\"Cannot have options -o and -O together\\n\");\n\t\t\tif (unlikely(STDOUT))\n\t\t\t\tfailure(\"Cannot specify an output directory when outputting to stdout\\n\");\n\t\t\tcontrol->outdir = malloc(strlen(optarg) + 2);\n\t\t\tif (control->outdir == NULL)\n\t\t\t\tfatal(\"Failed to allocate for outdir\\n\");\n\t\t\tstrcpy(control->outdir,optarg);\n\t\t\tif (strcmp(optarg+strlen(optarg) - 1, \"/\")) \t/* need a trailing slash */\n\t\t\t\tstrcat(control->outdir, \"/\");\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tcontrol->threads = strtol(optarg, &endptr, 10);\n\t\t\tif (control->threads < 1)\n\t\t\t\tfailure(\"Must have at least one thread\\n\");\n\t\t\tif (*endptr)\n\t\t\t\tfailure(\"Extra characters after number of threads: \\'%s\\'\\n\", endptr);\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tcontrol->flags |= FLAG_SHOW_PROGRESS;\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\tcontrol->flags &= ~FLAG_SHOW_PROGRESS;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\trecurse = true;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tif (control->outname)\n\t\t\t\tfailure(\"Specified output filename already, can't specify an extension.\\n\");\n\t\t\tif (unlikely(STDOUT))\n\t\t\t\tfailure(\"Cannot specify a filename suffix when outputting to stdout\\n\");\n\t\t\tdealloc(control->suffix);\n\t\t\tcontrol->suffix = strdup(optarg);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tif (control->outname)\n\t\t\t\tfailure(\"Cannot specify an output file name when just testing.\\n\");\n\t\t\tif (compat)\n\t\t\t\tcontrol->flags |= FLAG_KEEP_FILES;\n\t\t\tif (!KEEP_FILES)\n\t\t\t\tfailure(\"Doubt that you want to delete a file when just testing.\\n\");\n\t\t\tcontrol->flags |= FLAG_TEST_ONLY;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tcontrol->flags &= ~FLAG_THRESHOLD;\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\tcontrol->flags |= FLAG_UNLIMITED;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\t/* set verbosity flag */\n\t\t\tif (!(control->flags & FLAG_SHOW_PROGRESS))\n\t\t\t\tcontrol->flags |= FLAG_SHOW_PROGRESS;\n\t\t\telse if (!(control->flags & FLAG_VERBOSITY) && !(control->flags & FLAG_VERBOSITY_MAX))\n\t\t\t\tcontrol->flags |= FLAG_VERBOSITY;\n\t\t\telse if ((control->flags & FLAG_VERBOSITY)) {\n\t\t\t\tcontrol->flags &= ~FLAG_VERBOSITY;\n\t\t\t\tcontrol->flags |= FLAG_VERBOSITY_MAX;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tcontrol->msgout = stdout;\n\t\t\tprint_output(\"lrzip version %s\\n\", PACKAGE_VERSION);\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tcontrol->window = strtol(optarg, &endptr, 10);\n\t\t\tif (control->window < 1)\n\t\t\t\tfailure(\"Window must be positive\\n\");\n\t\t\tif (*endptr)\n\t\t\t\tfailure(\"Extra characters after window size: \\'%s\\'\\n\", endptr);\n\t\t\tbreak;\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '3':\n\t\tcase '4':\n\t\tcase '5':\n\t\tcase '6':\n\t\tcase '7':\n\t\tcase '8':\n\t\tcase '9':\n\t\t\tcontrol->compression_level = c - '0';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(compat);\n\t\t\treturn 2;\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tif (control->outname) {\n\t\tif (argc > 1)\n\t\t\tfailure(\"Cannot specify output filename with more than 1 file\\n\");\n\t\tif (recurse)\n\t\t\tfailure(\"Cannot specify output filename with recursive\\n\");\n\t}\n\n\tif (VERBOSE && !SHOW_PROGRESS) {\n\t\tprint_err(\"Cannot have -v and -q options. -v wins.\\n\");\n\t\tcontrol->flags |= FLAG_SHOW_PROGRESS;\n\t}\n\n\tif (UNLIMITED && control->window) {\n\t\tprint_err(\"If -U used, cannot specify a window size with -w.\\n\");\n\t\tcontrol->window = 0;\n\t}\n\n\tif (argc < 1)\n\t\tcontrol->flags |= FLAG_STDIN;\n\n\tif (UNLIMITED && STDIN) {\n\t\tprint_err(\"Cannot have -U and stdin, unlimited mode disabled.\\n\");\n\t\tcontrol->flags &= ~FLAG_UNLIMITED;\n\t}\n\n\tsetup_overhead(control);\n\n\t/* Set the main nice value to half that of the backend threads since\n\t * the rzip stage is usually the rate limiting step */\n\tcontrol->current_priority = getpriority(PRIO_PROCESS, 0);\n\tif (nice_set) {\n\t\tif (!NO_COMPRESS) {\n\t\t\t/* If niceness can't be set. just reset process priority */\n\t\t\tif (unlikely(setpriority(PRIO_PROCESS, 0, control->nice_val/2) == -1)) {\n\t\t\t\tprint_err(\"Warning, unable to set nice value %d...Resetting to %d\\n\",\n\t\t\t\t\tcontrol->nice_val, control->current_priority);\n\t\t\t\tsetpriority(PRIO_PROCESS, 0, (control->nice_val=control->current_priority));\n\t\t\t}\n\t\t} else {\n\t\t\tif (unlikely(setpriority(PRIO_PROCESS, 0, control->nice_val) == -1)) {\n\t\t\t\tprint_err(\"Warning, unable to set nice value %d...Resetting to %d\\n\",\n\t\t\t\t\tcontrol->nice_val, control->current_priority);\n\t\t\t\tsetpriority(PRIO_PROCESS, 0, (control->nice_val=control->current_priority));\n\t\t\t}\n\t\t}\n\t}\n\n\t/* One extra iteration for the case of no parameters means we will default to stdin/out */\n\tfor (i = 0; i <= argc; i++) {\n\t\tchar *dirlist = NULL, *infile = NULL;\n\t\tint direntries = 0, curentry = 0;\n\n\t\tif (i < argc)\n\t\t\tinfile = argv[i];\n\t\telse if (!(i == 0 && STDIN))\n\t\t\tbreak;\n\t\tif (infile) {\n\t\t\tif ((strcmp(infile, \"-\") == 0))\n\t\t\t\tcontrol->flags |= FLAG_STDIN;\n\t\t\telse {\n\t\t\t\tbool isdir = false;\n\t\t\t\tstruct stat istat;\n\n\t\t\t\tif (unlikely(stat(infile, &istat)))\n\t\t\t\t\tfailure(\"Failed to stat %s\\n\", infile);\n\t\t\t\tisdir = S_ISDIR(istat.st_mode);\n\t\t\t\tif (!recurse && (isdir || !S_ISREG(istat.st_mode))) {\n\t\t\t\t\tfailure(\"lrzip only works directly on regular FILES.\\n\"\n\t\t\t\t\t\"Use -r recursive, lrztar or pipe through tar for compressing directories.\\n\");\n\t\t\t\t}\n\t\t\t\tif (recurse && !isdir)\n\t\t\t\t\tfailure(\"%s not a directory, -r recursive needs a directory\\n\", infile);\n\t\t\t}\n\t\t}\n\n\t\tif (recurse) {\n\t\t\tif (unlikely(STDIN || STDOUT))\n\t\t\t\tfailure(\"Cannot use -r recursive with STDIO\\n\");\n\t\t\trecurse_dirlist(infile, &dirlist, &direntries);\n\t\t}\n\n\t\tif (INFO && STDIN)\n\t\t\tfailure(\"Will not get file info from STDIN\\n\");\nrecursion:\n\t\tif (recurse) {\n\t\t\tif (curentry >= direntries) {\n\t\t\t\tinfile = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tinfile = dirlist + MAX_PATH_LEN * curentry++;\n\t\t}\n\t\tcontrol->infile = infile;\n\n\t\t/* If no output filename is specified, and we're using\n\t\t * stdin, use stdout */\n\t\tif ((control->outname && (strcmp(control->outname, \"-\") == 0)) ||\n\t\t    (!control->outname && STDIN) || lrzcat)\n\t\t\t\tset_stdout(control);\n\n\t\tif (lrzcat) {\n\t\t\tcontrol->msgout = stderr;\n\t\t\tcontrol->outFILE = stdout;\n\t\t\tregister_outputfile(control, control->msgout);\n\t\t}\n\n\t\tif (!STDOUT) {\n\t\t\tcontrol->msgout = stdout;\n\t\t\tregister_outputfile(control, control->msgout);\n\t\t}\n\n\t\tif (STDIN)\n\t\t\tcontrol->inFILE = stdin;\n\n\t\t/* Implement signal handler only once flags are set */\n\t\tsigemptyset(&handler.sa_mask);\n\t\thandler.sa_flags = 0;\n\t\thandler.sa_handler = &sighandler;\n\t\tsigaction(SIGTERM, &handler, 0);\n\t\tsigaction(SIGINT, &handler, 0);\n\n\t\tif (!FORCE_REPLACE) {\n\t\t\tif (STDIN && isatty(fileno((FILE *)stdin))) {\n\t\t\t\tprint_err(\"Will not read stdin from a terminal. Use -f to override.\\n\");\n\t\t\t\tusage(compat);\n\t\t\t\texit (1);\n\t\t\t}\n\t\t\tif (!TEST_ONLY && STDOUT && isatty(fileno((FILE *)stdout)) && !compat) {\n\t\t\t\tprint_err(\"Will not write stdout to a terminal. Use -f to override.\\n\");\n\t\t\t\tusage(compat);\n\t\t\t\texit (1);\n\t\t\t}\n\t\t}\n\n\t\tif (CHECK_FILE) {\n\t\t\tif (!DECOMPRESS) {\n\t\t\t\tprint_err(\"Can only check file written on decompression.\\n\");\n\t\t\t\tcontrol->flags &= ~FLAG_CHECK;\n\t\t\t} else if (STDOUT) {\n\t\t\t\tprint_err(\"Can't check file written when writing to stdout. Checking disabled.\\n\");\n\t\t\t\tcontrol->flags &= ~FLAG_CHECK;\n\t\t\t}\n\t\t}\n\n\t\tsetup_ram(control);\n\t\tshow_summary();\n\n\t\tgettimeofday(&start_time, NULL);\n\n\t\tif (unlikely((STDIN || STDOUT) && ENCRYPT))\n\t\t\tfailure(\"Unable to work from STDIO while reading password\\n\");\n\n\t\tmemcpy(&local_control, &base_control, sizeof(rzip_control));\n\t\tif (DECOMPRESS || TEST_ONLY)\n\t\t\tdecompress_file(&local_control);\n\t\telse if (INFO)\n\t\t\tget_fileinfo(&local_control);\n\t\telse\n\t\t\tcompress_file(&local_control);\n\n\t\t/* compute total time */\n\t\tgettimeofday(&end_time, NULL);\n\t\ttotal_time = (end_time.tv_sec + (double)end_time.tv_usec / 1000000) -\n\t\t\t      (start_time.tv_sec + (double)start_time.tv_usec / 1000000);\n\t\thours = (int)total_time / 3600;\n\t\tminutes = (int)(total_time / 60) % 60;\n\t\tseconds = total_time - hours * 3600 - minutes * 60;\n\t\tif (!INFO)\n\t\t\tprint_progress(\"Total time: %02d:%02d:%05.2f\\n\", hours, minutes, seconds);\n\t\tif (recurse)\n\t\t\tgoto recursion;\n\t}\n\n\treturn 0;\n}", "target": 3, "idx": 11320}
{"commit_id": "3a7362750d5c372420aa8f0caf7bf5b5c3d0f52d", "project": "tensorflow", "func": "void DoNonMaxSuppressionOp(OpKernelContext* context, const Tensor& scores,\n                           int num_boxes, const Tensor& max_output_size,\n                           const T similarity_threshold,\n                           const T score_threshold, const T soft_nms_sigma,\n                           const std::function<float(int, int)>& similarity_fn,\n                           bool return_scores_tensor = false,\n                           bool pad_to_max_output_size = false,\n                           int* ptr_num_valid_outputs = nullptr) {\n  const int output_size = max_output_size.scalar<int>()();\n  OP_REQUIRES(context, output_size >= 0,\n              errors::InvalidArgument(\"output size must be non-negative\"));\n\n  std::vector<T> scores_data(num_boxes);\n  std::copy_n(scores.flat<T>().data(), num_boxes, scores_data.begin());\n\n  // Data structure for a selection candidate in NMS.\n  struct Candidate {\n    int box_index;\n    T score;\n    int suppress_begin_index;\n  };\n\n  auto cmp = [](const Candidate bs_i, const Candidate bs_j) {\n    return ((bs_i.score == bs_j.score) && (bs_i.box_index > bs_j.box_index)) ||\n           bs_i.score < bs_j.score;\n  };\n  std::priority_queue<Candidate, std::deque<Candidate>, decltype(cmp)>\n      candidate_priority_queue(cmp);\n  for (int i = 0; i < scores_data.size(); ++i) {\n    if (scores_data[i] > score_threshold) {\n      candidate_priority_queue.emplace(Candidate({i, scores_data[i], 0}));\n    }\n  }\n\n  T scale = static_cast<T>(0.0);\n  bool is_soft_nms = soft_nms_sigma > static_cast<T>(0.0);\n  if (is_soft_nms) {\n    scale = static_cast<T>(-0.5) / soft_nms_sigma;\n  }\n\n  auto suppress_weight = [similarity_threshold, scale,\n                          is_soft_nms](const T sim) {\n    const T weight = Eigen::numext::exp<T>(scale * sim * sim);\n    return is_soft_nms || sim <= similarity_threshold ? weight\n                                                      : static_cast<T>(0.0);\n  };\n\n  std::vector<int> selected;\n  std::vector<T> selected_scores;\n  float similarity;\n  T original_score;\n  Candidate next_candidate;\n\n  while (selected.size() < output_size && !candidate_priority_queue.empty()) {\n    next_candidate = candidate_priority_queue.top();\n    original_score = next_candidate.score;\n    candidate_priority_queue.pop();\n\n    // Overlapping boxes are likely to have similar scores, therefore we\n    // iterate through the previously selected boxes backwards in order to\n    // see if `next_candidate` should be suppressed. We also enforce a property\n    // that a candidate can be suppressed by another candidate no more than\n    // once via `suppress_begin_index` which tracks which previously selected\n    // boxes have already been compared against next_candidate prior to a given\n    // iteration.  These previous selected boxes are then skipped over in the\n    // following loop.\n    bool should_hard_suppress = false;\n    for (int j = static_cast<int>(selected.size()) - 1;\n         j >= next_candidate.suppress_begin_index; --j) {\n      similarity = similarity_fn(next_candidate.box_index, selected[j]);\n\n      next_candidate.score *= suppress_weight(static_cast<T>(similarity));\n\n      // First decide whether to perform hard suppression\n      if (!is_soft_nms && static_cast<T>(similarity) > similarity_threshold) {\n        should_hard_suppress = true;\n        break;\n      }\n\n      // If next_candidate survives hard suppression, apply soft suppression\n      if (next_candidate.score <= score_threshold) break;\n    }\n    // If `next_candidate.score` has not dropped below `score_threshold`\n    // by this point, then we know that we went through all of the previous\n    // selections and can safely update `suppress_begin_index` to\n    // `selected.size()`. If on the other hand `next_candidate.score`\n    // *has* dropped below the score threshold, then since `suppress_weight`\n    // always returns values in [0, 1], further suppression by items that were\n    // not covered in the above for loop would not have caused the algorithm\n    // to select this item. We thus do the same update to\n    // `suppress_begin_index`, but really, this element will not be added back\n    // into the priority queue in the following.\n    next_candidate.suppress_begin_index = selected.size();\n\n    if (!should_hard_suppress) {\n      if (next_candidate.score == original_score) {\n        // Suppression has not occurred, so select next_candidate\n        selected.push_back(next_candidate.box_index);\n        selected_scores.push_back(next_candidate.score);\n        continue;\n      }\n      if (next_candidate.score > score_threshold) {\n        // Soft suppression has occurred and current score is still greater than\n        // score_threshold; add next_candidate back onto priority queue.\n        candidate_priority_queue.push(next_candidate);\n      }\n    }\n  }\n\n  int num_valid_outputs = selected.size();\n  if (pad_to_max_output_size) {\n    selected.resize(output_size, 0);\n    selected_scores.resize(output_size, static_cast<T>(0));\n  }\n  if (ptr_num_valid_outputs) {\n    *ptr_num_valid_outputs = num_valid_outputs;\n  }\n\n  // Allocate output tensors\n  Tensor* output_indices = nullptr;\n  TensorShape output_shape({static_cast<int>(selected.size())});\n  OP_REQUIRES_OK(context,\n                 context->allocate_output(0, output_shape, &output_indices));\n  TTypes<int, 1>::Tensor output_indices_data = output_indices->tensor<int, 1>();\n  std::copy_n(selected.begin(), selected.size(), output_indices_data.data());\n\n  if (return_scores_tensor) {\n    Tensor* output_scores = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(1, output_shape, &output_scores));\n    typename TTypes<T, 1>::Tensor output_scores_data =\n        output_scores->tensor<T, 1>();\n    std::copy_n(selected_scores.begin(), selected_scores.size(),\n                output_scores_data.data());\n  }\n}", "target": 1, "idx": 11321}
{"commit_id": "fa8e98ba326749b66b09ee2195c05c872907a08f", "project": "swoole/swoole-src", "func": "static ssize_t http_build_trailer(http_context *ctx, swString *response) {\n    char *buf = SwooleTG.buffer_stack->str;\n    size_t l_buf = SwooleTG.buffer_stack->size;\n    int n;\n    ssize_t ret = 0;\n\n    zval *ztrailer =\n        sw_zend_read_property_ex(swoole_http_response_ce, ctx->response.zobject, SW_ZSTR_KNOWN(SW_ZEND_STR_TRAILER), 0);\n    uint32_t size = php_swoole_array_length_safe(ztrailer);\n\n    if (size > 0) {\n        const char *key;\n        uint32_t keylen;\n        int type;\n        zval *zvalue;\n\n        SW_HASHTABLE_FOREACH_START2(Z_ARRVAL_P(ztrailer), key, keylen, type, zvalue) {\n            if (UNEXPECTED(!key || ZVAL_IS_NULL(zvalue))) {\n                continue;\n            }\n\n            if (!ZVAL_IS_NULL(zvalue)) {\n                zend::String str_value(zvalue);\n                n = sw_snprintf(\n                    buf, l_buf, \"%.*s: %.*s\\r\\n\", (int) keylen, key, (int) str_value.len(), str_value.val());\n                swString_append_ptr(response, buf, n);\n                ret += n;\n            }\n        }\n        SW_HASHTABLE_FOREACH_END();\n        (void) type;\n        swString_append_ptr(response, ZEND_STRL(\"\\r\\n\"));\n    }\n\n    return ret;\n}", "target": 1, "idx": 11322}
{"commit_id": "b57b3967b1a42dd505dbe4fcf1e1d810e3ae3777", "project": "android", "func": "SampleTable::SampleTable(const sp<DataSource> &source)\n    : mDataSource(source),\n      mChunkOffsetOffset(-1),\n      mChunkOffsetType(0),\n      mNumChunkOffsets(0),\n      mSampleToChunkOffset(-1),\n      mNumSampleToChunkOffsets(0),\n      mSampleSizeOffset(-1),\n      mSampleSizeFieldSize(0),\n      mDefaultSampleSize(0),\n      mNumSampleSizes(0),\n      mHasTimeToSample(false),\n      mTimeToSampleCount(0),\n      mTimeToSample(),\n      mSampleTimeEntries(NULL),\n      mCompositionTimeDeltaEntries(NULL),\n      mNumCompositionTimeDeltaEntries(0),\n      mCompositionDeltaLookup(new CompositionDeltaLookup),\n      mSyncSampleOffset(-1),\n      mNumSyncSamples(0),\n      mSyncSamples(NULL),\n      mLastSyncSampleIndex(0),\n      mSampleToChunkEntries(NULL) {\n    mSampleIterator = new SampleIterator(this);\n}", "target": 1, "idx": 11323}
{"commit_id": "c784d551ad50864de1035ce54e72837301cf6aca", "project": "wireshark", "func": "static int\ndissect_thrift_type(tvbuff_t* tvb, packet_info* pinfo, proto_tree* tree,\n                    proto_item* pi, int type, int* offset, int length)\n{\n    switch (type){\n    case 2:\n        /*T_BOOL*/\n        proto_tree_add_item(tree, hf_thrift_bool, tvb, *offset, 1, ENC_BIG_ENDIAN);\n        *offset += 1;\n        break;\n    case 3:\n        /*T_BYTE , T_I08*/\n        proto_tree_add_item(tree, hf_thrift_byte, tvb, *offset, 1, ENC_BIG_ENDIAN);\n        *offset += 1;\n        break;\n    case 4:\n        /*T_DOUBLE*/\n        proto_tree_add_item(tree, hf_thrift_double, tvb, *offset, 8, ENC_BIG_ENDIAN);\n        *offset += 8;\n        break;\n    case 6:\n        /*T_I16 Integer 16*/\n        proto_tree_add_item(tree, hf_thrift_i16, tvb, *offset, 2, ENC_BIG_ENDIAN);\n        *offset += 2;\n        break;\n    case 8:\n        /*T_I32 Integer 32*/\n        proto_tree_add_item(tree, hf_thrift_i32, tvb, *offset, 4, ENC_BIG_ENDIAN);\n        *offset += 4;\n        break;\n    case 9:\n        /*T_U64 Integer 64*/\n        proto_tree_add_item(tree, hf_thrift_u64, tvb, *offset, 8, ENC_BIG_ENDIAN);\n        *offset += 8;\n        break;\n    case 10:\n        /*T_I64 Integer 64*/\n        proto_tree_add_item(tree, hf_thrift_i64, tvb, *offset, 8, ENC_BIG_ENDIAN);\n        *offset += 8;\n        break;\n    case 11:\n        /* T_UTF7 */\n        *offset = dissect_thrift_utf7(tvb, pinfo, tree, *offset, length);\n        break;\n    case 12:\n        /* T_STRUCT */\n        *offset = dissect_thrift_struct(tvb, pinfo, tree, *offset, length);\n        break;\n    case 13:\n        /* T_MAP */\n        *offset = dissect_thrift_map(tvb, pinfo, tree, *offset, length);\n        break;\n    case 15:\n        /* T_LIST */\n        *offset = dissect_thrift_list(tvb, pinfo, tree, *offset, length);\n        break;\n    default:\n        /* Bail out */\n        expert_add_info(pinfo, pi, &ei_thrift_wrong_type);\n        *offset = tvb_reported_length(tvb);\n        return -1;\n    }\n\n    return *offset;\n}", "target": 2, "idx": 11324}
{"commit_id": "6b4a7cde30f2e2cb03e78ef476cc73179cfffda3", "project": "knik0/faad2", "func": "static void calculate_gain(sbr_info *sbr, sbr_hfadj_info *adj, uint8_t ch)\n{\n    /* log2 values of limiter gains */\n    static real_t limGain[] = { -1.0, 0.0, 1.0, 33.219 };\n    uint8_t m, l, k;\n\n    uint8_t current_t_noise_band = 0;\n    uint8_t S_mapped;\n\n    ALIGN real_t Q_M_lim[MAX_M];\n    ALIGN real_t G_lim[MAX_M];\n    ALIGN real_t G_boost;\n    ALIGN real_t S_M[MAX_M];\n\n\n    for (l = 0; l < sbr->L_E[ch]; l++)\n    {\n        uint8_t current_f_noise_band = 0;\n        uint8_t current_res_band = 0;\n        uint8_t current_res_band2 = 0;\n        uint8_t current_hi_res_band = 0;\n\n        real_t delta = (l == sbr->l_A[ch] || l == sbr->prevEnvIsShort[ch]) ? 0 : 1;\n\n        S_mapped = get_S_mapped(sbr, ch, l, current_res_band2);\n\n        if (sbr->t_E[ch][l+1] > sbr->t_Q[ch][current_t_noise_band+1])\n        {\n            current_t_noise_band++;\n        }\n\n        for (k = 0; k < sbr->N_L[sbr->bs_limiter_bands]; k++)\n        {\n            real_t Q_M = 0;\n            real_t G_max;\n            real_t den = 0;\n            real_t acc1 = 0;\n            real_t acc2 = 0;\n            uint8_t current_res_band_size = 0;\n            uint8_t Q_M_size = 0;\n\n            uint8_t ml1, ml2;\n\n            /* bounds of current limiter bands */\n            ml1 = sbr->f_table_lim[sbr->bs_limiter_bands][k];\n            ml2 = sbr->f_table_lim[sbr->bs_limiter_bands][k+1];\n\n            if (ml1 > MAX_M)\n                ml1 = MAX_M;\n\n            if (ml2 > MAX_M)\n                ml2 = MAX_M;\n\n\n            /* calculate the accumulated E_orig and E_curr over the limiter band */\n            for (m = ml1; m < ml2; m++)\n            {\n                if ((m + sbr->kx) < sbr->f_table_res[sbr->f[ch][l]][current_res_band+1])\n                {\n                    current_res_band_size++;\n                } else {\n                    acc1 += QUANTISE2INT(pow2(-10 + log2_int_tab[current_res_band_size] + find_log2_E(sbr, current_res_band, l, ch)));\n\n                    current_res_band++;\n                    current_res_band_size = 1;\n                }\n\n                acc2 += QUANTISE2INT(sbr->E_curr[ch][m][l]/1024.0);\n            }\n            acc1 += QUANTISE2INT(pow2(-10 + log2_int_tab[current_res_band_size] + find_log2_E(sbr, current_res_band, l, ch)));\n\n            acc1 = QUANTISE2REAL( log2(EPS + acc1) );\n\n\n            /* calculate the maximum gain */\n            /* ratio of the energy of the original signal and the energy\n             * of the HF generated signal\n             */\n            G_max = acc1 - QUANTISE2REAL(log2(EPS + acc2)) + QUANTISE2REAL(limGain[sbr->bs_limiter_gains]);\n            G_max = min(G_max, QUANTISE2REAL(limGain[3]));\n\n\n            for (m = ml1; m < ml2; m++)\n            {\n                real_t G;\n                real_t E_curr, E_orig;\n                real_t Q_orig, Q_orig_plus1;\n                uint8_t S_index_mapped;\n\n\n                /* check if m is on a noise band border */\n                if ((m + sbr->kx) == sbr->f_table_noise[current_f_noise_band+1])\n                {\n                    /* step to next noise band */\n                    current_f_noise_band++;\n                }\n\n\n                /* check if m is on a resolution band border */\n                if ((m + sbr->kx) == sbr->f_table_res[sbr->f[ch][l]][current_res_band2+1])\n                {\n                    /* accumulate a whole range of equal Q_Ms */\n                    if (Q_M_size > 0)\n                        den += QUANTISE2INT(pow2(log2_int_tab[Q_M_size] + Q_M));\n                    Q_M_size = 0;\n\n                    /* step to next resolution band */\n                    current_res_band2++;\n\n                    /* if we move to a new resolution band, we should check if we are\n                     * going to add a sinusoid in this band\n                     */\n                    S_mapped = get_S_mapped(sbr, ch, l, current_res_band2);\n                }\n\n\n                /* check if m is on a HI_RES band border */\n                if ((m + sbr->kx) == sbr->f_table_res[HI_RES][current_hi_res_band+1])\n                {\n                    /* step to next HI_RES band */\n                    current_hi_res_band++;\n                }\n\n\n                /* find S_index_mapped\n                 * S_index_mapped can only be 1 for the m in the middle of the\n                 * current HI_RES band\n                 */\n                S_index_mapped = 0;\n                if ((l >= sbr->l_A[ch]) ||\n                    (sbr->bs_add_harmonic_prev[ch][current_hi_res_band] && sbr->bs_add_harmonic_flag_prev[ch]))\n                {\n                    /* find the middle subband of the HI_RES frequency band */\n                    if ((m + sbr->kx) == (sbr->f_table_res[HI_RES][current_hi_res_band+1] + sbr->f_table_res[HI_RES][current_hi_res_band]) >> 1)\n                        S_index_mapped = sbr->bs_add_harmonic[ch][current_hi_res_band];\n                }\n\n\n                /* find bitstream parameters */\n                if (sbr->E_curr[ch][m][l] == 0)\n                    E_curr = LOG2_MIN_INF;\n                else\n                    E_curr = -10 + log2(sbr->E_curr[ch][m][l]);\n                E_orig = -10 + find_log2_E(sbr, current_res_band2, l, ch);\n\n                Q_orig = find_log2_Q(sbr, current_f_noise_band, current_t_noise_band, ch);\n                Q_orig_plus1 = find_log2_Qplus1(sbr, current_f_noise_band, current_t_noise_band, ch);\n\n\n                /* Q_M only depends on E_orig and Q_div2:\n                 * since N_Q <= N_Low <= N_High we only need to recalculate Q_M on\n                 * a change of current res band (HI or LO)\n                 */\n                Q_M = E_orig + Q_orig - Q_orig_plus1;\n\n\n                /* S_M only depends on E_orig, Q_div and S_index_mapped:\n                 * S_index_mapped can only be non-zero once per HI_RES band\n                 */\n                if (S_index_mapped == 0)\n                {\n                    S_M[m] = LOG2_MIN_INF; /* -inf */\n                } else {\n                    S_M[m] = E_orig - Q_orig_plus1;\n\n                    /* accumulate sinusoid part of the total energy */\n                    den += pow2(S_M[m]);\n                }\n\n\n                /* calculate gain */\n                /* ratio of the energy of the original signal and the energy\n                 * of the HF generated signal\n                 */\n                /* E_curr here is officially E_curr+1 so the log2() of that can never be < 0 */\n                /* scaled by -10 */\n                G = E_orig - max(-10, E_curr);\n                if ((S_mapped == 0) && (delta == 1))\n                {\n                    /* G = G * 1/(1+Q) */\n                    G -= Q_orig_plus1;\n                } else if (S_mapped == 1) {\n                    /* G = G * Q/(1+Q) */\n                    G += Q_orig - Q_orig_plus1;\n                }\n\n\n                /* limit the additional noise energy level */\n                /* and apply the limiter */\n                if (G_max > G)\n                {\n                    Q_M_lim[m] = QUANTISE2REAL(Q_M);\n                    G_lim[m] = QUANTISE2REAL(G);\n\n                    if ((S_index_mapped == 0) && (l != sbr->l_A[ch]))\n                    {\n                        Q_M_size++;\n                    }\n                } else {\n                    /* G > G_max */\n                    Q_M_lim[m] = QUANTISE2REAL(Q_M) + G_max - QUANTISE2REAL(G);\n                    G_lim[m] = G_max;\n\n                    /* accumulate limited Q_M */\n                    if ((S_index_mapped == 0) && (l != sbr->l_A[ch]))\n                    {\n                        den += QUANTISE2INT(pow2(Q_M_lim[m]));\n                    }\n                }\n\n\n                /* accumulate the total energy */\n                /* E_curr changes for every m so we do need to accumulate every m */\n                den += QUANTISE2INT(pow2(E_curr + G_lim[m]));\n            }\n\n            /* accumulate last range of equal Q_Ms */\n            if (Q_M_size > 0)\n            {\n                den += QUANTISE2INT(pow2(log2_int_tab[Q_M_size] + Q_M));\n            }\n\n\n            /* calculate the final gain */\n            /* G_boost: [0..2.51188643] */\n            G_boost = acc1 - QUANTISE2REAL(log2(den + EPS));\n            G_boost = min(G_boost, QUANTISE2REAL(1.328771237) /* log2(1.584893192 ^ 2) */);\n\n\n            for (m = ml1; m < ml2; m++)\n            {\n                /* apply compensation to gain, noise floor sf's and sinusoid levels */\n#ifndef SBR_LOW_POWER\n                adj->G_lim_boost[l][m] = QUANTISE2REAL(pow2((G_lim[m] + G_boost) / 2.0));\n#else\n                /* sqrt() will be done after the aliasing reduction to save a\n                 * few multiplies\n                 */\n                adj->G_lim_boost[l][m] = QUANTISE2REAL(pow2(G_lim[m] + G_boost));\n#endif\n                adj->Q_M_lim_boost[l][m] = QUANTISE2REAL(pow2((Q_M_lim[m] + 10 + G_boost) / 2.0));\n\n                if (S_M[m] != LOG2_MIN_INF)\n                {\n                    adj->S_M_boost[l][m] = QUANTISE2REAL(pow2((S_M[m] + 10 + G_boost) / 2.0));\n                } else {\n                    adj->S_M_boost[l][m] = 0;\n                }\n            }\n        }\n    }\n}", "target": 1, "idx": 11325}
{"commit_id": "cb4ef0b09200c720dfdb07e097092dd105450343", "project": "envoyproxy/envoy", "func": "void BrotliDecompressorImpl::decompress(const Buffer::Instance& input_buffer,\n                                        Buffer::Instance& output_buffer) {\n  Common::BrotliContext ctx(chunk_size_, MaxInflateRatio * input_buffer.length());\n\n  for (const Buffer::RawSlice& input_slice : input_buffer.getRawSlices()) {\n    ctx.avail_in_ = input_slice.len_;\n    ctx.next_in_ = static_cast<uint8_t*>(input_slice.mem_);\n\n    while (ctx.avail_in_ > 0) {\n      if (!process(ctx, output_buffer)) {\n        ctx.finalizeOutput(output_buffer);\n        return;\n      }\n    }\n  }\n\n  // Even though the input has been fully consumed by the decoder it still can\n  // be unfolded into output not fitting the output chunk. Thus keep processing\n  // until the decoder's output is fully depleted.\n  bool success;\n  do {\n    success = process(ctx, output_buffer);\n  } while (success && BrotliDecoderHasMoreOutput(state_.get()));\n\n  ctx.finalizeOutput(output_buffer);\n}", "target": 2, "idx": 11326}
{"commit_id": "b3dd69b23e9338806891c708a0cc8a82c0d1872a", "project": "ImageMagick", "func": "static Image *ExtractPostscript(Image *image,const ImageInfo *image_info,\n  MagickOffsetType PS_Offset,ssize_t PS_Size,ExceptionInfo *exception)\n{\n  char\n    postscript_file[MagickPathExtent];\n\n  const MagicInfo\n    *magic_info;    \n\n  FILE\n    *ps_file;\n\n  ImageInfo\n    *clone_info;\n    \n  Image\n    *image2;\n    \n  unsigned char\n    magick[2*MagickPathExtent];    \n    \n\n  if ((clone_info=CloneImageInfo(image_info)) == NULL)\n    return(image);\n  clone_info->blob=(void *) NULL;\n  clone_info->length=0;\n\n  /* Obtain temporary file */\n  (void) AcquireUniqueFilename(postscript_file);\n  ps_file=fopen_utf8(postscript_file,\"wb\");\n  if (ps_file == (FILE *) NULL)\n    goto FINISH;\n\n  /* Copy postscript to temporary file */\n  (void) SeekBlob(image,PS_Offset,SEEK_SET);\n  (void) ReadBlob(image, 2*MagickPathExtent, magick);\n  \n  (void) SeekBlob(image,PS_Offset,SEEK_SET);\n  while(PS_Size-- > 0)\n    {\n      (void) fputc(ReadBlobByte(image),ps_file);\n    }\n  (void) fclose(ps_file);\n  \n    /* Detect file format - Check magic.mgk configuration file. */\n  magic_info=GetMagicInfo(magick,2*MagickPathExtent,exception);\n  if(magic_info == (const MagicInfo *) NULL) goto FINISH_UNL;\n  /*     printf(\"Detected:%s  \\n\",magic_info->name); */\n  if(exception->severity != UndefinedException) goto FINISH_UNL;     \n  if(magic_info->name == (char *) NULL) goto FINISH_UNL;\n    \n  (void) strncpy(clone_info->magick,magic_info->name,MagickPathExtent);\n  \n    /* Read nested image */\n  /*FormatString(clone_info->filename,\"%s:%s\",magic_info->name,postscript_file);*/\n  FormatLocaleString(clone_info->filename,MagickPathExtent,\"%s\",postscript_file);\n  image2=ReadImage(clone_info,exception);\n\n  if (!image2)\n    goto FINISH_UNL;\n\n  /*\n    Replace current image with new image while copying base image\n    attributes.\n  */\n  (void) CopyMagickMemory(image2->filename,image->filename,MagickPathExtent);\n  (void) CopyMagickMemory(image2->magick_filename,image->magick_filename,MagickPathExtent);\n  (void) CopyMagickMemory(image2->magick,image->magick,MagickPathExtent);\n  image2->depth=image->depth;\n  DestroyBlob(image2);\n  image2->blob=ReferenceBlob(image->blob);\n\n  if ((image->rows == 0) || (image->columns == 0))\n    DeleteImageFromList(&image);\n\n  AppendImageToList(&image,image2);\n\n FINISH_UNL:    \n  (void) RelinquishUniqueFileResource(postscript_file);\n FINISH:\n  DestroyImageInfo(clone_info);\n  return(image);\n}", "target": 1, "idx": 11327}
{"commit_id": "889dfaeda28271225262480fd2d7791c0b1450d3", "project": "MonetDB", "func": "str\nOPTemptybindImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)\n{\n\tint i,j, actions =0, extras= 0;\n\tint *empty = NULL;\n\tint limit = mb->stop, slimit = mb->ssize;\n\tInstrPtr p, q, *old = NULL, *updated = NULL;\n\tstr sch,tbl;\n\tint etop= 0, esize= 256;\n\tstr msg = MAL_SUCCEED;\n\n\t(void) stk;\n\t(void) cntxt;\n\n\t// use an instruction reference table to keep\n\n\tfor( i=0; i< mb->stop; i++) {\n\t\tp = getInstrPtr(mb,i);\n\t\tif( getModuleId(p) == sqlRef && (getFunctionId(p) == emptybindRef || getFunctionId(p) == emptybindidxRef))\n\t\t\textras += p->argc;\n\t}\n\tif (extras == 0){\n\t\tgoto wrapup;\n\t}\n\n\t// track of where 'emptybind' results are produced\n\t// reserve space for maximal number of emptybat variables created\n\tempty = (int *) GDKzalloc((mb->vsize + extras) * sizeof(int));\n\tif ( empty == NULL)\n\t\tthrow(MAL,\"optimizer.emptybind\", SQLSTATE(HY013) MAL_MALLOC_FAIL);\n\n\tupdated= (InstrPtr *) GDKzalloc(esize * sizeof(InstrPtr));\n\tif( updated == 0){\n\t\tGDKfree(empty);\n\t\tthrow(MAL,\"optimizer.emptybind\", SQLSTATE(HY013) MAL_MALLOC_FAIL);\n\t}\n\n\told = mb->stmt;\n\tif (newMalBlkStmt(mb, mb->ssize) < 0) {\n\t\tGDKfree(empty);\n\t\tGDKfree(updated);\n\t\tthrow(MAL,\"optimizer.emptybind\", SQLSTATE(HY013) MAL_MALLOC_FAIL);\n\t}\n\n\t/* Symbolic evaluation of instructions with empty BAT variables */\n\tactions = 0;\n\tfor (i = 0; i < limit; i++) {\n\t\tp = old[i];\n\n\t\tpushInstruction(mb,p);\n\t\tif (p->token == ENDsymbol){\n\t\t\tfor(i++; i<limit; i++)\n\t\t\t\tif (old[i])\n\t\t\t\t\tpushInstruction(mb,old[i]);\n\t\t\tbreak;\n\t\t}\n\n \t\t/*\n \t\t * The bulk of the intelligence lies in inspecting calling\n \t\t * sequences to filter and replace results\n \t\t */\n\t\tif ( getModuleId(p) == batRef && getFunctionId(p) == newRef){\n\t\t\tempty[getArg(p,0)] = i;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// any of these instructions leave a non-empty BAT behind\n\t\tif(p && getModuleId(p) == sqlRef && isUpdateInstruction(p)){\n\t\t\tif ( etop == esize){\n\t\t\t\tInstrPtr *tmp = updated;\n\t\t\t\tupdated = (InstrPtr*) GDKrealloc( updated, (esize += 256) * sizeof(InstrPtr));\n\t\t\t\tif( updated == NULL){\n\t\t\t\t\tGDKfree(tmp);\n\t\t\t\t\tGDKfree(empty);\n\t\t\t\t\tgoto wrapup;\n\t\t\t\t}\n\t\t\t}\n\t\t\tupdated[etop++]= p;\n\t\t}\n\n\t\t/* restore the naming, dropping the runtime property 'empty'\n\t\t * Keep the bind operation, because it is cheap, rather focus on their re-use\n\t\t */\n\n\t\tif (getFunctionId(p) == emptybindRef) {\n\t\t\tsetFunctionId(p,bindRef);\n\t\t\tp->typechk= TYPE_UNKNOWN;\n\t\t\tempty[getArg(p,0)] = i;\n\t\t\tif( p->retc == 2){\n\t\t\t\tempty[getArg(p,1)] = i;\n\t\t\t}\n\t\t\t// replace the call into a empty bat creation unless the table was updated already in the same query\n\t\t\tsch = getVarConstant(mb,getArg(p,2  + (p->retc==2))).val.sval;\n\t\t\ttbl = getVarConstant(mb,getArg(p,3  + (p->retc==2))).val.sval;\n\t\t\tfor(j= 0; j< etop; j++){\n\t\t\t\tq= updated[j];\n\t\t\t\tif(q && getModuleId(q) == sqlRef && isUpdateInstruction(q)){\n\t\t\t\t\tint c = getFunctionId(q) == claimRef;  /* claim has 2 results */\n\t\t\t\t\tint cl = getFunctionId(q) == clear_tableRef; /* clear table has no mvc dependency */\n\t\t\t\t\tif ( strcmp(getVarConstant(mb,getArg(q,2-cl+c)).val.sval, sch) == 0 &&\n\t\t\t\t\t\t strcmp(getVarConstant(mb,getArg(q,3-cl+c)).val.sval, tbl) == 0 ){\n\t\t\t\t\t\tempty[getArg(p,0)] = 0;\n\t\t\t\t\t\tif( p->retc == 2){\n\t\t\t\t\t\t\tempty[getArg(p,1)] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(q && getModuleId(q) == sqlcatalogRef){\n\t\t\t\t\tif ( strcmp(getVarConstant(mb,getArg(q,2)).val.sval, sch) == 0 ){\n\t\t\t\t\t\tempty[getArg(p,0)] = 0;\n\t\t\t\t\t\tif( p->retc == 2){\n\t\t\t\t\t\t\tempty[getArg(p,1)] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (getFunctionId(p) == emptybindidxRef) {\n\t\t\tsetFunctionId(p,bindidxRef);\n\t\t\tp->typechk= TYPE_UNKNOWN;\n\t\t\tempty[getArg(p,0)] = i;\n\t\t\tif( p->retc == 2){\n\t\t\t\tempty[getArg(p,1)] = i;\n\t\t\t}\n\t\t\t// replace the call into a empty bat creation unless the table was updated already in the same query\n\t\t\tsch = getVarConstant(mb,getArg(p,2  + (p->retc==2))).val.sval;\n\t\t\ttbl = getVarConstant(mb,getArg(p,3  + (p->retc==2))).val.sval;\n\t\t\tfor(j= 0; j< etop; j++){\n\t\t\t\tq= updated[j];\n\t\t\t\tif(q && getModuleId(q) == sqlRef && (getFunctionId(q) == appendRef || getFunctionId(q) == updateRef )){\n\t\t\t\t\tif ( strcmp(getVarConstant(mb,getArg(q,2)).val.sval, sch) == 0 &&\n\t\t\t\t\t\t strcmp(getVarConstant(mb,getArg(q,3)).val.sval, tbl) == 0 ){\n\t\t\t\t\t\tempty[getArg(p,0)] = 0;\n\t\t\t\t\t\tif( p->retc == 2){\n\t\t\t\t\t\t\tempty[getArg(p,1)] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(q && getModuleId(q) == sqlcatalogRef){\n\t\t\t\t\tif ( strcmp(getVarConstant(mb,getArg(q,2)).val.sval, sch) == 0 ){\n\t\t\t\t\t\tempty[getArg(p,0)] = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t// delta operations without updates can be replaced by an assignment\n\t\tif (getModuleId(p)== sqlRef && getFunctionId(p) == deltaRef && p->argc == 4){\n\t\t\tif (empty[getArg(p,2)] && empty[getArg(p,3)]){\n\t\t\t\tactions++;\n\t\t\t\tclrFunction(p);\n\t\t\t\tp->argc = 2;\n\t\t\t\tif (empty[getArg(p,1)]){\n\t\t\t\t\tempty[getArg(p,0)] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (getModuleId(p)== sqlRef && getFunctionId(p) == projectdeltaRef) {\n\t\t\tif( empty[getArg(p,3)] && empty[getArg(p,4)] ){\n\t\t\t\tactions++;\n\t\t\t\tsetModuleId(p,algebraRef);\n\t\t\t\tsetFunctionId(p,projectionRef);\n\t\t\t\tp->argc = 3;\n\t\t\t\tp->typechk= TYPE_UNKNOWN;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (getModuleId(p)== algebraRef && getFunctionId(p) == projectionRef) {\n\t\t\tif( empty[getArg(p,1)] || empty[getArg(p,2)] ){\n\t\t\t\tactions++;\n\t\t\t\temptyresult(0);\n\t\t\t}\n\t\t}\n\t\tif ((getModuleId(p)== algebraRef || getModuleId(p) == dictRef) && (getFunctionId(p) == thetaselectRef || getFunctionId(p) == selectRef)) {\n\t\t\tif( empty[getArg(p,1)] || empty[getArg(p,2)] ){\n\t\t\t\tactions++;\n\t\t\t\temptyresult(0);\n\t\t\t}\n\t\t}\n\t\tif (getModuleId(p) == forRef && getFunctionId(p) == decompressRef){\n\t\t\tif (empty[getArg(p,1)]){\n\t\t\t\tactions++;\n\t\t\t\temptyresult(0);\n\t\t\t}\n\t\t}\n\t\tif (getModuleId(p) == dictRef){\n\t\t\tif (getFunctionId(p) == decompressRef && (empty[getArg(p,1)] || empty[getArg(p,2)])){\n\t\t\t\tactions++;\n\t\t\t\temptyresult(0);\n\t\t\t}\n\t\t\tif (getFunctionId(p) == compressRef && empty[getArg(p,2)]){\n\t\t\t\tactions++;\n\t\t\t\temptyresult(0);\n\t\t\t}\n\t\t}\n\t\tif (getModuleId(p) == batmkeyRef || getModuleId(p) == batstrRef || getModuleId(p) == batmtimeRef ||\n\t\t\tgetModuleId(p) == batmmathRef || getModuleId(p) == batcalcRef || (getModuleId(p) == algebraRef && getFunctionId(p) == projectionpathRef)) {\n\t\t\tfor (int j = p->retc; j < p->argc; j++) {\n\t\t\t\tif( empty[getArg(p,j)]){\n\t\t\t\t\tactions++;\n\t\t\t\t\temptyresult(0);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (getModuleId(p)== batRef && isUpdateInstruction(p)){\n\t\t\tif( empty[getArg(p,1)] && empty[getArg(p,2)]){\n\t\t\t\temptyresult(0);\n\t\t\t} else if (empty[getArg(p,2)]){\n\t\t\t\tactions++;\n\t\t\t\tclrFunction(p);\n\t\t\t\tp->argc = 2;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(; i<slimit; i++)\n\t\tif (old[i])\n\t\t\tpushInstruction(mb, old[i]);\n\tGDKfree(old);\n\tGDKfree(empty);\n\tGDKfree(updated);\n\t/* Defense line against incorrect plans */\n\tmsg = chkTypes(cntxt->usermodule, mb, FALSE);\n\tif (!msg)\n\t\tmsg = chkFlow(mb);\n\tif (!msg)\n\t\tmsg = chkDeclarations(mb);\n\t/* keep all actions taken as a post block comment */\nwrapup:\n\t/* keep actions taken as a fake argument*/\n\t(void) pushInt(mb, pci, actions);\n\treturn msg;\n}", "target": 2, "idx": 11328}
{"commit_id": "d9da580b46a28ab497de2e94fdc7b9ff953dab17", "project": "xorg/lib/libXv", "func": "int\nXvQueryAdaptors(\n    Display *dpy,\n    Window window,\n    unsigned int *p_nAdaptors,\n    XvAdaptorInfo **p_pAdaptors)\n{\n    XExtDisplayInfo *info = xv_find_display(dpy);\n    xvQueryAdaptorsReq *req;\n    xvQueryAdaptorsReply rep;\n    size_t size;\n    unsigned int ii, jj;\n    char *name;\n    char *end;\n    XvAdaptorInfo *pas = NULL, *pa;\n    XvFormat *pfs, *pf;\n    char *buffer = NULL;\n    union {\n        char *buffer;\n        char *string;\n        xvAdaptorInfo *pa;\n        xvFormat *pf;\n    } u;\n    int status;\n\n    XvCheckExtension(dpy, info, XvBadExtension);\n\n    LockDisplay(dpy);\n\n    XvGetReq(QueryAdaptors, req);\n    req->window = window;\n\n    /* READ THE REPLY */\n\n    if (_XReply(dpy, (xReply *) &rep, 0, xFalse) == 0) {\n        rep.num_adaptors = 0;\n        status = XvBadReply;\n        goto out;\n    }\n\n    size = rep.length << 2;\n    if (size > 0) {\n        if ((buffer = Xmalloc(size)) == NULL) {\n            _XEatDataWords(dpy, rep.length);\n            status = XvBadAlloc;\n            goto out;\n        }\n        _XRead(dpy, buffer, (long) size);\n    }\n\n    /* GET INPUT ADAPTORS */\n\n    if (rep.num_adaptors == 0) {\n        /* If there are no adaptors, there's nothing more to do. */\n        status = Success;\n        goto out;\n    }\n\n    u.buffer = buffer;\n    end = buffer + size;\n\n    size = rep.num_adaptors * sizeof(XvAdaptorInfo);\n    if ((pas = Xmalloc(size)) == NULL) {\n        status = XvBadAlloc;\n        goto out;\n    }\n\n    /* INIT ADAPTOR FIELDS */\n\n    pa = pas;\n    for (ii = 0; ii < rep.num_adaptors; ii++) {\n        pa->num_adaptors = 0;\n        pa->name = (char *) NULL;\n        pa->formats = (XvFormat *) NULL;\n        pa++;\n    }\n\n    pa = pas;\n    for (ii = 0; ii < rep.num_adaptors; ii++) {\n        if (u.buffer + sz_xvAdaptorInfo > end) {\n            status = XvBadReply;\n            goto out;\n        }\n        pa->type = u.pa->type;\n        pa->base_id = u.pa->base_id;\n        pa->num_ports = u.pa->num_ports;\n        pa->num_formats = u.pa->num_formats;\n        pa->num_adaptors = rep.num_adaptors - ii;\n\n        /* GET ADAPTOR NAME */\n\n        size = u.pa->name_size;\n        u.buffer += pad_to_int32(sz_xvAdaptorInfo);\n\n        if (u.buffer + size > end) {\n            status = XvBadReply;\n            goto out;\n        }\n        if ((name = Xmalloc(size + 1)) == NULL) {\n            status = XvBadAlloc;\n            goto out;\n        }\n        (void) strncpy(name, u.string, size);\n        name[size] = '\\0';\n        pa->name = name;\n\n        u.buffer += pad_to_int32(size);\n\n        /* GET FORMATS */\n\n        size = pa->num_formats * sizeof(XvFormat);\n        if ((pfs = Xmalloc(size)) == NULL) {\n            status = XvBadAlloc;\n            goto out;\n        }\n\n        pf = pfs;\n        for (jj = 0; jj < pa->num_formats; jj++) {\n            if (u.buffer + sz_xvFormat > end) {\n                Xfree(pfs);\n                status = XvBadReply;\n                goto out;\n            }\n            pf->depth = u.pf->depth;\n            pf->visual_id = u.pf->visual;\n            pf++;\n\n            u.buffer += pad_to_int32(sz_xvFormat);\n        }\n\n        pa->formats = pfs;\n\n        pa++;\n\n    }\n\n    status = Success;\n\n  out:\n    if (status != Success) {\n        XvFreeAdaptorInfo(pas);\n        pas = NULL;\n    }\n\n    *p_nAdaptors = rep.num_adaptors;\n    *p_pAdaptors = pas;\n\n    Xfree(buffer);\n    UnlockDisplay(dpy);\n    SyncHandle();\n\n    return status;\n}", "target": 3, "idx": 11329}
{"commit_id": "b90cd6f2b905905fb42671009dc0e27c310a16ae", "project": "torvalds/linux", "func": "static void smp_task_timedout(struct timer_list *t)\n{\n\tstruct sas_task_slow *slow = from_timer(slow, t, timer);\n\tstruct sas_task *task = slow->task;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&task->task_state_lock, flags);\n\tif (!(task->task_state_flags & SAS_TASK_STATE_DONE)) {\n\t\ttask->task_state_flags |= SAS_TASK_STATE_ABORTED;\n\t\tcomplete(&task->slow_task->completion);\n\t}\n\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n}", "target": 2, "idx": 11330}
{"commit_id": "bb11d07139efe0f5e4ce0e4afda32abdbe82fa9d", "project": "ImageMagick", "func": "static Image *ReadCAPTIONImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    *caption,\n    geometry[MaxTextExtent],\n    *property,\n    *text;\n\n  const char\n    *gravity,\n    *option;\n\n  DrawInfo\n    *draw_info;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    split,\n    status;\n\n  register ssize_t\n    i;\n\n  size_t\n    height,\n    width;\n\n  TypeMetric\n    metrics;\n\n  /*\n    Initialize Image structure.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  (void) ResetImagePage(image,\"0x0+0+0\");\n  /*\n    Format caption.\n  */\n  option=GetImageOption(image_info,\"filename\");\n  if (option == (const char *) NULL)\n    property=InterpretImageProperties(image_info,image,image_info->filename);\n  else\n    if (LocaleNCompare(option,\"caption:\",8) == 0)\n      property=InterpretImageProperties(image_info,image,option+8);\n    else\n      property=InterpretImageProperties(image_info,image,option);\n  (void) SetImageProperty(image,\"caption\",property);\n  property=DestroyString(property);\n  caption=ConstantString(GetImageProperty(image,\"caption\"));\n  draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);\n  (void) CloneString(&draw_info->text,caption);\n  gravity=GetImageOption(image_info,\"gravity\");\n  if (gravity != (char *) NULL)\n    draw_info->gravity=(GravityType) ParseCommandOption(MagickGravityOptions,\n      MagickFalse,gravity);\n  split=MagickFalse;\n  status=MagickTrue;\n  if (image->columns == 0)\n    {\n      text=AcquireString(caption);\n      i=FormatMagickCaption(image,draw_info,split,&metrics,&text);\n      (void) CloneString(&draw_info->text,text);\n      text=DestroyString(text);\n      (void) FormatLocaleString(geometry,MaxTextExtent,\"%+g%+g\",\n        -metrics.bounds.x1,metrics.ascent);\n      if (draw_info->gravity == UndefinedGravity)\n        (void) CloneString(&draw_info->geometry,geometry);\n      status=GetMultilineTypeMetrics(image,draw_info,&metrics);\n      width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);\n      image->columns=width;\n    }\n  if (image->rows == 0)\n    {\n      split=MagickTrue;\n      text=AcquireString(caption);\n      i=FormatMagickCaption(image,draw_info,split,&metrics,&text);\n      (void) CloneString(&draw_info->text,text);\n      text=DestroyString(text);\n      (void) FormatLocaleString(geometry,MaxTextExtent,\"%+g%+g\",\n        -metrics.bounds.x1,metrics.ascent);\n      if (draw_info->gravity == UndefinedGravity)\n        (void) CloneString(&draw_info->geometry,geometry);\n      status=GetMultilineTypeMetrics(image,draw_info,&metrics);\n      image->rows=(size_t) ((i+1)*(metrics.ascent-metrics.descent+\n        draw_info->interline_spacing+draw_info->stroke_width)+0.5);\n    }\n  if (status != MagickFalse)\n    status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    { \n      draw_info=DestroyDrawInfo(draw_info);\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  if (SetImageBackgroundColor(image) == MagickFalse)\n    {\n      draw_info=DestroyDrawInfo(draw_info);\n      InheritException(exception,&image->exception);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if ((fabs(image_info->pointsize) < MagickEpsilon) && (strlen(caption) > 0))\n    {\n      double\n        high,\n        low;\n\n      ssize_t\n        n;\n\n      /*\n        Auto fit text into bounding box.\n      */\n      for (n=0; n < 32; n++, draw_info->pointsize*=2.0)\n      {\n        text=AcquireString(caption);\n        i=FormatMagickCaption(image,draw_info,split,&metrics,&text);\n        (void) CloneString(&draw_info->text,text);\n        text=DestroyString(text);\n        (void) FormatLocaleString(geometry,MaxTextExtent,\"%+g%+g\",\n          -metrics.bounds.x1,metrics.ascent);\n        if (draw_info->gravity == UndefinedGravity)\n          (void) CloneString(&draw_info->geometry,geometry);\n        status=GetMultilineTypeMetrics(image,draw_info,&metrics);\n        (void) status;\n        width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);\n        height=(size_t) floor(metrics.height+draw_info->stroke_width+0.5);\n        if ((image->columns != 0) && (image->rows != 0))\n          {\n            if ((width >= image->columns) && (height >= image->rows))\n              break;\n          }\n        else\n          if (((image->columns != 0) && (width >= image->columns)) ||\n              ((image->rows != 0) && (height >= image->rows)))\n            break;\n      }\n      high=draw_info->pointsize;\n      for (low=1.0; (high-low) > 0.5; )\n      {\n        draw_info->pointsize=(low+high)/2.0;\n        text=AcquireString(caption);\n        i=FormatMagickCaption(image,draw_info,split,&metrics,&text);\n        (void) CloneString(&draw_info->text,text);\n        text=DestroyString(text);\n        (void) FormatLocaleString(geometry,MaxTextExtent,\"%+g%+g\",\n          -metrics.bounds.x1,metrics.ascent);\n        if (draw_info->gravity == UndefinedGravity)\n          (void) CloneString(&draw_info->geometry,geometry);\n        (void) GetMultilineTypeMetrics(image,draw_info,&metrics);\n        width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);\n        height=(size_t) floor(metrics.height+draw_info->stroke_width+0.5);\n        if ((image->columns != 0) && (image->rows != 0))\n          {\n            if ((width < image->columns) && (height < image->rows))\n              low=draw_info->pointsize+0.5;\n            else\n              high=draw_info->pointsize-0.5;\n          }\n        else\n          if (((image->columns != 0) && (width < image->columns)) ||\n              ((image->rows != 0) && (height < image->rows)))\n            low=draw_info->pointsize+0.5;\n          else\n            high=draw_info->pointsize-0.5;\n      }\n      draw_info->pointsize=floor((low+high)/2.0-0.5);\n    }\n  /*\n    Draw caption.\n  */\n  i=FormatMagickCaption(image,draw_info,split,&metrics,&caption);\n  (void) CloneString(&draw_info->text,caption);\n  (void) FormatLocaleString(geometry,MaxTextExtent,\"%+g%+g\",MagickMax(\n    draw_info->direction == RightToLeftDirection ? image->columns-\n    metrics.bounds.x2 : -metrics.bounds.x1,0.0),draw_info->gravity ==\n    UndefinedGravity ? metrics.ascent : 0.0);\n  (void) CloneString(&draw_info->geometry,geometry);\n  status=AnnotateImage(image,draw_info);\n  if (image_info->pointsize == 0.0)\n    { \n      char\n        pointsize[MaxTextExtent];\n      \n      (void) FormatLocaleString(pointsize,MaxTextExtent,\"%.20g\",\n        draw_info->pointsize);\n      (void) SetImageProperty(image,\"caption:pointsize\",pointsize);\n    }\n  draw_info=DestroyDrawInfo(draw_info);\n  caption=DestroyString(caption);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  return(GetFirstImageInList(image));\n}", "target": 1, "idx": 11331}
{"commit_id": "35cd5ba367515ffbd274ca529c5e946447f4ba48", "project": "xen-project/xen", "func": "static int nvmx_handle_invvpid(struct cpu_user_regs *regs)\n{\n    struct vmx_inst_decoded decode;\n    unsigned long vpid;\n    int ret;\n\n    if ( (ret = decode_vmx_inst(regs, &decode, &vpid, 0)) != X86EMUL_OKAY )\n        return ret;\n\n    switch ( reg_read(regs, decode.reg2) )\n    {\n    /* Just invalidate all tlb entries for all types! */\n    case INVVPID_INDIVIDUAL_ADDR:\n    case INVVPID_SINGLE_CONTEXT:\n    case INVVPID_ALL_CONTEXT:\n        hvm_asid_flush_vcpu_asid(&vcpu_nestedhvm(current).nv_n2asid);\n        break;\n    default:\n        vmfail_invalid(regs);\n        return X86EMUL_OKAY;\n    }\n\n    vmsucceed(regs);\n    return X86EMUL_OKAY;\n}", "target": 2, "idx": 11332}
{"commit_id": "a4ae828ee416a66d8c7bf5ee71d653c2cc6a26dd", "project": "python/cpython", "func": "static int\nPyMemoTable_Set(PyMemoTable *self, PyObject *key, Py_ssize_t value)\n{\n    PyMemoEntry *entry;\n\n    assert(key != NULL);\n\n    entry = _PyMemoTable_Lookup(self, key);\n    if (entry->me_key != NULL) {\n        entry->me_value = value;\n        return 0;\n    }\n    Py_INCREF(key);\n    entry->me_key = key;\n    entry->me_value = value;\n    self->mt_used++;\n\n    /* If we added a key, we can safely resize. Otherwise just return!\n     * If used >= 2/3 size, adjust size. Normally, this quaduples the size.\n     *\n     * Quadrupling the size improves average table sparseness\n     * (reducing collisions) at the cost of some memory. It also halves\n     * the number of expensive resize operations in a growing memo table.\n     *\n     * Very large memo tables (over 50K items) use doubling instead.\n     * This may help applications with severe memory constraints.\n     */\n    if (SIZE_MAX / 3 >= self->mt_used && self->mt_used * 3 < self->mt_allocated * 2) {\n        return 0;\n    }\n    // self->mt_used is always < PY_SSIZE_T_MAX, so this can't overflow.\n    size_t desired_size = (self->mt_used > 50000 ? 2 : 4) * self->mt_used;\n    return _PyMemoTable_ResizeTable(self, desired_size);\n}", "target": 2, "idx": 11333}
{"commit_id": "90279abdfcd235172eab99651043051188938dcc", "project": "upx", "func": "int PackLinuxElf32::canUnpack()\n{\n    if (checkEhdr(&ehdri)) {\n        return false;\n    }\n    // FIXME: ET_DYN same as 64-bit canUnpack ??\n    if (Elf32_Ehdr::ET_DYN==get_te16(&ehdri.e_type)) {\n        PackLinuxElf32help1(fi);\n    }\n    if (super::canUnpack()) {\n        return true;\n    }\n    return false;\n}", "target": 2, "idx": 11334}
{"commit_id": "c0569cc04741cccf6548c2169fcc1609d958523f", "project": "chromium", "func": "TabsCustomBindings::TabsCustomBindings(ScriptContext* context)\n    : ObjectBackedNativeHandler(context) {\n  RouteFunction(\"OpenChannelToTab\", \"tabs\",\n                base::Bind(&TabsCustomBindings::OpenChannelToTab,\n                           base::Unretained(this)));\n}", "target": 2, "idx": 11335}
{"commit_id": "7873f8334c8d31031f8cfa83bd97ac6029309e4f", "project": "sudo-project/sudo", "func": "static int\nrunas_userlist_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct member_list *user_list, struct member **matching_user)\n{\n    const struct sudoers_context *ctx = parse_tree->ctx;\n    const char *lhost = parse_tree->lhost ? parse_tree->lhost : ctx->runas.host;\n    const char *shost = parse_tree->shost ? parse_tree->shost : ctx->runas.shost;\n    int user_matched = UNSPEC;\n    struct member *m;\n    struct alias *a;\n    debug_decl(runas_userlist_matches, SUDOERS_DEBUG_MATCH);\n\n    TAILQ_FOREACH_REVERSE(m, user_list, member_list, entries) {\n\tswitch (m->type) {\n\t    case ALL:\n\t\tuser_matched = m->negated ? DENY : ALLOW;\n\t\tbreak;\n\t    case NETGROUP:\n\t\tif (netgr_matches(parse_tree->nss, m->name,\n\t\t    def_netgroup_tuple ? lhost : NULL,\n\t\t    def_netgroup_tuple ? shost : NULL,\n\t\t    ctx->runas.pw->pw_name))\n\t\t    user_matched = m->negated ? DENY : ALLOW;\n\t\tbreak;\n\t    case USERGROUP:\n\t\tif (usergr_matches(m->name, ctx->runas.pw->pw_name, ctx->runas.pw))\n\t\t    user_matched = m->negated ? DENY : ALLOW;\n\t\tbreak;\n\t    case ALIAS:\n\t\ta = alias_get(parse_tree, m->name, RUNASALIAS);\n\t\tif (a != NULL) {\n\t\t    const int rc = runas_userlist_matches(parse_tree,\n\t\t\t&a->members, matching_user);\n\t\t    if (SPECIFIED(rc)) {\n\t\t\tif (m->negated) {\n\t\t\t    user_matched = rc == ALLOW ? DENY : ALLOW;\n\t\t\t} else {\n\t\t\t    user_matched = rc;\n\t\t\t}\n\t\t    }\n\t\t    alias_put(a);\n\t\t    break;\n\t\t}\n\t\tFALLTHROUGH;\n\t    case WORD:\n\t\tif (userpw_matches(m->name, ctx->runas.pw->pw_name, ctx->runas.pw))\n\t\t    user_matched = m->negated ? DENY : ALLOW;\n\t\tbreak;\n\t    case MYSELF:\n\t\t/*\n\t\t * Only match a rule with an empty runas user if a group\n\t\t * was specified on the command line without a user _or_\n\t\t * the user specified their own name on the command line.\n\t\t */\n\t\tif ((!ISSET(ctx->settings.flags, RUNAS_USER_SPECIFIED) &&\n\t\t\tISSET(ctx->settings.flags, RUNAS_GROUP_SPECIFIED)) ||\n\t\t\tstrcmp(ctx->user.name, ctx->runas.pw->pw_name) == 0)\n\t\t    user_matched = m->negated ? DENY : ALLOW;\n\t\tbreak;\n\t}\n\tif (SPECIFIED(user_matched)) {\n\t    if (matching_user != NULL && m->type != ALIAS)\n\t\t*matching_user = m;\n\t    break;\n\t}\n    }\n    debug_return_int(user_matched);\n}", "target": 2, "idx": 11336}
{"commit_id": "ef9c79ae81b00a63aa8638076ec81dc9482972e9", "project": "wireshark", "func": "static gint\ndissect_data_element(proto_tree *tree, proto_tree **next_tree,\n        packet_info *pinfo, tvbuff_t *tvb, gint offset)\n{\n    proto_item  *pitem;\n    proto_tree  *ptree;\n    gint        new_offset;\n    gint        length;\n    gint        len;\n    guint8      type;\n    guint8      size;\n\n    new_offset = get_type_length(tvb, offset, &length) - 1;\n    type = tvb_get_guint8(tvb, offset);\n    size = type & 0x07;\n    type = type >> 3;\n\n    pitem = proto_tree_add_none_format(tree, hf_data_element, tvb, offset, 0, \"Data Element: %s %s\",\n            val_to_str_const(type, vs_data_element_type, \"Unknown Type\"),\n            val_to_str_const(size, vs_data_element_size, \"Unknown Size\"));\n    ptree = proto_item_add_subtree(pitem, ett_btsdp_data_element);\n\n    len = (new_offset - offset) + length;\n\n    proto_item_set_len(pitem, len + 1);\n\n    proto_tree_add_item(ptree, hf_data_element_type, tvb, offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_item(ptree, hf_data_element_size, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset += 1;\n\n    if (new_offset > offset - 1) {\n        proto_tree_add_uint(ptree, hf_data_element_var_size, tvb,\n                offset, len - length, length);\n        proto_item_append_text(pitem, (length != 1) ? \" %u bytes\" : \" %u byte\", length);\n        offset += len - length;\n    }\n\n    pitem = proto_tree_add_item(ptree, hf_data_element_value, tvb, offset, length, ENC_NA);\n    if (length > tvb_reported_length_remaining(tvb, offset)) {\n        expert_add_info(pinfo, pitem, &ei_data_element_value_large);\n        proto_item_append_text(pitem, \": MISSING\");\n    } else if (length == 0)\n        proto_item_append_text(pitem, \": MISSING\");\n\n    if (next_tree) *next_tree = proto_item_add_subtree(pitem, ett_btsdp_data_element_value);\n    offset += length;\n\n    return offset;\n}", "target": 2, "idx": 11337}
{"commit_id": "6068b0fa8310bced874b322b20ac470472c64784", "project": "dinhvh/libetpan", "func": "int mailpop3_stls(mailpop3 * f)\n{\n  char command[POP3_STRING_SIZE];\n  int r;\n  char * response;\n\n  snprintf(command, POP3_STRING_SIZE, \"STLS\\r\\n\");\n  r = send_command(f, command);\n  if (r == -1)\n    return MAILPOP3_ERROR_STREAM;\n\n  response = read_line(f);\n  if (response == NULL)\n    return MAILPOP3_ERROR_STREAM;\n  r = parse_response(f, response);\n\n  if (r != RESPONSE_OK)\n    return MAILPOP3_ERROR_STLS_NOT_SUPPORTED;\n\n  // Detect if the server send extra data after the STLS response.\n  // This *may* be a \"response injection attack\".\n  if (f->pop3_stream->read_buffer_len != 0) {\n    // Since it is also protocol violation, exit.\n    // There is no error type for STARTTLS errors in POP3\n    return MAILPOP3_ERROR_SSL;\n  }\n  \n  return MAILPOP3_NO_ERROR;\n}", "target": 2, "idx": 11338}
{"commit_id": "5d069dbe8aaf2a197142558b6fb2978189ba3454", "project": "torvalds/linux", "func": "static int fuse_xattr_get(const struct xattr_handler *handler,\n\t\t\t struct dentry *dentry, struct inode *inode,\n\t\t\t const char *name, void *value, size_t size)\n{\n\tif (fuse_is_bad(inode))\n\t\treturn -EIO;\n\n\treturn fuse_getxattr(inode, name, value, size);\n}", "target": 1, "idx": 11339}
{"commit_id": "35a9a00afcb20897d462a766793ff45534810dc3", "project": "vim", "func": "static void\nnv_replace(cmdarg_T *cap)\n{\n    char_u\t*ptr;\n    int\t\thad_ctrl_v;\n    long\tn;\n\n    if (checkclearop(cap->oap))\n\treturn;\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf) && !prompt_curpos_editable())\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n#endif\n\n    // get another character\n    if (cap->nchar == Ctrl_V)\n    {\n\thad_ctrl_v = Ctrl_V;\n\tcap->nchar = get_literal(FALSE);\n\t// Don't redo a multibyte character with CTRL-V.\n\tif (cap->nchar > DEL)\n\t    had_ctrl_v = NUL;\n    }\n    else\n\thad_ctrl_v = NUL;\n\n    // Abort if the character is a special key.\n    if (IS_SPECIAL(cap->nchar))\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    // Visual mode \"r\"\n    if (VIsual_active)\n    {\n\tif (got_int)\n\t    reset_VIsual();\n\tif (had_ctrl_v)\n\t{\n\t    // Use a special (negative) number to make a difference between a\n\t    // literal CR or NL and a line break.\n\t    if (cap->nchar == CAR)\n\t\tcap->nchar = REPLACE_CR_NCHAR;\n\t    else if (cap->nchar == NL)\n\t\tcap->nchar = REPLACE_NL_NCHAR;\n\t}\n\tnv_operator(cap);\n\treturn;\n    }\n\n    // Break tabs, etc.\n    if (virtual_active())\n    {\n\tif (u_save_cursor() == FAIL)\n\t    return;\n\tif (gchar_cursor() == NUL)\n\t{\n\t    // Add extra space and put the cursor on the first one.\n\t    coladvance_force((colnr_T)(getviscol() + cap->count1));\n\t    curwin->w_cursor.col -= cap->count1;\n\t}\n\telse if (gchar_cursor() == TAB)\n\t    coladvance_force(getviscol());\n    }\n\n    // Abort if not enough characters to replace.\n    ptr = ml_get_cursor();\n    if (STRLEN(ptr) < (unsigned)cap->count1\n\t    || (has_mbyte && mb_charlen(ptr) < cap->count1))\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    /*\n     * Replacing with a TAB is done by edit() when it is complicated because\n     * 'expandtab' or 'smarttab' is set.  CTRL-V TAB inserts a literal TAB.\n     * Other characters are done below to avoid problems with things like\n     * CTRL-V 048 (for edit() this would be R CTRL-V 0 ESC).\n     */\n    if (had_ctrl_v != Ctrl_V && cap->nchar == '\\t' && (curbuf->b_p_et || p_sta))\n    {\n\tstuffnumReadbuff(cap->count1);\n\tstuffcharReadbuff('R');\n\tstuffcharReadbuff('\\t');\n\tstuffcharReadbuff(ESC);\n\treturn;\n    }\n\n    // save line for undo\n    if (u_save_cursor() == FAIL)\n\treturn;\n\n    if (had_ctrl_v != Ctrl_V && (cap->nchar == '\\r' || cap->nchar == '\\n'))\n    {\n\t/*\n\t * Replace character(s) by a single newline.\n\t * Strange vi behaviour: Only one newline is inserted.\n\t * Delete the characters here.\n\t * Insert the newline with an insert command, takes care of\n\t * autoindent.\tThe insert command depends on being on the last\n\t * character of a line or not.\n\t */\n\t(void)del_chars(cap->count1, FALSE);\t// delete the characters\n\tstuffcharReadbuff('\\r');\n\tstuffcharReadbuff(ESC);\n\n\t// Give 'r' to edit(), to get the redo command right.\n\tinvoke_edit(cap, TRUE, 'r', FALSE);\n    }\n    else\n    {\n\tprep_redo(cap->oap->regname, cap->count1,\n\t\t\t\t       NUL, 'r', NUL, had_ctrl_v, cap->nchar);\n\n\tcurbuf->b_op_start = curwin->w_cursor;\n\tif (has_mbyte)\n\t{\n\t    int\t\told_State = State;\n\n\t    if (cap->ncharC1 != 0)\n\t\tAppendCharToRedobuff(cap->ncharC1);\n\t    if (cap->ncharC2 != 0)\n\t\tAppendCharToRedobuff(cap->ncharC2);\n\n\t    // This is slow, but it handles replacing a single-byte with a\n\t    // multi-byte and the other way around.  Also handles adding\n\t    // composing characters for utf-8.\n\t    for (n = cap->count1; n > 0; --n)\n\t    {\n\t\tState = REPLACE;\n\t\tif (cap->nchar == Ctrl_E || cap->nchar == Ctrl_Y)\n\t\t{\n\t\t    int c = ins_copychar(curwin->w_cursor.lnum\n\t\t\t\t\t   + (cap->nchar == Ctrl_Y ? -1 : 1));\n\t\t    if (c != NUL)\n\t\t\tins_char(c);\n\t\t    else\n\t\t\t// will be decremented further down\n\t\t\t++curwin->w_cursor.col;\n\t\t}\n\t\telse\n\t\t    ins_char(cap->nchar);\n\t\tState = old_State;\n\t\tif (cap->ncharC1 != 0)\n\t\t    ins_char(cap->ncharC1);\n\t\tif (cap->ncharC2 != 0)\n\t\t    ins_char(cap->ncharC2);\n\t    }\n\t}\n\telse\n\t{\n\t    /*\n\t     * Replace the characters within one line.\n\t     */\n\t    for (n = cap->count1; n > 0; --n)\n\t    {\n\t\t/*\n\t\t * Get ptr again, because u_save and/or showmatch() will have\n\t\t * released the line.  This may also happen in ins_copychar().\n\t\t * At the same time we let know that the line will be changed.\n\t\t */\n\t\tif (cap->nchar == Ctrl_E || cap->nchar == Ctrl_Y)\n\t\t{\n\t\t  int c = ins_copychar(curwin->w_cursor.lnum\n\t\t\t\t\t   + (cap->nchar == Ctrl_Y ? -1 : 1));\n\n\t\t  ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE);\n\t\t  if (c != NUL)\n\t\t    ptr[curwin->w_cursor.col] = c;\n\t\t}\n\t\telse\n\t\t{\n\t\t    ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE);\n\t\t    ptr[curwin->w_cursor.col] = cap->nchar;\n\t\t}\n\t\tif (p_sm && msg_silent == 0)\n\t\t    showmatch(cap->nchar);\n\t\t++curwin->w_cursor.col;\n\t    }\n#ifdef FEAT_NETBEANS_INTG\n\t    if (netbeans_active())\n\t    {\n\t\tcolnr_T  start = (colnr_T)(curwin->w_cursor.col - cap->count1);\n\n\t\tnetbeans_removed(curbuf, curwin->w_cursor.lnum, start,\n\t\t\t\t\t\t\t   (long)cap->count1);\n\t\tnetbeans_inserted(curbuf, curwin->w_cursor.lnum, start,\n\t\t\t\t\t       &ptr[start], (int)cap->count1);\n\t    }\n#endif\n\n\t    // mark the buffer as changed and prepare for displaying\n\t    changed_bytes(curwin->w_cursor.lnum,\n\t\t\t       (colnr_T)(curwin->w_cursor.col - cap->count1));\n\t}\n\t--curwin->w_cursor.col;\t    // cursor on the last replaced char\n\t// if the character on the left of the current cursor is a multi-byte\n\t// character, move two characters left\n\tif (has_mbyte)\n\t    mb_adjust_cursor();\n\tcurbuf->b_op_end = curwin->w_cursor;\n\tcurwin->w_set_curswant = TRUE;\n\tset_last_insert(cap->nchar);\n    }\n}", "target": 2, "idx": 11340}
{"commit_id": "a4997ed2499c4de8c95e2de9e2a07b60384fbbec", "project": "openlink/virtuoso-opensource", "func": "void\nsqlo_fun_ref_epilogue (sqlo_t * so, op_table_t * from_ot)\n{\n  int all_cols_p = 0;\n  dk_set_t having_preds = NULL;\n  df_elt_t * group_dfe = from_ot->ot_group_dfe;\n  ST * texp = from_ot->ot_dt->_.select_stmt.table_exp;\n  ST ** group = texp ? texp->_.table_exp.group_by : NULL;\n\n  if (from_ot->ot_invariant_preds && !from_ot->ot_invariant_placed)\n    {\n      df_elt_t * gen_pt = so->so_gen_pt;\n      df_elt_t * filter = sqlo_new_dfe (so, DFE_FILTER, NULL);\n      df_elt_t ** after_test;\n      filter->_.filter.invariant_of_ot = from_ot;\n      from_ot->ot_invariant_placed = 1;\n      so->so_gen_pt = from_ot->ot_work_dfe->_.sub.first;\n      after_test = sqlo_and_list_body (so, LOC_LOCAL, so->so_gen_pt, from_ot->ot_invariant_preds);\n      filter->_.filter.body = after_test;\n      filter->_.filter.preds = from_ot->ot_invariant_preds;\n      sqlo_place_dfe_after  (so, LOC_LOCAL, so->so_gen_pt, filter);\n      so->so_gen_pt = gen_pt;\n    }\n\n  if (!from_ot->ot_fun_refs && !group_dfe)\n    {\n      int is_dist = sqlo_early_distinct (so, from_ot);\n      if (sqlo_is_seq_in_oby_order  (so, from_ot->ot_work_dfe->_.sub.first, NULL))\n\treturn;\n      if (!from_ot->ot_oby_dfe || from_ot->ot_oby_dfe->dfe_is_placed)\n\treturn;\n      if (is_dist)\n\tso->so_place_code_forr_cond = 1;\n      sqlo_place_oby_specs (so, from_ot, from_ot->ot_oby_dfe->_.setp.specs);\n      so->so_place_code_forr_cond = 0;\n      sqlo_place_dfe_after (so, from_ot->ot_work_dfe->dfe_locus, so->so_gen_pt, from_ot->ot_oby_dfe);\n      return;\n    }\n  if (group_dfe)\n    {\n    group_dfe->dfe_locus = from_ot->ot_work_dfe->dfe_locus; /* if dt passed through then group too */\n      group_dfe->_.setp.is_being_placed = 1;\n    }\n  if (group)\n    {\n      int inx;\n      all_cols_p = sqlo_oby_exp_cols (so, from_ot->ot_dt, group);\n      sqlo_place_oby_specs (so, from_ot, group);\n      _DO_BOX (inx, texp->_.table_exp.group_by_full)\n\t{\n\t  sqlo_place_oby_specs (so, from_ot, texp->_.table_exp.group_by_full[inx]);\n\t}\n      END_DO_BOX;\n    }\n  if (from_ot->ot_group_dfe)\n    sqlo_place_dfe_after (so, from_ot->ot_work_dfe->dfe_locus,\n\t\t\t  from_ot->ot_work_dfe->_.sub.last, from_ot->ot_group_dfe);\n  DO_SET (ST *, fref, &from_ot->ot_fun_refs)\n    {\n      df_elt_t * fref_dfe = sqlo_df (so, fref);\n      df_elt_t * arg_dfe = NULL;\n      int locus_to_loclocal = 0;\n      if (AMMSC_USER != fref->_.fn_ref.fn_code)\n\targ_dfe = sqlo_df (so, fref->_.fn_ref.fn_arg);\n/*      if (group_dfe->_.setp.specs\n\t  && fref->_.fn_ref.all_distinct\n\t  && !IS_BOX_POINTER (from_ot->ot_work_dfe->dfe_locus))\n\tsqlc_new_error (so->so_sc->sc_cc, \"37000\", \"SQ111\", \"Distinct not allowed with an aggregate with group by.\");\n*/\n      fref_dfe->dfe_locus = from_ot->ot_work_dfe->dfe_locus;\n      if (AMMSC_USER == fref->_.fn_ref.fn_code)\n\t{\n\t  int argidx;\n\t  DO_BOX_FAST (ST *, arg, argidx, fref->_.fn_ref.fn_arglist)\n\t    {\n\t      df_elt_t * arg_dfe = sqlo_df (so, arg);\n\t      sqlo_place_exp (so, from_ot->ot_work_dfe, arg_dfe);\n\t      if (DFE_CONST != arg_dfe->dfe_type && arg_dfe->dfe_locus != from_ot->ot_work_dfe->dfe_locus)\n\t\tlocus_to_loclocal = 1;\n\t    }\n\t  END_DO_BOX_FAST;\n\t}\n      else\n\t{\n\t  if (IS_BOX_POINTER (from_ot->ot_work_dfe->dfe_locus) &&\n\t      AMMSC_COUNTSUM == fref->_.fn_ref.fn_code &&\n\t      ST_P (fref->_.fn_ref.fn_arg, SEARCHED_CASE))\n\t    {\n\t      ST *stree = fref->_.fn_ref.fn_arg;\n\t      if ((4 == BOX_ELEMENTS (stree->_.comma_exp.exps)) &&\n\t\t  ST_P (stree->_.comma_exp.exps [0], BOP_NULL) &&\n\t\t  ST_P (stree->_.comma_exp.exps [2], QUOTE) &&\n\t\t  (0 == unbox ((box_t) stree->_.comma_exp.exps [1])) &&\n\t\t  (1 == unbox ((box_t) stree->_.comma_exp.exps [3])))\n\t\t{\n\t\t  sqlo_place_exp (so, from_ot->ot_work_dfe,\n\t\t      sqlo_df (so, stree->_.comma_exp.exps [0]->_.bin_exp.left));\n\t\t  arg_dfe->dfe_locus = from_ot->ot_work_dfe->dfe_locus;\n\t\t}\n\t      else\n\t\tsqlo_place_exp (so, from_ot->ot_work_dfe, arg_dfe);\n\t    }\n\t  else\n            {\n              char prev = so->so_place_code_forr_cond;\n              if (DFE_VALUE_SUBQ == from_ot->ot_work_dfe->dfe_type && !group) /* simple fref */\n                so->so_place_code_forr_cond = 0;\n              sqlo_place_exp (so, from_ot->ot_work_dfe, arg_dfe);\n              so->so_place_code_forr_cond = prev;\n            }\n\t  if (fref->_.fn_ref.fn_code == AMMSC_COUNT || fref->_.fn_ref.fn_code == AMMSC_COUNTSUM)\n\t    fref_dfe->dfe_sqt.sqt_dtp = DV_LONG_INT;\n\t  else\n\t    fref_dfe->dfe_sqt = arg_dfe->dfe_sqt;\n\t  if (DFE_CONST != arg_dfe->dfe_type && arg_dfe->dfe_locus != from_ot->ot_work_dfe->dfe_locus)\n\t    locus_to_loclocal = 1;\n\t}\n      if (arg_dfe)\n\tsqlg_find_aggregate_sqt (wi_inst.wi_schema, &(arg_dfe->dfe_sqt), fref, &(fref_dfe->dfe_sqt));\n      if (locus_to_loclocal)\n\t{\n\t  fref_dfe->dfe_locus = LOC_LOCAL;\n\t  group_dfe->dfe_locus = LOC_LOCAL;\n\t}\n      t_set_push (&group_dfe->_.setp.fun_refs, fref);\n    }\n  END_DO_SET();\n  if (group_dfe)\n    group_dfe->_.setp.is_being_placed = 0;\n\n  /* all the predicates not done so far are from the HAVING clause, even if not mentioned in the texp since they could hav been added to the ot from an enclosing context */\n  so->so_gen_pt = from_ot->ot_group_dfe;\n  DO_SET (df_elt_t *, pred, &from_ot->ot_preds)\n    {\n      if (!pred->dfe_is_placed)\n\tt_set_push (&having_preds, (void*) pred);\n    }\n  END_DO_SET();\n  if (having_preds)\n    {\n      df_elt_t * filter;\n      df_elt_t ** after_test = sqlo_and_list_body (so,\n\t\t\t\t\t\t   from_ot->ot_work_dfe ? from_ot->ot_work_dfe->dfe_locus : LOC_LOCAL,\n\t\t\t\t\t\t   from_ot->ot_group_dfe, having_preds);\n      if (enable_dfe_filter)\n\t{\n\t  filter = sqlo_new_dfe (so, DFE_FILTER, NULL);\n\t  filter->_.filter.body = after_test;\n\t  filter->_.filter.preds = having_preds;\n\t  sqlo_place_dfe_after  (so, group_dfe->dfe_locus, so->so_gen_pt,  filter);\n\t}\n      else\n\t{\n\t  group_dfe->_.setp.after_test = after_test;\n\t  group_dfe->_.setp.having_preds = having_preds;\n\t}\n    }\n  if (group_dfe && all_cols_p)\n    group_dfe->_.setp.is_linear = sqlo_is_group_linear (so, from_ot);\n  if (from_ot->ot_oby_dfe)\n    {\n      sqlo_place_oby_specs (so, from_ot, from_ot->ot_oby_dfe->_.setp.specs);\n      if (!from_ot->ot_oby_dfe->dfe_is_placed)\n\tsqlo_place_dfe_after (so, from_ot->ot_work_dfe->dfe_locus,\n\t    so->so_gen_pt->dfe_type == DFE_DT ? so->so_gen_pt->_.sub.last : so->so_gen_pt, from_ot->ot_oby_dfe);\n    }\n}", "target": 2, "idx": 11341}
{"commit_id": "6a3eb3360667170988f8a6477f6686242061488a", "project": "torvalds/linux", "func": "int\nSMB2_write(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t   unsigned int *nbytes, struct kvec *iov, int n_vec)\n{\n\tstruct smb_rqst rqst;\n\tint rc = 0;\n\tstruct smb2_write_req *req = NULL;\n\tstruct smb2_write_rsp *rsp = NULL;\n\tint resp_buftype;\n\tstruct kvec rsp_iov;\n\tint flags = 0;\n\tunsigned int total_len;\n\n\t*nbytes = 0;\n\n\tif (n_vec < 1)\n\t\treturn rc;\n\n\trc = smb2_plain_req_init(SMB2_WRITE, io_parms->tcon, (void **) &req,\n\t\t\t     &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\tif (io_parms->tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\tif (smb3_encryption_required(io_parms->tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\treq->sync_hdr.ProcessId = cpu_to_le32(io_parms->pid);\n\n\treq->PersistentFileId = io_parms->persistent_fid;\n\treq->VolatileFileId = io_parms->volatile_fid;\n\treq->WriteChannelInfoOffset = 0;\n\treq->WriteChannelInfoLength = 0;\n\treq->Channel = 0;\n\treq->Length = cpu_to_le32(io_parms->length);\n\treq->Offset = cpu_to_le64(io_parms->offset);\n\treq->DataOffset = cpu_to_le16(\n\t\t\t\toffsetof(struct smb2_write_req, Buffer));\n\treq->RemainingBytes = 0;\n\n\ttrace_smb3_write_enter(xid, io_parms->persistent_fid,\n\t\tio_parms->tcon->tid, io_parms->tcon->ses->Suid,\n\t\tio_parms->offset, io_parms->length);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 1 for Buffer */\n\tiov[0].iov_len = total_len - 1;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = n_vec + 1;\n\n\trc = cifs_send_recv(xid, io_parms->tcon->ses, &rqst,\n\t\t\t    &resp_buftype, flags, &rsp_iov);\n\trsp = (struct smb2_write_rsp *)rsp_iov.iov_base;\n\n\tif (rc) {\n\t\ttrace_smb3_write_err(xid, req->PersistentFileId,\n\t\t\t\t     io_parms->tcon->tid,\n\t\t\t\t     io_parms->tcon->ses->Suid,\n\t\t\t\t     io_parms->offset, io_parms->length, rc);\n\t\tcifs_stats_fail_inc(io_parms->tcon, SMB2_WRITE_HE);\n\t\tcifs_dbg(VFS, \"Send error in write = %d\\n\", rc);\n\t} else {\n\t\t*nbytes = le32_to_cpu(rsp->DataLength);\n\t\ttrace_smb3_write_done(xid, req->PersistentFileId,\n\t\t\t\t     io_parms->tcon->tid,\n\t\t\t\t     io_parms->tcon->ses->Suid,\n\t\t\t\t     io_parms->offset, *nbytes);\n\t}\n\n\tcifs_small_buf_release(req);\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}", "target": 0, "idx": 11342}
{"commit_id": "0a2d3e3644a7453b6513db2f9bc270f77943573f", "project": "Matroska-Org/libmatroska", "func": "filepos_t KaxInternalBlock::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  filepos_t Result;\n\n  FirstFrameLocation = input.getFilePointer(); // will be updated accordingly below\n\n  SetValueIsSet(false);\n\n  try {\n    if (ReadFully == SCOPE_ALL_DATA) {\n      Result = EbmlBinary::ReadData(input, ReadFully);\n      if (Result != GetSize())\n        throw SafeReadIOCallback::EndOfStreamX(GetSize() - Result);\n\n      binary *BufferStart = EbmlBinary::GetBuffer();\n\n      SafeReadIOCallback Mem(*this);\n      uint8 BlockHeadSize = 4;\n\n      // update internal values\n      TrackNumber = Mem.GetUInt8();\n      if ((TrackNumber & 0x80) == 0) {\n        // there is extra data\n        if ((TrackNumber & 0x40) == 0) {\n          // We don't support track numbers that large !\n          throw SafeReadIOCallback::EndOfStreamX(0);\n        }\n        TrackNumber = (TrackNumber & 0x3F) << 8;\n        TrackNumber += Mem.GetUInt8();\n        BlockHeadSize++;\n      } else {\n        TrackNumber &= 0x7F;\n      }\n\n      LocalTimecode = int16(Mem.GetUInt16BE());\n      bLocalTimecodeUsed = true;\n\n      uint8 Flags = Mem.GetUInt8();\n      if (EbmlId(*this) == EBML_ID(KaxSimpleBlock)) {\n        bIsKeyframe = (Flags & 0x80) != 0;\n        bIsDiscardable = (Flags & 0x01) != 0;\n      }\n      mInvisible = (Flags & 0x08) >> 3;\n      mLacing = LacingType((Flags & 0x06) >> 1);\n\n      // put all Frames in the list\n      if (mLacing == LACING_NONE) {\n        FirstFrameLocation += Mem.GetPosition();\n        DataBuffer * soloFrame = new DataBuffer(BufferStart + Mem.GetPosition(), GetSize() - BlockHeadSize);\n        myBuffers.push_back(soloFrame);\n        SizeList.resize(1);\n        SizeList[0] = GetSize() - BlockHeadSize;\n      } else {\n        // read the number of frames in the lace\n        uint32 LastBufferSize = GetSize() - BlockHeadSize - 1; // 1 for number of frame\n        uint8 FrameNum = Mem.GetUInt8(); // number of frames in the lace - 1\n        // read the list of frame sizes\n        uint8 Index;\n        int32 FrameSize;\n        uint32 SizeRead;\n        uint64 SizeUnknown;\n\n        SizeList.resize(FrameNum + 1);\n\n        switch (mLacing) {\n          case LACING_XIPH:\n            for (Index=0; Index<FrameNum; Index++) {\n              // get the size of the frame\n              FrameSize = 0;\n              uint8 Value;\n              do {\n                Value = Mem.GetUInt8();\n                FrameSize += Value;\n                LastBufferSize--;\n              } while (Value == 0xFF);\n              SizeList[Index] = FrameSize;\n              LastBufferSize -= FrameSize;\n            }\n            SizeList[Index] = LastBufferSize;\n            break;\n          case LACING_EBML:\n            SizeRead = LastBufferSize;\n            FrameSize = ReadCodedSizeValue(BufferStart + Mem.GetPosition(), SizeRead, SizeUnknown);\n            if (!FrameSize || (static_cast<uint32>(FrameSize + SizeRead) > LastBufferSize))\n              throw SafeReadIOCallback::EndOfStreamX(SizeRead);\n            SizeList[0] = FrameSize;\n            Mem.Skip(SizeRead);\n            LastBufferSize -= FrameSize + SizeRead;\n\n            for (Index=1; Index<FrameNum; Index++) {\n              // get the size of the frame\n              SizeRead = LastBufferSize;\n              FrameSize += ReadCodedSizeSignedValue(BufferStart + Mem.GetPosition(), SizeRead, SizeUnknown);\n              if (!FrameSize || (static_cast<uint32>(FrameSize + SizeRead) > LastBufferSize))\n                throw SafeReadIOCallback::EndOfStreamX(SizeRead);\n              SizeList[Index] = FrameSize;\n              Mem.Skip(SizeRead);\n              LastBufferSize -= FrameSize + SizeRead;\n            }\n            if (Index <= FrameNum) // Safety check if FrameNum == 0\n              SizeList[Index] = LastBufferSize;\n            break;\n          case LACING_FIXED:\n            for (Index=0; Index<=FrameNum; Index++) {\n              // get the size of the frame\n              SizeList[Index] = LastBufferSize / (FrameNum + 1);\n            }\n            break;\n          default: // other lacing not supported\n            assert(0);\n        }\n\n        FirstFrameLocation += Mem.GetPosition();\n\n        for (Index=0; Index<=FrameNum; Index++) {\n          DataBuffer * lacedFrame = new DataBuffer(BufferStart + Mem.GetPosition(), SizeList[Index]);\n          myBuffers.push_back(lacedFrame);\n          Mem.Skip(SizeList[Index]);\n        }\n      }\n\n      binary *BufferEnd = BufferStart + GetSize();\n      size_t NumFrames  = myBuffers.size();\n\n      // Sanity checks for frame pointers and boundaries.\n      for (size_t Index = 0; Index < NumFrames; ++Index) {\n        binary *FrameStart  = myBuffers[Index]->Buffer();\n        binary *FrameEnd    = FrameStart + myBuffers[Index]->Size();\n        binary *ExpectedEnd = (Index + 1) < NumFrames ? myBuffers[Index + 1]->Buffer() : BufferEnd;\n\n        if ((FrameStart < BufferStart) || (FrameEnd > BufferEnd) || (FrameEnd != ExpectedEnd))\n          throw SafeReadIOCallback::EndOfStreamX(0);\n      }\n\n      SetValueIsSet();\n    } else if (ReadFully == SCOPE_PARTIAL_DATA) {\n      binary _TempHead[5];\n      Result = input.read(_TempHead, 5);\n      if (Result != 5)\n        throw SafeReadIOCallback::EndOfStreamX(0);\n      binary *cursor = _TempHead;\n      binary *_tmpBuf;\n      uint8 BlockHeadSize = 4;\n\n      // update internal values\n      TrackNumber = *cursor++;\n      if ((TrackNumber & 0x80) == 0) {\n        // there is extra data\n        if ((TrackNumber & 0x40) == 0) {\n          // We don't support track numbers that large !\n          return Result;\n        }\n        TrackNumber = (TrackNumber & 0x3F) << 8;\n        TrackNumber += *cursor++;\n        BlockHeadSize++;\n      } else {\n        TrackNumber &= 0x7F;\n      }\n\n      big_int16 b16;\n      b16.Eval(cursor);\n      LocalTimecode = int16(b16);\n      bLocalTimecodeUsed = true;\n      cursor += 2;\n\n      if (EbmlId(*this) == EBML_ID(KaxSimpleBlock)) {\n        bIsKeyframe = (*cursor & 0x80) != 0;\n        bIsDiscardable = (*cursor & 0x01) != 0;\n      }\n      mInvisible = (*cursor & 0x08) >> 3;\n      mLacing = LacingType((*cursor++ & 0x06) >> 1);\n      if (cursor == &_TempHead[4]) {\n        _TempHead[0] = _TempHead[4];\n      } else {\n        Result += input.read(_TempHead, 1);\n      }\n\n      FirstFrameLocation += cursor - _TempHead;\n\n      // put all Frames in the list\n      if (mLacing != LACING_NONE) {\n        // read the number of frames in the lace\n        uint32 LastBufferSize = GetSize() - BlockHeadSize - 1; // 1 for number of frame\n        uint8 FrameNum = _TempHead[0]; // number of frames in the lace - 1\n        // read the list of frame sizes\n        uint8 Index;\n        int32 FrameSize;\n        uint32 SizeRead;\n        uint64 SizeUnknown;\n\n        SizeList.resize(FrameNum + 1);\n\n        switch (mLacing) {\n          case LACING_XIPH:\n            for (Index=0; Index<FrameNum; Index++) {\n              // get the size of the frame\n              FrameSize = 0;\n              do {\n                Result += input.read(_TempHead, 1);\n                FrameSize += uint8(_TempHead[0]);\n                LastBufferSize--;\n\n                FirstFrameLocation++;\n              } while (_TempHead[0] == 0xFF);\n\n              FirstFrameLocation++;\n              SizeList[Index] = FrameSize;\n              LastBufferSize -= FrameSize;\n            }\n            SizeList[Index] = LastBufferSize;\n            break;\n          case LACING_EBML:\n            SizeRead = LastBufferSize;\n            cursor = _tmpBuf = new binary[FrameNum*4]; /// \\warning assume the mean size will be coded in less than 4 bytes\n            Result += input.read(cursor, FrameNum*4);\n            FrameSize = ReadCodedSizeValue(cursor, SizeRead, SizeUnknown);\n            SizeList[0] = FrameSize;\n            cursor += SizeRead;\n            LastBufferSize -= FrameSize + SizeRead;\n\n            for (Index=1; Index<FrameNum; Index++) {\n              // get the size of the frame\n              SizeRead = LastBufferSize;\n              FrameSize += ReadCodedSizeSignedValue(cursor, SizeRead, SizeUnknown);\n              SizeList[Index] = FrameSize;\n              cursor += SizeRead;\n              LastBufferSize -= FrameSize + SizeRead;\n            }\n\n            FirstFrameLocation += cursor - _tmpBuf;\n\n            SizeList[Index] = LastBufferSize;\n            delete [] _tmpBuf;\n            break;\n          case LACING_FIXED:\n            for (Index=0; Index<=FrameNum; Index++) {\n              // get the size of the frame\n              SizeList[Index] = LastBufferSize / (FrameNum + 1);\n            }\n            break;\n          default: // other lacing not supported\n            assert(0);\n        }\n      } else {\n        SizeList.resize(1);\n        SizeList[0] = GetSize() - BlockHeadSize;\n      }\n      SetValueIsSet(false);\n      Result = GetSize();\n    } else {\n      SetValueIsSet(false);\n      Result = GetSize();\n    }\n\n  } catch (SafeReadIOCallback::EndOfStreamX &) {\n    SetValueIsSet(false);\n\n    std::memset(EbmlBinary::GetBuffer(), 0, GetSize());\n    myBuffers.clear();\n    SizeList.clear();\n    Timecode           = 0;\n    LocalTimecode      = 0;\n    TrackNumber        = 0;\n    bLocalTimecodeUsed = false;\n    FirstFrameLocation = 0;\n\n    return 0;\n  }\n\n  return Result;\n}", "target": 1, "idx": 11343}
{"commit_id": "10622ba36bb3910c151348f1569f039ecdd8786f", "project": "mz-automation/libiec61850", "func": "bool\nmmsMsg_parseFileName(char* filename, uint8_t* buffer, int* bufPos, int maxBufPos , uint32_t invokeId, ByteBuffer* response)\n{\n    if (*bufPos == maxBufPos)\n        return false;\n\n    uint8_t tag = buffer[(*bufPos)++];\n\n    if (tag != 0x19) {\n      mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n      return false;\n    }\n\n    int length;\n\n    *bufPos = BerDecoder_decodeLength(buffer, &length, *bufPos, maxBufPos);\n\n    if (*bufPos < 0)  {\n      mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n      return false;\n    }\n\n    if (length > 255) {\n      mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_REQUEST_INVALID_ARGUMENT, response);\n      return false;\n    }\n\n    memcpy(filename, buffer + *bufPos, length);\n    filename[length] = 0;\n    *bufPos += length;\n\n    /* Check if path contains invalid characters (prevent escaping the virtual filestore by using \"..\")\n     * TODO this may be platform dependent. Also depending of the platform there might be other evil\n     * characters.\n     */\n    if (strstr(filename, \"..\") != NULL) {\n        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n        return false;\n    }\n\n    return true;\n}", "target": 2, "idx": 11344}
{"commit_id": "58a6822d7140137ce957c6d2fc20bae1374186c1", "project": "android", "func": "WORD32 impeg2d_dec_pnb_mb_params(dec_state_t *ps_dec)\n{\n    stream_t *ps_stream = &ps_dec->s_bit_stream;\n    UWORD16 u2_mb_addr_incr;\n    UWORD16 u2_total_len;\n    UWORD16 u2_len;\n    UWORD16 u2_mb_type;\n    UWORD32 u4_next_word;\n    const dec_mb_params_t *ps_dec_mb_params;\n    if(impeg2d_bit_stream_nxt(ps_stream,1) == 1)\n    {\n        impeg2d_bit_stream_flush(ps_stream,1);\n\n    }\n    else\n    {\n        u2_mb_addr_incr = impeg2d_get_mb_addr_incr(ps_stream);\n\n        if(ps_dec->u2_first_mb)\n        {\n            /****************************************************************/\n            /* Section 6.3.17                                               */\n            /* The first MB of a slice cannot be skipped                    */\n            /* But the mb_addr_incr can be > 1, because at the beginning of */\n            /* a slice, it indicates the offset from the last MB in the     */\n            /* previous row. Hence for the first slice in a row, the        */\n            /* mb_addr_incr needs to be 1.                                  */\n            /****************************************************************/\n            /* MB_x is set to zero whenever MB_y changes.                   */\n            ps_dec->u2_mb_x = u2_mb_addr_incr - 1;\n            /* For error resilience */\n            ps_dec->u2_mb_x = MIN(ps_dec->u2_mb_x, (ps_dec->u2_num_horiz_mb - 1));\n\n            /****************************************************************/\n            /* mb_addr_incr is forced to 1 because in this decoder it is used */\n            /* more as an indicator of the number of MBs skipped than the   */\n            /* as defined by the standard (Section 6.3.17)                  */\n            /****************************************************************/\n            u2_mb_addr_incr = 1;\n            ps_dec->u2_first_mb = 0;\n        }\n        else\n        {\n            /****************************************************************/\n            /* In MPEG-2, the last MB of the row cannot be skipped and the  */\n            /* mb_addr_incr cannot be such that it will take the current MB   */\n            /* beyond the current row                                       */\n            /* In MPEG-1, the slice could start and end anywhere and is not */\n            /* restricted to a row like in MPEG-2. Hence this check should  */\n            /* not be done for MPEG-1 streams.                              */\n            /****************************************************************/\n            if(ps_dec->u2_is_mpeg2 &&\n                ((ps_dec->u2_mb_x + u2_mb_addr_incr) > ps_dec->u2_num_horiz_mb))\n            {\n                u2_mb_addr_incr    = ps_dec->u2_num_horiz_mb - ps_dec->u2_mb_x;\n            }\n\n\n            impeg2d_dec_skip_mbs(ps_dec, (UWORD16)(u2_mb_addr_incr - 1));\n        }\n\n    }\n    u4_next_word = (UWORD16)impeg2d_bit_stream_nxt(ps_stream,16);\n    /*-----------------------------------------------------------------------*/\n    /* MB type                                                               */\n    /*-----------------------------------------------------------------------*/\n    {\n        u2_mb_type   = ps_dec->pu2_mb_type[BITS((UWORD16)u4_next_word,15,10)];\n        u2_len      = BITS(u2_mb_type,15,8);\n        u2_total_len = u2_len;\n        u4_next_word = (UWORD16)LSW((UWORD16)u4_next_word << u2_len);\n    }\n    /*-----------------------------------------------------------------------*/\n    /* motion type                                                           */\n    /*-----------------------------------------------------------------------*/\n    {\n        WORD32 i4_motion_type = ps_dec->u2_motion_type;\n\n        if((u2_mb_type & MB_FORW_OR_BACK) &&  ps_dec->u2_read_motion_type)\n        {\n            ps_dec->u2_motion_type = BITS((UWORD16)u4_next_word,15,14);\n            u2_total_len += MB_MOTION_TYPE_LEN;\n            u4_next_word = (UWORD16)LSW((UWORD16)u4_next_word << MB_MOTION_TYPE_LEN);\n            i4_motion_type     = ps_dec->u2_motion_type;\n\n        }\n\n\n        if ((u2_mb_type & MB_FORW_OR_BACK) &&\n            ((i4_motion_type == 0) ||\n            (i4_motion_type == 3) ||\n            (i4_motion_type == 4) ||\n            (i4_motion_type >= 7)))\n        {\n            //TODO: VANG Check for validity\n            i4_motion_type = 1;\n        }\n\n    }\n    /*-----------------------------------------------------------------------*/\n    /* dct type                                                              */\n    /*-----------------------------------------------------------------------*/\n    {\n        if((u2_mb_type & MB_CODED) && ps_dec->u2_read_dct_type)\n        {\n            ps_dec->u2_field_dct = BIT((UWORD16)u4_next_word,15);\n            u2_total_len += MB_DCT_TYPE_LEN;\n            u4_next_word = (UWORD16)LSW((UWORD16)u4_next_word << MB_DCT_TYPE_LEN);\n        }\n    }\n    /*-----------------------------------------------------------------------*/\n    /* Quant scale code                                                      */\n    /*-----------------------------------------------------------------------*/\n    if(u2_mb_type & MB_QUANT)\n    {\n        UWORD16 u2_quant_scale_code;\n        u2_quant_scale_code = BITS((UWORD16)u4_next_word,15,11);\n\n        ps_dec->u1_quant_scale = (ps_dec->u2_q_scale_type) ?\n            gau1_impeg2_non_linear_quant_scale[u2_quant_scale_code] : (u2_quant_scale_code << 1);\n        u2_total_len += MB_QUANT_SCALE_CODE_LEN;\n    }\n    impeg2d_bit_stream_flush(ps_stream,u2_total_len);\n    /*-----------------------------------------------------------------------*/\n    /* Set the function pointers                                             */\n    /*-----------------------------------------------------------------------*/\n    ps_dec->u2_coded_mb    = (UWORD16)(u2_mb_type & MB_CODED);\n\n    if(u2_mb_type & MB_BIDRECT)\n    {\n        UWORD16 u2_index       = (ps_dec->u2_motion_type);\n\n        ps_dec->u2_prev_intra_mb    = 0;\n        ps_dec->e_mb_pred         = BIDIRECT;\n        ps_dec_mb_params = &ps_dec->ps_func_bi_direct[u2_index];\n        ps_dec->s_mb_type = ps_dec_mb_params->s_mb_type;\n        if(NULL == ps_dec_mb_params->pf_func_mb_params)\n            return -1;\n        ps_dec_mb_params->pf_func_mb_params(ps_dec);\n    }\n    else if(u2_mb_type & MB_FORW_OR_BACK)\n    {\n\n        UWORD16 u2_refPic      = !(u2_mb_type & MB_MV_FORW);\n        UWORD16 u2_index       = (ps_dec->u2_motion_type);\n        ps_dec->u2_prev_intra_mb    = 0;\n        ps_dec->e_mb_pred         = (e_pred_direction_t)u2_refPic;\n        ps_dec_mb_params = &ps_dec->ps_func_forw_or_back[u2_index];\n        ps_dec->s_mb_type = ps_dec_mb_params->s_mb_type;\n        if(NULL == ps_dec_mb_params->pf_func_mb_params)\n            return -1;\n        ps_dec_mb_params->pf_func_mb_params(ps_dec);\n\n    }\n    else if(u2_mb_type & MB_TYPE_INTRA)\n    {\n        ps_dec->u2_prev_intra_mb    = 1;\n        impeg2d_dec_intra_mb(ps_dec);\n\n    }\n    else\n    {\n        ps_dec->u2_prev_intra_mb =0;\n        ps_dec->e_mb_pred = FORW;\n        ps_dec->u2_motion_type = 0;\n        impeg2d_dec_0mv_coded_mb(ps_dec);\n    }\n\n    /*-----------------------------------------------------------------------*/\n    /* decode cbp                                                            */\n    /*-----------------------------------------------------------------------*/\n    if((u2_mb_type & MB_TYPE_INTRA))\n    {\n        ps_dec->u2_cbp  = 0x3f;\n        ps_dec->u2_prev_intra_mb    = 1;\n    }\n    else\n    {\n        ps_dec->u2_prev_intra_mb  = 0;\n        ps_dec->u2_def_dc_pred[Y_LUMA] = 128 << ps_dec->u2_intra_dc_precision;\n        ps_dec->u2_def_dc_pred[U_CHROMA] = 128 << ps_dec->u2_intra_dc_precision;\n        ps_dec->u2_def_dc_pred[V_CHROMA] = 128 << ps_dec->u2_intra_dc_precision;\n        if((ps_dec->u2_coded_mb))\n        {\n            UWORD16 cbpValue;\n            cbpValue  = gau2_impeg2d_cbp_code[impeg2d_bit_stream_nxt(ps_stream,MB_CBP_LEN)];\n            ps_dec->u2_cbp  = cbpValue & 0xFF;\n            impeg2d_bit_stream_flush(ps_stream,(cbpValue >> 8) & 0x0FF);\n        }\n        else\n        {\n            ps_dec->u2_cbp  = 0;\n        }\n    }\n    return 0;\n}", "target": 3, "idx": 11345}
{"commit_id": "3095060f479b86288e31c79ecbc5131a66bcd2f9", "project": "openbsd/src", "func": "static int\nnewkeys_to_blob(struct sshbuf *m, struct ssh *ssh, int mode)\n{\n\tstruct sshbuf *b;\n\tstruct sshcipher_ctx *cc;\n\tstruct sshcomp *comp;\n\tstruct sshenc *enc;\n\tstruct sshmac *mac;\n\tstruct newkeys *newkey;\n\tint r;\n\n\tif ((newkey = ssh->state->newkeys[mode]) == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tenc = &newkey->enc;\n\tmac = &newkey->mac;\n\tcomp = &newkey->comp;\n\tcc = (mode == MODE_OUT) ? ssh->state->send_context :\n\t    ssh->state->receive_context;\n\tif ((r = cipher_get_keyiv(cc, enc->iv, enc->iv_len)) != 0)\n\t\treturn r;\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t/* The cipher struct is constant and shared, you export pointer */\n\tif ((r = sshbuf_put_cstring(b, enc->name)) != 0 ||\n\t    (r = sshbuf_put(b, &enc->cipher, sizeof(enc->cipher))) != 0 ||\n\t    (r = sshbuf_put_u32(b, enc->enabled)) != 0 ||\n\t    (r = sshbuf_put_u32(b, enc->block_size)) != 0 ||\n\t    (r = sshbuf_put_string(b, enc->key, enc->key_len)) != 0 ||\n\t    (r = sshbuf_put_string(b, enc->iv, enc->iv_len)) != 0)\n\t\tgoto out;\n\tif (cipher_authlen(enc->cipher) == 0) {\n\t\tif ((r = sshbuf_put_cstring(b, mac->name)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, mac->enabled)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, mac->key, mac->key_len)) != 0)\n\t\t\tgoto out;\n\t}\n\tif ((r = sshbuf_put_u32(b, comp->type)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, comp->name)) != 0)\n\t\tgoto out;\n\tr = sshbuf_put_stringb(m, b);\n out:\n\tsshbuf_free(b);\n\treturn r;\n}", "target": 2, "idx": 11346}
{"commit_id": "ad5d07f4a9cd671233ae20983848874731102c08", "project": "torvalds/linux", "func": "static int calipso_doi_remove(u32 doi, struct netlbl_audit *audit_info)\n{\n\tint ret_val;\n\tstruct calipso_doi *doi_def;\n\tstruct audit_buffer *audit_buf;\n\n\tspin_lock(&calipso_doi_list_lock);\n\tdoi_def = calipso_doi_search(doi);\n\tif (!doi_def) {\n\t\tspin_unlock(&calipso_doi_list_lock);\n\t\tret_val = -ENOENT;\n\t\tgoto doi_remove_return;\n\t}\n\tlist_del_rcu(&doi_def->list);\n\tspin_unlock(&calipso_doi_list_lock);\n\n\tcalipso_doi_putdef(doi_def);\n\tret_val = 0;\n\ndoi_remove_return:\n\taudit_buf = netlbl_audit_start(AUDIT_MAC_CALIPSO_DEL, audit_info);\n\tif (audit_buf) {\n\t\taudit_log_format(audit_buf,\n\t\t\t\t \" calipso_doi=%u res=%u\",\n\t\t\t\t doi, ret_val == 0 ? 1 : 0);\n\t\taudit_log_end(audit_buf);\n\t}\n\n\treturn ret_val;\n}", "target": 2, "idx": 11347}
{"commit_id": "3d4eeda9ec0cb91e23bab7dc260d4c515119eb4b", "project": "tats/w3m", "func": "static Str\nprocess_form_int(struct parsed_tag *tag, int fid)\n{\n    char *p, *q, *r, *s, *tg, *n;\n\n    p = \"get\";\n    parsedtag_get_value(tag, ATTR_METHOD, &p);\n    q = \"!CURRENT_URL!\";\n    parsedtag_get_value(tag, ATTR_ACTION, &q);\n    q = url_encode(remove_space(q), cur_baseURL, cur_document_charset);\n    r = NULL;\n#ifdef USE_M17N\n    if (parsedtag_get_value(tag, ATTR_ACCEPT_CHARSET, &r))\n\tr = check_accept_charset(r);\n    if (!r && parsedtag_get_value(tag, ATTR_CHARSET, &r))\n\tr = check_charset(r);\n#endif\n    s = NULL;\n    parsedtag_get_value(tag, ATTR_ENCTYPE, &s);\n    tg = NULL;\n    parsedtag_get_value(tag, ATTR_TARGET, &tg);\n    n = NULL;\n    parsedtag_get_value(tag, ATTR_NAME, &n);\n\n    if (fid < 0) {\n\tform_max++;\n\tform_sp++;\n\tfid = form_max;\n    }\n    else {\t\t\t/* <form_int> */\n\tif (form_max < fid)\n\t    form_max = fid;\n\tform_sp = fid;\n    }\n    if (forms_size == 0) {\n\tforms_size = INITIAL_FORM_SIZE;\n\tforms = New_N(FormList *, forms_size);\n\tform_stack = NewAtom_N(int, forms_size);\n    }\n    if (forms_size <= form_max) {\n\tforms_size += form_max;\n\tforms = New_Reuse(FormList *, forms, forms_size);\n\tform_stack = New_Reuse(int, form_stack, forms_size);\n    }\n    form_stack[form_sp] = fid;\n\n    if (w3m_halfdump) {\n\tStr tmp = Sprintf(\"<form_int fid=\\\"%d\\\" action=\\\"%s\\\" method=\\\"%s\\\"\",\n\t\t\t  fid, html_quote(q), html_quote(p));\n\tif (s)\n\t    Strcat(tmp, Sprintf(\" enctype=\\\"%s\\\"\", html_quote(s)));\n\tif (tg)\n\t    Strcat(tmp, Sprintf(\" target=\\\"%s\\\"\", html_quote(tg)));\n\tif (n)\n\t    Strcat(tmp, Sprintf(\" name=\\\"%s\\\"\", html_quote(n)));\n#ifdef USE_M17N\n\tif (r)\n\t    Strcat(tmp, Sprintf(\" accept-charset=\\\"%s\\\"\", html_quote(r)));\n#endif\n\tStrcat_charp(tmp, \">\");\n\treturn tmp;\n    }\n\n    forms[fid] = newFormList(q, p, r, s, tg, n, NULL);\n    return NULL;\n}", "target": 1, "idx": 11348}
{"commit_id": "7690aa1cdf7c4565ad6b013b324c28b685505e24", "project": "torvalds/linux", "func": "static int nla_validate_array(const struct nlattr *head, int len, int maxtype,\n\t\t\t      const struct nla_policy *policy,\n\t\t\t      struct netlink_ext_ack *extack,\n\t\t\t      unsigned int validate, unsigned int depth)\n{\n\tconst struct nlattr *entry;\n\tint rem;\n\n\tnla_for_each_attr(entry, head, len, rem) {\n\t\tint ret;\n\n\t\tif (nla_len(entry) == 0)\n\t\t\tcontinue;\n\n\t\tif (nla_len(entry) < NLA_HDRLEN) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, entry,\n\t\t\t\t\t    \"Array element too short\");\n\t\t\treturn -ERANGE;\n\t\t}\n\n\t\tret = __nla_validate_parse(nla_data(entry), nla_len(entry),\n\t\t\t\t\t   maxtype, policy, validate, extack,\n\t\t\t\t\t   NULL, depth + 1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "target": 1, "idx": 11349}
{"commit_id": "3b5beaf49033cddf4b2cc4e4d391b966f4203471", "project": "xen-project/xen", "func": "static void inline\nshadow_put_page_from_l1e(shadow_l1e_t sl1e, struct domain *d)\n{\n    if ( !shadow_mode_refcounts(d) )\n        return;\n\n    put_page_from_l1e(sl1e, d);\n}", "target": 2, "idx": 11350}
{"commit_id": "942c3e0aee748ea6fe97cb2c1aa5893225316174", "project": "knik0/faad2", "func": "void faad_resetbits(bitfile *ld, int bits)\n{\n    uint32_t tmp;\n    int words = bits >> 5;\n    int remainder = bits & 0x1F;\n\n    if (ld->buffer_size < words * 4)\n        ld->bytes_left = 0;\n    else\n        ld->bytes_left = ld->buffer_size - words*4;\n\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword(&ld->start[words]);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n(&ld->start[words], ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufa = tmp;\n\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword(&ld->start[words+1]);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n(&ld->start[words+1], ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufb = tmp;\n\n    ld->bits_left = 32 - remainder;\n    ld->tail = &ld->start[words+2];\n\n    /* recheck for reading too many bytes */\n    ld->error = 0;\n//    if (ld->bytes_left == 0)\n//        ld->no_more_reading = 1;\n//    if (ld->bytes_left < 0)\n//        ld->error = 1;\n}", "target": 2, "idx": 11351}
{"commit_id": "48debe26f633e3b16809255d6ca7ce18db649a13", "project": "DMTF/libspdm", "func": "libspdm_return_t libspdm_get_response_capabilities(libspdm_context_t *spdm_context,\n                                                   size_t request_size,\n                                                   const void *request,\n                                                   size_t *response_size,\n                                                   void *response)\n{\n    const spdm_get_capabilities_request_t *spdm_request;\n    spdm_capabilities_response_t *spdm_response;\n    libspdm_return_t status;\n\n    spdm_request = request;\n\n    /* -=[Verify State Phase]=- */\n    if (spdm_context->response_state != LIBSPDM_RESPONSE_STATE_NORMAL) {\n        return libspdm_responder_handle_response_state(\n            spdm_context, spdm_request->header.request_response_code,  response_size, response);\n    }\n    if (spdm_context->connection_info.connection_state != LIBSPDM_CONNECTION_STATE_AFTER_VERSION) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_UNEXPECTED_REQUEST,\n                                               0, response_size, response);\n    }\n\n    /* -=[Validate Request Phase]=- */\n    if (!libspdm_check_request_version_compatibility(\n            spdm_context, spdm_request->header.spdm_version)) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_VERSION_MISMATCH, 0,\n                                               response_size, response);\n    }\n    if (spdm_request->header.spdm_version >= SPDM_MESSAGE_VERSION_12) {\n        if (request_size < sizeof(spdm_get_capabilities_request_t)) {\n            return libspdm_generate_error_response(\n                spdm_context, SPDM_ERROR_CODE_INVALID_REQUEST, 0, response_size, response);\n        } else {\n            request_size = sizeof(spdm_get_capabilities_request_t);\n        }\n    } else if (spdm_request->header.spdm_version >= SPDM_MESSAGE_VERSION_11) {\n        if (request_size < sizeof(spdm_get_capabilities_request_t) -\n            sizeof(spdm_request->data_transfer_size) - sizeof(spdm_request->max_spdm_msg_size)) {\n            return libspdm_generate_error_response(\n                spdm_context, SPDM_ERROR_CODE_INVALID_REQUEST, 0, response_size, response);\n        } else {\n            request_size = sizeof(spdm_get_capabilities_request_t) -\n                           sizeof(spdm_request->data_transfer_size) -\n                           sizeof(spdm_request->max_spdm_msg_size);\n        }\n    } else {\n        if (request_size < sizeof(spdm_message_header_t)) {\n            return libspdm_generate_error_response(\n                spdm_context, SPDM_ERROR_CODE_INVALID_REQUEST, 0, response_size, response);\n        } else {\n            request_size = sizeof(spdm_message_header_t);\n        }\n    }\n    if (!libspdm_check_request_flag_compatibility(\n            spdm_request->flags, spdm_request->header.spdm_version)) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_INVALID_REQUEST, 0,\n                                               response_size, response);\n    }\n    if (spdm_request->header.spdm_version >= SPDM_MESSAGE_VERSION_12) {\n        if ((spdm_request->data_transfer_size < SPDM_MIN_DATA_TRANSFER_SIZE_VERSION_12) ||\n            (spdm_request->data_transfer_size > spdm_request->max_spdm_msg_size)) {\n            return libspdm_generate_error_response(spdm_context,\n                                                   SPDM_ERROR_CODE_INVALID_REQUEST, 0,\n                                                   response_size, response);\n        }\n        if (((spdm_request->flags & SPDM_GET_CAPABILITIES_REQUEST_FLAGS_CHUNK_CAP) == 0) &&\n            (spdm_request->data_transfer_size != spdm_request->max_spdm_msg_size)) {\n            return libspdm_generate_error_response(spdm_context,\n                                                   SPDM_ERROR_CODE_INVALID_REQUEST, 0,\n                                                   response_size, response);\n        }\n    }\n    if (spdm_request->header.spdm_version >= SPDM_MESSAGE_VERSION_11) {\n        if (spdm_request->ct_exponent > LIBSPDM_MAX_CT_EXPONENT) {\n            return libspdm_generate_error_response(spdm_context,\n                                                   SPDM_ERROR_CODE_INVALID_REQUEST, 0,\n                                                   response_size, response);\n        }\n    }\n\n    libspdm_reset_message_buffer_via_request_code(spdm_context, NULL,\n                                                  spdm_request->header.request_response_code);\n\n    /* -=[Construct Response Phase]=- */\n    LIBSPDM_ASSERT(*response_size >= sizeof(spdm_capabilities_response_t));\n    *response_size = sizeof(spdm_capabilities_response_t);\n    libspdm_zero_mem(response, *response_size);\n    spdm_response = response;\n\n    spdm_response->header.spdm_version = spdm_request->header.spdm_version;\n    spdm_response->header.request_response_code = SPDM_CAPABILITIES;\n    spdm_response->header.param1 = 0;\n    spdm_response->header.param2 = 0;\n    spdm_response->ct_exponent = spdm_context->local_context.capability.ct_exponent;\n    spdm_response->flags = spdm_context->local_context.capability.flags;\n    spdm_response->data_transfer_size = spdm_context->local_context.capability.data_transfer_size;\n    spdm_response->max_spdm_msg_size = spdm_context->local_context.capability.max_spdm_msg_size;\n\n    if (spdm_response->header.spdm_version >= SPDM_MESSAGE_VERSION_12) {\n        *response_size = sizeof(spdm_capabilities_response_t);\n    } else {\n        *response_size = sizeof(spdm_capabilities_response_t) -\n                         sizeof(spdm_response->data_transfer_size) -\n                         sizeof(spdm_response->max_spdm_msg_size);\n    }\n\n    /* -=[Process Request Phase]=- */\n    status = libspdm_append_message_a(spdm_context, spdm_request, request_size);\n    if (LIBSPDM_STATUS_IS_ERROR(status)) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_UNSPECIFIED, 0,\n                                               response_size, response);\n    }\n    status = libspdm_append_message_a(spdm_context, spdm_response, *response_size);\n\n    if (LIBSPDM_STATUS_IS_ERROR(status)) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_UNSPECIFIED, 0,\n                                               response_size, response);\n    }\n    if (spdm_response->header.spdm_version >= SPDM_MESSAGE_VERSION_11) {\n        spdm_context->connection_info.capability.ct_exponent = spdm_request->ct_exponent;\n        spdm_context->connection_info.capability.flags = spdm_request->flags;\n    } else {\n        spdm_context->connection_info.capability.ct_exponent = 0;\n        spdm_context->connection_info.capability.flags = 0;\n    }\n    if (spdm_response->header.spdm_version >= SPDM_MESSAGE_VERSION_12) {\n        spdm_context->connection_info.capability.data_transfer_size =\n            spdm_request->data_transfer_size;\n        spdm_context->connection_info.capability.max_spdm_msg_size =\n            spdm_request->max_spdm_msg_size;\n    } else {\n        spdm_context->connection_info.capability.data_transfer_size = 0;\n        spdm_context->connection_info.capability.max_spdm_msg_size = 0;\n    }\n\n    /* -=[Update State Phase]=- */\n    libspdm_set_connection_state(spdm_context, LIBSPDM_CONNECTION_STATE_AFTER_CAPABILITIES);\n\n    return LIBSPDM_STATUS_SUCCESS;\n}", "target": 1, "idx": 11352}
{"commit_id": "d3e09bf4654fe5478b6dbf2b26ebab6271317d81", "project": "harfbuzz", "func": "void intersect (const hb_bit_set_invertible_t &other)\n  {\n    if (likely (inverted == other.inverted))\n    {\n      if (unlikely (inverted))\n\tprocess (hb_bitwise_or, other);\n      else\n\tprocess (hb_bitwise_and, other); /* Main branch. */\n    }\n    else\n    {\n      if (unlikely (inverted))\n\tprocess (hb_bitwise_lt, other);\n      else\n\tprocess (hb_bitwise_gt, other);\n    }\n    if (likely (s.successful))\n      inverted = inverted && other.inverted;\n  }", "target": 1, "idx": 11353}
{"commit_id": "0031c41be5c529f8329e327b63cde92ba1284842", "project": "torvalds/linux", "func": "bool radeon_atom_get_tv_timings(struct radeon_device *rdev, int index,\n\t\t\t\tstruct drm_display_mode *mode)\n{\n\tstruct radeon_mode_info *mode_info = &rdev->mode_info;\n\tATOM_ANALOG_TV_INFO *tv_info;\n\tATOM_ANALOG_TV_INFO_V1_2 *tv_info_v1_2;\n\tATOM_DTD_FORMAT *dtd_timings;\n\tint data_index = GetIndexIntoMasterTable(DATA, AnalogTV_Info);\n\tu8 frev, crev;\n\tu16 data_offset, misc;\n\n\tif (!atom_parse_data_header(mode_info->atom_context, data_index, NULL,\n\t\t\t\t    &frev, &crev, &data_offset))\n\t\treturn false;\n\n\tswitch (crev) {\n\tcase 1:\n\t\ttv_info = (ATOM_ANALOG_TV_INFO *)(mode_info->atom_context->bios + data_offset);\n\t\tif (index >= MAX_SUPPORTED_TV_TIMING)\n\t\t\treturn false;\n\n\t\tmode->crtc_htotal = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_Total);\n\t\tmode->crtc_hdisplay = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_Disp);\n\t\tmode->crtc_hsync_start = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_SyncStart);\n\t\tmode->crtc_hsync_end = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_SyncStart) +\n\t\t\tle16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_SyncWidth);\n\n\t\tmode->crtc_vtotal = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_Total);\n\t\tmode->crtc_vdisplay = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_Disp);\n\t\tmode->crtc_vsync_start = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_SyncStart);\n\t\tmode->crtc_vsync_end = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_SyncStart) +\n\t\t\tle16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_SyncWidth);\n\n\t\tmode->flags = 0;\n\t\tmisc = le16_to_cpu(tv_info->aModeTimings[index].susModeMiscInfo.usAccess);\n\t\tif (misc & ATOM_VSYNC_POLARITY)\n\t\t\tmode->flags |= DRM_MODE_FLAG_NVSYNC;\n\t\tif (misc & ATOM_HSYNC_POLARITY)\n\t\t\tmode->flags |= DRM_MODE_FLAG_NHSYNC;\n\t\tif (misc & ATOM_COMPOSITESYNC)\n\t\t\tmode->flags |= DRM_MODE_FLAG_CSYNC;\n\t\tif (misc & ATOM_INTERLACE)\n\t\t\tmode->flags |= DRM_MODE_FLAG_INTERLACE;\n\t\tif (misc & ATOM_DOUBLE_CLOCK_MODE)\n\t\t\tmode->flags |= DRM_MODE_FLAG_DBLSCAN;\n\n\t\tmode->clock = le16_to_cpu(tv_info->aModeTimings[index].usPixelClock) * 10;\n\n\t\tif (index == 1) {\n\t\t\t/* PAL timings appear to have wrong values for totals */\n\t\t\tmode->crtc_htotal -= 1;\n\t\t\tmode->crtc_vtotal -= 1;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\ttv_info_v1_2 = (ATOM_ANALOG_TV_INFO_V1_2 *)(mode_info->atom_context->bios + data_offset);\n\t\tif (index >= MAX_SUPPORTED_TV_TIMING_V1_2)\n\t\t\treturn false;\n\n\t\tdtd_timings = &tv_info_v1_2->aModeTimings[index];\n\t\tmode->crtc_htotal = le16_to_cpu(dtd_timings->usHActive) +\n\t\t\tle16_to_cpu(dtd_timings->usHBlanking_Time);\n\t\tmode->crtc_hdisplay = le16_to_cpu(dtd_timings->usHActive);\n\t\tmode->crtc_hsync_start = le16_to_cpu(dtd_timings->usHActive) +\n\t\t\tle16_to_cpu(dtd_timings->usHSyncOffset);\n\t\tmode->crtc_hsync_end = mode->crtc_hsync_start +\n\t\t\tle16_to_cpu(dtd_timings->usHSyncWidth);\n\n\t\tmode->crtc_vtotal = le16_to_cpu(dtd_timings->usVActive) +\n\t\t\tle16_to_cpu(dtd_timings->usVBlanking_Time);\n\t\tmode->crtc_vdisplay = le16_to_cpu(dtd_timings->usVActive);\n\t\tmode->crtc_vsync_start = le16_to_cpu(dtd_timings->usVActive) +\n\t\t\tle16_to_cpu(dtd_timings->usVSyncOffset);\n\t\tmode->crtc_vsync_end = mode->crtc_vsync_start +\n\t\t\tle16_to_cpu(dtd_timings->usVSyncWidth);\n\n\t\tmode->flags = 0;\n\t\tmisc = le16_to_cpu(dtd_timings->susModeMiscInfo.usAccess);\n\t\tif (misc & ATOM_VSYNC_POLARITY)\n\t\t\tmode->flags |= DRM_MODE_FLAG_NVSYNC;\n\t\tif (misc & ATOM_HSYNC_POLARITY)\n\t\t\tmode->flags |= DRM_MODE_FLAG_NHSYNC;\n\t\tif (misc & ATOM_COMPOSITESYNC)\n\t\t\tmode->flags |= DRM_MODE_FLAG_CSYNC;\n\t\tif (misc & ATOM_INTERLACE)\n\t\t\tmode->flags |= DRM_MODE_FLAG_INTERLACE;\n\t\tif (misc & ATOM_DOUBLE_CLOCK_MODE)\n\t\t\tmode->flags |= DRM_MODE_FLAG_DBLSCAN;\n\n\t\tmode->clock = le16_to_cpu(dtd_timings->usPixClk) * 10;\n\t\tbreak;\n\t}\n\treturn true;\n}", "target": 2, "idx": 11354}
{"commit_id": "7408c4c788ce047d4e652b60a04e7796bcd7267e", "project": "libsndfile", "func": "static int\nwav_write_header (SF_PRIVATE *psf, int calc_length)\n{\tsf_count_t\tcurrent ;\n\tint \t\terror, has_data = SF_FALSE ;\n\n\tcurrent = psf_ftell (psf) ;\n\n\tif (current > psf->dataoffset)\n\t\thas_data = SF_TRUE ;\n\n\tif (calc_length)\n\t{\tpsf->filelength = psf_get_filelen (psf) ;\n\n\t\tpsf->datalength = psf->filelength - psf->dataoffset ;\n\n\t\tif (psf->dataend)\n\t\t\tpsf->datalength -= psf->filelength - psf->dataend ;\n\t\telse if (psf->bytewidth > 0 && psf->sf.seekable == SF_TRUE)\n\t\t\tpsf->datalength = psf->sf.frames * psf->bytewidth * psf->sf.channels ;\n\t\t} ;\n\n\t/* Reset the current header length to zero. */\n\tpsf->header.ptr [0] = 0 ;\n\tpsf->header.indx = 0 ;\n\tpsf_fseek (psf, 0, SEEK_SET) ;\n\n\t/*\n\t** RIFX signifies big-endian format for all header and data.\n\t** To prevent lots of code copying here, we'll set the psf->rwf_endian flag\n\t** once here, and never specify endian-ness for all other header operations.\n\t*/\n\n\t/* RIFF/RIFX marker, length, WAVE and 'fmt ' markers. */\n\n\tif (psf->endian == SF_ENDIAN_LITTLE)\n\t\tpsf_binheader_writef (psf, \"etm8\", BHWm (RIFF_MARKER), BHW8 ((psf->filelength < 8) ? 8 : psf->filelength - 8)) ;\n\telse\n\t\tpsf_binheader_writef (psf, \"Etm8\", BHWm (RIFX_MARKER), BHW8 ((psf->filelength < 8) ? 8 : psf->filelength - 8)) ;\n\n\t/* WAVE and 'fmt ' markers. */\n\tpsf_binheader_writef (psf, \"mm\", BHWm (WAVE_MARKER), BHWm (fmt_MARKER)) ;\n\n\t/* Write the 'fmt ' chunk. */\n\tswitch (SF_CONTAINER (psf->sf.format))\n\t{\tcase SF_FORMAT_WAV :\n\t\t\t\tif ((error = wav_write_fmt_chunk (psf)) != 0)\n\t\t\t\t\treturn error ;\n\t\t\t\tbreak ;\n\n\t\tcase SF_FORMAT_WAVEX :\n\t\t\t\tif ((error = wavex_write_fmt_chunk (psf)) != 0)\n\t\t\t\t\treturn error ;\n\t\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\t\treturn SFE_UNIMPLEMENTED ;\n\t\t} ;\n\n\t/* The LIST/INFO chunk. */\n\tif (psf->strings.flags & SF_STR_LOCATE_START)\n\t\twavlike_write_strings (psf, SF_STR_LOCATE_START) ;\n\n\tif (psf->peak_info != NULL && psf->peak_info->peak_loc == SF_PEAK_START)\n\t\twavlike_write_peak_chunk (psf) ;\n\n\tif (psf->broadcast_16k != NULL)\n\t\twavlike_write_bext_chunk (psf) ;\n\n\tif (psf->cart_16k != NULL)\n\t\twavlike_write_cart_chunk (psf) ;\n\n\tif (psf->cues != NULL)\n\t{\tuint32_t k ;\n\n\t\tpsf_binheader_writef (psf, \"em44\", BHWm (cue_MARKER), BHW4 (4 + psf->cues->cue_count * 6 * 4), BHW4 (psf->cues->cue_count)) ;\n\n\t\tfor (k = 0 ; k < psf->cues->cue_count ; k++)\n\t\t\tpsf_binheader_writef (psf, \"e44m444\", BHW4 (psf->cues->cue_points [k].indx), BHW4 (psf->cues->cue_points [k].position),\n\t\t\t\t\t\tBHWm (psf->cues->cue_points [k].fcc_chunk), BHW4 (psf->cues->cue_points [k].chunk_start),\n\t\t\t\t\t\tBHW4 (psf->cues->cue_points [k].block_start), BHW4 (psf->cues->cue_points [k].sample_offset)) ;\n\t\t} ;\n\n\tif (psf->instrument != NULL)\n\t{\tint\t\ttmp ;\n\t\tdouble\tdtune = (double) (0x40000000) / 25.0 ;\n\n\t\tpsf_binheader_writef (psf, \"m4\", BHWm (smpl_MARKER), BHW4 (9 * 4 + psf->instrument->loop_count * 6 * 4)) ;\n\t\tpsf_binheader_writef (psf, \"44\", BHW4 (0), BHW4 (0)) ; /* Manufacturer zero is everyone */\n\t\ttmp = (int) (1.0e9 / psf->sf.samplerate) ; /* Sample period in nano seconds */\n\t\tpsf_binheader_writef (psf, \"44\", BHW4 (tmp), BHW4 (psf->instrument->basenote)) ;\n\t\ttmp = (uint32_t) (psf->instrument->detune * dtune + 0.5) ;\n\t\tpsf_binheader_writef (psf, \"4\", BHW4 (tmp)) ;\n\t\tpsf_binheader_writef (psf, \"44\", BHW4 (0), BHW4 (0)) ; /* SMTPE format */\n\t\tpsf_binheader_writef (psf, \"44\", BHW4 (psf->instrument->loop_count), BHW4 (0)) ;\n\n\t\t/* Make sure we don't read past the loops array end. */\n\t\tif (psf->instrument->loop_count > ARRAY_LEN (psf->instrument->loops))\n\t\t\tpsf->instrument->loop_count = ARRAY_LEN (psf->instrument->loops) ;\n\n\t\tfor (tmp = 0 ; tmp < psf->instrument->loop_count ; tmp++)\n\t\t{\tint type ;\n\n\t\t\ttype = psf->instrument->loops [tmp].mode ;\n\t\t\ttype = (type == SF_LOOP_FORWARD ? 0 : type == SF_LOOP_BACKWARD ? 2 : type == SF_LOOP_ALTERNATING ? 1 : 32) ;\n\n\t\t\tpsf_binheader_writef (psf, \"44\", BHW4 (tmp), BHW4 (type)) ;\n\t\t\tpsf_binheader_writef (psf, \"44\", BHW4 (psf->instrument->loops [tmp].start), BHW4 (psf->instrument->loops [tmp].end - 1)) ;\n\t\t\tpsf_binheader_writef (psf, \"44\", BHW4 (0), BHW4 (psf->instrument->loops [tmp].count)) ;\n\t\t\t} ;\n\t\t} ;\n\n\t/* Write custom headers. */\n\tif (psf->wchunks.used > 0)\n\t\twavlike_write_custom_chunks (psf) ;\n\n\tif (psf->header.indx + 16 < psf->dataoffset)\n\t{\t/* Add PAD data if necessary. */\n\t\tsize_t k = psf->dataoffset - (psf->header.indx + 16) ;\n\t\tpsf_binheader_writef (psf, \"m4z\", BHWm (PAD_MARKER), BHW4 (k), BHWz (k)) ;\n\t\t} ;\n\n\tpsf_binheader_writef (psf, \"tm8\", BHWm (data_MARKER), BHW8 (psf->datalength)) ;\n\tpsf_fwrite (psf->header.ptr, psf->header.indx, 1, psf) ;\n\tif (psf->error)\n\t\treturn psf->error ;\n\n\tif (has_data && psf->dataoffset != psf->header.indx)\n\t{\tpsf_log_printf (psf, \"Oooops : has_data && psf->dataoffset != psf->header.indx\\n\") ;\n\t\treturn psf->error = SFE_INTERNAL ;\n\t\t} ;\n\n\tpsf->dataoffset = psf->header.indx ;\n\n\tif (! has_data)\n\t\tpsf_fseek (psf, psf->dataoffset, SEEK_SET) ;\n\telse if (current > 0)\n\t\tpsf_fseek (psf, current, SEEK_SET) ;\n\n\treturn psf->error ;\n}", "target": 1, "idx": 11355}
{"commit_id": "047f96fb39e6bf70cb9f344093f5886e51dce0ac", "project": "gpac", "func": "Bool naludmx_create_avc_decoder_config(GF_NALUDmxCtx *ctx, u8 **dsi, u32 *dsi_size, u8 **dsi_enh, u32 *dsi_enh_size, u32 *max_width, u32 *max_height, u32 *max_enh_width, u32 *max_enh_height, GF_Fraction *sar)\n{\n\tu32 i, count;\n\tBool first = GF_TRUE;\n\tBool first_svc = GF_TRUE;\n\tGF_AVCConfig *cfg;\n\tGF_AVCConfig *avcc;\n\tGF_AVCConfig *svcc;\n\tu32 max_w, max_h, max_ew, max_eh;\n\n\n\tmax_w = max_h = max_ew = max_eh = 0;\n\tsar->num = sar->den = 0;\n\n\tif (!ctx->analyze && (!gf_list_count(ctx->sps) || !gf_list_count(ctx->pps)))\n\t\treturn GF_FALSE;\n\n\tavcc = gf_odf_avc_cfg_new();\n\tsvcc = gf_odf_avc_cfg_new();\n\tavcc->nal_unit_size = ctx->nal_length;\n\tsvcc->nal_unit_size = ctx->nal_length;\n\n\tctx->is_mvc = GF_FALSE;\n\tcount = gf_list_count(ctx->sps);\n\tfor (i=0; i<count; i++) {\n\t\tBool is_svc = GF_FALSE;\n\t\tGF_NALUFFParam *sl = gf_list_get(ctx->sps, i);\n\t\tAVC_SPS *sps = &ctx->avc_state->sps[sl->id];\n\t\tu32 nal_type = sl->data[0] & 0x1F;\n\n\t\tif ((sps->profile_idc == 118) || (sps->profile_idc == 128)) {\n\t\t\tctx->is_mvc = GF_TRUE;\n\t\t}\n\n\t\tif (ctx->explicit) {\n\t\t\tcfg = svcc;\n\t\t} else if (nal_type == GF_AVC_NALU_SVC_SUBSEQ_PARAM) {\n\t\t\tcfg = svcc;\n\t\t\tis_svc = GF_TRUE;\n\t\t} else {\n\t\t\tcfg = avcc;\n\t\t}\n\n\t\tif (first || (is_svc && first_svc) ) {\n\t\t\tcfg->configurationVersion = 1;\n\t\t\tcfg->profile_compatibility = sps->prof_compat;\n\t\t\tcfg->AVCProfileIndication = sps->profile_idc;\n\t\t\tcfg->AVCLevelIndication = sps->level_idc;\n\t\t\tcfg->chroma_format = sps->chroma_format;\n\t\t\tcfg->luma_bit_depth = 8 + sps->luma_bit_depth_m8;\n\t\t\tcfg->chroma_bit_depth = 8 + sps->chroma_bit_depth_m8;\n\t\t\t/*try to patch ?*/\n\t\t\tif (!gf_avcc_use_extensions(cfg->AVCProfileIndication)\n\t\t\t\t&& ((cfg->chroma_format>1) || (cfg->luma_bit_depth>8) || (cfg->chroma_bit_depth>8))\n\t\t\t) {\n\t\t\t\tif ((cfg->luma_bit_depth>8) || (cfg->chroma_bit_depth>8)) {\n\t\t\t\t\tcfg->AVCProfileIndication = 110;\n\t\t\t\t} else {\n\t\t\t\t\tcfg->AVCProfileIndication = (cfg->chroma_format==3) ? 244 : 122;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sps->vui_parameters_present_flag && sps->vui.par_num && sps->vui.par_den) {\n\t\t\t\tsar->num = sps->vui.par_num;\n\t\t\t\tsar->den = sps->vui.par_den;\n\t\t\t}\n\t\t\tctx->interlaced = sps->frame_mbs_only_flag ? GF_FALSE : GF_TRUE;\n\n\n\t\t\t/*disable frame rate scan, most bitstreams have wrong values there*/\n\t\t\tif (first && (!ctx->fps.num || !ctx->fps.den) && sps->vui.timing_info_present_flag\n\t\t\t\t/*if detected FPS is greater than 1000, assume wrong timing info*/\n\t\t\t\t&& (sps->vui.time_scale <= 1000*sps->vui.num_units_in_tick)\n\t\t\t) {\n\t\t\t\t/*ISO/IEC 14496-10 n11084 Table E-6*/\n\t\t\t\t/* not used :\t\t\t\tu8 DeltaTfiDivisorTable[] = {1,1,1,2,2,2,2,3,3,4,6}; */\n\t\t\t\tu8 DeltaTfiDivisorIdx;\n\t\t\t\tif (!sps->vui.pic_struct_present_flag) {\n\t\t\t\t\tDeltaTfiDivisorIdx = 1 + (1 - ctx->avc_state->s_info.field_pic_flag);\n\t\t\t\t} else {\n\t\t\t\t\tif (!ctx->avc_state->sei.pic_timing.pic_struct)\n\t\t\t\t\t\tDeltaTfiDivisorIdx = 2;\n\t\t\t\t\telse if (ctx->avc_state->sei.pic_timing.pic_struct == 8)\n\t\t\t\t\t\tDeltaTfiDivisorIdx = 6;\n\t\t\t\t\telse\n\t\t\t\t\t\tDeltaTfiDivisorIdx = (ctx->avc_state->sei.pic_timing.pic_struct+1) / 2;\n\t\t\t\t}\n\t\t\t\tif (ctx->notime) {\n\t\t\t\t\tu32 fps_num = 2 * sps->vui.time_scale;\n\t\t\t\t\tu32 fps_den = 2 * sps->vui.num_units_in_tick * DeltaTfiDivisorIdx;\n\t\t\t\t\tif (fps_num && fps_den) {\n\t\t\t\t\t\tctx->cur_fps.num = fps_num;\n\t\t\t\t\t\tctx->cur_fps.den = fps_den;\n\t\t\t\t\t}\n\t\t\t\t\tif (!ctx->fps.num && ctx->dts==ctx->fps.den)\n\t\t\t\t\t\tctx->dts = ctx->cur_fps.den;\n\t\t\t\t}\n\t\t\t\tif (! sps->vui.fixed_frame_rate_flag)\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[%s] Possible Variable Frame Rate: VUI \\\"fixed_frame_rate_flag\\\" absent\\n\", ctx->log_name));\n\t\t\t}\n\t\t\tctx->fps = ctx->cur_fps;\n\t\t}\n\t\tfirst = GF_FALSE;\n\t\tif (is_svc) {\n\t\t\tfirst_svc = GF_FALSE;\n\t\t\tif (sps->width > max_ew) max_ew = sps->width;\n\t\t\tif (sps->height > max_eh) max_eh = sps->height;\n\t\t} else {\n\t\t\tif (sps->width > max_w) max_w = sps->width;\n\t\t\tif (sps->height > max_h) max_h = sps->height;\n\t\t}\n\t\tif (!ctx->analyze)\n\t\t\tgf_list_add(cfg->sequenceParameterSets, sl);\n\t}\n\n\tcfg = ctx->explicit ? svcc : avcc;\n\tcount = gf_list_count(ctx->sps_ext);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = gf_list_get(ctx->sps_ext, i);\n\t\tif (!cfg->sequenceParameterSetExtensions) cfg->sequenceParameterSetExtensions = gf_list_new();\n\t\tif (!ctx->analyze)\n\t\t\tgf_list_add(cfg->sequenceParameterSetExtensions, sl);\n\t}\n\n\tcfg = ctx->explicit ? svcc : avcc;\n\tcount = gf_list_count(ctx->pps);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = gf_list_get(ctx->pps, i);\n\t\tif (!ctx->analyze)\n\t\t\tgf_list_add(cfg->pictureParameterSets, sl);\n\t}\n\n\tcfg = svcc;\n\tcount = gf_list_count(ctx->pps_svc);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = gf_list_get(ctx->pps_svc, i);\n\t\tif (!ctx->analyze)\n\t\t\tgf_list_add(cfg->pictureParameterSets, sl);\n\t}\n\n\t*dsi = *dsi_enh = NULL;\n\t*dsi_size = *dsi_enh_size = 0;\n\n\tif (ctx->explicit) {\n\t\tgf_odf_avc_cfg_write(svcc, dsi, dsi_size);\n\t} else {\n\t\tgf_odf_avc_cfg_write(avcc, dsi, dsi_size);\n\t\tif (gf_list_count(svcc->sequenceParameterSets) || svcc->sequenceParameterSetExtensions) {\n\t\t\tgf_odf_avc_cfg_write(svcc, dsi_enh, dsi_enh_size);\n\t\t}\n\t}\n\tgf_list_reset(avcc->sequenceParameterSets);\n\tgf_list_reset(avcc->sequenceParameterSetExtensions);\n\tgf_list_reset(avcc->pictureParameterSets);\n\tgf_list_reset(svcc->sequenceParameterSets);\n\tgf_list_reset(svcc->sequenceParameterSetExtensions);\n\tgf_list_reset(svcc->pictureParameterSets);\n\tgf_odf_avc_cfg_del(avcc);\n\tgf_odf_avc_cfg_del(svcc);\n\t*max_width = max_w;\n\t*max_height = max_h;\n\t*max_enh_width = max_ew;\n\t*max_enh_height = max_eh;\n\treturn GF_TRUE;\n}", "target": 2, "idx": 11356}
{"commit_id": "54d256d1fc9c6a9e7438f6f51206d1f99b1ed6b4", "project": "chromium", "func": "void MidiManagerMac::SendMidiData(MidiManagerClient* client,\n                                  uint32 port_index,\n                                  const std::vector<uint8>& data,\n                                  double timestamp) {\n  DCHECK(client_thread_.task_runner()->BelongsToCurrentThread());\n\n  // Lookup the destination based on the port index.\n  if (static_cast<size_t>(port_index) >= destinations_.size())\n    return;\n\n  MIDITimeStamp coremidi_timestamp = SecondsToMIDITimeStamp(timestamp);\n  MIDIEndpointRef destination = destinations_[port_index];\n\n  size_t send_size;\n  for (size_t sent_size = 0; sent_size < data.size(); sent_size += send_size) {\n    MIDIPacketList* packet_list =\n        reinterpret_cast<MIDIPacketList*>(midi_buffer_.data());\n    MIDIPacket* midi_packet = MIDIPacketListInit(packet_list);\n    // Limit the maximum payload size to kEstimatedMaxPacketDataSize that is\n    // half of midi_buffer data size. MIDIPacketList and MIDIPacket consume\n    // extra buffer areas for meta information, and available size is smaller\n    // than buffer size. Here, we simply assume that at least half size is\n    // available for data payload.\n    send_size = std::min(data.size() - sent_size, kEstimatedMaxPacketDataSize);\n    midi_packet = MIDIPacketListAdd(\n        packet_list,\n        kCoreMIDIMaxPacketListSize,\n        midi_packet,\n        coremidi_timestamp,\n        send_size,\n        &data[sent_size]);\n    DCHECK(midi_packet);\n\n    MIDISend(coremidi_output_, destination, packet_list);\n  }\n\n  AccumulateMidiBytesSent(client, data.size());\n}", "target": 3, "idx": 11357}
{"commit_id": "bd771cf5c4254511cc4abb88f3dab3bd58bdf8e8", "project": "kernel/git/deller/linux-fbdev", "func": "static ssize_t smtcfb_read(struct fb_info *info, char __user *buf,\n\t\t\t   size_t count, loff_t *ppos)\n{\n\tunsigned long p = *ppos;\n\n\tu32 *buffer, *dst;\n\tu32 __iomem *src;\n\tint c, i, cnt = 0, err = 0;\n\tunsigned long total_size;\n\n\tif (!info || !info->screen_base)\n\t\treturn -ENODEV;\n\n\tif (info->state != FBINFO_STATE_RUNNING)\n\t\treturn -EPERM;\n\n\ttotal_size = info->screen_size;\n\n\tif (total_size == 0)\n\t\ttotal_size = info->fix.smem_len;\n\n\tif (p >= total_size)\n\t\treturn 0;\n\n\tif (count >= total_size)\n\t\tcount = total_size;\n\n\tif (count + p > total_size)\n\t\tcount = total_size - p;\n\n\tbuffer = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tsrc = (u32 __iomem *)(info->screen_base + p);\n\n\tif (info->fbops->fb_sync)\n\t\tinfo->fbops->fb_sync(info);\n\n\twhile (count) {\n\t\tc = (count > PAGE_SIZE) ? PAGE_SIZE : count;\n\t\tdst = buffer;\n\t\tfor (i = (c + 3) >> 2; i--;) {\n\t\t\tu32 val;\n\n\t\t\tval = fb_readl(src);\n\t\t\t*dst = big_swap(val);\n\t\t\tsrc++;\n\t\t\tdst++;\n\t\t}\n\n\t\tif (copy_to_user(buf, buffer, c)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\t*ppos += c;\n\t\tbuf += c;\n\t\tcnt += c;\n\t\tcount -= c;\n\t}\n\n\tkfree(buffer);\n\n\treturn (err) ? err : cnt;\n}", "target": 1, "idx": 11358}
{"commit_id": "a09d2d00af53b43c6f11e6ab3cb58443c2cac8a7", "project": "torvalds/linux", "func": "static ssize_t\npxa3xx_gcu_write(struct file *file, const char *buff,\n\t\t size_t count, loff_t *offp)\n{\n\tint ret;\n\tunsigned long flags;\n\tstruct pxa3xx_gcu_batch\t*buffer;\n\tstruct pxa3xx_gcu_priv *priv = to_pxa3xx_gcu_priv(file);\n\n\tsize_t words = count / 4;\n\n\t/* Does not need to be atomic. There's a lock in user space,\n\t * but anyhow, this is just for statistics. */\n\tpriv->shared->num_writes++;\n\tpriv->shared->num_words += words;\n\n\t/* Last word reserved for batch buffer end command */\n\tif (words >= PXA3XX_GCU_BATCH_WORDS)\n\t\treturn -E2BIG;\n\n\t/* Wait for a free buffer */\n\tif (!priv->free) {\n\t\tret = pxa3xx_gcu_wait_free(priv);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * Get buffer from free list\n\t */\n\tspin_lock_irqsave(&priv->spinlock, flags);\n\tbuffer = priv->free;\n\tpriv->free = buffer->next;\n\tspin_unlock_irqrestore(&priv->spinlock, flags);\n\n\n\t/* Copy data from user into buffer */\n\tret = copy_from_user(buffer->ptr, buff, words * 4);\n\tif (ret) {\n\t\tspin_lock_irqsave(&priv->spinlock, flags);\n\t\tbuffer->next = priv->free;\n\t\tpriv->free = buffer;\n\t\tspin_unlock_irqrestore(&priv->spinlock, flags);\n\t\treturn -EFAULT;\n\t}\n\n\tbuffer->length = words;\n\n\t/* Append batch buffer end command */\n\tbuffer->ptr[words] = 0x01000000;\n\n\t/*\n\t * Add buffer to ready list\n\t */\n\tspin_lock_irqsave(&priv->spinlock, flags);\n\n\tbuffer->next = NULL;\n\n\tif (priv->ready) {\n\t\tBUG_ON(priv->ready_last == NULL);\n\n\t\tpriv->ready_last->next = buffer;\n\t} else\n\t\tpriv->ready = buffer;\n\n\tpriv->ready_last = buffer;\n\n\tif (!priv->shared->hw_running)\n\t\trun_ready(priv);\n\n\tspin_unlock_irqrestore(&priv->spinlock, flags);\n\n\treturn words * 4;\n}", "target": 1, "idx": 11359}
{"commit_id": "65000a7fd9eea62359e6d6714f17b94a99a82edd", "project": "radareorg/radare2", "func": "static grub_err_t\nfind_file (const char *currpath, grub_fshelp_node_t currroot,\n\t   grub_fshelp_node_t *currfound,\n\t   struct grub_fshelp_find_file_closure *c)\n{\n\tchar *fpath = grub_malloc (grub_strlen (currpath) + 1);\n  char *name = fpath;\n  char *next;\n  enum grub_fshelp_filetype type = GRUB_FSHELP_DIR;\n  grub_fshelp_node_t currnode = currroot;\n  grub_fshelp_node_t oldnode = currroot;\n\n  c->currroot = currroot;\n\n  grub_strncpy (fpath, currpath, grub_strlen (currpath) + 1);\n\n  /* Remove all leading slashes.  */\n  while (*name == '/')\n    name++;\n\n  if (! *name)\n    {\n      *currfound = currnode;\nfree (fpath);\n      return 0;\n    }\n\n  for (;;)\n    {\n      int found;\n      struct find_file_closure cc;\n\n      /* Extract the actual part from the pathname.  */\n      next = grub_strchr (name, '/');\n      if (next)\n\t{\n\t  /* Remove all leading slashes.  */\n\t  while (*next == '/')\n\t    *(next++) = '\\0';\n\t}\n\n      /* At this point it is expected that the current node is a\n\t directory, check if this is true.  */\n      if (type != GRUB_FSHELP_DIR)\n\t{\n\t  free_node (currnode, c);\nfree (fpath);\n\t  return grub_error (GRUB_ERR_BAD_FILE_TYPE, \"not a directory\");\n\t}\n\n      cc.name = name;\n      cc.type = &type;\n      cc.oldnode = &oldnode;\n      cc.currnode = &currnode;\n      /* Iterate over the directory.  */\n      found = c->iterate_dir (currnode, iterate, &cc);\n      if (! found)\n\t{\n\t  if (grub_errno) {\nfree (fpath);\n\t    return grub_errno;\n}\n\n\t  break;\n\t}\n\n      /* Read in the symlink and follow it.  */\n      if (type == GRUB_FSHELP_SYMLINK)\n\t{\n\t  char *symlink;\n\n\t  /* Test if the symlink does not loop.  */\n\t  if (++(c->symlinknest) == 8)\n\t    {\n\t      free_node (currnode, c);\n\t      free_node (oldnode, c);\nfree (fpath);\n\t      return grub_error (GRUB_ERR_SYMLINK_LOOP,\n\t\t\t\t \"too deep nesting of symlinks\");\n\t    }\n\n\t  symlink = c->read_symlink (currnode);\n\t  free_node (currnode, c);\n\n\t  if (!symlink)\n\t    {\n\t      free_node (oldnode, c);\nfree (fpath);\n\t      return grub_errno;\n\t    }\n\n\t  /* The symlink is an absolute path, go back to the root inode.  */\n\t  if (symlink[0] == '/')\n\t    {\n\t      free_node (oldnode, c);\n\t      oldnode = c->rootnode;\n\t    }\n\n\t  /* Lookup the node the symlink points to.  */\n\t  find_file (symlink, oldnode, &currnode, c);\n\t  type = c->foundtype;\n\t  grub_free (symlink);\n\n\t  if (grub_errno)\n\t    {\n\t      free_node (oldnode, c);\nfree (fpath);\n\t      return grub_errno;\n\t    }\n\t}\n\n      free_node (oldnode, c);\n\n      /* Found the node!  */\n      if (! next || *next == '\\0')\n\t{\n\t  *currfound = currnode;\n\t  c->foundtype = type;\nfree (fpath);\n\t  return 0;\n\t}\n\n      name = next;\n    }\n\nfree (fpath);\n  return grub_error (GRUB_ERR_FILE_NOT_FOUND, \"file not found\");\n}", "target": 2, "idx": 11360}
{"commit_id": "47a26a32c9a2cd630c48517c3e6ab2fa5f6a26ad", "project": "gpac", "func": "GF_Err gf_bifs_dec_proto_list(GF_BifsDecoder * codec, GF_BitStream *bs, GF_List *proto_list)\n{\n\tu8 flag, field_type, event_type, useQuant, useAnim, f;\n\tu32 i, NbRoutes, ID, numProtos, numFields, count, qpsftype, QP_Type, NumBits;\n\tGF_Node *node;\n\tchar name[1000];\n\tGF_ProtoFieldInterface *proto_field;\n\tGF_Proto *proto, *ParentProto;\n\tGF_Err e;\n\tu32 hasMinMax;\n\tvoid *qp_min_value, *qp_max_value;\n\tGF_SceneGraph *rootSG;\n\tGF_FieldInfo field;\n\n\tNumBits = qpsftype = 0;\n\t//store proto at codec level\n\trootSG = codec->current_graph;\n\tParentProto = codec->pCurrentProto;\n\te = GF_OK;\n\n\tnumProtos = 0;\n\tproto = NULL;\n\tflag = gf_bs_read_int(bs, 1);\n\twhile (flag) {\n\n\t\tif (!codec->info->config.ProtoIDBits) return GF_NON_COMPLIANT_BITSTREAM;\n\n\t\t/*1- proto interface declaration*/\n\t\tID = gf_bs_read_int(bs, codec->info->config.ProtoIDBits);\n\n\t\tif (codec->UseName) {\n\t\t\tgf_bifs_dec_name(bs, name, 1000);\n\t\t} else {\n\t\t\tsprintf(name, \"Proto%d\", gf_list_count(codec->current_graph->protos) );\n\t\t}\n\t\t/*create a proto in the current graph*/\n\t\tproto = gf_sg_proto_new(codec->current_graph, ID, name, proto_list ? GF_TRUE : GF_FALSE);\n\t\tif (!proto) {\n\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\tgoto exit;\n\t\t}\n\t\tif (proto_list) gf_list_add(proto_list, proto);\n\n\t\t/*during parsing, this proto is the current active one - all nodes/proto defined/declared\n\t\tbelow it will belong to its namespace*/\n\t\tcodec->current_graph = gf_sg_proto_get_graph(proto);\n\t\tcodec->pCurrentProto = proto;\n\n\t\tnumFields = 0;\n\t\tflag = gf_bs_read_int(bs, 1);\n\t\twhile (flag) {\n\t\t\tevent_type = gf_bs_read_int(bs, 2);\n\t\t\tfield_type = gf_bs_read_int(bs, 6);\n\n\t\t\tif (codec->UseName) {\n\t\t\t\tgf_bifs_dec_name(bs, name, 1000);\n\t\t\t} else {\n\t\t\t\tsprintf(name, \"_field%d\", numFields);\n\t\t\t}\n\n\t\t\t/*create field interface*/\n\t\t\tproto_field = gf_sg_proto_field_new(proto, field_type, event_type, name);\n\n\t\t\t/*get field info */\n\t\t\tgf_sg_proto_field_get_field(proto_field, &field);\n\n\t\t\tswitch (event_type) {\n\t\t\tcase GF_SG_EVENT_EXPOSED_FIELD:\n\t\t\tcase GF_SG_EVENT_FIELD:\n\t\t\t\t/*parse default value except nodes ...*/\n\t\t\t\tif (gf_sg_vrml_is_sf_field(field_type)) {\n\t\t\t\t\te = gf_bifs_dec_sf_field(codec, bs, NULL, &field, GF_FALSE);\n\t\t\t\t} else {\n\t\t\t\t\tif (codec->info->config.UsePredictiveMFField) {\n\t\t\t\t\t\tf = gf_bs_read_int(bs, 1);\n\t\t\t\t\t\t/*predictive encoding of proto field is not possible since QP info is not present yet*/\n\t\t\t\t\t\tassert(!f);\n\t\t\t\t\t}\n\t\t\t\t\t/*reserved*/\n\t\t\t\t\tf = gf_bs_read_int(bs, 1);\n\t\t\t\t\tif (!f) {\n\t\t\t\t\t\tif (gf_bs_read_int(bs, 1)) {\n\t\t\t\t\t\t\te = BD_DecMFFieldList(codec, bs, NULL, &field);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\te = BD_DecMFFieldVec(codec, bs, NULL, &field);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (e) goto exit;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tflag = gf_bs_read_int(bs, 1);\n\t\t\tnumFields++;\n\t\t}\n\n\t\t/*2- parse proto code*/\n\t\tflag = gf_bs_read_int(bs, 1);\n\n\t\t/*externProto*/\n\t\tif (flag) {\n\t\t\tmemset(&field, 0, sizeof(GF_FieldInfo));\n\t\t\tfield.far_ptr = gf_sg_proto_get_extern_url(proto);\n\t\t\tfield.fieldType = GF_SG_VRML_MFURL;\n\t\t\tfield.name = \"ExternProto\";\n\n\t\t\tif (codec->info->config.UsePredictiveMFField) {\n\t\t\t\tflag = gf_bs_read_int(bs, 1);\n\t\t\t\tassert(!flag);\n\t\t\t}\n\t\t\t/*reserved*/\n\t\t\tgf_bs_read_int(bs, 1);\n\n\t\t\t/*list or vector*/\n\t\t\tflag = gf_bs_read_int(bs, 1);\n\t\t\tif (flag) {\n\t\t\t\te = BD_DecMFFieldList(codec, bs, NULL, &field);\n\t\t\t} else {\n\t\t\t\te = BD_DecMFFieldVec(codec, bs, NULL, &field);\n\t\t\t}\n\t\t\tif (e) goto exit;\n\t\t}\n\t\t/*get proto code*/\n\t\telse {\n\t\t\t/*parse sub-proto list - subprotos are ALWAYS registered with parent proto graph*/\n\t\t\te = gf_bifs_dec_proto_list(codec, bs, NULL);\n\t\t\tif (e) goto exit;\n\n\t\t\tflag = 1;\n\n\t\t\twhile (flag) {\n\t\t\t\t/*parse all nodes in SFWorldNode table*/\n\t\t\t\tnode = gf_bifs_dec_node(codec, bs, NDT_SFWorldNode);\n\t\t\t\tif (!node) {\n\t\t\t\t\tif (codec->LastError) {\n\t\t\t\t\t\te = codec->LastError;\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tflag = gf_bs_read_int(bs, 1);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\te = gf_node_register(node, NULL);\n\t\t\t\tif (e) goto exit;\n\n\t\t\t\t//Ivica patch - Flush immediately because of proto instantiation\n\t\t\t\tgf_bifs_flush_command_list(codec);\n\n\t\t\t\tgf_sg_proto_add_node_code(proto, node);\n\t\t\t\tflag = gf_bs_read_int(bs, 1);\n\t\t\t}\n\n\t\t\t/*routes*/\n\t\t\tflag = gf_bs_read_int(bs, 1);\n\t\t\tif (flag) {\n\t\t\t\tflag = gf_bs_read_int(bs, 1);\n\t\t\t\tif (flag) {\n\t\t\t\t\t/*list route*/\n\t\t\t\t\twhile (flag) {\n\t\t\t\t\t\te = gf_bifs_dec_route(codec, bs, GF_FALSE);\n\t\t\t\t\t\tif (e) goto exit;\n\t\t\t\t\t\tflag = gf_bs_read_int(bs, 1);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/*vector*/\n\t\t\t\t\ti = gf_bs_read_int(bs, 5);\n\t\t\t\t\tNbRoutes = gf_bs_read_int(bs, i);\n\t\t\t\t\tfor (i=0; i<NbRoutes; i++) {\n\t\t\t\t\t\te = gf_bifs_dec_route(codec, bs, GF_FALSE);\n\t\t\t\t\t\tif (e) goto exit;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*restore the namespace*/\n\t\tcodec->current_graph = rootSG;\n\n\t\t/*3- parse anim and Quantization stuff*/\n\t\tuseQuant = gf_bs_read_int(bs, 1);\n\t\tuseAnim = gf_bs_read_int(bs, 1);\n\n\t\tcount = gf_sg_proto_get_field_count(proto);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tproto_field = gf_sg_proto_field_find(proto, i);\n\t\t\tgf_sg_proto_field_get_field(proto_field, &field);\n\n\t\t\t/*quant*/\n\t\t\tif (useQuant && ( (field.eventType == GF_SG_EVENT_FIELD) || (field.eventType == GF_SG_EVENT_EXPOSED_FIELD) )) {\n\t\t\t\tQP_Type = gf_bs_read_int(bs, 4);\n\n\t\t\t\tif (QP_Type==QC_LINEAR_SCALAR) {\n\t\t\t\t\tNumBits = gf_bs_read_int(bs, 5);\n\t\t\t\t}\n\t\t\t\thasMinMax = gf_bs_read_int(bs, 1);\n\t\t\t\tqp_min_value = qp_max_value = NULL;\n\t\t\t\tif (hasMinMax) {\n\t\t\t\t\t/*parse min and max*/\n\t\t\t\t\tqpsftype = gf_sg_vrml_get_sf_type(field.fieldType);\n\t\t\t\t\tswitch (qpsftype) {\n\t\t\t\t\tcase GF_SG_VRML_SFINT32:\n\t\t\t\t\tcase GF_SG_VRML_SFTIME:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t/*other fields are of elementary type SFFloat or shouldn't have min/max*/\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tqpsftype = GF_SG_VRML_SFFLOAT;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfield.fieldType = qpsftype;\n\n\t\t\t\t\tqp_min_value = gf_sg_vrml_field_pointer_new(qpsftype);\n\t\t\t\t\tfield.name = \"QPMinValue\";\n\t\t\t\t\tfield.far_ptr = qp_min_value;\n\t\t\t\t\tgf_bifs_dec_sf_field(codec, bs, NULL, &field, GF_FALSE);\n\n\t\t\t\t\tqp_max_value = gf_sg_vrml_field_pointer_new(qpsftype);\n\t\t\t\t\tfield.name = \"QPMaxValue\";\n\t\t\t\t\tfield.far_ptr = qp_max_value;\n\t\t\t\t\tgf_bifs_dec_sf_field(codec, bs, NULL, &field, GF_FALSE);\n\t\t\t\t}\n\n\t\t\t\t/*and store*/\n\t\t\t\tif (QP_Type) {\n\t\t\t\t\te = gf_bifs_proto_field_set_aq_info(proto_field, QP_Type, hasMinMax, qpsftype, qp_min_value, qp_max_value, NumBits);\n\t\t\t\t\tgf_sg_vrml_field_pointer_del(qp_min_value, qpsftype);\n\t\t\t\t\tgf_sg_vrml_field_pointer_del(qp_max_value, qpsftype);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*anim - not supported yet*/\n\t\t\tif (useAnim && ( (field.eventType == GF_SG_EVENT_IN) || (field.eventType == GF_SG_EVENT_EXPOSED_FIELD) )) {\n\t\t\t\tflag = gf_bs_read_int(bs, 1);\n\t\t\t\tif (flag) {\n\t\t\t\t\t/*Anim_Type = */gf_bs_read_int(bs, 4);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tnumProtos ++;\n\n\t\t/*4- get next proto*/\n\t\tflag = gf_bs_read_int(bs, 1);\n\t}\n\nexit:\n\tif (e) {\n\t\tif (proto) {\n\t\t\tif (proto_list) gf_list_del_item(proto_list, proto);\n\t\t\tgf_sg_proto_del(proto);\n\t\t}\n\t\tcodec->current_graph = rootSG;\n\t}\n\t/*restore original parent proto at codec level*/\n\tcodec->pCurrentProto = ParentProto;\n\treturn e;\n}", "target": 1, "idx": 11361}
{"commit_id": "36cf2a37132c7f01fa9adb5f95f5312b27742fd4", "project": "qemu", "func": "void virtqueue_map_sg(struct iovec *sg, hwaddr *addr,\n    size_t num_sg, int is_write)\n{\n    unsigned int i;\n    hwaddr len;\n\n    if (num_sg >= VIRTQUEUE_MAX_SIZE) {\n        error_report(\"virtio: map attempt out of bounds: %zd > %d\",\n                     num_sg, VIRTQUEUE_MAX_SIZE);\n        exit(1);\n    }\n\n    for (i = 0; i < num_sg; i++) {\n        len = sg[i].iov_len;\n        sg[i].iov_base = cpu_physical_memory_map(addr[i], &len, is_write);\n        if (sg[i].iov_base == NULL || len != sg[i].iov_len) {\n            error_report(\"virtio: trying to map MMIO memory\");\n            exit(1);\n        }\n    }\n}", "target": 2, "idx": 11362}
{"commit_id": "13dad7d5ef74ca2e6fe4010f5b03eb12e9bbe0ec", "project": "gpac", "func": "static GF_Err av1dmx_parse_flush_sample(GF_Filter *filter, GF_AV1DmxCtx *ctx)\n{\n\tu32 pck_size;\n\tGF_FilterPacket *pck;\n\tu8 *output;\n\n\tif (!ctx->opid)\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\n\tgf_bs_get_content_no_truncate(ctx->state.bs, &ctx->state.frame_obus, &pck_size, &ctx->state.frame_obus_alloc);\n\n\tif (!pck_size) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1Dmx] no frame OBU, skipping OBU\\n\"));\n\t\treturn GF_OK;\n\t}\n\n\tpck = gf_filter_pck_new_alloc(ctx->opid, pck_size, &output);\n\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, pck);\n\n\tgf_filter_pck_set_cts(pck, ctx->cts);\n\tgf_filter_pck_set_sap(pck, ctx->state.frame_state.key_frame ? GF_FILTER_SAP_1 : 0);\n\n\tmemcpy(output, ctx->state.frame_obus, pck_size);\n\n\tif (ctx->deps) {\n\t\tu8 flags = 0;\n\t\t//dependsOn\n\t\tflags = ( ctx->state.frame_state.key_frame) ? 2 : 1;\n\t\tflags <<= 2;\n\t\t//dependedOn\n\t \tflags |= ctx->state.frame_state.refresh_frame_flags ? 1 : 2;\n\t\tflags <<= 2;\n\t\t//hasRedundant\n\t \t//flags |= ctx->has_redundant ? 1 : 2;\n\t \tgf_filter_pck_set_dependency_flags(pck, flags);\n\t}\n\n\tgf_filter_pck_send(pck);\n\n\tav1dmx_update_cts(ctx);\n\tgf_av1_reset_state(&ctx->state, GF_FALSE);\n\n\treturn GF_OK;\n\n}", "target": 1, "idx": 11363}
{"commit_id": "93bc623489bdcfc7e9127614fcfb3258edf3f0f9", "project": "chromium", "func": "v8::Local<v8::Value> V8Debugger::functionLocation(v8::Local<v8::Context> context, v8::Local<v8::Function> function)\n{\n    int scriptId = function->ScriptId();\n    if (scriptId == v8::UnboundScript::kNoScriptId)\n        return v8::Null(m_isolate);\n    int lineNumber = function->GetScriptLineNumber();\n    int columnNumber = function->GetScriptColumnNumber();\n    if (lineNumber == v8::Function::kLineOffsetNotFound || columnNumber == v8::Function::kLineOffsetNotFound)\n        return v8::Null(m_isolate);\n    v8::Local<v8::Object> location = v8::Object::New(m_isolate);\n    if (!location->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))\n        return v8::Null(m_isolate);\n    if (!location->Set(context, toV8StringInternalized(m_isolate, \"scriptId\"), toV8String(m_isolate, String16::fromInteger(scriptId))).FromMaybe(false))\n        return v8::Null(m_isolate);\n    if (!location->Set(context, toV8StringInternalized(m_isolate, \"lineNumber\"), v8::Integer::New(m_isolate, lineNumber)).FromMaybe(false))\n        return v8::Null(m_isolate);\n    if (!location->Set(context, toV8StringInternalized(m_isolate, \"columnNumber\"), v8::Integer::New(m_isolate, columnNumber)).FromMaybe(false))\n        return v8::Null(m_isolate);\n    if (!markAsInternal(context, location, V8InternalValueType::kLocation))\n        return v8::Null(m_isolate);\n    return location;\n}", "target": 1, "idx": 11364}
{"commit_id": "f94b47c6bde624d6c07f43054087607c52054a95", "project": "torvalds/linux", "func": "int rtw_alloc_hwxmits(struct adapter *padapter)\n{\n\tstruct hw_xmit *hwxmits;\n\tstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\n\n\tpxmitpriv->hwxmit_entry = HWXMIT_ENTRY;\n\n\tpxmitpriv->hwxmits = kzalloc(sizeof(struct hw_xmit) * pxmitpriv->hwxmit_entry, GFP_KERNEL);\n\tif (!pxmitpriv->hwxmits)\n\t\treturn -ENOMEM;\n\n\thwxmits = pxmitpriv->hwxmits;\n\n\tif (pxmitpriv->hwxmit_entry == 5) {\n\t\thwxmits[0] .sta_queue = &pxmitpriv->bm_pending;\n\t\thwxmits[1] .sta_queue = &pxmitpriv->vo_pending;\n\t\thwxmits[2] .sta_queue = &pxmitpriv->vi_pending;\n\t\thwxmits[3] .sta_queue = &pxmitpriv->bk_pending;\n\t\thwxmits[4] .sta_queue = &pxmitpriv->be_pending;\n\t} else if (pxmitpriv->hwxmit_entry == 4) {\n\t\thwxmits[0] .sta_queue = &pxmitpriv->vo_pending;\n\t\thwxmits[1] .sta_queue = &pxmitpriv->vi_pending;\n\t\thwxmits[2] .sta_queue = &pxmitpriv->be_pending;\n\t\thwxmits[3] .sta_queue = &pxmitpriv->bk_pending;\n\t} else {\n\t}\n\n\treturn 0;\n}", "target": 1, "idx": 11365}
{"commit_id": "29870c8fe95e4e8a672f6f28c5fbe692bea09e9c", "project": "varnish/Varnish-Cache", "func": "uint16_t\nhttp_DissectRequest(struct sess *sp)\n{\n\tstruct http_conn *htc;\n\tstruct http *hp;\n\tuint16_t retval;\n\n\tCHECK_OBJ_NOTNULL(sp, SESS_MAGIC);\n\thtc = sp->htc;\n\tCHECK_OBJ_NOTNULL(htc, HTTP_CONN_MAGIC);\n\thp = sp->http;\n\tCHECK_OBJ_NOTNULL(hp, HTTP_MAGIC);\n\n\thp->logtag = HTTP_Rx;\n\n\tretval = http_splitline(sp->wrk, sp->fd, hp, htc,\n\t    HTTP_HDR_REQ, HTTP_HDR_URL, HTTP_HDR_PROTO);\n\tif (retval != 0) {\n\t\tWSPR(sp, SLT_HttpGarbage, htc->rxbuf);\n\t\treturn (retval);\n\t}\n\thttp_ProtoVer(hp);\n\n\tretval = htc_request_check_hdrs(sp, hp);\n\treturn (retval);\n}", "target": 2, "idx": 11366}
{"commit_id": "5b9fbeb75b6a98955f628e205ac26689bcb1383e", "project": "torvalds/linux", "func": "static void scalar32_min_max_or(struct bpf_reg_state *dst_reg,\n\t\t\t\tstruct bpf_reg_state *src_reg)\n{\n\tbool src_known = tnum_subreg_is_const(src_reg->var_off);\n\tbool dst_known = tnum_subreg_is_const(dst_reg->var_off);\n\tstruct tnum var32_off = tnum_subreg(dst_reg->var_off);\n\ts32 smin_val = src_reg->s32_min_value;\n\tu32 umin_val = src_reg->u32_min_value;\n\n\t/* Assuming scalar64_min_max_or will be called so it is safe\n\t * to skip updating register for known case.\n\t */\n\tif (src_known && dst_known)\n\t\treturn;\n\n\t/* We get our maximum from the var_off, and our minimum is the\n\t * maximum of the operands' minima\n\t */\n\tdst_reg->u32_min_value = max(dst_reg->u32_min_value, umin_val);\n\tdst_reg->u32_max_value = var32_off.value | var32_off.mask;\n\tif (dst_reg->s32_min_value < 0 || smin_val < 0) {\n\t\t/* Lose signed bounds when ORing negative numbers,\n\t\t * ain't nobody got time for that.\n\t\t */\n\t\tdst_reg->s32_min_value = S32_MIN;\n\t\tdst_reg->s32_max_value = S32_MAX;\n\t} else {\n\t\t/* ORing two positives gives a positive, so safe to\n\t\t * cast result into s64.\n\t\t */\n\t\tdst_reg->s32_min_value = dst_reg->u32_min_value;\n\t\tdst_reg->s32_max_value = dst_reg->u32_max_value;\n\t}\n}", "target": 1, "idx": 11367}
{"commit_id": "a3337563c705bc8e0cf32f910b3e9e3c43d962ff", "project": "barebox", "func": "static int check_passwd(unsigned char *passwd, size_t length)\n{\n\tstruct digest *d = NULL;\n\tunsigned char *passwd1_sum;\n\tunsigned char *passwd2_sum;\n\tint ret = 0;\n\tint hash_len;\n\n\tif (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) {\n\t\thash_len = PBKDF2_LENGTH;\n\t} else {\n\t\td = digest_alloc(PASSWD_SUM);\n\t\tif (!d) {\n\t\t\tpr_err(\"No such digest: %s\\n\",\n\t\t\t       PASSWD_SUM ? PASSWD_SUM : \"NULL\");\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\thash_len = digest_length(d);\n\t}\n\n\tpasswd1_sum = calloc(hash_len * 2, sizeof(unsigned char));\n\tif (!passwd1_sum)\n\t\treturn -ENOMEM;\n\n\tpasswd2_sum = passwd1_sum + hash_len;\n\n\tif (is_passwd_env_enable())\n\t\tret = read_env_passwd(passwd2_sum, hash_len);\n\telse if (is_passwd_default_enable())\n\t\tret = read_default_passwd(passwd2_sum, hash_len);\n\telse\n\t\tret = -EINVAL;\n\n\tif (ret < 0)\n\t\tgoto err;\n\n\tif (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) {\n\t\tchar *key = passwd2_sum + PBKDF2_SALT_LEN;\n\t\tchar *salt = passwd2_sum;\n\t\tint keylen = PBKDF2_LENGTH - PBKDF2_SALT_LEN;\n\n\t\tret = pkcs5_pbkdf2_hmac_sha1(passwd, length, salt,\n\t\t\tPBKDF2_SALT_LEN, PBKDF2_COUNT, keylen, passwd1_sum);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tif (!crypto_memneq(passwd1_sum, key, keylen))\n\t\t\tret = 1;\n\t} else {\n\t\tret = digest_digest(d, passwd, length, passwd1_sum);\n\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tif (!crypto_memneq(passwd1_sum, passwd2_sum, hash_len))\n\t\t\tret = 1;\n\t}\n\nerr:\n\tfree(passwd1_sum);\n\tdigest_free(d);\n\n\treturn ret;\n}", "target": 2, "idx": 11368}
{"commit_id": "a2dff1b59ea8c8ec10680f9e8e5593e4b38554a1", "project": "sass/libsass", "func": "utf_error validate_next(octet_iterator& it, octet_iterator end, uint32_t& code_point)\n    {\n        if (it == end)\n            return NOT_ENOUGH_ROOM;\n\n        // Save the original value of it so we can go back in case of failure\n        // Of course, it does not make much sense with i.e. stream iterators\n        octet_iterator original_it = it;\n\n        uint32_t cp = 0;\n        // Determine the sequence length based on the lead octet\n        typedef typename std::iterator_traits<octet_iterator>::difference_type octet_difference_type;\n        const octet_difference_type length = utf8::internal::sequence_length(it);\n\n        // Get trail octets and calculate the code point\n        utf_error err = UTF8_OK;\n        switch (length) {\n            case 0:\n                return INVALID_LEAD;\n            case 1:\n                err = utf8::internal::get_sequence_1(it, end, cp);\n                break;\n            case 2:\n                err = utf8::internal::get_sequence_2(it, end, cp);\n            break;\n            case 3:\n                err = utf8::internal::get_sequence_3(it, end, cp);\n            break;\n            case 4:\n                err = utf8::internal::get_sequence_4(it, end, cp);\n            break;\n        }\n\n        if (err == UTF8_OK) {\n            // Decoding succeeded. Now, security checks...\n            if (utf8::internal::is_code_point_valid(cp)) {\n                if (!utf8::internal::is_overlong_sequence(cp, length)){\n                    // Passed! Return here.\n                    code_point = cp;\n                    ++it;\n                    return UTF8_OK;\n                }\n                else\n                    err = OVERLONG_SEQUENCE;\n            }\n            else\n                err = INVALID_CODE_POINT;\n        }\n\n        // Failure branch - restore the original value of the iterator\n        it = original_it;\n        return err;\n    }", "target": 1, "idx": 11369}
{"commit_id": "97eff7eb57fc2320c267a949cffd622c38712484", "project": "php/php-src", "func": "static void array_cleanup( char* arr[] , int arr_size)\n{\n\tint i=0;\n\tfor( i=0; i< arr_size; i++ ){\n\t\tif( arr[i*2] ){\n\t\t\tefree( arr[i*2]);\n\t\t}\n\t}\n\tefree(arr);\n}", "target": 2, "idx": 11370}
{"commit_id": "8d385b247bca40ece40c9279391054bc98934325", "project": "xen-project/xen", "func": "int evtchn_reset(struct domain *d)\n{\n    unsigned int i;\n    int rc = 0;\n\n    if ( d != current->domain && !d->controller_pause_count )\n        return -EINVAL;\n\n    for ( i = 0; port_is_valid(d, i); i++ )\n        evtchn_close(d, i, 1);\n\n    spin_lock(&d->event_lock);\n\n    if ( d->active_evtchns > d->xen_evtchns )\n        rc = -EAGAIN;\n    else if ( d->evtchn_fifo )\n    {\n        /* Switching back to 2-level ABI. */\n        evtchn_fifo_destroy(d);\n        evtchn_2l_init(d);\n    }\n\n    spin_unlock(&d->event_lock);\n\n    return rc;\n}", "target": 2, "idx": 11371}
{"commit_id": "b90cd6f2b905905fb42671009dc0e27c310a16ae", "project": "torvalds/linux", "func": "static void smp_task_done(struct sas_task *task)\n{\n\tdel_timer(&task->slow_task->timer);\n\tcomplete(&task->slow_task->completion);\n}", "target": 2, "idx": 11372}
{"commit_id": "015c9bc58d5ebf733060e6b23f54bfb143155f9d", "project": "apache/trafficserver", "func": "OverridableHttpConfigParams()\n    : maintain_pristine_host_hdr(1),\n      chunking_enabled(1),\n      negative_caching_enabled(0),\n      negative_revalidating_enabled(0),\n      cache_when_to_revalidate(0),\n      keep_alive_enabled_in(1),\n      keep_alive_enabled_out(1),\n      keep_alive_post_out(1),\n      server_session_sharing_match(TS_SERVER_SESSION_SHARING_MATCH_BOTH),\n      auth_server_session_private(1),\n      fwd_proxy_auth_to_parent(0),\n      uncacheable_requests_bypass_parent(1),\n      attach_server_session_to_client(0),\n      forward_connect_method(0),\n      insert_age_in_response(1),\n      anonymize_remove_from(0),\n      anonymize_remove_referer(0),\n      anonymize_remove_user_agent(0),\n      anonymize_remove_cookie(0),\n      anonymize_remove_client_ip(0),\n      anonymize_insert_client_ip(1),\n      proxy_response_server_enabled(1),\n      proxy_response_hsts_include_subdomains(0),\n      insert_squid_x_forwarded_for(1),\n      insert_forwarded(HttpForwarded::OptionBitSet()),\n      send_http11_requests(1),\n      cache_http(1),\n      cache_ignore_client_no_cache(1),\n      cache_ignore_client_cc_max_age(0),\n      cache_ims_on_client_no_cache(1),\n      cache_ignore_server_no_cache(0),\n      cache_responses_to_cookies(1),\n      cache_ignore_auth(0),\n      cache_urls_that_look_dynamic(1),\n      cache_required_headers(2),\n      cache_range_lookup(1),\n      cache_range_write(0),\n      allow_multi_range(0),\n      cache_enable_default_vary_headers(0),\n      ignore_accept_mismatch(0),\n      ignore_accept_language_mismatch(0),\n      ignore_accept_encoding_mismatch(0),\n      ignore_accept_charset_mismatch(0),\n      insert_request_via_string(1),\n      insert_response_via_string(0),\n      doc_in_cache_skip_dns(1),\n      flow_control_enabled(0),\n      normalize_ae(0),\n      srv_enabled(0),\n      parent_failures_update_hostdb(0),\n      cache_open_write_fail_action(0),\n      post_check_content_length_enabled(1),\n      ssl_client_verify_server(0),\n      redirect_use_orig_cache_key(0),\n      number_of_redirections(0),\n      proxy_response_hsts_max_age(-1),\n      negative_caching_lifetime(1800),\n      negative_revalidating_lifetime(1800),\n      sock_recv_buffer_size_out(0),\n      sock_send_buffer_size_out(0),\n      sock_option_flag_out(0),\n      sock_packet_mark_out(0),\n      sock_packet_tos_out(0),\n      server_tcp_init_cwnd(0),\n      request_hdr_max_size(131072),\n      response_hdr_max_size(131072),\n      cache_heuristic_min_lifetime(3600),\n      cache_heuristic_max_lifetime(86400),\n      cache_guaranteed_min_lifetime(0),\n      cache_guaranteed_max_lifetime(31536000),\n      cache_max_stale_age(604800),\n      keep_alive_no_activity_timeout_in(120),\n      keep_alive_no_activity_timeout_out(120),\n      transaction_no_activity_timeout_in(30),\n      transaction_no_activity_timeout_out(30),\n      transaction_active_timeout_out(0),\n      transaction_active_timeout_in(900),\n      websocket_active_timeout(3600),\n      websocket_inactive_timeout(600),\n      origin_max_connections(0),\n      origin_max_connections_queue(0),\n      connect_attempts_max_retries(0),\n      connect_attempts_max_retries_dead_server(3),\n      connect_attempts_rr_retries(3),\n      connect_attempts_timeout(30),\n      post_connect_attempts_timeout(1800),\n      parent_connect_attempts(4),\n      parent_retry_time(300),\n      parent_fail_threshold(10),\n      per_parent_connect_attempts(2),\n      parent_connect_timeout(30),\n      down_server_timeout(300),\n      client_abort_threshold(10),\n      max_cache_open_read_retries(-1),\n      cache_open_read_retry_time(10),\n      cache_generation_number(-1),\n      max_cache_open_write_retries(1),\n      background_fill_active_timeout(60),\n      http_chunking_size(4096),\n      flow_high_water_mark(0),\n      flow_low_water_mark(0),\n      default_buffer_size_index(8),\n      default_buffer_water_mark(32768),\n      slow_log_threshold(0),\n      body_factory_template_base(NULL),\n      body_factory_template_base_len(0),\n      proxy_response_server_string(NULL),\n      proxy_response_server_string_len(0),\n      global_user_agent_header(NULL),\n      global_user_agent_header_size(0),\n      cache_heuristic_lm_factor(0.10),\n      background_fill_threshold(0.5),\n      client_cert_filename(NULL),\n      client_cert_filepath(NULL),\n      cache_vary_default_text(NULL),\n      cache_vary_default_images(NULL),\n      cache_vary_default_other(NULL)\n  {\n  }", "target": 1, "idx": 11373}
{"commit_id": "7a6f636db3360bb16d18078d51e8c596f31302a1", "project": "gpac", "func": "GF_Err Media_GetESD(GF_MediaBox *mdia, u32 sampleDescIndex, GF_ESD **out_esd, Bool true_desc_only)\n{\n\tu32 type;\n\tGF_ESD *esd;\n\tGF_MPEGSampleEntryBox *entry = NULL;\n\tGF_ESDBox *ESDa;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\tGF_SampleDescriptionBox *stsd = mdia->information->sampleTable->SampleDescription;\n\n\t*out_esd = NULL;\n\tif (!stsd || !stsd->child_boxes || !sampleDescIndex || (sampleDescIndex > gf_list_count(stsd->child_boxes)) )\n\t\treturn GF_BAD_PARAM;\n\n\tesd = NULL;\n\tentry = (GF_MPEGSampleEntryBox*)gf_list_get(stsd->child_boxes, sampleDescIndex - 1);\n\tif (! entry) return GF_ISOM_INVALID_MEDIA;\n\n\t*out_esd = NULL;\n\tESDa = NULL;\n\ttype = entry->type;\n\tswitch (type) {\n\tcase GF_ISOM_BOX_TYPE_ENCV:\n\tcase GF_ISOM_BOX_TYPE_ENCA:\n\tcase GF_ISOM_BOX_TYPE_ENCS:\n\tcase GF_ISOM_BOX_TYPE_ENCF:\n\tcase GF_ISOM_BOX_TYPE_ENCM:\n\tcase GF_ISOM_BOX_TYPE_ENCT:\n\t\tsinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\t\tif (sinf && sinf->original_format) {\n\t\t\ttype = sinf->original_format->data_format;\n\t\t}\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_RESV:\n\t\tsinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_RINF);\n\t\tif (sinf && sinf->original_format) {\n\t\t\ttype = sinf->original_format->data_format;\n\t\t}\n\t\tbreak;\n\t}\n\n\n\tswitch (type) {\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tESDa = ((GF_MPEGVisualSampleEntryBox*)entry)->esd;\n\t\tif (ESDa) esd = (GF_ESD *) ESDa->desc;\n\t\t/*avc1 encrypted*/\n\t\telse esd = ((GF_MPEGVisualSampleEntryBox*) entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_AVC1:\n\tcase GF_ISOM_BOX_TYPE_AVC2:\n\tcase GF_ISOM_BOX_TYPE_AVC3:\n\tcase GF_ISOM_BOX_TYPE_AVC4:\n\tcase GF_ISOM_BOX_TYPE_HVC1:\n\tcase GF_ISOM_BOX_TYPE_HEV1:\n\tcase GF_ISOM_BOX_TYPE_HVC2:\n\tcase GF_ISOM_BOX_TYPE_HEV2:\n\tcase GF_ISOM_BOX_TYPE_HVT1:\n\tcase GF_ISOM_BOX_TYPE_264B:\n\tcase GF_ISOM_BOX_TYPE_265B:\n\tcase GF_ISOM_BOX_TYPE_DVHE:\n\tcase GF_ISOM_BOX_TYPE_DVH1:\n\tcase GF_ISOM_BOX_TYPE_DVA1:\n\tcase GF_ISOM_BOX_TYPE_DVAV:\n\tcase GF_ISOM_BOX_TYPE_VVC1:\n\tcase GF_ISOM_BOX_TYPE_VVI1:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tesd = ((GF_MPEGVisualSampleEntryBox*) entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SVC1:\n\tcase GF_ISOM_BOX_TYPE_MVC1:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tif ((mdia->mediaTrack->extractor_mode & 0x0000FFFF) != GF_ISOM_NALU_EXTRACT_INSPECT)\n\t\t\tAVC_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*) entry, mdia);\n\t\telse\n\t\t\tAVC_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*) entry, NULL);\n\t\tesd = ((GF_MPEGVisualSampleEntryBox*) entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_LHE1:\n\tcase GF_ISOM_BOX_TYPE_LHV1:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tif ((mdia->mediaTrack->extractor_mode & 0x0000FFFF) != GF_ISOM_NALU_EXTRACT_INSPECT)\n\t\t\tHEVC_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*) entry, mdia);\n\t\telse\n\t\t\tHEVC_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*) entry, NULL);\n\t\tesd = ((GF_MPEGVisualSampleEntryBox*) entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DAV1:\n\tcase GF_ISOM_BOX_TYPE_AV01:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tAV1_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*)entry, mdia);\n\t\tesd = ((GF_MPEGVisualSampleEntryBox*)entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_VP08:\n\tcase GF_ISOM_BOX_TYPE_VP09:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tVP9_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*)entry, mdia);\n\t\tesd = ((GF_MPEGVisualSampleEntryBox*)entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n        {\n            GF_MPEGAudioSampleEntryBox *ase = (GF_MPEGAudioSampleEntryBox*)entry;\n            ESDa = ase->esd;\n            if (ESDa) {\n\t\t\t\tesd = (GF_ESD *) ESDa->desc;\n            } else if (!true_desc_only) {\n\t\t\t\tBool make_mp4a = GF_FALSE;\n\t\t\t\tsinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\n\t\t\t\tif (sinf && sinf->original_format) {\n\t\t\t\t\tif (sinf->original_format->data_format==GF_ISOM_BOX_TYPE_MP4A) {\n\t\t\t\t\t\tmake_mp4a = GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Assuming that if no ESD is provided the stream is Basic MPEG-4 AAC LC\n\t\t\t\t\tmake_mp4a = GF_TRUE;\n\t\t\t\t}\n\t\t\t\tif (make_mp4a) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\tGF_M4ADecSpecInfo aacinfo;\n\t\t\t\t\tmemset(&aacinfo, 0, sizeof(GF_M4ADecSpecInfo));\n\t\t\t\t\taacinfo.nb_chan = ase->channel_count;\n\t\t\t\t\taacinfo.base_object_type = GF_M4A_AAC_LC;\n\t\t\t\t\taacinfo.base_sr = ase->samplerate_hi;\n\t\t\t\t\t*out_esd = gf_odf_desc_esd_new(0);\n\t\t\t\t\t(*out_esd)->decoderConfig->streamType = GF_STREAM_AUDIO;\n\t\t\t\t\t(*out_esd)->decoderConfig->objectTypeIndication = GF_CODECID_AAC_MPEG4;\n\t\t\t\t\tgf_m4a_write_config(&aacinfo, &(*out_esd)->decoderConfig->decoderSpecificInfo->data, &(*out_esd)->decoderConfig->decoderSpecificInfo->dataLength);\n#else\n\t\t\t\t\treturn GF_NOT_SUPPORTED;\n#endif\n\t\t\t\t}\n            }\n        }\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\tif (entry->internal_type==GF_ISOM_SAMPLE_ENTRY_MP4S) {\n\t\t\tESDa = entry->esd;\n\t\t\tif (ESDa) esd = (GF_ESD *) ESDa->desc;\n\t\t}\n\t\tbreak;\n#ifndef GPAC_DISABLE_TTXT\n\tcase GF_ISOM_BOX_TYPE_TX3G:\n\tcase GF_ISOM_BOX_TYPE_TEXT:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_GENERIC)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\n\t\tif (!true_desc_only && mdia->mediaTrack->moov->mov->convert_streaming_text) {\n\t\t\tGF_Err e = gf_isom_get_ttxt_esd(mdia, out_esd);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n#endif\n#ifndef GPAC_DISABLE_VTT\n\tcase GF_ISOM_BOX_TYPE_WVTT:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_GENERIC)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t{\n\t\tGF_WebVTTSampleEntryBox*vtte = (GF_WebVTTSampleEntryBox*)entry;\n\t\tesd =  gf_odf_desc_esd_new(2);\n\t\t*out_esd = esd;\n\t\tesd->decoderConfig->streamType = GF_STREAM_TEXT;\n\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_WEBVTT;\n\t\tif (vtte->config) {\n\t\t\tesd->decoderConfig->decoderSpecificInfo->dataLength = (u32) strlen(vtte->config->string);\n\t\t\tesd->decoderConfig->decoderSpecificInfo->data = gf_malloc(sizeof(char)*esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\tmemcpy(esd->decoderConfig->decoderSpecificInfo->data, vtte->config->string, esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t}\n\t}\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STPP:\n\tcase GF_ISOM_BOX_TYPE_SBTT:\n\tcase GF_ISOM_BOX_TYPE_STXT:\n\t\tbreak;\n#endif\n\n\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tif (!true_desc_only) {\n\t\t\tGF_Err e = gf_isom_get_3gpp_audio_esd(mdia->information->sampleTable, type, (GF_GenericAudioSampleEntryBox*)entry, out_esd);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\t\t} else return GF_ISOM_INVALID_MEDIA;\n\n\tcase GF_ISOM_SUBTYPE_OPUS:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t{\n\t\tGF_OpusSpecificBox *opus_c;\n\t\tif (true_desc_only)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\n\t\topus_c = ((GF_MPEGAudioSampleEntryBox*)entry)->cfg_opus;\n\t\tif (!opus_c) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"ESD not found for Opus\\n)\"));\n\t\t\tbreak;\n\t\t}\n\t\t*out_esd = gf_odf_desc_esd_new(2);\n\t\t(*out_esd)->decoderConfig->streamType = GF_STREAM_AUDIO;\n\t\t(*out_esd)->decoderConfig->objectTypeIndication = GF_CODECID_OPUS;\n\t\tgf_odf_opus_cfg_write(&opus_c->opcfg, & (*out_esd)->decoderConfig->decoderSpecificInfo->data, & (*out_esd)->decoderConfig->decoderSpecificInfo->dataLength);\n\t\tbreak;\n\t}\n\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tif (true_desc_only) {\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\t} else {\n\t\t\tesd =  gf_odf_desc_esd_new(2);\n\t\t\t*out_esd = esd;\n\t\t\tesd->decoderConfig->streamType = GF_STREAM_VISUAL;\n\t\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_H263;\n\t\t\tbreak;\n\t\t}\n\n\tcase GF_ISOM_SUBTYPE_MP3:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tif (true_desc_only) {\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\t} else {\n\t\t\tesd =  gf_odf_desc_esd_new(2);\n\t\t\t*out_esd = esd;\n\t\t\tesd->decoderConfig->streamType = GF_STREAM_AUDIO;\n\t\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_MPEG_AUDIO;\n\t\t\tbreak;\n\t\t}\n\n\tcase GF_ISOM_SUBTYPE_LSR1:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_GENERIC)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tif (true_desc_only) {\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\t} else {\n\t\t\tGF_LASeRSampleEntryBox*ptr = (GF_LASeRSampleEntryBox*)entry;\n\t\t\tif (!ptr || !ptr->lsr_config || !ptr->lsr_config->hdr_size)\n\t\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\t\tesd =  gf_odf_desc_esd_new(2);\n\t\t\t*out_esd = esd;\n\t\t\tesd->decoderConfig->streamType = GF_STREAM_SCENE;\n\t\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_LASER;\n\t\t\tesd->decoderConfig->decoderSpecificInfo->dataLength = ptr->lsr_config->hdr_size;\n\t\t\tesd->decoderConfig->decoderSpecificInfo->data = gf_malloc(sizeof(char)*ptr->lsr_config->hdr_size);\n\t\t\tif (!esd->decoderConfig->decoderSpecificInfo->data) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(esd->decoderConfig->decoderSpecificInfo->data, ptr->lsr_config->hdr, sizeof(char)*ptr->lsr_config->hdr_size);\n\t\t\tbreak;\n\t\t}\n\tcase GF_ISOM_SUBTYPE_MH3D_MHA1:\n\tcase GF_ISOM_SUBTYPE_MH3D_MHA2:\n\tcase GF_ISOM_SUBTYPE_MH3D_MHM1:\n\tcase GF_ISOM_SUBTYPE_MH3D_MHM2:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\n\t\tif (true_desc_only) {\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\t} else {\n\t\t\tGF_MPEGAudioSampleEntryBox*ptr = (GF_MPEGAudioSampleEntryBox*)entry;\n\t\t\tesd = gf_odf_desc_esd_new(2);\n\t\t\t*out_esd = esd;\n\t\t\tesd->decoderConfig->streamType = GF_STREAM_AUDIO;\n\t\t\tif ((type==GF_ISOM_SUBTYPE_MH3D_MHA1) || (type==GF_ISOM_SUBTYPE_MH3D_MHA2))\n\t\t\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_MPHA;\n\t\t\telse\n\t\t\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_MHAS;\n\t\t\tif (ptr->cfg_mha) {\n\t\t\t\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\t\t\t\tgf_bs_write_u8(bs, ptr->cfg_mha->configuration_version);\n\t\t\t\tgf_bs_write_u8(bs, ptr->cfg_mha->mha_pl_indication);\n\t\t\t\tgf_bs_write_u8(bs, ptr->cfg_mha->reference_channel_layout);\n\t\t\t\tgf_bs_write_u16(bs, ptr->cfg_mha->mha_config ? ptr->cfg_mha->mha_config_size : 0);\n\t\t\t\tif (ptr->cfg_mha->mha_config && ptr->cfg_mha->mha_config_size)\n\t\t\t\t\tgf_bs_write_data(bs, ptr->cfg_mha->mha_config, ptr->cfg_mha->mha_config_size);\n\n\t\t\t\tgf_bs_get_content(bs, &esd->decoderConfig->decoderSpecificInfo->data, &esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\t\tgf_bs_del(bs);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn GF_ISOM_INVALID_MEDIA;\n\t}\n\n\tif (true_desc_only) {\n\t\tif (!esd) return GF_ISOM_INVALID_MEDIA;\n\t\t*out_esd = esd;\n\t\treturn GF_OK;\n\t} else {\n\t\tif (!esd && !*out_esd) return GF_ISOM_INVALID_MEDIA;\n\t\tif (*out_esd == NULL) return gf_odf_desc_copy((GF_Descriptor *)esd, (GF_Descriptor **)out_esd);\n\t}\n\treturn GF_OK;\n}", "target": 1, "idx": 11374}
{"commit_id": "7df22ab2fad6bf7cecf96465caede6401b9b451c", "project": "pcmacdon/jsish", "func": "static Jsi_RC StringConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (Jsi_FunctionIsConstructor(funcPtr)) {\n        const char *nv = \"\";\n        int len = -1;\n        if (Jsi_ValueGetLength(interp, args) > 0) {\n            Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n            if (v) {\n                \n                nv = Jsi_ValueToString(interp, v, &len);\n            }\n        }\n        if (_this->vt == JSI_VT_OBJECT && _this->d.obj->ot == JSI_OT_STRING) {\n            char *nstr = Jsi_StrdupLen(nv, len);\n            if (_this->d.obj->d.s.str)\n                if (!_this->d.obj->isstrkey)\n                    Jsi_Free(_this->d.obj->d.s.str);\n            _this->d.obj->isstrkey = 0;\n            _this->d.obj->d.s.str = nstr;\n            _this->d.obj->d.s.len = len;\n        } else\n            jsi_ValueMakeBlobDup(interp, &_this, (uchar*)nv, len);\n        Jsi_ValueDup2(interp, ret, _this);\n        return JSI_OK;\n    }\n    if (Jsi_ValueGetLength(interp, args) > 0) {\n        Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n        if (v) {\n            Jsi_ValueDup2(interp, ret, v);\n            Jsi_ValueToString(interp, *ret, NULL);\n            return JSI_OK;\n        }\n    }\n    Jsi_ValueMakeStringDup(interp, ret, \"\");\n    return JSI_OK;\n}", "target": 1, "idx": 11375}
{"commit_id": "8f8c04bf1ebbd2f72f1643e7ad9617dafa6e5409", "project": "u-boot", "func": "static uint get_alen(char *arg, uint default_len)\n{\n\tuint\tj;\n\tuint\talen;\n\n\talen = default_len;\n\tfor (j = 0; j < 8; j++) {\n\t\tif (arg[j] == '.') {\n\t\t\talen = arg[j+1] - '0';\n\t\t\tbreak;\n\t\t} else if (arg[j] == '\\0')\n\t\t\tbreak;\n\t}\n\treturn alen;\n}", "target": 3, "idx": 11376}
{"commit_id": "97c62c6167299028d80765080e74d91dfc99efbd", "project": "gssapi/gss-ntlmssp", "func": "static int ntlm_decode_field(struct wire_field_hdr *hdr,\n                             struct ntlm_buffer *buffer,\n                             size_t payload_offs,\n                             struct ntlm_buffer *field)\n{\n    struct ntlm_buffer b = { NULL, 0 };\n    uint32_t offs;\n    uint16_t len;\n\n    len = le16toh(hdr->len);\n    if (len == 0) goto done;\n\n    offs = le32toh(hdr->offset);\n    if ((offs < payload_offs) ||\n        (offs > buffer->length) ||\n        (UINT32_MAX - offs < len) ||\n        (offs + len > buffer->length)) {\n        return ERR_DECODE;\n    }\n\n    b.data = malloc(len);\n    if (!b.data) return ENOMEM;\n\n    b.length = len;\n    memcpy(b.data, &buffer->data[offs], b.length);\n\ndone:\n    *field = b;\n    return 0;\n}", "target": 1, "idx": 11377}
{"commit_id": "39b0f07dd960f34e7e6bf230ffc3d87c41ef0f2e", "project": "ArtifexSoftware/mupdf", "func": "static void\npdf_load_mesh_params(fz_context *ctx, pdf_document *doc, fz_shade *shade, pdf_obj *dict)\n{\n\tpdf_obj *obj;\n\tint i, n;\n\n\tshade->u.m.x0 = shade->u.m.y0 = 0;\n\tshade->u.m.x1 = shade->u.m.y1 = 1;\n\tfor (i = 0; i < FZ_MAX_COLORS; i++)\n\t{\n\t\tshade->u.m.c0[i] = 0;\n\t\tshade->u.m.c1[i] = 1;\n\t}\n\n\tshade->u.m.vprow = pdf_to_int(ctx, pdf_dict_get(ctx, dict, PDF_NAME_VerticesPerRow));\n\tshade->u.m.bpflag = pdf_to_int(ctx, pdf_dict_get(ctx, dict, PDF_NAME_BitsPerFlag));\n\tshade->u.m.bpcoord = pdf_to_int(ctx, pdf_dict_get(ctx, dict, PDF_NAME_BitsPerCoordinate));\n\tshade->u.m.bpcomp = pdf_to_int(ctx, pdf_dict_get(ctx, dict, PDF_NAME_BitsPerComponent));\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_Decode);\n\tif (pdf_array_len(ctx, obj) >= 6)\n\t{\n\t\tn = fz_mini(FZ_MAX_COLORS, (pdf_array_len(ctx, obj) - 4) / 2);\n\t\tshade->u.m.x0 = pdf_to_real(ctx, pdf_array_get(ctx, obj, 0));\n\t\tshade->u.m.x1 = pdf_to_real(ctx, pdf_array_get(ctx, obj, 1));\n\t\tshade->u.m.y0 = pdf_to_real(ctx, pdf_array_get(ctx, obj, 2));\n\t\tshade->u.m.y1 = pdf_to_real(ctx, pdf_array_get(ctx, obj, 3));\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tshade->u.m.c0[i] = pdf_to_real(ctx, pdf_array_get(ctx, obj, 4 + i * 2));\n\t\t\tshade->u.m.c1[i] = pdf_to_real(ctx, pdf_array_get(ctx, obj, 5 + i * 2));\n\t\t}\n\t}\n\n\tif (shade->u.m.vprow < 2 && shade->type == 5)\n\t{\n\t\tfz_warn(ctx, \"Too few vertices per row (%d)\", shade->u.m.vprow);\n\t\tshade->u.m.vprow = 2;\n\t}\n\n\tif (shade->u.m.bpflag != 2 && shade->u.m.bpflag != 4 && shade->u.m.bpflag != 8 &&\n\t\tshade->type != 5)\n\t{\n\t\tfz_warn(ctx, \"Invalid number of bits per flag (%d)\", shade->u.m.bpflag);\n\t\tshade->u.m.bpflag = 8;\n\t}\n\n\tif (shade->u.m.bpcoord != 1 && shade->u.m.bpcoord != 2 && shade->u.m.bpcoord != 4 &&\n\t\tshade->u.m.bpcoord != 8 && shade->u.m.bpcoord != 12 && shade->u.m.bpcoord != 16 &&\n\t\tshade->u.m.bpcoord != 24 && shade->u.m.bpcoord != 32)\n\t{\n\t\tfz_warn(ctx, \"Invalid number of bits per coordinate (%d)\", shade->u.m.bpcoord);\n\t\tshade->u.m.bpcoord = 8;\n\t}\n\n\tif (shade->u.m.bpcomp != 1 && shade->u.m.bpcomp != 2 && shade->u.m.bpcomp != 4 &&\n\t\tshade->u.m.bpcomp != 8 && shade->u.m.bpcomp != 12 && shade->u.m.bpcomp != 16)\n\t{\n\t\tfz_warn(ctx, \"Invalid number of bits per component (%d)\", shade->u.m.bpcomp);\n\t\tshade->u.m.bpcomp = 8;\n\t}\n}", "target": 3, "idx": 11378}
{"commit_id": "36a894aeb64a2e02871016da1c37d4a4ca109182", "project": "qemu-project/qemu", "func": "static void tulip_desc_write(TULIPState *s, hwaddr p,\n        struct tulip_descriptor *desc)\n{\n    const MemTxAttrs attrs = { .memory = true };\n\n    if (s->csr[0] & CSR0_DBO) {\n        stl_be_pci_dma(&s->dev, p, desc->status, attrs);\n        stl_be_pci_dma(&s->dev, p + 4, desc->control, attrs);\n        stl_be_pci_dma(&s->dev, p + 8, desc->buf_addr1, attrs);\n        stl_be_pci_dma(&s->dev, p + 12, desc->buf_addr2, attrs);\n    } else {\n        stl_le_pci_dma(&s->dev, p, desc->status, attrs);\n        stl_le_pci_dma(&s->dev, p + 4, desc->control, attrs);\n        stl_le_pci_dma(&s->dev, p + 8, desc->buf_addr1, attrs);\n        stl_le_pci_dma(&s->dev, p + 12, desc->buf_addr2, attrs);\n    }\n}", "target": 2, "idx": 11379}
{"commit_id": "20ad21c0d87ca80217aee47533d91e633ce1864d", "project": "LibRaw", "func": "int LibRaw::unpack_thumb(void)\n{\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_IDENTIFY);\n  CHECK_ORDER_BIT(LIBRAW_PROGRESS_THUMB_LOAD);\n\n#define THUMB_SIZE_CHECKT(A) \\\n  do { \\\n    if (INT64(A) > 1024ULL * 1024ULL * LIBRAW_MAX_THUMBNAIL_MB) throw LIBRAW_EXCEPTION_IO_CORRUPT; \\\n    if (INT64(A) > 0 &&  INT64(A) < 64ULL)        throw LIBRAW_EXCEPTION_IO_CORRUPT; \\\n  } while (0)\n\n#define THUMB_SIZE_CHECKTNZ(A) \\\n  do { \\\n    if (INT64(A) > 1024ULL * 1024ULL * LIBRAW_MAX_THUMBNAIL_MB) throw LIBRAW_EXCEPTION_IO_CORRUPT; \\\n    if (INT64(A) < 64ULL)        throw LIBRAW_EXCEPTION_IO_CORRUPT; \\\n  } while (0)\n\n\n#define THUMB_SIZE_CHECKWH(W,H) \\\n  do { \\\n    if (INT64(W)*INT64(H) > 1024ULL * 1024ULL * LIBRAW_MAX_THUMBNAIL_MB) throw LIBRAW_EXCEPTION_IO_CORRUPT; \\\n    if (INT64(W)*INT64(H) < 64ULL)        throw LIBRAW_EXCEPTION_IO_CORRUPT; \\\n  } while (0)\n\n  try\n  {\n    if (!libraw_internal_data.internal_data.input)\n      return LIBRAW_INPUT_CLOSED;\n\n    int t_colors = libraw_internal_data.unpacker_data.thumb_misc >> 5 & 7;\n    int t_bytesps = (libraw_internal_data.unpacker_data.thumb_misc & 31) / 8;\n\n    if (!ID.toffset && !(imgdata.thumbnail.tlength > 0 &&\n                         load_raw == &LibRaw::broadcom_load_raw) // RPi\n    )\n    {\n      return LIBRAW_NO_THUMBNAIL;\n    }\n    else if (thumb_load_raw)\n    {\n      kodak_thumb_loader();\n      T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n      SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n      return 0;\n    }\n    else\n    {\n#ifdef USE_X3FTOOLS\n\tif (write_thumb == &LibRaw::x3f_thumb_loader)\n      {\n        INT64 tsize = x3f_thumb_size();\n        if (tsize < 2048 || INT64(ID.toffset) + tsize < 1)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n        if (INT64(ID.toffset) + tsize > ID.input->size() + THUMB_READ_BEYOND)\n          throw LIBRAW_EXCEPTION_IO_EOF;\n        THUMB_SIZE_CHECKT(tsize);\n      }\n#else\n\tif (0) {}\n#endif\n      else\n      {\n        if (INT64(ID.toffset) + INT64(T.tlength) < 1)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n        if (INT64(ID.toffset) + INT64(T.tlength) >\n            ID.input->size() + THUMB_READ_BEYOND)\n          throw LIBRAW_EXCEPTION_IO_EOF;\n      }\n\n      ID.input->seek(ID.toffset, SEEK_SET);\n      if (write_thumb == &LibRaw::jpeg_thumb)\n      {\n        THUMB_SIZE_CHECKTNZ(T.tlength);\n\n        if (T.thumb)\n          free(T.thumb);\n        T.thumb = (char *)malloc(T.tlength);\n        merror(T.thumb, \"jpeg_thumb()\");\n        ID.input->read(T.thumb, 1, T.tlength);\n        unsigned char *tthumb = (unsigned char *)T.thumb;\n        tthumb[0] = 0xff;\n        tthumb[1] = 0xd8;\n#ifdef NO_JPEG\n        T.tcolors = 3;\n#else\n        {\n          jpegErrorManager jerr;\n          struct jpeg_decompress_struct cinfo;\n          cinfo.err = jpeg_std_error(&jerr.pub);\n          jerr.pub.error_exit = jpegErrorExit;\n          if (setjmp(jerr.setjmp_buffer))\n          {\n          err2:\n            // Error in original JPEG thumb, read it again because\n            // original bytes 0-1 was damaged above\n            jpeg_destroy_decompress(&cinfo);\n            T.tcolors = 3;\n            T.tformat = LIBRAW_THUMBNAIL_UNKNOWN;\n            ID.input->seek(ID.toffset, SEEK_SET);\n            ID.input->read(T.thumb, 1, T.tlength);\n            SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n            return 0;\n          }\n          jpeg_create_decompress(&cinfo);\n          jpeg_mem_src(&cinfo, (unsigned char *)T.thumb, T.tlength);\n          int rc = jpeg_read_header(&cinfo, TRUE);\n          if (rc != 1)\n            goto err2;\n          T.tcolors = (cinfo.num_components > 0 && cinfo.num_components <= 3)\n                          ? cinfo.num_components\n                          : 3;\n          jpeg_destroy_decompress(&cinfo);\n        }\n#endif\n        T.tformat = LIBRAW_THUMBNAIL_JPEG;\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n      else if (write_thumb == &LibRaw::layer_thumb)\n      {\n        int colors = libraw_internal_data.unpacker_data.thumb_misc >> 5 & 7;\n        if (colors != 1 && colors != 3)\n          return LIBRAW_UNSUPPORTED_THUMBNAIL;\n\n        THUMB_SIZE_CHECKWH(T.twidth, T.theight);\n\n        int tlength = T.twidth * T.theight;\n        if (T.thumb)\n          free(T.thumb);\n        T.thumb = (char *)calloc(colors, tlength);\n        merror(T.thumb, \"layer_thumb()\");\n        unsigned char *tbuf = (unsigned char *)calloc(colors, tlength);\n        merror(tbuf, \"layer_thumb()\");\n        ID.input->read(tbuf, colors, T.tlength);\n        if (libraw_internal_data.unpacker_data.thumb_misc >> 8 &&\n            colors == 3) // GRB order\n          for (int i = 0; i < tlength; i++)\n          {\n            T.thumb[i * 3] = tbuf[i + tlength];\n            T.thumb[i * 3 + 1] = tbuf[i];\n            T.thumb[i * 3 + 2] = tbuf[i + 2 * tlength];\n          }\n        else if (colors == 3) // RGB or 1-channel\n          for (int i = 0; i < tlength; i++)\n          {\n            T.thumb[i * 3] = tbuf[i];\n            T.thumb[i * 3 + 1] = tbuf[i + tlength];\n            T.thumb[i * 3 + 2] = tbuf[i + 2 * tlength];\n          }\n        else if (colors == 1)\n        {\n          free(T.thumb);\n          T.thumb = (char *)tbuf;\n          tbuf = 0;\n        }\n        if (tbuf)\n          free(tbuf);\n        T.tcolors = colors;\n        T.tlength = colors * tlength;\n        T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n      else if (write_thumb == &LibRaw::rollei_thumb)\n      {\n        int i;\n        THUMB_SIZE_CHECKWH(T.twidth, T.theight);\n        int tlength = T.twidth * T.theight;\n        if (T.thumb)\n          free(T.thumb);\n        T.tcolors = 3;\n        T.thumb = (char *)calloc(T.tcolors, tlength);\n        merror(T.thumb, \"layer_thumb()\");\n        unsigned short *tbuf = (unsigned short *)calloc(2, tlength);\n        merror(tbuf, \"layer_thumb()\");\n        read_shorts(tbuf, tlength);\n        for (i = 0; i < tlength; i++)\n        {\n          T.thumb[i * 3] = (tbuf[i] << 3) & 0xff;\n          T.thumb[i * 3 + 1] = (tbuf[i] >> 5 << 2) & 0xff;\n          T.thumb[i * 3 + 2] = (tbuf[i] >> 11 << 3) & 0xff;\n        }\n        free(tbuf);\n        T.tlength = T.tcolors * tlength;\n        T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n      else if (write_thumb == &LibRaw::ppm_thumb)\n      {\n        if (t_bytesps > 1)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT; // 8-bit thumb, but parsed for more\n                                             // bits\n        THUMB_SIZE_CHECKWH(T.twidth, T.theight);\n        int t_length = T.twidth * T.theight * t_colors;\n\n        if (T.tlength &&\n            (int)T.tlength < t_length) // try to find tiff ifd with needed offset\n        {\n          int pifd = find_ifd_by_offset(libraw_internal_data.internal_data.toffset);\n          if (pifd >= 0 && tiff_ifd[pifd].strip_offsets_count &&\n              tiff_ifd[pifd].strip_byte_counts_count)\n          {\n            // We found it, calculate final size\n            unsigned total_size = 0;\n            for (int i = 0; i < tiff_ifd[pifd].strip_byte_counts_count; i++)\n              total_size += tiff_ifd[pifd].strip_byte_counts[i];\n            if (total_size != (unsigned)t_length) // recalculate colors\n            {\n              if (total_size == T.twidth * T.tlength * 3)\n                T.tcolors = 3;\n              else if (total_size == T.twidth * T.tlength)\n                T.tcolors = 1;\n            }\n            T.tlength = total_size;\n            THUMB_SIZE_CHECKTNZ(T.tlength);\n            if (T.thumb)\n              free(T.thumb);\n            T.thumb = (char *)malloc(T.tlength);\n            merror(T.thumb, \"ppm_thumb()\");\n\n            char *dest = T.thumb;\n            INT64 pos = ID.input->tell();\n\n            for (int i = 0; i < tiff_ifd[pifd].strip_byte_counts_count &&\n                            i < tiff_ifd[pifd].strip_offsets_count;\n                 i++)\n            {\n              int remain = T.tlength;\n              int sz = tiff_ifd[pifd].strip_byte_counts[i];\n              int off = tiff_ifd[pifd].strip_offsets[i];\n              if (off >= 0 && off + sz <= ID.input->size() && sz <= remain)\n              {\n                ID.input->seek(off, SEEK_SET);\n                ID.input->read(dest, sz, 1);\n                remain -= sz;\n                dest += sz;\n              }\n            }\n            ID.input->seek(pos, SEEK_SET);\n            T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n            SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n            return 0;\n          }\n        }\n\n        if (!T.tlength)\n          T.tlength = t_length;\n        if (T.thumb)\n          free(T.thumb);\n\n        THUMB_SIZE_CHECKTNZ(T.tlength);\n\n        T.thumb = (char *)malloc(T.tlength);\n        if (!T.tcolors)\n          T.tcolors = t_colors;\n        merror(T.thumb, \"ppm_thumb()\");\n\n        ID.input->read(T.thumb, 1, T.tlength);\n\n        T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n      else if (write_thumb == &LibRaw::ppm16_thumb)\n      {\n        if (t_bytesps > 2)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT; // 16-bit thumb, but parsed for\n                                             // more bits\n        int o_bps = (imgdata.params.raw_processing_options &\n                     LIBRAW_PROCESSING_USE_PPM16_THUMBS)\n                        ? 2\n                        : 1;\n        int o_length = T.twidth * T.theight * t_colors * o_bps;\n        int i_length = T.twidth * T.theight * t_colors * 2;\n        if (!T.tlength)\n          T.tlength = o_length;\n        THUMB_SIZE_CHECKTNZ(o_length);\n        THUMB_SIZE_CHECKTNZ(i_length);\n        THUMB_SIZE_CHECKTNZ(T.tlength);\n\n        ushort *t_thumb = (ushort *)calloc(i_length, 1);\n        ID.input->read(t_thumb, 1, i_length);\n        if ((libraw_internal_data.unpacker_data.order == 0x4949) ==\n            (ntohs(0x1234) == 0x1234))\n          swab((char *)t_thumb, (char *)t_thumb, i_length);\n\n        if (T.thumb)\n          free(T.thumb);\n        if ((imgdata.params.raw_processing_options &\n             LIBRAW_PROCESSING_USE_PPM16_THUMBS))\n        {\n          T.thumb = (char *)t_thumb;\n          T.tformat = LIBRAW_THUMBNAIL_BITMAP16;\n        }\n        else\n        {\n          T.thumb = (char *)malloc(o_length);\n          merror(T.thumb, \"ppm_thumb()\");\n          for (int i = 0; i < o_length; i++)\n            T.thumb[i] = t_thumb[i] >> 8;\n          free(t_thumb);\n          T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n        }\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n#ifdef USE_X3FTOOLS\n\t  else if (write_thumb == &LibRaw::x3f_thumb_loader)\n      {\n        x3f_thumb_loader();\n        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n        return 0;\n      }\n#endif\n      else\n      {\n        return LIBRAW_UNSUPPORTED_THUMBNAIL;\n      }\n    }\n    // last resort\n    return LIBRAW_UNSUPPORTED_THUMBNAIL;\n  }\n  catch (LibRaw_exceptions err)\n  {\n    EXCEPTION_HANDLER(err);\n  }\n}", "target": 2, "idx": 11380}
{"commit_id": "4a9852c31c2fd0c0e72fbb689a586aabcfb11cb0", "project": "kravietz/pam_tacplus", "func": "int _pam_parse(int argc, const char **argv) {\n    int ctrl = 0;\n    const char *current_secret = NULL;\n\n    /* otherwise the list will grow with each call */\n    memset(tac_srv, 0, sizeof(tacplus_server_t) * TAC_PLUS_MAXSERVERS);\n    memset(&tac_srv_addr, 0, sizeof(struct addrinfo) * TAC_PLUS_MAXSERVERS);\n    memset(&tac_sock_addr, 0, sizeof(struct sockaddr) * TAC_PLUS_MAXSERVERS);\n    memset(&tac_sock6_addr, 0, sizeof(struct sockaddr_in6) * TAC_PLUS_MAXSERVERS);\n    tac_srv_no = 0;\n\n    tac_service[0] = 0;\n    tac_protocol[0] = 0;\n    tac_prompt[0] = 0;\n    tac_login[0] = 0;\n\n    for (ctrl = 0; argc-- > 0; ++argv) {\n        if (!strcmp(*argv, \"debug\")) { /* all */\n            ctrl |= PAM_TAC_DEBUG;\n        } else if (!strcmp(*argv, \"use_first_pass\")) {\n            ctrl |= PAM_TAC_USE_FIRST_PASS;\n        } else if (!strcmp(*argv, \"try_first_pass\")) {\n            ctrl |= PAM_TAC_TRY_FIRST_PASS;\n        } else if (!strncmp(*argv, \"service=\", 8)) { /* author & acct */\n            xstrcpy(tac_service, *argv + 8, sizeof(tac_service));\n        } else if (!strncmp(*argv, \"protocol=\", 9)) { /* author & acct */\n            xstrcpy(tac_protocol, *argv + 9, sizeof(tac_protocol));\n        } else if (!strncmp(*argv, \"prompt=\", 7)) { /* authentication */\n            xstrcpy(tac_prompt, *argv + 7, sizeof(tac_prompt));\n            /* Replace _ with space */\n            unsigned long chr;\n            for (chr = 0; chr < strlen(tac_prompt); chr++) {\n                if (tac_prompt[chr] == '_') {\n                    tac_prompt[chr] = ' ';\n                }\n            }\n        } else if (!strncmp(*argv, \"login=\", 6)) {\n            xstrcpy(tac_login, *argv + 6, sizeof(tac_login));\n        } else if (!strcmp(*argv, \"acct_all\")) {\n            ctrl |= PAM_TAC_ACCT;\n        } else if (!strncmp(*argv, \"server=\", 7)) { /* authen & acct */\n            if (tac_srv_no < TAC_PLUS_MAXSERVERS) {\n                struct addrinfo hints, *servers, *server;\n                int rv;\n                char *close_bracket, *server_name, *port, server_buf[256];\n\n                memset(&hints, 0, sizeof hints);\n                memset(&server_buf, 0, sizeof(server_buf));\n                hints.ai_family = AF_UNSPEC;  /* use IPv4 or IPv6, whichever */\n                hints.ai_socktype = SOCK_STREAM;\n\n                if (strlen(*argv + 7) >= sizeof(server_buf)) {\n                    _pam_log(LOG_ERR, \"server address too long, sorry\");\n                    continue;\n                }\n                strcpy(server_buf, *argv + 7);\n\n                if (*server_buf == '[' &&\n                    (close_bracket = strchr(server_buf, ']')) != NULL) { /* Check for URI syntax */\n                    server_name = server_buf + 1;\n                    _pam_log (LOG_ERR,\n                        \"reading server address as: %s \",\n                        server_name);\n                    port = strchr(close_bracket, ':');\n                    *close_bracket = '\\0';\n                } else { /* Fall back to traditional syntax */\n                    server_name = server_buf;\n                    port = strchr(server_buf, ':');\n                }\n                if (port != NULL) {\n                    *port = '\\0';\n                    port++;\n                }\n                _pam_log (LOG_DEBUG,\n                        \"sending server address to getaddrinfo as: %s \",\n                        server_name);\n                if ((rv = getaddrinfo(server_name, (port == NULL) ? \"49\" : port, &hints, &servers)) == 0) {\n                    for (server = servers;\n                         server != NULL && tac_srv_no < TAC_PLUS_MAXSERVERS; server = server->ai_next) {\n                        set_tac_srv_addr(tac_srv_no, server);\n                        set_tac_srv_key(tac_srv_no, current_secret);\n                        tac_srv_no++;\n                    }\n                    _pam_log(LOG_DEBUG, \"%s: server index %d \", __FUNCTION__, tac_srv_no);\n                    freeaddrinfo (servers);\n                } else {\n                    _pam_log(LOG_ERR,\n                             \"skip invalid server: %s (getaddrinfo: %s)\",\n                             server_name, gai_strerror(rv));\n                }\n            } else {\n                _pam_log(LOG_ERR, \"maximum number of servers (%d) exceeded, skipping\",\n                         TAC_PLUS_MAXSERVERS);\n            }\n        } else if (!strncmp(*argv, \"secret=\", 7)) {\n            current_secret = *argv + 7;     /* points right into argv (which is const) */\n\n            // this is possible because server structure is initialized only on the server= occurence\n            if (tac_srv_no == 0) {\n                _pam_log(LOG_ERR, \"secret set but no servers configured yet\");\n            } else {\n                // set secret for the last server configured\n                set_tac_srv_key(tac_srv_no - 1, current_secret);\n            }\n        } else if (!strncmp(*argv, \"timeout=\", 8)) {\n\n#ifdef HAVE_STRTOL\n            tac_timeout = strtol(*argv + 8, NULL, 10);\n\n#else\n            tac_timeout = atoi(*argv + 8);\n#endif\n            if (tac_timeout == LONG_MAX) {\n                _pam_log(LOG_ERR, \"timeout parameter cannot be parsed as integer: %s\", *argv);\n                tac_timeout = 0;\n            } else {\n                tac_readtimeout_enable = 1;\n            }\n        } else {\n            _pam_log(LOG_WARNING, \"unrecognized option: %s\", *argv);\n        }\n    }\n\n    if (ctrl & PAM_TAC_DEBUG) {\n        unsigned long n;\n\n        _pam_log(LOG_DEBUG, \"%d servers defined\", tac_srv_no);\n\n        for (n = 0; n < tac_srv_no; n++) {\n            _pam_log(LOG_DEBUG, \"server[%lu] { addr=%s, key='********' }\", n,\n\t\t\t    tac_ntop(tac_srv[n].addr->ai_addr));\n        }\n\n        _pam_log(LOG_DEBUG, \"tac_service='%s'\", tac_service);\n        _pam_log(LOG_DEBUG, \"tac_protocol='%s'\", tac_protocol);\n        _pam_log(LOG_DEBUG, \"tac_prompt='%s'\", tac_prompt);\n        _pam_log(LOG_DEBUG, \"tac_login='%s'\", tac_login);\n    }\n\n    return ctrl;\n}", "target": 2, "idx": 11381}
{"commit_id": "8d2e02ae650f00c4a53deb625211a0527126c605", "project": "xorg/lib/libX11", "func": "Font\nXLoadFont (\n    register Display *dpy,\n    _Xconst char *name)\n{\n    register long nbytes;\n    Font fid;\n    register xOpenFontReq *req;\n\n    if (strlen(name) >= USHRT_MAX)\n        return (0);\n\n    if (_XF86LoadQueryLocaleFont(dpy, name, (XFontStruct **)0, &fid))\n      return fid;\n\n    LockDisplay(dpy);\n    GetReq(OpenFont, req);\n    nbytes = req->nbytes = name ? (CARD16) strlen(name) : 0;\n    req->fid = fid = XAllocID(dpy);\n    req->length += (nbytes+3)>>2;\n    Data (dpy, name, nbytes);\n    UnlockDisplay(dpy);\n    SyncHandle();\n    return (fid);\n       /* can't return (req->fid) since request may have already been sent */\n}", "target": 3, "idx": 11382}
{"commit_id": "b7fa67742cd8d2b0ca0c0273b157f6ffee9ad6e2", "project": "php/php-src", "func": "static void spl_array_write_dimension_ex(int check_inherited, zval *object, zval *offset, zval *value TSRMLS_DC) /* {{{ */\n{\n\tspl_array_object *intern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);\n\tlong index;\n\tHashTable *ht;\n\n\tif (check_inherited && intern->fptr_offset_set) {\n\t\tif (!offset) {\n\t\t\tALLOC_INIT_ZVAL(offset);\n\t\t} else {\n\t\t\tSEPARATE_ARG_IF_REF(offset);\n\t\t}\n\t\tzend_call_method_with_2_params(&object, Z_OBJCE_P(object), &intern->fptr_offset_set, \"offsetSet\", NULL, offset, value);\n\t\tzval_ptr_dtor(&offset);\n\t\treturn;\n\t}\n\n\tif (!offset) {\n\t\tht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);\n\t\tif (ht->nApplyCount > 0) {\n\t\t\tzend_error(E_WARNING, \"Modification of ArrayObject during sorting is prohibited\");\n\t\t\treturn;\n\t\t}\n\t\tZ_ADDREF_P(value);\n\t\tzend_hash_next_index_insert(ht, (void**)&value, sizeof(void*), NULL);\n\t\treturn;\n\t}\n\tswitch(Z_TYPE_P(offset)) {\n\tcase IS_STRING:\n\t\tht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);\n\t\tif (ht->nApplyCount > 0) {\n\t\t\tzend_error(E_WARNING, \"Modification of ArrayObject during sorting is prohibited\");\n\t\t\treturn;\n\t\t}\n\t\tZ_ADDREF_P(value);\n\t\tzend_symtable_update(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, (void**)&value, sizeof(void*), NULL);\n\t\treturn;\n\tcase IS_DOUBLE:\n\tcase IS_RESOURCE:\n\tcase IS_BOOL:\n\tcase IS_LONG:\n\t\tht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);\n\t\tif (ht->nApplyCount > 0) {\n\t\t\tzend_error(E_WARNING, \"Modification of ArrayObject during sorting is prohibited\");\n\t\t\treturn;\n\t\t}\n\t\tif (offset->type == IS_DOUBLE) {\n\t\t\tindex = (long)Z_DVAL_P(offset);\n\t\t} else {\n\t\t\tindex = Z_LVAL_P(offset);\n\t\t}\n\t\tZ_ADDREF_P(value);\n\t\tzend_hash_index_update(ht, index, (void**)&value, sizeof(void*), NULL);\n\t\treturn;\n\tcase IS_NULL:\n\t\tht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);\n\t\tif (ht->nApplyCount > 0) {\n\t\t\tzend_error(E_WARNING, \"Modification of ArrayObject during sorting is prohibited\");\n\t\t\treturn;\n\t\t}\n\t\tZ_ADDREF_P(value);\n\t\tzend_hash_next_index_insert(ht, (void**)&value, sizeof(void*), NULL);\n\t\treturn;\n\tdefault:\n\t\tzend_error(E_WARNING, \"Illegal offset type\");\n\t\treturn;\n\t}\n}", "target": 2, "idx": 11383}
{"commit_id": "788d0824269bef539fe31a785b1517882eafed93", "project": "torvalds/linux", "func": "static inline void io_uring_task_cancel(void)\n{\n\tif (current->io_uring)\n\t\t__io_uring_cancel(true);\n}", "target": 2, "idx": 11384}
{"commit_id": "8109c368c6cfdb593faaf698c2bf5da32bb1ace4", "project": "GNOME/gnome-autoar", "func": "static void\nautoar_extractor_step_extract (AutoarExtractor *self) {\n  /* Step 3: Extract files\n   * We have to re-open the archive to extract files\n   */\n\n  struct archive *a;\n  struct archive_entry *entry;\n\n  int r;\n\n  g_debug (\"autoar_extractor_step_extract: called\");\n\n  r = libarchive_create_read_object (self->use_raw_format, self, &a);\n  if (r != ARCHIVE_OK) {\n    if (self->error == NULL) {\n      self->error =\n        autoar_common_g_error_new_a (a, self->source_basename);\n    }\n    archive_read_free (a);\n    return;\n  }\n\n  while ((r = archive_read_next_header (a, &entry)) == ARCHIVE_OK) {\n    const char *pathname;\n    const char *hardlink;\n    g_autoptr (GFile) extracted_filename = NULL;\n    g_autoptr (GFile) hardlink_filename = NULL;\n    AutoarConflictAction action;\n    g_autoptr (GFile) file_conflict = NULL;\n\n    if (g_cancellable_is_cancelled (self->cancellable)) {\n      archive_read_free (a);\n      return;\n    }\n\n    pathname = archive_entry_pathname (entry);\n    hardlink = archive_entry_hardlink (entry);\n\n    extracted_filename =\n      autoar_extractor_do_sanitize_pathname (self, pathname);\n\n    if (hardlink != NULL) {\n      hardlink_filename =\n        autoar_extractor_do_sanitize_pathname (self, hardlink);\n    }\n\n    /* Attempt to solve any name conflict before doing any operations */\n    file_conflict = autoar_extractor_check_file_conflict (self,\n                                                          extracted_filename,\n                                                          archive_entry_filetype (entry));\n    while (file_conflict) {\n      GFile *new_extracted_filename = NULL;\n\n      /* Do not try to solve any conflicts in parents for now. Especially\n       * symlinks in parents are dangerous as it can easily happen that files\n       * are written outside of the destination. The tar cmd fails to extract\n       * such archives with ENOTDIR. Let's do the same here. This is most\n       * probably malicious, or corrupted archive if the conflict was caused\n       * only by files from the archive...\n       */\n      if (!g_file_equal (file_conflict, extracted_filename)) {\n        self->error = g_error_new (G_IO_ERROR,\n                                   G_IO_ERROR_NOT_DIRECTORY,\n                                   \"The file is not a directory\");\n        archive_read_free (a);\n        return;\n      }\n\n      action = autoar_extractor_signal_conflict (self,\n                                                 extracted_filename,\n                                                 &new_extracted_filename);\n\n      switch (action) {\n        case AUTOAR_CONFLICT_OVERWRITE:\n          /* It is expected that this will fail for non-empty directories to\n           * prevent data loss.\n           */\n          g_file_delete (extracted_filename, self->cancellable, &self->error);\n          if (self->error != NULL) {\n            archive_read_free (a);\n            return;\n          }\n          break;\n        case AUTOAR_CONFLICT_CHANGE_DESTINATION:\n          /* FIXME: If the destination is changed for directory, it should be\n           * changed also for its children...\n           */\n          g_assert_nonnull (new_extracted_filename);\n          g_clear_object (&extracted_filename);\n          extracted_filename = new_extracted_filename;\n          break;\n        case AUTOAR_CONFLICT_SKIP:\n          archive_read_data_skip (a);\n          break;\n        default:\n          g_assert_not_reached ();\n          break;\n      }\n\n      if (action != AUTOAR_CONFLICT_CHANGE_DESTINATION) {\n        break;\n      }\n\n      g_clear_object (&file_conflict);\n      file_conflict = autoar_extractor_check_file_conflict (self,\n                                                            extracted_filename,\n                                                            archive_entry_filetype (entry));\n    }\n\n    if (file_conflict && action == AUTOAR_CONFLICT_SKIP) {\n      self->total_files -= 1;\n      self->total_size -= archive_entry_size (entry);\n      continue;\n    }\n\n    autoar_extractor_do_write_entry (self, a, entry,\n                                     extracted_filename, hardlink_filename);\n\n    if (self->error != NULL) {\n      archive_read_free (a);\n      return;\n    }\n\n    self->completed_files++;\n    autoar_extractor_signal_progress (self);\n  }\n\n  if (r != ARCHIVE_EOF) {\n    if (self->error == NULL) {\n      self->error =\n        autoar_common_g_error_new_a (a, self->source_basename);\n    }\n    archive_read_free (a);\n    return;\n  }\n\n  archive_read_free (a);\n}", "target": 1, "idx": 11385}
{"commit_id": "390e33436b0706dc2a77683b87235ff811d23d26", "project": "tats/w3m", "func": "wc_uint32\nwc_any_to_ucs(wc_wchar_t cc)\n{\n    int f;\n    wc_uint16 *map = NULL;\n    wc_uint32 map_size = 0x80;\n    wc_map *map2;\n\n    f = WC_CCS_INDEX(cc.ccs);\n    switch (WC_CCS_TYPE(cc.ccs)) {\n    case WC_CCS_A_CS94:\n\tif (cc.ccs == WC_CCS_US_ASCII)\n\t    return cc.code;\n\tif (f < WC_F_ISO_BASE || f > WC_F_CS94_END)\n\t    return WC_C_UCS4_ERROR;\n\tmap = cs94_ucs_map[f - WC_F_ISO_BASE];\n\tcc.code &= 0x7f;\n\tbreak;\n    case WC_CCS_A_CS94W:\n\tif (cc.ccs == WC_CCS_GB_2312 && WcOption.use_gb12345_map) {\n\t    cc.ccs = WC_CCS_GB_12345;\n\t    return wc_any_to_ucs(cc);\n\t} else if (cc.ccs == WC_CCS_JIS_X_0213_1) {\n\t    map2 = wc_map_search((wc_uint16)(cc.code & 0x7f7f),\n\t\tjisx02131_ucs_p2_map, N_jisx02131_ucs_p2_map);\n\t    if (map2)\n\t\treturn map2->code2 | WC_C_UCS4_PLANE2;\n\t} else if (cc.ccs == WC_CCS_JIS_X_0213_2) {\n\t    map2 = wc_map_search((wc_uint16)(cc.code & 0x7f7f),\n\t\tjisx02132_ucs_p2_map, N_jisx02132_ucs_p2_map);\n\t    if (map2)\n\t\treturn map2->code2 | WC_C_UCS4_PLANE2;\n\t}\n\tif (f < WC_F_ISO_BASE || f > WC_F_CS94W_END)\n\t    return 0;\n\tmap = cs94w_ucs_map[f - WC_F_ISO_BASE];\n\tmap_size = cs94w_ucs_map_size[f - WC_F_ISO_BASE];\n\tcc.code = WC_CS94W_N(cc.code);\n\tbreak;\n    case WC_CCS_A_CS96:\n\tif (f < WC_F_ISO_BASE || f > WC_F_CS96_END)\n\t    return WC_C_UCS4_ERROR;\n\tmap = cs96_ucs_map[f - WC_F_ISO_BASE];\n\tcc.code &= 0x7f;\n\tbreak;\n    case WC_CCS_A_CS96W:\n\tif (f < WC_F_ISO_BASE || f > WC_F_CS96W_END)\n\t    return WC_C_UCS4_ERROR;\n\tmap = cs96w_ucs_map[f - WC_F_ISO_BASE];\n\tmap_size = cs96w_ucs_map_size[f - WC_F_ISO_BASE];\n\tcc.code = WC_CS96W_N(cc.code);\n\tbreak;\n    case WC_CCS_A_CS942:\n\tif (f < WC_F_ISO_BASE || f > WC_F_CS942_END)\n\t    return WC_C_UCS4_ERROR;\n\tmap = cs942_ucs_map[f - WC_F_ISO_BASE];\n\tcc.code &= 0x7f;\n\tbreak;\n    case WC_CCS_A_PCS:\n\tif (f < WC_F_PCS_BASE || f > WC_F_PCS_END)\n\t    return WC_C_UCS4_ERROR;\n\tswitch (cc.ccs) {\n\tcase WC_CCS_CP1258_2:\n\t    map2 = wc_map_search((wc_uint16)cc.code,\n\t\tcp12582_ucs_map, N_cp12582_ucs_map);\n\t    if (map2)\n\t\treturn map2->code2;\n\t    return WC_C_UCS4_ERROR;\n\tcase WC_CCS_TCVN_5712_3:\n\t    return wc_any_to_ucs(wc_tcvn57123_to_tcvn5712(cc));\n\tcase WC_CCS_GBK_80:\n\t    return WC_C_UCS2_EURO;\n\t}\n\tmap = pcs_ucs_map[f - WC_F_PCS_BASE];\n\tmap_size = pcs_ucs_map_size[f - WC_F_PCS_BASE];\n\tcc.code &= 0x7f;\n\tbreak;\n    case WC_CCS_A_PCSW:\n\tif (f < WC_F_PCS_BASE || f > WC_F_PCSW_END)\n\t    return WC_C_UCS4_ERROR;\n\tmap = pcsw_ucs_map[f - WC_F_PCS_BASE];\n\tmap_size = pcsw_ucs_map_size[f - WC_F_PCS_BASE];\n\tswitch (cc.ccs) {\n\tcase WC_CCS_BIG5:\n\t    cc.code = WC_BIG5_N(cc.code);\n\t    break;\n\tcase WC_CCS_BIG5_2:\n\t    cc.code = WC_CS94W_N(cc.code) + WC_C_BIG5_2_BASE;\n\t    break;\n\tcase WC_CCS_HKSCS_1:\n\tcase WC_CCS_HKSCS_2:\n\t    cc = wc_cs128w_to_hkscs(cc);\n\tcase WC_CCS_HKSCS:\n\t    map2 = wc_map_search((wc_uint16)cc.code,\n\t\thkscs_ucs_p2_map, N_hkscs_ucs_p2_map);\n\t    if (map2)\n\t\treturn map2->code2 | WC_C_UCS4_PLANE2;\n\t    cc.code = wc_hkscs_to_N(cc.code);\n\t    break;\n\tcase WC_CCS_JOHAB:\n\t    return wc_any_to_ucs(wc_johab_to_cs128w(cc));\n\tcase WC_CCS_JOHAB_1:\n\t    return WC_CS94x128_N(cc.code) + WC_C_UCS2_HANGUL;\n\tcase WC_CCS_JOHAB_2:\n\t    cc.code = WC_CS128W_N(cc.code);\n\t    cc.code = WC_N_JOHAB2(cc.code);\n\t    map2 = wc_map_search((wc_uint16)cc.code,\n\t\tjohab2_ucs_map, N_johab2_ucs_map);\n\t    if (map2)\n\t\treturn map2->code2;\n\t    return WC_C_UCS4_ERROR;\n\tcase WC_CCS_JOHAB_3:\n\t    if ((cc.code & 0x7f7f) < 0x2121)\n\t\treturn WC_C_UCS4_ERROR;\n\tcase WC_CCS_SJIS_EXT:\n\t    return wc_any_to_ucs(wc_sjis_ext_to_cs94w(cc));\n\tcase WC_CCS_SJIS_EXT_1:\n\t    cc.code = wc_sjis_ext1_to_N(cc.code);\n\t    if (cc.code == WC_C_SJIS_ERROR)\n\t\treturn WC_C_UCS4_ERROR;\n\t    break;\n\tcase WC_CCS_SJIS_EXT_2:\n\t    cc.code = wc_sjis_ext2_to_N(cc.code);\n\t    if (cc.code == WC_C_SJIS_ERROR)\n\t\treturn WC_C_UCS4_ERROR;\n\t    break;\n\tcase WC_CCS_GBK_1:\n\tcase WC_CCS_GBK_2:\n\t    cc = wc_cs128w_to_gbk(cc);\n\tcase WC_CCS_GBK:\n\t    cc.code = wc_gbk_to_N(cc.code);\n\t    break;\n\tcase WC_CCS_GBK_EXT:\n\tcase WC_CCS_GBK_EXT_1:\n\tcase WC_CCS_GBK_EXT_2:\n\t    return wc_gb18030_to_ucs(cc);\n\tcase WC_CCS_UHC_1:\n\tcase WC_CCS_UHC_2:\n\t    cc = wc_cs128w_to_uhc(cc);\n\tcase WC_CCS_UHC:\n\t    if (cc.code > WC_C_UHC_END)\n\t\treturn WC_C_UCS4_ERROR;\n\t    cc.code = wc_uhc_to_N(cc.code);\n\t    break;\n\tdefault:\n\t    cc.code = WC_CS94W_N(cc.code);\n\t    break;\n\t}\n\tbreak;\n    case WC_CCS_A_WCS16:\n\tswitch (WC_CCS_SET(cc.ccs)) {\n\tcase WC_CCS_UCS2:\n\t    return cc.code;\n\t}\n\treturn WC_C_UCS4_ERROR;\n    case WC_CCS_A_WCS32:\n\tswitch (WC_CCS_SET(cc.ccs)) {\n\tcase WC_CCS_UCS4:\n\t    return cc.code;\n\tcase WC_CCS_UCS_TAG:\n\t    return wc_ucs_tag_to_ucs(cc.code);\n\tcase WC_CCS_GB18030:\n\t    return wc_gb18030_to_ucs(cc);\n\t}\n\treturn WC_C_UCS4_ERROR;\n    case WC_CCS_A_UNKNOWN:\n\tif (cc.ccs == WC_CCS_C1)\n\t    return (cc.code | 0x80);\n    default:\n\treturn WC_C_UCS4_ERROR;\n    }\n    if (map == NULL)\n\treturn WC_C_UCS4_ERROR;\n    if (map_size == 0 || cc.code > map_size - 1)\n\treturn WC_C_UCS4_ERROR;\n    cc.code = map[cc.code];\n    return cc.code ? cc.code : WC_C_UCS4_ERROR;\n}", "target": 1, "idx": 11386}
{"commit_id": "879f7080d7e141f415c79eaa3a8ac4a3dad0348b", "project": "openssl", "func": "static int tree_link_matching_nodes(X509_POLICY_LEVEL *curr,\n                                    X509_POLICY_DATA *data,\n                                    X509_POLICY_TREE *tree)\n{\n    X509_POLICY_LEVEL *last = curr - 1;\n    int i, matched = 0;\n\n    /* Iterate through all in nodes linking matches */\n    for (i = 0; i < sk_X509_POLICY_NODE_num(last->nodes); i++) {\n        X509_POLICY_NODE *node = sk_X509_POLICY_NODE_value(last->nodes, i);\n\n        if (policy_node_match(last, node, data->valid_policy)) {\n            if (level_add_node(curr, data, node, tree, 0) == NULL)\n                return 0;\n            matched = 1;\n        }\n    }\n    if (!matched && last->anyPolicy) {\n        if (level_add_node(curr, data, last->anyPolicy, tree, 0) == NULL)\n            return 0;\n    }\n    return 1;\n}", "target": 2, "idx": 11387}
{"commit_id": "8c17c272184f0227e8bd42c2a7d62d5683a466a8", "project": "mate-desktop/mate-screensaver", "func": "static void\napply_background_to_window (GSManager *manager,\n                            GSWindow  *window)\n{\n\tcairo_surface_t *surface;\n\tint              width;\n\tint              height;\n\n        mate_bg_load_from_preferences (manager->priv->bg);\n\n\tif (manager->priv->bg == NULL)\n\t{\n\t\tgs_debug (\"No background available\");\n\t\tgs_window_set_background_surface (window, NULL);\n\t}\n\n\tgtk_widget_get_preferred_width (GTK_WIDGET (window), &width, NULL);\n\tgtk_widget_get_preferred_height (GTK_WIDGET (window), &height, NULL);\n\tgs_debug (\"Creating background w:%d h:%d\", width, height);\n\tsurface = mate_bg_create_surface (manager->priv->bg,\n\t                                  gs_window_get_gdk_window (window),\n\t                                  width,\n\t                                  height,\n\t                                  FALSE);\n\tgs_window_set_background_surface (window, surface);\n\tcairo_surface_destroy (surface);\n}", "target": 1, "idx": 11388}
{"commit_id": "e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d", "project": "jasper-software/jasper", "func": "jp2_box_t *jp2_box_create(int type)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\tif (!(box = jp2_box_create0())) {\n\t\treturn 0;\n\t}\n\tbox->type = type;\n\tbox->len = 0;\n\tif (!(boxinfo = jp2_boxinfolookup(type))) {\n\t\treturn 0;\n\t}\n\tbox->info = boxinfo;\n\tbox->ops = &boxinfo->ops;\n\treturn box;\n}", "target": 1, "idx": 11389}
{"commit_id": "7ce5b2b590256ce53d6af28c1d203fb3bc1d2d97", "project": "vim", "func": "static void\nstop_insert(\n    pos_T\t*end_insert_pos,\n    int\t\tesc,\t\t\t// called by ins_esc()\n    int\t\tnomove)\t\t\t// <c-\\><c-o>, don't move cursor\n{\n    int\t\tcc;\n    char_u\t*ptr;\n\n    stop_redo_ins();\n    replace_flush();\t\t// abandon replace stack\n\n    /*\n     * Save the inserted text for later redo with ^@ and CTRL-A.\n     * Don't do it when \"restart_edit\" was set and nothing was inserted,\n     * otherwise CTRL-O w and then <Left> will clear \"last_insert\".\n     */\n    ptr = get_inserted();\n    if (did_restart_edit == 0 || (ptr != NULL\n\t\t\t\t       && (int)STRLEN(ptr) > new_insert_skip))\n    {\n\tvim_free(last_insert);\n\tlast_insert = ptr;\n\tlast_insert_skip = new_insert_skip;\n    }\n    else\n\tvim_free(ptr);\n\n    if (!arrow_used && end_insert_pos != NULL)\n    {\n\t// Auto-format now.  It may seem strange to do this when stopping an\n\t// insertion (or moving the cursor), but it's required when appending\n\t// a line and having it end in a space.  But only do it when something\n\t// was actually inserted, otherwise undo won't work.\n\tif (!ins_need_undo && has_format_option(FO_AUTO))\n\t{\n\t    pos_T   tpos = curwin->w_cursor;\n\n\t    // When the cursor is at the end of the line after a space the\n\t    // formatting will move it to the following word.  Avoid that by\n\t    // moving the cursor onto the space.\n\t    cc = 'x';\n\t    if (curwin->w_cursor.col > 0 && gchar_cursor() == NUL)\n\t    {\n\t\tdec_cursor();\n\t\tcc = gchar_cursor();\n\t\tif (!VIM_ISWHITE(cc))\n\t\t    curwin->w_cursor = tpos;\n\t    }\n\n\t    auto_format(TRUE, FALSE);\n\n\t    if (VIM_ISWHITE(cc))\n\t    {\n\t\tif (gchar_cursor() != NUL)\n\t\t    inc_cursor();\n\t\t// If the cursor is still at the same character, also keep\n\t\t// the \"coladd\".\n\t\tif (gchar_cursor() == NUL\n\t\t\t&& curwin->w_cursor.lnum == tpos.lnum\n\t\t\t&& curwin->w_cursor.col == tpos.col)\n\t\t    curwin->w_cursor.coladd = tpos.coladd;\n\t    }\n\t}\n\n\t// If a space was inserted for auto-formatting, remove it now.\n\tcheck_auto_format(TRUE);\n\n\t// If we just did an auto-indent, remove the white space from the end\n\t// of the line, and put the cursor back.\n\t// Do this when ESC was used or moving the cursor up/down.\n\t// Check for the old position still being valid, just in case the text\n\t// got changed unexpectedly.\n\tif (!nomove && did_ai && (esc || (vim_strchr(p_cpo, CPO_INDENT) == NULL\n\t\t\t&& curwin->w_cursor.lnum != end_insert_pos->lnum))\n\t\t&& end_insert_pos->lnum <= curbuf->b_ml.ml_line_count)\n\t{\n\t    pos_T\ttpos = curwin->w_cursor;\n\n\t    curwin->w_cursor = *end_insert_pos;\n\t    check_cursor_col();  // make sure it is not past the line\n\t    for (;;)\n\t    {\n\t\tif (gchar_cursor() == NUL && curwin->w_cursor.col > 0)\n\t\t    --curwin->w_cursor.col;\n\t\tcc = gchar_cursor();\n\t\tif (!VIM_ISWHITE(cc))\n\t\t    break;\n\t\tif (del_char(TRUE) == FAIL)\n\t\t    break;  // should not happen\n\t    }\n\t    if (curwin->w_cursor.lnum != tpos.lnum)\n\t\tcurwin->w_cursor = tpos;\n\t    else\n\t    {\n\t\t// reset tpos, could have been invalidated in the loop above\n\t\ttpos = curwin->w_cursor;\n\t\ttpos.col++;\n\t\tif (cc != NUL && gchar_pos(&tpos) == NUL)\n\t\t    ++curwin->w_cursor.col;\t// put cursor back on the NUL\n\t    }\n\n\t    // <C-S-Right> may have started Visual mode, adjust the position for\n\t    // deleted characters.\n\t    if (VIsual_active)\n\t\tcheck_visual_pos();\n\t}\n    }\n    did_ai = FALSE;\n#ifdef FEAT_SMARTINDENT\n    did_si = FALSE;\n    can_si = FALSE;\n    can_si_back = FALSE;\n#endif\n\n    // Set '[ and '] to the inserted text.  When end_insert_pos is NULL we are\n    // now in a different buffer.\n    if (end_insert_pos != NULL)\n    {\n\tcurbuf->b_op_start = Insstart;\n\tcurbuf->b_op_start_orig = Insstart_orig;\n\tcurbuf->b_op_end = *end_insert_pos;\n    }\n}", "target": 2, "idx": 11390}
{"commit_id": "eef4c1f9d24478aa1d2dd9ac7ec32efb2137f474", "project": "openconnect", "func": "static int get_cert_name(gnutls_x509_crt_t cert, char *name, size_t namelen)\n{\n\t/* When the name buffer is not big enough, gnutls_x509_crt_get_dn*() will\n\t * update the length argument to the required size, and return\n\t * GNUTLS_E_SHORT_MEMORY_BUFFER. We need to avoid clobbering the original\n\t * length variable. */\n\tsize_t nl = namelen;\n\tif (gnutls_x509_crt_get_dn_by_oid(cert, GNUTLS_OID_X520_COMMON_NAME,\n\t\t\t\t\t  0, 0, name, &nl)) {\n\t\tnl = namelen;\n\t\tif (gnutls_x509_crt_get_dn(cert, name, &nl)) {\n\t\t\tname[namelen-1] = 0;\n\t\t\tsnprintf(name, namelen-1, \"<unknown>\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 3, "idx": 11391}
{"commit_id": "ea92d2f0fcceb54a70910fa32e9a0d7a5afc3583", "project": "krb5", "func": "krb5_error_code KRB5_CALLCONV\nkrb5_pac_parse(krb5_context context,\n               const void *ptr,\n               size_t len,\n               krb5_pac *ppac)\n{\n    krb5_error_code ret;\n    size_t i;\n    const unsigned char *p = (const unsigned char *)ptr;\n    krb5_pac pac;\n    size_t header_len;\n    krb5_ui_4 cbuffers, version;\n\n    *ppac = NULL;\n\n    if (len < PACTYPE_LENGTH)\n        return ERANGE;\n\n    cbuffers = load_32_le(p);\n    p += 4;\n    version = load_32_le(p);\n    p += 4;\n\n    if (version != 0)\n        return EINVAL;\n\n    if (cbuffers < 1 || cbuffers > MAX_BUFFERS)\n        return ERANGE;\n\n    header_len = PACTYPE_LENGTH + (cbuffers * PAC_INFO_BUFFER_LENGTH);\n    if (len < header_len)\n        return ERANGE;\n\n    ret = krb5_pac_init(context, &pac);\n    if (ret != 0)\n        return ret;\n\n    pac->pac = (PACTYPE *)realloc(pac->pac,\n                                  sizeof(PACTYPE) + ((cbuffers - 1) * sizeof(PAC_INFO_BUFFER)));\n    if (pac->pac == NULL) {\n        krb5_pac_free(context, pac);\n        return ENOMEM;\n    }\n\n    pac->pac->cBuffers = cbuffers;\n    pac->pac->Version = version;\n\n    for (i = 0; i < pac->pac->cBuffers; i++) {\n        PAC_INFO_BUFFER *buffer = &pac->pac->Buffers[i];\n\n        buffer->ulType = load_32_le(p);\n        p += 4;\n        buffer->cbBufferSize = load_32_le(p);\n        p += 4;\n        buffer->Offset = load_64_le(p);\n        p += 8;\n\n        if (buffer->Offset % PAC_ALIGNMENT) {\n            krb5_pac_free(context, pac);\n            return EINVAL;\n        }\n        if (buffer->Offset < header_len || buffer->Offset > len ||\n            buffer->cbBufferSize > len - buffer->Offset) {\n            krb5_pac_free(context, pac);\n            return ERANGE;\n        }\n    }\n\n    pac->data.data = realloc(pac->data.data, len);\n    if (pac->data.data == NULL) {\n        krb5_pac_free(context, pac);\n        return ENOMEM;\n    }\n    memcpy(pac->data.data, ptr, len);\n\n    pac->data.length = len;\n\n    *ppac = pac;\n\n    return 0;\n}", "target": 2, "idx": 11392}
{"commit_id": "d2371b4b204f0a3c0af51ad4e9b491144dd1225c", "project": "gpac", "func": "GF_Err dinf_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e = gf_isom_box_array_read(s, bs, dinf_AddBox);\n\tif (e) {\n\t\treturn e;\n\t}\n\tif (!((GF_DataInformationBox *)s)->dref) {\n\t\tGF_Box* dref;\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing dref box in dinf\\n\"));\n\t\tdref = gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);\n\t\t((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)dref;\n\t\tgf_isom_box_add_for_dump_mode(s, dref);\n\t}\n\treturn GF_OK;\n}", "target": 1, "idx": 11393}
{"commit_id": "8c17c272184f0227e8bd42c2a7d62d5683a466a8", "project": "mate-desktop/mate-screensaver", "func": "static void\ngs_manager_create_windows (GSManager *manager)\n{\n\tGdkDisplay  *display;\n\n\tg_return_if_fail (manager != NULL);\n\tg_return_if_fail (GS_IS_MANAGER (manager));\n\n\tg_assert (manager->priv->windows == NULL);\n\n\tdisplay = gdk_display_get_default ();\n\tg_signal_connect (display, \"monitor-added\",\n\t                  G_CALLBACK (on_display_monitor_added),\n\t                  manager);\n\tg_signal_connect (display, \"monitor-removed\",\n\t                  G_CALLBACK (on_display_monitor_removed),\n\t                  manager);\n\n\tgs_manager_create_windows_for_display (manager, display);\n}", "target": 1, "idx": 11394}
{"commit_id": "024b8407392cb0b82b04b58ed256094ed5799e04", "project": "uclouvain/openjpeg", "func": "static OPJ_BOOL opj_j2k_update_image_dimensions(opj_image_t* p_image,\n        opj_event_mgr_t * p_manager)\n{\n    OPJ_UINT32 it_comp;\n    OPJ_INT32 l_comp_x1, l_comp_y1;\n    opj_image_comp_t* l_img_comp = NULL;\n\n    l_img_comp = p_image->comps;\n    for (it_comp = 0; it_comp < p_image->numcomps; ++it_comp) {\n        OPJ_INT32 l_h, l_w;\n        if (p_image->x0 > (OPJ_UINT32)INT_MAX ||\n                p_image->y0 > (OPJ_UINT32)INT_MAX ||\n                p_image->x1 > (OPJ_UINT32)INT_MAX ||\n                p_image->y1 > (OPJ_UINT32)INT_MAX) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"Image coordinates above INT_MAX are not supported\\n\");\n            return OPJ_FALSE;\n        }\n\n        l_img_comp->x0 = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)p_image->x0,\n                         (OPJ_INT32)l_img_comp->dx);\n        l_img_comp->y0 = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)p_image->y0,\n                         (OPJ_INT32)l_img_comp->dy);\n        l_comp_x1 = opj_int_ceildiv((OPJ_INT32)p_image->x1, (OPJ_INT32)l_img_comp->dx);\n        l_comp_y1 = opj_int_ceildiv((OPJ_INT32)p_image->y1, (OPJ_INT32)l_img_comp->dy);\n\n        l_w = opj_int_ceildivpow2(l_comp_x1, (OPJ_INT32)l_img_comp->factor)\n              - opj_int_ceildivpow2((OPJ_INT32)l_img_comp->x0, (OPJ_INT32)l_img_comp->factor);\n        if (l_w < 0) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"Size x of the decoded component image is incorrect (comp[%d].w=%d).\\n\",\n                          it_comp, l_w);\n            return OPJ_FALSE;\n        }\n        l_img_comp->w = (OPJ_UINT32)l_w;\n\n        l_h = opj_int_ceildivpow2(l_comp_y1, (OPJ_INT32)l_img_comp->factor)\n              - opj_int_ceildivpow2((OPJ_INT32)l_img_comp->y0, (OPJ_INT32)l_img_comp->factor);\n        if (l_h < 0) {\n            opj_event_msg(p_manager, EVT_ERROR,\n                          \"Size y of the decoded component image is incorrect (comp[%d].h=%d).\\n\",\n                          it_comp, l_h);\n            return OPJ_FALSE;\n        }\n        l_img_comp->h = (OPJ_UINT32)l_h;\n\n        l_img_comp++;\n    }\n\n    return OPJ_TRUE;\n}", "target": 2, "idx": 11395}
{"commit_id": "eb6bbf7b30da5bae87932514d54d0e3c68b23757", "project": "xen-project/xen", "func": "int gnttab_map_frame(struct domain *d, unsigned long idx, gfn_t gfn, mfn_t *mfn)\n{\n    int rc = 0;\n    struct grant_table *gt = d->grant_table;\n    bool status = false;\n\n    grant_write_lock(gt);\n\n    if ( evaluate_nospec(gt->gt_version == 2) && (idx & XENMAPIDX_grant_table_status) )\n    {\n        idx &= ~XENMAPIDX_grant_table_status;\n        status = true;\n\n        rc = gnttab_get_status_frame_mfn(d, idx, mfn);\n    }\n    else\n        rc = gnttab_get_shared_frame_mfn(d, idx, mfn);\n\n    if ( !rc && paging_mode_translate(d) )\n    {\n        gfn_t gfn = gnttab_get_frame_gfn(gt, status, idx);\n\n        if ( !gfn_eq(gfn, INVALID_GFN) )\n            rc = guest_physmap_remove_page(d, gfn, *mfn, 0);\n    }\n\n    if ( !rc )\n    {\n        /*\n         * Make sure gnttab_unpopulate_status_frames() won't (successfully)\n         * free the page until our caller has completed its operation.\n         */\n        if ( get_page(mfn_to_page(*mfn), d) )\n            gnttab_set_frame_gfn(gt, status, idx, gfn);\n        else\n            rc = -EBUSY;\n    }\n\n    grant_write_unlock(gt);\n\n    return rc;\n}", "target": 2, "idx": 11396}
{"commit_id": "065b7978c40ded35c356ced6cd922a40156c9c46", "project": "chakra-core/ChakraCore", "func": "bool JavascriptArray::IsMissingItem(uint32 index)\n    {\n        if (this->length <= index)\n        {\n            return false;\n        }\n\n        bool isIntArray = false, isFloatArray = false;\n        this->GetArrayTypeAndConvert(&isIntArray, &isFloatArray);\n\n        if (isIntArray)\n        {\n            return IsMissingItemAt<int32>(index);\n        }\n        else if (isFloatArray)\n        {\n            return IsMissingItemAt<double>(index);\n        }\n        else\n        {\n            return IsMissingItemAt<Var>(index);\n        }\n    }", "target": 1, "idx": 11397}
{"commit_id": "f9f017a9035a1befcc9e3afe689be54aa6c11576", "project": "apache/trafficserver", "func": "void\nUrlRewrite::PerformACLFiltering(HttpTransact::State *s, url_mapping *map)\n{\n  if (unlikely(!s || s->acl_filtering_performed || !s->client_connection_enabled)) {\n    return;\n  }\n\n  s->acl_filtering_performed = true; // small protection against reverse mapping\n\n  if (map->filter) {\n    int method               = s->hdr_info.client_request.method_get_wksidx();\n    int method_wksidx        = (method != -1) ? (method - HTTP_WKSIDX_CONNECT) : -1;\n    bool client_enabled_flag = true;\n\n    ink_release_assert(ats_is_ip(&s->client_info.src_addr));\n\n    for (acl_filter_rule *rp = map->filter; rp && client_enabled_flag; rp = rp->next) {\n      bool match = true;\n\n      if (rp->method_restriction_enabled) {\n        if (method_wksidx >= 0 && method_wksidx < HTTP_WKSIDX_METHODS_CNT) {\n          match = rp->standard_method_lookup[method_wksidx];\n        } else if (!rp->nonstandard_methods.empty()) {\n          match = false;\n        } else {\n          int method_str_len;\n          const char *method_str = s->hdr_info.client_request.method_get(&method_str_len);\n          match                  = rp->nonstandard_methods.count(std::string(method_str, method_str_len));\n        }\n      }\n\n      if (match && rp->src_ip_valid) {\n        match = false;\n        for (int j = 0; j < rp->src_ip_cnt && !match; j++) {\n          bool in_range = rp->src_ip_array[j].contains(s->client_info.src_addr);\n          if (rp->src_ip_array[j].invert) {\n            if (!in_range) {\n              match = true;\n            }\n          } else {\n            if (in_range) {\n              match = true;\n            }\n          }\n        }\n      }\n\n      if (match && rp->in_ip_valid) {\n        Debug(\"url_rewrite\", \"match was true and we have specified a in_ip field\");\n        match = false;\n        for (int j = 0; j < rp->in_ip_cnt && !match; j++) {\n          IpEndpoint incoming_addr;\n          incoming_addr.assign(s->state_machine->ua_txn->get_netvc()->get_local_addr());\n          if (is_debug_tag_set(\"url_rewrite\")) {\n            char buf1[128], buf2[128], buf3[128];\n            ats_ip_ntop(incoming_addr, buf1, sizeof(buf1));\n            ats_ip_ntop(rp->in_ip_array[j].start, buf2, sizeof(buf2));\n            ats_ip_ntop(rp->in_ip_array[j].end, buf3, sizeof(buf3));\n            Debug(\"url_rewrite\", \"Trying to match incoming address %s in range %s - %s.\", buf1, buf2, buf3);\n          }\n          bool in_range = rp->in_ip_array[j].contains(incoming_addr);\n          if (rp->in_ip_array[j].invert) {\n            if (!in_range) {\n              match = true;\n            }\n          } else {\n            if (in_range) {\n              match = true;\n            }\n          }\n        }\n      }\n\n      if (rp->internal) {\n        match = s->state_machine->ua_txn->get_netvc()->get_is_internal_request();\n        Debug(\"url_rewrite\", \"%s an internal request\", match ? \"matched\" : \"didn't match\");\n      }\n\n      if (match && client_enabled_flag) { // make sure that a previous filter did not DENY\n        Debug(\"url_rewrite\", \"matched ACL filter rule, %s request\", rp->allow_flag ? \"allowing\" : \"denying\");\n        client_enabled_flag = rp->allow_flag ? true : false;\n      } else {\n        if (!client_enabled_flag) {\n          Debug(\"url_rewrite\", \"Previous ACL filter rule denied request, continuing to deny it\");\n        } else {\n          Debug(\"url_rewrite\", \"did NOT match ACL filter rule, %s request\", rp->allow_flag ? \"denying\" : \"allowing\");\n          client_enabled_flag = rp->allow_flag ? false : true;\n        }\n      }\n\n    } /* end of for(rp = map->filter;rp;rp = rp->next) */\n\n    s->client_connection_enabled = client_enabled_flag;\n  }\n}", "target": 2, "idx": 11398}
{"commit_id": "79b5a555058eef4e1e7ff220c344d39f8cd09646", "project": "plougher/squashfs-tools", "func": "static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset,\n\tstruct inode **i)\n{\n\tstruct squashfs_dir_header dirh;\n\tchar buffer[sizeof(struct squashfs_dir_entry) + SQUASHFS_NAME_LEN + 1]\n\t\t__attribute__((aligned));\n\tstruct squashfs_dir_entry *dire = (struct squashfs_dir_entry *) buffer;\n\tlong long start;\n\tlong long bytes;\n\tint dir_count, size;\n\tstruct dir_ent *new_dir;\n\tstruct dir *dir;\n\n\tTRACE(\"squashfs_opendir: inode start block %d, offset %d\\n\",\n\t\tblock_start, offset);\n\n\t*i = read_inode(block_start, offset);\n\n\tdir = malloc(sizeof(struct dir));\n\tif(dir == NULL)\n\t\tEXIT_UNSQUASH(\"squashfs_opendir: malloc failed!\\n\");\n\n\tdir->dir_count = 0;\n\tdir->cur_entry = 0;\n\tdir->mode = (*i)->mode;\n\tdir->uid = (*i)->uid;\n\tdir->guid = (*i)->gid;\n\tdir->mtime = (*i)->time;\n\tdir->xattr = (*i)->xattr;\n\tdir->dirs = NULL;\n\n\tif ((*i)->data == 3)\n\t\t/*\n\t\t * if the directory is empty, skip the unnecessary\n\t\t * lookup_entry, this fixes the corner case with\n\t\t * completely empty filesystems where lookup_entry correctly\n\t\t * returning -1 is incorrectly treated as an error\n\t\t */\n\t\treturn dir;\n\n\tstart = sBlk.s.directory_table_start + (*i)->start;\n\tbytes = lookup_entry(directory_table_hash, start);\n\n\tif(bytes == -1)\n\t\tEXIT_UNSQUASH(\"squashfs_opendir: directory block %lld not \"\n\t\t\t\"found!\\n\", start);\n\n\tbytes += (*i)->offset;\n\tsize = (*i)->data + bytes - 3;\n\n\twhile(bytes < size) {\t\t\t\n\t\tSQUASHFS_SWAP_DIR_HEADER(directory_table + bytes, &dirh);\n\t\n\t\tdir_count = dirh.count + 1;\n\t\tTRACE(\"squashfs_opendir: Read directory header @ byte position \"\n\t\t\t\"%d, %d directory entries\\n\", bytes, dir_count);\n\t\tbytes += sizeof(dirh);\n\n\t\t/* dir_count should never be larger than SQUASHFS_DIR_COUNT */\n\t\tif(dir_count > SQUASHFS_DIR_COUNT) {\n\t\t\tERROR(\"File system corrupted: too many entries in directory\\n\");\n\t\t\tgoto corrupted;\n\t\t}\n\n\t\twhile(dir_count--) {\n\t\t\tSQUASHFS_SWAP_DIR_ENTRY(directory_table + bytes, dire);\n\n\t\t\tbytes += sizeof(*dire);\n\n\t\t\t/* size should never be SQUASHFS_NAME_LEN or larger */\n\t\t\tif(dire->size >= SQUASHFS_NAME_LEN) {\n\t\t\t\tERROR(\"File system corrupted: filename too long\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tmemcpy(dire->name, directory_table + bytes,\n\t\t\t\tdire->size + 1);\n\t\t\tdire->name[dire->size + 1] = '\\0';\n\n\t\t\t/* check name for invalid characters (i.e /, ., ..) */\n\t\t\tif(check_name(dire->name, dire->size + 1) == FALSE) {\n\t\t\t\tERROR(\"File system corrupted: invalid characters in name\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n\t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n\t\t\t\tdirh.start_block, dire->offset, dire->type);\n\t\t\tif((dir->dir_count % DIR_ENT_SIZE) == 0) {\n\t\t\t\tnew_dir = realloc(dir->dirs, (dir->dir_count +\n\t\t\t\t\tDIR_ENT_SIZE) * sizeof(struct dir_ent));\n\t\t\t\tif(new_dir == NULL)\n\t\t\t\t\tEXIT_UNSQUASH(\"squashfs_opendir: \"\n\t\t\t\t\t\t\"realloc failed!\\n\");\n\t\t\t\tdir->dirs = new_dir;\n\t\t\t}\n\t\t\tstrcpy(dir->dirs[dir->dir_count].name, dire->name);\n\t\t\tdir->dirs[dir->dir_count].start_block =\n\t\t\t\tdirh.start_block;\n\t\t\tdir->dirs[dir->dir_count].offset = dire->offset;\n\t\t\tdir->dirs[dir->dir_count].type = dire->type;\n\t\t\tdir->dir_count ++;\n\t\t\tbytes += dire->size + 1;\n\t\t}\n\t}\n\n\treturn dir;\n\ncorrupted:\n\tfree(dir->dirs);\n\tfree(dir);\n\treturn NULL;\n}", "target": 2, "idx": 11399}
{"commit_id": "d8a0cbc4f2979e0b1cadbe79f0b8b4ecb92477be", "project": "wireshark", "func": "static guint32\ns7comm_decode_response_write_data(tvbuff_t *tvb,\n                                  proto_tree *tree,\n                                  guint8 item_count,\n                                  guint32 offset)\n{\n    guint8 ret_val = 0;\n    guint8 i = 0;\n    proto_item *item = NULL;\n    proto_tree *item_tree = NULL;\n\n    for (i = 0; i < item_count; i++) {\n        ret_val = tvb_get_guint8(tvb, offset);\n        /* Insert a new tree for every item */\n        item = proto_tree_add_item(tree, hf_s7comm_data_item, tvb, offset, 1, ENC_NA);\n        item_tree = proto_item_add_subtree(item, ett_s7comm_data_item);\n        proto_item_append_text(item, \" [%d]: (%s)\", i+1, val_to_str(ret_val, s7comm_item_return_valuenames, \"Unknown code: 0x%02x\"));\n        proto_tree_add_uint(item_tree, hf_s7comm_data_returncode, tvb, offset, 1, ret_val);\n        offset += 1;\n    }\n    return offset;\n}", "target": 2, "idx": 11400}
{"commit_id": "8968a510250e8c70a611221d63fe0a45b7d3a551", "project": "gpac", "func": "GF_Err afra_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tunsigned int i;\n\tGF_AdobeFragRandomAccessBox *ptr = (GF_AdobeFragRandomAccessBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 9)\n\tptr->long_ids = gf_bs_read_int(bs, 1);\n\tptr->long_offsets = gf_bs_read_int(bs, 1);\n\tptr->global_entries = gf_bs_read_int(bs, 1);\n\tptr->reserved = gf_bs_read_int(bs, 5);\n\tptr->time_scale = gf_bs_read_u32(bs);\n\n\tptr->entry_count = gf_bs_read_u32(bs);\n\tif (ptr->size / ( (ptr->long_offsets ? 16 : 12) ) < ptr->entry_count)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tfor (i=0; i<ptr->entry_count; i++) {\n\t\tGF_AfraEntry *ae = gf_malloc(sizeof(GF_AfraEntry));\n\t\tif (!ae) return GF_OUT_OF_MEM;\n\t\tgf_list_add(ptr->local_access_entries, ae);\n\n\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\tae->time = gf_bs_read_u64(bs);\n\t\tif (ptr->long_offsets) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\tae->offset = gf_bs_read_u64(bs);\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\t\tae->offset = gf_bs_read_u32(bs);\n\t\t}\n\t}\n\n\tif (ptr->global_entries) {\n\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\tptr->global_entry_count = gf_bs_read_u32(bs);\n\t\tfor (i=0; i<ptr->global_entry_count; i++) {\n\t\t\tGF_GlobalAfraEntry *ae = gf_malloc(sizeof(GF_GlobalAfraEntry));\n\t\t\tif (!ae) return GF_OUT_OF_MEM;\n\t\t\tgf_list_add(ptr->global_access_entries, ae);\n\n\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\tae->time = gf_bs_read_u64(bs);\n\t\t\tif (ptr->long_ids) {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\t\tae->segment = gf_bs_read_u32(bs);\n\t\t\t\tae->fragment = gf_bs_read_u32(bs);\n\t\t\t} else {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\t\t\tae->segment = gf_bs_read_u16(bs);\n\t\t\t\tae->fragment = gf_bs_read_u16(bs);\n\t\t\t}\n\t\t\tif (ptr->long_offsets) {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 16)\n\t\t\t\tae->afra_offset = gf_bs_read_u64(bs);\n\t\t\t\tae->offset_from_afra = gf_bs_read_u64(bs);\n\t\t\t} else {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\t\tae->afra_offset = gf_bs_read_u32(bs);\n\t\t\t\tae->offset_from_afra = gf_bs_read_u32(bs);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn GF_OK;\n}", "target": 1, "idx": 11401}
{"commit_id": "e688cbd18ea85a4a61b32be4e8d6b37c66943c4a", "project": "CrowCpp/Crow", "func": "inline static void sanitize_filename(std::string& data, char replacement = '_')\n        {\n            unsigned char i = 0, length_limit;\n\n            length_limit = data.length() < 255 ? data.length() : 255;\n            data = data.substr(0, length_limit);\n\n            for (; i < length_limit; i++)\n            {\n                switch ((unsigned char)data[i])\n                {\n                    // WARNING While I can't see how using '\\' or '/' would cause a problem, it still warrants an investigation\n                    //case '/':\n                    case '?':\n                    case '<':\n                    case '>':\n                    //case '\\\\':\n                    case ':':\n                    case '*':\n                    case '|':\n                    case '\\\"':\n\n                    case 0x00:\n                    case 0x01:\n                    case 0x02:\n                    case 0x03:\n                    case 0x04:\n                    case 0x05:\n                    case 0x06:\n                    case 0x07:\n                    case 0x08:\n                    case 0x09:\n                    case 0x0a:\n                    case 0x0b:\n                    case 0x0c:\n                    case 0x0d:\n                    case 0x0e:\n                    case 0x0f:\n                    case 0x10:\n                    case 0x11:\n                    case 0x12:\n                    case 0x13:\n                    case 0x14:\n                    case 0x15:\n                    case 0x16:\n                    case 0x17:\n                    case 0x18:\n                    case 0x19:\n                    case 0x1a:\n                    case 0x1b:\n                    case 0x1c:\n                    case 0x1d:\n                    case 0x1e:\n                    case 0x1f:\n\n                    case 0x80:\n                    case 0x81:\n                    case 0x82:\n                    case 0x83:\n                    case 0x84:\n                    case 0x85:\n                    case 0x86:\n                    case 0x87:\n                    case 0x88:\n                    case 0x89:\n                    case 0x8a:\n                    case 0x8b:\n                    case 0x8c:\n                    case 0x8d:\n                    case 0x8e:\n                    case 0x8f:\n                    case 0x90:\n                    case 0x91:\n                    case 0x92:\n                    case 0x93:\n                    case 0x94:\n                    case 0x95:\n                    case 0x96:\n                    case 0x97:\n                    case 0x98:\n                    case 0x99:\n                    case 0x9a:\n                    case 0x9b:\n                    case 0x9c:\n                    case 0x9d:\n                    case 0x9e:\n                    case 0x9f:\n\n                        data[i] = replacement;\n                        break;\n\n                    default:\n                        break;\n                }\n            }\n            std::string str_replacement(1, replacement);\n\n            boost::ireplace_all(data, \"..\", str_replacement);\n\n            boost::ireplace_all(data, \"CON\", str_replacement);\n            boost::ireplace_all(data, \"PRN\", str_replacement);\n            boost::ireplace_all(data, \"AUX\", str_replacement);\n            boost::ireplace_all(data, \"NUL\", str_replacement);\n            boost::ireplace_all(data, \"COM1\", str_replacement);\n            boost::ireplace_all(data, \"COM2\", str_replacement);\n            boost::ireplace_all(data, \"COM3\", str_replacement);\n            boost::ireplace_all(data, \"COM4\", str_replacement);\n            boost::ireplace_all(data, \"COM5\", str_replacement);\n            boost::ireplace_all(data, \"COM6\", str_replacement);\n            boost::ireplace_all(data, \"COM7\", str_replacement);\n            boost::ireplace_all(data, \"COM8\", str_replacement);\n            boost::ireplace_all(data, \"COM9\", str_replacement);\n            boost::ireplace_all(data, \"LPT1\", str_replacement);\n            boost::ireplace_all(data, \"LPT2\", str_replacement);\n            boost::ireplace_all(data, \"LPT3\", str_replacement);\n            boost::ireplace_all(data, \"LPT4\", str_replacement);\n            boost::ireplace_all(data, \"LPT5\", str_replacement);\n            boost::ireplace_all(data, \"LPT6\", str_replacement);\n            boost::ireplace_all(data, \"LPT7\", str_replacement);\n            boost::ireplace_all(data, \"LPT8\", str_replacement);\n            boost::ireplace_all(data, \"LPT9\", str_replacement);\n        }", "target": 1, "idx": 11402}
{"commit_id": "3ade2efec2e90c6237de32a19680caaa3ebc2845", "project": "tensorflow", "func": "bool operator()(const OpKernelContext* context,\n                  typename TTypes<T, 4>::ConstTensor image,\n                  typename TTypes<float, 2>::ConstTensor boxes,\n                  typename TTypes<int32, 1>::ConstTensor box_index,\n                  const string& method_name, float extrapolation_value,\n                  typename TTypes<float, 4>::Tensor crops) {\n    const int batch_size = image.dimension(0);\n    const int image_height = image.dimension(1);\n    const int image_width = image.dimension(2);\n\n    const int num_boxes = crops.dimension(0);\n    const int crop_height = crops.dimension(1);\n    const int crop_width = crops.dimension(2);\n    const int depth = crops.dimension(3);\n\n    // Sharding across boxes.\n    auto CropAndResizePerBox = [&](int start_box, int limit_box) {\n      for (int b = start_box; b < limit_box; ++b) {\n        const float y1 = boxes(b, 0);\n        const float x1 = boxes(b, 1);\n        const float y2 = boxes(b, 2);\n        const float x2 = boxes(b, 3);\n\n        const int32 b_in = box_index(b);\n        if (!FastBoundsCheck(b_in, batch_size)) {\n          continue;\n        }\n\n        const float height_scale =\n            (crop_height > 1)\n                ? (y2 - y1) * (image_height - 1) / (crop_height - 1)\n                : 0;\n        const float width_scale =\n            (crop_width > 1) ? (x2 - x1) * (image_width - 1) / (crop_width - 1)\n                             : 0;\n\n        for (int y = 0; y < crop_height; ++y) {\n          const float in_y = (crop_height > 1)\n                                 ? y1 * (image_height - 1) + y * height_scale\n                                 : 0.5 * (y1 + y2) * (image_height - 1);\n          if (in_y < 0 || in_y > image_height - 1) {\n            for (int x = 0; x < crop_width; ++x) {\n              for (int d = 0; d < depth; ++d) {\n                crops(b, y, x, d) = extrapolation_value;\n              }\n            }\n            continue;\n          }\n          if (method_name == \"bilinear\") {\n\n            const int top_y_index = floorf(in_y);\n            const int bottom_y_index = ceilf(in_y);\n            const float y_lerp = in_y - top_y_index;\n\n            for (int x = 0; x < crop_width; ++x) {\n              const float in_x = (crop_width > 1)\n                                     ? x1 * (image_width - 1) + x * width_scale\n                                     : 0.5 * (x1 + x2) * (image_width - 1);\n              if (in_x < 0 || in_x > image_width - 1) {\n                for (int d = 0; d < depth; ++d) {\n                  crops(b, y, x, d) = extrapolation_value;\n                }\n                continue;\n              }\n              const int left_x_index = floorf(in_x);\n              const int right_x_index = ceilf(in_x);\n              const float x_lerp = in_x - left_x_index;\n\n              for (int d = 0; d < depth; ++d) {\n                const float top_left(static_cast<float>(\n                    image(b_in, top_y_index, left_x_index, d)));\n                const float top_right(static_cast<float>(\n                    image(b_in, top_y_index, right_x_index, d)));\n                const float bottom_left(static_cast<float>(\n                    image(b_in, bottom_y_index, left_x_index, d)));\n                const float bottom_right(static_cast<float>(\n                    image(b_in, bottom_y_index, right_x_index, d)));\n                const float top = top_left + (top_right - top_left) * x_lerp;\n                const float bottom =\n                    bottom_left + (bottom_right - bottom_left) * x_lerp;\n                crops(b, y, x, d) = top + (bottom - top) * y_lerp;\n              }\n            }\n          } else {  // method == \"nearest\"\n            for (int x = 0; x < crop_width; ++x) {\n              const float in_x = (crop_width > 1)\n                                     ? x1 * (image_width - 1) + x * width_scale\n                                     : 0.5 * (x1 + x2) * (image_width - 1);\n              if (in_x < 0 || in_x > image_width - 1) {\n                for (int d = 0; d < depth; ++d) {\n                  crops(b, y, x, d) = extrapolation_value;\n                }\n                continue;\n              }\n              const int closest_x_index = roundf(in_x);\n              const int closest_y_index = roundf(in_y);\n              for (int d = 0; d < depth; ++d) {\n                crops(b, y, x, d) = static_cast<float>(\n                    image(b_in, closest_y_index, closest_x_index, d));\n              }\n            }\n          }\n        }\n      }\n    };\n\n    // A rough estimation of the cost for each cropped box.\n    double cost_per_pixel =\n        depth * (Eigen::TensorOpCost::AddCost<float>() * 6 +\n                 Eigen::TensorOpCost::MulCost<float>() * 3 +\n                 Eigen::TensorOpCost::CastCost<T, float>() * 4) +\n        (Eigen::TensorOpCost::AddCost<float>() * 2 +\n         Eigen::TensorOpCost::AddCost<float>() * 3);\n    if (method_name == \"nearest\") {\n      cost_per_pixel = depth * Eigen::TensorOpCost::CastCost<T, float>() +\n                       Eigen::TensorOpCost::AddCost<float>() * 4 +\n                       Eigen::TensorOpCost::MulCost<float>() * 4;\n    }\n    const double cost_per_box = crop_height * crop_width * cost_per_pixel;\n\n    const DeviceBase::CpuWorkerThreads& worker_threads =\n        *(context->device()->tensorflow_cpu_worker_threads());\n    Shard(worker_threads.num_threads, worker_threads.workers, num_boxes,\n          cost_per_box, CropAndResizePerBox);\n\n    return true;\n  }", "target": 0, "idx": 11403}
{"commit_id": "b4d4b4cb019bd7240a52daa4ba61e3cc814f0384", "project": "tensorflow", "func": "inline TfLiteStatus ScatterNd(const RuntimeShape& indices_shape,\n                              const IndicesT* indices_data,\n                              const RuntimeShape& updates_shape,\n                              const UpdatesT* updates_data,\n                              const RuntimeShape& output_shape,\n                              UpdatesT* output_data) {\n  ruy::profiler::ScopeLabel label(\"ScatterNd\");\n\n  int n_slices = 1;\n  int slice_size = 1;\n  const int outer_dims = indices_shape.DimensionsCount() - 1;\n  const int indices_nd = indices_shape.Dims(outer_dims);\n  const int updates_dims = updates_shape.DimensionsCount();\n  for (int i = 0; i < outer_dims; ++i) {\n    n_slices *= indices_shape.Dims(i);\n  }\n  for (int i = outer_dims; i < updates_dims; ++i) {\n    slice_size *= updates_shape.Dims(i);\n  }\n\n  int output_flat_size = output_shape.FlatSize();\n  int remain_flat_size = output_flat_size;\n  std::vector<int> dims_to_count(indices_nd, 0);\n  for (int i = 0; i < indices_nd; ++i) {\n    dims_to_count[i] = remain_flat_size / output_shape.Dims(i);\n    remain_flat_size = dims_to_count[i];\n  }\n\n  if (n_slices * slice_size > updates_shape.FlatSize()) {\n    return kTfLiteError;\n  }\n  memset(output_data, 0, sizeof(UpdatesT) * output_flat_size);\n  for (int i = 0; i < n_slices; ++i) {\n    int to_pos = 0;\n    for (int j = 0; j < indices_nd; ++j) {\n      IndicesT idx = indices_data[i * indices_nd + j];\n      to_pos += idx * dims_to_count[j];\n    }\n    if (to_pos < 0 || to_pos + slice_size > output_flat_size) {\n      return kTfLiteError;\n    }\n    for (int j = 0; j < slice_size; j++) {\n      output_data[to_pos + j] += updates_data[i * slice_size + j];\n    }\n  }\n  return kTfLiteOk;\n}", "target": 2, "idx": 11404}
{"commit_id": "5f5a1318653c08e435cfa52f60b6a712815b659d", "project": "qemu", "func": "void virtio_config_writel(VirtIODevice *vdev, uint32_t addr, uint32_t data)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint32_t val = data;\n\n    if (addr + sizeof(val) > vdev->config_len) {\n        return;\n    }\n\n    stl_p(vdev->config + addr, val);\n\n    if (k->set_config) {\n        k->set_config(vdev, vdev->config);\n    }\n}", "target": 2, "idx": 11405}
{"commit_id": "c0151aa3ba76c785b32c7f9d16c98febe53017b1", "project": "android", "func": "static void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {\n  uint16_t ii;\n  size_t total_len, len;\n  uint8_t* p;\n  bool is_overflow = false;\n\n  len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;\n  BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);\n  p_buf->offset = L2CAP_MIN_OFFSET;\n  p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n\n  /* First byte in the response is the opcode */\n  if (p_cmd->multi_req.variable_len)\n    *p++ = GATT_RSP_READ_MULTI_VAR;\n  else\n    *p++ = GATT_RSP_READ_MULTI;\n\n  p_buf->len = 1;\n\n  /* Now walk through the buffers putting the data into the response in order\n   */\n  list_t* list = NULL;\n  const list_node_t* node = NULL;\n  if (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    list = fixed_queue_get_list(p_cmd->multi_rsp_q);\n  for (ii = 0; ii < p_cmd->multi_req.num_handles; ii++) {\n    tGATTS_RSP* p_rsp = NULL;\n\n    if (list != NULL) {\n      if (ii == 0)\n        node = list_begin(list);\n      else\n        node = list_next(node);\n      if (node != list_end(list)) p_rsp = (tGATTS_RSP*)list_node(node);\n    }\n\n    if (p_rsp != NULL) {\n      total_len = p_buf->len;\n      if (p_cmd->multi_req.variable_len) {\n        total_len += 2;\n      }\n\n      if (total_len > mtu) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      len = std::min((size_t) p_rsp->attr_value.len, mtu - total_len);\n\n      if (len == 0) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      if (len < p_rsp->attr_value.len) {\n        is_overflow = true;\n        VLOG(1) << StringPrintf(\n            \"multi read overflow available len=%zu val_len=%d\", len,\n            p_rsp->attr_value.len);\n      }\n\n      if (p_cmd->multi_req.variable_len) {\n        UINT16_TO_STREAM(p, (uint16_t) len);\n        p_buf->len += 2;\n      }\n\n      if (p_rsp->attr_value.handle == p_cmd->multi_req.handles[ii]) {\n        ARRAY_TO_STREAM(p, p_rsp->attr_value.value, (uint16_t) len);\n        p_buf->len += (uint16_t) len;\n      } else {\n        p_cmd->status = GATT_NOT_FOUND;\n        break;\n      }\n\n      if (is_overflow) break;\n\n    } else {\n      p_cmd->status = GATT_NOT_FOUND;\n      break;\n    }\n\n  } /* loop through all handles*/\n\n  /* Sanity check on the buffer length */\n  if (p_buf->len == 0) {\n    LOG(ERROR) << __func__ << \" nothing found!!\";\n    p_cmd->status = GATT_NOT_FOUND;\n    osi_free(p_buf);\n    VLOG(1) << __func__ << \"osi_free(p_buf)\";\n  } else if (p_cmd->p_rsp_msg != NULL) {\n    osi_free(p_buf);\n  } else {\n    p_cmd->p_rsp_msg = p_buf;\n  }\n}", "target": 2, "idx": 11406}
{"commit_id": "c5274dd12224421f2430b30c53b881b9403d649e", "project": "vim", "func": "void\nex_diffgetput(exarg_T *eap)\n{\n    linenr_T\tlnum;\n    int\t\tcount;\n    linenr_T\toff = 0;\n    diff_T\t*dp;\n    diff_T\t*dprev;\n    diff_T\t*dfree;\n    int\t\tidx_cur;\n    int\t\tidx_other;\n    int\t\tidx_from;\n    int\t\tidx_to;\n    int\t\ti;\n    int\t\tadded;\n    char_u\t*p;\n    aco_save_T\taco;\n    buf_T\t*buf;\n    int\t\tstart_skip, end_skip;\n    int\t\tnew_count;\n    int\t\tbuf_empty;\n    int\t\tfound_not_ma = FALSE;\n\n    // Find the current buffer in the list of diff buffers.\n    idx_cur = diff_buf_idx(curbuf);\n    if (idx_cur == DB_COUNT)\n    {\n\temsg(_(e_current_buffer_is_not_in_diff_mode));\n\treturn;\n    }\n\n    if (*eap->arg == NUL)\n    {\n\t// No argument: Find the other buffer in the list of diff buffers.\n\tfor (idx_other = 0; idx_other < DB_COUNT; ++idx_other)\n\t    if (curtab->tp_diffbuf[idx_other] != curbuf\n\t\t    && curtab->tp_diffbuf[idx_other] != NULL)\n\t    {\n\t\tif (eap->cmdidx != CMD_diffput\n\t\t\t\t     || curtab->tp_diffbuf[idx_other]->b_p_ma)\n\t\t    break;\n\t\tfound_not_ma = TRUE;\n\t    }\n\tif (idx_other == DB_COUNT)\n\t{\n\t    if (found_not_ma)\n\t\temsg(_(e_no_other_buffer_in_diff_mode_is_modifiable));\n\t    else\n\t\temsg(_(e_no_other_buffer_in_diff_mode));\n\t    return;\n\t}\n\n\t// Check that there isn't a third buffer in the list\n\tfor (i = idx_other + 1; i < DB_COUNT; ++i)\n\t    if (curtab->tp_diffbuf[i] != curbuf\n\t\t    && curtab->tp_diffbuf[i] != NULL\n\t\t    && (eap->cmdidx != CMD_diffput || curtab->tp_diffbuf[i]->b_p_ma))\n\t    {\n\t\temsg(_(e_more_than_two_buffers_in_diff_mode_dont_know_which_one_to_use));\n\t\treturn;\n\t    }\n    }\n    else\n    {\n\t// Buffer number or pattern given.  Ignore trailing white space.\n\tp = eap->arg + STRLEN(eap->arg);\n\twhile (p > eap->arg && VIM_ISWHITE(p[-1]))\n\t    --p;\n\tfor (i = 0; vim_isdigit(eap->arg[i]) && eap->arg + i < p; ++i)\n\t    ;\n\tif (eap->arg + i == p)\t    // digits only\n\t    i = atol((char *)eap->arg);\n\telse\n\t{\n\t    i = buflist_findpat(eap->arg, p, FALSE, TRUE, FALSE);\n\t    if (i < 0)\n\t\treturn;\t\t// error message already given\n\t}\n\tbuf = buflist_findnr(i);\n\tif (buf == NULL)\n\t{\n\t    semsg(_(e_cant_find_buffer_str), eap->arg);\n\t    return;\n\t}\n\tif (buf == curbuf)\n\t    return;\t\t// nothing to do\n\tidx_other = diff_buf_idx(buf);\n\tif (idx_other == DB_COUNT)\n\t{\n\t    semsg(_(e_buffer_str_is_not_in_diff_mode), eap->arg);\n\t    return;\n\t}\n    }\n\n    diff_busy = TRUE;\n\n    // When no range given include the line above or below the cursor.\n    if (eap->addr_count == 0)\n    {\n\t// Make it possible that \":diffget\" on the last line gets line below\n\t// the cursor line when there is no difference above the cursor.\n\tif (eap->cmdidx == CMD_diffget\n\t\t&& eap->line1 == curbuf->b_ml.ml_line_count\n\t\t&& diff_check(curwin, eap->line1) == 0\n\t\t&& (eap->line1 == 1 || diff_check(curwin, eap->line1 - 1) == 0))\n\t    ++eap->line2;\n\telse if (eap->line1 > 0)\n\t    --eap->line1;\n    }\n\n    if (eap->cmdidx == CMD_diffget)\n    {\n\tidx_from = idx_other;\n\tidx_to = idx_cur;\n    }\n    else\n    {\n\tidx_from = idx_cur;\n\tidx_to = idx_other;\n\t// Need to make the other buffer the current buffer to be able to make\n\t// changes in it.\n\t// set curwin/curbuf to buf and save a few things\n\taucmd_prepbuf(&aco, curtab->tp_diffbuf[idx_other]);\n    }\n\n    // May give the warning for a changed buffer here, which can trigger the\n    // FileChangedRO autocommand, which may do nasty things and mess\n    // everything up.\n    if (!curbuf->b_changed)\n    {\n\tchange_warning(0);\n\tif (diff_buf_idx(curbuf) != idx_to)\n\t{\n\t    emsg(_(e_buffer_changed_unexpectedly));\n\t    goto theend;\n\t}\n    }\n\n    dprev = NULL;\n    for (dp = curtab->tp_first_diff; dp != NULL; )\n    {\n\tif (dp->df_lnum[idx_cur] > eap->line2 + off)\n\t    break;\t// past the range that was specified\n\n\tdfree = NULL;\n\tlnum = dp->df_lnum[idx_to];\n\tcount = dp->df_count[idx_to];\n\tif (dp->df_lnum[idx_cur] + dp->df_count[idx_cur] > eap->line1 + off\n\t\t&& u_save(lnum - 1, lnum + count) != FAIL)\n\t{\n\t    // Inside the specified range and saving for undo worked.\n\t    start_skip = 0;\n\t    end_skip = 0;\n\t    if (eap->addr_count > 0)\n\t    {\n\t\t// A range was specified: check if lines need to be skipped.\n\t\tstart_skip = eap->line1 + off - dp->df_lnum[idx_cur];\n\t\tif (start_skip > 0)\n\t\t{\n\t\t    // range starts below start of current diff block\n\t\t    if (start_skip > count)\n\t\t    {\n\t\t\tlnum += count;\n\t\t\tcount = 0;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tcount -= start_skip;\n\t\t\tlnum += start_skip;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    start_skip = 0;\n\n\t\tend_skip = dp->df_lnum[idx_cur] + dp->df_count[idx_cur] - 1\n\t\t\t\t\t\t\t - (eap->line2 + off);\n\t\tif (end_skip > 0)\n\t\t{\n\t\t    // range ends above end of current/from diff block\n\t\t    if (idx_cur == idx_from)\t// :diffput\n\t\t    {\n\t\t\ti = dp->df_count[idx_cur] - start_skip - end_skip;\n\t\t\tif (count > i)\n\t\t\t    count = i;\n\t\t    }\n\t\t    else\t\t\t// :diffget\n\t\t    {\n\t\t\tcount -= end_skip;\n\t\t\tend_skip = dp->df_count[idx_from] - start_skip - count;\n\t\t\tif (end_skip < 0)\n\t\t\t    end_skip = 0;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    end_skip = 0;\n\t    }\n\n\t    buf_empty = BUFEMPTY();\n\t    added = 0;\n\t    for (i = 0; i < count; ++i)\n\t    {\n\t\t// remember deleting the last line of the buffer\n\t\tbuf_empty = curbuf->b_ml.ml_line_count == 1;\n\t\tml_delete(lnum);\n\t\t--added;\n\t    }\n\t    for (i = 0; i < dp->df_count[idx_from] - start_skip - end_skip; ++i)\n\t    {\n\t\tlinenr_T nr;\n\n\t\tnr = dp->df_lnum[idx_from] + start_skip + i;\n\t\tif (nr > curtab->tp_diffbuf[idx_from]->b_ml.ml_line_count)\n\t\t    break;\n\t\tp = vim_strsave(ml_get_buf(curtab->tp_diffbuf[idx_from],\n\t\t\t\t\t\t\t\t  nr, FALSE));\n\t\tif (p != NULL)\n\t\t{\n\t\t    ml_append(lnum + i - 1, p, 0, FALSE);\n\t\t    vim_free(p);\n\t\t    ++added;\n\t\t    if (buf_empty && curbuf->b_ml.ml_line_count == 2)\n\t\t    {\n\t\t\t// Added the first line into an empty buffer, need to\n\t\t\t// delete the dummy empty line.\n\t\t\tbuf_empty = FALSE;\n\t\t\tml_delete((linenr_T)2);\n\t\t    }\n\t\t}\n\t    }\n\t    new_count = dp->df_count[idx_to] + added;\n\t    dp->df_count[idx_to] = new_count;\n\n\t    if (start_skip == 0 && end_skip == 0)\n\t    {\n\t\t// Check if there are any other buffers and if the diff is\n\t\t// equal in them.\n\t\tfor (i = 0; i < DB_COUNT; ++i)\n\t\t    if (curtab->tp_diffbuf[i] != NULL && i != idx_from\n\t\t\t\t\t\t\t\t&& i != idx_to\n\t\t\t    && !diff_equal_entry(dp, idx_from, i))\n\t\t\tbreak;\n\t\tif (i == DB_COUNT)\n\t\t{\n\t\t    // delete the diff entry, the buffers are now equal here\n\t\t    dfree = dp;\n\t\t    dp = dp->df_next;\n\t\t    if (dprev == NULL)\n\t\t\tcurtab->tp_first_diff = dp;\n\t\t    else\n\t\t\tdprev->df_next = dp;\n\t\t}\n\t    }\n\n\t    if (added != 0)\n\t    {\n\t\t// Adjust marks.  This will change the following entries!\n\t\tmark_adjust(lnum, lnum + count - 1, (long)MAXLNUM, (long)added);\n\t\tif (curwin->w_cursor.lnum >= lnum)\n\t\t{\n\t\t    // Adjust the cursor position if it's in/after the changed\n\t\t    // lines.\n\t\t    if (curwin->w_cursor.lnum >= lnum + count)\n\t\t\tcurwin->w_cursor.lnum += added;\n\t\t    else if (added < 0)\n\t\t\tcurwin->w_cursor.lnum = lnum;\n\t\t}\n\t    }\n\t    changed_lines(lnum, 0, lnum + count, (long)added);\n\n\t    if (dfree != NULL)\n\t    {\n\t\t// Diff is deleted, update folds in other windows.\n#ifdef FEAT_FOLDING\n\t\tdiff_fold_update(dfree, idx_to);\n#endif\n\t\tvim_free(dfree);\n\t    }\n\n\t    // mark_adjust() may have made \"dp\" invalid.  We don't know where\n\t    // to continue then, bail out.\n\t    if (added != 0 && !valid_diff(dp))\n\t\tbreak;\n\n\t    if (dfree == NULL)\n\t\t// mark_adjust() may have changed the count in a wrong way\n\t\tdp->df_count[idx_to] = new_count;\n\n\t    // When changing the current buffer, keep track of line numbers\n\t    if (idx_cur == idx_to)\n\t\toff += added;\n\t}\n\n\t// If before the range or not deleted, go to next diff.\n\tif (dfree == NULL)\n\t{\n\t    dprev = dp;\n\t    dp = dp->df_next;\n\t}\n    }\n\n    // restore curwin/curbuf and a few other things\n    if (eap->cmdidx != CMD_diffget)\n    {\n\t// Syncing undo only works for the current buffer, but we change\n\t// another buffer.  Sync undo if the command was typed.  This isn't\n\t// 100% right when \":diffput\" is used in a function or mapping.\n\tif (KeyTyped)\n\t    u_sync(FALSE);\n\taucmd_restbuf(&aco);\n    }\n\ntheend:\n    diff_busy = FALSE;\n    if (diff_need_update)\n\tex_diffupdate(NULL);\n\n    // Check that the cursor is on a valid character and update its\n    // position.  When there were filler lines the topline has become\n    // invalid.\n    check_cursor();\n    changed_line_abv_curs();\n\n    if (diff_need_update)\n\t// redraw already done by ex_diffupdate()\n\tdiff_need_update = FALSE;\n    else\n    {\n\t// Also need to redraw the other buffers.\n\tdiff_redraw(FALSE);\n\tapply_autocmds(EVENT_DIFFUPDATED, NULL, NULL, FALSE, curbuf);\n    }\n}", "target": 2, "idx": 11407}
{"commit_id": "c65c8fdaaa257e0487ab0aaae9e8f6b439335945", "project": "cesanta/mongoose", "func": "int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,\n                   const char *dir) {\n  char offset[40] = \"\", name[200] = \"\", path[256];\n  mg_http_get_var(&hm->query, \"offset\", offset, sizeof(offset));\n  mg_http_get_var(&hm->query, \"name\", name, sizeof(name));\n  if (name[0] == '\\0') {\n    mg_http_reply(c, 400, \"\", \"%s\", \"name required\");\n    return -1;\n  } else {\n    FILE *fp;\n    long oft = strtol(offset, NULL, 0);\n    snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);\n    remove_double_dots(path);\n    LOG(LL_DEBUG, (\"%d bytes @ %ld [%s]\", (int) hm->body.len, oft, path));\n    if ((fp = fopen(path, oft == 0 ? \"wb\" : \"ab\")) == NULL) {\n      mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", path, errno);\n      return -2;\n    } else {\n      fwrite(hm->body.ptr, 1, hm->body.len, fp);\n      fclose(fp);\n      mg_http_reply(c, 200, \"\", \"\");\n      return (int) hm->body.len;\n    }\n  }\n}", "target": 3, "idx": 11408}
{"commit_id": "d4ff8fd5c175bc825258da3ffb01bd21bd5a6202", "project": "libuv", "func": "int uv_rwlock_tryrdlock(uv_rwlock_t* rwlock) {\n  int r;\n\n  r = pthread_rwlock_tryrdlock(rwlock);\n\n  if (r) {\n    if (r != EBUSY && r != EAGAIN)\n      abort();\n    return -1;\n  }\n  return 0;\n}", "target": 2, "idx": 11409}
{"commit_id": "287f5ac31dfdc074669182f51ece637706070eeb", "project": "jsummers/deark", "func": "static void do_iccprofile_item(deark *c, lctx *d, i64 pos, i64 len)\n{\n\ti64 selector;\n\ti64 data_len;\n\n\tif(len<4) return;\n\tselector = de_getu32be(pos);\n\tdata_len = len-4;\n\tde_dbg(c, \"ICC profile segment, selector=%d, data len=%d\", (int)selector,\n\t\t(int)data_len);\n\n\tif(selector!=1) {\n\t\t// If this is not a Continuation segment, close any current file.\n\t\tdbuf_close(d->iccprofile_file);\n\t\td->iccprofile_file = NULL;\n\t}\n\n\tif(selector==0) { // Beginning segment\n\t\td->iccprofile_file = dbuf_create_output_file(c, \"icc\", NULL, DE_CREATEFLAG_IS_AUX);\n\t}\n\n\tif(selector==0 || selector==1) {\n\t\t// Beginning and Continuation segments normally have profile data.\n\t\t// End segments (selector==2) are not allowed to include data.\n\n\t\tif(!d->iccprofile_file) {\n\t\t\tde_warn(c, \"Bad ICC profile segment\");\n\t\t\treturn;\n\t\t}\n\t\tdbuf_copy(c->infile, pos+4, data_len, d->iccprofile_file);\n\t}\n}", "target": 1, "idx": 11410}
{"commit_id": "0f4f199443faca715523b0659aa536251d8b978f", "project": "torvalds/linux", "func": "int iwl_pcie_ctxt_info_gen3_init(struct iwl_trans *trans,\n\t\t\t\t const struct fw_img *fw)\n{\n\tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\tstruct iwl_context_info_gen3 *ctxt_info_gen3;\n\tstruct iwl_prph_scratch *prph_scratch;\n\tstruct iwl_prph_scratch_ctrl_cfg *prph_sc_ctrl;\n\tstruct iwl_prph_info *prph_info;\n\tvoid *iml_img;\n\tu32 control_flags = 0;\n\tint ret;\n\tint cmdq_size = max_t(u32, IWL_CMD_QUEUE_SIZE,\n\t\t\t      trans->cfg->min_txq_size);\n\n\t/* Allocate prph scratch */\n\tprph_scratch = dma_alloc_coherent(trans->dev, sizeof(*prph_scratch),\n\t\t\t\t\t  &trans_pcie->prph_scratch_dma_addr,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!prph_scratch)\n\t\treturn -ENOMEM;\n\n\tprph_sc_ctrl = &prph_scratch->ctrl_cfg;\n\n\tprph_sc_ctrl->version.version = 0;\n\tprph_sc_ctrl->version.mac_id =\n\t\tcpu_to_le16((u16)iwl_read32(trans, CSR_HW_REV));\n\tprph_sc_ctrl->version.size = cpu_to_le16(sizeof(*prph_scratch) / 4);\n\n\tcontrol_flags = IWL_PRPH_SCRATCH_RB_SIZE_4K |\n\t\t\tIWL_PRPH_SCRATCH_MTR_MODE |\n\t\t\t(IWL_PRPH_MTR_FORMAT_256B &\n\t\t\t IWL_PRPH_SCRATCH_MTR_FORMAT) |\n\t\t\tIWL_PRPH_SCRATCH_EARLY_DEBUG_EN |\n\t\t\tIWL_PRPH_SCRATCH_EDBG_DEST_DRAM;\n\tprph_sc_ctrl->control.control_flags = cpu_to_le32(control_flags);\n\n\t/* initialize RX default queue */\n\tprph_sc_ctrl->rbd_cfg.free_rbd_addr =\n\t\tcpu_to_le64(trans_pcie->rxq->bd_dma);\n\n\t/* Configure debug, for integration */\n\tif (!iwl_trans_dbg_ini_valid(trans))\n\t\tiwl_pcie_alloc_fw_monitor(trans, 0);\n\tif (trans->dbg.num_blocks) {\n\t\tprph_sc_ctrl->hwm_cfg.hwm_base_addr =\n\t\t\tcpu_to_le64(trans->dbg.fw_mon[0].physical);\n\t\tprph_sc_ctrl->hwm_cfg.hwm_size =\n\t\t\tcpu_to_le32(trans->dbg.fw_mon[0].size);\n\t}\n\n\t/* allocate ucode sections in dram and set addresses */\n\tret = iwl_pcie_init_fw_sec(trans, fw, &prph_scratch->dram);\n\tif (ret)\n\t\tgoto err_free_prph_scratch;\n\n\n\t/* Allocate prph information\n\t * currently we don't assign to the prph info anything, but it would get\n\t * assigned later */\n\tprph_info = dma_alloc_coherent(trans->dev, sizeof(*prph_info),\n\t\t\t\t       &trans_pcie->prph_info_dma_addr,\n\t\t\t\t       GFP_KERNEL);\n\tif (!prph_info) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_prph_scratch;\n\t}\n\n\t/* Allocate context info */\n\tctxt_info_gen3 = dma_alloc_coherent(trans->dev,\n\t\t\t\t\t    sizeof(*ctxt_info_gen3),\n\t\t\t\t\t    &trans_pcie->ctxt_info_dma_addr,\n\t\t\t\t\t    GFP_KERNEL);\n\tif (!ctxt_info_gen3) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_prph_info;\n\t}\n\n\tctxt_info_gen3->prph_info_base_addr =\n\t\tcpu_to_le64(trans_pcie->prph_info_dma_addr);\n\tctxt_info_gen3->prph_scratch_base_addr =\n\t\tcpu_to_le64(trans_pcie->prph_scratch_dma_addr);\n\tctxt_info_gen3->prph_scratch_size =\n\t\tcpu_to_le32(sizeof(*prph_scratch));\n\tctxt_info_gen3->cr_head_idx_arr_base_addr =\n\t\tcpu_to_le64(trans_pcie->rxq->rb_stts_dma);\n\tctxt_info_gen3->tr_tail_idx_arr_base_addr =\n\t\tcpu_to_le64(trans_pcie->rxq->tr_tail_dma);\n\tctxt_info_gen3->cr_tail_idx_arr_base_addr =\n\t\tcpu_to_le64(trans_pcie->rxq->cr_tail_dma);\n\tctxt_info_gen3->cr_idx_arr_size =\n\t\tcpu_to_le16(IWL_NUM_OF_COMPLETION_RINGS);\n\tctxt_info_gen3->tr_idx_arr_size =\n\t\tcpu_to_le16(IWL_NUM_OF_TRANSFER_RINGS);\n\tctxt_info_gen3->mtr_base_addr =\n\t\tcpu_to_le64(trans_pcie->txq[trans_pcie->cmd_queue]->dma_addr);\n\tctxt_info_gen3->mcr_base_addr =\n\t\tcpu_to_le64(trans_pcie->rxq->used_bd_dma);\n\tctxt_info_gen3->mtr_size =\n\t\tcpu_to_le16(TFD_QUEUE_CB_SIZE(cmdq_size));\n\tctxt_info_gen3->mcr_size =\n\t\tcpu_to_le16(RX_QUEUE_CB_SIZE(MQ_RX_TABLE_SIZE));\n\n\ttrans_pcie->ctxt_info_gen3 = ctxt_info_gen3;\n\ttrans_pcie->prph_info = prph_info;\n\ttrans_pcie->prph_scratch = prph_scratch;\n\n\t/* Allocate IML */\n\timl_img = dma_alloc_coherent(trans->dev, trans->iml_len,\n\t\t\t\t     &trans_pcie->iml_dma_addr, GFP_KERNEL);\n\tif (!iml_img)\n\t\treturn -ENOMEM;\n\n\tmemcpy(iml_img, trans->iml, trans->iml_len);\n\n\tiwl_enable_fw_load_int_ctx_info(trans);\n\n\t/* kick FW self load */\n\tiwl_write64(trans, CSR_CTXT_INFO_ADDR,\n\t\t    trans_pcie->ctxt_info_dma_addr);\n\tiwl_write64(trans, CSR_IML_DATA_ADDR,\n\t\t    trans_pcie->iml_dma_addr);\n\tiwl_write32(trans, CSR_IML_SIZE_ADDR, trans->iml_len);\n\n\tiwl_set_bit(trans, CSR_CTXT_INFO_BOOT_CTRL,\n\t\t    CSR_AUTO_FUNC_BOOT_ENA);\n\tif (trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_AX210)\n\t\tiwl_write_umac_prph(trans, UREG_CPU_INIT_RUN, 1);\n\telse\n\t\tiwl_set_bit(trans, CSR_GP_CNTRL, CSR_AUTO_FUNC_INIT);\n\n\treturn 0;\n\nerr_free_prph_info:\n\tdma_free_coherent(trans->dev,\n\t\t\t  sizeof(*prph_info),\n\t\t\tprph_info,\n\t\t\ttrans_pcie->prph_info_dma_addr);\n\nerr_free_prph_scratch:\n\tdma_free_coherent(trans->dev,\n\t\t\t  sizeof(*prph_scratch),\n\t\t\tprph_scratch,\n\t\t\ttrans_pcie->prph_scratch_dma_addr);\n\treturn ret;\n\n}", "target": 1, "idx": 11411}
{"commit_id": "a80776332fd8c99b58beab5d91a6675e85013628", "project": "chromium", "func": "std::vector<std::string> UserScriptInjector::GetCssSources(\n    UserScript::RunLocation run_location) const {\n  DCHECK_EQ(UserScript::DOCUMENT_START, run_location);\n\n  std::vector<std::string> sources;\n  if (!script_)\n    return sources;\n\n  const UserScript::FileList& css_scripts = script_->css_scripts();\n  for (UserScript::FileList::const_iterator iter = css_scripts.begin();\n       iter != css_scripts.end();\n       ++iter) {\n    sources.push_back(iter->GetContent().as_string());\n  }\n  return sources;\n}", "target": 2, "idx": 11412}
{"commit_id": "4f10021e7ee527c1aa24853e2947e38e154d9ccb", "project": "michaelrsweet/pdfio", "func": "pdfio_dict_t *\t\t\t\t// O - New dictionary\n_pdfioDictRead(pdfio_file_t   *pdf,\t// I - PDF file\n               pdfio_obj_t    *obj,\t// I - Object, if any\n               _pdfio_token_t *tb,\t// I - Token buffer/stack\n               size_t         depth)\t// I - Depth of dictionary\n{\n  pdfio_dict_t\t\t*dict;\t\t// New dictionary\n  char\t\t\tkey[256];\t// Dictionary key\n  _pdfio_value_t\tvalue;\t\t// Dictionary value\n\n\n  PDFIO_DEBUG(\"_pdfioDictRead(pdf=%p)\\n\", pdf);\n\n  // Create a dictionary and start reading...\n  if ((dict = pdfioDictCreate(pdf)) == NULL)\n    return (NULL);\n\n  while (_pdfioTokenGet(tb, key, sizeof(key)))\n  {\n    // Get the next key or end-of-dictionary...\n    if (!strcmp(key, \">>\"))\n    {\n      // End of dictionary...\n      return (dict);\n    }\n    else if (key[0] != '/')\n    {\n      _pdfioFileError(pdf, \"Invalid dictionary contents.\");\n      break;\n    }\n    else if (_pdfioDictGetValue(dict, key + 1))\n    {\n      _pdfioFileError(pdf, \"Duplicate dictionary key '%s'.\", key + 1);\n      return (NULL);\n    }\n\n    // Then get the next value...\n    PDFIO_DEBUG(\"_pdfioDictRead: Reading value for '%s'.\\n\", key + 1);\n\n    if (!_pdfioValueRead(pdf, obj, tb, &value, depth))\n    {\n      _pdfioFileError(pdf, \"Missing value for dictionary key.\");\n      break;\n    }\n\n    if (!_pdfioDictSetValue(dict, pdfioStringCreate(pdf, key + 1), &value))\n      break;\n\n//    PDFIO_DEBUG(\"_pdfioDictRead: Set %s.\\n\", key);\n  }\n\n  // Dictionary is invalid - pdfioFileClose will free the memory, return NULL\n  // to indicate an error...\n  return (NULL);\n}", "target": 1, "idx": 11413}
{"commit_id": "567c9f58425c37260864f276b6d3f434eecf4b49", "project": "php/php-src", "func": "int gdImageColorMatch (gdImagePtr im1, gdImagePtr im2)\n{\n\tunsigned long *buf; /* stores our calculations */\n\tunsigned long *bp; /* buf ptr */\n\tint color, rgb;\n\tint x,y;\n\tint count;\n\n\tif( !im1->trueColor ) {\n\t\treturn -1; /* im1 must be True Color */\n\t}\n\tif( im2->trueColor ) {\n\t\treturn -2; /* im2 must be indexed */\n\t}\n\tif( (im1->sx != im2->sx) || (im1->sy != im2->sy) ) {\n\t\treturn -3; /* the images are meant to be the same dimensions */\n\t}\n\tif (im2->colorsTotal<1) {\n\t\treturn -4; /* At least 1 color must be allocated */\n\t}\n\n\tbuf = (unsigned long *)safe_emalloc(sizeof(unsigned long), 5 * gdMaxColors, 0);\n\tmemset( buf, 0, sizeof(unsigned long) * 5 * gdMaxColors );\n\n\tfor (x=0; x<im1->sx; x++) {\n\t\tfor( y=0; y<im1->sy; y++ ) {\n\t\t\tcolor = im2->pixels[y][x];\n\t\t\trgb = im1->tpixels[y][x];\n\t\t\tbp = buf + (color * 5);\n\t\t\t(*(bp++))++;\n\t\t\t*(bp++) += gdTrueColorGetRed(rgb);\n\t\t\t*(bp++) += gdTrueColorGetGreen(rgb);\n\t\t\t*(bp++) += gdTrueColorGetBlue(rgb);\n\t\t\t*(bp++) += gdTrueColorGetAlpha(rgb);\n\t\t}\n\t}\n\tbp = buf;\n\tfor (color=0; color<im2->colorsTotal; color++) {\n\t\tcount = *(bp++);\n\t\tif( count > 0 ) {\n\t\t\tim2->red[color]\t\t= *(bp++) / count;\n\t\t\tim2->green[color]\t= *(bp++) / count;\n\t\t\tim2->blue[color]\t= *(bp++) / count;\n\t\t\tim2->alpha[color]\t= *(bp++) / count;\n\t\t} else {\n\t\t\tbp += 4;\n\t\t}\n\t}\n\tgdFree(buf);\n\treturn 0;\n}", "target": 2, "idx": 11414}
{"commit_id": "e25a89f743b18c029bfbe5e1663ae0c7190912b0", "project": "torvalds/linux", "func": "struct mtk_vcodec_fw *mtk_vcodec_fw_vpu_init(struct mtk_vcodec_dev *dev,\n\t\t\t\t\t     enum mtk_vcodec_fw_use fw_use)\n{\n\tstruct platform_device *fw_pdev;\n\tstruct mtk_vcodec_fw *fw;\n\tenum rst_id rst_id;\n\n\tswitch (fw_use) {\n\tcase ENCODER:\n\t\trst_id = VPU_RST_ENC;\n\t\tbreak;\n\tcase DECODER:\n\tdefault:\n\t\trst_id = VPU_RST_DEC;\n\t\tbreak;\n\t}\n\n\tfw_pdev = vpu_get_plat_device(dev->plat_dev);\n\tif (!fw_pdev) {\n\t\tmtk_v4l2_err(\"firmware device is not ready\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tvpu_wdt_reg_handler(fw_pdev, mtk_vcodec_vpu_reset_handler, dev, rst_id);\n\n\tfw = devm_kzalloc(&dev->plat_dev->dev, sizeof(*fw), GFP_KERNEL);\n\tif (!fw)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfw->type = VPU;\n\tfw->ops = &mtk_vcodec_vpu_msg;\n\tfw->pdev = fw_pdev;\n\n\treturn fw;\n}", "target": 1, "idx": 11415}
{"commit_id": "154fe59531c12b82e26d1b24b5531f5066d224f5", "project": "projectacrn/acrn-hypervisor", "func": "void\nvq_endchains(struct virtio_vq_info *vq, int used_all_avail)\n{\n\tstruct virtio_base *base;\n\tuint16_t event_idx, new_idx, old_idx;\n\tint intr;\n\n\tif (!vq || !vq->used)\n\t\treturn;\n\n\t/*\n\t * Interrupt generation: if we're using EVENT_IDX,\n\t * interrupt if we've crossed the event threshold.\n\t * Otherwise interrupt is generated if we added \"used\" entries,\n\t * but suppressed by VRING_AVAIL_F_NO_INTERRUPT.\n\t *\n\t * In any case, though, if NOTIFY_ON_EMPTY is set and the\n\t * entire avail was processed, we need to interrupt always.\n\t */\n\n\tatomic_thread_fence();\n\n\tbase = vq->base;\n\told_idx = vq->save_used;\n\tvq->save_used = new_idx = vq->used->idx;\n\tif (used_all_avail &&\n\t    (base->negotiated_caps & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)))\n\t\tintr = 1;\n\telse if (base->negotiated_caps & (1 << VIRTIO_RING_F_EVENT_IDX)) {\n\t\tevent_idx = VQ_USED_EVENT_IDX(vq);\n\t\t/*\n\t\t * This calculation is per docs and the kernel\n\t\t * (see src/sys/dev/virtio/virtio_ring.h).\n\t\t */\n\t\tintr = (uint16_t)(new_idx - event_idx - 1) <\n\t\t\t(uint16_t)(new_idx - old_idx);\n\t} else {\n\t\tintr = new_idx != old_idx &&\n\t\t    !(vq->avail->flags & VRING_AVAIL_F_NO_INTERRUPT);\n\t}\n\tif (intr)\n\t\tvq_interrupt(base, vq);\n}", "target": 2, "idx": 11416}
{"commit_id": "232282fd8f9c21eefe8d2d2b96cdbbb172fe7b7c", "project": "libtiff", "func": "static int\nextractImageSection(struct image_data *image, struct pageseg *section, \n                    unsigned char *src_buff, unsigned char *sect_buff)\n  {\n  unsigned  char  bytebuff1, bytebuff2;\n#ifdef DEVELMODE\n  /* unsigned  char *src, *dst; */\n#endif\n\n  uint32_t    img_width, img_rowsize;\n#ifdef DEVELMODE\n  uint32_t    img_length;\n#endif\n  uint32_t    j, shift1, trailing_bits;\n  uint32_t    row, first_row, last_row, first_col, last_col;\n  uint32_t    src_offset, dst_offset, row_offset, col_offset;\n  uint32_t    offset1, full_bytes;\n  uint32_t    sect_width;\n#ifdef DEVELMODE\n  uint32_t    sect_length;\n#endif\n  uint16_t    bps, spp;\n\n#ifdef DEVELMODE\n  int      k;\n  unsigned char bitset;\n#endif\n\n  img_width = image->width;\n#ifdef DEVELMODE\n  img_length = image->length;\n#endif\n  bps = image->bps;\n  spp = image->spp;\n\n#ifdef DEVELMODE\n  /* src = src_buff; */\n  /* dst = sect_buff; */\n#endif\n  src_offset = 0;\n  dst_offset = 0;\n\n#ifdef DEVELMODE\n  char bitarray[39];\n#endif\n\n  /* rows, columns, width, length are expressed in pixels\n   * first_row, last_row, .. are index into image array starting at 0 to width-1,\n   * last_col shall be also extracted.  */\n  first_row = section->y1;\n  last_row  = section->y2;\n  first_col = section->x1;\n  last_col  = section->x2;\n\n  sect_width = last_col - first_col + 1;\n#ifdef DEVELMODE\n  sect_length = last_row - first_row + 1;\n#endif\n    /* The read function loadImage() used copy separate plane data into a buffer as interleaved\n     * samples rather than separate planes so the same logic works to extract regions\n     * regardless of the way the data are organized in the input file.\n     * Furthermore, bytes and bits are arranged in buffer according to COMPRESSION=1 and FILLORDER=1 \n     */\n    img_rowsize = (((img_width * spp * bps) + 7) / 8);    /* row size in full bytes of source image */\n    full_bytes = (sect_width * spp * bps) / 8;            /* number of COMPLETE bytes per row in section */\n    trailing_bits = (sect_width * spp * bps) % 8;         /* trailing bits within the last byte of destination buffer */\n\n#ifdef DEVELMODE\n    TIFFError (\"\", \"First row: %\"PRIu32\", last row: %\"PRIu32\", First col: %\"PRIu32\", last col: %\"PRIu32\"\\n\",\n           first_row, last_row, first_col, last_col);\n    TIFFError (\"\", \"Image width: %\"PRIu32\", Image length: %\"PRIu32\", bps: %\"PRIu16\", spp: %\"PRIu16\"\\n\",\n\t   img_width, img_length, bps, spp);\n    TIFFError (\"\", \"Sect  width: %\"PRIu32\",  Sect length: %\"PRIu32\", full bytes: %\"PRIu32\" trailing bits %\"PRIu32\"\\n\", \n           sect_width, sect_length, full_bytes, trailing_bits);\n#endif\n\n  if ((bps % 8) == 0)\n    {\n    col_offset = (first_col * spp * bps) / 8;\n    for (row = first_row; row <= last_row; row++)\n      {\n      row_offset = row * img_rowsize;\n      src_offset = row_offset + col_offset;\n\n#ifdef DEVELMODE\n        TIFFError (\"\", \"Src offset: %8\"PRIu32\", Dst offset: %8\"PRIu32, src_offset, dst_offset); \n#endif\n      _TIFFmemcpy (sect_buff + dst_offset, src_buff + src_offset, full_bytes);\n      dst_offset += full_bytes;\n      }        \n    }\n  else\n    { /* bps != 8 */\n    shift1 = ((first_col * spp * bps) % 8);           /* shift1 = bits to skip in the first byte of source buffer*/\n    for (row = first_row; row <= last_row; row++)\n      {\n      /* pull out the first byte */\n      row_offset = row * img_rowsize;\n      offset1 = row_offset + ((first_col * spp * bps) / 8);   /* offset1 = offset into source of byte with first bits to be extracted */\n\n#ifdef DEVELMODE\n      for (j = 0, k = 7; j < 8; j++, k--)\n        {\n        bitset = *(src_buff + offset1) & (((unsigned char)1 << k)) ? 1 : 0;\n        sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\");\n        }\n      sprintf(&bitarray[8], \" \");\n      sprintf(&bitarray[9], \" \");\n      for (j = 10, k = 7; j < 18; j++, k--)\n        {\n        bitset = *(src_buff + offset1 + full_bytes) & (((unsigned char)1 << k)) ? 1 : 0;\n        sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\");\n        }\n      bitarray[18] = '\\0';\n      TIFFError (\"\", \"Row: %3d Offset1: %\"PRIu32\",  Shift1: %\"PRIu32\",    Offset2: %\"PRIu32\",  Trailing_bits:  %\"PRIu32\"\\n\", \n                 row, offset1, shift1, offset1+full_bytes, trailing_bits); \n#endif\n\n      bytebuff1 = bytebuff2 = 0;\n      if (shift1 == 0) /* the region is byte and sample aligned */\n        {\n\t_TIFFmemcpy (sect_buff + dst_offset, src_buff + offset1, full_bytes);\n\n#ifdef DEVELMODE\n\tTIFFError (\"\", \"        Aligned data src offset1: %8\"PRIu32\", Dst offset: %8\"PRIu32\"\\n\", offset1, dst_offset);\n\tsprintf(&bitarray[18], \"\\n\");\n\tsprintf(&bitarray[19], \"\\t\");\n        for (j = 20, k = 7; j < 28; j++, k--)\n          {\n          bitset = *(sect_buff + dst_offset) & (((unsigned char)1 << k)) ? 1 : 0;\n          sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\");\n          }\n        bitarray[28] = ' ';\n        bitarray[29] = ' ';\n#endif\n        dst_offset += full_bytes;\n\n        if (trailing_bits != 0)\n          {\n      /* Only copy higher bits of samples and mask lower bits of not wanted column samples to zero */\n\t  bytebuff2 = src_buff[offset1 + full_bytes] & ((unsigned char)255 << (8 - trailing_bits));\n          sect_buff[dst_offset] = bytebuff2;\n#ifdef DEVELMODE\n\t  TIFFError (\"\", \"        Trailing bits src offset:  %8\"PRIu32\", Dst offset: %8\"PRIu32\"\\n\",\n          offset1 + full_bytes, dst_offset);\n          for (j = 30, k = 7; j < 38; j++, k--)\n            {\n            bitset = *(sect_buff + dst_offset) & (((unsigned char)1 << k)) ? 1 : 0;\n            sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\");\n            }\n          bitarray[38] = '\\0';\n          TIFFError (\"\", \"\\tFirst and last bytes before and after masking:\\n\\t%s\\n\\n\", bitarray);\n#endif\n          dst_offset++;\n          }\n        }\n      else   /* each destination byte will have to be built from two source bytes*/\n        {\n#ifdef DEVELMODE\n\t  TIFFError (\"\", \"        Unalligned data src offset: %8\"PRIu32\", Dst offset: %8\"PRIu32\"\\n\", offset1 , dst_offset);\n#endif\n        for (j = 0; j <= full_bytes; j++) \n          {\n          /* Skip the first shift1 bits and shift the source up by shift1 bits before save to destination.*/\n          /* Attention: src_buff size needs to be some bytes larger than image size, because could read behind image here. */\n          bytebuff1 = src_buff[offset1 + j] & ((unsigned char)255 >> shift1);\n          bytebuff2 = src_buff[offset1 + j + 1] & ((unsigned char)255 << (8 - shift1));\n          sect_buff[dst_offset + j] = (bytebuff1 << shift1) | (bytebuff2 >> (8 - shift1));\n          }\n#ifdef DEVELMODE\n\tsprintf(&bitarray[18], \"\\n\");\n\tsprintf(&bitarray[19], \"\\t\");\n        for (j = 20, k = 7; j < 28; j++, k--)\n          {\n          bitset = *(sect_buff + dst_offset) & (((unsigned char)1 << k)) ? 1 : 0;\n          sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\");\n          }\n        bitarray[28] = ' ';\n        bitarray[29] = ' ';\n#endif\n        dst_offset += full_bytes;\n\n        /* Copy the trailing_bits for the last byte in the destination buffer. \n           Could come from one ore two bytes of the source buffer. */\n        if (trailing_bits != 0)\n          {\n#ifdef DEVELMODE\n          TIFFError(\"\", \"        Trailing bits %4\"PRIu32\"   src offset: %8\"PRIu32\", Dst offset: %8\"PRIu32\"\\n\", trailing_bits, offset1 + full_bytes, dst_offset);\n#endif\n          /* More than necessary bits are already copied into last destination buffer, \n           * only masking of last byte in destination buffer is necessary.*/ \n          sect_buff[dst_offset] &= ((uint8_t)0xFF << (8 - trailing_bits));\n            }\n#ifdef DEVELMODE\n\t  sprintf(&bitarray[28], \" \");\n\t  sprintf(&bitarray[29], \" \");\n          for (j = 30, k = 7; j < 38; j++, k--)\n            {\n            bitset = *(sect_buff + dst_offset) & (((unsigned char)1 << k)) ? 1 : 0;\n            sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\");\n            }\n          bitarray[38] = '\\0';\n          TIFFError (\"\", \"\\tFirst and last bytes before and after masking:\\n\\t%s\\n\\n\", bitarray);\n#endif\n        dst_offset++;\n        }\n      }\n    }\n\n  return (0);\n  }", "target": 2, "idx": 11417}
{"commit_id": "0ff832d31470471803b175cfff4e40c1b08ee779", "project": "aawc/unrar", "func": "bool Unpack::UnpackLargeBlock(UnpackThreadData &D)\n{\n  if (!D.TableRead)\n  {\n    D.TableRead=true;\n    if (!ReadTables(D.Inp,D.BlockHeader,D.BlockTables))\n    {\n      D.DamagedData=true;\n      return false;\n    }\n  }\n\n  if (D.Inp.InAddr>D.BlockHeader.HeaderSize+D.BlockHeader.BlockSize)\n  {\n    D.DamagedData=true;\n    return false;\n  }\n  \n  int BlockBorder=D.BlockHeader.BlockStart+D.BlockHeader.BlockSize-1;\n\n  // Reserve enough space even for filter entry.\n  int DataBorder=D.DataSize-16;\n  int ReadBorder=Min(BlockBorder,DataBorder);\n\n  while (true)\n  {\n    UnpPtr&=MaxWinMask;\n    if (D.Inp.InAddr>=ReadBorder)\n    {\n      if (D.Inp.InAddr>BlockBorder || D.Inp.InAddr==BlockBorder && \n          D.Inp.InBit>=D.BlockHeader.BlockBitSize)\n        break;\n\n      // If we do not have any more data in file to read, we must process\n      // what we have until last byte. Otherwise we can return and append\n      // more data to unprocessed few bytes.\n      if ((D.Inp.InAddr>=DataBorder) && !D.NoDataLeft || D.Inp.InAddr>=D.DataSize)\n      {\n        D.Incomplete=true;\n        break;\n      }\n    }\n    if (((WriteBorder-UnpPtr) & MaxWinMask)<MAX_INC_LZ_MATCH && WriteBorder!=UnpPtr)\n    {\n      UnpWriteBuf();\n      if (WrittenFileSize>DestUnpSize)\n        return false;\n    }\n\n    uint MainSlot=DecodeNumber(D.Inp,&D.BlockTables.LD);\n    if (MainSlot<256)\n    {\n      Window[UnpPtr++]=(byte)MainSlot;\n      continue;\n    }\n    if (MainSlot>=262)\n    {\n      uint Length=SlotToLength(D.Inp,MainSlot-262);\n\n      uint DBits,Distance=1,DistSlot=DecodeNumber(D.Inp,&D.BlockTables.DD);\n      if (DistSlot<4)\n      {\n        DBits=0;\n        Distance+=DistSlot;\n      }\n      else\n      {\n        DBits=DistSlot/2 - 1;\n        Distance+=(2 | (DistSlot & 1)) << DBits;\n      }\n\n      if (DBits>0)\n      {\n        if (DBits>=4)\n        {\n          if (DBits>4)\n          {\n            Distance+=((D.Inp.getbits32()>>(36-DBits))<<4);\n            D.Inp.addbits(DBits-4);\n          }\n          uint LowDist=DecodeNumber(D.Inp,&D.BlockTables.LDD);\n          Distance+=LowDist;\n        }\n        else\n        {\n          Distance+=D.Inp.getbits32()>>(32-DBits);\n          D.Inp.addbits(DBits);\n        }\n      }\n\n      if (Distance>0x100)\n      {\n        Length++;\n        if (Distance>0x2000)\n        {\n          Length++;\n          if (Distance>0x40000)\n            Length++;\n        }\n      }\n\n      InsertOldDist(Distance);\n      LastLength=Length;\n      CopyString(Length,Distance);\n      continue;\n    }\n    if (MainSlot==256)\n    {\n      UnpackFilter Filter;\n      if (!ReadFilter(D.Inp,Filter) || !AddFilter(Filter))\n        break;\n      continue;\n    }\n    if (MainSlot==257)\n    {\n      if (LastLength!=0)\n        CopyString(LastLength,OldDist[0]);\n      continue;\n    }\n    if (MainSlot<262)\n    {\n      uint DistNum=MainSlot-258;\n      uint Distance=OldDist[DistNum];\n      for (uint I=DistNum;I>0;I--)\n        OldDist[I]=OldDist[I-1];\n      OldDist[0]=Distance;\n\n      uint LengthSlot=DecodeNumber(D.Inp,&D.BlockTables.RD);\n      uint Length=SlotToLength(D.Inp,LengthSlot);\n      LastLength=Length;\n      CopyString(Length,Distance);\n      continue;\n    }\n  }\n  return true;\n}", "target": 2, "idx": 11418}
{"commit_id": "d9c2dc1c26afb7a10a0834bd89683bfcbbeae408", "project": "FISCO-BCOS", "func": "ssize_t P2PMessage::decode(const byte* buffer, size_t size)\n{\n    if (size < HEADER_LENGTH)\n    {\n        return dev::network::PACKET_INCOMPLETE;\n    }\n\n    int32_t offset = 0;\n    m_length = ntohl(*((uint32_t*)&buffer[offset]));\n    if (m_length > MAX_MESSAGE_LENGTH)\n    {\n        SESSION_LOG(WARNING) << LOG_DESC(\"Illegal p2p message packet\") << LOG_KV(\"length\", m_length)\n                             << LOG_KV(\"maxLen\", MAX_MESSAGE_LENGTH);\n        return dev::network::PACKET_ERROR;\n    }\n    if (size < m_length)\n    {\n        return dev::network::PACKET_INCOMPLETE;\n    }\n\n    offset += 4;\n    m_protocolID = ntohs(*((PROTOCOL_ID*)&buffer[offset]));\n    offset += 2;\n    m_packetType = ntohs(*((PACKET_TYPE*)&buffer[offset]));\n    offset += 2;\n    m_seq = ntohl(*((uint32_t*)&buffer[offset]));\n    ///< TODO: assign to std::move\n    m_buffer->assign(&buffer[HEADER_LENGTH], &buffer[HEADER_LENGTH] + m_length - HEADER_LENGTH);\n\n    return m_length;\n}", "target": 2, "idx": 11419}
{"commit_id": "3b4929f65b0d8249f19a50245cd88ed1a2f78cff", "project": "kernel/git/netdev/net", "func": "static inline int __tcp_mtu_to_mss(struct sock *sk, int pmtu)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\tint mss_now;\n\n\t/* Calculate base mss without TCP options:\n\t   It is MMS_S - sizeof(tcphdr) of rfc1122\n\t */\n\tmss_now = pmtu - icsk->icsk_af_ops->net_header_len - sizeof(struct tcphdr);\n\n\t/* IPv6 adds a frag_hdr in case RTAX_FEATURE_ALLFRAG is set */\n\tif (icsk->icsk_af_ops->net_frag_header_len) {\n\t\tconst struct dst_entry *dst = __sk_dst_get(sk);\n\n\t\tif (dst && dst_allfrag(dst))\n\t\t\tmss_now -= icsk->icsk_af_ops->net_frag_header_len;\n\t}\n\n\t/* Clamp it (mss_clamp does not include tcp options) */\n\tif (mss_now > tp->rx_opt.mss_clamp)\n\t\tmss_now = tp->rx_opt.mss_clamp;\n\n\t/* Now subtract optional transport overhead */\n\tmss_now -= icsk->icsk_ext_hdr_len;\n\n\t/* Then reserve room for full set of TCP options and 8 bytes of data */\n\tif (mss_now < TCP_MIN_SND_MSS)\n\t\tmss_now = TCP_MIN_SND_MSS;\n\treturn mss_now;\n}", "target": 2, "idx": 11420}
{"commit_id": "415b73b1a400a994a86e6f29709aa0271e895dd5", "project": "chromium", "func": "void FileSystemNatives::GetIsolatedFileSystem(\n    const v8::FunctionCallbackInfo<v8::Value>& args) {\n  CHECK(args.Length() == 1 || args.Length() == 2);\n  CHECK(args[0]->IsString());\n  std::string file_system_id(*v8::String::Utf8Value(args[0]));\n  blink::WebLocalFrame* webframe =\n      blink::WebLocalFrame::frameForContext(context()->v8_context());\n  DCHECK(webframe);\n\n  GURL context_url =\n      extensions::ScriptContext::GetDataSourceURLForFrame(webframe);\n  CHECK(context_url.SchemeIs(extensions::kExtensionScheme));\n\n  std::string name(storage::GetIsolatedFileSystemName(context_url.GetOrigin(),\n                                                      file_system_id));\n\n  // The optional second argument is the subfolder within the isolated file\n  // system at which to root the DOMFileSystem we're returning to the caller.\n  std::string optional_root_name;\n  if (args.Length() == 2) {\n    CHECK(args[1]->IsString());\n    optional_root_name = *v8::String::Utf8Value(args[1]);\n  }\n\n  GURL root_url(storage::GetIsolatedFileSystemRootURIString(\n      context_url.GetOrigin(), file_system_id, optional_root_name));\n\n  args.GetReturnValue().Set(\n      blink::WebDOMFileSystem::create(webframe,\n                                      blink::WebFileSystemTypeIsolated,\n                                      blink::WebString::fromUTF8(name),\n                                      root_url)\n          .toV8Value(context()->v8_context()->Global(), args.GetIsolate()));\n}", "target": 2, "idx": 11421}
{"commit_id": "1acb8f2a7a9f10543868ddd737e37424d5c36cf4", "project": "torvalds/linux", "func": "static int ql_alloc_large_buffers(struct ql3_adapter *qdev)\n{\n\tint i;\n\tstruct ql_rcv_buf_cb *lrg_buf_cb;\n\tstruct sk_buff *skb;\n\tdma_addr_t map;\n\tint err;\n\n\tfor (i = 0; i < qdev->num_large_buffers; i++) {\n\t\tskb = netdev_alloc_skb(qdev->ndev,\n\t\t\t\t       qdev->lrg_buffer_len);\n\t\tif (unlikely(!skb)) {\n\t\t\t/* Better luck next round */\n\t\t\tnetdev_err(qdev->ndev,\n\t\t\t\t   \"large buff alloc failed for %d bytes at index %d\\n\",\n\t\t\t\t   qdev->lrg_buffer_len * 2, i);\n\t\t\tql_free_large_buffers(qdev);\n\t\t\treturn -ENOMEM;\n\t\t} else {\n\n\t\t\tlrg_buf_cb = &qdev->lrg_buf[i];\n\t\t\tmemset(lrg_buf_cb, 0, sizeof(struct ql_rcv_buf_cb));\n\t\t\tlrg_buf_cb->index = i;\n\t\t\tlrg_buf_cb->skb = skb;\n\t\t\t/*\n\t\t\t * We save some space to copy the ethhdr from first\n\t\t\t * buffer\n\t\t\t */\n\t\t\tskb_reserve(skb, QL_HEADER_SPACE);\n\t\t\tmap = pci_map_single(qdev->pdev,\n\t\t\t\t\t     skb->data,\n\t\t\t\t\t     qdev->lrg_buffer_len -\n\t\t\t\t\t     QL_HEADER_SPACE,\n\t\t\t\t\t     PCI_DMA_FROMDEVICE);\n\n\t\t\terr = pci_dma_mapping_error(qdev->pdev, map);\n\t\t\tif (err) {\n\t\t\t\tnetdev_err(qdev->ndev,\n\t\t\t\t\t   \"PCI mapping failed with error: %d\\n\",\n\t\t\t\t\t   err);\n\t\t\t\tdev_kfree_skb_irq(skb);\n\t\t\t\tql_free_large_buffers(qdev);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\tdma_unmap_addr_set(lrg_buf_cb, mapaddr, map);\n\t\t\tdma_unmap_len_set(lrg_buf_cb, maplen,\n\t\t\t\t\t  qdev->lrg_buffer_len -\n\t\t\t\t\t  QL_HEADER_SPACE);\n\t\t\tlrg_buf_cb->buf_phy_addr_low =\n\t\t\t    cpu_to_le32(LS_64BITS(map));\n\t\t\tlrg_buf_cb->buf_phy_addr_high =\n\t\t\t    cpu_to_le32(MS_64BITS(map));\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1, "idx": 11422}
{"commit_id": "55c3f68d638ac1263a386e0aaa004bb6e8bde731", "project": "ArtifexSoftware/mupdf", "func": "static void\npdf_read_new_xref_section(fz_context *ctx, pdf_document *doc, fz_stream *stm, int64_t i0, int i1, int w0, int w1, int w2)\n{\n\tpdf_xref_entry *table;\n\tint i, n;\n\n\tif (i0 < 0 || i0 > PDF_MAX_OBJECT_NUMBER || i1 < 0 || i1 > PDF_MAX_OBJECT_NUMBER || i0 + i1 - 1 > PDF_MAX_OBJECT_NUMBER)\n\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"xref subsection object numbers are out of range\");\n\n\ttable = pdf_xref_find_subsection(ctx, doc, i0, i1);\n\tfor (i = i0; i < i0 + i1; i++)\n\t{\n\t\tpdf_xref_entry *entry = &table[i-i0];\n\t\tint a = 0;\n\t\tint64_t b = 0;\n\t\tint c = 0;\n\n\t\tif (fz_is_eof(ctx, stm))\n\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"truncated xref stream\");\n\n\t\tfor (n = 0; n < w0; n++)\n\t\t\ta = (a << 8) + fz_read_byte(ctx, stm);\n\t\tfor (n = 0; n < w1; n++)\n\t\t\tb = (b << 8) + fz_read_byte(ctx, stm);\n\t\tfor (n = 0; n < w2; n++)\n\t\t\tc = (c << 8) + fz_read_byte(ctx, stm);\n\n\t\tif (!entry->type)\n\t\t{\n\t\t\tint t = w0 ? a : 1;\n\t\t\tentry->type = t == 0 ? 'f' : t == 1 ? 'n' : t == 2 ? 'o' : 0;\n\t\t\tentry->ofs = w1 ? b : 0;\n\t\t\tentry->gen = w2 ? c : 0;\n\t\t\tentry->num = i;\n\t\t}\n\t}\n\n\tdoc->has_xref_streams = 1;\n}", "target": 2, "idx": 11423}
{"commit_id": "7892032cfe67f4bde6fc2ee967e45a8fbaf33756", "project": "kernel/git/netdev/net", "func": "static void ip6gre_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\t       u8 type, u8 code, int offset, __be32 info)\n{\n\tconst struct gre_base_hdr *greh;\n\tconst struct ipv6hdr *ipv6h;\n\tint grehlen = sizeof(*greh);\n\tstruct ip6_tnl *t;\n\tint key_off = 0;\n\t__be16 flags;\n\t__be32 key;\n\n\tif (!pskb_may_pull(skb, offset + grehlen))\n\t\treturn;\n\tgreh = (const struct gre_base_hdr *)(skb->data + offset);\n\tflags = greh->flags;\n\tif (flags & (GRE_VERSION | GRE_ROUTING))\n\t\treturn;\n\tif (flags & GRE_CSUM)\n\t\tgrehlen += 4;\n\tif (flags & GRE_KEY) {\n\t\tkey_off = grehlen + offset;\n\t\tgrehlen += 4;\n\t}\n\n\tif (!pskb_may_pull(skb, offset + grehlen))\n\t\treturn;\n\tipv6h = (const struct ipv6hdr *)skb->data;\n\tgreh = (const struct gre_base_hdr *)(skb->data + offset);\n\tkey = key_off ? *(__be32 *)(skb->data + key_off) : 0;\n\n\tt = ip6gre_tunnel_lookup(skb->dev, &ipv6h->daddr, &ipv6h->saddr,\n\t\t\t\t key, greh->protocol);\n\tif (!t)\n\t\treturn;\n\n\tswitch (type) {\n\t\t__u32 teli;\n\t\tstruct ipv6_tlv_tnl_enc_lim *tel;\n\t\t__u32 mtu;\n\tcase ICMPV6_DEST_UNREACH:\n\t\tnet_dbg_ratelimited(\"%s: Path to destination invalid or inactive!\\n\",\n\t\t\t\t    t->parms.name);\n\t\tbreak;\n\tcase ICMPV6_TIME_EXCEED:\n\t\tif (code == ICMPV6_EXC_HOPLIMIT) {\n\t\t\tnet_dbg_ratelimited(\"%s: Too small hop limit or routing loop in tunnel!\\n\",\n\t\t\t\t\t    t->parms.name);\n\t\t}\n\t\tbreak;\n\tcase ICMPV6_PARAMPROB:\n\t\tteli = 0;\n\t\tif (code == ICMPV6_HDR_FIELD)\n\t\t\tteli = ip6_tnl_parse_tlv_enc_lim(skb, skb->data);\n\n\t\tif (teli && teli == be32_to_cpu(info) - 2) {\n\t\t\ttel = (struct ipv6_tlv_tnl_enc_lim *) &skb->data[teli];\n\t\t\tif (tel->encap_limit == 0) {\n\t\t\t\tnet_dbg_ratelimited(\"%s: Too small encapsulation limit or routing loop in tunnel!\\n\",\n\t\t\t\t\t\t    t->parms.name);\n\t\t\t}\n\t\t} else {\n\t\t\tnet_dbg_ratelimited(\"%s: Recipient unable to parse tunneled packet!\\n\",\n\t\t\t\t\t    t->parms.name);\n\t\t}\n\t\tbreak;\n\tcase ICMPV6_PKT_TOOBIG:\n\t\tmtu = be32_to_cpu(info) - offset;\n\t\tif (mtu < IPV6_MIN_MTU)\n\t\t\tmtu = IPV6_MIN_MTU;\n\t\tt->dev->mtu = mtu;\n\t\tbreak;\n\t}\n\n\tif (time_before(jiffies, t->err_time + IP6TUNNEL_ERR_TIMEO))\n\t\tt->err_count++;\n\telse\n\t\tt->err_count = 1;\n\tt->err_time = jiffies;\n}", "target": 3, "idx": 11424}
{"commit_id": "c9f838d104fed6f2f61d68164712e3204bf5271b", "project": "torvalds/linux", "func": "static int install_process_keyring(void)\n{\n\tstruct cred *new;\n\tint ret;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tret = install_process_keyring_to_cred(new);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\treturn ret;\n\t}\n\n\treturn commit_creds(new);\n}", "target": 1, "idx": 11425}
{"commit_id": "ee301cb2029db8a6289c5295daa42bba7715e99a", "project": "DanBloomberg/leptonica", "func": "SEL  *\nselReadStream(FILE  *fp)\n{\nchar    *selname;\nchar     linebuf[L_BUFSIZE];\nl_int32  sy, sx, cy, cx, i, j, version, ignore;\nSEL     *sel;\n\n    PROCNAME(\"selReadStream\");\n\n    if (!fp)\n        return (SEL *)ERROR_PTR(\"stream not defined\", procName, NULL);\n\n    if (fscanf(fp, \"  Sel Version %d\\n\", &version) != 1)\n        return (SEL *)ERROR_PTR(\"not a sel file\", procName, NULL);\n    if (version != SEL_VERSION_NUMBER)\n        return (SEL *)ERROR_PTR(\"invalid sel version\", procName, NULL);\n\n    if (fgets(linebuf, L_BUFSIZE, fp) == NULL)\n        return (SEL *)ERROR_PTR(\"error reading into linebuf\", procName, NULL);\n    selname = stringNew(linebuf);\n    sscanf(linebuf, \"  ------  %200s  ------\", selname);\n\n    if (fscanf(fp, \"  sy = %d, sx = %d, cy = %d, cx = %d\\n\",\n            &sy, &sx, &cy, &cx) != 4) {\n        LEPT_FREE(selname);\n        return (SEL *)ERROR_PTR(\"dimensions not read\", procName, NULL);\n    }\n\n    if ((sel = selCreate(sy, sx, selname)) == NULL) {\n        LEPT_FREE(selname);\n        return (SEL *)ERROR_PTR(\"sel not made\", procName, NULL);\n    }\n    selSetOrigin(sel, cy, cx);\n\n    for (i = 0; i < sy; i++) {\n        ignore = fscanf(fp, \"    \");\n        for (j = 0; j < sx; j++)\n            ignore = fscanf(fp, \"%1d\", &sel->data[i][j]);\n        ignore = fscanf(fp, \"\\n\");\n    }\n    ignore = fscanf(fp, \"\\n\");\n\n    LEPT_FREE(selname);\n    return sel;\n}", "target": 3, "idx": 11426}
{"commit_id": "b4ef4c17d618eba0adccc4c7d9e9a1ef809fc9b6", "project": "stephane/libmodbus", "func": "int modbus_reply(modbus_t *ctx, const uint8_t *req,\n                 int req_length, modbus_mapping_t *mb_mapping)\n{\n    int offset;\n    int slave;\n    int function;\n    uint16_t address;\n    uint8_t rsp[MAX_MESSAGE_LENGTH];\n    int rsp_length = 0;\n    sft_t sft;\n\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    offset = ctx->backend->header_length;\n    slave = req[offset - 1];\n    function = req[offset];\n    address = (req[offset + 1] << 8) + req[offset + 2];\n\n    sft.slave = slave;\n    sft.function = function;\n    sft.t_id = ctx->backend->prepare_response_tid(req, &req_length);\n\n    /* Data are flushed on illegal number of values errors. */\n    switch (function) {\n    case MODBUS_FC_READ_COILS:\n    case MODBUS_FC_READ_DISCRETE_INPUTS: {\n        unsigned int is_input = (function == MODBUS_FC_READ_DISCRETE_INPUTS);\n        int start_bits = is_input ? mb_mapping->start_input_bits : mb_mapping->start_bits;\n        int nb_bits = is_input ? mb_mapping->nb_input_bits : mb_mapping->nb_bits;\n        uint8_t *tab_bits = is_input ? mb_mapping->tab_input_bits : mb_mapping->tab_bits;\n        const char * const name = is_input ? \"read_input_bits\" : \"read_bits\";\n        int nb = (req[offset + 3] << 8) + req[offset + 4];\n        /* The mapping can be shifted to reduce memory consumption and it\n           doesn't always start at address zero. */\n        int mapping_address = address - start_bits;\n\n        if (nb < 1 || MODBUS_MAX_READ_BITS < nb) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,\n                \"Illegal nb of values %d in %s (max %d)\\n\",\n                nb, name, MODBUS_MAX_READ_BITS);\n        } else if (mapping_address < 0 || (mapping_address + nb) > nb_bits) {\n            rsp_length = response_exception(\n                ctx, &sft,\n                MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in %s\\n\",\n                mapping_address < 0 ? address : address + nb, name);\n        } else {\n            rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n            rsp[rsp_length++] = (nb / 8) + ((nb % 8) ? 1 : 0);\n            rsp_length = response_io_status(tab_bits, mapping_address, nb,\n                                            rsp, rsp_length);\n        }\n    }\n        break;\n    case MODBUS_FC_READ_HOLDING_REGISTERS:\n    case MODBUS_FC_READ_INPUT_REGISTERS: {\n        unsigned int is_input = (function == MODBUS_FC_READ_INPUT_REGISTERS);\n        int start_registers = is_input ? mb_mapping->start_input_registers : mb_mapping->start_registers;\n        int nb_registers = is_input ? mb_mapping->nb_input_registers : mb_mapping->nb_registers;\n        uint16_t *tab_registers = is_input ? mb_mapping->tab_input_registers : mb_mapping->tab_registers;\n        const char * const name = is_input ? \"read_input_registers\" : \"read_registers\";\n        int nb = (req[offset + 3] << 8) + req[offset + 4];\n        /* The mapping can be shifted to reduce memory consumption and it\n           doesn't always start at address zero. */\n        int mapping_address = address - start_registers;\n\n        if (nb < 1 || MODBUS_MAX_READ_REGISTERS < nb) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,\n                \"Illegal nb of values %d in %s (max %d)\\n\",\n                nb, name, MODBUS_MAX_READ_REGISTERS);\n        } else if (mapping_address < 0 || (mapping_address + nb) > nb_registers) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in %s\\n\",\n                mapping_address < 0 ? address : address + nb, name);\n        } else {\n            int i;\n\n            rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n            rsp[rsp_length++] = nb << 1;\n            for (i = mapping_address; i < mapping_address + nb; i++) {\n                rsp[rsp_length++] = tab_registers[i] >> 8;\n                rsp[rsp_length++] = tab_registers[i] & 0xFF;\n            }\n        }\n    }\n        break;\n    case MODBUS_FC_WRITE_SINGLE_COIL: {\n        int mapping_address = address - mb_mapping->start_bits;\n\n        if (mapping_address < 0 || mapping_address >= mb_mapping->nb_bits) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in write_bit\\n\",\n                address);\n        } else {\n            int data = (req[offset + 3] << 8) + req[offset + 4];\n\n            if (data == 0xFF00 || data == 0x0) {\n                mb_mapping->tab_bits[mapping_address] = data ? ON : OFF;\n                memcpy(rsp, req, req_length);\n                rsp_length = req_length;\n            } else {\n                rsp_length = response_exception(\n                    ctx, &sft,\n                    MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, FALSE,\n                    \"Illegal data value 0x%0X in write_bit request at address %0X\\n\",\n                    data, address);\n            }\n        }\n    }\n        break;\n    case MODBUS_FC_WRITE_SINGLE_REGISTER: {\n        int mapping_address = address - mb_mapping->start_registers;\n\n        if (mapping_address < 0 || mapping_address >= mb_mapping->nb_registers) {\n            rsp_length = response_exception(\n                ctx, &sft,\n                MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in write_register\\n\",\n                address);\n        } else {\n            int data = (req[offset + 3] << 8) + req[offset + 4];\n\n            mb_mapping->tab_registers[mapping_address] = data;\n            memcpy(rsp, req, req_length);\n            rsp_length = req_length;\n        }\n    }\n        break;\n    case MODBUS_FC_WRITE_MULTIPLE_COILS: {\n        int nb = (req[offset + 3] << 8) + req[offset + 4];\n        int nb_bits = req[offset + 5];\n        int mapping_address = address - mb_mapping->start_bits;\n\n        if (nb < 1 || MODBUS_MAX_WRITE_BITS < nb || nb_bits * 8 < nb) {\n            /* May be the indication has been truncated on reading because of\n             * invalid address (eg. nb is 0 but the request contains values to\n             * write) so it's necessary to flush. */\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,\n                \"Illegal number of values %d in write_bits (max %d)\\n\",\n                nb, MODBUS_MAX_WRITE_BITS);\n        } else if (mapping_address < 0 ||\n                   (mapping_address + nb) > mb_mapping->nb_bits) {\n            rsp_length = response_exception(\n                ctx, &sft,\n                MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in write_bits\\n\",\n                mapping_address < 0 ? address : address + nb);\n        } else {\n            /* 6 = byte count */\n            modbus_set_bits_from_bytes(mb_mapping->tab_bits, mapping_address, nb,\n                                       &req[offset + 6]);\n\n            rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n            /* 4 to copy the bit address (2) and the quantity of bits */\n            memcpy(rsp + rsp_length, req + rsp_length, 4);\n            rsp_length += 4;\n        }\n    }\n        break;\n    case MODBUS_FC_WRITE_MULTIPLE_REGISTERS: {\n        int nb = (req[offset + 3] << 8) + req[offset + 4];\n        int nb_bytes = req[offset + 5];\n        int mapping_address = address - mb_mapping->start_registers;\n\n        if (nb < 1 || MODBUS_MAX_WRITE_REGISTERS < nb || nb_bytes != nb * 2) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,\n                \"Illegal number of values %d in write_registers (max %d)\\n\",\n                nb, MODBUS_MAX_WRITE_REGISTERS);\n        } else if (mapping_address < 0 ||\n                   (mapping_address + nb) > mb_mapping->nb_registers) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in write_registers\\n\",\n                mapping_address < 0 ? address : address + nb);\n        } else {\n            int i, j;\n            for (i = mapping_address, j = 6; i < mapping_address + nb; i++, j += 2) {\n                /* 6 and 7 = first value */\n                mb_mapping->tab_registers[i] =\n                    (req[offset + j] << 8) + req[offset + j + 1];\n            }\n\n            rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n            /* 4 to copy the address (2) and the no. of registers */\n            memcpy(rsp + rsp_length, req + rsp_length, 4);\n            rsp_length += 4;\n        }\n    }\n        break;\n    case MODBUS_FC_REPORT_SLAVE_ID: {\n        int str_len;\n        int byte_count_pos;\n\n        rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n        /* Skip byte count for now */\n        byte_count_pos = rsp_length++;\n        rsp[rsp_length++] = _REPORT_SLAVE_ID;\n        /* Run indicator status to ON */\n        rsp[rsp_length++] = 0xFF;\n        /* LMB + length of LIBMODBUS_VERSION_STRING */\n        str_len = 3 + strlen(LIBMODBUS_VERSION_STRING);\n        memcpy(rsp + rsp_length, \"LMB\" LIBMODBUS_VERSION_STRING, str_len);\n        rsp_length += str_len;\n        rsp[byte_count_pos] = rsp_length - byte_count_pos - 1;\n    }\n        break;\n    case MODBUS_FC_READ_EXCEPTION_STATUS:\n        if (ctx->debug) {\n            fprintf(stderr, \"FIXME Not implemented\\n\");\n        }\n        errno = ENOPROTOOPT;\n        return -1;\n        break;\n    case MODBUS_FC_MASK_WRITE_REGISTER: {\n        int mapping_address = address - mb_mapping->start_registers;\n\n        if (mapping_address < 0 || mapping_address >= mb_mapping->nb_registers) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in write_register\\n\",\n                address);\n        } else {\n            uint16_t data = mb_mapping->tab_registers[mapping_address];\n            uint16_t and = (req[offset + 3] << 8) + req[offset + 4];\n            uint16_t or = (req[offset + 5] << 8) + req[offset + 6];\n\n            data = (data & and) | (or & (~and));\n            mb_mapping->tab_registers[mapping_address] = data;\n            memcpy(rsp, req, req_length);\n            rsp_length = req_length;\n        }\n    }\n        break;\n    case MODBUS_FC_WRITE_AND_READ_REGISTERS: {\n        int nb = (req[offset + 3] << 8) + req[offset + 4];\n        uint16_t address_write = (req[offset + 5] << 8) + req[offset + 6];\n        int nb_write = (req[offset + 7] << 8) + req[offset + 8];\n        int nb_write_bytes = req[offset + 9];\n        int mapping_address = address - mb_mapping->start_registers;\n        int mapping_address_write = address_write - mb_mapping->start_registers;\n\n        if (nb_write < 1 || MODBUS_MAX_WR_WRITE_REGISTERS < nb_write ||\n            nb < 1 || MODBUS_MAX_WR_READ_REGISTERS < nb ||\n            nb_write_bytes != nb_write * 2) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,\n                \"Illegal nb of values (W%d, R%d) in write_and_read_registers (max W%d, R%d)\\n\",\n                nb_write, nb, MODBUS_MAX_WR_WRITE_REGISTERS, MODBUS_MAX_WR_READ_REGISTERS);\n        } else if (mapping_address < 0 ||\n                   (mapping_address + nb) > mb_mapping->nb_registers ||\n                   mapping_address_write < 0 ||\n                   (mapping_address_write + nb_write) > mb_mapping->nb_registers) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data read address 0x%0X or write address 0x%0X write_and_read_registers\\n\",\n                mapping_address < 0 ? address : address + nb,\n                mapping_address_write < 0 ? address_write : address_write + nb_write);\n        } else {\n            int i, j;\n            rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n            rsp[rsp_length++] = nb << 1;\n\n            /* Write first.\n               10 and 11 are the offset of the first values to write */\n            for (i = mapping_address_write, j = 10;\n                 i < mapping_address_write + nb_write; i++, j += 2) {\n                mb_mapping->tab_registers[i] =\n                    (req[offset + j] << 8) + req[offset + j + 1];\n            }\n\n            /* and read the data for the response */\n            for (i = mapping_address; i < mapping_address + nb; i++) {\n                rsp[rsp_length++] = mb_mapping->tab_registers[i] >> 8;\n                rsp[rsp_length++] = mb_mapping->tab_registers[i] & 0xFF;\n            }\n        }\n    }\n        break;\n\n    default:\n        rsp_length = response_exception(\n            ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_FUNCTION, rsp, TRUE,\n            \"Unknown Modbus function code: 0x%0X\\n\", function);\n        break;\n    }\n\n    /* Suppress any responses when the request was a broadcast */\n    return (ctx->backend->backend_type == _MODBUS_BACKEND_TYPE_RTU &&\n            slave == MODBUS_BROADCAST_ADDRESS) ? 0 : send_msg(ctx, rsp, rsp_length);\n}", "target": 2, "idx": 11427}
{"commit_id": "5d45b69b590cabc5127282d1ade3bca1598e5f5c", "project": "wireshark", "func": "static gint\ndissect_wccp2_alternate_mask_assignment_data_element(tvbuff_t *tvb, int offset, gint length, packet_info *pinfo,\n                                                     proto_tree *info_tree, wccp_address_table* addr_table)\n{\n  proto_tree *mask_tree;\n\n  mask_tree = proto_tree_add_subtree(info_tree, tvb, offset, length,\n                                  ett_alternate_mask_assignment_data_element, NULL, \"Alternate Mask Assignment Data\");\n\n  if (length < 4)\n    return length-4;\n\n  if (length > 4)\n    for (;length >4;)\n      {\n        gint new_length;\n\n        new_length=dissect_wccp2_alternate_mask_value_set_list(tvb, offset, length, pinfo, mask_tree, addr_table);\n\n        CHECK_LENGTH_ADVANCE_OFFSET(new_length);\n      }\n\n  if (length < 2)\n    return -2;\n\n  return  dissect_wccp2_assignment_weight_and_status_element(tvb, offset, length, pinfo, info_tree);\n}", "target": 2, "idx": 11428}
{"commit_id": "425e8a9a59d49378d57e2116b6c9b0190a5986f5", "project": "Blosc/c-blosc2", "func": "int zfp_prec_decompress(const uint8_t *input, int32_t input_len, uint8_t *output,\n                        int32_t output_len, uint8_t meta, blosc2_dparams *dparams, const void *chunk) {\n  ZFP_ERROR_NULL(input);\n  ZFP_ERROR_NULL(output);\n  ZFP_ERROR_NULL(dparams);\n  ZFP_ERROR_NULL(dparams->schunk);\n  BLOSC_UNUSED_PARAM(chunk);\n\n  blosc2_schunk *sc = dparams->schunk;\n  int32_t typesize = sc->typesize;\n  int8_t ndim;\n  int64_t *shape = malloc(8 * sizeof(int64_t));\n  int32_t *chunkshape = malloc(8 * sizeof(int32_t));\n  int32_t *blockshape = malloc(8 * sizeof(int32_t));\n  uint8_t *smeta;\n  int32_t smeta_len;\n  if (blosc2_meta_get(sc, \"b2nd\", &smeta, &smeta_len) < 0) {\n    BLOSC_TRACE_ERROR(\"Cannot access b2nd meta info\");\n    free(shape);\n    free(chunkshape);\n    free(blockshape);\n    return BLOSC2_ERROR_FAILURE;\n  }\n  deserialize_meta(smeta, smeta_len, &ndim, shape, chunkshape, blockshape);\n  free(smeta);\n\n  zfp_type type;     /* array scalar type */\n  zfp_field *field;  /* array meta data */\n  zfp_stream *zfp;   /* compressed stream */\n  bitstream *stream; /* bit stream to write to or read from */\n  size_t zfpsize;    /* byte size of compressed stream */\n\n  uint prec;\n  switch (ndim) {\n    case 1:\n      prec = meta + 5;\n      break;\n    case 2:\n      prec = meta + 7;\n      break;\n    case 3:\n      prec = meta + 9;\n      break;\n    case 4:\n      prec = meta + 11;\n      break;\n    default:\n      free(shape);\n      free(chunkshape);\n      free(blockshape);\n      BLOSC_TRACE_ERROR(\"ZFP is not available for ndims: %d\", ndim);\n      return BLOSC2_ERROR_FAILURE;\n  }\n\n  if (prec > ZFP_MAX_PREC) {\n    BLOSC_TRACE_ERROR(\"Max precision for this codecs is %d\", ZFP_MAX_PREC);\n    prec = ZFP_MAX_PREC;\n  }\n\n  switch (typesize) {\n    case sizeof(float):\n      type = zfp_type_float;\n      break;\n    case sizeof(double):\n      type = zfp_type_double;\n      break;\n    default:\n      free(shape);\n      free(chunkshape);\n      free(blockshape);\n      BLOSC_TRACE_ERROR(\"ZFP is not available for typesize: %d\", typesize);\n      return BLOSC2_ERROR_FAILURE;\n  }\n\n  zfp = zfp_stream_open(NULL);\n  zfp_stream_set_precision(zfp, prec);\n  stream = stream_open((void *) input, input_len);\n  zfp_stream_set_bit_stream(zfp, stream);\n  zfp_stream_rewind(zfp);\n\n  switch (ndim) {\n    case 1:\n      field = zfp_field_1d((void *) output, type, blockshape[0]);\n      break;\n    case 2:\n      field = zfp_field_2d((void *) output, type, blockshape[1], blockshape[0]);\n      break;\n    case 3:\n      field = zfp_field_3d((void *) output, type, blockshape[2], blockshape[1], blockshape[0]);\n      break;\n    case 4:\n      field = zfp_field_4d((void *) output, type, blockshape[3], blockshape[2], blockshape[1], blockshape[0]);\n      break;\n    default:\n      free(shape);\n      free(chunkshape);\n      free(blockshape);\n      BLOSC_TRACE_ERROR(\"ZFP is not available for ndims: %d\", ndim);\n      return BLOSC2_ERROR_FAILURE;\n  }\n\n  zfpsize = zfp_decompress(zfp, field);\n\n  /* clean up */\n  zfp_field_free(field);\n  zfp_stream_close(zfp);\n  stream_close(stream);\n  free(shape);\n  free(chunkshape);\n  free(blockshape);\n\n  if (zfpsize == 0) {\n    BLOSC_TRACE_ERROR(\"\\n ZFP: Decompression failed\\n\");\n    return (int) zfpsize;\n  }\n\n  return (int) output_len;\n}", "target": 2, "idx": 11429}
{"commit_id": "34a08bec755670ea0490cb53bbc68058cafc69b6", "project": "OP-TEE/optee_os", "func": "TEE_Result syscall_hash_update(unsigned long state, const void *chunk,\n\t\t\tsize_t chunk_size)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\n\t/* No data, but size provided isn't valid parameters. */\n\tif (!chunk && chunk_size)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t/* Zero length hash is valid, but nothing we need to do. */\n\tif (!chunk_size)\n\t\treturn TEE_SUCCESS;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)chunk, chunk_size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tswitch (TEE_ALG_GET_CLASS(cs->algo)) {\n\tcase TEE_OPERATION_DIGEST:\n\t\tres = crypto_hash_update(cs->ctx, cs->algo, chunk, chunk_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\tres = crypto_mac_update(cs->ctx, cs->algo, chunk, chunk_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\treturn TEE_SUCCESS;\n}", "target": 3, "idx": 11430}
{"commit_id": "fb1ab50e448ddbed746fd27ae07469bc506d838b", "project": "bfabiszewski/libmobi", "func": "MOBI_RET mobi_reconstruct_infl(char *outstring, const MOBIIndx *infl, const MOBIIndexEntry *orth_entry) {\n    const char *label = orth_entry->label;\n    uint32_t *infl_groups = NULL;\n    size_t infl_count = mobi_get_indxentry_tagarray(&infl_groups, orth_entry, INDX_TAGARR_ORTH_INFL);\n    \n    if (infl_count == 0 || !infl_groups) {\n        return MOBI_SUCCESS;\n    }    \n    const char *start_tag = \"<idx:infl>\";\n    const char *end_tag = \"</idx:infl>\";\n    const char *iform_tag = \"<idx:iform%s value=\\\"%s\\\"/>\";\n    char name_attr[INDX_INFLBUF_SIZEMAX + 1];\n    char infl_tag[INDX_INFLBUF_SIZEMAX + 1];\n    strcpy(outstring, start_tag);\n    size_t initlen = strlen(start_tag) + strlen(end_tag);\n    size_t outlen = initlen;\n    size_t label_length = strlen(label);\n    if (label_length > INDX_INFLBUF_SIZEMAX) {\n        debug_print(\"Entry label too long (%s)\\n\", label);\n        return MOBI_DATA_CORRUPT;\n    }\n    if (infl->cncx_record == NULL) {\n        debug_print(\"%s\\n\", \"Missing cncx record\");\n        return MOBI_DATA_CORRUPT;\n    }\n    for (size_t i = 0; i < infl_count; i++) {\n        size_t offset = infl_groups[i];\n        if (offset >= infl->entries_count) {\n            debug_print(\"%s\\n\", \"Invalid entry offset\");\n            return MOBI_DATA_CORRUPT;\n        }\n        uint32_t *groups;\n        size_t group_cnt = mobi_get_indxentry_tagarray(&groups, &infl->entries[offset], INDX_TAGARR_INFL_GROUPS);\n        uint32_t *parts;\n        size_t part_cnt = mobi_get_indxentry_tagarray(&parts, &infl->entries[offset], INDX_TAGARR_INFL_PARTS_V2);\n        if (group_cnt != part_cnt) {\n            return MOBI_DATA_CORRUPT;\n        }\n        for (size_t j = 0; j < part_cnt; j++) {\n            name_attr[0] = '\\0';\n            char *group_name = mobi_get_cncx_string(infl->cncx_record, groups[j]);\n            if (group_name == NULL) {\n                debug_print(\"%s\\n\", \"Memory allocation failed\");\n                return MOBI_MALLOC_FAILED;\n            }\n            if (strlen(group_name)) {\n                snprintf(name_attr, INDX_INFLBUF_SIZEMAX, \" name=\\\"%s\\\"\", group_name);\n            }\n            free(group_name);\n            \n            unsigned char decoded[INDX_INFLBUF_SIZEMAX + 1];\n            memset(decoded, 0, INDX_INFLBUF_SIZEMAX + 1);\n            if (parts[j] >= infl->entries_count) {\n                debug_print(\"%s\\n\", \"Invalid entry offset\");\n                return MOBI_DATA_CORRUPT;\n            }\n            unsigned char *rule = (unsigned char *) infl->entries[parts[j]].label;\n            memcpy(decoded, label, label_length);\n            int decoded_length = (int) label_length;\n            MOBI_RET ret = mobi_decode_infl(decoded, &decoded_length, rule);\n            if (ret != MOBI_SUCCESS) {\n                return ret;\n            }\n            if (decoded_length == 0) {\n                continue;\n            }\n            int n = snprintf(infl_tag, INDX_INFLBUF_SIZEMAX, iform_tag, name_attr, decoded);\n            if (n > INDX_INFLBUF_SIZEMAX) {\n                debug_print(\"Skipping truncated tag: %s\\n\", infl_tag);\n                continue;\n            }\n            outlen += strlen(infl_tag);\n            if (outlen > INDX_INFLTAG_SIZEMAX) {\n                debug_print(\"Inflections text in %s too long (%zu)\\n\", label, outlen);\n                return MOBI_ERROR;\n            }\n            strcat(outstring, infl_tag);\n        }\n    }\n    if (outlen == initlen) {\n        outstring[0] = '\\0';\n    } else {\n        strcat(outstring, end_tag);\n    }\n    return MOBI_SUCCESS;\n}", "target": 2, "idx": 11431}
{"commit_id": "5517e22250e935dc7f86f64ad414aeae3dbcb36a", "project": "gerbv", "func": "void\ngerb_fclose(gerb_file_t *fd)\n{\n    if (fd) {\n        g_free(fd->filename);\n\n#ifdef HAVE_SYS_MMAN_H\n\tif (munmap(fd->data, fd->datalen) < 0)\n\t    GERB_FATAL_ERROR(\"munmap: %s\", strerror(errno));\n#else\n\tg_free(fd->data);\n#endif   \n\tif (fclose(fd->fd) == EOF)\n\t    GERB_FATAL_ERROR(\"fclose: %s\", strerror(errno));\n\tg_free(fd);\n    }\n\n    return;\n}", "target": 1, "idx": 11432}
{"commit_id": "29c63b786ae028d82405421585e91283c8fa0da3", "project": "apache/httpd", "func": "apr_status_t h2_stream_add_header(h2_stream *stream,\n                                  const char *name, size_t nlen,\n                                  const char *value, size_t vlen)\n{\n    int error = 0;\n    ap_assert(stream);\n    \n    if (stream->has_response) {\n        return APR_EINVAL;    \n    }\n    ++stream->request_headers_added;\n    if (name[0] == ':') {\n        if ((vlen) > stream->session->s->limit_req_line) {\n            /* pseudo header: approximation of request line size check */\n            ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, stream->session->c,\n                          \"h2_stream(%ld-%d): pseudo header %s too long\", \n                          stream->session->id, stream->id, name);\n            error = HTTP_REQUEST_URI_TOO_LARGE;\n        }\n    }\n    else if ((nlen + 2 + vlen) > stream->session->s->limit_req_fieldsize) {\n        /* header too long */\n        ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, stream->session->c,\n                      \"h2_stream(%ld-%d): header %s too long\", \n                      stream->session->id, stream->id, name);\n        error = HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;\n    }\n    \n    if (stream->request_headers_added \n        > stream->session->s->limit_req_fields + 4) {\n        /* too many header lines, include 4 pseudo headers */\n        if (stream->request_headers_added \n            > stream->session->s->limit_req_fields + 4 + 100) {\n            /* yeah, right */\n            return APR_ECONNRESET;\n        }\n        ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, stream->session->c,\n                      \"h2_stream(%ld-%d): too many header lines\", \n                      stream->session->id, stream->id);\n        error = HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;\n    }\n    \n    if (h2_stream_is_scheduled(stream)) {\n        return add_trailer(stream, name, nlen, value, vlen);\n    }\n    else if (error) {\n        return h2_stream_set_error(stream, error); \n    }\n    else {\n        if (!stream->rtmp) {\n            stream->rtmp = h2_req_create(stream->id, stream->pool, \n                                         NULL, NULL, NULL, NULL, NULL, 0);\n        }\n        if (stream->state != H2_STREAM_ST_OPEN) {\n            return APR_ECONNRESET;\n        }\n        return h2_request_add_header(stream->rtmp, stream->pool,\n                                     name, nlen, value, vlen);\n    }\n}", "target": 2, "idx": 11433}
{"commit_id": "dfd0743f1d9ea76931510ed150334d571fbab49d", "project": "torvalds/linux", "func": "int tee_shm_get_fd(struct tee_shm *shm)\n{\n\tint fd;\n\n\tif (!(shm->flags & TEE_SHM_DMA_BUF))\n\t\treturn -EINVAL;\n\n\t/* matched by tee_shm_put() in tee_shm_op_release() */\n\trefcount_inc(&shm->refcount);\n\tfd = anon_inode_getfd(\"tee_shm\", &tee_shm_fops, shm, O_RDWR);\n\tif (fd < 0)\n\t\ttee_shm_put(shm);\n\treturn fd;\n}", "target": 2, "idx": 11434}
{"commit_id": "8d2e02ae650f00c4a53deb625211a0527126c605", "project": "xorg/lib/libX11", "func": "int\nXSetCommand (\n\tDisplay *dpy,\n\tWindow w,\n\tchar **argv,\n\tint argc)\n{\n\tregister int i;\n\tsize_t nbytes;\n\tregister char *buf, *bp;\n\tfor (i = 0, nbytes = 0; i < argc; i++) {\n\t\tnbytes += safestrlen(argv[i]) + 1;\n\t\tif (nbytes >= USHRT_MAX)\n                    return 1;\n\t}\n\tif ((bp = buf = Xmalloc(nbytes))) {\n\t    /* copy arguments into single buffer */\n\t    for (i = 0; i < argc; i++) {\n\t\tif (argv[i]) {\n\t\t    (void) strcpy(bp, argv[i]);\n\t\t    bp += strlen(argv[i]) + 1;\n\t\t}\n\t\telse\n\t\t    *bp++ = '\\0';\n\t    }\n\t    XChangeProperty (dpy, w, XA_WM_COMMAND, XA_STRING, 8,\n\t\t\t     PropModeReplace, (unsigned char *)buf, nbytes);\n\t    Xfree(buf);\n\t}\n\treturn 1;\n}", "target": 3, "idx": 11435}
{"commit_id": "c6173f5fe66cdbab74f4f869311fe6aae2ba35f4", "project": "tensorflow", "func": "TfLiteStatus Subgraph::Invoke() {\n  SubgraphGuard guard(&context_, &is_subgraph_in_use_);\n  TF_LITE_ENSURE_OK(&context_, guard.status());\n\n  if (!consistent_) {\n    ReportError(\"Invoke called on model that is not consistent.\");\n    return kTfLiteError;\n  }\n\n  TfLiteStatus status = kTfLiteOk;\n  if (state_ == kStateUninvokable) {\n    ReportError(\"Invoke called on model that is not ready.\");\n    return kTfLiteError;\n  } else if (memory_planner_ && !memory_planner_->HasNonPersistentMemory()) {\n    ReportError(\"Non-persistent memory is not available.\");\n    return kTfLiteError;\n  }\n  TFLITE_SCOPED_TAGGED_DEFAULT_PROFILE(profiler_.get(), \"Invoke\");\n\n  // Invocations are always done in node order.\n  // Note that calling Invoke repeatedly will cause the original memory plan to\n  // be reused, unless either ResizeInputTensor() or AllocateTensors() has been\n  // called.\n  for (int execution_plan_index = 0;\n       execution_plan_index < execution_plan_.size(); execution_plan_index++) {\n    if (execution_plan_index == next_execution_plan_index_to_prepare_) {\n      TF_LITE_ENSURE_STATUS(PrepareOpsAndTensors());\n      TF_LITE_ENSURE(&context_, next_execution_plan_index_to_prepare_ >=\n                                    execution_plan_index);\n    }\n    int node_index = execution_plan_[execution_plan_index];\n    TfLiteNode& node = nodes_and_registration_[node_index].first;\n    const TfLiteRegistration& registration =\n        nodes_and_registration_[node_index].second;\n\n    const char* op_name = nullptr;\n    if (profiler_) op_name = GetTFLiteOpName(registration);\n    TFLITE_SCOPED_TAGGED_OPERATOR_PROFILE(profiler_.get(), op_name, node_index);\n\n    for (int i = 0; i < node.inputs->size; ++i) {\n      int tensor_index = node.inputs->data[i];\n      if (tensor_index == kTfLiteOptionalTensor) {\n        continue;\n      }\n      TfLiteTensor* tensor = &tensors_[tensor_index];\n      if (tensor->delegate && tensor->delegate != node.delegate &&\n          tensor->data_is_stale) {\n        TF_LITE_ENSURE_STATUS(EnsureTensorDataIsReadable(tensor_index));\n      }\n      if (tensor->data.raw == nullptr && tensor->bytes > 0) {\n        if (registration.builtin_code == kTfLiteBuiltinReshape && i == 1 &&\n            tensor->dims->size != 1) {\n          // In general, having a tensor here with no buffer will be an error.\n          // However, for the reshape operator, the second input tensor is\n          // sometimes only used for the shape, not for the data. Thus, null\n          // buffer is ok in this situation.\n          // The situation where null buffer is not ok for reshape operator is\n          // only when there are 2 inputs given to the node and the one\n          // corresponding to the shape (i == 1) is a vector that contains all\n          // dimensions. See `GetOutputShape()` function in\n          // `tensorflow/lite/kernels/reshape.cc`\n          continue;\n        } else {\n          // In all other cases, we need to return an error as otherwise we will\n          // trigger a null pointer dereference (likely).\n          ReportError(\"Input tensor %d lacks data\", tensor_index);\n          return kTfLiteError;\n        }\n      }\n    }\n\n    if (check_cancelled_func_ != nullptr &&\n        check_cancelled_func_(cancellation_data_)) {\n      ReportError(\"Client requested cancel during Invoke()\");\n      return kTfLiteError;\n    }\n\n    EnsureTensorsVectorCapacity();\n    tensor_resized_since_op_invoke_ = false;\n    if (OpInvoke(registration, &node) != kTfLiteOk) {\n      return ReportOpError(&context_, node, registration, node_index,\n                           \"failed to invoke\");\n    }\n\n    // Force execution prep for downstream ops if the latest op triggered the\n    // resize of a dynamic tensor.\n    if (tensor_resized_since_op_invoke_ &&\n        HasDynamicTensor(context_, node.outputs)) {\n      next_execution_plan_index_to_prepare_ = execution_plan_index + 1;\n\n      // This happens when an intermediate dynamic tensor is resized.\n      // We don't have to prepare all the ops, but we need to recompute\n      // the allocation plan.\n      if (next_execution_plan_index_to_plan_allocation_ >\n          next_execution_plan_index_to_prepare_) {\n        next_execution_plan_index_to_plan_allocation_ =\n            next_execution_plan_index_to_prepare_;\n        if (memory_planner_) {\n          TF_LITE_ENSURE_STATUS(memory_planner_->ResetAllocationsAfter(\n              next_execution_plan_index_to_plan_allocation_ - 1));\n        }\n      }\n    }\n  }\n\n  return status;\n}", "target": 2, "idx": 11436}
{"commit_id": "2871c70efaaaa0f102557a17c727fd4d5204dd4b", "project": "php/php-src", "func": "PHPAPI zend_string *php_escape_shell_cmd(char *str)\n{\n\tregister int x, y, l = (int)strlen(str);\n\tsize_t estimate = (2 * l) + 1;\n\tzend_string *cmd;\n#ifndef PHP_WIN32\n\tchar *p = NULL;\n#endif\n\n\n\tcmd = zend_string_safe_alloc(2, l, 0, 0);\n\n\tfor (x = 0, y = 0; x < l; x++) {\n\t\tint mb_len = php_mblen(str + x, (l - x));\n\n\t\t/* skip non-valid multibyte characters */\n\t\tif (mb_len < 0) {\n\t\t\tcontinue;\n\t\t} else if (mb_len > 1) {\n\t\t\tmemcpy(ZSTR_VAL(cmd) + y, str + x, mb_len);\n\t\t\ty += mb_len;\n\t\t\tx += mb_len - 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (str[x]) {\n#ifndef PHP_WIN32\n\t\t\tcase '\"':\n\t\t\tcase '\\'':\n\t\t\t\tif (!p && (p = memchr(str + x + 1, str[x], l - x - 1))) {\n\t\t\t\t\t/* noop */\n\t\t\t\t} else if (p && *p == str[x]) {\n\t\t\t\t\tp = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tZSTR_VAL(cmd)[y++] = '\\\\';\n\t\t\t\t}\n\t\t\t\tZSTR_VAL(cmd)[y++] = str[x];\n\t\t\t\tbreak;\n#else\n\t\t\t/* % is Windows specific for environmental variables, ^%PATH% will \n\t\t\t\toutput PATH while ^%PATH^% will not. escapeshellcmd->val will escape all % and !.\n\t\t\t*/\n\t\t\tcase '%':\n\t\t\tcase '!':\n\t\t\tcase '\"':\n\t\t\tcase '\\'':\n#endif\n\t\t\tcase '#': /* This is character-set independent */\n\t\t\tcase '&':\n\t\t\tcase ';':\n\t\t\tcase '`':\n\t\t\tcase '|':\n\t\t\tcase '*':\n\t\t\tcase '?':\n\t\t\tcase '~':\n\t\t\tcase '<':\n\t\t\tcase '>':\n\t\t\tcase '^':\n\t\t\tcase '(':\n\t\t\tcase ')':\n\t\t\tcase '[':\n\t\t\tcase ']':\n\t\t\tcase '{':\n\t\t\tcase '}':\n\t\t\tcase '$':\n\t\t\tcase '\\\\':\n\t\t\tcase '\\x0A': /* excluding these two */\n\t\t\tcase '\\xFF':\n#ifdef PHP_WIN32\n\t\t\t\tZSTR_VAL(cmd)[y++] = '^';\n#else\n\t\t\t\tZSTR_VAL(cmd)[y++] = '\\\\';\n#endif\n\t\t\t\t/* fall-through */\n\t\t\tdefault:\n\t\t\t\tZSTR_VAL(cmd)[y++] = str[x];\n\n\t\t}\n\t}\n\tZSTR_VAL(cmd)[y] = '\\0';\n\n\tif ((estimate - y) > 4096) {\n\t\t/* realloc if the estimate was way overill\n\t\t * Arbitrary cutoff point of 4096 */\n\t\tcmd = zend_string_truncate(cmd, y, 0);\n\t}\n\n\tZSTR_LEN(cmd) = y;\n\n\treturn cmd;\n}", "target": 2, "idx": 11437}
{"commit_id": "b70261a288ea4d2f4ac7cd04be08a9f0f2de4f4d", "project": "torvalds/linux", "func": "int\nmwifiex_cmd_append_vsie_tlv(struct mwifiex_private *priv,\n\t\t\t    u16 vsie_mask, u8 **buffer)\n{\n\tint id, ret_len = 0;\n\tstruct mwifiex_ie_types_vendor_param_set *vs_param_set;\n\n\tif (!buffer)\n\t\treturn 0;\n\tif (!(*buffer))\n\t\treturn 0;\n\n\t/*\n\t * Traverse through the saved vendor specific IE array and append\n\t * the selected(scan/assoc/adhoc) IE as TLV to the command\n\t */\n\tfor (id = 0; id < MWIFIEX_MAX_VSIE_NUM; id++) {\n\t\tif (priv->vs_ie[id].mask & vsie_mask) {\n\t\t\tvs_param_set =\n\t\t\t\t(struct mwifiex_ie_types_vendor_param_set *)\n\t\t\t\t*buffer;\n\t\t\tvs_param_set->header.type =\n\t\t\t\tcpu_to_le16(TLV_TYPE_PASSTHROUGH);\n\t\t\tvs_param_set->header.len =\n\t\t\t\tcpu_to_le16((((u16) priv->vs_ie[id].ie[1])\n\t\t\t\t& 0x00FF) + 2);\n\t\t\tif (le16_to_cpu(vs_param_set->header.len) >\n\t\t\t\tMWIFIEX_MAX_VSIE_LEN) {\n\t\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t\t    \"Invalid param length!\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmemcpy(vs_param_set->ie, priv->vs_ie[id].ie,\n\t\t\t       le16_to_cpu(vs_param_set->header.len));\n\t\t\t*buffer += le16_to_cpu(vs_param_set->header.len) +\n\t\t\t\t   sizeof(struct mwifiex_ie_types_header);\n\t\t\tret_len += le16_to_cpu(vs_param_set->header.len) +\n\t\t\t\t   sizeof(struct mwifiex_ie_types_header);\n\t\t}\n\t}\n\treturn ret_len;\n}", "target": 2, "idx": 11438}
{"commit_id": "135aa9a4a6a9b49b60aa730ebc3bcc6247d75c45", "project": "Moddable-OpenSource/moddable", "func": "void fx_DataView(txMachine* the)\n{\n\ttxSlot* slot;\n\ttxBoolean flag = 0;\n\ttxInteger offset, size;\n\ttxSlot* info;\n\ttxSlot* instance;\n\ttxSlot* view;\n\ttxSlot* buffer;\n\tif (mxIsUndefined(mxTarget))\n\t\tmxTypeError(\"call: DataView\");\n\tif ((mxArgc > 0) && (mxArgv(0)->kind == XS_REFERENCE_KIND)) {\n\t\tslot = mxArgv(0)->value.reference->next;\n\t\tif (slot && ((slot->kind == XS_ARRAY_BUFFER_KIND) || (slot->kind == XS_HOST_KIND))) {\n\t\t\tflag = 1;\n\t\t}\n\t}\n\tif (!flag)\n\t\tmxTypeError(\"buffer is no ArrayBuffer instance\");\n\t\t\n\toffset = fxArgToByteLength(the, 1, 0);\n\tinfo = fxGetBufferInfo(the, mxArgv(0));\n\tif (info->value.bufferInfo.length < offset)\n\t\tmxRangeError(\"out of range byteOffset %ld\", offset);\n\tsize = fxArgToByteLength(the, 2, -1);\n\tif (size >= 0) {\n\t\ttxInteger end = offset + size;\n\t\tif ((info->value.bufferInfo.length < end) || (end < offset))\n\t\t\tmxRangeError(\"out of range byteLength %ld\", size);\n\t}\n\telse {\n\t\tif (info->value.bufferInfo.maxLength < 0)\n\t\t\tsize = info->value.bufferInfo.length - offset;\n\t}\n\tmxPushSlot(mxTarget);\n\tfxGetPrototypeFromConstructor(the, &mxDataViewPrototype);\n\tinstance = fxNewDataViewInstance(the);\n\tmxPullSlot(mxResult);\n\tview = instance->next;\n\tbuffer = view->next;\n\tbuffer->kind = XS_REFERENCE_KIND;\n\tbuffer->value.reference = mxArgv(0)->value.reference;\n\tinfo = fxGetBufferInfo(the, buffer);\n\tif (info->value.bufferInfo.maxLength >= 0) {\n\t\tif (info->value.bufferInfo.length < offset)\n\t\t\tmxRangeError(\"out of range byteOffset %ld\", offset);\n\t\telse if (size >= 0) {\n\t\t\ttxInteger end = offset + size;\n\t\t\tif ((info->value.bufferInfo.length < end) || (end < offset))\n\t\t\t\tmxRangeError(\"out of range byteLength %ld\", size);\n\t\t}\n\t}\n\tview->value.dataView.offset = offset;\n\tview->value.dataView.size = size;\n}", "target": 2, "idx": 11439}
{"commit_id": "8dca25d26c7ca2caf6138267f6f17111212c156e", "project": "the-tcpdump-group/tcpdump", "func": "static const u_char *\nikev1_cert_print(netdissect_options *ndo, u_char tpay _U_,\n\t\t const struct isakmp_gen *ext, u_int item_len,\n\t\t const u_char *ep _U_, uint32_t phase _U_,\n\t\t uint32_t doi0 _U_,\n\t\t uint32_t proto0 _U_, int depth _U_)\n{\n\tconst struct ikev1_pl_cert *p;\n\tstruct ikev1_pl_cert cert;\n\tstatic const char *certstr[] = {\n\t\t\"none\",\t\"pkcs7\", \"pgp\", \"dns\",\n\t\t\"x509sign\", \"x509ke\", \"kerberos\", \"crl\",\n\t\t\"arl\", \"spki\", \"x509attr\",\n\t};\n\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_CERT)));\n\n\tp = (const struct ikev1_pl_cert *)ext;\n\tND_TCHECK(*p);\n\tUNALIGNED_MEMCPY(&cert, ext, sizeof(cert));\n\tND_PRINT((ndo,\" len=%d\", item_len - 4));\n\tND_PRINT((ndo,\" type=%s\", STR_OR_ID((cert.encode), certstr)));\n\tif (2 < ndo->ndo_vflag && 4 < item_len) {\n\t\t/* Print the entire payload in hex */\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), item_len - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + item_len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_CERT)));\n\treturn NULL;\n}", "target": 3, "idx": 11440}
{"commit_id": "ab03f9291b040269ae21d33b9f01529ed8311728", "project": "wolfSSL/wolfssl", "func": "static int Hmac_UpdateFinal_CT(Hmac* hmac, byte* digest, const byte* in,\n                               word32 sz, byte* header)\n{\n    byte lenBytes[8];\n    int  i, j, k;\n    int  blockBits, blockMask;\n    int  realLen, lastBlockLen, macLen, extraLen, eocIndex;\n    int  blocks, safeBlocks, lenBlock, eocBlock;\n    int  maxLen;\n    int  blockSz, padSz;\n    int  ret;\n    byte extraBlock;\n\n    switch (hmac->macType) {\n    #ifndef NO_SHA\n        case WC_SHA:\n            blockSz = WC_SHA_BLOCK_SIZE;\n            blockBits = 6;\n            macLen = WC_SHA_DIGEST_SIZE;\n            padSz = WC_SHA_BLOCK_SIZE - WC_SHA_PAD_SIZE + 1;\n            break;\n    #endif /* !NO_SHA */\n\n    #ifndef NO_SHA256\n        case WC_SHA256:\n            blockSz = WC_SHA256_BLOCK_SIZE;\n            blockBits = 6;\n            macLen = WC_SHA256_DIGEST_SIZE;\n            padSz = WC_SHA256_BLOCK_SIZE - WC_SHA256_PAD_SIZE + 1;\n            break;\n    #endif /* !NO_SHA256 */\n\n    #ifdef WOLFSSL_SHA384\n        case WC_SHA384:\n            blockSz = WC_SHA384_BLOCK_SIZE;\n            blockBits = 7;\n            macLen = WC_SHA384_DIGEST_SIZE;\n            padSz = WC_SHA384_BLOCK_SIZE - WC_SHA384_PAD_SIZE + 1;\n            break;\n    #endif /* WOLFSSL_SHA384 */\n\n    #ifdef WOLFSSL_SHA512\n        case WC_SHA512:\n            blockSz = WC_SHA512_BLOCK_SIZE;\n            blockBits = 7;\n            macLen = WC_SHA512_DIGEST_SIZE;\n            padSz = WC_SHA512_BLOCK_SIZE - WC_SHA512_PAD_SIZE + 1;\n            break;\n    #endif /* WOLFSSL_SHA512 */\n\n        default:\n            return BAD_FUNC_ARG;\n    }\n    blockMask = blockSz - 1;\n\n    /* Size of data to HMAC if padding length byte is zero. */\n    maxLen = WOLFSSL_TLS_HMAC_INNER_SZ + sz - 1 - macLen;\n    /* Complete data (including padding) has block for EOC and/or length. */\n    extraBlock = ctSetLTE((maxLen + padSz) & blockMask, padSz);\n    /* Total number of blocks for data including padding. */\n    blocks = ((maxLen + blockSz - 1) >> blockBits) + extraBlock;\n    /* Up to last 6 blocks can be hashed safely. */\n    safeBlocks = blocks - 6;\n\n    /* Length of message data. */\n    realLen = maxLen - in[sz - 1];\n    /* Number of message bytes in last block. */\n    lastBlockLen = realLen & blockMask;\n    /* Number of padding bytes in last block. */\n    extraLen = ((blockSz * 2 - padSz - lastBlockLen) & blockMask) + 1;\n    /* Number of blocks to create for hash. */\n    lenBlock = (realLen + extraLen) >> blockBits;\n    /* Block containing EOC byte. */\n    eocBlock = realLen >> blockBits;\n    /* Index of EOC byte in block. */\n    eocIndex = realLen & blockMask;\n\n    /* Add length of hmac's ipad to total length. */\n    realLen += blockSz;\n    /* Length as bits - 8 bytes bigendian. */\n    c32toa(realLen >> ((sizeof(word32) * 8) - 3), lenBytes);\n    c32toa(realLen << 3, lenBytes + sizeof(word32));\n\n    ret = Hmac_HashUpdate(hmac, (unsigned char*)hmac->ipad, blockSz);\n    if (ret != 0)\n        return ret;\n\n    XMEMSET(hmac->innerHash, 0, macLen);\n\n    if (safeBlocks > 0) {\n        ret = Hmac_HashUpdate(hmac, header, WOLFSSL_TLS_HMAC_INNER_SZ);\n        if (ret != 0)\n            return ret;\n        ret = Hmac_HashUpdate(hmac, in, safeBlocks * blockSz -\n                                                     WOLFSSL_TLS_HMAC_INNER_SZ);\n        if (ret != 0)\n            return ret;\n    }\n    else\n        safeBlocks = 0;\n\n    XMEMSET(digest, 0, macLen);\n    k = safeBlocks * blockSz;\n    for (i = safeBlocks; i < blocks; i++) {\n        unsigned char hashBlock[WC_MAX_BLOCK_SIZE];\n        unsigned char isEocBlock = ctMaskEq(i, eocBlock);\n        unsigned char isOutBlock = ctMaskEq(i, lenBlock);\n\n        for (j = 0; j < blockSz; j++, k++) {\n            unsigned char atEoc = ctMaskEq(j, eocIndex) & isEocBlock;\n            unsigned char pastEoc = ctMaskGT(j, eocIndex) & isEocBlock;\n            unsigned char b = 0;\n\n            if (k < WOLFSSL_TLS_HMAC_INNER_SZ)\n                b = header[k];\n            else if (k < maxLen)\n                b = in[k - WOLFSSL_TLS_HMAC_INNER_SZ];\n\n            b = ctMaskSel(atEoc, 0x80, b);\n            b &= (unsigned char)~(word32)pastEoc;\n            b &= ((unsigned char)~(word32)isOutBlock) | isEocBlock;\n\n            if (j >= blockSz - 8) {\n                b = ctMaskSel(isOutBlock, lenBytes[j - (blockSz - 8)], b);\n            }\n\n            hashBlock[j] = b;\n        }\n\n        ret = Hmac_HashUpdate(hmac, hashBlock, blockSz);\n        if (ret != 0)\n            return ret;\n        ret = Hmac_HashFinalRaw(hmac, hashBlock);\n        if (ret != 0)\n            return ret;\n        for (j = 0; j < macLen; j++)\n            ((unsigned char*)hmac->innerHash)[j] |= hashBlock[j] & isOutBlock;\n    }\n\n    ret = Hmac_OuterHash(hmac, digest);\n\n    return ret;\n}", "target": 1, "idx": 11441}
{"commit_id": "a9bf2520ab5abb69f9328906e406fbebfb36159a", "project": "galkahana/HummusJS", "func": "IDeletable* PDFObject::DetachMetadata(const std::string& inKey) {\n\tStringToIDeletable::iterator it = mMetadata.find(inKey);\n\n\tif (it == mMetadata.end())\n\t\treturn NULL;\n\telse {\n\t\tIDeletable* result = it->second;\n\t\tmMetadata.erase(it);\n\t\treturn result;\n\t}\n}", "target": 2, "idx": 11442}
{"commit_id": "afc39bea36fd436e54262f150c009e8d72db5014", "project": "envoyproxy/envoy", "func": "uint64_t HeaderMapImpl::appendToHeader(HeaderString& header, absl::string_view data) {\n  if (data.empty()) {\n    return 0;\n  }\n  uint64_t byte_size = 0;\n  if (!header.empty()) {\n    header.append(\",\", 1);\n    byte_size += 1;\n  }\n  header.append(data.data(), data.size());\n  return data.size() + byte_size;\n}", "target": 2, "idx": 11443}
{"commit_id": "ef299cc3fa1a9e1288665a9fdc8bff55629fd359", "project": "torvalds/linux", "func": "static int route4_change(struct net *net, struct sk_buff *in_skb,\n\t\t\t struct tcf_proto *tp, unsigned long base, u32 handle,\n\t\t\t struct nlattr **tca, void **arg, bool ovr,\n\t\t\t bool rtnl_held, struct netlink_ext_ack *extack)\n{\n\tstruct route4_head *head = rtnl_dereference(tp->root);\n\tstruct route4_filter __rcu **fp;\n\tstruct route4_filter *fold, *f1, *pfp, *f = NULL;\n\tstruct route4_bucket *b;\n\tstruct nlattr *opt = tca[TCA_OPTIONS];\n\tstruct nlattr *tb[TCA_ROUTE4_MAX + 1];\n\tunsigned int h, th;\n\tint err;\n\tbool new = true;\n\n\tif (opt == NULL)\n\t\treturn handle ? -EINVAL : 0;\n\n\terr = nla_parse_nested_deprecated(tb, TCA_ROUTE4_MAX, opt,\n\t\t\t\t\t  route4_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tfold = *arg;\n\tif (fold && handle && fold->handle != handle)\n\t\t\treturn -EINVAL;\n\n\terr = -ENOBUFS;\n\tf = kzalloc(sizeof(struct route4_filter), GFP_KERNEL);\n\tif (!f)\n\t\tgoto errout;\n\n\terr = tcf_exts_init(&f->exts, net, TCA_ROUTE4_ACT, TCA_ROUTE4_POLICE);\n\tif (err < 0)\n\t\tgoto errout;\n\n\tif (fold) {\n\t\tf->id = fold->id;\n\t\tf->iif = fold->iif;\n\t\tf->res = fold->res;\n\t\tf->handle = fold->handle;\n\n\t\tf->tp = fold->tp;\n\t\tf->bkt = fold->bkt;\n\t\tnew = false;\n\t}\n\n\terr = route4_set_parms(net, tp, base, f, handle, head, tb,\n\t\t\t       tca[TCA_RATE], new, ovr, extack);\n\tif (err < 0)\n\t\tgoto errout;\n\n\th = from_hash(f->handle >> 16);\n\tfp = &f->bkt->ht[h];\n\tfor (pfp = rtnl_dereference(*fp);\n\t     (f1 = rtnl_dereference(*fp)) != NULL;\n\t     fp = &f1->next)\n\t\tif (f->handle < f1->handle)\n\t\t\tbreak;\n\n\ttcf_block_netif_keep_dst(tp->chain->block);\n\trcu_assign_pointer(f->next, f1);\n\trcu_assign_pointer(*fp, f);\n\n\tif (fold && fold->handle && f->handle != fold->handle) {\n\t\tth = to_hash(fold->handle);\n\t\th = from_hash(fold->handle >> 16);\n\t\tb = rtnl_dereference(head->table[th]);\n\t\tif (b) {\n\t\t\tfp = &b->ht[h];\n\t\t\tfor (pfp = rtnl_dereference(*fp); pfp;\n\t\t\t     fp = &pfp->next, pfp = rtnl_dereference(*fp)) {\n\t\t\t\tif (pfp == fold) {\n\t\t\t\t\trcu_assign_pointer(*fp, fold->next);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\troute4_reset_fastmap(head);\n\t*arg = f;\n\tif (fold) {\n\t\ttcf_unbind_filter(tp, &fold->res);\n\t\ttcf_exts_get_net(&fold->exts);\n\t\ttcf_queue_work(&fold->rwork, route4_delete_filter_work);\n\t}\n\treturn 0;\n\nerrout:\n\tif (f)\n\t\ttcf_exts_destroy(&f->exts);\n\tkfree(f);\n\treturn err;\n}", "target": 2, "idx": 11444}
{"commit_id": "c919e1ca2ecfc47d796382973ba0e48b8f6f92a2", "project": "ffmpeg", "func": "static int msrle_decode_frame(AVCodecContext *avctx,\n                              void *data, int *got_frame,\n                              AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    MsrleContext *s = avctx->priv_data;\n    int istride = FFALIGN(avctx->width*avctx->bits_per_coded_sample, 32) / 8;\n    int ret;\n\n    s->buf = buf;\n    s->size = buf_size;\n\n    if ((ret = ff_reget_buffer(avctx, s->frame)) < 0)\n        return ret;\n\n    if (avctx->bits_per_coded_sample > 1 && avctx->bits_per_coded_sample <= 8) {\n        const uint8_t *pal = av_packet_get_side_data(avpkt, AV_PKT_DATA_PALETTE, NULL);\n\n        if (pal) {\n            s->frame->palette_has_changed = 1;\n            memcpy(s->pal, pal, AVPALETTE_SIZE);\n        }\n        /* make the palette available */\n        memcpy(s->frame->data[1], s->pal, AVPALETTE_SIZE);\n    }\n\n    /* FIXME how to correctly detect RLE ??? */\n    if (avctx->height * istride == avpkt->size) { /* assume uncompressed */\n        int linesize = av_image_get_linesize(avctx->pix_fmt, avctx->width, 0);\n        uint8_t *ptr = s->frame->data[0];\n        uint8_t *buf = avpkt->data + (avctx->height-1)*istride;\n        int i, j;\n\n        for (i = 0; i < avctx->height; i++) {\n            if (avctx->bits_per_coded_sample == 4) {\n                for (j = 0; j < avctx->width - 1; j += 2) {\n                    ptr[j+0] = buf[j>>1] >> 4;\n                    ptr[j+1] = buf[j>>1] & 0xF;\n                }\n                if (avctx->width & 1)\n                    ptr[j+0] = buf[j>>1] >> 4;\n            } else {\n                memcpy(ptr, buf, linesize);\n            }\n            buf -= istride;\n            ptr += s->frame->linesize[0];\n        }\n    } else {\n        bytestream2_init(&s->gb, buf, buf_size);\n        ff_msrle_decode(avctx, (AVPicture*)s->frame, avctx->bits_per_coded_sample, &s->gb);\n    }\n\n    if ((ret = av_frame_ref(data, s->frame)) < 0)\n        return ret;\n\n    *got_frame      = 1;\n\n    /* report that the buffer was completely consumed */\n    return buf_size;\n}", "target": 1, "idx": 11445}
{"commit_id": "1a7ffe466cd057daaef245b0a1ab6b82588e4c01", "project": "xen-project/xen", "func": "int amd_iommu_map_page(struct domain *d, dfn_t dfn, mfn_t mfn,\n                       unsigned int flags)\n{\n    bool_t need_flush = 0;\n    struct domain_iommu *hd = dom_iommu(d);\n    int rc;\n    unsigned long pt_mfn[7];\n    unsigned int merge_level;\n\n    if ( iommu_use_hap_pt(d) )\n        return 0;\n\n    memset(pt_mfn, 0, sizeof(pt_mfn));\n\n    spin_lock(&hd->arch.mapping_lock);\n\n    rc = amd_iommu_alloc_root(hd);\n    if ( rc )\n    {\n        spin_unlock(&hd->arch.mapping_lock);\n        AMD_IOMMU_DEBUG(\"Root table alloc failed, dfn = %\"PRI_dfn\"\\n\",\n                        dfn_x(dfn));\n        domain_crash(d);\n        return rc;\n    }\n\n    /* Since HVM domain is initialized with 2 level IO page table,\n     * we might need a deeper page table for wider dfn now */\n    if ( is_hvm_domain(d) )\n    {\n        if ( update_paging_mode(d, dfn_x(dfn)) )\n        {\n            spin_unlock(&hd->arch.mapping_lock);\n            AMD_IOMMU_DEBUG(\"Update page mode failed dfn = %\"PRI_dfn\"\\n\",\n                            dfn_x(dfn));\n            domain_crash(d);\n            return -EFAULT;\n        }\n    }\n\n    if ( iommu_pde_from_dfn(d, dfn_x(dfn), pt_mfn) || (pt_mfn[1] == 0) )\n    {\n        spin_unlock(&hd->arch.mapping_lock);\n        AMD_IOMMU_DEBUG(\"Invalid IO pagetable entry dfn = %\"PRI_dfn\"\\n\",\n                        dfn_x(dfn));\n        domain_crash(d);\n        return -EFAULT;\n    }\n\n    /* Install 4k mapping first */\n    need_flush = set_iommu_pte_present(pt_mfn[1], dfn_x(dfn), mfn_x(mfn), 1,\n                                       !!(flags & IOMMUF_writable),\n                                       !!(flags & IOMMUF_readable));\n\n    /* Do not increase pde count if io mapping has not been changed */\n    if ( !need_flush )\n        goto out;\n\n    amd_iommu_flush_pages(d, dfn_x(dfn), 0);\n\n    for ( merge_level = 2; merge_level <= hd->arch.paging_mode;\n          merge_level++ )\n    {\n        if ( pt_mfn[merge_level] == 0 )\n            break;\n        if ( !iommu_update_pde_count(d, pt_mfn[merge_level],\n                                     dfn_x(dfn), mfn_x(mfn), merge_level) )\n            break;\n\n        if ( iommu_merge_pages(d, pt_mfn[merge_level], dfn_x(dfn),\n                               flags, merge_level) )\n        {\n            spin_unlock(&hd->arch.mapping_lock);\n            AMD_IOMMU_DEBUG(\"Merge iommu page failed at level %d, \"\n                            \"dfn = %\"PRI_dfn\" mfn = %\"PRI_mfn\"\\n\",\n                            merge_level, dfn_x(dfn), mfn_x(mfn));\n            domain_crash(d);\n            return -EFAULT;\n        }\n\n        /* Deallocate lower level page table */\n        free_amd_iommu_pgtable(mfn_to_page(_mfn(pt_mfn[merge_level - 1])));\n    }\n\nout:\n    spin_unlock(&hd->arch.mapping_lock);\n    return 0;\n}", "target": 2, "idx": 11446}
{"commit_id": "124d3b7041f9a0ca7c43a6293e1cae4576c32fd5", "project": "torvalds/linux", "func": "static ssize_t generic_perform_write(struct file *file,\n\t\t\t\tstruct iov_iter *i, loff_t pos)\n{\n\tstruct address_space *mapping = file->f_mapping;\n\tconst struct address_space_operations *a_ops = mapping->a_ops;\n\tlong status = 0;\n\tssize_t written = 0;\n\tunsigned int flags = 0;\n\n\t/*\n\t * Copies from kernel address space cannot fail (NFSD is a big user).\n\t */\n\tif (segment_eq(get_fs(), KERNEL_DS))\n\t\tflags |= AOP_FLAG_UNINTERRUPTIBLE;\n\n\tdo {\n\t\tstruct page *page;\n\t\tpgoff_t index;\t\t/* Pagecache index for current page */\n\t\tunsigned long offset;\t/* Offset into pagecache page */\n\t\tunsigned long bytes;\t/* Bytes to write to page */\n\t\tsize_t copied;\t\t/* Bytes copied from user */\n\t\tvoid *fsdata;\n\n\t\toffset = (pos & (PAGE_CACHE_SIZE - 1));\n\t\tindex = pos >> PAGE_CACHE_SHIFT;\n\t\tbytes = min_t(unsigned long, PAGE_CACHE_SIZE - offset,\n\t\t\t\t\t\tiov_iter_count(i));\n\nagain:\n\n\t\t/*\n\t\t * Bring in the user page that we will copy from _first_.\n\t\t * Otherwise there's a nasty deadlock on copying from the\n\t\t * same page as we're writing to, without it being marked\n\t\t * up-to-date.\n\t\t *\n\t\t * Not only is this an optimisation, but it is also required\n\t\t * to check that the address is actually valid, when atomic\n\t\t * usercopies are used, below.\n\t\t */\n\t\tif (unlikely(iov_iter_fault_in_readable(i, bytes))) {\n\t\t\tstatus = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tstatus = a_ops->write_begin(file, mapping, pos, bytes, flags,\n\t\t\t\t\t\t&page, &fsdata);\n\t\tif (unlikely(status))\n\t\t\tbreak;\n\n\t\tpagefault_disable();\n\t\tcopied = iov_iter_copy_from_user_atomic(page, i, offset, bytes);\n\t\tpagefault_enable();\n\t\tflush_dcache_page(page);\n\n\t\tstatus = a_ops->write_end(file, mapping, pos, bytes, copied,\n\t\t\t\t\t\tpage, fsdata);\n\t\tif (unlikely(status < 0))\n\t\t\tbreak;\n\t\tcopied = status;\n\n\t\tcond_resched();\n\n\t\tiov_iter_advance(i, copied);\n\t\tif (unlikely(copied == 0)) {\n\t\t\t/*\n\t\t\t * If we were unable to copy any data at all, we must\n\t\t\t * fall back to a single segment length write.\n\t\t\t *\n\t\t\t * If we didn't fallback here, we could livelock\n\t\t\t * because not all segments in the iov can be copied at\n\t\t\t * once without a pagefault.\n\t\t\t */\n\t\t\tbytes = min_t(unsigned long, PAGE_CACHE_SIZE - offset,\n\t\t\t\t\t\tiov_iter_single_seg_count(i));\n\t\t\tgoto again;\n\t\t}\n\t\tpos += copied;\n\t\twritten += copied;\n\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\n\t} while (iov_iter_count(i));\n\n\treturn written ? written : status;\n}", "target": 1, "idx": 11447}
{"commit_id": "9a29d87538842a29b430c6956a4f914896643691", "project": "llvm/llvm-project", "func": "LogicalResult matchAndRewriteSortOp(OpTy op, ValueRange xys, uint64_t nx,\n                                    uint64_t ny, bool isCoo,\n                                    PatternRewriter &rewriter) {\n  Location loc = op.getLoc();\n  SmallVector<Value> operands{constantIndex(rewriter, loc, 0), op.getN()};\n\n  // Convert `values` to have dynamic shape and append them to `operands`.\n  for (Value v : xys) {\n    auto mtp = getMemRefType(v);\n    if (!mtp.isDynamicDim(0)) {\n      auto newMtp =\n          MemRefType::get({ShapedType::kDynamic}, mtp.getElementType());\n      v = rewriter.create<memref::CastOp>(loc, newMtp, v);\n    }\n    operands.push_back(v);\n  }\n\n  auto insertPoint = op->template getParentOfType<func::FuncOp>();\n  if (!insertPoint)\n    return failure();\n\n  SmallString<32> funcName;\n  FuncGeneratorType funcGenerator;\n  uint32_t nTrailingP = 0;\n  switch (op.getAlgorithm()) {\n  case SparseTensorSortKind::HybridQuickSort: {\n    funcName = kHybridQuickSortFuncNamePrefix;\n    funcGenerator = createQuickSortFunc;\n    nTrailingP = 1;\n    Value pDepthLimit = rewriter.create<memref::AllocaOp>(\n        loc, MemRefType::get({}, rewriter.getI64Type()));\n    operands.push_back(pDepthLimit);\n    // As a heuristics, set depthLimit = 2 * log2(n).\n    Value lo = operands[loIdx];\n    Value hi = operands[hiIdx];\n    Value len = rewriter.create<arith::IndexCastOp>(\n        loc, rewriter.getI64Type(),\n        rewriter.create<arith::SubIOp>(loc, hi, lo));\n    Value depthLimit = rewriter.create<arith::SubIOp>(\n        loc, constantI64(rewriter, loc, 64),\n        rewriter.create<math::CountLeadingZerosOp>(loc, len));\n    depthLimit = rewriter.create<arith::ShLIOp>(loc, depthLimit,\n                                                constantI64(rewriter, loc, 1));\n    rewriter.create<memref::StoreOp>(loc, depthLimit, pDepthLimit);\n    break;\n  }\n  case SparseTensorSortKind::QuickSort:\n    funcName = kQuickSortFuncNamePrefix;\n    funcGenerator = createQuickSortFunc;\n    break;\n  case SparseTensorSortKind::InsertionSortStable:\n    funcName = kSortStableFuncNamePrefix;\n    funcGenerator = createSortStableFunc;\n    break;\n  case SparseTensorSortKind::HeapSort:\n    funcName = kHeapSortFuncNamePrefix;\n    funcGenerator = createHeapSortFunc;\n    break;\n  }\n\n  FlatSymbolRefAttr func =\n      getMangledSortHelperFunc(rewriter, insertPoint, TypeRange(), funcName, nx,\n                               ny, isCoo, operands, funcGenerator, nTrailingP);\n  rewriter.replaceOpWithNewOp<func::CallOp>(op, func, TypeRange(), operands);\n  return success();\n}", "target": 1, "idx": 11448}
{"commit_id": "4a59cfaf9ab3d48fca4a15c0d2674bf7138e3d1a", "project": "jasper-software/jasper", "func": "void jpc_qmfb_join_colgrp(jpc_fix_t *a, int numrows, int stride,\n  int parity)\n{\n\n\tint bufsize = JPC_CEILDIVPOW2(numrows, 1);\n\tjpc_fix_t joinbuf[QMFB_JOINBUFSIZE * JPC_QMFB_COLGRPSIZE];\n\tjpc_fix_t *buf = joinbuf;\n\tjpc_fix_t *srcptr;\n\tjpc_fix_t *dstptr;\n\tregister jpc_fix_t *srcptr2;\n\tregister jpc_fix_t *dstptr2;\n\tregister int n;\n\tregister int i;\n\tint hstartcol;\n\n\t/* Allocate memory for the join buffer from the heap. */\n\tif (bufsize > QMFB_JOINBUFSIZE) {\n\t\tif (!(buf = jas_alloc3(bufsize, JPC_QMFB_COLGRPSIZE,\n\t\t  sizeof(jpc_fix_t)))) {\n\t\t\t/* We have no choice but to commit suicide. */\n\t\t\tabort();\n\t\t}\n\t}\n\n\thstartcol = (numrows + 1 - parity) >> 1;\n\n\t/* Save the samples from the lowpass channel. */\n\tn = hstartcol;\n\tsrcptr = &a[0];\n\tdstptr = buf;\n\twhile (n-- > 0) {\n\t\tdstptr2 = dstptr;\n\t\tsrcptr2 = srcptr;\n\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {\n\t\t\t*dstptr2 = *srcptr2;\n\t\t\t++dstptr2;\n\t\t\t++srcptr2;\n\t\t}\n\t\tsrcptr += stride;\n\t\tdstptr += JPC_QMFB_COLGRPSIZE;\n\t}\n\t/* Copy the samples from the highpass channel into place. */\n\tsrcptr = &a[hstartcol * stride];\n\tdstptr = &a[(1 - parity) * stride];\n\tn = numrows - hstartcol;\n\twhile (n-- > 0) {\n\t\tdstptr2 = dstptr;\n\t\tsrcptr2 = srcptr;\n\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {\n\t\t\t*dstptr2 = *srcptr2;\n\t\t\t++dstptr2;\n\t\t\t++srcptr2;\n\t\t}\n\t\tdstptr += 2 * stride;\n\t\tsrcptr += stride;\n\t}\n\t/* Copy the samples from the lowpass channel into place. */\n\tsrcptr = buf;\n\tdstptr = &a[parity * stride];\n\tn = hstartcol;\n\twhile (n-- > 0) {\n\t\tdstptr2 = dstptr;\n\t\tsrcptr2 = srcptr;\n\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {\n\t\t\t*dstptr2 = *srcptr2;\n\t\t\t++dstptr2;\n\t\t\t++srcptr2;\n\t\t}\n\t\tdstptr += 2 * stride;\n\t\tsrcptr += JPC_QMFB_COLGRPSIZE;\n\t}\n\n\t/* If the join buffer was allocated on the heap, free this memory. */\n\tif (buf != joinbuf) {\n\t\tjas_free(buf);\n\t}\n\n}", "target": 2, "idx": 11449}
{"commit_id": "54d8f27d0477937e1f99a414fc1ffd93d184b38a", "project": "xen-project/xen", "func": "static int libxl__device_nic_setdefault(libxl__gc *gc, uint32_t domid,\n                                        libxl_device_nic *nic, bool hotplug)\n{\n    int rc;\n\n    if (!nic->mtu)\n        nic->mtu = LIBXL_DEVICE_NIC_MTU_DEFAULT;\n    if (!nic->model) {\n        nic->model = strdup(\"rtl8139\");\n        if (!nic->model) return ERROR_NOMEM;\n    }\n    if (libxl__mac_is_default(&nic->mac)) {\n        const uint8_t *r;\n        libxl_uuid uuid;\n\n        libxl_uuid_generate(&uuid);\n        r = libxl_uuid_bytearray(&uuid);\n\n        /* Generate a random MAC address, with Xen's OUI (00:16:3e) */\n        nic->mac[0] = 0x00;\n        nic->mac[1] = 0x16;\n        nic->mac[2] = 0x3e;\n        nic->mac[3] = r[0] & 0x7f;\n        nic->mac[4] = r[1];\n        nic->mac[5] = r[2];\n    }\n    if (!nic->bridge) {\n        nic->bridge = strdup(\"xenbr0\");\n        if (!nic->bridge) return ERROR_NOMEM;\n    }\n    if ( !nic->script && asprintf(&nic->script, \"%s/vif-bridge\",\n                                  libxl__xen_script_dir_path()) < 0 )\n        return ERROR_FAIL;\n\n    rc = libxl__resolve_domid(gc, nic->backend_domname, &nic->backend_domid);\n    if (rc < 0) return rc;\n\n    switch (libxl__domain_type(gc, domid)) {\n    case LIBXL_DOMAIN_TYPE_HVM:\n        if (!nic->nictype) {\n            if (hotplug)\n                nic->nictype = LIBXL_NIC_TYPE_VIF;\n            else\n                nic->nictype = LIBXL_NIC_TYPE_VIF_IOEMU;\n        }\n        break;\n    case LIBXL_DOMAIN_TYPE_PVH:\n    case LIBXL_DOMAIN_TYPE_PV:\n        if (nic->nictype == LIBXL_NIC_TYPE_VIF_IOEMU) {\n            LOGD(ERROR, domid,\n            \"trying to create PV or PVH guest with an emulated interface\");\n            return ERROR_INVAL;\n        }\n        nic->nictype = LIBXL_NIC_TYPE_VIF;\n        break;\n    case LIBXL_DOMAIN_TYPE_INVALID:\n        return ERROR_FAIL;\n    default:\n        abort();\n    }\n\n    libxl_defbool_setdefault(&nic->trusted, true);\n\n    return rc;\n}", "target": 2, "idx": 11450}
{"commit_id": "dccb5f7d776e93863ae10bbff56a45c523c6eeb0", "project": "TigerVNC/tigervnc", "func": "void CConnection::processSecurityTypesMsg()\n{\n  vlog.debug(\"processing security types message\");\n\n  int secType = secTypeInvalid;\n\n  std::list<rdr::U8> secTypes;\n  secTypes = security.GetEnabledSecTypes();\n\n  if (cp.isVersion(3,3)) {\n\n    // legacy 3.3 server may only offer \"vnc authentication\" or \"none\"\n\n    secType = is->readU32();\n    if (secType == secTypeInvalid) {\n      throwConnFailedException();\n\n    } else if (secType == secTypeNone || secType == secTypeVncAuth) {\n      std::list<rdr::U8>::iterator i;\n      for (i = secTypes.begin(); i != secTypes.end(); i++)\n        if (*i == secType) {\n          secType = *i;\n          break;\n        }\n\n      if (i == secTypes.end())\n        secType = secTypeInvalid;\n    } else {\n      vlog.error(\"Unknown 3.3 security type %d\", secType);\n      throw Exception(\"Unknown 3.3 security type\");\n    }\n\n  } else {\n\n    // >=3.7 server will offer us a list\n\n    int nServerSecTypes = is->readU8();\n    if (nServerSecTypes == 0)\n      throwConnFailedException();\n\n    std::list<rdr::U8>::iterator j;\n\n    for (int i = 0; i < nServerSecTypes; i++) {\n      rdr::U8 serverSecType = is->readU8();\n      vlog.debug(\"Server offers security type %s(%d)\",\n                 secTypeName(serverSecType), serverSecType);\n\n      /*\n       * Use the first type sent by server which matches client's type.\n       * It means server's order specifies priority.\n       */\n      if (secType == secTypeInvalid) {\n        for (j = secTypes.begin(); j != secTypes.end(); j++)\n          if (*j == serverSecType) {\n            secType = *j;\n            break;\n          }\n       }\n    }\n\n    // Inform the server of our decision\n    if (secType != secTypeInvalid) {\n      os->writeU8(secType);\n      os->flush();\n      vlog.info(\"Choosing security type %s(%d)\",secTypeName(secType),secType);\n    }\n  }\n\n  if (secType == secTypeInvalid) {\n    state_ = RFBSTATE_INVALID;\n    vlog.error(\"No matching security types\");\n    throw Exception(\"No matching security types\");\n  }\n\n  state_ = RFBSTATE_SECURITY;\n  csecurity = security.GetCSecurity(secType);\n  processSecurityMsg();\n}", "target": 2, "idx": 11451}
{"commit_id": "c927a3492698c254637da836762f9b1f86cffabc", "project": "openssl", "func": "static int nc_match_single(int effective_type, GENERAL_NAME *gen,\n                           GENERAL_NAME *base)\n{\n    switch (gen->type) {\n    case GEN_OTHERNAME:\n        switch (effective_type) {\n        case GEN_EMAIL:\n            /*\n             * We are here only when we have SmtpUTF8 name,\n             * so we match the value of othername with base->d.rfc822Name\n             */\n            return nc_email_eai(gen->d.otherName->value, base->d.rfc822Name);\n\n        default:\n            return X509_V_ERR_UNSUPPORTED_CONSTRAINT_TYPE;\n        }\n\n    case GEN_DIRNAME:\n        return nc_dn(gen->d.directoryName, base->d.directoryName);\n\n    case GEN_DNS:\n        return nc_dns(gen->d.dNSName, base->d.dNSName);\n\n    case GEN_EMAIL:\n        return nc_email(gen->d.rfc822Name, base->d.rfc822Name);\n\n    case GEN_URI:\n        return nc_uri(gen->d.uniformResourceIdentifier,\n                      base->d.uniformResourceIdentifier);\n\n    case GEN_IPADD:\n        return nc_ip(gen->d.iPAddress, base->d.iPAddress);\n\n    default:\n        return X509_V_ERR_UNSUPPORTED_CONSTRAINT_TYPE;\n    }\n\n}", "target": 1, "idx": 11452}
{"commit_id": "9cec874582b925e373adb0896b85a112702f6664", "project": "nginx/njs", "func": "njs_int_t\nnjs_error_to_string(njs_vm_t *vm, njs_value_t *retval, const njs_value_t *error)\n{\n    if (njs_slow_path(!njs_is_object(error))) {\n        njs_type_error(vm, \"\\\"error\\\" is not an object\");\n        return NJS_ERROR;\n    }\n\n    return njs_error_to_string2(vm, retval, error, 1);\n}", "target": 2, "idx": 11453}
{"commit_id": "8a76fadaa39b87d740ec3346d9eccb64bde5a6af", "project": "opencv", "func": "void  RBaseStream::skip( int bytes )\n{\n    CV_Assert(bytes >= 0);\n    uchar* old = m_current;\n    m_current += bytes;\n    CV_Assert(m_current >= old);  // overflow check\n}", "target": 1, "idx": 11454}
{"commit_id": "b1a2cd50c0357f243b7435a732b4e62ba3157a2e", "project": "torvalds/linux", "func": "static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data, size_t data_size)\n{\n\tstruct l2cap_conf_rsp *rsp = data;\n\tvoid *ptr = rsp->data;\n\tvoid *endptr = data + data_size;\n\tvoid *req = chan->conf_req;\n\tint len = chan->conf_len;\n\tint type, hint, olen;\n\tunsigned long val;\n\tstruct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };\n\tstruct l2cap_conf_efs efs;\n\tu8 remote_efs = 0;\n\tu16 mtu = L2CAP_DEFAULT_MTU;\n\tu16 result = L2CAP_CONF_SUCCESS;\n\tu16 size;\n\n\tBT_DBG(\"chan %p\", chan);\n\n\twhile (len >= L2CAP_CONF_OPT_SIZE) {\n\t\tlen -= l2cap_get_conf_opt(&req, &type, &olen, &val);\n\t\tif (len < 0)\n\t\t\tbreak;\n\n\t\thint  = type & L2CAP_CONF_HINT;\n\t\ttype &= L2CAP_CONF_MASK;\n\n\t\tswitch (type) {\n\t\tcase L2CAP_CONF_MTU:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\tmtu = val;\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_FLUSH_TO:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\tchan->flush_to = val;\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_QOS:\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_RFC:\n\t\t\tif (olen != sizeof(rfc))\n\t\t\t\tbreak;\n\t\t\tmemcpy(&rfc, (void *) val, olen);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_FCS:\n\t\t\tif (olen != 1)\n\t\t\t\tbreak;\n\t\t\tif (val == L2CAP_FCS_NONE)\n\t\t\t\tset_bit(CONF_RECV_NO_FCS, &chan->conf_state);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_EFS:\n\t\t\tif (olen != sizeof(efs))\n\t\t\t\tbreak;\n\t\t\tremote_efs = 1;\n\t\t\tmemcpy(&efs, (void *) val, olen);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_EWS:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\tif (!(chan->conn->local_fixed_chan & L2CAP_FC_A2MP))\n\t\t\t\treturn -ECONNREFUSED;\n\t\t\tset_bit(FLAG_EXT_CTRL, &chan->flags);\n\t\t\tset_bit(CONF_EWS_RECV, &chan->conf_state);\n\t\t\tchan->tx_win_max = L2CAP_DEFAULT_EXT_WINDOW;\n\t\t\tchan->remote_tx_win = val;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif (hint)\n\t\t\t\tbreak;\n\t\t\tresult = L2CAP_CONF_UNKNOWN;\n\t\t\tl2cap_add_conf_opt(&ptr, (u8)type, sizeof(u8), type, endptr - ptr);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (chan->num_conf_rsp || chan->num_conf_req > 1)\n\t\tgoto done;\n\n\tswitch (chan->mode) {\n\tcase L2CAP_MODE_STREAMING:\n\tcase L2CAP_MODE_ERTM:\n\t\tif (!test_bit(CONF_STATE2_DEVICE, &chan->conf_state)) {\n\t\t\tchan->mode = l2cap_select_mode(rfc.mode,\n\t\t\t\t\t\t       chan->conn->feat_mask);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (remote_efs) {\n\t\t\tif (__l2cap_efs_supported(chan->conn))\n\t\t\t\tset_bit(FLAG_EFS_ENABLE, &chan->flags);\n\t\t\telse\n\t\t\t\treturn -ECONNREFUSED;\n\t\t}\n\n\t\tif (chan->mode != rfc.mode)\n\t\t\treturn -ECONNREFUSED;\n\n\t\tbreak;\n\t}\n\ndone:\n\tif (chan->mode != rfc.mode) {\n\t\tresult = L2CAP_CONF_UNACCEPT;\n\t\trfc.mode = chan->mode;\n\n\t\tif (chan->num_conf_rsp == 1)\n\t\t\treturn -ECONNREFUSED;\n\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),\n\t\t\t\t   (unsigned long) &rfc, endptr - ptr);\n\t}\n\n\tif (result == L2CAP_CONF_SUCCESS) {\n\t\t/* Configure output options and let the other side know\n\t\t * which ones we don't like. */\n\n\t\tif (mtu < L2CAP_DEFAULT_MIN_MTU)\n\t\t\tresult = L2CAP_CONF_UNACCEPT;\n\t\telse {\n\t\t\tchan->omtu = mtu;\n\t\t\tset_bit(CONF_MTU_DONE, &chan->conf_state);\n\t\t}\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, chan->omtu, endptr - ptr);\n\n\t\tif (remote_efs) {\n\t\t\tif (chan->local_stype != L2CAP_SERV_NOTRAFIC &&\n\t\t\t    efs.stype != L2CAP_SERV_NOTRAFIC &&\n\t\t\t    efs.stype != chan->local_stype) {\n\n\t\t\t\tresult = L2CAP_CONF_UNACCEPT;\n\n\t\t\t\tif (chan->num_conf_req >= 1)\n\t\t\t\t\treturn -ECONNREFUSED;\n\n\t\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_EFS,\n\t\t\t\t\t\t   sizeof(efs),\n\t\t\t\t\t\t   (unsigned long) &efs, endptr - ptr);\n\t\t\t} else {\n\t\t\t\t/* Send PENDING Conf Rsp */\n\t\t\t\tresult = L2CAP_CONF_PENDING;\n\t\t\t\tset_bit(CONF_LOC_CONF_PEND, &chan->conf_state);\n\t\t\t}\n\t\t}\n\n\t\tswitch (rfc.mode) {\n\t\tcase L2CAP_MODE_BASIC:\n\t\t\tchan->fcs = L2CAP_FCS_NONE;\n\t\t\tset_bit(CONF_MODE_DONE, &chan->conf_state);\n\t\t\tbreak;\n\n\t\tcase L2CAP_MODE_ERTM:\n\t\t\tif (!test_bit(CONF_EWS_RECV, &chan->conf_state))\n\t\t\t\tchan->remote_tx_win = rfc.txwin_size;\n\t\t\telse\n\t\t\t\trfc.txwin_size = L2CAP_DEFAULT_TX_WINDOW;\n\n\t\t\tchan->remote_max_tx = rfc.max_transmit;\n\n\t\t\tsize = min_t(u16, le16_to_cpu(rfc.max_pdu_size),\n\t\t\t\t     chan->conn->mtu - L2CAP_EXT_HDR_SIZE -\n\t\t\t\t     L2CAP_SDULEN_SIZE - L2CAP_FCS_SIZE);\n\t\t\trfc.max_pdu_size = cpu_to_le16(size);\n\t\t\tchan->remote_mps = size;\n\n\t\t\t__l2cap_set_ertm_timeouts(chan, &rfc);\n\n\t\t\tset_bit(CONF_MODE_DONE, &chan->conf_state);\n\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,\n\t\t\t\t\t   sizeof(rfc), (unsigned long) &rfc, endptr - ptr);\n\n\t\t\tif (remote_efs &&\n\t\t\t    test_bit(FLAG_EFS_ENABLE, &chan->flags)) {\n\t\t\t\tchan->remote_id = efs.id;\n\t\t\t\tchan->remote_stype = efs.stype;\n\t\t\t\tchan->remote_msdu = le16_to_cpu(efs.msdu);\n\t\t\t\tchan->remote_flush_to =\n\t\t\t\t\tle32_to_cpu(efs.flush_to);\n\t\t\t\tchan->remote_acc_lat =\n\t\t\t\t\tle32_to_cpu(efs.acc_lat);\n\t\t\t\tchan->remote_sdu_itime =\n\t\t\t\t\tle32_to_cpu(efs.sdu_itime);\n\t\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_EFS,\n\t\t\t\t\t\t   sizeof(efs),\n\t\t\t\t\t\t   (unsigned long) &efs, endptr - ptr);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase L2CAP_MODE_STREAMING:\n\t\t\tsize = min_t(u16, le16_to_cpu(rfc.max_pdu_size),\n\t\t\t\t     chan->conn->mtu - L2CAP_EXT_HDR_SIZE -\n\t\t\t\t     L2CAP_SDULEN_SIZE - L2CAP_FCS_SIZE);\n\t\t\trfc.max_pdu_size = cpu_to_le16(size);\n\t\t\tchan->remote_mps = size;\n\n\t\t\tset_bit(CONF_MODE_DONE, &chan->conf_state);\n\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),\n\t\t\t\t\t   (unsigned long) &rfc, endptr - ptr);\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tresult = L2CAP_CONF_UNACCEPT;\n\n\t\t\tmemset(&rfc, 0, sizeof(rfc));\n\t\t\trfc.mode = chan->mode;\n\t\t}\n\n\t\tif (result == L2CAP_CONF_SUCCESS)\n\t\t\tset_bit(CONF_OUTPUT_DONE, &chan->conf_state);\n\t}\n\trsp->scid   = cpu_to_le16(chan->dcid);\n\trsp->result = cpu_to_le16(result);\n\trsp->flags  = cpu_to_le16(0);\n\n\treturn ptr - data;\n}", "target": 1, "idx": 11455}
{"commit_id": "6a40a85ff239497c6458c7dbef18f6a2736fe992", "project": "nginx/njs", "func": "static njs_jump_off_t\nnjs_vmcode_await(njs_vm_t *vm, njs_vmcode_await_t *await)\n{\n    size_t              size;\n    njs_int_t           ret;\n    njs_frame_t         *frame;\n    njs_value_t         ctor, val, on_fulfilled, on_rejected, *value;\n    njs_promise_t       *promise;\n    njs_function_t      *fulfilled, *rejected;\n    njs_async_ctx_t     *ctx;\n    njs_native_frame_t  *active;\n\n    active = &vm->active_frame->native;\n\n    value = njs_scope_valid_value(vm, await->retval);\n    if (njs_slow_path(value == NULL)) {\n        return NJS_ERROR;\n    }\n\n    njs_set_function(&ctor, &vm->constructors[NJS_OBJ_TYPE_PROMISE]);\n\n    promise = njs_promise_resolve(vm, &ctor, value);\n    if (njs_slow_path(promise == NULL)) {\n        return NJS_ERROR;\n    }\n\n    ctx = active->function->await;\n\n    if (ctx == NULL) {\n        ctx = njs_mp_alloc(vm->mem_pool, sizeof(njs_async_ctx_t));\n        if (njs_slow_path(ctx == NULL)) {\n            njs_memory_error(vm);\n            return NJS_ERROR;\n        }\n\n        size = njs_function_frame_size(active);\n\n        fulfilled = njs_promise_create_function(vm, size);\n        if (njs_slow_path(fulfilled == NULL)) {\n            return NJS_ERROR;\n        }\n\n        ctx->await = fulfilled->context;\n        ctx->capability = active->function->context;\n\n        active->function->context = NULL;\n\n        ret = njs_function_frame_save(vm, ctx->await, NULL);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return NJS_ERROR;\n        }\n\n    } else {\n        fulfilled = njs_promise_create_function(vm, 0);\n        if (njs_slow_path(fulfilled == NULL)) {\n            return NJS_ERROR;\n        }\n    }\n\n    ctx->pc = (u_char *) await + sizeof(njs_vmcode_await_t);\n    ctx->index = await->retval;\n\n    frame = (njs_frame_t *) active;\n\n    if (frame->exception.catch != NULL) {\n        ctx->await->native.pc = frame->exception.catch;\n\n    } else {\n        ctx->await->native.pc = ctx->pc;\n    }\n\n    fulfilled->context = ctx;\n    fulfilled->args_count = 1;\n    fulfilled->u.native = njs_await_fulfilled;\n\n    rejected = njs_promise_create_function(vm, 0);\n    if (njs_slow_path(rejected == NULL)) {\n        return NJS_ERROR;\n    }\n\n    rejected->context = ctx;\n    rejected->args_count = 1;\n    rejected->u.native = njs_await_rejected;\n\n    njs_set_promise(&val, promise);\n    njs_set_function(&on_fulfilled, fulfilled);\n    njs_set_function(&on_rejected, rejected);\n\n    ret = njs_promise_perform_then(vm, &val, &on_fulfilled, &on_rejected, NULL);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return NJS_ERROR;\n    }\n\n    (void) njs_vmcode_return(vm, NULL, &vm->retval);\n\n    return NJS_AGAIN;\n}", "target": 3, "idx": 11456}
{"commit_id": "045deec1cbdebb27d817008ad5df94d96a08b1bf", "project": "tensorflow", "func": "bool IsIdentityConsumingSwitch(const MutableGraphView& graph,\n                               const NodeDef& node) {\n  if ((IsIdentity(node) || IsIdentityNSingleInput(node)) &&\n      node.input_size() > 0) {\n    TensorId tensor_id = ParseTensorName(node.input(0));\n    if (IsTensorIdControlling(tensor_id)) {\n      return false;\n    }\n\n    NodeDef* input_node = graph.GetNode(tensor_id.node());\n    if (input_node == nullptr) {\n      return false;\n    }\n    return IsSwitch(*input_node);\n  }\n  return false;\n}", "target": 1, "idx": 11457}
{"commit_id": "86ee8b5c6a5737f35a650fcf370d9d0f5823e531", "project": "pcmacdon/jsish", "func": "static Jsi_RC jsi_ArraySpliceCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    int newlen, argc, istart, n, rhowmany, ilen, curlen;\n    Jsi_Value *va, *start, *howmany;\n    Jsi_Obj *nobj, *obj = _this->d.obj;\n    if (obj->modifying)\n      return Jsi_LogError(\"already modifying\");\n    \n    start = Jsi_ValueArrayIndex(interp, args, 0);\n    howmany = Jsi_ValueArrayIndex(interp, args, 1);\n    argc = Jsi_ValueGetLength(interp, args);\n    istart = 0;\n    ilen = (argc>=2 ? argc - 2 : 0);\n    n = jsi_SizeOfArray(interp, obj);\n    curlen = n;\n    \n    if (!start)\n        return JSI_OK;\n\n    nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    Jsi_ValueMakeArrayObject(interp, ret, nobj);\n    Jsi_ObjSetLength(interp, nobj, 0);\n    \n    /* Determine start index. */\n    Jsi_Number nstart;\n    if (Jsi_GetNumberFromValue(interp, start, &nstart) != JSI_OK)\n      return JSI_ERROR;\n    istart = (int)nstart;\n    if (istart > n)\n        return JSI_OK;\n    if (istart < 0)\n        istart = (n+istart);\n    if (istart<0)\n        istart=0;\n      \n    Jsi_Number nhow;\n    rhowmany = n-istart;\n    if (howmany) {\n        if (Jsi_GetNumberFromValue(interp, howmany, &nhow) != JSI_OK) return JSI_ERROR;\n        rhowmany = (int)nhow;\n        if (rhowmany >= (n-istart))\n            rhowmany = n-istart;\n        if (rhowmany < 0)\n            rhowmany = (n-istart);\n        if (rhowmany<0)\n            return JSI_OK;\n    }\n    \n    if (curlen < 0) {\n        Jsi_ObjSetLength(interp, obj, curlen=0);\n    }\n    Jsi_ObjListifyArray(interp, obj);\n   \n    if (Jsi_ObjArraySizer(interp, nobj, rhowmany)<=0)\n      return JSI_ERROR;\n\n    /* Move elements to return object. */\n    int i, j, m;\n    for (m=0, j = 0, i = istart; m<rhowmany && m<curlen; m++, i++, j++)\n    {\n        if (!obj->arr[i]) continue;\n        nobj->arr[m] = obj->arr[i];\n        obj->arr[i] = NULL;\n    }\n    Jsi_ObjSetLength(interp, nobj, m);\n    \n    /* Shift remaining down. */\n    for (; rhowmany && i<curlen; i++)\n    {\n        obj->arr[i-rhowmany] = obj->arr[i];\n        obj->arr[i] = NULL;\n    }\n    curlen -= j;\n    /* Add elements. */\n    newlen = curlen + argc - (argc>=2?2:1);\n    if (Jsi_ObjArraySizer(interp, obj, newlen+3) <= 0) {\n        Jsi_ValueMakeUndef(interp, ret);\n        return Jsi_LogError(\"too long\");\n    }\n    if (ilen>0) {\n        for (i = curlen-1; i>=istart; i--) {\n            obj->arr[i+ilen] = obj->arr[i];\n            obj->arr[i] = NULL;\n        }\n        for (m=istart, i = 2; i<argc; m++,i++) {\n            va = Jsi_ValueArrayIndex(interp, args, i);\n            if (!va) continue;\n            obj->arr[m] = NULL;\n            Jsi_ValueDup2(interp, obj->arr+m, va);\n        }\n    }\n    Jsi_ObjSetLength(interp, obj, newlen);\n    return JSI_OK;\n}", "target": 1, "idx": 11458}
{"commit_id": "350bbe0597d37ad67abe5fef8fba984707b4e9ad", "project": "nmap", "func": "static int do_session_handshake (lua_State *L, int status, lua_KContext ctx) {\n    int rc;\n    struct ssh_userdata *sshu = NULL;\n\n    assert(lua_gettop(L) == 4);\n    sshu = (struct ssh_userdata *) nseU_checkudata(L, 3, SSH2_UDATA, \"ssh2\");\n\n    while ((rc = libssh2_session_handshake(sshu->session, sshu->sp[0])) == LIBSSH2_ERROR_EAGAIN) {\n        luaL_getmetafield(L, 3, \"filter\");\n        lua_pushvalue(L, 3);\n\n        assert(lua_status(L) == LUA_OK);\n        lua_callk(L, 1, 0, 0, do_session_handshake);\n    }\n\n    if (rc) {\n        libssh2_session_free(sshu->session);\n        sshu->session = NULL;\n        return luaL_error(L, \"Unable to complete libssh2 handshake.\");\n    }\n\n    // lua_pushvalue(L, 3);\n    lua_settop(L, 3);\n\n    return 1;\n}", "target": 2, "idx": 11459}
{"commit_id": "cc00bcaa589914096edef7fb87ca5cee4a166b5c", "project": "torvalds/linux", "func": "static int do_add_counters(struct net *net, sockptr_t arg, unsigned int len)\n{\n\tunsigned int i;\n\tstruct xt_counters_info tmp;\n\tstruct xt_counters *paddc;\n\tstruct xt_table *t;\n\tconst struct xt_table_info *private;\n\tint ret = 0;\n\tstruct arpt_entry *iter;\n\tunsigned int addend;\n\n\tpaddc = xt_copy_counters(arg, len, &tmp);\n\tif (IS_ERR(paddc))\n\t\treturn PTR_ERR(paddc);\n\n\tt = xt_find_table_lock(net, NFPROTO_ARP, tmp.name);\n\tif (IS_ERR(t)) {\n\t\tret = PTR_ERR(t);\n\t\tgoto free;\n\t}\n\n\tlocal_bh_disable();\n\tprivate = xt_table_get_private_protected(t);\n\tif (private->number != tmp.num_counters) {\n\t\tret = -EINVAL;\n\t\tgoto unlock_up_free;\n\t}\n\n\ti = 0;\n\n\taddend = xt_write_recseq_begin();\n\txt_entry_foreach(iter,  private->entries, private->size) {\n\t\tstruct xt_counters *tmp;\n\n\t\ttmp = xt_get_this_cpu_counter(&iter->counters);\n\t\tADD_COUNTER(*tmp, paddc[i].bcnt, paddc[i].pcnt);\n\t\t++i;\n\t}\n\txt_write_recseq_end(addend);\n unlock_up_free:\n\tlocal_bh_enable();\n\txt_table_unlock(t);\n\tmodule_put(t->me);\n free:\n\tvfree(paddc);\n\n\treturn ret;\n}", "target": 1, "idx": 11460}
{"commit_id": "43ea0649d4b70fdcf3e9fa5c03aee1bbba0b04bb", "project": "chromium", "func": "void FrameLoader::finishedParsing()\n{\n    if (m_stateMachine.creatingInitialEmptyDocument())\n        return;\n\n    // This can be called from the LocalFrame's destructor, in which case we shouldn't protect ourselves\n    // because doing so will cause us to re-enter the destructor when protector goes out of scope.\n    // Null-checking the FrameView indicates whether or not we're in the destructor.\n    RefPtrWillBeRawPtr<LocalFrame> protect(m_frame->view() ? m_frame.get() : nullptr);\n\n    m_progressTracker->finishedParsing();\n\n    if (client()) {\n        ScriptForbiddenScope forbidScripts;\n        client()->dispatchDidFinishDocumentLoad(m_documentLoader ? m_documentLoader->isCommittedButEmpty() : true);\n    }\n\n    if (client())\n        client()->runScriptsAtDocumentReady();\n\n    checkCompleted();\n\n    if (!m_frame->view())\n        return; // We are being destroyed by something checkCompleted called.\n\n    // Check if the scrollbars are really needed for the content.\n    // If not, remove them, relayout, and repaint.\n    m_frame->view()->restoreScrollbar();\n    processFragment(m_frame->document()->url(), NavigationToDifferentDocument);\n}", "target": 2, "idx": 11461}
{"commit_id": "f49cd2f4d6170d27a2c61f1fecb03d8a70c91f57", "project": "torvalds/linux", "func": "int tcp_getsockopt(struct sock *sk, int level, int optname, char __user *optval,\n\t\t   int __user *optlen)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\tif (level != SOL_TCP)\n\t\t/* Paired with WRITE_ONCE() in do_ipv6_setsockopt() and tcp_v6_connect() */\n\t\treturn READ_ONCE(icsk->icsk_af_ops)->getsockopt(sk, level, optname,\n\t\t\t\t\t\t\t\toptval, optlen);\n\treturn do_tcp_getsockopt(sk, level, optname, USER_SOCKPTR(optval),\n\t\t\t\t USER_SOCKPTR(optlen));\n}", "target": 2, "idx": 11462}
{"commit_id": "62e39f34b2705131a2d08aff0c2e542c6a52cf0e", "project": "radareorg/radare2", "func": "static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) {\n\tconst char *section_name = \"\";\n\tconst char *link_section_name = \"\";\n\tchar *end = NULL;\n\tElf_(Shdr) *link_shdr = NULL;\n\tut8 dfs[sizeof (Elf_(Verdef))] = {0};\n\tSdb *sdb;\n\tint cnt, i;\n\tif (shdr->sh_link > bin->ehdr.e_shnum) {\n\t\treturn false;\n\t}\n\tlink_shdr = &bin->shdr[shdr->sh_link];\n\tif (shdr->sh_size < 1 || shdr->sh_size > SIZE_MAX) {\n\t\treturn false;\n\t}\n\tElf_(Verdef) *defs = calloc (shdr->sh_size, sizeof (char));\n\tif (!defs) {\n\t\treturn false;\n\t}\n\tif (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {\n\t\tsection_name = &bin->shstrtab[shdr->sh_name];\n\t}\n\tif (link_shdr && bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) {\n\t\tlink_section_name = &bin->shstrtab[link_shdr->sh_name];\n\t}\n\tif (!defs) {\n\t\tbprintf (\"Warning: Cannot allocate memory (Check Elf_(Verdef))\\n\");\n\t\treturn NULL;\n\t}\n\tsdb = sdb_new0 ();\n\tend = (char *)defs + shdr->sh_size;\n\tsdb_set (sdb, \"section_name\", section_name, 0);\n\tsdb_num_set (sdb, \"entries\", shdr->sh_info, 0);\n\tsdb_num_set (sdb, \"addr\", shdr->sh_addr, 0);\n\tsdb_num_set (sdb, \"offset\", shdr->sh_offset, 0);\n\tsdb_num_set (sdb, \"link\", shdr->sh_link, 0);\n\tsdb_set (sdb, \"link_section_name\", link_section_name, 0);\n\n\tfor (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && (end - (char *)defs > i); ++cnt) {\n\t\tSdb *sdb_verdef = sdb_new0 ();\n\t\tchar *vstart = ((char*)defs) + i;\n\t\tchar key[32] = {0};\n\t\tElf_(Verdef) *verdef = (Elf_(Verdef)*)vstart;\n\t\tElf_(Verdaux) aux = {0};\n\t\tint j = 0;\n\t\tint isum = 0;\n\n\t\tr_buf_read_at (bin->b, shdr->sh_offset + i, dfs, sizeof (Elf_(Verdef)));\n\t\tverdef->vd_version = READ16 (dfs, j)\n\t\tverdef->vd_flags = READ16 (dfs, j)\n\t\tverdef->vd_ndx = READ16 (dfs, j)\n\t\tverdef->vd_cnt = READ16 (dfs, j)\n\t\tverdef->vd_hash = READ32 (dfs, j)\n\t\tverdef->vd_aux = READ32 (dfs, j)\n\t\tverdef->vd_next = READ32 (dfs, j)\n\t\tint vdaux = verdef->vd_aux;\n\t\tif (vdaux < 1 || (char *)UINTPTR_MAX - vstart < vdaux) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\t\tvstart += vdaux;\n\t\tif (vstart > end || end - vstart < sizeof (Elf_(Verdaux))) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tj = 0;\n\t\taux.vda_name = READ32 (vstart, j)\n\t\taux.vda_next = READ32 (vstart, j)\n\n\t\tisum = i + verdef->vd_aux;\n\t\tif (aux.vda_name > bin->dynstr_size) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tsdb_num_set (sdb_verdef, \"idx\", i, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_version\", verdef->vd_version, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_ndx\", verdef->vd_ndx, 0);\n\t\tsdb_num_set (sdb_verdef, \"vd_cnt\", verdef->vd_cnt, 0);\n\t\tsdb_set (sdb_verdef, \"vda_name\", &bin->dynstr[aux.vda_name], 0);\n\t\tsdb_set (sdb_verdef, \"flags\", get_ver_flags (verdef->vd_flags), 0);\n\n\t\tfor (j = 1; j < verdef->vd_cnt; ++j) {\n\t\t\tint k;\n\t\t\tSdb *sdb_parent = sdb_new0 ();\n\t\t\tisum += aux.vda_next;\n\t\t\tvstart += aux.vda_next;\n\t\t\tif (vstart > end || end - vstart < sizeof (Elf_(Verdaux))) {\n\t\t\t\tsdb_free (sdb_verdef);\n\t\t\t\tsdb_free (sdb_parent);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tk = 0;\n\t\t\taux.vda_name = READ32 (vstart, k)\n\t\t\taux.vda_next = READ32 (vstart, k)\n\t\t\tif (aux.vda_name > bin->dynstr_size) {\n\t\t\t\tsdb_free (sdb_verdef);\n\t\t\t\tsdb_free (sdb_parent);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tsdb_num_set (sdb_parent, \"idx\", isum, 0);\n\t\t\tsdb_num_set (sdb_parent, \"parent\", j, 0);\n\t\t\tsdb_set (sdb_parent, \"vda_name\", &bin->dynstr[aux.vda_name], 0);\n\t\t\tsnprintf (key, sizeof (key), \"parent%d\", j - 1);\n\t\t\tsdb_ns_set (sdb_verdef, key, sdb_parent);\n\t\t}\n\n\t\tsnprintf (key, sizeof (key), \"verdef%d\", cnt);\n\t\tsdb_ns_set (sdb, key, sdb_verdef);\n\t\tif (!verdef->vd_next) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\t\tif ((st32)verdef->vd_next < 1) {\n\t\t\teprintf (\"Warning: Invalid vd_next in the ELF version\\n\");\n\t\t\tbreak;\n\t\t}\n\t\ti += verdef->vd_next;\n\t}", "target": 1, "idx": 11463}
{"commit_id": "c992857618db99776917f10bf4f2345a5fdc78b0", "project": "redis", "func": "sds sdsMakeRoomFor(sds s, size_t addlen) {\n    void *sh, *newsh;\n    size_t avail = sdsavail(s);\n    size_t len, newlen;\n    char type, oldtype = s[-1] & SDS_TYPE_MASK;\n    int hdrlen;\n\n    /* Return ASAP if there is enough space left. */\n    if (avail >= addlen) return s;\n\n    len = sdslen(s);\n    sh = (char*)s-sdsHdrSize(oldtype);\n    newlen = (len+addlen);\n    assert(newlen > len);   /* Catch size_t overflow */\n    if (newlen < SDS_MAX_PREALLOC)\n        newlen *= 2;\n    else\n        newlen += SDS_MAX_PREALLOC;\n\n    type = sdsReqType(newlen);\n\n    /* Don't use type 5: the user is appending to the string and type 5 is\n     * not able to remember empty space, so sdsMakeRoomFor() must be called\n     * at every appending operation. */\n    if (type == SDS_TYPE_5) type = SDS_TYPE_8;\n\n    hdrlen = sdsHdrSize(type);\n    assert(hdrlen + newlen + 1 > len);  /* Catch size_t overflow */\n    if (oldtype==type) {\n        newsh = s_realloc(sh, hdrlen+newlen+1);\n        if (newsh == NULL) return NULL;\n        s = (char*)newsh+hdrlen;\n    } else {\n        /* Since the header size changes, need to move the string forward,\n         * and can't use realloc */\n        newsh = s_malloc(hdrlen+newlen+1);\n        if (newsh == NULL) return NULL;\n        memcpy((char*)newsh+hdrlen, s, len+1);\n        s_free(sh);\n        s = (char*)newsh+hdrlen;\n        s[-1] = type;\n        sdssetlen(s, len);\n    }\n    sdssetalloc(s, newlen);\n    return s;\n}", "target": 1, "idx": 11464}
{"commit_id": "f60a85cad677c4f9bb4cadd764f1d106c38c7cf8", "project": "torvalds/linux", "func": "static void umd_cleanup(struct subprocess_info *info)\n{\n\tstruct umd_info *umd_info = info->data;\n\n\t/* cleanup if umh_setup() was successful but exec failed */\n\tif (info->retval)\n\t\tumd_cleanup_helper(umd_info);\n}", "target": 1, "idx": 11465}
{"commit_id": "dd4f16e7e816f2165fba76e3d162cd8d2978dcb2", "project": "lldpd", "func": "int\nlldp_decode(struct lldpd *cfg, char *frame, int s,\n    struct lldpd_hardware *hardware,\n    struct lldpd_chassis **newchassis, struct lldpd_port **newport)\n{\n\tstruct lldpd_chassis *chassis;\n\tstruct lldpd_port *port;\n\tconst char lldpaddr[] = LLDP_MULTICAST_ADDR;\n\tconst char dot1[] = LLDP_TLV_ORG_DOT1;\n\tconst char dot3[] = LLDP_TLV_ORG_DOT3;\n\tconst char med[] = LLDP_TLV_ORG_MED;\n\tconst char dcbx[] = LLDP_TLV_ORG_DCBX;\n\tunsigned char orgid[3];\n\tint length, gotend = 0, ttl_received = 0;\n\tint tlv_size, tlv_type, tlv_subtype;\n\tu_int8_t *pos, *tlv;\n\tchar *b;\n#ifdef ENABLE_DOT1\n\tstruct lldpd_vlan *vlan = NULL;\n\tint vlan_len;\n\tstruct lldpd_ppvid *ppvid;\n\tstruct lldpd_pi *pi = NULL;\n#endif\n\tstruct lldpd_mgmt *mgmt;\n\tint af;\n\tu_int8_t addr_str_length, addr_str_buffer[32];\n\tu_int8_t addr_family, addr_length, *addr_ptr, iface_subtype;\n\tu_int32_t iface_number, iface;\n#ifdef ENABLE_CUSTOM\n\tstruct lldpd_custom *custom = NULL;\n#endif\n\n\tlog_debug(\"lldp\", \"receive LLDP PDU on %s\",\n\t    hardware->h_ifname);\n\n\tif ((chassis = calloc(1, sizeof(struct lldpd_chassis))) == NULL) {\n\t\tlog_warn(\"lldp\", \"failed to allocate remote chassis\");\n\t\treturn -1;\n\t}\n\tTAILQ_INIT(&chassis->c_mgmt);\n\tif ((port = calloc(1, sizeof(struct lldpd_port))) == NULL) {\n\t\tlog_warn(\"lldp\", \"failed to allocate remote port\");\n\t\tfree(chassis);\n\t\treturn -1;\n\t}\n#ifdef ENABLE_DOT1\n\tTAILQ_INIT(&port->p_vlans);\n\tTAILQ_INIT(&port->p_ppvids);\n\tTAILQ_INIT(&port->p_pids);\n#endif\n#ifdef ENABLE_CUSTOM\n\tTAILQ_INIT(&port->p_custom_list);\n#endif\n\n\tlength = s;\n\tpos = (u_int8_t*)frame;\n\n\tif (length < 2*ETHER_ADDR_LEN + sizeof(u_int16_t)) {\n\t\tlog_warnx(\"lldp\", \"too short frame received on %s\", hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tif (PEEK_CMP(lldpaddr, ETHER_ADDR_LEN) != 0) {\n\t\tlog_info(\"lldp\", \"frame not targeted at LLDP multicast address received on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tPEEK_DISCARD(ETHER_ADDR_LEN);\t/* Skip source address */\n\tif (PEEK_UINT16 != ETHERTYPE_LLDP) {\n\t\tlog_info(\"lldp\", \"non LLDP frame received on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\n\twhile (length && (!gotend)) {\n\t\tif (length < 2) {\n\t\t\tlog_warnx(\"lldp\", \"tlv header too short received on %s\",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t\ttlv_size = PEEK_UINT16;\n\t\ttlv_type = tlv_size >> 9;\n\t\ttlv_size = tlv_size & 0x1ff;\n\t\t(void)PEEK_SAVE(tlv);\n\t\tif (length < tlv_size) {\n\t\t\tlog_warnx(\"lldp\", \"frame too short for tlv received on %s\",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t\tswitch (tlv_type) {\n\t\tcase LLDP_TLV_END:\n\t\t\tif (tlv_size != 0) {\n\t\t\t\tlog_warnx(\"lldp\", \"lldp end received with size not null on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tif (length)\n\t\t\t\tlog_debug(\"lldp\", \"extra data after lldp end on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\tgotend = 1;\n\t\t\tbreak;\n\t\tcase LLDP_TLV_CHASSIS_ID:\n\t\tcase LLDP_TLV_PORT_ID:\n\t\t\tCHECK_TLV_SIZE(2, \"Port Id\");\n\t\t\ttlv_subtype = PEEK_UINT8;\n\t\t\tif ((tlv_subtype == 0) || (tlv_subtype > 7)) {\n\t\t\t\tlog_warnx(\"lldp\", \"unknown subtype for tlv id received on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tif ((b = (char *)calloc(1, tlv_size - 1)) == NULL) {\n\t\t\t\tlog_warn(\"lldp\", \"unable to allocate memory for id tlv \"\n\t\t\t\t    \"received on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tPEEK_BYTES(b, tlv_size - 1);\n\t\t\tif (tlv_type == LLDP_TLV_PORT_ID) {\n\t\t\t\tport->p_id_subtype = tlv_subtype;\n\t\t\t\tport->p_id = b;\n\t\t\t\tport->p_id_len = tlv_size - 1;\n\t\t\t} else {\n\t\t\t\tchassis->c_id_subtype = tlv_subtype;\n\t\t\t\tchassis->c_id = b;\n\t\t\t\tchassis->c_id_len = tlv_size - 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LLDP_TLV_TTL:\n\t\t\tCHECK_TLV_SIZE(2, \"TTL\");\n\t\t\tchassis->c_ttl = PEEK_UINT16;\n\t\t\tttl_received = 1;\n\t\t\tbreak;\n\t\tcase LLDP_TLV_PORT_DESCR:\n\t\tcase LLDP_TLV_SYSTEM_NAME:\n\t\tcase LLDP_TLV_SYSTEM_DESCR:\n\t\t\tif (tlv_size < 1) {\n\t\t\t\tlog_debug(\"lldp\", \"empty tlv received on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((b = (char *)calloc(1, tlv_size + 1)) == NULL) {\n\t\t\t\tlog_warn(\"lldp\", \"unable to allocate memory for string tlv \"\n\t\t\t\t    \"received on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tPEEK_BYTES(b, tlv_size);\n\t\t\tif (tlv_type == LLDP_TLV_PORT_DESCR)\n\t\t\t\tport->p_descr = b;\n\t\t\telse if (tlv_type == LLDP_TLV_SYSTEM_NAME)\n\t\t\t\tchassis->c_name = b;\n\t\t\telse chassis->c_descr = b;\n\t\t\tbreak;\n\t\tcase LLDP_TLV_SYSTEM_CAP:\n\t\t\tCHECK_TLV_SIZE(4, \"System capabilities\");\n\t\t\tchassis->c_cap_available = PEEK_UINT16;\n\t\t\tchassis->c_cap_enabled = PEEK_UINT16;\n\t\t\tbreak;\n\t\tcase LLDP_TLV_MGMT_ADDR:\n\t\t\tCHECK_TLV_SIZE(1, \"Management address\");\n\t\t\taddr_str_length = PEEK_UINT8;\n\t\t\tif (addr_str_length > sizeof(addr_str_buffer)) {\n\t\t\t\tlog_warnx(\"lldp\", \"too large management address on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tCHECK_TLV_SIZE(1 + addr_str_length, \"Management address\");\n\t\t\tPEEK_BYTES(addr_str_buffer, addr_str_length);\n\t\t\taddr_length = addr_str_length - 1;\n\t\t\taddr_family = addr_str_buffer[0];\n\t\t\taddr_ptr = &addr_str_buffer[1];\n\t\t\tCHECK_TLV_SIZE(1 + addr_str_length + 5, \"Management address\");\n\t\t\tiface_subtype = PEEK_UINT8;\n\t\t\tiface_number = PEEK_UINT32;\n\n\t\t\taf = lldpd_af_from_lldp_proto(addr_family);\n\t\t\tif (af == LLDPD_AF_UNSPEC)\n\t\t\t\tbreak;\n\t\t\tif (iface_subtype == LLDP_MGMT_IFACE_IFINDEX)\n\t\t\t\tiface = iface_number;\n\t\t\telse\n\t\t\t\tiface = 0;\n\t\t\tmgmt = lldpd_alloc_mgmt(af, addr_ptr, addr_length, iface);\n\t\t\tif (mgmt == NULL) {\n\t\t\t\tassert(errno == ENOMEM);\n\t\t\t\tlog_warn(\"lldp\", \"unable to allocate memory \"\n\t\t\t\t\t\t\t\"for management address\");\n\t\t\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tTAILQ_INSERT_TAIL(&chassis->c_mgmt, mgmt, m_entries);\n\t\t\tbreak;\n\t\tcase LLDP_TLV_ORG:\n\t\t\tCHECK_TLV_SIZE(1 + (int)sizeof(orgid), \"Organisational\");\n\t\t\tPEEK_BYTES(orgid, sizeof(orgid));\n\t\t\ttlv_subtype = PEEK_UINT8;\n\t\t\tif (memcmp(dot1, orgid, sizeof(orgid)) == 0) {\n#ifndef ENABLE_DOT1\n\t\t\t\thardware->h_rx_unrecognized_cnt++;\n#else\n\t\t\t\t/* Dot1 */\n\t\t\t\tswitch (tlv_subtype) {\n\t\t\t\tcase LLDP_TLV_DOT1_VLANNAME:\n\t\t\t\t\tCHECK_TLV_SIZE(7, \"VLAN\");\n\t\t\t\t\tif ((vlan = (struct lldpd_vlan *)calloc(1,\n\t\t\t\t\t\t    sizeof(struct lldpd_vlan))) == NULL) {\n\t\t\t\t\t\tlog_warn(\"lldp\", \"unable to alloc vlan \"\n\t\t\t\t\t\t    \"structure for \"\n\t\t\t\t\t\t    \"tlv received on %s\",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tvlan->v_vid = PEEK_UINT16;\n\t\t\t\t\tvlan_len = PEEK_UINT8;\n\t\t\t\t\tCHECK_TLV_SIZE(7 + vlan_len, \"VLAN\");\n\t\t\t\t\tif ((vlan->v_name =\n\t\t\t\t\t\t(char *)calloc(1, vlan_len + 1)) == NULL) {\n\t\t\t\t\t\tlog_warn(\"lldp\", \"unable to alloc vlan name for \"\n\t\t\t\t\t\t    \"tlv received on %s\",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tPEEK_BYTES(vlan->v_name, vlan_len);\n\t\t\t\t\tTAILQ_INSERT_TAIL(&port->p_vlans,\n\t\t\t\t\t    vlan, v_entries);\n\t\t\t\t\tvlan = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT1_PVID:\n\t\t\t\t\tCHECK_TLV_SIZE(6, \"PVID\");\n\t\t\t\t\tport->p_pvid = PEEK_UINT16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT1_PPVID:\n\t\t\t\t\tCHECK_TLV_SIZE(7, \"PPVID\");\n\t\t\t\t\t/* validation needed */\n\t\t\t\t\t/* PPVID has to be unique if more than\n\t\t\t\t\t   one PPVID TLVs are received  - \n\t\t\t\t\t   discard if duplicate */\n\t\t\t\t\t/* if support bit is not set and \n\t\t\t\t\t   enabled bit is set - PPVID TLV is\n\t\t\t\t\t   considered error  and discarded */\n\t\t\t\t\t/* if PPVID > 4096 - bad and discard */\n\t\t\t\t\tif ((ppvid = (struct lldpd_ppvid *)calloc(1,\n\t\t\t\t\t\t    sizeof(struct lldpd_ppvid))) == NULL) {\n\t\t\t\t\t\tlog_warn(\"lldp\", \"unable to alloc ppvid \"\n\t\t\t\t\t\t    \"structure for \"\n\t\t\t\t\t\t    \"tlv received on %s\",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tppvid->p_cap_status = PEEK_UINT8;\n\t\t\t\t\tppvid->p_ppvid = PEEK_UINT16;\t\n\t\t\t\t\tTAILQ_INSERT_TAIL(&port->p_ppvids,\n\t\t\t\t\t    ppvid, p_entries);\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT1_PI:\n\t\t\t\t\t/* validation needed */\n\t\t\t\t\t/* PI has to be unique if more than \n\t\t\t\t\t   one PI TLVs are received  - discard\n\t\t\t\t\t   if duplicate ?? */\n\t\t\t\t\tCHECK_TLV_SIZE(5, \"PI\");\n\t\t\t\t\tif ((pi = (struct lldpd_pi *)calloc(1,\n\t\t\t\t\t\t    sizeof(struct lldpd_pi))) == NULL) {\n\t\t\t\t\t\tlog_warn(\"lldp\", \"unable to alloc PI \"\n\t\t\t\t\t\t    \"structure for \"\n\t\t\t\t\t\t    \"tlv received on %s\",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tpi->p_pi_len = PEEK_UINT8;\n\t\t\t\t\tCHECK_TLV_SIZE(5 + pi->p_pi_len, \"PI\");\n\t\t\t\t\tif ((pi->p_pi =\n\t\t\t\t\t\t(char *)calloc(1, pi->p_pi_len)) == NULL) {\n\t\t\t\t\t\tlog_warn(\"lldp\", \"unable to alloc pid name for \"\n\t\t\t\t\t\t    \"tlv received on %s\",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tPEEK_BYTES(pi->p_pi, pi->p_pi_len);\n\t\t\t\t\tTAILQ_INSERT_TAIL(&port->p_pids,\n\t\t\t\t\t    pi, p_entries);\n\t\t\t\t\tpi = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* Unknown Dot1 TLV, ignore it */\n\t\t\t\t\thardware->h_rx_unrecognized_cnt++;\n\t\t\t\t}\n#endif\n\t\t\t} else if (memcmp(dot3, orgid, sizeof(orgid)) == 0) {\n#ifndef ENABLE_DOT3\n\t\t\t\thardware->h_rx_unrecognized_cnt++;\n#else\n\t\t\t\t/* Dot3 */\n\t\t\t\tswitch (tlv_subtype) {\n\t\t\t\tcase LLDP_TLV_DOT3_MAC:\n\t\t\t\t\tCHECK_TLV_SIZE(9, \"MAC/PHY\");\n\t\t\t\t\tport->p_macphy.autoneg_support = PEEK_UINT8;\n\t\t\t\t\tport->p_macphy.autoneg_enabled =\n\t\t\t\t\t    (port->p_macphy.autoneg_support & 0x2) >> 1;\n\t\t\t\t\tport->p_macphy.autoneg_support =\n\t\t\t\t\t    port->p_macphy.autoneg_support & 0x1;\n\t\t\t\t\tport->p_macphy.autoneg_advertised =\n\t\t\t\t\t    PEEK_UINT16;\n\t\t\t\t\tport->p_macphy.mau_type = PEEK_UINT16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT3_LA:\n\t\t\t\t\tCHECK_TLV_SIZE(9, \"Link aggregation\");\n\t\t\t\t\tPEEK_DISCARD_UINT8;\n\t\t\t\t\tport->p_aggregid = PEEK_UINT32;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT3_MFS:\n\t\t\t\t\tCHECK_TLV_SIZE(6, \"MFS\");\n\t\t\t\t\tport->p_mfs = PEEK_UINT16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT3_POWER:\n\t\t\t\t\tCHECK_TLV_SIZE(7, \"Power\");\n\t\t\t\t\tport->p_power.devicetype = PEEK_UINT8;\n\t\t\t\t\tport->p_power.supported =\n\t\t\t\t\t\t(port->p_power.devicetype & 0x2) >> 1;\n\t\t\t\t\tport->p_power.enabled =\n\t\t\t\t\t\t(port->p_power.devicetype & 0x4) >> 2;\n\t\t\t\t\tport->p_power.paircontrol =\n\t\t\t\t\t\t(port->p_power.devicetype & 0x8) >> 3;\n\t\t\t\t\tport->p_power.devicetype =\n\t\t\t\t\t\t(port->p_power.devicetype & 0x1)?\n\t\t\t\t\t\tLLDP_DOT3_POWER_PSE:LLDP_DOT3_POWER_PD;\n\t\t\t\t\tport->p_power.pairs = PEEK_UINT8;\n\t\t\t\t\tport->p_power.class = PEEK_UINT8;\n\t\t\t\t\t/* 802.3at? */\n\t\t\t\t\tif (tlv_size >= 12) {\n\t\t\t\t\t\tport->p_power.powertype = PEEK_UINT8;\n\t\t\t\t\t\tport->p_power.source =\n\t\t\t\t\t\t    (port->p_power.powertype & (1<<5 | 1<<4)) >> 4;\n\t\t\t\t\t\tport->p_power.priority =\n\t\t\t\t\t\t    (port->p_power.powertype & (1<<1 | 1<<0));\n\t\t\t\t\t\tport->p_power.powertype =\n\t\t\t\t\t\t    (port->p_power.powertype & (1<<7))?\n\t\t\t\t\t\t    LLDP_DOT3_POWER_8023AT_TYPE1:\n\t\t\t\t\t\t    LLDP_DOT3_POWER_8023AT_TYPE2;\n\t\t\t\t\t\tport->p_power.requested = PEEK_UINT16;\n\t\t\t\t\t\tport->p_power.allocated = PEEK_UINT16;\n\t\t\t\t\t} else\n\t\t\t\t\t\tport->p_power.powertype =\n\t\t\t\t\t\t    LLDP_DOT3_POWER_8023AT_OFF;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* Unknown Dot3 TLV, ignore it */\n\t\t\t\t\thardware->h_rx_unrecognized_cnt++;\n\t\t\t\t}\n#endif\n\t\t\t} else if (memcmp(med, orgid, sizeof(orgid)) == 0) {\n\t\t\t\t/* LLDP-MED */\n#ifndef ENABLE_LLDPMED\n\t\t\t\thardware->h_rx_unrecognized_cnt++;\n#else\n\t\t\t\tu_int32_t policy;\n\t\t\t\tunsigned loctype;\n\t\t\t\tunsigned power;\n\n\t\t\t\tswitch (tlv_subtype) {\n\t\t\t\tcase LLDP_TLV_MED_CAP:\n\t\t\t\t\tCHECK_TLV_SIZE(7, \"LLDP-MED capabilities\");\n\t\t\t\t\tchassis->c_med_cap_available = PEEK_UINT16;\n\t\t\t\t\tchassis->c_med_type = PEEK_UINT8;\n\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t    LLDP_MED_CAP_CAP;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_MED_POLICY:\n\t\t\t\t\tCHECK_TLV_SIZE(8, \"LLDP-MED policy\");\n\t\t\t\t\tpolicy = PEEK_UINT32;\n\t\t\t\t\tif (((policy >> 24) < 1) ||\n\t\t\t\t\t    ((policy >> 24) > LLDP_MED_APPTYPE_LAST)) {\n\t\t\t\t\t\tlog_info(\"lldp\", \"unknown policy field %d \"\n\t\t\t\t\t\t    \"received on %s\",\n\t\t\t\t\t\t    policy,\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].type =\n\t\t\t\t\t    (policy >> 24);\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].unknown =\n\t\t\t\t\t    ((policy & 0x800000) != 0);\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].tagged =\n\t\t\t\t\t    ((policy & 0x400000) != 0);\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].vid =\n\t\t\t\t\t    (policy & 0x001FFE00) >> 9;\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].priority =\n\t\t\t\t\t    (policy & 0x1C0) >> 6;\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].dscp =\n\t\t\t\t\t    policy & 0x3F;\n\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t    LLDP_MED_CAP_POLICY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_MED_LOCATION:\n\t\t\t\t\tCHECK_TLV_SIZE(5, \"LLDP-MED Location\");\n\t\t\t\t\tloctype = PEEK_UINT8;\n\t\t\t\t\tif ((loctype < 1) ||\n\t\t\t\t\t    (loctype > LLDP_MED_LOCFORMAT_LAST)) {\n\t\t\t\t\t\tlog_info(\"lldp\", \"unknown location type \"\n\t\t\t\t\t\t    \"received on %s\",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif ((port->p_med_location[loctype - 1].data =\n\t\t\t\t\t\t(char*)malloc(tlv_size - 5)) == NULL) {\n\t\t\t\t\t\tlog_warn(\"lldp\", \"unable to allocate memory \"\n\t\t\t\t\t\t    \"for LLDP-MED location for \"\n\t\t\t\t\t\t    \"frame received on %s\",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tPEEK_BYTES(port->p_med_location[loctype - 1].data,\n\t\t\t\t\t    tlv_size - 5);\n\t\t\t\t\tport->p_med_location[loctype - 1].data_len =\n\t\t\t\t\t    tlv_size - 5;\n\t\t\t\t\tport->p_med_location[loctype - 1].format = loctype;\n\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t    LLDP_MED_CAP_LOCATION;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_MED_MDI:\n\t\t\t\t\tCHECK_TLV_SIZE(7, \"LLDP-MED PoE-MDI\");\n\t\t\t\t\tpower = PEEK_UINT8;\n\t\t\t\t\tswitch (power & 0xC0) {\n\t\t\t\t\tcase 0x0:\n\t\t\t\t\t\tport->p_med_power.devicetype = LLDP_MED_POW_TYPE_PSE;\n\t\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t\t    LLDP_MED_CAP_MDI_PSE;\n\t\t\t\t\t\tswitch (power & 0x30) {\n\t\t\t\t\t\tcase 0x0:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_UNKNOWN;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x10:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_PRIMARY;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x20:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_BACKUP;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_RESERVED;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x40:\n\t\t\t\t\t\tport->p_med_power.devicetype = LLDP_MED_POW_TYPE_PD;\n\t\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t\t    LLDP_MED_CAP_MDI_PD;\n\t\t\t\t\t\tswitch (power & 0x30) {\n\t\t\t\t\t\tcase 0x0:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_UNKNOWN;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x10:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_PSE;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x20:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_LOCAL;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_BOTH;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tport->p_med_power.devicetype =\n\t\t\t\t\t\t    LLDP_MED_POW_TYPE_RESERVED;\n\t\t\t\t\t}\n\t\t\t\t\tif ((power & 0x0F) > LLDP_MED_POW_PRIO_LOW)\n\t\t\t\t\t\tport->p_med_power.priority =\n\t\t\t\t\t\t    LLDP_MED_POW_PRIO_UNKNOWN;\n\t\t\t\t\telse\n\t\t\t\t\t\tport->p_med_power.priority =\n\t\t\t\t\t\t    power & 0x0F;\n\t\t\t\t\tport->p_med_power.val = PEEK_UINT16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_MED_IV_HW:\n\t\t\t\tcase LLDP_TLV_MED_IV_SW:\n\t\t\t\tcase LLDP_TLV_MED_IV_FW:\n\t\t\t\tcase LLDP_TLV_MED_IV_SN:\n\t\t\t\tcase LLDP_TLV_MED_IV_MANUF:\n\t\t\t\tcase LLDP_TLV_MED_IV_MODEL:\n\t\t\t\tcase LLDP_TLV_MED_IV_ASSET:\n\t\t\t\t\tif (tlv_size <= 4)\n\t\t\t\t\t\tb = NULL;\n\t\t\t\t\telse {\n\t\t\t\t\t\tif ((b = (char*)malloc(tlv_size - 3)) ==\n\t\t\t\t\t\t    NULL) {\n\t\t\t\t\t\t\tlog_warn(\"lldp\", \"unable to allocate \"\n\t\t\t\t\t\t\t    \"memory for LLDP-MED \"\n\t\t\t\t\t\t\t    \"inventory for frame \"\n\t\t\t\t\t\t\t    \"received on %s\",\n\t\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tPEEK_BYTES(b, tlv_size - 4);\n\t\t\t\t\t\tb[tlv_size - 4] = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tswitch (tlv_subtype) {\n\t\t\t\t\tcase LLDP_TLV_MED_IV_HW:\n\t\t\t\t\t\tchassis->c_med_hw = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_FW:\n\t\t\t\t\t\tchassis->c_med_fw = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_SW:\n\t\t\t\t\t\tchassis->c_med_sw = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_SN:\n\t\t\t\t\t\tchassis->c_med_sn = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_MANUF:\n\t\t\t\t\t\tchassis->c_med_manuf = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_MODEL:\n\t\t\t\t\t\tchassis->c_med_model = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_ASSET:\n\t\t\t\t\t\tchassis->c_med_asset = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t    LLDP_MED_CAP_IV;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* Unknown LLDP MED, ignore it */\n\t\t\t\t\thardware->h_rx_unrecognized_cnt++;\n\t\t\t\t}\n#endif /* ENABLE_LLDPMED */\n\t\t\t} else if (memcmp(dcbx, orgid, sizeof(orgid)) == 0) {\n\t\t\t\tlog_debug(\"lldp\", \"unsupported DCBX tlv received on %s - ignore\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\thardware->h_rx_unrecognized_cnt++;\n\t\t\t} else {\n\t\t\t\tlog_debug(\"lldp\", \"unknown org tlv [%02x:%02x:%02x] received on %s\",\n\t\t\t\t    orgid[0], orgid[1], orgid[2],\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\thardware->h_rx_unrecognized_cnt++;\n#ifdef ENABLE_CUSTOM\n\t\t\t\tcustom = (struct lldpd_custom*)calloc(1, sizeof(struct lldpd_custom));\n\t\t\t\tif (!custom) {\n\t\t\t\t\tlog_warn(\"lldp\",\n\t\t\t\t\t    \"unable to allocate memory for custom TLV\");\n\t\t\t\t\tgoto malformed;\n\t\t\t\t}\n\t\t\t\tcustom->oui_info_len = tlv_size > 4 ? tlv_size - 4 : 0;\n\t\t\t\tmemcpy(custom->oui, orgid, sizeof(custom->oui));\n\t\t\t\tcustom->subtype = tlv_subtype;\n\t\t\t\tif (custom->oui_info_len > 0) {\n\t\t\t\t\tcustom->oui_info = malloc(custom->oui_info_len);\n\t\t\t\t\tif (!custom->oui_info) {\n\t\t\t\t\t\tlog_warn(\"lldp\",\n\t\t\t\t\t\t    \"unable to allocate memory for custom TLV data\");\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tPEEK_BYTES(custom->oui_info, custom->oui_info_len);\n\t\t\t\t}\n\t\t\t\tTAILQ_INSERT_TAIL(&port->p_custom_list, custom, next);\n\t\t\t\tcustom = NULL;\n#endif\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_warnx(\"lldp\", \"unknown tlv (%d) received on %s\",\n\t\t\t    tlv_type, hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t\tif (pos > tlv + tlv_size) {\n\t\t\tlog_warnx(\"lldp\", \"BUG: already past TLV!\");\n\t\t\tgoto malformed;\n\t\t}\n\t\tPEEK_DISCARD(tlv + tlv_size - pos);\n\t}\n\n\t/* Some random check */\n\tif ((chassis->c_id == NULL) ||\n\t    (port->p_id == NULL) ||\n\t    (!ttl_received) ||\n\t    (gotend == 0)) {\n\t\tlog_warnx(\"lldp\", \"some mandatory tlv are missing for frame received on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\t*newchassis = chassis;\n\t*newport = port;\n\treturn 1;\nmalformed:\n#ifdef ENABLE_CUSTOM\n\tfree(custom);\n#endif\n#ifdef ENABLE_DOT1\n\tfree(vlan);\n\tfree(pi);\n#endif\n\tlldpd_chassis_cleanup(chassis, 1);\n\tlldpd_port_cleanup(port, 1);\n\tfree(port);\n\treturn -1;\n}", "target": 3, "idx": 11466}
{"commit_id": "83a4b92815ea04969d494416eaae3d4c6b338e4a", "project": "vadz/libtiff", "func": "static int\nloadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned char **read_ptr)\n  {\n  uint32   i;\n  float    xres = 0.0, yres = 0.0;\n  uint32   nstrips = 0, ntiles = 0;\n  uint16   planar = 0;\n  uint16   bps = 0, spp = 0, res_unit = 0;\n  uint16   orientation = 0;\n  uint16   input_compression = 0, input_photometric = 0;\n  uint16   subsampling_horiz, subsampling_vert;\n  uint32   width = 0, length = 0;\n  uint32   stsize = 0, tlsize = 0, buffsize = 0, scanlinesize = 0;\n  uint32   tw = 0, tl = 0;       /* Tile width and length */\n  uint32   tile_rowsize = 0;\n  unsigned char *read_buff = NULL;\n  unsigned char *new_buff  = NULL;\n  int      readunit = 0;\n  static   uint32  prev_readsize = 0;\n\n  TIFFGetFieldDefaulted(in, TIFFTAG_BITSPERSAMPLE, &bps);\n  TIFFGetFieldDefaulted(in, TIFFTAG_SAMPLESPERPIXEL, &spp);\n  TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &planar);\n  TIFFGetFieldDefaulted(in, TIFFTAG_ORIENTATION, &orientation);\n  if (! TIFFGetFieldDefaulted(in, TIFFTAG_PHOTOMETRIC, &input_photometric))\n    TIFFError(\"loadImage\",\"Image lacks Photometric interpreation tag\");\n  if (! TIFFGetField(in, TIFFTAG_IMAGEWIDTH,  &width))\n    TIFFError(\"loadimage\",\"Image lacks image width tag\");\n  if(! TIFFGetField(in, TIFFTAG_IMAGELENGTH, &length))\n    TIFFError(\"loadimage\",\"Image lacks image length tag\");\n  TIFFGetFieldDefaulted(in, TIFFTAG_XRESOLUTION, &xres);\n  TIFFGetFieldDefaulted(in, TIFFTAG_YRESOLUTION, &yres);\n  if (!TIFFGetFieldDefaulted(in, TIFFTAG_RESOLUTIONUNIT, &res_unit))\n    res_unit = RESUNIT_INCH;\n  if (!TIFFGetField(in, TIFFTAG_COMPRESSION, &input_compression))\n    input_compression = COMPRESSION_NONE;\n\n#ifdef DEBUG2\n  char compressionid[16];\n\n  switch (input_compression)\n    {\n    case COMPRESSION_NONE:\t/* 1  dump mode */\n\t strcpy (compressionid, \"None/dump\");\n         break;         \n    case COMPRESSION_CCITTRLE:\t  /* 2 CCITT modified Huffman RLE */\n\t strcpy (compressionid, \"Huffman RLE\");\n         break;         \n    case COMPRESSION_CCITTFAX3:\t  /* 3 CCITT Group 3 fax encoding */\n\t strcpy (compressionid, \"Group3 Fax\");\n         break;         \n    case COMPRESSION_CCITTFAX4:\t  /* 4 CCITT Group 4 fax encoding */\n\t strcpy (compressionid, \"Group4 Fax\");\n         break;         \n    case COMPRESSION_LZW:\t  /* 5 Lempel-Ziv  & Welch */\n\t strcpy (compressionid, \"LZW\");\n         break;         \n    case COMPRESSION_OJPEG:\t  /* 6 !6.0 JPEG */\n\t strcpy (compressionid, \"Old Jpeg\");\n         break;         \n    case COMPRESSION_JPEG:\t  /* 7 %JPEG DCT compression */\n\t strcpy (compressionid, \"New Jpeg\");\n         break;         \n    case COMPRESSION_NEXT:\t  /* 32766 NeXT 2-bit RLE */\n\t strcpy (compressionid, \"Next RLE\");\n         break;         \n    case COMPRESSION_CCITTRLEW:   /* 32771 #1 w/ word alignment */\n\t strcpy (compressionid, \"CITTRLEW\");\n         break;         \n    case COMPRESSION_PACKBITS:\t  /* 32773 Macintosh RLE */\n\t strcpy (compressionid, \"Mac Packbits\");\n         break;         \n    case COMPRESSION_THUNDERSCAN: /* 32809 ThunderScan RLE */\n\t strcpy (compressionid, \"Thunderscan\");\n         break;         \n    case COMPRESSION_IT8CTPAD:\t  /* 32895 IT8 CT w/padding */\n\t strcpy (compressionid, \"IT8 padded\");\n         break;         \n    case COMPRESSION_IT8LW:\t  /* 32896 IT8 Linework RLE */\n\t strcpy (compressionid, \"IT8 RLE\");\n         break;         \n    case COMPRESSION_IT8MP:\t  /* 32897 IT8 Monochrome picture */\n\t strcpy (compressionid, \"IT8 mono\");\n         break;         \n    case COMPRESSION_IT8BL:\t  /* 32898 IT8 Binary line art */\n\t strcpy (compressionid, \"IT8 lineart\");\n         break;         \n    case COMPRESSION_PIXARFILM:\t  /* 32908 Pixar companded 10bit LZW */\n\t strcpy (compressionid, \"Pixar 10 bit\");\n         break;         \n    case COMPRESSION_PIXARLOG:\t  /* 32909 Pixar companded 11bit ZIP */\n\t strcpy (compressionid, \"Pixar 11bit\");\n         break;         \n    case COMPRESSION_DEFLATE:\t  /* 32946 Deflate compression */\n\t strcpy (compressionid, \"Deflate\");\n         break;         \n    case COMPRESSION_ADOBE_DEFLATE: /* 8 Deflate compression */\n\t strcpy (compressionid, \"Adobe deflate\");\n         break;         \n    default:\n\t strcpy (compressionid, \"None/unknown\");\n         break;         \n    }\n  TIFFError(\"loadImage\", \"Input compression %s\", compressionid);\n#endif\n\n  scanlinesize = TIFFScanlineSize(in);\n  image->bps = bps;\n  image->spp = spp;\n  image->planar = planar;\n  image->width = width;\n  image->length = length;\n  image->xres = xres;\n  image->yres = yres;\n  image->res_unit = res_unit;\n  image->compression = input_compression;\n  image->photometric = input_photometric;\n#ifdef DEBUG2\n  char photometricid[12];\n\n  switch (input_photometric)\n    {\n    case PHOTOMETRIC_MINISWHITE:\n         strcpy (photometricid, \"MinIsWhite\");\n         break;\n    case PHOTOMETRIC_MINISBLACK:\n         strcpy (photometricid, \"MinIsBlack\");\n         break;\n    case PHOTOMETRIC_RGB:\n         strcpy (photometricid, \"RGB\");\n         break;\n    case PHOTOMETRIC_PALETTE:\n         strcpy (photometricid, \"Palette\");\n         break;\n    case PHOTOMETRIC_MASK:\n         strcpy (photometricid, \"Mask\");\n         break;\n    case PHOTOMETRIC_SEPARATED:\n         strcpy (photometricid, \"Separated\");\n         break;\n    case PHOTOMETRIC_YCBCR:\n         strcpy (photometricid, \"YCBCR\");\n         break;\n    case PHOTOMETRIC_CIELAB:\n         strcpy (photometricid, \"CIELab\");\n         break;\n    case PHOTOMETRIC_ICCLAB:\n         strcpy (photometricid, \"ICCLab\");\n         break;\n    case PHOTOMETRIC_ITULAB:\n         strcpy (photometricid, \"ITULab\");\n         break;\n    case PHOTOMETRIC_LOGL:\n         strcpy (photometricid, \"LogL\");\n         break;\n    case PHOTOMETRIC_LOGLUV:\n         strcpy (photometricid, \"LOGLuv\");\n         break;\n    default:\n         strcpy (photometricid, \"Unknown\");\n         break;\n    }\n  TIFFError(\"loadImage\", \"Input photometric interpretation %s\", photometricid);\n\n#endif\n  image->orientation = orientation;\n  switch (orientation)\n    {\n    case 0:\n    case ORIENTATION_TOPLEFT:\n         image->adjustments = 0;\n\t break;\n    case ORIENTATION_TOPRIGHT:\n         image->adjustments = MIRROR_HORIZ;\n\t break;\n    case ORIENTATION_BOTRIGHT:\n         image->adjustments = ROTATECW_180;\n\t break;\n    case ORIENTATION_BOTLEFT:\n         image->adjustments = MIRROR_VERT; \n\t break;\n    case ORIENTATION_LEFTTOP:\n         image->adjustments = MIRROR_VERT | ROTATECW_90;\n\t break;\n    case ORIENTATION_RIGHTTOP:\n         image->adjustments = ROTATECW_90;\n\t break;\n    case ORIENTATION_RIGHTBOT:\n         image->adjustments = MIRROR_VERT | ROTATECW_270;\n\t break; \n    case ORIENTATION_LEFTBOT:\n         image->adjustments = ROTATECW_270;\n\t break;\n    default:\n         image->adjustments = 0;\n         image->orientation = ORIENTATION_TOPLEFT;\n   }\n\n  if ((bps == 0) || (spp == 0))\n    {\n    TIFFError(\"loadImage\", \"Invalid samples per pixel (%d) or bits per sample (%d)\",\n\t       spp, bps);\n    return (-1);\n    }\n\n  if (TIFFIsTiled(in))\n    {\n    readunit = TILE;\n    tlsize = TIFFTileSize(in);\n    ntiles = TIFFNumberOfTiles(in);\n    TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n    TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n\n    tile_rowsize  = TIFFTileRowSize(in);      \n    if (ntiles == 0 || tlsize == 0 || tile_rowsize == 0)\n    {\n\tTIFFError(\"loadImage\", \"File appears to be tiled, but the number of tiles, tile size, or tile rowsize is zero.\");\n\texit(-1);\n    }\n    buffsize = tlsize * ntiles;\n    if (tlsize != (buffsize / ntiles))\n    {\n\tTIFFError(\"loadImage\", \"Integer overflow when calculating buffer size\");\n\texit(-1);\n    }\n\n    if (buffsize < (uint32)(ntiles * tl * tile_rowsize))\n      {\n      buffsize = ntiles * tl * tile_rowsize;\n      if (ntiles != (buffsize / tl / tile_rowsize))\n      {\n\tTIFFError(\"loadImage\", \"Integer overflow when calculating buffer size\");\n\texit(-1);\n      }\n      \n#ifdef DEBUG2\n      TIFFError(\"loadImage\",\n\t        \"Tilesize %u is too small, using ntiles * tilelength * tilerowsize %lu\",\n                tlsize, (unsigned long)buffsize);\n#endif\n      }\n    \n    if (dump->infile != NULL)\n      dump_info (dump->infile, dump->format, \"\", \n                 \"Tilesize: %u, Number of Tiles: %u, Tile row size: %u\",\n                 tlsize, ntiles, tile_rowsize);\n    }\n  else\n    {\n    uint32 buffsize_check;\n    readunit = STRIP;\n    TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    stsize = TIFFStripSize(in);\n    nstrips = TIFFNumberOfStrips(in);\n    if (nstrips == 0 || stsize == 0)\n    {\n\tTIFFError(\"loadImage\", \"File appears to be striped, but the number of stipes or stripe size is zero.\");\n\texit(-1);\n    }\n\n    buffsize = stsize * nstrips;\n    if (stsize != (buffsize / nstrips))\n    {\n\tTIFFError(\"loadImage\", \"Integer overflow when calculating buffer size\");\n\texit(-1);\n    }\n    buffsize_check = ((length * width * spp * bps) + 7);\n    if (length != ((buffsize_check - 7) / width / spp / bps))\n    {\n\tTIFFError(\"loadImage\", \"Integer overflow detected.\");\n\texit(-1);\n    }\n    if (buffsize < (uint32) (((length * width * spp * bps) + 7) / 8))\n      {\n      buffsize =  ((length * width * spp * bps) + 7) / 8;\n#ifdef DEBUG2\n      TIFFError(\"loadImage\",\n\t        \"Stripsize %u is too small, using imagelength * width * spp * bps / 8 = %lu\",\n                stsize, (unsigned long)buffsize);\n#endif\n      }\n    \n    if (dump->infile != NULL)\n      dump_info (dump->infile, dump->format, \"\",\n                 \"Stripsize: %u, Number of Strips: %u, Rows per Strip: %u, Scanline size: %u\",\n\t\t stsize, nstrips, rowsperstrip, scanlinesize);\n    }\n  \n  if (input_compression == COMPRESSION_JPEG)\n    {  /* Force conversion to RGB */\n    jpegcolormode = JPEGCOLORMODE_RGB;\n    TIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n    }\n  /* The clause up to the read statement is taken from Tom Lane's tiffcp patch */\n  else \n    {   /* Otherwise, can't handle subsampled input */\n    if (input_photometric == PHOTOMETRIC_YCBCR)\n      {\n      TIFFGetFieldDefaulted(in, TIFFTAG_YCBCRSUBSAMPLING,\n \t\t           &subsampling_horiz, &subsampling_vert);\n      if (subsampling_horiz != 1 || subsampling_vert != 1)\n        {\n\tTIFFError(\"loadImage\", \n\t\t\"Can't copy/convert subsampled image with subsampling %d horiz %d vert\",\n                subsampling_horiz, subsampling_vert);\n        return (-1);\n        }\n\t}\n    }\n \n  read_buff = *read_ptr;\n  /* +3 : add a few guard bytes since reverseSamples16bits() can read a bit */\n  /* outside buffer */\n  if (!read_buff)\n  {\n    if( buffsize > 0xFFFFFFFFU - 3 )\n    {\n        TIFFError(\"loadImage\", \"Unable to allocate/reallocate read buffer\");\n        return (-1);\n    }\n    read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);\n  }\n  else\n    {\n    if (prev_readsize < buffsize)\n    {\n      if( buffsize > 0xFFFFFFFFU - 3 )\n      {\n          TIFFError(\"loadImage\", \"Unable to allocate/reallocate read buffer\");\n          return (-1);\n      }\n      new_buff = _TIFFrealloc(read_buff, buffsize+3);\n      if (!new_buff)\n        {\n\tfree (read_buff);\n        read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);\n        }\n      else\n        read_buff = new_buff;\n      }\n    }\n  if (!read_buff)\n    {\n    TIFFError(\"loadImage\", \"Unable to allocate/reallocate read buffer\");\n    return (-1);\n    }\n\n  read_buff[buffsize] = 0;\n  read_buff[buffsize+1] = 0;\n  read_buff[buffsize+2] = 0;\n\n  prev_readsize = buffsize;\n  *read_ptr = read_buff;\n\n  /* N.B. The read functions used copy separate plane data into a buffer as interleaved\n   * samples rather than separate planes so the same logic works to extract regions\n   * regardless of the way the data are organized in the input file.\n   */\n  switch (readunit) {\n    case STRIP:\n         if (planar == PLANARCONFIG_CONTIG)\n           {\n\t     if (!(readContigStripsIntoBuffer(in, read_buff)))\n\t     {\n\t     TIFFError(\"loadImage\", \"Unable to read contiguous strips into buffer\");\n\t     return (-1);\n             }\n           }\n         else\n           {\n\t   if (!(readSeparateStripsIntoBuffer(in, read_buff, length, width, spp, dump)))\n\t     {\n\t     TIFFError(\"loadImage\", \"Unable to read separate strips into buffer\");\n\t     return (-1);\n             }\n           }\n         break;\n\n    case TILE:\n         if (planar == PLANARCONFIG_CONTIG)\n           {\n\t   if (!(readContigTilesIntoBuffer(in, read_buff, length, width, tw, tl, spp, bps)))\n\t     {\n\t     TIFFError(\"loadImage\", \"Unable to read contiguous tiles into buffer\");\n\t     return (-1);\n             }\n           }\n         else\n           {\n\t   if (!(readSeparateTilesIntoBuffer(in, read_buff, length, width, tw, tl, spp, bps)))\n\t     {\n\t     TIFFError(\"loadImage\", \"Unable to read separate tiles into buffer\");\n\t     return (-1);\n             }\n           }\n         break;\n    default: TIFFError(\"loadImage\", \"Unsupported image file format\");\n          return (-1);\n          break;\n    }\n  if ((dump->infile != NULL) && (dump->level == 2))\n    {\n    dump_info  (dump->infile, dump->format, \"loadImage\", \n                \"Image width %d, length %d, Raw image data, %4d bytes\",\n                width, length,  buffsize);\n    dump_info  (dump->infile, dump->format, \"\", \n                \"Bits per sample %d, Samples per pixel %d\", bps, spp);\n\n    for (i = 0; i < length; i++)\n      dump_buffer(dump->infile, dump->format, 1, scanlinesize, \n                  i, read_buff + (i * scanlinesize));\n    }\n  return (0);\n  }", "target": 3, "idx": 11467}
{"commit_id": "755d3f9debf8879448211fffb018f556136f6a79", "project": "xen-project/xen", "func": "int domain_entry_inc(struct connection *conn, struct node *node)\n{\n\tstruct domain *d;\n\tunsigned int domid;\n\n\tif (!node->perms.p)\n\t\treturn 0;\n\n\tdomid = node->perms.p[0].id;\n\n\tif (conn && conn->transaction) {\n\t\ttransaction_entry_inc(conn->transaction, domid);\n\t} else {\n\t\td = (conn && domid == conn->id && conn->domain) ? conn->domain\n\t\t    : find_or_alloc_existing_domain(domid);\n\t\tif (d)\n\t\t\td->nbentry++;\n\t\telse\n\t\t\treturn ENOMEM;\n\t}\n\n\treturn 0;\n}", "target": 1, "idx": 11468}
{"commit_id": "b4e79bfa0c7d2d08f6f1e7ec38143fc8cb11394a", "project": "libtiff", "func": "static int\nLZWDecode(TIFF* tif, uint8_t* op0, tmsize_t occ0, uint16_t s)\n{\n\tstatic const char module[] = \"LZWDecode\";\n\tLZWCodecState *sp = DecoderState(tif);\n\tuint8_t *op = (uint8_t*) op0;\n\ttmsize_t occ = occ0;\n\tuint8_t *bp;\n\tlong nbits, nextbits, nbitsmask;\n\tWordType nextdata;\n\tcode_t *free_entp, *maxcodep, *oldcodep;\n\n\t(void) s;\n\tassert(sp != NULL);\n\tassert(sp->dec_codetab != NULL);\n\n\tif (sp->read_error) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Restart interrupted output operation.\n\t */\n\tif (sp->dec_restart) {\n\t\ttmsize_t residue;\n\n\t\tcode_t* codep = sp->dec_codep;\n\t\tresidue = codep->length - sp->dec_restart;\n\t\tif (residue > occ) {\n\t\t\t/*\n\t\t\t * Residue from previous decode is sufficient\n\t\t\t * to satisfy decode request.  Skip to the\n\t\t\t * start of the decoded string, place decoded\n\t\t\t * values in the output buffer, and return.\n\t\t\t */\n\t\t\tsp->dec_restart += occ;\n\t\t\tdo {\n\t\t\t\tcodep = codep->next;\n\t\t\t} while (--residue > occ && codep);\n\t\t\tif (codep) {\n\t\t\t\tuint8_t* tp = op + occ;\n\t\t\t\tdo {\n\t\t\t\t\t*--tp = codep->value;\n\t\t\t\t\tcodep = codep->next;\n\t\t\t\t} while (--occ && codep);\n\t\t\t}\n\t\t\treturn (1);\n\t\t}\n\t\t/*\n\t\t * Residue satisfies only part of the decode request.\n\t\t */\n\t\top += residue;\n\t\tocc -= residue;\n\t\tuint8_t* tp = op;\n\t\tdo {\n\t\t\t*--tp = codep->value;\n\t\t\tcodep = codep->next;\n\t\t} while (--residue && codep);\n\t\tsp->dec_restart = 0;\n\t}\n\n\tbp = (uint8_t*)tif->tif_rawcp;\n\tsp->dec_bitsleft += (((uint64_t)tif->tif_rawcc - sp->old_tif_rawcc) << 3);\n\tuint64_t dec_bitsleft = sp->dec_bitsleft;\n\tnbits = sp->lzw_nbits;\n\tnextdata = sp->lzw_nextdata;\n\tnextbits = sp->lzw_nextbits;\n\tnbitsmask = sp->dec_nbitsmask;\n\toldcodep = sp->dec_oldcodep;\n\tfree_entp = sp->dec_free_entp;\n\tmaxcodep = sp->dec_maxcodep;\n\tcode_t* const dec_codetab = sp->dec_codetab;\n\tcode_t* codep;\n\n    if (occ == 0) {\n        goto after_loop;\n    }\n\nbegin:\n    {\n        WordType code;\n        GetNextCodeLZW();\n        codep = dec_codetab + code;\n        if (code >= CODE_FIRST)\n            goto code_above_or_equal_to_258;\n        if (code < 256)\n            goto code_below_256;\n        if (code == CODE_EOI)\n            goto after_loop;\n        goto code_clear;\n\ncode_below_256:\n        {\n            if (codep > free_entp)\n                goto error_code;\n            free_entp->next = oldcodep;\n            free_entp->firstchar = oldcodep->firstchar;\n            free_entp->length = oldcodep->length+1;\n            free_entp->value = (uint8_t)code;\n            free_entp->repeated = (bool)(oldcodep->repeated & (oldcodep->value == code));\n            if (++free_entp > maxcodep) {\n                if (++nbits > BITS_MAX)\t\t/* should not happen for a conformant encoder */\n                    nbits = BITS_MAX;\n                nbitsmask = MAXCODE(nbits);\n                maxcodep = dec_codetab + nbitsmask-1;\n                if( free_entp >= &dec_codetab[CSIZE] )\n                {\n                    /* At that point, the next valid states are either EOI or a */\n                    /* CODE_CLEAR. If a regular code is read, at the next */\n                    /* attempt at registering a new entry, we will error out */\n                    /* due to setting free_entp before any valid code */\n                    free_entp = dec_codetab - 1;\n                }\n            }\n            oldcodep = codep;\n            *op++ = (uint8_t)code;\n            occ--;\n            if (occ == 0)\n                goto after_loop;\n            goto begin;\n        }\n\ncode_above_or_equal_to_258:\n        {\n            /*\n             * Add the new entry to the code table.\n             */\n\n            if (codep >= free_entp)\n            {\n                if (codep != free_entp)\n                    goto error_code;\n                free_entp->value = oldcodep->firstchar;\n            }\n            else\n            {\n                free_entp->value = codep->firstchar;\n            }\n            free_entp->repeated = (bool)(oldcodep->repeated & (oldcodep->value == free_entp->value));\n            free_entp->next = oldcodep;\n\n            free_entp->firstchar = oldcodep->firstchar;\n            free_entp->length = oldcodep->length+1;\n            if (++free_entp > maxcodep) {\n                if (++nbits > BITS_MAX)\t\t/* should not happen for a conformant encoder */\n                    nbits = BITS_MAX;\n                nbitsmask = MAXCODE(nbits);\n                maxcodep = dec_codetab + nbitsmask-1;\n                if (free_entp >= &dec_codetab[CSIZE])\n                {\n                    /* At that point, the next valid states are either EOI or a */\n                    /* CODE_CLEAR. If a regular code is read, at the next */\n                    /* attempt at registering a new entry, we will error out */\n                    /* due to setting free_entp before any valid code */\n                    free_entp = dec_codetab - 1;\n                }\n            }\n            oldcodep = codep;\n\n            /*\n             * Code maps to a string, copy string\n             * value to output (written in reverse).\n             */\n            /* tiny bit faster on x86_64 to store in unsigned short than int */\n            unsigned short len = codep->length;\n\n            if (len < 3) /* equivalent to len == 2 given all other conditions */\n            {\n                if (occ <= 2)\n                {\n                    if (occ == 2)\n                    {\n                        memcpy(op, &(codep->firstchar), 2);\n                        op += 2;\n                        occ -= 2;\n                        goto after_loop;\n                    }\n                    goto too_short_buffer;\n                }\n\n                memcpy(op, &(codep->firstchar), 2);\n                op += 2;\n                occ -= 2;\n                goto begin; /* we can save the comparison occ > 0 */\n            }\n\n            if (len == 3)\n            {\n                if (occ <= 3)\n                {\n                    if (occ == 3)\n                    {\n                        op[0] = codep->firstchar;\n                        op[1] = codep->next->value;\n                        op[2] = codep->value;\n                        op += 3;\n                        occ -= 3;\n                        goto after_loop;\n                    }\n                    goto too_short_buffer;\n                }\n\n                op[0] = codep->firstchar;\n                op[1] = codep->next->value;\n                op[2] = codep->value;\n                op += 3;\n                occ -= 3;\n                goto begin; /* we can save the comparison occ > 0 */\n            }\n\n            if (len > occ)\n            {\n                goto too_short_buffer;\n            }\n\n            if (codep->repeated)\n            {\n                memset(op, codep->value, len);\n                op += len;\n                occ -= len;\n                if (occ == 0)\n                    goto after_loop;\n                goto begin;\n            }\n\n            uint8_t* tp = op + len;\n\n            assert(len >= 4);\n\n            *--tp = codep->value;\n            codep = codep->next;\n            *--tp = codep->value;\n            codep = codep->next;\n            *--tp = codep->value;\n            codep = codep->next;\n            *--tp = codep->value;\n            if (tp > op)\n            {\n                 do {\n                    codep = codep->next;\n                    *--tp = codep->value;\n                } while (tp > op);\n            }\n\n            assert(occ >= len);\n            op += len;\n            occ -= len;\n            if (occ == 0)\n                goto after_loop;\n            goto begin;\n        }\n\ncode_clear:\n        {\n            free_entp = dec_codetab + CODE_FIRST;\n            nbits = BITS_MIN;\n            nbitsmask = MAXCODE(BITS_MIN);\n            maxcodep = dec_codetab + nbitsmask-1;\n            do {\n                GetNextCodeLZW();\n            } while (code == CODE_CLEAR);\t/* consecutive CODE_CLEAR codes */\n            if (code == CODE_EOI)\n                goto after_loop;\n            if (code > CODE_EOI) {\n                goto error_code;\n            }\n            *op++ = (uint8_t)code;\n            occ--;\n            oldcodep = dec_codetab + code;\n            if (occ == 0)\n                goto after_loop;\n            goto begin;\n        }\n    }\n\ntoo_short_buffer:\n    {\n        /*\n         * String is too long for decode buffer,\n         * locate portion that will fit, copy to\n         * the decode buffer, and setup restart\n         * logic for the next decoding call.\n         */\n        sp->dec_codep = codep;\n        do {\n            codep = codep->next;\n        } while (codep->length > occ);\n\n        sp->dec_restart = occ;\n        uint8_t* tp = op + occ;\n        do  {\n            *--tp = codep->value;\n            codep = codep->next;\n        }  while (--occ);\n    }\n\nafter_loop:\n\ttif->tif_rawcc -= (tmsize_t)((uint8_t*) bp - tif->tif_rawcp );\n\ttif->tif_rawcp = (uint8_t*) bp;\n\tsp->old_tif_rawcc = tif->tif_rawcc;\n\tsp->dec_bitsleft = dec_bitsleft;\n\tsp->lzw_nbits = (unsigned short) nbits;\n\tsp->lzw_nextdata = nextdata;\n\tsp->lzw_nextbits = nextbits;\n\tsp->dec_nbitsmask = nbitsmask;\n\tsp->dec_oldcodep = oldcodep;\n\tsp->dec_free_entp = free_entp;\n\tsp->dec_maxcodep = maxcodep;\n\n\tif (occ > 0) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\"Not enough data at scanline %\"PRIu32\" (short %\"PRIu64\" bytes)\",\n\t\t\t     tif->tif_row, (uint64_t)occ);\n\t\treturn (0);\n\t}\n\treturn (1);\n\nno_eoi:\n    TIFFErrorExt(tif->tif_clientdata, module,\n                    \"LZWDecode: Strip %\"PRIu32\" not terminated with EOI code\",\n                    tif->tif_curstrip);\n    return 0;\nerror_code:\n    sp->read_error = 1;\n    TIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"Using code not yet in table\");\n    return 0;\n}", "target": 1, "idx": 11469}
{"commit_id": "af74f7db384ed149fe42b21dbd7975f8a54ef227", "project": "DPDK/dpdk", "func": "static int\nvhost_user_get_inflight_fd(struct virtio_net **pdev,\n\t\t\t   struct vhu_msg_context *ctx,\n\t\t\t   int main_fd __rte_unused)\n{\n\tstruct rte_vhost_inflight_info_packed *inflight_packed;\n\tuint64_t pervq_inflight_size, mmap_size;\n\tuint16_t num_queues, queue_size;\n\tstruct virtio_net *dev = *pdev;\n\tint fd, i, j;\n\tint numa_node = SOCKET_ID_ANY;\n\tvoid *addr;\n\n\tif (validate_msg_fds(dev, ctx, 0) != 0)\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\n\tif (ctx->msg.size != sizeof(ctx->msg.payload.inflight)) {\n\t\tVHOST_LOG_CONFIG(ERR, \"(%s) invalid get_inflight_fd message size is %d\\n\",\n\t\t\tdev->ifname, ctx->msg.size);\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t}\n\n\t/*\n\t * If VQ 0 has already been allocated, try to allocate on the same\n\t * NUMA node. It can be reallocated later in numa_realloc().\n\t */\n\tif (dev->nr_vring > 0)\n\t\tnuma_node = dev->virtqueue[0]->numa_node;\n\n\tif (dev->inflight_info == NULL) {\n\t\tdev->inflight_info = rte_zmalloc_socket(\"inflight_info\",\n\t\t\t\tsizeof(struct inflight_mem_info), 0, numa_node);\n\t\tif (!dev->inflight_info) {\n\t\t\tVHOST_LOG_CONFIG(ERR, \"(%s) failed to alloc dev inflight area\\n\",\n\t\t\t\t\tdev->ifname);\n\t\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t\t}\n\t\tdev->inflight_info->fd = -1;\n\t}\n\n\tnum_queues = ctx->msg.payload.inflight.num_queues;\n\tqueue_size = ctx->msg.payload.inflight.queue_size;\n\n\tVHOST_LOG_CONFIG(INFO, \"(%s) get_inflight_fd num_queues: %u\\n\",\n\t\tdev->ifname, ctx->msg.payload.inflight.num_queues);\n\tVHOST_LOG_CONFIG(INFO, \"(%s) get_inflight_fd queue_size: %u\\n\",\n\t\tdev->ifname, ctx->msg.payload.inflight.queue_size);\n\n\tif (vq_is_packed(dev))\n\t\tpervq_inflight_size = get_pervq_shm_size_packed(queue_size);\n\telse\n\t\tpervq_inflight_size = get_pervq_shm_size_split(queue_size);\n\n\tmmap_size = num_queues * pervq_inflight_size;\n\taddr = inflight_mem_alloc(dev, \"vhost-inflight\", mmap_size, &fd);\n\tif (!addr) {\n\t\tVHOST_LOG_CONFIG(ERR, \"(%s) failed to alloc vhost inflight area\\n\", dev->ifname);\n\t\t\tctx->msg.payload.inflight.mmap_size = 0;\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t}\n\tmemset(addr, 0, mmap_size);\n\n\tif (dev->inflight_info->addr) {\n\t\tmunmap(dev->inflight_info->addr, dev->inflight_info->size);\n\t\tdev->inflight_info->addr = NULL;\n\t}\n\n\tif (dev->inflight_info->fd >= 0) {\n\t\tclose(dev->inflight_info->fd);\n\t\tdev->inflight_info->fd = -1;\n\t}\n\n\tdev->inflight_info->addr = addr;\n\tdev->inflight_info->size = ctx->msg.payload.inflight.mmap_size = mmap_size;\n\tdev->inflight_info->fd = ctx->fds[0] = fd;\n\tctx->msg.payload.inflight.mmap_offset = 0;\n\tctx->fd_num = 1;\n\n\tif (vq_is_packed(dev)) {\n\t\tfor (i = 0; i < num_queues; i++) {\n\t\t\tinflight_packed =\n\t\t\t\t(struct rte_vhost_inflight_info_packed *)addr;\n\t\t\tinflight_packed->used_wrap_counter = 1;\n\t\t\tinflight_packed->old_used_wrap_counter = 1;\n\t\t\tfor (j = 0; j < queue_size; j++)\n\t\t\t\tinflight_packed->desc[j].next = j + 1;\n\t\t\taddr = (void *)((char *)addr + pervq_inflight_size);\n\t\t}\n\t}\n\n\tVHOST_LOG_CONFIG(INFO, \"(%s) send inflight mmap_size: %\"PRIu64\"\\n\",\n\t\t\tdev->ifname, ctx->msg.payload.inflight.mmap_size);\n\tVHOST_LOG_CONFIG(INFO, \"(%s) send inflight mmap_offset: %\"PRIu64\"\\n\",\n\t\t\tdev->ifname, ctx->msg.payload.inflight.mmap_offset);\n\tVHOST_LOG_CONFIG(INFO, \"(%s) send inflight fd: %d\\n\", dev->ifname, ctx->fds[0]);\n\n\treturn RTE_VHOST_MSG_RESULT_REPLY;\n}", "target": 1, "idx": 11470}
{"commit_id": "a9f3b3bad17d91e2067fc00d51b0302349570d08", "project": "xen-project/xen", "func": "static int hvm_translate_linear_addr(\n    enum x86_segment seg,\n    unsigned long offset,\n    unsigned int bytes,\n    enum hvm_access_type access_type,\n    struct sh_emulate_ctxt *sh_ctxt,\n    unsigned long *paddr)\n{\n    const struct segment_register *reg;\n    int okay;\n\n    /*\n     * Can arrive here with non-user segments.  However, no such cirucmstance\n     * is part of a legitimate pagetable update, so fail the emulation.\n     */\n    if ( !is_x86_user_segment(seg) )\n        return X86EMUL_UNHANDLEABLE;\n\n    reg = hvm_get_seg_reg(seg, sh_ctxt);\n\n    okay = hvm_virtual_to_linear_addr(\n        seg, reg, offset, bytes, access_type, sh_ctxt->ctxt.addr_size, paddr);\n\n    if ( !okay )\n    {\n        hvm_inject_hw_exception(\n            (seg == x86_seg_ss) ? TRAP_stack_error : TRAP_gp_fault, 0);\n        return X86EMUL_EXCEPTION;\n    }\n\n    return 0;\n}", "target": 1, "idx": 11471}
{"commit_id": "cbddb98484ea8ec1deece351abd56e063d775b38", "project": "the-tcpdump-group/tcpdump", "func": "static void\naodv_extension(netdissect_options *ndo,\n               const struct aodv_ext *ep, u_int length)\n{\n\tconst struct aodv_hello *ah;\n\n\tND_TCHECK(*ep);\n\tswitch (ep->type) {\n\tcase AODV_EXT_HELLO:\n\t\tah = (const struct aodv_hello *)(const void *)ep;\n\t\tND_TCHECK(*ah);\n\t\tif (length < sizeof(struct aodv_hello))\n\t\t\tgoto trunc;\n\t\tif (ep->length < 4) {\n\t\t\tND_PRINT((ndo, \"\\n\\text HELLO - bad length %u\", ep->length));\n\t\t\tbreak;\n\t\t}\n\t\tND_PRINT((ndo, \"\\n\\text HELLO %ld ms\",\n\t\t    (unsigned long)EXTRACT_32BITS(&ah->interval)));\n\t\tbreak;\n\n\tdefault:\n\t\tND_PRINT((ndo, \"\\n\\text %u %u\", ep->type, ep->length));\n\t\tbreak;\n\t}\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \" [|hello]\"));\n}", "target": 3, "idx": 11472}
{"commit_id": "4ab3a086d10eeec1424f2e8a968827a6336203df", "project": "torvalds/linux", "func": "static void asus_kbd_backlight_work(struct work_struct *work)\n{\n\tstruct asus_kbd_leds *led = container_of(work, struct asus_kbd_leds, work);\n\tu8 buf[] = { FEATURE_KBD_REPORT_ID, 0xba, 0xc5, 0xc4, 0x00 };\n\tint ret;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&led->lock, flags);\n\tbuf[4] = led->brightness;\n\tspin_unlock_irqrestore(&led->lock, flags);\n\n\tret = asus_kbd_set_report(led->hdev, buf, sizeof(buf));\n\tif (ret < 0)\n\t\thid_err(led->hdev, \"Asus failed to set keyboard backlight: %d\\n\", ret);\n}", "target": 1, "idx": 11473}
{"commit_id": "b2b4d629f100eaee9f5942a106b1ccefe85b8808", "project": "gost-engine/engine", "func": "static int pkey_gost2018_decrypt(EVP_PKEY_CTX *pctx, unsigned char *key,\n                          size_t *key_len, const unsigned char *in,\n                          size_t in_len)\n{\n    const unsigned char *p = in;\n    struct gost_pmeth_data *data;\n    EVP_PKEY *priv;\n    PSKeyTransport_gost *pst = NULL;\n    int ret = 0;\n    unsigned char expkeys[64];\n    EVP_PKEY *eph_key = NULL;\n    int pkey_nid;\n    int mac_nid = NID_undef;\n    int iv_len = 0;\n\n    if (!(data = EVP_PKEY_CTX_get_data(pctx)) ||\n        !(priv = EVP_PKEY_CTX_get0_pkey(pctx))) {\n       GOSTerr(GOST_F_PKEY_GOST2018_DECRYPT, GOST_R_ERROR_COMPUTING_EXPORT_KEYS);\n       ret = 0;\n       goto err;\n    }\n    pkey_nid = EVP_PKEY_base_id(priv);\n\n    switch (data->cipher_nid) {\n    case NID_magma_ctr:\n        mac_nid = NID_magma_mac;\n        iv_len = 4;\n        break;\n    case NID_grasshopper_ctr:\n        mac_nid = NID_grasshopper_mac;\n        iv_len = 8;\n        break;\n    default:\n        GOSTerr(GOST_F_PKEY_GOST2018_DECRYPT, GOST_R_INVALID_CIPHER);\n        return -1;\n        break;\n    }\n\n    pst = d2i_PSKeyTransport_gost(NULL, (const unsigned char **)&p, in_len);\n    if (!pst) {\n        GOSTerr(GOST_F_PKEY_GOST2018_DECRYPT,\n                GOST_R_ERROR_PARSING_KEY_TRANSPORT_INFO);\n        return -1;\n    }\n\n    eph_key = X509_PUBKEY_get(pst->ephem_key);\n/*\n * TODO beldmit\n   1.  Checks the next three conditions fulfilling and terminates the\n   connection with fatal error if not.\n\n   o  Q_eph is on the same curve as server public key;\n\n   o  Q_eph is not equal to zero point;\n\n   o  q * Q_eph is not equal to zero point.\n*/\n    if (eph_key == NULL) {\n       GOSTerr(GOST_F_PKEY_GOST2018_DECRYPT,\n               GOST_R_ERROR_COMPUTING_EXPORT_KEYS);\n       ret = 0;\n       goto err;\n    }\n\n    if (data->shared_ukm_size == 0 && pst->ukm != NULL) {\n        if (EVP_PKEY_CTX_ctrl(pctx, -1, -1, EVP_PKEY_CTRL_SET_IV,\n        ASN1_STRING_length(pst->ukm), (void *)ASN1_STRING_get0_data(pst->ukm)) < 0) {\n            GOSTerr(GOST_F_PKEY_GOST2018_DECRYPT, GOST_R_UKM_NOT_SET);\n            goto err;\n        }\n    }\n\n    if (gost_keg(data->shared_ukm, pkey_nid,\n                 EC_KEY_get0_public_key(EVP_PKEY_get0(eph_key)),\n                 EVP_PKEY_get0(priv), expkeys) <= 0) {\n        GOSTerr(GOST_F_PKEY_GOST2018_DECRYPT,\n                GOST_R_ERROR_COMPUTING_EXPORT_KEYS);\n        goto err;\n    }\n\n    if (gost_kimp15(ASN1_STRING_get0_data(pst->psexp),\n                    ASN1_STRING_length(pst->psexp), data->cipher_nid,\n                    expkeys + 32, mac_nid, expkeys + 0, data->shared_ukm + 24,\n                    iv_len, key) <= 0) {\n        GOSTerr(GOST_F_PKEY_GOST2018_DECRYPT, GOST_R_CANNOT_UNPACK_EPHEMERAL_KEY);\n        goto err;\n    }\n\n    *key_len = 32;\n    ret = 1;\n err:\n    OPENSSL_cleanse(expkeys, sizeof(expkeys));\n    EVP_PKEY_free(eph_key);\n    PSKeyTransport_gost_free(pst);\n    return ret;\n}", "target": 1, "idx": 11474}
{"commit_id": "c597156adc60a45b5f827793cd420945f47bc03b", "project": "atheme", "func": "static void cs_cmd_flags(sourceinfo_t *si, int parc, char *parv[])\n{\n\tchanacs_t *ca;\n\tmowgli_node_t *n;\n\tchar *channel = parv[0];\n\tchar *target = sstrdup(parv[1]);\n\tchar *flagstr = parv[2];\n\tconst char *str1;\n\tunsigned int addflags, removeflags, restrictflags;\n\thook_channel_acl_req_t req;\n\tmychan_t *mc;\n\n\tif (parc < 1)\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"FLAGS\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: FLAGS <channel> [target] [flags]\"));\n\t\treturn;\n\t}\n\n\tmc = mychan_find(channel);\n\tif (!mc)\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"Channel \\2%s\\2 is not registered.\"), channel);\n\t\treturn;\n\t}\n\n\tif (metadata_find(mc, \"private:close:closer\") && (target || !has_priv(si, PRIV_CHAN_AUSPEX)))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 is closed.\"), channel);\n\t\treturn;\n\t}\n\n\tif (!target || (target && target[0] == '+' && flagstr == NULL))\n\t{\n\t\tunsigned int flags = (target != NULL) ? flags_to_bitmask(target, 0) : 0;\n\n\t\tdo_list(si, mc, flags);\n\t\treturn;\n\t}\n\n\t/*\n\t * following conditions are for compatibility with Anope just to avoid a whole clusterfuck\n\t * of confused users caused by their 'innovation.'  yeah, that's a word for it alright.\n\t *\n\t * anope 1.9's shiny new FLAGS command has:\n\t *\n\t * FLAGS #channel LIST\n\t * FLAGS #channel MODIFY user flagspec\n\t * FLAGS #channel CLEAR\n\t *\n\t * obviously they do not support the atheme syntax, because lets face it, they like to\n\t * 'innovate.'  this is, of course, hilarious for obvious reasons.  never mind that we\n\t * *invented* the FLAGS system for channel ACLs, so you would think they would find it\n\t * worthwhile to be compatible here.  i guess that would have been too obvious or something\n\t * about their whole 'stealing our design' thing that they have been doing in 1.9 since the\n\t * beginning...  or do i mean 'innovating?'\n\t *\n\t * anyway we rewrite the commands as appropriate in the two if blocks below so that they\n\t * are processed by the flags code as the user would intend.  obviously, we're not really\n\t * capable of handling the anope flag model (which makes honestly zero sense to me, and is\n\t * extremely complex which kind of misses the entire point of the flags UI design...) so if\n\t * some user tries passing anope flags, it will probably be hilarious.  the good news is\n\t * most of the anope flags tie up to atheme flags in some weird way anyway (probably because,\n\t * i don't know, they copied the entire design and then fucked it up?  yeah.  probably that.)\n\t *\n\t *   --nenolod\n\t */\n\telse if (anope_flags_compat && !strcasecmp(target, \"LIST\") && myentity_find_ext(target) == NULL)\n\t{\n\t\tdo_list(si, mc, 0);\n\t\tfree(target);\n\n\t\treturn;\n\t}\n\telse if (anope_flags_compat && !strcasecmp(target, \"CLEAR\") && myentity_find_ext(target) == NULL)\n\t{\n\t\tfree(target);\n\n\t\tif (!chanacs_source_has_flag(mc, si, CA_FOUNDER))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, \"You are not authorized to perform this operation.\");\n\t\t\treturn;\n\t\t}\n\n\t\tmowgli_node_t *tn;\n\n\t\tMOWGLI_ITER_FOREACH_SAFE(n, tn, mc->chanacs.head)\n\t\t{\n\t\t\tca = n->data;\n\n\t\t\tif (ca->level & CA_FOUNDER)\n\t\t\t\tcontinue;\n\n\t\t\tobject_unref(ca);\n\t\t}\n\n\t\tlogcommand(si, CMDLOG_DO, \"CLEAR:FLAGS: \\2%s\\2\", mc->name);\n\t\tcommand_success_nodata(si, _(\"Cleared flags in \\2%s\\2.\"), mc->name);\n\t\treturn;\n\t}\n\telse if (anope_flags_compat && !strcasecmp(target, \"MODIFY\") && myentity_find_ext(target) == NULL)\n\t{\n\t\tfree(target);\n\n\t\tif (parc < 3)\n\t\t{\n\t\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"FLAGS\");\n\t\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: FLAGS <#channel> MODIFY [target] <flags>\"));\n\t\t\treturn;\n\t\t}\n\n\t\tflagstr = strchr(parv[2], ' ');\n\t\tif (flagstr)\n\t\t\t*flagstr++ = '\\0';\n\n\t\ttarget = strdup(parv[2]);\n\t}\n\n\t{\n\t\tmyentity_t *mt;\n\n\t\tif (!si->smu)\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not logged in.\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (!flagstr)\n\t\t{\n\t\t\tif (!(mc->flags & MC_PUBACL) && !chanacs_source_has_flag(mc, si, CA_ACLVIEW))\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to execute this command.\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (validhostmask(target))\n\t\t\t\tca = chanacs_find_host_literal(mc, target, 0);\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!(mt = myentity_find_ext(target)))\n\t\t\t\t{\n\t\t\t\t\tcommand_fail(si, fault_nosuch_target, _(\"\\2%s\\2 is not registered.\"), target);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfree(target);\n\t\t\t\ttarget = sstrdup(mt->name);\n\t\t\t\tca = chanacs_find_literal(mc, mt, 0);\n\t\t\t}\n\t\t\tif (ca != NULL)\n\t\t\t{\n\t\t\t\tstr1 = bitmask_to_flags2(ca->level, 0);\n\t\t\t\tcommand_success_string(si, str1, _(\"Flags for \\2%s\\2 in \\2%s\\2 are \\2%s\\2.\"),\n\t\t\t\t\t\ttarget, channel,\n\t\t\t\t\t\tstr1);\n\t\t\t}\n\t\t\telse\n\t\t\t\tcommand_success_string(si, \"\", _(\"No flags for \\2%s\\2 in \\2%s\\2.\"),\n\t\t\t\t\t\ttarget, channel);\n\t\t\tlogcommand(si, CMDLOG_GET, \"FLAGS: \\2%s\\2 on \\2%s\\2\", mc->name, target);\n\t\t\treturn;\n\t\t}\n\n\t\t/* founder may always set flags -- jilles */\n\t\trestrictflags = chanacs_source_flags(mc, si);\n\t\tif (restrictflags & CA_FOUNDER)\n\t\t\trestrictflags = ca_all;\n\t\telse\n\t\t{\n\t\t\tif (!(restrictflags & CA_FLAGS))\n\t\t\t{\n\t\t\t\t/* allow a user to remove their own access\n\t\t\t\t * even without +f */\n\t\t\t\tif (restrictflags & CA_AKICK ||\n\t\t\t\t\t\tsi->smu == NULL ||\n\t\t\t\t\t\tirccasecmp(target, entity(si->smu)->name) ||\n\t\t\t\t\t\tstrcmp(flagstr, \"-*\"))\n\t\t\t\t{\n\t\t\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to execute this command.\"));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (irccasecmp(target, entity(si->smu)->name))\n\t\t\t\trestrictflags = allow_flags(mc, restrictflags);\n\t\t\telse\n\t\t\t\trestrictflags |= allow_flags(mc, restrictflags);\n\t\t}\n\n\t\tif (*flagstr == '+' || *flagstr == '-' || *flagstr == '=')\n\t\t{\n\t\t\tflags_make_bitmasks(flagstr, &addflags, &removeflags);\n\t\t\tif (addflags == 0 && removeflags == 0)\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_badparams, _(\"No valid flags given, use /%s%s HELP FLAGS for a list\"), ircd->uses_rcommand ? \"\" : \"msg \", chansvs.me->disp);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\taddflags = get_template_flags(mc, flagstr);\n\t\t\tif (addflags == 0)\n\t\t\t{\n\t\t\t\t/* Hack -- jilles */\n\t\t\t\tif (*target == '+' || *target == '-' || *target == '=')\n\t\t\t\t\tcommand_fail(si, fault_badparams, _(\"Usage: FLAGS %s [target] [flags]\"), mc->name);\n\t\t\t\telse\n\t\t\t\t\tcommand_fail(si, fault_badparams, _(\"Invalid template name given, use /%s%s TEMPLATE %s for a list\"), ircd->uses_rcommand ? \"\" : \"msg \", chansvs.me->disp, mc->name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tremoveflags = ca_all & ~addflags;\n\t\t}\n\n\t\tif (!validhostmask(target))\n\t\t{\n\t\t\tif (!(mt = myentity_find_ext(target)))\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_nosuch_target, _(\"\\2%s\\2 is not registered.\"), target);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfree(target);\n\t\t\ttarget = sstrdup(mt->name);\n\n\t\t\tca = chanacs_open(mc, mt, NULL, true, entity(si->smu));\n\n\t\t\tif (ca->level & CA_FOUNDER && removeflags & CA_FLAGS && !(removeflags & CA_FOUNDER))\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_noprivs, _(\"You may not remove a founder's +f access.\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (ca->level & CA_FOUNDER && removeflags & CA_FOUNDER && mychan_num_founders(mc) == 1)\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_noprivs, _(\"You may not remove the last founder.\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!(ca->level & CA_FOUNDER) && addflags & CA_FOUNDER)\n\t\t\t{\n\t\t\t\tif (mychan_num_founders(mc) >= chansvs.maxfounders)\n\t\t\t\t{\n\t\t\t\t\tcommand_fail(si, fault_noprivs, _(\"Only %d founders allowed per channel.\"), chansvs.maxfounders);\n\t\t\t\t\tchanacs_close(ca);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!myentity_can_register_channel(mt))\n\t\t\t\t{\n\t\t\t\t\tcommand_fail(si, fault_toomany, _(\"\\2%s\\2 has too many channels registered.\"), mt->name);\n\t\t\t\t\tchanacs_close(ca);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!myentity_allow_foundership(mt))\n\t\t\t\t{\n\t\t\t\t\tcommand_fail(si, fault_toomany, _(\"\\2%s\\2 cannot take foundership of a channel.\"), mt->name);\n\t\t\t\t\tchanacs_close(ca);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (addflags & CA_FOUNDER)\n\t\t\t\taddflags |= CA_FLAGS, removeflags &= ~CA_FLAGS;\n\n\t\t\t/* If NEVEROP is set, don't allow adding new entries\n\t\t\t * except sole +b. Adding flags if the current level\n\t\t\t * is +b counts as adding an entry.\n\t\t\t * -- jilles */\n\t\t\t/* XXX: not all entities are users */\n\t\t\tif (isuser(mt) && (MU_NEVEROP & user(mt)->flags && addflags != CA_AKICK && addflags != 0 && (ca->level == 0 || ca->level == CA_AKICK)))\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 does not wish to be added to channel access lists (NEVEROP set).\"), mt->name);\n\t\t\t\tchanacs_close(ca);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (ca->level == 0 && chanacs_is_table_full(ca))\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_toomany, _(\"Channel %s access list is full.\"), mc->name);\n\t\t\t\tchanacs_close(ca);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treq.ca = ca;\n\t\t\treq.oldlevel = ca->level;\n\n\t\t\tif (!chanacs_modify(ca, &addflags, &removeflags, restrictflags))\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not allowed to set \\2%s\\2 on \\2%s\\2 in \\2%s\\2.\"), bitmask_to_flags2(addflags, removeflags), mt->name, mc->name);\n\t\t\t\tchanacs_close(ca);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treq.newlevel = ca->level;\n\n\t\t\thook_call_channel_acl_change(&req);\n\t\t\tchanacs_close(ca);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (addflags & CA_FOUNDER)\n\t\t\t{\n\t\t                command_fail(si, fault_badparams, _(\"You may not set founder status on a hostmask.\"));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tca = chanacs_open(mc, NULL, target, true, entity(si->smu));\n\t\t\tif (ca->level == 0 && chanacs_is_table_full(ca))\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_toomany, _(\"Channel %s access list is full.\"), mc->name);\n\t\t\t\tchanacs_close(ca);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treq.ca = ca;\n\t\t\treq.oldlevel = ca->level;\n\n\t\t\tif (!chanacs_modify(ca, &addflags, &removeflags, restrictflags))\n\t\t\t{\n\t\t                command_fail(si, fault_noprivs, _(\"You are not allowed to set \\2%s\\2 on \\2%s\\2 in \\2%s\\2.\"), bitmask_to_flags2(addflags, removeflags), target, mc->name);\n\t\t\t\tchanacs_close(ca);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treq.newlevel = ca->level;\n\n\t\t\thook_call_channel_acl_change(&req);\n\t\t\tchanacs_close(ca);\n\t\t}\n\n\t\tif ((addflags | removeflags) == 0)\n\t\t{\n\t\t\tcommand_fail(si, fault_nochange, _(\"Channel access to \\2%s\\2 for \\2%s\\2 unchanged.\"), channel, target);\n\t\t\treturn;\n\t\t}\n\t\tflagstr = bitmask_to_flags2(addflags, removeflags);\n\t\tcommand_success_nodata(si, _(\"Flags \\2%s\\2 were set on \\2%s\\2 in \\2%s\\2.\"), flagstr, target, channel);\n\t\tlogcommand(si, CMDLOG_SET, \"FLAGS: \\2%s\\2 \\2%s\\2 \\2%s\\2\", mc->name, target, flagstr);\n\t\tverbose(mc, \"\\2%s\\2 set flags \\2%s\\2 on \\2%s\\2\", get_source_name(si), flagstr, target);\n\t}\n\n\tfree(target);\n}", "target": 2, "idx": 11475}
{"commit_id": "d919b2744cd05abae043490f0a3dd1946c1ccb8c", "project": "open5gs", "func": "static int on_part_data(\n        multipart_parser *parser, const char *at, size_t length)\n{\n    multipart_parser_data_t *data = NULL;\n\n    ogs_assert(parser);\n    data = multipart_parser_get_data(parser);\n    ogs_assert(data);\n\n    if (data->num_of_part < OGS_SBI_MAX_NUM_OF_PART && at && length) {\n        SWITCH(data->part[data->num_of_part].content_type)\n        CASE(OGS_SBI_CONTENT_JSON_TYPE)\n        CASE(OGS_SBI_CONTENT_5GNAS_TYPE)\n        CASE(OGS_SBI_CONTENT_NGAP_TYPE)\n            size_t offset = 0;\n\n            if (data->part[data->num_of_part].content == NULL) {\n                data->part[data->num_of_part].content_length = length;\n                data->part[data->num_of_part].content =\n                    (char *)ogs_malloc(length + 1);\n                ogs_assert(data->part[data->num_of_part].content);\n            } else {\n                offset = data->part[data->num_of_part].content_length;\n                if ((data->part[data->num_of_part].content_length + length) >\n                        OGS_HUGE_LEN) {\n                    ogs_error(\"Overflow length [%d:%d]\",\n                        (int)data->part[data->num_of_part].content_length,\n                        (int)length);\n                    ogs_assert_if_reached();\n                    return 0;\n                }\n                data->part[data->num_of_part].content_length += length;\n                data->part[data->num_of_part].content = (char *)ogs_realloc(\n                    data->part[data->num_of_part].content,\n                    data->part[data->num_of_part].content_length + 1);\n                ogs_assert(data->part[data->num_of_part].content);\n            }\n            memcpy(data->part[data->num_of_part].content + offset, at, length);\n            data->part[data->num_of_part].content[\n                data->part[data->num_of_part].content_length] = 0;\n            break;\n\n        DEFAULT\n            ogs_error(\"Unknown content_type [%s]\",\n                    data->part[data->num_of_part].content_type);\n            ogs_log_hexdump(OGS_LOG_ERROR, (unsigned char *)at, length);\n        END\n    }\n    return 0;\n}", "target": 2, "idx": 11476}
{"commit_id": "dfd0743f1d9ea76931510ed150334d571fbab49d", "project": "torvalds/linux", "func": "static void tee_shm_release(struct tee_device *teedev, struct tee_shm *shm)\n{\n\tif (shm->flags & TEE_SHM_POOL) {\n\t\tstruct tee_shm_pool_mgr *poolm;\n\n\t\tif (shm->flags & TEE_SHM_DMA_BUF)\n\t\t\tpoolm = teedev->pool->dma_buf_mgr;\n\t\telse\n\t\t\tpoolm = teedev->pool->private_mgr;\n\n\t\tpoolm->ops->free(poolm, shm);\n\t} else if (shm->flags & TEE_SHM_REGISTER) {\n\t\tint rc = teedev->desc->ops->shm_unregister(shm->ctx, shm);\n\n\t\tif (rc)\n\t\t\tdev_err(teedev->dev.parent,\n\t\t\t\t\"unregister shm %p failed: %d\", shm, rc);\n\n\t\trelease_registered_pages(shm);\n\t}\n\n\tteedev_ctx_put(shm->ctx);\n\n\tkfree(shm);\n\n\ttee_device_put(teedev);\n}", "target": 2, "idx": 11477}
{"commit_id": "197c949e7798fbf28cfadc69d9ca0c2abbf93191", "project": "torvalds/linux", "func": "int udp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len, int noblock,\n\t\tint flags, int *addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_in *, sin, msg->msg_name);\n\tstruct sk_buff *skb;\n\tunsigned int ulen, copied;\n\tint peeked, off = 0;\n\tint err;\n\tint is_udplite = IS_UDPLITE(sk);\n\tbool checksum_valid = false;\n\tbool slow;\n\n\tif (flags & MSG_ERRQUEUE)\n\t\treturn ip_recv_error(sk, msg, len, addr_len);\n\ntry_again:\n\tskb = __skb_recv_datagram(sk, flags | (noblock ? MSG_DONTWAIT : 0),\n\t\t\t\t  &peeked, &off, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tulen = skb->len - sizeof(struct udphdr);\n\tcopied = len;\n\tif (copied > ulen)\n\t\tcopied = ulen;\n\telse if (copied < ulen)\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\n\t/*\n\t * If checksum is needed at all, try to do it while copying the\n\t * data.  If the data is truncated, or if we only want a partial\n\t * coverage checksum (UDP-Lite), do it before the copy.\n\t */\n\n\tif (copied < ulen || UDP_SKB_CB(skb)->partial_cov) {\n\t\tchecksum_valid = !udp_lib_checksum_complete(skb);\n\t\tif (!checksum_valid)\n\t\t\tgoto csum_copy_err;\n\t}\n\n\tif (checksum_valid || skb_csum_unnecessary(skb))\n\t\terr = skb_copy_datagram_msg(skb, sizeof(struct udphdr),\n\t\t\t\t\t    msg, copied);\n\telse {\n\t\terr = skb_copy_and_csum_datagram_msg(skb, sizeof(struct udphdr),\n\t\t\t\t\t\t     msg);\n\n\t\tif (err == -EINVAL)\n\t\t\tgoto csum_copy_err;\n\t}\n\n\tif (unlikely(err)) {\n\t\ttrace_kfree_skb(skb, udp_recvmsg);\n\t\tif (!peeked) {\n\t\t\tatomic_inc(&sk->sk_drops);\n\t\t\tUDP_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\t   UDP_MIB_INERRORS, is_udplite);\n\t\t}\n\t\tgoto out_free;\n\t}\n\n\tif (!peeked)\n\t\tUDP_INC_STATS_USER(sock_net(sk),\n\t\t\t\tUDP_MIB_INDATAGRAMS, is_udplite);\n\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\t/* Copy the address. */\n\tif (sin) {\n\t\tsin->sin_family = AF_INET;\n\t\tsin->sin_port = udp_hdr(skb)->source;\n\t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n\t\tmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t\t*addr_len = sizeof(*sin);\n\t}\n\tif (inet->cmsg_flags)\n\t\tip_cmsg_recv_offset(msg, skb, sizeof(struct udphdr));\n\n\terr = copied;\n\tif (flags & MSG_TRUNC)\n\t\terr = ulen;\n\nout_free:\n\tskb_free_datagram_locked(sk, skb);\nout:\n\treturn err;\n\ncsum_copy_err:\n\tslow = lock_sock_fast(sk);\n\tif (!skb_kill_datagram(sk, skb, flags)) {\n\t\tUDP_INC_STATS_USER(sock_net(sk), UDP_MIB_CSUMERRORS, is_udplite);\n\t\tUDP_INC_STATS_USER(sock_net(sk), UDP_MIB_INERRORS, is_udplite);\n\t}\n\tunlock_sock_fast(sk, slow);\n\n\t/* starting over for a new packet, but check if we need to yield */\n\tcond_resched();\n\tmsg->msg_flags &= ~MSG_TRUNC;\n\tgoto try_again;\n}", "target": 3, "idx": 11478}
{"commit_id": "363b02dab09b3226f3bd1420dad9c72b79a42a76", "project": "torvalds/linux", "func": "static int trusted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct trusted_key_payload *p;\n\tstruct trusted_key_payload *new_p;\n\tstruct trusted_key_options *new_o;\n\tsize_t datalen = prep->datalen;\n\tchar *datablob;\n\tint ret = 0;\n\n\tif (key_is_negative(key))\n\t\treturn -ENOKEY;\n\tp = key->payload.data[0];\n\tif (!p->migratable)\n\t\treturn -EPERM;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tdatablob = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!datablob)\n\t\treturn -ENOMEM;\n\tnew_o = trusted_options_alloc();\n\tif (!new_o) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tnew_p = trusted_payload_alloc(key);\n\tif (!new_p) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmemcpy(datablob, prep->data, datalen);\n\tdatablob[datalen] = '\\0';\n\tret = datablob_parse(datablob, new_p, new_o);\n\tif (ret != Opt_update) {\n\t\tret = -EINVAL;\n\t\tkzfree(new_p);\n\t\tgoto out;\n\t}\n\n\tif (!new_o->keyhandle) {\n\t\tret = -EINVAL;\n\t\tkzfree(new_p);\n\t\tgoto out;\n\t}\n\n\t/* copy old key values, and reseal with new pcrs */\n\tnew_p->migratable = p->migratable;\n\tnew_p->key_len = p->key_len;\n\tmemcpy(new_p->key, p->key, p->key_len);\n\tdump_payload(p);\n\tdump_payload(new_p);\n\n\tret = key_seal(new_p, new_o);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: key_seal failed (%d)\\n\", ret);\n\t\tkzfree(new_p);\n\t\tgoto out;\n\t}\n\tif (new_o->pcrlock) {\n\t\tret = pcrlock(new_o->pcrlock);\n\t\tif (ret < 0) {\n\t\t\tpr_info(\"trusted_key: pcrlock failed (%d)\\n\", ret);\n\t\t\tkzfree(new_p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\trcu_assign_keypointer(key, new_p);\n\tcall_rcu(&p->rcu, trusted_rcu_free);\nout:\n\tkzfree(datablob);\n\tkzfree(new_o);\n\treturn ret;\n}", "target": 2, "idx": 11479}
{"commit_id": "aebe9f4639b13a1f4e9a6b42cdd2e38c617b442d", "project": "kernel/git/wireless/wireless", "func": "static void\ncfg80211_update_notlisted_nontrans(struct wiphy *wiphy,\n\t\t\t\t   struct cfg80211_bss *nontrans_bss,\n\t\t\t\t   struct ieee80211_mgmt *mgmt, size_t len)\n{\n\tu8 *ie, *new_ie, *pos;\n\tconst struct element *nontrans_ssid;\n\tconst u8 *trans_ssid, *mbssid;\n\tsize_t ielen = len - offsetof(struct ieee80211_mgmt,\n\t\t\t\t      u.probe_resp.variable);\n\tsize_t new_ie_len;\n\tstruct cfg80211_bss_ies *new_ies;\n\tconst struct cfg80211_bss_ies *old;\n\tsize_t cpy_len;\n\n\tlockdep_assert_held(&wiphy_to_rdev(wiphy)->bss_lock);\n\n\tie = mgmt->u.probe_resp.variable;\n\n\tnew_ie_len = ielen;\n\ttrans_ssid = cfg80211_find_ie(WLAN_EID_SSID, ie, ielen);\n\tif (!trans_ssid)\n\t\treturn;\n\tnew_ie_len -= trans_ssid[1];\n\tmbssid = cfg80211_find_ie(WLAN_EID_MULTIPLE_BSSID, ie, ielen);\n\t/*\n\t * It's not valid to have the MBSSID element before SSID\n\t * ignore if that happens - the code below assumes it is\n\t * after (while copying things inbetween).\n\t */\n\tif (!mbssid || mbssid < trans_ssid)\n\t\treturn;\n\tnew_ie_len -= mbssid[1];\n\n\tnontrans_ssid = ieee80211_bss_get_elem(nontrans_bss, WLAN_EID_SSID);\n\tif (!nontrans_ssid)\n\t\treturn;\n\n\tnew_ie_len += nontrans_ssid->datalen;\n\n\t/* generate new ie for nontrans BSS\n\t * 1. replace SSID with nontrans BSS' SSID\n\t * 2. skip MBSSID IE\n\t */\n\tnew_ie = kzalloc(new_ie_len, GFP_ATOMIC);\n\tif (!new_ie)\n\t\treturn;\n\n\tnew_ies = kzalloc(sizeof(*new_ies) + new_ie_len, GFP_ATOMIC);\n\tif (!new_ies)\n\t\tgoto out_free;\n\n\tpos = new_ie;\n\n\t/* copy the nontransmitted SSID */\n\tcpy_len = nontrans_ssid->datalen + 2;\n\tmemcpy(pos, nontrans_ssid, cpy_len);\n\tpos += cpy_len;\n\t/* copy the IEs between SSID and MBSSID */\n\tcpy_len = trans_ssid[1] + 2;\n\tmemcpy(pos, (trans_ssid + cpy_len), (mbssid - (trans_ssid + cpy_len)));\n\tpos += (mbssid - (trans_ssid + cpy_len));\n\t/* copy the IEs after MBSSID */\n\tcpy_len = mbssid[1] + 2;\n\tmemcpy(pos, mbssid + cpy_len, ((ie + ielen) - (mbssid + cpy_len)));\n\n\t/* update ie */\n\tnew_ies->len = new_ie_len;\n\tnew_ies->tsf = le64_to_cpu(mgmt->u.probe_resp.timestamp);\n\tnew_ies->from_beacon = ieee80211_is_beacon(mgmt->frame_control);\n\tmemcpy(new_ies->data, new_ie, new_ie_len);\n\tif (ieee80211_is_probe_resp(mgmt->frame_control)) {\n\t\told = rcu_access_pointer(nontrans_bss->proberesp_ies);\n\t\trcu_assign_pointer(nontrans_bss->proberesp_ies, new_ies);\n\t\trcu_assign_pointer(nontrans_bss->ies, new_ies);\n\t\tif (old)\n\t\t\tkfree_rcu((struct cfg80211_bss_ies *)old, rcu_head);\n\t} else {\n\t\told = rcu_access_pointer(nontrans_bss->beacon_ies);\n\t\trcu_assign_pointer(nontrans_bss->beacon_ies, new_ies);\n\t\trcu_assign_pointer(nontrans_bss->ies, new_ies);\n\t\tif (old)\n\t\t\tkfree_rcu((struct cfg80211_bss_ies *)old, rcu_head);\n\t}\n\nout_free:\n\tkfree(new_ie);\n}", "target": 2, "idx": 11480}
{"commit_id": "3db1af1f370295ad5355b8f64b865a2a357bcac0", "project": "libgit2", "func": "static int read_entry(\n\tgit_index_entry **out,\n\tsize_t *out_size,\n\tgit_index *index,\n\tconst void *buffer,\n\tsize_t buffer_size,\n\tconst char *last)\n{\n\tsize_t path_length, entry_size;\n\tconst char *path_ptr;\n\tstruct entry_short source;\n\tgit_index_entry entry = {{0}};\n\tbool compressed = index->version >= INDEX_VERSION_NUMBER_COMP;\n\tchar *tmp_path = NULL;\n\n\tif (INDEX_FOOTER_SIZE + minimal_entry_size > buffer_size)\n\t\treturn -1;\n\n\t/* buffer is not guaranteed to be aligned */\n\tmemcpy(&source, buffer, sizeof(struct entry_short));\n\n\tentry.ctime.seconds = (git_time_t)ntohl(source.ctime.seconds);\n\tentry.ctime.nanoseconds = ntohl(source.ctime.nanoseconds);\n\tentry.mtime.seconds = (git_time_t)ntohl(source.mtime.seconds);\n\tentry.mtime.nanoseconds = ntohl(source.mtime.nanoseconds);\n\tentry.dev = ntohl(source.dev);\n\tentry.ino = ntohl(source.ino);\n\tentry.mode = ntohl(source.mode);\n\tentry.uid = ntohl(source.uid);\n\tentry.gid = ntohl(source.gid);\n\tentry.file_size = ntohl(source.file_size);\n\tgit_oid_cpy(&entry.id, &source.oid);\n\tentry.flags = ntohs(source.flags);\n\n\tif (entry.flags & GIT_IDXENTRY_EXTENDED) {\n\t\tuint16_t flags_raw;\n\t\tsize_t flags_offset;\n\n\t\tflags_offset = offsetof(struct entry_long, flags_extended);\n\t\tmemcpy(&flags_raw, (const char *) buffer + flags_offset,\n\t\t\tsizeof(flags_raw));\n\t\tflags_raw = ntohs(flags_raw);\n\n\t\tmemcpy(&entry.flags_extended, &flags_raw, sizeof(flags_raw));\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_long, path);\n\t} else\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_short, path);\n\n\tif (!compressed) {\n\t\tpath_length = entry.flags & GIT_IDXENTRY_NAMEMASK;\n\n\t\t/* if this is a very long string, we must find its\n\t\t * real length without overflowing */\n\t\tif (path_length == 0xFFF) {\n\t\t\tconst char *path_end;\n\n\t\t\tpath_end = memchr(path_ptr, '\\0', buffer_size);\n\t\t\tif (path_end == NULL)\n\t\t\t\treturn -1;\n\n\t\t\tpath_length = path_end - path_ptr;\n\t\t}\n\n\t\tentry_size = index_entry_size(path_length, 0, entry.flags);\n\t\tentry.path = (char *)path_ptr;\n\t} else {\n\t\tsize_t varint_len, last_len, prefix_len, suffix_len, path_len;\n\t\tuintmax_t strip_len;\n\n\t\tstrip_len = git_decode_varint((const unsigned char *)path_ptr, &varint_len);\n\t\tlast_len = strlen(last);\n\n\t\tif (varint_len == 0 || last_len < strip_len)\n\t\t\treturn index_error_invalid(\"incorrect prefix length\");\n\n\t\tprefix_len = last_len - strip_len;\n\t\tsuffix_len = strlen(path_ptr + varint_len);\n\n\t\tGITERR_CHECK_ALLOC_ADD(&path_len, prefix_len, suffix_len);\n\t\tGITERR_CHECK_ALLOC_ADD(&path_len, path_len, 1);\n\n\t\tif (path_len > GIT_PATH_MAX)\n\t\t\treturn index_error_invalid(\"unreasonable path length\");\n\n\t\ttmp_path = git__malloc(path_len);\n\t\tGITERR_CHECK_ALLOC(tmp_path);\n\n\t\tmemcpy(tmp_path, last, prefix_len);\n\t\tmemcpy(tmp_path + prefix_len, path_ptr + varint_len, suffix_len + 1);\n\t\tentry_size = index_entry_size(suffix_len, varint_len, entry.flags);\n\t\tentry.path = tmp_path;\n\t}\n\n\tif (entry_size == 0)\n\t\treturn -1;\n\n\tif (INDEX_FOOTER_SIZE + entry_size > buffer_size)\n\t\treturn -1;\n\n\tif (index_entry_dup(out, index, &entry) < 0) {\n\t\tgit__free(tmp_path);\n\t\treturn -1;\n\t}\n\n\tgit__free(tmp_path);\n\t*out_size = entry_size;\n\treturn 0;\n}", "target": 1, "idx": 11481}
{"commit_id": "5d2e73a5f80a5b5aff3caf1ec6d39b5b3f54b26e", "project": "torvalds/linux", "func": "static int zr364xx_vidioc_querycap(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_capability *cap)\n{\n\tstruct zr364xx_camera *cam = video_drvdata(file);\n\n\tstrscpy(cap->driver, DRIVER_DESC, sizeof(cap->driver));\n\tif (cam->udev->product)\n\t\tstrscpy(cap->card, cam->udev->product, sizeof(cap->card));\n\tstrscpy(cap->bus_info, dev_name(&cam->udev->dev),\n\t\tsizeof(cap->bus_info));\n\tcap->device_caps = V4L2_CAP_VIDEO_CAPTURE |\n\t\t\t    V4L2_CAP_READWRITE |\n\t\t\t    V4L2_CAP_STREAMING;\n\tcap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\n\n\treturn 0;\n}", "target": 1, "idx": 11482}
{"commit_id": "effaf5a240e03020f4ae953e10b764622c3e87cc", "project": "qemu-project/qemu", "func": "static int xhci_ring_chain_length(XHCIState *xhci, const XHCIRing *ring)\n{\n    XHCITRB trb;\n    int length = 0;\n    dma_addr_t dequeue = ring->dequeue;\n    bool ccs = ring->ccs;\n    /* hack to bundle together the two/three TDs that make a setup transfer */\n    bool control_td_set = 0;\n    uint32_t link_cnt = 0;\n\n    do {\n        TRBType type;\n        if (dma_memory_read(xhci->as, dequeue, &trb, TRB_SIZE,\n                        MEMTXATTRS_UNSPECIFIED) != MEMTX_OK) {\n            qemu_log_mask(LOG_GUEST_ERROR, \"%s: DMA memory access failed!\\n\",\n                          __func__);\n            return -1;\n        }\n        le64_to_cpus(&trb.parameter);\n        le32_to_cpus(&trb.status);\n        le32_to_cpus(&trb.control);\n\n        if ((trb.control & TRB_C) != ccs) {\n            return -length;\n        }\n\n        type = TRB_TYPE(trb);\n\n        if (type == TR_LINK) {\n            if (++link_cnt > TRB_LINK_LIMIT) {\n                return -length;\n            }\n            dequeue = xhci_mask64(trb.parameter);\n            if (trb.control & TRB_LK_TC) {\n                ccs = !ccs;\n            }\n            continue;\n        }\n\n        length += 1;\n        dequeue += TRB_SIZE;\n\n        if (type == TR_SETUP) {\n            control_td_set = 1;\n        } else if (type == TR_STATUS) {\n            control_td_set = 0;\n        }\n\n        if (!control_td_set && !(trb.control & TRB_TR_CH)) {\n            return length;\n        }\n\n        /*\n         * According to the xHCI spec, Transfer Ring segments should have\n         * a maximum size of 64 kB (see chapter \"6 Data Structures\")\n         */\n    } while (length < TRB_LINK_LIMIT * 65536 / TRB_SIZE);\n\n    qemu_log_mask(LOG_GUEST_ERROR, \"%s: exceeded maximum tranfer ring size!\\n\",\n                          __func__);\n\n    return -1;\n}", "target": 0, "idx": 11483}
{"commit_id": "f0c505a3e5d47989a5f69be2d0d4f250af6b1a6c", "project": "LibRaw", "func": "static void x3f_load_property_list(x3f_info_t *I, x3f_directory_entry_t *DE)\n{\n\tx3f_directory_entry_header_t *DEH = &DE->header;\n\tx3f_property_list_t *PL = &DEH->data_subsection.property_list;\n\tint i;\n\n\tread_data_set_offset(I, DE, X3F_PROPERTY_LIST_HEADER_SIZE);\n\n\tGET_PROPERTY_TABLE(PL->property_table, PL->num_properties);\n\n\tif (!PL->data_size)\n\t\tPL->data_size = read_data_block(&PL->data, I, DE, 0);\n\tuint32_t maxoffset = PL->data_size/sizeof(utf16_t)-2; // at least 2 chars, value + terminating 0x0000\n\n\tfor (i=0; i<PL->num_properties; i++) {\n\t\tx3f_property_t *P = &PL->property_table.element[i];\n\t\tif(P->name_offset > maxoffset || P->value_offset > maxoffset)\n\t\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n\t\tP->name = ((utf16_t *)PL->data + P->name_offset);\n\t\tP->value = ((utf16_t *)PL->data + P->value_offset);\n\t}\n}", "target": 2, "idx": 11484}
{"commit_id": "0da8b8b801f9276359262f1ef8274c7812d3dfda", "project": "php/php-src", "func": "static entity_table_opt determine_entity_table(int all, int doctype)\n{\n\tentity_table_opt retval = {NULL};\n\n\tassert(!(doctype == ENT_HTML_DOC_XML1 && all));\n\n\tif (all) {\n\t\tretval.ms_table = (doctype == ENT_HTML_DOC_HTML5) ?\n\t\t\tentity_ms_table_html5 : entity_ms_table_html4;\n\t} else {\n\t\tretval.table = (doctype == ENT_HTML_DOC_HTML401) ?\n\t\t\tstage3_table_be_noapos_00000 : stage3_table_be_apos_00000;\n\t}\n\treturn retval;\n}", "target": 2, "idx": 11485}
{"commit_id": "785d67a78a1d533759fcd2f5e8d6ef778de849e0", "project": "tensorflow", "func": "void Compute(OpKernelContext* ctx) override {\n    const Tensor& input = ctx->input(0);\n\n    const Tensor& input_min = ctx->input(1);\n    const Tensor& input_max = ctx->input(2);\n    const Tensor& requested_output_min = ctx->input(3);\n    const Tensor& requested_output_max = ctx->input(4);\n    OP_REQUIRES(\n        ctx, TensorShapeUtils::IsScalar(input_min.shape()),\n        errors::InvalidArgument(\"`input_min` must be rank 0 but is rank \",\n                                input_min.dims()));\n    OP_REQUIRES(\n        ctx, TensorShapeUtils::IsScalar(input_max.shape()),\n        errors::InvalidArgument(\"`input_max` must be rank 0 but is rank \",\n                                input_max.dims()));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(requested_output_min.shape()),\n                errors::InvalidArgument(\n                    \"`requested_output_min` must be rank 0 but is rank \",\n                    requested_output_min.dims()));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(requested_output_max.shape()),\n                errors::InvalidArgument(\n                    \"`requested_output_max` must be rank 0 but is rank \",\n                    requested_output_max.dims()));\n\n    const float input_min_float = input_min.flat<float>()(0);\n    const float input_max_float = input_max.flat<float>()(0);\n    const float requested_output_min_float =\n        requested_output_min.flat<float>()(0);\n    const float requested_output_max_float =\n        requested_output_max.flat<float>()(0);\n\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, input.shape(), &output));\n    Tensor* output_min = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(1, TensorShape({}), &output_min));\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(2, TensorShape({}), &output_max));\n\n    OP_REQUIRES(\n        ctx, requested_output_min_float <= 0.0f,\n        errors::InvalidArgument(\"requested_output_min must be <= 0, but got \",\n                                requested_output_min_float));\n    OP_REQUIRES(\n        ctx, requested_output_max_float >= requested_output_min_float,\n        errors::InvalidArgument(\n            \"requested_output_max must be >= requested_output_min, but got \",\n            requested_output_max_float, \" and \", requested_output_min_float));\n\n    auto input_array = input.flat<T1>();\n\n#if 0\n    // This is the reference, non-eigen implementation:\n    auto output_array = output->flat<T2>();\n    RequantizeManyInNewRange<T1, T2>(\n        input_array.data(), input_array.size(),\n        input_min_float, input_max_float,\n        requested_output_min_float, requested_output_max_float,\n        output_array.data());\n#endif\n\n    if (input_array.size() > 0) {\n      if (meta::IsSupportedAndEnabled() && std::is_same<T1, qint32>() &&\n          std::is_same<T2, quint8>()) {\n        auto input_i32_array = input.flat<qint32>();\n        meta::Requantize(ctx, input_i32_array.data(), input_i32_array.size(),\n                         input_min_float, input_max_float,\n                         requested_output_min_float, requested_output_max_float,\n                         output->flat<quint8>().data());\n      } else {\n        RequantizeManyInNewRangeUsingEigen<T1, T2>(\n            ctx->eigen_device<CPUDevice>(), input, input_min_float,\n            input_max_float, requested_output_min_float,\n            requested_output_max_float, output);\n      }\n    }\n\n    output_min->flat<float>().setConstant(requested_output_min_float);\n    output_max->flat<float>().setConstant(requested_output_max_float);\n  }", "target": 1, "idx": 11486}
{"commit_id": "51cdb67ff7c5f1242ac58c5aa603ceaf1793b788", "project": "gpac", "func": "static s32 gf_avc_read_sps_bs_internal(GF_BitStream *bs, AVCState *avc, u32 subseq_sps, u32 *vui_flag_pos, u32 nal_hdr)\n{\n\tAVC_SPS *sps;\n\ts32 mb_width, mb_height, sps_id = -1;\n\tu32 profile_idc, level_idc, pcomp, i, chroma_format_idc, cl = 0, cr = 0, ct = 0, cb = 0, luma_bd, chroma_bd;\n\tu8 separate_colour_plane_flag = 0;\n\n\tif (!vui_flag_pos) {\n\t\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\t}\n\n\tif (!bs) {\n\t\treturn -1;\n\t}\n\n\tif (!nal_hdr) {\n\t\tgf_bs_read_int_log(bs, 1, \"forbidden_zero_bit\");\n\t\tgf_bs_read_int_log(bs, 2, \"nal_ref_idc\");\n\t\tgf_bs_read_int_log(bs, 5, \"nal_unit_type\");\n\t}\n\tprofile_idc = gf_bs_read_int_log(bs, 8, \"profile_idc\");\n\n\tpcomp = gf_bs_read_int_log(bs, 8, \"profile_compatibility\");\n\t/*sanity checks*/\n\tif (pcomp & 0x3)\n\t\treturn -1;\n\n\tlevel_idc = gf_bs_read_int_log(bs, 8, \"level_idc\");\n\n\t/*SubsetSps is used to be sure that AVC SPS are not going to be scratched\n\tby subset SPS. According to the SVC standard, subset SPS can have the same sps_id\n\tthan its base layer, but it does not refer to the same SPS. */\n\tsps_id = gf_bs_read_ue_log(bs, \"sps_id\") + GF_SVC_SSPS_ID_SHIFT * subseq_sps;\n\tif ((sps_id < 0) || (sps_id >= 32)) {\n\t\treturn -1;\n\t}\n\n\tluma_bd = chroma_bd = 0;\n\tsps = &avc->sps[sps_id];\n\tchroma_format_idc = sps->ChromaArrayType = 1;\n\tsps->state |= subseq_sps ? AVC_SUBSPS_PARSED : AVC_SPS_PARSED;\n\n\t/*High Profile and SVC*/\n\tswitch (profile_idc) {\n\tcase 100:\n\tcase 110:\n\tcase 122:\n\tcase 244:\n\tcase 44:\n\t\t/*sanity checks: note1 from 7.4.2.1.1 of iso/iec 14496-10-N11084*/\n\t\tif (pcomp & 0xE0)\n\t\t\treturn -1;\n\tcase 83:\n\tcase 86:\n\tcase 118:\n\tcase 128:\n\t\tchroma_format_idc = gf_bs_read_ue_log(bs, \"chroma_format_idc\");\n\t\tsps->ChromaArrayType = chroma_format_idc;\n\t\tif (chroma_format_idc == 3) {\n\t\t\tseparate_colour_plane_flag = gf_bs_read_int_log(bs, 1, \"separate_colour_plane_flag\");\n\t\t\t/*\n\t\t\tDepending on the value of separate_colour_plane_flag, the value of the variable ChromaArrayType is assigned as follows.\n\t\t\t\\96\tIf separate_colour_plane_flag is equal to 0, ChromaArrayType is set equal to chroma_format_idc.\n\t\t\t\\96\tOtherwise (separate_colour_plane_flag is equal to 1), ChromaArrayType is set equal to 0.\n\t\t\t*/\n\t\t\tif (separate_colour_plane_flag) sps->ChromaArrayType = 0;\n\t\t}\n\t\tluma_bd = gf_bs_read_ue_log(bs, \"luma_bit_depth\");\n\t\tchroma_bd = gf_bs_read_ue_log(bs, \"chroma_bit_depth\");\n\t\t/*qpprime_y_zero_transform_bypass_flag = */ gf_bs_read_int_log(bs, 1, \"qpprime_y_zero_transform_bypass_flag\");\n\t\t/*seq_scaling_matrix_present_flag*/\n\t\tif (gf_bs_read_int_log(bs, 1, \"seq_scaling_matrix_present_flag\")) {\n\t\t\tu32 k;\n\t\t\tfor (k = 0; k < 8; k++) {\n\t\t\t\tif (gf_bs_read_int_log_idx(bs, 1, \"seq_scaling_list_present_flag\", k)) {\n\t\t\t\t\tu32 z, last = 8, next = 8;\n\t\t\t\t\tu32 sl = k < 6 ? 16 : 64;\n\t\t\t\t\tfor (z = 0; z < sl; z++) {\n\t\t\t\t\t\tif (next) {\n\t\t\t\t\t\t\ts32 delta = gf_bs_read_se(bs);\n\t\t\t\t\t\t\tnext = (last + delta + 256) % 256;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlast = next ? next : last;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tsps->profile_idc = profile_idc;\n\tsps->level_idc = level_idc;\n\tsps->prof_compat = pcomp;\n\tsps->log2_max_frame_num = gf_bs_read_ue_log(bs, \"log2_max_frame_num\") + 4;\n\tsps->poc_type = gf_bs_read_ue_log(bs, \"poc_type\");\n\tsps->chroma_format = chroma_format_idc;\n\tsps->luma_bit_depth_m8 = luma_bd;\n\tsps->chroma_bit_depth_m8 = chroma_bd;\n\n\tif (sps->poc_type == 0) {\n\t\tsps->log2_max_poc_lsb = gf_bs_read_ue_log(bs, \"log2_max_poc_lsb\") + 4;\n\t}\n\telse if (sps->poc_type == 1) {\n\t\tsps->delta_pic_order_always_zero_flag = gf_bs_read_int_log(bs, 1, \"delta_pic_order_always_zero_flag\");\n\t\tsps->offset_for_non_ref_pic = gf_bs_read_se_log(bs, \"offset_for_non_ref_pic\");\n\t\tsps->offset_for_top_to_bottom_field = gf_bs_read_se_log(bs, \"offset_for_top_to_bottom_field\");\n\t\tsps->poc_cycle_length = gf_bs_read_ue_log(bs, \"poc_cycle_length\");\n\t\tif (sps->poc_cycle_length > GF_ARRAY_LENGTH(sps->offset_for_ref_frame)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[avc-h264] offset_for_ref_frame overflow from poc_cycle_length\\n\"));\n\t\t\treturn -1;\n\t\t}\n\t\tfor (i = 0; i < sps->poc_cycle_length; i++)\n\t\t\tsps->offset_for_ref_frame[i] = gf_bs_read_se_log_idx(bs, \"offset_for_ref_frame\", i);\n\t}\n\tif (sps->poc_type > 2) {\n\t\treturn -1;\n\t}\n\tsps->max_num_ref_frames = gf_bs_read_ue_log(bs, \"max_num_ref_frames\");\n\tsps->gaps_in_frame_num_value_allowed_flag = gf_bs_read_int_log(bs, 1, \"gaps_in_frame_num_value_allowed_flag\");\n\tmb_width = gf_bs_read_ue_log(bs, \"pic_width_in_mbs_minus1\") + 1;\n\tmb_height = gf_bs_read_ue_log(bs, \"pic_height_in_map_units_minus1\") + 1;\n\n\tsps->frame_mbs_only_flag = gf_bs_read_int_log(bs, 1, \"frame_mbs_only_flag\");\n\n\tsps->width = mb_width * 16;\n\tsps->height = (2 - sps->frame_mbs_only_flag) * mb_height * 16;\n\n\tif (!sps->frame_mbs_only_flag) sps->mb_adaptive_frame_field_flag = gf_bs_read_int_log(bs, 1, \"mb_adaptive_frame_field_flag\");\n\tgf_bs_read_int_log(bs, 1, \"direct_8x8_inference_flag\");\n\n\tif (gf_bs_read_int_log(bs, 1, \"frame_cropping_flag\")) {\n\t\tint CropUnitX, CropUnitY, SubWidthC = -1, SubHeightC = -1;\n\n\t\tif (chroma_format_idc == 1) {\n\t\t\tSubWidthC = 2; SubHeightC = 2;\n\t\t}\n\t\telse if (chroma_format_idc == 2) {\n\t\t\tSubWidthC = 2; SubHeightC = 1;\n\t\t}\n\t\telse if ((chroma_format_idc == 3) && (separate_colour_plane_flag == 0)) {\n\t\t\tSubWidthC = 1; SubHeightC = 1;\n\t\t}\n\n\t\tif (sps->ChromaArrayType == 0) {\n\t\t\tassert(SubWidthC == -1);\n\t\t\tCropUnitX = 1;\n\t\t\tCropUnitY = 2 - sps->frame_mbs_only_flag;\n\t\t}\n\t\telse {\n\t\t\tCropUnitX = SubWidthC;\n\t\t\tCropUnitY = SubHeightC * (2 - sps->frame_mbs_only_flag);\n\t\t}\n\n\t\tcl = gf_bs_read_ue_log(bs, \"frame_crop_left_offset\");\n\t\tcr = gf_bs_read_ue_log(bs, \"frame_crop_right_offset\");\n\t\tct = gf_bs_read_ue_log(bs, \"frame_crop_top_offset\");\n\t\tcb = gf_bs_read_ue_log(bs, \"frame_crop_bottom_offset\");\n\n\t\tsps->width -= CropUnitX * (cl + cr);\n\t\tsps->height -= CropUnitY * (ct + cb);\n\t\tcl *= CropUnitX;\n\t\tcr *= CropUnitX;\n\t\tct *= CropUnitY;\n\t\tcb *= CropUnitY;\n\t}\n\tsps->crop.left = cl;\n\tsps->crop.right = cr;\n\tsps->crop.top = ct;\n\tsps->crop.bottom = cb;\n\n\tif (vui_flag_pos) {\n\t\t*vui_flag_pos = (u32)gf_bs_get_bit_offset(bs);\n\t}\n\t/*vui_parameters_present_flag*/\n\tsps->vui_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_parameters_present_flag\");\n\tif (sps->vui_parameters_present_flag) {\n\t\tsps->vui.aspect_ratio_info_present_flag = gf_bs_read_int_log(bs, 1, \"aspect_ratio_info_present_flag\");\n\t\tif (sps->vui.aspect_ratio_info_present_flag) {\n\t\t\ts32 aspect_ratio_idc = gf_bs_read_int_log(bs, 8, \"aspect_ratio_idc\");\n\t\t\tif (aspect_ratio_idc == 255) {\n\t\t\t\tsps->vui.par_num = gf_bs_read_int_log(bs, 16, \"aspect_ratio_num\");\n\t\t\t\tsps->vui.par_den = gf_bs_read_int_log(bs, 16, \"aspect_ratio_den\");\n\t\t\t}\n\t\t\telse if (aspect_ratio_idc < GF_ARRAY_LENGTH(avc_hevc_sar) ) {\n\t\t\t\tsps->vui.par_num = avc_hevc_sar[aspect_ratio_idc].w;\n\t\t\t\tsps->vui.par_den = avc_hevc_sar[aspect_ratio_idc].h;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] Unknown aspect_ratio_idc: your video may have a wrong aspect ratio. Contact the GPAC team!\\n\"));\n\t\t\t}\n\t\t}\n\t\tsps->vui.overscan_info_present_flag = gf_bs_read_int_log(bs, 1, \"overscan_info_present_flag\");\n\t\tif (sps->vui.overscan_info_present_flag)\n\t\t\tgf_bs_read_int_log(bs, 1, \"overscan_appropriate_flag\");\n\n\t\t/* default values */\n\t\tsps->vui.video_format = 5;\n\t\tsps->vui.colour_primaries = 2;\n\t\tsps->vui.transfer_characteristics = 2;\n\t\tsps->vui.matrix_coefficients = 2;\n\t\t/* now read values if possible */\n\t\tsps->vui.video_signal_type_present_flag = gf_bs_read_int_log(bs, 1, \"video_signal_type_present_flag\");\n\t\tif (sps->vui.video_signal_type_present_flag) {\n\t\t\tsps->vui.video_format = gf_bs_read_int_log(bs, 3, \"video_format\");\n\t\t\tsps->vui.video_full_range_flag = gf_bs_read_int_log(bs, 1, \"video_full_range_flag\");\n\t\t\tsps->vui.colour_description_present_flag = gf_bs_read_int_log(bs, 1, \"colour_description_present_flag\");\n\t\t\tif (sps->vui.colour_description_present_flag) {\n\t\t\t\tsps->vui.colour_primaries = gf_bs_read_int_log(bs, 8, \"colour_primaries\");\n\t\t\t\tsps->vui.transfer_characteristics = gf_bs_read_int_log(bs, 8, \"transfer_characteristics\");\n\t\t\t\tsps->vui.matrix_coefficients = gf_bs_read_int_log(bs, 8, \"matrix_coefficients\");\n\t\t\t}\n\t\t}\n\n\t\tif (gf_bs_read_int_log(bs, 1, \"chroma_location_info_present_flag\")) {\n\t\t\tgf_bs_read_ue_log(bs, \"chroma_sample_location_type_top_field\");\n\t\t\tgf_bs_read_ue_log(bs, \"chroma_sample_location_type_bottom_field\");\n\t\t}\n\n\t\tsps->vui.timing_info_present_flag = gf_bs_read_int_log(bs, 1, \"timing_info_present_flag\");\n\t\tif (sps->vui.timing_info_present_flag) {\n\t\t\tsps->vui.num_units_in_tick = gf_bs_read_int_log(bs, 32, \"num_units_in_tick\");\n\t\t\tsps->vui.time_scale = gf_bs_read_int_log(bs, 32, \"time_scale\");\n\t\t\tsps->vui.fixed_frame_rate_flag = gf_bs_read_int_log(bs, 1, \"fixed_frame_rate_flag\");\n\t\t}\n\n\t\tsps->vui.nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"nal_hrd_parameters_present_flag\");\n\t\tif (sps->vui.nal_hrd_parameters_present_flag)\n\t\t\tavc_parse_hrd_parameters(bs, &sps->vui.hrd);\n\n\t\tsps->vui.vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vcl_hrd_parameters_present_flag\");\n\t\tif (sps->vui.vcl_hrd_parameters_present_flag)\n\t\t\tavc_parse_hrd_parameters(bs, &sps->vui.hrd);\n\n\t\tif (sps->vui.nal_hrd_parameters_present_flag || sps->vui.vcl_hrd_parameters_present_flag)\n\t\t\tsps->vui.low_delay_hrd_flag = gf_bs_read_int_log(bs, 1, \"low_delay_hrd_flag\");\n\n\t\tsps->vui.pic_struct_present_flag = gf_bs_read_int_log(bs, 1, \"pic_struct_present_flag\");\n\t}\n\t/*end of seq_parameter_set_data*/\n\n\tif (subseq_sps) {\n\t\tif ((profile_idc == 83) || (profile_idc == 86)) {\n\t\t\tu8 extended_spatial_scalability_idc;\n\t\t\t/*parsing seq_parameter_set_svc_extension*/\n\n\t\t\tgf_bs_read_int_log(bs, 1, \"inter_layer_deblocking_filter_control_present_flag\");\n\t\t\textended_spatial_scalability_idc = gf_bs_read_int_log(bs, 2, \"extended_spatial_scalability_idc\");\n\t\t\tif (sps->ChromaArrayType == 1 || sps->ChromaArrayType == 2) {\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"chroma_phase_x_plus1_flag\");\n\t\t\t}\n\t\t\tif (sps->ChromaArrayType == 1) {\n\t\t\t\tgf_bs_read_int_log(bs, 2, \"chroma_phase_y_plus1\");\n\t\t\t}\n\t\t\tif (extended_spatial_scalability_idc == 1) {\n\t\t\t\tif (sps->ChromaArrayType > 0) {\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"seq_ref_layer_chroma_phase_x_plus1_flag\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 2, \"seq_ref_layer_chroma_phase_y_plus1\");\n\t\t\t\t}\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_left_offset\");\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_top_offset\");\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_right_offset\");\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_bottom_offset\");\n\t\t\t}\n\t\t\tif (gf_bs_read_int_log(bs, 1, \"seq_tcoeff_level_prediction_flag\")) {\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"adaptive_tcoeff_level_prediction_flag\");\n\t\t\t}\n\t\t\tgf_bs_read_int_log(bs, 1, \"slice_header_restriction_flag\");\n\n\t\t\tif (gf_bs_read_int_log(bs, 1, \"svc_vui_parameters_present\")) {\n\t\t\t\tu32 vui_ext_num_entries_minus1 = gf_bs_read_ue_log(bs, \"vui_ext_num_entries_minus1\");\n\n\t\t\t\tfor (i = 0; i <= vui_ext_num_entries_minus1; i++) {\n\t\t\t\t\tu8 vui_ext_nal_hrd_parameters_present_flag, vui_ext_vcl_hrd_parameters_present_flag, vui_ext_timing_info_present_flag;\n\t\t\t\t\tgf_bs_read_int_log(bs, 3, \"vui_ext_dependency_id\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 4, \"vui_ext_quality_id\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 3, \"vui_ext_temporal_id\");\n\t\t\t\t\tvui_ext_timing_info_present_flag = gf_bs_read_int_log(bs, 1, \"vui_ext_timing_info_present_flag\");\n\t\t\t\t\tif (vui_ext_timing_info_present_flag) {\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 32, \"vui_ext_num_units_in_tick\");\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 32, \"vui_ext_time_scale\");\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"vui_ext_fixed_frame_rate_flag\");\n\t\t\t\t\t}\n\t\t\t\t\tvui_ext_nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_ext_nal_hrd_parameters_present_flag\");\n\t\t\t\t\tif (vui_ext_nal_hrd_parameters_present_flag) {\n\t\t\t\t\t\t//hrd_parameters( )\n\t\t\t\t\t}\n\t\t\t\t\tvui_ext_vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_ext_vcl_hrd_parameters_present_flag\");\n\t\t\t\t\tif (vui_ext_vcl_hrd_parameters_present_flag) {\n\t\t\t\t\t\t//hrd_parameters( )\n\t\t\t\t\t}\n\t\t\t\t\tif (vui_ext_nal_hrd_parameters_present_flag || vui_ext_vcl_hrd_parameters_present_flag) {\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"vui_ext_low_delay_hrd_flag\");\n\t\t\t\t\t}\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"vui_ext_pic_struct_present_flag\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ((profile_idc == 118) || (profile_idc == 128)) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CODING, (\"[avc-h264] MVC parsing not implemented - skipping parsing end of Subset SPS\\n\"));\n\t\t\treturn sps_id;\n\t\t}\n\n\t\tif (gf_bs_read_int_log(bs, 1, \"additional_extension2\")) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] skipping parsing end of Subset SPS (additional_extension2)\\n\"));\n\t\t\treturn sps_id;\n\t\t}\n\t}\n\treturn sps_id;\n}", "target": 1, "idx": 11487}
{"commit_id": "b5dba59e0cf7e2cc4d3b3b1ac5fe81ddf21959eb", "project": "torvalds/linux", "func": "static int io_issue_sqe(struct io_kiocb *req, const struct io_uring_sqe *sqe,\n\t\t\tstruct io_kiocb **nxt, bool force_nonblock)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tint ret;\n\n\tswitch (req->opcode) {\n\tcase IORING_OP_NOP:\n\t\tret = io_nop(req);\n\t\tbreak;\n\tcase IORING_OP_READV:\n\tcase IORING_OP_READ_FIXED:\n\t\tif (sqe) {\n\t\t\tret = io_read_prep(req, sqe, force_nonblock);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_read(req, nxt, force_nonblock);\n\t\tbreak;\n\tcase IORING_OP_WRITEV:\n\tcase IORING_OP_WRITE_FIXED:\n\t\tif (sqe) {\n\t\t\tret = io_write_prep(req, sqe, force_nonblock);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_write(req, nxt, force_nonblock);\n\t\tbreak;\n\tcase IORING_OP_FSYNC:\n\t\tif (sqe) {\n\t\t\tret = io_prep_fsync(req, sqe);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_fsync(req, nxt, force_nonblock);\n\t\tbreak;\n\tcase IORING_OP_POLL_ADD:\n\t\tif (sqe) {\n\t\t\tret = io_poll_add_prep(req, sqe);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_poll_add(req, nxt);\n\t\tbreak;\n\tcase IORING_OP_POLL_REMOVE:\n\t\tif (sqe) {\n\t\t\tret = io_poll_remove_prep(req, sqe);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_poll_remove(req);\n\t\tbreak;\n\tcase IORING_OP_SYNC_FILE_RANGE:\n\t\tif (sqe) {\n\t\t\tret = io_prep_sfr(req, sqe);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_sync_file_range(req, nxt, force_nonblock);\n\t\tbreak;\n\tcase IORING_OP_SENDMSG:\n\t\tif (sqe) {\n\t\t\tret = io_sendmsg_prep(req, sqe);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_sendmsg(req, nxt, force_nonblock);\n\t\tbreak;\n\tcase IORING_OP_RECVMSG:\n\t\tif (sqe) {\n\t\t\tret = io_recvmsg_prep(req, sqe);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_recvmsg(req, nxt, force_nonblock);\n\t\tbreak;\n\tcase IORING_OP_TIMEOUT:\n\t\tif (sqe) {\n\t\t\tret = io_timeout_prep(req, sqe, false);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_timeout(req);\n\t\tbreak;\n\tcase IORING_OP_TIMEOUT_REMOVE:\n\t\tif (sqe) {\n\t\t\tret = io_timeout_remove_prep(req, sqe);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_timeout_remove(req);\n\t\tbreak;\n\tcase IORING_OP_ACCEPT:\n\t\tif (sqe) {\n\t\t\tret = io_accept_prep(req, sqe);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_accept(req, nxt, force_nonblock);\n\t\tbreak;\n\tcase IORING_OP_CONNECT:\n\t\tif (sqe) {\n\t\t\tret = io_connect_prep(req, sqe);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_connect(req, nxt, force_nonblock);\n\t\tbreak;\n\tcase IORING_OP_ASYNC_CANCEL:\n\t\tif (sqe) {\n\t\t\tret = io_async_cancel_prep(req, sqe);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_async_cancel(req, nxt);\n\t\tbreak;\n\tcase IORING_OP_FALLOCATE:\n\t\tif (sqe) {\n\t\t\tret = io_fallocate_prep(req, sqe);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_fallocate(req, nxt, force_nonblock);\n\t\tbreak;\n\tcase IORING_OP_OPENAT:\n\t\tif (sqe) {\n\t\t\tret = io_openat_prep(req, sqe);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_openat(req, nxt, force_nonblock);\n\t\tbreak;\n\tcase IORING_OP_CLOSE:\n\t\tif (sqe) {\n\t\t\tret = io_close_prep(req, sqe);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = io_close(req, nxt, force_nonblock);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (ctx->flags & IORING_SETUP_IOPOLL) {\n\t\tconst bool in_async = io_wq_current_is_worker();\n\n\t\tif (req->result == -EAGAIN)\n\t\t\treturn -EAGAIN;\n\n\t\t/* workqueue context doesn't hold uring_lock, grab it now */\n\t\tif (in_async)\n\t\t\tmutex_lock(&ctx->uring_lock);\n\n\t\tio_iopoll_req_issued(req);\n\n\t\tif (in_async)\n\t\t\tmutex_unlock(&ctx->uring_lock);\n\t}\n\n\treturn 0;\n}", "target": 2, "idx": 11488}
{"commit_id": "cc00bcaa589914096edef7fb87ca5cee4a166b5c", "project": "torvalds/linux", "func": "static int get_info(struct net *net, void __user *user, const int *len)\n{\n\tchar name[XT_TABLE_MAXNAMELEN];\n\tstruct xt_table *t;\n\tint ret;\n\n\tif (*len != sizeof(struct arpt_getinfo))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(name, user, sizeof(name)) != 0)\n\t\treturn -EFAULT;\n\n\tname[XT_TABLE_MAXNAMELEN-1] = '\\0';\n#ifdef CONFIG_COMPAT\n\tif (in_compat_syscall())\n\t\txt_compat_lock(NFPROTO_ARP);\n#endif\n\tt = xt_request_find_table_lock(net, NFPROTO_ARP, name);\n\tif (!IS_ERR(t)) {\n\t\tstruct arpt_getinfo info;\n\t\tconst struct xt_table_info *private = xt_table_get_private_protected(t);\n#ifdef CONFIG_COMPAT\n\t\tstruct xt_table_info tmp;\n\n\t\tif (in_compat_syscall()) {\n\t\t\tret = compat_table_info(private, &tmp);\n\t\t\txt_compat_flush_offsets(NFPROTO_ARP);\n\t\t\tprivate = &tmp;\n\t\t}\n#endif\n\t\tmemset(&info, 0, sizeof(info));\n\t\tinfo.valid_hooks = t->valid_hooks;\n\t\tmemcpy(info.hook_entry, private->hook_entry,\n\t\t       sizeof(info.hook_entry));\n\t\tmemcpy(info.underflow, private->underflow,\n\t\t       sizeof(info.underflow));\n\t\tinfo.num_entries = private->number;\n\t\tinfo.size = private->size;\n\t\tstrcpy(info.name, name);\n\n\t\tif (copy_to_user(user, &info, *len) != 0)\n\t\t\tret = -EFAULT;\n\t\telse\n\t\t\tret = 0;\n\t\txt_table_unlock(t);\n\t\tmodule_put(t->me);\n\t} else\n\t\tret = PTR_ERR(t);\n#ifdef CONFIG_COMPAT\n\tif (in_compat_syscall())\n\t\txt_compat_unlock(NFPROTO_ARP);\n#endif\n\treturn ret;\n}", "target": 1, "idx": 11489}
{"commit_id": "32671e3799ca2e4590773fd0e63aaa4229e50c06", "project": "torvalds/linux", "func": "static int perf_read_group(struct perf_event *event,\n\t\t\t\t   u64 read_format, char __user *buf)\n{\n\tstruct perf_event *leader = event->group_leader, *child;\n\tstruct perf_event_context *ctx = leader->ctx;\n\tint ret;\n\tu64 *values;\n\n\tlockdep_assert_held(&ctx->mutex);\n\n\tvalues = kzalloc(event->read_size, GFP_KERNEL);\n\tif (!values)\n\t\treturn -ENOMEM;\n\n\tvalues[0] = 1 + leader->nr_siblings;\n\n\tmutex_lock(&leader->child_mutex);\n\n\tret = __perf_read_group_add(leader, read_format, values);\n\tif (ret)\n\t\tgoto unlock;\n\n\tlist_for_each_entry(child, &leader->child_list, child_list) {\n\t\tret = __perf_read_group_add(child, read_format, values);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t}\n\n\tmutex_unlock(&leader->child_mutex);\n\n\tret = event->read_size;\n\tif (copy_to_user(buf, values, event->read_size))\n\t\tret = -EFAULT;\n\tgoto out;\n\nunlock:\n\tmutex_unlock(&leader->child_mutex);\nout:\n\tkfree(values);\n\treturn ret;\n}", "target": 2, "idx": 11490}
{"commit_id": "9c1c33d16ca0cb7a2365835fd77d758a1ea0bb62", "project": "AcademySoftwareFoundation/openexr", "func": "int\ngetChunkOffsetTableSize(const Header& header,bool)\n{\n    //\n    // if there is a type in the header which indicates the part is not a currently supported type,\n    // use the chunkCount attribute\n    //\n\n\n    if(header.hasType()  && !isSupportedType(header.type()))\n    {\n        if(header.hasChunkCount())\n        {\n           return header.chunkCount();\n        }\n        else\n        {\n           throw IEX_NAMESPACE::ArgExc (\"unsupported header type to \"\n           \"get chunk offset table size\");\n        }\n    }\n\n    //\n    // part is a known type - ignore the header attribute and compute the chunk size from the header\n    //\n    if (isTiled(header.type()) == false)\n        return getScanlineChunkOffsetTableSize(header);\n    else\n        return getTiledChunkOffsetTableSize(header);\n    \n}", "target": 1, "idx": 11491}
{"commit_id": "2a02ff76b5f4d2a0b01f0eee289c47e0901c49b6", "project": "nothings/stb", "func": "static float *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\n{\n   char buffer[STBI__HDR_BUFLEN];\n   char *token;\n   int valid = 0;\n   int width, height;\n   stbi_uc *scanline;\n   float *hdr_data;\n   int len;\n   unsigned char count, value;\n   int i, j, k, c1,c2, z;\n   const char *headerToken;\n   STBI_NOTUSED(ri);\n\n   // Check identifier\n   headerToken = stbi__hdr_gettoken(s,buffer);\n   if (strcmp(headerToken, \"#?RADIANCE\") != 0 && strcmp(headerToken, \"#?RGBE\") != 0)\n      return stbi__errpf(\"not HDR\", \"Corrupt HDR image\");\n\n   // Parse header\n   for(;;) {\n      token = stbi__hdr_gettoken(s,buffer);\n      if (token[0] == 0) break;\n      if (strcmp(token, \"FORMAT=32-bit_rle_rgbe\") == 0) valid = 1;\n   }\n\n   if (!valid)    return stbi__errpf(\"unsupported format\", \"Unsupported HDR format\");\n\n   // Parse width and height\n   // can't use sscanf() if we're not using stdio!\n   token = stbi__hdr_gettoken(s,buffer);\n   if (strncmp(token, \"-Y \", 3))  return stbi__errpf(\"unsupported data layout\", \"Unsupported HDR format\");\n   token += 3;\n   height = (int) strtol(token, &token, 10);\n   while (*token == ' ') ++token;\n   if (strncmp(token, \"+X \", 3))  return stbi__errpf(\"unsupported data layout\", \"Unsupported HDR format\");\n   token += 3;\n   width = (int) strtol(token, NULL, 10);\n\n   if (height > STBI_MAX_DIMENSIONS) return stbi__errpf(\"too large\",\"Very large image (corrupt?)\");\n   if (width > STBI_MAX_DIMENSIONS) return stbi__errpf(\"too large\",\"Very large image (corrupt?)\");\n\n   *x = width;\n   *y = height;\n\n   if (comp) *comp = 3;\n   if (req_comp == 0) req_comp = 3;\n\n   if (!stbi__mad4sizes_valid(width, height, req_comp, sizeof(float), 0))\n      return stbi__errpf(\"too large\", \"HDR image is too large\");\n\n   // Read data\n   hdr_data = (float *) stbi__malloc_mad4(width, height, req_comp, sizeof(float), 0);\n   if (!hdr_data)\n      return stbi__errpf(\"outofmem\", \"Out of memory\");\n\n   // Load image data\n   // image data is stored as some number of sca\n   if ( width < 8 || width >= 32768) {\n      // Read flat data\n      for (j=0; j < height; ++j) {\n         for (i=0; i < width; ++i) {\n            stbi_uc rgbe[4];\n           main_decode_loop:\n            stbi__getn(s, rgbe, 4);\n            stbi__hdr_convert(hdr_data + j * width * req_comp + i * req_comp, rgbe, req_comp);\n         }\n      }\n   } else {\n      // Read RLE-encoded data\n      scanline = NULL;\n\n      for (j = 0; j < height; ++j) {\n         c1 = stbi__get8(s);\n         c2 = stbi__get8(s);\n         len = stbi__get8(s);\n         if (c1 != 2 || c2 != 2 || (len & 0x80)) {\n            // not run-length encoded, so we have to actually use THIS data as a decoded\n            // pixel (note this can't be a valid pixel--one of RGB must be >= 128)\n            stbi_uc rgbe[4];\n            rgbe[0] = (stbi_uc) c1;\n            rgbe[1] = (stbi_uc) c2;\n            rgbe[2] = (stbi_uc) len;\n            rgbe[3] = (stbi_uc) stbi__get8(s);\n            stbi__hdr_convert(hdr_data, rgbe, req_comp);\n            i = 1;\n            j = 0;\n            STBI_FREE(scanline);\n            goto main_decode_loop; // yes, this makes no sense\n         }\n         len <<= 8;\n         len |= stbi__get8(s);\n         if (len != width) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"invalid decoded scanline length\", \"corrupt HDR\"); }\n         if (scanline == NULL) {\n            scanline = (stbi_uc *) stbi__malloc_mad2(width, 4, 0);\n            if (!scanline) {\n               STBI_FREE(hdr_data);\n               return stbi__errpf(\"outofmem\", \"Out of memory\");\n            }\n         }\n\n         for (k = 0; k < 4; ++k) {\n            int nleft;\n            i = 0;\n            while ((nleft = width - i) > 0) {\n               count = stbi__get8(s);\n               if (count > 128) {\n                  // Run\n                  value = stbi__get8(s);\n                  count -= 128;\n                  if ((count == 0) || (count > nleft)) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"corrupt\", \"bad RLE data in HDR\"); }\n                  for (z = 0; z < count; ++z)\n                     scanline[i++ * 4 + k] = value;\n               } else {\n                  // Dump\n                  if ((count == 0) || (count > nleft)) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"corrupt\", \"bad RLE data in HDR\"); }\n                  for (z = 0; z < count; ++z)\n                     scanline[i++ * 4 + k] = stbi__get8(s);\n               }\n            }\n         }\n         for (i=0; i < width; ++i)\n            stbi__hdr_convert(hdr_data+(j*width + i)*req_comp, scanline + i*4, req_comp);\n      }\n      if (scanline)\n         STBI_FREE(scanline);\n   }\n\n   return hdr_data;\n}", "target": 1, "idx": 11492}
{"commit_id": "838c0dc7641e1c991c0f3027bf94bee4606012f8", "project": "bluez", "func": "static struct pending_op *pending_read_new(struct bt_att *att,\n\t\t\t\t\tstruct queue *owner_queue,\n\t\t\t\t\tstruct gatt_db_attribute *attrib,\n\t\t\t\t\tunsigned int id, uint16_t offset)\n{\n\tstruct pending_op *op;\n\n\top = new0(struct pending_op, 1);\n\n\top->owner_queue = owner_queue;\n\top->att = bt_att_ref(att);\n\top->attrib = attrib;\n\top->id = id;\n\top->offset = offset;\n\top->link_type = bt_att_get_link_type(att);\n\tqueue_push_tail(owner_queue, op);\n\n\top->disconn_id = bt_att_register_disconnect(att, pending_disconnect_cb,\n\t\t\t\t\t\t\t\top, NULL);\n\n\treturn op;\n}", "target": 3, "idx": 11493}
{"commit_id": "1295ae4dbb52fe06b19733b0257e2340d7b63b8d", "project": "tensorflow", "func": "StatusOr<std::vector<int64_t>> GetKernelSize(XlaOpKernelContext* ctx) {\n    std::vector<int64_t> ksize;\n    if (ctx->num_inputs() == 1) {\n      ksize = ksize_;\n    } else {\n      const TensorShape ksize_shape = ctx->InputShape(1);\n      // Validate input sizes.\n      if (!TensorShapeUtils::IsVector(ksize_shape)) {\n        return errors::InvalidArgument(\"ksize must be a vector, not shape \",\n                                       ksize_shape.DebugString());\n      }\n      if (ksize_shape.num_elements() != num_dims()) {\n        return errors::InvalidArgument(\n            \"Sliding window ksize field must \"\n            \"specify \",\n            num_dims(), \" dimensions\");\n      }\n      auto status = ctx->ConstantInputAsIntVector(1, &ksize);\n      if (!status.ok()) {\n        return status;\n      }\n    }\n    TF_RETURN_IF_ERROR(ValidateKernelSizes(ksize));\n    return ksize;\n  }", "target": 2, "idx": 11494}
{"commit_id": "5408a6d93f45bf1f7acd9ae5d44e0ebd77379e98", "project": "pcmacdon/jsish", "func": "static Jsi_RC jsi_ArrayShiftCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    Jsi_Value *v;\n    Jsi_Obj *obj = _this->d.obj;\n    Jsi_ObjListifyArray(interp, obj);\n    uint n = jsi_SizeOfArray(interp, obj);\n    if (n<=0) {\n        Jsi_ValueMakeUndef(interp, ret);\n    } else {\n        n--;\n        v = obj->arr[0];\n        memmove(obj->arr, obj->arr+1, n*sizeof(Jsi_Value*));\n        obj->arr[n] = NULL;\n        Jsi_ValueDup2(interp, ret, v);\n        Jsi_DecrRefCount(interp, v);\n        Jsi_ObjSetLength(interp, obj, n);\n    }\n    return JSI_OK;\n}", "target": 3, "idx": 11495}
{"commit_id": "2e00e95473861846aa8538be87db07699d9f676d", "project": "nginx/njs", "func": "static njs_int_t\nnjs_array_prototype_splice(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    int64_t      i, n, start, length, items, delta, delete;\n    njs_int_t    ret;\n    njs_value_t  *this, value, del_object;\n    njs_array_t  *array, *deleted;\n\n    this = njs_argument(args, 0);\n\n    ret = njs_value_to_object(vm, this);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    ret = njs_object_length(vm, this, &length);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n\n    ret = njs_value_to_integer(vm, njs_arg(args, nargs, 1), &start);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    start = (start < 0) ? njs_max(length + start, 0) : njs_min(start, length);\n\n    items = 0;\n    delete = 0;\n\n    if (nargs == 2) {\n        delete = length - start;\n\n    } else if (nargs > 2) {\n        items = nargs - 3;\n\n        ret = njs_value_to_integer(vm, njs_arg(args, nargs, 2), &delete);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n\n        delete = njs_min(njs_max(delete, 0), length - start);\n    }\n\n    delta = items - delete;\n\n    if (njs_slow_path((length + delta) > NJS_MAX_LENGTH)) {\n        njs_type_error(vm, \"Invalid length\");\n        return NJS_ERROR;\n    }\n\n    /* TODO: ArraySpeciesCreate(). */\n\n    deleted = njs_array_alloc(vm, 0, delete, 0);\n    if (njs_slow_path(deleted == NULL)) {\n        return NJS_ERROR;\n    }\n\n    if (njs_fast_path(njs_is_fast_array(this) && deleted->object.fast_array)) {\n        array = njs_array(this);\n        for (i = 0, n = start; i < delete; i++, n++) {\n            deleted->start[i] = array->start[n];\n        }\n\n    } else {\n        njs_set_array(&del_object, deleted);\n\n        for (i = 0, n = start; i < delete; i++, n++) {\n            ret = njs_value_property_i64(vm, this, n, &value);\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                return NJS_ERROR;\n            }\n\n            if (ret == NJS_OK) {\n                /* TODO:  CreateDataPropertyOrThrow(). */\n                ret = njs_value_property_i64_set(vm, &del_object, i, &value);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    return ret;\n                }\n\n            } else {\n                if (deleted->object.fast_array) {\n                    njs_set_invalid(&deleted->start[i]);\n                }\n            }\n        }\n\n        ret = njs_object_length_set(vm, &del_object, delete);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return NJS_ERROR;\n        }\n    }\n\n    if (njs_fast_path(njs_is_fast_array(this))) {\n        array = njs_array(this);\n\n        if (delta != 0) {\n            /*\n             * Relocate the rest of items.\n             * Index of the first item is in \"n\".\n             */\n            if (delta > 0) {\n                ret = njs_array_expand(vm, array, 0, delta);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    return ret;\n                }\n            }\n\n            ret = njs_array_copy_within(vm, this, start + items, start + delete,\n                                        array->length - (start + delete), 0);\n            if (njs_slow_path(ret != NJS_OK)) {\n                return ret;\n            }\n\n            array->length += delta;\n        }\n\n        /* Copy new items. */\n\n        if (items > 0) {\n            memcpy(&array->start[start], &args[3],\n                   items * sizeof(njs_value_t));\n        }\n\n    } else {\n\n       if (delta != 0) {\n           ret = njs_array_copy_within(vm, this, start + items, start + delete,\n                                       length - (start + delete), delta < 0);\n            if (njs_slow_path(ret != NJS_OK)) {\n                return ret;\n            }\n\n            for (i = length - 1; i >= length + delta; i--) {\n                ret = njs_value_property_i64_delete(vm, this, i, NULL);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    return NJS_ERROR;\n                }\n            }\n       }\n\n        /* Copy new items. */\n\n        for (i = 3, n = start; items-- > 0; i++, n++) {\n            ret = njs_value_property_i64_set(vm, this, n, &args[i]);\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                return NJS_ERROR;\n            }\n        }\n\n        ret = njs_object_length_set(vm, this, length + delta);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return NJS_ERROR;\n        }\n    }\n\n    njs_set_array(&vm->retval, deleted);\n\n    return NJS_OK;\n}", "target": 1, "idx": 11496}
{"commit_id": "d2ab84732936b6e7e5a461dc94344902965e9a06", "project": "ArtifexSoftware/ghostpdl", "func": "void\nxps_load_sfnt_name(xps_font_t *font, char *namep)\n{\n    byte *namedata;\n    int offset, length;\n    /*int format;*/\n    int count, stringoffset;\n    int found;\n    int i, k;\n\n    found = 0;\n    strcpy(namep, \"Unknown\");\n\n    offset = xps_find_sfnt_table(font, \"name\", &length);\n    if (offset < 0 || length < 6)\n    {\n        gs_warn(\"cannot find name table\");\n        return;\n    }\n\n    /* validate the offset, and the data for the two\n     * values we're about to read\n     */\n    if (offset + 6 > font->length)\n    {\n        gs_warn(\"name table byte offset invalid\");\n        return;\n    }\n    namedata = font->data + offset;\n\n    /*format = u16(namedata + 0);*/\n    count = u16(namedata + 2);\n    stringoffset = u16(namedata + 4);\n\n    if (stringoffset + offset > font->length\n        || offset + 6 + count * 12 > font->length)\n    {\n        gs_warn(\"name table invalid\");\n        return;\n    }\n\n    if (length < 6 + (count * 12))\n    {\n        gs_warn(\"name table too short\");\n        return;\n    }\n\n    for (i = 0; i < count; i++)\n    {\n        byte *record = namedata + 6 + i * 12;\n        int pid = u16(record + 0);\n        int eid = u16(record + 2);\n        int langid = u16(record + 4);\n        int nameid = u16(record + 6);\n        length = u16(record + 8);\n        offset = u16(record + 10);\n\n        /* Full font name or postscript name */\n        if (nameid == 4 || nameid == 6)\n        {\n            if (pid == 1 && eid == 0 && langid == 0) /* mac roman, english */\n            {\n                if (found < 3)\n                {\n                    memcpy(namep, namedata + stringoffset + offset, length);\n                    namep[length] = 0;\n                    found = 3;\n                }\n            }\n\n            if (pid == 3 && eid == 1 && langid == 0x409) /* windows unicode ucs-2, US */\n            {\n                if (found < 2)\n                {\n                    unsigned char *s = namedata + stringoffset + offset;\n                    int n = length / 2;\n                    for (k = 0; k < n; k ++)\n                    {\n                        int c = u16(s + k * 2);\n                        namep[k] = isprint(c) ? c : '?';\n                    }\n                    namep[k] = 0;\n                    found = 2;\n                }\n            }\n\n            if (pid == 3 && eid == 10 && langid == 0x409) /* windows unicode ucs-4, US */\n            {\n                if (found < 1)\n                {\n                    unsigned char *s = namedata + stringoffset + offset;\n                    int n = length / 4;\n                    for (k = 0; k < n; k ++)\n                    {\n                        int c = u32(s + k * 4);\n                        namep[k] = isprint(c) ? c : '?';\n                    }\n                    namep[k] = 0;\n                    found = 1;\n                }\n            }\n        }\n    }\n}", "target": 2, "idx": 11497}
{"commit_id": "d7603583f90c2bc6074a4ee2886bd28082d7c65b", "project": "android", "func": "static void worker_process(int fd, debugger_request_t& request) {\n  // Open the tombstone file if we need it.\n  std::string tombstone_path;\n  int tombstone_fd = -1;\n  switch (request.action) {\n    case DEBUGGER_ACTION_DUMP_TOMBSTONE:\n    case DEBUGGER_ACTION_CRASH:\n      tombstone_fd = open_tombstone(&tombstone_path);\n      if (tombstone_fd == -1) {\n        ALOGE(\"debuggerd: failed to open tombstone file: %s\\n\", strerror(errno));\n        exit(1);\n      }\n      break;\n\n    case DEBUGGER_ACTION_DUMP_BACKTRACE:\n      break;\n\n    default:\n      ALOGE(\"debuggerd: unexpected request action: %d\", request.action);\n      exit(1);\n  }\n\n  // At this point, the thread that made the request is blocked in\n  // a read() call.  If the thread has crashed, then this gives us\n  // time to PTRACE_ATTACH to it before it has a chance to really fault.\n  //\n  // The PTRACE_ATTACH sends a SIGSTOP to the target process, but it\n  // won't necessarily have stopped by the time ptrace() returns.  (We\n  // currently assume it does.)  We write to the file descriptor to\n  // ensure that it can run as soon as we call PTRACE_CONT below.\n  // See details in bionic/libc/linker/debugger.c, in function\n  // debugger_signal_handler().\n\n  // Attach to the target process.\n  if (!ptrace_attach_thread(request.pid, request.tid)) {\n    ALOGE(\"debuggerd: ptrace attach failed: %s\", strerror(errno));\n    exit(1);\n  }\n\n  // DEBUGGER_ACTION_CRASH requests can come from arbitrary processes and the tid field in the\n  // request is sent from the other side. If an attacker can cause a process to be spawned with the\n  // pid of their process, they could trick debuggerd into dumping that process by exiting after\n  // sending the request. Validate the trusted request.uid/gid to defend against this.\n  if (request.action == DEBUGGER_ACTION_CRASH) {\n    pid_t pid;\n    uid_t uid;\n    gid_t gid;\n    if (get_process_info(request.tid, &pid, &uid, &gid) != 0) {\n      ALOGE(\"debuggerd: failed to get process info for tid '%d'\", request.tid);\n      exit(1);\n    }\n\n    if (pid != request.pid || uid != request.uid || gid != request.gid) {\n      ALOGE(\n        \"debuggerd: attached task %d does not match request: \"\n        \"expected pid=%d,uid=%d,gid=%d, actual pid=%d,uid=%d,gid=%d\",\n        request.tid, request.pid, request.uid, request.gid, pid, uid, gid);\n      exit(1);\n    }\n  }\n\n  // Don't attach to the sibling threads if we want to attach gdb.\n  // Supposedly, it makes the process less reliable.\n  bool attach_gdb = should_attach_gdb(request);\n  if (attach_gdb) {\n    // Open all of the input devices we need to listen for VOLUMEDOWN before dropping privileges.\n    if (init_getevent() != 0) {\n      ALOGE(\"debuggerd: failed to initialize input device, not waiting for gdb\");\n      attach_gdb = false;\n    }\n\n  }\n\n  std::set<pid_t> siblings;\n  if (!attach_gdb) {\n    ptrace_siblings(request.pid, request.tid, siblings);\n  }\n\n  // Generate the backtrace map before dropping privileges.\n  std::unique_ptr<BacktraceMap> backtrace_map(BacktraceMap::Create(request.pid));\n\n  int amfd = -1;\n  std::unique_ptr<std::string> amfd_data;\n  if (request.action == DEBUGGER_ACTION_CRASH) {\n    // Connect to the activity manager before dropping privileges.\n    amfd = activity_manager_connect();\n    amfd_data.reset(new std::string);\n  }\n\n  bool succeeded = false;\n\n  // Now that we've done everything that requires privileges, we can drop them.\n  if (!drop_privileges()) {\n    ALOGE(\"debuggerd: failed to drop privileges, exiting\");\n    _exit(1);\n  }\n\n  int crash_signal = SIGKILL;\n  succeeded = perform_dump(request, fd, tombstone_fd, backtrace_map.get(), siblings,\n                           &crash_signal, amfd_data.get());\n  if (succeeded) {\n    if (request.action == DEBUGGER_ACTION_DUMP_TOMBSTONE) {\n      if (!tombstone_path.empty()) {\n        android::base::WriteFully(fd, tombstone_path.c_str(), tombstone_path.length());\n      }\n    }\n  }\n\n  if (attach_gdb) {\n    // Tell the signal process to send SIGSTOP to the target.\n    if (!send_signal(request.pid, 0, SIGSTOP)) {\n      ALOGE(\"debuggerd: failed to stop process for gdb attach: %s\", strerror(errno));\n      attach_gdb = false;\n    }\n  }\n\n  if (!attach_gdb) {\n    // Tell the Activity Manager about the crashing process. If we are\n    // waiting for gdb to attach, do not send this or Activity Manager\n    // might kill the process before anyone can attach.\n    activity_manager_write(request.pid, crash_signal, amfd, *amfd_data.get());\n  }\n\n  if (ptrace(PTRACE_DETACH, request.tid, 0, 0) != 0) {\n    ALOGE(\"debuggerd: ptrace detach from %d failed: %s\", request.tid, strerror(errno));\n  }\n\n  for (pid_t sibling : siblings) {\n    ptrace(PTRACE_DETACH, sibling, 0, 0);\n  }\n\n  // Send the signal back to the process if it crashed and we're not waiting for gdb.\n  if (!attach_gdb && request.action == DEBUGGER_ACTION_CRASH) {\n    if (!send_signal(request.pid, request.tid, crash_signal)) {\n      ALOGE(\"debuggerd: failed to kill process %d: %s\", request.pid, strerror(errno));\n    }\n  }\n\n  // Wait for gdb, if requested.\n  if (attach_gdb) {\n    wait_for_user_action(request);\n\n    // Now tell the activity manager about this process.\n    activity_manager_write(request.pid, crash_signal, amfd, *amfd_data.get());\n\n    // Tell the signal process to send SIGCONT to the target.\n    if (!send_signal(request.pid, 0, SIGCONT)) {\n      ALOGE(\"debuggerd: failed to resume process %d: %s\", request.pid, strerror(errno));\n    }\n\n    uninit_getevent();\n  }\n\n  close(amfd);\n\n  exit(!succeeded);\n}", "target": 2, "idx": 11498}
{"commit_id": "77c955200ddd1761d6ed7a6c1578349fedbb55e4", "project": "android", "func": "T* reset(size_t count = 0) {\n        sk_free(fPtr);\n        fPtr = count ? (T*)sk_malloc_throw(count, sizeof(T)) : nullptr;\n        return fPtr;\n    }", "target": 2, "idx": 11499}
{"commit_id": "5b3406094f2679dfb3763de4414257268565b943", "project": "bitcoin", "func": "bool PeerManagerImpl::SendMessages(CNode* pto)\n{\n    AssertLockHeld(g_msgproc_mutex);\n\n    PeerRef peer = GetPeerRef(pto->GetId());\n    if (!peer) return false;\n    const Consensus::Params& consensusParams = m_chainparams.GetConsensus();\n\n    // We must call MaybeDiscourageAndDisconnect first, to ensure that we'll\n    // disconnect misbehaving peers even before the version handshake is complete.\n    if (MaybeDiscourageAndDisconnect(*pto, *peer)) return true;\n\n    // Don't send anything until the version handshake is complete\n    if (!pto->fSuccessfullyConnected || pto->fDisconnect)\n        return true;\n\n    // If we get here, the outgoing message serialization version is set and can't change.\n    const CNetMsgMaker msgMaker(pto->GetCommonVersion());\n\n    const auto current_time{GetTime<std::chrono::microseconds>()};\n\n    if (pto->IsAddrFetchConn() && current_time - pto->m_connected > 10 * AVG_ADDRESS_BROADCAST_INTERVAL) {\n        LogPrint(BCLog::NET, \"addrfetch connection timeout; disconnecting peer=%d\\n\", pto->GetId());\n        pto->fDisconnect = true;\n        return true;\n    }\n\n    MaybeSendPing(*pto, *peer, current_time);\n\n    // MaybeSendPing may have marked peer for disconnection\n    if (pto->fDisconnect) return true;\n\n    MaybeSendAddr(*pto, *peer, current_time);\n\n    MaybeSendSendHeaders(*pto, *peer);\n\n    {\n        LOCK(cs_main);\n\n        CNodeState &state = *State(pto->GetId());\n\n        // Start block sync\n        if (m_chainman.m_best_header == nullptr) {\n            m_chainman.m_best_header = m_chainman.ActiveChain().Tip();\n        }\n\n        // Determine whether we might try initial headers sync or parallel\n        // block download from this peer -- this mostly affects behavior while\n        // in IBD (once out of IBD, we sync from all peers).\n        bool sync_blocks_and_headers_from_peer = false;\n        if (state.fPreferredDownload) {\n            sync_blocks_and_headers_from_peer = true;\n        } else if (CanServeBlocks(*peer) && !pto->IsAddrFetchConn()) {\n            // Typically this is an inbound peer. If we don't have any outbound\n            // peers, or if we aren't downloading any blocks from such peers,\n            // then allow block downloads from this peer, too.\n            // We prefer downloading blocks from outbound peers to avoid\n            // putting undue load on (say) some home user who is just making\n            // outbound connections to the network, but if our only source of\n            // the latest blocks is from an inbound peer, we have to be sure to\n            // eventually download it (and not just wait indefinitely for an\n            // outbound peer to have it).\n            if (m_num_preferred_download_peers == 0 || mapBlocksInFlight.empty()) {\n                sync_blocks_and_headers_from_peer = true;\n            }\n        }\n\n        if (!state.fSyncStarted && CanServeBlocks(*peer) && !m_chainman.m_blockman.LoadingBlocks()) {\n            // Only actively request headers from a single peer, unless we're close to today.\n            if ((nSyncStarted == 0 && sync_blocks_and_headers_from_peer) || m_chainman.m_best_header->Time() > GetAdjustedTime() - 24h) {\n                const CBlockIndex* pindexStart = m_chainman.m_best_header;\n                /* If possible, start at the block preceding the currently\n                   best known header.  This ensures that we always get a\n                   non-empty list of headers back as long as the peer\n                   is up-to-date.  With a non-empty response, we can initialise\n                   the peer's known best block.  This wouldn't be possible\n                   if we requested starting at m_chainman.m_best_header and\n                   got back an empty response.  */\n                if (pindexStart->pprev)\n                    pindexStart = pindexStart->pprev;\n                if (MaybeSendGetHeaders(*pto, GetLocator(pindexStart), *peer)) {\n                    LogPrint(BCLog::NET, \"initial getheaders (%d) to peer=%d (startheight:%d)\\n\", pindexStart->nHeight, pto->GetId(), peer->m_starting_height);\n\n                    state.fSyncStarted = true;\n                    peer->m_headers_sync_timeout = current_time + HEADERS_DOWNLOAD_TIMEOUT_BASE +\n                        (\n                         // Convert HEADERS_DOWNLOAD_TIMEOUT_PER_HEADER to microseconds before scaling\n                         // to maintain precision\n                         std::chrono::microseconds{HEADERS_DOWNLOAD_TIMEOUT_PER_HEADER} *\n                         Ticks<std::chrono::seconds>(GetAdjustedTime() - m_chainman.m_best_header->Time()) / consensusParams.nPowTargetSpacing\n                        );\n                    nSyncStarted++;\n                }\n            }\n        }\n\n        //\n        // Try sending block announcements via headers\n        //\n        {\n            // If we have no more than MAX_BLOCKS_TO_ANNOUNCE in our\n            // list of block hashes we're relaying, and our peer wants\n            // headers announcements, then find the first header\n            // not yet known to our peer but would connect, and send.\n            // If no header would connect, or if we have too many\n            // blocks, or if the peer doesn't want headers, just\n            // add all to the inv queue.\n            LOCK(peer->m_block_inv_mutex);\n            std::vector<CBlock> vHeaders;\n            bool fRevertToInv = ((!peer->m_prefers_headers &&\n                                 (!state.m_requested_hb_cmpctblocks || peer->m_blocks_for_headers_relay.size() > 1)) ||\n                                 peer->m_blocks_for_headers_relay.size() > MAX_BLOCKS_TO_ANNOUNCE);\n            const CBlockIndex *pBestIndex = nullptr; // last header queued for delivery\n            ProcessBlockAvailability(pto->GetId()); // ensure pindexBestKnownBlock is up-to-date\n\n            if (!fRevertToInv) {\n                bool fFoundStartingHeader = false;\n                // Try to find first header that our peer doesn't have, and\n                // then send all headers past that one.  If we come across any\n                // headers that aren't on m_chainman.ActiveChain(), give up.\n                for (const uint256& hash : peer->m_blocks_for_headers_relay) {\n                    const CBlockIndex* pindex = m_chainman.m_blockman.LookupBlockIndex(hash);\n                    assert(pindex);\n                    if (m_chainman.ActiveChain()[pindex->nHeight] != pindex) {\n                        // Bail out if we reorged away from this block\n                        fRevertToInv = true;\n                        break;\n                    }\n                    if (pBestIndex != nullptr && pindex->pprev != pBestIndex) {\n                        // This means that the list of blocks to announce don't\n                        // connect to each other.\n                        // This shouldn't really be possible to hit during\n                        // regular operation (because reorgs should take us to\n                        // a chain that has some block not on the prior chain,\n                        // which should be caught by the prior check), but one\n                        // way this could happen is by using invalidateblock /\n                        // reconsiderblock repeatedly on the tip, causing it to\n                        // be added multiple times to m_blocks_for_headers_relay.\n                        // Robustly deal with this rare situation by reverting\n                        // to an inv.\n                        fRevertToInv = true;\n                        break;\n                    }\n                    pBestIndex = pindex;\n                    if (fFoundStartingHeader) {\n                        // add this to the headers message\n                        vHeaders.push_back(pindex->GetBlockHeader());\n                    } else if (PeerHasHeader(&state, pindex)) {\n                        continue; // keep looking for the first new block\n                    } else if (pindex->pprev == nullptr || PeerHasHeader(&state, pindex->pprev)) {\n                        // Peer doesn't have this header but they do have the prior one.\n                        // Start sending headers.\n                        fFoundStartingHeader = true;\n                        vHeaders.push_back(pindex->GetBlockHeader());\n                    } else {\n                        // Peer doesn't have this header or the prior one -- nothing will\n                        // connect, so bail out.\n                        fRevertToInv = true;\n                        break;\n                    }\n                }\n            }\n            if (!fRevertToInv && !vHeaders.empty()) {\n                if (vHeaders.size() == 1 && state.m_requested_hb_cmpctblocks) {\n                    // We only send up to 1 block as header-and-ids, as otherwise\n                    // probably means we're doing an initial-ish-sync or they're slow\n                    LogPrint(BCLog::NET, \"%s sending header-and-ids %s to peer=%d\\n\", __func__,\n                            vHeaders.front().GetHash().ToString(), pto->GetId());\n\n                    std::optional<CSerializedNetMsg> cached_cmpctblock_msg;\n                    {\n                        LOCK(m_most_recent_block_mutex);\n                        if (m_most_recent_block_hash == pBestIndex->GetBlockHash()) {\n                            cached_cmpctblock_msg = msgMaker.Make(NetMsgType::CMPCTBLOCK, *m_most_recent_compact_block);\n                        }\n                    }\n                    if (cached_cmpctblock_msg.has_value()) {\n                        m_connman.PushMessage(pto, std::move(cached_cmpctblock_msg.value()));\n                    } else {\n                        CBlock block;\n                        bool ret = ReadBlockFromDisk(block, pBestIndex, consensusParams);\n                        assert(ret);\n                        CBlockHeaderAndShortTxIDs cmpctblock{block};\n                        m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::CMPCTBLOCK, cmpctblock));\n                    }\n                    state.pindexBestHeaderSent = pBestIndex;\n                } else if (peer->m_prefers_headers) {\n                    if (vHeaders.size() > 1) {\n                        LogPrint(BCLog::NET, \"%s: %u headers, range (%s, %s), to peer=%d\\n\", __func__,\n                                vHeaders.size(),\n                                vHeaders.front().GetHash().ToString(),\n                                vHeaders.back().GetHash().ToString(), pto->GetId());\n                    } else {\n                        LogPrint(BCLog::NET, \"%s: sending header %s to peer=%d\\n\", __func__,\n                                vHeaders.front().GetHash().ToString(), pto->GetId());\n                    }\n                    m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::HEADERS, vHeaders));\n                    state.pindexBestHeaderSent = pBestIndex;\n                } else\n                    fRevertToInv = true;\n            }\n            if (fRevertToInv) {\n                // If falling back to using an inv, just try to inv the tip.\n                // The last entry in m_blocks_for_headers_relay was our tip at some point\n                // in the past.\n                if (!peer->m_blocks_for_headers_relay.empty()) {\n                    const uint256& hashToAnnounce = peer->m_blocks_for_headers_relay.back();\n                    const CBlockIndex* pindex = m_chainman.m_blockman.LookupBlockIndex(hashToAnnounce);\n                    assert(pindex);\n\n                    // Warn if we're announcing a block that is not on the main chain.\n                    // This should be very rare and could be optimized out.\n                    // Just log for now.\n                    if (m_chainman.ActiveChain()[pindex->nHeight] != pindex) {\n                        LogPrint(BCLog::NET, \"Announcing block %s not on main chain (tip=%s)\\n\",\n                            hashToAnnounce.ToString(), m_chainman.ActiveChain().Tip()->GetBlockHash().ToString());\n                    }\n\n                    // If the peer's chain has this block, don't inv it back.\n                    if (!PeerHasHeader(&state, pindex)) {\n                        peer->m_blocks_for_inv_relay.push_back(hashToAnnounce);\n                        LogPrint(BCLog::NET, \"%s: sending inv peer=%d hash=%s\\n\", __func__,\n                            pto->GetId(), hashToAnnounce.ToString());\n                    }\n                }\n            }\n            peer->m_blocks_for_headers_relay.clear();\n        }\n\n        //\n        // Message: inventory\n        //\n        std::vector<CInv> vInv;\n        {\n            LOCK(peer->m_block_inv_mutex);\n            vInv.reserve(std::max<size_t>(peer->m_blocks_for_inv_relay.size(), INVENTORY_BROADCAST_MAX));\n\n            // Add blocks\n            for (const uint256& hash : peer->m_blocks_for_inv_relay) {\n                vInv.push_back(CInv(MSG_BLOCK, hash));\n                if (vInv.size() == MAX_INV_SZ) {\n                    m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n                    vInv.clear();\n                }\n            }\n            peer->m_blocks_for_inv_relay.clear();\n        }\n\n        if (auto tx_relay = peer->GetTxRelay(); tx_relay != nullptr) {\n                LOCK(tx_relay->m_tx_inventory_mutex);\n                // Check whether periodic sends should happen\n                bool fSendTrickle = pto->HasPermission(NetPermissionFlags::NoBan);\n                if (tx_relay->m_next_inv_send_time < current_time) {\n                    fSendTrickle = true;\n                    if (pto->IsInboundConn()) {\n                        tx_relay->m_next_inv_send_time = NextInvToInbounds(current_time, INBOUND_INVENTORY_BROADCAST_INTERVAL);\n                    } else {\n                        tx_relay->m_next_inv_send_time = GetExponentialRand(current_time, OUTBOUND_INVENTORY_BROADCAST_INTERVAL);\n                    }\n                }\n\n                // Time to send but the peer has requested we not relay transactions.\n                if (fSendTrickle) {\n                    LOCK(tx_relay->m_bloom_filter_mutex);\n                    if (!tx_relay->m_relay_txs) tx_relay->m_tx_inventory_to_send.clear();\n                }\n\n                // Respond to BIP35 mempool requests\n                if (fSendTrickle && tx_relay->m_send_mempool) {\n                    auto vtxinfo = m_mempool.infoAll();\n                    tx_relay->m_send_mempool = false;\n                    const CFeeRate filterrate{tx_relay->m_fee_filter_received.load()};\n\n                    LOCK(tx_relay->m_bloom_filter_mutex);\n\n                    for (const auto& txinfo : vtxinfo) {\n                        const uint256& hash = peer->m_wtxid_relay ? txinfo.tx->GetWitnessHash() : txinfo.tx->GetHash();\n                        CInv inv(peer->m_wtxid_relay ? MSG_WTX : MSG_TX, hash);\n                        tx_relay->m_tx_inventory_to_send.erase(hash);\n                        // Don't send transactions that peers will not put into their mempool\n                        if (txinfo.fee < filterrate.GetFee(txinfo.vsize)) {\n                            continue;\n                        }\n                        if (tx_relay->m_bloom_filter) {\n                            if (!tx_relay->m_bloom_filter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                        }\n                        tx_relay->m_tx_inventory_known_filter.insert(hash);\n                        // Responses to MEMPOOL requests bypass the m_recently_announced_invs filter.\n                        vInv.push_back(inv);\n                        if (vInv.size() == MAX_INV_SZ) {\n                            m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n                            vInv.clear();\n                        }\n                    }\n                    tx_relay->m_last_mempool_req = std::chrono::duration_cast<std::chrono::seconds>(current_time);\n                }\n\n                // Determine transactions to relay\n                if (fSendTrickle) {\n                    // Produce a vector with all candidates for sending\n                    std::vector<std::set<uint256>::iterator> vInvTx;\n                    vInvTx.reserve(tx_relay->m_tx_inventory_to_send.size());\n                    for (std::set<uint256>::iterator it = tx_relay->m_tx_inventory_to_send.begin(); it != tx_relay->m_tx_inventory_to_send.end(); it++) {\n                        vInvTx.push_back(it);\n                    }\n                    const CFeeRate filterrate{tx_relay->m_fee_filter_received.load()};\n                    // Topologically and fee-rate sort the inventory we send for privacy and priority reasons.\n                    // A heap is used so that not all items need sorting if only a few are being sent.\n                    CompareInvMempoolOrder compareInvMempoolOrder(&m_mempool, peer->m_wtxid_relay);\n                    std::make_heap(vInvTx.begin(), vInvTx.end(), compareInvMempoolOrder);\n                    // No reason to drain out at many times the network's capacity,\n                    // especially since we have many peers and some will draw much shorter delays.\n                    unsigned int nRelayedTransactions = 0;\n                    LOCK(tx_relay->m_bloom_filter_mutex);\n                    size_t broadcast_max{INVENTORY_BROADCAST_MAX + (tx_relay->m_tx_inventory_to_send.size()/1000)*5};\n                    broadcast_max = std::min<size_t>(1000, broadcast_max);\n                    while (!vInvTx.empty() && nRelayedTransactions < broadcast_max) {\n                        // Fetch the top element from the heap\n                        std::pop_heap(vInvTx.begin(), vInvTx.end(), compareInvMempoolOrder);\n                        std::set<uint256>::iterator it = vInvTx.back();\n                        vInvTx.pop_back();\n                        uint256 hash = *it;\n                        CInv inv(peer->m_wtxid_relay ? MSG_WTX : MSG_TX, hash);\n                        // Remove it from the to-be-sent set\n                        tx_relay->m_tx_inventory_to_send.erase(it);\n                        // Check if not in the filter already\n                        if (tx_relay->m_tx_inventory_known_filter.contains(hash)) {\n                            continue;\n                        }\n                        // Not in the mempool anymore? don't bother sending it.\n                        auto txinfo = m_mempool.info(ToGenTxid(inv));\n                        if (!txinfo.tx) {\n                            continue;\n                        }\n                        auto txid = txinfo.tx->GetHash();\n                        auto wtxid = txinfo.tx->GetWitnessHash();\n                        // Peer told you to not send transactions at that feerate? Don't bother sending it.\n                        if (txinfo.fee < filterrate.GetFee(txinfo.vsize)) {\n                            continue;\n                        }\n                        if (tx_relay->m_bloom_filter && !tx_relay->m_bloom_filter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                        // Send\n                        tx_relay->m_recently_announced_invs.insert(hash);\n                        vInv.push_back(inv);\n                        nRelayedTransactions++;\n                        {\n                            // Expire old relay messages\n                            while (!g_relay_expiration.empty() && g_relay_expiration.front().first < current_time)\n                            {\n                                mapRelay.erase(g_relay_expiration.front().second);\n                                g_relay_expiration.pop_front();\n                            }\n\n                            auto ret = mapRelay.emplace(txid, std::move(txinfo.tx));\n                            if (ret.second) {\n                                g_relay_expiration.emplace_back(current_time + RELAY_TX_CACHE_TIME, ret.first);\n                            }\n                            // Add wtxid-based lookup into mapRelay as well, so that peers can request by wtxid\n                            auto ret2 = mapRelay.emplace(wtxid, ret.first->second);\n                            if (ret2.second) {\n                                g_relay_expiration.emplace_back(current_time + RELAY_TX_CACHE_TIME, ret2.first);\n                            }\n                        }\n                        if (vInv.size() == MAX_INV_SZ) {\n                            m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n                            vInv.clear();\n                        }\n                        tx_relay->m_tx_inventory_known_filter.insert(hash);\n                        if (hash != txid) {\n                            // Insert txid into m_tx_inventory_known_filter, even for\n                            // wtxidrelay peers. This prevents re-adding of\n                            // unconfirmed parents to the recently_announced\n                            // filter, when a child tx is requested. See\n                            // ProcessGetData().\n                            tx_relay->m_tx_inventory_known_filter.insert(txid);\n                        }\n                    }\n                }\n        }\n        if (!vInv.empty())\n            m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n\n        // Detect whether we're stalling\n        auto stalling_timeout = m_block_stalling_timeout.load();\n        if (state.m_stalling_since.count() && state.m_stalling_since < current_time - stalling_timeout) {\n            // Stalling only triggers when the block download window cannot move. During normal steady state,\n            // the download window should be much larger than the to-be-downloaded set of blocks, so disconnection\n            // should only happen during initial block download.\n            LogPrintf(\"Peer=%d is stalling block download, disconnecting\\n\", pto->GetId());\n            pto->fDisconnect = true;\n            // Increase timeout for the next peer so that we don't disconnect multiple peers if our own\n            // bandwidth is insufficient.\n            const auto new_timeout = std::min(2 * stalling_timeout, BLOCK_STALLING_TIMEOUT_MAX);\n            if (stalling_timeout != new_timeout && m_block_stalling_timeout.compare_exchange_strong(stalling_timeout, new_timeout)) {\n                LogPrint(BCLog::NET, \"Increased stalling timeout temporarily to %d seconds\\n\", count_seconds(new_timeout));\n            }\n            return true;\n        }\n        // In case there is a block that has been in flight from this peer for block_interval * (1 + 0.5 * N)\n        // (with N the number of peers from which we're downloading validated blocks), disconnect due to timeout.\n        // We compensate for other peers to prevent killing off peers due to our own downstream link\n        // being saturated. We only count validated in-flight blocks so peers can't advertise non-existing block hashes\n        // to unreasonably increase our timeout.\n        if (state.vBlocksInFlight.size() > 0) {\n            QueuedBlock &queuedBlock = state.vBlocksInFlight.front();\n            int nOtherPeersWithValidatedDownloads = m_peers_downloading_from - 1;\n            if (current_time > state.m_downloading_since + std::chrono::seconds{consensusParams.nPowTargetSpacing} * (BLOCK_DOWNLOAD_TIMEOUT_BASE + BLOCK_DOWNLOAD_TIMEOUT_PER_PEER * nOtherPeersWithValidatedDownloads)) {\n                LogPrintf(\"Timeout downloading block %s from peer=%d, disconnecting\\n\", queuedBlock.pindex->GetBlockHash().ToString(), pto->GetId());\n                pto->fDisconnect = true;\n                return true;\n            }\n        }\n        // Check for headers sync timeouts\n        if (state.fSyncStarted && peer->m_headers_sync_timeout < std::chrono::microseconds::max()) {\n            // Detect whether this is a stalling initial-headers-sync peer\n            if (m_chainman.m_best_header->Time() <= GetAdjustedTime() - 24h) {\n                if (current_time > peer->m_headers_sync_timeout && nSyncStarted == 1 && (m_num_preferred_download_peers - state.fPreferredDownload >= 1)) {\n                    // Disconnect a peer (without NetPermissionFlags::NoBan permission) if it is our only sync peer,\n                    // and we have others we could be using instead.\n                    // Note: If all our peers are inbound, then we won't\n                    // disconnect our sync peer for stalling; we have bigger\n                    // problems if we can't get any outbound peers.\n                    if (!pto->HasPermission(NetPermissionFlags::NoBan)) {\n                        LogPrintf(\"Timeout downloading headers from peer=%d, disconnecting\\n\", pto->GetId());\n                        pto->fDisconnect = true;\n                        return true;\n                    } else {\n                        LogPrintf(\"Timeout downloading headers from noban peer=%d, not disconnecting\\n\", pto->GetId());\n                        // Reset the headers sync state so that we have a\n                        // chance to try downloading from a different peer.\n                        // Note: this will also result in at least one more\n                        // getheaders message to be sent to\n                        // this peer (eventually).\n                        state.fSyncStarted = false;\n                        nSyncStarted--;\n                        peer->m_headers_sync_timeout = 0us;\n                    }\n                }\n            } else {\n                // After we've caught up once, reset the timeout so we can't trigger\n                // disconnect later.\n                peer->m_headers_sync_timeout = std::chrono::microseconds::max();\n            }\n        }\n\n        // Check that outbound peers have reasonable chains\n        // GetTime() is used by this anti-DoS logic so we can test this using mocktime\n        ConsiderEviction(*pto, *peer, GetTime<std::chrono::seconds>());\n\n        //\n        // Message: getdata (blocks)\n        //\n        std::vector<CInv> vGetData;\n        if (CanServeBlocks(*peer) && ((sync_blocks_and_headers_from_peer && !IsLimitedPeer(*peer)) || !m_chainman.ActiveChainstate().IsInitialBlockDownload()) && state.nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n            std::vector<const CBlockIndex*> vToDownload;\n            NodeId staller = -1;\n            FindNextBlocksToDownload(*peer, MAX_BLOCKS_IN_TRANSIT_PER_PEER - state.nBlocksInFlight, vToDownload, staller);\n            for (const CBlockIndex *pindex : vToDownload) {\n                uint32_t nFetchFlags = GetFetchFlags(*peer);\n                vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));\n                BlockRequested(pto->GetId(), *pindex);\n                LogPrint(BCLog::NET, \"Requesting block %s (%d) peer=%d\\n\", pindex->GetBlockHash().ToString(),\n                    pindex->nHeight, pto->GetId());\n            }\n            if (state.nBlocksInFlight == 0 && staller != -1) {\n                if (State(staller)->m_stalling_since == 0us) {\n                    State(staller)->m_stalling_since = current_time;\n                    LogPrint(BCLog::NET, \"Stall started peer=%d\\n\", staller);\n                }\n            }\n        }\n\n        //\n        // Message: getdata (transactions)\n        //\n        std::vector<std::pair<NodeId, GenTxid>> expired;\n        auto requestable = m_txrequest.GetRequestable(pto->GetId(), current_time, &expired);\n        for (const auto& entry : expired) {\n            LogPrint(BCLog::NET, \"timeout of inflight %s %s from peer=%d\\n\", entry.second.IsWtxid() ? \"wtx\" : \"tx\",\n                entry.second.GetHash().ToString(), entry.first);\n        }\n        for (const GenTxid& gtxid : requestable) {\n            if (!AlreadyHaveTx(gtxid)) {\n                LogPrint(BCLog::NET, \"Requesting %s %s peer=%d\\n\", gtxid.IsWtxid() ? \"wtx\" : \"tx\",\n                    gtxid.GetHash().ToString(), pto->GetId());\n                vGetData.emplace_back(gtxid.IsWtxid() ? MSG_WTX : (MSG_TX | GetFetchFlags(*peer)), gtxid.GetHash());\n                if (vGetData.size() >= MAX_GETDATA_SZ) {\n                    m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n                    vGetData.clear();\n                }\n                m_txrequest.RequestedTx(pto->GetId(), gtxid.GetHash(), current_time + GETDATA_TX_INTERVAL);\n            } else {\n                // We have already seen this transaction, no need to download. This is just a belt-and-suspenders, as\n                // this should already be called whenever a transaction becomes AlreadyHaveTx().\n                m_txrequest.ForgetTxHash(gtxid.GetHash());\n            }\n        }\n\n\n        if (!vGetData.empty())\n            m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n    } // release cs_main\n    MaybeSendFeefilter(*pto, *peer, current_time);\n    return true;\n}", "target": 2, "idx": 11500}
{"commit_id": "21eae25a8db5fdcd112dbcfcd9e5c37e32d32e2f", "project": "ImageMagick", "func": "static MagickBooleanType SkipRGBMipmaps(Image *image,DDSInfo *dds_info,\n  int pixel_size,ExceptionInfo *exception)\n{\n  MagickOffsetType\n    offset;\n\n  register ssize_t\n    i;\n\n  size_t\n    h,\n    w;\n\n  /*\n    Only skip mipmaps for textures and cube maps\n  */\n  if (EOFBlob(image) != MagickFalse)\n    {\n      ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n        image->filename);\n      return(MagickFalse);\n    }\n  if (dds_info->ddscaps1 & DDSCAPS_MIPMAP\n      && (dds_info->ddscaps1 & DDSCAPS_TEXTURE\n          || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))\n    {\n      w = DIV2(dds_info->width);\n      h = DIV2(dds_info->height);\n\n      /*\n        Mipmapcount includes the main image, so start from one\n      */\n      for (i=1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)\n      {\n        offset = (MagickOffsetType) w * h * pixel_size;\n        (void) SeekBlob(image, offset, SEEK_CUR);\n\n        w = DIV2(w);\n        h = DIV2(h);\n      }\n    }\n  return(MagickTrue);\n}", "target": 1, "idx": 11501}
{"commit_id": "b1042c3eefca87c4bc32afb404ed6518d693e5be", "project": "gpac", "func": "int AVI_read_frame(avi_t *AVI, u8 *vidbuf, int *keyframe)\n{\n\tint n;\n\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\tif(!AVI->video_index)         {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\n\tif(AVI->video_pos < 0 || AVI->video_pos >= AVI->video_frames) return -1;\n\tn = (u32) AVI->video_index[AVI->video_pos].len;\n\n\t*keyframe = (AVI->video_index[AVI->video_pos].key==0x10) ? 1:0;\n\n\tif (vidbuf == NULL) {\n\t\tAVI->video_pos++;\n\t\treturn n;\n\t}\n\n\tgf_fseek(AVI->fdes, AVI->video_index[AVI->video_pos].pos, SEEK_SET);\n\tAVI->video_pos++;\n\n\tif (avi_read(AVI->fdes,vidbuf,n) != (u32) n)\n\t{\n\t\tAVI_errno = AVI_ERR_READ;\n\t\treturn -1;\n\t}\n\n\treturn n;\n}", "target": 1, "idx": 11502}
{"commit_id": "29b52a2856c00bae0f11492a124b8d6c1dd9b830", "project": "ImageMagick", "func": "static Image *ReadICONImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  IconFile\n    icon_file;\n\n  IconInfo\n    icon_info;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    extent;\n\n  register IndexPacket\n    *indexes;\n\n  register ssize_t\n    i,\n    x;\n\n  register PixelPacket\n    *q;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bit,\n    byte,\n    bytes_per_line,\n    one,\n    scanline_pad;\n\n  ssize_t\n    count,\n    offset,\n    y;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"%s\",image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  icon_file.reserved=(short) ReadBlobLSBShort(image);\n  icon_file.resource_type=(short) ReadBlobLSBShort(image);\n  icon_file.count=(short) ReadBlobLSBShort(image);\n  if ((icon_file.reserved != 0) ||\n      ((icon_file.resource_type != 1) && (icon_file.resource_type != 2)) ||\n      (icon_file.count > MaxIcons))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  extent=0;\n  for (i=0; i < icon_file.count; i++)\n  {\n    icon_file.directory[i].width=(unsigned char) ReadBlobByte(image);\n    icon_file.directory[i].height=(unsigned char) ReadBlobByte(image);\n    icon_file.directory[i].colors=(unsigned char) ReadBlobByte(image);\n    icon_file.directory[i].reserved=(unsigned char) ReadBlobByte(image);\n    icon_file.directory[i].planes=(unsigned short) ReadBlobLSBShort(image);\n    icon_file.directory[i].bits_per_pixel=(unsigned short)\n      ReadBlobLSBShort(image);\n    icon_file.directory[i].size=ReadBlobLSBLong(image);\n    icon_file.directory[i].offset=ReadBlobLSBLong(image);\n    if (EOFBlob(image) != MagickFalse)\n      break;\n    extent=MagickMax(extent,icon_file.directory[i].size);\n  }\n  if ((EOFBlob(image) != MagickFalse) || (extent > GetBlobSize(image)))\n    ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n  one=1;\n  for (i=0; i < icon_file.count; i++)\n  {\n    /*\n      Verify Icon identifier.\n    */\n    offset=(ssize_t) SeekBlob(image,(MagickOffsetType)\n      icon_file.directory[i].offset,SEEK_SET);\n    if (offset < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    icon_info.size=ReadBlobLSBLong(image);\n    icon_info.width=(unsigned char) ReadBlobLSBSignedLong(image);\n    icon_info.height=(unsigned char) (ReadBlobLSBSignedLong(image)/2);\n    icon_info.planes=ReadBlobLSBShort(image);\n    icon_info.bits_per_pixel=ReadBlobLSBShort(image);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    if (((icon_info.planes == 18505) && (icon_info.bits_per_pixel == 21060)) || \n        (icon_info.size == 0x474e5089))\n      {\n        Image\n          *icon_image;\n\n        ImageInfo\n          *read_info;\n\n        size_t\n          length;\n\n        unsigned char\n          *png;\n\n        /*\n          Icon image encoded as a compressed PNG image.\n        */\n        length=icon_file.directory[i].size;\n        if ((length < 16) || (~length < 16))\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        png=(unsigned char *) AcquireQuantumMemory(length+16,sizeof(*png));\n        if (png == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) CopyMagickMemory(png,\"\\211PNG\\r\\n\\032\\n\\000\\000\\000\\015\",12);\n        png[12]=(unsigned char) icon_info.planes;\n        png[13]=(unsigned char) (icon_info.planes >> 8);\n        png[14]=(unsigned char) icon_info.bits_per_pixel;\n        png[15]=(unsigned char) (icon_info.bits_per_pixel >> 8);\n        count=ReadBlob(image,length-16,png+16);\n        icon_image=(Image *) NULL;\n        if (count > 0)\n          {\n            read_info=CloneImageInfo(image_info);\n            (void) CopyMagickString(read_info->magick,\"PNG\",MaxTextExtent);\n            icon_image=BlobToImage(read_info,png,length+16,exception);\n            read_info=DestroyImageInfo(read_info);\n          }\n        png=(unsigned char *) RelinquishMagickMemory(png);\n        if (icon_image == (Image *) NULL)\n          {\n            if (count != (ssize_t) (length-16))\n              ThrowReaderException(CorruptImageError,\n                \"InsufficientImageDataInFile\");\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        DestroyBlob(icon_image);\n        icon_image->blob=ReferenceBlob(image->blob);\n        ReplaceImageInList(&image,icon_image);\n        icon_image->scene=i;\n      }\n    else\n      {\n        if (icon_info.bits_per_pixel > 32)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        icon_info.compression=ReadBlobLSBLong(image);\n        icon_info.image_size=ReadBlobLSBLong(image);\n        icon_info.x_pixels=ReadBlobLSBLong(image);\n        icon_info.y_pixels=ReadBlobLSBLong(image);\n        icon_info.number_colors=ReadBlobLSBLong(image);\n        icon_info.colors_important=ReadBlobLSBLong(image);\n        image->matte=MagickTrue;\n        image->columns=(size_t) icon_file.directory[i].width;\n        if ((ssize_t) image->columns > icon_info.width)\n          image->columns=(size_t) icon_info.width;\n        if (image->columns == 0)\n          image->columns=256;\n        image->rows=(size_t) icon_file.directory[i].height;\n        if ((ssize_t) image->rows > icon_info.height)\n          image->rows=(size_t) icon_info.height;\n        if (image->rows == 0)\n          image->rows=256;\n        image->depth=icon_info.bits_per_pixel;\n        if (image->debug != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \" scene    = %.20g\",(double) i);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   size   = %.20g\",(double) icon_info.size);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   width  = %.20g\",(double) icon_file.directory[i].width);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   height = %.20g\",(double) icon_file.directory[i].height);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   colors = %.20g\",(double ) icon_info.number_colors);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   planes = %.20g\",(double) icon_info.planes);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   bpp    = %.20g\",(double) icon_info.bits_per_pixel);\n          }\n      if ((icon_info.number_colors != 0) || (icon_info.bits_per_pixel <= 16U))\n        {\n          image->storage_class=PseudoClass;\n          image->colors=icon_info.number_colors;\n          if (image->colors == 0)\n            image->colors=one << icon_info.bits_per_pixel;\n        }\n      if (image->storage_class == PseudoClass)\n        {\n          register ssize_t\n            i;\n\n          unsigned char\n            *icon_colormap;\n\n          /*\n            Read Icon raster colormap.\n          */\n          if (AcquireImageColormap(image,image->colors) == MagickFalse)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          icon_colormap=(unsigned char *) AcquireQuantumMemory((size_t)\n            image->colors,4UL*sizeof(*icon_colormap));\n          if (icon_colormap == (unsigned char *) NULL)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          count=ReadBlob(image,(size_t) (4*image->colors),icon_colormap);\n          if (count != (ssize_t) (4*image->colors))\n            {\n              icon_colormap=(unsigned char *) RelinquishMagickMemory(\n                icon_colormap);\n              ThrowReaderException(CorruptImageError,\n                \"InsufficientImageDataInFile\");\n            }\n          p=icon_colormap;\n          for (i=0; i < (ssize_t) image->colors; i++)\n          {\n            image->colormap[i].blue=(Quantum) ScaleCharToQuantum(*p++);\n            image->colormap[i].green=(Quantum) ScaleCharToQuantum(*p++);\n            image->colormap[i].red=(Quantum) ScaleCharToQuantum(*p++);\n            p++;\n          }\n          icon_colormap=(unsigned char *) RelinquishMagickMemory(icon_colormap);\n        }\n        /*\n          Convert Icon raster image to pixel packets.\n        */\n        if ((image_info->ping != MagickFalse) &&\n            (image_info->number_scenes != 0))\n          if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n            break;\n        status=SetImageExtent(image,image->columns,image->rows);\n        if (status == MagickFalse)\n          {\n            InheritException(exception,&image->exception);\n            return(DestroyImageList(image));\n          }\n        bytes_per_line=(((image->columns*icon_info.bits_per_pixel)+31) &\n          ~31) >> 3;\n        (void) bytes_per_line;\n        scanline_pad=((((image->columns*icon_info.bits_per_pixel)+31) & ~31)-\n          (image->columns*icon_info.bits_per_pixel)) >> 3;\n        switch (icon_info.bits_per_pixel)\n        {\n          case 1:\n          {\n            /*\n              Convert bitmap scanline.\n            */\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              indexes=GetAuthenticIndexQueue(image);\n              for (x=0; x < (ssize_t) (image->columns-7); x+=8)\n              {\n                byte=(size_t) ReadBlobByte(image);\n                for (bit=0; bit < 8; bit++)\n                  SetPixelIndex(indexes+x+bit,((byte & (0x80 >> bit)) != 0 ?\n                    0x01 : 0x00));\n              }\n              if ((image->columns % 8) != 0)\n                {\n                  byte=(size_t) ReadBlobByte(image);\n                  for (bit=0; bit < (image->columns % 8); bit++)\n                    SetPixelIndex(indexes+x+bit,((byte & (0x80 >> bit)) != 0 ?\n                      0x01 : 0x00));\n                }\n              for (x=0; x < (ssize_t) scanline_pad; x++)\n                (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n                    image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          case 4:\n          {\n            /*\n              Read 4-bit Icon scanline.\n            */\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              indexes=GetAuthenticIndexQueue(image);\n              for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n              {\n                byte=(size_t) ReadBlobByte(image);\n                SetPixelIndex(indexes+x,((byte >> 4) & 0xf));\n                SetPixelIndex(indexes+x+1,((byte) & 0xf));\n              }\n              if ((image->columns % 2) != 0)\n                {\n                  byte=(size_t) ReadBlobByte(image);\n                  SetPixelIndex(indexes+x,((byte >> 4) & 0xf));\n                }\n              for (x=0; x < (ssize_t) scanline_pad; x++)\n                (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n                    image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          case 8:\n          {\n            /*\n              Convert PseudoColor scanline.\n            */\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              indexes=GetAuthenticIndexQueue(image);\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                byte=(size_t) ReadBlobByte(image);\n                SetPixelIndex(indexes+x,byte);\n              }\n              for (x=0; x < (ssize_t) scanline_pad; x++)\n                (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n                    image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          case 16:\n          {\n            /*\n              Convert PseudoColor scanline.\n            */\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              indexes=GetAuthenticIndexQueue(image);\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                byte=(size_t) ReadBlobByte(image);\n                byte|=(size_t) (ReadBlobByte(image) << 8);\n                SetPixelIndex(indexes+x,byte);\n              }\n              for (x=0; x < (ssize_t) scanline_pad; x++)\n                (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n                    image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          case 24:\n          case 32:\n          {\n            /*\n              Convert DirectColor scanline.\n            */\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelBlue(q,ScaleCharToQuantum((unsigned char)\n                  ReadBlobByte(image)));\n                SetPixelGreen(q,ScaleCharToQuantum((unsigned char)\n                  ReadBlobByte(image)));\n                SetPixelRed(q,ScaleCharToQuantum((unsigned char)\n                  ReadBlobByte(image)));\n                if (icon_info.bits_per_pixel == 32)\n                  SetPixelAlpha(q,ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image)));\n                q++;\n              }\n              if (icon_info.bits_per_pixel == 24)\n                for (x=0; x < (ssize_t) scanline_pad; x++)\n                  (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n                    image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          default:\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        }\n        if ((image_info->ping == MagickFalse) &&\n            (icon_info.bits_per_pixel <= 16))\n          (void) SyncImage(image);\n        if (icon_info.bits_per_pixel != 32)\n          {\n            /*\n              Read the ICON alpha mask.\n            */\n            image->storage_class=DirectClass;\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n              {\n                byte=(size_t) ReadBlobByte(image);\n                for (bit=0; bit < 8; bit++)\n                  SetPixelOpacity(q+x+bit,(((byte & (0x80 >> bit)) != 0) ?\n                    TransparentOpacity : OpaqueOpacity));\n              }\n              if ((image->columns % 8) != 0)\n                {\n                  byte=(size_t) ReadBlobByte(image);\n                  for (bit=0; bit < (image->columns % 8); bit++)\n                    SetPixelOpacity(q+x+bit,(((byte & (0x80 >> bit)) != 0) ?\n                      TransparentOpacity : OpaqueOpacity));\n                }\n              if ((image->columns % 32) != 0)\n                for (x=0; x < (ssize_t) ((32-(image->columns % 32))/8); x++)\n                  (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n            }\n          }\n        if (EOFBlob(image) != MagickFalse)\n          {\n            ThrowFileException(exception,CorruptImageError,\n              \"UnexpectedEndOfFile\",image->filename);\n            break;\n          }\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (i < (ssize_t) (icon_file.count-1))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}", "target": 1, "idx": 11503}
{"commit_id": "42f299be6abb302f32cec78b1c0812364c9f9285", "project": "wireshark", "func": "static void iax2_add_ts_fields(packet_info *pinfo, proto_tree *iax2_tree, iax_packet_data *iax_packet, guint16 shortts)\n{\n  guint32     longts =shortts;\n  nstime_t    ts;\n  proto_item *item;\n\n  if (iax_packet->call_data == NULL) {\n    /* no call info for this frame; perhaps we missed the NEW packet */\n    return;\n  }\n\n  if (iax_packet->abstime.secs == -1) {\n    time_t start_secs = iax_packet->call_data->start_time.secs;\n    time_t abs_secs = start_secs + longts/1000;\n\n    /* deal with short timestamps by assuming that packets are never more than\n     * 16 seconds late */\n    while(abs_secs < pinfo->abs_ts.secs - 16) {\n      longts += 32768;\n      abs_secs = start_secs + longts/1000;\n    }\n\n    iax_packet->abstime.secs=abs_secs;\n    iax_packet->abstime.nsecs=iax_packet->call_data->start_time.nsecs + (longts % 1000) * 1000000;\n    if (iax_packet->abstime.nsecs >= 1000000000) {\n      iax_packet->abstime.nsecs -= 1000000000;\n      iax_packet->abstime.secs ++;\n    }\n  }\n  iax2_info->timestamp = longts;\n\n  if (iax2_tree) {\n    item = proto_tree_add_time(iax2_tree, hf_iax2_absts, NULL, 0, 0, &iax_packet->abstime);\n    PROTO_ITEM_SET_GENERATED(item);\n\n    ts  = pinfo->abs_ts;\n    nstime_delta(&ts, &ts, &iax_packet->abstime);\n\n    item = proto_tree_add_time(iax2_tree, hf_iax2_lateness, NULL, 0, 0, &ts);\n    PROTO_ITEM_SET_GENERATED(item);\n  }\n}", "target": 1, "idx": 11504}
{"commit_id": "7a6f636db3360bb16d18078d51e8c596f31302a1", "project": "gpac", "func": "Bool isor_declare_item_properties(ISOMReader *read, ISOMChannel *ch, u32 item_idx)\n{\n\tGF_ImageItemProperties props;\n\tGF_FilterPid *pid;\n\tGF_ESD *esd;\n\tu32 item_id=0;\n\tu32 scheme_type=0, scheme_version=0, item_type;\n\tu32 item_codecid=0;\n\tconst char *item_name, *item_mime_type, *item_encoding;\n\nretry:\n\n\tif (item_idx>gf_isom_get_meta_item_count(read->mov, GF_TRUE, 0))\n\t\treturn GF_FALSE;\n\n\titem_name = item_mime_type = item_encoding = NULL;\n\tgf_isom_get_meta_item_info(read->mov, GF_TRUE, 0, item_idx, &item_id, &item_type, &scheme_type, &scheme_version, NULL, NULL, NULL, &item_name, &item_mime_type, &item_encoding);\n\n\tif (!item_id) return GF_FALSE;\n\tif (item_type==GF_ISOM_ITEM_TYPE_AUXI) return GF_FALSE;\n\tif (read->play_only_track_id && (read->play_only_track_id!=item_id)) return GF_FALSE;\n\n\tgf_isom_get_meta_image_props(read->mov, GF_TRUE, 0, item_id, &props, NULL);\n\n\t//check we support the protection scheme\n\tswitch (scheme_type) {\n\tcase GF_ISOM_CBC_SCHEME:\n\tcase GF_ISOM_CENS_SCHEME:\n\tcase GF_ISOM_CBCS_SCHEME:\n\tcase GF_ISOM_CENC_SCHEME:\n\tcase GF_ISOM_PIFF_SCHEME:\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n\n\n\tesd = gf_media_map_item_esd(read->mov, item_id);\n\tif (!esd) {\n\t\tswitch (item_type) {\n\t\tcase GF_ISOM_SUBTYPE_HVT1:\n\t\t\titem_codecid = GF_CODECID_HEVC_TILES;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t//unsupported item, try next\n\t\t\titem_idx++;\n\t\t\tgoto retry;\n\t\t}\n\t} else {\n\t\titem_codecid = esd->decoderConfig->objectTypeIndication;\n\t}\n\n\t//OK declare PID\n\tif (!ch)\n\t\tpid = gf_filter_pid_new(read->filter);\n\telse {\n\t\tpid = ch->pid;\n\t\tch->item_id = item_id;\n\t}\n\n\n\t//do not override PID ID if itt is set\n\tif (!ch) {\n\t\tif (read->pid)\n\t\t\tgf_filter_pid_copy_properties(pid, read->pid);\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_ID, &PROP_UINT(esd ? esd->ESID : item_id));\n\t}\n\n\tif (read->itemid)\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_ITEM_ID, &PROP_UINT(item_id));\n\n\tif ((item_codecid==GF_CODECID_HEVC) && gf_isom_meta_item_has_ref(read->mov, GF_TRUE, 0, item_id, GF_ISOM_REF_TBAS)) {\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_TILE_BASE, &PROP_BOOL(GF_TRUE));\n\t}\n\n\n\t//TODO: no support for LHEVC images\n\t//gf_filter_pid_set_property(pid, GF_PROP_PID_DEPENDENCY_ID, &PROP_UINT(esd->dependsOnESID));\n\n\tgf_filter_pid_set_property(pid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_VISUAL));\n\tgf_filter_pid_set_property(pid, GF_PROP_PID_CODECID, &PROP_UINT(item_codecid));\n\tgf_filter_pid_set_property(pid, GF_PROP_PID_TIMESCALE, &PROP_UINT(1000));\n\tif (esd) {\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_TIMESCALE, &PROP_UINT(1000));\n\t\tif (esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data) {\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA_NO_COPY(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength));\n\n\t\t\tesd->decoderConfig->decoderSpecificInfo->data=NULL;\n\t\t\tesd->decoderConfig->decoderSpecificInfo->dataLength=0;\n\t\t}\n\t\tgf_odf_desc_del((GF_Descriptor *)esd);\n\t}\n\n\tif (props.width && props.height) {\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_WIDTH, &PROP_UINT(props.width));\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_HEIGHT, &PROP_UINT(props.height));\n\t}\n\n\tgf_filter_pid_set_property(pid, GF_PROP_PID_HIDDEN, props.hidden ? &PROP_BOOL(GF_TRUE) : NULL);\n\tgf_filter_pid_set_property(pid, GF_PROP_PID_ALPHA, props.alpha ? &PROP_BOOL(GF_TRUE) : NULL);\n\tgf_filter_pid_set_property(pid, GF_PROP_PID_MIRROR, props.mirror ? &PROP_UINT(props.mirror) : NULL);\n\tgf_filter_pid_set_property(pid, GF_PROP_PID_ROTATE, props.alpha ? &PROP_UINT(props.angle) : NULL);\n\n\tif (props.clap_wden) {\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CLAP_W, &PROP_FRAC_INT(props.clap_wnum,props.clap_wden) );\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CLAP_H, &PROP_FRAC_INT(props.clap_hnum,props.clap_hden) );\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CLAP_X, &PROP_FRAC_INT(props.clap_honum,props.clap_hoden) );\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CLAP_Y, &PROP_FRAC_INT(props.clap_vonum,props.clap_voden) );\n\t} else {\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CLAP_W, NULL);\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CLAP_H, NULL);\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CLAP_X, NULL);\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CLAP_Y, NULL);\n\t}\n\n\tif (gf_isom_get_meta_primary_item_id(read->mov, GF_TRUE, 0) == item_id) {\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_PRIMARY_ITEM, &PROP_BOOL(GF_TRUE));\n\t} else {\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_PRIMARY_ITEM, &PROP_BOOL(GF_FALSE));\n\t}\n\n\tif (!gf_sys_is_test_mode() && !read->itt)\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_ITEM_NUM, &PROP_UINT(item_idx) );\n\n\tgf_filter_pid_set_property_str(pid, \"meta:mime\", item_mime_type ? &PROP_STRING(item_mime_type) : NULL );\n\tgf_filter_pid_set_property_str(pid, \"meta:name\", item_name ? &PROP_STRING(item_name) : NULL );\n\tgf_filter_pid_set_property_str(pid, \"meta:encoding\", item_encoding ? &PROP_STRING(item_encoding) : NULL );\n\n\tif ((item_type == GF_ISOM_SUBTYPE_UNCV) || (item_type == GF_ISOM_ITEM_TYPE_UNCI)) {\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_PIXFMT, &PROP_UINT(GF_PIXEL_UNCV) );\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CODECID, &PROP_UINT(GF_CODECID_RAW_UNCV) );\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_ISOM_SUBTYPE,  &PROP_4CC(GF_ISOM_ITEM_TYPE_UNCI) );\n\t}\n\n\tif (item_codecid == GF_CODECID_HEVC_TILES) {\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CROP_POS, &PROP_VEC2I_INT(props.hOffset, props.vOffset) );\n\n\t\tu32 base_id = gf_isom_meta_get_item_ref_id(read->mov, GF_TRUE, 0, item_id, GF_ISOM_REF_TBAS, 1);\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_DEPENDENCY_ID, base_id ? &PROP_UINT(base_id) : NULL );\n\t}\n\n\t//setup cenc\n\tif (scheme_type) {\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_PROTECTION_SCHEME_TYPE, &PROP_4CC(scheme_type) );\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_PROTECTION_SCHEME_VERSION, &PROP_UINT(scheme_version) );\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_ENCRYPTED, &PROP_BOOL(GF_TRUE) );\n\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_ORIG_STREAM_TYPE, &PROP_UINT(GF_STREAM_VISUAL));\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_ENCRYPTED) );\n\t}\n\n\tif (!ch) {\n\t\tch = isor_create_channel(read, pid, 0, item_id, GF_FALSE);\n\t\tif (ch && scheme_type) {\n\t\t\tch->is_cenc = 1;\n\t\t\tch->is_encrypted = 1;\n\n\t\t\tisor_declare_pssh(ch);\n\n\t\t}\n\t}\n\treturn GF_TRUE;\n}", "target": 1, "idx": 11505}
{"commit_id": "2e1198672759eda6e122ff38fcf6df06f27e0fe2", "project": "qemu", "func": "static void stellaris_enet_class_init(ObjectClass *klass, void *data)\n{\n    DeviceClass *dc = DEVICE_CLASS(klass);\n    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);\n\n    k->init = stellaris_enet_init;\n    dc->unrealize = stellaris_enet_unrealize;\n    dc->props = stellaris_enet_properties;\n    dc->vmsd = &vmstate_stellaris_enet;\n}", "target": 2, "idx": 11506}
{"commit_id": "755d3f9debf8879448211fffb018f556136f6a79", "project": "xen-project/xen", "func": "int domain_memory_add(unsigned int domid, int mem, bool no_quota_check)\n{\n\tstruct domain *domain;\n\n\tdomain = find_domain_struct(domid);\n\tif (domain) {\n\t\t/*\n\t\t * domain_chk_quota() will print warning and also store whether\n\t\t * the soft/hard quota has been hit. So check no_quota_check\n\t\t * *after*.\n\t\t */\n\t\tif (domain_chk_quota(domain, domain->memory + mem) &&\n\t\t    !no_quota_check)\n\t\t\treturn ENOMEM;\n\t\tdomain->memory += mem;\n\t} else {\n\t\t/*\n\t\t * The domain the memory is to be accounted for should always\n\t\t * exist, as accounting is done either for a domain related to\n\t\t * the current connection, or for the domain owning a node\n\t\t * (which is always existing, as the owner of the node is\n\t\t * tested to exist and deleted or replaced by domid 0 if not).\n\t\t * So not finding the related domain MUST be an error in the\n\t\t * data base.\n\t\t */\n\t\terrno = ENOENT;\n\t\tcorrupt(NULL, \"Accounting called for non-existing domain %u\\n\",\n\t\t\tdomid);\n\t\treturn ENOENT;\n\t}\n\n\treturn 0;\n}", "target": 1, "idx": 11507}
{"commit_id": "6d2fd968d8d520283b96986945a1b91c8a60131b", "project": "appneta/tcpreplay", "func": "int _our_safe_pcap_next_ex(pcap_t *pcap, struct pcap_pkthdr **pkthdr,\n        const u_char **pktdata, const char *funcname,\n        const int line, const char *file)\n{\n    int res = pcap_next_ex(pcap, pkthdr, pktdata);\n\n    if (*pktdata && *pkthdr) {\n        if ((*pkthdr)->len > MAXPACKET) {\n            fprintf(stderr, \"safe_pcap_next_ex ERROR: Invalid packet length in %s:%s() line %d: %u is greater than maximum %u\\n\",\n                    file, funcname, line, (*pkthdr)->len, MAXPACKET);\n            exit(-1);\n        }\n\n        if ((*pkthdr)->len < (*pkthdr)->caplen) {\n            fprintf(stderr, \"safe_pcap_next_ex ERROR: Invalid packet length in %s:%s() line %d: packet length %u is less than capture length %u\\n\",\n                    file, funcname, line, (*pkthdr)->len, (*pkthdr)->caplen);\n            exit(-1);\n        }\n    }\n\n    return res;\n}", "target": 2, "idx": 11508}
{"commit_id": "beba892bc0d4e4ded4d667ab1d2a94f4d75109a9", "project": "libtom/libtommath", "func": "mp_err s_mp_mul_digs(const mp_int *a, const mp_int *b, mp_int *c, int digs)\n{\n   mp_int  t;\n   mp_err  err;\n   int     pa, pb, ix, iy;\n   mp_digit u;\n   mp_word r;\n   mp_digit tmpx, *tmpt, *tmpy;\n\n   if (digs < 0) {\n      return MP_VAL;\n   }\n\n   /* can we use the fast multiplier? */\n   if ((digs < MP_WARRAY) &&\n       (MP_MIN(a->used, b->used) < MP_MAXFAST)) {\n      return s_mp_mul_digs_fast(a, b, c, digs);\n   }\n\n   if ((err = mp_init_size(&t, digs)) != MP_OKAY) {\n      return err;\n   }\n   t.used = digs;\n\n   /* compute the digits of the product directly */\n   pa = a->used;\n   for (ix = 0; ix < pa; ix++) {\n      /* set the carry to zero */\n      u = 0;\n\n      /* limit ourselves to making digs digits of output */\n      pb = MP_MIN(b->used, digs - ix);\n\n      /* setup some aliases */\n      /* copy of the digit from a used within the nested loop */\n      tmpx = a->dp[ix];\n\n      /* an alias for the destination shifted ix places */\n      tmpt = t.dp + ix;\n\n      /* an alias for the digits of b */\n      tmpy = b->dp;\n\n      /* compute the columns of the output and propagate the carry */\n      for (iy = 0; iy < pb; iy++) {\n         /* compute the column as a mp_word */\n         r       = (mp_word)*tmpt +\n                   ((mp_word)tmpx * (mp_word)*tmpy++) +\n                   (mp_word)u;\n\n         /* the new column is the lower part of the result */\n         *tmpt++ = (mp_digit)(r & (mp_word)MP_MASK);\n\n         /* get the carry word from the result */\n         u       = (mp_digit)(r >> (mp_word)MP_DIGIT_BIT);\n      }\n      /* set carry if it is placed below digs */\n      if ((ix + iy) < digs) {\n         *tmpt = u;\n      }\n   }\n\n   mp_clamp(&t);\n   mp_exch(&t, c);\n\n   mp_clear(&t);\n   return MP_OKAY;\n}", "target": 3, "idx": 11509}
{"commit_id": "c1592a89942e9678f7d9c8030efa777c0d57edab", "project": "torvalds/linux", "func": "static void nft_lookup_activate(const struct nft_ctx *ctx,\n\t\t\t\tconst struct nft_expr *expr)\n{\n\tstruct nft_lookup *priv = nft_expr_priv(expr);\n\n\tnf_tables_activate_set(ctx, priv->set);\n}", "target": 2, "idx": 11510}
{"commit_id": "33aa7f07d54ae066f201c6d298cb4a2181cb90e6", "project": "openrazer", "func": "int razer_get_usb_response(struct usb_device *usb_dev, uint report_index, struct razer_report* request_report, uint response_index, struct razer_report* response_report, ulong wait_min, ulong wait_max)\n{\n    uint request = HID_REQ_GET_REPORT; // 0x01\n    uint request_type = USB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_IN; // 0xA1\n    uint value = 0x300;\n\n    uint size = RAZER_USB_REPORT_LEN; // 0x90\n    int len;\n    int retval;\n    int result = 0;\n    char *buf;\n\n    buf = kzalloc(sizeof(struct razer_report), GFP_KERNEL);\n    if (buf == NULL)\n        return -ENOMEM;\n\n    // Send the request to the device.\n    // TODO look to see if index needs to be different for the request and the response\n    retval = razer_send_control_msg(usb_dev, request_report, report_index, wait_min, wait_max);\n\n    // Now ask for response\n    len = usb_control_msg(usb_dev, usb_rcvctrlpipe(usb_dev, 0),\n                          request,         // Request\n                          request_type,    // RequestType\n                          value,           // Value\n                          response_index,  // Index\n                          buf,             // Data\n                          size,\n                          USB_CTRL_SET_TIMEOUT);\n\n    memcpy(response_report, buf, sizeof(struct razer_report));\n    kfree(buf);\n\n    // Error if report is wrong length\n    if(len != 90) {\n        printk(KERN_WARNING \"razer driver: Invalid USB response. USB Report length: %d\\n\", len);\n        result = 1;\n    }\n\n    if (WARN_ONCE(response_report->data_size > ARRAY_SIZE(response_report->arguments),\n                  \"Field data_size %d in response is bigger than arguments\\n\",\n                  response_report->data_size)) {\n        /* Sanitize the value since at the moment callers don't respect the return code */\n        response_report->data_size = ARRAY_SIZE(response_report->arguments);\n        return -EINVAL;\n    }\n\n    return result;\n}", "target": 1, "idx": 11511}
{"commit_id": "bea84e2844b647532a9b7fbc3a6a8989d66e49e3", "project": "ValveSoftware/GameNetworkingSockets", "func": "bool AES_GCM_DecryptContext::Decrypt(\n\tconst void *pEncryptedDataAndTag, size_t cbEncryptedDataAndTag,\n\tconst void *pIV,\n\tvoid *pPlaintextData, uint32 *pcbPlaintextData,\n\tconst void *pAdditionalAuthenticationData, size_t cbAuthenticationData\n) {\n\t// Make sure caller's buffer is big enough to hold the result\n\tif ( cbEncryptedDataAndTag > *pcbPlaintextData + crypto_aead_aes256gcm_ABYTES )\n\t{\n\t\t*pcbPlaintextData = 0;\n\t\treturn false;\n\t}\n\n    unsigned long long cbPlaintextData_longlong;\n    const int nDecryptResult = crypto_aead_aes256gcm_decrypt_afternm(\n\t\tstatic_cast<unsigned char*>( pPlaintextData ), &cbPlaintextData_longlong,\n\t\tnullptr,\n\t\tstatic_cast<const unsigned char*>( pEncryptedDataAndTag ), cbEncryptedDataAndTag,\n\t\tstatic_cast<const unsigned char*>( pAdditionalAuthenticationData ), cbAuthenticationData,\n\t\tstatic_cast<const unsigned char*>( pIV ), static_cast<const crypto_aead_aes256gcm_state*>( m_ctx )\n\t);\n\n    *pcbPlaintextData = cbPlaintextData_longlong;\n\n    return nDecryptResult == 0;\n}", "target": 3, "idx": 11512}
{"commit_id": "0daec57f5cfc4225aa4527b537b4ec4fbbc35635", "project": "mumble-voip/mumble", "func": "void Server::msgVersion(ServerUser *uSource, MumbleProto::Version &msg) {\n\tRATELIMIT(uSource);\n\n\tif (msg.has_version())\n\t\tuSource->uiVersion=msg.version();\n\tif (msg.has_release())\n\t\tuSource->qsRelease = u8(msg.release());\n\tif (msg.has_os()) {\n\t\tuSource->qsOS = u8(msg.os());\n\t\tif (msg.has_os_version())\n\t\t\tuSource->qsOSVersion = u8(msg.os_version());\n\t}\n\n\tlog(uSource, QString(\"Client version %1 (%2: %3)\").arg(MumbleVersion::toString(uSource->uiVersion)).arg(uSource->qsOS).arg(uSource->qsRelease));\n}", "target": 2, "idx": 11513}
{"commit_id": "6a748ccc3f76ff10e3ae43014967ea4b0c088aaf", "project": "gpac", "func": "void id3dmx_flush(GF_Filter *filter, u8 *id3_buf, u32 id3_buf_size, GF_FilterPid *audio_pid, GF_FilterPid **video_pid_p)\n{\n\tGF_BitStream *bs = gf_bs_new(id3_buf, id3_buf_size, GF_BITSTREAM_READ);\n\tchar *sep_desc;\n\tchar *_buf=NULL;\n\tu32 buf_alloc=0;\n\tgf_bs_skip_bytes(bs, 3);\n\t/*u8 major = */gf_bs_read_u8(bs);\n\t/*u8 minor = */gf_bs_read_u8(bs);\n\t/*u8 unsync = */gf_bs_read_int(bs, 1);\n\tu8 ext_hdr = gf_bs_read_int(bs, 1);\n\tgf_bs_read_int(bs, 6);\n\tu32 size = gf_id3_read_size(bs);\n\n\n\tif (ext_hdr) {\n\n\t}\n\n\twhile (size && (gf_bs_available(bs)>=10) ) {\n\t\tchar *buf;\n\t\tchar szTag[1024];\n\t\tchar *sep;\n\t\ts32 tag_idx;\n\t\tu32 pic_size;\n\t\t//u32 pic_type;\n\t\tu32 ftag = gf_bs_read_u32(bs);\n\t\tu32 fsize = gf_id3_read_size(bs);\n\t\t/*u16 fflags = */gf_bs_read_u16(bs);\n\n\t\tsize -= 10;\n\t\tif (!fsize)\n\t\t\tbreak;\n\n\t\tif (size<fsize) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MP3Dmx] Broken ID3 frame tag %s, size %d but remaining bytes %d\\n\", gf_4cc_to_str(ftag), fsize, size));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (buf_alloc <= fsize+2) {\n\t\t\t_buf = gf_realloc(_buf, fsize+3);\n\t\t\tbuf_alloc = fsize+3;\n\t\t}\n\t\t//read into _buf+1 so that buf+1 is always %2 mem aligned as it can be loaded as unsigned short\n\t\tgf_bs_read_data(bs, _buf+1, fsize);\n\t\t_buf[fsize+1]=0;\n\t\t_buf[fsize+2]=0;\n\t\tbuf = _buf+1;\n\n\t\ttag_idx = gf_itags_find_by_id3tag(ftag);\n\n\t\tif (ftag==GF_ID3V2_FRAME_TXXX) {\n\t\t\tsep = memchr(buf, 0, fsize);\n\t\t\tif (sep) {\n\t\t\t\tif (!stricmp(buf+1, \"comment\")) {\n\t\t\t\t\tid3dmx_set_string(audio_pid, \"comment\", sep+1, GF_FALSE);\n\t\t\t\t} else {\n\t\t\t\t\tstrcpy(szTag, \"tag_\");\n\t\t\t\t\tstrncat(szTag, buf+1, 1019);\n\t\t\t\t\tid3dmx_set_string(audio_pid, szTag, sep+1, GF_TRUE);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (ftag == GF_ID3V2_FRAME_APIC) {\n\t\t\t//first char is text encoding\n\t\t\t//then mime\n\t\t\tsep = memchr(buf+1, 0, fsize-1);\n\t\t\t/*pic_type = sep[1];*/\n\t\t\tsep_desc = memchr(sep+2, 0, fsize-1);\n\n\t\t\tif (sep_desc) {\n\t\t\t\tGF_Err e;\n\t\t\t\tpic_size = (u32) ( (sep_desc + 1) - buf);\n\t\t\t\tpic_size = fsize - pic_size;\n\n\t\t\t\tif (video_pid_p) {\n\t\t\t\t\te = gf_filter_pid_raw_new(filter, NULL, NULL, buf+1, NULL, sep_desc+1, pic_size, GF_FALSE, video_pid_p);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MP3Dmx] error setting up video pid for cover art: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\t\t}\n\t\t\t\t\tif (*video_pid_p) {\n\t\t\t\t\t\tu8 *out_buffer;\n\t\t\t\t\t\tGF_FilterPacket *dst_pck;\n\t\t\t\t\t\tgf_filter_pid_set_name(*video_pid_p, \"CoverArt\");\n\t\t\t\t\t\tgf_filter_pid_set_property(*video_pid_p, GF_PROP_PID_COVER_ART, &PROP_BOOL(GF_TRUE));\n\t\t\t\t\t\tdst_pck = gf_filter_pck_new_alloc(*video_pid_p, pic_size, &out_buffer);\n\t\t\t\t\t\tif (dst_pck) {\n\t\t\t\t\t\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);\n\t\t\t\t\t\t\tmemcpy(out_buffer, sep_desc+1, pic_size);\n\t\t\t\t\t\t\tgf_filter_pck_send(dst_pck);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgf_filter_pid_set_eos(*video_pid_p);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tgf_filter_pid_set_property(audio_pid, GF_PROP_PID_COVER_ART, &PROP_DATA(sep_desc+1, pic_size) );\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (tag_idx>=0) {\n\t\t\tconst char *tag_name = gf_itags_get_name((u32) tag_idx);\n\t\t\tid3dmx_set_string(audio_pid, (char *) tag_name, buf+1, GF_FALSE);\n\t\t} else {\n\t\t\tsprintf(szTag, \"tag_%s\", gf_4cc_to_str(ftag));\n\t\t\tif ((ftag>>24) == 'T') {\n\t\t\t\tid3dmx_set_string(audio_pid, szTag, buf+1, GF_TRUE);\n\t\t\t} else {\n\t\t\t\tgf_filter_pid_set_property_dyn(audio_pid, szTag, &PROP_DATA(buf, fsize) );\n\t\t\t}\n\t\t}\n\t\tsize -= fsize;\n\t}\n\tgf_bs_del(bs);\n\tif (_buf) gf_free(_buf);\n}", "target": 0, "idx": 11514}
{"commit_id": "87d6bef033062f969e70fa40c43dfd945d5a20ab", "project": "the-tcpdump-group/libpcap", "func": "pcap_t *\npcap_ng_check_header(const uint8_t *magic, FILE *fp, u_int precision,\n    char *errbuf, int *err)\n{\n\tbpf_u_int32 magic_int;\n\tsize_t amt_read;\n\tbpf_u_int32 total_length;\n\tbpf_u_int32 byte_order_magic;\n\tstruct block_header *bhdrp;\n\tstruct section_header_block *shbp;\n\tpcap_t *p;\n\tint swapped = 0;\n\tstruct pcap_ng_sf *ps;\n\tint status;\n\tstruct block_cursor cursor;\n\tstruct interface_description_block *idbp;\n\n\t/*\n\t * Assume no read errors.\n\t */\n\t*err = 0;\n\n\t/*\n\t * Check whether the first 4 bytes of the file are the block\n\t * type for a pcapng savefile.\n\t */\n\tmemcpy(&magic_int, magic, sizeof(magic_int));\n\tif (magic_int != BT_SHB) {\n\t\t/*\n\t\t * XXX - check whether this looks like what the block\n\t\t * type would be after being munged by mapping between\n\t\t * UN*X and DOS/Windows text file format and, if it\n\t\t * does, look for the byte-order magic number in\n\t\t * the appropriate place and, if we find it, report\n\t\t * this as possibly being a pcapng file transferred\n\t\t * between UN*X and Windows in text file format?\n\t\t */\n\t\treturn (NULL);\t/* nope */\n\t}\n\n\t/*\n\t * OK, they are.  However, that's just \\n\\r\\r\\n, so it could,\n\t * conceivably, be an ordinary text file.\n\t *\n\t * It could not, however, conceivably be any other type of\n\t * capture file, so we can read the rest of the putative\n\t * Section Header Block; put the block type in the common\n\t * header, read the rest of the common header and the\n\t * fixed-length portion of the SHB, and look for the byte-order\n\t * magic value.\n\t */\n\tamt_read = fread(&total_length, 1, sizeof(total_length), fp);\n\tif (amt_read < sizeof(total_length)) {\n\t\tif (ferror(fp)) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"error reading dump file\");\n\t\t\t*err = 1;\n\t\t\treturn (NULL);\t/* fail */\n\t\t}\n\n\t\t/*\n\t\t * Possibly a weird short text file, so just say\n\t\t * \"not pcapng\".\n\t\t */\n\t\treturn (NULL);\n\t}\n\tamt_read = fread(&byte_order_magic, 1, sizeof(byte_order_magic), fp);\n\tif (amt_read < sizeof(byte_order_magic)) {\n\t\tif (ferror(fp)) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"error reading dump file\");\n\t\t\t*err = 1;\n\t\t\treturn (NULL);\t/* fail */\n\t\t}\n\n\t\t/*\n\t\t * Possibly a weird short text file, so just say\n\t\t * \"not pcapng\".\n\t\t */\n\t\treturn (NULL);\n\t}\n\tif (byte_order_magic != BYTE_ORDER_MAGIC) {\n\t\tbyte_order_magic = SWAPLONG(byte_order_magic);\n\t\tif (byte_order_magic != BYTE_ORDER_MAGIC) {\n\t\t\t/*\n\t\t\t * Not a pcapng file.\n\t\t\t */\n\t\t\treturn (NULL);\n\t\t}\n\t\tswapped = 1;\n\t\ttotal_length = SWAPLONG(total_length);\n\t}\n\n\t/*\n\t * Check the sanity of the total length.\n\t */\n\tif (total_length < sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer) ||\n            (total_length > BT_SHB_INSANE_MAX)) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Section Header Block in pcapng dump file has invalid length %\" PRIsize \" < _%lu_ < %lu (BT_SHB_INSANE_MAX)\",\n                              sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer),\n                              total_length,\n                              BT_SHB_INSANE_MAX);\n\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\n\n\n\t/*\n\t * OK, this is a good pcapng file.\n\t * Allocate a pcap_t for it.\n\t */\n\tp = pcap_open_offline_common(errbuf, sizeof (struct pcap_ng_sf));\n\tif (p == NULL) {\n\t\t/* Allocation failed. */\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\tp->swapped = swapped;\n\tps = p->priv;\n\n\t/*\n\t * What precision does the user want?\n\t */\n\tswitch (precision) {\n\n\tcase PCAP_TSTAMP_PRECISION_MICRO:\n\t\tps->user_tsresol = 1000000;\n\t\tbreak;\n\n\tcase PCAP_TSTAMP_PRECISION_NANO:\n\t\tps->user_tsresol = 1000000000;\n\t\tbreak;\n\n\tdefault:\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"unknown time stamp resolution %u\", precision);\n\t\tfree(p);\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\n\tp->opt.tstamp_precision = precision;\n\n\t/*\n\t * Allocate a buffer into which to read blocks.  We default to\n\t * the maximum of:\n\t *\n\t *\tthe total length of the SHB for which we read the header;\n\t *\n\t *\t2K, which should be more than large enough for an Enhanced\n\t *\tPacket Block containing a full-size Ethernet frame, and\n\t *\tleaving room for some options.\n\t *\n\t * If we find a bigger block, we reallocate the buffer, up to\n\t * the maximum size.  We start out with a maximum size of\n\t * INITIAL_MAX_BLOCKSIZE; if we see any link-layer header types\n\t * with a maximum snapshot that results in a larger maximum\n\t * block length, we boost the maximum.\n\t */\n\tp->bufsize = 2048;\n\tif (p->bufsize < total_length)\n\t\tp->bufsize = total_length;\n\tp->buffer = malloc(p->bufsize);\n\tif (p->buffer == NULL) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"out of memory\");\n\t\tfree(p);\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\tps->max_blocksize = INITIAL_MAX_BLOCKSIZE;\n\n\t/*\n\t * Copy the stuff we've read to the buffer, and read the rest\n\t * of the SHB.\n\t */\n\tbhdrp = (struct block_header *)p->buffer;\n\tshbp = (struct section_header_block *)((u_char *)p->buffer + sizeof(struct block_header));\n\tbhdrp->block_type = magic_int;\n\tbhdrp->total_length = total_length;\n\tshbp->byte_order_magic = byte_order_magic;\n\tif (read_bytes(fp,\n\t    (u_char *)p->buffer + (sizeof(magic_int) + sizeof(total_length) + sizeof(byte_order_magic)),\n\t    total_length - (sizeof(magic_int) + sizeof(total_length) + sizeof(byte_order_magic)),\n\t    1, errbuf) == -1)\n\t\tgoto fail;\n\n\tif (p->swapped) {\n\t\t/*\n\t\t * Byte-swap the fields we've read.\n\t\t */\n\t\tshbp->major_version = SWAPSHORT(shbp->major_version);\n\t\tshbp->minor_version = SWAPSHORT(shbp->minor_version);\n\n\t\t/*\n\t\t * XXX - we don't care about the section length.\n\t\t */\n\t}\n\t/* currently only SHB version 1.0 is supported */\n\tif (! (shbp->major_version == PCAP_NG_VERSION_MAJOR &&\n\t       shbp->minor_version == PCAP_NG_VERSION_MINOR)) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"unsupported pcapng savefile version %u.%u\",\n\t\t    shbp->major_version, shbp->minor_version);\n\t\tgoto fail;\n\t}\n\tp->version_major = shbp->major_version;\n\tp->version_minor = shbp->minor_version;\n\n\t/*\n\t * Save the time stamp resolution the user requested.\n\t */\n\tp->opt.tstamp_precision = precision;\n\n\t/*\n\t * Now start looking for an Interface Description Block.\n\t */\n\tfor (;;) {\n\t\t/*\n\t\t * Read the next block.\n\t\t */\n\t\tstatus = read_block(fp, p, &cursor, errbuf);\n\t\tif (status == 0) {\n\t\t\t/* EOF - no IDB in this file */\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"the capture file has no Interface Description Blocks\");\n\t\t\tgoto fail;\n\t\t}\n\t\tif (status == -1)\n\t\t\tgoto fail;\t/* error */\n\t\tswitch (cursor.block_type) {\n\n\t\tcase BT_IDB:\n\t\t\t/*\n\t\t\t * Get a pointer to the fixed-length portion of the\n\t\t\t * IDB.\n\t\t\t */\n\t\t\tidbp = get_from_block_data(&cursor, sizeof(*idbp),\n\t\t\t    errbuf);\n\t\t\tif (idbp == NULL)\n\t\t\t\tgoto fail;\t/* error */\n\n\t\t\t/*\n\t\t\t * Byte-swap it if necessary.\n\t\t\t */\n\t\t\tif (p->swapped) {\n\t\t\t\tidbp->linktype = SWAPSHORT(idbp->linktype);\n\t\t\t\tidbp->snaplen = SWAPLONG(idbp->snaplen);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Try to add this interface.\n\t\t\t */\n\t\t\tif (!add_interface(p, &cursor, errbuf))\n\t\t\t\tgoto fail;\n\n\t\t\tgoto done;\n\n\t\tcase BT_EPB:\n\t\tcase BT_SPB:\n\t\tcase BT_PB:\n\t\t\t/*\n\t\t\t * Saw a packet before we saw any IDBs.  That's\n\t\t\t * not valid, as we don't know what link-layer\n\t\t\t * encapsulation the packet has.\n\t\t\t */\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"the capture file has a packet block before any Interface Description Blocks\");\n\t\t\tgoto fail;\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Just ignore it.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\ndone:\n\tp->tzoff = 0;\t/* XXX - not used in pcap */\n\tp->linktype = linktype_to_dlt(idbp->linktype);\n\tp->snapshot = pcap_adjust_snapshot(p->linktype, idbp->snaplen);\n\tp->linktype_ext = 0;\n\n\t/*\n\t * If the maximum block size for a packet with the maximum\n\t * snapshot length for this DLT_ is bigger than the current\n\t * maximum block size, increase the maximum.\n\t */\n\tif (MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen_for_dlt(p->linktype)) > ps->max_blocksize)\n\t\tps->max_blocksize = MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen_for_dlt(p->linktype));\n\n\tp->next_packet_op = pcap_ng_next_packet;\n\tp->cleanup_op = pcap_ng_cleanup;\n\n\treturn (p);\n\nfail:\n\tfree(ps->ifaces);\n\tfree(p->buffer);\n\tfree(p);\n\t*err = 1;\n\treturn (NULL);\n}", "target": 1, "idx": 11515}
{"commit_id": "c6ec1155d026c91b1badb07ef1605bb747cff064", "project": "grpc", "func": "static void internal_set_str(grpc_error **err, grpc_error_strs which,\n                             grpc_slice value) {\n  uint8_t slot = (*err)->strs[which];\n  if (slot == UINT8_MAX) {\n    slot = get_placement(err, sizeof(value));\n    if (slot == UINT8_MAX) {\n      const char *str = grpc_slice_to_c_string(value);\n      gpr_log(GPR_ERROR, \"Error %p is full, dropping string {\\\"%s\\\":\\\"%s\\\"}\",\n              *err, error_str_name(which), str);\n      gpr_free((void *)str);\n      return;\n    }\n  } else {\n    unref_slice(*(grpc_slice *)((*err)->arena + slot));\n  }\n  (*err)->strs[which] = slot;\n  memcpy((*err)->arena + slot, &value, sizeof(value));\n}", "target": 3, "idx": 11516}
{"commit_id": "c4d34984ec92b3d5252a7d5cddd85a1d3a8001ae", "project": "pjsip/pjproject", "func": "static pjmedia_sdp_attr *parse_attr( pj_pool_t *pool, pj_scanner *scanner,\n\t\t\t\t    volatile parse_context *ctx)\n{\n    pjmedia_sdp_attr *attr;\n\n    ctx->last_error = PJMEDIA_SDP_EINATTR;\n\n    attr = PJ_POOL_ALLOC_T(pool, pjmedia_sdp_attr);\n\n    /* check equal sign */\n    if (scanner->curptr+1 >= scanner->end || *(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn NULL;\n    }\n\n    /* skip a= */\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n    \n    /* get attr name. */\n    pj_scan_get(scanner, &cs_token, &attr->name);\n\n    if (*scanner->curptr && *scanner->curptr != '\\r' && \n\t*scanner->curptr != '\\n') \n    {\n\t/* skip ':' if present. */\n\tif (*scanner->curptr == ':')\n\t    pj_scan_get_char(scanner);\n\n\t/* get value */\n\tif (!pj_scan_is_eof(scanner) && *scanner->curptr != '\\r' && *scanner->curptr != '\\n') {\n\t    pj_scan_get_until_chr(scanner, \"\\r\\n\", &attr->value);\n\t} else {\n\t    attr->value.ptr = NULL;\n\t    attr->value.slen = 0;\n\t}\n\n    } else {\n\tattr->value.ptr = NULL;\n\tattr->value.slen = 0;\n    }\n\n    /* We've got what we're looking for, skip anything until newline */\n    pj_scan_skip_line(scanner);\n\n    return attr;\n}", "target": 2, "idx": 11517}
{"commit_id": "1b71a6ba963d131375f5e489b3b25e36f19f3f24", "project": "knik0/faad2", "func": "static int stszin(int size)\n{\n    int cnt;\n    uint32_t ofs;\n\n    // version/flags\n    u32in();\n    // Sample size\n    u32in();\n    // Number of entries\n    mp4config.frame.ents = u32in();\n\n    if (!(mp4config.frame.ents + 1))\n        return ERR_FAIL;\n\n    mp4config.frame.data = malloc(sizeof(*mp4config.frame.data)\n                                  * (mp4config.frame.ents + 1));\n\n    if (!mp4config.frame.data)\n        return ERR_FAIL;\n\n    ofs = 0;\n    mp4config.frame.data[0] = ofs;\n    for (cnt = 0; cnt < mp4config.frame.ents; cnt++)\n    {\n        uint32_t fsize = u32in();\n\n        ofs += fsize;\n        if (mp4config.frame.maxsize < fsize)\n            mp4config.frame.maxsize = fsize;\n\n        mp4config.frame.data[cnt + 1] = ofs;\n\n        if (ofs < mp4config.frame.data[cnt])\n            return ERR_FAIL;\n    }\n\n    return size;\n}", "target": 2, "idx": 11518}
{"commit_id": "d80988cfc04ee608bee722448e7c3bc8347ec04c", "project": "xen-project/xen", "func": "int guest_remove_page(struct domain *d, unsigned long gmfn)\n{\n    struct page_info *page;\n#ifdef CONFIG_X86\n    p2m_type_t p2mt;\n#endif\n    mfn_t mfn;\n    int rc;\n\n#ifdef CONFIG_X86\n    mfn = get_gfn_query(d, gmfn, &p2mt);\n    if ( unlikely(p2mt == p2m_invalid) || unlikely(p2mt == p2m_mmio_dm) )\n    {\n        put_gfn(d, gmfn);\n\n        return -ENOENT;\n    }\n\n    if ( unlikely(p2m_is_paging(p2mt)) )\n    {\n        rc = guest_physmap_remove_page(d, _gfn(gmfn), mfn, 0);\n        if ( rc )\n            goto out_put_gfn;\n\n        put_gfn(d, gmfn);\n\n        /* If the page hasn't yet been paged out, there is an\n         * actual page that needs to be released. */\n        if ( p2mt == p2m_ram_paging_out )\n        {\n            ASSERT(mfn_valid(mfn));\n            page = mfn_to_page(mfn);\n            if ( test_and_clear_bit(_PGC_allocated, &page->count_info) )\n                put_page(page);\n        }\n        p2m_mem_paging_drop_page(d, gmfn, p2mt);\n\n        return 0;\n    }\n    if ( p2mt == p2m_mmio_direct )\n    {\n        rc = clear_mmio_p2m_entry(d, gmfn, mfn, PAGE_ORDER_4K);\n        goto out_put_gfn;\n    }\n#else\n    mfn = gfn_to_mfn(d, _gfn(gmfn));\n#endif\n    if ( unlikely(!mfn_valid(mfn)) )\n    {\n        put_gfn(d, gmfn);\n        gdprintk(XENLOG_INFO, \"Domain %u page number %lx invalid\\n\",\n                d->domain_id, gmfn);\n\n        return -EINVAL;\n    }\n            \n#ifdef CONFIG_X86\n    if ( p2m_is_shared(p2mt) )\n    {\n        /*\n         * Unshare the page, bail out on error. We unshare because we\n         * might be the only one using this shared page, and we need to\n         * trigger proper cleanup. Once done, this is like any other page.\n         */\n        rc = mem_sharing_unshare_page(d, gmfn, 0);\n        if ( rc )\n        {\n            mem_sharing_notify_enomem(d, gmfn, false);\n            goto out_put_gfn;\n        }\n        /* Maybe the mfn changed */\n        mfn = get_gfn_query_unlocked(d, gmfn, &p2mt);\n        ASSERT(!p2m_is_shared(p2mt));\n    }\n#endif /* CONFIG_X86 */\n\n    page = mfn_to_page(mfn);\n    if ( unlikely(!get_page(page, d)) )\n    {\n        put_gfn(d, gmfn);\n        gdprintk(XENLOG_INFO, \"Bad page free for domain %u\\n\", d->domain_id);\n\n        return -ENXIO;\n    }\n\n    rc = guest_physmap_remove_page(d, _gfn(gmfn), mfn, 0);\n\n    /*\n     * With the lack of an IOMMU on some platforms, domains with DMA-capable\n     * device must retrieve the same pfn when the hypercall populate_physmap\n     * is called.\n     *\n     * For this purpose (and to match populate_physmap() behavior), the page\n     * is kept allocated.\n     */\n    if ( !rc && !is_domain_direct_mapped(d) &&\n         test_and_clear_bit(_PGC_allocated, &page->count_info) )\n        put_page(page);\n\n    put_page(page);\n out_put_gfn: __maybe_unused;\n    put_gfn(d, gmfn);\n\n    /*\n     * Filter out -ENOENT return values that aren't a result of an empty p2m\n     * entry.\n     */\n    return rc != -ENOENT ? rc : -EINVAL;\n}", "target": 1, "idx": 11519}
{"commit_id": "f5364c150aa645b3d7daa21b5c0b9feaa1c9cd6d", "project": "torvalds/linux", "func": "static struct dentry *proc_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\tint err;\n\tstruct super_block *sb;\n\tstruct pid_namespace *ns;\n\tchar *options;\n\n\tif (flags & MS_KERNMOUNT) {\n\t\tns = (struct pid_namespace *)data;\n\t\toptions = NULL;\n\t} else {\n\t\tns = task_active_pid_ns(current);\n\t\toptions = data;\n\n\t\t/* Does the mounter have privilege over the pid namespace? */\n\t\tif (!ns_capable(ns->user_ns, CAP_SYS_ADMIN))\n\t\t\treturn ERR_PTR(-EPERM);\n\t}\n\n\tsb = sget(fs_type, proc_test_super, proc_set_super, flags, ns);\n\tif (IS_ERR(sb))\n\t\treturn ERR_CAST(sb);\n\n\t/*\n\t * procfs isn't actually a stacking filesystem; however, there is\n\t * too much magic going on inside it to permit stacking things on\n\t * top of it\n\t */\n\tsb->s_stack_depth = FILESYSTEM_MAX_STACK_DEPTH;\n\n\tif (!proc_parse_options(options, ns)) {\n\t\tdeactivate_locked_super(sb);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (!sb->s_root) {\n\t\terr = proc_fill_super(sb);\n\t\tif (err) {\n\t\t\tdeactivate_locked_super(sb);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\n\t\tsb->s_flags |= MS_ACTIVE;\n\t\t/* User space would break if executables appear on proc */\n\t\tsb->s_iflags |= SB_I_NOEXEC;\n\t}\n\n\treturn dget(sb->s_root);\n}", "target": 2, "idx": 11520}
{"commit_id": "53d8c8f3d181d87a6aa925b449b51c4a2c922a51", "project": "unicode-org/icu", "func": "UnicodeString DecimalQuantity::toScientificString() const {\n    U_ASSERT(!isApproximate);\n    UnicodeString result;\n    if (isNegative()) {\n        result.append(u'-');\n    }\n    if (precision == 0) {\n        result.append(u\"0E+0\", -1);\n        return result;\n    }\n    // NOTE: It is not safe to add to lOptPos (aka maxInt) or subtract from\n    // rOptPos (aka -maxFrac) due to overflow.\n    int32_t upperPos = std::min(precision + scale, lOptPos) - scale - 1;\n    int32_t lowerPos = std::max(scale, rOptPos) - scale;\n    int32_t p = upperPos;\n    result.append(u'0' + getDigitPos(p));\n    if ((--p) >= lowerPos) {\n        result.append(u'.');\n        for (; p >= lowerPos; p--) {\n            result.append(u'0' + getDigitPos(p));\n        }\n    }\n    result.append(u'E');\n    int32_t _scale = upperPos + scale;\n    if (_scale == INT32_MIN) {\n        result.append({u\"-2147483648\", -1});\n        return result;\n    } else if (_scale < 0) {\n        _scale *= -1;\n        result.append(u'-');\n    } else {\n        result.append(u'+');\n    }\n    if (_scale == 0) {\n        result.append(u'0');\n    }\n    int32_t insertIndex = result.length();\n    while (_scale > 0) {\n        std::div_t res = std::div(_scale, 10);\n        result.insert(insertIndex, u'0' + res.rem);\n        _scale = res.quot;\n    }\n    return result;\n}", "target": 3, "idx": 11521}
{"commit_id": "7f2d6fe34d695d3445e2d50937db5541a1b76bde", "project": "ImageMagick", "func": "static MagickBooleanType WritePCXImage(const ImageInfo *image_info,Image *image)\n{\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset,\n    *page_table,\n    scene;\n\n  MemoryInfo\n    *pixel_info;\n\n  PCXInfo\n    pcx_info;\n\n  register const IndexPacket\n    *indexes;\n\n  register const PixelPacket\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *q;\n\n  size_t\n    length;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *pcx_colormap,\n    *pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  if ((image->columns > 65535UL) || (image->rows > 65535UL))\n    ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n  (void) TransformImageColorspace(image,sRGBColorspace);\n  page_table=(MagickOffsetType *) NULL;\n  if ((LocaleCompare(image_info->magick,\"DCX\") == 0) ||\n      ((GetNextImageInList(image) != (Image *) NULL) &&\n       (image_info->adjoin != MagickFalse)))\n    {\n      /*\n        Write the DCX page table.\n      */\n      (void) WriteBlobLSBLong(image,0x3ADE68B1L);\n      page_table=(MagickOffsetType *) AcquireQuantumMemory(1024UL,\n        sizeof(*page_table));\n      if (page_table == (MagickOffsetType *) NULL)\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      for (scene=0; scene < 1024; scene++)\n        (void) WriteBlobLSBLong(image,0x00000000L);\n    }\n  scene=0;\n  do\n  {\n    if (page_table != (MagickOffsetType *) NULL)\n      page_table[scene]=TellBlob(image);\n    /*\n      Initialize PCX raster file header.\n    */\n    pcx_info.identifier=0x0a;\n    pcx_info.version=5;\n    pcx_info.encoding=image_info->compression == NoCompression ? 0 : 1;\n    pcx_info.bits_per_pixel=8;\n    if ((image->storage_class == PseudoClass) &&\n        (SetImageMonochrome(image,&image->exception) != MagickFalse))\n      pcx_info.bits_per_pixel=1;\n    pcx_info.left=0;\n    pcx_info.top=0;\n    pcx_info.right=(unsigned short) (image->columns-1);\n    pcx_info.bottom=(unsigned short) (image->rows-1);\n    switch (image->units)\n    {\n      case UndefinedResolution:\n      case PixelsPerInchResolution:\n      default:\n      {\n        pcx_info.horizontal_resolution=(unsigned short) image->x_resolution;\n        pcx_info.vertical_resolution=(unsigned short) image->y_resolution;\n        break;\n      }\n      case PixelsPerCentimeterResolution:\n      {\n        pcx_info.horizontal_resolution=(unsigned short)\n          (2.54*image->x_resolution+0.5);\n        pcx_info.vertical_resolution=(unsigned short)\n          (2.54*image->y_resolution+0.5);\n        break;\n      }\n    }\n    pcx_info.reserved=0;\n    pcx_info.planes=1;\n    if ((image->storage_class == DirectClass) || (image->colors > 256))\n      {\n        pcx_info.planes=3;\n        if (image->matte != MagickFalse)\n          pcx_info.planes++;\n      }\n    length=(((size_t) image->columns*pcx_info.bits_per_pixel+7)/8);\n    if (length > 65535UL)\n      ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n    pcx_info.bytes_per_line=(unsigned short) length;\n    pcx_info.palette_info=1;\n    pcx_info.colormap_signature=0x0c;\n    /*\n      Write PCX header.\n    */\n    (void) WriteBlobByte(image,pcx_info.identifier);\n    (void) WriteBlobByte(image,pcx_info.version);\n    (void) WriteBlobByte(image,pcx_info.encoding);\n    (void) WriteBlobByte(image,pcx_info.bits_per_pixel);\n    (void) WriteBlobLSBShort(image,pcx_info.left);\n    (void) WriteBlobLSBShort(image,pcx_info.top);\n    (void) WriteBlobLSBShort(image,pcx_info.right);\n    (void) WriteBlobLSBShort(image,pcx_info.bottom);\n    (void) WriteBlobLSBShort(image,pcx_info.horizontal_resolution);\n    (void) WriteBlobLSBShort(image,pcx_info.vertical_resolution);\n    /*\n      Dump colormap to file.\n    */\n    pcx_colormap=(unsigned char *) AcquireQuantumMemory(256UL,\n      3*sizeof(*pcx_colormap));\n    if (pcx_colormap == (unsigned char *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) memset(pcx_colormap,0,3*256*sizeof(*pcx_colormap));\n    q=pcx_colormap;\n    if ((image->storage_class == PseudoClass) && (image->colors <= 256))\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        *q++=ScaleQuantumToChar(image->colormap[i].red);\n        *q++=ScaleQuantumToChar(image->colormap[i].green);\n        *q++=ScaleQuantumToChar(image->colormap[i].blue);\n      }\n    (void) WriteBlob(image,3*16,(const unsigned char *) pcx_colormap);\n    (void) WriteBlobByte(image,pcx_info.reserved);\n    (void) WriteBlobByte(image,pcx_info.planes);\n    (void) WriteBlobLSBShort(image,pcx_info.bytes_per_line);\n    (void) WriteBlobLSBShort(image,pcx_info.palette_info);\n    for (i=0; i < 58; i++)\n      (void) WriteBlobByte(image,'\\0');\n    length=(size_t) pcx_info.bytes_per_line;\n    pixel_info=AcquireVirtualMemory(length,pcx_info.planes*sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      {\n        pcx_colormap=(unsigned char *) RelinquishMagickMemory(pcx_colormap);\n        if (page_table != (MagickOffsetType *) NULL)\n          page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table);\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    q=pixels;\n    if ((image->storage_class == DirectClass) || (image->colors > 256))\n      {\n        /*\n          Convert DirectClass image to PCX raster pixels.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=pixels;\n          for (i=0; i < pcx_info.planes; i++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n            if (p == (const PixelPacket *) NULL)\n              break;\n            switch ((int) i)\n            {\n              case 0:\n              {\n                for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n                {\n                  *q++=ScaleQuantumToChar(GetPixelRed(p));\n                  p++;\n                }\n                break;\n              }\n              case 1:\n              {\n                for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n                {\n                  *q++=ScaleQuantumToChar(GetPixelGreen(p));\n                  p++;\n                }\n                break;\n              }\n              case 2:\n              {\n                for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n                {\n                  *q++=ScaleQuantumToChar(GetPixelBlue(p));\n                  p++;\n                }\n                break;\n              }\n              case 3:\n              default:\n              {\n                for (x=(ssize_t) pcx_info.bytes_per_line; x != 0; x--)\n                {\n                  *q++=ScaleQuantumToChar((Quantum)\n                    (GetPixelAlpha(p)));\n                  p++;\n                }\n                break;\n              }\n            }\n          }\n          if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      {\n        if (pcx_info.bits_per_pixel > 1)\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n            if (p == (const PixelPacket *) NULL)\n              break;\n            indexes=GetVirtualIndexQueue(image);\n            q=pixels;\n            for (x=0; x < (ssize_t) image->columns; x++)\n              *q++=(unsigned char) GetPixelIndex(indexes+x);\n            if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                  y,image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        else\n          {\n            register unsigned char\n              bit,\n              byte;\n\n            /*\n              Convert PseudoClass image to a PCX monochrome image.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n              if (p == (const PixelPacket *) NULL)\n                break;\n              indexes=GetVirtualIndexQueue(image);\n              bit=0;\n              byte=0;\n              q=pixels;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                byte<<=1;\n                if (GetPixelLuma(image,p) >= (QuantumRange/2.0))\n                  byte|=0x01;\n                bit++;\n                if (bit == 8)\n                  {\n                    *q++=byte;\n                    bit=0;\n                    byte=0;\n                  }\n                p++;\n              }\n              if (bit != 0)\n                *q++=byte << (8-bit);\n              if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        (void) WriteBlobByte(image,pcx_info.colormap_signature);\n        (void) WriteBlob(image,3*256,pcx_colormap);\n      }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    pcx_colormap=(unsigned char *) RelinquishMagickMemory(pcx_colormap);\n    if (page_table == (MagickOffsetType *) NULL)\n      break;\n    if (scene >= 1023)\n      break;\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  if (page_table != (MagickOffsetType *) NULL)\n    {\n      /*\n        Write the DCX page table.\n      */\n      page_table[scene+1]=0;\n      offset=SeekBlob(image,0L,SEEK_SET);\n      if (offset < 0)\n        {\n          page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table);\n          ThrowWriterException(CorruptImageError,\"ImproperImageHeader\");\n        }\n      (void) WriteBlobLSBLong(image,0x3ADE68B1L);\n      for (i=0; i <= (ssize_t) scene; i++)\n        (void) WriteBlobLSBLong(image,(unsigned int) page_table[i]);\n      page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table);\n    }\n  if (status == MagickFalse)\n    {\n      char\n        *message;\n\n      message=GetExceptionMessage(errno);\n      (void) ThrowMagickException(&image->exception,GetMagickModule(),\n        FileOpenError,\"UnableToWriteFile\",\"`%s': %s\",image->filename,message);\n      message=DestroyString(message);\n    }\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}", "target": 2, "idx": 11522}
{"commit_id": "01cff3f986259d661103412a20745928c727326f", "project": "tensorflow", "func": "void DoCompute(OpKernelContext* c) {\n    core::RefCountPtr<Var> v;\n    OP_REQUIRES_OK(c, LookupResource(c, HandleFromInput(c, 0), &v));\n    Tensor* params = v->tensor();\n    const Tensor& indices = c->input(1);\n    const Tensor& updates = c->input(2);\n\n    // Check that rank(updates.shape) = rank(indices.shape + params.shape[1:])\n    OP_REQUIRES(c,\n                updates.dims() == 0 ||\n                    updates.dims() == indices.dims() + params->dims() - 1,\n                errors::InvalidArgument(\n                    \"Must have updates.shape = indices.shape + \"\n                    \"params.shape[1:] or updates.shape = [], got \",\n                    \"updates.shape \", updates.shape().DebugString(),\n                    \", indices.shape \", indices.shape().DebugString(),\n                    \", params.shape \", params->shape().DebugString()));\n\n    // Check that we have enough index space\n    const int64_t N_big = indices.NumElements();\n    OP_REQUIRES(\n        c, N_big <= std::numeric_limits<Index>::max(),\n        errors::InvalidArgument(\"indices has too many elements for \",\n                                DataTypeString(DataTypeToEnum<Index>::v()),\n                                \" indexing: \", N_big, \" > \",\n                                std::numeric_limits<Index>::max()));\n    const Index N = static_cast<Index>(N_big);\n    OP_REQUIRES(\n        c, params->dim_size(0) <= std::numeric_limits<Index>::max(),\n        errors::InvalidArgument(\"params.shape[0] too large for \",\n                                DataTypeString(DataTypeToEnum<Index>::v()),\n                                \" indexing: \", params->dim_size(0), \" > \",\n                                std::numeric_limits<Index>::max()));\n\n    if (N > 0) {\n      auto indices_flat = indices.flat<Index>();\n      auto params_flat = params->flat_outer_dims<T>();\n      if (TensorShapeUtils::IsScalar(updates.shape())) {\n        const auto update = updates.scalar<T>();\n\n        functor::ScatterScalarFunctor<Device, T, Index, op> functor;\n        const Index bad_i = functor(c, c->template eigen_device<Device>(),\n                                    params_flat, update, indices_flat);\n        OP_REQUIRES(c, bad_i < 0,\n                    errors::InvalidArgument(\n                        \"indices\", SliceDebugString(indices.shape(), bad_i),\n                        \" = \", indices_flat(bad_i), \" is not in [0, \",\n                        params->dim_size(0), \")\"));\n      } else {\n        int64_t num_updates = updates.NumElements();\n        OP_REQUIRES(\n            c, TensorShapeUtils::StartsWith(updates.shape(), indices.shape()),\n            errors::InvalidArgument(\n                \"The shape of indices (\", indices.shape().DebugString(),\n                \") must be a prefix of the shape of updates (\",\n                updates.shape().DebugString(), \")\"));\n        auto updates_flat = updates.shaped<T, 2>({N, num_updates / N});\n\n        functor::ScatterFunctor<Device, T, Index, op> functor;\n        const Index bad_i = functor(c, c->template eigen_device<Device>(),\n                                    params_flat, updates_flat, indices_flat);\n        OP_REQUIRES(c, bad_i < 0,\n                    errors::InvalidArgument(\n                        \"indices\", SliceDebugString(indices.shape(), bad_i),\n                        \" = \", indices_flat(bad_i), \" is not in [0, \",\n                        params->dim_size(0), \")\"));\n      }\n    }\n  }", "target": 2, "idx": 11523}
{"commit_id": "48a992727d82cb7db076fa15d372178743b1f4cd", "project": "torvalds/linux", "func": "static int mcryptd_create_hash(struct crypto_template *tmpl, struct rtattr **tb,\n\t\t\t      struct mcryptd_queue *queue)\n{\n\tstruct hashd_instance_ctx *ctx;\n\tstruct ahash_instance *inst;\n\tstruct hash_alg_common *halg;\n\tstruct crypto_alg *alg;\n\tu32 type = 0;\n\tu32 mask = 0;\n\tint err;\n\n\tif (!mcryptd_check_internal(tb, &type, &mask))\n\t\treturn -EINVAL;\n\n\thalg = ahash_attr_alg(tb[1], type, mask);\n\tif (IS_ERR(halg))\n\t\treturn PTR_ERR(halg);\n\n\talg = &halg->base;\n\tpr_debug(\"crypto: mcryptd hash alg: %s\\n\", alg->cra_name);\n\tinst = mcryptd_alloc_instance(alg, ahash_instance_headroom(),\n\t\t\t\t\tsizeof(*ctx));\n\terr = PTR_ERR(inst);\n\tif (IS_ERR(inst))\n\t\tgoto out_put_alg;\n\n\tctx = ahash_instance_ctx(inst);\n\tctx->queue = queue;\n\n\terr = crypto_init_ahash_spawn(&ctx->spawn, halg,\n\t\t\t\t      ahash_crypto_instance(inst));\n\tif (err)\n\t\tgoto out_free_inst;\n\n\ttype = CRYPTO_ALG_ASYNC;\n\tif (alg->cra_flags & CRYPTO_ALG_INTERNAL)\n\t\ttype |= CRYPTO_ALG_INTERNAL;\n\tinst->alg.halg.base.cra_flags = type;\n\n\tinst->alg.halg.digestsize = halg->digestsize;\n\tinst->alg.halg.statesize = halg->statesize;\n\tinst->alg.halg.base.cra_ctxsize = sizeof(struct mcryptd_hash_ctx);\n\n\tinst->alg.halg.base.cra_init = mcryptd_hash_init_tfm;\n\tinst->alg.halg.base.cra_exit = mcryptd_hash_exit_tfm;\n\n\tinst->alg.init   = mcryptd_hash_init_enqueue;\n\tinst->alg.update = mcryptd_hash_update_enqueue;\n\tinst->alg.final  = mcryptd_hash_final_enqueue;\n\tinst->alg.finup  = mcryptd_hash_finup_enqueue;\n\tinst->alg.export = mcryptd_hash_export;\n\tinst->alg.import = mcryptd_hash_import;\n\tinst->alg.setkey = mcryptd_hash_setkey;\n\tinst->alg.digest = mcryptd_hash_digest_enqueue;\n\n\terr = ahash_register_instance(tmpl, inst);\n\tif (err) {\n\t\tcrypto_drop_ahash(&ctx->spawn);\nout_free_inst:\n\t\tkfree(inst);\n\t}\n\nout_put_alg:\n\tcrypto_mod_put(alg);\n\treturn err;\n}", "target": 1, "idx": 11524}
{"commit_id": "68338b71a563b24e62617bb629059adc0c94b230", "project": "radareorg/radare2", "func": "static void dex_parse_debug_item(RBinFile *binfile, RBinDexObj *bin,\n\t\t\t\t  RBinDexClass *c, int MI, int MA, int paddr, int ins_size,\n\t\t\t\t  int insns_size, char *class_name, int regsz,\n\t\t\t\t  int debug_info_off) {\n\tstruct r_bin_t *rbin = binfile->rbin;\n\tconst ut8 *p4 = r_buf_get_at (binfile->buf, debug_info_off, NULL);\n\tconst ut8 *p4_end = p4 + binfile->buf->length - debug_info_off;\n\tut64 line_start;\n\tut64 parameters_size;\n\tut64 param_type_idx;\n\tut16 argReg = regsz - ins_size;\n\tut64 source_file_idx = c->source_file;\n\tRList *params, *debug_positions, *emitted_debug_locals = NULL; \n\tbool keep = true;\n\tif (argReg > regsz) {\n\t\treturn; // this return breaks tests\n\t}\n\tp4 = r_uleb128 (p4, p4_end - p4, &line_start);\n\tp4 = r_uleb128 (p4, p4_end - p4, &parameters_size);\n\t// TODO: check when we should use source_file\n\t// The state machine consists of five registers\n\tut32 address = 0;\n\tut32 line = line_start;\n\tif (!(debug_positions = r_list_newf ((RListFree)free))) {\n\t\treturn;\t\n\t}\n\tif (!(emitted_debug_locals = r_list_newf ((RListFree)free))) {\n\t\tr_list_free (debug_positions);\n\t\treturn;\n\t}\n\n\tstruct dex_debug_local_t debug_locals[regsz];\n\tmemset (debug_locals, 0, sizeof (struct dex_debug_local_t) * regsz);\n\tif (!(MA & 0x0008)) {\n\t\tdebug_locals[argReg].name = \"this\";\n\t\tdebug_locals[argReg].descriptor = r_str_newf(\"%s;\", class_name);\n\t\tdebug_locals[argReg].startAddress = 0;\n\t\tdebug_locals[argReg].signature = NULL;\n\t\tdebug_locals[argReg].live = true;\n\t\targReg++;\n\t}\n\tif (!(params = dex_method_signature2 (bin, MI))) {\n\t\tr_list_free (debug_positions);\n\t\tr_list_free (emitted_debug_locals);\n\t\treturn;\n\t}\n\n\tRListIter *iter = r_list_iterator (params);\n\tchar *name;\n\tchar *type;\n\tint reg;\n\n\tr_list_foreach (params, iter, type) {\n\t\tif ((argReg >= regsz) || !type || parameters_size <= 0) {\n\t\t\tr_list_free (debug_positions);\n\t\t\tr_list_free (params);\n\t\t\tr_list_free (emitted_debug_locals);\n\t\t\treturn;\n\t\t}\n\t\tp4 = r_uleb128 (p4, p4_end - p4, &param_type_idx); // read uleb128p1\n\t\tparam_type_idx -= 1;\n\t\tname = getstr (bin, param_type_idx);\n\t\treg = argReg;\n\t\tswitch (type[0]) {\n\t\tcase 'D':\n\t\tcase 'J':\n\t\t\targReg += 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\targReg += 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (name) {\n\t\t\tdebug_locals[reg].name = name;\n\t\t\tdebug_locals[reg].descriptor = type;\n\t\t\tdebug_locals[reg].signature = NULL;\n\t\t\tdebug_locals[reg].startAddress = address;\n\t\t\tdebug_locals[reg].live = true;\n\t\t}\n\t\t--parameters_size;\n\t}\n\n\tif (p4 <= 0) {\n\t\treturn;\n\t}\n\tut8 opcode = *(p4++) & 0xff;\n\twhile (keep) {\n\t\tswitch (opcode) {\n\t\tcase 0x0: // DBG_END_SEQUENCE\n\t\t\tkeep = false;\n\t\t\tbreak;\n\t\tcase 0x1: // DBG_ADVANCE_PC\n\t\t\t{\n\t\t\tut64 addr_diff;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &addr_diff);\n\t\t\taddress += addr_diff;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x2: // DBG_ADVANCE_LINE\n\t\t\t{\n\t\t\tst64 line_diff = r_sleb128 (&p4, p4_end);\n\t\t\tline += line_diff;\n\t\t\t}\n\t\t\tbreak;\t\n\t\tcase 0x3: // DBG_START_LOCAL\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tut64 name_idx;\n\t\t\tut64 type_idx;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &name_idx); \n\t\t\tname_idx -= 1;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &type_idx); \n\t\t\ttype_idx -= 1;\n\t\t\tif (register_num >= regsz) {\n\t\t\t\tr_list_free (debug_positions);\n\t\t\t\tr_list_free (params);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Emit what was previously there, if anything\n\t\t\t// emitLocalCbIfLive\n\t\t\tif (debug_locals[register_num].live) {\n\t\t\t\tstruct dex_debug_local_t *local = malloc (\n\t\t\t\t\tsizeof (struct dex_debug_local_t));\n\t\t\t\tif (!local) {\n\t\t\t\t\tkeep = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlocal->name = debug_locals[register_num].name;\n\t\t\t\tlocal->descriptor = debug_locals[register_num].descriptor;\n\t\t\t\tlocal->startAddress = debug_locals[register_num].startAddress;\n\t\t\t\tlocal->signature = debug_locals[register_num].signature;\n\t\t\t\tlocal->live = true;\n\t\t\t\tlocal->reg = register_num;\n\t\t\t\tlocal->endAddress = address;\n\t\t\t\tr_list_append (emitted_debug_locals, local);\n\t\t\t}\n\t\t\tdebug_locals[register_num].name = getstr (bin, name_idx);\n\t\t\tdebug_locals[register_num].descriptor = dex_type_descriptor (bin, type_idx);\n\t\t\tdebug_locals[register_num].startAddress = address;\n\t\t\tdebug_locals[register_num].signature = NULL;\n\t\t\tdebug_locals[register_num].live = true;\n\t\t\t//eprintf(\"DBG_START_LOCAL %x %x %x\\n\", register_num, name_idx, type_idx);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x4: //DBG_START_LOCAL_EXTENDED\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tut64 name_idx;\n\t\t\tut64 type_idx;\n\t\t\tut64 sig_idx;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &name_idx);\n\t\t\tname_idx -= 1;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &type_idx);\n\t\t\ttype_idx -= 1;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &sig_idx);\n\t\t\tsig_idx -= 1;\n\t\t\tif (register_num >= regsz) {\n\t\t\t\tr_list_free (debug_positions);\n\t\t\t\tr_list_free (params);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Emit what was previously there, if anything\n\t\t\t// emitLocalCbIfLive\n\t\t\tif (debug_locals[register_num].live) {\n\t\t\t\tstruct dex_debug_local_t *local = malloc (\n\t\t\t\t\tsizeof (struct dex_debug_local_t));\n\t\t\t\tif (!local) {\n\t\t\t\t\tkeep = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlocal->name = debug_locals[register_num].name;\n\t\t\t\tlocal->descriptor = debug_locals[register_num].descriptor;\n\t\t\t\tlocal->startAddress = debug_locals[register_num].startAddress;\n\t\t\t\tlocal->signature = debug_locals[register_num].signature;\n\t\t\t\tlocal->live = true;\n\t\t\t\tlocal->reg = register_num;\n\t\t\t\tlocal->endAddress = address;\n\t\t\t\tr_list_append (emitted_debug_locals, local);\n\t\t\t}\n\n\t\t\tdebug_locals[register_num].name = getstr (bin, name_idx);\n\t\t\tdebug_locals[register_num].descriptor = dex_type_descriptor (bin, type_idx);\n\t\t\tdebug_locals[register_num].startAddress = address;\n\t\t\tdebug_locals[register_num].signature = getstr (bin, sig_idx);\n\t\t\tdebug_locals[register_num].live = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x5: // DBG_END_LOCAL\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\t// emitLocalCbIfLive\n\t\t\tif (debug_locals[register_num].live) {\n\t\t\t\tstruct dex_debug_local_t *local = malloc (\n\t\t\t\t\tsizeof (struct dex_debug_local_t));\n\t\t\t\tif (!local) {\n\t\t\t\t\tkeep = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlocal->name = debug_locals[register_num].name;\n\t\t\t\tlocal->descriptor = debug_locals[register_num].descriptor;\n\t\t\t\tlocal->startAddress = debug_locals[register_num].startAddress;\n\t\t\t\tlocal->signature = debug_locals[register_num].signature;\n\t\t\t\tlocal->live = true;\n\t\t\t\tlocal->reg = register_num;\n\t\t\t\tlocal->endAddress = address;\n\t\t\t\tr_list_append (emitted_debug_locals, local);\n\t\t\t}\n\t\t\tdebug_locals[register_num].live = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x6: // DBG_RESTART_LOCAL\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\tif (!debug_locals[register_num].live) {\n\t\t\t\tdebug_locals[register_num].startAddress = address;\n\t\t\t\tdebug_locals[register_num].live = true;\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x7: //DBG_SET_PROLOGUE_END\n\t\t\tbreak;\n\t\tcase 0x8: //DBG_SET_PROLOGUE_BEGIN\n\t\t\tbreak;\n\t\tcase 0x9:\n\t\t\t{\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &source_file_idx);\n\t\t\tsource_file_idx--;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t{\n\t\t\tint adjusted_opcode = opcode - 0x0a;\n\t\t\taddress += (adjusted_opcode / 15);\n\t\t\tline += -4 + (adjusted_opcode % 15);\n\t\t\tstruct dex_debug_position_t *position =\n\t\t\t\tmalloc (sizeof (struct dex_debug_position_t));\n\t\t\tif (!position) {\n\t\t\t\tkeep = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tposition->source_file_idx = source_file_idx;\n\t\t\tposition->address = address;\n\t\t\tposition->line = line;\n\t\t\tr_list_append (debug_positions, position);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\topcode = *(p4++) & 0xff;\n\t}\n\n\tif (!binfile->sdb_addrinfo) {\n\t\tbinfile->sdb_addrinfo = sdb_new0 ();\n\t}\n\n\tchar *fileline;\n\tchar offset[64];\n\tchar *offset_ptr;\n\n\tRListIter *iter1;\n\tstruct dex_debug_position_t *pos;\n\tr_list_foreach (debug_positions, iter1, pos) {\n\t\tfileline = r_str_newf (\"%s|%\"PFMT64d, getstr (bin, pos->source_file_idx), pos->line);\n\t\toffset_ptr = sdb_itoa (pos->address + paddr, offset, 16);\n\t\tsdb_set (binfile->sdb_addrinfo, offset_ptr, fileline, 0);\n\t\tsdb_set (binfile->sdb_addrinfo, fileline, offset_ptr, 0);\n\t}\n\n\tif (!dexdump) {\n\t\tr_list_free (debug_positions);\n\t\tr_list_free (emitted_debug_locals);\n\t\tr_list_free (params);\n\t\treturn;\n\t}\n\n\tRListIter *iter2;\n\tstruct dex_debug_position_t *position;\n\n\trbin->cb_printf (\"      positions     :\\n\");\n\tr_list_foreach (debug_positions, iter2, position) {\n\t\trbin->cb_printf (\"        0x%04llx line=%llu\\n\",\n\t\t\t\t position->address, position->line);\n\t}\n\n\trbin->cb_printf (\"      locals        :\\n\");\n\n\tRListIter *iter3;\n\tstruct dex_debug_local_t *local;\n\tr_list_foreach (emitted_debug_locals, iter3, local) {\n\t\tif (local->signature) {\n\t\t\trbin->cb_printf (\n\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s %s\\n\",\n\t\t\t\tlocal->startAddress, local->endAddress,\n\t\t\t\tlocal->reg, local->name, local->descriptor,\n\t\t\t\tlocal->signature);\n\t\t} else {\n\t\t\trbin->cb_printf (\n\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s\\n\",\n\t\t\t\tlocal->startAddress, local->endAddress,\n\t\t\t\tlocal->reg, local->name, local->descriptor);\n\t\t}\n\t}\n\n\tfor (reg = 0; reg < regsz; reg++) {\n\t\tif (debug_locals[reg].live) {\n\t\t\tif (debug_locals[reg].signature) {\n\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s \"\n\t\t\t\t\t\"%s\\n\",\n\t\t\t\t\tdebug_locals[reg].startAddress,\n\t\t\t\t\tinsns_size, reg, debug_locals[reg].name,\n\t\t\t\t\tdebug_locals[reg].descriptor,\n\t\t\t\t\tdebug_locals[reg].signature);\n\t\t\t} else {\n\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s\"\n\t\t\t\t\t\"\\n\",\n\t\t\t\t\tdebug_locals[reg].startAddress,\n\t\t\t\t\tinsns_size, reg, debug_locals[reg].name,\n\t\t\t\t\tdebug_locals[reg].descriptor);\n\t\t\t}\n\t\t}\n\t}\n\tr_list_free (debug_positions);\n\tr_list_free (emitted_debug_locals);\n\tr_list_free (params);\n}", "target": 1, "idx": 11525}
{"commit_id": "486c4dc3b83b4b67d663fb0fa62bc24138ec3946", "project": "openssh/openssh-portable", "func": "char *\ncompat_pkalg_proposal(struct ssh *ssh, char *pkalg_prop)\n{\n\tif (!(ssh->compat & SSH_BUG_RSASIGMD5))\n\t\treturn xstrdup(pkalg_prop);\n\tdebug2_f(\"original public key proposal: %s\", pkalg_prop);\n\tif ((pkalg_prop = match_filter_denylist(pkalg_prop, \"ssh-rsa\")) == NULL)\n\t\tfatal(\"match_filter_denylist failed\");\n\tdebug2_f(\"compat public key proposal: %s\", pkalg_prop);\n\tif (*pkalg_prop == '\\0')\n\t\tfatal(\"No supported PK algorithms found\");\n\treturn pkalg_prop;\n}", "target": 1, "idx": 11526}
{"commit_id": "e59216049cac290fb437a04c4f41ea46826cfba5", "project": "ArtifexSoftware/ghostpdl", "func": "static int\ngsijs_put_params(gx_device *dev, gs_param_list *plist)\n{\n    gx_device_ijs *ijsdev = (gx_device_ijs *)dev;\n    int code = 0;\n    bool is_open = dev->is_open;\n\n    /* We allow duplex to be set in all cases. At some point, it may\n       be worthwhile to query the device to see if it supports\n       duplex. Note also that this code will get called even before\n       the device has been opened, which is when the -DDuplex\n       command line is processed. */\n    if (ijsdev->Duplex_set < 0) {\n        ijsdev->Duplex = 1;\n        ijsdev->Duplex_set = 0;\n    }\n\n    /* If a parameter must not be changed after the device is open,\n     * the last parameter of gsijs_read_xxx() is is_open.\n     * If a parameter may be changed at any time, it is false.\n     */\n    if (code >= 0)\n        code = gsijs_read_string(plist, \"IjsServer\",\n            ijsdev->IjsServer, sizeof(ijsdev->IjsServer),\n            ijsdev->memory->gs_lib_ctx->core->path_control_active, is_open);\n\n    if (code >= 0)\n        code = gsijs_read_string_malloc(plist, \"DeviceManufacturer\",\n            &ijsdev->DeviceManufacturer, &ijsdev->DeviceManufacturer_size,\n            is_open);\n\n    if (code >= 0)\n        code = gsijs_read_string_malloc(plist, \"DeviceModel\",\n            &ijsdev->DeviceModel, &ijsdev->DeviceModel_size,\n            is_open);\n\n    if (code >= 0)\n        code = gsijs_read_string_malloc(plist, \"IjsParams\",\n            &(ijsdev->IjsParams), &(ijsdev->IjsParams_size), is_open);\n\n    if (code >= 0)\n        code = gsijs_read_int(plist, \"BitsPerSample\", &ijsdev->BitsPerSample,\n                1, 16, is_open);\n\n    if (code >= 0)\n        code = gsijs_read_bool(plist, \"IjsUseOutputFD\",\n                               &ijsdev->IjsUseOutputFD, is_open);\n\n    if (code >= 0) {\n        code = gsijs_read_string_malloc(plist, \"ProcessColorModel\",\n            &ijsdev->ColorSpace, &ijsdev->ColorSpace_size, is_open);\n    }\n\n    if (code >= 0) {\n        code = gsijs_read_bool(plist, \"Tumble\", &ijsdev->IjsTumble, false);\n        if (code == 0)\n            ijsdev->IjsTumble_set = true;\n    }\n\n    if (code >= 0)\n        code = gsijs_set_color_format(ijsdev);\n\n    if (code >= 0)\n        code = gdev_prn_put_params(dev, plist);\n\n    if (code >= 0 && is_open) {\n        code = gsijs_set_generic_params(ijsdev);\n        if (code >= 0)\n          code = gsijs_set_margin_params(ijsdev);\n        if (code < 0)\n            return gs_note_error(gs_error_ioerror);\n    }\n\n    return code;\n}", "target": 2, "idx": 11527}
{"commit_id": "8416ae54ecefa670534f27a31db71d048b9c7f16", "project": "jabberd2", "func": "static void _sx_sasl_client_process(sx_t s, sx_plugin_t p, Gsasl_session *sd, const char *mech, const char *in, int inlen) {\n    _sx_sasl_t ctx = (_sx_sasl_t) p->private;\n    _sx_sasl_sess_t sctx = NULL;\n    char *buf = NULL, *out = NULL, *realm = NULL, **ext_id;\n    char hostname[256];\n    int ret;\n#ifdef HAVE_SSL\n    int i;\n#endif\n    size_t buflen, outlen;\n\n    assert(ctx);\n    assert(ctx->cb);\n\n    if(mech != NULL) {\n        _sx_debug(ZONE, \"auth request from client (mechanism=%s)\", mech);\n\n        if(!gsasl_server_support_p(ctx->gsasl_ctx, mech) || (ctx->cb)(sx_sasl_cb_CHECK_MECH, (void*)mech, NULL, s, ctx->cbarg) != sx_sasl_ret_OK) {\n             _sx_debug(ZONE, \"client requested mechanism (%s) that we didn't offer\", mech);\n             _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INVALID_MECHANISM, NULL), 0);\n             return;\n        }\n\n        /* startup */\n        ret = gsasl_server_start(ctx->gsasl_ctx, mech, &sd);\n        if(ret != GSASL_OK) {\n            _sx_debug(ZONE, \"gsasl_server_start failed, no sasl for this conn; (%d): %s\", ret, gsasl_strerror(ret));\n            _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_TEMPORARY_FAILURE, gsasl_strerror(ret)), 0);\n            return;\n        }\n\n        /* get the realm */\n        (ctx->cb)(sx_sasl_cb_GET_REALM, NULL, (void **) &realm, s, ctx->cbarg);\n\n        /* cleanup any existing session context */\n        sctx = gsasl_session_hook_get(sd);\n        if (sctx != NULL) free(sctx);\n\n        /* allocate and initialize our per session context */\n        sctx = (_sx_sasl_sess_t) calloc(1, sizeof(struct _sx_sasl_sess_st));\n        sctx->s = s;\n        sctx->ctx = ctx;\n        gsasl_session_hook_set(sd, (void *) sctx);\n        gsasl_property_set(sd, GSASL_SERVICE, ctx->appname);\n        gsasl_property_set(sd, GSASL_REALM, realm);\n\n        /* get hostname */\n        hostname[0] = '\\0';\n        gethostname(hostname, 256);\n        hostname[255] = '\\0';\n        gsasl_property_set(sd, GSASL_HOSTNAME, hostname);\n\n        /* get EXTERNAL data from the ssl plugin */\n        ext_id = NULL;\n#ifdef HAVE_SSL\n        for(i = 0; i < s->env->nplugins; i++)\n            if(s->env->plugins[i]->magic == SX_SSL_MAGIC && s->plugin_data[s->env->plugins[i]->index] != NULL)\n                ext_id = ((_sx_ssl_conn_t) s->plugin_data[s->env->plugins[i]->index])->external_id;\n        if (ext_id != NULL) {\n            //_sx_debug(ZONE, \"sasl context ext id '%s'\", ext_id);\n            /* if there is, store it for later */\n            for (i = 0; i < SX_CONN_EXTERNAL_ID_MAX_COUNT; i++)\n                if (ext_id[i] != NULL) {\n                    ctx->ext_id[i] = strdup(ext_id[i]);\n                } else {\n                    ctx->ext_id[i] = NULL;\n                    break;\n                }\n        }\n#endif\n\n        _sx_debug(ZONE, \"sasl context initialised for %d\", s->tag);\n\n        s->plugin_data[p->index] = (void *) sd;\n\n        if(strcmp(mech, \"ANONYMOUS\") == 0) {\n            /*\n             * special case for SASL ANONYMOUS: ignore the initial\n             * response provided by the client and generate a random\n             * authid to use as the jid node for the user, as\n             * specified in XEP-0175\n             */\n            (ctx->cb)(sx_sasl_cb_GEN_AUTHZID, NULL, (void **)&out, s, ctx->cbarg);\n            buf = strdup(out);\n            buflen = strlen(buf);\n        } else if (strstr(in, \"<\") != NULL && strncmp(in, \"=\", strstr(in, \"<\") - in ) == 0) {\n            /* XXX The above check is hackish, but `in` is just weird */\n            /* This is a special case for SASL External c2s. See XEP-0178 */\n            _sx_debug(ZONE, \"gsasl auth string is empty\");\n            buf = strdup(\"\");\n            buflen = strlen(buf);\n        } else {\n            /* decode and process */\n            ret = gsasl_base64_from(in, inlen, &buf, &buflen);\n            if (ret != GSASL_OK) {\n                _sx_debug(ZONE, \"gsasl_base64_from failed, no sasl for this conn; (%d): %s\", ret, gsasl_strerror(ret));\n                _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INCORRECT_ENCODING, gsasl_strerror(ret)), 0);\n                if(buf != NULL) free(buf);\n                return;\n            }\n        }\n\n        ret = gsasl_step(sd, buf, buflen, &out, &outlen);\n    }\n\n    else {\n        /* decode and process */\n        ret = gsasl_base64_from(in, inlen, &buf, &buflen);\n        if (ret != GSASL_OK) {\n            _sx_debug(ZONE, \"gsasl_base64_from failed, no sasl for this conn; (%d): %s\", ret, gsasl_strerror(ret));\n            _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INCORRECT_ENCODING, gsasl_strerror(ret)), 0);\n            return;\n        }\n\n        if(!sd) {\n            _sx_debug(ZONE, \"response send before auth request enabling mechanism (decoded: %.*s)\", buflen, buf);\n            _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_MECH_TOO_WEAK, \"response send before auth request enabling mechanism\"), 0);\n            if(buf != NULL) free(buf);\n            return;\n        }\n        _sx_debug(ZONE, \"response from client (decoded: %.*s)\", buflen, buf);\n        ret = gsasl_step(sd, buf, buflen, &out, &outlen);\n    }\n\n    if(buf != NULL) free(buf);\n\n    /* auth completed */\n    if(ret == GSASL_OK) {\n        _sx_debug(ZONE, \"sasl handshake completed\");\n\n        /* encode the leftover response */\n        ret = gsasl_base64_to(out, outlen, &buf, &buflen);\n        if (ret == GSASL_OK) {\n            /* send success */\n            _sx_nad_write(s, _sx_sasl_success(s, buf, buflen), 0);\n            free(buf);\n\n            /* set a notify on the success nad buffer */\n            ((sx_buf_t) s->wbufq->front->data)->notify = _sx_sasl_notify_success;\n            ((sx_buf_t) s->wbufq->front->data)->notify_arg = (void *) p;\n        }\n        else {\n            _sx_debug(ZONE, \"gsasl_base64_to failed, no sasl for this conn; (%d): %s\", ret, gsasl_strerror(ret));\n            _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INCORRECT_ENCODING, gsasl_strerror(ret)), 0);\n            if(buf != NULL) free(buf);\n        }\n\n        if(out != NULL) free(out);\n\n        return;\n    }\n\n    /* in progress */\n    if(ret == GSASL_NEEDS_MORE) {\n        _sx_debug(ZONE, \"sasl handshake in progress (challenge: %.*s)\", outlen, out);\n\n        /* encode the challenge */\n        ret = gsasl_base64_to(out, outlen, &buf, &buflen);\n        if (ret == GSASL_OK) {\n            _sx_nad_write(s, _sx_sasl_challenge(s, buf, buflen), 0);\n            free(buf);\n        }\n        else {\n            _sx_debug(ZONE, \"gsasl_base64_to failed, no sasl for this conn; (%d): %s\", ret, gsasl_strerror(ret));\n            _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INCORRECT_ENCODING, gsasl_strerror(ret)), 0);\n            if(buf != NULL) free(buf);\n        }\n\n        if(out != NULL) free(out);\n\n        return;\n    }\n\n    if(out != NULL) free(out);\n\n    /* its over */\n    _sx_debug(ZONE, \"sasl handshake failed; (%d): %s\", ret, gsasl_strerror(ret));\n\n    switch (ret) {\n        case GSASL_AUTHENTICATION_ERROR:\n\tcase GSASL_NO_ANONYMOUS_TOKEN:\n\tcase GSASL_NO_AUTHID:\n\tcase GSASL_NO_AUTHZID:\n\tcase GSASL_NO_PASSWORD:\n\tcase GSASL_NO_PASSCODE:\n\tcase GSASL_NO_PIN:\n\tcase GSASL_NO_SERVICE:\n\tcase GSASL_NO_HOSTNAME:\n            out = _sasl_err_NOT_AUTHORIZED;\n            break;\n\tcase GSASL_UNKNOWN_MECHANISM:\n\tcase GSASL_MECHANISM_PARSE_ERROR:\n            out = _sasl_err_INVALID_MECHANISM;\n            break;\n\tcase GSASL_BASE64_ERROR:\n            out = _sasl_err_INCORRECT_ENCODING;\n            break;\n        default:\n            out = _sasl_err_MALFORMED_REQUEST;\n    }\n    _sx_nad_write(s, _sx_sasl_failure(s, out, gsasl_strerror(ret)), 0);\n}", "target": 3, "idx": 11528}
{"commit_id": "93ce93587d36493f2f86921fa79921b3cba63fbb", "project": "torvalds/linux", "func": "long watch_queue_set_filter(struct pipe_inode_info *pipe,\n\t\t\t    struct watch_notification_filter __user *_filter)\n{\n\tstruct watch_notification_type_filter *tf;\n\tstruct watch_notification_filter filter;\n\tstruct watch_type_filter *q;\n\tstruct watch_filter *wfilter;\n\tstruct watch_queue *wqueue = pipe->watch_queue;\n\tint ret, nr_filter = 0, i;\n\n\tif (!wqueue)\n\t\treturn -ENODEV;\n\n\tif (!_filter) {\n\t\t/* Remove the old filter */\n\t\twfilter = NULL;\n\t\tgoto set;\n\t}\n\n\t/* Grab the user's filter specification */\n\tif (copy_from_user(&filter, _filter, sizeof(filter)) != 0)\n\t\treturn -EFAULT;\n\tif (filter.nr_filters == 0 ||\n\t    filter.nr_filters > 16 ||\n\t    filter.__reserved != 0)\n\t\treturn -EINVAL;\n\n\ttf = memdup_user(_filter->filters, filter.nr_filters * sizeof(*tf));\n\tif (IS_ERR(tf))\n\t\treturn PTR_ERR(tf);\n\n\tret = -EINVAL;\n\tfor (i = 0; i < filter.nr_filters; i++) {\n\t\tif ((tf[i].info_filter & ~tf[i].info_mask) ||\n\t\t    tf[i].info_mask & WATCH_INFO_LENGTH)\n\t\t\tgoto err_filter;\n\t\t/* Ignore any unknown types */\n\t\tif (tf[i].type >= WATCH_TYPE__NR)\n\t\t\tcontinue;\n\t\tnr_filter++;\n\t}\n\n\t/* Now we need to build the internal filter from only the relevant\n\t * user-specified filters.\n\t */\n\tret = -ENOMEM;\n\twfilter = kzalloc(struct_size(wfilter, filters, nr_filter), GFP_KERNEL);\n\tif (!wfilter)\n\t\tgoto err_filter;\n\twfilter->nr_filters = nr_filter;\n\n\tq = wfilter->filters;\n\tfor (i = 0; i < filter.nr_filters; i++) {\n\t\tif (tf[i].type >= WATCH_TYPE__NR)\n\t\t\tcontinue;\n\n\t\tq->type\t\t\t= tf[i].type;\n\t\tq->info_filter\t\t= tf[i].info_filter;\n\t\tq->info_mask\t\t= tf[i].info_mask;\n\t\tq->subtype_filter[0]\t= tf[i].subtype_filter[0];\n\t\t__set_bit(q->type, wfilter->type_filter);\n\t\tq++;\n\t}\n\n\tkfree(tf);\nset:\n\tpipe_lock(pipe);\n\twfilter = rcu_replace_pointer(wqueue->filter, wfilter,\n\t\t\t\t      lockdep_is_held(&pipe->mutex));\n\tpipe_unlock(pipe);\n\tif (wfilter)\n\t\tkfree_rcu(wfilter, rcu);\n\treturn 0;\n\nerr_filter:\n\tkfree(tf);\n\treturn ret;\n}", "target": 2, "idx": 11529}
{"commit_id": "129e41f9f63885ad8224ef413c2860788fb9e849", "project": "wireshark", "func": "static block_return_val\npcapng_read_block(wtap *wth, FILE_T fh, pcapng_t *pn, wtapng_block_t *wblock, int *err, gchar **err_info)\n{\n    block_return_val ret;\n    pcapng_block_header_t bh;\n    guint32 block_total_length;\n\n    wblock->block = NULL;\n\n    /* Try to read the (next) block header */\n    if (!wtap_read_bytes_or_eof(fh, &bh, sizeof bh, err, err_info)) {\n        pcapng_debug(\"pcapng_read_block: wtap_read_bytes_or_eof() failed, err = %d.\", *err);\n        if (*err == 0 || *err == WTAP_ERR_SHORT_READ) {\n            /*\n             * Short read or EOF.\n             *\n             * If we're reading this as part of an open,\n             * the file is too short to be a pcap-ng file.\n             *\n             * If we're not, we treat PCAPNG_BLOCK_NOT_SHB and\n             * PCAPNG_BLOCK_ERROR the same, so we can just return\n             * PCAPNG_BLOCK_NOT_SHB in both cases.\n             */\n            return PCAPNG_BLOCK_NOT_SHB;\n        }\n        return PCAPNG_BLOCK_ERROR;\n    }\n\n    /*\n     * SHBs have to be treated differently from other blocks, as we\n     * might be doing an open and attempting to read a block at the\n     * beginning of the file to see if it's a pcap-ng file or not,\n     * and as they do not necessarily have the same byte order as\n     * previous blocks.\n     */\n    if (bh.block_type == BLOCK_TYPE_SHB) {\n        /*\n         * BLOCK_TYPE_SHB has the same value regardless of byte order,\n         * so we don't need to byte-swap it.\n         */\n        wblock->type = bh.block_type;\n\n        pcapng_debug(\"pcapng_read_block: block_type 0x%x\", bh.block_type);\n\n        ret = pcapng_read_section_header_block(fh, &bh, pn, wblock, err, err_info);\n        if (ret != PCAPNG_BLOCK_OK) {\n            return ret;\n        }\n    } else {\n        if (pn->byte_swapped) {\n            bh.block_type         = GUINT32_SWAP_LE_BE(bh.block_type);\n            bh.block_total_length = GUINT32_SWAP_LE_BE(bh.block_total_length);\n        }\n\n        wblock->type = bh.block_type;\n\n        pcapng_debug(\"pcapng_read_block: block_type 0x%x\", bh.block_type);\n\n        if (!pn->shb_read) {\n            /*\n             * No SHB seen yet, so we're trying to read the first block\n             * during an open, to see whether it's an SHB; if what we\n             * read doesn't look like an SHB, this isn't a pcap-ng file.\n             */\n            *err = 0;\n            *err_info = NULL;\n            return PCAPNG_BLOCK_NOT_SHB;\n        }\n\n        /* Don't try to allocate memory for a huge number of options, as\n           that might fail and, even if it succeeds, it might not leave\n           any address space or memory+backing store for anything else.\n\n           We do that by imposing a maximum block size of MAX_BLOCK_SIZE. */\n        if (bh.block_total_length > MAX_BLOCK_SIZE) {\n            *err = WTAP_ERR_BAD_FILE;\n            *err_info = g_strdup_printf(\"pcapng_read_block: total block length %u is too large (> %u)\",\n                                        bh.block_total_length, MAX_BLOCK_SIZE);\n            return PCAPNG_BLOCK_ERROR;\n        }\n\n        switch (bh.block_type) {\n            case(BLOCK_TYPE_IDB):\n                if (!pcapng_read_if_descr_block(wth, fh, &bh, pn, wblock, err, err_info))\n                    return PCAPNG_BLOCK_ERROR;\n                break;\n            case(BLOCK_TYPE_PB):\n                if (!pcapng_read_packet_block(fh, &bh, pn, wblock, err, err_info, FALSE))\n                    return PCAPNG_BLOCK_ERROR;\n                break;\n            case(BLOCK_TYPE_SPB):\n                if (!pcapng_read_simple_packet_block(fh, &bh, pn, wblock, err, err_info))\n                    return PCAPNG_BLOCK_ERROR;\n                break;\n            case(BLOCK_TYPE_EPB):\n                if (!pcapng_read_packet_block(fh, &bh, pn, wblock, err, err_info, TRUE))\n                    return PCAPNG_BLOCK_ERROR;\n                break;\n            case(BLOCK_TYPE_NRB):\n                if (!pcapng_read_name_resolution_block(fh, &bh, pn, wblock, err, err_info))\n                    return PCAPNG_BLOCK_ERROR;\n                break;\n            case(BLOCK_TYPE_ISB):\n                if (!pcapng_read_interface_statistics_block(fh, &bh, pn, wblock, err, err_info))\n                    return PCAPNG_BLOCK_ERROR;\n                break;\n            case(BLOCK_TYPE_SYSDIG_EVENT):\n            /* case(BLOCK_TYPE_SYSDIG_EVF): */\n                if (!pcapng_read_sysdig_event_block(fh, &bh, pn, wblock, err, err_info))\n                    return PCAPNG_BLOCK_ERROR;\n                break;\n            default:\n                pcapng_debug(\"pcapng_read_block: Unknown block_type: 0x%x (block ignored), block total length %d\", bh.block_type, bh.block_total_length);\n                if (!pcapng_read_unknown_block(fh, &bh, pn, wblock, err, err_info))\n                    return PCAPNG_BLOCK_ERROR;\n                break;\n        }\n    }\n\n    /* sanity check: first and second block lengths must match */\n    if (!wtap_read_bytes(fh, &block_total_length, sizeof block_total_length,\n                         err, err_info)) {\n        pcapng_debug(\"pcapng_check_block_trailer: couldn't read second block length\");\n        return PCAPNG_BLOCK_ERROR;\n    }\n\n    if (pn->byte_swapped)\n        block_total_length = GUINT32_SWAP_LE_BE(block_total_length);\n\n    if (block_total_length != bh.block_total_length) {\n        *err = WTAP_ERR_BAD_FILE;\n        *err_info = g_strdup_printf(\"pcapng_check_block_trailer: total block lengths (first %u and second %u) don't match\",\n                                    bh.block_total_length, block_total_length);\n        return PCAPNG_BLOCK_ERROR;\n    }\n    return PCAPNG_BLOCK_OK;\n}", "target": 2, "idx": 11530}
{"commit_id": "6b325fd26bf06bee17abd3fd3fd4b0aa0e74e7b2", "project": "Samsung/mTower", "func": "TEE_Result TEE_PopulateTransientObject(TEE_ObjectHandle object,\n\t\t\t\t       const TEE_Attribute *attrs,\n\t\t\t\t       uint32_t attrCount)\n{\n\tTEE_Result res;\n\tTEE_ObjectInfo info;\n\n\tif (attrCount > 4) {\n\t\tTEE_Panic(TEE_ERROR_BAD_PARAMETERS);\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\tstruct utee_attribute ua[attrCount];\n\n\t__utee_check_attr_in_annotation(attrs, attrCount);\n\n\tres = utee_cryp_obj_get_info((unsigned long)object, &info);\n\tif (res != TEE_SUCCESS)\n\t\tTEE_Panic(res);\n\n\t/* Must be a transient object */\n\tif ((info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)\n\t\tTEE_Panic(0);\n\n\t/* Must not be initialized already */\n\tif ((info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)\n\t\tTEE_Panic(0);\n\n\t__utee_from_attr(ua, attrs, attrCount);\n\tres = utee_cryp_obj_populate((unsigned long)object, ua, attrCount);\n\tif (res != TEE_SUCCESS && res != TEE_ERROR_BAD_PARAMETERS)\n\t\tTEE_Panic(res);\n\treturn res;\n}", "target": 2, "idx": 11531}
{"commit_id": "d8cc503575463ff3d81b22dad292665f2c88911e", "project": "pdfium", "func": "OPJ_UINT32 opj_tcd_get_decoded_tile_size ( opj_tcd_t *p_tcd )\n{\n        OPJ_UINT32 i;\n        OPJ_UINT32 l_data_size = 0;\n        opj_image_comp_t * l_img_comp = 00;\n        opj_tcd_tilecomp_t * l_tile_comp = 00;\n        opj_tcd_resolution_t * l_res = 00;\n        OPJ_UINT32 l_size_comp, l_remaining;\n        OPJ_UINT32 l_temp;\n\n        l_tile_comp = p_tcd->tcd_image->tiles->comps;\n        l_img_comp = p_tcd->image->comps;\n\n        for (i=0;i<p_tcd->image->numcomps;++i) {\n                l_size_comp = l_img_comp->prec >> 3; /*(/ 8)*/\n                l_remaining = l_img_comp->prec & 7;  /* (%8) */\n\n                if(l_remaining) {\n                        ++l_size_comp;\n                }\n\n                if (l_size_comp == 3) {\n                        l_size_comp = 4;\n                }\n\n                l_res = l_tile_comp->resolutions + l_tile_comp->minimum_num_resolutions - 1;\n                l_temp = (OPJ_UINT32)((l_res->x1 - l_res->x0) * (l_res->y1 - l_res->y0)); /* x1*y1 can't overflow */\n\n                if (l_size_comp && ((OPJ_UINT32)-1) / l_size_comp < l_temp) {\n                        return (OPJ_UINT32)-1;\n                }\n                l_temp *= l_size_comp;\n\n                if (l_temp > ((OPJ_UINT32)-1) - l_data_size) {\n                        return (OPJ_UINT32)-1;\n                }\n                l_data_size += l_temp;\n\n                ++l_img_comp;\n                ++l_tile_comp;\n        }\n\n        return l_data_size;\n}", "target": 2, "idx": 11532}
{"commit_id": "76e313745e813f80e8910aceb2210af3ad8cf897", "project": "Exiv2/exiv2", "func": "int CommentValue::read(const std::string& comment)\n    {\n        std::string c = comment;\n        CharsetId charsetId = undefined;\n        if (comment.length() > 8 && comment.substr(0, 8) == \"charset=\") {\n            std::string::size_type pos = comment.find_first_of(' ');\n            std::string name = comment.substr(8, pos-8);\n            // Strip quotes (so you can also specify the charset without quotes)\n            if (!name.empty()) {\n                if (name[0] == '\"') name = name.substr(1);\n                if (name[name.length()-1] == '\"') name = name.substr(0, name.length()-1);\n            }\n            charsetId = CharsetInfo::charsetIdByName(name);\n            if (charsetId == invalidCharsetId) {\n#ifndef SUPPRESS_WARNINGS\n                EXV_WARNING << Error(kerInvalidCharset, name) << \"\\n\";\n#endif\n                return 1;\n            }\n            c.clear();\n            if (pos != std::string::npos) c = comment.substr(pos+1);\n        }\n        if (charsetId == unicode) {\n            const char* to = byteOrder_ == littleEndian ? \"UCS-2LE\" : \"UCS-2BE\";\n            convertStringCharset(c, \"UTF-8\", to);\n        }\n        const std::string code(CharsetInfo::code(charsetId), 8);\n        return StringValueBase::read(code + c);\n    }", "target": 1, "idx": 11533}
{"commit_id": "693dc40936a9eeac0e1c10ff496b3d327e25642b", "project": "wireshark", "func": "static int\ndissect_geonw(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\n{\n    guint8 bh_next_header;\n    guint32 ch_next_header;\n    guint32 header_type;\n    guint32 rhl;\n    guint32 tmp_val;\n    gint offset = 0;\n    proto_item *ti;\n    proto_item *top_item;\n    gint hdr_len = 0;\n    guint32 payload_len = 0;\n    guint32 reserved;\n    guint32 timestamp;\n    guint32 sequence_number = SN_MAX + 1;\n    struct geonwheader *geonwh;\n    gint32 latlon;\n\n    geonwh = wmem_new0(pinfo->pool, struct geonwheader);\n\n    col_set_str(pinfo->cinfo, COL_PROTOCOL, \"GEONW\");\n    /* Clear out stuff in the info column */\n    col_clear(pinfo->cinfo,COL_INFO);\n\n    bh_next_header = tvb_get_guint8(tvb, 0) & 0x0f;\n    header_type = tvb_get_guint8(tvb, 5);\n\n    if (bh_next_header == BH_NH_SECURED_PKT) {\n        hdr_len = BH_LEN;\n    }\n    else {\n        hdr_len = BH_LEN + CH_LEN;\n        switch(header_type & HT_MASK) {\n            case HT_BEACON:\n                hdr_len += BEACON_LEN;\n                break;\n            case HT_GEOUNICAST:\n                hdr_len += GUC_LEN;\n                break;\n            case HT_GEOANYCAST:\n                hdr_len += GAC_LEN;\n                break;\n            case HT_GEOBROADCAST:\n                hdr_len += GBC_LEN;\n                break;\n            case HT_TSB:\n                hdr_len += TSB_LEN;\n                break;\n            case HT_LS:\n                hdr_len += LS_REQUEST_LEN;\n                if (header_type == HTST_LS_REPLY) {\n                    hdr_len += (LS_REPLY_LEN - LS_REQUEST_LEN);\n                }\n                break;\n            default:\n                hdr_len = -1;\n        }\n    }\n    top_item = proto_tree_add_item(tree, proto_geonw, tvb, 0, hdr_len, ENC_NA);\n    proto_tree *geonw_tree = proto_item_add_subtree(top_item, ett_geonw);\n\n    // Basic Header subtree\n    ti = proto_tree_add_item(geonw_tree, hf_geonw_bh, tvb, 0, 4, ENC_NA);\n    proto_tree *geonw_bh_tree = proto_item_add_subtree(ti, ett_geonw_bh);\n\n    ti = proto_tree_add_item_ret_uint(geonw_bh_tree, hf_geonw_bh_version, tvb, offset, 1, ENC_BIG_ENDIAN, &tmp_val);\n    geonwh->gnw_ver = tmp_val;\n    // Shall be 0 or 1\n    if (tmp_val > 1) {\n        col_add_fstr(pinfo->cinfo, COL_INFO,\n                     \"Bogus GeoNetworking version (%u, must be less than 2)\", tmp_val);\n        expert_add_info_format(pinfo, ti, &ei_geonw_version_err, \"Bogus GeoNetworking version\");\n        return tvb_captured_length(tvb);\n    }\n    proto_tree_add_item(geonw_bh_tree, hf_geonw_bh_next_header, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset += 1;\n    // Reserved byte\n    // Expert info if not zero?\n    ti = proto_tree_add_item_ret_uint(geonw_bh_tree, hf_geonw_bh_reserved, tvb, offset, 1, ENC_NA, &reserved);\n    if (reserved) {\n        expert_add_info(pinfo, ti, &ei_geonw_nz_reserved);\n    }\n    offset += 1;\n\n    // Subtree and lt_mult and lt_base\n    ti = proto_tree_add_item_ret_uint(geonw_bh_tree, hf_geonw_bh_life_time, tvb, offset, 1, ENC_BIG_ENDIAN, &tmp_val);\n    geonwh->gnw_lt = tmp_val;\n    proto_tree *geonw_bh_lt_tree = proto_item_add_subtree(ti, ett_geonw_bh_lt);\n\n    proto_tree_add_item(geonw_bh_lt_tree, hf_geonw_bh_lt_mult, tvb, offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_item(geonw_bh_lt_tree, hf_geonw_bh_lt_base, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset += 1;\n\n    proto_item *rhl_ti = proto_tree_add_item_ret_uint(geonw_bh_tree, hf_geonw_bh_remain_hop_limit, tvb, offset, 1, ENC_BIG_ENDIAN, &rhl);\n    geonwh->gnw_rhl = rhl;\n    /*\n     * Flag a low RHL if the next header is not a common header\n     */\n    if (rhl < 5 && bh_next_header != BH_NH_COMMON_HDR) {\n        expert_add_info_format(pinfo, rhl_ti, &ei_geonw_rhl_too_low, \"\\\"Remain Hop Limit\\\" only %u\", rhl);\n    }\n    offset += 1;\n\n    if (bh_next_header == BH_NH_SECURED_PKT) {\n        dissect_secured_message(tvb, offset, pinfo, geonw_tree, NULL);\n        tvbuff_t *next_tvb = (tvbuff_t*)p_get_proto_data(pinfo->pool, pinfo, proto_geonw, SEC_TVB_KEY);\n        if (next_tvb) {\n            tvb = next_tvb;\n            bh_next_header = BH_NH_COMMON_HDR;\n            offset = 0;\n            header_type = tvb_get_guint8(tvb, 1);\n\n            hdr_len = CH_LEN;\n            switch(header_type & HT_MASK) {\n                case HT_BEACON:\n                    hdr_len += BEACON_LEN;\n                    break;\n                case HT_GEOUNICAST:\n                    hdr_len += GUC_LEN;\n                    break;\n                case HT_GEOANYCAST:\n                    hdr_len += GAC_LEN;\n                    break;\n                case HT_GEOBROADCAST:\n                    hdr_len += GBC_LEN;\n                    break;\n                case HT_TSB:\n                    hdr_len += TSB_LEN;\n                    break;\n                case HT_LS:\n                    hdr_len += LS_REQUEST_LEN;\n                    if (header_type == HTST_LS_REPLY) {\n                        hdr_len += (LS_REPLY_LEN - LS_REQUEST_LEN);\n                    }\n                    break;\n                default:\n                    hdr_len = -1;\n            }\n        }\n    }\n\n    if (bh_next_header == BH_NH_COMMON_HDR) {\n        // Common Header subtree\n        ti = proto_tree_add_item(geonw_tree, hf_geonw_ch, tvb, offset, 8, ENC_NA);\n        proto_tree *geonw_ch_tree = proto_item_add_subtree(ti, ett_geonw_ch);\n\n        // Next Header\n        proto_tree_add_item_ret_uint(geonw_ch_tree, hf_geonw_ch_next_header, tvb, offset, 1, ENC_BIG_ENDIAN, &ch_next_header);\n        geonwh->gnw_proto = ch_next_header;\n        // Reserved\n        ti = proto_tree_add_item_ret_uint(geonw_ch_tree, hf_geonw_ch_reserved1, tvb, offset, 1, ENC_NA, &reserved);\n        if (reserved) {\n            expert_add_info(pinfo, ti, &ei_geonw_nz_reserved);\n        }\n        offset += 1;\n\n        // HT\n        proto_tree_add_item_ret_uint(geonw_ch_tree, hf_geonw_ch_header_type, tvb, offset, 1, ENC_BIG_ENDIAN, &header_type);\n        geonwh->gnw_htype = header_type;\n        col_add_str(pinfo->cinfo, COL_INFO, val_to_str(header_type, ch_header_type_names, \"Unknown (%u)\"));\n        offset += 1;\n\n        /* Now that we know the header type, lets add expert info on RHL\n         * RHL shall be\n         *  = 1 if parameter Packet transport type in the service primitive\n         *    GN-DATA.request is SHB, or if Header type HT = 1 (BEACON)\n         *  = Value of optional Maximum hop limit parameter from service\n         *    primitive GN-DATA.request\n         *  = Otherwise GN protocol constant itsGnDefaultHopLimit if\n         *    GN-DATA.request parameter Packet transport type is GUC, GBC, GBC\n         *    or TSB\n         * Flag a low RHL if the packet is not BEACON or SHB.\n         */\n        if (header_type == HTST_BEACON || header_type == HTST_TSB_SINGLE) {\n            if (rhl > 1) {\n                expert_add_info_format(pinfo, rhl_ti, &ei_geonw_rhl_lncb, \"\\\"Remain Hop Limit\\\" != 1 for BEACON or SHB (%u)\", rhl);\n            }\n        } else if (rhl < 5) {\n            expert_add_info_format(pinfo, rhl_ti, &ei_geonw_rhl_too_low, \"\\\"Remain Hop Limit\\\" only %u\", rhl);\n        }\n\n        // TC\n        ti = proto_tree_add_item_ret_uint(geonw_ch_tree, hf_geonw_ch_traffic_class, tvb, offset, 1, ENC_BIG_ENDIAN, &tmp_val);\n        geonwh->gnw_tc = tmp_val;\n        proto_tree *geonw_ch_tc_tree = proto_item_add_subtree(ti, ett_geonw_ch_tc);\n\n        proto_tree_add_item(geonw_ch_tc_tree, hf_geonw_ch_tc_scf, tvb, offset, 1, ENC_BIG_ENDIAN);\n        proto_tree_add_item(geonw_ch_tc_tree, hf_geonw_ch_tc_offload, tvb, offset, 1, ENC_BIG_ENDIAN);\n        proto_tree_add_item(geonw_ch_tc_tree, hf_geonw_ch_tc_id, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset += 1;\n\n        ti = proto_tree_add_item(geonw_ch_tree, hf_geonw_ch_flags, tvb, offset, 1, ENC_NA);\n        proto_tree *geonw_ch_flag_tree = proto_item_add_subtree(ti, ett_geonw_ch_tc);\n        // Flag (itsGnIsMobile)\n        proto_tree_add_item_ret_uint(geonw_ch_flag_tree, hf_geonw_ch_flags_mob, tvb, offset, 1, ENC_BIG_ENDIAN, &tmp_val);\n        geonwh->gnw_flags = tmp_val;\n        ti = proto_tree_add_item_ret_uint(geonw_ch_flag_tree, hf_geonw_ch_flags_reserved, tvb, offset, 1, ENC_BIG_ENDIAN, &reserved);\n        if (reserved & 0x7f) {\n            expert_add_info(pinfo, ti, &ei_geonw_nz_reserved);\n        }\n        offset += 1;\n\n        // PL (16 bits)\n        ti = proto_tree_add_item_ret_uint(geonw_ch_tree, hf_geonw_ch_payload_length, tvb, offset, 2, ENC_BIG_ENDIAN, &payload_len);\n        geonwh->gnw_len = payload_len;\n        if (hdr_len > 0) { // We know the length of the header\n            if (payload_len) {\n                if (((header_type & HT_MASK) == HT_LS) || (header_type == HT_BEACON)) {\n                    expert_add_info(pinfo, ti, &ei_geonw_nz_reserved);\n                }\n                else if ((payload_len + (unsigned) hdr_len) > tvb_reported_length(tvb)) {\n                    expert_add_info(pinfo, ti, &ei_geonw_payload_len);\n                }\n                else {\n                    /*\n                     * Now that we know that the total length of this GNW datagram isn't\n                     * obviously bogus, adjust the length of this tvbuff to include only\n                     * the GNW datagram.\n                     */\n                    set_actual_length(tvb, hdr_len + payload_len);\n                }\n            }\n            else {\n                set_actual_length(tvb, hdr_len);\n            }\n        }\n        offset += 2;\n\n        // MHL\n        proto_tree_add_item_ret_uint(geonw_ch_tree, hf_geonw_ch_max_hop_limit, tvb, offset, 1, ENC_BIG_ENDIAN, &tmp_val);\n        geonwh->gnw_mhl = tmp_val;\n        // Expert mhl < rhl: packet will be ignored\n        if (tmp_val < rhl) {\n            expert_add_info_format(pinfo, rhl_ti, &ei_geonw_mhl_lt_rhl, \"Ignored: \\\"Remain Hop Limit\\\" > %u (mhl)\", tmp_val);\n        }\n        offset += 1;\n\n        // Reserved...\n        ti = proto_tree_add_item_ret_uint(geonw_ch_tree, hf_geonw_ch_reserved2, tvb, offset, 1, ENC_NA, &reserved);\n        // Expert info if not zero\n        if (reserved) {\n            expert_add_info(pinfo, ti, &ei_geonw_nz_reserved);\n        }\n        offset += 1;\n\n        // Stop here if header_type unknown\n        if (!IS_HT_KNOWN(header_type)) {\n            // Update top level tree item\n            proto_item_set_end(top_item, tvb, offset);\n            return tvb_reported_length(tvb);\n        }\n\n        geonwh->gnw_sn = SN_MAX+1;\n\n        proto_tree *geonw_sh_tree;\n        switch(header_type & HT_MASK) {\n            case HT_BEACON:\n                ti = proto_tree_add_item(geonw_tree, hf_geonw_beacon, tvb, offset, hdr_len-offset, ENC_NA);\n                break;\n            case HT_GEOUNICAST:\n                ti = proto_tree_add_item(geonw_tree, hf_geonw_guc, tvb, offset, hdr_len-offset, ENC_NA);\n                break;\n            case HT_GEOANYCAST:\n                ti = proto_tree_add_item(geonw_tree, hf_geonw_gac, tvb, offset, hdr_len-offset, ENC_NA);\n                break;\n            case HT_GEOBROADCAST:\n                ti = proto_tree_add_item(geonw_tree, hf_geonw_gbc, tvb, offset, hdr_len-offset, ENC_NA);\n                break;\n            case HT_TSB:\n                ti = proto_tree_add_item(geonw_tree, hf_geonw_tsb, tvb, offset, hdr_len-offset, ENC_NA);\n                break;\n            case HT_LS:\n                ti = proto_tree_add_item(geonw_tree, hf_geonw_ls, tvb, offset, hdr_len-offset, ENC_NA);\n                break;\n            default:\n                // Exit if header_type unknown?\n                return tvb_captured_length(tvb);\n        }\n        geonw_sh_tree = proto_item_add_subtree(ti, ett_geonw_sh);\n\n        switch(header_type) {\n            case HTST_GEOUNICAST:\n            case HTST_GAC_CIRCLE:\n            case HTST_GAC_RECT:\n            case HTST_GAC_ELLIPSE:\n            case HTST_GBC_CIRCLE:\n            case HTST_GBC_RECT:\n            case HTST_GBC_ELLIPSE:\n            case HTST_TSB_MULT:\n            case HTST_LS_REQUEST:\n            case HTST_LS_REPLY:\n                // Seq num\n                proto_tree_add_item_ret_uint(geonw_sh_tree, hf_geonw_seq_num, tvb, offset, 2, ENC_BIG_ENDIAN, &sequence_number);\n                geonwh->gnw_sn = sequence_number;\n                offset += 2;\n                // 16 bits reserved\n                ti = proto_tree_add_item_ret_uint(geonw_sh_tree, hf_geonw_reserved, tvb, offset, 2, ENC_BIG_ENDIAN, &reserved);\n                // Expert info if not zero?\n                if (reserved) {\n                    expert_add_info(pinfo, ti, &ei_geonw_nz_reserved);\n                }\n                offset += 2;\n            case HTST_TSB_SINGLE:\n            case HTST_BEACON:\n                break;\n        }\n\n        // Every packet has source address\n        ti = proto_tree_add_item(geonw_sh_tree, hf_geonw_so_pv, tvb, offset, 24, ENC_NA);\n        proto_tree *geonw_so_tree = proto_item_add_subtree(ti, ett_geonw_so);\n\n        ti = proto_tree_add_item(geonw_so_tree, hf_geonw_so_pv_addr, tvb, offset, 8, ENC_NA);\n        proto_tree *geonw_so_add_tree = proto_item_add_subtree(ti, ett_geonw_so);\n        set_address_tvb(&pinfo->net_src, geonw_address_type, 8, tvb, offset);\n        copy_address_shallow(&pinfo->src, &pinfo->net_src);\n        copy_address_shallow(&geonwh->gnw_src, &pinfo->src);\n\n        proto_tree_add_item(geonw_so_add_tree, hf_geonw_so_pv_addr_manual, tvb, offset, 1, ENC_BIG_ENDIAN);\n        proto_tree_add_item(geonw_so_add_tree, hf_geonw_so_pv_addr_type, tvb, offset, 1, ENC_BIG_ENDIAN);\n        ti = proto_tree_add_item_ret_uint(geonw_so_add_tree, hf_geonw_so_pv_addr_country, tvb, offset, 2, ENC_BIG_ENDIAN, &reserved);\n        if (reserved > 999) {\n            expert_add_info(pinfo, ti, &ei_geonw_scc_too_big);\n        }\n        offset += 2;\n        proto_tree_add_item(geonw_so_add_tree, hf_geonw_so_pv_addr_mid, tvb, offset, 6, ENC_NA);\n        offset += 6;\n\n        proto_tree_add_item_ret_uint(geonw_so_tree, hf_geonw_so_pv_time, tvb, offset, 4, ENC_BIG_ENDIAN, &timestamp);\n        geonwh->gnw_tst = timestamp;\n\n        // XXX Is it possible to \"follow\" a station when updating its GN_ADDR?\n\n        if(geonw_analyze_seq && (geonwh->gnw_ver==0) && !(pinfo->fd->visited)) {\n            // Duplication detection uses SN and TST or only TST (see Annex A of ETSI EN 302 636-4-1)\n            // We rely on address type and hashtable as this shall be done on a per station basis (i.e. not over a conversation)\n            // We do not try to consider GN_ADDR updates (due to duplicate address detection or anonymous setting)\n            hashgeonw_t *tp = (hashgeonw_t *)wmem_map_lookup(geonw_hashtable, pinfo->net_src.data);\n            if (tp == NULL) {\n                tp = geonw_hash_new_entry((const guint8 *)pinfo->net_src.data, FALSE);\n                tp->sequence_number = sequence_number;\n                tp->timestamp = timestamp;\n            } else {\n                if ((sequence_number <= SN_MAX) && (tp->sequence_number > SN_MAX)) {\n                    tp->sequence_number = sequence_number;\n                    tp->timestamp = timestamp;\n                }\n                else if (sequence_number <= SN_MAX) {\n                    /*\n                     * 1   P is the received GeoNetworking packet\n                     * 2   SN(P) is the sequence number in the received GeoNetworking packet\n                     * 3   SN(SO) is the last received sequence number from source SO\n                     * 4   SN_MAX is the maximum sequence number = 2^16 - 1\n                     * 5   TST(P) is the timestamp in the received GeoNetworking packet\n                     * 6   TST(SO) is the last received timestamp from source SO\n                     * 7   TST_MAX is the maximum value of the timestamp = 2^32 - 1\n                     * 8\n                     * 9   IF (((TST(P) > TST(SO) AND ((TST(P) - TST(SO)) <= TST_MAX/2)) OR\n                     *             ((TST(SO) > TST(P)) AND ((TST(SO) - TST(P)) > TST_MAX/2))) THEN\n                     * 10                                                  # TST(P) is greater than TST(SO)\n                     * 11      TST(SO) = TST(P)\n                     * 12      SN(SO) = SN(P)                              # P is not a duplicate packet\n                     * 13  ELSEIF TST(P) = TST(SO) THEN\n                     * 14      IF (((SN(P) > SN(SO) AND ((SN(P) - SN(SO)) <= SN_MAX/2)) OR\n                     *              ((SN(SO) > SN(P)) AND ((SN(SO) - SN(P)) > SN_MAX/2))) THEN\n                     * 15                                                  # SN(P) is greater than SN(SO)\n                     * 16          TST(SO) = TST(P)\n                     * 17          SN(SO) = SN(P)                          # P is not a duplicate packet\n                     * 18      ELSE\n                     * 19                                                  # SN(P) is not greater than SN(SO)\n                     * 20                                                  # P is a duplicate\n                     * 21      ENDIF\n                     * 22  ELSE\n                     * 23                                                  # TST(P) not greater than TST(SO)\n                     * 24  ENDIF\n                     */\n                    if (((timestamp > tp->timestamp) && (((guint64)timestamp - (guint64)tp->timestamp) <= (guint64)TST_MAX/2)) ||\n                            ((tp->timestamp > timestamp) && (((guint64)tp->timestamp - (guint64)timestamp) > (guint64)TST_MAX/2))) {\n                                                                    // TST(P) is greater than TST(SO)\n                        tp->sequence_number = sequence_number;\n                        tp->timestamp = timestamp;                  // P is not a duplicate packet\n                    } else if (timestamp == tp->timestamp) {\n                        if (((sequence_number > tp->sequence_number) && ((sequence_number - tp->sequence_number) <= SN_MAX/2)) ||\n                             ((tp->sequence_number > sequence_number) && ((tp->sequence_number - sequence_number) > SN_MAX/2))) {\n                                                                    // SN(P) is greater than SN(SO)\n                            tp->timestamp = timestamp;\n                            tp->sequence_number = sequence_number;  // P is not a duplicate packet\n                        } else {\n                                                                    // SN(P) is not greater than SN(SO)\n                                                                    // P is a duplicate\n                            ti = proto_tree_add_item(geonw_tree, hf_geonw_analysis_flags, tvb, 0, 0, ENC_NA);\n                            proto_item_set_generated(ti);\n                            expert_add_info(pinfo, ti, &ei_geonw_analysis_duplicate);\n                            col_prepend_fence_fstr(pinfo->cinfo, COL_INFO, \"[Duplicate packet] \");\n                        }\n                    } // else { # TST(P) not greater than TST(SO) }\n                }\n                else {\n                    /*\n                     * 1   P is the received GeoNetworking packet\n                     * 2   TST(P) is the timestamp in the received GeoNetworking packet\n                     * 3   TST(SO) is the last received timestamp from source SO\n                     * 4   TS_MAX is the maximum value of the timestamp = 2^32 - 1\n                     * 5\n                     * 6   IF (((TST(P) > TST(SO) AND ((TST(P) - TST(SO)) <= TST_MAX/2)) OR\n                     *             ((TST(SO) > TST(P)) AND ((TST(SO) - TST(P)) > TST_MAX/2))) THEN\n                     * 7                                       # TST(P) is greater than TST(SO)\n                     * 8       TST(SO) = TST(P)                # P is not a duplicate packet\n                     * 9   ELSE\n                     * 10                                      # P is a duplicate\n                     * 11  ENDIF\n                     */\n                    if (((timestamp > tp->timestamp) && (((guint64)timestamp - (guint64)tp->timestamp) <= (guint64)TST_MAX/2)) ||\n                            ((tp->timestamp > timestamp) && (((guint64)tp->timestamp - (guint64)timestamp) > (guint64)TST_MAX/2))) {\n                                                        // TST(P) is greater than TST(SO)\n                        tp->timestamp = timestamp;      // P is not a duplicate packet\n                    } else {\n                                                        // P is a duplicate\n                        ti = proto_tree_add_item(geonw_tree, hf_geonw_analysis_flags, tvb, 0, 0, ENC_NA);\n                        proto_item_set_generated(ti);\n                        expert_add_info(pinfo, ti, &ei_geonw_analysis_duplicate);\n                        col_prepend_fence_fstr(pinfo->cinfo, COL_INFO, \"[Duplicate packet] \");\n                    }\n                }\n            }\n        }\n        // XXX Implement DPD if version == 1\n\n        offset += 4;\n        ti = proto_tree_add_item_ret_int(geonw_so_tree, hf_geonw_so_pv_lat, tvb, offset, 4, ENC_BIG_ENDIAN, &latlon);\n        if (latlon < -900000000 || latlon > 900000000) {\n            expert_add_info_format(pinfo, ti, &ei_geonw_out_of_range, \"Latitude out of range (%f)\", (float)latlon/10000000);\n        }\n        geonwh->gnw_lat = latlon;\n        offset += 4;\n        ti = proto_tree_add_item_ret_int(geonw_so_tree, hf_geonw_so_pv_lon, tvb, offset, 4, ENC_BIG_ENDIAN, &latlon);\n        if (latlon < -1800000000 || latlon > 1800000000) {\n            expert_add_info_format(pinfo, ti, &ei_geonw_out_of_range, \"Longitude out of range (%f)\", (float)latlon/10000000);\n        }\n        geonwh->gnw_lon = latlon;\n        offset += 4;\n        proto_tree_add_item(geonw_so_tree, hf_geonw_so_pv_pai, tvb, offset, 1, ENC_BIG_ENDIAN);\n        proto_tree_add_item(geonw_so_tree, hf_geonw_so_pv_speed, tvb, offset, 2, ENC_BIG_ENDIAN);\n        offset += 2;\n        ti = proto_tree_add_item_ret_uint(geonw_so_tree, hf_geonw_so_pv_heading, tvb, offset, 2, ENC_BIG_ENDIAN, &tmp_val);\n        if (tmp_val > 3600) {\n            expert_add_info_format(pinfo, ti, &ei_geonw_out_of_range, \"Out of range [0..360] (%f)\", (float)tmp_val/10);\n        }\n        offset += 2;\n\n        proto_tree *geonw_de_tree = NULL;\n        proto_tree *geonw_de_add_tree = NULL;\n        switch(header_type) {\n            case HTST_GEOUNICAST:\n            case HTST_LS_REPLY:\n                // Destination address\n                ti = proto_tree_add_item(geonw_sh_tree, hf_geonw_de_pv, tvb, offset, 20, ENC_NA);\n                geonw_de_tree = proto_item_add_subtree(ti, ett_geonw_de);\n\n                ti = proto_tree_add_item(geonw_de_tree, hf_geonw_de_pv_addr, tvb, offset, 8, ENC_NA);\n                geonw_de_add_tree = proto_item_add_subtree(ti, ett_geonw_de);\n                set_address_tvb(&pinfo->net_dst, geonw_address_type, 8, tvb, offset);\n                copy_address_shallow(&pinfo->dst, &pinfo->net_dst);\n                copy_address_shallow(&geonwh->gnw_dst, &pinfo->dst);\n\n                if (header_type == HTST_LS_REPLY) {\n                    transaction_end(pinfo, geonw_tree);\n                }\n\n                proto_tree_add_item(geonw_de_add_tree, hf_geonw_de_pv_addr_manual, tvb, offset, 1, ENC_BIG_ENDIAN);\n                proto_tree_add_item(geonw_de_add_tree, hf_geonw_de_pv_addr_type, tvb, offset, 1, ENC_BIG_ENDIAN);\n                ti = proto_tree_add_item_ret_uint(geonw_de_add_tree, hf_geonw_de_pv_addr_country, tvb, offset, 2, ENC_BIG_ENDIAN, &reserved);\n                if (reserved > 999) {\n                    expert_add_info(pinfo, ti, &ei_geonw_scc_too_big);\n                }\n                offset += 2;\n                proto_tree_add_item(geonw_de_add_tree, hf_geonw_de_pv_addr_mid, tvb, offset, 6, ENC_NA);\n                offset += 6;\n\n                proto_tree_add_item(geonw_de_tree, hf_geonw_de_pv_time, tvb, offset, 4, ENC_BIG_ENDIAN);\n                offset += 4;\n                ti = proto_tree_add_item_ret_int(geonw_de_tree, hf_geonw_de_pv_lat, tvb, offset, 4, ENC_BIG_ENDIAN, &latlon);\n                if (latlon < -900000000 || latlon > 900000000) {\n                    expert_add_info_format(pinfo, ti, &ei_geonw_out_of_range, \"Latitude out of range (%f)\", (float)latlon/10000000);\n                }\n                offset += 4;\n                ti = proto_tree_add_item_ret_int(geonw_de_tree, hf_geonw_de_pv_lon, tvb, offset, 4, ENC_BIG_ENDIAN, &latlon);\n                if (latlon < -1800000000 || latlon > 1800000000) {\n                    expert_add_info_format(pinfo, ti, &ei_geonw_out_of_range, \"Longitude out of range (%f)\", (float)latlon/10000000);\n                }\n                offset += 4;\n                break;\n            case HTST_TSB_SINGLE:\n                // Reserved 32 bits\n                // See usage in 636-4 subpart 2 for ITS-5G\n                reserved = tvb_get_guint32(tvb, offset, ENC_BIG_ENDIAN);\n                if (reserved) {\n                    ti = proto_tree_add_item(geonw_sh_tree, hf_geonw_dccmco, tvb, offset, 4, ENC_NA);\n                    proto_tree *dccmco = proto_item_add_subtree(ti, ett_geonw_dccmco);\n                    proto_tree_add_item(dccmco, hf_geonw_dccmco_cbr_l_0_hop, tvb, offset, 1, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(dccmco, hf_geonw_dccmco_cbr_l_1_hop, tvb, offset+1, 1, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(dccmco, hf_geonw_dccmco_output_power, tvb, offset+2, 1, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(dccmco, hf_geonw_dccmco_reserved, tvb, offset+2, 1, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(dccmco, hf_geonw_shb_reserved, tvb, offset+3, 1, ENC_BIG_ENDIAN);\n                }\n                else {\n                    proto_tree_add_item(geonw_sh_tree, hf_geonw_shb_reserved, tvb, offset, 4, ENC_BIG_ENDIAN);\n                }\n                offset += 4;\n                break;\n            case HTST_GAC_CIRCLE:\n            case HTST_GAC_RECT:\n            case HTST_GAC_ELLIPSE:\n            case HTST_GBC_CIRCLE:\n            case HTST_GBC_RECT:\n            case HTST_GBC_ELLIPSE:\n                ti = proto_tree_add_item_ret_int(geonw_sh_tree, hf_geonw_gxc_latitude, tvb, offset, 4, ENC_BIG_ENDIAN, &latlon);\n                if (latlon < -900000000 || latlon > 900000000) {\n                    expert_add_info_format(pinfo, ti, &ei_geonw_out_of_range, \"Latitude out of range (%f)\", (float)latlon/10000000);\n                }\n                offset += 4;\n                ti = proto_tree_add_item_ret_int(geonw_sh_tree, hf_geonw_gxc_longitude, tvb, offset, 4, ENC_BIG_ENDIAN, &latlon);\n                if (latlon < -1800000000 || latlon > 1800000000) {\n                    expert_add_info_format(pinfo, ti, &ei_geonw_out_of_range, \"Longitude out of range (%f)\", (float)latlon/10000000);\n                }\n                offset += 4;\n                switch(header_type&0x0f) {\n                    case HST_CIRCULAR:\n                        /*\n                         * According to EN 302 363-4-1:\n                         * In case of a circular area (GeoNetworking packet\n                         * sub-type HST = 0), the fields shall be set to the\n                         * following values:\n                         *  1) Distance a is set to the radius r.\n                         *  2) Distance b is set to 0.\n                         *  3) Angle is set to 0.\n                         */\n                        proto_tree_add_item(geonw_sh_tree, hf_geonw_gxc_radius, tvb, offset, 2, ENC_BIG_ENDIAN);\n                        offset += 2;\n                        ti = proto_tree_add_item_ret_uint(geonw_sh_tree, hf_geonw_gxc_distanceb, tvb, offset, 2, ENC_BIG_ENDIAN, &reserved);\n                        if (reserved) {\n                            expert_add_info(pinfo, ti, &ei_geonw_nz_reserved);\n                        }\n                        offset += 2;\n                        ti = proto_tree_add_item_ret_uint(geonw_sh_tree, hf_geonw_gxc_angle, tvb, offset, 2, ENC_BIG_ENDIAN, &reserved);\n                        if (reserved) {\n                            expert_add_info(pinfo, ti, &ei_geonw_nz_reserved);\n                        }\n                        offset += 2;\n                        break;\n                    case HST_RECTANGULAR:\n                    case HST_ELLIPSOIDAL:\n                        proto_tree_add_item(geonw_sh_tree, hf_geonw_gxc_distancea, tvb, offset, 2, ENC_BIG_ENDIAN);\n                        offset += 2;\n                        proto_tree_add_item(geonw_sh_tree, hf_geonw_gxc_distanceb, tvb, offset, 2, ENC_BIG_ENDIAN);\n                        offset += 2;\n                        ti = proto_tree_add_item_ret_uint(geonw_sh_tree, hf_geonw_gxc_angle, tvb, offset, 2, ENC_BIG_ENDIAN, &tmp_val);\n                        if (tmp_val > 360) {\n                            expert_add_info_format(pinfo, ti, &ei_geonw_out_of_range, \"Out of range [0..360] (%f)\", (float)tmp_val);\n                        }\n                        offset += 2;\n                }\n                ti = proto_tree_add_item_ret_uint(geonw_sh_tree, hf_geonw_gxc_reserved, tvb, offset, 2, ENC_BIG_ENDIAN, &reserved);\n                if (reserved) {\n                    expert_add_info(pinfo, ti, &ei_geonw_nz_reserved);\n                }\n                offset += 2;\n                break;\n            case HTST_LS_REQUEST:\n                // GN_ADDR\n                ti = proto_tree_add_item(geonw_sh_tree, hf_geonw_lsrq_addr, tvb, offset, 8, ENC_NA);\n                geonw_de_add_tree = proto_item_add_subtree(ti, ett_geonw_lsrq_add);\n                set_address_tvb(&pinfo->net_dst, geonw_address_type, 8, tvb, offset);\n                copy_address_shallow(&pinfo->dst, &pinfo->net_dst);\n\n                proto_tree_add_item(geonw_de_add_tree, hf_geonw_lsrq_addr_manual, tvb, offset, 1, ENC_BIG_ENDIAN);\n                proto_tree_add_item(geonw_de_add_tree, hf_geonw_lsrq_addr_type, tvb, offset, 1, ENC_BIG_ENDIAN);\n                ti = proto_tree_add_item_ret_uint(geonw_de_add_tree, hf_geonw_lsrq_addr_country, tvb, offset, 2, ENC_BIG_ENDIAN, &reserved);\n                if (reserved > 999) {\n                    expert_add_info(pinfo, ti, &ei_geonw_scc_too_big);\n                }\n                offset += 2;\n                proto_tree_add_item(geonw_de_add_tree, hf_geonw_lsrq_addr_mid, tvb, offset, 6, ENC_NA);\n                offset += 6;\n                transaction_start(pinfo, geonw_tree);\n                break;\n            //case HTST_BEACON:\n            //case HTST_TSB_MULT:\n        }\n        proto_item_set_end(top_item, tvb, offset);\n\n        tap_queue_packet(geonw_tap, pinfo, geonwh);\n\n        if (payload_len) {\n            // TODO expert info if payload_len different from remaining\n            tvbuff_t *next_tvb = tvb_new_subset_length(tvb, offset, payload_len);\n            switch(ch_next_header) {\n                case CH_NH_BTP_A:\n                    call_dissector(btpa_handle, next_tvb, pinfo, tree);\n                    break;\n                case CH_NH_BTP_B:\n                    call_dissector(btpb_handle, next_tvb, pinfo, tree);\n                    break;\n                case CH_NH_IPV6:\n                    call_dissector(ipv6_handle, next_tvb, pinfo, tree);\n                    break;\n                default:\n                    if (!dissector_try_uint(geonw_subdissector_table, ch_next_header, next_tvb, pinfo, tree)) {\n                        call_data_dissector(next_tvb, pinfo, tree);\n                    }\n            }\n        }\n\n    }\n\n    return tvb_captured_length(tvb);\n}", "target": 1, "idx": 11534}
{"commit_id": "8e76aef72820435e766c7f339ed36da33da90c40", "project": "xen-project/xen", "func": "void create_periodic_time(\n    struct vcpu *v, struct periodic_time *pt, uint64_t delta,\n    uint64_t period, uint8_t irq, time_cb *cb, void *data, bool level)\n{\n    if ( !pt->source ||\n         (irq >= NR_ISAIRQS && pt->source == PTSRC_isa) ||\n         (level && period) ||\n         (pt->source == PTSRC_ioapic ? irq >= hvm_domain_irq(v->domain)->nr_gsis\n                                     : level) )\n    {\n        ASSERT_UNREACHABLE();\n        return;\n    }\n\n    destroy_periodic_time(pt);\n\n    write_lock(&v->domain->arch.hvm.pl_time->pt_migrate);\n\n    pt->pending_intr_nr = 0;\n    pt->do_not_freeze = 0;\n    pt->irq_issued = 0;\n\n    /* Periodic timer must be at least 0.1ms. */\n    if ( (period < 100000) && period )\n    {\n        if ( !test_and_set_bool(pt->warned_timeout_too_short) )\n            gdprintk(XENLOG_WARNING, \"HVM_PlatformTime: program too \"\n                     \"small period %\"PRIu64\"\\n\", period);\n        period = 100000;\n    }\n\n    pt->period = period;\n    pt->vcpu = v;\n    pt->last_plt_gtime = hvm_get_guest_time(pt->vcpu);\n    pt->irq = irq;\n    pt->one_shot = !period;\n    pt->level = level;\n    pt->scheduled = NOW() + delta;\n\n    if ( !pt->one_shot )\n    {\n        if ( v->domain->arch.hvm.params[HVM_PARAM_VPT_ALIGN] )\n        {\n            pt->scheduled = align_timer(pt->scheduled, pt->period);\n        }\n        else if ( pt->source == PTSRC_lapic )\n        {\n            /*\n             * Offset LAPIC ticks from other timer ticks. Otherwise guests\n             * which use LAPIC ticks for process accounting can see long\n             * sequences of process ticks incorrectly accounted to interrupt\n             * processing (seen with RHEL3 guest).\n             */\n            pt->scheduled += delta >> 1;\n        }\n    }\n\n    pt->cb = cb;\n    pt->priv = data;\n\n    pt->on_list = 1;\n    list_add(&pt->list, &v->arch.hvm.tm_list);\n\n    init_timer(&pt->timer, pt_timer_fn, pt, v->processor);\n    set_timer(&pt->timer, pt->scheduled);\n\n    write_unlock(&v->domain->arch.hvm.pl_time->pt_migrate);\n}", "target": 1, "idx": 11535}
{"commit_id": "f3a24d7916b9173c69a3e0ee790102993833d6c5", "project": "curl", "func": "CURLcode Curl_auth_create_plain_message(struct Curl_easy *data,\n                                        const char *userp,\n                                        const char *passwdp,\n                                        char **outptr, size_t *outlen)\n{\n  CURLcode result;\n  char *plainauth;\n  size_t ulen;\n  size_t plen;\n  size_t plainlen;\n\n  *outlen = 0;\n  *outptr = NULL;\n  ulen = strlen(userp);\n  plen = strlen(passwdp);\n\n  /* Compute binary message length. Check for overflows. */\n  if((ulen > SIZE_T_MAX/4) || (plen > (SIZE_T_MAX/2 - 2)))\n    return CURLE_OUT_OF_MEMORY;\n  plainlen = 2 * ulen + plen + 2;\n\n  plainauth = malloc(plainlen);\n  if(!plainauth)\n    return CURLE_OUT_OF_MEMORY;\n\n  /* Calculate the reply */\n  memcpy(plainauth, userp, ulen);\n  plainauth[ulen] = '\\0';\n  memcpy(plainauth + ulen + 1, userp, ulen);\n  plainauth[2 * ulen + 1] = '\\0';\n  memcpy(plainauth + 2 * ulen + 2, passwdp, plen);\n\n  /* Base64 encode the reply */\n  result = Curl_base64_encode(data, plainauth, plainlen, outptr, outlen);\n  free(plainauth);\n\n  return result;\n}", "target": 1, "idx": 11536}
{"commit_id": "b6ad54b72c7f8c422c288dd9c8756d2a15f30e53", "project": "chromium", "func": "static void\nxmlXPathCompPathExpr(xmlXPathParserContextPtr ctxt) {\n    int lc = 1;           /* Should we branch to LocationPath ?         */\n    xmlChar *name = NULL; /* we may have to preparse a name to find out */\n\n    SKIP_BLANKS;\n    if ((CUR == '$') || (CUR == '(') ||\n\t(IS_ASCII_DIGIT(CUR)) ||\n        (CUR == '\\'') || (CUR == '\"') ||\n\t(CUR == '.' && IS_ASCII_DIGIT(NXT(1)))) {\n\tlc = 0;\n    } else if (CUR == '*') {\n\t/* relative or absolute location path */\n\tlc = 1;\n    } else if (CUR == '/') {\n\t/* relative or absolute location path */\n\tlc = 1;\n    } else if (CUR == '@') {\n\t/* relative abbreviated attribute location path */\n\tlc = 1;\n    } else if (CUR == '.') {\n\t/* relative abbreviated attribute location path */\n\tlc = 1;\n    } else {\n\t/*\n\t * Problem is finding if we have a name here whether it's:\n\t *   - a nodetype\n\t *   - a function call in which case it's followed by '('\n\t *   - an axis in which case it's followed by ':'\n\t *   - a element name\n\t * We do an a priori analysis here rather than having to\n\t * maintain parsed token content through the recursive function\n\t * calls. This looks uglier but makes the code easier to\n\t * read/write/debug.\n\t */\n\tSKIP_BLANKS;\n\tname = xmlXPathScanName(ctxt);\n\tif ((name != NULL) && (xmlStrstr(name, (xmlChar *) \"::\") != NULL)) {\n#ifdef DEBUG_STEP\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PathExpr: Axis\\n\");\n#endif\n\t    lc = 1;\n\t    xmlFree(name);\n\t} else if (name != NULL) {\n\t    int len =xmlStrlen(name);\n\n\n\t    while (NXT(len) != 0) {\n\t\tif (NXT(len) == '/') {\n\t\t    /* element name */\n#ifdef DEBUG_STEP\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PathExpr: AbbrRelLocation\\n\");\n#endif\n\t\t    lc = 1;\n\t\t    break;\n\t\t} else if (IS_BLANK_CH(NXT(len))) {\n\t\t    /* ignore blanks */\n\t\t    ;\n\t\t} else if (NXT(len) == ':') {\n#ifdef DEBUG_STEP\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PathExpr: AbbrRelLocation\\n\");\n#endif\n\t\t    lc = 1;\n\t\t    break;\n\t\t} else if ((NXT(len) == '(')) {\n\t\t    /* Node Type or Function */\n\t\t    if (xmlXPathIsNodeType(name)) {\n#ifdef DEBUG_STEP\n\t\t        xmlGenericError(xmlGenericErrorContext,\n\t\t\t\t\"PathExpr: Type search\\n\");\n#endif\n\t\t\tlc = 1;\n                    } else if (ctxt->xptr &&\n                               xmlStrEqual(name, BAD_CAST \"range-to\")) {\n                        lc = 1;\n\t\t    } else {\n#ifdef DEBUG_STEP\n\t\t        xmlGenericError(xmlGenericErrorContext,\n\t\t\t\t\"PathExpr: function call\\n\");\n#endif\n\t\t\tlc = 0;\n\t\t    }\n                    break;\n\t\t} else if ((NXT(len) == '[')) {\n\t\t    /* element name */\n#ifdef DEBUG_STEP\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PathExpr: AbbrRelLocation\\n\");\n#endif\n\t\t    lc = 1;\n\t\t    break;\n\t\t} else if ((NXT(len) == '<') || (NXT(len) == '>') ||\n\t\t\t   (NXT(len) == '=')) {\n\t\t    lc = 1;\n\t\t    break;\n\t\t} else {\n\t\t    lc = 1;\n\t\t    break;\n\t\t}\n\t\tlen++;\n\t    }\n\t    if (NXT(len) == 0) {\n#ifdef DEBUG_STEP\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PathExpr: AbbrRelLocation\\n\");\n#endif\n\t\t/* element name */\n\t\tlc = 1;\n\t    }\n\t    xmlFree(name);\n\t} else {\n\t    /* make sure all cases are covered explicitly */\n\t    XP_ERROR(XPATH_EXPR_ERROR);\n\t}\n    }\n\n    if (lc) {\n\tif (CUR == '/') {\n\t    PUSH_LEAVE_EXPR(XPATH_OP_ROOT, 0, 0);\n\t} else {\n\t    PUSH_LEAVE_EXPR(XPATH_OP_NODE, 0, 0);\n\t}\n\txmlXPathCompLocationPath(ctxt);\n    } else {\n\txmlXPathCompFilterExpr(ctxt);\n\tCHECK_ERROR;\n\tif ((CUR == '/') && (NXT(1) == '/')) {\n\t    SKIP(2);\n\t    SKIP_BLANKS;\n\n\t    PUSH_LONG_EXPR(XPATH_OP_COLLECT, AXIS_DESCENDANT_OR_SELF,\n\t\t    NODE_TEST_TYPE, NODE_TYPE_NODE, NULL, NULL);\n\t    PUSH_UNARY_EXPR(XPATH_OP_RESET, ctxt->comp->last, 1, 0);\n\n\t    xmlXPathCompRelativeLocationPath(ctxt);\n\t} else if (CUR == '/') {\n\t    xmlXPathCompRelativeLocationPath(ctxt);\n\t}\n    }\n    SKIP_BLANKS;\n}", "target": 2, "idx": 11537}
{"commit_id": "215d1f3928713d6eaec67244bcda72105b898000", "project": "kernel/git/tip/tip", "func": "mm_segment_t enable_sacf_uaccess(void)\n{\n\tmm_segment_t old_fs;\n\tunsigned long asce, cr;\n\tunsigned long flags;\n\n\told_fs = current->thread.mm_segment;\n\tif (old_fs & 1)\n\t\treturn old_fs;\n\t/* protect against a concurrent page table upgrade */\n\tlocal_irq_save(flags);\n\tcurrent->thread.mm_segment |= 1;\n\tasce = S390_lowcore.kernel_asce;\n\tif (likely(old_fs == USER_DS)) {\n\t\t__ctl_store(cr, 1, 1);\n\t\tif (cr != S390_lowcore.kernel_asce) {\n\t\t\t__ctl_load(S390_lowcore.kernel_asce, 1, 1);\n\t\t\tset_cpu_flag(CIF_ASCE_PRIMARY);\n\t\t}\n\t\tasce = S390_lowcore.user_asce;\n\t}\n\t__ctl_store(cr, 7, 7);\n\tif (cr != asce) {\n\t\t__ctl_load(asce, 7, 7);\n\t\tset_cpu_flag(CIF_ASCE_SECONDARY);\n\t}\n\tlocal_irq_restore(flags);\n\treturn old_fs;\n}", "target": 2, "idx": 11538}
{"commit_id": "62a97e6a561ce65e88d4c537a1b82c336f012722", "project": "LibreOffice/core", "func": "void Polygon::Insert( sal_uInt16 nPos, const Point& rPt )\n{\n    ImplMakeUnique();\n\n    if( nPos >= mpImplPolygon->mnPoints )\n        nPos = mpImplPolygon->mnPoints;\n\n    if (mpImplPolygon->ImplSplit(nPos, 1))\n        mpImplPolygon->mpPointAry[ nPos ] = rPt;\n}", "target": 3, "idx": 11539}
{"commit_id": "9b5fedc37ccbcd23695a0e97c0fe46c999e26100", "project": "merces/libpe", "func": "pe_exports_t *pe_exports(pe_ctx_t *ctx) {\n\tif (ctx->cached_data.exports != NULL)\n\t\treturn ctx->cached_data.exports;\n\n\tpe_exports_t *exports = ctx->cached_data.exports = calloc(1, sizeof(pe_exports_t));\n\tif (exports == NULL) {\n\t\t// TODO(jweyrich): Should we report an error? If yes, we need a redesign.\n\t\treturn NULL;\n\t}\n\n\texports->err = LIBPE_E_OK;\n\n\tconst IMAGE_DATA_DIRECTORY *dir = pe_directory_by_entry(ctx, IMAGE_DIRECTORY_ENTRY_EXPORT);\n\tif (dir == NULL) { \n\t\treturn exports;\n\t}\n\n\tconst uint64_t va = dir->VirtualAddress;\n\tif (va == 0) {\n\t\t// NOTE: This file has no exported symbols.\n\t\treturn exports;\n\t}\n\n\tuint64_t ofs;\n\n\tofs = pe_rva2ofs(ctx, va);\n\tconst IMAGE_EXPORT_DIRECTORY *exp = LIBPE_PTR_ADD(ctx->map_addr, ofs);\n\tif (!pe_can_read(ctx, exp, sizeof(IMAGE_EXPORT_DIRECTORY))) {\n\t\texports->err = LIBPE_E_EXPORTS_CANT_READ_DIR;\n\t\treturn exports;\n\t}\n\n\tofs = pe_rva2ofs(ctx, exp->Name);\n\tconst char *name_ptr = LIBPE_PTR_ADD(ctx->map_addr, ofs);\n\tif (!pe_can_read(ctx, name_ptr, 1)) {\n\t\texports->err = LIBPE_E_EXPORTS_CANT_READ_RVA;\n\t\treturn exports;\n\t}\n\n\texports->name = strdup(name_ptr);\n\t\n\tconst uint32_t ordinal_base = exp->Base;\n\t\n\tofs = pe_rva2ofs(ctx, exp->AddressOfNames);\n\tconst uint32_t *rva_ptr = LIBPE_PTR_ADD(ctx->map_addr, ofs);\n\tif (!pe_can_read(ctx, rva_ptr, sizeof(uint32_t))) {\n\t\texports->err = LIBPE_E_EXPORTS_CANT_READ_RVA;\n\t\treturn exports;\n\t}\n\n\t// If `NumberOfNames == 0` then all functions are exported by ordinal.\n\t// Otherwise `NumberOfNames` should be equal to `NumberOfFunctions`\n\t// if (exp->NumberOfNames != 0 && exp->NumberOfNames != exp->NumberOfFunctions) {\n\t// \texports->err = LIBPE_E_EXPORTS_FUNC_NEQ_NAMES;\n\t// \treturn exports;\n\t// }\n\n\t//\n\t// The format of IMAGE_EXPORT_DIRECTORY can be seen in http://i.msdn.microsoft.com/dynimg/IC60608.gif\n\t//\n\n\t// We want to use `NumberOfFunctions` for looping as it's the total number of functions/symbols\n\t// exported by the module. On the other hand, `NumberOfNames` is the number of\n\t// functions/symbols exported by name only.\n\n\texports->functions_count = exp->NumberOfFunctions;\n\texports->functions = calloc(exp->NumberOfFunctions, sizeof(pe_exported_function_t));\n\tif (exports->functions == NULL) {\n\t\texports->err = LIBPE_E_ALLOCATION_FAILURE;\n\t\treturn exports;\n\t}\n\n\tconst uint64_t offset_to_AddressOfFunctions = pe_rva2ofs(ctx, exp->AddressOfFunctions);\n\tconst uint64_t offset_to_AddressOfNames = pe_rva2ofs(ctx, exp->AddressOfNames);\n\tconst uint64_t offset_to_AddressOfNameOrdinals = pe_rva2ofs(ctx, exp->AddressOfNameOrdinals);\n\n\tuint64_t offsets_to_Names[exp->NumberOfFunctions];\n\tmemset(offsets_to_Names, 0, sizeof(offsets_to_Names));  // This is needed for VLAs.\n\n\t//\n\t// Names\n\t//\n\t\n\tfor (uint32_t i=0; i < exp->NumberOfNames; i++) {\n\t\tuint64_t entry_ordinal_list_ptr = offset_to_AddressOfNameOrdinals + sizeof(uint16_t) * i;\n\t\tuint16_t *entry_ordinal_list = LIBPE_PTR_ADD(ctx->map_addr, entry_ordinal_list_ptr);\n\n\t\tif (!pe_can_read(ctx, entry_ordinal_list, sizeof(uint16_t))) {\n\t\t\t// TODO: Should we report something?\n\t\t\tbreak;\n\t\t}\n\t\tconst uint16_t ordinal = *entry_ordinal_list;\n\n\t\tuint64_t entry_name_list_ptr = offset_to_AddressOfNames + sizeof(uint32_t) * i;\n\t\tuint32_t *entry_name_list = LIBPE_PTR_ADD(ctx->map_addr, entry_name_list_ptr);\n\n\t\tif (!pe_can_read(ctx, entry_name_list, sizeof(uint32_t))) {\n\t\t\t// TODO: Should we report something?\n\t\t\tbreak;\n\t\t}\n\n\t\tconst uint32_t entry_name_rva = *entry_name_list;\n\t\tconst uint64_t entry_name_ofs = pe_rva2ofs(ctx, entry_name_rva);\n\n        if (ordinal < exp->NumberOfFuntions) {\n            offsets_to_Names[ordinal] = entry_name_ofs;\n        }\n\t}\n\n\t//\n\t// Functions\n\t//\n\n\tfor (uint32_t i=0; i < exp->NumberOfFunctions; i++) {\n\t\tuint64_t entry_va_list_ptr = offset_to_AddressOfFunctions + sizeof(uint32_t) * i;\n\t\tuint32_t *entry_va_list = LIBPE_PTR_ADD(ctx->map_addr, entry_va_list_ptr);\n\n\t\tif (!pe_can_read(ctx, entry_va_list, sizeof(uint32_t))) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// Add `Base` to the element of `AddressOfNameOrdinals` array to get the correct ordinal..\n\t\t//const uint16_t entry_ordinal = exp->Base + *entry_ordinal_list;\n\t\tconst uint32_t entry_va = *entry_va_list;\n\t\tconst uint64_t entry_name_ofs = offsets_to_Names[i];\n\n\t\t// FIX: Don't need to zero all elements!\n\t\t// FIXME: 300 bytes is enough or too much?\n\t\tchar fname[300];\n\t\tfname[0] = 0;\n\n\t\tif (entry_name_ofs != 0) {\n\t\t\tconst char *entry_name = LIBPE_PTR_ADD(ctx->map_addr, entry_name_ofs);\n\n\t\t\t// Validate whether it's ok to access at least 1 byte after entry_name.\n\t\t\t// It might be '\\0', for example.\n\t\t\tif (!pe_can_read(ctx, entry_name, 1)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t//printf(\"ord=%d, va=%x, name=%s\\n\", entry_ordinal, entry_va, entry_name);\n\n\t\t\tconst size_t fname_size = sizeof(fname);\n\t\t\tstrncpy(fname, entry_name, fname_size-1);\n\t\t\t// Because `strncpy` does not guarantee to NUL terminate the string itself, this must be done explicitly.\n\t\t\tfname[fname_size - 1] = '\\0';\n\t\t}\n\n\t\texports->functions[i].ordinal = ordinal_base + i;\n\t\texports->functions[i].address = entry_va;\n\n\t\texports->functions[i].name = strdup(fname);\n\t\tif (exports->functions[i].name == NULL) {\n\t\t\texports->err = LIBPE_E_ALLOCATION_FAILURE;\n\t\t\treturn exports;\n\t\t}\n\n\t\t// Check whether the exported function is forwarded.\n\t\t// It's forwarded if its RVA is inside the exports section.\n\t\tif (entry_va >= va && entry_va <= va + dir->Size) {\n\t\t\t// When a symbol is forwarded, its RVA points to a string containing\n\t\t\t// the name of the DLL and symbol to which it is forwarded.\n\t\t\tconst uint64_t fw_entry_name_ofs = pe_rva2ofs(ctx, entry_va);\n\t\t\tconst char *fw_entry_name = LIBPE_PTR_ADD(ctx->map_addr, fw_entry_name_ofs);\n\n\t\t\t// Validate whether it's ok to access at least 1 byte after fw_entry_name.\n\t\t\t// It might be '\\0', for example.\n\t\t\tif (!pe_can_read(ctx, fw_entry_name, 1)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\texports->functions[i].fwd_name = strdup(fw_entry_name);\n\t\t\tif (exports->functions[i].fwd_name == NULL) {\n\t\t\t\texports->err = LIBPE_E_ALLOCATION_FAILURE;\n\t\t\t\treturn exports;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn exports;\n}", "target": 3, "idx": 11540}
{"commit_id": "353050be4c19e102178ccc05988101887c25ae53", "project": "kernel/git/bpf/bpf", "func": "static int bpf_map_do_batch(const union bpf_attr *attr,\n\t\t\t    union bpf_attr __user *uattr,\n\t\t\t    int cmd)\n{\n\tbool has_read  = cmd == BPF_MAP_LOOKUP_BATCH ||\n\t\t\t cmd == BPF_MAP_LOOKUP_AND_DELETE_BATCH;\n\tbool has_write = cmd != BPF_MAP_LOOKUP_BATCH;\n\tstruct bpf_map *map;\n\tint err, ufd;\n\tstruct fd f;\n\n\tif (CHECK_ATTR(BPF_MAP_BATCH))\n\t\treturn -EINVAL;\n\n\tufd = attr->batch.map_fd;\n\tf = fdget(ufd);\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\tif (has_write)\n\t\tbpf_map_write_active_inc(map);\n\tif (has_read && !(map_get_sys_perms(map, f) & FMODE_CAN_READ)) {\n\t\terr = -EPERM;\n\t\tgoto err_put;\n\t}\n\tif (has_write && !(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) {\n\t\terr = -EPERM;\n\t\tgoto err_put;\n\t}\n\n\tif (cmd == BPF_MAP_LOOKUP_BATCH)\n\t\tBPF_DO_BATCH(map->ops->map_lookup_batch);\n\telse if (cmd == BPF_MAP_LOOKUP_AND_DELETE_BATCH)\n\t\tBPF_DO_BATCH(map->ops->map_lookup_and_delete_batch);\n\telse if (cmd == BPF_MAP_UPDATE_BATCH)\n\t\tBPF_DO_BATCH(map->ops->map_update_batch);\n\telse\n\t\tBPF_DO_BATCH(map->ops->map_delete_batch);\nerr_put:\n\tif (has_write)\n\t\tbpf_map_write_active_dec(map);\n\tfdput(f);\n\treturn err;\n}", "target": 1, "idx": 11541}
{"commit_id": "93bc623489bdcfc7e9127614fcfb3258edf3f0f9", "project": "chromium", "func": "v8::Local<v8::Object> V8InjectedScriptHost::create(v8::Local<v8::Context> context, V8InspectorImpl* inspector)\n{\n    v8::Isolate* isolate = inspector->isolate();\n    v8::Local<v8::Object> injectedScriptHost = v8::Object::New(isolate);\n    bool success = injectedScriptHost->SetPrototype(context, v8::Null(isolate)).FromMaybe(false);\n    DCHECK(success);\n    v8::Local<v8::External> debuggerExternal = v8::External::New(isolate, inspector);\n    setFunctionProperty(context, injectedScriptHost, \"internalConstructorName\", V8InjectedScriptHost::internalConstructorNameCallback, debuggerExternal);\n    setFunctionProperty(context, injectedScriptHost, \"formatAccessorsAsProperties\", V8InjectedScriptHost::formatAccessorsAsProperties, debuggerExternal);\n    setFunctionProperty(context, injectedScriptHost, \"subtype\", V8InjectedScriptHost::subtypeCallback, debuggerExternal);\n    setFunctionProperty(context, injectedScriptHost, \"getInternalProperties\", V8InjectedScriptHost::getInternalPropertiesCallback, debuggerExternal);\n    setFunctionProperty(context, injectedScriptHost, \"objectHasOwnProperty\", V8InjectedScriptHost::objectHasOwnPropertyCallback, debuggerExternal);\n    setFunctionProperty(context, injectedScriptHost, \"bind\", V8InjectedScriptHost::bindCallback, debuggerExternal);\n    setFunctionProperty(context, injectedScriptHost, \"proxyTargetValue\", V8InjectedScriptHost::proxyTargetValueCallback, debuggerExternal);\n    return injectedScriptHost;\n}", "target": 1, "idx": 11542}
{"commit_id": "60ff122ef5862d04b39b150541459e7f5e35add8", "project": "DaveGamble/cJSON", "func": "CJSON_PUBLIC(char*) cJSON_SetValuestring(cJSON *object, const char *valuestring)\n{\n    char *copy = NULL;\n    /* if object's type is not cJSON_String or is cJSON_IsReference, it should not set valuestring */\n    if ((object == NULL) || !(object->type & cJSON_String) || (object->type & cJSON_IsReference))\n    {\n        return NULL;\n    }\n    /* return NULL if the object is corrupted */\n    if (object->valuestring == NULL)\n    {\n        return NULL;\n    }\n    if (strlen(valuestring) <= strlen(object->valuestring))\n    {\n        strcpy(object->valuestring, valuestring);\n        return object->valuestring;\n    }\n    copy = (char*) cJSON_strdup((const unsigned char*)valuestring, &global_hooks);\n    if (copy == NULL)\n    {\n        return NULL;\n    }\n    if (object->valuestring != NULL)\n    {\n        cJSON_free(object->valuestring);\n    }\n    object->valuestring = copy;\n\n    return copy;\n}", "target": 2, "idx": 11543}
{"commit_id": "0ecb22aa909e52d86b4545aa7a51f7a0922147e6", "project": "ImageMagick", "func": "static Image *ReadRLAImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  typedef struct _WindowFrame\n  {\n    short\n      left,\n      right,\n      bottom,\n      top;\n  } WindowFrame;\n\n  typedef struct _RLAInfo\n  {\n    WindowFrame\n      window,\n      active_window;\n\n    short\n      frame,\n      storage_type,\n      number_channels,\n      number_matte_channels,\n      number_auxiliary_channels,\n      revision;\n\n    char\n      gamma[16+1],\n      red_primary[24+1],\n      green_primary[24+1],\n      blue_primary[24+1],\n      white_point[24+1];\n\n    int\n      job_number;\n\n    char\n      name[128+1],\n      description[128+1],\n      program[64+1],\n      machine[32+1],\n      user[32+1],\n      date[20+1],\n      aspect[24+1],\n      aspect_ratio[8+1],\n      chan[32+1];\n\n    short\n      field;\n\n    char\n      time[12+1],\n      filter[32+1];\n\n    short\n      bits_per_channel,\n      matte_type,\n      matte_bits,\n      auxiliary_type,\n      auxiliary_bits;\n\n    char\n      auxiliary[32+1],\n      space[36+1];\n\n    int\n      next;\n  } RLAInfo;\n\n  Image\n    *image;\n\n  int\n    channel,\n    length,\n    runlength;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset,\n    *scanlines;\n\n  register ssize_t\n    i,\n    x;\n\n  register PixelPacket\n    *q;\n\n  ssize_t\n    count,\n    y;\n\n  RLAInfo\n    rla_info;\n\n  unsigned char\n    byte;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) ResetMagickMemory(&rla_info,0,sizeof(rla_info));\n  rla_info.window.left=(short) ReadBlobMSBShort(image);\n  rla_info.window.right=(short) ReadBlobMSBShort(image);\n  rla_info.window.bottom=(short) ReadBlobMSBShort(image);\n  rla_info.window.top=(short) ReadBlobMSBShort(image);\n  rla_info.active_window.left=(short) ReadBlobMSBShort(image);\n  rla_info.active_window.right=(short) ReadBlobMSBShort(image);\n  rla_info.active_window.bottom=(short) ReadBlobMSBShort(image);\n  rla_info.active_window.top=(short) ReadBlobMSBShort(image);\n  rla_info.frame=(short) ReadBlobMSBShort(image);\n  rla_info.storage_type=(short) ReadBlobMSBShort(image);\n  rla_info.number_channels=(short) ReadBlobMSBShort(image);\n  rla_info.number_matte_channels=(short) ReadBlobMSBShort(image);\n  if (rla_info.number_channels == 0)\n    rla_info.number_channels=3;\n  rla_info.number_channels+=rla_info.number_matte_channels;\n  rla_info.number_auxiliary_channels=(short) ReadBlobMSBShort(image);\n  rla_info.revision=(short) ReadBlobMSBShort(image);\n  count=ReadBlob(image,16,(unsigned char *) rla_info.gamma);\n  count=ReadBlob(image,24,(unsigned char *) rla_info.red_primary);\n  count=ReadBlob(image,24,(unsigned char *) rla_info.green_primary);\n  count=ReadBlob(image,24,(unsigned char *) rla_info.blue_primary);\n  count=ReadBlob(image,24,(unsigned char *) rla_info.white_point);\n  rla_info.job_number=ReadBlobMSBSignedLong(image);\n  count=ReadBlob(image,128,(unsigned char *) rla_info.name);\n  count=ReadBlob(image,128,(unsigned char *) rla_info.description);\n  rla_info.description[127]='\\0';\n  count=ReadBlob(image,64,(unsigned char *) rla_info.program);\n  count=ReadBlob(image,32,(unsigned char *) rla_info.machine);\n  count=ReadBlob(image,32,(unsigned char *) rla_info.user);\n  count=ReadBlob(image,20,(unsigned char *) rla_info.date);\n  count=ReadBlob(image,24,(unsigned char *) rla_info.aspect);\n  count=ReadBlob(image,8,(unsigned char *) rla_info.aspect_ratio);\n  count=ReadBlob(image,32,(unsigned char *) rla_info.chan);\n  rla_info.field=(short) ReadBlobMSBShort(image);\n  count=ReadBlob(image,12,(unsigned char *) rla_info.time);\n  count=ReadBlob(image,32,(unsigned char *) rla_info.filter);\n  rla_info.bits_per_channel=(short) ReadBlobMSBShort(image);\n  rla_info.matte_type=(short) ReadBlobMSBShort(image);\n  rla_info.matte_bits=(short) ReadBlobMSBShort(image);\n  rla_info.auxiliary_type=(short) ReadBlobMSBShort(image);\n  rla_info.auxiliary_bits=(short) ReadBlobMSBShort(image);\n  count=ReadBlob(image,32,(unsigned char *) rla_info.auxiliary);\n  count=ReadBlob(image,36,(unsigned char *) rla_info.space);\n  if ((size_t) count != 36)\n    ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n  rla_info.next=ReadBlobMSBSignedLong(image);\n  /*\n    Initialize image structure.\n  */\n  image->matte=rla_info.number_matte_channels != 0 ? MagickTrue : MagickFalse;\n  image->columns=(size_t) (rla_info.active_window.right-\n    rla_info.active_window.left+1);\n  image->rows=(size_t) (rla_info.active_window.top-\n    rla_info.active_window.bottom+1);\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  scanlines=(MagickOffsetType *) AcquireQuantumMemory(image->rows,\n    sizeof(*scanlines));\n  if (scanlines == (MagickOffsetType *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  if (*rla_info.description != '\\0')\n    (void) SetImageProperty(image,\"comment\",(char *) rla_info.description);\n  /*\n    Read offsets to each scanline data.\n  */\n  for (i=0; i < (ssize_t) image->rows; i++)\n    scanlines[i]=(MagickOffsetType) ReadBlobMSBSignedLong(image);\n  /*\n    Read image data.\n  */\n  x=0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    offset=SeekBlob(image,scanlines[image->rows-y-1],SEEK_SET);\n    if (offset < 0)\n      {\n        scanlines=(MagickOffsetType *) RelinquishMagickMemory(scanlines);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    for (channel=0; channel < (int) rla_info.number_channels; channel++)\n    {\n      length=ReadBlobMSBSignedShort(image);\n      while (length > 0)\n      {\n        byte=(unsigned char) ReadBlobByte(image);\n        runlength=byte;\n        if (byte > 127)\n          runlength=byte-256;\n        length--;\n        if (length == 0)\n          break;\n        if (runlength < 0)\n          {\n            while (runlength < 0)\n            {\n              q=GetAuthenticPixels(image,(ssize_t) (x % image->columns),\n                (ssize_t) (y % image->rows),1,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              byte=(unsigned char) ReadBlobByte(image);\n              length--;\n              switch (channel)\n              {\n                case 0:\n                {\n                  SetPixelRed(q,ScaleCharToQuantum(byte));\n                  break;\n                }\n                case 1:\n                {\n                  SetPixelGreen(q,ScaleCharToQuantum(byte));\n                  break;\n                }\n                case 2:\n                {\n                  SetPixelBlue(q,ScaleCharToQuantum(byte));\n                  break;\n                }\n                case 3:\n                default:\n                {\n                  SetPixelAlpha(q,ScaleCharToQuantum(byte));\n                  break;\n                }\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              x++;\n              runlength++;\n            }\n            continue;\n          }\n        byte=(unsigned char) ReadBlobByte(image);\n        length--;\n        runlength++;\n        do\n        {\n          q=GetAuthenticPixels(image,(ssize_t) (x % image->columns),\n            (ssize_t) (y % image->rows),1,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          switch (channel)\n          {\n            case 0:\n            {\n              SetPixelRed(q,ScaleCharToQuantum(byte));\n              break;\n            }\n            case 1:\n            {\n              SetPixelGreen(q,ScaleCharToQuantum(byte));\n              break;\n            }\n            case 2:\n            {\n              SetPixelBlue(q,ScaleCharToQuantum(byte));\n              break;\n            }\n            case 3:\n            default:\n            {\n              SetPixelAlpha(q,ScaleCharToQuantum(byte));\n              break;\n            }\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          x++;\n          runlength--;\n        }\n        while (runlength > 0);\n      }\n    }\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  scanlines=(MagickOffsetType *) RelinquishMagickMemory(scanlines);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}", "target": 1, "idx": 11544}
{"commit_id": "7872a831783e17dcc4d0aa70cffc256afb664f7a", "project": "ceph", "func": "int RGWFCGX::init_env(CephContext* const cct)\n{\n  env.init(cct, (char **)fcgx->envp);\n  return 0;\n}", "target": 2, "idx": 11545}
{"commit_id": "0bf9f8d3e399a0e1d2b717f71b4776172446184b", "project": "xen-project/xen", "func": "unsigned long hypercall_create_continuation(\n    unsigned int op, const char *format, ...)\n{\n    struct vcpu *curr = current;\n    struct mc_state *mcs = &curr->mc_state;\n    const char *p = format;\n    unsigned long arg;\n    unsigned int i;\n    va_list args;\n\n    curr->hcall_preempted = true;\n\n    va_start(args, format);\n\n    if ( mcs->flags & MCSF_in_multicall )\n    {\n        for ( i = 0; *p != '\\0'; i++ )\n            mcs->call.args[i] = NEXT_ARG(p, args);\n    }\n    else\n    {\n        struct cpu_user_regs *regs = guest_cpu_user_regs();\n\n        regs->rax = op;\n\n        if ( !curr->hcall_compat )\n        {\n            for ( i = 0; *p != '\\0'; i++ )\n            {\n                arg = NEXT_ARG(p, args);\n                switch ( i )\n                {\n                case 0: regs->rdi = arg; break;\n                case 1: regs->rsi = arg; break;\n                case 2: regs->rdx = arg; break;\n                case 3: regs->r10 = arg; break;\n                case 4: regs->r8  = arg; break;\n                case 5: regs->r9  = arg; break;\n                }\n            }\n        }\n        else\n        {\n            for ( i = 0; *p != '\\0'; i++ )\n            {\n                arg = NEXT_ARG(p, args);\n                switch ( i )\n                {\n                case 0: regs->rbx = arg; break;\n                case 1: regs->rcx = arg; break;\n                case 2: regs->rdx = arg; break;\n                case 3: regs->rsi = arg; break;\n                case 4: regs->rdi = arg; break;\n                case 5: regs->rbp = arg; break;\n                }\n            }\n        }\n    }\n\n    va_end(args);\n\n    return op;\n\n bad_fmt:\n    gprintk(XENLOG_ERR, \"Bad hypercall continuation format '%c'\\n\", *p);\n    ASSERT_UNREACHABLE();\n    domain_crash(curr->domain);\n    return 0;\n}", "target": 1, "idx": 11546}
{"commit_id": "537bc7c723439b9194a358f64d871dd326c18887", "project": "tensorflow", "func": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  const auto* params = reinterpret_cast<TfLiteSVDFParams*>(node->builtin_data);\n  OpData* op_data = reinterpret_cast<OpData*>(node->user_data);\n  int scratch_tensor_index = op_data->scratch_tensor_index;\n\n  // Check we have all the inputs and outputs we need.\n  TF_LITE_ENSURE_EQ(context, node->outputs->size, 1);\n  TF_LITE_ENSURE_EQ(context, node->inputs->size, 5);\n\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  const TfLiteTensor* weights_feature;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kWeightsFeatureTensor,\n                                          &weights_feature));\n  const TfLiteTensor* weights_time;\n  TF_LITE_ENSURE_OK(\n      context, GetInputSafe(context, node, kWeightsTimeTensor, &weights_time));\n\n  TF_LITE_ENSURE(context,\n                 input->type == kTfLiteFloat32 || input->type == kTfLiteInt8);\n\n  // Check all the parameters of tensor match within themselves and match the\n  // input configuration.\n  const int rank = params->rank;\n  const int batch_size = input->dims->data[0];\n  const int num_filters = weights_feature->dims->data[0];\n  TF_LITE_ENSURE(context, rank != 0);\n  TF_LITE_ENSURE_EQ(context, num_filters % rank, 0);\n  const int num_units = num_filters / rank;\n  const int memory_size = weights_time->dims->data[1];\n  TF_LITE_ENSURE_EQ(context, input->dims->data[1],\n                    weights_feature->dims->data[1]);\n  TF_LITE_ENSURE_EQ(context, weights_time->dims->data[0], num_filters);\n\n  const TfLiteTensor* bias = GetOptionalInputTensor(context, node, kBiasTensor);\n  if (bias) {\n    TF_LITE_ENSURE_EQ(context, bias->dims->data[0], num_units);\n  }\n\n  const TfLiteTensor* state;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kStateTensor, &state));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  // Check the shape of input state tensors.\n  TF_LITE_ENSURE_EQ(context, NumDimensions(state), 2);\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(state, 0), batch_size);\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(state, 1),\n                    memory_size * num_filters);\n\n  // Resize output.\n  TfLiteIntArray* output_size_array = TfLiteIntArrayCreate(2);\n  output_size_array->data[0] = batch_size;\n  output_size_array->data[1] = num_units;\n  TF_LITE_ENSURE_OK(context,\n                    context->ResizeTensor(context, output, output_size_array));\n\n  // The weights are of consistent type, so it suffices to check one.\n  const bool is_hybrid_op = IsHybridOp(input, weights_feature);\n  const bool is_full_integer = input->type == kTfLiteInt8;\n\n  // Resize scratch.\n  TfLiteIntArrayFree(node->temporaries);\n  if (is_hybrid_op) {\n    node->temporaries = TfLiteIntArrayCreate(6);\n  } else if (is_full_integer) {\n    node->temporaries = TfLiteIntArrayCreate(2);\n  } else {\n    node->temporaries = TfLiteIntArrayCreate(1);\n  }\n  node->temporaries->data[0] = scratch_tensor_index;\n\n  TfLiteIntArray* scratch_size_array = TfLiteIntArrayCreate(2);\n  scratch_size_array->data[0] = batch_size;\n  scratch_size_array->data[1] = num_filters;\n\n  TfLiteTensor* scratch_tensor;\n  TF_LITE_ENSURE_OK(\n      context, GetTemporarySafe(context, node, /*index=*/0, &scratch_tensor));\n\n  // The scratch buffer is of type int32 for full integer svdf and it's of type\n  // float32 for hybrid and float case.\n  if (is_full_integer) {\n    scratch_tensor->type = kTfLiteInt32;\n  } else {\n    scratch_tensor->type = kTfLiteFloat32;\n  }\n  scratch_tensor->allocation_type = kTfLiteArenaRw;\n  TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scratch_tensor,\n                                                   scratch_size_array));\n\n  if (is_hybrid_op) {\n    op_data->compute_row_sums = true;\n    // Tell interpreter to allocate temporary tensors to store quantized values\n    // of input tensors.\n    node->temporaries->data[1] = scratch_tensor_index + 1;\n    TfLiteTensor* input_quantized;\n    TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/1,\n                                                &input_quantized));\n    input_quantized->type = weights_feature->type;\n    input_quantized->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqual(input_quantized->dims, input->dims)) {\n      TfLiteIntArray* input_quantized_size = TfLiteIntArrayCopy(input->dims);\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_quantized,\n                                                       input_quantized_size));\n    }\n\n    // Tell interpreter to allocate temporary tensors to store scaling factors.\n    node->temporaries->data[2] = scratch_tensor_index + 2;\n    TfLiteTensor* scaling_factors;\n    TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/2,\n                                                &scaling_factors));\n    scaling_factors->type = kTfLiteFloat32;\n    scaling_factors->allocation_type = kTfLiteArenaRw;\n    int scaling_dims[1] = {batch_size};\n    if (!TfLiteIntArrayEqualsArray(scaling_factors->dims, 1, scaling_dims)) {\n      TfLiteIntArray* scaling_factors_size = TfLiteIntArrayCreate(1);\n      scaling_factors_size->data[0] = batch_size;\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scaling_factors,\n                                                       scaling_factors_size));\n    }\n\n    // Used to store dequantized weights_time matrix for hybrid computation of\n    // matmul(state, weights_time), which occurs in floating point.\n    node->temporaries->data[3] = scratch_tensor_index + 3;\n    TfLiteTensor* float_weights_time;\n    TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/3,\n                                                &float_weights_time));\n    float_weights_time->type = kTfLiteFloat32;\n    // Persistent so that we can compute the dequantized weights only once.\n    float_weights_time->allocation_type = kTfLiteArenaRwPersistent;\n    if (!TfLiteIntArrayEqual(float_weights_time->dims, weights_time->dims)) {\n      TfLiteIntArray* float_weights_time_size =\n          TfLiteIntArrayCopy(weights_time->dims);\n      TF_LITE_ENSURE_OK(context,\n                        context->ResizeTensor(context, float_weights_time,\n                                              float_weights_time_size));\n    }\n\n    node->temporaries->data[4] = scratch_tensor_index + 4;\n    TfLiteTensor* zero_points;\n    TF_LITE_ENSURE_OK(\n        context, GetTemporarySafe(context, node, /*index=*/4, &zero_points));\n    zero_points->type = kTfLiteFloat32;\n    zero_points->allocation_type = kTfLiteArenaRw;\n    int zero_points_dims[1] = {batch_size};\n    if (!TfLiteIntArrayEqualsArray(zero_points->dims, 1, zero_points_dims)) {\n      TfLiteIntArray* zero_points_size = TfLiteIntArrayCreate(1);\n      zero_points_size->data[0] = zero_points_dims[0];\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, zero_points,\n                                                       zero_points_size));\n    }\n\n    node->temporaries->data[5] = scratch_tensor_index + 5;\n    TfLiteTensor* row_sums;\n    TF_LITE_ENSURE_OK(context,\n                      GetTemporarySafe(context, node, /*index=*/5, &row_sums));\n    row_sums->type = kTfLiteFloat32;\n    row_sums->allocation_type = kTfLiteArenaRwPersistent;\n    int row_sums_dims[1] = {num_filters};\n    if (!TfLiteIntArrayEqualsArray(row_sums->dims, 1, row_sums_dims)) {\n      TfLiteIntArray* row_sums_size = TfLiteIntArrayCreate(1);\n      row_sums_size->data[0] = row_sums_dims[0];\n      TF_LITE_ENSURE_OK(\n          context, context->ResizeTensor(context, row_sums, row_sums_size));\n    }\n  }\n  if (is_full_integer) {\n    // Allocated one extra tensor.\n    TfLiteIntArray* output_temp_size_array = TfLiteIntArrayCreate(2);\n    output_temp_size_array->data[0] = num_units;\n    output_temp_size_array->data[1] = batch_size;\n    node->temporaries->data[1] = scratch_tensor_index + 1;\n    TfLiteTensor* output_temp;\n    TF_LITE_ENSURE_OK(\n        context, GetTemporarySafe(context, node, /*index=*/1, &output_temp));\n    output_temp->type = kTfLiteInt32;\n    output_temp->allocation_type = kTfLiteArenaRw;\n    TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, output_temp,\n                                                     output_temp_size_array));\n\n    // Calculate effective scales.\n    TF_LITE_ENSURE(context, input->quantization.type != kTfLiteNoQuantization);\n    auto* input_params =\n        reinterpret_cast<TfLiteAffineQuantization*>(input->quantization.params);\n    TF_LITE_ENSURE(context,\n                   weights_feature->quantization.type != kTfLiteNoQuantization);\n    auto* weights_feature_params = reinterpret_cast<TfLiteAffineQuantization*>(\n        weights_feature->quantization.params);\n    TF_LITE_ENSURE(context, state->quantization.type != kTfLiteNoQuantization);\n    auto* state_params =\n        reinterpret_cast<TfLiteAffineQuantization*>(state->quantization.params);\n    TF_LITE_ENSURE(context,\n                   weights_time->quantization.type != kTfLiteNoQuantization);\n    auto* weight_time_params = reinterpret_cast<TfLiteAffineQuantization*>(\n        weights_time->quantization.params);\n    TF_LITE_ENSURE(context, output->quantization.type != kTfLiteNoQuantization);\n    auto* output_params = reinterpret_cast<TfLiteAffineQuantization*>(\n        output->quantization.params);\n    const double effective_scale_1 = input_params->scale->data[0] *\n                                     weights_feature_params->scale->data[0] /\n                                     state_params->scale->data[0];\n    const double effective_scale_2 = state_params->scale->data[0] *\n                                     weight_time_params->scale->data[0] /\n                                     output_params->scale->data[0];\n    QuantizeMultiplier(effective_scale_1, &op_data->effective_scale_1_a,\n                       &op_data->effective_scale_1_b);\n    QuantizeMultiplier(effective_scale_2, &op_data->effective_scale_2_a,\n                       &op_data->effective_scale_2_b);\n  }\n  return kTfLiteOk;\n}", "target": 1, "idx": 11547}
{"commit_id": "caf09f175a5e873a1256e0878a37865a8a06e427", "project": "nanomq/NanoNNG", "func": "uint8_t *\ncopyn_utf8_str(const uint8_t *src, uint32_t *pos, int *str_len, int limit)\n{\n\t*str_len      = 0;\n\tuint8_t *dest = NULL;\n\tint      max;\n\n\t// remaining length must > 2 for a valid length\n\tif (limit < 2)\n\t\treturn NULL;\n\tmax = limit + *pos;\n\n\tNNI_GET16(src + (*pos), *str_len);\n\t*pos = (*pos) + 2;\n\tif (*str_len > (limit-2)) {\n\t\t//buffer overflow\n\t\t*str_len = -1;\n\t\treturn NULL;\n\t}\n\tif (*str_len > 0) {\n\t\tif (utf8_check((const char *) (src + *pos), *str_len) ==\n\t\t    ERR_SUCCESS) {\n\t\t\tif ((dest = nng_alloc(*str_len + 1)) == NULL) {\n\t\t\t\t*str_len = 0;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tmemcpy(dest, src + (*pos), *str_len);\n\t\t\tdest[*str_len] = '\\0';\n\t\t\t*pos           = (*pos) + (*str_len);\n\t\t\tif (*pos >= max) {\n\t\t\t\tnng_free(dest, *str_len + 1);\n\t\t\t\t*str_len = -1;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\t*str_len = -1;\n\t\t}\n\t}\n\treturn dest;\n}", "target": 2, "idx": 11548}
{"commit_id": "65756b4082cd79a2d99b2ccb5b392291fd53703f", "project": "android", "func": "void SoftAMR::onQueueFilled(OMX_U32 /* portIndex */) {\n    List<BufferInfo *> &inQueue = getPortQueue(0);\n    List<BufferInfo *> &outQueue = getPortQueue(1);\n\n    if (mSignalledError || mOutputPortSettingsChange != NONE) {\n        return;\n    }\n\n    while (!inQueue.empty() && !outQueue.empty()) {\n        BufferInfo *inInfo = *inQueue.begin();\n        OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;\n\n        if (inHeader->nFilledLen == 0) {\n            inInfo->mOwnedByUs = false;\n            inQueue.erase(inQueue.begin());\n            notifyEmptyBufferDone(inHeader);\n            continue;\n        }\n\n        BufferInfo *outInfo = *outQueue.begin();\n        OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;\n\n        if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n            inQueue.erase(inQueue.begin());\n            inInfo->mOwnedByUs = false;\n            notifyEmptyBufferDone(inHeader);\n\n            outHeader->nFilledLen = 0;\n            outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n\n            outQueue.erase(outQueue.begin());\n            outInfo->mOwnedByUs = false;\n            notifyFillBufferDone(outHeader);\n            return;\n        }\n\n        if (inHeader->nOffset == 0) {\n            mAnchorTimeUs = inHeader->nTimeStamp;\n            mNumSamplesOutput = 0;\n        }\n\n        const uint8_t *inputPtr = inHeader->pBuffer + inHeader->nOffset;\n        int32_t numBytesRead;\n\n        if (mMode == MODE_NARROW) {\n            if (outHeader->nAllocLen < kNumSamplesPerFrameNB * sizeof(int16_t)) {\n                ALOGE(\"b/27662364: NB expected output buffer %zu bytes vs %u\",\n                       kNumSamplesPerFrameNB * sizeof(int16_t), outHeader->nAllocLen);\n                android_errorWriteLog(0x534e4554, \"27662364\");\n                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);\n                mSignalledError = true;\n                return;\n            }\n\n            int16 mode = ((inputPtr[0] >> 3) & 0x0f);\n            // for WMF since MIME_IETF is used when calling AMRDecode.\n            size_t frameSize = WmfDecBytesPerFrame[mode] + 1;\n\n            if (inHeader->nFilledLen < frameSize) {\n                ALOGE(\"b/27662364: expected %zu bytes vs %u\", frameSize, inHeader->nFilledLen);\n                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);\n                mSignalledError = true;\n                return;\n            }\n\n            numBytesRead =\n                AMRDecode(mState,\n                  (Frame_Type_3GPP)((inputPtr[0] >> 3) & 0x0f),\n                  (UWord8 *)&inputPtr[1],\n                  reinterpret_cast<int16_t *>(outHeader->pBuffer),\n                  MIME_IETF);\n\n            if (numBytesRead == -1) {\n                ALOGE(\"PV AMR decoder AMRDecode() call failed\");\n\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n\n                return;\n            }\n\n            ++numBytesRead;  // Include the frame type header byte.\n\n            if (static_cast<size_t>(numBytesRead) > inHeader->nFilledLen) {\n                // This is bad, should never have happened, but did. Abort now.\n\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n\n                return;\n            }\n        } else {\n            if (outHeader->nAllocLen < kNumSamplesPerFrameWB * sizeof(int16_t)) {\n                ALOGE(\"b/27662364: WB expected output buffer %zu bytes vs %u\",\n                       kNumSamplesPerFrameWB * sizeof(int16_t), outHeader->nAllocLen);\n                android_errorWriteLog(0x534e4554, \"27662364\");\n                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);\n                mSignalledError = true;\n                return;\n            }\n\n            int16 mode = ((inputPtr[0] >> 3) & 0x0f);\n\n            if (mode >= 10 && mode <= 13) {\n                ALOGE(\"encountered illegal frame type %d in AMR WB content.\",\n                      mode);\n\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n\n                return;\n            }\n\n            size_t frameSize = getFrameSize(mode);\n            if (inHeader->nFilledLen < frameSize) {\n                ALOGE(\"b/27662364: expected %zu bytes vs %u\", frameSize, inHeader->nFilledLen);\n                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);\n                mSignalledError = true;\n                return;\n            }\n\n            int16_t *outPtr = (int16_t *)outHeader->pBuffer;\n\n            if (mode >= 9) {\n                // Produce silence instead of comfort noise and for\n                // speech lost/no data.\n                memset(outPtr, 0, kNumSamplesPerFrameWB * sizeof(int16_t));\n            } else if (mode < 9) {\n                int16 frameType;\n                RX_State_wb rx_state;\n                mime_unsorting(\n                        const_cast<uint8_t *>(&inputPtr[1]),\n                        mInputSampleBuffer,\n                        &frameType, &mode, 1, &rx_state);\n\n                int16_t numSamplesOutput;\n                pvDecoder_AmrWb(\n                        mode, mInputSampleBuffer,\n                        outPtr,\n                        &numSamplesOutput,\n                        mDecoderBuf, frameType, mDecoderCookie);\n\n                CHECK_EQ((int)numSamplesOutput, (int)kNumSamplesPerFrameWB);\n\n                for (int i = 0; i < kNumSamplesPerFrameWB; ++i) {\n                    /* Delete the 2 LSBs (14-bit output) */\n                    outPtr[i] &= 0xfffC;\n                }\n            }\n\n            numBytesRead = frameSize;\n        }\n\n        inHeader->nOffset += numBytesRead;\n        inHeader->nFilledLen -= numBytesRead;\n\n        outHeader->nFlags = 0;\n        outHeader->nOffset = 0;\n\n        if (mMode == MODE_NARROW) {\n            outHeader->nFilledLen = kNumSamplesPerFrameNB * sizeof(int16_t);\n\n            outHeader->nTimeStamp =\n                mAnchorTimeUs\n                    + (mNumSamplesOutput * 1000000ll) / kSampleRateNB;\n\n            mNumSamplesOutput += kNumSamplesPerFrameNB;\n        } else {\n            outHeader->nFilledLen = kNumSamplesPerFrameWB * sizeof(int16_t);\n\n            outHeader->nTimeStamp =\n                mAnchorTimeUs\n                    + (mNumSamplesOutput * 1000000ll) / kSampleRateWB;\n\n            mNumSamplesOutput += kNumSamplesPerFrameWB;\n        }\n\n        if (inHeader->nFilledLen == 0) {\n            inInfo->mOwnedByUs = false;\n            inQueue.erase(inQueue.begin());\n            inInfo = NULL;\n            notifyEmptyBufferDone(inHeader);\n            inHeader = NULL;\n        }\n\n        outInfo->mOwnedByUs = false;\n        outQueue.erase(outQueue.begin());\n        outInfo = NULL;\n        notifyFillBufferDone(outHeader);\n        outHeader = NULL;\n\n        ++mInputBufferCount;\n    }\n}", "target": 2, "idx": 11549}
{"commit_id": "b8fcb59e9e1d1189caf2e0f5e39346944dcd6b9d", "project": "ImageMagick", "func": "static Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    colorspace[MagickPathExtent],\n    text[MagickPathExtent];\n\n  Image\n    *image;\n\n  long\n    x_offset,\n    y_offset;\n\n  PixelInfo\n    pixel;\n\n  MagickBooleanType\n    status;\n\n  QuantumAny\n    range;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  ssize_t\n    count,\n    type,\n    y;\n\n  unsigned long\n    depth,\n    height,\n    max_value,\n    width;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) ResetMagickMemory(text,0,sizeof(text));\n  (void) ReadBlobString(image,text);\n  if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) != 0)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  do\n  {\n    width=0;\n    height=0;\n    max_value=0;\n    *colorspace='\\0';\n    count=(ssize_t) sscanf(text+32,\"%lu,%lu,%lu,%32s\",&width,&height,&max_value,\n      colorspace);\n    if ((count != 4) || (width == 0) || (height == 0) || (max_value == 0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    image->columns=width;\n    image->rows=height;\n    if ((max_value == 0) || (max_value > 4294967295UL))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    for (depth=1; (GetQuantumRange(depth)+1) < max_value; depth++) ;\n    image->depth=depth;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    LocaleLower(colorspace);\n    i=(ssize_t) strlen(colorspace)-1;\n    image->alpha_trait=UndefinedPixelTrait;\n    if ((i > 0) && (colorspace[i] == 'a'))\n      {\n        colorspace[i]='\\0';\n        image->alpha_trait=BlendPixelTrait;\n      }\n    type=ParseCommandOption(MagickColorspaceOptions,MagickFalse,colorspace);\n    if (type < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    (void) SetImageBackgroundColor(image,exception);\n    (void) SetImageColorspace(image,(ColorspaceType) type,exception);\n    GetPixelInfo(image,&pixel);\n    range=GetQuantumRange(image->depth);\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      double\n        alpha,\n        black,\n        blue,\n        green,\n        red;\n\n      red=0.0;\n      green=0.0;\n      blue=0.0;\n      black=0.0;\n      alpha=0.0;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        if (ReadBlobString(image,text) == (char *) NULL)\n          break;\n        switch (image->colorspace)\n        {\n          case GRAYColorspace:\n          {\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                count=(ssize_t) sscanf(text,\"%ld,%ld: (%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&alpha);\n                green=red;\n                blue=red;\n                break;\n              }\n            count=(ssize_t) sscanf(text,\"%ld,%ld: (%lf%*[%,]\",&x_offset,\n              &y_offset,&red);\n            green=red;\n            blue=red;\n            break;       \n          }\n          case CMYKColorspace:\n          {\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                count=(ssize_t) sscanf(text,\n                  \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&green,&blue,&black,&alpha);\n                break;\n              }\n            count=(ssize_t) sscanf(text,\n              \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",&x_offset,\n              &y_offset,&red,&green,&blue,&black);\n            break;\n          }\n          default:\n          {\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                count=(ssize_t) sscanf(text,\n                  \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&green,&blue,&alpha);\n                break;\n              }\n            count=(ssize_t) sscanf(text,\n              \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]\",&x_offset,\n              &y_offset,&red,&green,&blue);\n            break;       \n          }\n        }\n        if (strchr(text,'%') != (char *) NULL)\n          {\n            red*=0.01*range;\n            green*=0.01*range;\n            blue*=0.01*range;\n            black*=0.01*range;\n            alpha*=0.01*range;\n          }\n        if (image->colorspace == LabColorspace)\n          {\n            green+=(range+1)/2.0;\n            blue+=(range+1)/2.0;\n          }\n        pixel.red=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (red+0.5),\n          range);\n        pixel.green=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (green+0.5),\n          range);\n        pixel.blue=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (blue+0.5),\n          range);\n        pixel.black=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (black+0.5),\n          range);\n        pixel.alpha=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (alpha+0.5),\n          range);\n        q=GetAuthenticPixels(image,(ssize_t) x_offset,(ssize_t) y_offset,1,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          continue;\n        SetPixelViaPixelInfo(image,&pixel,q);\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n      }\n    }\n    *text='\\0';\n    (void) ReadBlobString(image,text);\n    if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}", "target": 1, "idx": 11550}
{"commit_id": "e59dc85e6ce58fd7618c3680b2a8def62050582f", "project": "ImageMagick", "func": "static Image *ReadPATTERNImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  const void\n    *blob;\n\n  Image\n    *image;\n\n  ImageInfo\n    *blob_info;\n\n  register ssize_t\n    i;\n\n  size_t\n    extent;\n\n  blob_info=CloneImageInfo(image_info);\n  image=(Image *) NULL;\n  blob=(const void *) NULL;\n  extent=0;\n  for (i=0; PatternImageList[i].blob != (const void *) NULL; i++)\n    if (LocaleCompare(blob_info->filename,PatternImageList[i].name) == 0)\n      {\n        (void) CopyMagickString(blob_info->magick,PatternImageList[i].magick,\n          MaxTextExtent);\n        blob=PatternImageList[i].blob;\n        extent=PatternImageList[i].extent;\n        break;\n      }\n  if (blob == (const void *) NULL)\n    {\n      blob_info=DestroyImageInfo(blob_info);\n      ThrowReaderException(OptionError,\"UnrecognizedImageFormat\");\n    }\n  image=BlobToImage(blob_info,blob,extent,exception);\n  if (image_info->size != (char *) NULL)\n    {\n      Image\n        *pattern_image;\n\n      /*\n        Tile pattern across image canvas.\n      */\n      pattern_image=image;\n      image=AcquireImage(image_info);\n      (void) TextureImage(image,pattern_image);\n      pattern_image=DestroyImage(pattern_image);\n    }\n  blob_info=DestroyImageInfo(blob_info);\n  return(GetFirstImageInList(image));\n}", "target": 1, "idx": 11551}
{"commit_id": "90c4afcde1bf3ad5aead4477716161c350b049f8", "project": "ImageMagick", "func": "static MagickBooleanType WriteJP2Image(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  const char\n    *option,\n    *property;\n\n  int\n    jp2_status;\n\n  MagickBooleanType\n    status;\n\n  opj_codec_t\n    *jp2_codec;\n\n  OPJ_COLOR_SPACE\n    jp2_colorspace;\n\n  opj_cparameters_t\n    parameters;\n\n  opj_image_cmptparm_t\n    jp2_info[5];\n\n  opj_image_t\n    *jp2_image;\n\n  opj_stream_t\n    *jp2_stream;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    y;\n\n  unsigned int\n    channels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  /*\n    Initialize JPEG 2000 API.\n  */\n  opj_set_default_encoder_parameters(&parameters);\n  for (i=1; i < 6; i++)\n    if (((size_t) (1UL << (i+2)) > image->columns) &&\n        ((size_t) (1UL << (i+2)) > image->rows))\n      break;\n  parameters.numresolution=i;\n  option=GetImageOption(image_info,\"jp2:number-resolutions\");\n  if (option != (const char *) NULL)\n    parameters.numresolution=StringToInteger(option);\n  parameters.tcp_numlayers=1;\n  parameters.tcp_rates[0]=0;  /* lossless */\n  parameters.cp_disto_alloc=1;\n  if ((image_info->quality != 0) && (image_info->quality != 100))\n    {\n      parameters.tcp_distoratio[0]=(double) image_info->quality;\n      parameters.cp_fixed_quality=OPJ_TRUE;\n    }\n  if (image_info->extract != (char *) NULL)\n    {\n      RectangleInfo\n        geometry;\n\n      int\n        flags;\n\n      /*\n        Set tile size.\n      */\n      (void) memset(&geometry,0,sizeof(geometry));\n      flags=ParseAbsoluteGeometry(image_info->extract,&geometry);\n      parameters.cp_tdx=(int) geometry.width;\n      parameters.cp_tdy=(int) geometry.width;\n      if ((flags & HeightValue) != 0)\n        parameters.cp_tdy=(int) geometry.height;\n      if ((flags & XValue) != 0)\n        parameters.cp_tx0=geometry.x;\n      if ((flags & YValue) != 0)\n        parameters.cp_ty0=geometry.y;\n      parameters.tile_size_on=OPJ_TRUE;\n    }\n  option=GetImageOption(image_info,\"jp2:quality\");\n  if (option != (const char *) NULL)\n    {\n      register const char\n        *p;\n\n      /*\n        Set quality PSNR.\n      */\n      p=option;\n      for (i=0; sscanf(p,\"%f\",&parameters.tcp_distoratio[i]) == 1; i++)\n      {\n        if (i > 100)\n          break;\n        while ((*p != '\\0') && (*p != ','))\n          p++;\n        if (*p == '\\0')\n          break;\n        p++;\n      }\n      parameters.tcp_numlayers=i+1;\n      parameters.cp_fixed_quality=OPJ_TRUE;\n    }\n  option=GetImageOption(image_info,\"jp2:progression-order\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleCompare(option,\"LRCP\") == 0)\n        parameters.prog_order=OPJ_LRCP;\n      if (LocaleCompare(option,\"RLCP\") == 0)\n        parameters.prog_order=OPJ_RLCP;\n      if (LocaleCompare(option,\"RPCL\") == 0)\n        parameters.prog_order=OPJ_RPCL;\n      if (LocaleCompare(option,\"PCRL\") == 0)\n        parameters.prog_order=OPJ_PCRL;\n      if (LocaleCompare(option,\"CPRL\") == 0)\n        parameters.prog_order=OPJ_CPRL;\n    }\n  option=GetImageOption(image_info,\"jp2:rate\");\n  if (option != (const char *) NULL)\n    {\n      register const char\n        *p;\n\n      /*\n        Set compression rate.\n      */\n      p=option;\n      for (i=0; sscanf(p,\"%f\",&parameters.tcp_rates[i]) == 1; i++)\n      {\n        if (i >= 100)\n          break;\n        while ((*p != '\\0') && (*p != ','))\n          p++;\n        if (*p == '\\0')\n          break;\n        p++;\n      }\n      parameters.tcp_numlayers=i+1;\n      parameters.cp_disto_alloc=OPJ_TRUE;\n    }\n  if (image_info->sampling_factor != (const char *) NULL)\n    (void) sscanf(image_info->sampling_factor,\"%d,%d\",\n      &parameters.subsampling_dx,&parameters.subsampling_dy);\n  property=GetImageProperty(image,\"comment\",exception);\n  if (property != (const char *) NULL)\n    parameters.cp_comment=(char *) property;\n  channels=3;\n  jp2_colorspace=OPJ_CLRSPC_SRGB;\n  if (image->colorspace == YUVColorspace)\n    {\n      jp2_colorspace=OPJ_CLRSPC_SYCC;\n      parameters.subsampling_dx=2;\n    }\n  else\n    {\n      if (IsGrayColorspace(image->colorspace) != MagickFalse)\n        {\n          channels=1;\n          jp2_colorspace=OPJ_CLRSPC_GRAY;\n        }\n      else\n        (void) TransformImageColorspace(image,sRGBColorspace,exception);\n      if (image->alpha_trait != UndefinedPixelTrait)\n        channels++;\n    }\n  parameters.tcp_mct=channels == 3 ? 1 : 0;\n  memset(jp2_info,0,sizeof(jp2_info));\n  for (i=0; i < (ssize_t) channels; i++)\n  {\n    jp2_info[i].prec=(OPJ_UINT32) image->depth;\n    jp2_info[i].bpp=(OPJ_UINT32) image->depth;\n    if ((image->depth == 1) &&\n        ((LocaleCompare(image_info->magick,\"JPT\") == 0) ||\n         (LocaleCompare(image_info->magick,\"JP2\") == 0)))\n      {\n        jp2_info[i].prec++;  /* OpenJPEG returns exception for depth @ 1 */\n        jp2_info[i].bpp++;\n      }\n    jp2_info[i].sgnd=0;\n    jp2_info[i].dx=parameters.subsampling_dx;\n    jp2_info[i].dy=parameters.subsampling_dy;\n    jp2_info[i].w=(OPJ_UINT32) image->columns;\n    jp2_info[i].h=(OPJ_UINT32) image->rows;\n  }\n  jp2_image=opj_image_create((OPJ_UINT32) channels,jp2_info,jp2_colorspace);\n  if (jp2_image == (opj_image_t *) NULL)\n    ThrowWriterException(DelegateError,\"UnableToEncodeImageFile\");\n  jp2_image->x0=parameters.image_offset_x0;\n  jp2_image->y0=parameters.image_offset_y0;\n  jp2_image->x1=(unsigned int) (2*parameters.image_offset_x0+(image->columns-1)*\n    parameters.subsampling_dx+1);\n  jp2_image->y1=(unsigned int) (2*parameters.image_offset_y0+(image->rows-1)*\n    parameters.subsampling_dx+1);\n  if ((image->depth == 12) &&\n      ((image->columns == 2048) || (image->rows == 1080) ||\n       (image->columns == 4096) || (image->rows == 2160)))\n    CinemaProfileCompliance(jp2_image,&parameters);\n  if (channels == 4)\n    jp2_image->comps[3].alpha=1;\n  else\n   if ((channels == 2) && (jp2_colorspace == OPJ_CLRSPC_GRAY))\n     jp2_image->comps[1].alpha=1;\n  /*\n    Convert to JP2 pixels.\n  */\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *p;\n\n    ssize_t\n      x;\n\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      for (i=0; i < (ssize_t) channels; i++)\n      {\n        double\n          scale;\n\n        register int\n          *q;\n\n        scale=(double) ((1UL << jp2_image->comps[i].prec)-1)/QuantumRange;\n        q=jp2_image->comps[i].data+(y/jp2_image->comps[i].dy*\n          image->columns/jp2_image->comps[i].dx+x/jp2_image->comps[i].dx);\n        switch (i)\n        {\n          case 0:\n          {\n            if (jp2_colorspace == OPJ_CLRSPC_GRAY)\n              {\n                *q=(int) (scale*GetPixelGray(image,p));\n                break;\n              }\n            *q=(int) (scale*GetPixelRed(image,p));\n            break;\n          }\n          case 1:\n          {\n            if (jp2_colorspace == OPJ_CLRSPC_GRAY)\n              {\n                *q=(int) (scale*GetPixelAlpha(image,p));\n                break;\n              }\n            *q=(int) (scale*GetPixelGreen(image,p));\n            break;\n          }\n          case 2:\n          {\n            *q=(int) (scale*GetPixelBlue(image,p));\n            break;\n          }\n          case 3:\n          {\n            *q=(int) (scale*GetPixelAlpha(image,p));\n            break;\n          }\n        }\n      }\n      p+=GetPixelChannels(image);\n    }\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  if (LocaleCompare(image_info->magick,\"JPT\") == 0)\n    jp2_codec=opj_create_compress(OPJ_CODEC_JPT);\n  else\n    if (LocaleCompare(image_info->magick,\"J2K\") == 0)\n      jp2_codec=opj_create_compress(OPJ_CODEC_J2K);\n    else\n      jp2_codec=opj_create_compress(OPJ_CODEC_JP2);\n  opj_set_warning_handler(jp2_codec,JP2WarningHandler,exception);\n  opj_set_error_handler(jp2_codec,JP2ErrorHandler,exception);\n  opj_setup_encoder(jp2_codec,&parameters,jp2_image);\n  jp2_stream=opj_stream_create(OPJ_J2K_STREAM_CHUNK_SIZE,OPJ_FALSE);\n  if (jp2_stream == (opj_stream_t *) NULL)\n    {\n      opj_destroy_codec(jp2_codec);\n      opj_image_destroy(jp2_image);\n      ThrowWriterException(DelegateError,\"UnableToEncodeImageFile\");\n    }\n  opj_stream_set_read_function(jp2_stream,JP2ReadHandler);\n  opj_stream_set_write_function(jp2_stream,JP2WriteHandler);\n  opj_stream_set_seek_function(jp2_stream,JP2SeekHandler);\n  opj_stream_set_skip_function(jp2_stream,JP2SkipHandler);\n  opj_stream_set_user_data(jp2_stream,image,NULL);\n  jp2_status=opj_start_compress(jp2_codec,jp2_image,jp2_stream);\n  if ((jp2_status == 0) || (opj_encode(jp2_codec,jp2_stream) == 0) ||\n      (opj_end_compress(jp2_codec,jp2_stream) == 0))\n    {\n      opj_stream_destroy(jp2_stream);\n      opj_destroy_codec(jp2_codec);\n      opj_image_destroy(jp2_image);\n      ThrowWriterException(DelegateError,\"UnableToEncodeImageFile\");\n    }\n  /*\n    Free resources.\n  */\n  opj_stream_destroy(jp2_stream);\n  opj_destroy_codec(jp2_codec);\n  opj_image_destroy(jp2_image);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}", "target": 2, "idx": 11552}
{"commit_id": "535a786f124b739e3c857529cecc29e4eeb79778", "project": "podofo", "func": "void PdfXRefStreamParserObject::ReadXRefTable()\n{\n    int64_t size = this->GetDictionary().FindKeyAs<int64_t>(PdfName::KeySize, 0);\n    auto& arrObj = this->GetDictionary().MustFindKey(\"W\");\n\n    // The pdf reference states that W is always an array with 3 entries\n    // all of them have to be integers\n    const PdfArray* arr;\n    if (!arrObj.TryGetArray(arr) || arr->size() != 3)\n        PODOFO_RAISE_ERROR_INFO(PdfErrorCode::InvalidXRefStream, \"Invalid XRef stream /W array\");\n\n    int64_t wArray[W_ARRAY_SIZE] = { 0, 0, 0 };\n    int64_t num;\n    for (unsigned i = 0; i < W_ARRAY_SIZE; i++)\n    {\n\n        if (!(*arr)[i].TryGetNumber(num))\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::InvalidXRefStream, \"Invalid XRef stream /W array\");\n\n        wArray[i] = num;\n    }\n\n    vector<int64_t> indices;\n    getIndices(indices, static_cast<int64_t>(size));\n\n    parseStream(wArray, indices);\n}", "target": 2, "idx": 11553}
{"commit_id": "b8beb55913471952f92770c90c372139d78c16c0", "project": "FreeRDP", "func": "BOOL update_write_cache_bitmap_v3_order(wStream* s, CACHE_BITMAP_V3_ORDER* cache_bitmap_v3,\n                                        UINT16* flags)\n{\n\tBOOL rc;\n\tBYTE bitsPerPixelId;\n\tBITMAP_DATA_EX* bitmapData;\n\n\tif (!Stream_EnsureRemainingCapacity(\n\t        s, update_approximate_cache_bitmap_v3_order(cache_bitmap_v3, flags)))\n\t\treturn FALSE;\n\n\tbitmapData = &cache_bitmap_v3->bitmapData;\n\tbitsPerPixelId = get_bpp_bmf(cache_bitmap_v3->bpp, &rc);\n\tif (!rc)\n\t\treturn FALSE;\n\t*flags = (cache_bitmap_v3->cacheId & 0x00000003) |\n\t         ((cache_bitmap_v3->flags << 7) & 0x0000FF80) | ((bitsPerPixelId << 3) & 0x00000078);\n\tStream_Write_UINT16(s, cache_bitmap_v3->cacheIndex); /* cacheIndex (2 bytes) */\n\tStream_Write_UINT32(s, cache_bitmap_v3->key1);       /* key1 (4 bytes) */\n\tStream_Write_UINT32(s, cache_bitmap_v3->key2);       /* key2 (4 bytes) */\n\tStream_Write_UINT8(s, bitmapData->bpp);\n\tStream_Write_UINT8(s, 0);                   /* reserved1 (1 byte) */\n\tStream_Write_UINT8(s, 0);                   /* reserved2 (1 byte) */\n\tStream_Write_UINT8(s, bitmapData->codecID); /* codecID (1 byte) */\n\tStream_Write_UINT16(s, bitmapData->width);  /* width (2 bytes) */\n\tStream_Write_UINT16(s, bitmapData->height); /* height (2 bytes) */\n\tStream_Write_UINT32(s, bitmapData->length); /* length (4 bytes) */\n\tStream_Write(s, bitmapData->data, bitmapData->length);\n\treturn TRUE;\n}", "target": 0, "idx": 11554}
{"commit_id": "a22959beae1aad96b1f72710a5daadf529c41bda", "project": "tiann/KernelSU", "func": "bool become_manager(char *pkg)\n{\n\tstruct fdtable *files_table;\n\tint i = 0;\n\tstruct path files_path;\n\tchar *cwd;\n\tchar *buf;\n\tbool result = false;\n\n\t// must be zygote's direct child, otherwise any app can fork a new process and\n\t// open manager's apk\n\tif (task_uid(current->real_parent).val != 0) {\n\t\tpr_info(\"parent is not zygote!\\n\");\n\t\treturn false;\n\t}\n\n\tbuf = (char *)kmalloc(PATH_MAX, GFP_ATOMIC);\n\tif (!buf) {\n\t\tpr_err(\"kalloc path failed.\\n\");\n\t\treturn false;\n\t}\n\n\tfiles_table = files_fdtable(current->files);\n\n\tint pkg_len = strlen(pkg);\n\t// todo: use iterate_fd\n\tfor (i = 0; files_table->fd[i] != NULL; i++) {\n\t\tfiles_path = files_table->fd[i]->f_path;\n\t\tif (!d_is_reg(files_path.dentry)) {\n\t\t\tcontinue;\n\t\t}\n\t\tcwd = d_path(&files_path, buf, PATH_MAX);\n\t\tif (startswith(cwd, \"/data/app/\") != 0 ||\n\t\t    endswith(cwd, \"/base.apk\") != 0) {\n\t\t\tcontinue;\n\t\t}\n\t\t// we have found the apk!\n\t\tpr_info(\"found apk: %s\\n\", cwd);\n\t\tchar *pkg_index = strstr(cwd, pkg);\n\t\tif (!pkg_index) {\n\t\t\tpr_info(\"apk path not match package name!\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tchar *next_char = pkg_index + pkg_len;\n\t\t// because we ensure the cwd must startswith `/data/app` and endswith `base.apk`\n\t\t// we don't need to check if the pointer is out of bounds\n\t\tif (*next_char != '-') {\n\t\t\t// from android 8.1: http://aospxref.com/android-8.1.0_r81/xref/frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java#17612\n\t\t\t// to android 13: http://aospxref.com/android-13.0.0_r3/xref/frameworks/base/services/core/java/com/android/server/pm/PackageManagerServiceUtils.java#1208\n\t\t\t// /data/app/~~[randomStringA]/[packageName]-[randomStringB]\n\t\t\t// the previous char must be `/` and the next char must be `-`\n\t\t\t// because we use strstr instead of equals, this is a strong verfication.\n\t\t\tpr_info(\"invalid pkg: %s\\n\", pkg);\n\t\t\tcontinue;\n\t\t}\n\t\tif (is_manager_apk(cwd)) {\n\t\t\t// check passed\n\t\t\tuid_t uid = current_uid().val;\n\t\t\tpr_info(\"manager uid: %d\\n\", uid);\n\n\t\t\tksu_set_manager_uid(uid);\n\n\t\t\tresult = true;\n\t\t\tgoto clean;\n\t\t} else {\n\t\t\tpr_info(\"manager signature invalid!\\n\");\n\t\t}\n\n\t\tbreak;\n\t}\n\nclean:\n\tkfree(buf);\n\treturn result;\n}", "target": 3, "idx": 11555}
{"commit_id": "a5770b6559b6e6765c4ef800e85ae42781ea4900", "project": "wireshark", "func": "static gint\nhandle_message_body_parameters(tvbuff_t    *tvb,\n                               packet_info *pinfo,\n                               proto_tree  *header_tree,\n                               guint       encoding,\n                               gint        offset,\n                               gint32      body_length,\n                               guint8      *signature,\n                               guint8      signature_length)\n{\n    gint        packet_length, end_of_body;\n    proto_tree *tree;\n    proto_item *item;\n    const gint  starting_offset = offset;\n\n    packet_length = tvb_reported_length(tvb);\n\n    /* Add a subtree/row for the message body parameters. */\n    item = proto_tree_add_item(header_tree, hf_alljoyn_mess_body_parameters, tvb, offset, body_length, ENC_NA);\n    tree = proto_item_add_subtree(item, ett_alljoyn_mess_body_parameters);\n\n    end_of_body = offset + body_length;\n\n    if(end_of_body > packet_length) {\n        end_of_body = packet_length;\n    }\n\n    while(offset < end_of_body && signature_length > 0 && signature && *signature) {\n        offset = parse_arg(tvb,\n                           pinfo,\n                           NULL,\n                           encoding,\n                           offset,\n                           tree,    /* Add the args to the Parameters tree. */\n                           FALSE,\n                           *signature,\n                           HDR_INVALID,\n                           &signature,\n                           &signature_length,\n                           starting_offset);\n    }\n\n    return offset;\n}", "target": 1, "idx": 11556}
{"commit_id": "8eba2bd291b347e3008aa9e565652d51ad638cfa", "project": "vim", "func": "int\nget_lisp_indent(void)\n{\n    pos_T\t*pos, realpos, paren;\n    int\t\tamount;\n    char_u\t*that;\n    colnr_T\tcol;\n    colnr_T\tfirsttry;\n    int\t\tparencount, quotecount;\n    int\t\tvi_lisp;\n\n    // Set vi_lisp to use the vi-compatible method\n    vi_lisp = (vim_strchr(p_cpo, CPO_LISP) != NULL);\n\n    realpos = curwin->w_cursor;\n    curwin->w_cursor.col = 0;\n\n    if ((pos = findmatch(NULL, '(')) == NULL)\n\tpos = findmatch(NULL, '[');\n    else\n    {\n\tparen = *pos;\n\tpos = findmatch(NULL, '[');\n\tif (pos == NULL || LT_POSP(pos, &paren))\n\t    pos = &paren;\n    }\n    if (pos != NULL)\n    {\n\t// Extra trick: Take the indent of the first previous non-white\n\t// line that is at the same () level.\n\tamount = -1;\n\tparencount = 0;\n\n\twhile (--curwin->w_cursor.lnum >= pos->lnum)\n\t{\n\t    if (linewhite(curwin->w_cursor.lnum))\n\t\tcontinue;\n\t    for (that = ml_get_curline(); *that != NUL; ++that)\n\t    {\n\t\tif (*that == ';')\n\t\t{\n\t\t    while (*(that + 1) != NUL)\n\t\t\t++that;\n\t\t    continue;\n\t\t}\n\t\tif (*that == '\\\\')\n\t\t{\n\t\t    if (*(that + 1) != NUL)\n\t\t\t++that;\n\t\t    continue;\n\t\t}\n\t\tif (*that == '\"' && *(that + 1) != NUL)\n\t\t{\n\t\t    while (*++that && *that != '\"')\n\t\t    {\n\t\t\t// skipping escaped characters in the string\n\t\t\tif (*that == '\\\\')\n\t\t\t{\n\t\t\t    if (*++that == NUL)\n\t\t\t\tbreak;\n\t\t\t    if (that[1] == NUL)\n\t\t\t    {\n\t\t\t\t++that;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    if (*that == NUL)\n\t\t\tbreak;\n\t\t}\n\t\tif (*that == '(' || *that == '[')\n\t\t    ++parencount;\n\t\telse if (*that == ')' || *that == ']')\n\t\t    --parencount;\n\t    }\n\t    if (parencount == 0)\n\t    {\n\t\tamount = get_indent();\n\t\tbreak;\n\t    }\n\t}\n\n\tif (amount == -1)\n\t{\n\t    curwin->w_cursor.lnum = pos->lnum;\n\t    curwin->w_cursor.col = pos->col;\n\t    col = pos->col;\n\n\t    that = ml_get_curline();\n\n\t    if (vi_lisp && get_indent() == 0)\n\t\tamount = 2;\n\t    else\n\t    {\n\t\tchar_u *line = that;\n\n\t\tamount = 0;\n\t\twhile (*that && col)\n\t\t{\n\t\t    amount += lbr_chartabsize_adv(line, &that, (colnr_T)amount);\n\t\t    col--;\n\t\t}\n\n\t\t// Some keywords require \"body\" indenting rules (the\n\t\t// non-standard-lisp ones are Scheme special forms):\n\t\t//\n\t\t// (let ((a 1))    instead    (let ((a 1))\n\t\t//   (...))\t      of\t   (...))\n\n\t\tif (!vi_lisp && (*that == '(' || *that == '[')\n\t\t\t\t\t\t      && lisp_match(that + 1))\n\t\t    amount += 2;\n\t\telse\n\t\t{\n\t\t    if (*that != NUL)\n\t\t    {\n\t\t\tthat++;\n\t\t\tamount++;\n\t\t    }\n\t\t    firsttry = amount;\n\n\t\t    while (VIM_ISWHITE(*that))\n\t\t    {\n\t\t\tamount += lbr_chartabsize(line, that, (colnr_T)amount);\n\t\t\t++that;\n\t\t    }\n\n\t\t    if (*that && *that != ';') // not a comment line\n\t\t    {\n\t\t\t// test *that != '(' to accommodate first let/do\n\t\t\t// argument if it is more than one line\n\t\t\tif (!vi_lisp && *that != '(' && *that != '[')\n\t\t\t    firsttry++;\n\n\t\t\tparencount = 0;\n\t\t\tquotecount = 0;\n\n\t\t\tif (vi_lisp\n\t\t\t\t|| (*that != '\"'\n\t\t\t\t    && *that != '\\''\n\t\t\t\t    && *that != '#'\n\t\t\t\t    && (*that < '0' || *that > '9')))\n\t\t\t{\n\t\t\t    while (*that\n\t\t\t\t    && (!VIM_ISWHITE(*that)\n\t\t\t\t\t|| quotecount\n\t\t\t\t\t|| parencount)\n\t\t\t\t    && (!((*that == '(' || *that == '[')\n\t\t\t\t\t    && !quotecount\n\t\t\t\t\t    && !parencount\n\t\t\t\t\t    && vi_lisp)))\n\t\t\t    {\n\t\t\t\tif (*that == '\"')\n\t\t\t\t    quotecount = !quotecount;\n\t\t\t\tif ((*that == '(' || *that == '[')\n\t\t\t\t\t\t\t       && !quotecount)\n\t\t\t\t    ++parencount;\n\t\t\t\tif ((*that == ')' || *that == ']')\n\t\t\t\t\t\t\t       && !quotecount)\n\t\t\t\t    --parencount;\n\t\t\t\tif (*that == '\\\\' && *(that+1) != NUL)\n\t\t\t\t    amount += lbr_chartabsize_adv(\n\t\t\t\t\t\tline, &that, (colnr_T)amount);\n\t\t\t\tamount += lbr_chartabsize_adv(\n\t\t\t\t\t\tline, &that, (colnr_T)amount);\n\t\t\t    }\n\t\t\t}\n\t\t\twhile (VIM_ISWHITE(*that))\n\t\t\t{\n\t\t\t    amount += lbr_chartabsize(\n\t\t\t\t\t\t line, that, (colnr_T)amount);\n\t\t\t    that++;\n\t\t\t}\n\t\t\tif (!*that || *that == ';')\n\t\t\t    amount = firsttry;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    else\n\tamount = 0;\t// no matching '(' or '[' found, use zero indent\n\n    curwin->w_cursor = realpos;\n\n    return amount;\n}", "target": 2, "idx": 11557}
{"commit_id": "bf814387f42e9b0dea9d75c03db4723c88e7d962", "project": "ffmpeg", "func": "static int read_vlc_prefix(GetBitContext *gb, JXLEntropyDecoder *dec, JXLSymbolDistribution *dist)\n{\n    int8_t level1_lens[18] = { 0 };\n    int8_t level1_lens_s[18] = { 0 };\n    int16_t level1_syms[18] = { 0 };\n    uint32_t level1_codecounts[19] = { 0 };\n    uint8_t *buf = NULL;\n    int8_t *level2_lens, *level2_lens_s;\n    int16_t *level2_syms;\n    uint32_t *level2_codecounts;\n\n    int repeat_count_prev = 0, repeat_count_zero = 0, prev = 8;\n    int total_code = 0, len, hskip, num_codes = 0, ret;\n\n    VLC level1_vlc = { 0 };\n\n    if (dist->alphabet_size == 1) {\n        dist->vlc.bits = 0;\n        dist->default_symbol = 0;\n        return 0;\n    }\n\n    hskip = get_bits(gb, 2);\n    if (hskip == 1)\n        return read_simple_vlc_prefix(gb, dec, dist);\n\n    level1_codecounts[0] = hskip;\n    for (int i = hskip; i < 18; i++) {\n        len = level1_lens[prefix_codelen_map[i]] = get_vlc2(gb, level0_table, 4, 1);\n        level1_codecounts[len]++;\n        if (len) {\n            total_code += (32 >> len);\n            num_codes++;\n        }\n        if (total_code >= 32) {\n            level1_codecounts[0] += 18 - i - 1;\n            break;\n        }\n    }\n\n    if (total_code != 32 && num_codes >= 2 || num_codes < 1) {\n        ret = AVERROR_INVALIDDATA;\n        goto end;\n    }\n\n    for (int i = 1; i < 19; i++)\n         level1_codecounts[i] += level1_codecounts[i - 1];\n\n    for (int i = 17; i >= 0; i--) {\n        int idx = --level1_codecounts[level1_lens[i]];\n        level1_lens_s[idx] = level1_lens[i];\n        level1_syms[idx] = i;\n    }\n\n    ret = ff_vlc_init_from_lengths(&level1_vlc, 5, 18, level1_lens_s, 1, level1_syms, 2, 2,\n        0, VLC_INIT_LE, dec->logctx);\n    if (ret < 0)\n        goto end;\n\n    buf = av_mallocz(MAX_PREFIX_ALPHABET_SIZE * (2 * sizeof(int8_t) + sizeof(int16_t) + sizeof(uint32_t))\n                     + sizeof(uint32_t));\n    if (!buf) {\n        ret = AVERROR(ENOMEM);\n        goto end;\n    }\n\n    level2_lens = (int8_t *)buf;\n    level2_lens_s = (int8_t *)(buf + MAX_PREFIX_ALPHABET_SIZE * sizeof(int8_t));\n    level2_syms = (int16_t *)(buf + MAX_PREFIX_ALPHABET_SIZE * (2 * sizeof(int8_t)));\n    level2_codecounts = (uint32_t *)(buf + MAX_PREFIX_ALPHABET_SIZE * (2 * sizeof(int8_t) + sizeof(int16_t)));\n\n    total_code = 0;\n    for (int i = 0; i < dist->alphabet_size; i++) {\n        len = get_vlc2(gb, level1_vlc.table, 5, 1);\n        if (get_bits_left(gb) < 0) {\n            ret = AVERROR_BUFFER_TOO_SMALL;\n            goto end;\n        }\n        if (len == 16) {\n            int extra = 3 + get_bits(gb, 2);\n            if (repeat_count_prev)\n                extra += 4 * (repeat_count_prev - 2) - repeat_count_prev;\n            extra = FFMIN(extra, dist->alphabet_size - i);\n            for (int j = 0; j < extra; j++)\n                level2_lens[i + j] = prev;\n            total_code += (32768 >> prev) * extra;\n            i += extra - 1;\n            repeat_count_prev += extra;\n            repeat_count_zero = 0;\n            level2_codecounts[prev] += extra;\n        } else if (len == 17) {\n            int extra = 3 + get_bits(gb, 3);\n            if (repeat_count_zero > 0)\n                extra += 8 * (repeat_count_zero - 2) - repeat_count_zero;\n            extra = FFMIN(extra, dist->alphabet_size - i);\n            i += extra - 1;\n            repeat_count_prev = 0;\n            repeat_count_zero += extra;\n            level2_codecounts[0] += extra;\n        } else {\n            level2_lens[i] = len;\n            repeat_count_prev = repeat_count_zero = 0;\n            if (len) {\n                total_code += (32768 >> len);\n                prev = len;\n            }\n            level2_codecounts[len]++;\n        }\n        if (total_code >= 32768) {\n            level2_codecounts[0] += dist->alphabet_size - i - 1;\n            break;\n        }\n    }\n\n    if (total_code != 32768 && level2_codecounts[0] < dist->alphabet_size - 1) {\n        ret = AVERROR_INVALIDDATA;\n        goto end;\n    }\n\n    for (int i = 1; i < dist->alphabet_size + 1; i++)\n        level2_codecounts[i] += level2_codecounts[i - 1];\n\n    for (int i = dist->alphabet_size - 1; i >= 0; i--) {\n        int idx = --level2_codecounts[level2_lens[i]];\n        level2_lens_s[idx] = level2_lens[i];\n        level2_syms[idx] = i;\n    }\n\n    ret = ff_vlc_init_from_lengths(&dist->vlc, 15, dist->alphabet_size, level2_lens_s,\n                                    1, level2_syms, 2, 2, 0, VLC_INIT_LE, dec->logctx);\n\nend:\n    av_freep(&buf);\n    ff_vlc_free(&level1_vlc);\n\n    return ret;\n}", "target": 1, "idx": 11558}
{"commit_id": "992a11007fff6cfd40b952150ab8d30410c4a20a", "project": "sonicdoe/detect-character-encoding", "func": "NAN_METHOD(DetectCharacterEncoding) {\n\tNan::HandleScope scope;\n\n\tv8::Local<v8::Object> inputBuffer = info[0]->ToObject();\n\n\tUCharsetDetector *charsetDetector;\n\tconst UCharsetMatch *charsetMatch;\n\tUErrorCode errorCode = U_ZERO_ERROR;\n\n\tcharsetDetector = ucsdet_open(&errorCode);\n\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to open ICU charset detector.\");\n\t\treturn;\n\t}\n\n\tucsdet_setText(\n\t\tcharsetDetector,\n\t\tnode::Buffer::Data(inputBuffer),\n\t\tnode::Buffer::Length(inputBuffer),\n\t\t&errorCode\n\t);\n\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to set ICU charset detector\u2019s text.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\n\tcharsetMatch = ucsdet_detect(charsetDetector, &errorCode);\n\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to detect charset.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\n\tif(charsetMatch == NULL) {\n\t\tinfo.GetReturnValue().Set(Nan::Null());\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\n\tconst char *charsetName = ucsdet_getName(charsetMatch, &errorCode);\n\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get name from charset match.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\n\tint32_t confidence = ucsdet_getConfidence(charsetMatch, &errorCode);\n\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get confidence from charset match.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\n\tv8::Local<v8::Object> obj = Nan::New<v8::Object>();\n\tobj->Set(Nan::New<v8::String>(\"encoding\").ToLocalChecked(), Nan::New<v8::String>(charsetName).ToLocalChecked());\n\tobj->Set(Nan::New<v8::String>(\"confidence\").ToLocalChecked(), Nan::New<v8::Number>(confidence));\n\n\tinfo.GetReturnValue().Set(obj);\n\tucsdet_close(charsetDetector);\n}", "target": 2, "idx": 11559}
{"commit_id": "211124b972e74f0da66bc8b16f181f78793e2f66", "project": "the-tcpdump-group/tcpdump", "func": "static int\ndccp_print_option(netdissect_options *ndo, const u_char *option, u_int hlen)\n{\n\tuint8_t optlen, i;\n\n\tND_TCHECK(*option);\n\n\tif (*option >= 32) {\n\t\tND_TCHECK(*(option+1));\n\t\toptlen = *(option +1);\n\t\tif (optlen < 2) {\n\t\t\tif (*option >= 128)\n\t\t\t\tND_PRINT((ndo, \"CCID option %u optlen too short\", *option));\n\t\t\telse\n\t\t\t\tND_PRINT((ndo, \"%s optlen too short\",\n\t\t\t\t\t  tok2str(dccp_option_values, \"Option %u\", *option)));\n\t\t\treturn 0;\n\t\t}\n\t} else\n\t\toptlen = 1;\n\n\tif (hlen < optlen) {\n\t\tif (*option >= 128)\n\t\t\tND_PRINT((ndo, \"CCID option %u optlen goes past header length\",\n\t\t\t\t  *option));\n\t\telse\n\t\t\tND_PRINT((ndo, \"%s optlen goes past header length\",\n\t\t\t\t  tok2str(dccp_option_values, \"Option %u\", *option)));\n\t\treturn 0;\n\t}\n\tND_TCHECK2(*option, optlen);\n\n\tif (*option >= 128) {\n\t\tND_PRINT((ndo, \"CCID option %d\", *option));\n\t\tswitch (optlen) {\n\t\t\tcase 4:\n\t\t\t\tND_PRINT((ndo, \" %u\", EXTRACT_16BITS(option + 2)));\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tND_PRINT((ndo, \" %u\", EXTRACT_32BITS(option + 2)));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tND_PRINT((ndo, \"%s\", tok2str(dccp_option_values, \"Option %u\", *option)));\n\t\tswitch (*option) {\n\t\tcase 32:\n\t\tcase 33:\n\t\tcase 34:\n\t\tcase 35:\n\t\t\tif (optlen < 3) {\n\t\t\t\tND_PRINT((ndo, \" optlen too short\"));\n\t\t\t\treturn optlen;\n\t\t\t}\n\t\t\tif (*(option + 2) < 10){\n\t\t\t\tND_PRINT((ndo, \" %s\", dccp_feature_nums[*(option + 2)]));\n\t\t\t\tfor (i = 0; i < optlen - 3; i++)\n\t\t\t\t\tND_PRINT((ndo, \" %d\", *(option + 3 + i)));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 36:\n\t\t\tif (optlen > 2) {\n\t\t\t\tND_PRINT((ndo, \" 0x\"));\n\t\t\t\tfor (i = 0; i < optlen - 2; i++)\n\t\t\t\t\tND_PRINT((ndo, \"%02x\", *(option + 2 + i)));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 37:\n\t\t\tfor (i = 0; i < optlen - 2; i++)\n\t\t\t\tND_PRINT((ndo, \" %d\", *(option + 2 + i)));\n\t\t\tbreak;\n\t\tcase 38:\n\t\t\tif (optlen > 2) {\n\t\t\t\tND_PRINT((ndo, \" 0x\"));\n\t\t\t\tfor (i = 0; i < optlen - 2; i++)\n\t\t\t\t\tND_PRINT((ndo, \"%02x\", *(option + 2 + i)));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 39:\n\t\t\tif (optlen > 2) {\n\t\t\t\tND_PRINT((ndo, \" 0x\"));\n\t\t\t\tfor (i = 0; i < optlen - 2; i++)\n\t\t\t\t\tND_PRINT((ndo, \"%02x\", *(option + 2 + i)));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 40:\n\t\t\tif (optlen > 2) {\n\t\t\t\tND_PRINT((ndo, \" 0x\"));\n\t\t\t\tfor (i = 0; i < optlen - 2; i++)\n\t\t\t\t\tND_PRINT((ndo, \"%02x\", *(option + 2 + i)));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 41:\n\t\t/*\n\t\t * 13.1.  Timestamp Option\n\t\t *\n\t\t *  +--------+--------+--------+--------+--------+--------+\n\t\t *  |00101001|00000110|          Timestamp Value          |\n\t\t *  +--------+--------+--------+--------+--------+--------+\n\t\t *   Type=41  Length=6\n\t\t */\n\t\t\tif (optlen == 6)\n\t\t\t\tND_PRINT((ndo, \" %u\", EXTRACT_32BITS(option + 2)));\n\t\t\telse\n\t\t\t\tND_PRINT((ndo, \" [optlen != 6]\"));\n\t\t\tbreak;\n\t\tcase 42:\n\t\t/*\n\t\t * 13.3.  Timestamp Echo Option\n\t\t *\n\t\t *  +--------+--------+--------+--------+--------+--------+\n\t\t *  |00101010|00000110|           Timestamp Echo          |\n\t\t *  +--------+--------+--------+--------+--------+--------+\n\t\t *   Type=42    Len=6\n\t\t *\n\t\t *  +--------+--------+------- ... -------+--------+--------+\n\t\t *  |00101010|00001000|  Timestamp Echo   |   Elapsed Time  |\n\t\t *  +--------+--------+------- ... -------+--------+--------+\n\t\t *   Type=42    Len=8       (4 bytes)\n\t\t *\n\t\t *  +--------+--------+------- ... -------+------- ... -------+\n\t\t *  |00101010|00001010|  Timestamp Echo   |    Elapsed Time   |\n\t\t *  +--------+--------+------- ... -------+------- ... -------+\n\t\t *   Type=42   Len=10       (4 bytes)           (4 bytes)\n\t\t */\n\t\t\tswitch (optlen) {\n\t\t\tcase 6:\n\t\t\t\tND_PRINT((ndo, \" %u\", EXTRACT_32BITS(option + 2)));\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tND_PRINT((ndo, \" %u\", EXTRACT_32BITS(option + 2)));\n\t\t\t\tND_PRINT((ndo, \" (elapsed time %u)\", EXTRACT_16BITS(option + 6)));\n\t\t\t\tbreak;\n\t\t\tcase 10:\n\t\t\t\tND_PRINT((ndo, \" %u\", EXTRACT_32BITS(option + 2)));\n\t\t\t\tND_PRINT((ndo, \" (elapsed time %u)\", EXTRACT_32BITS(option + 6)));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \" [optlen != 6 or 8 or 10]\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 43:\n\t\t\tif (optlen == 6)\n\t\t\t\tND_PRINT((ndo, \" %u\", EXTRACT_32BITS(option + 2)));\n\t\t\telse if (optlen == 4)\n\t\t\t\tND_PRINT((ndo, \" %u\", EXTRACT_16BITS(option + 2)));\n\t\t\telse\n\t\t\t\tND_PRINT((ndo, \" [optlen != 4 or 6]\"));\n\t\t\tbreak;\n\t\tcase 44:\n\t\t\tif (optlen > 2) {\n\t\t\t\tND_PRINT((ndo, \" \"));\n\t\t\t\tfor (i = 0; i < optlen - 2; i++)\n\t\t\t\t\tND_PRINT((ndo, \"%02x\", *(option + 2 + i)));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn optlen;\ntrunc:\n\tND_PRINT((ndo, \"%s\", tstr));\n\treturn 0;\n}", "target": 2, "idx": 11560}
{"commit_id": "54d83fc74aa9ec72794373cb47432c5f7fb1a309", "project": "torvalds/linux", "func": "static bool check_underflow(const struct arpt_entry *e)\n{\n\tconst struct xt_entry_target *t;\n\tunsigned int verdict;\n\n\tif (!unconditional(e))\n\t\treturn false;\n\tt = arpt_get_target_c(e);\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\n\t\treturn false;\n\tverdict = ((struct xt_standard_target *)t)->verdict;\n\tverdict = -verdict - 1;\n\treturn verdict == NF_DROP || verdict == NF_ACCEPT;\n}", "target": 2, "idx": 11561}
{"commit_id": "c6655a0b620a3e31f085cc906f8073fe81b2fad3", "project": "gost-engine/engine", "func": "static int pkey_gost2018_encrypt(EVP_PKEY_CTX *pctx, unsigned char *out,\n                          size_t *out_len, const unsigned char *key,\n                          size_t key_len)\n{\n    PSKeyTransport_gost *pst = NULL;\n    EVP_PKEY *pubk = EVP_PKEY_CTX_get0_pkey(pctx);\n    struct gost_pmeth_data *data = EVP_PKEY_CTX_get_data(pctx);\n    int pkey_nid = EVP_PKEY_base_id(pubk);\n    unsigned char expkeys[64];\n    EVP_PKEY *sec_key = NULL;\n    int ret = 0;\n    int mac_nid = NID_undef;\n    size_t mac_len = 0;\n    int exp_len = 0, iv_len = 0;\n    unsigned char *exp_buf = NULL;\n    int key_is_ephemeral = 0;\n    int res_len = 0;\n\n    switch (data->cipher_nid) {\n    case NID_magma_ctr:\n        mac_nid = NID_magma_mac;\n        mac_len = 8;\n        iv_len = 4;\n        break;\n    case NID_grasshopper_ctr:\n        mac_nid = NID_grasshopper_mac;\n        mac_len = 16;\n        iv_len = 8;\n        break;\n    default:\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, GOST_R_INVALID_CIPHER);\n        return -1;\n        break;\n    }\n    exp_len = key_len + mac_len;\n    exp_buf = OPENSSL_malloc(exp_len);\n    if (!exp_buf) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE);\n        return -1;\n    }\n\n    sec_key = EVP_PKEY_CTX_get0_peerkey(pctx);\n    if (!sec_key)\n    {\n      sec_key = EVP_PKEY_new();\n      if (sec_key == NULL) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE );\n        goto err;\n      }\n\n      if (!EVP_PKEY_assign(sec_key, EVP_PKEY_base_id(pubk), EC_KEY_new())\n          || !EVP_PKEY_copy_parameters(sec_key, pubk)\n          || !gost_ec_keygen(EVP_PKEY_get0(sec_key))) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT,\n            GOST_R_ERROR_COMPUTING_SHARED_KEY);\n        goto err;\n      }\n      key_is_ephemeral = 1;\n    }\n\n    if (data->shared_ukm_size == 0) {\n        if (RAND_bytes(data->shared_ukm, 32) <= 0) {\n            GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n        data->shared_ukm_size = 32;\n    }\n\n    if (gost_keg(data->shared_ukm, pkey_nid,\n                 EC_KEY_get0_public_key(EVP_PKEY_get0(pubk)),\n                 EVP_PKEY_get0(sec_key), expkeys) <= 0) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT,\n                GOST_R_ERROR_COMPUTING_EXPORT_KEYS);\n        goto err;\n    }\n\n    if (gost_kexp15(key, key_len, data->cipher_nid, expkeys + 32,\n                    mac_nid, expkeys + 0, data->shared_ukm + 24, iv_len,\n                    exp_buf, &exp_len) <= 0) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, GOST_R_CANNOT_PACK_EPHEMERAL_KEY);\n        goto err;\n    }\n\n    pst = PSKeyTransport_gost_new();\n    if (!pst) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    pst->ukm = ASN1_OCTET_STRING_new();\n    if (pst->ukm == NULL) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    if (!ASN1_OCTET_STRING_set(pst->ukm, data->shared_ukm, data->shared_ukm_size)) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    if (!ASN1_OCTET_STRING_set(pst->psexp, exp_buf, exp_len)) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    if (!X509_PUBKEY_set(&pst->ephem_key, out ? sec_key : pubk)) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, GOST_R_CANNOT_PACK_EPHEMERAL_KEY);\n        goto err;\n    }\n\n    res_len = i2d_PSKeyTransport_gost(pst, NULL);\n    if (res_len <= 0) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_ASN1_LIB);\n        goto err;\n    }\n\n    if (out == NULL) {\n        *out_len = res_len;\n        ret = 1;\n    } else {\n        if ((size_t)res_len > *out_len) {\n            GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, GOST_R_INVALID_BUFFER_SIZE);\n            goto err;\n        }\n        if ((*out_len = i2d_PSKeyTransport_gost(pst, &out)) > 0)\n            ret = 1;\n        else\n            GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_ASN1_LIB);\n    }\n\n err:\n    OPENSSL_cleanse(expkeys, sizeof(expkeys));\n    if (key_is_ephemeral)\n        EVP_PKEY_free(sec_key);\n\n    PSKeyTransport_gost_free(pst);\n    OPENSSL_free(exp_buf);\n    return ret;\n}", "target": 1, "idx": 11562}
{"commit_id": "cbda3c6b2dbbd3fbdc482ff8c0170a78ec2e97d0", "project": "tensorflow", "func": "TfLiteStatus EvalHybridPerChannel(TfLiteContext* context, TfLiteNode* node,\n                                  TfLiteDepthwiseConvParams* params,\n                                  OpData* data, const TfLiteTensor* input,\n                                  const TfLiteTensor* filter,\n                                  const TfLiteTensor* bias,\n                                  TfLiteTensor* output) {\n  float output_activation_min, output_activation_max;\n  CalculateActivationRange(params->activation, &output_activation_min,\n                           &output_activation_max);\n  const int batch_size = SizeOfDimension(input, 0);\n  TF_LITE_ENSURE(context, batch_size != 0);\n  const int input_size = NumElements(input) / batch_size;\n  TfLiteTensor* input_quantized;\n  TF_LITE_ENSURE_OK(context,\n                    GetTemporarySafe(context, node, data->input_quantized_index,\n                                     &input_quantized));\n  int8_t* quantized_input_ptr_batch = input_quantized->data.int8;\n  TfLiteTensor* scaling_factors_tensor;\n  TF_LITE_ENSURE_OK(context,\n                    GetTemporarySafe(context, node, data->scaling_factors_index,\n                                     &scaling_factors_tensor));\n  float* scaling_factors_ptr = GetTensorData<float>(scaling_factors_tensor);\n  TfLiteTensor* input_offset_tensor;\n  TF_LITE_ENSURE_OK(context,\n                    GetTemporarySafe(context, node, data->input_offset_index,\n                                     &input_offset_tensor));\n  int32_t* input_offset_ptr = GetTensorData<int32_t>(input_offset_tensor);\n\n  for (int b = 0; b < batch_size; ++b) {\n    const int offset = b * input_size;\n    tensor_utils::AsymmetricQuantizeFloats(\n        GetTensorData<float>(input) + offset, input_size,\n        quantized_input_ptr_batch + offset, &scaling_factors_ptr[b],\n        &input_offset_ptr[b]);\n  }\n\n  DepthwiseParams op_params;\n  op_params.padding_type = PaddingType::kSame;\n  op_params.padding_values.width = data->padding.width;\n  op_params.padding_values.height = data->padding.height;\n  op_params.stride_width = params->stride_width;\n  op_params.stride_height = params->stride_height;\n  op_params.dilation_width_factor = params->dilation_width_factor;\n  op_params.dilation_height_factor = params->dilation_height_factor;\n  op_params.depth_multiplier = params->depth_multiplier;\n\n  op_params.weights_offset = 0;\n  op_params.float_activation_min = output_activation_min;\n  op_params.float_activation_max = output_activation_max;\n  const auto* affine_quantization =\n      reinterpret_cast<TfLiteAffineQuantization*>(filter->quantization.params);\n  if (kernel_type == kReference) {\n    reference_integer_ops::DepthwiseConvHybridPerChannel(\n        op_params, scaling_factors_ptr, GetTensorShape(input),\n        quantized_input_ptr_batch, GetTensorShape(filter),\n        GetTensorData<int8>(filter), GetTensorShape(bias),\n        GetTensorData<float>(bias), GetTensorShape(output),\n        GetTensorData<float>(output), affine_quantization->scale->data,\n        input_offset_ptr);\n  } else {\n    optimized_integer_ops::DepthwiseConvHybridPerChannel(\n        op_params, scaling_factors_ptr, GetTensorShape(input),\n        quantized_input_ptr_batch, GetTensorShape(filter),\n        GetTensorData<int8>(filter), GetTensorShape(bias),\n        GetTensorData<float>(bias), GetTensorShape(output),\n        GetTensorData<float>(output), affine_quantization->scale->data,\n        input_offset_ptr, CpuBackendContext::GetFromContext(context));\n  }\n\n  return kTfLiteOk;\n}", "target": 0, "idx": 11563}
{"commit_id": "da5c0f119203ad9728920456a0f52a6d850c01cd", "project": "torvalds/linux", "func": "int nfc_dev_down(struct nfc_dev *dev)\n{\n\tint rc = 0;\n\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\n\tdevice_lock(&dev->dev);\n\n\tif (dev->shutting_down) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (!dev->dev_up) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\n\tif (dev->polling || dev->active_target) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\n\tif (dev->ops->dev_down)\n\t\tdev->ops->dev_down(dev);\n\n\tdev->dev_up = false;\n\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1, "idx": 11564}
{"commit_id": "e310c4f91d229a072507f80c73811489b4cdff27", "project": "cloudendpoints/esp", "func": "void CheckServiceControl(std::shared_ptr<context::RequestContext> context,\n                         std::function<void(Status status)> continuation) {\n  std::shared_ptr<cloud_trace::CloudTraceSpan> trace_span(\n      CreateSpan(context->cloud_trace(), \"CheckServiceControl\"));\n  // If the method is not configured from the service config.\n  // or if not need to check service control, skip it.\n  if (!context->method()) {\n    if (context->GetRequestHTTPMethodWithOverride() == \"OPTIONS\") {\n      TRACE(trace_span) << \"OPTIONS request is rejected\";\n      continuation(Status(Code::PERMISSION_DENIED,\n                          \"The service does not allow CORS traffic.\",\n                          Status::SERVICE_CONTROL));\n    } else {\n      TRACE(trace_span) << \"Method is not configured in the service config\";\n      continuation(Status(Code::NOT_FOUND, \"Method does not exist.\",\n                          Status::SERVICE_CONTROL));\n    }\n    return;\n  } else if (!context->service_context()->service_control() ||\n             context->method()->skip_service_control()) {\n    TRACE(trace_span) << \"Service control check is not needed\";\n    continuation(Status::OK);\n    return;\n  }\n\n  if (context->api_key().empty()) {\n    if (context->method()->allow_unregistered_calls()) {\n      // Not need to call Check.\n      TRACE(trace_span) << \"Service control check is not needed\";\n      continuation(Status::OK);\n      return;\n    }\n\n    TRACE(trace_span) << \"Failed at checking caller identity.\";\n    continuation(\n        Status(Code::UNAUTHENTICATED,\n               \"Method doesn't allow unregistered callers (callers without \"\n               \"established identity). Please use API Key or other form of \"\n               \"API consumer identity to call this API.\",\n               Status::SERVICE_CONTROL));\n    return;\n  }\n\n  service_control::CheckRequestInfo info;\n  context->FillCheckRequestInfo(&info);\n  context->service_context()->service_control()->Check(\n      info, trace_span.get(),\n      [context, continuation, trace_span](\n          Status status, const service_control::CheckResponseInfo &info) {\n        TRACE(trace_span) << \"Check service control request returned with \"\n                          << \"status \" << status.ToString();\n        // info is valid regardless status.\n        context->set_check_response_info(info);\n\n        // update consumer_project_id to service context\n        if (!info.consumer_project_id.empty()) {\n          context->request()->AddHeaderToBackend(\n              kConsumerProjecId, info.consumer_project_id, false);\n        }\n\n        continuation(status);\n      });\n}", "target": 1, "idx": 11565}
{"commit_id": "c9b92530a723ac5ef8e352885a1862b18f31b2f5", "project": "torvalds/linux", "func": "int ext4_orphan_del(handle_t *handle, struct inode *inode)\n{\n\tstruct list_head *prev;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi;\n\t__u32 ino_next;\n\tstruct ext4_iloc iloc;\n\tint err = 0;\n\n\tif (!EXT4_SB(inode->i_sb)->s_journal)\n\t\treturn 0;\n\n\tmutex_lock(&EXT4_SB(inode->i_sb)->s_orphan_lock);\n\tif (list_empty(&ei->i_orphan))\n\t\tgoto out;\n\n\tino_next = NEXT_ORPHAN(inode);\n\tprev = ei->i_orphan.prev;\n\tsbi = EXT4_SB(inode->i_sb);\n\n\tjbd_debug(4, \"remove inode %lu from orphan list\\n\", inode->i_ino);\n\n\tlist_del_init(&ei->i_orphan);\n\n\t/* If we're on an error path, we may not have a valid\n\t * transaction handle with which to update the orphan list on\n\t * disk, but we still need to remove the inode from the linked\n\t * list in memory. */\n\tif (!handle)\n\t\tgoto out;\n\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out_err;\n\n\tif (prev == &sbi->s_orphan) {\n\t\tjbd_debug(4, \"superblock will point to %u\\n\", ino_next);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\t\tif (err)\n\t\t\tgoto out_brelse;\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(ino_next);\n\t\terr = ext4_handle_dirty_super(handle, inode->i_sb);\n\t} else {\n\t\tstruct ext4_iloc iloc2;\n\t\tstruct inode *i_prev =\n\t\t\t&list_entry(prev, struct ext4_inode_info, i_orphan)->vfs_inode;\n\n\t\tjbd_debug(4, \"orphan inode %lu will point to %u\\n\",\n\t\t\t  i_prev->i_ino, ino_next);\n\t\terr = ext4_reserve_inode_write(handle, i_prev, &iloc2);\n\t\tif (err)\n\t\t\tgoto out_brelse;\n\t\tNEXT_ORPHAN(i_prev) = ino_next;\n\t\terr = ext4_mark_iloc_dirty(handle, i_prev, &iloc2);\n\t}\n\tif (err)\n\t\tgoto out_brelse;\n\tNEXT_ORPHAN(inode) = 0;\n\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\nout_err:\n\text4_std_error(inode->i_sb, err);\nout:\n\tmutex_unlock(&EXT4_SB(inode->i_sb)->s_orphan_lock);\n\treturn err;\n\nout_brelse:\n\tbrelse(iloc.bh);\n\tgoto out_err;\n}", "target": 1, "idx": 11566}
{"commit_id": "a15378861368a4267c2c2c73b90db2849f943ebd", "project": "redis/hiredis", "func": "static int redisLibeventAttach(redisAsyncContext *ac, struct event_base *base) {\n    redisContext *c = &(ac->c);\n    redisLibeventEvents *e;\n\n    /* Nothing should be attached when something is already attached */\n    if (ac->ev.data != NULL)\n        return REDIS_ERR;\n\n    /* Create container for context and r/w events */\n    e = (redisLibeventEvents*)hi_calloc(1, sizeof(*e));\n    e->context = ac;\n\n    /* Register functions to start/stop listening for events */\n    ac->ev.addRead = redisLibeventAddRead;\n    ac->ev.delRead = redisLibeventDelRead;\n    ac->ev.addWrite = redisLibeventAddWrite;\n    ac->ev.delWrite = redisLibeventDelWrite;\n    ac->ev.cleanup = redisLibeventCleanup;\n    ac->ev.data = e;\n\n    /* Initialize and install read/write events */\n    e->rev = event_new(base, c->fd, EV_READ, redisLibeventReadEvent, e);\n    e->wev = event_new(base, c->fd, EV_WRITE, redisLibeventWriteEvent, e);\n    event_add(e->rev, NULL);\n    event_add(e->wev, NULL);\n    return REDIS_OK;\n}", "target": 2, "idx": 11567}
{"commit_id": "c3a3a0c424322009fec3ab735fb20ce8f6e19e70", "project": "openthread", "func": "otError Commissioner::AddJoiner(const Mac::ExtAddress *aEui64, const char *aPskd, uint32_t aTimeout)\n{\n    otError error = OT_ERROR_NO_BUFS;\n\n    VerifyOrExit(mState == OT_COMMISSIONER_STATE_ACTIVE, error = OT_ERROR_INVALID_STATE);\n\n    VerifyOrExit(strnlen(aPskd, Dtls::kPskMaxLength + 1) <= Dtls::kPskMaxLength, error = OT_ERROR_INVALID_ARGS);\n\n    RemoveJoiner(aEui64, 0); // remove immediately\n\n    for (Joiner *joiner = &mJoiners[0]; joiner < OT_ARRAY_END(mJoiners); joiner++)\n    {\n        if (joiner->mValid)\n        {\n            continue;\n        }\n\n        if (aEui64 != NULL)\n        {\n            joiner->mEui64 = *aEui64;\n            joiner->mAny   = false;\n        }\n        else\n        {\n            joiner->mAny = true;\n        }\n\n        (void)strlcpy(joiner->mPsk, aPskd, sizeof(joiner->mPsk));\n        joiner->mValid          = true;\n        joiner->mExpirationTime = TimerMilli::GetNow() + Time::SecToMsec(aTimeout);\n\n        UpdateJoinerExpirationTimer();\n\n        SendCommissionerSet();\n\n        otLogInfoMeshCoP(\"Added Joiner (%s, %s)\", (aEui64 != NULL) ? aEui64->ToString().AsCString() : \"*\", aPskd);\n\n        ExitNow(error = OT_ERROR_NONE);\n    }\n\nexit:\n    return error;\n}", "target": 3, "idx": 11568}
{"commit_id": "879f7080d7e141f415c79eaa3a8ac4a3dad0348b", "project": "openssl", "func": "static int tree_add_unmatched(X509_POLICY_LEVEL *curr,\n                              const X509_POLICY_CACHE *cache,\n                              const ASN1_OBJECT *id,\n                              X509_POLICY_NODE *node, X509_POLICY_TREE *tree)\n{\n    X509_POLICY_DATA *data;\n\n    if (id == NULL)\n        id = node->data->valid_policy;\n    /*\n     * Create a new node with qualifiers from anyPolicy and id from unmatched\n     * node.\n     */\n    if ((data = policy_data_new(NULL, id, node_critical(node))) == NULL)\n        return 0;\n\n    /* Curr may not have anyPolicy */\n    data->qualifier_set = cache->anyPolicy->qualifier_set;\n    data->flags |= POLICY_DATA_FLAG_SHARED_QUALIFIERS;\n    if (level_add_node(curr, data, node, tree, 1) == NULL) {\n        policy_data_free(data);\n        return 0;\n    }\n    return 1;\n}", "target": 2, "idx": 11569}
{"commit_id": "2896c93811e39d63a4d9b63ccf12a8fbc226e5e4", "project": "torvalds/linux", "func": "static int target_xcopy_parse_target_descriptors(struct se_cmd *se_cmd,\n\t\t\t\tstruct xcopy_op *xop, unsigned char *p,\n\t\t\t\tunsigned short tdll, sense_reason_t *sense_ret)\n{\n\tstruct se_device *local_dev = se_cmd->se_dev;\n\tunsigned char *desc = p;\n\tint offset = tdll % XCOPY_TARGET_DESC_LEN, rc;\n\tunsigned short cscd_index = 0;\n\tunsigned short start = 0;\n\n\t*sense_ret = TCM_INVALID_PARAMETER_LIST;\n\n\tif (offset != 0) {\n\t\tpr_err(\"XCOPY target descriptor list length is not\"\n\t\t\t\" multiple of %d\\n\", XCOPY_TARGET_DESC_LEN);\n\t\t*sense_ret = TCM_UNSUPPORTED_TARGET_DESC_TYPE_CODE;\n\t\treturn -EINVAL;\n\t}\n\tif (tdll > RCR_OP_MAX_TARGET_DESC_COUNT * XCOPY_TARGET_DESC_LEN) {\n\t\tpr_err(\"XCOPY target descriptor supports a maximum\"\n\t\t\t\" two src/dest descriptors, tdll: %hu too large..\\n\", tdll);\n\t\t/* spc4r37 6.4.3.4 CSCD DESCRIPTOR LIST LENGTH field */\n\t\t*sense_ret = TCM_TOO_MANY_TARGET_DESCS;\n\t\treturn -EINVAL;\n\t}\n\t/*\n\t * Generate an IEEE Registered Extended designator based upon the\n\t * se_device the XCOPY was received upon..\n\t */\n\tmemset(&xop->local_dev_wwn[0], 0, XCOPY_NAA_IEEE_REGEX_LEN);\n\ttarget_xcopy_gen_naa_ieee(local_dev, &xop->local_dev_wwn[0]);\n\n\twhile (start < tdll) {\n\t\t/*\n\t\t * Check target descriptor identification with 0xE4 type, and\n\t\t * compare the current index with the CSCD descriptor IDs in\n\t\t * the segment descriptor. Use VPD 0x83 WWPN matching ..\n\t\t */\n\t\tswitch (desc[0]) {\n\t\tcase 0xe4:\n\t\t\trc = target_xcopy_parse_tiddesc_e4(se_cmd, xop,\n\t\t\t\t\t\t\t&desc[0], cscd_index);\n\t\t\tif (rc != 0)\n\t\t\t\tgoto out;\n\t\t\tstart += XCOPY_TARGET_DESC_LEN;\n\t\t\tdesc += XCOPY_TARGET_DESC_LEN;\n\t\t\tcscd_index++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"XCOPY unsupported descriptor type code:\"\n\t\t\t\t\t\" 0x%02x\\n\", desc[0]);\n\t\t\t*sense_ret = TCM_UNSUPPORTED_TARGET_DESC_TYPE_CODE;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tswitch (xop->op_origin) {\n\tcase XCOL_SOURCE_RECV_OP:\n\t\trc = target_xcopy_locate_se_dev_e4(se_cmd->se_sess,\n\t\t\t\t\t\txop->dst_tid_wwn,\n\t\t\t\t\t\t&xop->dst_dev,\n\t\t\t\t\t\t&xop->remote_lun_ref);\n\t\tbreak;\n\tcase XCOL_DEST_RECV_OP:\n\t\trc = target_xcopy_locate_se_dev_e4(se_cmd->se_sess,\n\t\t\t\t\t\txop->src_tid_wwn,\n\t\t\t\t\t\t&xop->src_dev,\n\t\t\t\t\t\t&xop->remote_lun_ref);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"XCOPY CSCD descriptor IDs not found in CSCD list - \"\n\t\t\t\"stdi: %hu dtdi: %hu\\n\", xop->stdi, xop->dtdi);\n\t\trc = -EINVAL;\n\t\tbreak;\n\t}\n\t/*\n\t * If a matching IEEE NAA 0x83 descriptor for the requested device\n\t * is not located on this node, return COPY_ABORTED with ASQ/ASQC\n\t * 0x0d/0x02 - COPY_TARGET_DEVICE_NOT_REACHABLE to request the\n\t * initiator to fall back to normal copy method.\n\t */\n\tif (rc < 0) {\n\t\t*sense_ret = TCM_COPY_TARGET_DEVICE_NOT_REACHABLE;\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"XCOPY TGT desc: Source dev: %p NAA IEEE WWN: 0x%16phN\\n\",\n\t\t xop->src_dev, &xop->src_tid_wwn[0]);\n\tpr_debug(\"XCOPY TGT desc: Dest dev: %p NAA IEEE WWN: 0x%16phN\\n\",\n\t\t xop->dst_dev, &xop->dst_tid_wwn[0]);\n\n\treturn cscd_index;\n\nout:\n\treturn -EINVAL;\n}", "target": 2, "idx": 11570}
{"commit_id": "e21a05a00855b3e647302f06683aca743ae08deb", "project": "kohler/gifsicle", "func": "int\nClp_SetOptions(Clp_Parser *clp, int nopt, const Clp_Option *opt)\n{\n    Clp_Internal *cli = clp->internal;\n    Clp_InternOption *iopt;\n    int i;\n    static unsigned opt_generation = 0;\n\n    if (nopt > cli->nopt) {\n        iopt = (Clp_InternOption *)malloc(sizeof(Clp_InternOption) * nopt);\n        if (!iopt)\n            return -1;\n        free(cli->iopt);\n        cli->iopt = iopt;\n    }\n\n    cli->opt = opt;\n    cli->nopt = nopt;\n    cli->opt_generation = ++opt_generation;\n    iopt = cli->iopt;\n    cli->current_option = -1;\n\n    /* Massage the options to make them usable */\n    for (i = 0; i < nopt; ++i) {\n        memset(&iopt[i], 0, sizeof(iopt[i]));\n\n        /* Ignore negative option_ids, which are internal to CLP */\n        if (opt[i].option_id < 0) {\n            Clp_OptionError(clp, \"CLP internal error: option %d has negative option_id\", i);\n            iopt[i].ilong = iopt[i].ishort = iopt[i].ipos = iopt[i].ineg = iopt[i].unquoted = 0;\n            continue;\n        }\n\n        /* Set flags based on input flags */\n        iopt[i].ilong = (opt[i].long_name != 0 && opt[i].long_name[0] != 0);\n        iopt[i].ishort = (opt[i].short_name > 0\n                          && opt[i].short_name < (cli->utf8 ? 0x110000 : 256));\n        iopt[i].ipos = 1;\n        iopt[i].ineg = (opt[i].flags & Clp_Negate) != 0;\n        iopt[i].imandatory = (opt[i].flags & Clp_Mandatory) != 0;\n        iopt[i].ioptional = (opt[i].flags & Clp_Optional) != 0;\n        iopt[i].iprefmatch = (opt[i].flags & Clp_PreferredMatch) != 0;\n        iopt[i].unquoted = 0;\n        iopt[i].ilongoff = 0;\n\n        /* Enforce invariants */\n        if (opt[i].val_type <= 0)\n            iopt[i].imandatory = iopt[i].ioptional = 0;\n        if (opt[i].val_type > 0 && !iopt[i].ioptional)\n            iopt[i].imandatory = 1;\n\n        /* Options that start with 'no-' should be changed to OnlyNegated */\n        if (iopt[i].ilong && strncmp(opt[i].long_name, \"no-\", 3) == 0) {\n            iopt[i].ipos = 0;\n            iopt[i].ineg = 1;\n            iopt[i].ilongoff = 3;\n            if (strncmp(opt[i].long_name + 3, \"no-\", 3) == 0)\n                Clp_OptionError(clp, \"CLP internal error: option %d begins with \\\"no-no-\\\"\", i);\n        } else if (opt[i].flags & Clp_OnlyNegated) {\n            iopt[i].ipos = 0;\n            iopt[i].ineg = 1;\n        }\n    }\n\n    /* Check option set */\n    calculate_lmm(clp, opt, iopt, nopt);\n\n    return 0;\n}", "target": 2, "idx": 11571}
{"commit_id": "d3e09bf4654fe5478b6dbf2b26ebab6271317d81", "project": "harfbuzz", "func": "void\nhb_map_clear (hb_map_t *map)\n{\n  return map->clear ();\n}", "target": 1, "idx": 11572}
{"commit_id": "2919516136a4227d9e6d8f2fe66ef976aaf8c561", "project": "openssl", "func": "char *X509_NAME_oneline(X509_NAME *a, char *buf, int len)\n{\n    X509_NAME_ENTRY *ne;\n    int i;\n    int n, lold, l, l1, l2, num, j, type;\n    const char *s;\n    char *p;\n    unsigned char *q;\n    BUF_MEM *b = NULL;\n    static const char hex[17] = \"0123456789ABCDEF\";\n    int gs_doit[4];\n    char tmp_buf[80];\n#ifdef CHARSET_EBCDIC\n    char ebcdic_buf[1024];\n#endif\n\n    if (buf == NULL) {\n        if ((b = BUF_MEM_new()) == NULL)\n            goto err;\n        if (!BUF_MEM_grow(b, 200))\n            goto err;\n        b->data[0] = '\\0';\n        len = 200;\n    } else if (len == 0) {\n        return NULL;\n    }\n    if (a == NULL) {\n        if (b) {\n            buf = b->data;\n            OPENSSL_free(b);\n        }\n        strncpy(buf, \"NO X509_NAME\", len);\n        buf[len - 1] = '\\0';\n        return buf;\n    }\n\n    len--;                      /* space for '\\0' */\n    l = 0;\n    for (i = 0; i < sk_X509_NAME_ENTRY_num(a->entries); i++) {\n        ne = sk_X509_NAME_ENTRY_value(a->entries, i);\n        n = OBJ_obj2nid(ne->object);\n        if ((n == NID_undef) || ((s = OBJ_nid2sn(n)) == NULL)) {\n            i2t_ASN1_OBJECT(tmp_buf, sizeof(tmp_buf), ne->object);\n            s = tmp_buf;\n        }\n        l1 = strlen(s);\n\n        type = ne->value->type;\n        num = ne->value->length;\n        if (num > NAME_ONELINE_MAX) {\n            X509err(X509_F_X509_NAME_ONELINE, X509_R_NAME_TOO_LONG);\n            goto end;\n        }\n        q = ne->value->data;\n#ifdef CHARSET_EBCDIC\n        if (type == V_ASN1_GENERALSTRING ||\n            type == V_ASN1_VISIBLESTRING ||\n            type == V_ASN1_PRINTABLESTRING ||\n            type == V_ASN1_TELETEXSTRING ||\n            type == V_ASN1_VISIBLESTRING || type == V_ASN1_IA5STRING) {\n            if (num > (int)sizeof(ebcdic_buf))\n                num = sizeof(ebcdic_buf);\n            ascii2ebcdic(ebcdic_buf, q, num);\n            q = ebcdic_buf;\n        }\n#endif\n\n        if ((type == V_ASN1_GENERALSTRING) && ((num % 4) == 0)) {\n            gs_doit[0] = gs_doit[1] = gs_doit[2] = gs_doit[3] = 0;\n            for (j = 0; j < num; j++)\n                if (q[j] != 0)\n                    gs_doit[j & 3] = 1;\n\n            if (gs_doit[0] | gs_doit[1] | gs_doit[2])\n                gs_doit[0] = gs_doit[1] = gs_doit[2] = gs_doit[3] = 1;\n            else {\n                gs_doit[0] = gs_doit[1] = gs_doit[2] = 0;\n                gs_doit[3] = 1;\n            }\n        } else\n            gs_doit[0] = gs_doit[1] = gs_doit[2] = gs_doit[3] = 1;\n\n        for (l2 = j = 0; j < num; j++) {\n            if (!gs_doit[j & 3])\n                continue;\n            l2++;\n#ifndef CHARSET_EBCDIC\n            if ((q[j] < ' ') || (q[j] > '~'))\n                l2 += 3;\n#else\n            if ((os_toascii[q[j]] < os_toascii[' ']) ||\n                (os_toascii[q[j]] > os_toascii['~']))\n                l2 += 3;\n#endif\n        }\n\n        lold = l;\n        l += 1 + l1 + 1 + l2;\n        if (l > NAME_ONELINE_MAX) {\n            X509err(X509_F_X509_NAME_ONELINE, X509_R_NAME_TOO_LONG);\n            goto end;\n        }\n        if (b != NULL) {\n            if (!BUF_MEM_grow(b, l + 1))\n                goto err;\n            p = &(b->data[lold]);\n        } else if (l > len) {\n            break;\n        } else\n            p = &(buf[lold]);\n        *(p++) = '/';\n        memcpy(p, s, (unsigned int)l1);\n        p += l1;\n        *(p++) = '=';\n\n#ifndef CHARSET_EBCDIC          /* q was assigned above already. */\n        q = ne->value->data;\n#endif\n\n        for (j = 0; j < num; j++) {\n            if (!gs_doit[j & 3])\n                continue;\n#ifndef CHARSET_EBCDIC\n            n = q[j];\n            if ((n < ' ') || (n > '~')) {\n                *(p++) = '\\\\';\n                *(p++) = 'x';\n                *(p++) = hex[(n >> 4) & 0x0f];\n                *(p++) = hex[n & 0x0f];\n            } else\n                *(p++) = n;\n#else\n            n = os_toascii[q[j]];\n            if ((n < os_toascii[' ']) || (n > os_toascii['~'])) {\n                *(p++) = '\\\\';\n                *(p++) = 'x';\n                *(p++) = hex[(n >> 4) & 0x0f];\n                *(p++) = hex[n & 0x0f];\n            } else\n                *(p++) = q[j];\n#endif\n        }\n        *p = '\\0';\n    }\n    if (b != NULL) {\n        p = b->data;\n        OPENSSL_free(b);\n    } else\n        p = buf;\n    if (i == 0)\n        *p = '\\0';\n    return (p);\n err:\n    X509err(X509_F_X509_NAME_ONELINE, ERR_R_MALLOC_FAILURE);\n end:\n    BUF_MEM_free(b);\n    return (NULL);\n}", "target": 2, "idx": 11573}
{"commit_id": "6e06b1c89dd0d16f74894eac4cfc1327a06ee4a0", "project": "libarchive", "func": "static int\nchoose_filters(struct archive_read *a)\n{\n\tint number_bidders, i, bid, best_bid, n;\n\tstruct archive_read_filter_bidder *bidder, *best_bidder;\n\tstruct archive_read_filter *filter;\n\tssize_t avail;\n\tint r;\n\n\tfor (n = 0; n < 25; ++n) {\n\t\tnumber_bidders = sizeof(a->bidders) / sizeof(a->bidders[0]);\n\n\t\tbest_bid = 0;\n\t\tbest_bidder = NULL;\n\n\t\tbidder = a->bidders;\n\t\tfor (i = 0; i < number_bidders; i++, bidder++) {\n\t\t\tif (bidder->bid != NULL) {\n\t\t\t\tbid = (bidder->bid)(bidder, a->filter);\n\t\t\t\tif (bid > best_bid) {\n\t\t\t\t\tbest_bid = bid;\n\t\t\t\t\tbest_bidder = bidder;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* If no bidder, we're done. */\n\t\tif (best_bidder == NULL) {\n\t\t\t/* Verify the filter by asking it for some data. */\n\t\t\t__archive_read_filter_ahead(a->filter, 1, &avail);\n\t\t\tif (avail < 0) {\n\t\t\t\t__archive_read_close_filters(a);\n\t\t\t\t__archive_read_free_filters(a);\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\ta->archive.compression_name = a->filter->name;\n\t\t\ta->archive.compression_code = a->filter->code;\n\t\t\treturn (ARCHIVE_OK);\n\t\t}\n\n\t\tfilter\n\t\t    = (struct archive_read_filter *)calloc(1, sizeof(*filter));\n\t\tif (filter == NULL)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tfilter->bidder = best_bidder;\n\t\tfilter->archive = a;\n\t\tfilter->upstream = a->filter;\n\t\ta->filter = filter;\n\t\tr = (best_bidder->init)(a->filter);\n\t\tif (r != ARCHIVE_OK) {\n\t\t\t__archive_read_close_filters(a);\n\t\t\t__archive_read_free_filters(a);\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t}\n\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t    \"Input requires too many filters for decoding\");\n\treturn (ARCHIVE_FATAL);\n}", "target": 1, "idx": 11574}
{"commit_id": "362786f14a753d8a5256ef97d7c10ed576d6572b", "project": "qemu", "func": "void net_checksum_calculate(uint8_t *data, int length)\n{\n    int hlen, plen, proto, csum_offset;\n    uint16_t csum;\n\n    /* Ensure data has complete L2 & L3 headers. */\n    if (length < 14 + 20) {\n        return;\n    }\n\n    if ((data[14] & 0xf0) != 0x40)\n\treturn; /* not IPv4 */\n    hlen  = (data[14] & 0x0f) * 4;\n    plen  = (data[16] << 8 | data[17]) - hlen;\n    proto = data[23];\n\n    switch (proto) {\n    case PROTO_TCP:\n\tcsum_offset = 16;\n\tbreak;\n    case PROTO_UDP:\n\tcsum_offset = 6;\n\tbreak;\n    default:\n\treturn;\n    }\n\n    if (plen < csum_offset + 2 || 14 + hlen + plen > length) {\n        return;\n    }\n\n    data[14+hlen+csum_offset]   = 0;\n    data[14+hlen+csum_offset+1] = 0;\n    csum = net_checksum_tcpudp(plen, proto, data+14+12, data+14+hlen);\n    data[14+hlen+csum_offset]   = csum >> 8;\n    data[14+hlen+csum_offset+1] = csum & 0xff;\n}", "target": 2, "idx": 11575}
{"commit_id": "9be22b639ea69e102d3847dca4c53ef025e9527b", "project": "libtiff", "func": "static int LZWDecode(TIFF *tif, uint8_t *op0, tmsize_t occ0, uint16_t s)\n{\n    static const char module[] = \"LZWDecode\";\n    LZWCodecState *sp = DecoderState(tif);\n    uint8_t *op = (uint8_t *)op0;\n    tmsize_t occ = occ0;\n    uint8_t *bp;\n    long nbits, nextbits, nbitsmask;\n    WordType nextdata;\n    code_t *free_entp, *maxcodep, *oldcodep;\n\n    (void)s;\n    assert(sp != NULL);\n    assert(sp->dec_codetab != NULL);\n\n    if (sp->read_error)\n    {\n        TIFFErrorExtR(tif, module,\n                      \"LZWDecode: Scanline %\" PRIu32 \" cannot be read due to \"\n                      \"previous error\",\n                      tif->tif_row);\n        return 0;\n    }\n\n    /*\n     * Restart interrupted output operation.\n     */\n    if (sp->dec_restart)\n    {\n        tmsize_t residue;\n\n        code_t *codep = sp->dec_codep;\n        residue = codep->length - sp->dec_restart;\n        if (residue > occ)\n        {\n            /*\n             * Residue from previous decode is sufficient\n             * to satisfy decode request.  Skip to the\n             * start of the decoded string, place decoded\n             * values in the output buffer, and return.\n             */\n            sp->dec_restart += occ;\n            do\n            {\n                codep = codep->next;\n            } while (--residue > occ && codep);\n            if (codep)\n            {\n                uint8_t *tp = op + occ;\n                do\n                {\n                    *--tp = codep->value;\n                    codep = codep->next;\n                } while (--occ && codep);\n            }\n            return (1);\n        }\n        /*\n         * Residue satisfies only part of the decode request.\n         */\n        op += residue;\n        occ -= residue;\n        uint8_t *tp = op;\n        do\n        {\n            *--tp = codep->value;\n            codep = codep->next;\n        } while (--residue && codep);\n        sp->dec_restart = 0;\n    }\n\n    bp = (uint8_t *)tif->tif_rawcp;\n    sp->dec_bitsleft += (((uint64_t)tif->tif_rawcc - sp->old_tif_rawcc) << 3);\n    uint64_t dec_bitsleft = sp->dec_bitsleft;\n    nbits = sp->lzw_nbits;\n    nextdata = sp->lzw_nextdata;\n    nextbits = sp->lzw_nextbits;\n    nbitsmask = sp->dec_nbitsmask;\n    oldcodep = sp->dec_oldcodep;\n    free_entp = sp->dec_free_entp;\n    maxcodep = sp->dec_maxcodep;\n    code_t *const dec_codetab = sp->dec_codetab;\n    code_t *codep;\n\n    if (occ == 0)\n    {\n        goto after_loop;\n    }\n\nbegin:\n{\n    WordType code;\n    GetNextCodeLZW();\n    codep = dec_codetab + code;\n    if (code >= CODE_FIRST)\n        goto code_above_or_equal_to_258;\n    if (code < 256)\n        goto code_below_256;\n    if (code == CODE_EOI)\n        goto after_loop;\n    goto code_clear;\n\ncode_below_256:\n{\n    if (codep > free_entp)\n        goto error_code;\n    free_entp->next = oldcodep;\n    free_entp->firstchar = oldcodep->firstchar;\n    free_entp->length = oldcodep->length + 1;\n    free_entp->value = (uint8_t)code;\n    free_entp->repeated =\n        (bool)(oldcodep->repeated & (oldcodep->value == code));\n    if (++free_entp > maxcodep)\n    {\n        if (++nbits > BITS_MAX) /* should not happen for a conformant encoder */\n            nbits = BITS_MAX;\n        nbitsmask = MAXCODE(nbits);\n        maxcodep = dec_codetab + nbitsmask - 1;\n        if (free_entp >= &dec_codetab[CSIZE])\n        {\n            /* At that point, the next valid states are either EOI or a */\n            /* CODE_CLEAR. If a regular code is read, at the next */\n            /* attempt at registering a new entry, we will error out */\n            /* due to setting free_entp before any valid code */\n            free_entp = dec_codetab - 1;\n        }\n    }\n    oldcodep = codep;\n    *op++ = (uint8_t)code;\n    occ--;\n    if (occ == 0)\n        goto after_loop;\n    goto begin;\n}\n\ncode_above_or_equal_to_258:\n{\n    /*\n     * Add the new entry to the code table.\n     */\n\n    if (codep >= free_entp)\n    {\n        if (codep != free_entp)\n            goto error_code;\n        free_entp->value = oldcodep->firstchar;\n    }\n    else\n    {\n        free_entp->value = codep->firstchar;\n    }\n    free_entp->repeated =\n        (bool)(oldcodep->repeated & (oldcodep->value == free_entp->value));\n    free_entp->next = oldcodep;\n\n    free_entp->firstchar = oldcodep->firstchar;\n    free_entp->length = oldcodep->length + 1;\n    if (++free_entp > maxcodep)\n    {\n        if (++nbits > BITS_MAX) /* should not happen for a conformant encoder */\n            nbits = BITS_MAX;\n        nbitsmask = MAXCODE(nbits);\n        maxcodep = dec_codetab + nbitsmask - 1;\n        if (free_entp >= &dec_codetab[CSIZE])\n        {\n            /* At that point, the next valid states are either EOI or a */\n            /* CODE_CLEAR. If a regular code is read, at the next */\n            /* attempt at registering a new entry, we will error out */\n            /* due to setting free_entp before any valid code */\n            free_entp = dec_codetab - 1;\n        }\n    }\n    oldcodep = codep;\n\n    /*\n     * Code maps to a string, copy string\n     * value to output (written in reverse).\n     */\n    /* tiny bit faster on x86_64 to store in unsigned short than int */\n    unsigned short len = codep->length;\n\n    if (len < 3) /* equivalent to len == 2 given all other conditions */\n    {\n        if (occ <= 2)\n        {\n            if (occ == 2)\n            {\n                memcpy(op, &(codep->firstchar), 2);\n                op += 2;\n                occ -= 2;\n                goto after_loop;\n            }\n            goto too_short_buffer;\n        }\n\n        memcpy(op, &(codep->firstchar), 2);\n        op += 2;\n        occ -= 2;\n        goto begin; /* we can save the comparison occ > 0 */\n    }\n\n    if (len == 3)\n    {\n        if (occ <= 3)\n        {\n            if (occ == 3)\n            {\n                op[0] = codep->firstchar;\n                op[1] = codep->next->value;\n                op[2] = codep->value;\n                op += 3;\n                occ -= 3;\n                goto after_loop;\n            }\n            goto too_short_buffer;\n        }\n\n        op[0] = codep->firstchar;\n        op[1] = codep->next->value;\n        op[2] = codep->value;\n        op += 3;\n        occ -= 3;\n        goto begin; /* we can save the comparison occ > 0 */\n    }\n\n    if (len > occ)\n    {\n        goto too_short_buffer;\n    }\n\n    if (codep->repeated)\n    {\n        memset(op, codep->value, len);\n        op += len;\n        occ -= len;\n        if (occ == 0)\n            goto after_loop;\n        goto begin;\n    }\n\n    uint8_t *tp = op + len;\n\n    assert(len >= 4);\n\n    *--tp = codep->value;\n    codep = codep->next;\n    *--tp = codep->value;\n    codep = codep->next;\n    *--tp = codep->value;\n    codep = codep->next;\n    *--tp = codep->value;\n    if (tp > op)\n    {\n        do\n        {\n            codep = codep->next;\n            *--tp = codep->value;\n        } while (tp > op);\n    }\n\n    assert(occ >= len);\n    op += len;\n    occ -= len;\n    if (occ == 0)\n        goto after_loop;\n    goto begin;\n}\n\ncode_clear:\n{\n    free_entp = dec_codetab + CODE_FIRST;\n    nbits = BITS_MIN;\n    nbitsmask = MAXCODE(BITS_MIN);\n    maxcodep = dec_codetab + nbitsmask - 1;\n    do\n    {\n        GetNextCodeLZW();\n    } while (code == CODE_CLEAR); /* consecutive CODE_CLEAR codes */\n    if (code == CODE_EOI)\n        goto after_loop;\n    if (code > CODE_EOI)\n    {\n        goto error_code;\n    }\n    *op++ = (uint8_t)code;\n    occ--;\n    oldcodep = dec_codetab + code;\n    if (occ == 0)\n        goto after_loop;\n    goto begin;\n}\n}\n\ntoo_short_buffer:\n{\n    /*\n     * String is too long for decode buffer,\n     * locate portion that will fit, copy to\n     * the decode buffer, and setup restart\n     * logic for the next decoding call.\n     */\n    sp->dec_codep = codep;\n    do\n    {\n        codep = codep->next;\n    } while (codep->length > occ);\n\n    sp->dec_restart = occ;\n    uint8_t *tp = op + occ;\n    do\n    {\n        *--tp = codep->value;\n        codep = codep->next;\n    } while (--occ);\n}\n\nafter_loop:\n    tif->tif_rawcc -= (tmsize_t)((uint8_t *)bp - tif->tif_rawcp);\n    tif->tif_rawcp = (uint8_t *)bp;\n    sp->old_tif_rawcc = tif->tif_rawcc;\n    sp->dec_bitsleft = dec_bitsleft;\n    sp->lzw_nbits = (unsigned short)nbits;\n    sp->lzw_nextdata = nextdata;\n    sp->lzw_nextbits = nextbits;\n    sp->dec_nbitsmask = nbitsmask;\n    sp->dec_oldcodep = oldcodep;\n    sp->dec_free_entp = free_entp;\n    sp->dec_maxcodep = maxcodep;\n\n    if (occ > 0)\n    {\n        TIFFErrorExtR(tif, module,\n                      \"Not enough data at scanline %\" PRIu32 \" (short %\" PRIu64\n                      \" bytes)\",\n                      tif->tif_row, (uint64_t)occ);\n        return (0);\n    }\n    return (1);\n\nno_eoi:\n    sp->read_error = 1;\n    TIFFErrorExtR(tif, module,\n                  \"LZWDecode: Strip %\" PRIu32 \" not terminated with EOI code\",\n                  tif->tif_curstrip);\n    return 0;\nerror_code:\n    sp->read_error = 1;\n    TIFFErrorExtR(tif, tif->tif_name, \"Using code not yet in table\");\n    return 0;\n}", "target": 1, "idx": 11576}
{"commit_id": "bda9772e7872b0d2b9bee32930cf7a4983837b39", "project": "google/asylo", "func": "bool FromkLinuxSockAddr(const struct klinux_sockaddr *input,\n                        socklen_t input_len, struct sockaddr *output,\n                        socklen_t *output_len,\n                        void (*abort_handler)(const char *)) {\n  if (!input || !output || !output_len || input_len == 0) {\n    output = nullptr;\n    return false;\n  }\n\n  int16_t klinux_family = input->klinux_sa_family;\n  if (klinux_family == kLinux_AF_UNIX) {\n    if (input_len < sizeof(struct klinux_sockaddr_un)) {\n      return false;\n    }\n\n    struct klinux_sockaddr_un *klinux_sockaddr_un_in =\n        const_cast<struct klinux_sockaddr_un *>(\n            reinterpret_cast<const struct klinux_sockaddr_un *>(input));\n\n    struct sockaddr_un sockaddr_un_out;\n    sockaddr_un_out.sun_family = AF_UNIX;\n    InitializeToZeroArray(sockaddr_un_out.sun_path);\n    ReinterpretCopyArray(\n        sockaddr_un_out.sun_path, klinux_sockaddr_un_in->klinux_sun_path,\n        std::min(sizeof(sockaddr_un_out.sun_path),\n                 sizeof(klinux_sockaddr_un_in->klinux_sun_path)));\n    CopySockaddr(&sockaddr_un_out, sizeof(sockaddr_un_out), output, output_len);\n  } else if (klinux_family == kLinux_AF_INET) {\n    if (input_len < sizeof(struct klinux_sockaddr_in)) {\n      return false;\n    }\n    struct klinux_sockaddr_in *klinux_sockaddr_in_in =\n        const_cast<struct klinux_sockaddr_in *>(\n            reinterpret_cast<const struct klinux_sockaddr_in *>(input));\n\n    struct sockaddr_in sockaddr_in_out;\n    sockaddr_in_out.sin_family = AF_INET;\n    sockaddr_in_out.sin_port = klinux_sockaddr_in_in->klinux_sin_port;\n    InitializeToZeroSingle(&sockaddr_in_out.sin_addr);\n    ReinterpretCopySingle(&sockaddr_in_out.sin_addr,\n                          &klinux_sockaddr_in_in->klinux_sin_addr);\n    InitializeToZeroArray(sockaddr_in_out.sin_zero);\n    ReinterpretCopyArray(sockaddr_in_out.sin_zero,\n                         klinux_sockaddr_in_in->klinux_sin_zero);\n    CopySockaddr(&sockaddr_in_out, sizeof(sockaddr_in_out), output, output_len);\n  } else if (klinux_family == kLinux_AF_INET6) {\n    if (input_len < sizeof(struct klinux_sockaddr_in6)) {\n      return false;\n    }\n\n    struct klinux_sockaddr_in6 *klinux_sockaddr_in6_in =\n        const_cast<struct klinux_sockaddr_in6 *>(\n            reinterpret_cast<const struct klinux_sockaddr_in6 *>(input));\n\n    struct sockaddr_in6 sockaddr_in6_out;\n    sockaddr_in6_out.sin6_family = AF_INET6;\n    sockaddr_in6_out.sin6_port = klinux_sockaddr_in6_in->klinux_sin6_port;\n    sockaddr_in6_out.sin6_flowinfo =\n        klinux_sockaddr_in6_in->klinux_sin6_flowinfo;\n    sockaddr_in6_out.sin6_scope_id =\n        klinux_sockaddr_in6_in->klinux_sin6_scope_id;\n    InitializeToZeroSingle(&sockaddr_in6_out.sin6_addr);\n    ReinterpretCopySingle(&sockaddr_in6_out.sin6_addr,\n                          &klinux_sockaddr_in6_in->klinux_sin6_addr);\n    CopySockaddr(&sockaddr_in6_out, sizeof(sockaddr_in6_out), output,\n                 output_len);\n  } else if (klinux_family == kLinux_AF_UNSPEC) {\n    output = nullptr;\n    *output_len = 0;\n  } else {\n    if (abort_handler != nullptr) {\n      std::string message = absl::StrCat(\n          \"Type conversion error - Unsupported AF family: \", klinux_family);\n      abort_handler(message.c_str());\n    } else {\n      abort();\n    }\n  }\n  return true;\n}", "target": 0, "idx": 11577}
{"commit_id": "97574866cbab026acb1bbd735201f790091b9400", "project": "libtiff", "func": "void\n_TIFFSetupFields(TIFF* tif, const TIFFFieldArray* fieldarray)\n{\n\tif (tif->tif_fields && tif->tif_nfields > 0) {\n\t\tuint32_t i;\n\n\t\tfor (i = 0; i < tif->tif_nfields; i++) {\n\t\t\tTIFFField *fld = tif->tif_fields[i];\n\t\t\tif (fld->field_name != NULL) {\n\t\t\t\tif (fld->field_bit == FIELD_CUSTOM &&\n\t\t\t\t\tTIFFFieldIsAnonymous(fld)) {\n\t\t\t\t\t_TIFFfree(fld->field_name);\n\t\t\t\t\t/* catuion: tif_fields[i] must not be the beginning of a fields-array. \n\t\t\t\t\t *          Otherwise the following tags are also freed with the first free().\n\t\t\t\t\t */\n\t\t\t\t\t_TIFFfree(fld);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t_TIFFfree(tif->tif_fields);\n\t\ttif->tif_fields = NULL;\n\t\ttif->tif_nfields = 0;\n\t}\n\tif (!_TIFFMergeFields(tif, fieldarray->fields, fieldarray->count)) {\n\t\tTIFFErrorExt(tif->tif_clientdata, \"_TIFFSetupFields\",\n\t\t\t     \"Setting up field info failed\");\n\t}\n}", "target": 1, "idx": 11578}
{"commit_id": "7c30bc38a588b22b01f11130cfe99e7f36accf94", "project": "MariaDB/server", "func": "static\ncomp_thread_ctxt_t *\ncreate_worker_threads(uint n)\n{\n\tcomp_thread_ctxt_t\t*threads;\n\tuint \t\t\ti;\n\n\tthreads = (comp_thread_ctxt_t *)\n\t\tmy_malloc(sizeof(comp_thread_ctxt_t) * n, MYF(MY_FAE));\n\n\tfor (i = 0; i < n; i++) {\n\t\tcomp_thread_ctxt_t *thd = threads + i;\n\n\t\tthd->num = i + 1;\n\t\tthd->started = FALSE;\n\t\tthd->cancelled = FALSE;\n\t\tthd->data_avail = FALSE;\n\n\t\tthd->to = (char *) my_malloc(COMPRESS_CHUNK_SIZE +\n\t\t\t\t\t\t   MY_QLZ_COMPRESS_OVERHEAD,\n\t\t\t\t\t\t   MYF(MY_FAE));\n\n\t\t/* Initialize the control mutex and condition var */\n\t\tif (pthread_mutex_init(&thd->ctrl_mutex, NULL) ||\n\t\t    pthread_cond_init(&thd->ctrl_cond, NULL)) {\n\t\t\tgoto err;\n\t\t}\n\n\t\t/* Initialize and data mutex and condition var */\n\t\tif (pthread_mutex_init(&thd->data_mutex, NULL) ||\n\t\t    pthread_cond_init(&thd->data_cond, NULL)) {\n\t\t\tgoto err;\n\t\t}\n\n\t\tpthread_mutex_lock(&thd->ctrl_mutex);\n\n\t\tif (pthread_create(&thd->id, NULL, compress_worker_thread_func,\n\t\t\t\t   thd)) {\n\t\t\tmsg(\"compress: pthread_create() failed: \"\n\t\t\t    \"errno = %d\", errno);\n\t\t\tpthread_mutex_unlock(&thd->ctrl_mutex);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\t/* Wait for the threads to start */\n\tfor (i = 0; i < n; i++) {\n\t\tcomp_thread_ctxt_t *thd = threads + i;\n\n\t\twhile (thd->started == FALSE)\n\t\t\tpthread_cond_wait(&thd->ctrl_cond, &thd->ctrl_mutex);\n\t\tpthread_mutex_unlock(&thd->ctrl_mutex);\n\t}\n\n\treturn threads;\n\nerr:\n\twhile (i > 0) {\n\t\tcomp_thread_ctxt_t *thd;\n\t\ti--;\n\t\tthd = threads + i;\n\t\tpthread_mutex_unlock(&thd->ctrl_mutex);\n\t}\n\n\tmy_free(threads);\n\treturn NULL;\n}", "target": 1, "idx": 11579}
{"commit_id": "8764fdc24c31c21dc43b2a2f99eb8c48a34e5e9c", "project": "upx", "func": "void\nPackLinuxElf32::invert_pt_dynamic(Elf32_Dyn const *dynp, unsigned dt_filesz)\n{\n    if (dt_table[Elf32_Dyn::DT_NULL]) {\n        return;  // not 1st time; do not change upx_dt_init\n    }\n    if ((file_size - (e_phnum*sizeof(Elf32_Phdr) + sizeof(Elf32_Ehdr))) < dt_filesz) {\n        char msg[50]; snprintf(msg, sizeof(msg),\n            \"bad PT_DYNAMIC.pt_filesz %#x\", dt_filesz);\n        throwCantPack(msg);\n    }\n    Elf32_Dyn const *const dynp0 = dynp;\n    unsigned ndx = 1+ 0;\n    unsigned const limit = dt_filesz / sizeof(*dynp);\n    if (dynp)\n    for (; ; ++ndx, ++dynp) {\n        if (limit <= ndx) {\n            throwCantPack(\"DT_NULL not found\");\n        }\n        unsigned const d_tag = get_te32(&dynp->d_tag);\n        if (d_tag < DT_NUM) {\n            if (Elf32_Dyn::DT_NEEDED != d_tag\n            &&  dt_table[d_tag]\n            &&    get_te32(&dynp->d_val)\n               != get_te32(&dynp0[-1+ dt_table[d_tag]].d_val)) {\n                char msg[50]; snprintf(msg, sizeof(msg),\n                    \"duplicate DT_%#x: [%#x] [%#x]\",\n                    d_tag, -1+ dt_table[d_tag], -1+ ndx);\n                throwCantPack(msg);\n            }\n            dt_table[d_tag] = ndx;\n        }\n        if (Elf32_Dyn::DT_NULL == d_tag) {\n            break;  // check here so that dt_table[DT_NULL] is set\n        }\n    }\n    upx_dt_init = 0;\n         if (dt_table[Elf32_Dyn::DT_INIT])          upx_dt_init = Elf32_Dyn::DT_INIT;\n    else if (dt_table[Elf32_Dyn::DT_PREINIT_ARRAY]) upx_dt_init = Elf32_Dyn::DT_PREINIT_ARRAY;\n    else if (dt_table[Elf32_Dyn::DT_INIT_ARRAY])    upx_dt_init = Elf32_Dyn::DT_INIT_ARRAY;\n\n    unsigned const z_str = dt_table[Elf32_Dyn::DT_STRSZ];\n    if (z_str) {\n        strtab_end = get_te32(&dynp0[-1+ z_str].d_val);\n        if ((u32_t)file_size <= strtab_end) { // FIXME: weak\n            char msg[50]; snprintf(msg, sizeof(msg),\n                \"bad DT_STRSZ %#x\", strtab_end);\n            throwCantPack(msg);\n        }\n    }\n    unsigned const x_sym = dt_table[Elf32_Dyn::DT_SYMTAB];\n    unsigned const x_str = dt_table[Elf32_Dyn::DT_STRTAB];\n    if (x_sym && x_str) {\n        upx_uint32_t const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);\n        upx_uint32_t const v_str = get_te32(&dynp0[-1+ x_str].d_val);\n        unsigned const  z_sym = dt_table[Elf32_Dyn::DT_SYMENT];\n        unsigned const sz_sym = !z_sym ? sizeof(Elf32_Sym)\n            : get_te32(&dynp0[-1+ z_sym].d_val);\n        if (sz_sym < sizeof(Elf32_Sym)) {\n            char msg[50]; snprintf(msg, sizeof(msg),\n                \"bad DT_SYMENT %x\", sz_sym);\n            throwCantPack(msg);\n        }\n        if (v_sym < v_str) {\n            symnum_end = (v_str - v_sym) / sz_sym;\n        }\n        if (symnum_end < 1) {\n            throwCantPack(\"bad DT_SYMTAB\");\n        }\n    }\n    // DT_HASH often ends at DT_SYMTAB\n    unsigned const v_hsh = elf_unsigned_dynamic(Elf32_Dyn::DT_HASH);\n    if (v_hsh && file_image) {\n        hashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_HASH);\n        if (!hashtab) {\n            char msg[40]; snprintf(msg, sizeof(msg),\n               \"bad DT_HASH %#x\", v_hsh);\n            throwCantPack(msg);\n        }\n        unsigned const nbucket = get_te32(&hashtab[0]);\n        unsigned const *const buckets = &hashtab[2];\n        unsigned const *const chains = &buckets[nbucket]; (void)chains;\n\n        unsigned const v_sym = !x_sym ? 0 : get_te32(&dynp0[-1+ x_sym].d_val);\n        if (!nbucket || (nbucket>>31) || !v_sym || file_size <= v_sym\n        || ((v_hsh < v_sym) && (v_sym - v_hsh) < sizeof(*buckets)*(2+ nbucket))\n        ) {\n            char msg[80]; snprintf(msg, sizeof(msg),\n                \"bad DT_HASH nbucket=%#x  len=%#x\",\n                nbucket, (v_sym - v_hsh));\n            throwCantPack(msg);\n        }\n        unsigned chmax = 0;\n        for (unsigned j= 0; j < nbucket; ++j) {\n            if (chmax < buckets[j]) {\n                chmax = buckets[j];\n            }\n        }\n        if ((v_hsh < v_sym) && (v_sym - v_hsh) <\n                (sizeof(*buckets)*(2+ nbucket) + sizeof(*chains)*(1+ chmax))) {\n            char msg[80]; snprintf(msg, sizeof(msg),\n                \"bad DT_HASH nbucket=%#x  len=%#x\",\n                nbucket, (v_sym - v_hsh));\n            throwCantPack(msg);\n        }\n    }\n    // DT_GNU_HASH often ends at DT_SYMTAB;  FIXME: not for Android?\n    unsigned const v_gsh = elf_unsigned_dynamic(Elf32_Dyn::DT_GNU_HASH);\n    if (v_gsh && file_image) {\n        gashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_GNU_HASH);\n        if (!gashtab) {\n            char msg[40]; snprintf(msg, sizeof(msg),\n               \"bad DT_GNU_HASH %#x\", v_gsh);\n            throwCantPack(msg);\n        }\n        unsigned const n_bucket = get_te32(&gashtab[0]);\n        unsigned const symbias  = get_te32(&gashtab[1]);\n        unsigned const n_bitmask = get_te32(&gashtab[2]);\n        unsigned const gnu_shift = get_te32(&gashtab[3]);\n        unsigned const *const bitmask = (unsigned const *)(void const *)&gashtab[4];\n        unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask];\n        unsigned     const *const hasharr = &buckets[n_bucket]; (void)hasharr;\n        if (!n_bucket || (1u<<31) <= n_bucket  /* fie on fuzzers */\n        || (void const *)&file_image[file_size] <= (void const *)hasharr) {\n            char msg[80]; snprintf(msg, sizeof(msg),\n                \"bad n_bucket %#x\\n\", n_bucket);\n            throwCantPack(msg);\n        }\n      //unsigned     const *const gashend = &hasharr[n_bucket];  // minimum, except:\n        // Rust and Android trim unused zeroes from high end of hasharr[]\n        unsigned bmax = 0;\n        for (unsigned j= 0; j < n_bucket; ++j) {\n            if (buckets[j]) {\n                if (buckets[j] < symbias) {\n                    char msg[50]; snprintf(msg, sizeof(msg),\n                            \"bad DT_GNU_HASH bucket[%d] < symbias{%#x}\\n\",\n                            buckets[j], symbias);\n                    throwCantPack(msg);\n                }\n                if (bmax < buckets[j]) {\n                    bmax = buckets[j];\n                }\n            }\n        }\n        if ((1+ bmax) < symbias) {\n            char msg[80]; snprintf(msg, sizeof(msg),\n                    \"bad DT_GNU_HASH (1+ max_bucket)=%#x < symbias=%#x\", 1+ bmax, symbias);\n            throwCantPack(msg);\n        }\n        bmax -= symbias;\n\n        unsigned const v_sym = !x_sym ? 0 : get_te32(&dynp0[-1+ x_sym].d_val);\n        unsigned r = 0;\n        if (!n_bucket || !n_bitmask || !v_sym\n        || (r=1, ((-1+ n_bitmask) & n_bitmask))  // not a power of 2\n        || (r=2, (8*sizeof(unsigned) <= gnu_shift))  // shifted result always == 0\n        || (r=3, (n_bucket>>30))  // fie on fuzzers\n        || (r=4, (n_bitmask>>30))\n        || (r=5, ((file_size/sizeof(unsigned))\n                <= ((sizeof(*bitmask)/sizeof(unsigned))*n_bitmask + 2*n_bucket)))  // FIXME: weak\n        || (r=6, ((v_gsh < v_sym) && (v_sym - v_gsh) < (sizeof(unsigned)*4  // headers\n                + sizeof(*bitmask)*n_bitmask  // bitmask\n                + sizeof(*buckets)*n_bucket  // buckets\n                + sizeof(*hasharr)*(1+ bmax)  // hasharr\n            )) )\n        ) {\n            char msg[90]; snprintf(msg, sizeof(msg),\n                \"bad DT_GNU_HASH n_bucket=%#x  n_bitmask=%#x  len=%#lx  r=%d\",\n                n_bucket, n_bitmask, (long unsigned)(v_sym - v_gsh), r);\n            throwCantPack(msg);\n        }\n    }\n    unsigned const e_shstrndx = get_te16(&ehdri.e_shstrndx);\n    if (e_shnum <= e_shstrndx\n    &&  !(0==e_shnum && 0==e_shstrndx) ) {\n        char msg[40]; snprintf(msg, sizeof(msg),\n            \"bad .e_shstrndx %d >= .e_shnum %d\", e_shstrndx, e_shnum);\n        throwCantPack(msg);\n    }\n}", "target": 2, "idx": 11580}
{"commit_id": "f6d28fe2c95c678cc3202cc5dc825a3fcc709e93", "project": "vim", "func": "static void\nwin_exchange(long Prenum)\n{\n    frame_T\t*frp;\n    frame_T\t*frp2;\n    win_T\t*wp;\n    win_T\t*wp2;\n    int\t\ttemp;\n\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n    if (ONE_WINDOW)\t    // just one window\n    {\n\tbeep_flush();\n\treturn;\n    }\n    if (text_or_buf_locked())\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    /*\n     * find window to exchange with\n     */\n    if (Prenum)\n    {\n\tfrp = curwin->w_frame->fr_parent->fr_child;\n\twhile (frp != NULL && --Prenum > 0)\n\t    frp = frp->fr_next;\n    }\n    else if (curwin->w_frame->fr_next != NULL)\t// Swap with next\n\tfrp = curwin->w_frame->fr_next;\n    else    // Swap last window in row/col with previous\n\tfrp = curwin->w_frame->fr_prev;\n\n    // We can only exchange a window with another window, not with a frame\n    // containing windows.\n    if (frp == NULL || frp->fr_win == NULL || frp->fr_win == curwin)\n\treturn;\n    wp = frp->fr_win;\n\n/*\n * 1. remove curwin from the list. Remember after which window it was in wp2\n * 2. insert curwin before wp in the list\n * if wp != wp2\n *    3. remove wp from the list\n *    4. insert wp after wp2\n * 5. exchange the status line height and vsep width.\n */\n    wp2 = curwin->w_prev;\n    frp2 = curwin->w_frame->fr_prev;\n    if (wp->w_prev != curwin)\n    {\n\twin_remove(curwin, NULL);\n\tframe_remove(curwin->w_frame);\n\twin_append(wp->w_prev, curwin);\n\tframe_insert(frp, curwin->w_frame);\n    }\n    if (wp != wp2)\n    {\n\twin_remove(wp, NULL);\n\tframe_remove(wp->w_frame);\n\twin_append(wp2, wp);\n\tif (frp2 == NULL)\n\t    frame_insert(wp->w_frame->fr_parent->fr_child, wp->w_frame);\n\telse\n\t    frame_append(frp2, wp->w_frame);\n    }\n    temp = curwin->w_status_height;\n    curwin->w_status_height = wp->w_status_height;\n    wp->w_status_height = temp;\n    temp = curwin->w_vsep_width;\n    curwin->w_vsep_width = wp->w_vsep_width;\n    wp->w_vsep_width = temp;\n\n    frame_fix_height(curwin);\n    frame_fix_height(wp);\n    frame_fix_width(curwin);\n    frame_fix_width(wp);\n\n    (void)win_comp_pos();\t\t// recompute window positions\n\n    if (wp->w_buffer != curbuf)\n\treset_VIsual_and_resel();\n    else if (VIsual_active)\n\twp->w_cursor = curwin->w_cursor;\n\n    win_enter(wp, TRUE);\n    redraw_all_later(UPD_NOT_VALID);\n}", "target": 2, "idx": 11581}
{"commit_id": "7873f8334c8d31031f8cfa83bd97ac6029309e4f", "project": "sudo-project/sudo", "func": "int\nsudo_auth_end_session(void)\n{\n    sudo_auth *auth;\n    int ret = true;\n    int status;\n    debug_decl(sudo_auth_end_session, SUDOERS_DEBUG_AUTH);\n\n    for (auth = auth_switch; auth->name; auth++) {\n\tif (auth->end_session && !IS_DISABLED(auth)) {\n\t    status = (auth->end_session)(auth);\n\t    switch (status) {\n\t    case AUTH_SUCCESS:\n\t\tbreak;\n\t    case AUTH_FAILURE:\n\t\tret = false;\n\t\tbreak;\n\t    default:\n\t\t/* Assume error msg already printed. */\n\t\tret = -1;\n\t\tbreak;\n\t    }\n\t}\n    }\n    debug_return_int(ret);\n}", "target": 2, "idx": 11582}
{"commit_id": "9bfab35522301794483f8f9ed60820bdec9be59e", "project": "neomutt", "func": "static int pop_fetch_headers(struct Context *ctx)\n{\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  struct Progress progress;\n\n#ifdef USE_HCACHE\n  header_cache_t *hc = pop_hcache_open(pop_data, ctx->path);\n#endif\n\n  time(&pop_data->check_time);\n  pop_data->clear_cache = false;\n\n  for (int i = 0; i < ctx->msgcount; i++)\n    ctx->hdrs[i]->refno = -1;\n\n  const int old_count = ctx->msgcount;\n  int ret = pop_fetch_data(pop_data, \"UIDL\\r\\n\", NULL, fetch_uidl, ctx);\n  const int new_count = ctx->msgcount;\n  ctx->msgcount = old_count;\n\n  if (pop_data->cmd_uidl == 2)\n  {\n    if (ret == 0)\n    {\n      pop_data->cmd_uidl = 1;\n\n      mutt_debug(1, \"set UIDL capability\\n\");\n    }\n\n    if (ret == -2 && pop_data->cmd_uidl == 2)\n    {\n      pop_data->cmd_uidl = 0;\n\n      mutt_debug(1, \"unset UIDL capability\\n\");\n      snprintf(pop_data->err_msg, sizeof(pop_data->err_msg), \"%s\",\n               _(\"Command UIDL is not supported by server.\"));\n    }\n  }\n\n  if (!ctx->quiet)\n  {\n    mutt_progress_init(&progress, _(\"Fetching message headers...\"),\n                       MUTT_PROGRESS_MSG, ReadInc, new_count - old_count);\n  }\n\n  if (ret == 0)\n  {\n    int i, deleted;\n    for (i = 0, deleted = 0; i < old_count; i++)\n    {\n      if (ctx->hdrs[i]->refno == -1)\n      {\n        ctx->hdrs[i]->deleted = true;\n        deleted++;\n      }\n    }\n    if (deleted > 0)\n    {\n      mutt_error(\n          ngettext(\"%d message has been lost. Try reopening the mailbox.\",\n                   \"%d messages have been lost. Try reopening the mailbox.\", deleted),\n          deleted);\n    }\n\n    bool hcached = false;\n    for (i = old_count; i < new_count; i++)\n    {\n      if (!ctx->quiet)\n        mutt_progress_update(&progress, i + 1 - old_count, -1);\n#ifdef USE_HCACHE\n      void *data = mutt_hcache_fetch(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data));\n      if (data)\n      {\n        char *uidl = mutt_str_strdup(ctx->hdrs[i]->data);\n        int refno = ctx->hdrs[i]->refno;\n        int index = ctx->hdrs[i]->index;\n        /*\n         * - POP dynamically numbers headers and relies on h->refno\n         *   to map messages; so restore header and overwrite restored\n         *   refno with current refno, same for index\n         * - h->data needs to a separate pointer as it's driver-specific\n         *   data freed separately elsewhere\n         *   (the old h->data should point inside a malloc'd block from\n         *   hcache so there shouldn't be a memleak here)\n         */\n        struct Header *h = mutt_hcache_restore((unsigned char *) data);\n        mutt_hcache_free(hc, &data);\n        mutt_header_free(&ctx->hdrs[i]);\n        ctx->hdrs[i] = h;\n        ctx->hdrs[i]->refno = refno;\n        ctx->hdrs[i]->index = index;\n        ctx->hdrs[i]->data = uidl;\n        ret = 0;\n        hcached = true;\n      }\n      else\n#endif\n          if ((ret = pop_read_header(pop_data, ctx->hdrs[i])) < 0)\n        break;\n#ifdef USE_HCACHE\n      else\n      {\n        mutt_hcache_store(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data),\n                          ctx->hdrs[i], 0);\n      }\n#endif\n\n      /*\n       * faked support for flags works like this:\n       * - if 'hcached' is true, we have the message in our hcache:\n       *        - if we also have a body: read\n       *        - if we don't have a body: old\n       *          (if $mark_old is set which is maybe wrong as\n       *          $mark_old should be considered for syncing the\n       *          folder and not when opening it XXX)\n       * - if 'hcached' is false, we don't have the message in our hcache:\n       *        - if we also have a body: read\n       *        - if we don't have a body: new\n       */\n      const bool bcached =\n          (mutt_bcache_exists(pop_data->bcache, cache_id(ctx->hdrs[i]->data)) == 0);\n      ctx->hdrs[i]->old = false;\n      ctx->hdrs[i]->read = false;\n      if (hcached)\n      {\n        if (bcached)\n          ctx->hdrs[i]->read = true;\n        else if (MarkOld)\n          ctx->hdrs[i]->old = true;\n      }\n      else\n      {\n        if (bcached)\n          ctx->hdrs[i]->read = true;\n      }\n\n      ctx->msgcount++;\n    }\n\n    if (i > old_count)\n      mx_update_context(ctx, i - old_count);\n  }\n\n#ifdef USE_HCACHE\n  mutt_hcache_close(hc);\n#endif\n\n  if (ret < 0)\n  {\n    for (int i = ctx->msgcount; i < new_count; i++)\n      mutt_header_free(&ctx->hdrs[i]);\n    return ret;\n  }\n\n  /* after putting the result into our structures,\n   * clean up cache, i.e. wipe messages deleted outside\n   * the availability of our cache\n   */\n  if (MessageCacheClean)\n    mutt_bcache_list(pop_data->bcache, msg_cache_check, (void *) ctx);\n\n  mutt_clear_error();\n  return (new_count - old_count);\n}", "target": 3, "idx": 11583}
{"commit_id": "87d6bef033062f969e70fa40c43dfd945d5a20ab", "project": "the-tcpdump-group/libpcap", "func": "pcap_t *\npcap_ng_check_header(const uint8_t *magic, FILE *fp, u_int precision,\n    char *errbuf, int *err)\n{\n\tbpf_u_int32 magic_int;\n\tsize_t amt_read;\n\tbpf_u_int32 total_length;\n\tbpf_u_int32 byte_order_magic;\n\tstruct block_header *bhdrp;\n\tstruct section_header_block *shbp;\n\tpcap_t *p;\n\tint swapped = 0;\n\tstruct pcap_ng_sf *ps;\n\tint status;\n\tstruct block_cursor cursor;\n\tstruct interface_description_block *idbp;\n\n\t/*\n\t * Assume no read errors.\n\t */\n\t*err = 0;\n\n\t/*\n\t * Check whether the first 4 bytes of the file are the block\n\t * type for a pcapng savefile.\n\t */\n\tmemcpy(&magic_int, magic, sizeof(magic_int));\n\tif (magic_int != BT_SHB) {\n\t\t/*\n\t\t * XXX - check whether this looks like what the block\n\t\t * type would be after being munged by mapping between\n\t\t * UN*X and DOS/Windows text file format and, if it\n\t\t * does, look for the byte-order magic number in\n\t\t * the appropriate place and, if we find it, report\n\t\t * this as possibly being a pcapng file transferred\n\t\t * between UN*X and Windows in text file format?\n\t\t */\n\t\treturn (NULL);\t/* nope */\n\t}\n\n\t/*\n\t * OK, they are.  However, that's just \\n\\r\\r\\n, so it could,\n\t * conceivably, be an ordinary text file.\n\t *\n\t * It could not, however, conceivably be any other type of\n\t * capture file, so we can read the rest of the putative\n\t * Section Header Block; put the block type in the common\n\t * header, read the rest of the common header and the\n\t * fixed-length portion of the SHB, and look for the byte-order\n\t * magic value.\n\t */\n\tamt_read = fread(&total_length, 1, sizeof(total_length), fp);\n\tif (amt_read < sizeof(total_length)) {\n\t\tif (ferror(fp)) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"error reading dump file\");\n\t\t\t*err = 1;\n\t\t\treturn (NULL);\t/* fail */\n\t\t}\n\n\t\t/*\n\t\t * Possibly a weird short text file, so just say\n\t\t * \"not pcapng\".\n\t\t */\n\t\treturn (NULL);\n\t}\n\tamt_read = fread(&byte_order_magic, 1, sizeof(byte_order_magic), fp);\n\tif (amt_read < sizeof(byte_order_magic)) {\n\t\tif (ferror(fp)) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"error reading dump file\");\n\t\t\t*err = 1;\n\t\t\treturn (NULL);\t/* fail */\n\t\t}\n\n\t\t/*\n\t\t * Possibly a weird short text file, so just say\n\t\t * \"not pcapng\".\n\t\t */\n\t\treturn (NULL);\n\t}\n\tif (byte_order_magic != BYTE_ORDER_MAGIC) {\n\t\tbyte_order_magic = SWAPLONG(byte_order_magic);\n\t\tif (byte_order_magic != BYTE_ORDER_MAGIC) {\n\t\t\t/*\n\t\t\t * Not a pcapng file.\n\t\t\t */\n\t\t\treturn (NULL);\n\t\t}\n\t\tswapped = 1;\n\t\ttotal_length = SWAPLONG(total_length);\n\t}\n\n\t/*\n\t * Check the sanity of the total length.\n\t */\n\tif (total_length < sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer) ||\n            (total_length > BT_SHB_INSANE_MAX)) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Section Header Block in pcapng dump file has invalid length %\" PRIsize \" < _%lu_ < %lu (BT_SHB_INSANE_MAX)\",\n                              sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer),\n                              total_length,\n                              BT_SHB_INSANE_MAX);\n\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\n\n\n\t/*\n\t * OK, this is a good pcapng file.\n\t * Allocate a pcap_t for it.\n\t */\n\tp = pcap_open_offline_common(errbuf, sizeof (struct pcap_ng_sf));\n\tif (p == NULL) {\n\t\t/* Allocation failed. */\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\tp->swapped = swapped;\n\tps = p->priv;\n\n\t/*\n\t * What precision does the user want?\n\t */\n\tswitch (precision) {\n\n\tcase PCAP_TSTAMP_PRECISION_MICRO:\n\t\tps->user_tsresol = 1000000;\n\t\tbreak;\n\n\tcase PCAP_TSTAMP_PRECISION_NANO:\n\t\tps->user_tsresol = 1000000000;\n\t\tbreak;\n\n\tdefault:\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"unknown time stamp resolution %u\", precision);\n\t\tfree(p);\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\n\tp->opt.tstamp_precision = precision;\n\n\t/*\n\t * Allocate a buffer into which to read blocks.  We default to\n\t * the maximum of:\n\t *\n\t *\tthe total length of the SHB for which we read the header;\n\t *\n\t *\t2K, which should be more than large enough for an Enhanced\n\t *\tPacket Block containing a full-size Ethernet frame, and\n\t *\tleaving room for some options.\n\t *\n\t * If we find a bigger block, we reallocate the buffer, up to\n\t * the maximum size.  We start out with a maximum size of\n\t * INITIAL_MAX_BLOCKSIZE; if we see any link-layer header types\n\t * with a maximum snapshot that results in a larger maximum\n\t * block length, we boost the maximum.\n\t */\n\tp->bufsize = 2048;\n\tif (p->bufsize < total_length)\n\t\tp->bufsize = total_length;\n\tp->buffer = malloc(p->bufsize);\n\tif (p->buffer == NULL) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"out of memory\");\n\t\tfree(p);\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\tps->max_blocksize = INITIAL_MAX_BLOCKSIZE;\n\n\t/*\n\t * Copy the stuff we've read to the buffer, and read the rest\n\t * of the SHB.\n\t */\n\tbhdrp = (struct block_header *)p->buffer;\n\tshbp = (struct section_header_block *)((u_char *)p->buffer + sizeof(struct block_header));\n\tbhdrp->block_type = magic_int;\n\tbhdrp->total_length = total_length;\n\tshbp->byte_order_magic = byte_order_magic;\n\tif (read_bytes(fp,\n\t    (u_char *)p->buffer + (sizeof(magic_int) + sizeof(total_length) + sizeof(byte_order_magic)),\n\t    total_length - (sizeof(magic_int) + sizeof(total_length) + sizeof(byte_order_magic)),\n\t    1, errbuf) == -1)\n\t\tgoto fail;\n\n\tif (p->swapped) {\n\t\t/*\n\t\t * Byte-swap the fields we've read.\n\t\t */\n\t\tshbp->major_version = SWAPSHORT(shbp->major_version);\n\t\tshbp->minor_version = SWAPSHORT(shbp->minor_version);\n\n\t\t/*\n\t\t * XXX - we don't care about the section length.\n\t\t */\n\t}\n\t/* currently only SHB version 1.0 is supported */\n\tif (! (shbp->major_version == PCAP_NG_VERSION_MAJOR &&\n\t       shbp->minor_version == PCAP_NG_VERSION_MINOR)) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"unsupported pcapng savefile version %u.%u\",\n\t\t    shbp->major_version, shbp->minor_version);\n\t\tgoto fail;\n\t}\n\tp->version_major = shbp->major_version;\n\tp->version_minor = shbp->minor_version;\n\n\t/*\n\t * Save the time stamp resolution the user requested.\n\t */\n\tp->opt.tstamp_precision = precision;\n\n\t/*\n\t * Now start looking for an Interface Description Block.\n\t */\n\tfor (;;) {\n\t\t/*\n\t\t * Read the next block.\n\t\t */\n\t\tstatus = read_block(fp, p, &cursor, errbuf);\n\t\tif (status == 0) {\n\t\t\t/* EOF - no IDB in this file */\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"the capture file has no Interface Description Blocks\");\n\t\t\tgoto fail;\n\t\t}\n\t\tif (status == -1)\n\t\t\tgoto fail;\t/* error */\n\t\tswitch (cursor.block_type) {\n\n\t\tcase BT_IDB:\n\t\t\t/*\n\t\t\t * Get a pointer to the fixed-length portion of the\n\t\t\t * IDB.\n\t\t\t */\n\t\t\tidbp = get_from_block_data(&cursor, sizeof(*idbp),\n\t\t\t    errbuf);\n\t\t\tif (idbp == NULL)\n\t\t\t\tgoto fail;\t/* error */\n\n\t\t\t/*\n\t\t\t * Byte-swap it if necessary.\n\t\t\t */\n\t\t\tif (p->swapped) {\n\t\t\t\tidbp->linktype = SWAPSHORT(idbp->linktype);\n\t\t\t\tidbp->snaplen = SWAPLONG(idbp->snaplen);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Try to add this interface.\n\t\t\t */\n\t\t\tif (!add_interface(p, &cursor, errbuf))\n\t\t\t\tgoto fail;\n\n\t\t\tgoto done;\n\n\t\tcase BT_EPB:\n\t\tcase BT_SPB:\n\t\tcase BT_PB:\n\t\t\t/*\n\t\t\t * Saw a packet before we saw any IDBs.  That's\n\t\t\t * not valid, as we don't know what link-layer\n\t\t\t * encapsulation the packet has.\n\t\t\t */\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"the capture file has a packet block before any Interface Description Blocks\");\n\t\t\tgoto fail;\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Just ignore it.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\ndone:\n\tp->tzoff = 0;\t/* XXX - not used in pcap */\n\tp->linktype = linktype_to_dlt(idbp->linktype);\n\tp->snapshot = pcap_adjust_snapshot(p->linktype, idbp->snaplen);\n\tp->linktype_ext = 0;\n\n\t/*\n\t * If the maximum block size for a packet with the maximum\n\t * snapshot length for this DLT_ is bigger than the current\n\t * maximum block size, increase the maximum.\n\t */\n\tif (MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen_for_dlt(p->linktype)) > ps->max_blocksize)\n\t\tps->max_blocksize = MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen_for_dlt(p->linktype));\n\n\tp->next_packet_op = pcap_ng_next_packet;\n\tp->cleanup_op = pcap_ng_cleanup;\n\n\treturn (p);\n\nfail:\n\tfree(ps->ifaces);\n\tfree(p->buffer);\n\tfree(p);\n\t*err = 1;\n\treturn (NULL);\n}", "target": 1, "idx": 11584}
{"commit_id": "65f75a32a93ae4044c528a987a68366ecd4b46b9", "project": "ImageMagick", "func": "static MagickBooleanType WriteTGAImage(const ImageInfo *image_info,Image *image)\n{\n  CompressionType\n    compression;\n\n  const char\n    *comment,\n    *value;\n\n  const double\n    midpoint = QuantumRange/2.0;\n\n  MagickBooleanType\n    status;\n\n  QuantumAny\n    range;\n\n  register const IndexPacket\n    *indexes;\n\n  register const PixelPacket\n    *p;\n\n  register ssize_t\n    x;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *q;\n\n  ssize_t\n    count,\n    y;\n\n  TGAInfo\n    tga_info;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  /*\n    Initialize TGA raster file header.\n  */\n  if ((image->columns > 65535L) || (image->rows > 65535L))\n    ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n  (void) TransformImageColorspace(image,sRGBColorspace);\n  compression=image->compression;\n  if (image_info->compression != UndefinedCompression)\n    compression=image_info->compression;\n  range=GetQuantumRange(5UL);\n  tga_info.id_length=0;\n  comment=GetImageProperty(image,\"comment\");\n  if (comment != (const char *) NULL)\n    tga_info.id_length=(unsigned char) MagickMin(strlen(comment),255);\n  tga_info.colormap_type=0;\n  tga_info.colormap_index=0;\n  tga_info.colormap_length=0;\n  tga_info.colormap_size=0;\n  tga_info.x_origin=0;\n  tga_info.y_origin=0;\n  tga_info.width=(unsigned short) image->columns;\n  tga_info.height=(unsigned short) image->rows;\n  tga_info.bits_per_pixel=8;\n  tga_info.attributes=0;\n  if ((image_info->type != TrueColorType) &&\n      (image_info->type != TrueColorMatteType) &&\n      (image_info->type != PaletteType) &&\n      (image->matte == MagickFalse) &&\n      (SetImageGray(image,&image->exception) != MagickFalse))\n    tga_info.image_type=compression == RLECompression ? TGARLEMonochrome :\n      TGAMonochrome;\n  else\n    if ((image->storage_class == DirectClass) || (image->colors > 256))\n      {\n        /*\n          Full color TGA raster.\n        */\n        tga_info.image_type=compression == RLECompression ? TGARLERGB : TGARGB;\n        if (image_info->depth == 5)\n          {\n            tga_info.bits_per_pixel=16;\n            if (image->matte != MagickFalse)\n              tga_info.attributes=1;  /* # of alpha bits */\n          }\n        else\n          {\n            tga_info.bits_per_pixel=24;\n            if (image->matte != MagickFalse)\n              {\n                tga_info.bits_per_pixel=32;\n                tga_info.attributes=8;  /* # of alpha bits */\n              }\n          }\n      }\n    else\n      {\n        /*\n          Colormapped TGA raster.\n        */\n        tga_info.image_type=compression == RLECompression ? TGARLEColormap :\n          TGAColormap;\n        tga_info.colormap_type=1;\n        tga_info.colormap_length=(unsigned short) image->colors;\n        if (image_info->depth == 5)\n          tga_info.colormap_size=16;\n        else\n          tga_info.colormap_size=24;\n      }\n  value=GetImageArtifact(image,\"tga:image-origin\");\n  if (value != (const char *) NULL)\n    {\n      OrientationType\n        origin;\n\n      origin=(OrientationType) ParseCommandOption(MagickOrientationOptions,\n        MagickFalse,value);\n      if (origin == BottomRightOrientation || origin == TopRightOrientation)\n        tga_info.attributes|=(1UL << 4);\n      if (origin == TopLeftOrientation || origin == TopRightOrientation)\n        tga_info.attributes|=(1UL << 5);\n    }\n  /*\n    Write TGA header.\n  */\n  (void) WriteBlobByte(image,tga_info.id_length);\n  (void) WriteBlobByte(image,tga_info.colormap_type);\n  (void) WriteBlobByte(image,(unsigned char) tga_info.image_type);\n  (void) WriteBlobLSBShort(image,tga_info.colormap_index);\n  (void) WriteBlobLSBShort(image,tga_info.colormap_length);\n  (void) WriteBlobByte(image,tga_info.colormap_size);\n  (void) WriteBlobLSBShort(image,tga_info.x_origin);\n  (void) WriteBlobLSBShort(image,tga_info.y_origin);\n  (void) WriteBlobLSBShort(image,tga_info.width);\n  (void) WriteBlobLSBShort(image,tga_info.height);\n  (void) WriteBlobByte(image,tga_info.bits_per_pixel);\n  (void) WriteBlobByte(image,tga_info.attributes);\n  if (tga_info.id_length != 0)\n    (void) WriteBlob(image,tga_info.id_length,(unsigned char *) comment);\n  if (tga_info.colormap_type != 0)\n    {\n      unsigned char\n        green,\n        *targa_colormap;\n\n      /*\n        Dump colormap to file (blue, green, red byte order).\n      */\n      targa_colormap=(unsigned char *) AcquireQuantumMemory((size_t)\n        tga_info.colormap_length,(tga_info.colormap_size/8)*sizeof(\n        *targa_colormap));\n      if (targa_colormap == (unsigned char *) NULL)\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      q=targa_colormap;\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        if (image_info->depth == 5)\n          {\n            green=(unsigned char) ScaleQuantumToAny(image->colormap[i].green,\n              range);\n            *q++=((unsigned char) ScaleQuantumToAny(image->colormap[i].blue,\n              range)) | ((green & 0x07) << 5);\n            *q++=(((image->matte != MagickFalse) && (\n              (double) image->colormap[i].opacity < midpoint)) ? 0x80 : 0) |\n              ((unsigned char) ScaleQuantumToAny(image->colormap[i].red,\n              range) << 2) | ((green & 0x18) >> 3);\n          }\n        else\n          {\n            *q++=ScaleQuantumToChar(image->colormap[i].blue);\n            *q++=ScaleQuantumToChar(image->colormap[i].green);\n            *q++=ScaleQuantumToChar(image->colormap[i].red);\n          }\n      }\n      (void) WriteBlob(image,(size_t) ((tga_info.colormap_size/8)*\n        tga_info.colormap_length),targa_colormap);\n      targa_colormap=(unsigned char *) RelinquishMagickMemory(targa_colormap);\n    }\n  /*\n    Convert MIFF to TGA raster pixels.\n  */\n  for (y=(ssize_t) (image->rows-1); y >= 0; y--)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n    if (p == (const PixelPacket *) NULL)\n      break;\n    indexes=GetVirtualIndexQueue(image);\n    if (compression == RLECompression)\n      {\n        x=0;\n        count=0;\n        while (x < (ssize_t) image->columns)\n        {\n          i=1;\n          while ((i < 128) && (count + i < 128) &&\n                 ((x + i) < (ssize_t) image->columns))\n          {\n            if (tga_info.image_type == TGARLEColormap)\n              {\n                if (GetPixelIndex(indexes+i) != GetPixelIndex(indexes+(i-1)))\n                  break;\n              }\n            else\n              if (tga_info.image_type == TGARLEMonochrome)\n                {\n                  if (GetPixelLuma(image,p+i) != GetPixelLuma(image,p+(i-1)))\n                    break;\n                }\n              else\n                {\n                  if ((GetPixelBlue(p+i) != GetPixelBlue(p+(i-1))) ||\n                      (GetPixelGreen(p+i) != GetPixelGreen(p+(i-1))) ||\n                      (GetPixelRed(p+i) != GetPixelRed(p+(i-1))))\n                    break;\n                  if ((image->matte != MagickFalse) &&\n                      (GetPixelAlpha(p+i) != GetPixelAlpha(p+(i-1))))\n                    break;\n                }\n            i++;\n          }\n          if (i < 3)\n            {\n              count+=i;\n              p+=i;\n              indexes+=i;\n            }\n          if ((i >= 3) || (count == 128) ||\n              ((x + i) == (ssize_t) image->columns))\n            {\n              if (count > 0)\n                {\n                  (void) WriteBlobByte(image,(unsigned char) (--count));\n                  while (count >= 0)\n                  {\n                    WriteTGAPixel(image,tga_info.image_type,indexes-(count+1),\n                      p-(count+1),range,midpoint);\n                    count--;\n                  }\n                  count=0;\n                }\n            }\n          if (i >= 3)\n            {\n              (void) WriteBlobByte(image,(unsigned char) ((i-1) | 0x80));\n              WriteTGAPixel(image,tga_info.image_type,indexes,p,range,midpoint);\n              p+=i;\n              indexes+=i;\n            }\n          x+=i;\n        }\n      }\n    else\n      {\n        for (x=0; x < (ssize_t) image->columns; x++)\n          WriteTGAPixel(image,tga_info.image_type,indexes+x,p++,range,midpoint);\n      }\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}", "target": 1, "idx": 11585}
{"commit_id": "716b53d0a14c72bda16c0872565dd1909757e73f", "project": "openzfs/zfs", "func": "boolean_t\nzfs_groupmember(zfsvfs_t *zfsvfs, uint64_t id, cred_t *cr)\n{\n#ifdef HAVE_KSID\n\tuid_t\t\tgid;\n\n#ifdef illumos\n\tksid_t\t\t*ksid = crgetsid(cr, KSID_GROUP);\n\tksidlist_t\t*ksidlist = crgetsidlist(cr);\n\n\tif (ksid && ksidlist) {\n\t\tint\t\ti;\n\t\tksid_t\t\t*ksid_groups;\n\t\tuint32_t\tidx = FUID_INDEX(id);\n\t\tuint32_t\trid = FUID_RID(id);\n\n\t\tksid_groups = ksidlist->ksl_sids;\n\n\t\tfor (i = 0; i != ksidlist->ksl_nsid; i++) {\n\t\t\tif (idx == 0) {\n\t\t\t\tif (id != IDMAP_WK_CREATOR_GROUP_GID &&\n\t\t\t\t    id == ksid_groups[i].ks_id) {\n\t\t\t\t\treturn (B_TRUE);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst char *domain;\n\n\t\t\t\tdomain = zfs_fuid_find_by_idx(zfsvfs, idx);\n\t\t\t\tASSERT(domain != NULL);\n\n\t\t\t\tif (strcmp(domain,\n\t\t\t\t    IDMAP_WK_CREATOR_SID_AUTHORITY) == 0)\n\t\t\t\t\treturn (B_FALSE);\n\n\t\t\t\tif ((strcmp(domain,\n\t\t\t\t    ksid_groups[i].ks_domain->kd_name) == 0) &&\n\t\t\t\t    rid == ksid_groups[i].ks_rid)\n\t\t\t\t\treturn (B_TRUE);\n\t\t\t}\n\t\t}\n\t}\n#endif /* illumos */\n\n\t/*\n\t * Not found in ksidlist, check posix groups\n\t */\n\tgid = zfs_fuid_map_id(zfsvfs, id, cr, ZFS_GROUP);\n\treturn (groupmember(gid, cr));\n#else\n\treturn (B_TRUE);\n#endif\n}", "target": 2, "idx": 11586}
{"commit_id": "21998a351512eba4ed5969006f0c55882d995ada", "project": "torvalds/linux", "func": "static char *stibp_state(void)\n{\n\tif (spectre_v2_enabled == SPECTRE_V2_IBRS_ENHANCED)\n\t\treturn \"\";\n\n\tswitch (spectre_v2_user_stibp) {\n\tcase SPECTRE_V2_USER_NONE:\n\t\treturn \", STIBP: disabled\";\n\tcase SPECTRE_V2_USER_STRICT:\n\t\treturn \", STIBP: forced\";\n\tcase SPECTRE_V2_USER_STRICT_PREFERRED:\n\t\treturn \", STIBP: always-on\";\n\tcase SPECTRE_V2_USER_PRCTL:\n\tcase SPECTRE_V2_USER_SECCOMP:\n\t\tif (static_key_enabled(&switch_to_cond_stibp))\n\t\t\treturn \", STIBP: conditional\";\n\t}\n\treturn \"\";\n}", "target": 1, "idx": 11587}
{"commit_id": "ed8fdce754a5d8d14c09e989d8877707bd43906f", "project": "openbsd/src", "func": "void\ntcp_sack_option(struct tcpcb *tp, struct tcphdr *th, u_char *cp, int optlen)\n{\n\tint tmp_olen;\n\tu_char *tmp_cp;\n\tstruct sackhole *cur, *p, *temp;\n\n\tif (!tp->sack_enable)\n\t\treturn;\n\t/* SACK without ACK doesn't make sense. */\n\tif ((th->th_flags & TH_ACK) == 0)\n\t       return;\n\t/* Make sure the ACK on this segment is in [snd_una, snd_max]. */\n\tif (SEQ_LT(th->th_ack, tp->snd_una) ||\n\t    SEQ_GT(th->th_ack, tp->snd_max))\n\t\treturn;\n\t/* Note: TCPOLEN_SACK must be 2*sizeof(tcp_seq) */\n\tif (optlen <= 2 || (optlen - 2) % TCPOLEN_SACK != 0)\n\t\treturn;\n\t/* Note: TCPOLEN_SACK must be 2*sizeof(tcp_seq) */\n\ttmp_cp = cp + 2;\n\ttmp_olen = optlen - 2;\n\ttcpstat_inc(tcps_sack_rcv_opts);\n\tif (tp->snd_numholes < 0)\n\t\ttp->snd_numholes = 0;\n\tif (tp->t_maxseg == 0)\n\t\tpanic(\"tcp_sack_option\"); /* Should never happen */\n\twhile (tmp_olen > 0) {\n\t\tstruct sackblk sack;\n\n\t\tmemcpy(&sack.start, tmp_cp, sizeof(tcp_seq));\n\t\tsack.start = ntohl(sack.start);\n\t\tmemcpy(&sack.end, tmp_cp + sizeof(tcp_seq), sizeof(tcp_seq));\n\t\tsack.end = ntohl(sack.end);\n\t\ttmp_olen -= TCPOLEN_SACK;\n\t\ttmp_cp += TCPOLEN_SACK;\n\t\tif (SEQ_LEQ(sack.end, sack.start))\n\t\t\tcontinue; /* bad SACK fields */\n\t\tif (SEQ_LEQ(sack.end, tp->snd_una))\n\t\t\tcontinue; /* old block */\n\t\tif (SEQ_GT(th->th_ack, tp->snd_una)) {\n\t\t\tif (SEQ_LT(sack.start, th->th_ack))\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (SEQ_GT(sack.end, tp->snd_max))\n\t\t\tcontinue;\n\t\tif (tp->snd_holes == NULL) { /* first hole */\n\t\t\ttp->snd_holes = (struct sackhole *)\n\t\t\t    pool_get(&sackhl_pool, PR_NOWAIT);\n\t\t\tif (tp->snd_holes == NULL) {\n\t\t\t\t/* ENOBUFS, so ignore SACKed block for now*/\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tcur = tp->snd_holes;\n\t\t\tcur->start = th->th_ack;\n\t\t\tcur->end = sack.start;\n\t\t\tcur->rxmit = cur->start;\n\t\t\tcur->next = NULL;\n\t\t\ttp->snd_numholes = 1;\n\t\t\ttp->rcv_lastsack = sack.end;\n\t\t\t/*\n\t\t\t * dups is at least one.  If more data has been\n\t\t\t * SACKed, it can be greater than one.\n\t\t\t */\n\t\t\tcur->dups = min(tcprexmtthresh,\n\t\t\t    ((sack.end - cur->end)/tp->t_maxseg));\n\t\t\tif (cur->dups < 1)\n\t\t\t\tcur->dups = 1;\n\t\t\tcontinue; /* with next sack block */\n\t\t}\n\t\t/* Go thru list of holes:  p = previous,  cur = current */\n\t\tp = cur = tp->snd_holes;\n\t\twhile (cur) {\n\t\t\tif (SEQ_LEQ(sack.end, cur->start))\n\t\t\t\t/* SACKs data before the current hole */\n\t\t\t\tbreak; /* no use going through more holes */\n\t\t\tif (SEQ_GEQ(sack.start, cur->end)) {\n\t\t\t\t/* SACKs data beyond the current hole */\n\t\t\t\tcur->dups++;\n\t\t\t\tif (((sack.end - cur->end)/tp->t_maxseg) >=\n\t\t\t\t    tcprexmtthresh)\n\t\t\t\t\tcur->dups = tcprexmtthresh;\n\t\t\t\tp = cur;\n\t\t\t\tcur = cur->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (SEQ_LEQ(sack.start, cur->start)) {\n\t\t\t\t/* Data acks at least the beginning of hole */\n\t\t\t\tif (SEQ_GEQ(sack.end, cur->end)) {\n\t\t\t\t\t/* Acks entire hole, so delete hole */\n\t\t\t\t\tif (p != cur) {\n\t\t\t\t\t\tp->next = cur->next;\n\t\t\t\t\t\tpool_put(&sackhl_pool, cur);\n\t\t\t\t\t\tcur = p->next;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcur = cur->next;\n\t\t\t\t\t\tpool_put(&sackhl_pool, p);\n\t\t\t\t\t\tp = cur;\n\t\t\t\t\t\ttp->snd_holes = p;\n\t\t\t\t\t}\n\t\t\t\t\ttp->snd_numholes--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* otherwise, move start of hole forward */\n\t\t\t\tcur->start = sack.end;\n\t\t\t\tcur->rxmit = SEQ_MAX(cur->rxmit, cur->start);\n\t\t\t\tp = cur;\n\t\t\t\tcur = cur->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* move end of hole backward */\n\t\t\tif (SEQ_GEQ(sack.end, cur->end)) {\n\t\t\t\tcur->end = sack.start;\n\t\t\t\tcur->rxmit = SEQ_MIN(cur->rxmit, cur->end);\n\t\t\t\tcur->dups++;\n\t\t\t\tif (((sack.end - cur->end)/tp->t_maxseg) >=\n\t\t\t\t    tcprexmtthresh)\n\t\t\t\t\tcur->dups = tcprexmtthresh;\n\t\t\t\tp = cur;\n\t\t\t\tcur = cur->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (SEQ_LT(cur->start, sack.start) &&\n\t\t\t    SEQ_GT(cur->end, sack.end)) {\n\t\t\t\t/*\n\t\t\t\t * ACKs some data in middle of a hole; need to\n\t\t\t\t * split current hole\n\t\t\t\t */\n\t\t\t\tif (tp->snd_numholes >= TCP_SACKHOLE_LIMIT)\n\t\t\t\t\tgoto done;\n\t\t\t\ttemp = (struct sackhole *)\n\t\t\t\t    pool_get(&sackhl_pool, PR_NOWAIT);\n\t\t\t\tif (temp == NULL)\n\t\t\t\t\tgoto done; /* ENOBUFS */\n\t\t\t\ttemp->next = cur->next;\n\t\t\t\ttemp->start = sack.end;\n\t\t\t\ttemp->end = cur->end;\n\t\t\t\ttemp->dups = cur->dups;\n\t\t\t\ttemp->rxmit = SEQ_MAX(cur->rxmit, temp->start);\n\t\t\t\tcur->end = sack.start;\n\t\t\t\tcur->rxmit = SEQ_MIN(cur->rxmit, cur->end);\n\t\t\t\tcur->dups++;\n\t\t\t\tif (((sack.end - cur->end)/tp->t_maxseg) >=\n\t\t\t\t\ttcprexmtthresh)\n\t\t\t\t\tcur->dups = tcprexmtthresh;\n\t\t\t\tcur->next = temp;\n\t\t\t\tp = temp;\n\t\t\t\tcur = p->next;\n\t\t\t\ttp->snd_numholes++;\n\t\t\t}\n\t\t}\n\t\t/* At this point, p points to the last hole on the list */\n\t\tif (SEQ_LT(tp->rcv_lastsack, sack.start)) {\n\t\t\t/*\n\t\t\t * Need to append new hole at end.\n\t\t\t * Last hole is p (and it's not NULL).\n\t\t\t */\n\t\t\tif (tp->snd_numholes >= TCP_SACKHOLE_LIMIT)\n\t\t\t\tgoto done;\n\t\t\ttemp = (struct sackhole *)\n\t\t\t    pool_get(&sackhl_pool, PR_NOWAIT);\n\t\t\tif (temp == NULL)\n\t\t\t\tgoto done; /* ENOBUFS */\n\t\t\ttemp->start = tp->rcv_lastsack;\n\t\t\ttemp->end = sack.start;\n\t\t\ttemp->dups = min(tcprexmtthresh,\n\t\t\t    ((sack.end - sack.start)/tp->t_maxseg));\n\t\t\tif (temp->dups < 1)\n\t\t\t\ttemp->dups = 1;\n\t\t\ttemp->rxmit = temp->start;\n\t\t\ttemp->next = 0;\n\t\t\tp->next = temp;\n\t\t\ttp->rcv_lastsack = sack.end;\n\t\t\ttp->snd_numholes++;\n\t\t}\n\t}\ndone:\n\treturn;\n}", "target": 2, "idx": 11588}
{"commit_id": "2555283eb40df89945557273121e9393ef9b542b", "project": "torvalds/linux", "func": "void unlink_anon_vmas(struct vm_area_struct *vma)\n{\n\tstruct anon_vma_chain *avc, *next;\n\tstruct anon_vma *root = NULL;\n\n\t/*\n\t * Unlink each anon_vma chained to the VMA.  This list is ordered\n\t * from newest to oldest, ensuring the root anon_vma gets freed last.\n\t */\n\tlist_for_each_entry_safe(avc, next, &vma->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma = avc->anon_vma;\n\n\t\troot = lock_anon_vma_root(root, anon_vma);\n\t\tanon_vma_interval_tree_remove(avc, &anon_vma->rb_root);\n\n\t\t/*\n\t\t * Leave empty anon_vmas on the list - we'll need\n\t\t * to free them outside the lock.\n\t\t */\n\t\tif (RB_EMPTY_ROOT(&anon_vma->rb_root.rb_root)) {\n\t\t\tanon_vma->parent->num_children--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_del(&avc->same_vma);\n\t\tanon_vma_chain_free(avc);\n\t}\n\tif (vma->anon_vma) {\n\t\tvma->anon_vma->num_active_vmas--;\n\n\t\t/*\n\t\t * vma would still be needed after unlink, and anon_vma will be prepared\n\t\t * when handle fault.\n\t\t */\n\t\tvma->anon_vma = NULL;\n\t}\n\tunlock_anon_vma_root(root);\n\n\t/*\n\t * Iterate the list once more, it now only contains empty and unlinked\n\t * anon_vmas, destroy them. Could not do before due to __put_anon_vma()\n\t * needing to write-acquire the anon_vma->root->rwsem.\n\t */\n\tlist_for_each_entry_safe(avc, next, &vma->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma = avc->anon_vma;\n\n\t\tVM_WARN_ON(anon_vma->num_children);\n\t\tVM_WARN_ON(anon_vma->num_active_vmas);\n\t\tput_anon_vma(anon_vma);\n\n\t\tlist_del(&avc->same_vma);\n\t\tanon_vma_chain_free(avc);\n\t}\n}", "target": 1, "idx": 11589}
{"commit_id": "68f67b1a3a4d319543692afb5bd5b191ec984287", "project": "appneta/tcpreplay", "func": "static COUNTER\nprocess_raw_packets(pcap_t * pcap)\n{\n    ipv4_hdr_t *ip_hdr = NULL;\n    ipv6_hdr_t *ip6_hdr = NULL;\n    eth_hdr_t *eth_hdr = NULL;\n    struct pcap_pkthdr pkthdr;\n    const u_char *pktdata = NULL;\n    COUNTER packetnum = 0;\n    int l2len;\n    u_char ipbuff[MAXPACKET], *buffptr;\n    tcpr_dir_t direction = TCPR_DIR_ERROR;\n    tcpprep_opt_t *options = tcpprep->options;\n\n    assert(pcap);\n    \n    while ((pktdata = safe_pcap_next(pcap, &pkthdr)) != NULL) {\n        packetnum++;\n\n        dbgx(1, \"Packet \" COUNTER_SPEC, packetnum);\n\n        /* look for include or exclude LIST match */\n        if (options->xX.list != NULL) {\n            if (options->xX.mode < xXExclude) {\n                /* include list */\n                if (!check_list(options->xX.list, packetnum)) {\n                    add_cache(&(options->cachedata), DONT_SEND, 0);\n                    continue;\n                }\n            }\n            /* exclude list */\n            else if (check_list(options->xX.list, packetnum)) {\n                add_cache(&(options->cachedata), DONT_SEND, 0);\n                continue;\n            }\n        }\n\n        /*\n         * If the packet doesn't include an IPv4 header we should just treat\n         * it as a non-IP packet, UNLESS we're in MAC mode, in which case\n         * we should let the MAC matcher below handle it\n         */\n        if (options->mode != MAC_MODE) {\n            dbg(3, \"Looking for IPv4/v6 header in non-MAC mode\");\n            \n            /* get the IP header (if any) */\n            buffptr = ipbuff;\n    \n            /* first look for IPv4 */\n            if ((ip_hdr = (ipv4_hdr_t *)get_ipv4(pktdata, pkthdr.caplen, \n                    pcap_datalink(pcap), &buffptr))) {\n                dbg(2, \"Packet is IPv4\");\n            } else if ((ip6_hdr = (ipv6_hdr_t *)get_ipv6(pktdata, pkthdr.caplen,\n                    pcap_datalink(pcap), &buffptr))) {\n                /* IPv6 */\n                dbg(2, \"Packet is IPv6\");    \n            } else {\n                /* we're something else... */\n                dbg(2, \"Packet isn't IPv4/v6\");\n\n                /* we don't want to cache these packets twice */\n                if (options->mode != AUTO_MODE) {\n                    dbg(3, \"Adding to cache using options for Non-IP packets\");\n                    add_cache(&options->cachedata, SEND, options->nonip);\n                }\n\n                /* go to next packet */\n                continue;\n            }\n    \n            l2len = get_l2len(pktdata, pkthdr.caplen, pcap_datalink(pcap));\n            if (l2len < 0) {\n                /* go to next packet */\n                continue;\n            }\n\n            /* look for include or exclude CIDR match */\n            if (options->xX.cidr != NULL) {\n                if (ip_hdr) {\n                    if (!process_xX_by_cidr_ipv4(options->xX.mode, options->xX.cidr, ip_hdr)) {\n                        add_cache(&options->cachedata, DONT_SEND, 0);\n                        continue;\n                    }\n                } else if (ip6_hdr) {\n                    if (!process_xX_by_cidr_ipv6(options->xX.mode, options->xX.cidr, ip6_hdr)) {\n                        add_cache(&options->cachedata, DONT_SEND, 0);\n                        continue;\n                    }\n                }\n            }\n        }\n\n        switch (options->mode) {\n        case REGEX_MODE:\n            dbg(2, \"processing regex mode...\");\n            if (ip_hdr) {\n                direction = check_ipv4_regex(ip_hdr->ip_src.s_addr);\n            } else if (ip6_hdr) {\n                direction = check_ipv6_regex(&ip6_hdr->ip_src);\n            }\n\n            /* reverse direction? */\n            if (HAVE_OPT(REVERSE) && (direction == TCPR_DIR_C2S || direction == TCPR_DIR_S2C))\n                direction = direction == TCPR_DIR_C2S ? TCPR_DIR_S2C : TCPR_DIR_C2S;\n\n            add_cache(&options->cachedata, SEND, direction);\n            break;\n\n        case CIDR_MODE:\n            dbg(2, \"processing cidr mode...\");\n            if (ip_hdr) {\n                direction = check_ip_cidr(options->cidrdata, ip_hdr->ip_src.s_addr) ? TCPR_DIR_C2S : TCPR_DIR_S2C;\n            } else if (ip6_hdr) {\n                direction = check_ip6_cidr(options->cidrdata, &ip6_hdr->ip_src) ? TCPR_DIR_C2S : TCPR_DIR_S2C;\n            }\n\n            /* reverse direction? */\n            if (HAVE_OPT(REVERSE) && (direction == TCPR_DIR_C2S || direction == TCPR_DIR_S2C))\n                direction = direction == TCPR_DIR_C2S ? TCPR_DIR_S2C : TCPR_DIR_C2S;\n\n            add_cache(&options->cachedata, SEND, direction);\n            break;\n\n        case MAC_MODE:\n            dbg(2, \"processing mac mode...\");\n            if (pkthdr.caplen < sizeof(*eth_hdr)) {\n                dbg(2, \"capture length too short for mac mode processing\");\n                break;\n            }\n\n            eth_hdr = (eth_hdr_t *)pktdata;\n            direction = macinstring(options->maclist, (u_char *)eth_hdr->ether_shost);\n\n            /* reverse direction? */\n            if (HAVE_OPT(REVERSE) && (direction == TCPR_DIR_C2S || direction == TCPR_DIR_S2C))\n                direction = direction == TCPR_DIR_C2S ? TCPR_DIR_S2C : TCPR_DIR_C2S;\n\n            add_cache(&options->cachedata, SEND, direction);\n            break;\n\n        case AUTO_MODE:\n            dbg(2, \"processing first pass of auto mode...\");\n            /* first run through in auto mode: create tree */\n            if (options->automode != FIRST_MODE) {\n                if (ip_hdr) {\n                    add_tree_ipv4(ip_hdr->ip_src.s_addr, pktdata, pkthdr.caplen);\n                } else if (ip6_hdr) {\n                    add_tree_ipv6(&ip6_hdr->ip_src, pktdata, pkthdr.caplen);\n                }\n            } else {\n                if (ip_hdr) {\n                    add_tree_first_ipv4(pktdata, pkthdr.caplen);\n                } else if (ip6_hdr) {\n                    add_tree_first_ipv6(pktdata, pkthdr.caplen);\n                }\n            }  \n            break;\n\n        case ROUTER_MODE:\n            /* \n             * second run through in auto mode: create route\n             * based cache\n             */\n            dbg(2, \"processing second pass of auto: router mode...\");\n            if (ip_hdr) {\n                add_cache(&options->cachedata, SEND,\n                    check_ip_tree(options->nonip, ip_hdr->ip_src.s_addr));\n            } else {\n                add_cache(&options->cachedata, SEND,\n                    check_ip6_tree(options->nonip, &ip6_hdr->ip_src));\n            }\n            break;\n\n        case BRIDGE_MODE:\n            /*\n             * second run through in auto mode: create bridge\n             * based cache\n             */\n            dbg(2, \"processing second pass of auto: bridge mode...\");\n            if (ip_hdr) {\n                add_cache(&options->cachedata, SEND,\n                    check_ip_tree(DIR_UNKNOWN, ip_hdr->ip_src.s_addr));\n            } else {\n                add_cache(&options->cachedata, SEND,\n                    check_ip6_tree(DIR_UNKNOWN, &ip6_hdr->ip_src));\n            }\n            break;\n\n        case SERVER_MODE:\n            /* \n             * second run through in auto mode: create bridge\n             * where unknowns are servers\n             */\n            dbg(2, \"processing second pass of auto: server mode...\");\n            if (ip_hdr) {\n                add_cache(&options->cachedata, SEND,\n                    check_ip_tree(DIR_SERVER, ip_hdr->ip_src.s_addr));\n            } else {\n                add_cache(&options->cachedata, SEND,\n                    check_ip6_tree(DIR_SERVER, &ip6_hdr->ip_src));\n            }\n            break;\n\n        case CLIENT_MODE:\n            /* \n             * second run through in auto mode: create bridge\n             * where unknowns are clients\n             */\n            dbg(2, \"processing second pass of auto: client mode...\");\n            if (ip_hdr) {\n                add_cache(&options->cachedata, SEND,\n                    check_ip_tree(DIR_CLIENT, ip_hdr->ip_src.s_addr));\n            } else {\n                add_cache(&options->cachedata, SEND,\n                    check_ip6_tree(DIR_CLIENT, &ip6_hdr->ip_src));\n            }\n            break;\n\n        case PORT_MODE:\n            /*\n             * process ports based on their destination port\n             */\n            dbg(2, \"processing port mode...\");\n            add_cache(&options->cachedata, SEND,\n            \t\tcheck_dst_port(ip_hdr, ip6_hdr, (pkthdr.caplen - l2len)));\n            break;\n\n        case FIRST_MODE:\n            /*\n             * First packet mode, looks at each host and picks clients\n             * by the ones which send the first packet in a session\n             */\n            dbg(2, \"processing second pass of auto: first packet mode...\");\n            if (ip_hdr) {\n                add_cache(&options->cachedata, SEND,\n                    check_ip_tree(DIR_UNKNOWN, ip_hdr->ip_src.s_addr));\n            } else {\n                add_cache(&options->cachedata, SEND,\n                    check_ip6_tree(DIR_UNKNOWN, &ip6_hdr->ip_src));\n            }\n            break;\n            \n        default:\n            errx(-1, \"Whoops!  What mode are we in anyways? %d\", options->mode);\n        }\n#ifdef ENABLE_VERBOSE\n        if (options->verbose)\n            tcpdump_print(&tcpprep->tcpdump, &pkthdr, pktdata);\n#endif\n    }\n\n    return packetnum;\n}", "target": 2, "idx": 11590}
{"commit_id": "0ff832d31470471803b175cfff4e40c1b08ee779", "project": "aawc/unrar", "func": "virtual bool IsOpened() {return hFile!=FILE_BAD_HANDLE;}", "target": 2, "idx": 11591}
{"commit_id": "deece2fa6ab89a7319363fbc2c0b4d37f5469a93", "project": "jerryscript-project/jerryscript", "func": "static ecma_value_t\necma_module_namespace_object_add_export_if_needed (ecma_module_t *module_p, /**< module */\n                                                   ecma_string_t *export_name_p) /**< export name */\n{\n  JERRY_ASSERT (module_p->namespace_object_p != NULL);\n  ecma_value_t result = ECMA_VALUE_EMPTY;\n\n  /* Default exports should not be added to the namespace object. */\n  if (ecma_compare_ecma_string_to_magic_id (export_name_p, LIT_MAGIC_STRING_DEFAULT)\n      || ecma_find_named_property (module_p->namespace_object_p, export_name_p) != NULL)\n  {\n    /* This export name has already been handled. */\n    return result;\n  }\n\n  ecma_module_record_t record;\n  result = ecma_module_resolve_export (module_p, export_name_p, &record);\n\n  if (ECMA_IS_VALUE_ERROR (result))\n  {\n    return result;\n  }\n\n  if (record.module_p == NULL)\n  {\n    /* 15.2.1.18 / 3.d.iv Skip ambiguous names. */\n    return result;\n  }\n\n  ecma_object_t *ref_base_lex_env_p;\n  ecma_value_t prop_value = ecma_op_get_value_lex_env_base (record.module_p->scope_p,\n                                                            &ref_base_lex_env_p,\n                                                            record.name_p);\n  ecma_property_t *new_property_p;\n  ecma_create_named_data_property (module_p->namespace_object_p,\n                                   export_name_p,\n                                   ECMA_PROPERTY_FIXED,\n                                   &new_property_p);\n\n  ecma_named_data_property_assign_value (module_p->namespace_object_p,\n                                         ECMA_PROPERTY_VALUE_PTR (new_property_p),\n                                         prop_value);\n\n  ecma_free_value (prop_value);\n  return result;\n}", "target": 1, "idx": 11592}
{"commit_id": "67d760ab775dae4efe803b5944b0439aa3c0b04a", "project": "ArtifexSoftware/ghostpdl", "func": "static int\nznumicc_components(i_ctx_t * i_ctx_p)\n{\n    ref *                   pnval;\n    ref *                   pstrmval;\n    stream *                s;\n    int                     ncomps, expected = 0, code;\n    cmm_profile_t           *picc_profile;\n    os_ptr                  op = osp;\n\n    check_type(*op, t_dictionary);\n    check_dict_read(*op);\n\n    code = dict_find_string(op, \"N\", &pnval);\n    if (code < 0)\n        return code;\n    if (code == 0)\n        return_error(gs_error_undefined);\n    if (r_type(pnval) != t_integer)\n        return gs_note_error(gs_error_typecheck);\n    ncomps = pnval->value.intval;\n    /* verify the DataSource entry. Create profile from stream */\n    if (dict_find_string(op, \"DataSource\", &pstrmval) <= 0)\n        return_error(gs_error_undefined);\n    check_read_file(i_ctx_p, s, pstrmval);\n\n    picc_profile = gsicc_profile_new(s, gs_gstate_memory(igs), NULL, 0);\n    if (picc_profile == NULL)\n        return gs_throw(gs_error_VMerror, \"Creation of ICC profile failed\");\n\n    picc_profile->num_comps = ncomps;\n    picc_profile->profile_handle =\n        gsicc_get_profile_handle_buffer(picc_profile->buffer,\n                                        picc_profile->buffer_size,\n                                        gs_gstate_memory(igs));\n    if (picc_profile->profile_handle == NULL) {\n        rc_decrement(picc_profile,\"znumicc_components\");\n        make_int(op, expected);\n        return 0;\n    }\n    picc_profile->data_cs =\n        gscms_get_profile_data_space(picc_profile->profile_handle,\n            picc_profile->memory);\n\n    switch (picc_profile->data_cs) {\n        case gsCIEXYZ:\n        case gsCIELAB:\n        case gsRGB:\n            expected = 3;\n            break;\n        case gsGRAY:\n            expected = 1;\n            break;\n        case gsCMYK:\n            expected = 4;\n            break;\n        case gsNCHANNEL:\n            expected = 0;\n            break;\n        case gsNAMED:\n        case gsUNDEFINED:\n            expected = -1;\n            break;\n    }\n\n    make_int(op, expected);\n\n    rc_decrement(picc_profile,\"zset_outputintent\");\n    return 0;\n}", "target": 2, "idx": 11593}
{"commit_id": "eff8e457298d01b437e4fd78194ad6de3c8d7ad6", "project": "chromium", "func": "SaveItem::SaveItem(const GURL& url,\n                   const Referrer& referrer,\n                   SavePackage* package,\n                   SaveFileCreateInfo::SaveFileSource save_source,\n                   int frame_tree_node_id,\n                   int container_frame_tree_node_id)\n    : save_item_id_(GetNextSaveItemId()),\n      url_(url),\n      referrer_(referrer),\n      frame_tree_node_id_(frame_tree_node_id),\n      container_frame_tree_node_id_(container_frame_tree_node_id),\n      total_bytes_(0),\n      received_bytes_(0),\n      state_(WAIT_START),\n      is_success_(false),\n      save_source_(save_source),\n      package_(package) {\n  DCHECK(package);\n}", "target": 0, "idx": 11594}
{"commit_id": "1a5f95fc018a5667de5a9448aee9d7251b2eb952", "project": "ImageMagick", "func": "static Image *ReadPWPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  FILE\n    *file;\n\n  Image\n    *image,\n    *next_image,\n    *pwp_image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  register Image\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    filesize,\n    length;\n\n  ssize_t\n    count;\n\n  unsigned char\n    magick[MaxTextExtent];\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  pwp_image=AcquireImage(image_info);\n  image=pwp_image;\n  status=OpenBlob(image_info,pwp_image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return((Image *) NULL);\n  ResetMagickMemory(magick,0,sizeof(magick));\n  count=ReadBlob(pwp_image,5,magick);\n  if ((count != 5) || (LocaleNCompare((char *) magick,\"SFW95\",5) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  read_info=CloneImageInfo(image_info);\n  (void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,\n    (void *) NULL);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  unique_file=AcquireUniqueFileResource(read_info->filename);\n  for ( ; ; )\n  {\n    (void) memset(magick,0,sizeof(magick));\n    for (c=ReadBlobByte(pwp_image); c != EOF; c=ReadBlobByte(pwp_image))\n    {\n      for (i=0; i < 17; i++)\n        magick[i]=magick[i+1];\n      magick[17]=(unsigned char) c;\n      if (LocaleNCompare((char *) (magick+12),\"SFW94A\",6) == 0)\n        break;\n    }\n    if (c == EOF)\n      {\n        (void) RelinquishUniqueFileResource(read_info->filename);\n        read_info=DestroyImageInfo(read_info);\n        ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n      }\n    if (LocaleNCompare((char *) (magick+12),\"SFW94A\",6) != 0)\n      {\n        (void) RelinquishUniqueFileResource(read_info->filename);\n        read_info=DestroyImageInfo(read_info);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    /*\n      Dump SFW image to a temporary file.\n    */\n    file=(FILE *) NULL;\n    if (unique_file != -1)\n      file=fdopen(unique_file,\"wb\");\n    if ((unique_file == -1) || (file == (FILE *) NULL))\n      {\n        (void) RelinquishUniqueFileResource(read_info->filename);\n        read_info=DestroyImageInfo(read_info);\n        image=DestroyImageList(image);\n        ThrowFileException(exception,FileOpenError,\"UnableToWriteFile\",\n          image->filename);\n        return((Image *) NULL);\n      }\n    length=fwrite(\"SFW94A\",1,6,file);\n    (void) length;\n    filesize=65535UL*magick[2]+256L*magick[1]+magick[0];\n    for (i=0; i < (ssize_t) filesize; i++)\n    {\n      c=ReadBlobByte(pwp_image);\n      if (c == EOF)\n        break;\n      (void) fputc(c,file);\n    }\n    (void) fclose(file);\n    if (c == EOF)\n      {\n        (void) RelinquishUniqueFileResource(read_info->filename);\n        read_info=DestroyImageInfo(read_info);\n        ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n      }\n    next_image=ReadImage(read_info,exception);\n    if (next_image == (Image *) NULL)\n      break;\n    (void) FormatLocaleString(next_image->filename,MaxTextExtent,\n      \"slide_%02ld.sfw\",(long) next_image->scene);\n    if (image == (Image *) NULL)\n      image=next_image;\n    else\n      {\n        /*\n          Link image into image list.\n        */\n        for (p=image; p->next != (Image *) NULL; p=GetNextImageInList(p)) ;\n        next_image->previous=p;\n        next_image->scene=p->scene+1;\n        p->next=next_image;\n      }\n    if (image_info->number_scenes != 0)\n      if (next_image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(pwp_image),\n      GetBlobSize(pwp_image));\n    if (status == MagickFalse)\n      break;\n  }\n  if (unique_file != -1)\n    (void) close(unique_file);\n  (void) RelinquishUniqueFileResource(read_info->filename);\n  read_info=DestroyImageInfo(read_info);\n  if (image != (Image *) NULL)\n    {\n      if (EOFBlob(image) != MagickFalse)\n        {\n          char\n            *message;\n\n          message=GetExceptionMessage(errno);\n          (void) ThrowMagickException(exception,GetMagickModule(),\n            CorruptImageError,\"UnexpectedEndOfFile\",\"`%s': %s\",image->filename,\n            message);\n          message=DestroyString(message);\n        }\n      (void) CloseBlob(image);\n    }\n  return(GetFirstImageInList(image));\n}", "target": 1, "idx": 11595}
{"commit_id": "b4e79bfa0c7d2d08f6f1e7ec38143fc8cb11394a", "project": "libtiff", "func": "static int\nLZWPreDecode(TIFF* tif, uint16_t s)\n{\n\tstatic const char module[] = \"LZWPreDecode\";\n\tLZWCodecState *sp = DecoderState(tif);\n\n\t(void) s;\n\tassert(sp != NULL);\n\tif( sp->dec_codetab == NULL )\n        {\n            tif->tif_setupdecode( tif );\n\t    if( sp->dec_codetab == NULL )\n\t\treturn (0);\n        }\n\n\t/*\n\t * Check for old bit-reversed codes.\n\t */\n\tif (tif->tif_rawcc >= 2 &&\n\t    tif->tif_rawdata[0] == 0 && (tif->tif_rawdata[1] & 0x1)) {\n#ifdef LZW_COMPAT\n\t\tif (!sp->dec_decode) {\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t    \"Old-style LZW codes, convert file\");\n\t\t\t/*\n\t\t\t * Override default decoding methods with\n\t\t\t * ones that deal with the old coding.\n\t\t\t * Otherwise the predictor versions set\n\t\t\t * above will call the compatibility routines\n\t\t\t * through the dec_decode method.\n\t\t\t */\n\t\t\ttif->tif_decoderow = LZWDecodeCompat;\n\t\t\ttif->tif_decodestrip = LZWDecodeCompat;\n\t\t\ttif->tif_decodetile = LZWDecodeCompat;\n\t\t\t/*\n\t\t\t * If doing horizontal differencing, must\n\t\t\t * re-setup the predictor logic since we\n\t\t\t * switched the basic decoder methods...\n\t\t\t */\n\t\t\t(*tif->tif_setupdecode)(tif);\n\t\t\tsp->dec_decode = LZWDecodeCompat;\n\t\t}\n\t\tsp->lzw_maxcode = MAXCODE(BITS_MIN);\n#else /* !LZW_COMPAT */\n\t\tif (!sp->dec_decode) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"Old-style LZW codes not supported\");\n\t\t\tsp->dec_decode = LZWDecode;\n\t\t}\n\t\treturn (0);\n#endif/* !LZW_COMPAT */\n\t} else {\n\t\tsp->lzw_maxcode = MAXCODE(BITS_MIN)-1;\n\t\tsp->dec_decode = LZWDecode;\n\t}\n\tsp->lzw_nbits = BITS_MIN;\n\tsp->lzw_nextbits = 0;\n\tsp->lzw_nextdata = 0;\n\n\tsp->dec_restart = 0;\n\tsp->dec_nbitsmask = MAXCODE(BITS_MIN);\n\tsp->dec_bitsleft = 0;\n\tsp->old_tif_rawcc = 0;\n\tsp->dec_free_entp = sp->dec_codetab  - 1 ; // + CODE_FIRST;\n\t/*\n\t * Zero entries that are not yet filled in.  We do\n\t * this to guard against bogus input data that causes\n\t * us to index into undefined entries.  If you can\n\t * come up with a way to safely bounds-check input codes\n\t * while decoding then you can remove this operation.\n\t */\n\tsp->dec_oldcodep = &sp->dec_codetab[0];\n\tsp->dec_maxcodep = &sp->dec_codetab[sp->dec_nbitsmask-1];\n\tsp->read_error = 0;\n\treturn (1);\n}", "target": 1, "idx": 11596}
{"commit_id": "fbfa4d1083ea84c5429992ca3e996d7d4fbc8238", "project": "YanVugenfirer/kvm-guest-drivers-windows", "func": "tTcpIpPacketParsingResult ParaNdis_CheckSumVerify(\n                                                tCompletePhysicalAddress *pDataPages,\n                                                ULONG ulDataLength,\n                                                ULONG ulStartOffset,\n                                                ULONG flags,\n                                                LPCSTR caller)\n{\n    IPHeader *pIpHeader = (IPHeader *) RtlOffsetToPointer(pDataPages[0].Virtual, ulStartOffset);\n\n    tTcpIpPacketParsingResult res = QualifyIpPacket(pIpHeader, ulDataLength);\n    if (res.ipStatus == ppresNotIP || res.ipCheckSum == ppresIPTooShort)\n        return res;\n\n    if (res.ipStatus == ppresIPV4)\n    {\n        if (flags & pcrIpChecksum)\n            res = VerifyIpChecksum(&pIpHeader->v4, res, (flags & pcrFixIPChecksum) != 0);\n        if(res.xxpStatus == ppresXxpKnown)\n        {\n            if (res.TcpUdp == ppresIsTCP) /* TCP */\n            {\n                if(flags & pcrTcpV4Checksum)\n                {\n                    res = VerifyTcpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixTcpV4Checksum));\n                }\n            }\n            else /* UDP */\n            {\n                if (flags & pcrUdpV4Checksum)\n                {\n                    res = VerifyUdpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixUdpV4Checksum));\n                }\n            }\n        }\n    }\n    else if (res.ipStatus == ppresIPV6)\n    {\n        if(res.xxpStatus == ppresXxpKnown)\n        {\n            if (res.TcpUdp == ppresIsTCP) /* TCP */\n            {\n                if(flags & pcrTcpV6Checksum)\n                {\n                    res = VerifyTcpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixTcpV6Checksum));\n                }\n            }\n            else /* UDP */\n            {\n                if (flags & pcrUdpV6Checksum)\n                {\n                    res = VerifyUdpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixUdpV6Checksum));\n                }\n            }\n        }\n    }\n    PrintOutParsingResult(res, 1, caller);\n    return res;\n}", "target": 2, "idx": 11597}
{"commit_id": "1c45a899f83fa88e60ab69936bea3c4754e7808b", "project": "wireshark", "func": "static void dissect_client_transport_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                                          guint offset, guint length_remaining)\n{\n    char    *transport_info;\n    guint   ipaddr[4];\n    char    protocol[3+1] = \"\";\n    guint   port;\n    int     fields_matched;\n\n    /* Flags */\n    proto_tree_add_item(tree, hf_msmms_command_prefix1, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n    offset += 4;\n    proto_tree_add_item(tree, hf_msmms_command_prefix2, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n    offset += 4;\n\n    /* These 12 bytes are not understood */\n    offset += 4;\n    offset += 4;\n    offset += 4;\n\n    /* Extract and show the string in tree and info column */\n    transport_info = tvb_get_string_enc(pinfo->pool, tvb, offset, length_remaining - 20, ENC_UTF_16|ENC_LITTLE_ENDIAN);\n\n    proto_tree_add_string_format(tree, hf_msmms_command_client_transport_info, tvb,\n                                 offset, length_remaining-20,\n                                 transport_info, \"Transport: (%s)\", transport_info);\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" (%s)\",\n                    format_text_string(pinfo->pool, (const guchar*)transport_info));\n\n\n    /* Try to extract details from this string */\n    fields_matched = sscanf(transport_info, \"%*c%*c%u.%u.%u.%u%*c%3s%*c%u\",\n                            &ipaddr[0], &ipaddr[1], &ipaddr[2], &ipaddr[3],\n                            protocol, &port);\n\n    /* Use this information to set up a conversation for the data stream */\n    if (fields_matched == 6)\n    {\n        conversation_type ckt = CONVERSATION_NONE;\n\n        /* Work out the port type */\n        if (strncmp(protocol, \"UDP\", 3) == 0)\n        {\n            ckt = CONVERSATION_UDP;\n        }\n        else\n        if (strncmp(protocol, \"TCP\", 3) == 0)\n        {\n            ckt = CONVERSATION_TCP;\n        }\n\n        /* Set the dissector for indicated conversation */\n        if (ckt != CONVERSATION_NONE)\n        {\n            guint8 octets[4];\n            address addr;\n            octets[0] = ipaddr[0];\n            octets[1] = ipaddr[1];\n            octets[2] = ipaddr[2];\n            octets[3] = ipaddr[3];\n            addr.type = AT_IPv4;\n            addr.len = 4;\n            addr.data = octets;\n            msmms_data_add_address(pinfo, &addr, ckt, port);\n        }\n    }\n}", "target": 1, "idx": 11598}
{"commit_id": "eaf166009e44641e6570c576ba071217f100fd99", "project": "virtualsquare/picotcp", "func": "static int tcp_syn(struct pico_socket *s, struct pico_frame *f)\n{\n    struct pico_socket_tcp *new = NULL;\n    struct pico_tcp_hdr *hdr = NULL;\n    uint16_t mtu;\n    if(s->number_of_pending_conn >= s->max_backlog)\n        return -1;\n\n    new = (struct pico_socket_tcp *)pico_socket_clone(s);\n    hdr = (struct pico_tcp_hdr *)f->transport_hdr;\n    if (!new)\n        return -1;\n\n#ifdef PICO_TCP_SUPPORT_SOCKET_STATS\n    if (!pico_timer_add(t->sock.stack, 2000, sock_stats, s)) {\n        tcp_dbg(\"TCP: Failed to start socket statistics timer\\n\");\n        return -1;\n    }\n#endif\n\n    new->sock.remote_port = ((struct pico_trans *)f->transport_hdr)->sport;\n#ifdef PICO_SUPPORT_IPV4\n    if (IS_IPV4(f)) {\n        new->sock.remote_addr.ip4.addr = ((struct pico_ipv4_hdr *)(f->net_hdr))->src.addr;\n        new->sock.local_addr.ip4.addr = ((struct pico_ipv4_hdr *)(f->net_hdr))->dst.addr;\n    }\n\n#endif\n#ifdef PICO_SUPPORT_IPV6\n    if (IS_IPV6(f)) {\n        new->sock.remote_addr.ip6 = ((struct pico_ipv6_hdr *)(f->net_hdr))->src;\n        new->sock.local_addr.ip6 = ((struct pico_ipv6_hdr *)(f->net_hdr))->dst;\n    }\n\n#endif\n    f->sock = &new->sock;\n    mtu = (uint16_t)pico_socket_get_mss(&new->sock);\n    if (mtu > PICO_SIZE_TCPHDR + PICO_TCP_MIN_MSS)\n        new->mss = (uint16_t)(mtu - PICO_SIZE_TCPHDR);\n    else\n        new->mss = PICO_TCP_MIN_MSS;\n    if (tcp_parse_options(f) < 0)\n        return -1;\n    new->sock.stack = s->stack;\n    new->tcpq_in.max_size = PICO_DEFAULT_SOCKETQ;\n    new->tcpq_out.max_size = PICO_DEFAULT_SOCKETQ;\n    new->tcpq_hold.max_size = 2u * mtu;\n    new->rcv_nxt = long_be(hdr->seq) + 1;\n    new->snd_nxt = long_be(pico_paws());\n    new->snd_last = new->snd_nxt;\n    new->cwnd = PICO_TCP_IW;\n    new->ssthresh = (uint16_t)((uint16_t)(PICO_DEFAULT_SOCKETQ / new->mss) -  (((uint16_t)(PICO_DEFAULT_SOCKETQ / new->mss)) >> 3u));\n    new->recv_wnd = short_be(hdr->rwnd);\n    new->linger_timeout = PICO_SOCKET_LINGER_TIMEOUT;\n    s->number_of_pending_conn++;\n    new->sock.parent = s;\n    new->sock.wakeup = s->wakeup;\n    rto_set(new, PICO_TCP_RTO_MIN);\n    /* Initialize timestamp values */\n    new->sock.state = PICO_SOCKET_STATE_BOUND | PICO_SOCKET_STATE_CONNECTED | PICO_SOCKET_STATE_TCP_SYN_RECV;\n    pico_socket_add(&new->sock);\n    tcp_send_synack(&new->sock);\n    tcp_dbg(\"SYNACK sent, socket added. snd_nxt is %08x\\n\", new->snd_nxt);\n    return 0;\n}", "target": 2, "idx": 11599}
{"commit_id": "09b9d4f1994a674c4ec85b4947aa656eda1aed8a", "project": "FreeRDP", "func": "static BOOL gdi_Bitmap_Decompress(rdpContext* context, rdpBitmap* bitmap,\n                                  const BYTE* pSrcData, UINT32 DstWidth, UINT32 DstHeight,\n                                  UINT32 bpp, UINT32 length, BOOL compressed,\n                                  UINT32 codecId)\n{\n\tUINT32 SrcSize = length;\n\trdpGdi* gdi = context->gdi;\n\tUINT32 size = DstWidth * DstHeight;\n\tbitmap->compressed = FALSE;\n\tbitmap->format = gdi->dstFormat;\n\n\tif ((GetBytesPerPixel(bitmap->format) == 0) ||\n\t    (DstWidth == 0) || (DstHeight == 0) || (DstWidth > UINT32_MAX / DstHeight) ||\n\t    (size > (UINT32_MAX / GetBytesPerPixel(bitmap->format))))\n\t\treturn FALSE;\n\n\tsize *= GetBytesPerPixel(bitmap->format);\n\tbitmap->length = size;\n\tbitmap->data = (BYTE*) _aligned_malloc(bitmap->length, 16);\n\n\tif (!bitmap->data)\n\t\treturn FALSE;\n\n\tif (compressed)\n\t{\n\t\tif (bpp < 32)\n\t\t{\n\t\t\tif (!interleaved_decompress(context->codecs->interleaved,\n\t\t\t                            pSrcData, SrcSize,\n\t\t\t                            DstWidth, DstHeight,\n\t\t\t                            bpp,\n\t\t\t                            bitmap->data, bitmap->format,\n\t\t\t                            0, 0, 0, DstWidth, DstHeight,\n\t\t\t                            &gdi->palette))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!planar_decompress(context->codecs->planar, pSrcData, SrcSize,\n\t\t\t                       DstWidth, DstHeight,\n\t\t\t                       bitmap->data, bitmap->format, 0, 0, 0,\n\t\t\t                       DstWidth, DstHeight, TRUE))\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tconst UINT32 SrcFormat = gdi_get_pixel_format(bpp);\n\t\tconst size_t sbpp = GetBytesPerPixel(SrcFormat);\n\t\tconst size_t dbpp = GetBytesPerPixel(bitmap->format);\n\n\t\tif ((sbpp == 0) || (dbpp == 0))\n\t\t\treturn FALSE;\n\t\telse\n\t\t{\n\t\t\tconst size_t dstSize = SrcSize * dbpp / sbpp;\n\n\t\t\tif (dstSize  < bitmap->length)\n\t\t\t\treturn FALSE;\n\t\t}\n\n\t\tif (!freerdp_image_copy(bitmap->data, bitmap->format, 0, 0, 0,\n\t\t                        DstWidth, DstHeight, pSrcData, SrcFormat,\n\t\t                        0, 0, 0, &gdi->palette, FREERDP_FLIP_VERTICAL))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}", "target": 3, "idx": 11600}
{"commit_id": "5af10dfd0afc559bb4b0f7e3e8227a1578333995", "project": "torvalds/linux", "func": "int hugetlb_mcopy_atomic_pte(struct mm_struct *dst_mm,\n\t\t\t    pte_t *dst_pte,\n\t\t\t    struct vm_area_struct *dst_vma,\n\t\t\t    unsigned long dst_addr,\n\t\t\t    unsigned long src_addr,\n\t\t\t    struct page **pagep)\n{\n\tint vm_shared = dst_vma->vm_flags & VM_SHARED;\n\tstruct hstate *h = hstate_vma(dst_vma);\n\tpte_t _dst_pte;\n\tspinlock_t *ptl;\n\tint ret;\n\tstruct page *page;\n\n\tif (!*pagep) {\n\t\tret = -ENOMEM;\n\t\tpage = alloc_huge_page(dst_vma, dst_addr, 0);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\n\t\tret = copy_huge_page_from_user(page,\n\t\t\t\t\t\t(const void __user *) src_addr,\n\t\t\t\t\t\tpages_per_huge_page(h), false);\n\n\t\t/* fallback to copy_from_user outside mmap_sem */\n\t\tif (unlikely(ret)) {\n\t\t\tret = -EFAULT;\n\t\t\t*pagep = page;\n\t\t\t/* don't free the page */\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tpage = *pagep;\n\t\t*pagep = NULL;\n\t}\n\n\t/*\n\t * The memory barrier inside __SetPageUptodate makes sure that\n\t * preceding stores to the page contents become visible before\n\t * the set_pte_at() write.\n\t */\n\t__SetPageUptodate(page);\n\tset_page_huge_active(page);\n\n\t/*\n\t * If shared, add to page cache\n\t */\n\tif (vm_shared) {\n\t\tstruct address_space *mapping = dst_vma->vm_file->f_mapping;\n\t\tpgoff_t idx = vma_hugecache_offset(h, dst_vma, dst_addr);\n\n\t\tret = huge_add_to_page_cache(page, mapping, idx);\n\t\tif (ret)\n\t\t\tgoto out_release_nounlock;\n\t}\n\n\tptl = huge_pte_lockptr(h, dst_mm, dst_pte);\n\tspin_lock(ptl);\n\n\tret = -EEXIST;\n\tif (!huge_pte_none(huge_ptep_get(dst_pte)))\n\t\tgoto out_release_unlock;\n\n\tif (vm_shared) {\n\t\tpage_dup_rmap(page, true);\n\t} else {\n\t\tClearPagePrivate(page);\n\t\thugepage_add_new_anon_rmap(page, dst_vma, dst_addr);\n\t}\n\n\t_dst_pte = make_huge_pte(dst_vma, page, dst_vma->vm_flags & VM_WRITE);\n\tif (dst_vma->vm_flags & VM_WRITE)\n\t\t_dst_pte = huge_pte_mkdirty(_dst_pte);\n\t_dst_pte = pte_mkyoung(_dst_pte);\n\n\tset_huge_pte_at(dst_mm, dst_addr, dst_pte, _dst_pte);\n\n\t(void)huge_ptep_set_access_flags(dst_vma, dst_addr, dst_pte, _dst_pte,\n\t\t\t\t\tdst_vma->vm_flags & VM_WRITE);\n\thugetlb_count_add(pages_per_huge_page(h), dst_mm);\n\n\t/* No need to invalidate - it was non-present before */\n\tupdate_mmu_cache(dst_vma, dst_addr, dst_pte);\n\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\n\tret = 0;\nout:\n\treturn ret;\nout_release_unlock:\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\nout_release_nounlock:\n\tput_page(page);\n\tgoto out;\n}", "target": 1, "idx": 11601}
{"commit_id": "d6d86830705f173fca6087a3e67ceaf68db80523", "project": "torvalds/linux", "func": "static int __tipc_sendmsg(struct socket *sock, struct msghdr *m, size_t dlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct net *net = sock_net(sk);\n\tstruct tipc_sock *tsk = tipc_sk(sk);\n\tstruct tipc_uaddr *ua = (struct tipc_uaddr *)m->msg_name;\n\tlong timeout = sock_sndtimeo(sk, m->msg_flags & MSG_DONTWAIT);\n\tstruct list_head *clinks = &tsk->cong_links;\n\tbool syn = !tipc_sk_type_connectionless(sk);\n\tstruct tipc_group *grp = tsk->group;\n\tstruct tipc_msg *hdr = &tsk->phdr;\n\tstruct tipc_socket_addr skaddr;\n\tstruct sk_buff_head pkts;\n\tint atype, mtu, rc;\n\n\tif (unlikely(dlen > TIPC_MAX_USER_MSG_SIZE))\n\t\treturn -EMSGSIZE;\n\n\tif (ua) {\n\t\tif (!tipc_uaddr_valid(ua, m->msg_namelen))\n\t\t\treturn -EINVAL;\n\t\tatype = ua->addrtype;\n\t}\n\n\t/* If socket belongs to a communication group follow other paths */\n\tif (grp) {\n\t\tif (!ua)\n\t\t\treturn tipc_send_group_bcast(sock, m, dlen, timeout);\n\t\tif (atype == TIPC_SERVICE_ADDR)\n\t\t\treturn tipc_send_group_anycast(sock, m, dlen, timeout);\n\t\tif (atype == TIPC_SOCKET_ADDR)\n\t\t\treturn tipc_send_group_unicast(sock, m, dlen, timeout);\n\t\tif (atype == TIPC_SERVICE_RANGE)\n\t\t\treturn tipc_send_group_mcast(sock, m, dlen, timeout);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ua) {\n\t\tua = (struct tipc_uaddr *)&tsk->peer;\n\t\tif (!syn && ua->family != AF_TIPC)\n\t\t\treturn -EDESTADDRREQ;\n\t\tatype = ua->addrtype;\n\t}\n\n\tif (unlikely(syn)) {\n\t\tif (sk->sk_state == TIPC_LISTEN)\n\t\t\treturn -EPIPE;\n\t\tif (sk->sk_state != TIPC_OPEN)\n\t\t\treturn -EISCONN;\n\t\tif (tsk->published)\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (atype == TIPC_SERVICE_ADDR)\n\t\t\ttsk->conn_addrtype = atype;\n\t\tmsg_set_syn(hdr, 1);\n\t}\n\n\tmemset(&skaddr, 0, sizeof(skaddr));\n\n\t/* Determine destination */\n\tif (atype == TIPC_SERVICE_RANGE) {\n\t\treturn tipc_sendmcast(sock, ua, m, dlen, timeout);\n\t} else if (atype == TIPC_SERVICE_ADDR) {\n\t\tskaddr.node = ua->lookup_node;\n\t\tua->scope = tipc_node2scope(skaddr.node);\n\t\tif (!tipc_nametbl_lookup_anycast(net, ua, &skaddr))\n\t\t\treturn -EHOSTUNREACH;\n\t} else if (atype == TIPC_SOCKET_ADDR) {\n\t\tskaddr = ua->sk;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Block or return if destination link is congested */\n\trc = tipc_wait_for_cond(sock, &timeout,\n\t\t\t\t!tipc_dest_find(clinks, skaddr.node, 0));\n\tif (unlikely(rc))\n\t\treturn rc;\n\n\t/* Finally build message header */\n\tmsg_set_destnode(hdr, skaddr.node);\n\tmsg_set_destport(hdr, skaddr.ref);\n\tif (atype == TIPC_SERVICE_ADDR) {\n\t\tmsg_set_type(hdr, TIPC_NAMED_MSG);\n\t\tmsg_set_hdr_sz(hdr, NAMED_H_SIZE);\n\t\tmsg_set_nametype(hdr, ua->sa.type);\n\t\tmsg_set_nameinst(hdr, ua->sa.instance);\n\t\tmsg_set_lookup_scope(hdr, ua->scope);\n\t} else { /* TIPC_SOCKET_ADDR */\n\t\tmsg_set_type(hdr, TIPC_DIRECT_MSG);\n\t\tmsg_set_lookup_scope(hdr, 0);\n\t\tmsg_set_hdr_sz(hdr, BASIC_H_SIZE);\n\t}\n\n\t/* Add message body */\n\t__skb_queue_head_init(&pkts);\n\tmtu = tipc_node_get_mtu(net, skaddr.node, tsk->portid, true);\n\trc = tipc_msg_build(hdr, m, 0, dlen, mtu, &pkts);\n\tif (unlikely(rc != dlen))\n\t\treturn rc;\n\tif (unlikely(syn && !tipc_msg_skb_clone(&pkts, &sk->sk_write_queue))) {\n\t\t__skb_queue_purge(&pkts);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Send message */\n\ttrace_tipc_sk_sendmsg(sk, skb_peek(&pkts), TIPC_DUMP_SK_SNDQ, \" \");\n\trc = tipc_node_xmit(net, &pkts, skaddr.node, tsk->portid);\n\tif (unlikely(rc == -ELINKCONG)) {\n\t\ttipc_dest_push(clinks, skaddr.node, 0);\n\t\ttsk->cong_link_cnt++;\n\t\trc = 0;\n\t}\n\n\tif (unlikely(syn && !rc)) {\n\t\ttipc_set_sk_state(sk, TIPC_CONNECTING);\n\t\tif (dlen && timeout) {\n\t\t\ttimeout = msecs_to_jiffies(timeout);\n\t\t\ttipc_wait_for_connect(sock, &timeout);\n\t\t}\n\t}\n\n\treturn rc ? rc : dlen;\n}", "target": 1, "idx": 11602}
{"commit_id": "edb251a7ef1602d20a5afcbf23f24afb163de63b", "project": "GNOME/gimp", "func": "void fli_read_lc_2(FILE *f, s_fli_header *fli_header, unsigned char *old_framebuf, unsigned char *framebuf)\n{\n\tunsigned short yc, lc, numline;\n\tunsigned char *pos;\n\tmemcpy(framebuf, old_framebuf, fli_header->width * fli_header->height);\n\tyc=0;\n\tnumline = fli_read_short(f);\n\tfor (lc=0; lc < numline; lc++) {\n\t\tunsigned short pc, pcnt, lpf, lpn;\n\t\tsize_t n, xc;\n\t\tpc=fli_read_short(f);\n\t\tlpf=0; lpn=0;\n\t\twhile (pc & 0x8000) {\n\t\t\tif (pc & 0x4000) {\n\t\t\t\tyc+=-(signed short)pc;\n\t\t\t} else {\n\t\t\t\tlpf=1;lpn=pc&0xFF;\n\t\t\t}\n\t\t\tpc=fli_read_short(f);\n\t\t}\n\t\tyc=MIN(yc, fli_header->height);\n\t\txc=0;\n\t\tpos=framebuf+(fli_header->width * yc);\n\t\tn=(size_t)fli_header->width * (fli_header->height-yc);\n\t\tfor (pcnt=pc; pcnt>0; pcnt--) {\n\t\t\tunsigned short ps,skip;\n\t\t\tskip=fli_read_char(f);\n\t\t\tps=fli_read_char(f);\n\t\t\txc+=MIN(n-xc,skip);\n\t\t\tif (ps & 0x80) {\n\t\t\t\tunsigned char v1,v2;\n\t\t\t\tps=-(signed char)ps;\n\t\t\t\tv1=fli_read_char(f);\n\t\t\t\tv2=fli_read_char(f);\n\t\t\t\twhile (ps>0 && xc+1<n) {\n\t\t\t\t\tpos[xc++]=v1;\n\t\t\t\t\tpos[xc++]=v2;\n\t\t\t\t\tps--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsize_t len;\n\t\t\t\tlen=MIN((n-xc)/2,ps);\n\t\t\t\tfread(&(pos[xc]), len, 2, f);\n\t\t\t\txc+=len << 1;\n\t\t\t}\n\t\t}\n\t\tif (lpf) pos[xc]=lpn;\n\t\tyc++;\n\t}\n}", "target": 2, "idx": 11603}
{"commit_id": "f843ee6dd019bcece3e74e76ad9df0155655d0df", "project": "torvalds/linux", "func": "static inline int xfrm_replay_verify_len(struct xfrm_replay_state_esn *replay_esn,\n\t\t\t\t\t struct nlattr *rp)\n{\n\tstruct xfrm_replay_state_esn *up;\n\tint ulen;\n\n\tif (!replay_esn || !rp)\n\t\treturn 0;\n\n\tup = nla_data(rp);\n\tulen = xfrm_replay_state_esn_len(up);\n\n\t/* Check the overall length and the internal bitmap length to avoid\n\t * potential overflow. */\n\tif (nla_len(rp) < ulen ||\n\t    xfrm_replay_state_esn_len(replay_esn) != ulen ||\n\t    replay_esn->bmp_len != up->bmp_len)\n\t\treturn -EINVAL;\n\n\tif (up->replay_window > up->bmp_len * sizeof(__u32) * 8)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}", "target": 2, "idx": 11604}
{"commit_id": "58fd993a89a3a22fa5a4a1a4548125c6783ec80c", "project": "android", "func": "String8 MetaDataBase::toString() const {\n    String8 s;\n    std::lock_guard<std::mutex> guard(mInternalData->mLock);\n    for (int i = mInternalData->mItems.size(); --i >= 0;) {\n        int32_t key = mInternalData->mItems.keyAt(i);\n        char cc[5];\n        MakeFourCCString(key, cc);\n        const typed_data &item = mInternalData->mItems.valueAt(i);\n        s.appendFormat(\"%s: %s\", cc, item.asString(false).string());\n        if (i != 0) {\n            s.append(\", \");\n        }\n    }\n    return s;\n}", "target": 2, "idx": 11605}
{"commit_id": "b3b29ce8f3acf3a32733d930105a17d7b0ba347e", "project": "yhirose/cpp-peglib", "func": "inline size_t codepoint_length(const char *s8, size_t l) {\n  if (l) {\n    auto b = static_cast<uint8_t>(s8[0]);\n    if ((b & 0x80) == 0) {\n      return 1;\n    } else if ((b & 0xE0) == 0xC0 && l >= 2) {\n      return 2;\n    } else if ((b & 0xF0) == 0xE0 && l >= 3) {\n      return 3;\n    } else if ((b & 0xF8) == 0xF0 && l >= 4) {\n      return 4;\n    }\n  }\n  return 0;\n}", "target": 1, "idx": 11606}
{"commit_id": "0ace17d56824165c7f4c68785d6b58971db954dd", "project": "torvalds/linux", "func": "static void slip_write_wakeup(struct tty_struct *tty)\n{\n\tstruct slip *sl;\n\n\trcu_read_lock();\n\tsl = rcu_dereference(tty->disc_data);\n\tif (!sl)\n\t\tgoto out;\n\n\tschedule_work(&sl->tx_work);\nout:\n\trcu_read_unlock();\n}", "target": 1, "idx": 11607}
{"commit_id": "8bc1379b82b8e809eef77a9fedbb75c6c297be19", "project": "torvalds/linux", "func": "int ext4_da_write_inline_data_begin(struct address_space *mapping,\n\t\t\t\t    struct inode *inode,\n\t\t\t\t    loff_t pos, unsigned len,\n\t\t\t\t    unsigned flags,\n\t\t\t\t    struct page **pagep,\n\t\t\t\t    void **fsdata)\n{\n\tint ret, inline_size;\n\thandle_t *handle;\n\tstruct page *page;\n\tstruct ext4_iloc iloc;\n\tint retries;\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\treturn ret;\n\nretry_journal:\n\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 1);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto out;\n\t}\n\n\tinline_size = ext4_get_max_inline_size(inode);\n\n\tret = -ENOSPC;\n\tif (inline_size >= pos + len) {\n\t\tret = ext4_prepare_inline_data(handle, inode, pos + len);\n\t\tif (ret && ret != -ENOSPC)\n\t\t\tgoto out_journal;\n\t}\n\n\t/*\n\t * We cannot recurse into the filesystem as the transaction\n\t * is already started.\n\t */\n\tflags |= AOP_FLAG_NOFS;\n\n\tif (ret == -ENOSPC) {\n\t\text4_journal_stop(handle);\n\t\tret = ext4_da_convert_inline_data_to_extent(mapping,\n\t\t\t\t\t\t\t    inode,\n\t\t\t\t\t\t\t    flags,\n\t\t\t\t\t\t\t    fsdata);\n\t\tif (ret == -ENOSPC &&\n\t\t    ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\t\tgoto retry_journal;\n\t\tgoto out;\n\t}\n\n\n\tpage = grab_cache_page_write_begin(mapping, 0, flags);\n\tif (!page) {\n\t\tret = -ENOMEM;\n\t\tgoto out_journal;\n\t}\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\tif (!ext4_has_inline_data(inode)) {\n\t\tret = 0;\n\t\tgoto out_release_page;\n\t}\n\n\tif (!PageUptodate(page)) {\n\t\tret = ext4_read_inline_page(inode, page);\n\t\tif (ret < 0)\n\t\t\tgoto out_release_page;\n\t}\n\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\t*pagep = page;\n\tbrelse(iloc.bh);\n\treturn 1;\nout_release_page:\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\tunlock_page(page);\n\tput_page(page);\nout_journal:\n\text4_journal_stop(handle);\nout:\n\tbrelse(iloc.bh);\n\treturn ret;\n}", "target": 1, "idx": 11608}
{"commit_id": "7e112c1563632f57cfa1c4fa964987f823da17fa", "project": "chromium", "func": "void PasswordGenerationAgent::OnUserTriggeredGeneratePassword() {\n  if (last_focused_password_element_.isNull() || !render_frame())\n    return;\n\n  blink::WebFormElement form = last_focused_password_element_.form();\n  std::unique_ptr<PasswordForm> password_form;\n  std::vector<blink::WebFormControlElement> control_elements;\n  if (!form.isNull()) {\n    password_form = CreatePasswordFormFromWebForm(form, nullptr, nullptr);\n    control_elements = form_util::ExtractAutofillableElementsInForm(form);\n  } else {\n    const blink::WebFrame& frame = *render_frame()->GetWebFrame();\n    blink::WebDocument doc = frame.document();\n    if (doc.isNull())\n      return;\n    password_form =\n        CreatePasswordFormFromUnownedInputElements(frame, nullptr, nullptr);\n    control_elements =\n        form_util::GetUnownedFormFieldElements(doc.all(), nullptr);\n  }\n\n  if (!password_form)\n    return;\n\n  generation_element_ = last_focused_password_element_;\n  std::vector<blink::WebInputElement> password_elements;\n  GetAccountCreationPasswordFields(control_elements, &password_elements);\n  password_elements = FindPasswordElementsForGeneration(\n      password_elements, last_focused_password_element_.nameForAutofill());\n  generation_form_data_.reset(new AccountCreationFormData(\n      make_linked_ptr(password_form.release()), password_elements));\n  is_manually_triggered_ = true;\n  ShowGenerationPopup();\n}", "target": 2, "idx": 11609}
{"commit_id": "6b485b146a1b9d6ce72dfd7b5f36456c166e7a16", "project": "FreeRDP", "func": "BOOL nego_read_request(rdpNego* nego, wStream* s)\n{\n\tBYTE li;\n\tBYTE type;\n\tUINT16 length;\n\n\tif (!tpkt_read_header(s, &length))\n\t\treturn FALSE;\n\n\tif (!tpdu_read_connection_request(s, &li, length))\n\t\treturn FALSE;\n\n\tif (li != Stream_GetRemainingLength(s) + 6)\n\t{\n\t\tWLog_ERR(TAG, \"Incorrect TPDU length indicator.\");\n\t\treturn FALSE;\n\t}\n\n\tif (!nego_read_request_token_or_cookie(nego, s))\n\t{\n\t\tWLog_ERR(TAG, \"Failed to parse routing token or cookie.\");\n\t\treturn FALSE;\n\t}\n\n\tif (Stream_GetRemainingLength(s) >= 8)\n\t{\n\t\t/* rdpNegData (optional) */\n\t\tStream_Read_UINT8(s, type); /* Type */\n\n\t\tif (type != TYPE_RDP_NEG_REQ)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Incorrect negotiation request type %\" PRIu8 \"\", type);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tif (!nego_process_negotiation_request(nego, s))\n\t\t\treturn FALSE;\n\t}\n\n\treturn tpkt_ensure_stream_consumed(s, length);\n}", "target": 0, "idx": 11610}
{"commit_id": "1b98172b141fe874ad43e679e67506f9b2139043", "project": "c-ares", "func": "int\nares_parse_soa_reply(const unsigned char *abuf, int alen,\n\t\t     struct ares_soa_reply **soa_out)\n{\n  const unsigned char *aptr;\n  long len;\n  char *qname = NULL, *rr_name = NULL;\n  struct ares_soa_reply *soa = NULL;\n  int qdcount, ancount, qclass;\n  int status, i, rr_type, rr_class, rr_len;\n\n  if (alen < HFIXEDSZ)\n    return ARES_EBADRESP;\n\n  /* parse message header */\n  qdcount = DNS_HEADER_QDCOUNT(abuf);\n  ancount = DNS_HEADER_ANCOUNT(abuf);\n\n  if (qdcount != 1)\n    return ARES_EBADRESP;\n  if (ancount == 0)\n    return ARES_EBADRESP;\n  \n  aptr = abuf + HFIXEDSZ;\n\n  /* query name */\n  status = ares__expand_name_for_response(aptr, abuf, alen, &qname, &len);\n  if (status != ARES_SUCCESS)\n    goto failed_stat;\n\n  if (alen <= len + HFIXEDSZ + 1)\n    goto failed;\n  aptr += len;\n\n  qclass = DNS_QUESTION_TYPE(aptr);\n\n  /* skip qtype & qclass */\n  if (aptr + QFIXEDSZ > abuf + alen)\n    goto failed;\n  aptr += QFIXEDSZ;\n\n  /* qclass of SOA with multiple answers */\n  if (qclass == T_SOA && ancount > 1)\n    goto failed;\n\n  /* examine all the records, break and return if found soa */\n  for (i = 0; i < ancount; i++)\n  {\n    rr_name = NULL;\n    status  = ares__expand_name_for_response (aptr, abuf, alen, &rr_name, &len);\n    if (status != ARES_SUCCESS)\n     {\n      ares_free(rr_name);\n      goto failed_stat;\n     }\n\n    aptr += len;\n    if ( aptr + RRFIXEDSZ > abuf + alen )\n    {\n      ares_free(rr_name);\n      status = ARES_EBADRESP;\n      goto failed_stat;\n    }\n    rr_type = DNS_RR_TYPE( aptr );\n    rr_class = DNS_RR_CLASS( aptr );\n    rr_len = DNS_RR_LEN( aptr );\n    aptr += RRFIXEDSZ;\n    if (aptr + rr_len > abuf + alen)\n      {\n        ares_free(rr_name);\n        status = ARES_EBADRESP;\n        goto failed_stat;\n      }\n    if ( rr_class == C_IN && rr_type == T_SOA )\n    {\n      /* allocate result struct */\n      soa = ares_malloc_data(ARES_DATATYPE_SOA_REPLY);\n      if (!soa)\n        {\n          ares_free(rr_name);\n          status = ARES_ENOMEM;\n          goto failed_stat;\n        }\n\n      /* nsname */\n      status = ares__expand_name_for_response(aptr, abuf, alen, &soa->nsname,\n                                               &len);\n      if (status != ARES_SUCCESS)\n       {\n        ares_free(rr_name);\n        goto failed_stat;\n       }\n      aptr += len;\n\n      /* hostmaster */\n      status = ares__expand_name_for_response(aptr, abuf, alen,\n                                               &soa->hostmaster, &len);\n      if (status != ARES_SUCCESS)\n       {\n        ares_free(rr_name);\n        goto failed_stat;\n       }\n      aptr += len;\n\n      /* integer fields */\n      if (aptr + 5 * 4 > abuf + alen)\n       {\n        ares_free(rr_name);\n        goto failed;\n       }\n      soa->serial = DNS__32BIT(aptr + 0 * 4);\n      soa->refresh = DNS__32BIT(aptr + 1 * 4);\n      soa->retry = DNS__32BIT(aptr + 2 * 4);\n      soa->expire = DNS__32BIT(aptr + 3 * 4);\n      soa->minttl = DNS__32BIT(aptr + 4 * 4);\n\n      ares_free(qname);\n      ares_free(rr_name);\n\n      *soa_out = soa;\n\n      return ARES_SUCCESS;\n    }\n    aptr += rr_len;\n    \n    ares_free(rr_name);\n    \n    if (aptr > abuf + alen)\n      goto failed_stat;\n  }\n  /* no SOA record found */\n  status = ARES_EBADRESP;\n  goto failed_stat;\nfailed:\n  status = ARES_EBADRESP;\n\nfailed_stat:\n  if (soa)\n    ares_free_data(soa);\n  if (qname)\n    ares_free(qname);\n  return status;\n}", "target": 3, "idx": 11611}
{"commit_id": "229abab99f39f11624e5651f819e7f1f8eddedcc", "project": "debauchee/barrier", "func": "void MainWindow::checkFingerprint(const QString& line)\n{\n    QRegExp fingerprintRegex(\".*peer fingerprint \\\\(SHA1\\\\): ([A-F0-9:]+) \\\\(SHA256\\\\): ([A-F0-9:]+)\");\n    if (!fingerprintRegex.exactMatch(line)) {\n        return;\n    }\n\n    barrier::FingerprintData fingerprint_sha1 = {\n        barrier::fingerprint_type_to_string(barrier::FingerprintType::SHA1),\n        barrier::string::from_hex(fingerprintRegex.cap(1).toStdString())\n    };\n\n    barrier::FingerprintData fingerprint_sha256 = {\n        barrier::fingerprint_type_to_string(barrier::FingerprintType::SHA256),\n        barrier::string::from_hex(fingerprintRegex.cap(2).toStdString())\n    };\n\n    bool is_client = barrierType() == barrierClient;\n\n    auto db_path = is_client\n            ? barrier::DataDirectories::trusted_servers_ssl_fingerprints_path()\n            : barrier::DataDirectories::trusted_clients_ssl_fingerprints_path();\n\n    auto db_dir = db_path.parent_path();\n    if (!barrier::fs::exists(db_dir)) {\n        barrier::fs::create_directories(db_dir);\n    }\n\n    // We compare only SHA256 fingerprints, but show both SHA1 and SHA256 so that the users can\n    // still verify fingerprints on old Barrier servers. This way the only time when we are exposed\n    // to SHA1 vulnerabilities is when the user is reconnecting again.\n    barrier::FingerprintDatabase db;\n    db.read(db_path);\n    if (db.is_trusted(fingerprint_sha256)) {\n        return;\n    }\n\n    static bool messageBoxAlreadyShown = false;\n\n    if (!messageBoxAlreadyShown) {\n        if (is_client) {\n            stopBarrier();\n        }\n\n        QString message;\n        if (is_client) {\n            message = tr(\"Do you trust this fingerprint?\\n\\n\"\n               \"SHA256:\\n\"\n               \"%1\\n\"\n               \"%2\\n\\n\"\n               \"SHA1 (obsolete, when using old Barrier client):\\n\"\n               \"%3\\n\\n\"\n               \"This is a server fingerprint. You should compare this \"\n               \"fingerprint to the one on your server's screen. If the \"\n               \"two don't match exactly, then it's probably not the server \"\n               \"you're expecting (it could be a malicious user).\\n\\n\"\n               \"To automatically trust this fingerprint for future \"\n               \"connections, click Yes. To reject this fingerprint and \"\n               \"disconnect from the server, click No.\")\n            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha256.data)))\n            .arg(QString::fromStdString(\n                     barrier::create_fingerprint_randomart(fingerprint_sha256.data)))\n            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha1.data)));\n        } else {\n            message = tr(\"Do you trust this fingerprint?\\n\\n\"\n               \"SHA256:\\n\"\n               \"%1\\n\"\n               \"%2\\n\\n\"\n               \"This is a client fingerprint. You should compare this \"\n               \"fingerprint to the one on your client's screen. If the \"\n               \"two don't match exactly, then it's probably not the client \"\n               \"you're expecting (it could be a malicious user).\\n\\n\"\n               \"To automatically trust this fingerprint for future \"\n               \"connections, click Yes. To reject this fingerprint and \"\n               \"disconnect the client, click No.\")\n            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha256.data)))\n            .arg(QString::fromStdString(\n                     barrier::create_fingerprint_randomart(fingerprint_sha256.data)));\n        }\n\n        messageBoxAlreadyShown = true;\n        QMessageBox::StandardButton fingerprintReply =\n            QMessageBox::information(\n            this, tr(\"Security question\"),\n            message,\n            QMessageBox::Yes | QMessageBox::No);\n\n        if (fingerprintReply == QMessageBox::Yes) {\n            // restart core process after trusting fingerprint.\n            db.add_trusted(fingerprint_sha256);\n            db.write(db_path);\n            if (is_client) {\n                startBarrier();\n            }\n        }\n\n        messageBoxAlreadyShown = false;\n    }\n}", "target": 2, "idx": 11612}
{"commit_id": "beacc44eb8cdf6d58717ec1a5103c5141f1b37f9", "project": "antlarr/audiofile", "func": "int MSADPCM::decodeBlock(const uint8_t *encoded, int16_t *decoded)\n{\n\tms_adpcm_state decoderState[2];\n\tms_adpcm_state *state[2];\n\n\tint channelCount = m_track->f.channelCount;\n\n\t// Calculate the number of bytes needed for decoded data.\n\tint outputLength = m_framesPerPacket * sizeof (int16_t) * channelCount;\n\n\tstate[0] = &decoderState[0];\n\tif (channelCount == 2)\n\t\tstate[1] = &decoderState[1];\n\telse\n\t\tstate[1] = &decoderState[0];\n\n\t// Initialize block predictor.\n\tfor (int i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->predictorIndex = *encoded++;\n\t\tassert(state[i]->predictorIndex < m_numCoefficients);\n\t}\n\n\t// Initialize delta.\n\tfor (int i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->delta = (encoded[1]<<8) | encoded[0];\n\t\tencoded += sizeof (uint16_t);\n\t}\n\n\t// Initialize first two samples.\n\tfor (int i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->sample1 = (encoded[1]<<8) | encoded[0];\n\t\tencoded += sizeof (uint16_t);\n\t}\n\n\tfor (int i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->sample2 = (encoded[1]<<8) | encoded[0];\n\t\tencoded += sizeof (uint16_t);\n\t}\n\n\tconst int16_t *coefficient[2] =\n\t{\n\t\tm_coefficients[state[0]->predictorIndex],\n\t\tm_coefficients[state[1]->predictorIndex]\n\t};\n\n\tfor (int i=0; i<channelCount; i++)\n\t\t*decoded++ = state[i]->sample2;\n\n\tfor (int i=0; i<channelCount; i++)\n\t\t*decoded++ = state[i]->sample1;\n\n\t/*\n\t\tThe first two samples have already been 'decoded' in\n\t\tthe block header.\n\t*/\n\tint samplesRemaining = (m_framesPerPacket - 2) * m_track->f.channelCount;\n\n\twhile (samplesRemaining > 0)\n\t{\n\t\tuint8_t code;\n\t\tint16_t newSample;\n\t\tbool ok;\n\n\t\tcode = *encoded >> 4;\n\t\tnewSample = decodeSample(*state[0], code, coefficient[0], &ok);\n\t\tif (!ok) return 0;\n\t\t*decoded++ = newSample;\n\n\t\tcode = *encoded & 0x0f;\n\t\tnewSample = decodeSample(*state[1], code, coefficient[1], &ok);\n\t\tif (!ok) return 0;\n\t\t*decoded++ = newSample;\n\n\t\tencoded++;\n\t\tsamplesRemaining -= 2;\n\t}\n\n\treturn outputLength;\n}", "target": 1, "idx": 11613}
{"commit_id": "e678873", "project": "quassel", "func": "void CoreAuthHandler::onReadyRead()\n{\n    if (socket()->bytesAvailable() < 4)\n        return;\n\n    // once we have selected a peer, we certainly don't want to read more data!\n    if (_peer)\n        return;\n\n    if (!_magicReceived) {\n        quint32 magic;\n        socket()->peek((char*)&magic, 4);\n        magic = qFromBigEndian<quint32>(magic);\n\n        if ((magic & 0xffffff00) != Protocol::magic) {\n            // no magic, assume legacy protocol\n            qDebug() << \"Legacy client detected, switching to compatibility mode\";\n            _legacy = true;\n            RemotePeer *peer = PeerFactory::createPeer(PeerFactory::ProtoDescriptor(Protocol::LegacyProtocol, 0), this, socket(), Compressor::NoCompression, this);\n            connect(peer, SIGNAL(protocolVersionMismatch(int,int)), SLOT(onProtocolVersionMismatch(int,int)));\n            setPeer(peer);\n            return;\n        }\n\n        _magicReceived = true;\n        quint8 features = magic & 0xff;\n        // figure out which connection features we'll use based on the client's support\n        if (Core::sslSupported() && (features & Protocol::Encryption))\n            _connectionFeatures |= Protocol::Encryption;\n        if (features & Protocol::Compression)\n            _connectionFeatures |= Protocol::Compression;\n\n        socket()->read((char*)&magic, 4); // read the 4 bytes we've just peeked at\n    }\n\n    // read the list of protocols supported by the client\n    while (socket()->bytesAvailable() >= 4 && _supportedProtos.size() < 16) { // sanity check\n        quint32 data;\n        socket()->read((char*)&data, 4);\n        data = qFromBigEndian<quint32>(data);\n\n        Protocol::Type type = static_cast<Protocol::Type>(data & 0xff);\n        quint16 protoFeatures = static_cast<quint16>(data>>8 & 0xffff);\n        _supportedProtos.append(PeerFactory::ProtoDescriptor(type, protoFeatures));\n\n        if (data >= 0x80000000) { // last protocol\n            Compressor::CompressionLevel level;\n            if (_connectionFeatures & Protocol::Compression)\n                level = Compressor::BestCompression;\n            else\n                level = Compressor::NoCompression;\n\n            RemotePeer *peer = PeerFactory::createPeer(_supportedProtos, this, socket(), level, this);\n            if (!peer) {\n                qWarning() << \"Received invalid handshake data from client\" << socket()->peerAddress().toString();\n                close();\n                return;\n            }\n\n            if (peer->protocol() == Protocol::LegacyProtocol) {\n                _legacy = true;\n                connect(peer, SIGNAL(protocolVersionMismatch(int,int)), SLOT(onProtocolVersionMismatch(int,int)));\n            }\n            setPeer(peer);\n\n            // inform the client\n            quint32 reply = peer->protocol() | peer->enabledFeatures()<<8 | _connectionFeatures<<24;\n            reply = qToBigEndian<quint32>(reply);\n            socket()->write((char*)&reply, 4);\n            socket()->flush();\n\n            if (!_legacy && (_connectionFeatures & Protocol::Encryption))\n                startSsl(); // legacy peer enables it later\n            return;\n        }\n    }\n}", "target": 2, "idx": 11614}
{"commit_id": "759c01142a5d0f364a462346168a56de28a80f52", "project": "torvalds/linux", "func": "struct pipe_inode_info *alloc_pipe_info(void)\n{\n\tstruct pipe_inode_info *pipe;\n\n\tpipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL);\n\tif (pipe) {\n\t\tunsigned long pipe_bufs = PIPE_DEF_BUFFERS;\n\t\tstruct user_struct *user = get_current_user();\n\n\t\tif (!too_many_pipe_buffers_hard(user)) {\n\t\t\tif (too_many_pipe_buffers_soft(user))\n\t\t\t\tpipe_bufs = 1;\n\t\t\tpipe->bufs = kzalloc(sizeof(struct pipe_buffer) * pipe_bufs, GFP_KERNEL);\n\t\t}\n\n\t\tif (pipe->bufs) {\n\t\t\tinit_waitqueue_head(&pipe->wait);\n\t\t\tpipe->r_counter = pipe->w_counter = 1;\n\t\t\tpipe->buffers = pipe_bufs;\n\t\t\tpipe->user = user;\n\t\t\taccount_pipe_buffers(pipe, 0, pipe_bufs);\n\t\t\tmutex_init(&pipe->mutex);\n\t\t\treturn pipe;\n\t\t}\n\t\tfree_uid(user);\n\t\tkfree(pipe);\n\t}\n\n\treturn NULL;\n}", "target": 1, "idx": 11615}
{"commit_id": "e996e322ffd42aaa051602da182d03178d0f13e1", "project": "wget", "func": "static uerr_t\nftp_retrieve_glob (struct url *u, struct url *original_url,\n                   ccon *con, int action)\n{\n  struct fileinfo *f, *start;\n  uerr_t res;\n\n  con->cmd |= LEAVE_PENDING;\n\n  res = ftp_get_listing (u, original_url, con, &start);\n  if (res != RETROK)\n    return res;\n  /* First: weed out that do not conform the global rules given in\n     opt.accepts and opt.rejects.  */\n  if (opt.accepts || opt.rejects)\n    {\n      f = start;\n      while (f)\n        {\n          if (f->type != FT_DIRECTORY && !acceptable (f->name))\n            {\n              logprintf (LOG_VERBOSE, _(\"Rejecting %s.\\n\"),\n                         quote (f->name));\n              f = delelement (f, &start);\n            }\n          else\n            f = f->next;\n        }\n    }\n  /* Remove all files with possible harmful names or invalid entries. */\n  f = start;\n  while (f)\n    {\n      if (has_insecure_name_p (f->name) || is_invalid_entry (f))\n        {\n          logprintf (LOG_VERBOSE, _(\"Rejecting %s.\\n\"),\n                     quote (f->name));\n          f = delelement (f, &start);\n        }\n      else\n        f = f->next;\n    }\n  /* Now weed out the files that do not match our globbing pattern.\n     If we are dealing with a globbing pattern, that is.  */\n  if (*u->file)\n    {\n      if (action == GLOB_GLOBALL)\n        {\n          int (*matcher) (const char *, const char *, int)\n            = opt.ignore_case ? fnmatch_nocase : fnmatch;\n          int matchres = 0;\n\n          f = start;\n          while (f)\n            {\n              matchres = matcher (u->file, f->name, 0);\n              if (matchres == -1)\n                {\n                  logprintf (LOG_NOTQUIET, _(\"Error matching %s against %s: %s\\n\"),\n                             u->file, quotearg_style (escape_quoting_style, f->name),\n                             strerror (errno));\n                  break;\n                }\n              if (matchres == FNM_NOMATCH)\n                f = delelement (f, &start); /* delete the element from the list */\n              else\n                f = f->next;        /* leave the element in the list */\n            }\n          if (matchres == -1)\n            {\n              freefileinfo (start);\n              return RETRBADPATTERN;\n            }\n        }\n      else if (action == GLOB_GETONE)\n        {\n#ifdef __VMS\n          /* 2009-09-09 SMS.\n           * Odd-ball compiler (\"HP C V7.3-009 on OpenVMS Alpha V7.3-2\")\n           * bug causes spurious %CC-E-BADCONDIT complaint with this\n           * \"?:\" statement.  (Different linkage attributes for strcmp()\n           * and strcasecmp().)  Converting to \"if\" changes the\n           * complaint to %CC-W-PTRMISMATCH on \"cmp = strcmp;\".  Adding\n           * the senseless type cast clears the complaint, and looks\n           * harmless.\n           */\n          int (*cmp) (const char *, const char *)\n            = opt.ignore_case ? strcasecmp : (int (*)())strcmp;\n#else /* def __VMS */\n          int (*cmp) (const char *, const char *)\n            = opt.ignore_case ? strcasecmp : strcmp;\n#endif /* def __VMS [else] */\n          f = start;\n          while (f)\n            {\n              if (0 != cmp(u->file, f->name))\n                f = delelement (f, &start);\n              else\n                f = f->next;\n            }\n        }\n    }\n  if (start)\n    {\n      /* Just get everything.  */\n      res = ftp_retrieve_list (u, original_url, start, con);\n    }\n  else\n    {\n      if (action == GLOB_GLOBALL)\n        {\n          /* No luck.  */\n          /* #### This message SUCKS.  We should see what was the\n             reason that nothing was retrieved.  */\n          logprintf (LOG_VERBOSE, _(\"No matches on pattern %s.\\n\"),\n                     quote (u->file));\n        }\n      else if (action == GLOB_GETONE) /* GLOB_GETONE or GLOB_GETALL */\n        {\n          /* Let's try retrieving it anyway.  */\n          con->st |= ON_YOUR_OWN;\n          res = ftp_loop_internal (u, original_url, NULL, con, NULL, false);\n          return res;\n        }\n\n      /* If action == GLOB_GETALL, and the file list is empty, there's\n         no point in trying to download anything or in complaining about\n         it.  (An empty directory should not cause complaints.)\n      */\n    }\n  freefileinfo (start);\n  if (opt.quota && total_downloaded_bytes > opt.quota)\n    return QUOTEXC;\n  else\n    return res;\n}", "target": 2, "idx": 11616}
{"commit_id": "881b5b03a590198d03008e4200dd00cc537712f3", "project": "PowerDNS/pdns", "func": "string PacketReader::getLabel(unsigned int recurs)\n{\n  string ret;\n  size_t wirelength = 0;\n  ret.reserve(40);\n  getLabelFromContent(d_content, d_pos, ret, recurs++, wirelength);\n  return ret;\n}", "target": 2, "idx": 11617}
{"commit_id": "42cb14b110a5698ccf26ce59c4441722605a3743", "project": "torvalds/linux", "func": "void migrate_page_copy(struct page *newpage, struct page *page)\n{\n\tint cpupid;\n\n\tif (PageHuge(page) || PageTransHuge(page))\n\t\tcopy_huge_page(newpage, page);\n\telse\n\t\tcopy_highpage(newpage, page);\n\n\tif (PageError(page))\n\t\tSetPageError(newpage);\n\tif (PageReferenced(page))\n\t\tSetPageReferenced(newpage);\n\tif (PageUptodate(page))\n\t\tSetPageUptodate(newpage);\n\tif (TestClearPageActive(page)) {\n\t\tVM_BUG_ON_PAGE(PageUnevictable(page), page);\n\t\tSetPageActive(newpage);\n\t} else if (TestClearPageUnevictable(page))\n\t\tSetPageUnevictable(newpage);\n\tif (PageChecked(page))\n\t\tSetPageChecked(newpage);\n\tif (PageMappedToDisk(page))\n\t\tSetPageMappedToDisk(newpage);\n\n\t/* Move dirty on pages not done by migrate_page_move_mapping() */\n\tif (PageDirty(page))\n\t\tSetPageDirty(newpage);\n\n\tif (page_is_young(page))\n\t\tset_page_young(newpage);\n\tif (page_is_idle(page))\n\t\tset_page_idle(newpage);\n\n\t/*\n\t * Copy NUMA information to the new page, to prevent over-eager\n\t * future migrations of this same page.\n\t */\n\tcpupid = page_cpupid_xchg_last(page, -1);\n\tpage_cpupid_xchg_last(newpage, cpupid);\n\n\tksm_migrate_page(newpage, page);\n\t/*\n\t * Please do not reorder this without considering how mm/ksm.c's\n\t * get_ksm_page() depends upon ksm_migrate_page() and PageSwapCache().\n\t */\n\tif (PageSwapCache(page))\n\t\tClearPageSwapCache(page);\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\n\t/*\n\t * If any waiters have accumulated on the new page then\n\t * wake them up.\n\t */\n\tif (PageWriteback(newpage))\n\t\tend_page_writeback(newpage);\n}", "target": 2, "idx": 11618}
{"commit_id": "4435b9142ff9813845d5c97ab29a5d637bedb257", "project": "php/php-src", "func": "static void php_hash_do_hash(INTERNAL_FUNCTION_PARAMETERS, int isfilename, zend_bool raw_output_default) /* {{{ */\n{\n\tchar *algo, *data, *digest;\n\tint algo_len, data_len;\n\tzend_bool raw_output = raw_output_default;\n\tconst php_hash_ops *ops;\n\tvoid *context;\n\tphp_stream *stream = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ss|b\", &algo, &algo_len, &data, &data_len, &raw_output) == FAILURE) {\n\t\treturn;\n\t}\n\n\tops = php_hash_fetch_ops(algo, algo_len);\n\tif (!ops) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown hashing algorithm: %s\", algo);\n\t\tRETURN_FALSE;\n\t}\n\tif (isfilename) {\n\t\tif (CHECK_NULL_PATH(data, data_len)) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid path\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tstream = php_stream_open_wrapper_ex(data, \"rb\", REPORT_ERRORS, NULL, DEFAULT_CONTEXT);\n\t\tif (!stream) {\n\t\t\t/* Stream will report errors opening file */\n\t\t\tRETURN_FALSE;\n\t\t}\n\t}\n\n\tcontext = emalloc(ops->context_size);\n\tops->hash_init(context);\n\n\tif (isfilename) {\n\t\tchar buf[1024];\n\t\tint n;\n\n\t\twhile ((n = php_stream_read(stream, buf, sizeof(buf))) > 0) {\n\t\t\tops->hash_update(context, (unsigned char *) buf, n);\n\t\t}\n\t\tphp_stream_close(stream);\n\t} else {\n\t\tops->hash_update(context, (unsigned char *) data, data_len);\n\t}\n\n\tdigest = emalloc(ops->digest_size + 1);\n\tops->hash_final((unsigned char *) digest, context);\n\tefree(context);\n\n\tif (raw_output) {\n\t\tdigest[ops->digest_size] = 0;\n\t\tRETURN_STRINGL(digest, ops->digest_size, 0);\n\t} else {\n\t\tchar *hex_digest = safe_emalloc(ops->digest_size, 2, 1);\n\n\t\tphp_hash_bin2hex(hex_digest, (unsigned char *) digest, ops->digest_size);\n\t\thex_digest[2 * ops->digest_size] = 0;\n\t\tefree(digest);\n\t\tRETURN_STRINGL(hex_digest, 2 * ops->digest_size, 0);\n\t}\n}", "target": 1, "idx": 11619}
{"commit_id": "a6981567e8e215acc1ef690c8dbb30f2d9b00a19", "project": "openbsd/src", "func": "static void\nprocess_open(u_int32_t id)\n{\n\tu_int32_t pflags;\n\tAttrib a;\n\tchar *name;\n\tint r, handle, fd, flags, mode, status = SSH2_FX_FAILURE;\n\n\tif ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(iqueue, &pflags)) != 0 || /* portable flags */\n\t    (r = decode_attrib(iqueue, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"request %u: open flags %d\", id, pflags);\n\tflags = flags_from_portable(pflags);\n\tmode = (a.flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ? a.perm : 0666;\n\tlogit(\"open \\\"%s\\\" flags %s mode 0%o\",\n\t    name, string_from_portable(pflags), mode);\n\tif (readonly &&\n\t    ((flags & O_ACCMODE) != O_RDONLY ||\n\t    (flags & (O_CREAT|O_TRUNC)) != 0)) {\n\t\tverbose(\"Refusing open request in read-only mode\");\n\t\tstatus = SSH2_FX_PERMISSION_DENIED;\n\t} else {\n\t\tfd = open(name, flags, mode);\n\t\tif (fd < 0) {\n\t\t\tstatus = errno_to_portable(errno);\n\t\t} else {\n\t\t\thandle = handle_new(HANDLE_FILE, name, fd, flags, NULL);\n\t\t\tif (handle < 0) {\n\t\t\t\tclose(fd);\n\t\t\t} else {\n\t\t\t\tsend_handle(id, handle);\n\t\t\t\tstatus = SSH2_FX_OK;\n\t\t\t}\n\t\t}\n\t}\n\tif (status != SSH2_FX_OK)\n\t\tsend_status(id, status);\n\tfree(name);\n}", "target": 1, "idx": 11620}
{"commit_id": "0ddb634dde56dbd7c589ce1fb7c8871fd183e1e9", "project": "GNOME/libgfbgraph", "func": "GInputStream *\ngfbgraph_photo_download_default_size (GFBGraphPhoto       *photo,\n                                      GFBGraphAuthorizer  *authorizer,\n                                      GError             **error)\n{\n  GInputStream *stream = NULL;\n  SoupSession *session;\n  SoupRequester *requester;\n  SoupRequest *request;\n  SoupMessage *message;\n  GFBGraphPhotoPrivate *priv;\n\n  g_return_val_if_fail (GFBGRAPH_IS_PHOTO (photo), NULL);\n  g_return_val_if_fail (GFBGRAPH_IS_AUTHORIZER (authorizer), NULL);\n\n  priv = GFBGRAPH_PHOTO_GET_PRIVATE (photo);\n\n  session = soup_session_sync_new ();\n  requester = soup_requester_new ();\n  g_object_set (G_OBJECT (session), \"ssl-use-system-ca-file\", TRUE, NULL);\n  soup_session_add_feature (session, SOUP_SESSION_FEATURE (requester));\n\n  request = soup_requester_request (requester, priv->source, error);\n  if (request != NULL) {\n    message = soup_request_http_get_message (SOUP_REQUEST_HTTP (request));\n\n    stream = soup_request_send (request, NULL, error);\n    if (stream != NULL) {\n      g_object_weak_ref (G_OBJECT (stream),\n                         (GWeakNotify)g_object_unref,\n                         session);\n    }\n\n    g_clear_object (&message);\n    g_clear_object (&request);\n  }\n\n  g_clear_object (&requester);\n\n  return stream;\n}", "target": 1, "idx": 11621}
{"commit_id": "d4841f1161bdb5e13cb19e81af42437a634dd6ef", "project": "android", "func": "WORD32 ih264d_mark_err_slice_skip(dec_struct_t * ps_dec,\n                                WORD32 num_mb_skip,\n                                UWORD8 u1_is_idr_slice,\n                                UWORD16 u2_frame_num,\n                                pocstruct_t *ps_cur_poc,\n                                WORD32 prev_slice_err)\n{\n    WORD32 i2_cur_mb_addr;\n    UWORD32 u1_num_mbs, u1_num_mbsNby2;\n    UWORD32 u1_mb_idx = ps_dec->u1_mb_idx;\n    UWORD32 i2_mb_skip_run;\n\n    UWORD32 u1_num_mbs_next, u1_end_of_row;\n    const UWORD32 i2_pic_wdin_mbs = ps_dec->u2_frm_wd_in_mbs;\n    UWORD32 u1_slice_end;\n    UWORD32 u1_tfr_n_mb;\n    UWORD32 u1_decode_nmb;\n    dec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;\n    dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;\n    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;\n    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;\n    deblk_mb_t *ps_cur_deblk_mb;\n    dec_mb_info_t *ps_cur_mb_info;\n    parse_pmbarams_t *ps_parse_mb_data;\n    UWORD32 u1_inter_mb_type;\n    UWORD32 u1_deblk_mb_type;\n    UWORD16 u2_total_mbs_coded;\n    UWORD32 u1_mbaff = ps_slice->u1_mbaff_frame_flag;\n    parse_part_params_t *ps_part_info;\n    WORD32 ret;\n\n\n    if(ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC)\n    {\n        ih264d_err_pic_dispbuf_mgr(ps_dec);\n        return 0;\n    }\n    ps_dec->ps_dpb_cmds->u1_long_term_reference_flag = 0;\n    if(prev_slice_err == 1)\n    {\n        /* first slice - missing/header corruption */\n        ps_dec->ps_cur_slice->u2_frame_num = u2_frame_num;\n\n\n        if(!ps_dec->u1_first_slice_in_stream)\n        {\n            ih264d_end_of_pic(ps_dec, u1_is_idr_slice,\n                ps_dec->ps_cur_slice->u2_frame_num);\n            ps_dec->s_cur_pic_poc.u2_frame_num =\n                ps_dec->ps_cur_slice->u2_frame_num;\n        }\n\n        {\n            WORD32 i, j, poc = 0;\n\n            ps_dec->ps_cur_slice->u2_first_mb_in_slice = 0;\n\n            ps_dec->pf_mvpred = ih264d_mvpred_nonmbaff;\n            ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_bp;\n            ps_dec->p_motion_compensate = ih264d_motion_compensate_bp;\n\n            if(ps_dec->ps_cur_pic != NULL)\n                poc = ps_dec->ps_cur_pic->i4_poc + 2;\n\n            j = 0;\n            for(i = 0; i < MAX_NUM_PIC_PARAMS; i++)\n                   if(ps_dec->ps_pps[i].u1_is_valid == TRUE)\n                       j = i;\n            {\n                //initialize slice params required by ih264d_start_of_pic to valid values\n                ps_dec->ps_cur_slice->u1_bottom_field_flag = 0;\n                ps_dec->ps_cur_slice->u1_field_pic_flag = 0;\n                ps_dec->ps_cur_slice->u1_slice_type = P_SLICE;\n                ps_dec->ps_cur_slice->u1_nal_ref_idc = 1;\n                ps_dec->ps_cur_slice->u1_nal_unit_type = 1;\n                ret = ih264d_start_of_pic(ps_dec, poc, ps_cur_poc,\n                        ps_dec->ps_cur_slice->u2_frame_num,\n                        &ps_dec->ps_pps[j]);\n\n                if(ret != OK)\n                {\n                    return ret;\n                }\n            }\n\n            ps_dec->ps_ref_pic_buf_lx[0][0]->u1_pic_buf_id = 0;\n\n            ps_dec->u4_output_present = 0;\n\n            {\n                ih264d_get_next_display_field(ps_dec,\n                                              ps_dec->ps_out_buffer,\n                                              &(ps_dec->s_disp_op));\n                /* If error code is non-zero then there is no buffer available for display,\n                 hence avoid format conversion */\n\n                if(0 != ps_dec->s_disp_op.u4_error_code)\n                {\n                    ps_dec->u4_fmt_conv_cur_row = ps_dec->s_disp_frame_info.u4_y_ht;\n                }\n                else\n                    ps_dec->u4_output_present = 1;\n            }\n\n            if(ps_dec->u1_separate_parse == 1)\n            {\n                if(ps_dec->u4_dec_thread_created == 0)\n                {\n                    ithread_create(ps_dec->pv_dec_thread_handle, NULL,\n                                   (void *)ih264d_decode_picture_thread,\n                                   (void *)ps_dec);\n\n                    ps_dec->u4_dec_thread_created = 1;\n                }\n\n                if((ps_dec->u4_num_cores == 3) &&\n                                ((ps_dec->u4_app_disable_deblk_frm == 0) || ps_dec->i1_recon_in_thread3_flag)\n                                && (ps_dec->u4_bs_deblk_thread_created == 0))\n                {\n                    ps_dec->u4_start_recon_deblk = 0;\n                    ithread_create(ps_dec->pv_bs_deblk_thread_handle, NULL,\n                                   (void *)ih264d_recon_deblk_thread,\n                                   (void *)ps_dec);\n                    ps_dec->u4_bs_deblk_thread_created = 1;\n                }\n            }\n        }\n    }\n    else\n    {\n        // Middle / last slice\n\n        dec_slice_struct_t *ps_parse_cur_slice;\n        ps_parse_cur_slice = ps_dec->ps_dec_slice_buf + ps_dec->u2_cur_slice_num;\n\n        if(ps_dec->u1_slice_header_done\n            && ps_parse_cur_slice == ps_dec->ps_parse_cur_slice)\n        {\n            // Slice data corrupted\n            u1_num_mbs = ps_dec->u4_num_mbs_cur_nmb;\n\n            if(u1_num_mbs)\n            {\n                ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs - 1;\n            }\n            else\n            {\n                if(ps_dec->u1_separate_parse)\n                {\n                    ps_cur_mb_info = ps_dec->ps_nmb_info - 1;\n                }\n                else\n                {\n                    ps_cur_mb_info = ps_dec->ps_nmb_info\n                            + ps_dec->u4_num_mbs_prev_nmb - 1;\n                }\n            }\n\n            ps_dec->u2_mby = ps_cur_mb_info->u2_mby;\n            ps_dec->u2_mbx = ps_cur_mb_info->u2_mbx;\n\n            ps_dec->u1_mb_ngbr_availablity =\n                    ps_cur_mb_info->u1_mb_ngbr_availablity;\n\n            // Going back 1 mb\n            ps_dec->pv_parse_tu_coeff_data = ps_dec->pv_prev_mb_parse_tu_coeff_data;\n            ps_dec->u2_cur_mb_addr--;\n            ps_dec->i4_submb_ofst -= SUB_BLK_SIZE;\n\n            if(u1_num_mbs)\n            {\n                // Parse/decode N-MB left unparsed\n                if (ps_dec->u1_pr_sl_type == P_SLICE\n                        || ps_dec->u1_pr_sl_type == B_SLICE)\n                {\n                    ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx,    u1_num_mbs);\n                    ps_dec->ps_part = ps_dec->ps_parse_part_params;\n                }\n\n                u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;\n                u1_end_of_row = (!u1_num_mbs_next)\n                        && (!(u1_mbaff && (u1_num_mbs & 0x01)));\n                u1_slice_end = 1;\n                u1_tfr_n_mb = 1;\n                ps_cur_mb_info->u1_end_of_slice = u1_slice_end;\n\n                if(ps_dec->u1_separate_parse)\n                {\n                    ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                            u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n                    ps_dec->ps_nmb_info += u1_num_mbs;\n                }\n                else\n                {\n                    ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                            u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n                }\n                ps_dec->u2_total_mbs_coded += u1_num_mbs;\n                ps_dec->u1_mb_idx = 0;\n                ps_dec->u4_num_mbs_cur_nmb = 0;\n            }\n\n            if(ps_dec->u2_total_mbs_coded\n                    >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n            {\n                ps_dec->u1_pic_decode_done = 1;\n                return 0;\n            }\n\n            // Inserting new slice\n            ps_dec->u2_cur_slice_num++;\n             ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\n            ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\n            ps_dec->ps_parse_cur_slice++;\n\n        }\n        else\n        {\n            // Slice missing / header corrupted\n            ps_dec->ps_parse_cur_slice = ps_dec->ps_dec_slice_buf\n                                            + ps_dec->u2_cur_slice_num;\n        }\n    }\n\n    /******************************************************/\n    /* Initializations to new slice                       */\n    /******************************************************/\n    {\n        WORD32 num_entries;\n        WORD32 size;\n        UWORD8 *pu1_buf;\n\n        num_entries = MAX_FRAMES;\n        if((1 >= ps_dec->ps_cur_sps->u1_num_ref_frames) &&\n            (0 == ps_dec->i4_display_delay))\n        {\n            num_entries = 1;\n        }\n        num_entries = ((2 * num_entries) + 1);\n        if(BASE_PROFILE_IDC != ps_dec->ps_cur_sps->u1_profile_idc)\n        {\n            num_entries *= 2;\n        }\n        size = num_entries * sizeof(void *);\n        size += PAD_MAP_IDX_POC * sizeof(void *);\n\n        pu1_buf = (UWORD8 *)ps_dec->pv_map_ref_idx_to_poc_buf;\n        pu1_buf += size * ps_dec->u2_cur_slice_num;\n        ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc = (volatile void **)pu1_buf;\n    }\n\n    ps_dec->ps_cur_slice->u2_first_mb_in_slice = ps_dec->u2_total_mbs_coded << u1_mbaff;\n    ps_dec->ps_cur_slice->i1_slice_alpha_c0_offset = 0;\n    ps_dec->ps_cur_slice->i1_slice_beta_offset = 0;\n\n    if(ps_dec->ps_cur_slice->u1_field_pic_flag)\n        ps_dec->u2_prv_frame_num = ps_dec->ps_cur_slice->u2_frame_num;\n\n    ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice = ps_dec->u2_total_mbs_coded << u1_mbaff;\n    ps_dec->ps_parse_cur_slice->u2_log2Y_crwd =    ps_dec->ps_cur_slice->u2_log2Y_crwd;\n\n\n    if(ps_dec->u1_separate_parse)\n    {\n        ps_dec->ps_parse_cur_slice->pv_tu_coeff_data_start = ps_dec->pv_parse_tu_coeff_data;\n    }\n    else\n    {\n        ps_dec->pv_proc_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;\n    }\n\n    /******************************************************/\n    /* Initializations specific to P slice                */\n    /******************************************************/\n    u1_inter_mb_type = P_MB;\n    u1_deblk_mb_type = D_INTER_MB;\n\n    ps_dec->ps_cur_slice->u1_slice_type = P_SLICE;\n    ps_dec->ps_parse_cur_slice->slice_type = P_SLICE;\n    ps_dec->pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb;\n    ps_dec->ps_part = ps_dec->ps_parse_part_params;\n\n    /******************************************************/\n    /* Parsing / decoding the slice                       */\n    /******************************************************/\n    ps_dec->u1_slice_header_done = 2;\n    ps_dec->u1_qp = ps_slice->u1_slice_qp;\n    ih264d_update_qp(ps_dec, 0);\n    u1_mb_idx = ps_dec->u1_mb_idx;\n    ps_parse_mb_data = ps_dec->ps_parse_mb_data;\n    u1_num_mbs = u1_mb_idx;\n\n    u1_slice_end = 0;\n    u1_tfr_n_mb = 0;\n    u1_decode_nmb = 0;\n    u1_num_mbsNby2 = 0;\n    i2_cur_mb_addr = ps_dec->u2_total_mbs_coded;\n    i2_mb_skip_run = num_mb_skip;\n\n    while(!u1_slice_end)\n    {\n        UWORD8 u1_mb_type;\n\n        if(i2_cur_mb_addr > ps_dec->ps_cur_sps->u2_max_mb_addr)\n            break;\n\n        ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs;\n        ps_dec->u4_num_mbs_cur_nmb = u1_num_mbs;\n\n        ps_cur_mb_info->u1_Mux = 0;\n        ps_dec->u4_num_pmbair = (u1_num_mbs >> u1_mbaff);\n        ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_num_mbs;\n\n        ps_cur_mb_info->u1_end_of_slice = 0;\n\n        /* Storing Default partition info */\n        ps_parse_mb_data->u1_num_part = 1;\n        ps_parse_mb_data->u1_isI_mb = 0;\n\n        /**************************************************************/\n        /* Get the required information for decoding of MB            */\n        /**************************************************************/\n        /* mb_x, mb_y, neighbor availablity, */\n        if (u1_mbaff)\n            ih264d_get_mb_info_cavlc_mbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);\n        else\n            ih264d_get_mb_info_cavlc_nonmbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);\n\n        /* Set the deblocking parameters for this MB */\n        if(ps_dec->u4_app_disable_deblk_frm == 0)\n        {\n            ih264d_set_deblocking_parameters(ps_cur_deblk_mb, ps_slice,\n                                             ps_dec->u1_mb_ngbr_availablity,\n                                             ps_dec->u1_cur_mb_fld_dec_flag);\n        }\n\n        /* Set appropriate flags in ps_cur_mb_info and ps_dec */\n        ps_dec->i1_prev_mb_qp_delta = 0;\n        ps_dec->u1_sub_mb_num = 0;\n        ps_cur_mb_info->u1_mb_type = MB_SKIP;\n        ps_cur_mb_info->u1_mb_mc_mode = PRED_16x16;\n        ps_cur_mb_info->u1_cbp = 0;\n\n        /* Storing Skip partition info */\n        ps_part_info = ps_dec->ps_part;\n        ps_part_info->u1_is_direct = PART_DIRECT_16x16;\n        ps_part_info->u1_sub_mb_num = 0;\n        ps_dec->ps_part++;\n\n        /* Update Nnzs */\n        ih264d_update_nnz_for_skipmb(ps_dec, ps_cur_mb_info, CAVLC);\n\n        ps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;\n        ps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;\n\n        i2_mb_skip_run--;\n\n        ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;\n\n        if (u1_mbaff)\n        {\n            ih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info);\n        }\n\n        /**************************************************************/\n        /* Get next Macroblock address                                */\n        /**************************************************************/\n        i2_cur_mb_addr++;\n\n        u1_num_mbs++;\n        u1_num_mbsNby2++;\n        ps_parse_mb_data++;\n\n        /****************************************************************/\n        /* Check for End Of Row and other flags that determine when to  */\n        /* do DMA setup for N/2-Mb, Decode for N-Mb, and Transfer for   */\n        /* N-Mb                                                         */\n        /****************************************************************/\n        u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;\n        u1_end_of_row = (!u1_num_mbs_next) && (!(u1_mbaff && (u1_num_mbs & 0x01)));\n        u1_slice_end = !i2_mb_skip_run;\n        u1_tfr_n_mb = (u1_num_mbs == ps_dec->u1_recon_mb_grp) || u1_end_of_row\n                        || u1_slice_end;\n        u1_decode_nmb = u1_tfr_n_mb || u1_slice_end;\n        ps_cur_mb_info->u1_end_of_slice = u1_slice_end;\n\n        if(u1_decode_nmb)\n        {\n            ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx, u1_num_mbs);\n            u1_num_mbsNby2 = 0;\n\n            ps_parse_mb_data = ps_dec->ps_parse_mb_data;\n            ps_dec->ps_part = ps_dec->ps_parse_part_params;\n\n            if(ps_dec->u1_separate_parse)\n            {\n                ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                                     u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n                ps_dec->ps_nmb_info +=  u1_num_mbs;\n            }\n            else\n            {\n                ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs, u1_num_mbs_next,\n                                            u1_tfr_n_mb, u1_end_of_row);\n            }\n            ps_dec->u2_total_mbs_coded += u1_num_mbs;\n            if(u1_tfr_n_mb)\n                u1_num_mbs = 0;\n            u1_mb_idx = u1_num_mbs;\n            ps_dec->u1_mb_idx = u1_num_mbs;\n        }\n    }\n\n    ps_dec->u4_num_mbs_cur_nmb = 0;\n    ps_dec->ps_cur_slice->u4_mbs_in_slice = i2_cur_mb_addr\n                        - ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice;\n\n    H264_DEC_DEBUG_PRINT(\"Mbs in slice: %d\\n\", ps_dec->ps_cur_slice->u4_mbs_in_slice);\n\n    ps_dec->u2_cur_slice_num++;\n\n    /* incremented here only if first slice is inserted */\n    if(ps_dec->u4_first_slice_in_pic != 0)\n        ps_dec->ps_parse_cur_slice++;\n\n    ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\n    ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\n\n    if(ps_dec->u2_total_mbs_coded\n            >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n    {\n        ps_dec->u1_pic_decode_done = 1;\n    }\n\n    return 0;\n\n}", "target": 2, "idx": 11622}
{"commit_id": "34b3be18a04ecdc610aae4c48e5d1b799d8689f6", "project": "torvalds/linux", "func": "int sdma_init(struct hfi1_devdata *dd, u8 port)\n{\n\tunsigned this_idx;\n\tstruct sdma_engine *sde;\n\tstruct rhashtable *tmp_sdma_rht;\n\tu16 descq_cnt;\n\tvoid *curr_head;\n\tstruct hfi1_pportdata *ppd = dd->pport + port;\n\tu32 per_sdma_credits;\n\tuint idle_cnt = sdma_idle_cnt;\n\tsize_t num_engines = chip_sdma_engines(dd);\n\tint ret = -ENOMEM;\n\n\tif (!HFI1_CAP_IS_KSET(SDMA)) {\n\t\tHFI1_CAP_CLEAR(SDMA_AHG);\n\t\treturn 0;\n\t}\n\tif (mod_num_sdma &&\n\t    /* can't exceed chip support */\n\t    mod_num_sdma <= chip_sdma_engines(dd) &&\n\t    /* count must be >= vls */\n\t    mod_num_sdma >= num_vls)\n\t\tnum_engines = mod_num_sdma;\n\n\tdd_dev_info(dd, \"SDMA mod_num_sdma: %u\\n\", mod_num_sdma);\n\tdd_dev_info(dd, \"SDMA chip_sdma_engines: %u\\n\", chip_sdma_engines(dd));\n\tdd_dev_info(dd, \"SDMA chip_sdma_mem_size: %u\\n\",\n\t\t    chip_sdma_mem_size(dd));\n\n\tper_sdma_credits =\n\t\tchip_sdma_mem_size(dd) / (num_engines * SDMA_BLOCK_SIZE);\n\n\t/* set up freeze waitqueue */\n\tinit_waitqueue_head(&dd->sdma_unfreeze_wq);\n\tatomic_set(&dd->sdma_unfreeze_count, 0);\n\n\tdescq_cnt = sdma_get_descq_cnt();\n\tdd_dev_info(dd, \"SDMA engines %zu descq_cnt %u\\n\",\n\t\t    num_engines, descq_cnt);\n\n\t/* alloc memory for array of send engines */\n\tdd->per_sdma = kcalloc_node(num_engines, sizeof(*dd->per_sdma),\n\t\t\t\t    GFP_KERNEL, dd->node);\n\tif (!dd->per_sdma)\n\t\treturn ret;\n\n\tidle_cnt = ns_to_cclock(dd, idle_cnt);\n\tif (idle_cnt)\n\t\tdd->default_desc1 =\n\t\t\tSDMA_DESC1_HEAD_TO_HOST_FLAG;\n\telse\n\t\tdd->default_desc1 =\n\t\t\tSDMA_DESC1_INT_REQ_FLAG;\n\n\tif (!sdma_desct_intr)\n\t\tsdma_desct_intr = SDMA_DESC_INTR;\n\n\t/* Allocate memory for SendDMA descriptor FIFOs */\n\tfor (this_idx = 0; this_idx < num_engines; ++this_idx) {\n\t\tsde = &dd->per_sdma[this_idx];\n\t\tsde->dd = dd;\n\t\tsde->ppd = ppd;\n\t\tsde->this_idx = this_idx;\n\t\tsde->descq_cnt = descq_cnt;\n\t\tsde->desc_avail = sdma_descq_freecnt(sde);\n\t\tsde->sdma_shift = ilog2(descq_cnt);\n\t\tsde->sdma_mask = (1 << sde->sdma_shift) - 1;\n\n\t\t/* Create a mask specifically for each interrupt source */\n\t\tsde->int_mask = (u64)1 << (0 * TXE_NUM_SDMA_ENGINES +\n\t\t\t\t\t   this_idx);\n\t\tsde->progress_mask = (u64)1 << (1 * TXE_NUM_SDMA_ENGINES +\n\t\t\t\t\t\tthis_idx);\n\t\tsde->idle_mask = (u64)1 << (2 * TXE_NUM_SDMA_ENGINES +\n\t\t\t\t\t    this_idx);\n\t\t/* Create a combined mask to cover all 3 interrupt sources */\n\t\tsde->imask = sde->int_mask | sde->progress_mask |\n\t\t\t     sde->idle_mask;\n\n\t\tspin_lock_init(&sde->tail_lock);\n\t\tseqlock_init(&sde->head_lock);\n\t\tspin_lock_init(&sde->senddmactrl_lock);\n\t\tspin_lock_init(&sde->flushlist_lock);\n\t\tseqlock_init(&sde->waitlock);\n\t\t/* insure there is always a zero bit */\n\t\tsde->ahg_bits = 0xfffffffe00000000ULL;\n\n\t\tsdma_set_state(sde, sdma_state_s00_hw_down);\n\n\t\t/* set up reference counting */\n\t\tkref_init(&sde->state.kref);\n\t\tinit_completion(&sde->state.comp);\n\n\t\tINIT_LIST_HEAD(&sde->flushlist);\n\t\tINIT_LIST_HEAD(&sde->dmawait);\n\n\t\tsde->tail_csr =\n\t\t\tget_kctxt_csr_addr(dd, this_idx, SD(TAIL));\n\n\t\ttasklet_init(&sde->sdma_hw_clean_up_task, sdma_hw_clean_up_task,\n\t\t\t     (unsigned long)sde);\n\n\t\ttasklet_init(&sde->sdma_sw_clean_up_task, sdma_sw_clean_up_task,\n\t\t\t     (unsigned long)sde);\n\t\tINIT_WORK(&sde->err_halt_worker, sdma_err_halt_wait);\n\t\tINIT_WORK(&sde->flush_worker, sdma_field_flush);\n\n\t\tsde->progress_check_head = 0;\n\n\t\ttimer_setup(&sde->err_progress_check_timer,\n\t\t\t    sdma_err_progress_check, 0);\n\n\t\tsde->descq = dma_alloc_coherent(&dd->pcidev->dev,\n\t\t\t\t\t\tdescq_cnt * sizeof(u64[2]),\n\t\t\t\t\t\t&sde->descq_phys, GFP_KERNEL);\n\t\tif (!sde->descq)\n\t\t\tgoto bail;\n\t\tsde->tx_ring =\n\t\t\tkvzalloc_node(array_size(descq_cnt,\n\t\t\t\t\t\t sizeof(struct sdma_txreq *)),\n\t\t\t\t      GFP_KERNEL, dd->node);\n\t\tif (!sde->tx_ring)\n\t\t\tgoto bail;\n\t}\n\n\tdd->sdma_heads_size = L1_CACHE_BYTES * num_engines;\n\t/* Allocate memory for DMA of head registers to memory */\n\tdd->sdma_heads_dma = dma_alloc_coherent(&dd->pcidev->dev,\n\t\t\t\t\t\tdd->sdma_heads_size,\n\t\t\t\t\t\t&dd->sdma_heads_phys,\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (!dd->sdma_heads_dma) {\n\t\tdd_dev_err(dd, \"failed to allocate SendDMA head memory\\n\");\n\t\tgoto bail;\n\t}\n\n\t/* Allocate memory for pad */\n\tdd->sdma_pad_dma = dma_alloc_coherent(&dd->pcidev->dev, sizeof(u32),\n\t\t\t\t\t      &dd->sdma_pad_phys, GFP_KERNEL);\n\tif (!dd->sdma_pad_dma) {\n\t\tdd_dev_err(dd, \"failed to allocate SendDMA pad memory\\n\");\n\t\tgoto bail;\n\t}\n\n\t/* assign each engine to different cacheline and init registers */\n\tcurr_head = (void *)dd->sdma_heads_dma;\n\tfor (this_idx = 0; this_idx < num_engines; ++this_idx) {\n\t\tunsigned long phys_offset;\n\n\t\tsde = &dd->per_sdma[this_idx];\n\n\t\tsde->head_dma = curr_head;\n\t\tcurr_head += L1_CACHE_BYTES;\n\t\tphys_offset = (unsigned long)sde->head_dma -\n\t\t\t      (unsigned long)dd->sdma_heads_dma;\n\t\tsde->head_phys = dd->sdma_heads_phys + phys_offset;\n\t\tinit_sdma_regs(sde, per_sdma_credits, idle_cnt);\n\t}\n\tdd->flags |= HFI1_HAS_SEND_DMA;\n\tdd->flags |= idle_cnt ? HFI1_HAS_SDMA_TIMEOUT : 0;\n\tdd->num_sdma = num_engines;\n\tret = sdma_map_init(dd, port, ppd->vls_operational, NULL);\n\tif (ret < 0)\n\t\tgoto bail;\n\n\ttmp_sdma_rht = kzalloc(sizeof(*tmp_sdma_rht), GFP_KERNEL);\n\tif (!tmp_sdma_rht) {\n\t\tret = -ENOMEM;\n\t\tgoto bail;\n\t}\n\n\tret = rhashtable_init(tmp_sdma_rht, &sdma_rht_params);\n\tif (ret < 0) {\n\t\tkfree(tmp_sdma_rht);\n\t\tgoto bail;\n\t}\n\n\tdd->sdma_rht = tmp_sdma_rht;\n\n\tdd_dev_info(dd, \"SDMA num_sdma: %u\\n\", dd->num_sdma);\n\treturn 0;\n\nbail:\n\tsdma_clean(dd, num_engines);\n\treturn ret;\n}", "target": 1, "idx": 11623}
{"commit_id": "24403a9a35cd7fbe5ea6e596b1c6deb9d8633566", "project": "wireshark", "func": "void\nproto_register_amf(void)\n{\n        static hf_register_info hf[] = {\n                { &hf_amf_version,\n                  { \"AMF version\", \"amf.version\", FT_UINT16, BASE_DEC,\n                    NULL, 0x0, NULL, HFILL }},\n\n                { &hf_amf_header_count,\n                  { \"Header count\", \"amf.header_count\", FT_UINT16, BASE_DEC,\n                    NULL, 0x0, NULL, HFILL }},\n\n                { &hf_amf_header_name,\n                  { \"Name\", \"amf.header.name\", FT_UINT_STRING, BASE_NONE,\n                    NULL, 0x0, NULL, HFILL }},\n\n                { &hf_amf_header_must_understand,\n                  { \"Must understand\", \"amf.header.must_understand\", FT_BOOLEAN, BASE_NONE,\n                    NULL, 0x0, NULL, HFILL }},\n\n                { &hf_amf_header_length,\n                  { \"Length\", \"amf.header.length\", FT_UINT32, BASE_DEC,\n                    NULL, 0x0, NULL, HFILL }},\n\n#if 0\n                { &hf_amf_header_value_type,\n                  { \"Value type\", \"amf.header.value_type\", FT_UINT32, BASE_HEX,\n                    VALS(rtmpt_type_vals), 0x0, NULL, HFILL }},\n#endif\n\n                { &hf_amf_message_count,\n                  { \"Message count\", \"amf.message_count\", FT_UINT16, BASE_DEC,\n                    NULL, 0x0, NULL, HFILL }},\n\n                { &hf_amf_message_target_uri,\n                  { \"Target URI\", \"amf.message.target_uri\", FT_UINT_STRING, BASE_NONE,\n                    NULL, 0x0, NULL, HFILL }},\n\n                { &hf_amf_message_response_uri,\n                  { \"Response URI\", \"amf.message.response_uri\", FT_UINT_STRING, BASE_NONE,\n                    NULL, 0x0, NULL, HFILL }},\n\n                { &hf_amf_message_length,\n                  { \"Length\", \"amf.message.length\", FT_UINT32, BASE_DEC,\n                    NULL, 0x0, NULL, HFILL }},\n\n\n/* AMF basic types */\n                { &hf_amf_amf0_type,\n                  { \"AMF0 type\", \"amf.amf0_type\", FT_UINT8, BASE_HEX,\n                    VALS(amf0_type_vals), 0x0, NULL, HFILL }},\n\n                { &hf_amf_amf3_type,\n                  { \"AMF3 type\", \"amf.amf3_type\", FT_UINT8, BASE_HEX,\n                    VALS(amf3_type_vals), 0x0, NULL, HFILL }},\n\n                { &hf_amf_number,\n                  { \"Number\", \"amf.number\", FT_DOUBLE, BASE_NONE,\n                    NULL, 0x0, \"AMF number\", HFILL }},\n\n                { &hf_amf_integer,\n                  { \"Integer\", \"amf.integer\", FT_UINT32, BASE_DEC,\n                    NULL, 0x0, \"RTMPT AMF3 integer\", HFILL }},\n\n                { &hf_amf_boolean,\n                  { \"Boolean\", \"amf.boolean\", FT_BOOLEAN, BASE_NONE,\n                    NULL, 0x0, \"AMF boolean\", HFILL }},\n\n                { &hf_amf_stringlength,\n                  { \"String length\", \"amf.stringlength\", FT_UINT32, BASE_DEC,\n                    NULL, 0x0, \"AMF string length\", HFILL }},\n\n                { &hf_amf_string,\n                  { \"String\", \"amf.string\", FT_STRING, BASE_NONE,\n                    NULL, 0x0, \"AMF string\", HFILL }},\n\n                { &hf_amf_string_reference,\n                  { \"String reference\", \"amf.string_reference\", FT_UINT32, BASE_DEC,\n                    NULL, 0x0, \"RTMPT AMF3 string reference\", HFILL }},\n\n                { &hf_amf_object_reference,\n                  { \"Object reference\", \"amf.object_reference\", FT_UINT32, BASE_DEC,\n                    NULL, 0x0, \"AMF object reference\", HFILL }},\n\n                { &hf_amf_date,\n                  { \"Date\", \"amf.date\", FT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL,\n                    NULL, 0x0, \"AMF date\", HFILL }},\n\n#if 0\n                { &hf_amf_longstringlength,\n                  { \"String length\", \"amf.longstringlength\", FT_UINT32, BASE_DEC,\n                    NULL, 0x0, \"AMF long string length\", HFILL }},\n#endif\n\n                { &hf_amf_longstring,\n                  { \"Long string\", \"amf.longstring\", FT_STRING, BASE_NONE,\n                    NULL, 0x0, \"AMF long string\", HFILL }},\n\n                { &hf_amf_xml_doc,\n                  { \"XML document\", \"amf.xml_doc\", FT_STRING, BASE_NONE,\n                    NULL, 0x0, \"AMF XML document\", HFILL }},\n\n                { &hf_amf_xmllength,\n                  { \"XML text length\", \"amf.xmllength\", FT_UINT32, BASE_DEC,\n                    NULL, 0x0, \"AMF E4X XML length\", HFILL }},\n\n                { &hf_amf_xml,\n                  { \"XML\", \"amf.xml\", FT_STRING, BASE_NONE,\n                    NULL, 0x0, \"AMF E4X XML\", HFILL }},\n\n                { &hf_amf_int64,\n                  { \"Int64\", \"amf.int64\", FT_INT64, BASE_DEC,\n                    NULL, 0x0, \"AMF int64\", HFILL }},\n\n                { &hf_amf_bytearraylength,\n                  { \"ByteArray length\", \"amf.bytearraylength\", FT_UINT32, BASE_DEC,\n                    NULL, 0x0, \"RTMPT AMF3 ByteArray length\", HFILL }},\n\n                { &hf_amf_bytearray,\n                  { \"ByteArray\", \"amf.bytearray\", FT_BYTES, BASE_NONE,\n                    NULL, 0x0, \"RTMPT AMF3 ByteArray\", HFILL }},\n\n/* AMF object types and subfields of the object types */\n                { &hf_amf_object,\n                  { \"Object\", \"amf.object\", FT_NONE, BASE_NONE,\n                    NULL, 0x0, \"AMF object\", HFILL }},\n\n                { &hf_amf_traitcount,\n                  { \"Trait count\", \"amf.traitcount\", FT_UINT32, BASE_DEC,\n                    NULL, 0x0, \"AMF count of traits for an object\", HFILL }},\n\n                { &hf_amf_classnamelength,\n                  { \"Class name length\", \"amf.classnamelength\", FT_UINT32, BASE_DEC,\n                    NULL, 0x0, \"AMF class name length\", HFILL }},\n\n                { &hf_amf_classname,\n                  { \"Class name\", \"amf.classname\", FT_STRING, BASE_NONE,\n                    NULL, 0x0, \"AMF class name\", HFILL }},\n\n                { &hf_amf_membernamelength,\n                  { \"Member name length\", \"amf.membernamelength\", FT_UINT32, BASE_DEC,\n                    NULL, 0x0, \"AMF member name length\", HFILL }},\n\n                { &hf_amf_membername,\n                  { \"Member name\", \"amf.membername\", FT_STRING, BASE_NONE,\n                    NULL, 0x0, \"AMF member name\", HFILL }},\n\n                { &hf_amf_trait_reference,\n                  { \"Trait reference\", \"amf.trait_reference\", FT_UINT32, BASE_DEC,\n                    NULL, 0x0, \"AMF trait reference\", HFILL }},\n\n                { &hf_amf_ecmaarray,\n                  { \"ECMA array\", \"amf.ecmaarray\", FT_NONE, BASE_NONE,\n                    NULL, 0x0, \"AMF ECMA array\", HFILL }},\n\n                { &hf_amf_strictarray,\n                  { \"Strict array\", \"amf.strictarray\", FT_NONE, BASE_NONE,\n                    NULL, 0x0, \"AMF strict array\", HFILL }},\n\n                { &hf_amf_array,\n                  { \"Array\", \"amf.array\", FT_NONE, BASE_NONE,\n                    NULL, 0x0, \"RTMPT AMF3 array\", HFILL }},\n\n                { &hf_amf_arraylength,\n                  { \"Array length\", \"amf.arraylength\", FT_UINT32, BASE_DEC,\n                    NULL, 0x0, \"AMF array length\", HFILL }},\n\n                { &hf_amf_arraydenselength,\n                  { \"Length of dense portion\", \"amf.arraydenselength\", FT_UINT32, BASE_DEC,\n                    NULL, 0x0, \"AMF length of dense portion of array\", HFILL }},\n\n                { &hf_amf_end_of_object_marker,\n                  { \"End Of Object Marker\", \"amf.end_of_object_marker\", FT_NONE, BASE_NONE,\n                    NULL, 0x0, NULL, HFILL }},\n\n                { &hf_amf_end_of_associative_part,\n                  { \"End of associative part\", \"amf.end_of_associative_part\", FT_NONE, BASE_NONE,\n                    NULL, 0x0, NULL, HFILL }},\n\n                { &hf_amf_end_of_dynamic_members,\n                  { \"End Of dynamic members\", \"amf.end_of_dynamic_members\", FT_NONE, BASE_NONE,\n                    NULL, 0x0, NULL, HFILL }},\n        };\n\n        static ei_register_info ei[] = {\n                { &ei_amf_loop, { \"amf.loop\", PI_MALFORMED, PI_ERROR, \"Loop in AMF dissection\", EXPFILL }}\n        };\n\n\n        static gint *ett[] = {\n                &ett_amf,\n                &ett_amf_headers,\n                &ett_amf_messages,\n                &ett_amf_value,\n                &ett_amf_property,\n                &ett_amf_string,\n                &ett_amf_array_element,\n                &ett_amf_traits,\n                &ett_amf_trait_member,\n        };\n\n        expert_module_t* expert_amf;\n\n        proto_amf = proto_register_protocol(\"Action Message Format\", \"AMF\", \"amf\");\n        proto_register_field_array(proto_amf, hf, array_length(hf));\n        proto_register_subtree_array(ett, array_length(ett));\n        expert_amf = expert_register_protocol(proto_amf);\n        expert_register_field_array(expert_amf, ei, array_length(ei));\n}", "target": 2, "idx": 11624}
{"commit_id": "e40b0219a8c77741ae48989efb520f4a762a5be3", "project": "xen-project/xen", "func": "static int _put_final_page_type(struct page_info *page, unsigned long type,\n                                bool preemptible, struct page_info *ptpg)\n{\n    int rc = free_page_type(page, type, preemptible);\n\n    /* No need for atomic update of type_info here: noone else updates it. */\n    if ( rc == 0 )\n    {\n        if ( ptpg && PGT_type_equal(type, ptpg->u.inuse.type_info) )\n        {\n            dec_linear_uses(page);\n            dec_linear_entries(ptpg);\n        }\n        ASSERT(!page->linear_pt_count || page_get_owner(page)->is_dying);\n        set_tlbflush_timestamp(page);\n        smp_wmb();\n        page->u.inuse.type_info--;\n    }\n    else if ( rc == -EINTR )\n    {\n        ASSERT((page->u.inuse.type_info &\n                (PGT_count_mask|PGT_validated|PGT_partial)) == 1);\n        smp_wmb();\n        page->u.inuse.type_info |= PGT_validated;\n    }\n    else\n    {\n        BUG_ON(rc != -ERESTART);\n        smp_wmb();\n        get_page_light(page);\n        page->u.inuse.type_info |= PGT_partial;\n    }\n\n    return rc;\n}", "target": 2, "idx": 11625}
{"commit_id": "e63c4a7d04c145dafaf4b09de5f9f5de69cee8ef", "project": "WebAssembly/binaryen", "func": "void WasmBinaryBuilder::processFunctions() {\n  for (auto* func : functions) {\n    wasm.addFunction(func);\n  }\n\n  // now that we have names for each function, apply things\n\n  if (startIndex != static_cast<Index>(-1)) {\n    wasm.start = getFunctionIndexName(startIndex);\n  }\n\n  for (auto* curr : exportOrder) {\n    auto index = exportIndexes[curr];\n    switch (curr->kind) {\n      case ExternalKind::Function: {\n        if (index >= wasm.functions.size()) {\n          throwError(\"bad function export index\");\n        }\n        curr->value = getFunctionIndexName(index);\n        break;\n      }\n      case ExternalKind::Table: curr->value = Name::fromInt(0); break;\n      case ExternalKind::Memory: curr->value = Name::fromInt(0); break;\n      case ExternalKind::Global: curr->value = getGlobalName(index); break;\n      default: throwError(\"bad export kind\");\n    }\n    wasm.addExport(curr);\n  }\n\n  for (auto& iter : functionCalls) {\n    size_t index = iter.first;\n    auto& calls = iter.second;\n    for (auto* call : calls) {\n      call->target = getFunctionIndexName(index);\n    }\n  }\n\n  for (auto& pair : functionTable) {\n    auto i = pair.first;\n    auto& indexes = pair.second;\n    for (auto j : indexes) {\n      wasm.table.segments[i].data.push_back(getFunctionIndexName(j));\n    }\n  }\n\n  // Everything now has its proper name.\n\n  wasm.updateMaps();\n}", "target": 1, "idx": 11626}
{"commit_id": "34cc326eb2c5695833361887fe0b32e8d987741c", "project": "ArtifexSoftware/ghostpdl", "func": "static int\ncopy_stack(i_ctx_t *i_ctx_p, const ref_stack_t * pstack, int skip, ref * arr)\n{\n    uint size = ref_stack_count(pstack) - skip;\n    uint save_space = ialloc_space(idmemory);\n    int code, i;\n\n    if (size > 65535)\n        size = 65535;\n    ialloc_set_space(idmemory, avm_local);\n    code = ialloc_ref_array(arr, a_all, size, \"copy_stack\");\n    if (code >= 0)\n        code = ref_stack_store(pstack, arr, size, 0, 1, true, idmemory,\n                               \"copy_stack\");\n    /* If we are copying the exec stack, try to replace any oparrays with\n     * with the operator than references them\n     */\n    if (pstack == &e_stack) {\n        for (i = 0; i < size; i++) {\n            if (errorexec_find(i_ctx_p, &arr->value.refs[i]) < 0)\n                make_null(&arr->value.refs[i]);\n        }\n    }\n    ialloc_set_space(idmemory, save_space);\n    return code;\n}", "target": 1, "idx": 11627}
{"commit_id": "aacae2065744adb05e858d327198c7bbe7f452b0", "project": "opencv", "func": "uchar* FillGrayRow1( uchar* data, uchar* indices, int len, uchar* palette )\n{\n    uchar* end = data + len;\n\n    const uchar p0 = palette[0], p1 = palette[1];\n\n    while( (data += 8) < end )\n    {\n        int idx = *indices++;\n        *((uchar*)(data - 8)) = (idx & 128) ? p1 : p0;\n        *((uchar*)(data - 7)) = (idx & 64) ? p1 : p0;\n        *((uchar*)(data - 6)) = (idx & 32) ? p1 : p0;\n        *((uchar*)(data - 5)) = (idx & 16) ? p1 : p0;\n        *((uchar*)(data - 4)) = (idx & 8) ? p1 : p0;\n        *((uchar*)(data - 3)) = (idx & 4) ? p1 : p0;\n        *((uchar*)(data - 2)) = (idx & 2) ? p1 : p0;\n        *((uchar*)(data - 1)) = (idx & 1) ? p1 : p0;\n    }\n\n    int idx = indices[0];\n    for( data -= 8; data < end; data++, idx += idx )\n    {\n        data[0] = (idx & 128) ? p1 : p0;\n    }\n\n    return data;\n}", "target": 1, "idx": 11628}
{"commit_id": "76ca8da989c7d97a7f76c75d475fe95a584439d7", "project": "torvalds/linux", "func": "static void bigben_set_led(struct led_classdev *led,\n\tenum led_brightness value)\n{\n\tstruct device *dev = led->dev->parent;\n\tstruct hid_device *hid = to_hid_device(dev);\n\tstruct bigben_device *bigben = hid_get_drvdata(hid);\n\tint n;\n\tbool work;\n\tunsigned long flags;\n\n\tif (!bigben) {\n\t\thid_err(hid, \"no device data\\n\");\n\t\treturn;\n\t}\n\n\tfor (n = 0; n < NUM_LEDS; n++) {\n\t\tif (led == bigben->leds[n]) {\n\t\t\tspin_lock_irqsave(&bigben->lock, flags);\n\t\t\tif (value == LED_OFF) {\n\t\t\t\twork = (bigben->led_state & BIT(n));\n\t\t\t\tbigben->led_state &= ~BIT(n);\n\t\t\t} else {\n\t\t\t\twork = !(bigben->led_state & BIT(n));\n\t\t\t\tbigben->led_state |= BIT(n);\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&bigben->lock, flags);\n\n\t\t\tif (work) {\n\t\t\t\tbigben->work_led = true;\n\t\t\t\tbigben_schedule_work(bigben);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n}", "target": 1, "idx": 11629}
{"commit_id": "19913ae4b4ff58ebcb84e9dc9fbef81da5c8d850", "project": "miniupnp/ngiflib", "func": "SDL_Surface * SDL_LoadGIF(const char * file)\n{\n\t/* MODE WRAPPER A DEUX BALLES */\n\tSDL_Surface * surface;\n\tstruct ngiflib_gif * gif;\n\tFILE *fgif;\n\tint err,i;\n\tu8 * pdst, * psrc;\n\tu8 * p = NULL;\n#ifdef NGIFLIB_NO_FILE\n\tu8 * buffer;\n\tlong filesize;\n#endif /* NGIFLIB_NO_FILE */\n\n\tfgif = fopen(file, \"rb\");\n\tif(fgif==NULL)\n\t\treturn NULL;\n\tgif = (struct ngiflib_gif *)ngiflib_malloc(sizeof(struct ngiflib_gif));\n\tngiflib_memset(gif, 0, sizeof(struct ngiflib_gif));\n#ifdef NGIFLIB_NO_FILE\n\tfseek(fgif, 0, SEEK_END);\n\tfilesize = ftell(fgif);\n\tif (filesize < 0) {\n\t\tGifDestroy(gif);\n\t\treturn NULL;\n\t}\n\tfseek(fgif, 0, SEEK_SET);\n\tbuffer = malloc(filesize);\n\tif(buffer == NULL) {\n\t\tGifDestroy(gif);\n\t\treturn NULL;\n\t}\n\tfread(buffer, 1, filesize, fgif);\n\tgif->input.buffer.bytes = buffer;\n\tgif->input.buffer.count = (unsigned long)filesize;\n\tgif->mode = NGIFLIB_MODE_FROM_MEM | NGIFLIB_MODE_INDEXED;\n#else /* NGIFLIB_NO_FILE */\n\tgif->input.file = fgif;\n\t/*gif->mode = NGIFLIB_MODE_FROM_FILE | NGIFLIB_MODE_TRUE_COLOR; */\n\tgif->mode = NGIFLIB_MODE_FROM_FILE | NGIFLIB_MODE_INDEXED;\n#ifdef NGIFLIBSDL_LOG\n\tgif->log = stdout;\n#endif /* NGIFLIBSDL_LOG */\n#endif /* NGIFLIB_NO_FILE */\n\terr = LoadGif(gif);\n\tfclose(fgif);\n#ifdef NGIFLIB_NO_FILE\n\tfree(buffer);\n#endif /* NGIFLIB_NO_FILE */\n\tif(err!=1)\n\t{\n\t\tGifDestroy(gif);\n\t\treturn NULL;\n\t}\n\tp = gif->frbuff.p8;\n\t/*\n\tsurface = SDL_CreateRGBSurfaceFrom(p, gif->width, gif->height,\n\t                                   32, gif->width << 2,\n\t\t\t\t\t\t\t\t\t   0x00ff0000,\n\t\t\t\t\t\t\t\t\t   0x0000ff00,\n\t\t\t\t\t\t\t\t\t   0x000000ff,\n\t\t\t\t\t\t\t\t\t   0xff000000);\n\t*/\n\tsurface = SDL_CreateRGBSurface(SDL_SWSURFACE | SDL_SRCCOLORKEY,\n\t                               gif->width, gif->height, 8,\n\t\t\t\t\t\t\t\t   0,0,0,0);\n\tSDL_LockSurface(surface);\n\tif(gif->cur_img->gce.transparent_flag)\n\t{\n\t\tSDL_SetColorKey(surface, SDL_SRCCOLORKEY, gif->cur_img->gce.transparent_color);\n\t}\n\tfor(i=0; i<gif->ncolors; i++)\n\t{\n\t\tsurface->format->palette->colors[i].r = gif->palette[i].r;\n\t\tsurface->format->palette->colors[i].g = gif->palette[i].g;\n\t\tsurface->format->palette->colors[i].b = gif->palette[i].b;\n\t}\n\tpsrc = p; pdst = surface->pixels;\n\tfor(i=0; i<gif->height; i++)\n\t{\n\t\tngiflib_memcpy(pdst, psrc, gif->width);\n\t\tpdst += surface->pitch;\n\t\tpsrc += gif->width;\n\t}\n\tSDL_UnlockSurface(surface);\n\tGifDestroy(gif);\n\treturn surface;\n}", "target": 2, "idx": 11630}
{"commit_id": "f56136eb9f7e1bb0f34cd1bace60c4c02a0ed6ea", "project": "systemd", "func": "static int dns_transaction_requires_rrsig(DnsTransaction *t, DnsResourceRecord *rr) {\n        int r;\n\n        assert(t);\n        assert(rr);\n\n        /* Checks if the RR we are looking for must be signed with an\n         * RRSIG. This is used for positive responses. */\n\n        if (t->scope->dnssec_mode == DNSSEC_NO)\n                return false;\n\n        if (dns_type_is_pseudo(rr->key->type))\n                return -EINVAL;\n\n        r = dns_transaction_negative_trust_anchor_lookup(t, dns_resource_key_name(rr->key));\n        if (r < 0)\n                return r;\n        if (r > 0)\n                return false;\n\n        switch (rr->key->type) {\n\n        case DNS_TYPE_RRSIG:\n                /* RRSIGs are the signatures themselves, they need no signing. */\n                return false;\n\n        case DNS_TYPE_SOA:\n        case DNS_TYPE_NS: {\n                DnsTransaction *dt;\n\n                /* For SOA or NS RRs we look for a matching DS transaction */\n\n                SET_FOREACH(dt, t->dnssec_transactions) {\n\n                        if (dns_transaction_key(dt)->class != rr->key->class)\n                                continue;\n                        if (dns_transaction_key(dt)->type != DNS_TYPE_DS)\n                                continue;\n\n                        r = dns_name_equal(dns_resource_key_name(dns_transaction_key(dt)), dns_resource_key_name(rr->key));\n                        if (r < 0)\n                                return r;\n                        if (r == 0)\n                                continue;\n\n                        /* We found a DS transactions for the SOA/NS\n                         * RRs we are looking at. If it discovered signed DS\n                         * RRs, then we need to be signed, too. */\n\n                        if (!FLAGS_SET(dt->answer_query_flags, SD_RESOLVED_AUTHENTICATED))\n                                return false;\n\n                        return dns_answer_match_key(dt->answer, dns_transaction_key(dt), NULL);\n                }\n\n                /* We found nothing that proves this is safe to leave\n                 * this unauthenticated, hence ask inist on\n                 * authentication. */\n                return true;\n        }\n\n        case DNS_TYPE_DS:\n        case DNS_TYPE_CNAME:\n        case DNS_TYPE_DNAME: {\n                const char *parent = NULL;\n                DnsTransaction *dt;\n\n                /*\n                 * CNAME/DNAME RRs cannot be located at a zone apex, hence look directly for the parent SOA.\n                 *\n                 * DS RRs are signed if the parent is signed, hence also look at the parent SOA\n                 */\n\n                SET_FOREACH(dt, t->dnssec_transactions) {\n\n                        if (dns_transaction_key(dt)->class != rr->key->class)\n                                continue;\n                        if (dns_transaction_key(dt)->type != DNS_TYPE_SOA)\n                                continue;\n\n                        if (!parent) {\n                                parent = dns_resource_key_name(rr->key);\n                                r = dns_name_parent(&parent);\n                                if (r < 0)\n                                        return r;\n                                if (r == 0) {\n                                        if (rr->key->type == DNS_TYPE_DS)\n                                                return true;\n\n                                        /* A CNAME/DNAME without a parent? That's sooo weird. */\n                                        return log_debug_errno(SYNTHETIC_ERRNO(EBADMSG),\n                                                               \"Transaction %\" PRIu16 \" claims CNAME/DNAME at root. Refusing.\", t->id);\n                                }\n                        }\n\n                        r = dns_name_equal(dns_resource_key_name(dns_transaction_key(dt)), parent);\n                        if (r < 0)\n                                return r;\n                        if (r == 0)\n                                continue;\n\n                        return FLAGS_SET(dt->answer_query_flags, SD_RESOLVED_AUTHENTICATED);\n                }\n\n                return true;\n        }\n\n        default: {\n                DnsTransaction *dt;\n\n                /* Any other kind of RR (including DNSKEY/NSEC/NSEC3). Let's see if our SOA lookup was authenticated */\n\n                SET_FOREACH(dt, t->dnssec_transactions) {\n\n                        if (dns_transaction_key(dt)->class != rr->key->class)\n                                continue;\n                        if (dns_transaction_key(dt)->type != DNS_TYPE_SOA)\n                                continue;\n\n                        r = dns_name_equal(dns_resource_key_name(dns_transaction_key(dt)), dns_resource_key_name(rr->key));\n                        if (r < 0)\n                                return r;\n                        if (r == 0)\n                                continue;\n\n                        /* We found the transaction that was supposed to find the SOA RR for us. It was\n                         * successful, but found no RR for us. This means we are not at a zone cut. In this\n                         * case, we require authentication if the SOA lookup was authenticated too. */\n                        return FLAGS_SET(dt->answer_query_flags, SD_RESOLVED_AUTHENTICATED);\n                }\n\n                return true;\n        }}\n}", "target": 1, "idx": 11631}
{"commit_id": "66cb1320242db9ce2954a539dc2d5410bf033dbd", "project": "chromium", "func": "void ElementAnimations::NotifyPlayersAnimationAborted(\n    base::TimeTicks monotonic_time,\n    TargetProperty::Type target_property,\n    int group) {\n  ElementAnimations::PlayersList::Iterator it(players_list_.get());\n  AnimationPlayer* player;\n  while ((player = it.GetNext()) != nullptr)\n    player->NotifyAnimationAborted(monotonic_time, target_property, group);\n}", "target": 2, "idx": 11632}
{"commit_id": "6e396c50a4630c1bd065aaf19244cf8c1fdcd6d1", "project": "chromium", "func": "inline void LayoutObject::setNeedsLayout(LayoutInvalidationReasonForTracing reason, MarkingBehavior markParents, SubtreeLayoutScope* layouter)\n{\n    ASSERT(!isSetNeedsLayoutForbidden());\n    bool alreadyNeededLayout = m_bitfields.selfNeedsLayout();\n    setSelfNeedsLayout(true);\n    if (!alreadyNeededLayout) {\n        TRACE_EVENT_INSTANT1(\n            TRACE_DISABLED_BY_DEFAULT(\"devtools.timeline.invalidationTracking\"),\n            \"LayoutInvalidationTracking\",\n            TRACE_EVENT_SCOPE_THREAD,\n            \"data\",\n            InspectorLayoutInvalidationTrackingEvent::data(this, reason));\n        if (markParents == MarkContainerChain && (!layouter || layouter->root() != this))\n            markContainerChainForLayout(layouter);\n    }\n}", "target": 2, "idx": 11633}
{"commit_id": "21998a351512eba4ed5969006f0c55882d995ada", "project": "torvalds/linux", "func": "void arch_seccomp_spec_mitigate(struct task_struct *task)\n{\n\tif (ssb_mode == SPEC_STORE_BYPASS_SECCOMP)\n\t\tssb_prctl_set(task, PR_SPEC_FORCE_DISABLE);\n\tif (spectre_v2_user_ibpb == SPECTRE_V2_USER_SECCOMP ||\n\t    spectre_v2_user_stibp == SPECTRE_V2_USER_SECCOMP)\n\t\tib_prctl_set(task, PR_SPEC_FORCE_DISABLE);\n}", "target": 1, "idx": 11634}
{"commit_id": "47a26a32c9a2cd630c48517c3e6ab2fa5f6a26ad", "project": "gpac", "func": "GF_Err BM_ParseRouteInsert(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tGF_Err e;\n\tu8 flag;\n\tGF_Command *com;\n\tGF_Node *InNode, *OutNode;\n\tu32 RouteID, outField, inField, numBits, ind, node_id;\n\tchar name[1000];\n\n\tRouteID = 0;\n\n\tflag = gf_bs_read_int(bs, 1);\n\t/*def'ed route*/\n\tif (flag) {\n\t\tRouteID = 1 + gf_bs_read_int(bs, codec->info->config.RouteIDBits);\n\t\tif (codec->UseName) gf_bifs_dec_name(bs, name, 1000);\n\t}\n\t/*origin*/\n\tnode_id = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\tOutNode = gf_sg_find_node(codec->current_graph, node_id);\n\tif (!OutNode) return GF_SG_UNKNOWN_NODE;\n\n\tnumBits = gf_node_get_num_fields_in_mode(OutNode, GF_SG_FIELD_CODING_OUT) - 1;\n\tnumBits = gf_get_bit_size(numBits);\n\tind = gf_bs_read_int(bs, numBits);\n\te = gf_bifs_get_field_index(OutNode, ind, GF_SG_FIELD_CODING_OUT, &outField);\n\tif (e) return e;\n\n\t/*target*/\n\tnode_id = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\tInNode = gf_sg_find_node(codec->current_graph, node_id);\n\tif (!InNode) return GF_SG_UNKNOWN_NODE;\n\n\tnumBits = gf_node_get_num_fields_in_mode(InNode, GF_SG_FIELD_CODING_IN) - 1;\n\tnumBits = gf_get_bit_size(numBits);\n\tind = gf_bs_read_int(bs, numBits);\n\te = gf_bifs_get_field_index(InNode, ind, GF_SG_FIELD_CODING_IN, &inField);\n\tif (e) return e;\n\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_ROUTE_INSERT);\n\tcom->RouteID = RouteID;\n\tif (codec->UseName) com->def_name = gf_strdup( name);\n\tcom->fromNodeID = gf_node_get_id(OutNode);\n\tcom->fromFieldIndex = outField;\n\tcom->toNodeID = gf_node_get_id(InNode);\n\tcom->toFieldIndex = inField;\n\tgf_list_add(com_list, com);\n\treturn codec->LastError;\n}", "target": 1, "idx": 11635}
{"commit_id": "80eecda8e5d09c442c24307f340840a5b70ea3b9", "project": "qemu", "func": "static int is_rndis(USBNetState *s)\n{\n    return s->dev.config ?\n            s->dev.config->bConfigurationValue == DEV_RNDIS_CONFIG_VALUE : 0;\n}", "target": 1, "idx": 11636}
{"commit_id": "6297a117d77fa3a0df2e21ca926a92c231819cd5", "project": "php/php-src", "func": "static int php_stream_memory_set_option(php_stream *stream, int option, int value, void *ptrparam TSRMLS_DC) /* {{{ */\n{\n\tphp_stream_memory_data *ms = (php_stream_memory_data*)stream->abstract;\n\tsize_t newsize;\n\n\tswitch(option) {\n\t\tcase PHP_STREAM_OPTION_TRUNCATE_API:\n\t\t\tswitch (value) {\n\t\t\t\tcase PHP_STREAM_TRUNCATE_SUPPORTED:\n\t\t\t\t\treturn PHP_STREAM_OPTION_RETURN_OK;\n\n\t\t\t\tcase PHP_STREAM_TRUNCATE_SET_SIZE:\n\t\t\t\t\tif (ms->mode & TEMP_STREAM_READONLY) {\n\t\t\t\t\t\treturn PHP_STREAM_OPTION_RETURN_ERR;\n\t\t\t\t\t}\n\t\t\t\t\tnewsize = *(size_t*)ptrparam;\n\t\t\t\t\tif (newsize <= ms->fsize) {\n\t\t\t\t\t\tif (newsize < ms->fpos) {\n\t\t\t\t\t\t\tms->fpos = newsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tms->data = erealloc(ms->data, newsize);\n\t\t\t\t\t\tmemset(ms->data+ms->fsize, 0, newsize - ms->fsize);\n\t\t\t\t\t\tms->fsize = newsize;\n\t\t\t\t\t}\n\t\t\t\t\tms->fsize = newsize;\n\t\t\t\t\treturn PHP_STREAM_OPTION_RETURN_OK;\n\t\t\t}\n\t\tdefault:\n\t\t\treturn PHP_STREAM_OPTION_RETURN_NOTIMPL;\n\t}\n}", "target": 2, "idx": 11637}
{"commit_id": "0301ce1486b1450f219202677f30d0fa97335419", "project": "binutils-gdb", "func": "static bfd_boolean\naout_get_external_symbols (bfd *abfd)\n{\n  if (obj_aout_external_syms (abfd) == NULL)\n    {\n      bfd_size_type count;\n      struct external_nlist *syms;\n      bfd_size_type amt = exec_hdr (abfd)->a_syms;\n\n      count = amt / EXTERNAL_NLIST_SIZE;\n      if (count == 0)\n\treturn TRUE;\t\t/* Nothing to do.  */\n\n#ifdef USE_MMAP\n      if (! bfd_get_file_window (abfd, obj_sym_filepos (abfd), amt,\n\t\t\t\t &obj_aout_sym_window (abfd), TRUE))\n\treturn FALSE;\n      syms = (struct external_nlist *) obj_aout_sym_window (abfd).data;\n#else\n      /* We allocate using malloc to make the values easy to free\n\t later on.  If we put them on the objalloc it might not be\n\t possible to free them.  */\n      syms = (struct external_nlist *) bfd_malloc (amt);\n      if (syms == NULL)\n\treturn FALSE;\n\n      if (bfd_seek (abfd, obj_sym_filepos (abfd), SEEK_SET) != 0\n\t  || bfd_bread (syms, amt, abfd) != amt)\n\t{\n\t  free (syms);\n\t  return FALSE;\n\t}\n#endif\n\n      obj_aout_external_syms (abfd) = syms;\n      obj_aout_external_sym_count (abfd) = count;\n    }\n\n  if (obj_aout_external_strings (abfd) == NULL\n      && exec_hdr (abfd)->a_syms != 0)\n    {\n      unsigned char string_chars[BYTES_IN_WORD];\n      bfd_size_type stringsize;\n      char *strings;\n      bfd_size_type amt = BYTES_IN_WORD;\n\n      /* Get the size of the strings.  */\n      if (bfd_seek (abfd, obj_str_filepos (abfd), SEEK_SET) != 0\n\t  || bfd_bread ((void *) string_chars, amt, abfd) != amt)\n\treturn FALSE;\n      stringsize = GET_WORD (abfd, string_chars);\n      if (stringsize == 0)\n\tstringsize = 1;\n      else if (stringsize < BYTES_IN_WORD\n\t       || (size_t) stringsize != stringsize)\n\t{\n\t  bfd_set_error (bfd_error_bad_value);\n\t  return FALSE;\n\t}\n\n#ifdef USE_MMAP\n      if (stringsize >= BYTES_IN_WORD)\n\t{\n\t  if (! bfd_get_file_window (abfd, obj_str_filepos (abfd), stringsize,\n\t\t\t\t     &obj_aout_string_window (abfd), TRUE))\n\t    return FALSE;\n\t  strings = (char *) obj_aout_string_window (abfd).data;\n\t}\n      else\n#endif\n\t{\n\t  strings = (char *) bfd_malloc (stringsize);\n\t  if (strings == NULL)\n\t    return FALSE;\n\n\t  if (stringsize >= BYTES_IN_WORD)\n\t    {\n\t      /* Keep the string count in the buffer for convenience\n\t\t when indexing with e_strx.  */\n\t      amt = stringsize - BYTES_IN_WORD;\n\t      if (bfd_bread (strings + BYTES_IN_WORD, amt, abfd) != amt)\n\t\t{\n\t\t  free (strings);\n\t\t  return FALSE;\n\t\t}\n\t    }\n\t}\n      /* Ensure that a zero index yields an empty string.  */\n      strings[0] = '\\0';\n\n      strings[stringsize - 1] = 0;\n\n      obj_aout_external_strings (abfd) = strings;\n      obj_aout_external_string_size (abfd) = stringsize;\n    }\n\n  return TRUE;\n}", "target": 2, "idx": 11638}
{"commit_id": "4a8b02d5f1afb38b00c77ab1321d5f56720f4e30", "project": "MisterTea/EternalTerminal", "func": "int main(int argc, char** argv) {\n  // Setup easylogging configurations\n  el::Configurations defaultConf = LogHandler::setupLogHandler(&argc, &argv);\n  LogHandler::setupStdoutLogger();\n\n  et::HandleTerminate();\n\n  // Override easylogging handler for sigint\n  ::signal(SIGINT, et::InterruptSignalHandler);\n\n  // Parse command line arguments\n  cxxopts::Options options(\"etterminal\", \"User terminal for Eternal Terminal.\");\n\n  try {\n    options.allow_unrecognised_options();\n\n    options.add_options()         //\n        (\"h,help\", \"Print help\")  //\n        (\"idpasskey\",\n         \"If set, uses IPC to send a client id/key to the server daemon. \"\n         \"Alternatively, pass in via stdin.\",\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"idpasskeyfile\",\n         \"If set, uses IPC to send a client id/key to the server daemon from a \"\n         \"file. Alternatively, pass in via stdin.\",\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"jump\",\n         \"If set, forward all packets between client and dst terminal\")  //\n        (\"dsthost\", \"Must be set if jump is set to true\",\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"dstport\", \"Must be set if jump is set to true\",\n         cxxopts::value<int>()->default_value(\"2022\"))  //\n        // Not used by etterminal but easylogging uses this flag under the hood\n        (\"v,verbose\", \"Enable verbose logging\",\n         cxxopts::value<int>()->default_value(\"0\"))  //\n        (\"logtostdout\", \"Write log to stdout\")       //\n        (\"serverfifo\",\n         \"If set, connects to the etserver instance listening on the matching \"\n         \"fifo name\",                                       //\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        ;\n\n    auto result = options.parse(argc, argv);\n    if (result.count(\"help\")) {\n      CLOG(INFO, \"stdout\") << options.help({}) << endl;\n      exit(0);\n    }\n\n    el::Loggers::setVerboseLevel(result[\"verbose\"].as<int>());\n\n    GOOGLE_PROTOBUF_VERIFY_VERSION;\n    srand(1);\n\n    ServerFifoPath serverFifo;\n    if (!result[\"serverfifo\"].as<string>().empty()) {\n      serverFifo.setPathOverride(result[\"serverfifo\"].as<string>());\n    }\n\n    shared_ptr<SocketHandler> ipcSocketHandler(new PipeSocketHandler());\n    shared_ptr<PsuedoUserTerminal> term(new PsuedoUserTerminal());\n\n    string idpasskey;\n    if (result.count(\"idpasskey\") == 0 && result.count(\"idpasskeyfile\") == 0) {\n      // Try to read from stdin\n      struct timeval timeout;\n      timeout.tv_sec = 1;\n      timeout.tv_usec = 0;\n      fd_set readfds;\n      FD_ZERO(&readfds);\n\n      FD_SET(STDIN_FILENO, &readfds);\n\n      int selectResult = 0;\n      do {\n        // Repeatedly calls when interrupted, up to the timeout.\n        selectResult = select(1, &readfds, NULL, NULL, &timeout);\n      } while (selectResult < 0 && errno == EINTR);\n\n      FATAL_FAIL(selectResult);\n      if (selectResult == 0) {\n        CLOG(INFO, \"stdout\")\n            << \"Call etterminal with --idpasskey or --idpasskeyfile, or feed \"\n               \"this information on stdin\\n\";\n        exit(1);\n      }\n\n      string stdinData;\n      if (!getline(cin, stdinData)) {\n        CLOG(INFO, \"stdout\")\n            << \"Call etterminal with --idpasskey or --idpasskeyfile, or feed \"\n               \"this information on stdin\\n\";\n        exit(1);\n      }\n      auto tokens = split(stdinData, '_');\n      if (tokens.size() == 2) {\n        idpasskey = tokens[0];\n        if (idpasskey.substr(0, 3) == std::string(\"XXX\")) {\n          // New client connecting to new server, throw away passkey and\n          // regenerate\n          string passkey = genRandomAlphaNum(32);\n          string id = genRandomAlphaNum(16);\n          idpasskey = id + string(\"/\") + passkey;\n        }\n\n        FATAL_FAIL(setenv(\"TERM\", tokens[1].c_str(), 1));\n      } else {\n        STFATAL << \"Invalid number of tokens: \" << tokens.size();\n      }\n    } else {\n      string idpasskey = result[\"idpasskey\"].as<string>();\n      if (result.count(\"idpasskeyfile\")) {\n        // Check for passkey file\n        std::ifstream t(result[\"idpasskeyfile\"].as<string>().c_str());\n        std::stringstream buffer;\n        buffer << t.rdbuf();\n        idpasskey = buffer.str();\n        // Trim whitespace\n        idpasskey.erase(idpasskey.find_last_not_of(\" \\n\\r\\t\") + 1);\n      }\n    }\n\n    string id = split(idpasskey, '/')[0];\n    string username = string(ssh_get_local_username());\n    if (result.count(\"jump\")) {\n      // etserver with --jump cannot write to the default log file(root)\n      LogHandler::setupLogFiles(&defaultConf, GetTempDirectory(),\n                                (\"etjump-\" + username + \"-\" + id),\n                                result.count(\"logtostdout\"), false);\n      // Reconfigure default logger to apply settings above\n      el::Loggers::reconfigureLogger(\"default\", defaultConf);\n      // set thread name\n      el::Helpers::setThreadName(\"jump-main\");\n      // Install log rotation callback\n      el::Helpers::installPreRollOutCallback(LogHandler::rolloutHandler);\n\n      CLOG(INFO, \"stdout\") << \"IDPASSKEY:\" << idpasskey << endl;\n      if (DaemonCreator::createSessionLeader() == -1) {\n        STFATAL << \"Error creating daemon: \" << strerror(GetErrno());\n      }\n      SocketEndpoint destinationEndpoint;\n      destinationEndpoint.set_name(result[\"dsthost\"].as<string>());\n      destinationEndpoint.set_port(result[\"dstport\"].as<int>());\n      shared_ptr<SocketHandler> jumpClientSocketHandler(new TcpSocketHandler());\n      UserJumphostHandler ujh(jumpClientSocketHandler, idpasskey,\n                              destinationEndpoint, ipcSocketHandler,\n                              serverFifo.getEndpointForConnect());\n      ujh.run();\n\n      // Uninstall log rotation callback\n      el::Helpers::uninstallPreRollOutCallback();\n      return 0;\n    }\n\n    // etserver with --idpasskey cannot write to the default log file(root)\n    LogHandler::setupLogFiles(&defaultConf, GetTempDirectory(),\n                              (\"etterminal-\" + username + \"-\" + id),\n                              result.count(\"logtostdout\"), false);\n\n    // Reconfigure default logger to apply settings above\n    el::Loggers::reconfigureLogger(\"default\", defaultConf);\n    // set thread name\n    el::Helpers::setThreadName(\"terminal-main\");\n    // Install log rotation callback\n    el::Helpers::installPreRollOutCallback(LogHandler::rolloutHandler);\n\n    UserTerminalHandler uth(ipcSocketHandler, term, true,\n                            serverFifo.getEndpointForConnect(), idpasskey);\n    CLOG(INFO, \"stdout\") << \"IDPASSKEY:\" << idpasskey << endl;\n    if (DaemonCreator::createSessionLeader() == -1) {\n      STFATAL << \"Error creating daemon: \" << strerror(GetErrno());\n    }\n    uth.run();\n\n  } catch (cxxopts::OptionException& oe) {\n    CLOG(INFO, \"stdout\") << \"Exception: \" << oe.what() << \"\\n\" << endl;\n    CLOG(INFO, \"stdout\") << options.help({}) << endl;\n    exit(1);\n  }\n\n  // Uninstall log rotation callback\n  el::Helpers::uninstallPreRollOutCallback();\n  return 0;\n}", "target": 1, "idx": 11639}
{"commit_id": "c394a488942387246653833359a5c94b5832674e", "project": "openssl", "func": "static X509_ALGOR *rsa_mgf1_decode(X509_ALGOR *alg)\n{\n    const unsigned char *p;\n    int plen;\n    if (alg == NULL || alg->parameter == NULL)\n        return NULL;\n    if (OBJ_obj2nid(alg->algorithm) != NID_mgf1)\n        return NULL;\n    if (alg->parameter->type != V_ASN1_SEQUENCE)\n        return NULL;\n\n    p = alg->parameter->value.sequence->data;\n    plen = alg->parameter->value.sequence->length;\n    return d2i_X509_ALGOR(NULL, &p, plen);\n}", "target": 2, "idx": 11640}
{"commit_id": "b20e1639dbac84b3fcb393858521c13ad47a9d70", "project": "the-tcpdump-group/tcpdump", "func": "static int\nisis_print_mt_capability_subtlv(netdissect_options *ndo,\n                                const uint8_t *tptr, int len)\n{\n  int stlv_type, stlv_len, tmp;\n\n  while (len > 2)\n  {\n    ND_TCHECK2(*tptr, 2);\n    stlv_type = *(tptr++);\n    stlv_len  = *(tptr++);\n\n    /* first lets see if we know the subTLVs name*/\n    ND_PRINT((ndo, \"\\n\\t      %s subTLV #%u, length: %u\",\n               tok2str(isis_mt_capability_subtlv_values, \"unknown\", stlv_type),\n               stlv_type,\n               stlv_len));\n\n    len = len - 2;\n\n    /* Make sure the subTLV fits within the space left */\n    if (len < stlv_len)\n      goto trunc;\n    /* Make sure the entire subTLV is in the captured data */\n    ND_TCHECK2(*(tptr), stlv_len);\n\n    switch (stlv_type)\n    {\n      case ISIS_SUBTLV_SPB_INSTANCE:\n          if (stlv_len < ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN)\n            goto trunc;\n\n          ND_PRINT((ndo, \"\\n\\t        CIST Root-ID: %08x\", EXTRACT_32BITS(tptr)));\n          tptr = tptr+4;\n          ND_PRINT((ndo, \" %08x\", EXTRACT_32BITS(tptr)));\n          tptr = tptr+4;\n          ND_PRINT((ndo, \", Path Cost: %08x\", EXTRACT_32BITS(tptr)));\n          tptr = tptr+4;\n          ND_PRINT((ndo, \", Prio: %d\", EXTRACT_16BITS(tptr)));\n          tptr = tptr + 2;\n          ND_PRINT((ndo, \"\\n\\t        RES: %d\",\n                    EXTRACT_16BITS(tptr) >> 5));\n          ND_PRINT((ndo, \", V: %d\",\n                    (EXTRACT_16BITS(tptr) >> 4) & 0x0001));\n          ND_PRINT((ndo, \", SPSource-ID: %d\",\n                    (EXTRACT_32BITS(tptr) & 0x000fffff)));\n          tptr = tptr+4;\n          ND_PRINT((ndo, \", No of Trees: %x\", *(tptr)));\n\n          tmp = *(tptr++);\n\n          len = len - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN;\n          stlv_len = stlv_len - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN;\n\n          while (tmp)\n          {\n            if (stlv_len < ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN)\n              goto trunc;\n\n            ND_PRINT((ndo, \"\\n\\t         U:%d, M:%d, A:%d, RES:%d\",\n                      *(tptr) >> 7, (*(tptr) >> 6) & 0x01,\n                      (*(tptr) >> 5) & 0x01, (*(tptr) & 0x1f)));\n\n            tptr++;\n\n            ND_PRINT((ndo, \", ECT: %08x\", EXTRACT_32BITS(tptr)));\n\n            tptr = tptr + 4;\n\n            ND_PRINT((ndo, \", BVID: %d, SPVID: %d\",\n                      (EXTRACT_24BITS(tptr) >> 12) & 0x000fff,\n                      EXTRACT_24BITS(tptr) & 0x000fff));\n\n            tptr = tptr + 3;\n            len = len - ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN;\n            stlv_len = stlv_len - ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN;\n            tmp--;\n          }\n\n          break;\n\n      case ISIS_SUBTLV_SPBM_SI:\n          if (stlv_len < 8)\n            goto trunc;\n\n          ND_PRINT((ndo, \"\\n\\t        BMAC: %08x\", EXTRACT_32BITS(tptr)));\n          tptr = tptr+4;\n          ND_PRINT((ndo, \"%04x\", EXTRACT_16BITS(tptr)));\n          tptr = tptr+2;\n\n          ND_PRINT((ndo, \", RES: %d, VID: %d\", EXTRACT_16BITS(tptr) >> 12,\n                    (EXTRACT_16BITS(tptr)) & 0x0fff));\n\n          tptr = tptr+2;\n          len = len - 8;\n          stlv_len = stlv_len - 8;\n\n          while (stlv_len >= 4) {\n            ND_TCHECK2(*tptr, 4);\n            ND_PRINT((ndo, \"\\n\\t        T: %d, R: %d, RES: %d, ISID: %d\",\n                    (EXTRACT_32BITS(tptr) >> 31),\n                    (EXTRACT_32BITS(tptr) >> 30) & 0x01,\n                    (EXTRACT_32BITS(tptr) >> 24) & 0x03f,\n                    (EXTRACT_32BITS(tptr)) & 0x0ffffff));\n\n            tptr = tptr + 4;\n            len = len - 4;\n            stlv_len = stlv_len - 4;\n          }\n\n        break;\n\n      default:\n        break;\n    }\n    tptr += stlv_len;\n    len -= stlv_len;\n  }\n  return 0;\n\n  trunc:\n    ND_PRINT((ndo, \"\\n\\t\\t\"));\n    ND_PRINT((ndo, \"%s\", tstr));\n    return(1);\n}", "target": 3, "idx": 11641}
{"commit_id": "02c3dad0f3b4d26e0faa5cc51d06bc50d693dcdc", "project": "mesa", "func": "static char *\nalloc_shm(struct dri_sw_displaytarget *dri_sw_dt, unsigned size)\n{\n   char *addr;\n\n   /* 0600 = user read+write */\n   dri_sw_dt->shmid = shmget(IPC_PRIVATE, size, IPC_CREAT | 0600);\n   if (dri_sw_dt->shmid < 0)\n      return NULL;\n\n   addr = (char *) shmat(dri_sw_dt->shmid, 0, 0);\n   /* mark the segment immediately for deletion to avoid leaks */\n   shmctl(dri_sw_dt->shmid, IPC_RMID, 0);\n\n   if (addr == (char *) -1)\n      return NULL;\n\n   return addr;\n}", "target": 1, "idx": 11642}
{"commit_id": "3f8449c647e5ab32cf6f8837cb600c1756b6189c", "project": "sympa-community/sympa", "func": "int main(int argn, char **argv, char **envp) {\n    char *myenvp[] = { \"IFS= \\t\\n\", \"PATH=/bin:/usr/bin\", NULL };\n\n    setreuid(geteuid(),geteuid());\n    setregid(getegid(),getegid());\n    argv[0] = SYMPASOAP;\n    return execve(SYMPASOAP, argv, myenvp);\n}", "target": 2, "idx": 11643}
{"commit_id": "f5364c150aa645b3d7daa21b5c0b9feaa1c9cd6d", "project": "torvalds/linux", "func": "int ecryptfs_privileged_open(struct file **lower_file,\n\t\t\t     struct dentry *lower_dentry,\n\t\t\t     struct vfsmount *lower_mnt,\n\t\t\t     const struct cred *cred)\n{\n\tstruct ecryptfs_open_req req;\n\tint flags = O_LARGEFILE;\n\tint rc = 0;\n\n\tinit_completion(&req.done);\n\treq.lower_file = lower_file;\n\treq.path.dentry = lower_dentry;\n\treq.path.mnt = lower_mnt;\n\n\t/* Corresponding dput() and mntput() are done when the\n\t * lower file is fput() when all eCryptfs files for the inode are\n\t * released. */\n\tflags |= IS_RDONLY(d_inode(lower_dentry)) ? O_RDONLY : O_RDWR;\n\t(*lower_file) = dentry_open(&req.path, flags, cred);\n\tif (!IS_ERR(*lower_file))\n\t\tgoto have_file;\n\tif ((flags & O_ACCMODE) == O_RDONLY) {\n\t\trc = PTR_ERR((*lower_file));\n\t\tgoto out;\n\t}\n\tmutex_lock(&ecryptfs_kthread_ctl.mux);\n\tif (ecryptfs_kthread_ctl.flags & ECRYPTFS_KTHREAD_ZOMBIE) {\n\t\trc = -EIO;\n\t\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\t\tprintk(KERN_ERR \"%s: We are in the middle of shutting down; \"\n\t\t       \"aborting privileged request to open lower file\\n\",\n\t\t\t__func__);\n\t\tgoto out;\n\t}\n\tlist_add_tail(&req.kthread_ctl_list, &ecryptfs_kthread_ctl.req_list);\n\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\twake_up(&ecryptfs_kthread_ctl.wait);\n\twait_for_completion(&req.done);\n\tif (IS_ERR(*lower_file)) {\n\t\trc = PTR_ERR(*lower_file);\n\t\tgoto out;\n\t}\nhave_file:\n\tif ((*lower_file)->f_op->mmap == NULL) {\n\t\tfput(*lower_file);\n\t\t*lower_file = NULL;\n\t\trc = -EMEDIUMTYPE;\n\t}\nout:\n\treturn rc;\n}", "target": 2, "idx": 11644}
{"commit_id": "4dd2b82d5adfbe0b1587ccad7a8f76d826120f37", "project": "kernel/git/netdev/net", "func": "static struct sk_buff *udp_gro_receive_segment(struct list_head *head,\n\t\t\t\t\t       struct sk_buff *skb)\n{\n\tstruct udphdr *uh = udp_hdr(skb);\n\tstruct sk_buff *pp = NULL;\n\tstruct udphdr *uh2;\n\tstruct sk_buff *p;\n\tunsigned int ulen;\n\n\t/* requires non zero csum, for symmetry with GSO */\n\tif (!uh->check) {\n\t\tNAPI_GRO_CB(skb)->flush = 1;\n\t\treturn NULL;\n\t}\n\n\t/* Do not deal with padded or malicious packets, sorry ! */\n\tulen = ntohs(uh->len);\n\tif (ulen <= sizeof(*uh) || ulen != skb_gro_len(skb)) {\n\t\tNAPI_GRO_CB(skb)->flush = 1;\n\t\treturn NULL;\n\t}\n\t/* pull encapsulating udp header */\n\tskb_gro_pull(skb, sizeof(struct udphdr));\n\tskb_gro_postpull_rcsum(skb, uh, sizeof(struct udphdr));\n\n\tlist_for_each_entry(p, head, list) {\n\t\tif (!NAPI_GRO_CB(p)->same_flow)\n\t\t\tcontinue;\n\n\t\tuh2 = udp_hdr(p);\n\n\t\t/* Match ports only, as csum is always non zero */\n\t\tif ((*(u32 *)&uh->source != *(u32 *)&uh2->source)) {\n\t\t\tNAPI_GRO_CB(p)->same_flow = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Terminate the flow on len mismatch or if it grow \"too much\".\n\t\t * Under small packet flood GRO count could elsewhere grow a lot\n\t\t * leading to excessive truesize values.\n\t\t * On len mismatch merge the first packet shorter than gso_size,\n\t\t * otherwise complete the GRO packet.\n\t\t */\n\t\tif (ulen > ntohs(uh2->len) || skb_gro_receive(p, skb) ||\n\t\t    ulen != ntohs(uh2->len) ||\n\t\t    NAPI_GRO_CB(p)->count >= UDP_GRO_CNT_MAX)\n\t\t\tpp = p;\n\n\t\treturn pp;\n\t}\n\n\t/* mismatch, but we never need to flush */\n\treturn NULL;\n}", "target": 3, "idx": 11645}
{"commit_id": "dd528b3aabd13863f855a68e76966e4e019fc399", "project": "babelouest/rhonabwy", "func": "int\nrsa_oaep_sha256_decrypt(const struct rsa_private_key *key,\n\t    size_t label_length, const uint8_t *label,\n\t    size_t *length, uint8_t *message,\n\t    const mpz_t gibberish)\n{\n  mpz_t m;\n  int res;\n  struct sha256_ctx ctx;\n\n  if (nettle_mpz_sizeinbase_256_u (gibberish) > key->size ||\n      key->size < (2*SHA1_DIGEST_SIZE)+2) {\n    return 0;\n  }\n\n  mpz_init(m);\n  rsa_compute_root(key, m, gibberish);\n\n  res = pkcs1_oaep_decrypt (key->size, m, SHA256_DIGEST_SIZE,\n                            &ctx, &nettle_sha256, (nettle_hash_init_func*)&sha256_init, (nettle_hash_update_func*)&sha256_update, (nettle_hash_digest_func*)&sha256_digest,\n                            label_length, label, length, message);\n  mpz_clear(m);\n  return res;\n}", "target": 2, "idx": 11646}
{"commit_id": "afb7a814783cda12f5b72167163b9109ee1d15a7", "project": "coreboot", "func": "static int install_permanent_handler(int num_cpus, uintptr_t smbase,\n\t\t\t\t\tsize_t smsize, size_t save_state_size)\n{\n\t/*\n\t * All the CPUs will relocate to permanaent handler now. Set parameters\n\t * needed for all CPUs. The placement of each CPUs entry point is\n\t * determined by the loader. This code simply provides the beginning of\n\t * SMRAM region, the number of CPUs who will use the handler, the stack\n\t * size and save state size for each CPU.\n\t */\n\tstruct smm_loader_params smm_params = {\n\t\t.per_cpu_stack_size = CONFIG_SMM_MODULE_STACK_SIZE,\n\t\t.num_concurrent_stacks = num_cpus,\n\t\t.per_cpu_save_state_size = save_state_size,\n\t\t.num_concurrent_save_states = num_cpus,\n\t};\n\n\t/* Allow callback to override parameters. */\n\tif (mp_state.ops.adjust_smm_params != NULL)\n\t\tmp_state.ops.adjust_smm_params(&smm_params, 1);\n\n\tprintk(BIOS_DEBUG, \"Installing permanent SMM handler to 0x%08lx\\n\", smbase);\n\n\tif (smm_load_module((void *)smbase, smsize, &smm_params))\n\t\treturn -1;\n\n\tadjust_smm_apic_id_map(&smm_params);\n\n\treturn 0;\n}", "target": 3, "idx": 11647}
{"commit_id": "fba4f123cc456d2b2538f811bb831483bf336bad", "project": "libarchive", "func": "static int\nset_acl(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode,\n    int ae_requested_type, const char *tname)\n{\n\tint\t\t acl_type = 0;\n\tacl_t\t\t acl;\n\tacl_entry_t\t acl_entry;\n\tacl_permset_t\t acl_permset;\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\tacl_flagset_t\t acl_flagset;\n\tint\t\t r;\n#endif\n\tint\t\t ret;\n\tint\t\t ae_type, ae_permset, ae_tag, ae_id;\n\tint\t\t perm_map_size;\n\tconst acl_perm_map_t\t*perm_map;\n\tuid_t\t\t ae_uid;\n\tgid_t\t\t ae_gid;\n\tconst char\t*ae_name;\n\tint\t\t entries;\n\tint\t\t i;\n\n\tret = ARCHIVE_OK;\n\tentries = archive_acl_reset(abstract_acl, ae_requested_type);\n\tif (entries == 0)\n\t\treturn (ARCHIVE_OK);\n\n\n\tswitch (ae_requested_type) {\n\tcase ARCHIVE_ENTRY_ACL_TYPE_ACCESS:\n\t\tacl_type = ACL_TYPE_ACCESS;\n\t\tbreak;\n\tcase ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:\n\t\tacl_type = ACL_TYPE_DEFAULT;\n\t\tbreak;\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\tcase ARCHIVE_ENTRY_ACL_TYPE_NFS4:\n\t\tacl_type = ACL_TYPE_NFS4;\n\t\tbreak;\n#endif\n\tdefault:\n\t\terrno = ENOENT;\n\t\tarchive_set_error(a, errno, \"Unsupported ACL type\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\tif (acl_type == ACL_TYPE_DEFAULT && !S_ISDIR(mode)) {\n\t\terrno = EINVAL;\n\t\tarchive_set_error(a, errno,\n\t\t    \"Cannot set default ACL on non-directory\");\n\t\treturn (ARCHIVE_WARN);\n\t}\n\n\tacl = acl_init(entries);\n\tif (acl == (acl_t)NULL) {\n\t\tarchive_set_error(a, errno,\n\t\t    \"Failed to initialize ACL working storage\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\twhile (archive_acl_next(a, abstract_acl, ae_requested_type, &ae_type,\n\t\t   &ae_permset, &ae_tag, &ae_id, &ae_name) == ARCHIVE_OK) {\n\t\tif (acl_create_entry(&acl, &acl_entry) != 0) {\n\t\t\tarchive_set_error(a, errno,\n\t\t\t    \"Failed to create a new ACL entry\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\t\tswitch (ae_tag) {\n\t\tcase ARCHIVE_ENTRY_ACL_USER:\n\t\t\tae_uid = archive_write_disk_uid(a, ae_name, ae_id);\n\t\t\tacl_set_tag_type(acl_entry, ACL_USER);\n\t\t\tacl_set_qualifier(acl_entry, &ae_uid);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_GROUP:\n\t\t\tae_gid = archive_write_disk_gid(a, ae_name, ae_id);\n\t\t\tacl_set_tag_type(acl_entry, ACL_GROUP);\n\t\t\tacl_set_qualifier(acl_entry, &ae_gid);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_USER_OBJ:\n\t\t\tacl_set_tag_type(acl_entry, ACL_USER_OBJ);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_GROUP_OBJ:\n\t\t\tacl_set_tag_type(acl_entry, ACL_GROUP_OBJ);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_MASK:\n\t\t\tacl_set_tag_type(acl_entry, ACL_MASK);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_OTHER:\n\t\t\tacl_set_tag_type(acl_entry, ACL_OTHER);\n\t\t\tbreak;\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\t\tcase ARCHIVE_ENTRY_ACL_EVERYONE:\n\t\t\tacl_set_tag_type(acl_entry, ACL_EVERYONE);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Unsupported ACL tag\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\t\tr = 0;\n\t\tswitch (ae_type) {\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ALLOW:\n\t\t\tr = acl_set_entry_type_np(acl_entry,\n\t\t\t    ACL_ENTRY_TYPE_ALLOW);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_DENY:\n\t\t\tr = acl_set_entry_type_np(acl_entry,\n\t\t\t    ACL_ENTRY_TYPE_DENY);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_AUDIT:\n\t\t\tr = acl_set_entry_type_np(acl_entry,\n\t\t\t    ACL_ENTRY_TYPE_AUDIT);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ALARM:\n\t\t\tr = acl_set_entry_type_np(acl_entry,\n\t\t\t    ACL_ENTRY_TYPE_ALARM);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ACCESS:\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:\n\t\t\t// These don't translate directly into the system ACL.\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Unsupported ACL entry type\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\n\t\tif (r != 0) {\n\t\t\tarchive_set_error(a, errno,\n\t\t\t    \"Failed to set ACL entry type\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n#endif\n\n\t\tif (acl_get_permset(acl_entry, &acl_permset) != 0) {\n\t\t\tarchive_set_error(a, errno,\n\t\t\t    \"Failed to get ACL permission set\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\t\tif (acl_clear_perms(acl_permset) != 0) {\n\t\t\tarchive_set_error(a, errno,\n\t\t\t    \"Failed to clear ACL permissions\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\t\tif (ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_NFS4) {\n\t\t\tperm_map_size = acl_nfs4_perm_map_size;\n\t\t\tperm_map = acl_nfs4_perm_map;\n\t\t} else {\n#endif\n\t\t\tperm_map_size = acl_posix_perm_map_size;\n\t\t\tperm_map = acl_posix_perm_map;\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\t\t}\n#endif\n\n\t\tfor (i = 0; i < perm_map_size; ++i) {\n\t\t\tif (ae_permset & perm_map[i].a_perm) {\n\t\t\t\tif (acl_add_perm(acl_permset,\n\t\t\t\t    perm_map[i].p_perm) != 0) {\n\t\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t\t    \"Failed to add ACL permission\");\n\t\t\t\t\tret = ARCHIVE_FAILED;\n\t\t\t\t\tgoto exit_free;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\t\tif (ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_NFS4) {\n\t\t\t/*\n\t\t\t * acl_get_flagset_np() fails with non-NFSv4 ACLs\n\t\t\t */\n\t\t\tif (acl_get_flagset_np(acl_entry, &acl_flagset) != 0) {\n\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t    \"Failed to get flagset from an NFSv4 \"\n\t\t\t\t    \"ACL entry\");\n\t\t\t\tret = ARCHIVE_FAILED;\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\tif (acl_clear_flags_np(acl_flagset) != 0) {\n\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t    \"Failed to clear flags from an NFSv4 \"\n\t\t\t\t    \"ACL flagset\");\n\t\t\t\tret = ARCHIVE_FAILED;\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\tfor (i = 0; i < acl_nfs4_flag_map_size; ++i) {\n\t\t\t\tif (ae_permset & acl_nfs4_flag_map[i].a_perm) {\n\t\t\t\t\tif (acl_add_flag_np(acl_flagset,\n\t\t\t\t\t    acl_nfs4_flag_map[i].p_perm) != 0) {\n\t\t\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t\t\t    \"Failed to add flag to \"\n\t\t\t\t\t\t    \"NFSv4 ACL flagset\");\n\t\t\t\t\t\tret = ARCHIVE_FAILED;\n\t\t\t\t\t\tgoto exit_free;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\t/* Try restoring the ACL through 'fd' if we can. */\n\tif (fd >= 0) {\n\t\tif (acl_set_fd_np(fd, acl, acl_type) == 0)\n\t\t\tret = ARCHIVE_OK;\n\t\telse {\n\t\t\tif (errno == EOPNOTSUPP) {\n\t\t\t\t/* Filesystem doesn't support ACLs */\n\t\t\t\tret = ARCHIVE_OK;\n\t\t\t} else {\n\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t    \"Failed to set acl on fd: %s\", tname);\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t}\n\t\t}\n\t}\n#if HAVE_ACL_SET_LINK_NP\n\telse if (acl_set_link_np(name, acl_type, acl) != 0)\n#else\n\t/* FreeBSD older than 8.0 */\n\telse if (S_ISLNK(mode)) {\n\t    /* acl_set_file() follows symbolic links, skip */\n\t    ret = ARCHIVE_OK;\n\t} else if (acl_set_file(name, acl_type, acl) != 0)\n#endif\n\t{\n\t\tif (errno == EOPNOTSUPP) {\n\t\t\t/* Filesystem doesn't support ACLs */\n\t\t\tret = ARCHIVE_OK;\n\t\t} else {\n\t\t\tarchive_set_error(a, errno, \"Failed to set acl: %s\",\n\t\t\t    tname);\n\t\t\tret = ARCHIVE_WARN;\n\t\t}\n\t}\nexit_free:\n\tacl_free(acl);\n\treturn (ret);\n}", "target": 2, "idx": 11648}
{"commit_id": "9301bfe730c66180263248b74353daa99f5a969b", "project": "FreeRDP", "func": "BOOL rdp_read_share_control_header(wStream* s, UINT16* length, UINT16* type, UINT16* channel_id)\n{\n\tUINT16 len;\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\treturn FALSE;\n\n\t/* Share Control Header */\n\tStream_Read_UINT16(s, len); /* totalLength */\n\n\t*length = len;\n\n\t/* If length is 0x8000 then we actually got a flow control PDU that we should ignore\n\t http://msdn.microsoft.com/en-us/library/cc240576.aspx */\n\tif (len == 0x8000)\n\t{\n\t\tif (!rdp_read_flow_control_pdu(s, type))\n\t\t\treturn FALSE;\n\t\t*channel_id = 0;\n\t\t*length = 8; /* Flow control PDU is 8 bytes */\n\t\treturn TRUE;\n\t}\n\n\tif ((len < 4) || ((len - 2) > Stream_GetRemainingLength(s)))\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, *type); /* pduType */\n\t*type &= 0x0F;                /* type is in the 4 least significant bits */\n\n\tif (len > 4)\n\t\tStream_Read_UINT16(s, *channel_id); /* pduSource */\n\telse\n\t\t*channel_id = 0; /* Windows XP can send such short DEACTIVATE_ALL PDUs. */\n\n\treturn TRUE;\n}", "target": 0, "idx": 11649}
{"commit_id": "d834160d9759f1098df692b34e6eeb548f9e317b", "project": "android", "func": "OMX_ERRORTYPE SimpleSoftOMXComponent::useBuffer(\n        OMX_BUFFERHEADERTYPE **header,\n        OMX_U32 portIndex,\n        OMX_PTR appPrivate,\n        OMX_U32 size,\n        OMX_U8 *ptr) {\n    Mutex::Autolock autoLock(mLock);\n    CHECK_LT(portIndex, mPorts.size());\n\n    PortInfo *port = &mPorts.editItemAt(portIndex);\n    if (size < port->mDef.nBufferSize) {\n        ALOGE(\"b/63522430, Buffer size is too small.\");\n        android_errorWriteLog(0x534e4554, \"63522430\");\n        return OMX_ErrorBadParameter;\n    }\n\n    *header = new OMX_BUFFERHEADERTYPE;\n    (*header)->nSize = sizeof(OMX_BUFFERHEADERTYPE);\n    (*header)->nVersion.s.nVersionMajor = 1;\n    (*header)->nVersion.s.nVersionMinor = 0;\n    (*header)->nVersion.s.nRevision = 0;\n    (*header)->nVersion.s.nStep = 0;\n    (*header)->pBuffer = ptr;\n    (*header)->nAllocLen = size;\n    (*header)->nFilledLen = 0;\n    (*header)->nOffset = 0;\n    (*header)->pAppPrivate = appPrivate;\n    (*header)->pPlatformPrivate = NULL;\n    (*header)->pInputPortPrivate = NULL;\n    (*header)->pOutputPortPrivate = NULL;\n    (*header)->hMarkTargetComponent = NULL;\n    (*header)->pMarkData = NULL;\n    (*header)->nTickCount = 0;\n    (*header)->nTimeStamp = 0;\n    (*header)->nFlags = 0;\n    (*header)->nOutputPortIndex = portIndex;\n    (*header)->nInputPortIndex = portIndex;\n\n    CHECK(mState == OMX_StateLoaded || port->mDef.bEnabled == OMX_FALSE);\n\n    CHECK_LT(port->mBuffers.size(), port->mDef.nBufferCountActual);\n\n    port->mBuffers.push();\n\n    BufferInfo *buffer =\n        &port->mBuffers.editItemAt(port->mBuffers.size() - 1);\n\n    buffer->mHeader = *header;\n    buffer->mOwnedByUs = false;\n\n    if (port->mBuffers.size() == port->mDef.nBufferCountActual) {\n        port->mDef.bPopulated = OMX_TRUE;\n        checkTransitions();\n    }\n\n    return OMX_ErrorNone;\n}", "target": 2, "idx": 11650}
{"commit_id": "e2ac765a25e902728b6d4a825358aa536e6668c2", "project": "appneta/tcpreplay", "func": "int\nfix_ipv4_checksums(tcpedit_t *tcpedit, struct pcap_pkthdr *pkthdr,\n                   ipv4_hdr_t *ip_hdr, const size_t l2len)\n{\n    int ret1 = 0, ret2 = 0, ip_len;\n    assert(tcpedit);\n    assert(pkthdr);\n    assert(ip_hdr);\n\n    if (pkthdr->caplen < (sizeof(*ip_hdr) + l2len)) {\n        tcpedit_setwarn(tcpedit, \"caplen too small to read IPv4 header: %u\",\n                pkthdr->caplen);\n        return TCPEDIT_WARN;\n    }\n\n    if (ip_hdr->ip_v != 4) {\n        tcpedit_seterr(tcpedit, \"Invalid packet: Expected IPv4 packet: got %u\", ip_hdr->ip_v);\n        return TCPEDIT_ERROR;\n    }\n\n    ip_len = (int)ntohs(ip_hdr->ip_len);\n    /* calc the L4 checksum if we have the whole packet && not a frag or first frag */\n    if (pkthdr->caplen == pkthdr->len &&\n            (htons(ip_hdr->ip_off) & (IP_MF | IP_OFFMASK)) == 0) {\n        if (ip_len != (int)(pkthdr->caplen - l2len)) {\n            tcpedit_seterr(tcpedit,\n                           \"caplen minus L2 length %u does IPv4 header length %u\",\n                           pkthdr->caplen - l2len,\n                           ip_len);\n            return TCPEDIT_ERROR;\n        }\n        ret1 = do_checksum(tcpedit, (u_char*)ip_hdr, ip_hdr->ip_p,\n                           ip_len - (ip_hdr->ip_hl << 2));\n        if (ret1 < 0)\n            return TCPEDIT_ERROR;\n    }\n    \n    /* calc IP checksum */\n    ret2 = do_checksum(tcpedit, (u_char *) ip_hdr, IPPROTO_IP, ip_len);\n    if (ret2 < 0)\n        return TCPEDIT_ERROR;\n\n    /* what do we return? */\n    if (ret1 == TCPEDIT_WARN || ret2 == TCPEDIT_WARN)\n        return TCPEDIT_WARN;\n    \n    return TCPEDIT_OK;\n}", "target": 2, "idx": 11651}
{"commit_id": "6302c20acd4355fd60f791ac2027efcbd9c9f87d", "project": "JayXon/Leanify", "func": "size_t Ico::Leanify(size_t size_leanified /*= 0*/) {\n  // number of images inside ico file\n  const uint16_t num_of_img = *(uint16_t*)(fp_ + 4);\n\n  // corrupt file: no image or file size too small\n  if (num_of_img == 0 || 6 + num_of_img * sizeof(IconDirEntry) >= size_) {\n    return Format::Leanify(size_leanified);\n  }\n\n  // sort the entries by offset just in case it's not sorted before\n  IconDirEntry* entry_addr = reinterpret_cast<IconDirEntry*>(fp_ + 6);\n  vector<IconDirEntry> entries(entry_addr, entry_addr + num_of_img);\n  std::sort(entries.begin(), entries.end(),\n            [](const IconDirEntry& a, const IconDirEntry& b) { return a.dwImageOffset < b.dwImageOffset; });\n\n  // check overlaps\n  for (size_t i = 1; i < entries.size(); i++) {\n    if (entries[i - 1].dwImageOffset + entries[i - 1].dwBytesInRes > entries[i].dwImageOffset) {\n      cerr << \"Error: Found overlapping icon entries!\" << endl;\n      return Format::Leanify(size_leanified);\n    }\n  }\n\n  // is file size enough?\n  if (static_cast<uint64_t>(entries.back().dwImageOffset) + entries.back().dwBytesInRes > size_) {\n    return Format::Leanify(size_leanified);\n  }\n\n  for (size_t i = 0; i < entries.size(); i++) {\n    uint32_t old_offset = entries[i].dwImageOffset;\n    // write new offset\n    if (i != 0) {\n      entries[i].dwImageOffset = entries[i - 1].dwImageOffset + entries[i - 1].dwBytesInRes;\n    } else {\n      entries[i].dwImageOffset = 6 + num_of_img * sizeof(IconDirEntry);\n    }\n\n    // Leanify PNG\n    if (memcmp(fp_ + old_offset, Png::header_magic, sizeof(Png::header_magic)) == 0) {\n      entries[i].dwBytesInRes = Png(fp_ + old_offset, entries[i].dwBytesInRes)\n                                    .Leanify(size_leanified + old_offset - entries[i].dwImageOffset);\n      continue;\n    }\n\n    // Convert 256x256 BMP to PNG if possible\n    if (entries[i].bWidth == 0 && entries[i].bHeight == 0) {\n      auto dib = reinterpret_cast<Bmp::BITMAPINFOHEADER*>(fp_ + old_offset);\n      if (dib->biSize >= 40 && dib->biWidth == 256 && dib->biHeight == 512 &&  // DIB in ICO always has double height\n          dib->biPlanes == 1 && dib->biBitCount == 32 &&                       // only support RGBA for now\n          dib->biCompression == 0 &&                                           // BI_RGB aka no compression\n          dib->biSize + std::max(dib->biSizeImage, 256 * 256 * 4U) <= entries[i].dwBytesInRes &&\n          (dib->biSizeImage == 0 || dib->biSizeImage >= 256 * 256 * 4U) && dib->biClrUsed == 0) {\n        VerbosePrint(\"Converting 256x256 BMP to PNG...\");\n        // BMP stores ARGB in little endian, so it's actually BGRA, convert it to normal RGBA\n        // It also stores the pixels upside down for some reason, so reverse it.\n        uint8_t* bmp_row = fp_ + old_offset + dib->biSize + 256 * 256 * 4;\n        vector<uint8_t> raw(256 * 256 * 4), png;\n        // TODO: detect 0RGB and convert it to RGBA using mask\n        for (size_t j = 0; j < 256; j++) {\n          bmp_row -= 256 * 4;\n          for (size_t k = 0; k < 256; k++) {\n            raw[(j * 256 + k) * 4 + 0] = bmp_row[k * 4 + 2];\n            raw[(j * 256 + k) * 4 + 1] = bmp_row[k * 4 + 1];\n            raw[(j * 256 + k) * 4 + 2] = bmp_row[k * 4 + 0];\n            raw[(j * 256 + k) * 4 + 3] = bmp_row[k * 4 + 3];\n          }\n        }\n        if (lodepng::encode(png, raw, 256, 256) == 0) {\n          // Optimize the new PNG\n          size_t png_size = Png(png).Leanify();\n          if (png_size < entries[i].dwBytesInRes) {\n            entries[i].dwBytesInRes = png_size;\n            memcpy(fp_ + entries[i].dwImageOffset - size_leanified, png.data(), png_size);\n            continue;\n          }\n        }\n      }\n    }\n    memmove(fp_ + entries[i].dwImageOffset - size_leanified, fp_ + old_offset, entries[i].dwBytesInRes);\n  }\n\n  fp_ -= size_leanified;\n\n  // write headers if moved\n  if (size_leanified) {\n    memcpy(fp_, header_magic, sizeof(header_magic));\n    *(uint16_t*)(fp_ + 4) = num_of_img;\n  }\n  // write new entries\n  memcpy(fp_ + 6, entries.data(), entries.size() * sizeof(IconDirEntry));\n\n  // offset + size of last img\n  size_ = entries.back().dwImageOffset + entries.back().dwBytesInRes;\n  return size_;\n}", "target": 1, "idx": 11652}
{"commit_id": "05f43d44e4bc26611ce25fd7d726e483f73363ce", "project": "qemu", "func": "static TRBType xhci_ring_fetch(XHCIState *xhci, XHCIRing *ring, XHCITRB *trb,\n                               dma_addr_t *addr)\n{\n    PCIDevice *pci_dev = PCI_DEVICE(xhci);\n    uint32_t link_cnt = 0;\n\n    while (1) {\n        TRBType type;\n        pci_dma_read(pci_dev, ring->dequeue, trb, TRB_SIZE);\n        trb->addr = ring->dequeue;\n        trb->ccs = ring->ccs;\n        le64_to_cpus(&trb->parameter);\n        le32_to_cpus(&trb->status);\n        le32_to_cpus(&trb->control);\n\n        trace_usb_xhci_fetch_trb(ring->dequeue, trb_name(trb),\n                                 trb->parameter, trb->status, trb->control);\n\n        if ((trb->control & TRB_C) != ring->ccs) {\n            return 0;\n        }\n\n        type = TRB_TYPE(*trb);\n\n        if (type != TR_LINK) {\n            if (addr) {\n                *addr = ring->dequeue;\n            }\n            ring->dequeue += TRB_SIZE;\n            return type;\n        } else {\n            if (++link_cnt > TRB_LINK_LIMIT) {\n                return 0;\n            }\n            ring->dequeue = xhci_mask64(trb->parameter);\n            if (trb->control & TRB_LK_TC) {\n                ring->ccs = !ring->ccs;\n            }\n        }\n    }\n}", "target": 1, "idx": 11653}
{"commit_id": "e7719a0dfac7a20cb7da5529e09773d8271bb78b", "project": "xen-project/xen", "func": "static bool_t evtchn_2l_is_pending(struct domain *d, evtchn_port_t port)\n{\n    unsigned int max_ports = BITS_PER_EVTCHN_WORD(d) * BITS_PER_EVTCHN_WORD(d);\n\n    ASSERT(port < max_ports);\n    return port < max_ports && test_bit(port, &shared_info(d, evtchn_pending));\n}", "target": 3, "idx": 11654}
{"commit_id": "923e6d3673beeec6a51e68d6340305a1ff5a39ba", "project": "Exiv2/exiv2", "func": "ExifData::const_iterator isoSpeed(const ExifData& ed)\n    {\n        static const char* keys[] = {\n            \"Exif.Photo.ISOSpeedRatings\",\n            \"Exif.Image.ISOSpeedRatings\",\n            \"Exif.CanonSi.ISOSpeed\",\n            \"Exif.CanonCs.ISOSpeed\",\n            \"Exif.Nikon1.ISOSpeed\",\n            \"Exif.Nikon2.ISOSpeed\",\n            \"Exif.Nikon3.ISOSpeed\",\n            \"Exif.NikonIi.ISO\",\n            \"Exif.NikonIi.ISO2\",\n            \"Exif.MinoltaCsNew.ISOSetting\",\n            \"Exif.MinoltaCsOld.ISOSetting\",\n            \"Exif.MinoltaCs5D.ISOSpeed\",\n            \"Exif.MinoltaCs7D.ISOSpeed\",\n            \"Exif.Sony1Cs.ISOSetting\",\n            \"Exif.Sony2Cs.ISOSetting\",\n            \"Exif.Sony1Cs2.ISOSetting\",\n            \"Exif.Sony2Cs2.ISOSetting\",\n            \"Exif.Sony1MltCsA100.ISOSetting\",\n            \"Exif.Pentax.ISO\",\n            \"Exif.PentaxDng.ISO\",\n            \"Exif.Olympus.ISOSpeed\",\n            \"Exif.Samsung2.ISO\",\n            \"Exif.Casio.ISO\",\n            \"Exif.Casio2.ISO\",\n            \"Exif.Casio2.ISOSpeed\"\n        };\n\n        struct SensKeyNameList {\n            int count;\n            const char* keys[3];\n        };\n\n        // covers Exif.Phot.SensitivityType values 1-7. Note that SOS, REI and\n        // ISO do differ in their meaning. Values coming first in a list (and\n        // existing as a tag) are picked up first and used as the \"ISO\" value.\n        static const SensKeyNameList sensitivityKey[] = {\n            { 1, { \"Exif.Photo.StandardOutputSensitivity\" }},\n            { 1, { \"Exif.Photo.RecommendedExposureIndex\" }},\n            { 1, { \"Exif.Photo.ISOSpeed\" }},\n            { 2, { \"Exif.Photo.RecommendedExposureIndex\", \"Exif.Photo.StandardOutputSensitivity\" }},\n            { 2, { \"Exif.Photo.ISOSpeed\", \"Exif.Photo.StandardOutputSensitivity\" }},\n            { 2, { \"Exif.Photo.ISOSpeed\", \"Exif.Photo.RecommendedExposureIndex\" }},\n            { 3, { \"Exif.Photo.ISOSpeed\", \"Exif.Photo.RecommendedExposureIndex\", \"Exif.Photo.StandardOutputSensitivity\" }}\n        };\n\n        static const char* sensitivityType[] = {\n            \"Exif.Photo.SensitivityType\"\n        };\n\n        // Find the first ISO value which is not \"0\"\n        const int cnt = EXV_COUNTOF(keys);\n        ExifData::const_iterator md = ed.end();\n        long iso_val = -1;\n        for (int idx = 0; idx < cnt; ) {\n            md = findMetadatum(ed, keys + idx, cnt - idx);\n            if (md == ed.end()) break;\n            std::ostringstream os;\n            md->write(os, &ed);\n            bool ok = false;\n            iso_val = parseLong(os.str(), ok);\n            if (ok && iso_val > 0) break;\n            while (strcmp(keys[idx++], md->key().c_str()) != 0 && idx < cnt) {}\n            md = ed.end();\n        }\n\n        // there is either a possible ISO \"overflow\" or no legacy\n        // ISO tag at all. Check for SensitivityType tag and the referenced\n        // ISO value (see EXIF 2.3 Annex G)\n        long iso_tmp_val = -1;\n        while (iso_tmp_val == -1 && (iso_val == 65535 || md == ed.end())) {\n            ExifData::const_iterator md_st = findMetadatum(ed, sensitivityType, 1);\n            // no SensitivityType? exit with existing data\n            if (md_st == ed.end())\n                break;\n            // otherwise pick up actual value and grab value accordingly\n            std::ostringstream os;\n            md_st->write(os, &ed);\n            bool ok = false;\n            const long st_val = parseLong(os.str(), ok);\n            // SensivityType out of range or cannot be parsed properly\n            if (!ok || st_val < 1 || st_val > 7)\n                break;\n            // pick up list of ISO tags, and check for at least one of\n            // them available.\n            const SensKeyNameList *sensKeys = &sensitivityKey[st_val - 1];\n            md_st = ed.end();\n            for (int idx = 0; idx < sensKeys->count; md_st = ed.end()) {\n                md_st = findMetadatum(ed, const_cast<const char**>(sensKeys->keys), sensKeys->count);\n                if (md_st == ed.end())\n                    break;\n                std::ostringstream os_iso;\n                md_st->write(os_iso, &ed);\n                ok = false;\n                iso_tmp_val = parseLong(os_iso.str(), ok);\n                // something wrong with the value\n                if (ok || iso_tmp_val > 0) {\n                    md = md_st;\n                    break;\n                }\n                while (strcmp(sensKeys->keys[idx++], md_st->key().c_str()) != 0 && idx < sensKeys->count) {}\n            }\n            break;\n        }\n\n        return md;\n    }", "target": 1, "idx": 11655}
{"commit_id": "d13dd30240e32071210f55b587182ff48757ea46", "project": "vim", "func": "int\nclass_object_index(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\tverbose UNUSED)\t// give error messages\n{\n    if (VIM_ISWHITE((*arg)[1]))\n    {\n\tsemsg(_(e_no_white_space_allowed_after_str_str), \".\", *arg);\n\treturn FAIL;\n    }\n\n    ++*arg;\n    char_u *name = *arg;\n    char_u *name_end = find_name_end(name, NULL, NULL, FNE_CHECK_START);\n    if (name_end == name)\n\treturn FAIL;\n    size_t len = name_end - name;\n\n    class_T *cl;\n    if (rettv->v_type == VAR_CLASS)\n\tcl = rettv->vval.v_class;\n    else // VAR_OBJECT\n    {\n\tif (rettv->vval.v_object == NULL)\n\t{\n\t    emsg(_(e_using_null_object));\n\t    return FAIL;\n\t}\n\tcl = rettv->vval.v_object->obj_class;\n    }\n\n    if (cl == NULL)\n    {\n\temsg(_(e_incomplete_type));\n\treturn FAIL;\n    }\n\n    if (*name_end == '(')\n    {\n\tint on_class = rettv->v_type == VAR_CLASS;\n\tint count = on_class ? cl->class_class_function_count\n\t\t\t     : cl->class_obj_method_count;\n\tfor (int i = 0; i < count; ++i)\n\t{\n\t    ufunc_T *fp = on_class ? cl->class_class_functions[i]\n\t\t\t\t   : cl->class_obj_methods[i];\n\t    // Use a separate pointer to avoid that ASAN complains about\n\t    // uf_name[] only being 4 characters.\n\t    char_u *ufname = (char_u *)fp->uf_name;\n\t    if (STRNCMP(name, ufname, len) == 0 && ufname[len] == NUL)\n\t    {\n\t\ttypval_T    argvars[MAX_FUNC_ARGS + 1];\n\t\tint\t    argcount = 0;\n\n\t\tchar_u *argp = name_end;\n\t\tint ret = get_func_arguments(&argp, evalarg, 0,\n\t\t\t\t\t\t\t   argvars, &argcount);\n\t\tif (ret == FAIL)\n\t\t    return FAIL;\n\n\t\tfuncexe_T   funcexe;\n\t\tCLEAR_FIELD(funcexe);\n\t\tfuncexe.fe_evaluate = TRUE;\n\t\tif (rettv->v_type == VAR_OBJECT)\n\t\t{\n\t\t    funcexe.fe_object = rettv->vval.v_object;\n\t\t    ++funcexe.fe_object->obj_refcount;\n\t\t}\n\n\t\t// Clear the class or object after calling the function, in\n\t\t// case the refcount is one.\n\t\ttypval_T tv_tofree = *rettv;\n\t\trettv->v_type = VAR_UNKNOWN;\n\n\t\t// Call the user function.  Result goes into rettv;\n\t\tint error = call_user_func_check(fp, argcount, argvars,\n\t\t\t\t\t\t\trettv, &funcexe, NULL);\n\n\t\t// Clear the previous rettv and the arguments.\n\t\tclear_tv(&tv_tofree);\n\t\tfor (int idx = 0; idx < argcount; ++idx)\n\t\t    clear_tv(&argvars[idx]);\n\n\t\tif (error != FCERR_NONE)\n\t\t{\n\t\t    user_func_error(error, printable_func_name(fp),\n\t\t\t\t\t\t\t funcexe.fe_found_var);\n\t\t    return FAIL;\n\t\t}\n\t\t*arg = argp;\n\t\treturn OK;\n\t    }\n\t}\n\n\tsemsg(_(e_method_not_found_on_class_str_str), cl->class_name, name);\n    }\n\n    else if (rettv->v_type == VAR_OBJECT)\n    {\n\tfor (int i = 0; i < cl->class_obj_member_count; ++i)\n\t{\n\t    ocmember_T *m = &cl->class_obj_members[i];\n\t    if (STRNCMP(name, m->ocm_name, len) == 0 && m->ocm_name[len] == NUL)\n\t    {\n\t\tif (*name == '_')\n\t\t{\n\t\t    semsg(_(e_cannot_access_private_member_str), m->ocm_name);\n\t\t    return FAIL;\n\t\t}\n\n\t\t// The object only contains a pointer to the class, the member\n\t\t// values array follows right after that.\n\t\tobject_T *obj = rettv->vval.v_object;\n\t\ttypval_T *tv = (typval_T *)(obj + 1) + i;\n\t\tcopy_tv(tv, rettv);\n\t\tobject_unref(obj);\n\n\t\t*arg = name_end;\n\t\treturn OK;\n\t    }\n\t}\n\n\tsemsg(_(e_member_not_found_on_object_str_str), cl->class_name, name);\n    }\n\n    else if (rettv->v_type == VAR_CLASS)\n    {\n\t// class member\n\tfor (int i = 0; i < cl->class_class_member_count; ++i)\n\t{\n\t    ocmember_T *m = &cl->class_class_members[i];\n\t    if (STRNCMP(name, m->ocm_name, len) == 0 && m->ocm_name[len] == NUL)\n\t    {\n\t\tif (*name == '_')\n\t\t{\n\t\t    semsg(_(e_cannot_access_private_member_str), m->ocm_name);\n\t\t    return FAIL;\n\t\t}\n\n\t\ttypval_T *tv = &cl->class_members_tv[i];\n\t\tcopy_tv(tv, rettv);\n\t\tclass_unref(cl);\n\n\t\t*arg = name_end;\n\t\treturn OK;\n\t    }\n\t}\n\n\tsemsg(_(e_member_not_found_on_class_str_str), cl->class_name, name);\n    }\n\n    return FAIL;\n}", "target": 1, "idx": 11656}
{"commit_id": "2671fa4dc0109d3fb581bc3078fdf17b5d9080f6", "project": "torvalds/linux", "func": "static int nf_conntrack_standalone_init_sysctl(struct net *net)\n{\n\tstruct nf_conntrack_net *cnet = net_generic(net, nf_conntrack_net_id);\n\tstruct nf_udp_net *un = nf_udp_pernet(net);\n\tstruct ctl_table *table;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(nf_ct_sysctl_table) != NF_SYSCTL_CT_LAST_SYSCTL);\n\n\ttable = kmemdup(nf_ct_sysctl_table, sizeof(nf_ct_sysctl_table),\n\t\t\tGFP_KERNEL);\n\tif (!table)\n\t\treturn -ENOMEM;\n\n\ttable[NF_SYSCTL_CT_COUNT].data = &net->ct.count;\n\ttable[NF_SYSCTL_CT_CHECKSUM].data = &net->ct.sysctl_checksum;\n\ttable[NF_SYSCTL_CT_LOG_INVALID].data = &net->ct.sysctl_log_invalid;\n\ttable[NF_SYSCTL_CT_ACCT].data = &net->ct.sysctl_acct;\n\ttable[NF_SYSCTL_CT_HELPER].data = &net->ct.sysctl_auto_assign_helper;\n#ifdef CONFIG_NF_CONNTRACK_EVENTS\n\ttable[NF_SYSCTL_CT_EVENTS].data = &net->ct.sysctl_events;\n#endif\n#ifdef CONFIG_NF_CONNTRACK_TIMESTAMP\n\ttable[NF_SYSCTL_CT_TIMESTAMP].data = &net->ct.sysctl_tstamp;\n#endif\n\ttable[NF_SYSCTL_CT_PROTO_TIMEOUT_GENERIC].data = &nf_generic_pernet(net)->timeout;\n\ttable[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMP].data = &nf_icmp_pernet(net)->timeout;\n\ttable[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMPV6].data = &nf_icmpv6_pernet(net)->timeout;\n\ttable[NF_SYSCTL_CT_PROTO_TIMEOUT_UDP].data = &un->timeouts[UDP_CT_UNREPLIED];\n\ttable[NF_SYSCTL_CT_PROTO_TIMEOUT_UDP_STREAM].data = &un->timeouts[UDP_CT_REPLIED];\n\n\tnf_conntrack_standalone_init_tcp_sysctl(net, table);\n\tnf_conntrack_standalone_init_sctp_sysctl(net, table);\n\tnf_conntrack_standalone_init_dccp_sysctl(net, table);\n\tnf_conntrack_standalone_init_gre_sysctl(net, table);\n\n\t/* Don't allow non-init_net ns to alter global sysctls */\n\tif (!net_eq(&init_net, net)) {\n\t\ttable[NF_SYSCTL_CT_MAX].mode = 0444;\n\t\ttable[NF_SYSCTL_CT_EXPECT_MAX].mode = 0444;\n\t\ttable[NF_SYSCTL_CT_BUCKETS].mode = 0444;\n\t}\n\n\tcnet->sysctl_header = register_net_sysctl(net, \"net/netfilter\", table);\n\tif (!cnet->sysctl_header)\n\t\tgoto out_unregister_netfilter;\n\n\treturn 0;\n\nout_unregister_netfilter:\n\tkfree(table);\n\treturn -ENOMEM;\n}", "target": 0, "idx": 11657}
{"commit_id": "190ffdf6c8b1ec443be202c7d69e63a7e3da25e3", "project": "facebook/hhvm", "func": "String string_number_format(double d, int dec,\n                            const String& dec_point,\n                            const String& thousand_sep) {\n  char *tmpbuf = nullptr, *resbuf;\n  char *s, *t;  /* source, target */\n  char *dp;\n  int integral;\n  int tmplen, reslen=0;\n  int count=0;\n  int is_negative=0;\n\n  if (d < 0) {\n    is_negative = 1;\n    d = -d;\n  }\n\n  if (dec < 0) dec = 0;\n  d = php_math_round(d, dec);\n\n  // departure from PHP: we got rid of dependencies on spprintf() here.\n  String tmpstr(63, ReserveString);\n  tmpbuf = tmpstr.mutableData();\n  tmplen = snprintf(tmpbuf, 64, \"%.*F\", dec, d);\n  if (tmplen < 0) return empty_string();\n  if (tmpbuf == nullptr || !isdigit((int)tmpbuf[0])) {\n    tmpstr.setSize(tmplen);\n    return tmpstr;\n  }\n  if (tmplen >= 64) {\n    // Uncommon, asked for more than 64 chars worth of precision\n    tmpstr = String(tmplen, ReserveString);\n    tmpbuf = tmpstr.mutableData();\n    tmplen = snprintf(tmpbuf, tmplen + 1, \"%.*F\", dec, d);\n    if (tmplen < 0) return empty_string();\n    if (tmpbuf == nullptr || !isdigit((int)tmpbuf[0])) {\n      tmpstr.setSize(tmplen);\n      return tmpstr;\n    }\n  }\n\n  /* find decimal point, if expected */\n  if (dec) {\n    dp = strpbrk(tmpbuf, \".,\");\n  } else {\n    dp = nullptr;\n  }\n\n  /* calculate the length of the return buffer */\n  if (dp) {\n    integral = dp - tmpbuf;\n  } else {\n    /* no decimal point was found */\n    integral = tmplen;\n  }\n\n  /* allow for thousand separators */\n  if (!thousand_sep.empty()) {\n    if (integral + thousand_sep.size() * ((integral-1) / 3) < integral) {\n      /* overflow */\n      raise_error(\"String overflow\");\n    }\n\n    integral += ((integral-1) / 3) * thousand_sep.size();\n  }\n\n  reslen = integral;\n\n  if (dec) {\n    reslen += dec;\n\n    if (!dec_point.empty()) {\n      if (reslen + dec_point.size() < dec_point.size()) {\n        /* overflow */\n        raise_error(\"String overflow\");\n      }\n      reslen += dec_point.size();\n    }\n  }\n\n  /* add a byte for minus sign */\n  if (is_negative) {\n    reslen++;\n  }\n  String resstr(reslen, ReserveString);\n  resbuf = resstr.mutableData();\n\n  s = tmpbuf+tmplen-1;\n  t = resbuf+reslen-1;\n\n  /* copy the decimal places.\n   * Take care, as the sprintf implementation may return less places than\n   * we requested due to internal buffer limitations */\n  if (dec) {\n    int declen = dp ? s - dp : 0;\n    int topad = dec > declen ? dec - declen : 0;\n\n    /* pad with '0's */\n    while (topad--) {\n      *t-- = '0';\n    }\n\n    if (dp) {\n      s -= declen + 1; /* +1 to skip the point */\n      t -= declen;\n\n      /* now copy the chars after the point */\n      memcpy(t + 1, dp + 1, declen);\n    }\n\n    /* add decimal point */\n    if (!dec_point.empty()) {\n      memcpy(t + (1 - dec_point.size()), dec_point.data(), dec_point.size());\n      t -= dec_point.size();\n    }\n  }\n\n  /* copy the numbers before the decimal point, adding thousand\n   * separator every three digits */\n  while(s >= tmpbuf) {\n    *t-- = *s--;\n    if (thousand_sep && (++count%3)==0 && s>=tmpbuf) {\n      memcpy(t + (1 - thousand_sep.size()),\n             thousand_sep.data(),\n             thousand_sep.size());\n      t -= thousand_sep.size();\n    }\n  }\n\n  /* and a minus sign, if needed */\n  if (is_negative) {\n    *t-- = '-';\n  }\n\n  resstr.setSize(reslen);\n  return resstr;\n}", "target": 3, "idx": 11658}
{"commit_id": "2ca9ab45891b6ae8e32b6c28c81eebca059cbe5d", "project": "radareorg/radare2", "func": "static void r_bin_dwarf_dump_debug_info(FILE *f, const RBinDwarfDebugInfo *inf) {\n\tsize_t i, j, k;\n\tRBinDwarfDIE *dies;\n\tRBinDwarfAttrValue *values;\n\tif (!inf || !f) {\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < inf->length; i++) {\n\t\tfprintf (f, \"  Compilation Unit @ offset 0x%\"PFMT64x\":\\n\", inf->comp_units [i].offset);\n\t\tfprintf (f, \"   Length:        0x%x\\n\", inf->comp_units [i].hdr.length);\n\t\tfprintf (f, \"   Version:       %d\\n\", inf->comp_units [i].hdr.version);\n\t\tfprintf (f, \"   Abbrev Offset: 0x%x\\n\", inf->comp_units [i].hdr.abbrev_offset);\n\t\tfprintf (f, \"   Pointer Size:  %d\\n\", inf->comp_units [i].hdr.pointer_size);\n\n\t\tdies = inf->comp_units[i].dies;\n\n\t\tfor (j = 0; j < inf->comp_units[i].length; j++) {\n\t\t\tfprintf (f, \"    Abbrev Number: %\"PFMT64u\" \", dies[j].abbrev_code);\n\n\t\t\tif (dies[j].tag && dies[j].tag <= DW_TAG_volatile_type &&\n\t\t\t\t       dwarf_tag_name_encodings[dies[j].tag]) {\n\t\t\t\tfprintf (f, \"(%s)\\n\", dwarf_tag_name_encodings[dies[j].tag]);\n\t\t\t} else {\n\t\t\t\tfprintf (f, \"(Unknown abbrev tag)\\n\");\n\t\t\t}\n\n\t\t\tif (!dies[j].abbrev_code) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvalues = dies[j].attr_values;\n\n\t\t\tfor (k = 0; k < dies[j].length; k++) {\n\t\t\t\tif (!values[k].name) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (values[k].name < DW_AT_vtable_elem_location &&\n\t\t\t\t\t\tdwarf_attr_encodings[values[k].name]) {\n\t\t\t\t\tfprintf (f, \"     %-18s : \", dwarf_attr_encodings[values[k].name]);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf (f, \"     TODO\\t\");\n\t\t\t\t}\n\t\t\t\tr_bin_dwarf_dump_attr_value (&values[k], f);\n\t\t\t\tfprintf (f, \"\\n\");\n\t\t\t}\n\t\t}\n\t}\n}", "target": 1, "idx": 11659}
{"commit_id": "7a1aac3343af85b4af4df5f8844946eaa27394ab", "project": "php/php-src", "func": "int gdTransformAffineGetImage(gdImagePtr *dst,\n\t\t  const gdImagePtr src,\n\t\t  gdRectPtr src_area,\n\t\t  const double affine[6])\n{\n\tint res;\n\tdouble m[6];\n\tgdRect bbox;\n\tgdRect area_full;\n\n\tif (src_area == NULL) {\n\t\tarea_full.x = 0;\n\t\tarea_full.y = 0;\n\t\tarea_full.width  = gdImageSX(src);\n\t\tarea_full.height = gdImageSY(src);\n\t\tsrc_area = &area_full;\n\t}\n\n\tgdTransformAffineBoundingBox(src_area, affine, &bbox);\n\n\t*dst = gdImageCreateTrueColor(bbox.width, bbox.height);\n\tif (*dst == NULL) {\n\t\treturn GD_FALSE;\n\t}\n\t(*dst)->saveAlphaFlag = 1;\n\n\tif (!src->trueColor) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\n\t/* Translate to dst origin (0,0) */\n\tgdAffineTranslate(m, -bbox.x, -bbox.y);\n\tgdAffineConcat(m, affine, m);\n\n\tgdImageAlphaBlending(*dst, 0);\n\n\tres = gdTransformAffineCopy(*dst,\n\t\t  0,0,\n\t\t  src,\n\t\t  src_area,\n\t\t  m);\n\n\tif (res != GD_TRUE) {\n\t\tgdImageDestroy(*dst);\n\t\tdst = NULL;\n\t\treturn GD_FALSE;\n\t} else {\n\t\treturn GD_TRUE;\n\t}\n}", "target": 2, "idx": 11660}
{"commit_id": "1fe8fbc032ccda1db9af66d93016b49c16c1f22d", "project": "dinhvh/libetpan", "func": "static int mailimf_group_parse(const char * message, size_t length,\n\t\t\t       size_t * indx,\n\t\t\t       struct mailimf_group ** result)\n{\n  size_t cur_token;\n  char * display_name;\n  struct mailimf_mailbox_list * mailbox_list;\n  struct mailimf_group * group;\n  int r;\n  int res;\n  clist * list;\n\n  cur_token = * indx;\n\n  mailbox_list = NULL;\n\n  r = mailimf_display_name_parse(message, length, &cur_token, &display_name);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_display_name;\n  }\n\n  r = mailimf_mailbox_list_parse(message, length, &cur_token, &mailbox_list);\n  switch (r) {\n  case MAILIMF_NO_ERROR:\n    break;\n  case MAILIMF_ERROR_PARSE:\n    r = mailimf_cfws_parse(message, length, &cur_token);\n    if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n      res = r;\n      goto free_display_name;\n    }\n    list = clist_new();\n    if (list == NULL) {\n      res = MAILIMF_ERROR_MEMORY;\n      goto free_display_name;\n    }\n    mailbox_list = mailimf_mailbox_list_new(list);\n    if (mailbox_list == NULL) {\n      res = MAILIMF_ERROR_MEMORY;\n      clist_free(list);\n      goto free_display_name;\n    }\n    break;\n  default:\n    res = r;\n    goto free_display_name;\n  }\n\n  r = mailimf_semi_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_mailbox_list;\n  }\n\n  group = mailimf_group_new(display_name, mailbox_list);\n  if (group == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_mailbox_list;\n  }\n\n  * indx = cur_token;\n  * result = group;\n\n  return MAILIMF_NO_ERROR;\n\n free_mailbox_list:\n  if (mailbox_list != NULL) {\n    mailimf_mailbox_list_free(mailbox_list);\n  }\n free_display_name:\n  mailimf_display_name_free(display_name);\n err:\n  return res;\n}", "target": 2, "idx": 11661}
{"commit_id": "f6bbf0010ba004f5e90c7aefdebc0ee4bd3283b9", "project": "torvalds/linux", "func": "static void vhost_vdpa_config_put(struct vhost_vdpa *v)\n{\n\tif (v->config_ctx) {\n\t\teventfd_ctx_put(v->config_ctx);\n\t\tv->config_ctx = NULL;\n\t}\n}", "target": 2, "idx": 11662}
{"commit_id": "755d3f9debf8879448211fffb018f556136f6a79", "project": "xen-project/xen", "func": "struct node *read_node(struct connection *conn, const void *ctx,\n\t\t       const char *name)\n{\n\tTDB_DATA key, data;\n\tstruct xs_tdb_record_hdr *hdr;\n\tstruct node *node;\n\tint err;\n\n\tnode = talloc(ctx, struct node);\n\tif (!node) {\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\tnode->name = talloc_strdup(node, name);\n\tif (!node->name) {\n\t\ttalloc_free(node);\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\n\tif (transaction_prepend(conn, name, &key))\n\t\treturn NULL;\n\n\tdata = tdb_fetch(tdb_ctx, key);\n\n\tif (data.dptr == NULL) {\n\t\tif (tdb_error(tdb_ctx) == TDB_ERR_NOEXIST) {\n\t\t\tnode->generation = NO_GENERATION;\n\t\t\terr = access_node(conn, node, NODE_ACCESS_READ, NULL);\n\t\t\terrno = err ? : ENOENT;\n\t\t} else {\n\t\t\tlog(\"TDB error on read: %s\", tdb_errorstr(tdb_ctx));\n\t\t\terrno = EIO;\n\t\t}\n\t\tgoto error;\n\t}\n\n\tnode->parent = NULL;\n\ttalloc_steal(node, data.dptr);\n\n\t/* Datalen, childlen, number of permissions */\n\thdr = (void *)data.dptr;\n\tnode->generation = hdr->generation;\n\tnode->perms.num = hdr->num_perms;\n\tnode->datalen = hdr->datalen;\n\tnode->childlen = hdr->childlen;\n\n\t/* Permissions are struct xs_permissions. */\n\tnode->perms.p = hdr->perms;\n\tnode->acc.domid = node->perms.p[0].id;\n\tnode->acc.memory = data.dsize;\n\tif (domain_adjust_node_perms(node))\n\t\tgoto error;\n\n\t/* If owner is gone reset currently accounted memory size. */\n\tif (node->acc.domid != node->perms.p[0].id)\n\t\tnode->acc.memory = 0;\n\n\t/* Data is binary blob (usually ascii, no nul). */\n\tnode->data = node->perms.p + hdr->num_perms;\n\t/* Children is strings, nul separated. */\n\tnode->children = node->data + node->datalen;\n\n\tif (access_node(conn, node, NODE_ACCESS_READ, NULL))\n\t\tgoto error;\n\n\treturn node;\n\n error:\n\terr = errno;\n\ttalloc_free(node);\n\terrno = err;\n\treturn NULL;\n}", "target": 1, "idx": 11663}
{"commit_id": "318aaf34f1179b39fa9c30fa0f3288b645beee39", "project": "torvalds/linux", "func": "static void sas_eh_finish_cmd(struct scsi_cmnd *cmd)\n{\n\tstruct sas_ha_struct *sas_ha = SHOST_TO_SAS_HA(cmd->device->host);\n\tstruct domain_device *dev = cmd_to_domain_dev(cmd);\n\tstruct sas_task *task = TO_SAS_TASK(cmd);\n\n\t/* At this point, we only get called following an actual abort\n\t * of the task, so we should be guaranteed not to be racing with\n\t * any completions from the LLD.  Task is freed after this.\n\t */\n\tsas_end_task(cmd, task);\n\n\tif (dev_is_sata(dev)) {\n\t\t/* defer commands to libata so that libata EH can\n\t\t * handle ata qcs correctly\n\t\t */\n\t\tlist_move_tail(&cmd->eh_entry, &sas_ha->eh_ata_q);\n\t\treturn;\n\t}\n\n\t/* now finish the command and move it on to the error\n\t * handler done list, this also takes it off the\n\t * error handler pending list.\n\t */\n\tscsi_eh_finish_cmd(cmd, &sas_ha->eh_done_q);\n}", "target": 1, "idx": 11664}
{"commit_id": "014b40fb7e8d59087cf1c1988a68dd1979f86cb3", "project": "timescale/timescaledb", "func": "static void\ntsl_copy_or_move_chunk_proc(FunctionCallInfo fcinfo, bool delete_on_src_node)\n{\n\tOid chunk_id = PG_ARGISNULL(0) ? InvalidOid : PG_GETARG_OID(0);\n\tconst char *src_node_name = PG_ARGISNULL(1) ? NULL : NameStr(*PG_GETARG_NAME(1));\n\tconst char *dst_node_name = PG_ARGISNULL(2) ? NULL : NameStr(*PG_GETARG_NAME(2));\n\tconst char *op_id = PG_ARGISNULL(3) ? NULL : NameStr(*PG_GETARG_NAME(3));\n\tint rc;\n\tbool nonatomic = fcinfo->context && IsA(fcinfo->context, CallContext) &&\n\t\t\t\t\t !castNode(CallContext, fcinfo->context)->atomic;\n\n\tTS_PREVENT_FUNC_IF_READ_ONLY();\n\n\tPreventInTransactionBlock(true, get_func_name(FC_FN_OID(fcinfo)));\n\n\t/* src_node and dst_node both have to be non-NULL */\n\tif (src_node_name == NULL || dst_node_name == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid source or destination node\")));\n\n\tif (!OidIsValid(chunk_id))\n\t\tereport(ERROR, (errcode(ERRCODE_INVALID_PARAMETER_VALUE), errmsg(\"invalid chunk\")));\n\n\tif ((rc = SPI_connect_ext(nonatomic ? SPI_OPT_NONATOMIC : 0)) != SPI_OK_CONNECT)\n\t\telog(ERROR, \"SPI_connect failed: %s\", SPI_result_code_string(rc));\n\n\t/* Lock down search_path */\n\trc = SPI_exec(\"SET LOCAL search_path TO pg_catalog, pg_temp\", 0);\n\tif (rc < 0)\n\t\tereport(ERROR, (errcode(ERRCODE_INTERNAL_ERROR), (errmsg(\"could not set search_path\"))));\n\n\t/* perform the actual distributed chunk move after a few sanity checks */\n\tchunk_copy(chunk_id, src_node_name, dst_node_name, op_id, delete_on_src_node);\n\n\tif ((rc = SPI_finish()) != SPI_OK_FINISH)\n\t\telog(ERROR, \"SPI_finish failed: %s\", SPI_result_code_string(rc));\n}", "target": 2, "idx": 11665}
{"commit_id": "1630f53481f445ada0a455e9979236d31a8d3bb0", "project": "GNOME/nautilus", "func": "static gboolean\nis_link_trusted (NautilusFile *file,\n                 gboolean      is_launcher)\n{\n    GFile *location;\n    gboolean res;\n    g_autofree gchar* trusted = NULL;\n\n    if (!is_launcher)\n    {\n        return TRUE;\n    }\n\n    trusted = nautilus_file_get_metadata (file,\n                                          NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED,\n                                          NULL);\n    if (nautilus_file_can_execute (file) && trusted != NULL)\n    {\n        return TRUE;\n    }\n\n    res = FALSE;\n\n    if (nautilus_file_is_local (file))\n    {\n        location = nautilus_file_get_location (file);\n        res = nautilus_is_in_system_dir (location);\n        g_object_unref (location);\n    }\n\n    return res;\n}", "target": 1, "idx": 11666}
{"commit_id": "8d2e02ae650f00c4a53deb625211a0527126c605", "project": "xorg/lib/libX11", "func": "int\nXSetClassHint(\n\tDisplay *dpy,\n\tWindow w,\n\tXClassHint *classhint)\n{\n\tchar *class_string;\n\tchar *s;\n\tsize_t len_nm, len_cl;\n\n\tlen_nm = safestrlen(classhint->res_name);\n\tlen_cl = safestrlen(classhint->res_class);\n        if (len_nm + len_cl >= USHRT_MAX)\n            return 1;\n\tif ((class_string = s = Xmalloc(len_nm + len_cl + 2))) {\n\t    if (len_nm) {\n\t\tstrcpy(s, classhint->res_name);\n\t\ts += len_nm + 1;\n\t    }\n\t    else\n\t\t*s++ = '\\0';\n\t    if (len_cl)\n\t\tstrcpy(s, classhint->res_class);\n\t    else\n\t\t*s = '\\0';\n\t    XChangeProperty(dpy, w, XA_WM_CLASS, XA_STRING, 8,\n\t\t\t    PropModeReplace, (unsigned char *) class_string,\n\t\t\t    len_nm+len_cl+2);\n\t    Xfree(class_string);\n\t}\n\treturn 1;\n}", "target": 3, "idx": 11667}
{"commit_id": "0bf9f8d3e399a0e1d2b717f71b4776172446184b", "project": "xen-project/xen", "func": "unsigned long hypercall_create_continuation(\n    unsigned int op, const char *format, ...)\n{\n    struct vcpu *curr = current;\n    struct mc_state *mcs = &curr->mc_state;\n    const char *p = format;\n    unsigned long arg;\n    unsigned int i;\n    va_list args;\n\n    curr->hcall_preempted = true;\n\n    va_start(args, format);\n\n    if ( mcs->flags & MCSF_in_multicall )\n    {\n        for ( i = 0; *p != '\\0'; i++ )\n            mcs->call.args[i] = NEXT_ARG(p, args);\n    }\n    else\n    {\n        struct cpu_user_regs *regs = guest_cpu_user_regs();\n\n        regs->rax = op;\n\n        if ( !curr->hcall_compat )\n        {\n            for ( i = 0; *p != '\\0'; i++ )\n            {\n                arg = NEXT_ARG(p, args);\n                switch ( i )\n                {\n                case 0: regs->rdi = arg; break;\n                case 1: regs->rsi = arg; break;\n                case 2: regs->rdx = arg; break;\n                case 3: regs->r10 = arg; break;\n                case 4: regs->r8  = arg; break;\n                case 5: regs->r9  = arg; break;\n                }\n            }\n        }\n        else\n        {\n            for ( i = 0; *p != '\\0'; i++ )\n            {\n                arg = NEXT_ARG(p, args);\n                switch ( i )\n                {\n                case 0: regs->rbx = arg; break;\n                case 1: regs->rcx = arg; break;\n                case 2: regs->rdx = arg; break;\n                case 3: regs->rsi = arg; break;\n                case 4: regs->rdi = arg; break;\n                case 5: regs->rbp = arg; break;\n                }\n            }\n        }\n    }\n\n    va_end(args);\n\n    return op;\n\n bad_fmt:\n    gprintk(XENLOG_ERR, \"Bad hypercall continuation format '%c'\\n\", *p);\n    ASSERT_UNREACHABLE();\n    domain_crash(curr->domain);\n    return 0;\n}", "target": 1, "idx": 11668}
{"commit_id": "cb1214c124e1bd61f7dd551b94a794864861592e", "project": "ImageMagick", "func": "static int format8BIM(Image *ifile, Image *ofile)\n{\n  char\n    temp[MagickPathExtent];\n\n  unsigned int\n    foundOSType;\n\n  int\n    ID,\n    resCount,\n    i,\n    c;\n\n  ssize_t\n    count;\n\n  unsigned char\n    *PString,\n    *str;\n\n  resCount=0;\n  foundOSType=0; /* found the OSType */\n  (void) foundOSType;\n  c=ReadBlobByte(ifile);\n  while (c != EOF)\n  {\n    if (c == '8')\n      {\n        unsigned char\n          buffer[5];\n\n        buffer[0]=(unsigned char) c;\n        for (i=1; i<4; i++)\n        {\n          c=ReadBlobByte(ifile);\n          if (c == EOF)\n            return(-1);\n          buffer[i] = (unsigned char) c;\n        }\n        buffer[4]=0;\n        if (strcmp((const char *)buffer, \"8BIM\") == 0)\n          foundOSType=1;\n        else\n          continue;\n      }\n    else\n      {\n        c=ReadBlobByte(ifile);\n        continue;\n      }\n    /*\n      We found the OSType (8BIM) and now grab the ID, PString, and Size fields.\n    */\n    ID=ReadBlobMSBSignedShort(ifile);\n    if (ID < 0)\n      return(-1);\n    {\n      unsigned char\n        plen;\n\n      c=ReadBlobByte(ifile);\n      if (c == EOF)\n        return(-1);\n      plen = (unsigned char) c;\n      PString=(unsigned char *) AcquireQuantumMemory((size_t) (plen+\n        MagickPathExtent),sizeof(*PString));\n      if (PString == (unsigned char *) NULL)\n        return 0;\n      for (i=0; i<plen; i++)\n      {\n        c=ReadBlobByte(ifile);\n        if (c == EOF)\n          {\n            PString=(unsigned char *) RelinquishMagickMemory(PString);\n            return -1;\n          }\n        PString[i] = (unsigned char) c;\n      }\n      PString[ plen ] = 0;\n      if ((plen & 0x01) == 0)\n      {\n        c=ReadBlobByte(ifile);\n        if (c == EOF)\n          {\n            PString=(unsigned char *) RelinquishMagickMemory(PString);\n            return -1;\n          }\n      }\n    }\n    count=(ssize_t) ReadBlobMSBSignedLong(ifile);\n    if ((count < 0) || (count > GetBlobSize(ifile)))\n      {\n        PString=(unsigned char *) RelinquishMagickMemory(PString);\n        return -1;\n      }\n    /* make a buffer to hold the data and snag it from the input stream */\n    str=(unsigned char *) AcquireQuantumMemory((size_t) count+1,sizeof(*str));\n    if (str == (unsigned char *) NULL)\n      {\n        PString=(unsigned char *) RelinquishMagickMemory(PString);\n        return 0;\n      }\n    for (i=0; i < (ssize_t) count; i++)\n    {\n      c=ReadBlobByte(ifile);\n      if (c == EOF)\n        {\n          str=(unsigned char *) RelinquishMagickMemory(str);\n          PString=(unsigned char *) RelinquishMagickMemory(PString);\n          return -1;\n        }\n      str[i]=(unsigned char) c;\n    }\n\n    /* we currently skip thumbnails, since it does not make\n     * any sense preserving them in a real world application\n     */\n    if (ID != THUMBNAIL_ID)\n      {\n        /* now finish up by formatting this binary data into\n         * ASCII equivalent\n         */\n        if (strlen((const char *)PString) > 0)\n          (void) FormatLocaleString(temp,MagickPathExtent,\"8BIM#%d#%s=\",ID,\n            PString);\n        else\n          (void) FormatLocaleString(temp,MagickPathExtent,\"8BIM#%d=\",ID);\n        (void) WriteBlobString(ofile,temp);\n        if (ID == IPTC_ID)\n          {\n            formatString(ofile, \"IPTC\", 4);\n            formatIPTCfromBuffer(ofile, (char *)str, (ssize_t) count);\n          }\n        else\n          formatString(ofile, (char *)str, (ssize_t) count);\n      }\n    str=(unsigned char *) RelinquishMagickMemory(str);\n    PString=(unsigned char *) RelinquishMagickMemory(PString);\n    resCount++;\n    c=ReadBlobByte(ifile);\n  }\n  return resCount;\n}", "target": 2, "idx": 11669}
{"commit_id": "879f7080d7e141f415c79eaa3a8ac4a3dad0348b", "project": "openssl", "func": "static int tree_link_any(X509_POLICY_LEVEL *curr,\n                         const X509_POLICY_CACHE *cache,\n                         X509_POLICY_TREE *tree)\n{\n    int i;\n    X509_POLICY_NODE *node;\n    X509_POLICY_LEVEL *last = curr - 1;\n\n    for (i = 0; i < sk_X509_POLICY_NODE_num(last->nodes); i++) {\n        node = sk_X509_POLICY_NODE_value(last->nodes, i);\n\n        if (!tree_link_unmatched(curr, cache, node, tree))\n            return 0;\n    }\n    /* Finally add link to anyPolicy */\n    if (last->anyPolicy &&\n        level_add_node(curr, cache->anyPolicy, last->anyPolicy, tree, 0) == NULL)\n        return 0;\n    return 1;\n}", "target": 2, "idx": 11670}
{"commit_id": "947bc1ee6d05be10204b918df75a503415fd3213", "project": "pjsip/pjproject", "func": "static pj_status_t avi_get_frame(pjmedia_port *this_port, \n\t\t\t         pjmedia_frame *frame)\n{\n    struct avi_reader_port *fport = (struct avi_reader_port*)this_port;\n    pj_status_t status = PJ_SUCCESS;\n    pj_ssize_t size_read = 0, size_to_read = 0;\n\n    pj_assert(fport->base.info.signature == SIGNATURE);\n\n    /* We encountered end of file */\n    if (fport->eof) {\n\tPJ_LOG(5,(THIS_FILE, \"File port %.*s EOF\",\n\t\t  (int)fport->base.info.name.slen,\n\t\t  fport->base.info.name.ptr));\n\n\t/* Call callback, if any */\n\tif (fport->cb2) {\n\t    pj_bool_t no_loop = (fport->options & PJMEDIA_AVI_FILE_NO_LOOP);\n\n\t    if (!fport->subscribed) {\n\t    \tstatus = pjmedia_event_subscribe(NULL, &file_on_event,\n\t    \t\t\t\t         fport, fport);\n\t    \tfport->subscribed = (status == PJ_SUCCESS)? PJ_TRUE:\n\t    \t\t\t    PJ_FALSE;\n\t    }\n\n\t    if (fport->subscribed && fport->eof != 2) {\n\t    \tpjmedia_event event;\n\n\t    \tif (no_loop) {\n\t    \t    /* To prevent the callback from being called repeatedly */\n\t    \t    fport->eof = 2;\n\t    \t} else {\n\t    \t    fport->eof = PJ_FALSE;\n        \t    pj_file_setpos(fport->fd, fport->start_data, PJ_SEEK_SET);\n\t    \t}\n\n\t    \tpjmedia_event_init(&event, PJMEDIA_EVENT_CALLBACK,\n\t                      \t   NULL, fport);\n\t    \tpjmedia_event_publish(NULL, fport, &event,\n\t                              PJMEDIA_EVENT_PUBLISH_POST_EVENT);\n\t    }\n\t    \n\t    /* Should not access player port after this since\n\t     * it might have been destroyed by the callback.\n\t     */\n\t    frame->type = PJMEDIA_FRAME_TYPE_NONE;\n\t    frame->size = 0;\n\t    \n\t    return (no_loop? PJ_EEOF: PJ_SUCCESS);\n\n\t} else if (fport->cb) {\n\t    status = (*fport->cb)(this_port, fport->base.port_data.pdata);\n\t}\n\n\t/* If callback returns non PJ_SUCCESS or 'no loop' is specified,\n\t * return immediately (and don't try to access player port since\n\t * it might have been destroyed by the callback).\n\t */\n\tif ((status != PJ_SUCCESS) ||\n            (fport->options & PJMEDIA_AVI_FILE_NO_LOOP)) \n        {\n\t    frame->type = PJMEDIA_FRAME_TYPE_NONE;\n\t    frame->size = 0;\n\t    return PJ_EEOF;\n\t}\n\n        /* Rewind file */\n\tPJ_LOG(5,(THIS_FILE, \"File port %.*s rewinding..\",\n\t\t  (int)fport->base.info.name.slen,\n\t\t  fport->base.info.name.ptr));\n\tfport->eof = PJ_FALSE;\n        pj_file_setpos(fport->fd, fport->start_data, PJ_SEEK_SET);\n    }\n\n    /* For PCMU/A audio stream, reduce frame size to half (temporarily). */\n    if (fport->base.info.fmt.type == PJMEDIA_TYPE_AUDIO &&\n\t(fport->fmt_id == PJMEDIA_FORMAT_PCMA ||\n\t fport->fmt_id == PJMEDIA_FORMAT_PCMU))\n    {\n\tframe->size >>= 1;\n    }\n\n    /* Fill frame buffer. */\n    size_to_read = frame->size;\n    do {\n        pjmedia_avi_subchunk ch = {0, 0};\n        char *cid;\n        unsigned stream_id;\n\n        /* We need to read data from the file past the chunk boundary */\n        if (fport->size_left > 0 && fport->size_left < size_to_read) {\n            status = file_read3(fport->fd, frame->buf, fport->size_left,\n                                fport->bits_per_sample, &size_read);\n            if (status != PJ_SUCCESS)\n                goto on_error2;\n            size_to_read -= fport->size_left;\n            fport->size_left = 0;\n        }\n\n        /* Read new chunk data */\n        if (fport->size_left == 0) {\n            pj_off_t pos;\n            pj_off_t ch_len;\n\n            pj_file_getpos(fport->fd, &pos);\n\n            /* Data is padded to the nearest WORD boundary */\n            if (fport->pad) {\n                status = pj_file_setpos(fport->fd, fport->pad, PJ_SEEK_CUR);\n                fport->pad = 0;\n            }\n\n            status = file_read(fport->fd, &ch, sizeof(pjmedia_avi_subchunk));\n            if (status != PJ_SUCCESS) {\n                size_read = 0;\n                goto on_error2;\n            }\n            \n            PJ_CHECK_OVERFLOW_UINT32_TO_LONG(ch.len, \n                                         status = PJ_EINVAL;  goto on_error2;);\n            ch_len = ch.len;\n\n            cid = (char *)&ch.id;\n            if (cid[0] >= '0' && cid[0] <= '9' &&\n                cid[1] >= '0' && cid[1] <= '9') \n            {\n                stream_id = (cid[0] - '0') * 10 + (cid[1] - '0');\n            } else\n                stream_id = 100;\n            fport->pad = (pj_uint8_t)ch.len & 1;\n\n            TRACE_((THIS_FILE, \"Reading movi data at pos %u (%x), id: %.*s, \"\n                               \"length: %u\", (unsigned long)pos,\n                               (unsigned long)pos, 4, cid, ch.len));\n\n            /* We are only interested in data with our stream id */\n            if (stream_id != fport->stream_id) {\n                if (COMPARE_TAG(ch.id, PJMEDIA_AVI_LIST_TAG))\n                    PJ_LOG(5, (THIS_FILE, \"Unsupported LIST tag found in \"\n                                          \"the movi data.\"));\n                else if (COMPARE_TAG(ch.id, PJMEDIA_AVI_RIFF_TAG)) {\n                    PJ_LOG(3, (THIS_FILE, \"Unsupported format: multiple \"\n                           \"AVIs in a single file.\"));\n                    status = AVI_EOF;\n                    goto on_error2;\n                }\n\n                status = pj_file_setpos(fport->fd, ch_len, PJ_SEEK_CUR);\n                continue;\n            }\n            fport->size_left = ch.len;\n        }\n\n        frame->type = (fport->base.info.fmt.type == PJMEDIA_TYPE_VIDEO ?\n                       PJMEDIA_FRAME_TYPE_VIDEO : PJMEDIA_FRAME_TYPE_AUDIO);\n\n        if (frame->type == PJMEDIA_FRAME_TYPE_AUDIO) {\n            if (size_to_read > fport->size_left)\n                size_to_read = fport->size_left;\n            status = file_read3(fport->fd, (char *)frame->buf + frame->size -\n                                size_to_read, size_to_read,\n                                fport->bits_per_sample, &size_read);\n            if (status != PJ_SUCCESS)\n                goto on_error2;\n            fport->size_left -= size_to_read;\n        } else {\n            pj_assert(frame->size >= ch.len);\n            status = file_read3(fport->fd, frame->buf, ch.len,\n                                0, &size_read);\n            if (status != PJ_SUCCESS)\n                goto on_error2;\n            frame->size = ch.len;\n            fport->size_left = 0;\n        }\n\n        break;\n\n    } while(1);\n    frame->timestamp.u64 = fport->next_ts.u64;\n    if (frame->type == PJMEDIA_FRAME_TYPE_AUDIO) {\n\n\t/* Decode PCMU/A frame */\n\tif (fport->fmt_id == PJMEDIA_FORMAT_PCMA ||\n\t    fport->fmt_id == PJMEDIA_FORMAT_PCMU)\n\t{\n\t    unsigned i;\n\t    pj_uint16_t *dst;\n\t    pj_uint8_t *src;\n\n\t    dst = (pj_uint16_t*)frame->buf + frame->size - 1;\n\t    src = (pj_uint8_t*)frame->buf + frame->size - 1;\n\n\t    if (fport->fmt_id == PJMEDIA_FORMAT_PCMU) {\n\t\tfor (i = 0; i < frame->size; ++i) {\n\t\t    *dst-- = (pj_uint16_t) pjmedia_ulaw2linear(*src--);\n\t\t}\n\t    } else {\n\t\tfor (i = 0; i < frame->size; ++i) {\n\t\t    *dst-- = (pj_uint16_t) pjmedia_alaw2linear(*src--);\n\t\t}\n\t    }\n\n\t    /* Return back the frame size */\n\t    frame->size <<= 1;\n\t}\n\n\tif (fport->usec_per_frame) {\n\t    fport->next_ts.u64 += (fport->usec_per_frame *\n\t\t\t\t   fport->base.info.fmt.det.aud.clock_rate /\n\t\t\t\t   1000000);\n\t} else {\n\t    fport->next_ts.u64 += (frame->size *\n\t\t\t\t   fport->base.info.fmt.det.aud.clock_rate /\n\t\t\t\t   (fport->base.info.fmt.det.aud.avg_bps / 8));\n\t}\n    } else {\n\tif (fport->usec_per_frame) {\n\t    fport->next_ts.u64 += (fport->usec_per_frame * VIDEO_CLOCK_RATE /\n\t\t\t\t   1000000);\n\t} else {\n\t    fport->next_ts.u64 += (frame->size * VIDEO_CLOCK_RATE /\n\t\t\t\t   (fport->base.info.fmt.det.vid.avg_bps / 8));\n\t}\n    }\n\n    return PJ_SUCCESS;\n\non_error2:\n    if (status == AVI_EOF) {\n        fport->eof = PJ_TRUE;\n\n        size_to_read -= size_read;\n        if (size_to_read == (pj_ssize_t)frame->size) {\n            /* Frame is empty */\n \t    frame->type = PJMEDIA_FRAME_TYPE_NONE;\n\t    frame->size = 0;\n\t    return PJ_EEOF;           \n        }\n        pj_bzero((char *)frame->buf + frame->size - size_to_read,\n                 size_to_read);\n\n        return PJ_SUCCESS;\n    }\n\n    return status;\n}", "target": 2, "idx": 11671}
{"commit_id": "7a6f636db3360bb16d18078d51e8c596f31302a1", "project": "gpac", "func": "static void isor_get_chapters(GF_ISOFile *file, GF_FilterPid *opid)\n{\n\tu32 i, count;\n\tGF_PropertyValue p;\n\tGF_PropUIntList times;\n\tGF_PropStringList names;\n\tcount = gf_isom_get_chapter_count(file, 0);\n\tif (count) {\n\t\ttimes.vals = gf_malloc(sizeof(u32)*count);\n\t\tnames.vals = gf_malloc(sizeof(char *)*count);\n\t\ttimes.nb_items = names.nb_items = count;\n\n\t\tfor (i=0; i<count; i++) {\n\t\t\tconst char *name;\n\t\t\tu64 start;\n\t\t\tgf_isom_get_chapter(file, 0, i+1, &start, &name);\n\t\t\ttimes.vals[i] = (u32) start;\n\t\t\tnames.vals[i] = gf_strdup(name);\n\t\t}\n\t\tp.type = GF_PROP_UINT_LIST;\n\t\tp.value.uint_list = times;\n\t\tgf_filter_pid_set_property(opid, GF_PROP_PID_CHAP_TIMES, &p);\n\t\tgf_free(times.vals);\n\n\t\tp.type = GF_PROP_STRING_LIST;\n\t\tp.value.string_list = names;\n\t\tgf_filter_pid_set_property(opid, GF_PROP_PID_CHAP_NAMES, &p);\n\t\t//no free for string lists\n\t\treturn;\n\t}\n\n\tu32 chap_tk=0;\n\tcount = gf_isom_get_track_count(file);\n\tfor (i=0; i<count; i++) {\n\t\tu32 nb_ref = gf_isom_get_reference_count(file, i+1, GF_ISOM_REF_CHAP);\n\t\tif (nb_ref) {\n\t\t\tgf_isom_get_reference(file, i+1, GF_ISOM_REF_CHAP, 1, &chap_tk);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (chap_tk) {\n\t\tcount = gf_isom_get_sample_count(file, chap_tk);\n\t\tif (!count) chap_tk=0;\n\t}\n\tif (!chap_tk) return;\n\n\ttimes.vals = gf_malloc(sizeof(u32)*count);\n\tnames.vals = gf_malloc(sizeof(char *)*count);\n\ttimes.nb_items = names.nb_items = count;\n\n\tfor (i=0; i<count; i++) {\n\t\tu32 di;\n\t\tGF_ISOSample *s = gf_isom_get_sample(file, chap_tk, i+1, &di);\n\t\tif (!s) continue;\n\t\tGF_BitStream *bs = gf_bs_new(s->data, s->dataLength, GF_BITSTREAM_READ);\n\t\tGF_TextSample *txt = gf_isom_parse_text_sample(bs);\n\t\tif (txt) {\n\t\t\ttimes.vals[i] = (u32) s->DTS;\n\t\t\tnames.vals[i] = gf_strdup(txt->text ? txt->text : \"\");\n\t\t\tgf_isom_delete_text_sample(txt);\n\t\t}\n\t\tgf_bs_del(bs);\n\t\tgf_isom_sample_del(&s);\n\t}\n\tp.type = GF_PROP_UINT_LIST;\n\tp.value.uint_list = times;\n\tgf_filter_pid_set_property(opid, GF_PROP_PID_CHAP_TIMES, &p);\n\tgf_free(times.vals);\n\n\tp.type = GF_PROP_STRING_LIST;\n\tp.value.string_list = names;\n\tgf_filter_pid_set_property(opid, GF_PROP_PID_CHAP_NAMES, &p);\n\n}", "target": 1, "idx": 11672}
{"commit_id": "7ec54f9eb62b5d177e30eb8b1cad795a5f8d8986", "project": "qemu-project/qemu", "func": "static void usbredir_handle_bulk_data(USBRedirDevice *dev, USBPacket *p,\n                                      uint8_t ep)\n{\n    struct usb_redir_bulk_packet_header bulk_packet;\n    size_t size = usb_packet_size(p);\n    const int maxp = dev->endpoint[EP2I(ep)].max_packet_size;\n\n    if (usbredir_already_in_flight(dev, p->id)) {\n        p->status = USB_RET_ASYNC;\n        return;\n    }\n\n    if (dev->endpoint[EP2I(ep)].bulk_receiving_enabled) {\n        if (size != 0 && (size % maxp) == 0) {\n            usbredir_handle_buffered_bulk_in_data(dev, p, ep);\n            return;\n        }\n        WARNING(\"bulk recv invalid size %zd ep %02x, disabling\\n\", size, ep);\n        assert(dev->endpoint[EP2I(ep)].pending_async_packet == NULL);\n        usbredir_stop_bulk_receiving(dev, ep);\n        dev->endpoint[EP2I(ep)].bulk_receiving_enabled = 0;\n    }\n\n    DPRINTF(\"bulk-out ep %02X stream %u len %zd id %\"PRIu64\"\\n\",\n            ep, p->stream, size, p->id);\n\n    bulk_packet.endpoint  = ep;\n    bulk_packet.length    = size;\n    bulk_packet.stream_id = p->stream;\n    bulk_packet.length_high = size >> 16;\n    assert(bulk_packet.length_high == 0 ||\n           usbredirparser_peer_has_cap(dev->parser,\n                                       usb_redir_cap_32bits_bulk_length));\n\n    if (ep & USB_DIR_IN || size == 0) {\n        usbredirparser_send_bulk_packet(dev->parser, p->id,\n                                        &bulk_packet, NULL, 0);\n    } else {\n        g_autofree uint8_t *buf = g_malloc(size);\n        usb_packet_copy(p, buf, size);\n        usbredir_log_data(dev, \"bulk data out:\", buf, size);\n        usbredirparser_send_bulk_packet(dev->parser, p->id,\n                                        &bulk_packet, buf, size);\n    }\n    usbredirparser_do_write(dev->parser);\n    p->status = USB_RET_ASYNC;\n}", "target": 1, "idx": 11673}
{"commit_id": "eff73de2b1600ad8230692f00bc0ab49b166512a", "project": "torvalds/linux", "func": "static void cpia2_usb_disconnect(struct usb_interface *intf)\n{\n\tstruct camera_data *cam = usb_get_intfdata(intf);\n\tusb_set_intfdata(intf, NULL);\n\n\tDBG(\"Stopping stream\\n\");\n\tcpia2_usb_stream_stop(cam);\n\n\tmutex_lock(&cam->v4l2_lock);\n\tDBG(\"Unregistering camera\\n\");\n\tcpia2_unregister_camera(cam);\n\tv4l2_device_disconnect(&cam->v4l2_dev);\n\tmutex_unlock(&cam->v4l2_lock);\n\n\tif(cam->buffers) {\n\t\tDBG(\"Wakeup waiting processes\\n\");\n\t\tcam->curbuff->status = FRAME_READY;\n\t\tcam->curbuff->length = 0;\n\t\twake_up_interruptible(&cam->wq_stream);\n\t}\n\n\tv4l2_device_put(&cam->v4l2_dev);\n\n\tLOG(\"CPiA2 camera disconnected.\\n\");\n}", "target": 1, "idx": 11674}
{"commit_id": "ea25f914dc164c8d56b36147ecc86bc65f83c469", "project": "torvalds/linux", "func": "static int check_stack_boundary(struct bpf_verifier_env *env, int regno,\n\t\t\t\tint access_size, bool zero_size_allowed,\n\t\t\t\tstruct bpf_call_arg_meta *meta)\n{\n\tstruct bpf_verifier_state *state = env->cur_state;\n\tstruct bpf_reg_state *regs = state->regs;\n\tint off, i, slot, spi;\n\n\tif (regs[regno].type != PTR_TO_STACK) {\n\t\t/* Allow zero-byte read from NULL, regardless of pointer type */\n\t\tif (zero_size_allowed && access_size == 0 &&\n\t\t    register_is_null(regs[regno]))\n\t\t\treturn 0;\n\n\t\tverbose(env, \"R%d type=%s expected=%s\\n\", regno,\n\t\t\treg_type_str[regs[regno].type],\n\t\t\treg_type_str[PTR_TO_STACK]);\n\t\treturn -EACCES;\n\t}\n\n\t/* Only allow fixed-offset stack reads */\n\tif (!tnum_is_const(regs[regno].var_off)) {\n\t\tchar tn_buf[48];\n\n\t\ttnum_strn(tn_buf, sizeof(tn_buf), regs[regno].var_off);\n\t\tverbose(env, \"invalid variable stack read R%d var_off=%s\\n\",\n\t\t\tregno, tn_buf);\n\t\treturn -EACCES;\n\t}\n\toff = regs[regno].off + regs[regno].var_off.value;\n\tif (off >= 0 || off < -MAX_BPF_STACK || off + access_size > 0 ||\n\t    access_size < 0 || (access_size == 0 && !zero_size_allowed)) {\n\t\tverbose(env, \"invalid stack type R%d off=%d access_size=%d\\n\",\n\t\t\tregno, off, access_size);\n\t\treturn -EACCES;\n\t}\n\n\tif (env->prog->aux->stack_depth < -off)\n\t\tenv->prog->aux->stack_depth = -off;\n\n\tif (meta && meta->raw_mode) {\n\t\tmeta->access_size = access_size;\n\t\tmeta->regno = regno;\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < access_size; i++) {\n\t\tslot = -(off + i) - 1;\n\t\tspi = slot / BPF_REG_SIZE;\n\t\tif (state->allocated_stack <= slot ||\n\t\t    state->stack[spi].slot_type[slot % BPF_REG_SIZE] !=\n\t\t\tSTACK_MISC) {\n\t\t\tverbose(env, \"invalid indirect read from stack off %d+%d size %d\\n\",\n\t\t\t\toff, i, access_size);\n\t\t\treturn -EACCES;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 2, "idx": 11675}
{"commit_id": "203ab0db28c9666b16069d4056ac5f66f753a51d", "project": "Exiv2/exiv2", "func": "void TiffParserWorker::findPrimaryGroups(PrimaryGroups& primaryGroups,\n                                             TiffComponent* pSourceDir)\n    {\n        if (0 == pSourceDir) return;\n\n        const IfdId imageGroups[] = {\n            ifd0Id,\n            ifd1Id,\n            ifd2Id,\n            ifd3Id,\n            subImage1Id,\n            subImage2Id,\n            subImage3Id,\n            subImage4Id,\n            subImage5Id,\n            subImage6Id,\n            subImage7Id,\n            subImage8Id,\n            subImage9Id\n        };\n\n        for (unsigned int i = 0; i < EXV_COUNTOF(imageGroups); ++i) {\n            TiffFinder finder(0x00fe, imageGroups[i]);\n            pSourceDir->accept(finder);\n            TiffEntryBase* te = dynamic_cast<TiffEntryBase*>(finder.result());\n            if (   te ) {\n                if (te->pValue()) {\n                    if (te->pValue()->typeId() == unsignedLong\n                        && te->pValue()->count() == 1\n                        && (te->pValue()->toLong() & 1) == 0) {\n                        primaryGroups.push_back(te->group());\n                    }\n                }\n            }\n        }\n\n    }", "target": 1, "idx": 11676}
{"commit_id": "0f0b080ecde4d3dfec158d6f60da34d5e31693c4", "project": "tensorflow", "func": "void Compute(OpKernelContext* context) override {\n    // Input tensor is of the following dimensions:\n    // [ batch, in_rows, in_cols, in_depth ]\n    const Tensor& input = context->input(0);\n\n    // Input filter is of the following dimensions:\n    // [ filter_rows, filter_cols, in_depth, out_depth]\n    const Tensor& filter = context->input(1);\n\n    // For 2D convolution, there should be 4 dimensions.\n    OP_REQUIRES(context, input.dims() == 4,\n                errors::InvalidArgument(\"input must be rank 4 but is rank \",\n                                        input.shape().dims()));\n    OP_REQUIRES(context, filter.dims() == 4,\n                errors::InvalidArgument(\"filter must be rank 4 but is rank \",\n                                        filter.shape().dims()));\n\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(context->input(2).shape()),\n                errors::InvalidArgument(\"min_input must be rank 0 but is rank \",\n                                        context->input(2).shape().dims()));\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(context->input(3).shape()),\n                errors::InvalidArgument(\"max_input must be rank 0 but is rank \",\n                                        context->input(3).shape().dims()));\n    OP_REQUIRES(\n        context, TensorShapeUtils::IsScalar(context->input(4).shape()),\n        errors::InvalidArgument(\"min_filter must be rank 0 but is rank \",\n                                context->input(4).shape().dims()));\n    OP_REQUIRES(\n        context, TensorShapeUtils::IsScalar(context->input(5).shape()),\n        errors::InvalidArgument(\"max_filter must be rank 0 but is rank \",\n                                context->input(5).shape().dims()));\n\n    const float min_input = context->input(2).flat<float>()(0);\n    const float max_input = context->input(3).flat<float>()(0);\n    const float min_filter = context->input(4).flat<float>()(0);\n    const float max_filter = context->input(5).flat<float>()(0);\n    const int32_t offset_input =\n        FloatToQuantizedUnclamped<T1>(0.0f, min_input, max_input);\n    const int32_t offset_filter =\n        FloatToQuantizedUnclamped<T2>(0.0f, min_filter, max_filter);\n    const int32_t offset_output = 0;\n    const int32_t mult_output = 1;\n    const int32_t shift_output = 0;\n\n    // The last dimension for input is in_depth. It must be the same as the\n    // filter's in_depth.\n    const int64_t in_depth = input.dim_size(3);\n    OP_REQUIRES(context, in_depth == filter.dim_size(2),\n                errors::InvalidArgument(\n                    \"input and filter must have the same depth: \", in_depth,\n                    \" vs \", filter.dim_size(2)));\n\n    // The last dimension for filter is out_depth.\n    const int64_t out_depth = filter.dim_size(3);\n\n    // The second dimension for input is rows/height.\n    // The first dimension for filter is rows/height.\n    const int64_t input_rows = input.dim_size(1);\n    const int64_t filter_rows = filter.dim_size(0);\n\n    // The third dimension for input is columns/width.\n    // The second dimension for filter is columns/width.\n    const int64_t input_cols = input.dim_size(2);\n    const int64_t filter_cols = filter.dim_size(1);\n\n    // The first dimension for input is batch.\n    const int64_t batch = input.dim_size(0);\n\n    // For now we take the stride from the second dimension only (we\n    // assume row = col stride, and do not support striding on the\n    // batch or depth dimension).\n    const int stride = strides_[1];\n\n    int64_t out_rows = 0, out_cols = 0, pad_rows = 0, pad_cols = 0;\n    OP_REQUIRES_OK(context,\n                   GetWindowedOutputSize(input_rows, filter_rows, stride,\n                                         padding_, &out_rows, &pad_rows));\n    OP_REQUIRES_OK(context,\n                   GetWindowedOutputSize(input_cols, filter_cols, stride,\n                                         padding_, &out_cols, &pad_cols));\n    CHECK_GT(batch, 0);\n    CHECK_GT(out_rows, 0);\n    CHECK_GT(out_cols, 0);\n    CHECK_GT(out_depth, 0);\n    TensorShape out_shape({batch, out_rows, out_cols, out_depth});\n\n    // Output tensor is of the following dimensions:\n    // [ in_batch, out_rows, out_cols, out_depth ]\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, out_shape, &output));\n\n    // This will call different implementations (e.g. reference or optimized)\n    // depending on the template parameter.\n    ConvFunctor<T1, T2, T3> conv_functor;\n    conv_functor(context, input.flat<T1>().data(), batch, input_rows,\n                 input_cols, in_depth, offset_input, filter.flat<T2>().data(),\n                 filter_rows, filter_cols, out_depth, offset_filter, stride,\n                 padding_, output->flat<T3>().data(), out_rows, out_cols,\n                 shift_output, offset_output, mult_output);\n\n    float min_output_value;\n    float max_output_value;\n    QuantizationRangeForMultiplication<T1, T2, T3>(\n        min_input, max_input, min_filter, max_filter, &min_output_value,\n        &max_output_value);\n\n    Tensor* output_min = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, {}, &output_min));\n    output_min->flat<float>()(0) = min_output_value;\n\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(2, {}, &output_max));\n    output_max->flat<float>()(0) = max_output_value;\n  }", "target": 1, "idx": 11677}
{"commit_id": "fbc691eaaa10d0bcea6741d5a223dc3906106548", "project": "sysstat", "func": "void handle_curr_act_stats(int ifd, off_t fpos, int *curr, long *cnt, int *eosaf,\n\t\t\t   int rows, unsigned int act_id, int *reset,\n\t\t\t   struct file_activity *file_actlst, char *file,\n\t\t\t   struct file_magic *file_magic, void *rec_hdr_tmp,\n\t\t\t   int endian_mismatch, int arch_64, size_t b_size)\n{\n\tint p, reset_cd;\n\tunsigned long lines = 0;\n\tunsigned char rtype;\n\tint davg = 0, next, inc = 0;\n\n\tif (lseek(ifd, fpos, SEEK_SET) < fpos) {\n\t\tperror(\"lseek\");\n\t\texit(2);\n\t}\n\n\t/*\n\t * Restore the first stats collected.\n\t * Used to compute the rate displayed on the first line.\n\t */\n\tcopy_structures(act, id_seq, record_hdr, !*curr, 2);\n\n\t*cnt  = count;\n\n\t/* Assess number of lines printed when a bitmap is used */\n\tp = get_activity_position(act, act_id, EXIT_IF_NOT_FOUND);\n\tif (act[p]->bitmap) {\n\t\tinc = count_bits(act[p]->bitmap->b_array,\n\t\t\t\t BITMAP_SIZE(act[p]->bitmap->b_size));\n\t}\n\treset_cd = 1;\n\n\tdo {\n\t\t/*\n\t\t * Display <count> lines of stats.\n\t\t * Start with reading current sample's record header.\n\t\t */\n\t\t*eosaf = read_record_hdr(ifd, rec_hdr_tmp, &record_hdr[*curr],\n\t\t\t\t\t &file_hdr, arch_64, endian_mismatch, UEOF_STOP, b_size);\n\t\trtype = record_hdr[*curr].record_type;\n\n\t\tif (!*eosaf && (rtype != R_RESTART) && (rtype != R_COMMENT)) {\n\t\t\t/* Read the extra fields since it's not a special record */\n\t\t\tread_file_stat_bunch(act, *curr, ifd, file_hdr.sa_act_nr, file_actlst,\n\t\t\t\t\t     endian_mismatch, arch_64, file, file_magic, UEOF_STOP);\n\t\t}\n\n\t\tif ((lines >= rows) || !lines) {\n\t\t\tlines = 0;\n\t\t\tdis = 1;\n\t\t}\n\t\telse\n\t\t\tdis = 0;\n\n\t\tif (!*eosaf && (rtype != R_RESTART)) {\n\n\t\t\tif (rtype == R_COMMENT) {\n\t\t\t\t/* Display comment */\n\t\t\t\tnext = print_special_record(&record_hdr[*curr], flags + S_F_LOCAL_TIME,\n\t\t\t\t\t\t\t    &tm_start, &tm_end, R_COMMENT, ifd,\n\t\t\t\t\t\t\t    &rectime, NULL, file, 0,\n\t\t\t\t\t\t\t    file_magic, &file_hdr, act, &sar_fmt,\n\t\t\t\t\t\t\t    endian_mismatch, arch_64);\n\t\t\t\tif (next && lines) {\n\t\t\t\t\t/*\n\t\t\t\t\t * A line of comment was actually displayed: Count it in the\n\t\t\t\t\t * total number of displayed lines.\n\t\t\t\t\t * If no lines of stats had been previously displayed, ignore it\n\t\t\t\t\t * to make sure the header line will be displayed.\n\t\t\t\t\t */\n\t\t\t\t\tlines++;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* next is set to 1 when we were close enough to desired interval */\n\t\t\tnext = write_stats(*curr, USE_SA_FILE, cnt, tm_start.use, tm_end.use,\n\t\t\t\t\t   *reset, act_id, reset_cd);\n\t\t\treset_cd = 0;\n\t\t\tif (next && (*cnt > 0)) {\n\t\t\t\t(*cnt)--;\n\t\t\t}\n\n\t\t\tif (next) {\n\t\t\t\tdavg++;\n\t\t\t\t*curr ^= 1;\n\n\t\t\t\tif (inc) {\n\t\t\t\t\tlines += inc;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlines += act[p]->nr[*curr];\n\t\t\t\t}\n\t\t\t}\n\t\t\t*reset = FALSE;\n\t\t}\n\t}\n\twhile (*cnt && !*eosaf && (rtype != R_RESTART));\n\n\tif (davg) {\n\t\twrite_stats_avg(!*curr, USE_SA_FILE, act_id);\n\t}\n\n\t*reset = TRUE;\n}", "target": 2, "idx": 11678}
{"commit_id": "853bc26a7ea39e354b9f8889ae7ad1492ffa28d2", "project": "torvalds/linux", "func": "static struct o2nm_cluster *to_o2nm_cluster_from_node(struct o2nm_node *node)\n{\n\t/* through the first node_set .parent\n\t * mycluster/nodes/mynode == o2nm_cluster->o2nm_node_group->o2nm_node */\n\tif (node->nd_item.ci_parent)\n\t\treturn to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);\n\telse\n\t\treturn NULL;\n}", "target": 1, "idx": 11679}
{"commit_id": "dc8235128c3a1fcd5da8f30ab6839d413d353f28", "project": "GNOME/gdm", "func": "static gboolean\nlook_for_existing_users_sync (GdmDisplay *self)\n{\n        GdmDisplayPrivate *priv;\n        GError *error = NULL;\n        GVariant *call_result;\n        GVariant *user_list;\n\n        priv = gdm_display_get_instance_private (self);\n        priv->accountsservice_proxy = g_dbus_proxy_new_sync (priv->connection,\n                                                             0, NULL,\n                                                             \"org.freedesktop.Accounts\",\n                                                             \"/org/freedesktop/Accounts\",\n                                                             \"org.freedesktop.Accounts\",\n                                                             NULL,\n                                                             &error);\n\n        if (!priv->accountsservice_proxy) {\n                g_critical (\"Failed to contact accountsservice: %s\", error->message);\n                goto out;\n        }\n\n        call_result = g_dbus_proxy_call_sync (priv->accountsservice_proxy,\n                                              \"ListCachedUsers\",\n                                              NULL,\n                                              0,\n                                              -1,\n                                              NULL,\n                                              &error);\n\n        if (!call_result) {\n                g_critical (\"Failed to list cached users: %s\", error->message);\n                goto out;\n        }\n\n        g_variant_get (call_result, \"(@ao)\", &user_list);\n        priv->have_existing_user_accounts = g_variant_n_children (user_list) > 0;\n        g_variant_unref (user_list);\n        g_variant_unref (call_result);\nout:\n        g_clear_error (&error);\n        return priv->accountsservice_proxy != NULL && call_result != NULL;\n}", "target": 2, "idx": 11680}
{"commit_id": "399c297aa93afe2c0a39e2a1b3f972aebba44c9d", "project": "vim", "func": "static int\nspell_read_tree(\n    FILE\t*fd,\n    char_u\t**bytsp,\n    idx_T\t**idxsp,\n    int\t\tprefixtree,\t/* TRUE for the prefix tree */\n    int\t\tprefixcnt)\t/* when \"prefixtree\" is TRUE: prefix count */\n{\n    int\t\tlen;\n    int\t\tidx;\n    char_u\t*bp;\n    idx_T\t*ip;\n\n    /* The tree size was computed when writing the file, so that we can\n     * allocate it as one long block. <nodecount> */\n    len = get4c(fd);\n    if (len < 0)\n\treturn SP_TRUNCERROR;\n    if (len >= 0x3ffffff)\n\t/* Invalid length, multiply with sizeof(int) would overflow. */\n\treturn SP_FORMERROR;\n    if (len > 0)\n    {\n\t/* Allocate the byte array. */\n\tbp = lalloc((long_u)len, TRUE);\n\tif (bp == NULL)\n\t    return SP_OTHERERROR;\n\t*bytsp = bp;\n\n\t/* Allocate the index array. */\n\tip = (idx_T *)lalloc_clear((long_u)(len * sizeof(int)), TRUE);\n\tif (ip == NULL)\n\t    return SP_OTHERERROR;\n\t*idxsp = ip;\n\n\t/* Recursively read the tree and store it in the array. */\n\tidx = read_tree_node(fd, bp, ip, len, 0, prefixtree, prefixcnt);\n\tif (idx < 0)\n\t    return idx;\n    }\n    return 0;\n}", "target": 3, "idx": 11681}
{"commit_id": "6e389ce2c34355d36009a8fb1666bed29fa2d4f4", "project": "protobuf-c", "func": "static inline size_t\nint32_pack(uint32_t value, uint8_t *out)\n{\n\tif ((int32_t)value < 0) {\n\t\tout[0] = value | 0x80;\n\t\tout[1] = (value >> 7) | 0x80;\n\t\tout[2] = (value >> 14) | 0x80;\n\t\tout[3] = (value >> 21) | 0x80;\n\t\tout[4] = (value >> 28) | 0xf0;\n\t\tout[5] = out[6] = out[7] = out[8] = 0xff;\n\t\tout[9] = 0x01;\n\t\treturn 10;\n\t} else {\n\t\treturn uint32_pack(value, out);\n\t}\n}", "target": 1, "idx": 11682}
{"commit_id": "f8d9a433fe22ab2fa15c00179048ab02ae23d583", "project": "dlundquist/sniproxy", "func": "struct Address *\nnew_address(const char *hostname_or_ip) {\n    union {\n        struct sockaddr a;\n        struct sockaddr_in in;\n        struct sockaddr_in6 in6;\n        struct sockaddr_un un;\n        struct sockaddr_storage s;\n    } s;\n    char ip_buf[ADDRESS_BUFFER_SIZE];\n    char *port;\n    size_t len;\n\n    if (hostname_or_ip == NULL)\n        return NULL;\n\n    /* IPv6 address */\n    /* we need to test for raw IPv6 address for IPv4 port combinations since a\n     * colon would give false positives\n     */\n    memset(&s, 0, sizeof(s));\n    if (inet_pton(AF_INET6, hostname_or_ip,\n                &s.in6.sin6_addr) == 1) {\n        s.in6.sin6_family = AF_INET6;\n\n        return new_address_sa(&s.a, sizeof(s.in6));\n    }\n\n    /* Unix socket */\n    memset(&s, 0, sizeof(s));\n    if (strncmp(\"unix:\", hostname_or_ip, 5) == 0) {\n        if (strlen(hostname_or_ip) >=\n                sizeof(s.un.sun_path))\n            return NULL;\n\n        /* XXX: only supporting pathname unix sockets */\n        s.un.sun_family = AF_UNIX;\n        strncpy(s.un.sun_path,\n                hostname_or_ip + 5,\n                sizeof(s.un.sun_path) - 1);\n\n        return new_address_sa(&s.a, offsetof(struct sockaddr_un, sun_path) +\n                              strlen(s.un.sun_path) + 1);\n    }\n\n    /* Trailing port */\n    if ((port = strrchr(hostname_or_ip, ':')) != NULL &&\n            is_numeric(port + 1)) {\n        len = (size_t)(port - hostname_or_ip);\n        int port_num = atoi(port + 1);\n\n        if (len < sizeof(ip_buf) && port_num >= 0 && port_num <= 65535) {\n            strncpy(ip_buf, hostname_or_ip, len);\n            ip_buf[len] = '\\0';\n\n            struct Address *addr = new_address(ip_buf);\n            if (addr != NULL)\n                address_set_port(addr, (uint16_t) port_num);\n\n            return addr;\n        }\n    }\n\n    /* Wildcard */\n    if (strcmp(\"*\", hostname_or_ip) == 0) {\n        struct Address *addr = malloc(sizeof(struct Address));\n        if (addr != NULL) {\n            addr->type = WILDCARD;\n            addr->len = 0;\n            address_set_port(addr, 0);\n        }\n        return addr;\n    }\n\n    /* IPv4 address */\n    memset(&s, 0, sizeof(s));\n    if (inet_pton(AF_INET, hostname_or_ip,\n                  &s.in.sin_addr) == 1) {\n        s.in.sin_family = AF_INET;\n\n        return new_address_sa(&s.a, sizeof(s.in));\n    }\n\n    /* [IPv6 address] */\n    memset(&s, 0, sizeof(s));\n    if (hostname_or_ip[0] == '[' &&\n            (port = strchr(hostname_or_ip, ']')) != NULL) {\n        len = (size_t)(port - hostname_or_ip - 1);\n        if (len >= INET6_ADDRSTRLEN)\n            return NULL;\n\n        /* inet_pton() will not parse the IP correctly unless it is in a\n         * separate string.\n         */\n        strncpy(ip_buf, hostname_or_ip + 1, len);\n        ip_buf[len] = '\\0';\n\n        if (inet_pton(AF_INET6, ip_buf,\n                      &s.in6.sin6_addr) == 1) {\n            s.in6.sin6_family = AF_INET6;\n\n            return new_address_sa(&s.a, sizeof(s.in6));\n        }\n    }\n\n    /* hostname */\n    if (valid_hostname(hostname_or_ip)) {\n        len = strlen(hostname_or_ip);\n        struct Address *addr = malloc(\n                offsetof(struct Address, data) + len + 1);\n        if (addr != NULL) {\n            addr->type = HOSTNAME;\n            addr->port = 0;\n            addr->len = len;\n            memcpy(addr->data, hostname_or_ip, len);\n            addr->data[addr->len] = '\\0';\n\n            /* Store address in lower case */\n            for (char *c = addr->data; *c != '\\0'; c++)\n                *c = tolower(*c);\n        }\n\n        return addr;\n    }\n\n    return NULL;\n}", "target": 3, "idx": 11683}
{"commit_id": "8c55ff393340998faae887dfac19e7ef128e1e58", "project": "ffmpeg", "func": "static int output_frame(H264Context *h, AVFrame *dst, Picture *srcp)\n{\n    AVFrame *src = &srcp->f;\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(src->format);\n    int i;\n    int ret = av_frame_ref(dst, src);\n    if (ret < 0)\n        return ret;\n\n    av_dict_set(&dst->metadata, \"stereo_mode\", ff_h264_sei_stereo_mode(h), 0);\n\n    if (!srcp->crop)\n        return 0;\n\n    for (i = 0; i < desc->nb_components; i++) {\n        int hshift = (i > 0) ? desc->log2_chroma_w : 0;\n        int vshift = (i > 0) ? desc->log2_chroma_h : 0;\n        int off    = ((srcp->crop_left >> hshift) << h->pixel_shift) +\n                      (srcp->crop_top  >> vshift) * dst->linesize[i];\n        dst->data[i] += off;\n    }\n    return 0;\n}", "target": 1, "idx": 11684}
{"commit_id": "0f0fbc07d9be31f5e83ec5328d7311fdfd8328b1", "project": "ArtifexSoftware/mupdf", "func": "static void read_zip_dir_imp(fz_context *ctx, fz_zip_archive *zip, int start_offset)\n{\n\tfz_stream *file = zip->super.file;\n\tint sig;\n\tint i, count, offset, csize, usize;\n\tint namesize, metasize, commentsize;\n\tchar *name;\n\tsize_t n;\n\n\tzip->count = 0;\n\n\tfz_seek(ctx, file, start_offset, 0);\n\n\tsig = fz_read_int32_le(ctx, file);\n\tif (sig != ZIP_END_OF_CENTRAL_DIRECTORY_SIG)\n\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"wrong zip end of central directory signature (0x%x)\", sig);\n\n\t(void) fz_read_int16_le(ctx, file); /* this disk */\n\t(void) fz_read_int16_le(ctx, file); /* start disk */\n\t(void) fz_read_int16_le(ctx, file); /* entries in this disk */\n\tcount = fz_read_int16_le(ctx, file); /* entries in central directory disk */\n\t(void) fz_read_int32_le(ctx, file); /* size of central directory */\n\toffset = fz_read_int32_le(ctx, file); /* offset to central directory */\n\n\t/* ZIP64 */\n\tif (count == 0xFFFF || offset == 0xFFFFFFFF)\n\t{\n\t\tint64_t offset64, count64;\n\n\t\tfz_seek(ctx, file, start_offset - 20, 0);\n\n\t\tsig = fz_read_int32_le(ctx, file);\n\t\tif (sig != ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIG)\n\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"wrong zip64 end of central directory locator signature (0x%x)\", sig);\n\n\t\t(void) fz_read_int32_le(ctx, file); /* start disk */\n\t\toffset64 = fz_read_int64_le(ctx, file); /* offset to end of central directory record */\n\t\tif (offset64 > INT32_MAX)\n\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"zip64 files larger than 2 GB aren't supported\");\n\n\t\tfz_seek(ctx, file, offset64, 0);\n\n\t\tsig = fz_read_int32_le(ctx, file);\n\t\tif (sig != ZIP64_END_OF_CENTRAL_DIRECTORY_SIG)\n\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"wrong zip64 end of central directory signature (0x%x)\", sig);\n\n\t\t(void) fz_read_int64_le(ctx, file); /* size of record */\n\t\t(void) fz_read_int16_le(ctx, file); /* version made by */\n\t\t(void) fz_read_int16_le(ctx, file); /* version to extract */\n\t\t(void) fz_read_int32_le(ctx, file); /* disk number */\n\t\t(void) fz_read_int32_le(ctx, file); /* disk number start */\n\t\tcount64 = fz_read_int64_le(ctx, file); /* entries in central directory disk */\n\t\t(void) fz_read_int64_le(ctx, file); /* entries in central directory */\n\t\t(void) fz_read_int64_le(ctx, file); /* size of central directory */\n\t\toffset64 = fz_read_int64_le(ctx, file); /* offset to central directory */\n\n\t\tif (count == 0xFFFF)\n\t\t{\n\t\t\tif (count64 > INT32_MAX)\n\t\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"zip64 files larger than 2 GB aren't supported\");\n\t\t\tcount = count64;\n\t\t}\n\t\tif (offset == 0xFFFFFFFF)\n\t\t{\n\t\t\tif (offset64 > INT32_MAX)\n\t\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"zip64 files larger than 2 GB aren't supported\");\n\t\t\toffset = offset64;\n\t\t}\n\t}\n\n\tfz_seek(ctx, file, offset, 0);\n\n\tfor (i = 0; i < count; i++)\n\t{\n\t\tsig = fz_read_int32_le(ctx, file);\n\t\tif (sig != ZIP_CENTRAL_DIRECTORY_SIG)\n\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"wrong zip central directory signature (0x%x)\", sig);\n\n\t\t(void) fz_read_int16_le(ctx, file); /* version made by */\n\t\t(void) fz_read_int16_le(ctx, file); /* version to extract */\n\t\t(void) fz_read_int16_le(ctx, file); /* general */\n\t\t(void) fz_read_int16_le(ctx, file); /* method */\n\t\t(void) fz_read_int16_le(ctx, file); /* last mod file time */\n\t\t(void) fz_read_int16_le(ctx, file); /* last mod file date */\n\t\t(void) fz_read_int32_le(ctx, file); /* crc-32 */\n\t\tcsize = fz_read_int32_le(ctx, file);\n\t\tusize = fz_read_int32_le(ctx, file);\n\t\tnamesize = fz_read_int16_le(ctx, file);\n\t\tmetasize = fz_read_int16_le(ctx, file);\n\t\tcommentsize = fz_read_int16_le(ctx, file);\n\t\t(void) fz_read_int16_le(ctx, file); /* disk number start */\n\t\t(void) fz_read_int16_le(ctx, file); /* int file atts */\n\t\t(void) fz_read_int32_le(ctx, file); /* ext file atts */\n\t\toffset = fz_read_int32_le(ctx, file);\n\n\t\tif (namesize < 0 || metasize < 0 || commentsize < 0)\n\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"invalid size in zip entry\");\n\n\t\tname = fz_malloc(ctx, namesize + 1);\n\t\tn = fz_read(ctx, file, (unsigned char*)name, namesize);\n\t\tif (n < (size_t)namesize)\n\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"premature end of data in zip entry name\");\n\t\tname[namesize] = '\\0';\n\n\t\twhile (metasize > 0)\n\t\t{\n\t\t\tint type = fz_read_int16_le(ctx, file);\n\t\t\tint size = fz_read_int16_le(ctx, file);\n\t\t\tif (type == ZIP64_EXTRA_FIELD_SIG)\n\t\t\t{\n\t\t\t\tint sizeleft = size;\n\t\t\t\tif (usize == 0xFFFFFFFF && sizeleft >= 8)\n\t\t\t\t{\n\t\t\t\t\tusize = fz_read_int64_le(ctx, file);\n\t\t\t\t\tsizeleft -= 8;\n\t\t\t\t}\n\t\t\t\tif (csize == 0xFFFFFFFF && sizeleft >= 8)\n\t\t\t\t{\n\t\t\t\t\tcsize = fz_read_int64_le(ctx, file);\n\t\t\t\t\tsizeleft -= 8;\n\t\t\t\t}\n\t\t\t\tif (offset == 0xFFFFFFFF && sizeleft >= 8)\n\t\t\t\t{\n\t\t\t\t\toffset = fz_read_int64_le(ctx, file);\n\t\t\t\t\tsizeleft -= 8;\n\t\t\t\t}\n\t\t\t\tfz_seek(ctx, file, sizeleft - size, 1);\n\t\t\t}\n\t\t\tfz_seek(ctx, file, size, 1);\n\t\t\tmetasize -= 4 + size;\n\t\t}\n\t\tif (usize < 0 || csize < 0 || offset < 0)\n\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"zip64 files larger than 2 GB are not supported\");\n\n\t\tfz_seek(ctx, file, commentsize, 1);\n\n\t\tzip->entries = fz_resize_array(ctx, zip->entries, zip->count + 1, sizeof *zip->entries);\n\n\t\tzip->entries[zip->count].name = name;\n\t\tzip->entries[zip->count].offset = offset;\n\t\tzip->entries[zip->count].csize = csize;\n\t\tzip->entries[zip->count].usize = usize;\n\n\t\tzip->count++;\n\t}\n}", "target": 2, "idx": 11685}
{"commit_id": "a6dcafe6ded8e61658b40f5699878cd19a481f80", "project": "facebook/hermes", "func": "CallResult<HermesValue>\naddOp_RJS(Runtime &runtime, Handle<> xHandle, Handle<> yHandle) {\n  auto resX = toPrimitive_RJS(runtime, xHandle, PreferredType::NONE);\n  if (resX == ExecutionStatus::EXCEPTION) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto xPrim = runtime.makeHandle(resX.getValue());\n\n  auto resY = toPrimitive_RJS(runtime, yHandle, PreferredType::NONE);\n  if (resY == ExecutionStatus::EXCEPTION) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto yPrim = runtime.makeHandle(resY.getValue());\n\n  // If one of the values is a string, concatenate as strings.\n  if (xPrim->isString() || yPrim->isString()) {\n    auto resX = toString_RJS(runtime, xPrim);\n    if (resX == ExecutionStatus::EXCEPTION) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    auto xStr = runtime.makeHandle(std::move(*resX));\n\n    auto resY = toString_RJS(runtime, yPrim);\n    if (resY == ExecutionStatus::EXCEPTION) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    auto yStr = runtime.makeHandle(std::move(*resY));\n\n    return StringPrimitive::concat(runtime, xStr, yStr);\n  }\n\n  // xPrim and yPrim are primitives; hence, they are already bigints, or they\n  // will never be bigints.\n  if (LLVM_LIKELY(!xPrim->isBigInt())) {\n    // xPrim is not a bigint; thus this is Number + Number.\n    auto res = toNumber_RJS(runtime, xPrim);\n    if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    const double xNum = res->getNumber();\n    // N.B.: toNumber(yPrim) will raise an TypeError if yPrim is bigint, which\n    // is the correct exception to be raised when trying to perform\n    // Number + BigInt. This avoids the need to check if yPrim is a bigint.\n    res = toNumber_RJS(runtime, yPrim);\n    if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    const double yNum = res->getNumber();\n    return HermesValue::encodeDoubleValue(xNum + yNum);\n  }\n\n  // yPrim is a primitive; therefore it is already a BigInt, or it will never be\n  // one.\n  if (!yPrim->isBigInt()) {\n    return runtime.raiseTypeErrorForValue(\n        \"Cannot convert \", yHandle, \" to BigInt\");\n  }\n\n  return BigIntPrimitive::add(\n      runtime,\n      runtime.makeHandle(xPrim->getBigInt()),\n      runtime.makeHandle(yPrim->getBigInt()));\n}", "target": 3, "idx": 11686}
{"commit_id": "963c2d57aa63fa5421cf30698485bd4ba20e06aa", "project": "contiki-ng", "func": "static bool\nmodify(struct jsonparse_state *state, char c)\n{\n  if(state->depth > 0) {\n    state->stack[state->depth - 1] = c;\n    return true;\n  } else {\n    return false;\n  }\n}", "target": 2, "idx": 11687}
{"commit_id": "5e3cc1ee1405a7eb3487ed24f786dec01b4cbe1f", "project": "torvalds/linux", "func": "void\nv9fs_stat2inode(struct p9_wstat *stat, struct inode *inode,\n\t\t struct super_block *sb, unsigned int flags)\n{\n\tumode_t mode;\n\tchar ext[32];\n\tchar tag_name[14];\n\tunsigned int i_nlink;\n\tstruct v9fs_session_info *v9ses = sb->s_fs_info;\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\n\tset_nlink(inode, 1);\n\n\tinode->i_atime.tv_sec = stat->atime;\n\tinode->i_mtime.tv_sec = stat->mtime;\n\tinode->i_ctime.tv_sec = stat->mtime;\n\n\tinode->i_uid = v9ses->dfltuid;\n\tinode->i_gid = v9ses->dfltgid;\n\n\tif (v9fs_proto_dotu(v9ses)) {\n\t\tinode->i_uid = stat->n_uid;\n\t\tinode->i_gid = stat->n_gid;\n\t}\n\tif ((S_ISREG(inode->i_mode)) || (S_ISDIR(inode->i_mode))) {\n\t\tif (v9fs_proto_dotu(v9ses) && (stat->extension[0] != '\\0')) {\n\t\t\t/*\n\t\t\t * Hadlink support got added later to\n\t\t\t * to the .u extension. So there can be\n\t\t\t * server out there that doesn't support\n\t\t\t * this even with .u extension. So check\n\t\t\t * for non NULL stat->extension\n\t\t\t */\n\t\t\tstrlcpy(ext, stat->extension, sizeof(ext));\n\t\t\t/* HARDLINKCOUNT %u */\n\t\t\tsscanf(ext, \"%13s %u\", tag_name, &i_nlink);\n\t\t\tif (!strncmp(tag_name, \"HARDLINKCOUNT\", 13))\n\t\t\t\tset_nlink(inode, i_nlink);\n\t\t}\n\t}\n\tmode = p9mode2perm(v9ses, stat);\n\tmode |= inode->i_mode & ~S_IALLUGO;\n\tinode->i_mode = mode;\n\n\tif (!(flags & V9FS_STAT2INODE_KEEP_ISIZE))\n\t\tv9fs_i_size_write(inode, stat->length);\n\t/* not real number of blocks, but 512 byte ones ... */\n\tinode->i_blocks = (stat->length + 512 - 1) >> 9;\n\tv9inode->cache_validity &= ~V9FS_INO_INVALID_ATTR;\n}", "target": 2, "idx": 11688}
{"commit_id": "9cf652cef49d74afe3d454f27d49eb1a1394951e", "project": "ffmpeg", "func": "static int nut_read_header(AVFormatContext *s)\n{\n    NUTContext *nut = s->priv_data;\n    AVIOContext *bc = s->pb;\n    int64_t pos;\n    int initialized_stream_count, ret;\n\n    nut->avf = s;\n\n    /* main header */\n    pos = 0;\n    ret = 0;\n    do {\n        if (ret == AVERROR(ENOMEM))\n            return ret;\n\n        pos = find_startcode(bc, MAIN_STARTCODE, pos) + 1;\n        if (pos < 0 + 1) {\n            av_log(s, AV_LOG_ERROR, \"No main startcode found.\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    } while ((ret = decode_main_header(nut)) < 0);\n\n    /* stream headers */\n    pos = 0;\n    for (initialized_stream_count = 0; initialized_stream_count < s->nb_streams;) {\n        pos = find_startcode(bc, STREAM_STARTCODE, pos) + 1;\n        if (pos < 0 + 1) {\n            av_log(s, AV_LOG_ERROR, \"Not all stream headers found.\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        if (decode_stream_header(nut) >= 0)\n            initialized_stream_count++;\n    }\n\n    /* info headers */\n    pos = 0;\n    for (;;) {\n        uint64_t startcode = find_any_startcode(bc, pos);\n        pos = avio_tell(bc);\n\n        if (startcode == 0) {\n            av_log(s, AV_LOG_ERROR, \"EOF before video frames\\n\");\n            return AVERROR_INVALIDDATA;\n        } else if (startcode == SYNCPOINT_STARTCODE) {\n            nut->next_startcode = startcode;\n            break;\n        } else if (startcode != INFO_STARTCODE) {\n            continue;\n        }\n\n        decode_info_header(nut);\n    }\n\n    ffformatcontext(s)->data_offset = pos - 8;\n\n    if (bc->seekable & AVIO_SEEKABLE_NORMAL) {\n        int64_t orig_pos = avio_tell(bc);\n        find_and_decode_index(nut);\n        avio_seek(bc, orig_pos, SEEK_SET);\n    }\n    av_assert0(nut->next_startcode == SYNCPOINT_STARTCODE);\n\n    ff_metadata_conv_ctx(s, NULL, ff_nut_metadata_conv);\n\n    return 0;\n}", "target": 1, "idx": 11689}
{"commit_id": "8e9d6b38c036a97020c462ad48e1132e0ddc57ce", "project": "gpac", "func": "GF_Err chnl_box_size(GF_Box *s)\n{\n\tGF_ChannelLayoutBox *ptr = (GF_ChannelLayoutBox *) s;\n\ts->size += 1;\n\tif (ptr->version==1) s->size++;\n\tif (ptr->layout.stream_structure & 1) {\n\t\ts->size += 1;\n\t\tif (ptr->layout.definedLayout==0) {\n\t\t\tu32 i;\n\t\t\tif (ptr->version==1) s->size++;\n\t\t\tfor (i=0; i<ptr->layout.channels_count; i++) {\n\t\t\t\ts->size+=1;\n\t\t\t\tif (ptr->layout.layouts[i].position==126)\n\t\t\t\t\ts->size+=3;\n\t\t\t}\n\t\t} else {\n\t\t\tif (ptr->version==1) {\n\t\t\t\ts->size += 1;\n\t\t\t\tif (ptr->layout.omitted_channels_present)\n\t\t\t\t\ts->size += 8;\n\t\t\t} else {\n\t\t\t\ts->size += 8;\n\t\t\t}\n\t\t}\n\t}\n\tif ((ptr->version==0) && (ptr->layout.stream_structure & 2)) {\n\t\ts->size += 1;\n\t}\n\treturn GF_OK;\n}", "target": 2, "idx": 11690}
{"commit_id": "9eeac00b38348c664dfeae2525bba0cf1bc32349", "project": "gpac", "func": "static void nhmldump_send_header(GF_NHMLDumpCtx *ctx)\n{\n\tGF_FilterPacket *dst_pck;\n\tchar nhml[1024];\n\tu32 size;\n\tu8 *output;\n\tconst GF_PropertyValue *p;\n\n\tctx->szRootName = \"NHNTStream\";\n\tif (ctx->dims) {\n\t\tctx->szRootName = \"DIMSStream\";\n\t}\n\n\tif (!ctx->filep) {\n\t\tsprintf(nhml, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n\");\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t}\n\n\t/*write header*/\n\tsprintf(nhml, \"<%s version=\\\"1.0\\\" \", ctx->szRootName);\n\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\n\n\tNHML_PRINT_UINT(GF_PROP_PID_ID, NULL, \"trackID\")\n\tNHML_PRINT_UINT(GF_PROP_PID_TIMESCALE, NULL, \"timeScale\")\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_IN_IOD);\n\tif (p && p->value.boolean) {\n\t\tsprintf(nhml, \"inRootOD=\\\"yes\\\" \");\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t}\n\n\tif (ctx->oti && (ctx->oti<GF_CODECID_LAST_MPEG4_MAPPING)) {\n\t\tsprintf(nhml, \"streamType=\\\"%d\\\" objectTypeIndication=\\\"%d\\\" \", ctx->streamtype, ctx->oti);\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32)strlen(nhml));\n\t} else {\n\t\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_SUBTYPE);\n\t\tif (p) {\n\t\t\tsprintf(nhml, \"%s=\\\"%s\\\" \", \"mediaType\", gf_4cc_to_str(p->value.uint));\n\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\n\t\t\tNHML_PRINT_4CC(GF_PROP_PID_ISOM_SUBTYPE, \"mediaSubType\", \"mediaSubType\")\n\t\t} else {\n\t\t\tNHML_PRINT_4CC(GF_PROP_PID_CODECID, NULL, \"codecID\")\n\t\t}\n\t}\n\n\tif (ctx->w && ctx->h) {\n\t\t//compatibility with old arch, we might want to remove this\n\t\tswitch (ctx->streamtype) {\n\t\tcase GF_STREAM_VISUAL:\n\t\tcase GF_STREAM_SCENE:\n\t\t\tsprintf(nhml, \"width=\\\"%d\\\" height=\\\"%d\\\" \", ctx->w, ctx->h);\n\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\telse if (ctx->sr && ctx->chan) {\n\t\tsprintf(nhml, \"sampleRate=\\\"%d\\\" numChannels=\\\"%d\\\" \", ctx->sr, ctx->chan);\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\tsprintf(nhml, \"sampleRate=\\\"%d\\\" numChannels=\\\"%d\\\" \", ctx->sr, ctx->chan);\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_AUDIO_FORMAT);\n\t\tif (p)\n\t\t\tsprintf(nhml, \"bitsPerSample=\\\"%d\\\" \", gf_audio_fmt_bit_depth(p->value.uint));\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t}\n\n\tNHML_PRINT_4CC(0, \"codec_vendor\", \"codecVendor\")\n\tNHML_PRINT_UINT(0, \"codec_version\", \"codecVersion\")\n\tNHML_PRINT_UINT(0, \"codec_revision\", \"codecRevision\")\n\tNHML_PRINT_STRING(0, \"compressor_name\", \"compressorName\")\n\tNHML_PRINT_UINT(0, \"temporal_quality\", \"temporalQuality\")\n\tNHML_PRINT_UINT(0, \"spatial_quality\", \"spatialQuality\")\n\tNHML_PRINT_UINT(0, \"hres\", \"horizontalResolution\")\n\tNHML_PRINT_UINT(0, \"vres\", \"verticalResolution\")\n\tNHML_PRINT_UINT(GF_PROP_PID_BIT_DEPTH_Y, NULL, \"bitDepth\")\n\n\tNHML_PRINT_STRING(0, \"meta:xmlns\", \"xml_namespace\")\n\tNHML_PRINT_STRING(0, \"meta:schemaloc\", \"xml_schema_location\")\n\tNHML_PRINT_STRING(0, \"meta:mime\", \"mime_type\")\n\n\tNHML_PRINT_STRING(0, \"meta:config\", \"config\")\n\tNHML_PRINT_STRING(0, \"meta:aux_mimes\", \"aux_mime_type\")\n\n\tif (ctx->codecid == GF_CODECID_DIMS) {\n\t\tif (gf_filter_pid_get_property_str(ctx->ipid, \"meta:xmlns\")==NULL) {\n\t\t\tsprintf(nhml, \"xmlns=\\\"http://www.3gpp.org/richmedia\\\" \");\n\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\t}\n\n\t\tNHML_PRINT_UINT(0, \"dims:profile\", \"profile\")\n\t\tNHML_PRINT_UINT(0, \"dims:level\", \"level\")\n\t\tNHML_PRINT_UINT(0, \"dims:pathComponents\", \"pathComponents\")\n\n\t\tp = gf_filter_pid_get_property_str(ctx->ipid, \"dims:fullRequestHost\");\n\t\tif (p) {\n\t\t\tsprintf(nhml, \"useFullRequestHost=\\\"%s\\\" \", p->value.boolean ? \"yes\" : \"no\");\n\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\t}\n\t\tp = gf_filter_pid_get_property_str(ctx->ipid, \"dims:streamType\");\n\t\tif (p) {\n\t\t\tsprintf(nhml, \"stream_type=\\\"%s\\\" \", p->value.boolean ? \"primary\" : \"secondary\");\n\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\t}\n\t\tp = gf_filter_pid_get_property_str(ctx->ipid, \"dims:redundant\");\n\t\tif (p) {\n\t\t\tsprintf(nhml, \"contains_redundant=\\\"%s\\\" \", (p->value.uint==1) ? \"main\" : ((p->value.uint==1) ? \"redundant\" : \"main+redundant\") );\n\t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t\t}\n\t\tNHML_PRINT_UINT(0, \"dims:scriptTypes\", \"scriptTypes\")\n\t}\n\n\t//send DCD\n\tif (ctx->opid_info) {\n\t\tsprintf(nhml, \"specificInfoFile=\\\"%s\\\" \", gf_file_basename(ctx->info_file) );\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\n\t\tdst_pck = gf_filter_pck_new_shared(ctx->opid_info, ctx->dcfg, ctx->dcfg_size, NULL);\n\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);\n\t\tgf_filter_pck_set_readonly(dst_pck);\n\t\tgf_filter_pck_send(dst_pck);\n\t}\n\n\tNHML_PRINT_STRING(0, \"meta:encoding\", \"encoding\")\n\tNHML_PRINT_STRING(0, \"meta:contentEncoding\", \"content_encoding\")\n\tctx->uncompress = GF_FALSE;\n\tif (p) {\n\t\tif (!strcmp(p->value.string, \"deflate\")) ctx->uncompress = GF_TRUE;\n\t\telse {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[NHMLMx] content_encoding %s not supported\\n\", p->value.string ));\n\t\t}\n\t}\n\n\tif (ctx->opid_mdia) {\n\t\tsprintf(nhml, \"baseMediaFile=\\\"%s\\\" \", gf_file_basename(ctx->media_file) );\n\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\t}\n\tsprintf(nhml, \">\\n\");\n\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n\n\tgf_bs_get_content_no_truncate(ctx->bs_w, &ctx->nhml_buffer, &size, &ctx->nhml_buffer_size);\n\n\tif (ctx->filep) {\n\t\tgf_fwrite(ctx->nhml_buffer, size, ctx->filep);\n\t\treturn;\n\t}\n\n\tdst_pck = gf_filter_pck_new_alloc(ctx->opid_nhml, size, &output);\n\tmemcpy(output, ctx->nhml_buffer, size);\n\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_FALSE);\n\tgf_filter_pck_send(dst_pck);\n}", "target": 1, "idx": 11691}
{"commit_id": "063eb917c88f8a965d4988501a4ff54441440c42", "project": "vooon/ntpd_driver", "func": "int main(int argc, char *argv[])\n{\n  ros::init(argc, argv, \"ntpd_shm\");\n\n  ros::NodeHandle nh(\"~\");\n  ros::Subscriber time_ref_sub;\n\n  int shm_unit;\n\n  // Override default ROS handler\n  signal(SIGINT, sig_handler);\n\n  // Read Parameters\n  nh.param(\"shm_unit\", shm_unit, 2);\n  nh.param(\"fixup_date\", g_set_date, false);\n\n  // Report settings\n  ROS_INFO_STREAM(\"NTP date fixup: \" << ((g_set_date) ? \"enabled\" : \"disabled\"));\n\n  g_shm = get_shmTime(shm_unit);\n  if (g_shm == NULL)\n    return 1;\n\n  // prefer to unreliable connection, but accept tcp too.\n  time_ref_sub = nh.subscribe(\"time_ref\", 10, time_ref_cb,\n      ros::TransportHints()\n      .unreliable().maxDatagramSize(1024)\n      .reliable().tcpNoDelay(true));\n\n  ros::spin();\n  put_shmTime(&g_shm);\n  return 0;\n}", "target": 3, "idx": 11692}
{"commit_id": "f5c7f5dfbaf0d2f7d946d0fe86f08e6bcb36ed0d", "project": "openssl", "func": "WORK_STATE tls_finish_handshake(SSL *s, WORK_STATE wst)\n{\n    void (*cb) (const SSL *ssl, int type, int val) = NULL;\n\n#ifndef OPENSSL_NO_SCTP\n    if (SSL_IS_DTLS(s) && BIO_dgram_is_sctp(SSL_get_wbio(s))) {\n        WORK_STATE ret;\n        ret = dtls_wait_for_dry(s);\n        if (ret != WORK_FINISHED_CONTINUE)\n            return ret;\n    }\n#endif\n\n    /* clean a few things up */\n    ssl3_cleanup_key_block(s);\n\n    if (!SSL_IS_DTLS(s)) {\n        /*\n         * We don't do this in DTLS because we may still need the init_buf\n         * in case there are any unexpected retransmits\n         */\n        BUF_MEM_free(s->init_buf);\n        s->init_buf = NULL;\n    }\n\n    ssl_free_wbio_buffer(s);\n\n    s->init_num = 0;\n\n    if (!s->server || s->renegotiate == 2) {\n        /* skipped if we just sent a HelloRequest */\n        s->renegotiate = 0;\n        s->new_session = 0;\n\n        if (s->server) {\n            ssl_update_cache(s, SSL_SESS_CACHE_SERVER);\n\n            s->ctx->stats.sess_accept_good++;\n            s->handshake_func = ossl_statem_accept;\n        } else {\n            ssl_update_cache(s, SSL_SESS_CACHE_CLIENT);\n            if (s->hit)\n                s->ctx->stats.sess_hit++;\n\n            s->handshake_func = ossl_statem_connect;\n            s->ctx->stats.sess_connect_good++;\n        }\n\n        if (s->info_callback != NULL)\n            cb = s->info_callback;\n        else if (s->ctx->info_callback != NULL)\n            cb = s->ctx->info_callback;\n\n        if (cb != NULL)\n            cb(s, SSL_CB_HANDSHAKE_DONE, 1);\n\n        if (SSL_IS_DTLS(s)) {\n            /* done with handshaking */\n            s->d1->handshake_read_seq = 0;\n            s->d1->handshake_write_seq = 0;\n            s->d1->next_handshake_write_seq = 0;\n            dtls1_clear_received_buffer(s);\n        }\n    }\n\n    return WORK_FINISHED_STOP;\n}", "target": 2, "idx": 11693}
{"commit_id": "d7eec4e598158ab6a98bf505354e84352f9715ec", "project": "airtower-luna/mod_gnutls", "func": "static apr_status_t gnutls_io_input_read(mgs_handle_t * ctxt,\n        char *buf, apr_size_t * len)\n{\n    apr_size_t wanted = *len;\n    apr_size_t bytes = 0;\n\n    *len = 0;\n\n    /* If we have something leftover from last time, try that first. */\n    if ((bytes = char_buffer_read(&ctxt->input_cbuf, buf, wanted))) {\n        *len = bytes;\n        if (ctxt->input_mode == AP_MODE_SPECULATIVE) {\n            /* We want to rollback this read. */\n            if (ctxt->input_cbuf.length > 0) {\n                ctxt->input_cbuf.value -= bytes;\n                ctxt->input_cbuf.length += bytes;\n            } else {\n                char_buffer_write(&ctxt->input_cbuf, buf,\n                        (int) bytes);\n            }\n            return APR_SUCCESS;\n        }\n        /* This could probably be *len == wanted, but be safe from stray\n         * photons.\n         */\n        if (*len >= wanted) {\n            return APR_SUCCESS;\n        }\n        if (ctxt->input_mode == AP_MODE_GETLINE) {\n            if (memchr(buf, APR_ASCII_LF, *len)) {\n                return APR_SUCCESS;\n            }\n        } else {\n            /* Down to a nonblock pattern as we have some data already\n             */\n            ctxt->input_block = APR_NONBLOCK_READ;\n        }\n    }\n\n    if (ctxt->session == NULL) {\n        ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, ctxt->c,\n                      \"%s: GnuTLS session is NULL!\", __func__);\n        return APR_EGENERAL;\n    }\n\n    while (1)\n    {\n        /* Note: The pull function sets ctxt->input_rc */\n        int rc = gnutls_record_recv(ctxt->session,\n                                    buf + bytes, wanted - bytes);\n\n        if (rc > 0) {\n            *len += rc;\n            if (ctxt->input_mode == AP_MODE_SPECULATIVE) {\n                /* We want to rollback this read. */\n                char_buffer_write(&ctxt->input_cbuf, buf,\n                                  *len);\n            }\n            return ctxt->input_rc;\n        } else if (rc == 0) {\n            /* EOF, return code depends on whether we still have data\n             * to return. */\n            if (*len > 0) {\n                ctxt->input_rc = APR_SUCCESS;\n            } else {\n                ctxt->input_rc = APR_EOF;\n            }\n            break;\n        } else { /* (rc < 0) */\n\n            if (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN)\n            {\n                ap_log_cerror(APLOG_MARK, APLOG_TRACE2, ctxt->input_rc, ctxt->c,\n                              \"%s: looping recv after '%s' (%d)\",\n                              __func__, gnutls_strerror(rc), rc);\n                /* For a blocking read, loop and try again\n                 * immediately. Otherwise just notify the caller. */\n                if (ctxt->input_block != APR_NONBLOCK_READ)\n                    continue;\n                else\n                    ctxt->input_rc =\n                        (rc == GNUTLS_E_AGAIN ? APR_EAGAIN : APR_EINTR);\n            } else if (rc == GNUTLS_E_REHANDSHAKE) {\n                /* A client has asked for a new Hankshake. Currently, we don't do it */\n                ap_log_cerror(APLOG_MARK, APLOG_DEBUG,\n                        ctxt->input_rc,\n                        ctxt->c,\n                        \"GnuTLS: Error reading data. Client Requested a New Handshake.\"\n                        \" (%d) '%s'\", rc,\n                        gnutls_strerror(rc));\n            } else if (rc == GNUTLS_E_WARNING_ALERT_RECEIVED) {\n                rc = gnutls_alert_get(ctxt->session);\n                ap_log_cerror(APLOG_MARK, APLOG_DEBUG,\n                        ctxt->input_rc,\n                        ctxt->c,\n                        \"GnuTLS: Warning Alert From Client: \"\n                        \" (%d) '%s'\", rc,\n                        gnutls_alert_get_name(rc));\n            } else if (rc == GNUTLS_E_FATAL_ALERT_RECEIVED) {\n                rc = gnutls_alert_get(ctxt->session);\n                ap_log_cerror(APLOG_MARK, APLOG_DEBUG,\n                        ctxt->input_rc,\n                        ctxt->c,\n                        \"GnuTLS: Fatal Alert From Client: \"\n                        \"(%d) '%s'\", rc,\n                        gnutls_alert_get_name(rc));\n                ctxt->input_rc = APR_EGENERAL;\n                break;\n            } else if (rc == GNUTLS_E_PULL_ERROR\n                       && APR_STATUS_IS_TIMEUP(ctxt->input_rc)) {\n                ap_log_cerror(\n                    APLOG_MARK, APLOG_TRACE2, ctxt->input_rc, ctxt->c,\n                    \"%s: transport read timed out\", __func__);\n            } else {\n                /* Some Other Error. Report it. Die. */\n                if (gnutls_error_is_fatal(rc)) {\n                    ap_log_cerror(\n                        APLOG_MARK, APLOG_DEBUG,\n                        ctxt->input_rc,\n                        ctxt->c,\n                        \"GnuTLS: Error reading data. (%d) '%s'\",\n                        rc, gnutls_strerror(rc));\n                } else if (*len > 0) {\n                    ctxt->input_rc = APR_SUCCESS;\n                    break;\n                }\n            }\n\n            if (ctxt->input_rc == APR_SUCCESS) {\n                ap_log_cerror(APLOG_MARK, APLOG_INFO, ctxt->input_rc, ctxt->c,\n                              \"%s: GnuTLS error: %s (%d)\",\n                              __func__, gnutls_strerror(rc), rc);\n                ctxt->input_rc = APR_EGENERAL;\n            }\n            break;\n        }\n    }\n    return ctxt->input_rc;\n}", "target": 2, "idx": 11694}
{"commit_id": "22774aa9e62f586319c8f107f5bae950fed900bc", "project": "gpac", "func": "GF_Err adts_dmx_process(GF_Filter *filter)\n{\n\tGF_ADTSDmxCtx *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck, *dst_pck;\n\tu8 *data, *output;\n\tu8 *start;\n\tu32 pck_size, remain, prev_pck_size;\n\tu64 cts = GF_FILTER_NO_TS;\n\n\t//always reparse duration\n\tif (!ctx->duration.num)\n\t\tadts_dmx_check_dur(filter, ctx);\n\n\tif (ctx->opid && !ctx->is_playing)\n\t\treturn GF_OK;\n\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (!pck) {\n\t\tif (gf_filter_pid_is_eos(ctx->ipid)) {\n\t\t\tif (!ctx->adts_buffer_size) {\n\t\t\t\tif (ctx->opid)\n\t\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\t\tctx->src_pck = NULL;\n\t\t\t\treturn GF_EOS;\n\t\t\t}\n\t\t} else {\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\tprev_pck_size = ctx->adts_buffer_size;\n\tif (pck && !ctx->resume_from) {\n\t\tdata = (char *) gf_filter_pck_get_data(pck, &pck_size);\n\t\tif (!pck_size) {\n\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\tif (ctx->byte_offset != GF_FILTER_NO_BO) {\n\t\t\tu64 byte_offset = gf_filter_pck_get_byte_offset(pck);\n\t\t\tif (!ctx->adts_buffer_size) {\n\t\t\t\tctx->byte_offset = byte_offset;\n\t\t\t} else if (ctx->byte_offset + ctx->adts_buffer_size != byte_offset) {\n\t\t\t\tctx->byte_offset = GF_FILTER_NO_BO;\n\t\t\t\tif ((byte_offset != GF_FILTER_NO_BO) && (byte_offset>ctx->adts_buffer_size) ) {\n\t\t\t\t\tctx->byte_offset = byte_offset - ctx->adts_buffer_size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ctx->adts_buffer_size + pck_size > ctx->adts_buffer_alloc) {\n\t\t\tctx->adts_buffer_alloc = ctx->adts_buffer_size + pck_size;\n\t\t\tctx->adts_buffer = gf_realloc(ctx->adts_buffer, ctx->adts_buffer_alloc);\n\t\t}\n\t\tmemcpy(ctx->adts_buffer + ctx->adts_buffer_size, data, pck_size);\n\t\tctx->adts_buffer_size += pck_size;\n\t}\n\n\t//input pid sets some timescale - we flushed pending data , update cts\n\tif (ctx->timescale && pck) {\n\t\tcts = gf_filter_pck_get_cts(pck);\n\t}\n\n\tif (cts == GF_FILTER_NO_TS) {\n\t\t//avoids updating cts\n\t\tprev_pck_size = 0;\n\t}\n\n\tremain = ctx->adts_buffer_size;\n\tstart = ctx->adts_buffer;\n\n\tif (ctx->resume_from) {\n\t\tstart += ctx->resume_from - 1;\n\t\tremain -= ctx->resume_from - 1;\n\t\tctx->resume_from = 0;\n\t}\n\n\twhile (remain) {\n\t\tu8 *sync;\n\t\tu32 sync_pos, size, offset, bytes_to_drop=0, nb_blocks_per_frame;\n\n\t\tif (!ctx->tag_size && (remain>3)) {\n\n\t\t\t/* Did we read an ID3v2 ? */\n\t\t\tif (start[0] == 'I' && start[1] == 'D' && start[2] == '3') {\n\t\t\t\tif (remain<10)\n\t\t\t\t\treturn GF_OK;\n\n\t\t\t\tctx->tag_size = ((start[9] & 0x7f) + ((start[8] & 0x7f) << 7) + ((start[7] & 0x7f) << 14) + ((start[6] & 0x7f) << 21));\n\n\t\t\t\tbytes_to_drop = 10;\n\t\t\t\tif (ctx->id3_buffer_alloc < ctx->tag_size+10) {\n\t\t\t\t\tctx->id3_buffer = gf_realloc(ctx->id3_buffer, ctx->tag_size+10);\n\t\t\t\t\tctx->id3_buffer_alloc = ctx->tag_size+10;\n\t\t\t\t}\n\t\t\t\tmemcpy(ctx->id3_buffer, start, 10);\n\t\t\t\tctx->id3_buffer_size = 10;\n\t\t\t\tgoto drop_byte;\n\t\t\t}\n\t\t}\n\t\tif (ctx->tag_size) {\n\t\t\tif (ctx->tag_size>remain) {\n\t\t\t\tbytes_to_drop = remain;\n\t\t\t\tctx->tag_size-=remain;\n\t\t\t} else {\n\t\t\t\tbytes_to_drop = ctx->tag_size;\n\t\t\t\tctx->tag_size = 0;\n\t\t\t}\n\t\t\tmemcpy(ctx->id3_buffer + ctx->id3_buffer_size, start, bytes_to_drop);\n\t\t\tctx->id3_buffer_size += bytes_to_drop;\n\n\t\t\tif (!ctx->tag_size && ctx->opid) {\n\t\t\t\tid3dmx_flush(filter, ctx->id3_buffer, ctx->id3_buffer_size, ctx->opid, ctx->expart ? &ctx->vpid : NULL);\n\t\t\t\tctx->id3_buffer_size = 0;\n\t\t\t}\n\t\t\tgoto drop_byte;\n\n\t\t}\n\n\t\tsync = memchr(start, 0xFF, remain);\n\t\tsync_pos = (u32) (sync ? sync - start : remain);\n\n\t\t//couldn't find sync byte in this packet\n\t\tif (remain - sync_pos < 7) {\n\t\t\tbreak;\n\t\t}\n\n\t\t//not sync !\n\t\tif ((sync[1] & 0xF0) != 0xF0) {\n\t\t\tGF_LOG(ctx->nb_frames ? GF_LOG_WARNING : GF_LOG_DEBUG, GF_LOG_PARSER, (\"[ADTSDmx] invalid ADTS sync bytes, resyncing\\n\"));\n\t\t\tctx->nb_frames = 0;\n\t\t\tgoto drop_byte;\n\t\t}\n\t\tif (!ctx->bs) {\n\t\t\tctx->bs = gf_bs_new(sync + 1, remain - sync_pos - 1, GF_BITSTREAM_READ);\n\t\t} else {\n\t\t\tgf_bs_reassign_buffer(ctx->bs, sync + 1, remain - sync_pos - 1);\n\t\t}\n\n\t\t//ok parse header\n\t\tgf_bs_read_int(ctx->bs, 4);\n\n\t\tctx->hdr.is_mp2 = (Bool)gf_bs_read_int(ctx->bs, 1);\n\t\t//if (ctx->mpeg4)\n\t\t//we deprecate old MPEG-2 signaling for AAC in ISOBMFF, as it is not well supported anyway and we don't write adif_header as\n\t\t//supposed to be for these types\n\t\tctx->hdr.is_mp2 = 0;\n\n\t\tgf_bs_read_int(ctx->bs, 2);\n\t\tctx->hdr.no_crc = (Bool)gf_bs_read_int(ctx->bs, 1);\n\n\t\tctx->hdr.profile = 1 + gf_bs_read_int(ctx->bs, 2);\n\t\tctx->hdr.sr_idx = gf_bs_read_int(ctx->bs, 4);\n\t\tgf_bs_read_int(ctx->bs, 1);\n\t\tctx->hdr.nb_ch = gf_bs_read_int(ctx->bs, 3);\n\n\t\tgf_bs_read_int(ctx->bs, 4);\n\t\tctx->hdr.frame_size = gf_bs_read_int(ctx->bs, 13);\n\t\tgf_bs_read_int(ctx->bs, 11);\n\t\tnb_blocks_per_frame = gf_bs_read_int(ctx->bs, 2);\n\t\tctx->hdr.hdr_size = 7;\n\n\t\tif (!ctx->hdr.no_crc) {\n\t\t\tu32 skip;\n\t\t\tif (!nb_blocks_per_frame) {\n\t\t\t\tskip = 2;\n\t\t\t} else {\n\t\t\t\tskip = 2 + 2*nb_blocks_per_frame; //and we have 2 bytes per raw_data_block\n\t\t\t}\n\t\t\tctx->hdr.hdr_size += skip;\n\t\t\tgf_bs_skip_bytes(ctx->bs, skip);\n\t\t}\n\n\t\tif (!ctx->hdr.frame_size || !GF_M4ASampleRates[ctx->hdr.sr_idx]) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[ADTSDmx] Invalid ADTS frame header, resyncing\\n\"));\n\t\t\tctx->nb_frames = 0;\n\t\t\tgoto drop_byte;\n\t\t}\n\t\tif ((nb_blocks_per_frame>2) || (nb_blocks_per_frame && ctx->hdr.nb_ch)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[ADTSDmx] Unsupported multi-block ADTS frame header - patch welcome\\n\"));\n\t\t\tctx->nb_frames = 0;\n\t\t\tgoto drop_byte;\n\t\t} else if (!nb_blocks_per_frame) {\n\t\t\tif (ctx->aacchcfg<0)\n\t\t\t\tctx->hdr.nb_ch = -ctx->aacchcfg;\n\t\t\telse if (!ctx->hdr.nb_ch)\n\t\t\t\tctx->hdr.nb_ch = ctx->aacchcfg;\n\n\t\t\tif (!ctx->hdr.nb_ch) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[ADTSDmx] Missing channel configuration in ADTS frame header, defaulting to stereo - use `--aacchcfg` to force config\\n\"));\n\t\t\t\tctx->hdr.nb_ch = ctx->aacchcfg = 2;\n\t\t\t}\n\t\t}\n\n\t\tif (nb_blocks_per_frame==2) {\n\t\t\tu32 pos = (u32) gf_bs_get_position(ctx->bs);\n\t\t\tgf_m4a_parse_program_config_element(ctx->bs, &ctx->acfg);\n\t\t\tif (!ctx->hdr.no_crc)\n\t\t\t\tgf_bs_skip_bytes(ctx->bs, 2);  //per block CRC\n\n\t\t\tctx->hdr.hdr_size += (u32) gf_bs_get_position(ctx->bs) - pos;\n\t\t}\n\t\t//value 1->6 match channel number, value 7 is 7.1\n\t\tif (ctx->hdr.nb_ch==7)\n\t\t\tctx->hdr.nb_ch = 8;\n\n\n\t\t//ready to send packet\n\t\tif (ctx->hdr.frame_size + 1 < remain) {\n\t\t\tu32 next_frame = ctx->hdr.frame_size;\n\t\t\t//make sure we are sync!\n\t\t\tif ((sync[next_frame] !=0xFF) || ((sync[next_frame+1] & 0xF0) !=0xF0) ) {\n\t\t\t\tGF_LOG(ctx->nb_frames ? GF_LOG_WARNING : GF_LOG_DEBUG, GF_LOG_PARSER, (\"[ADTSDmx] invalid next ADTS frame sync, resyncing\\n\"));\n\t\t\t\tctx->nb_frames = 0;\n\t\t\t\tgoto drop_byte;\n\t\t\t}\n\t\t}\n\t\t//otherwise wait for next frame, unless if end of stream\n\t\telse if (pck) {\n\t\t\tif (ctx->timescale && !prev_pck_size &&  (cts != GF_FILTER_NO_TS) ) {\n\t\t\t\tctx->cts = cts;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ctx->hdr.frame_size < ctx->hdr.hdr_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[ADTSDmx] Corrupted ADTS frame header, resyncing\\n\"));\n\t\t\tctx->nb_frames = 0;\n\t\t\tgoto drop_byte;\n\t\t}\n\n\t\tadts_dmx_check_pid(filter, ctx);\n\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->resume_from = 1 + ctx->adts_buffer_size - remain;\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\tctx->nb_frames++;\n\t\tsize = ctx->hdr.frame_size - ctx->hdr.hdr_size;\n\t\toffset = ctx->hdr.hdr_size;\n\t\t//per raw-block CRC\n\t\tif ((nb_blocks_per_frame==2) && !ctx->hdr.no_crc)\n\t\t\tsize -= 2;\n\n\t\tif (ctx->in_seek) {\n\t\t\tu64 nb_samples_at_seek = (u64) (ctx->start_range * GF_M4ASampleRates[ctx->sr_idx]);\n\t\t\tif (ctx->cts + ctx->dts_inc >= nb_samples_at_seek) {\n\t\t\t\t//u32 samples_to_discard = (ctx->cts + ctx->dts_inc) - nb_samples_at_seek;\n\t\t\t\tctx->in_seek = GF_FALSE;\n\t\t\t}\n\t\t}\n\n\t\tbytes_to_drop = ctx->hdr.frame_size;\n\t\tif (ctx->timescale && !prev_pck_size &&  (cts != GF_FILTER_NO_TS) ) {\n\t\t\tctx->cts = cts;\n\t\t\tcts = GF_FILTER_NO_TS;\n\t\t}\n\n\t\tif (!ctx->in_seek) {\n\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, size, &output);\n\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\n\t\t\tmemcpy(output, sync + offset, size);\n\n\t\t\tgf_filter_pck_set_dts(dst_pck, ctx->cts);\n\t\t\tgf_filter_pck_set_cts(dst_pck, ctx->cts);\n\t\t\tgf_filter_pck_set_duration(dst_pck, ctx->dts_inc);\n\t\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);\n\t\t\tgf_filter_pck_set_sap(dst_pck, GF_FILTER_SAP_1);\n\n\t\t\tif (ctx->byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, ctx->byte_offset + ctx->hdr.hdr_size);\n\t\t\t}\n\n\t\t\tgf_filter_pck_send(dst_pck);\n\t\t}\n\t\tadts_dmx_update_cts(ctx);\n\n\n\t\t//truncated last frame\n\t\tif (bytes_to_drop>remain) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[ADTSDmx] truncated ADTS frame!\\n\"));\n\t\t\tbytes_to_drop=remain;\n\t\t}\n\ndrop_byte:\n\t\tif (!bytes_to_drop) {\n\t\t\tbytes_to_drop = 1;\n\t\t}\n\t\tstart += bytes_to_drop;\n\t\tremain -= bytes_to_drop;\n\n\t\tif (prev_pck_size) {\n\t\t\tif (prev_pck_size > bytes_to_drop) prev_pck_size -= bytes_to_drop;\n\t\t\telse {\n\t\t\t\tprev_pck_size=0;\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\t\tctx->src_pck = pck;\n\t\t\t\tif (pck)\n\t\t\t\t\tgf_filter_pck_ref_props(&ctx->src_pck);\n\t\t\t}\n\t\t}\n\t\tif (ctx->byte_offset != GF_FILTER_NO_BO)\n\t\t\tctx->byte_offset += bytes_to_drop;\n\t}\n\n\tif (!pck) {\n\t\tctx->adts_buffer_size = 0;\n\t\treturn adts_dmx_process(filter);\n\t} else {\n\t\tif (remain) {\n\t\t\tmemmove(ctx->adts_buffer, start, remain);\n\t\t}\n\t\tctx->adts_buffer_size = remain;\n\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t}\n\treturn GF_OK;\n}", "target": 1, "idx": 11695}
{"commit_id": "be749d7efa7c9021da746e685bd6dec79f9dd99b", "project": "DaveGamble/cJSON", "func": "static cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)\n{\n    cJSON *current_element = NULL;\n\n    if ((object == NULL) || (name == NULL))\n    {\n        return NULL;\n    }\n\n    current_element = object->child;\n    if (case_sensitive)\n    {\n        while ((current_element != NULL) && (current_element->string != NULL) && (strcmp(name, current_element->string) != 0))\n        {\n            current_element = current_element->next;\n        }\n    }\n    else\n    {\n        while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))\n        {\n            current_element = current_element->next;\n        }\n    }\n\n    if ((current_element == NULL) || (current_element->string == NULL)) {\n        return NULL;\n    }\n\n    return current_element;\n}", "target": 2, "idx": 11696}
{"commit_id": "216525144ee7c910296f5b05d214ca1327c9ce48", "project": "tensorflow", "func": "Status FractionalPoolShapeFn(InferenceContext* c) {\n  ShapeHandle input;\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 4, &input));\n\n  std::vector<float> pooling_ratio;\n  TF_RETURN_IF_ERROR(c->GetAttr(\"pooling_ratio\", &pooling_ratio));\n  if (pooling_ratio.size() != 4) {\n    return errors::InvalidArgument(\n        \"pooling_ratio field must specify 4 dimensions\");\n  }\n  std::vector<DimensionHandle> output_dims;\n  for (int i = 0; i < 4; ++i) {\n    DimensionHandle d = c->Dim(input, i);\n    if (c->ValueKnown(d)) {\n      // This must match the same logic in the kernel function in\n      // core/kernels/fractional_max_pool_op.cc.\n      auto val =\n          static_cast<int64_t>(std::floor(c->Value(d) / pooling_ratio[i]));\n      if (val < 0) {\n        return errors::InvalidArgument(\"Size computed for dim \", i,\n                                       \" is negative: \", val);\n      }\n      output_dims.push_back(c->MakeDim(val));\n    } else {\n      output_dims.push_back(c->UnknownDim());\n    }\n  }\n\n  for (std::size_t i = 0; i < pooling_ratio.size(); ++i) {\n    if (pooling_ratio[i] < 1) {\n      return errors::InvalidArgument(\n          \"pooling_ratio cannot be smaller than 1, got: \", pooling_ratio[i]);\n    }\n  }\n\n  c->set_output(0, c->MakeShape(output_dims));\n  c->set_output(1, c->Vector(output_dims[1]));\n  c->set_output(2, c->Vector(output_dims[2]));\n  return OkStatus();\n}", "target": 2, "idx": 11697}
{"commit_id": "b224e2f5739fe61de9fa69955d016725b2a4b78d", "project": "poppler", "func": "bool SplashOutputDev::tilingPatternFill(GfxState *state, Gfx *gfxA, Catalog *catalog, Object *str,\n\t\t\t\t\tconst double *ptm, int paintType, int /*tilingType*/, Dict *resDict,\n\t\t\t\t\tconst double *mat, const double *bbox,\n\t\t\t\t\tint x0, int y0, int x1, int y1,\n\t\t\t\t\tdouble xStep, double yStep)\n{\n  PDFRectangle box;\n  Gfx *gfx;\n  Splash *formerSplash = splash;\n  SplashBitmap *formerBitmap = bitmap;\n  double width, height;\n  int surface_width, surface_height, result_width, result_height, i;\n  int repeatX, repeatY;\n  SplashCoord matc[6];\n  Matrix m1;\n  const double *ctm;\n  double savedCTM[6];\n  double kx, ky, sx, sy;\n  bool retValue = false;\n\n  width = bbox[2] - bbox[0];\n  height = bbox[3] - bbox[1];\n\n  if (xStep != width || yStep != height)\n    return false;\n\n  // calculate offsets\n  ctm = state->getCTM();\n  for (i = 0; i < 6; ++i) {\n    savedCTM[i] = ctm[i];\n  }\n  state->concatCTM(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5]);\n  state->concatCTM(1, 0, 0, 1, bbox[0], bbox[1]);\n  ctm = state->getCTM();\n  for (i = 0; i < 6; ++i) {\n    if (!std::isfinite(ctm[i])) {\n      state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n      return false;\n    }\n  }\n  matc[4] = x0 * xStep * ctm[0] + y0 * yStep * ctm[2] + ctm[4];\n  matc[5] = x0 * xStep * ctm[1] + y0 * yStep * ctm[3] + ctm[5];\n  if (splashAbs(ctm[1]) > splashAbs(ctm[0])) {\n    kx = -ctm[1];\n    ky = ctm[2] - (ctm[0] * ctm[3]) / ctm[1];\n  } else {\n    kx = ctm[0];\n    ky = ctm[3] - (ctm[1] * ctm[2]) / ctm[0];\n  }\n  result_width = (int) ceil(fabs(kx * width * (x1 - x0)));\n  result_height = (int) ceil(fabs(ky * height * (y1 - y0)));\n  kx = state->getHDPI() / 72.0;\n  ky = state->getVDPI() / 72.0;\n  m1.m[0] = (ptm[0] == 0) ? fabs(ptm[2]) * kx : fabs(ptm[0]) * kx;\n  m1.m[1] = 0;\n  m1.m[2] = 0;\n  m1.m[3] = (ptm[3] == 0) ? fabs(ptm[1]) * ky : fabs(ptm[3]) * ky;\n  m1.m[4] = 0;\n  m1.m[5] = 0;\n  m1.transform(width, height, &kx, &ky);\n  surface_width = (int) ceil (fabs(kx));\n  surface_height = (int) ceil (fabs(ky));\n\n  sx = (double) result_width / (surface_width * (x1 - x0));\n  sy = (double) result_height / (surface_height * (y1 - y0));\n  m1.m[0] *= sx;\n  m1.m[3] *= sy;\n  m1.transform(width, height, &kx, &ky);\n\n  if(fabs(kx) < 1 && fabs(ky) < 1) {\n    kx = std::min<double>(kx, ky);\n    ky = 2 / kx;\n    m1.m[0] *= ky;\n    m1.m[3] *= ky;\n    m1.transform(width, height, &kx, &ky);\n    surface_width = (int) ceil (fabs(kx));\n    surface_height = (int) ceil (fabs(ky));\n    repeatX = x1 - x0;\n    repeatY = y1 - y0;\n  } else {\n    if ((unsigned long) surface_width * surface_height > 0x800000L) {\n      state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n      return false;\n    }\n    while(fabs(kx) > 16384 || fabs(ky) > 16384) {\n      // limit pattern bitmap size\n      m1.m[0] /= 2;\n      m1.m[3] /= 2;\n      m1.transform(width, height, &kx, &ky);\n    }\n    surface_width = (int) ceil (fabs(kx));\n    surface_height = (int) ceil (fabs(ky));\n    // adjust repeat values to completely fill region\n    if (unlikely(surface_width == 0 || surface_height == 0)) {\n        state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n        return false;\n    }\n    repeatX = result_width / surface_width;\n    repeatY = result_height / surface_height;\n    if (surface_width * repeatX < result_width)\n      repeatX++;\n    if (surface_height * repeatY < result_height)\n      repeatY++;\n    if (x1 - x0 > repeatX)\n      repeatX = x1 - x0;\n    if (y1 - y0 > repeatY)\n      repeatY = y1 - y0;\n  }\n  // restore CTM and calculate rotate and scale with rounded matrix\n  state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n  state->concatCTM(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5]);\n  state->concatCTM(width * repeatX, 0, 0, height * repeatY, bbox[0], bbox[1]);\n  ctm = state->getCTM();\n  matc[0] = ctm[0];\n  matc[1] = ctm[1];\n  matc[2] = ctm[2];\n  matc[3] = ctm[3];\n\n  if (surface_width == 0 || surface_height == 0 || repeatX * repeatY <= 4) {\n    state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n    return false;\n  }\n  m1.transform(bbox[0], bbox[1], &kx, &ky);\n  m1.m[4] = -kx;\n  m1.m[5] = -ky;\n\n  bitmap = new SplashBitmap(surface_width, surface_height, 1,\n                            (paintType == 1) ? colorMode : splashModeMono8, true);\n  if (bitmap->getDataPtr() == nullptr) {\n    SplashBitmap *tBitmap = bitmap;\n    bitmap = formerBitmap;\n    delete tBitmap;\n    state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n    return false;\n  }\n  splash = new Splash(bitmap, true);\n  if (paintType == 2) {\n    SplashColor clearColor;\n#ifdef SPLASH_CMYK\n    clearColor[0] = (colorMode == splashModeCMYK8 || colorMode == splashModeDeviceN8) ? 0x00 : 0xFF;\n#else\n    clearColor[0] = 0xFF;\n#endif\n    splash->clear(clearColor, 0);\n  } else {\n    splash->clear(paperColor, 0);\n  }\n  splash->setThinLineMode(formerSplash->getThinLineMode());\n  splash->setMinLineWidth(s_minLineWidth);\n\n  box.x1 = bbox[0]; box.y1 = bbox[1];\n  box.x2 = bbox[2]; box.y2 = bbox[3];\n  gfx = new Gfx(doc, this, resDict, &box, nullptr, nullptr, nullptr, gfxA);\n  // set pattern transformation matrix\n  gfx->getState()->setCTM(m1.m[0], m1.m[1], m1.m[2], m1.m[3], m1.m[4], m1.m[5]);\n  updateCTM(gfx->getState(), m1.m[0], m1.m[1], m1.m[2], m1.m[3], m1.m[4], m1.m[5]);\n  gfx->display(str);\n  delete splash;\n  splash = formerSplash;\n  TilingSplashOutBitmap imgData;\n  imgData.bitmap = bitmap;\n  imgData.paintType = paintType;\n  imgData.pattern = splash->getFillPattern();\n  imgData.colorMode = colorMode;\n  imgData.y = 0;\n  imgData.repeatX = repeatX;\n  imgData.repeatY = repeatY;\n  SplashBitmap *tBitmap = bitmap;\n  bitmap = formerBitmap;\n  result_width = tBitmap->getWidth() * imgData.repeatX;\n  result_height = tBitmap->getHeight() * imgData.repeatY;\n\n  if (splashAbs(matc[1]) > splashAbs(matc[0])) {\n    kx = -matc[1];\n    ky = matc[2] - (matc[0] * matc[3]) / matc[1];\n  } else {\n    kx = matc[0];\n    ky = matc[3] - (matc[1] * matc[2]) / matc[0];\n  }\n  kx = result_width / (fabs(kx) + 1);\n  ky = result_height / (fabs(ky) + 1);\n  state->concatCTM(kx, 0, 0, ky, 0, 0);\n  ctm = state->getCTM();\n  matc[0] = ctm[0];\n  matc[1] = ctm[1];\n  matc[2] = ctm[2];\n  matc[3] = ctm[3];\n  bool minorAxisZero = matc[1] == 0 && matc[2] == 0;\n  if (matc[0] > 0 && minorAxisZero && matc[3] > 0) {\n    // draw the tiles\n    for (int y = 0; y < imgData.repeatY; ++y) {\n      for (int x = 0; x < imgData.repeatX; ++x) {\n        x0 = splashFloor(matc[4]) + x * tBitmap->getWidth();\n        y0 = splashFloor(matc[5]) + y * tBitmap->getHeight();\n        splash->blitImage(tBitmap, true, x0, y0);\n      }\n    }\n    retValue = true;\n  } else {\n    retValue = splash->drawImage(&tilingBitmapSrc, nullptr, &imgData, colorMode, true, result_width, result_height, matc, false, true) == splashOk;\n  }\n  delete tBitmap;\n  delete gfx;\n  return retValue;\n}", "target": 2, "idx": 11698}
{"commit_id": "f043bfc98c193c284e2cd768fefabe18ac2fed9b", "project": "torvalds/linux", "func": "static int usbhid_parse(struct hid_device *hid)\n{\n\tstruct usb_interface *intf = to_usb_interface(hid->dev.parent);\n\tstruct usb_host_interface *interface = intf->cur_altsetting;\n\tstruct usb_device *dev = interface_to_usbdev (intf);\n\tstruct hid_descriptor *hdesc;\n\tu32 quirks = 0;\n\tunsigned int rsize = 0;\n\tchar *rdesc;\n\tint ret, n;\n\tint num_descriptors;\n\tsize_t offset = offsetof(struct hid_descriptor, desc);\n\n\tquirks = usbhid_lookup_quirk(le16_to_cpu(dev->descriptor.idVendor),\n\t\t\tle16_to_cpu(dev->descriptor.idProduct));\n\n\tif (quirks & HID_QUIRK_IGNORE)\n\t\treturn -ENODEV;\n\n\t/* Many keyboards and mice don't like to be polled for reports,\n\t * so we will always set the HID_QUIRK_NOGET flag for them. */\n\tif (interface->desc.bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT) {\n\t\tif (interface->desc.bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD ||\n\t\t\tinterface->desc.bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE)\n\t\t\t\tquirks |= HID_QUIRK_NOGET;\n\t}\n\n\tif (usb_get_extra_descriptor(interface, HID_DT_HID, &hdesc) &&\n\t    (!interface->desc.bNumEndpoints ||\n\t     usb_get_extra_descriptor(&interface->endpoint[0], HID_DT_HID, &hdesc))) {\n\t\tdbg_hid(\"class descriptor not present\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (hdesc->bLength < sizeof(struct hid_descriptor)) {\n\t\tdbg_hid(\"hid descriptor is too short\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\thid->version = le16_to_cpu(hdesc->bcdHID);\n\thid->country = hdesc->bCountryCode;\n\n\tnum_descriptors = min_t(int, hdesc->bNumDescriptors,\n\t       (hdesc->bLength - offset) / sizeof(struct hid_class_descriptor));\n\n\tfor (n = 0; n < num_descriptors; n++)\n\t\tif (hdesc->desc[n].bDescriptorType == HID_DT_REPORT)\n\t\t\trsize = le16_to_cpu(hdesc->desc[n].wDescriptorLength);\n\n\tif (!rsize || rsize > HID_MAX_DESCRIPTOR_SIZE) {\n\t\tdbg_hid(\"weird size of report descriptor (%u)\\n\", rsize);\n\t\treturn -EINVAL;\n\t}\n\n\trdesc = kmalloc(rsize, GFP_KERNEL);\n\tif (!rdesc)\n\t\treturn -ENOMEM;\n\n\thid_set_idle(dev, interface->desc.bInterfaceNumber, 0, 0);\n\n\tret = hid_get_class_descriptor(dev, interface->desc.bInterfaceNumber,\n\t\t\tHID_DT_REPORT, rdesc, rsize);\n\tif (ret < 0) {\n\t\tdbg_hid(\"reading report descriptor failed\\n\");\n\t\tkfree(rdesc);\n\t\tgoto err;\n\t}\n\n\tret = hid_parse_report(hid, rdesc, rsize);\n\tkfree(rdesc);\n\tif (ret) {\n\t\tdbg_hid(\"parsing report descriptor failed\\n\");\n\t\tgoto err;\n\t}\n\n\thid->quirks |= quirks;\n\n\treturn 0;\nerr:\n\treturn ret;\n}", "target": 1, "idx": 11699}
{"commit_id": "00e8f205475332d7842d0f0d1481eeab4e83017c", "project": "radareorg/radare2", "func": "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon) {\n\tconst char *quotestr = \"`\";\n\tconst char *tick = NULL;\n\tchar *ptr, *ptr2, *str;\n\tchar *arroba = NULL;\n\tint i, ret = 0, pipefd;\n\tbool usemyblock = false;\n\tint scr_html = -1;\n\tint scr_color = -1;\n\tbool eos = false;\n\tbool haveQuote = false;\n\n\tif (!cmd) {\n\t\treturn 0;\n\t}\n\tcmd = r_str_trim_head_tail (cmd);\n\n\t/* quoted / raw command */\n\tswitch (*cmd) {\n\tcase '.':\n\t\tif (cmd[1] == '\"') { /* interpret */\n\t\t\treturn r_cmd_call (core->rcmd, cmd);\n\t\t}\n\t\tbreak;\n\tcase '\"':\n\t\tfor (; *cmd; ) {\n\t\t\tint pipefd = -1;\n\t\t\tut64 oseek = UT64_MAX;\n\t\t\tchar *line, *p;\n\t\t\thaveQuote = *cmd == '\"';\n\t\t\tif (haveQuote) {\n\t\t\t//\t*cmd = 0;\n\t\t\t\tcmd++;\n\t\t\t\tp = cmd[0] ? find_eoq (cmd + 1) : NULL;\n\t\t\t\tif (!p || !*p) {\n\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t*p++ = 0;\n\t\t\t\tif (!*p) {\n\t\t\t\t\teos = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tchar *sc = strchr (cmd, ';');\n\t\t\t\tif (sc) {\n\t\t\t\t\t*sc = 0;\n\t\t\t\t}\n\t\t\t\tr_core_cmd0 (core, cmd);\n\t\t\t\tif (!sc) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcmd = sc + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (p[0]) {\n\t\t\t\t// workaround :D\n\t\t\t\tif (p[0] == '@') {\n\t\t\t\t\tp--;\n\t\t\t\t}\n\t\t\t\twhile (p[1] == ';' || IS_WHITESPACE (p[1])) {\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\t*q = 0;\n\t\t\t\t\t}\n\t\t\t\t\thaveQuote = q != NULL;\n\t\t\t\t\toseek = core->offset;\n\t\t\t\t\tr_core_seek (core,\n\t\t\t\t\t\t     r_num_math (core->num, p + 2), 1);\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\t*p = '\"';\n\t\t\t\t\t\tp = q;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tp = strchr (p + 1, ';');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (p && *p && p[1] == '>') {\n\t\t\t\t\tstr = p + 2;\n\t\t\t\t\twhile (*str == '>') {\n\t\t\t\t\t\tstr++;\n\t\t\t\t\t}\n\t\t\t\t\twhile (IS_WHITESPACE (*str)) {\n\t\t\t\t\t\tstr++;\n\t\t\t\t\t}\n\t\t\t\t\tr_cons_flush ();\n\t\t\t\t\tpipefd = r_cons_pipe_open (str, 1, p[2] == '>');\n\t\t\t\t}\n\t\t\t}\n\t\t\tline = strdup (cmd);\n\t\t\tline = r_str_replace (line, \"\\\\\\\"\", \"\\\"\", true);\n\t\t\tif (p && *p && p[1] == '|') {\n\t\t\t\tstr = p + 2;\n\t\t\t\twhile (IS_WHITESPACE (*str)) {\n\t\t\t\t\tstr++;\n\t\t\t\t}\n\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n\t\t\t} else {\n\t\t\t\tr_cmd_call (core->rcmd, line);\n\t\t\t}\n\t\t\tfree (line);\n\t\t\tif (oseek != UT64_MAX) {\n\t\t\t\tr_core_seek (core, oseek, 1);\n\t\t\t\toseek = UT64_MAX;\n\t\t\t}\n\t\t\tif (pipefd != -1) {\n\t\t\t\tr_cons_flush ();\n\t\t\t\tr_cons_pipe_close (pipefd);\n\t\t\t}\n\t\t\tif (!p) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (eos) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (haveQuote) {\n\t\t\t\tif (*p == ';') {\n\t\t\t\t\tcmd = p + 1;\n\t\t\t\t} else {\n\t\t\t\t\tif (*p == '\"') {\n\t\t\t\t\t\tcmd = p + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t*p = '\"';\n\t\t\t\t\t\tcmd = p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcmd = p + 1;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\tcase '(':\n\t\tif (cmd[1] != '*') {\n\t\t\treturn r_cmd_call (core->rcmd, cmd);\n\t\t}\n\t}\n\n// TODO must honor \" and `\n\t/* comments */\n\tif (*cmd != '#') {\n\t\tptr = (char *)r_str_lastbut (cmd, '#', quotestr);\n\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n\t\t\t*ptr = '\\0';\n\t\t}\n\t}\n\n\t/* multiple commands */\n\t// TODO: must honor \" and ` boundaries\n\t//ptr = strrchr (cmd, ';');\n\tif (*cmd != '#') {\n\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n\t\tif (colon && ptr) {\n\t\t\tint ret ;\n\t\t\t*ptr = '\\0';\n\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcmd = ptr + 1;\n\t\t\tret = r_core_cmd_subst (core, cmd);\n\t\t\t*ptr = ';';\n\t\t\treturn ret;\n\t\t\t//r_cons_flush ();\n\t\t}\n\t}\n\n\t// TODO must honor \" and `\n\t/* pipe console to shell process */\n\t//ptr = strchr (cmd, '|');\n\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n\tif (ptr) {\n\t\tchar *ptr2 = strchr (cmd, '`');\n\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n\t\t\tif (!tick || (tick && tick > ptr)) {\n\t\t\t\t*ptr = '\\0';\n\t\t\t\tcmd = r_str_clean (cmd);\n\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n\t\t\t\t\t// TODO: should be disable scr.color in pd| ?\n\t\t\t\t\teprintf (\"Usage: <r2command> | <program|H|>\\n\");\n\t\t\t\t\teprintf (\" pd|?   - show this help\\n\");\n\t\t\t\t\teprintf (\" pd|    - disable scr.html and scr.color\\n\");\n\t\t\t\t\teprintf (\" pd|H   - enable scr.html, respect scr.color\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t} else if (!strcmp (ptr + 1, \"H\")) { // \"|H\"\n\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n\t\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n\t\t\t\t\tint value = core->num->value;\n\t\t\t\t\tif (*cmd) {\n\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_io_system (core->io, ptr + 1);\n\t\t\t\t\t}\n\t\t\t\t\tcore->num->value = value;\n\t\t\t\t\treturn 0;\n\t\t\t\t} else { // \"|\"\n\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n\t\t\t\t\tr_config_set_i (core->config, \"scr.html\", 0);\n\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// TODO must honor \" and `\n\t/* bool conditions */\n\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n\t//ptr = strchr (cmd, '&');\n\twhile (ptr && ptr[1] == '&') {\n\t\t*ptr = '\\0';\n\t\tret = r_cmd_call (core->rcmd, cmd);\n\t\tif (ret == -1) {\n\t\t\teprintf (\"command error(%s)\\n\", cmd);\n\t\t\tif (scr_html != -1) {\n\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n\t\t\t}\n\t\t\tif (scr_color != -1) {\n\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++);\n\t\tptr = strchr (cmd, '&');\n\t}\n\n\t/* Out Of Band Input */\n\tfree (core->oobi);\n\tcore->oobi = NULL;\n\n\tptr = strstr (cmd, \"?*\");\n\tif (ptr) {\n\t\tchar *prech = ptr - 1;\n\t\tif (*prech != '~') {\n\t\t\tptr[1] = 0;\n\t\t\tif (*cmd != '#' && strlen (cmd) < 5) {\n\t\t\t\tr_cons_break_push (NULL, NULL);\n\t\t\t\trecursive_help (core, cmd);\n\t\t\t\tr_cons_break_pop ();\n\t\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n\t\t\t\tif (scr_html != -1) {\n\t\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n\t\t\t\t}\n\t\t\tif (scr_color != -1) {\n\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n#if 0\n\tptr = strchr (cmd, '<');\n\tif (ptr) {\n\t\tptr[0] = '\\0';\n\t\tif (r_cons_singleton()->is_interactive) {\n\t\t\tif (ptr[1] == '<') {\n\t\t\t\t/* this is a bit mess */\n\t\t\t\t//const char *oprompt = strdup (r_line_singleton ()->prompt);\n\t\t\t\t//oprompt = \">\";\n\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n\t\t\t\t\t//nothing to see here\n\t\t\t\t}\n\t\t\t\teprintf (\"==> Reading from stdin until '%s'\\n\", str);\n\t\t\t\tfree (core->oobi);\n\t\t\t\tcore->oobi = malloc (1);\n\t\t\t\tif (core->oobi) {\n\t\t\t\t\tcore->oobi[0] = '\\0';\n\t\t\t\t}\n\t\t\t\tcore->oobi_len = 0;\n\t\t\t\tfor (;;) {\n\t\t\t\t\tchar buf[1024];\n\t\t\t\t\tint ret;\n\t\t\t\t\twrite (1, \"> \", 2);\n\t\t\t\t\tfgets (buf, sizeof (buf) - 1, stdin); // XXX use r_line ??\n\t\t\t\t\tif (feof (stdin)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (*buf) buf[strlen (buf) - 1]='\\0';\n\t\t\t\t\tret = strlen (buf);\n\t\t\t\t\tcore->oobi_len += ret;\n\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n\t\t\t\t\tif (core->oobi) {\n\t\t\t\t\t\tif (!strcmp (buf, str)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//r_line_set_prompt (oprompt);\n\t\t\t} else {\n\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n\t\t\t\t\t//nothing to see here\n\t\t\t\t}\n\t\t\t\tif (!*str) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t\teprintf (\"Slurping file '%s'\\n\", str);\n\t\t\t\tfree (core->oobi);\n\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n\t\t\t\tif (!core->oobi) {\n\t\t\t\t\teprintf (\"cannot open file\\n\");\n\t\t\t\t} else if (ptr == cmd) {\n\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Cannot slurp with << in non-interactive mode\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\nnext:\n#endif\n\t// TODO must honor \" and `\n\t/* pipe console to file */\n\tptr = strchr (cmd, '>');\n\tif (ptr) {\n\t\tint fdn = 1;\n\t\tint pipecolor = r_config_get_i (core->config, \"scr.pipecolor\");\n\t\tint use_editor = false;\n\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n\t\t*ptr = '\\0';\n\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n\t\tif (!*str) {\n\t\t\teprintf (\"No output?\\n\");\n\t\t\tgoto next2;\n\t\t}\n\t\t/* r_cons_flush() handles interactive output (to the terminal)\n\t\t * differently (e.g. asking about too long output). This conflicts\n\t\t * with piping to a file. Disable it while piping. */\n\t\tif (ptr > (cmd + 1) && ISWHITECHAR (ptr[-2])) {\n\t\t\tchar *fdnum = ptr - 1;\n\t\t\tif (*fdnum == 'H') { // \"H>\"\n\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n\t\t\t\tpipecolor = true;\n\t\t\t\t*fdnum = 0;\n\t\t\t} else {\n\t\t\t\tif (IS_DIGIT(*fdnum)) {\n\t\t\t\t\tfdn = *fdnum - '0';\n\t\t\t\t}\n\t\t\t\t*fdnum = 0;\n\t\t\t}\n\t\t}\n\t\tr_cons_set_interactive (false);\n\t\tif (!strcmp (str, \"-\")) {\n\t\t\tuse_editor = true;\n\t\t\tstr = r_file_temp (\"dumpedit\");\n\t\t\tr_config_set (core->config, \"scr.color\", \"false\");\n\t\t}\n\t\tif (fdn > 0) {\n\t\t\tpipefd = r_cons_pipe_open (str, fdn, ptr[1] == '>');\n\t\t\tif (pipefd != -1) {\n\t\t\t\tif (!pipecolor) {\n\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n\t\t\t\t}\n\t\t\t\tret = r_core_cmd_subst (core, cmd);\n\t\t\t\tr_cons_flush ();\n\t\t\t\tr_cons_pipe_close (pipefd);\n\t\t\t}\n\t\t}\n\t\tr_cons_set_last_interactive ();\n\t\tif (!pipecolor) {\n\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n\t\t}\n\t\tif (use_editor) {\n\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n\t\t\tif (editor && *editor) {\n\t\t\t\tr_sys_cmdf (\"%s '%s'\", editor, str);\n\t\t\t\tr_file_rm (str);\n\t\t\t} else {\n\t\t\t\teprintf (\"No cfg.editor configured\\n\");\n\t\t\t}\n\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n\t\t\tfree (str);\n\t\t}\n\t\tif (scr_html != -1) {\n\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n\t\t}\n\t\t\tif (scr_color != -1) {\n\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n\t\t\t}\n\t\treturn ret;\n\t}\nnext2:\n\t/* sub commands */\n\tptr = strchr (cmd, '`');\n\tif (ptr) {\n\t\tint empty = 0;\n\t\tint oneline = 1;\n\t\tif (ptr[1] == '`') {\n\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n\t\t\toneline = 0;\n\t\t\tempty = 1;\n\t\t}\n\t\tptr2 = strchr (ptr + 1, '`');\n\t\tif (empty) {\n\t\t\t/* do nothing */\n\t\t} else if (!ptr2) {\n\t\t\teprintf (\"parse: Missing backtick in expression.\\n\");\n\t\t\tgoto fail;\n\t\t} else {\n\t\t\tint value = core->num->value;\n\t\t\t*ptr = '\\0';\n\t\t\t*ptr2 = '\\0';\n\t\t\tif (ptr[1] == '!') {\n\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n\t\t\t} else {\n\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n\t\t\t}\n\t\t\tif (!str) {\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\t// ignore contents if first char is pipe or comment\n\t\t\tif (*str == '|' || *str == '*') {\n\t\t\t\teprintf (\"r_core_cmd_subst_i: invalid backticked command\\n\");\n\t\t\t\tfree (str);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tif (oneline && str) {\n\t\t\t\tfor (i = 0; str[i]; i++) {\n\t\t\t\t\tif (str[i] == '\\n') {\n\t\t\t\t\t\tstr[i] = ' ';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstr = r_str_append (str, ptr2 + 1);\n\t\t\tcmd = r_str_append (strdup (cmd), str);\n\t\t\tcore->num->value = value;\n\t\t\tret = r_core_cmd_subst (core, cmd);\n\t\t\tfree (cmd);\n\t\t\tif (scr_html != -1) {\n\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n\t\t\t}\n\t\t\tfree (str);\n\t\t\treturn ret;\n\t\t}\n\t}\n\t// TODO must honor \" and `\n\tcore->fixedblock = false;\n\n\tif (r_str_endswith (cmd, \"~?\") && cmd[2] == '\\0') {\n\t\tr_cons_grep_help ();\n\t\treturn true;\n\t}\n\tif (*cmd != '.') {\n\t\tr_cons_grep_parsecmd (cmd, quotestr);\n\t}\n\n\t/* temporary seek commands */\n\tif (*cmd!= '(' && *cmd != '\"') {\n\t\tptr = strchr (cmd, '@');\n\t\tif (ptr == cmd + 1 && *cmd == '?') {\n\t\t\tptr = NULL;\n\t\t}\n\t} else {\n\t\tptr = NULL;\n\t}\n\n\tcore->tmpseek = ptr? true: false;\n\tint rc = 0;\n\tif (ptr) {\n\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n\t\tut64 addr = UT64_MAX;\n\t\tconst char *tmpbits = NULL;\n\t\tconst char *offstr = NULL;\n\t\tut64 tmpbsz = core->blocksize;\n\t\tchar *tmpeval = NULL;\n\t\tut64 tmpoff = core->offset;\n\t\tchar *tmpasm = NULL;\n\t\tint tmpfd = -1;\n\t\tint sz, len;\n\t\tut8 *buf;\n\n\t\t*ptr = '\\0';\n\t\tfor (ptr++; *ptr == ' '; ptr++) {\n\t\t\t//nothing to see here\n\t\t}\n\t\tif (*ptr && ptr[1] == ':') {\n\t\t\t/* do nothing here */\n\t\t} else {\n\t\t\tptr--;\n\t\t}\n\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n\t\t\tstrchr (ptr + 2, '@'): NULL;\nrepeat_arroba:\n\t\tif (arroba) {\n\t\t\t*arroba = 0;\n\t\t}\n\t\tif (ptr[1] == '?') {\n\t\t\thelpCmdAt (core);\n\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n\t\t\tusemyblock = true;\n\t\t\tswitch (ptr[0]) {\n\t\t\tcase 'f': // \"@f:\" // slurp file in block\n\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n\t\t\t\tif (f) {\n\t\t\t\t\tbuf = malloc (sz);\n\t\t\t\t\tif (buf) {\n\t\t\t\t\t\tfree (core->block);\n\t\t\t\t\t\tcore->block = buf;\n\t\t\t\t\t\tcore->blocksize = sz;\n\t\t\t\t\t\tmemcpy (core->block, f, sz);\n\t\t\t\t\t} else {\n\t\t\t\t\t\teprintf (\"cannot alloc %d\", sz);\n\t\t\t\t\t}\n\t\t\t\t\tfree (f);\n\t\t\t\t} else {\n\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'r': // \"@r:\" // regname\n\t\t\t\tif (ptr[1] == ':') {\n\t\t\t\t\tut64 regval;\n\t\t\t\t\tchar *mander = strdup (ptr + 2);\n\t\t\t\t\tchar *sep = findSeparator (mander);\n\t\t\t\t\tif (sep) {\n\t\t\t\t\t\tchar ch = *sep;\n\t\t\t\t\t\t*sep = 0;\n\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n\t\t\t\t\t\t*sep = ch;\n\t\t\t\t\t\tchar *numexpr = r_str_newf (\"0x%\"PFMT64x\"%s\", regval, sep);\n\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n\t\t\t\t\t\tfree (numexpr);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n\t\t\t\t\t}\n\t\t\t\t\tr_core_seek (core, regval, 1);\n\t\t\t\t\tfree (mander);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'b': // \"@b:\" // bits\n\t\t\t\ttmpbits = strdup (r_config_get (core->config, \"asm.bits\"));\n\t\t\t\tr_config_set_i (core->config, \"asm.bits\",\n\t\t\t\t\tr_num_math (core->num, ptr + 2));\n\t\t\t\tbreak;\n\t\t\tcase 'i': // \"@i:\"\n\t\t\t\t{\n\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n\t\t\t\t\tif (addr) {\n\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'e': // \"@e:\"\n\t\t\t\ttmpeval = parse_tmp_evals (core, ptr + 2);\n\t\t\t\tbreak;\n\t\t\tcase 'x': // \"@x:\" // hexpairs\n\t\t\t\tif (ptr[1] == ':') {\n\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n\t\t\t\t\tif (buf) {\n\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n\t\t\t\t\t\tr_core_block_size (core, R_ABS(len));\n\t\t\t\t\t\tmemcpy (core->block, buf, core->blocksize);\n\t\t\t\t\t\tcore->fixedblock = true;\n\t\t\t\t\t\tfree (buf);\n\t\t\t\t\t} else {\n\t\t\t\t\t\teprintf (\"cannot allocate\\n\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\teprintf (\"Invalid @x: syntax\\n\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'k': // \"@k\"\n\t\t\t\t {\n\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n\t\t\t\t\tif (out) {\n\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n\t\t\t\t\t\tfree (out);\n\t\t\t\t\t}\n\t\t\t\t }\n\t\t\t\tbreak;\n\t\t\tcase 'o': // \"@o:3\"\n\t\t\t\tif (ptr[1] == ':') {\n\t\t\t\t\ttmpfd = core->io->raised;\n\t\t\t\t\tr_io_raise (core->io, atoi (ptr + 2));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'a': // \"@a:\"\n\t\t\t\tif (ptr[1] == ':') {\n\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n\t\t\t\t\ttmpasm = strdup (r_config_get (core->config, \"asm.arch\"));\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\t*q++ = 0;\n\t\t\t\t\t\ttmpbits = r_config_get (core->config, \"asm.bits\");\n\t\t\t\t\t\tr_config_set (core->config, \"asm.bits\", q);\n\t\t\t\t\t}\n\t\t\t\t\tr_config_set (core->config, \"asm.arch\", ptr + 2);\n\t\t\t\t\t// TODO: handle asm.bits\n\t\t\t\t} else {\n\t\t\t\t\teprintf (\"Usage: pd 10 @a:arm:32\\n\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 's': // \"@s:\"\n\t\t\t\tlen = strlen (ptr + 2);\n\t\t\t\tr_core_block_size (core, len);\n\t\t\t\tmemcpy (core->block, ptr + 2, len);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto ignore;\n\t\t\t}\n\t\t\t*ptr = '@';\n\t\t\tgoto next_arroba; //ignore; //return ret;\n\t\t}\nignore:\n\t\tptr = r_str_trim_head (ptr + 1);\n\t\tptr--;\n\n\t\tcmd = r_str_clean (cmd);\n\t\tif (ptr2) {\n\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t    !memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t    !memcmp (ptr2 + 1, \"0x\", 2)) {\n\t\t\t\t/* 0xXXXX:0xYYYY */\n\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n\t\t\t\t/* XXXX:YYYY */\n\t\t\t} else {\n\t\t\t\t*ptr2 = '\\0';\n\t\t\t\tif (!ptr2[1]) {\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n\t\t\t}\n\t\t}\n\n\t\toffstr = r_str_trim_head (ptr + 1);\n\n\t\taddr = r_num_math (core->num, offstr);\n\t\tif (isalpha ((unsigned char)ptr[1]) && !addr) {\n\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t} else {\n\t\t\tchar ch = *offstr;\n\t\t\tif (ch == '-' || ch == '+') {\n\t\t\t\taddr = core->offset + addr;\n\t\t\t}\n\t\t}\nnext_arroba:\n\t\tif (arroba) {\n\t\t\tptr = arroba;\n\t\t\tarroba = NULL;\n\t\t\tgoto repeat_arroba;\n\t\t}\n\t\tif (ptr[1] == '@') {\n\t\t\t// TODO: remove temporally seek (should be done by cmd_foreach)\n\t\t\tif (ptr[2] == '@') {\n\t\t\t\tchar *rule = ptr + 3;\n\t\t\t\twhile (*rule && *rule == ' ') rule++;\n\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n\t\t\t} else {\n\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n\t\t\t}\n\t\t\t//ret = -1; /* do not run out-of-foreach cmd */\n\t\t} else {\n\t\t\tbool tmpseek = false;\n\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n\t\t\t\t\"io.buffer.from\", \"lines.from\", \"search.from\", \"zoom.from\", NULL };\n\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n\t\t\t\t\"io.buffer.to\", \"lines.to\", \"search.to\", \"zoom.to\", NULL };\n\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n\n\t\t\t// @..\n\t\t\tif (ptr[1] == '.' && ptr[2] == '.') {\n\t\t\t\tchar *range = ptr + 3;\n\t\t\t\tchar *p = strchr (range, ' ');\n\t\t\t\tif (!p) {\n\t\t\t\t\teprintf (\"Usage: / ABCD @..0x1000 0x3000\\n\");\n\t\t\t\t\tfree (tmpeval);\n\t\t\t\t\tfree (tmpasm);\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t\t*p = '\\x00';\n\t\t\t\tut64 from = r_num_math (core->num, range);\n\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n\t\t\t\t// save current ranges\n\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n\t\t\t\t}\n\t\t\t\tfor (i = 0; tovars[i]; i++) {\n\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n\t\t\t\t}\n\t\t\t\t// set new ranges\n\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n\t\t\t\t}\n\t\t\t\tfor (i = 0; tovars[i]; i++) {\n\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n\t\t\t\t}\n\t\t\t\ttmpseek = true;\n\t\t\t}\n\t\t\tif (usemyblock) {\n\t\t\t\tif (addr != UT64_MAX) {\n\t\t\t\t\tcore->offset = addr;\n\t\t\t\t}\n\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n\t\t\t} else {\n\t\t\t\tif (addr != UT64_MAX) {\n\t\t\t\t\tif (!ptr[1] || r_core_seek (core, addr, 1)) {\n\t\t\t\t\t\tr_core_block_read (core);\n\t\t\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tret = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tmpseek) {\n\t\t\t\t// restore ranges\n\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n\t\t\t\t}\n\t\t\t\tfor (i = 0; tovars[i]; i++) {\n\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ptr2) {\n\t\t\t*ptr2 = '!';\n\t\t\tr_core_block_size (core, tmpbsz);\n\t\t}\n\t\tif (tmpasm) {\n\t\t\tr_config_set (core->config, \"asm.arch\", tmpasm);\n\t\t\ttmpasm = NULL;\n\t\t}\n\t\tif (tmpfd != -1) {\n\t\t\tr_io_raise (core->io, tmpfd);\n\t\t}\n\t\tif (tmpbits) {\n\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n\t\t\ttmpbits = NULL;\n\t\t}\n\t\tif (tmpeval) {\n\t\t\tr_core_cmd0 (core, tmpeval);\n\t\t\tR_FREE (tmpeval);\n\t\t}\n\t\tr_core_seek (core, tmpoff, 1);\n\t\t*ptr = '@';\n\t\trc = ret;\n\t\tgoto beach;\n\t}\n\n\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\nbeach:\n\tif (scr_html != -1) {\n\t\tr_cons_flush ();\n\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n\t}\n\tif (scr_color != -1) {\n\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n\t}\n\tcore->fixedblock = false;\n\treturn rc;\nfail:\n\trc = -1;\n\tgoto beach;\n}", "target": 1, "idx": 11700}
{"commit_id": "3ebba796fa251d042be42b929a2d916ee5c34a49", "project": "torvalds/linux", "func": "static void io_sq_offload_start(struct io_ring_ctx *ctx)\n{\n\tstruct io_sq_data *sqd = ctx->sq_data;\n\n\tctx->flags &= ~IORING_SETUP_R_DISABLED;\n\tif (ctx->flags & IORING_SETUP_SQPOLL)\n\t\tcomplete(&sqd->startup);\n}", "target": 1, "idx": 11701}
{"commit_id": "bb7f0f989ca7de1153bd128a40a71709e339fa03", "project": "torvalds/linux", "func": "static int adjust_ptr_min_max_vals(struct bpf_verifier_env *env,\n\t\t\t\t   struct bpf_insn *insn,\n\t\t\t\t   const struct bpf_reg_state *ptr_reg,\n\t\t\t\t   const struct bpf_reg_state *off_reg)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env), *dst_reg;\n\tbool known = tnum_is_const(off_reg->var_off);\n\ts64 smin_val = off_reg->smin_value, smax_val = off_reg->smax_value,\n\t    smin_ptr = ptr_reg->smin_value, smax_ptr = ptr_reg->smax_value;\n\tu64 umin_val = off_reg->umin_value, umax_val = off_reg->umax_value,\n\t    umin_ptr = ptr_reg->umin_value, umax_ptr = ptr_reg->umax_value;\n\tu8 opcode = BPF_OP(insn->code);\n\tu32 dst = insn->dst_reg;\n\n\tdst_reg = &regs[dst];\n\n\tif (WARN_ON_ONCE(known && (smin_val != smax_val))) {\n\t\tprint_verifier_state(env, env->cur_state);\n\t\tverbose(env,\n\t\t\t\"verifier internal error: known but bad sbounds\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (WARN_ON_ONCE(known && (umin_val != umax_val))) {\n\t\tprint_verifier_state(env, env->cur_state);\n\t\tverbose(env,\n\t\t\t\"verifier internal error: known but bad ubounds\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (BPF_CLASS(insn->code) != BPF_ALU64) {\n\t\t/* 32-bit ALU ops on pointers produce (meaningless) scalars */\n\t\tif (!env->allow_ptr_leaks)\n\t\t\tverbose(env,\n\t\t\t\t\"R%d 32-bit pointer arithmetic prohibited\\n\",\n\t\t\t\tdst);\n\t\treturn -EACCES;\n\t}\n\n\tif (ptr_reg->type == PTR_TO_MAP_VALUE_OR_NULL) {\n\t\tif (!env->allow_ptr_leaks)\n\t\t\tverbose(env, \"R%d pointer arithmetic on PTR_TO_MAP_VALUE_OR_NULL prohibited, null-check it first\\n\",\n\t\t\t\tdst);\n\t\treturn -EACCES;\n\t}\n\tif (ptr_reg->type == CONST_PTR_TO_MAP) {\n\t\tif (!env->allow_ptr_leaks)\n\t\t\tverbose(env, \"R%d pointer arithmetic on CONST_PTR_TO_MAP prohibited\\n\",\n\t\t\t\tdst);\n\t\treturn -EACCES;\n\t}\n\tif (ptr_reg->type == PTR_TO_PACKET_END) {\n\t\tif (!env->allow_ptr_leaks)\n\t\t\tverbose(env, \"R%d pointer arithmetic on PTR_TO_PACKET_END prohibited\\n\",\n\t\t\t\tdst);\n\t\treturn -EACCES;\n\t}\n\n\t/* In case of 'scalar += pointer', dst_reg inherits pointer type and id.\n\t * The id may be overwritten later if we create a new variable offset.\n\t */\n\tdst_reg->type = ptr_reg->type;\n\tdst_reg->id = ptr_reg->id;\n\n\tif (!check_reg_sane_offset(env, off_reg, ptr_reg->type) ||\n\t    !check_reg_sane_offset(env, ptr_reg, ptr_reg->type))\n\t\treturn -EINVAL;\n\n\tswitch (opcode) {\n\tcase BPF_ADD:\n\t\t/* We can take a fixed offset as long as it doesn't overflow\n\t\t * the s32 'off' field\n\t\t */\n\t\tif (known && (ptr_reg->off + smin_val ==\n\t\t\t      (s64)(s32)(ptr_reg->off + smin_val))) {\n\t\t\t/* pointer += K.  Accumulate it into fixed offset */\n\t\t\tdst_reg->smin_value = smin_ptr;\n\t\t\tdst_reg->smax_value = smax_ptr;\n\t\t\tdst_reg->umin_value = umin_ptr;\n\t\t\tdst_reg->umax_value = umax_ptr;\n\t\t\tdst_reg->var_off = ptr_reg->var_off;\n\t\t\tdst_reg->off = ptr_reg->off + smin_val;\n\t\t\tdst_reg->range = ptr_reg->range;\n\t\t\tbreak;\n\t\t}\n\t\t/* A new variable offset is created.  Note that off_reg->off\n\t\t * == 0, since it's a scalar.\n\t\t * dst_reg gets the pointer type and since some positive\n\t\t * integer value was added to the pointer, give it a new 'id'\n\t\t * if it's a PTR_TO_PACKET.\n\t\t * this creates a new 'base' pointer, off_reg (variable) gets\n\t\t * added into the variable offset, and we copy the fixed offset\n\t\t * from ptr_reg.\n\t\t */\n\t\tif (signed_add_overflows(smin_ptr, smin_val) ||\n\t\t    signed_add_overflows(smax_ptr, smax_val)) {\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value = smin_ptr + smin_val;\n\t\t\tdst_reg->smax_value = smax_ptr + smax_val;\n\t\t}\n\t\tif (umin_ptr + umin_val < umin_ptr ||\n\t\t    umax_ptr + umax_val < umax_ptr) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value = umin_ptr + umin_val;\n\t\t\tdst_reg->umax_value = umax_ptr + umax_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_add(ptr_reg->var_off, off_reg->var_off);\n\t\tdst_reg->off = ptr_reg->off;\n\t\tif (reg_is_pkt_pointer(ptr_reg)) {\n\t\t\tdst_reg->id = ++env->id_gen;\n\t\t\t/* something was added to pkt_ptr, set range to zero */\n\t\t\tdst_reg->range = 0;\n\t\t}\n\t\tbreak;\n\tcase BPF_SUB:\n\t\tif (dst_reg == off_reg) {\n\t\t\t/* scalar -= pointer.  Creates an unknown scalar */\n\t\t\tif (!env->allow_ptr_leaks)\n\t\t\t\tverbose(env, \"R%d tried to subtract pointer from scalar\\n\",\n\t\t\t\t\tdst);\n\t\t\treturn -EACCES;\n\t\t}\n\t\t/* We don't allow subtraction from FP, because (according to\n\t\t * test_verifier.c test \"invalid fp arithmetic\", JITs might not\n\t\t * be able to deal with it.\n\t\t */\n\t\tif (ptr_reg->type == PTR_TO_STACK) {\n\t\t\tif (!env->allow_ptr_leaks)\n\t\t\t\tverbose(env, \"R%d subtraction from stack pointer prohibited\\n\",\n\t\t\t\t\tdst);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (known && (ptr_reg->off - smin_val ==\n\t\t\t      (s64)(s32)(ptr_reg->off - smin_val))) {\n\t\t\t/* pointer -= K.  Subtract it from fixed offset */\n\t\t\tdst_reg->smin_value = smin_ptr;\n\t\t\tdst_reg->smax_value = smax_ptr;\n\t\t\tdst_reg->umin_value = umin_ptr;\n\t\t\tdst_reg->umax_value = umax_ptr;\n\t\t\tdst_reg->var_off = ptr_reg->var_off;\n\t\t\tdst_reg->id = ptr_reg->id;\n\t\t\tdst_reg->off = ptr_reg->off - smin_val;\n\t\t\tdst_reg->range = ptr_reg->range;\n\t\t\tbreak;\n\t\t}\n\t\t/* A new variable offset is created.  If the subtrahend is known\n\t\t * nonnegative, then any reg->range we had before is still good.\n\t\t */\n\t\tif (signed_sub_overflows(smin_ptr, smax_val) ||\n\t\t    signed_sub_overflows(smax_ptr, smin_val)) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value = smin_ptr - smax_val;\n\t\t\tdst_reg->smax_value = smax_ptr - smin_val;\n\t\t}\n\t\tif (umin_ptr < umax_val) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\t/* Cannot overflow (as long as bounds are consistent) */\n\t\t\tdst_reg->umin_value = umin_ptr - umax_val;\n\t\t\tdst_reg->umax_value = umax_ptr - umin_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_sub(ptr_reg->var_off, off_reg->var_off);\n\t\tdst_reg->off = ptr_reg->off;\n\t\tif (reg_is_pkt_pointer(ptr_reg)) {\n\t\t\tdst_reg->id = ++env->id_gen;\n\t\t\t/* something was added to pkt_ptr, set range to zero */\n\t\t\tif (smin_val < 0)\n\t\t\t\tdst_reg->range = 0;\n\t\t}\n\t\tbreak;\n\tcase BPF_AND:\n\tcase BPF_OR:\n\tcase BPF_XOR:\n\t\t/* bitwise ops on pointers are troublesome, prohibit for now.\n\t\t * (However, in principle we could allow some cases, e.g.\n\t\t * ptr &= ~3 which would reduce min_value by 3.)\n\t\t */\n\t\tif (!env->allow_ptr_leaks)\n\t\t\tverbose(env, \"R%d bitwise operator %s on pointer prohibited\\n\",\n\t\t\t\tdst, bpf_alu_string[opcode >> 4]);\n\t\treturn -EACCES;\n\tdefault:\n\t\t/* other operators (e.g. MUL,LSH) produce non-pointer results */\n\t\tif (!env->allow_ptr_leaks)\n\t\t\tverbose(env, \"R%d pointer arithmetic with %s operator prohibited\\n\",\n\t\t\t\tdst, bpf_alu_string[opcode >> 4]);\n\t\treturn -EACCES;\n\t}\n\n\tif (!check_reg_sane_offset(env, dst_reg, ptr_reg->type))\n\t\treturn -EINVAL;\n\n\t__update_reg_bounds(dst_reg);\n\t__reg_deduce_bounds(dst_reg);\n\t__reg_bound_offset(dst_reg);\n\treturn 0;\n}", "target": 2, "idx": 11702}
{"commit_id": "8619907c06707d13d2714833a802692138325e34", "project": "squid-cache/squid", "func": "static void\ndecode_pub_auth(cachemgr_request * req)\n{\n    const char *host_name;\n    const char *time_str;\n\n    debug(\"cmgr: decoding pub: '%s'\\n\", safe_str(req->pub_auth));\n    safe_free(req->passwd);\n\n    if (!req->pub_auth || strlen(req->pub_auth) < 4 + strlen(safe_str(req->hostname)))\n        return;\n\n    char *buf = static_cast<char*>(xmalloc(BASE64_DECODE_LENGTH(strlen(req->pub_auth))+1));\n    struct base64_decode_ctx ctx;\n    base64_decode_init(&ctx);\n    size_t decodedLen = 0;\n    if (!base64_decode_update(&ctx, &decodedLen, reinterpret_cast<uint8_t*>(buf), strlen(req->pub_auth), req->pub_auth) ||\n            !base64_decode_final(&ctx)) {\n        debug(\"cmgr: base64 decode failure. Incomplete auth token string.\\n\");\n        xfree(buf);\n        return;\n    }\n    buf[decodedLen] = '\\0';\n\n    debug(\"cmgr: length ok\\n\");\n\n    /* parse ( a lot of memory leaks, but that is cachemgr style :) */\n    if ((host_name = strtok(buf, \"|\")) == NULL) {\n        xfree(buf);\n        return;\n    }\n\n    debug(\"cmgr: decoded host: '%s'\\n\", host_name);\n\n    if ((time_str = strtok(NULL, \"|\")) == NULL) {\n        xfree(buf);\n        return;\n    }\n\n    debug(\"cmgr: decoded time: '%s' (now: %d)\\n\", time_str, (int) now);\n\n    char *user_name;\n    if ((user_name = strtok(NULL, \"|\")) == NULL) {\n        xfree(buf);\n        return;\n    }\n    rfc1738_unescape(user_name);\n\n    debug(\"cmgr: decoded uname: '%s'\\n\", user_name);\n\n    char *passwd;\n    if ((passwd = strtok(NULL, \"|\")) == NULL) {\n        xfree(buf);\n        return;\n    }\n    rfc1738_unescape(passwd);\n\n    debug(\"cmgr: decoded passwd: '%s'\\n\", passwd);\n\n    /* verify freshness and validity */\n    if (atoi(time_str) + passwd_ttl < now) {\n        xfree(buf);\n        return;\n    }\n\n    if (strcasecmp(host_name, req->hostname)) {\n        xfree(buf);\n        return;\n    }\n\n    debug(\"cmgr: verified auth. info.\\n\");\n\n    /* ok, accept */\n    safe_free(req->user_name);\n\n    req->user_name = xstrdup(user_name);\n\n    req->passwd = xstrdup(passwd);\n\n    xfree(buf);\n}", "target": 1, "idx": 11703}
{"commit_id": "3c939e3f69955d087e0bb671868f7267dfb2a502", "project": "php/php-src", "func": "int node_is_equal_ex(xmlNodePtr node, char *name, char *ns)\n{\n\tif (name == NULL || ((node->name) && strcmp((char*)node->name, name) == 0)) {\n\t\tif (ns) {\n\t\t\txmlNsPtr nsPtr = node_find_ns(node);\n\t\t\tif (nsPtr) {\n\t\t\t\treturn (strcmp((char*)nsPtr->href, ns) == 0);\n\t\t\t} else {\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}", "target": 1, "idx": 11704}
{"commit_id": "65cf035b8dc1df5d8020e0b1449514a3c42933e7", "project": "binutils-gdb", "func": "static struct module *\nnew_module (bfd *abfd)\n{\n  struct module *module\n    = (struct module *) bfd_zalloc (abfd, sizeof (struct module));\n  module->file_table_count = 16; /* Arbitrary.  */\n  module->file_table\n    = bfd_zmalloc (module->file_table_count * sizeof (struct fileinfo));\n  return module;\n}", "target": 1, "idx": 11705}
{"commit_id": "7f9ec5593e04827249e7aeb466da06a98a0d7329", "project": "ffmpeg", "func": "static int asf_read_marker(AVFormatContext *s, int64_t size)\n{\n    AVIOContext *pb = s->pb;\n    ASFContext *asf = s->priv_data;\n    int i, count, name_len, ret;\n    char name[1024];\n\n    avio_rl64(pb);            // reserved 16 bytes\n    avio_rl64(pb);            // ...\n    count = avio_rl32(pb);    // markers count\n    avio_rl16(pb);            // reserved 2 bytes\n    name_len = avio_rl16(pb); // name length\n    avio_skip(pb, name_len);\n\n    for (i = 0; i < count; i++) {\n        int64_t pres_time;\n        int name_len;\n\n        if (avio_feof(pb))\n            return AVERROR_INVALIDDATA;\n\n        avio_rl64(pb);             // offset, 8 bytes\n        pres_time = avio_rl64(pb); // presentation time\n        pres_time -= asf->hdr.preroll * 10000;\n        avio_rl16(pb);             // entry length\n        avio_rl32(pb);             // send time\n        avio_rl32(pb);             // flags\n        name_len = avio_rl32(pb);  // name length\n        if ((ret = avio_get_str16le(pb, name_len * 2, name,\n                                    sizeof(name))) < name_len)\n            avio_skip(pb, name_len - ret);\n        avpriv_new_chapter(s, i, (AVRational) { 1, 10000000 }, pres_time,\n                           AV_NOPTS_VALUE, name);\n    }\n\n    return 0;\n}", "target": 1, "idx": 11706}
{"commit_id": "8e6cb0a579df34bbdcfbbc8e0f4d8244d4747409", "project": "SerenityOS/serenity", "func": "[[nodiscard]] static ByteBuffer copy(void const* data, size_t size)\n    {\n        auto buffer = create_uninitialized(size);\n        if (size != 0)\n            __builtin_memcpy(buffer.data(), data, size);\n        return buffer;\n    }", "target": 2, "idx": 11707}
{"commit_id": "e03553605b45c88f0b4b2980adfbbb8f6fca2fd6", "project": "GNOME/libxslt", "func": "int\nxsltParseStylesheetImport(xsltStylesheetPtr style, xmlNodePtr cur) {\n    int ret = -1;\n    xmlDocPtr import = NULL;\n    xmlChar *base = NULL;\n    xmlChar *uriRef = NULL;\n    xmlChar *URI = NULL;\n    xsltStylesheetPtr res;\n    xsltSecurityPrefsPtr sec;\n\n    if ((cur == NULL) || (style == NULL))\n\treturn (ret);\n\n    uriRef = xmlGetNsProp(cur, (const xmlChar *)\"href\", NULL);\n    if (uriRef == NULL) {\n\txsltTransformError(NULL, style, cur,\n\t    \"xsl:import : missing href attribute\\n\");\n\tgoto error;\n    }\n\n    base = xmlNodeGetBase(style->doc, cur);\n    URI = xmlBuildURI(uriRef, base);\n    if (URI == NULL) {\n\txsltTransformError(NULL, style, cur,\n\t    \"xsl:import : invalid URI reference %s\\n\", uriRef);\n\tgoto error;\n    }\n\n    res = style;\n    while (res != NULL) {\n        if (res->doc == NULL)\n\t    break;\n\tif (xmlStrEqual(res->doc->URL, URI)) {\n\t    xsltTransformError(NULL, style, cur,\n\t       \"xsl:import : recursion detected on imported URL %s\\n\", URI);\n\t    goto error;\n\t}\n\tres = res->parent;\n    }\n\n    /*\n     * Security framework check\n     */\n    sec = xsltGetDefaultSecurityPrefs();\n    if (sec != NULL) {\n\tint secres;\n\n\tsecres = xsltCheckRead(sec, NULL, URI);\n\tif (secres <= 0) {\n            if (secres == 0)\n                xsltTransformError(NULL, NULL, NULL,\n                     \"xsl:import: read rights for %s denied\\n\",\n                                 URI);\n\t    goto error;\n\t}\n    }\n\n    import = xsltDocDefaultLoader(URI, style->dict, XSLT_PARSE_OPTIONS,\n                                  (void *) style, XSLT_LOAD_STYLESHEET);\n    if (import == NULL) {\n\txsltTransformError(NULL, style, cur,\n\t    \"xsl:import : unable to load %s\\n\", URI);\n\tgoto error;\n    }\n\n    res = xsltParseStylesheetImportedDoc(import, style);\n    if (res != NULL) {\n\tres->next = style->imports;\n\tstyle->imports = res;\n\tif (style->parent == NULL) {\n\t    xsltFixImportedCompSteps(style, res);\n\t}\n\tret = 0;\n    } else {\n\txmlFreeDoc(import);\n\t}\n\nerror:\n    if (uriRef != NULL)\n\txmlFree(uriRef);\n    if (base != NULL)\n\txmlFree(base);\n    if (URI != NULL)\n\txmlFree(URI);\n\n    return (ret);\n}", "target": 3, "idx": 11708}
{"commit_id": "dd42bf1197144ede075a9d4793123f7689e164bc", "project": "torvalds/linux", "func": "static void tty_set_termios_ldisc(struct tty_struct *tty, int num)\n{\n\tdown_write(&tty->termios_rwsem);\n\ttty->termios.c_line = num;\n\tup_write(&tty->termios_rwsem);\n\n\ttty->disc_data = NULL;\n\ttty->receive_room = 0;\n}", "target": 1, "idx": 11709}
{"commit_id": "c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81", "project": "torvalds/linux", "func": "key_ref_t keyring_search(key_ref_t keyring,\n\t\t\t struct key_type *type,\n\t\t\t const char *description)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= type,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tkey_ref_t key;\n\tint ret;\n\n\tif (type->match_preparse) {\n\t\tret = type->match_preparse(&ctx.match_data);\n\t\tif (ret < 0)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\tkey = keyring_search_aux(keyring, &ctx);\n\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\n\treturn key;\n}", "target": 2, "idx": 11710}
{"commit_id": "e7e513ccf83a31145244dcc214abc8e322e1c672", "project": "syoyo/tinyexr", "func": "static bool hufDecode(const long long *hcode,  // i : encoding table\n                      const HufDec *hdecod,    // i : decoding table\n                      const char *in,          // i : compressed input buffer\n                      int ni,                  // i : input size (in bits)\n                      int rlc,                 // i : run-length code\n                      int no,  // i : expected output size (in bytes)\n                      unsigned short *out)  //  o: uncompressed output buffer\n{\n  long long c = 0;\n  int lc = 0;\n  unsigned short *outb = out;          // begin\n  unsigned short *oe = out + no;       // end\n  const char *ie = in + (ni + 7) / 8;  // input byte size\n\n  //\n  // Loop on input bytes\n  //\n\n  while (in < ie) {\n    getChar(c, lc, in);\n\n    //\n    // Access decoding table\n    //\n\n    while (lc >= HUF_DECBITS) {\n      const HufDec pl = hdecod[(c >> (lc - HUF_DECBITS)) & HUF_DECMASK];\n\n      if (pl.len) {\n        //\n        // Get short code\n        //\n\n        lc -= pl.len;\n        // std::cout << \"lit = \" << pl.lit << std::endl;\n        // std::cout << \"rlc = \" << rlc << std::endl;\n        // std::cout << \"c = \" << c << std::endl;\n        // std::cout << \"lc = \" << lc << std::endl;\n        // std::cout << \"in = \" << in << std::endl;\n        // std::cout << \"out = \" << out << std::endl;\n        // std::cout << \"oe = \" << oe << std::endl;\n        if (!getCode(pl.lit, rlc, c, lc, in, ie, out, outb, oe)) {\n          return false;\n        }\n      } else {\n        if (!pl.p) {\n          return false;\n        }\n        // invalidCode(); // wrong code\n\n        //\n        // Search long code\n        //\n\n        int j;\n\n        for (j = 0; j < pl.lit; j++) {\n          int l = hufLength(hcode[pl.p[j]]);\n\n          while (lc < l && in < ie)  // get more bits\n            getChar(c, lc, in);\n\n          if (lc >= l) {\n            if (hufCode(hcode[pl.p[j]]) ==\n                ((c >> (lc - l)) & (((long long)(1) << l) - 1))) {\n              //\n              // Found : get long code\n              //\n\n              lc -= l;\n              if (!getCode(pl.p[j], rlc, c, lc, in, ie, out, outb, oe)) {\n                return false;\n              }\n              break;\n            }\n          }\n        }\n\n        if (j == pl.lit) {\n          return false;\n          // invalidCode(); // Not found\n        }\n      }\n    }\n  }\n\n  //\n  // Get remaining (short) codes\n  //\n\n  int i = (8 - ni) & 7;\n  c >>= i;\n  lc -= i;\n\n  while (lc > 0) {\n    const HufDec pl = hdecod[(c << (HUF_DECBITS - lc)) & HUF_DECMASK];\n\n    if (pl.len) {\n      lc -= pl.len;\n      if (!getCode(pl.lit, rlc, c, lc, in, ie, out, outb, oe)) {\n        return false;\n      }\n    } else {\n      return false;\n      // invalidCode(); // wrong (long) code\n    }\n  }\n\n  if (out - outb != no) {\n    return false;\n  }\n  // notEnoughData ();\n\n  return true;\n}", "target": 3, "idx": 11711}
{"commit_id": "5e16e2d1c9fe245e4c17005d779fde91ec0b9c05", "project": "radareorg/radare2", "func": "static pyc_object *get_object(RBuffer *buffer) {\n\tbool error = false;\n\tpyc_object *ret = NULL;\n\tut8 code = get_ut8 (buffer, &error);\n\tut8 flag = code & FLAG_REF;\n\tRListIter *ref_idx = NULL;\n\tut8 type = code & ~FLAG_REF;\n\n\tif (error) {\n\t\treturn NULL;\n\t}\n\n\tif (flag) {\n\t\tret = get_none_object ();\n\t\tif (!ret) {\n\t\t\treturn NULL;\n\t\t}\n\t\tref_idx = r_list_append (refs, ret);\n\t\tif (!ref_idx) {\n\t\t\tfree_object (ret);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tswitch (type) {\n\tcase TYPE_NULL:\n\t\tfree_object (ret);\n\t\treturn NULL;\n\tcase TYPE_TRUE:\n\t\tfree_object (ret);\n\t\treturn get_true_object ();\n\tcase TYPE_FALSE:\n\t\tfree_object (ret);\n\t\treturn get_false_object ();\n\tcase TYPE_NONE:\n\t\tfree_object (ret);\n\t\treturn get_none_object ();\n\tcase TYPE_REF:\n\t\tfree_object (ret);\n\t\treturn get_ref_object (buffer);\n\tcase TYPE_SMALL_TUPLE:\n\t\tret = get_small_tuple_object (buffer);\n\t\tbreak;\n\tcase TYPE_TUPLE:\n\t\tret = get_tuple_object (buffer);\n\t\tbreak;\n\tcase TYPE_STRING:\n\t\tret = get_string_object (buffer);\n\t\tbreak;\n\tcase TYPE_CODE_v0:\n\t\tret = get_code_object (buffer);\n\t\tif (ret) {\n\t\t\tret->type = TYPE_CODE_v0;\n\t\t}\n\t\tbreak;\n\tcase TYPE_CODE_v1:\n\t\tret = get_code_object (buffer);\n\t\tif (ret) {\n\t\t\tret->type = TYPE_CODE_v1;\n\t\t}\n\t\tbreak;\n\tcase TYPE_INT:\n\t\tret = get_int_object (buffer);\n\t\tbreak;\n\tcase TYPE_ASCII_INTERNED:\n\t\tret = get_ascii_interned_object (buffer);\n\t\tbreak;\n\tcase TYPE_SHORT_ASCII:\n\t\tret = get_short_ascii_object (buffer);\n\t\tbreak;\n\tcase TYPE_ASCII:\n\t\tret = get_ascii_object (buffer);\n\t\tbreak;\n\tcase TYPE_SHORT_ASCII_INTERNED:\n\t\tret = get_short_ascii_interned_object (buffer);\n\t\tbreak;\n\tcase TYPE_INT64:\n\t\tret = get_int64_object (buffer);\n\t\tbreak;\n\tcase TYPE_INTERNED:\n\t\tret = get_interned_object (buffer);\n\t\tbreak;\n\tcase TYPE_STRINGREF:\n\t\tret = get_stringref_object (buffer);\n\t\tbreak;\n\tcase TYPE_FLOAT:\n\t\tret = get_float_object (buffer);\n\t\tbreak;\n\tcase TYPE_BINARY_FLOAT:\n\t\tret = get_binary_float_object (buffer);\n\t\tbreak;\n\tcase TYPE_COMPLEX:\n\t\tret = get_complex_object (buffer); // behaviour depends on Python version\n\t\tbreak;\n\tcase TYPE_BINARY_COMPLEX:\n\t\tret = get_binary_complex_object (buffer);\n\t\tbreak;\n\tcase TYPE_LIST:\n\t\tret = get_list_object (buffer);\n\t\tbreak;\n\tcase TYPE_LONG:\n\t\tret = get_long_object (buffer);\n\t\tbreak;\n\tcase TYPE_UNICODE:\n\t\tret = get_unicode_object (buffer);\n\t\tbreak;\n\tcase TYPE_DICT:\n\t\tret = get_dict_object (buffer);\n\t\tbreak;\n\tcase TYPE_FROZENSET:\n\tcase TYPE_SET:\n\t\tret = get_set_object (buffer);\n\t\tbreak;\n\tcase TYPE_STOPITER:\n\tcase TYPE_ELLIPSIS:\n\t\tret = R_NEW0 (pyc_object);\n\t\tbreak;\n\tcase TYPE_UNKNOWN:\n\t\teprintf (\"Get not implemented for type 0x%x\\n\", type);\n\t\tfree_object (ret);\n\t\treturn NULL;\n\tcase 0:\n\t\t// nop\n\t\tbreak;\n\tdefault:\n\t\teprintf (\"Undefined type in get_object (0x%x)\\n\", type);\n\t\tfree_object (ret);\n\t\treturn NULL;\n\t}\n\n\tif (flag && ref_idx) {\n\t\tif (ref_idx->data != ret) {\n\t\t\tfree_object (ref_idx->data);\n\t\t}\n\t\tref_idx->data = copy_object (ret);\n\t}\n\treturn ret;\n}", "target": 1, "idx": 11712}
{"commit_id": "319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12", "project": "xen-project/xen", "func": "static void amd_iommu_setup_domain_device(\n    struct domain *domain, struct amd_iommu *iommu,\n    uint8_t devfn, struct pci_dev *pdev)\n{\n    struct amd_iommu_dte *table, *dte;\n    unsigned long flags;\n    int req_id, valid = 1;\n    u8 bus = pdev->bus;\n    const struct domain_iommu *hd = dom_iommu(domain);\n\n    /* dom_io is used as a sentinel for quarantined devices */\n    if ( domain == dom_io )\n        return;\n\n    BUG_ON( !hd->arch.root_table || !hd->arch.paging_mode ||\n            !iommu->dev_table.buffer );\n\n    if ( iommu_hwdom_passthrough && is_hardware_domain(domain) )\n        valid = 0;\n\n    /* get device-table entry */\n    req_id = get_dma_requestor_id(iommu->seg, PCI_BDF2(bus, devfn));\n    table = iommu->dev_table.buffer;\n    dte = &table[req_id];\n\n    spin_lock_irqsave(&iommu->lock, flags);\n\n    if ( !dte->v || !dte->tv )\n    {\n        /* bind DTE to domain page-tables */\n        amd_iommu_set_root_page_table(\n            dte, page_to_maddr(hd->arch.root_table), domain->domain_id,\n            hd->arch.paging_mode, valid);\n\n        if ( pci_ats_device(iommu->seg, bus, pdev->devfn) &&\n             iommu_has_cap(iommu, PCI_CAP_IOTLB_SHIFT) )\n            dte->i = ats_enabled;\n\n        amd_iommu_flush_device(iommu, req_id);\n\n        AMD_IOMMU_DEBUG(\"Setup I/O page table: device id = %#x, type = %#x, \"\n                        \"root table = %#\"PRIx64\", \"\n                        \"domain = %d, paging mode = %d\\n\",\n                        req_id, pdev->type,\n                        page_to_maddr(hd->arch.root_table),\n                        domain->domain_id, hd->arch.paging_mode);\n    }\n\n    spin_unlock_irqrestore(&iommu->lock, flags);\n\n    ASSERT(pcidevs_locked());\n\n    if ( pci_ats_device(iommu->seg, bus, pdev->devfn) &&\n         !pci_ats_enabled(iommu->seg, bus, pdev->devfn) )\n    {\n        if ( devfn == pdev->devfn )\n            enable_ats_device(pdev, &iommu->ats_devices);\n\n        amd_iommu_flush_iotlb(devfn, pdev, INV_IOMMU_ALL_PAGES_ADDRESS, 0);\n    }\n}", "target": 1, "idx": 11713}
{"commit_id": "1713eec29add37b654ec6bf262b843d139c1ffc6", "project": "ffmpeg", "func": "static int shorten_decode_frame(AVCodecContext *avctx, void *data,\n                                int *got_frame_ptr, AVPacket *avpkt)\n{\n    AVFrame *frame     = data;\n    const uint8_t *buf = avpkt->data;\n    int buf_size       = avpkt->size;\n    ShortenContext *s  = avctx->priv_data;\n    int i, input_buf_size = 0;\n    int ret;\n\n    /* allocate internal bitstream buffer */\n    if (s->max_framesize == 0) {\n        void *tmp_ptr;\n        s->max_framesize = 1024; // should hopefully be enough for the first header\n        tmp_ptr = av_fast_realloc(s->bitstream, &s->allocated_bitstream_size,\n                                  s->max_framesize + FF_INPUT_BUFFER_PADDING_SIZE);\n        if (!tmp_ptr) {\n            av_log(avctx, AV_LOG_ERROR, \"error allocating bitstream buffer\\n\");\n            return AVERROR(ENOMEM);\n        }\n        s->bitstream = tmp_ptr;\n    }\n\n    /* append current packet data to bitstream buffer */\n    if (1 && s->max_framesize) { //FIXME truncated\n        buf_size       = FFMIN(buf_size, s->max_framesize - s->bitstream_size);\n        input_buf_size = buf_size;\n\n        if (s->bitstream_index + s->bitstream_size + buf_size >\n            s->allocated_bitstream_size) {\n            memmove(s->bitstream, &s->bitstream[s->bitstream_index],\n                    s->bitstream_size);\n            s->bitstream_index = 0;\n        }\n        if (buf)\n            memcpy(&s->bitstream[s->bitstream_index + s->bitstream_size], buf,\n                   buf_size);\n        buf               = &s->bitstream[s->bitstream_index];\n        buf_size         += s->bitstream_size;\n        s->bitstream_size = buf_size;\n\n        /* do not decode until buffer has at least max_framesize bytes or\n         * the end of the file has been reached */\n        if (buf_size < s->max_framesize && avpkt->data) {\n            *got_frame_ptr = 0;\n            return input_buf_size;\n        }\n    }\n    /* init and position bitstream reader */\n    init_get_bits(&s->gb, buf, buf_size * 8);\n    skip_bits(&s->gb, s->bitindex);\n\n    /* process header or next subblock */\n    if (!s->got_header) {\n        if ((ret = read_header(s)) < 0)\n            return ret;\n        *got_frame_ptr = 0;\n        goto finish_frame;\n    }\n\n    /* if quit command was read previously, don't decode anything */\n    if (s->got_quit_command) {\n        *got_frame_ptr = 0;\n        return avpkt->size;\n    }\n\n    s->cur_chan = 0;\n    while (s->cur_chan < s->channels) {\n        unsigned cmd;\n        int len;\n\n        if (get_bits_left(&s->gb) < 3 + FNSIZE) {\n            *got_frame_ptr = 0;\n            break;\n        }\n\n        cmd = get_ur_golomb_shorten(&s->gb, FNSIZE);\n\n        if (cmd > FN_VERBATIM) {\n            av_log(avctx, AV_LOG_ERROR, \"unknown shorten function %d\\n\", cmd);\n            *got_frame_ptr = 0;\n            break;\n        }\n\n        if (!is_audio_command[cmd]) {\n            /* process non-audio command */\n            switch (cmd) {\n            case FN_VERBATIM:\n                len = get_ur_golomb_shorten(&s->gb, VERBATIM_CKSIZE_SIZE);\n                while (len--)\n                    get_ur_golomb_shorten(&s->gb, VERBATIM_BYTE_SIZE);\n                break;\n            case FN_BITSHIFT:\n                s->bitshift = get_ur_golomb_shorten(&s->gb, BITSHIFTSIZE);\n                break;\n            case FN_BLOCKSIZE: {\n                unsigned blocksize = get_uint(s, av_log2(s->blocksize));\n                if (blocksize > s->blocksize) {\n                    av_log(avctx, AV_LOG_ERROR,\n                           \"Increasing block size is not supported\\n\");\n                    return AVERROR_PATCHWELCOME;\n                }\n                if (!blocksize || blocksize > MAX_BLOCKSIZE) {\n                    av_log(avctx, AV_LOG_ERROR, \"invalid or unsupported \"\n                                                \"block size: %d\\n\", blocksize);\n                    return AVERROR(EINVAL);\n                }\n                s->blocksize = blocksize;\n                break;\n            }\n            case FN_QUIT:\n                s->got_quit_command = 1;\n                break;\n            }\n            if (cmd == FN_BLOCKSIZE || cmd == FN_QUIT) {\n                *got_frame_ptr = 0;\n                break;\n            }\n        } else {\n            /* process audio command */\n            int residual_size = 0;\n            int channel = s->cur_chan;\n            int32_t coffset;\n\n            /* get Rice code for residual decoding */\n            if (cmd != FN_ZERO) {\n                residual_size = get_ur_golomb_shorten(&s->gb, ENERGYSIZE);\n                /* This is a hack as version 0 differed in the definition\n                 * of get_sr_golomb_shorten(). */\n                if (s->version == 0)\n                    residual_size--;\n            }\n\n            /* calculate sample offset using means from previous blocks */\n            if (s->nmean == 0)\n                coffset = s->offset[channel][0];\n            else {\n                int32_t sum = (s->version < 2) ? 0 : s->nmean / 2;\n                for (i = 0; i < s->nmean; i++)\n                    sum += s->offset[channel][i];\n                coffset = sum / s->nmean;\n                if (s->version >= 2)\n                    coffset >>= FFMIN(1, s->bitshift);\n            }\n\n            /* decode samples for this channel */\n            if (cmd == FN_ZERO) {\n                for (i = 0; i < s->blocksize; i++)\n                    s->decoded[channel][i] = 0;\n            } else {\n                if ((ret = decode_subframe_lpc(s, cmd, channel,\n                                               residual_size, coffset)) < 0)\n                    return ret;\n            }\n\n            /* update means with info from the current block */\n            if (s->nmean > 0) {\n                int32_t sum = (s->version < 2) ? 0 : s->blocksize / 2;\n                for (i = 0; i < s->blocksize; i++)\n                    sum += s->decoded[channel][i];\n\n                for (i = 1; i < s->nmean; i++)\n                    s->offset[channel][i - 1] = s->offset[channel][i];\n\n                if (s->version < 2)\n                    s->offset[channel][s->nmean - 1] = sum / s->blocksize;\n                else\n                    s->offset[channel][s->nmean - 1] = (sum / s->blocksize) << s->bitshift;\n            }\n\n            /* copy wrap samples for use with next block */\n            for (i = -s->nwrap; i < 0; i++)\n                s->decoded[channel][i] = s->decoded[channel][i + s->blocksize];\n\n            /* shift samples to add in unused zero bits which were removed\n             * during encoding */\n            fix_bitshift(s, s->decoded[channel]);\n\n            /* if this is the last channel in the block, output the samples */\n            s->cur_chan++;\n            if (s->cur_chan == s->channels) {\n                /* get output buffer */\n                frame->nb_samples = s->blocksize;\n                if ((ret = ff_get_buffer(avctx, frame, 0)) < 0) {\n                    av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n                    return ret;\n                }\n                /* interleave output */\n                output_buffer((int16_t **)frame->extended_data, s->channels,\n                              s->blocksize, s->decoded);\n\n                *got_frame_ptr = 1;\n            }\n        }\n    }\n    if (s->cur_chan < s->channels)\n        *got_frame_ptr = 0;\n\nfinish_frame:\n    s->bitindex = get_bits_count(&s->gb) - 8 * (get_bits_count(&s->gb) / 8);\n    i           = get_bits_count(&s->gb) / 8;\n    if (i > buf_size) {\n        av_log(s->avctx, AV_LOG_ERROR, \"overread: %d\\n\", i - buf_size);\n        s->bitstream_size  = 0;\n        s->bitstream_index = 0;\n        return AVERROR_INVALIDDATA;\n    }\n    if (s->bitstream_size) {\n        s->bitstream_index += i;\n        s->bitstream_size  -= i;\n        return input_buf_size;\n    } else\n        return i;\n}", "target": 1, "idx": 11714}
{"commit_id": "1f686d023b95219db933394a7704ad9aa5f01cbb", "project": "ffmpeg", "func": "static int decode_studio_vop_header(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\n    MpegEncContext *s = &ctx->m;\n\n    if (get_bits_left(gb) <= 32)\n        return 0;\n\n    s->partitioned_frame = 0;\n    s->interlaced_dct = 0;\n    s->decode_mb = mpeg4_decode_studio_mb;\n\n    decode_smpte_tc(ctx, gb);\n\n    skip_bits(gb, 10); /* temporal_reference */\n    skip_bits(gb, 2); /* vop_structure */\n    s->pict_type = get_bits(gb, 2) + AV_PICTURE_TYPE_I; /* vop_coding_type */\n    if (get_bits1(gb)) { /* vop_coded */\n        skip_bits1(gb); /* top_field_first */\n        skip_bits1(gb); /* repeat_first_field */\n        s->progressive_frame = get_bits1(gb) ^ 1; /* progressive_frame */\n    }\n\n    if (s->pict_type == AV_PICTURE_TYPE_I) {\n        if (get_bits1(gb))\n            reset_studio_dc_predictors(s);\n    }\n\n    if (ctx->shape != BIN_ONLY_SHAPE) {\n        s->alternate_scan = get_bits1(gb);\n        s->frame_pred_frame_dct = get_bits1(gb);\n        s->dct_precision = get_bits(gb, 2);\n        s->intra_dc_precision = get_bits(gb, 2);\n        s->q_scale_type = get_bits1(gb);\n    }\n\n    if (s->alternate_scan) {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable,   ff_alternate_vertical_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable,   ff_alternate_vertical_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_vertical_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);\n    } else {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable,   ff_zigzag_direct);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable,   ff_zigzag_direct);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_horizontal_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);\n    }\n\n    mpeg4_load_default_matrices(s);\n\n    next_start_code_studio(gb);\n    extension_and_user_data(s, gb, 4);\n\n    return 0;\n}", "target": 2, "idx": 11715}
{"commit_id": "d99636fad60629785efd1ef72da772a8ef68f54c", "project": "jasper-software/jasper", "func": "cmdopts_t *cmdopts_parse(int argc, char **argv)\n{\n\tenum {\n\t\tCMDOPT_HELP = 0,\n\t\tCMDOPT_VERBOSE,\n\t\tCMDOPT_QUIET,\n\t\tCMDOPT_INFILE,\n\t\tCMDOPT_INFMT,\n\t\tCMDOPT_INOPT,\n\t\tCMDOPT_OUTFILE,\n\t\tCMDOPT_OUTFMT,\n\t\tCMDOPT_OUTOPT,\n\t\tCMDOPT_VERSION,\n\t\tCMDOPT_DEBUG,\n\t\tCMDOPT_CMPTNO,\n\t\tCMDOPT_SRGB,\n\t\tCMDOPT_MAXMEM,\n\t\tCMDOPT_LIST_ENABLED_CODECS,\n\t\tCMDOPT_LIST_ALL_CODECS,\n\t\tCMDOPT_ENABLE_FORMAT,\n\t\tCMDOPT_ENABLE_ALL_FORMATS,\n\t};\n\n\tstatic const jas_opt_t cmdoptions[] = {\n\t\t{CMDOPT_HELP, \"help\", 0},\n\t\t{CMDOPT_VERBOSE, \"verbose\", 0},\n\t\t{CMDOPT_QUIET, \"quiet\", 0},\n\t\t{CMDOPT_QUIET, \"q\", 0},\n\t\t{CMDOPT_INFILE, \"input\", JAS_OPT_HASARG},\n\t\t{CMDOPT_INFILE, \"f\", JAS_OPT_HASARG},\n\t\t{CMDOPT_INFMT, \"input-format\", JAS_OPT_HASARG},\n\t\t{CMDOPT_INFMT, \"t\", JAS_OPT_HASARG},\n\t\t{CMDOPT_INOPT, \"input-option\", JAS_OPT_HASARG},\n\t\t{CMDOPT_INOPT, \"o\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTFILE, \"output\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTFILE, \"F\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTFMT, \"output-format\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTFMT, \"T\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTOPT, \"output-option\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTOPT, \"O\", JAS_OPT_HASARG},\n\t\t{CMDOPT_VERSION, \"version\", 0},\n\t\t{CMDOPT_DEBUG, \"debug-level\", JAS_OPT_HASARG},\n\t\t{CMDOPT_CMPTNO, \"cmptno\", JAS_OPT_HASARG},\n\t\t{CMDOPT_SRGB, \"force-srgb\", 0},\n\t\t{CMDOPT_SRGB, \"S\", 0},\n\t\t{CMDOPT_MAXMEM, \"memory-limit\", JAS_OPT_HASARG},\n\t\t{CMDOPT_LIST_ENABLED_CODECS, \"list-enabled-formats\", 0},\n\t\t{CMDOPT_LIST_ALL_CODECS, \"list-all-formats\", 0},\n\t\t{CMDOPT_ENABLE_FORMAT, \"enable-format\", JAS_OPT_HASARG},\n\t\t{CMDOPT_ENABLE_ALL_FORMATS, \"enable-all-formats\", 0},\n\t\t{-1, 0, 0}\n\t};\n\n\tcmdopts_t *cmdopts;\n\tint c;\n\n\tif (!(cmdopts = malloc(sizeof(cmdopts_t)))) {\n\t\tfprintf(stderr, \"error: insufficient memory\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tcmdopts->infile = 0;\n\tcmdopts->infmt = -1;\n\tcmdopts->infmt_str = 0;\n\tcmdopts->inopts = 0;\n\tcmdopts->inoptsbuf[0] = '\\0';\n\tcmdopts->outfile = 0;\n\tcmdopts->outfmt = -1;\n\tcmdopts->outfmt_str = 0;\n\tcmdopts->outopts = 0;\n\tcmdopts->outoptsbuf[0] = '\\0';\n\tcmdopts->verbose = 0;\n\tcmdopts->version = 0;\n\tcmdopts->cmptno = -1;\n\tcmdopts->debug = 0;\n\tcmdopts->srgb = 0;\n\tcmdopts->list_codecs = 0;\n\tcmdopts->list_codecs_all = 0;\n\tcmdopts->help = 0;\n\tcmdopts->max_mem = get_default_max_mem_usage();\n\tcmdopts->enable_format = 0;\n\tcmdopts->enable_all_formats = 0;\n\n\twhile ((c = jas_getopt(argc, argv, cmdoptions)) != EOF) {\n\t\tswitch (c) {\n\t\tcase CMDOPT_HELP:\n\t\t\tcmdopts->help = 1;\n\t\t\tbreak;\n\t\tcase CMDOPT_VERBOSE:\n\t\t\tcmdopts->verbose = 1;\n\t\t\tbreak;\n\t\tcase CMDOPT_QUIET:\n\t\t\tcmdopts->verbose = -1;\n\t\t\tbreak;\n\t\tcase CMDOPT_VERSION:\n\t\t\tcmdopts->version = 1;\n\t\t\tbreak;\n\t\tcase CMDOPT_LIST_ENABLED_CODECS:\n\t\t\tcmdopts->list_codecs = 1;\n\t\t\tcmdopts->list_codecs_all = 0;\n\t\t\tbreak;\n\t\tcase CMDOPT_LIST_ALL_CODECS:\n\t\t\tcmdopts->list_codecs = 1;\n\t\t\tcmdopts->list_codecs_all = 1;\n\t\t\tbreak;\n\t\tcase CMDOPT_DEBUG:\n\t\t\tcmdopts->debug = atoi(jas_optarg);\n\t\t\tbreak;\n\t\tcase CMDOPT_INFILE:\n\t\t\tcmdopts->infile = jas_optarg;\n\t\t\tbreak;\n\t\tcase CMDOPT_INFMT:\n\t\t\tcmdopts->infmt_str= jas_optarg;\n\t\t\tbreak;\n\t\tcase CMDOPT_INOPT:\n\t\t\taddopt(cmdopts->inoptsbuf, OPTSMAX, jas_optarg);\n\t\t\tcmdopts->inopts = cmdopts->inoptsbuf;\n\t\t\tbreak;\n\t\tcase CMDOPT_OUTFILE:\n\t\t\tcmdopts->outfile = jas_optarg;\n\t\t\tbreak;\n\t\tcase CMDOPT_OUTFMT:\n\t\t\tcmdopts->outfmt_str = jas_optarg;\n\t\t\tbreak;\n\t\tcase CMDOPT_OUTOPT:\n\t\t\taddopt(cmdopts->outoptsbuf, OPTSMAX, jas_optarg);\n\t\t\tcmdopts->outopts = cmdopts->outoptsbuf;\n\t\t\tbreak;\n\t\tcase CMDOPT_CMPTNO:\n\t\t\tcmdopts->cmptno = atoi(jas_optarg);\n\t\t\tbreak;\n\t\tcase CMDOPT_SRGB:\n\t\t\tcmdopts->srgb = 1;\n\t\t\tbreak;\n\t\tcase CMDOPT_MAXMEM:\n\t\t\tcmdopts->max_mem = strtoull(jas_optarg, 0, 10);\n\t\t\tbreak;\n\t\tcase CMDOPT_ENABLE_FORMAT:\n\t\t\tcmdopts->enable_format = jas_optarg;\n\t\t\tbreak;\n\t\tcase CMDOPT_ENABLE_ALL_FORMATS:\n\t\t\tcmdopts->enable_all_formats = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcmdopts_destroy(cmdopts);\n\t\t\tbadusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\twhile (jas_optind < argc) {\n\t\tfprintf(stderr,\n\t\t  \"warning: ignoring bogus command line argument %s\\n\",\n\t\t  argv[jas_optind]);\n\t\t++jas_optind;\n\t}\n\n\tif (cmdopts->version || cmdopts->list_codecs || cmdopts->help) {\n\t\tgoto done;\n\t}\n\n\tif (!cmdopts->outfmt_str && !cmdopts->outfile) {\n\t\tfprintf(stderr, \"error: cannot determine output format\\n\");\n\t\tcmdopts_destroy(cmdopts);\n\t\tbadusage();\n\t}\n\ndone:\n\treturn cmdopts;\n}", "target": 2, "idx": 11716}
{"commit_id": "e2fa213cf571041dbd04ab0329303ffdc980678a", "project": "vim", "func": "static void\nnv_brackets(cmdarg_T *cap)\n{\n    pos_T\tprev_pos;\n    pos_T\t*pos = NULL;\t    // init for GCC\n    pos_T\told_pos;\t    // cursor position before command\n    int\t\tflag;\n    long\tn;\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    old_pos = curwin->w_cursor;\n    curwin->w_cursor.coladd = 0;    // TODO: don't do this for an error.\n\n#ifdef FEAT_SEARCHPATH\n    // \"[f\" or \"]f\" : Edit file under the cursor (same as \"gf\")\n    if (cap->nchar == 'f')\n\tnv_gotofile(cap);\n    else\n#endif\n\n#ifdef FEAT_FIND_ID\n    // Find the occurrence(s) of the identifier or define under cursor\n    // in current and included files or jump to the first occurrence.\n    //\n    //\t\t\tsearch\t     list\t    jump\n    //\t\t      fwd   bwd    fwd\t bwd\t fwd\tbwd\n    // identifier     \"]i\"  \"[i\"   \"]I\"  \"[I\"\t\"]^I\"  \"[^I\"\n    // define\t      \"]d\"  \"[d\"   \"]D\"  \"[D\"\t\"]^D\"  \"[^D\"\n    if (vim_strchr((char_u *)\"iI\\011dD\\004\", cap->nchar) != NULL)\n    {\n\tchar_u\t*ptr;\n\tint\tlen;\n\n\tif ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)\n\t    clearop(cap->oap);\n\telse\n\t{\n\t    // Make a copy, if the line was changed it will be freed.\n\t    ptr = vim_strnsave(ptr, len);\n\t    if (ptr == NULL)\n\t\treturn;\n\n\t    find_pattern_in_path(ptr, 0, len, TRUE,\n\t\tcap->count0 == 0 ? !isupper(cap->nchar) : FALSE,\n\t\t((cap->nchar & 0xf) == ('d' & 0xf)) ?  FIND_DEFINE : FIND_ANY,\n\t\tcap->count1,\n\t\tisupper(cap->nchar) ? ACTION_SHOW_ALL :\n\t\t\t    islower(cap->nchar) ? ACTION_SHOW : ACTION_GOTO,\n\t\tcap->cmdchar == ']' ? curwin->w_cursor.lnum + 1 : (linenr_T)1,\n\t\t(linenr_T)MAXLNUM);\n\t    vim_free(ptr);\n\t    curwin->w_set_curswant = TRUE;\n\t}\n    }\n    else\n#endif\n\n    // \"[{\", \"[(\", \"]}\" or \"])\": go to Nth unclosed '{', '(', '}' or ')'\n    // \"[#\", \"]#\": go to start/end of Nth innermost #if..#endif construct.\n    // \"[/\", \"[*\", \"]/\", \"]*\": go to Nth comment start/end.\n    // \"[m\" or \"]m\" search for prev/next start of (Java) method.\n    // \"[M\" or \"]M\" search for prev/next end of (Java) method.\n    if (  (cap->cmdchar == '['\n\t\t&& vim_strchr((char_u *)\"{(*/#mM\", cap->nchar) != NULL)\n\t    || (cap->cmdchar == ']'\n\t\t&& vim_strchr((char_u *)\"})*/#mM\", cap->nchar) != NULL))\n\tnv_bracket_block(cap, &old_pos);\n\n    // \"[[\", \"[]\", \"]]\" and \"][\": move to start or end of function\n    else if (cap->nchar == '[' || cap->nchar == ']')\n    {\n\tif (cap->nchar == cap->cmdchar)\t\t    // \"]]\" or \"[[\"\n\t    flag = '{';\n\telse\n\t    flag = '}';\t\t    // \"][\" or \"[]\"\n\n\tcurwin->w_set_curswant = TRUE;\n\t// Imitate strange Vi behaviour: When using \"]]\" with an operator\n\t// we also stop at '}'.\n\tif (!findpar(&cap->oap->inclusive, cap->arg, cap->count1, flag,\n\t      (cap->oap->op_type != OP_NOP\n\t\t\t\t      && cap->arg == FORWARD && flag == '{')))\n\t    clearopbeep(cap->oap);\n\telse\n\t{\n\t    if (cap->oap->op_type == OP_NOP)\n\t\tbeginline(BL_WHITE | BL_FIX);\n#ifdef FEAT_FOLDING\n\t    if ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t\tfoldOpenCursor();\n#endif\n\t}\n    }\n\n    // \"[p\", \"[P\", \"]P\" and \"]p\": put with indent adjustment\n    else if (cap->nchar == 'p' || cap->nchar == 'P')\n    {\n\tnv_put_opt(cap, TRUE);\n    }\n\n    // \"['\", \"[`\", \"]'\" and \"]`\": jump to next mark\n    else if (cap->nchar == '\\'' || cap->nchar == '`')\n    {\n\tpos = &curwin->w_cursor;\n\tfor (n = cap->count1; n > 0; --n)\n\t{\n\t    prev_pos = *pos;\n\t    pos = getnextmark(pos, cap->cmdchar == '[' ? BACKWARD : FORWARD,\n\t\t\t\t\t\t\t  cap->nchar == '\\'');\n\t    if (pos == NULL)\n\t\tbreak;\n\t}\n\tif (pos == NULL)\n\t    pos = &prev_pos;\n\tnv_cursormark(cap, cap->nchar == '\\'', pos);\n    }\n\n    // [ or ] followed by a middle mouse click: put selected text with\n    // indent adjustment.  Any other button just does as usual.\n    else if (cap->nchar >= K_RIGHTRELEASE && cap->nchar <= K_LEFTMOUSE)\n    {\n\t(void)do_mouse(cap->oap, cap->nchar,\n\t\t       (cap->cmdchar == ']') ? FORWARD : BACKWARD,\n\t\t       cap->count1, PUT_FIXINDENT);\n    }\n\n#ifdef FEAT_FOLDING\n    // \"[z\" and \"]z\": move to start or end of open fold.\n    else if (cap->nchar == 'z')\n    {\n\tif (foldMoveTo(FALSE, cap->cmdchar == ']' ? FORWARD : BACKWARD,\n\t\t\t\t\t\t\t cap->count1) == FAIL)\n\t    clearopbeep(cap->oap);\n    }\n#endif\n\n#ifdef FEAT_DIFF\n    // \"[c\" and \"]c\": move to next or previous diff-change.\n    else if (cap->nchar == 'c')\n    {\n\tif (diff_move_to(cap->cmdchar == ']' ? FORWARD : BACKWARD,\n\t\t\t\t\t\t\t cap->count1) == FAIL)\n\t    clearopbeep(cap->oap);\n    }\n#endif\n\n#ifdef FEAT_SPELL\n    // \"[s\", \"[S\", \"]s\" and \"]S\": move to next spell error.\n    else if (cap->nchar == 's' || cap->nchar == 'S')\n    {\n\tsetpcmark();\n\tfor (n = 0; n < cap->count1; ++n)\n\t    if (spell_move_to(curwin, cap->cmdchar == ']' ? FORWARD : BACKWARD,\n\t\t\t  cap->nchar == 's' ? TRUE : FALSE, FALSE, NULL) == 0)\n\t    {\n\t\tclearopbeep(cap->oap);\n\t\tbreak;\n\t    }\n\t    else\n\t\tcurwin->w_set_curswant = TRUE;\n# ifdef FEAT_FOLDING\n\tif (cap->oap->op_type == OP_NOP && (fdo_flags & FDO_SEARCH) && KeyTyped)\n\t    foldOpenCursor();\n# endif\n    }\n#endif\n\n    // Not a valid cap->nchar.\n    else\n\tclearopbeep(cap->oap);\n}", "target": 2, "idx": 11717}
{"commit_id": "7f14c7227f342d9932f9b918893c8814f86d2a0d", "project": "torvalds/linux", "func": "static void xudc_getstatus(struct xusb_udc *udc)\n{\n\tstruct xusb_ep *ep0\t= &udc->ep[0];\n\tstruct xusb_req *req\t= udc->req;\n\tstruct xusb_ep *target_ep;\n\tu16 status = 0;\n\tu32 epcfgreg;\n\tint epnum;\n\tu32 halt;\n\tint ret;\n\n\tswitch (udc->setup.bRequestType & USB_RECIP_MASK) {\n\tcase USB_RECIP_DEVICE:\n\t\t/* Get device status */\n\t\tstatus = 1 << USB_DEVICE_SELF_POWERED;\n\t\tif (udc->remote_wkp)\n\t\t\tstatus |= (1 << USB_DEVICE_REMOTE_WAKEUP);\n\t\tbreak;\n\tcase USB_RECIP_INTERFACE:\n\t\tbreak;\n\tcase USB_RECIP_ENDPOINT:\n\t\tepnum = udc->setup.wIndex & USB_ENDPOINT_NUMBER_MASK;\n\t\tif (epnum >= XUSB_MAX_ENDPOINTS)\n\t\t\tgoto stall;\n\t\ttarget_ep = &udc->ep[epnum];\n\t\tepcfgreg = udc->read_fn(udc->addr + target_ep->offset);\n\t\thalt = epcfgreg & XUSB_EP_CFG_STALL_MASK;\n\t\tif (udc->setup.wIndex & USB_DIR_IN) {\n\t\t\tif (!target_ep->is_in)\n\t\t\t\tgoto stall;\n\t\t} else {\n\t\t\tif (target_ep->is_in)\n\t\t\t\tgoto stall;\n\t\t}\n\t\tif (halt)\n\t\t\tstatus = 1 << USB_ENDPOINT_HALT;\n\t\tbreak;\n\tdefault:\n\t\tgoto stall;\n\t}\n\n\treq->usb_req.length = 2;\n\t*(u16 *)req->usb_req.buf = cpu_to_le16(status);\n\tret = __xudc_ep0_queue(ep0, req);\n\tif (ret == 0)\n\t\treturn;\nstall:\n\tdev_err(udc->dev, \"Can't respond to getstatus request\\n\");\n\txudc_ep0_stall(udc);\n}", "target": 2, "idx": 11718}
{"commit_id": "7a7d737a3929f335b9717ddbd31db91151b69ad2", "project": "TicklishHoneyBee/nodau", "func": "int db_update(char* name, char* value)\n{\n\tchar* sql;\n\tint r = 0;\n\t/* create the sql statement using the name/text for this note\n\t * if it's meant to be encrypted, then crypt_key will be set */\n\tif (crypt_key) {\n\t\tvalue = note_encrypt(value,crypt_key);\n\t\tif (asprintf(&sql, \"UPDATE nodau set text=?, encrypted='true' WHERE name=?\") < 0)\n\t\t\treturn 1;\n\t}else{\n\t\tif (asprintf(&sql, \"UPDATE nodau set text=?, encrypted='false' WHERE name=?\") < 0)\n\t\t\treturn 1;\n\t}\n\n\tsqlite3_stmt *compiled_statement;\n\tr = sqlite3_prepare_v2(db_data.db, sql, -1, &compiled_statement, NULL);\n\tif (r != SQLITE_OK)\n\t\treturn 1;\n\n\tr= sqlite3_bind_text(compiled_statement, 1, value, -1, NULL);\n\tr= sqlite3_bind_text(compiled_statement, 2, name, -1, NULL);\n\tif (r != SQLITE_OK)\n\t\treturn 1;\n\n\t/* do it */\n\tr = sqlite3_step(compiled_statement);\n\tif (r != SQLITE_DONE) {\n\t\tfprintf(stderr, \"Error #%d: %s\\n\", r, db_err());\n\t\treturn 1;\n\t}\n\tr = sqlite3_finalize(compiled_statement);\n\tif (r != SQLITE_OK)\n\t\tfprintf(stderr, \"Error #%d: %s\\n\", r, db_err());\n\n\tfree(sql);\n\tif (crypt_key)\n\t\tfree(value);\n\treturn r;\n}", "target": 3, "idx": 11719}
{"commit_id": "897dffbae322b46b83f99a607d527058a72c51ed", "project": "GNOME/libxml2", "func": "void *\nxmlReallocLoc(void *ptr,size_t size, const char * file, int line)\n{\n    MEMHDR *p, *tmp;\n    unsigned long number;\n#ifdef DEBUG_MEMORY\n    size_t oldsize;\n#endif\n\n    if (ptr == NULL)\n        return(xmlMallocLoc(size, file, line));\n\n    if (!xmlMemInitialized) xmlInitMemory();\n    TEST_POINT\n\n    p = CLIENT_2_HDR(ptr);\n    number = p->mh_number;\n    if (xmlMemStopAtBlock == number) xmlMallocBreakpoint();\n    if (p->mh_tag != MEMTAG) {\n       Mem_Tag_Err(p);\n\t goto error;\n    }\n    p->mh_tag = ~MEMTAG;\n    xmlMutexLock(xmlMemMutex);\n    debugMemSize -= p->mh_size;\n    debugMemBlocks--;\n#ifdef DEBUG_MEMORY\n    oldsize = p->mh_size;\n#endif\n#ifdef MEM_LIST\n    debugmem_list_delete(p);\n#endif\n    xmlMutexUnlock(xmlMemMutex);\n\n    if (size > (MAX_SIZE_T - RESERVE_SIZE)) {\n\txmlGenericError(xmlGenericErrorContext,\n\t\t\"xmlMallocLoc : Unsigned overflow\\n\");\n\txmlMemoryDump();\n\treturn(NULL);\n    }\n\n    tmp = (MEMHDR *) realloc(p,RESERVE_SIZE+size);\n    if (!tmp) {\n\t free(p);\n\t goto error;\n    }\n    p = tmp;\n    if (xmlMemTraceBlockAt == ptr) {\n\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"%p : Realloced(%lu -> %lu) Ok\\n\",\n\t\t\txmlMemTraceBlockAt, (long unsigned)p->mh_size,\n\t\t\t(long unsigned)size);\n\txmlMallocBreakpoint();\n    }\n    p->mh_tag = MEMTAG;\n    p->mh_number = number;\n    p->mh_type = REALLOC_TYPE;\n    p->mh_size = size;\n    p->mh_file = file;\n    p->mh_line = line;\n    xmlMutexLock(xmlMemMutex);\n    debugMemSize += size;\n    debugMemBlocks++;\n    if (debugMemSize > debugMaxMemSize) debugMaxMemSize = debugMemSize;\n#ifdef MEM_LIST\n    debugmem_list_add(p);\n#endif\n    xmlMutexUnlock(xmlMemMutex);\n\n    TEST_POINT\n\n#ifdef DEBUG_MEMORY\n    xmlGenericError(xmlGenericErrorContext,\n\t    \"Realloced(%d to %d) Ok\\n\", oldsize, size);\n#endif\n    return(HDR_2_CLIENT(p));\n\nerror:\n    return(NULL);\n}", "target": 2, "idx": 11720}
{"commit_id": "97574866cbab026acb1bbd735201f790091b9400", "project": "libtiff", "func": "void\nTIFFCleanup(TIFF* tif)\n{\n\t/*\n         * Flush buffered data and directory (if dirty).\n         */\n\tif (tif->tif_mode != O_RDONLY)\n\t\tTIFFFlush(tif);\n\t(*tif->tif_cleanup)(tif);\n\tTIFFFreeDirectory(tif);\n\n\tif (tif->tif_dirlist)\n\t\t_TIFFfree(tif->tif_dirlist);\n\n\t/*\n         * Clean up client info links.\n         */\n\twhile( tif->tif_clientinfo )\n\t{\n\t\tTIFFClientInfoLink *psLink = tif->tif_clientinfo;\n\n\t\ttif->tif_clientinfo = psLink->next;\n\t\t_TIFFfree( psLink->name );\n\t\t_TIFFfree( psLink );\n\t}\n\n\tif (tif->tif_rawdata && (tif->tif_flags&TIFF_MYBUFFER))\n\t\t_TIFFfree(tif->tif_rawdata);\n\tif (isMapped(tif))\n\t\tTIFFUnmapFileContents(tif, tif->tif_base, (toff_t)tif->tif_size);\n\n\t/*\n         * Clean up custom fields.\n         */\n\tif (tif->tif_fields && tif->tif_nfields > 0) {\n\t\tuint32_t i;\n\n\t\tfor (i = 0; i < tif->tif_nfields; i++) {\n\t\t\tTIFFField *fld = tif->tif_fields[i];\n\t\t\tif (fld->field_name != NULL) {\n\t\t\t\tif (fld->field_bit == FIELD_CUSTOM &&\n\t\t\t\t\t/* catuion: tif_fields[i] must not be the beginning of a fields-array.\n\t\t\t\t\t *          Otherwise the following tags are also freed with the first free().\n\t\t\t\t\t */\n\t\t\t\t\tTIFFFieldIsAnonymous(fld)) {\n\t\t\t\t\t_TIFFfree(fld->field_name);\n\t\t\t\t\t_TIFFfree(fld);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t_TIFFfree(tif->tif_fields);\n\t}\n\n        if (tif->tif_nfieldscompat > 0) {\n                uint32_t i;\n\n                for (i = 0; i < tif->tif_nfieldscompat; i++) {\n                        if (tif->tif_fieldscompat[i].allocated_size)\n                                _TIFFfree(tif->tif_fieldscompat[i].fields);\n                }\n                _TIFFfree(tif->tif_fieldscompat);\n        }\n\n\t_TIFFfree(tif);\n}", "target": 1, "idx": 11721}
{"commit_id": "ccf7734cad06cb9383d55190d6cd6aa6ccc91ab2", "project": "pdfium", "func": "void CPDFSDK_Document::RemovePageView(UnderlyingPageType* pUnderlyingPage) {\n  auto it = m_pageMap.find(pUnderlyingPage);\n  if (it == m_pageMap.end())\n    return;\n\n  CPDFSDK_PageView* pPageView = it->second;\n  if (pPageView->IsLocked())\n    return;\n\n  // This must happen before we remove |pPageView| from the map because\n  // |KillFocusAnnotIfNeeded| can call into the |GetPage| method which will\n  // look for this page view in the map, if it doesn't find it a new one will\n  // be created. We then have two page views pointing to the same page and\n  // bad things happen.\n  pPageView->KillFocusAnnotIfNeeded();\n\n  // Remove the page from the map to make sure we don't accidentally attempt\n  // to use the |pPageView| while we're cleaning it up.\n  m_pageMap.erase(it);\n\n  delete pPageView;\n}", "target": 2, "idx": 11722}
{"commit_id": "b7eb1d0174c", "project": "ArtifexSoftware/ghostpdl", "func": "static int\npl_glyph_name(gs_font * pfont, gs_glyph glyph, gs_const_string * pstr)\n{\n    uint table_length;\n    ulong table_offset;\n    pl_font_t * plfont = (pl_font_t *)pfont->client_data;\n\n    if (glyph >= GS_MIN_GLYPH_INDEX)\n        glyph -= GS_MIN_GLYPH_INDEX;\n\n    /* guess if the font type is not truetype */\n    if (pfont->FontType != ft_TrueType) {\n        glyph -= 29;\n        if (glyph < 258) {\n            pstr->data = (const byte *)pl_mac_names[glyph];\n            pstr->size = strlen((const char *)pstr->data);\n            return 0;\n        } else {\n            if_debug1m('=', pfont->memory,\n                       \"[=]glyph index %lx out of range\\n\", (ulong) glyph);\n            return -1;\n        }\n    }\n\n    table_offset =\n        tt_find_table((gs_font_type42 *) pfont, \"post\", &table_length);\n    /* no post table */\n    if (table_offset == 0)\n        return -1;\n    /* this shoudn't happen but... */\n    if (table_length == 0)\n        return -1;\n\n    {\n        ulong format;\n        int numGlyphs;\n        uint glyph_name_index;\n        const byte *postp;      /* post table pointer */\n\n        ((gs_font_type42 *) pfont)->data.string_proc((gs_font_type42 *) pfont,\n                                                     table_offset,\n                                                     table_length, &postp);\n        format = u32(postp);\n        if (format != 0x20000) {\n            /* format 1.0 (mac encoding) is a simple table see the TT\n               spec.  We don't implement this because we don't see it\n               in practice */\n            dmprintf1(pfont->memory, \"unknown post table format %lX\\n\",\n                      format);\n            return -1;\n        }\n        /* skip over the post header */\n        numGlyphs = (int)u16(postp + 32);\n        if ((int)glyph > numGlyphs - 1) {\n            if_debug1m('=', pfont->memory,\n                       \"[=]glyph index %lx out of range\\n\", glyph);\n            return -1;\n        }\n        /* glyph name index starts at post + 34 each entry is 2 bytes */\n        glyph_name_index = u16(postp + 34 + (glyph * 2));\n        /* this shouldn't happen */\n        if (glyph_name_index > 0x7fff)\n            return -1;\n        /* mac easy */\n        if (glyph_name_index < 258) {\n\n            pstr->data = (const byte *)pl_mac_names[glyph_name_index];\n            pstr->size = strlen((const char *)pstr->data);\n            return 0;\n            /* not mac */\n        } else {\n            byte *mydata;\n            /* and here's the tricky part */\n            const byte *pascal_stringp = postp + 34 + (numGlyphs * 2);\n            /* 0 - 257 lives in the mac table above */\n            glyph_name_index -= 258;\n            /* The string we want is the index'th pascal string,\n               so we \"hop\" to each length byte \"index\" times. */\n            while (glyph_name_index > 0) {\n                pascal_stringp += ((int)(*pascal_stringp) + 1);\n                glyph_name_index--;\n            }\n            /* length byte */\n            pstr->size = (int)(*pascal_stringp);\n            /* + 1 is for the length byte */\n            pstr->data = pascal_stringp + 1;\n            /* sanity check */\n            if (pstr->data + pstr->size > postp + table_length ||\n                pstr->data - 1 < postp) {\n                dmprintf(pfont->memory, \"data out of range\\n\");\n                return -1;\n            }\n            /* sigh - we have to allocate a copy of the data - by the\n               time a high level device makes use of it the font data\n               may be freed.  Track the allocated memory in our\n               font 'wrapper' so we can free it when we free tha font wrapper.\n             */\n            mydata =\n                gs_alloc_bytes(pfont->memory, pstr->size + 1,\n                               \"glyph to name\");\n            if (mydata == 0)\n                return -1;\n            memcpy(mydata, pascal_stringp + 1, pstr->size);\n            pstr->data = mydata;\n            if (plfont->names == NULL) {\n                plfont->names = (char **)gs_alloc_bytes(pfont->memory, 256 * sizeof (char *), \"names storage\");\n                if (plfont->names == NULL) {\n                    gs_free_object(pfont->memory, (byte *)pstr->data, \"free string on error\");\n                    pstr->data = NULL;\n                    pstr->size = 0;\n                    return -1;\n                }\n                plfont->max_name_index = 255;\n                plfont->next_name_index = 0;\n                memset(plfont->names, 0x00, 256 * sizeof (char *));\n            }\n            if (plfont->next_name_index > plfont->max_name_index) {\n                char **temp = NULL;\n                temp = (char **)gs_alloc_bytes(pfont->memory, (plfont->max_name_index + 256) * sizeof (char *), \"names storage\");\n                if (temp == NULL) {\n                    gs_free_object(pfont->memory, (byte *)pstr->data, \"free string on error\");\n                    pstr->data = NULL;\n                    pstr->size = 0;\n                    return -1;\n                }\n                memset(temp, 0x00, (plfont->max_name_index + 256) * sizeof (char *));\n                memcpy(temp, plfont->names, plfont->max_name_index * sizeof(char *));\n                gs_free_object(pfont->memory, (void *)plfont->names, \"realloc names storage\");\n                plfont->names = temp;\n                plfont->max_name_index += 256;\n            }\n            plfont->names[plfont->next_name_index++] = (char *)pstr->data;\n            return 0;\n        }\n    }\n    return 0;\n}", "target": 1, "idx": 11723}
{"commit_id": "d8861bab48b6c1fc3cdbcab8ff9d1eaea43afe7f", "project": "torvalds/linux", "func": "static int gfar_clean_rx_ring(struct gfar_priv_rx_q *rx_queue,\n\t\t\t      int rx_work_limit)\n{\n\tstruct net_device *ndev = rx_queue->ndev;\n\tstruct gfar_private *priv = netdev_priv(ndev);\n\tstruct rxbd8 *bdp;\n\tint i, howmany = 0;\n\tstruct sk_buff *skb = rx_queue->skb;\n\tint cleaned_cnt = gfar_rxbd_unused(rx_queue);\n\tunsigned int total_bytes = 0, total_pkts = 0;\n\n\t/* Get the first full descriptor */\n\ti = rx_queue->next_to_clean;\n\n\twhile (rx_work_limit--) {\n\t\tu32 lstatus;\n\n\t\tif (cleaned_cnt >= GFAR_RX_BUFF_ALLOC) {\n\t\t\tgfar_alloc_rx_buffs(rx_queue, cleaned_cnt);\n\t\t\tcleaned_cnt = 0;\n\t\t}\n\n\t\tbdp = &rx_queue->rx_bd_base[i];\n\t\tlstatus = be32_to_cpu(bdp->lstatus);\n\t\tif (lstatus & BD_LFLAG(RXBD_EMPTY))\n\t\t\tbreak;\n\n\t\t/* lost RXBD_LAST descriptor due to overrun */\n\t\tif (skb &&\n\t\t    (lstatus & BD_LFLAG(RXBD_FIRST))) {\n\t\t\t/* discard faulty buffer */\n\t\t\tdev_kfree_skb(skb);\n\t\t\tskb = NULL;\n\t\t\trx_queue->stats.rx_dropped++;\n\n\t\t\t/* can continue normally */\n\t\t}\n\n\t\t/* order rx buffer descriptor reads */\n\t\trmb();\n\n\t\t/* fetch next to clean buffer from the ring */\n\t\tskb = gfar_get_next_rxbuff(rx_queue, lstatus, skb);\n\t\tif (unlikely(!skb))\n\t\t\tbreak;\n\n\t\tcleaned_cnt++;\n\t\thowmany++;\n\n\t\tif (unlikely(++i == rx_queue->rx_ring_size))\n\t\t\ti = 0;\n\n\t\trx_queue->next_to_clean = i;\n\n\t\t/* fetch next buffer if not the last in frame */\n\t\tif (!(lstatus & BD_LFLAG(RXBD_LAST)))\n\t\t\tcontinue;\n\n\t\tif (unlikely(lstatus & BD_LFLAG(RXBD_ERR))) {\n\t\t\tcount_errors(lstatus, ndev);\n\n\t\t\t/* discard faulty buffer */\n\t\t\tdev_kfree_skb(skb);\n\t\t\tskb = NULL;\n\t\t\trx_queue->stats.rx_dropped++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tgfar_process_frame(ndev, skb);\n\n\t\t/* Increment the number of packets */\n\t\ttotal_pkts++;\n\t\ttotal_bytes += skb->len;\n\n\t\tskb_record_rx_queue(skb, rx_queue->qindex);\n\n\t\tskb->protocol = eth_type_trans(skb, ndev);\n\n\t\t/* Send the packet up the stack */\n\t\tnapi_gro_receive(&rx_queue->grp->napi_rx, skb);\n\n\t\tskb = NULL;\n\t}\n\n\t/* Store incomplete frames for completion */\n\trx_queue->skb = skb;\n\n\trx_queue->stats.rx_packets += total_pkts;\n\trx_queue->stats.rx_bytes += total_bytes;\n\n\tif (cleaned_cnt)\n\t\tgfar_alloc_rx_buffs(rx_queue, cleaned_cnt);\n\n\t/* Update Last Free RxBD pointer for LFC */\n\tif (unlikely(priv->tx_actual_en)) {\n\t\tu32 bdp_dma = gfar_rxbd_dma_lastfree(rx_queue);\n\n\t\tgfar_write(rx_queue->rfbptr, bdp_dma);\n\t}\n\n\treturn howmany;\n}", "target": 1, "idx": 11724}
{"commit_id": "3119b232c9c453c98d8fa8b6ae4e37ba18117cd4", "project": "VirusTotal/yara", "func": "int re_yyget_column  (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n        if (! YY_CURRENT_BUFFER)\n            return 0;\n    \n    return yycolumn;\n}", "target": 2, "idx": 11725}
{"commit_id": "baa4b8a02c1ffab9645d13f0bfb1c0d10d311a0c", "project": "exempi", "func": "void PostScript_MetaHandler::ParsePSFile()\n{\n\tbool     found = false;\n\tIOBuffer ioBuf;\n\n\tXMP_IO* fileRef = this->parent->ioRef;\n\n\tXMP_AbortProc abortProc  = this->parent->abortProc;\n\tvoid *        abortArg   = this->parent->abortArg;\n\tconst bool    checkAbort = (abortProc != 0);\n\n\t//Determine the file type PS or EPS\n\tif ( ! PostScript_Support::IsValidPSFile(fileRef,this->fileformat) ) return ; \n\t// Check for the binary EPSF preview header.\n\n\tfileRef->Rewind();\n\tif ( ! CheckFileSpace ( fileRef, &ioBuf, 4 ) ) return ;\n\tXMP_Uns32 fileheader = GetUns32BE ( ioBuf.ptr );\n\n\tif ( fileheader == 0xC5D0D3C6 ) \n\t{\n\n\t\tif ( ! CheckFileSpace ( fileRef, &ioBuf, 30 ) ) return ;\n\n\t\tXMP_Uns32 psOffset = GetUns32LE ( ioBuf.ptr+4 );\t// PostScript offset.\n\t\tXMP_Uns32 psLength = GetUns32LE ( ioBuf.ptr+8 );\t// PostScript length.\n\n\t\tsetTokenInfo(kPS_EndPostScript,psOffset+psLength,0);\n\t\tMoveToOffset ( fileRef, psOffset, &ioBuf );\n\n\t}\n\n\twhile ( true ) \n\t{\n\t\tif ( checkAbort && abortProc(abortArg) ) {\n\t\t\tXMP_Throw ( \"PostScript_MetaHandler::FindPostScriptHint - User abort\", kXMPErr_UserAbort );\n\t\t}\n\n\t\tif ( ! CheckFileSpace ( fileRef, &ioBuf, kPSContainsForString.length() ) ) return ;\n\n\t\tif ( (CheckFileSpace ( fileRef, &ioBuf, kPSEndCommentString.length() )&& \n\t\t\t\tCheckBytes ( ioBuf.ptr, Uns8Ptr(kPSEndCommentString.c_str()), kPSEndCommentString.length() )\n\t\t\t\t)|| *ioBuf.ptr!='%' || !(*(ioBuf.ptr+1)>32 && *(ioBuf.ptr+1)<=126 )) // implicit endcomment check\n\t\t{\n\t\t\tif (CheckBytes ( ioBuf.ptr, Uns8Ptr(kPSEndCommentString.c_str()), kPSEndCommentString.length() ))\n\t\t\t{\n\t\t\t\tsetTokenInfo(kPS_EndComments,ioBuf.filePos+ioBuf.ptr-ioBuf.data,kPSEndCommentString.length());\n\t\t\t\tioBuf.ptr+=kPSEndCommentString.length();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsetTokenInfo(kPS_EndComments,ioBuf.filePos+ioBuf.ptr-ioBuf.data,0);\n\t\t\t}\n\t\t\t// Found \"%%EndComments\", look for docInfo Dictionary\n\t\t\t// skip past the end of this line.\n\t\t\twhile(true)\n\t\t\t{\n\t\t\t\tif ( ! CheckFileSpace ( fileRef, &ioBuf, 1 ) ) return ;\n\t\t\t\tif (! IsWhitespace (*ioBuf.ptr)) break;\n\t\t\t\t++ioBuf.ptr;\n\t\t\t} \n\t\t\t// search for /DOCINFO\n\t\t\twhile(true)\n\t\t\t{\n\t\t\t\tif ( ! CheckFileSpace ( fileRef, &ioBuf, 5 ) ) return ;\n\t\t\t\tif (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"/DOCI\"), 5 ) \n\t\t\t\t\t&& CheckFileSpace ( fileRef, &ioBuf, kPSContainsDocInfoString.length() )\n\t\t\t\t\t&&CheckBytes ( ioBuf.ptr, Uns8Ptr(kPSContainsDocInfoString.c_str()), kPSContainsDocInfoString.length() ))\n\t\t\t\t\t\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tioBuf.ptr+=kPSContainsDocInfoString.length();\n\t\t\t\t\tExtractDocInfoDict(ioBuf);\n\t\t\t\t}// DOCINFO Not found in document\n\t\t\t\telse if(CheckBytes ( ioBuf.ptr, Uns8Ptr(\"%%Beg\"), 5 ))\n\t\t\t\t{//possibly one of %%BeginProlog %%BeginSetup %%BeginBinary %%BeginData \n\t\t\t\t\t// %%BeginDocument %%BeginPageSetup\n\t\t\t\t\tXMP_Int64 begStartpos=ioBuf.filePos+ioBuf.ptr-ioBuf.data;\n\t\t\t\t\tioBuf.ptr+=5;\n\t\t\t\t\tif (!CheckFileSpace ( fileRef, &ioBuf, 6 )) return;\n\t\t\t\t\tif(CheckBytes ( ioBuf.ptr, Uns8Ptr(\"inProl\"), 6 ))\n\t\t\t\t\t{//%%BeginProlog\n\t\t\t\t\t\tioBuf.ptr+=6;\n\t\t\t\t\t\tif (!CheckFileSpace ( fileRef, &ioBuf, 2 ))return;\n\t\t\t\t\t\tif(CheckBytes ( ioBuf.ptr, Uns8Ptr(\"og\"), 2 ))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tioBuf.ptr+=2;\n\t\t\t\t\t\t\tsetTokenInfo(kPS_BeginProlog,begStartpos,13);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"inSetu\"), 6 ))\n\t\t\t\t\t{//%%BeginSetup \n\t\t\t\t\t\tioBuf.ptr+=6;\n\t\t\t\t\t\tif (!CheckFileSpace ( fileRef, &ioBuf, 1 ))return;\n\t\t\t\t\t\tif(CheckBytes ( ioBuf.ptr, Uns8Ptr(\"p\"), 1 ))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tioBuf.ptr+=1;\n\t\t\t\t\t\t\tsetTokenInfo(kPS_BeginSetup,begStartpos,12);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"inBina\"), 6 ))\n\t\t\t\t\t{//%%BeginBinary\n\t\t\t\t\t\tioBuf.ptr+=6;\n\t\t\t\t\t\tif (!CheckFileSpace ( fileRef, &ioBuf, 3 ))return;\n\t\t\t\t\t\tif(CheckBytes ( ioBuf.ptr, Uns8Ptr(\"ry\"), 3 ))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tioBuf.ptr+=3;\n\t\t\t\t\t\t\t//ignore till %%EndBinary\n\t\t\t\t\t\t\twhile(true)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (!CheckFileSpace ( fileRef, &ioBuf, 12 ))return;\n\t\t\t\t\t\t\t\tif (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"%%EndBinary\"), 11 ))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tioBuf.ptr+=11;\n\t\t\t\t\t\t\t\t\tif (IsWhitespace(*ioBuf.ptr))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tioBuf.ptr++;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t++ioBuf.ptr;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"inData\"), 6 ))\n\t\t\t\t\t{//%%BeginData\n\t\t\t\t\t\tioBuf.ptr+=6;\n\t\t\t\t\t\tif (!CheckFileSpace ( fileRef, &ioBuf, 1 ))return;\n\t\t\t\t\t\tif(CheckBytes ( ioBuf.ptr, Uns8Ptr(\":\"), 1 ))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//ignore till %%EndData\n\t\t\t\t\t\t\twhile(true)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (!CheckFileSpace ( fileRef, &ioBuf, 10 ))return;\n\t\t\t\t\t\t\t\tif (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"%%EndData\"), 9 ))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tioBuf.ptr+=9;\n\t\t\t\t\t\t\t\t\tif (IsWhitespace(*ioBuf.ptr))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tioBuf.ptr++;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t++ioBuf.ptr;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"inDocu\"), 6 ))\n\t\t\t\t\t{// %%BeginDocument\n\t\t\t\t\t\tioBuf.ptr+=6;\n\t\t\t\t\t\tif (!CheckFileSpace ( fileRef, &ioBuf, 5 ))return;\n\t\t\t\t\t\tif(CheckBytes ( ioBuf.ptr, Uns8Ptr(\"ment:\"), 5 ))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tioBuf.ptr+=5;\n\t\t\t\t\t\t\t//ignore till %%EndDocument\n\t\t\t\t\t\t\twhile(true)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (!CheckFileSpace ( fileRef, &ioBuf, 14 ))return;\n\t\t\t\t\t\t\t\tif (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"%%EndDocument\"), 13 ))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tioBuf.ptr+=13;\n\t\t\t\t\t\t\t\t\tif (IsWhitespace(*ioBuf.ptr))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tioBuf.ptr++;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t++ioBuf.ptr;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"inPage\"), 6 ))\n\t\t\t\t\t{// %%BeginPageSetup\n\t\t\t\t\t\tioBuf.ptr+=6;\n\t\t\t\t\t\tif (!CheckFileSpace ( fileRef, &ioBuf, 5 ))return;\n\t\t\t\t\t\tif(CheckBytes ( ioBuf.ptr, Uns8Ptr(\"Setup\"), 5 ))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tioBuf.ptr+=5;\n\t\t\t\t\t\t\tsetTokenInfo(kPS_BeginPageSetup,begStartpos,16);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(CheckBytes ( ioBuf.ptr, Uns8Ptr(\"%%End\"), 5 ))\n\t\t\t\t{//possibly %%EndProlog %%EndSetup %%EndPageSetup %%EndPageComments\n\t\t\t\t\tXMP_Int64 begStartpos=ioBuf.filePos+ioBuf.ptr-ioBuf.data;\n\t\t\t\t\tioBuf.ptr+=5;\n\t\t\t\t\tif ( ! CheckFileSpace ( fileRef, &ioBuf, 5 ) ) return ;\n\t\t\t\t\tif (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"Prolo\"), 5 ))\n\t\t\t\t\t{// %%EndProlog\n\t\t\t\t\t\tioBuf.ptr+=5;\n\t\t\t\t\t\tif ( ! CheckFileSpace ( fileRef, &ioBuf, 1 ) ) return ;\n\t\t\t\t\t\tif (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"g\"), 1 ))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tioBuf.ptr+=1;\n\t\t\t\t\t\t\tsetTokenInfo(kPS_EndProlog,begStartpos,11);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"Setup\"), 5 ))\n\t\t\t\t\t{//%%EndSetup\n\t\t\t\t\t\tioBuf.ptr+=5;\n\t\t\t\t\t\tsetTokenInfo(kPS_EndSetup,begStartpos,10);\n\t\t\t\t\t}\n\t\t\t\t\telse if (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"PageS\"), 5 ))\n\t\t\t\t\t{//%%EndPageSetup\n\t\t\t\t\t\tioBuf.ptr+=5;\n\t\t\t\t\t\tif ( ! CheckFileSpace ( fileRef, &ioBuf, 4 ) ) return ;\n\t\t\t\t\t\tif (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"etup\"), 4 ))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tioBuf.ptr+=4;\n\t\t\t\t\t\t\tsetTokenInfo(kPS_EndPageSetup,begStartpos,14);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"PageC\"), 5 ))\n\t\t\t\t\t{//%%EndPageComments\n\t\t\t\t\t\tioBuf.ptr+=5;\n\t\t\t\t\t\tif ( ! CheckFileSpace ( fileRef, &ioBuf, 7 ) ) return ;\n\t\t\t\t\t\tif (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"omments\"), 7 ))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tioBuf.ptr+=7;\n\t\t\t\t\t\t\tsetTokenInfo(kPS_EndPageComments,begStartpos,17);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(CheckBytes ( ioBuf.ptr, Uns8Ptr(\"%%Pag\"), 5 ))\n\t\t\t\t{\n\t\t\t\t\tXMP_Int64 begStartpos=ioBuf.filePos+ioBuf.ptr-ioBuf.data;\n\t\t\t\t\tioBuf.ptr+=5;\n\t\t\t\t\tif ( ! CheckFileSpace ( fileRef, &ioBuf, 2 ) ) return ;\n\t\t\t\t\tif (CheckBytes ( ioBuf.ptr, Uns8Ptr(\":\"), 2 ))\n\t\t\t\t\t{\n\t\t\t\t\t\tioBuf.ptr+=2;\n\t\t\t\t\t\twhile(!IsNewline(*ioBuf.ptr))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif ( ! CheckFileSpace ( fileRef, &ioBuf, 1 ) ) return ;\n\t\t\t\t\t\t\t++ioBuf.ptr;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsetTokenInfo(kPS_Page,begStartpos,ioBuf.filePos+ioBuf.ptr-ioBuf.data-begStartpos);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\telse if(CheckBytes ( ioBuf.ptr, Uns8Ptr(\"%%Tra\"), 5 ))\n\t\t\t\t{\n\t\t\t\t\tXMP_Int64 begStartpos=ioBuf.filePos+ioBuf.ptr-ioBuf.data;\n\t\t\t\t\tioBuf.ptr+=5;\n\t\t\t\t\tif ( ! CheckFileSpace ( fileRef, &ioBuf, 4 ) ) return ;\n\t\t\t\t\tif (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"iler\"), 4 ))\n\t\t\t\t\t{\n\t\t\t\t\t\tioBuf.ptr+=4;\n\t\t\t\t\t\twhile(ioBuf.ptr < ioBuf.limit &&\n                                                      !IsNewline(*ioBuf.ptr))\n                                                    ++ioBuf.ptr;\n\t\t\t\t\t\tsetTokenInfo(kPS_Trailer,begStartpos,ioBuf.filePos+ioBuf.ptr-ioBuf.data-begStartpos);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(CheckBytes ( ioBuf.ptr, Uns8Ptr(\"%%EOF\"), 5 ))\n\t\t\t\t{\n\t\t\t\t\tioBuf.ptr+=5;\n\t\t\t\t\tsetTokenInfo(kPS_EOF,ioBuf.filePos+ioBuf.ptr-ioBuf.data,5);\n\t\t\t\t}\n\t\t\t\tif ( ! CheckFileSpace ( fileRef, &ioBuf, 1 ) ) return ;\n\t\t\t\t++ioBuf.ptr;\n\t\t\t}\n\t\t\t//dont have to search after this DOCINFO last thing \n\t\t\treturn;\n\n\t\t}else if (!(kPS_Creator & dscFlags) && \n\t\t\t CheckFileSpace ( fileRef, &ioBuf, kPSContainsForString.length() )&&\n\t\t\tCheckBytes ( ioBuf.ptr, Uns8Ptr(kPSContainsForString.c_str()), kPSContainsForString.length() ))\n\t\t{\n\t\t\tioBuf.ptr+=kPSContainsForString.length();\n\t\t\tif ( ! ExtractDSCCommentValue(ioBuf,kPS_dscFor) ) return ;\n\t\t}\n\t\telse if (!(kPS_CreatorTool & dscFlags) &&\n\t\t\t CheckFileSpace ( fileRef, &ioBuf, kPSContainsCreatorString.length() )&&\n\t\t\t CheckBytes ( ioBuf.ptr, Uns8Ptr(kPSContainsCreatorString.c_str()), kPSContainsCreatorString.length() ))\n\t\t{\n\t\t\tioBuf.ptr+=kPSContainsCreatorString.length();\n\t\t\tif ( ! ExtractDSCCommentValue(ioBuf,kPS_dscCreator) ) return ;\n\t\t}\n\t\telse if (!(kPS_CreateDate & dscFlags) &&\n\t\t\t CheckFileSpace ( fileRef, &ioBuf, kPSContainsCreateDateString.length() )&&\n\t\t\tCheckBytes ( ioBuf.ptr, Uns8Ptr(kPSContainsCreateDateString.c_str()), kPSContainsCreateDateString.length() ))\n\t\t{\n\t\t\t\n\t\t\tioBuf.ptr+=kPSContainsCreateDateString.length();\n\t\t\tif ( ! ExtractDSCCommentValue(ioBuf,kPS_dscCreateDate) ) return ;\n\t\t}\n\t\telse if (!(kPS_Title & dscFlags) &&\n\t\t\t CheckFileSpace ( fileRef, &ioBuf, kPSContainsTitleString.length() )&&\n\t\t\tCheckBytes ( ioBuf.ptr, Uns8Ptr(kPSContainsTitleString.c_str()), kPSContainsTitleString.length() ))\n\t\t{\n\t\t\t\t\t\t\n\t\t\tioBuf.ptr+=kPSContainsTitleString.length();\n\t\t\tif ( ! ExtractDSCCommentValue(ioBuf,kPS_dscTitle) ) return ;\n\t\t}\n\t\telse if( CheckFileSpace ( fileRef, &ioBuf, kPSContainsXMPString.length() )&&\n\t\t\t (  CheckBytes ( ioBuf.ptr, Uns8Ptr(kPSContainsXMPString.c_str()), kPSContainsXMPString.length()    ) )) {\n\n\t\t\t// Found \"%ADO_ContainsXMP:\", look for the main packet location option.\n\t\t\t\n\t\t\tXMP_Int64 containsXMPStartpos=ioBuf.filePos+ioBuf.ptr-ioBuf.data;\n\t\t\tioBuf.ptr += kPSContainsXMPString.length();\n\t\t\tExtractContainsXMPHint(ioBuf,containsXMPStartpos);\n\n\t\t}\t// Found \"%ADO_ContainsXMP:\".\n\t\t//Some other DSC comments skip past the end of this line.\n\t\tif ( ! PostScript_Support::SkipUntilNewline(fileRef,ioBuf) ) return ;\n\n\t}\t// Outer marker loop.\n\n\treturn ;\t// Should never reach here.\n\n}", "target": 1, "idx": 11726}
{"commit_id": "347f071f1b9180563c28b0f3d0627b91eb456c72", "project": "wireshark", "func": "void\nproto_register_wbxml(void)\n{\n\tmodule_t *wbxml_module;\t/* WBXML Preferences */\n\n\t/* Setup list of header fields. */\n\tstatic hf_register_info hf[] = {\n\t\t{ &hf_wbxml_version,\n\t\t  { \"Version\",\n\t\t    \"wbxml.version\",\n\t\t    FT_UINT8, BASE_HEX|BASE_EXT_STRING,\n\t\t    &vals_wbxml_versions_ext, 0x00,\n\t\t    \"WBXML Version\", HFILL }\n\t\t},\n\t\t{ &hf_wbxml_public_id_known,\n\t\t  { \"Public Identifier (known)\",\n\t\t    \"wbxml.public_id.known\",\n\t\t    FT_UINT32, BASE_HEX|BASE_EXT_STRING,\n\t\t    &vals_wbxml_public_ids_ext, 0x00,\n\t\t    \"WBXML Known Public Identifier (integer)\", HFILL }\n\t\t},\n\t\t{ &hf_wbxml_public_id_literal,\n\t\t  { \"Public Identifier (literal)\",\n\t\t    \"wbxml.public_id.literal\",\n\t\t    FT_STRING, BASE_NONE,\n\t\t    NULL, 0x00,\n\t\t    \"WBXML Literal Public Identifier (text string)\", HFILL }\n\t\t},\n\t\t{ &hf_wbxml_charset,\n\t\t  { \"Character Set\",\n\t\t    \"wbxml.charset\",\n\t\t    FT_UINT32, BASE_DEC|BASE_EXT_STRING,\n\t\t    &mibenum_vals_character_sets_ext, 0x00,\n\t\t    \"WBXML Character Set\", HFILL }\n\t\t},\n\t\t{ &hf_wbxml_string_table_item_offset,\n\t\t  { \"Offset\",\n\t\t    \"wbxml.string_table_item_offset\",\n\t\t    FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_string_table_item_string,\n\t\t  { \"String\",\n\t\t    \"wbxml.string_table_item_string\",\n\t\t    FT_STRINGZ, STR_UNICODE,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_switch_page,\n\t\t  { \"SWITCH_PAGE\",\n\t\t    \"wbxml.switch_page\",\n\t\t    FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_known_tag,\n\t\t  { \"Known Tag\",\n\t\t    \"wbxml.known_tag\",\n\t\t    FT_STRING, BASE_NONE,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_end_known_tag,\n\t\t  { \"END Known Tag\",\n\t\t    \"wbxml.end_known_tag\",\n\t\t    FT_STRING, BASE_NONE,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_end_known_tag_uint,\n\t\t  { \"END Known Tag\",\n\t\t    \"wbxml.end_known_tag.uint\",\n\t\t    FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_str_i,\n\t\t  { \"STR_I\",\n\t\t    \"wbxml.str_i\",\n\t\t    FT_STRING, BASE_NONE,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_str_t,\n\t\t  { \"STR_T\",\n\t\t    \"wbxml.str_t\",\n\t\t    FT_STRING, BASE_NONE,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_opaque_data,\n\t\t  { \"Opaque Data\",\n\t\t    \"wbxml.opaque_data\",\n\t\t    FT_BYTES, BASE_NONE,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_entity,\n\t\t  { \"ENTITY\",\n\t\t    \"wbxml.entity\",\n\t\t    FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_literal,\n\t\t  { \"LITERAL\",\n\t\t    \"wbxml.literal\",\n\t\t    FT_STRING, BASE_NONE,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_ext_i,\n\t\t  { \"EXT_I\",\n\t\t    \"wbxml.ext_i\",\n\t\t    FT_STRING, BASE_NONE,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_ext_t,\n\t\t  { \"EXT_T\",\n\t\t    \"wbxml.ext_t\",\n\t\t    FT_STRING, BASE_NONE,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_extension_token,\n\t\t  { \"Extension Token\",\n\t\t    \"wbxml.extension_token\",\n\t\t    FT_STRING, BASE_NONE,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_reserved_2,\n\t\t  { \"RESERVED_2\",\n\t\t    \"wbxml.reserved_2\",\n\t\t    FT_NONE, BASE_NONE,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_invalid_token,\n\t\t  { \"Invalid token\",\n\t\t    \"wbxml.invalid_token\",\n\t\t    FT_UINT32, BASE_DEC,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_known_attrvalue,\n\t\t  { \"Known attrValue\",\n\t\t    \"wbxml.known_attrvalue\",\n\t\t    FT_STRING, BASE_NONE,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_known_attrstart,\n\t\t  { \"Known attrStart\",\n\t\t    \"wbxml.known_attrstart\",\n\t\t    FT_STRING, BASE_NONE,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_end_literal_tag,\n\t\t  { \"END (Literal Tag)\",\n\t\t    \"wbxml.end_literal_tag\",\n\t\t    FT_STRING, BASE_NONE,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_literal_a,\n\t\t  { \"LITERAL_A\",\n\t\t    \"wbxml.literal_a\",\n\t\t    FT_STRING, BASE_NONE,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_literal_c,\n\t\t  { \"LITERAL_C\",\n\t\t    \"wbxml.literal_c\",\n\t\t    FT_STRING, BASE_NONE,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_literal_ac,\n\t\t  { \"LITERAL_AC\",\n\t\t    \"wbxml.literal_ac\",\n\t\t    FT_STRING, BASE_NONE,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_end_pi,\n\t\t  { \"END (PI)\",\n\t\t    \"wbxml.end_pi\",\n\t\t    FT_NONE, BASE_NONE,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_end_attribute_list,\n\t\t  { \"END (attribute list)\",\n\t\t    \"wbxml.end_attribute_list\",\n\t\t    FT_NONE, BASE_NONE,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t\t{ &hf_wbxml_pi_xml,\n\t\t  { \"PI (XML Processing Instruction)\",\n\t\t    \"wbxml.pi_xml\",\n\t\t    FT_NONE, BASE_NONE,\n\t\t    NULL, 0x00,\n\t\t    NULL, HFILL }\n\t\t},\n\t};\n\n\t/* Setup protocol subtree array */\n\tstatic gint *ett[] = {\n\t\t&ett_wbxml,\n\t\t&ett_wbxml_str_tbl,\n\t\t&ett_wbxml_content,\n\t\t&ett_wbxml_tags,\n\t\t&ett_wbxml_string_table_item,\n\t};\n\n\tstatic ei_register_info ei[] = {\n\t\t{ &ei_wbxml_data_not_shown, { \"wbxml.data_not_shown\", PI_PROTOCOL, PI_NOTE, \"Data representation not shown (edit WBXML preferences to show)\", EXPFILL }},\n\t\t{ &ei_wbxml_content_type_not_supported, { \"wbxml.content_type.not_supported\", PI_UNDECODED, PI_WARN, \"Rendering of this content type not (yet) supported\", EXPFILL }},\n\t\t{ &ei_wbxml_content_type_disabled, { \"wbxml.content_type.disabled\", PI_PROTOCOL, PI_NOTE, \"Rendering of this content type has been disabled (edit WBXML preferences to enable)\", EXPFILL }},\n\t\t{ &ei_wbxml_oversized_uintvar, { \"wbxml.oversized_uintvar\", PI_MALFORMED, PI_ERROR, \"Uintvar is oversized\", EXPFILL }},\n\t\t{ &ei_wbxml_too_much_recursion, { \"wbxml.too_much_recursion\", PI_UNDECODED, PI_WARN, \"Too much recursion\", EXPFILL }}\n\t};\n\n\texpert_module_t* expert_wbxml;\n\n\t/* Register the protocol name and description */\n\tproto_wbxml = proto_register_protocol(\n\t\t\t\t\t      \"WAP Binary XML\",\n\t\t\t\t\t      \"WBXML\",\n\t\t\t\t\t      \"wbxml\"\n\t\t\t\t\t      );\n\n\t/* Required function calls to register the header fields\n\t * and subtrees used */\n\tproto_register_field_array(proto_wbxml, hf, array_length(hf));\n\tproto_register_subtree_array(ett, array_length(ett));\n\texpert_wbxml = expert_register_protocol(proto_wbxml);\n\texpert_register_field_array(expert_wbxml, ei, array_length(ei));\n\n\t/* Preferences */\n\twbxml_module = prefs_register_protocol(proto_wbxml, NULL);\n\tprefs_register_bool_preference(wbxml_module,\n\t\t\t\t       \"skip_wbxml_token_mapping\",\n\t\t\t\t       \"Skip the mapping of WBXML tokens to media type tokens.\",\n\t\t\t\t       \"Enable this preference if you want to view the WBXML \"\n\t\t\t\t       \"tokens without the representation in a media type \"\n\t\t\t\t       \"(e.g., WML). Tokens will show up as Tag_0x12, \"\n\t\t\t\t       \"attrStart_0x08 or attrValue_0x0B for example.\",\n\t\t\t\t       &skip_wbxml_token_mapping);\n\tprefs_register_bool_preference(wbxml_module,\n\t\t\t\t       \"disable_wbxml_token_parsing\",\n\t\t\t\t       \"Disable the parsing of the WBXML tokens.\",\n\t\t\t\t       \"Enable this preference if you want to skip the \"\n\t\t\t\t       \"parsing of the WBXML tokens that constitute the body \"\n\t\t\t\t       \"of the WBXML document. Only the WBXML header will be \"\n\t\t\t\t       \"dissected (and visualized) then.\",\n\t\t\t\t       &disable_wbxml_token_parsing);\n\n\tregister_dissector(\"wbxml\", dissect_wbxml, proto_wbxml);\n\tregister_dissector(\"wbxml-uaprof\", dissect_uaprof, proto_wbxml);\n}", "target": 1, "idx": 11727}
{"commit_id": "3c4edac2a5b00dec6c8579a0ee658cfb3bb16d94", "project": "android", "func": "void *SoftMP3::memsetSafe(OMX_BUFFERHEADERTYPE *outHeader, int c, size_t len) {\n    if (len > outHeader->nAllocLen) {\n        ALOGE(\"memset buffer too small: got %lu, expected %zu\", (unsigned long)outHeader->nAllocLen, len);\n        android_errorWriteLog(0x534e4554, \"29422022\");\n        notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);\n        mSignalledError = true;\n        return NULL;\n    }\n    return memset(outHeader->pBuffer, c, len);\n}", "target": 2, "idx": 11728}
{"commit_id": "6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d", "project": "dbry/WavPack", "func": "int ParseDsdiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)\n{\n    int64_t infilesize, total_samples;\n    DFFFileHeader dff_file_header;\n    DFFChunkHeader dff_chunk_header;\n    uint32_t bcount;\n\n    infilesize = DoGetFileSize (infile);\n    memcpy (&dff_file_header, fourcc, 4);\n\n    if ((!DoReadFile (infile, ((char *) &dff_file_header) + 4, sizeof (DFFFileHeader) - 4, &bcount) ||\n        bcount != sizeof (DFFFileHeader) - 4) || strncmp (dff_file_header.formType, \"DSD \", 4)) {\n            error_line (\"%s is not a valid .DFF file!\", infilename);\n            return WAVPACK_SOFT_ERROR;\n    }\n    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n        !WavpackAddWrapper (wpc, &dff_file_header, sizeof (DFFFileHeader))) {\n            error_line (\"%s\", WavpackGetErrorMessage (wpc));\n            return WAVPACK_SOFT_ERROR;\n    }\n\n#if 1   // this might be a little too picky...\n    WavpackBigEndianToNative (&dff_file_header, DFFFileHeaderFormat);\n\n    if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) &&\n        dff_file_header.ckDataSize && dff_file_header.ckDataSize + 1 && dff_file_header.ckDataSize + 12 != infilesize) {\n            error_line (\"%s is not a valid .DFF file (by total size)!\", infilename);\n            return WAVPACK_SOFT_ERROR;\n    }\n\n    if (debug_logging_mode)\n        error_line (\"file header indicated length = %lld\", dff_file_header.ckDataSize);\n\n#endif\n\n    // loop through all elements of the DSDIFF header\n    // (until the data chuck) and copy them to the output file\n\n    while (1) {\n        if (!DoReadFile (infile, &dff_chunk_header, sizeof (DFFChunkHeader), &bcount) ||\n            bcount != sizeof (DFFChunkHeader)) {\n                error_line (\"%s is not a valid .DFF file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n        }\n        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n            !WavpackAddWrapper (wpc, &dff_chunk_header, sizeof (DFFChunkHeader))) {\n                error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                return WAVPACK_SOFT_ERROR;\n        }\n\n        WavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat);\n\n        if (debug_logging_mode)\n            error_line (\"chunk header indicated length = %lld\", dff_chunk_header.ckDataSize);\n\n        if (!strncmp (dff_chunk_header.ckID, \"FVER\", 4)) {\n            uint32_t version;\n\n            if (dff_chunk_header.ckDataSize != sizeof (version) ||\n                !DoReadFile (infile, &version, sizeof (version), &bcount) ||\n                bcount != sizeof (version)) {\n                    error_line (\"%s is not a valid .DFF file!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, &version, sizeof (version))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            WavpackBigEndianToNative (&version, \"L\");\n\n            if (debug_logging_mode)\n                error_line (\"dsdiff file version = 0x%08x\", version);\n        }\n        else if (!strncmp (dff_chunk_header.ckID, \"PROP\", 4)) {\n            char *prop_chunk;\n\n            if (dff_chunk_header.ckDataSize < 4 || dff_chunk_header.ckDataSize > 1024) {\n                error_line (\"%s is not a valid .DFF file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            if (debug_logging_mode)\n                error_line (\"got PROP chunk of %d bytes total\", (int) dff_chunk_header.ckDataSize);\n\n            prop_chunk = malloc ((size_t) dff_chunk_header.ckDataSize);\n\n            if (!DoReadFile (infile, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize, &bcount) ||\n                bcount != dff_chunk_header.ckDataSize) {\n                    error_line (\"%s is not a valid .DFF file!\", infilename);\n                    free (prop_chunk);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize)) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    free (prop_chunk);\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            if (!strncmp (prop_chunk, \"SND \", 4)) {\n                char *cptr = prop_chunk + 4, *eptr = prop_chunk + dff_chunk_header.ckDataSize;\n                uint16_t numChannels, chansSpecified, chanMask = 0;\n                uint32_t sampleRate;\n\n                while (eptr - cptr >= sizeof (dff_chunk_header)) {\n                    memcpy (&dff_chunk_header, cptr, sizeof (dff_chunk_header));\n                    cptr += sizeof (dff_chunk_header);\n                    WavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat);\n\n                    if (eptr - cptr >= dff_chunk_header.ckDataSize) {\n                        if (!strncmp (dff_chunk_header.ckID, \"FS  \", 4) && dff_chunk_header.ckDataSize == 4) {\n                            memcpy (&sampleRate, cptr, sizeof (sampleRate));\n                            WavpackBigEndianToNative (&sampleRate, \"L\");\n                            cptr += dff_chunk_header.ckDataSize;\n\n                            if (debug_logging_mode)\n                                error_line (\"got sample rate of %u Hz\", sampleRate);\n                        }\n                        else if (!strncmp (dff_chunk_header.ckID, \"CHNL\", 4) && dff_chunk_header.ckDataSize >= 2) {\n                            memcpy (&numChannels, cptr, sizeof (numChannels));\n                            WavpackBigEndianToNative (&numChannels, \"S\");\n                            cptr += sizeof (numChannels);\n\n                            chansSpecified = (int)(dff_chunk_header.ckDataSize - sizeof (numChannels)) / 4;\n\n                            while (chansSpecified--) {\n                                if (!strncmp (cptr, \"SLFT\", 4) || !strncmp (cptr, \"MLFT\", 4))\n                                    chanMask |= 0x1;\n                                else if (!strncmp (cptr, \"SRGT\", 4) || !strncmp (cptr, \"MRGT\", 4))\n                                    chanMask |= 0x2;\n                                else if (!strncmp (cptr, \"LS  \", 4))\n                                    chanMask |= 0x10;\n                                else if (!strncmp (cptr, \"RS  \", 4))\n                                    chanMask |= 0x20;\n                                else if (!strncmp (cptr, \"C   \", 4))\n                                    chanMask |= 0x4;\n                                else if (!strncmp (cptr, \"LFE \", 4))\n                                    chanMask |= 0x8;\n                                else\n                                    if (debug_logging_mode)\n                                        error_line (\"undefined channel ID %c%c%c%c\", cptr [0], cptr [1], cptr [2], cptr [3]);\n\n                                cptr += 4;\n                            }\n\n                            if (debug_logging_mode)\n                                error_line (\"%d channels, mask = 0x%08x\", numChannels, chanMask);\n                        }\n                        else if (!strncmp (dff_chunk_header.ckID, \"CMPR\", 4) && dff_chunk_header.ckDataSize >= 4) {\n                            if (strncmp (cptr, \"DSD \", 4)) {\n                                error_line (\"DSDIFF files must be uncompressed, not \\\"%c%c%c%c\\\"!\",\n                                    cptr [0], cptr [1], cptr [2], cptr [3]);\n                                free (prop_chunk);\n                                return WAVPACK_SOFT_ERROR;\n                            }\n\n                            cptr += dff_chunk_header.ckDataSize;\n                        }\n                        else {\n                            if (debug_logging_mode)\n                                error_line (\"got PROP/SND chunk type \\\"%c%c%c%c\\\" of %d bytes\", dff_chunk_header.ckID [0],\n                                    dff_chunk_header.ckID [1], dff_chunk_header.ckID [2], dff_chunk_header.ckID [3], dff_chunk_header.ckDataSize);\n\n                            cptr += dff_chunk_header.ckDataSize;\n                        }\n                    }\n                    else {\n                        error_line (\"%s is not a valid .DFF file!\", infilename);\n                        free (prop_chunk);\n                        return WAVPACK_SOFT_ERROR;\n                    }\n                }\n\n                if (chanMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {\n                    error_line (\"this DSDIFF file already has channel order information!\");\n                    free (prop_chunk);\n                    return WAVPACK_SOFT_ERROR;\n                }\n                else if (chanMask)\n                    config->channel_mask = chanMask;\n\n                config->bits_per_sample = 8;\n                config->bytes_per_sample = 1;\n                config->num_channels = numChannels;\n                config->sample_rate = sampleRate / 8;\n                config->qmode |= QMODE_DSD_MSB_FIRST;\n            }\n            else if (debug_logging_mode)\n                error_line (\"got unknown PROP chunk type \\\"%c%c%c%c\\\" of %d bytes\",\n                    prop_chunk [0], prop_chunk [1], prop_chunk [2], prop_chunk [3], dff_chunk_header.ckDataSize);\n\n            free (prop_chunk);\n        }\n        else if (!strncmp (dff_chunk_header.ckID, \"DSD \", 4)) {\n            total_samples = dff_chunk_header.ckDataSize / config->num_channels;\n            break;\n        }\n        else {          // just copy unknown chunks to output file\n\n            int bytes_to_copy = (int)(((dff_chunk_header.ckDataSize) + 1) & ~(int64_t)1);\n            char *buff;\n\n            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {\n                error_line (\"%s is not a valid .DFF file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            buff = malloc (bytes_to_copy);\n\n            if (debug_logging_mode)\n                error_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\",\n                    dff_chunk_header.ckID [0], dff_chunk_header.ckID [1], dff_chunk_header.ckID [2],\n                    dff_chunk_header.ckID [3], dff_chunk_header.ckDataSize);\n\n            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||\n                bcount != bytes_to_copy ||\n                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    free (buff);\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            free (buff);\n        }\n    }\n\n    if (debug_logging_mode)\n        error_line (\"setting configuration with %lld samples\", total_samples);\n\n    if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {\n        error_line (\"%s: %s\", infilename, WavpackGetErrorMessage (wpc));\n        return WAVPACK_SOFT_ERROR;\n    }\n\n    return WAVPACK_NO_ERROR;\n}", "target": 1, "idx": 11729}
{"commit_id": "8764fdc24c31c21dc43b2a2f99eb8c48a34e5e9c", "project": "upx", "func": "void\nPackLinuxElf64::invert_pt_dynamic(Elf64_Dyn const *dynp, upx_uint64_t dt_filesz)\n{\n    if (dt_table[Elf64_Dyn::DT_NULL]) {\n        return;  // not 1st time; do not change upx_dt_init\n    }\n    if ((file_size - (e_phnum*sizeof(Elf64_Phdr) + sizeof(Elf64_Ehdr))) < dt_filesz) {\n        char msg[50]; snprintf(msg, sizeof(msg),\n            \"bad PT_DYNAMIC.pt_filesz %#lx\", (long unsigned)dt_filesz);\n        throwCantPack(msg);\n    }\n    Elf64_Dyn const *const dynp0 = dynp;\n    unsigned ndx = 1+ 0;\n    unsigned const limit = dt_filesz / sizeof(*dynp);\n    if (dynp)\n    for (; ; ++ndx, ++dynp) {\n        if (limit <= ndx) {\n            throwCantPack(\"DT_NULL not found\");\n        }\n        upx_uint64_t const d_tag = get_te64(&dynp->d_tag);\n        if (d_tag>>32) { // outrageous\n            char msg[50]; snprintf(msg, sizeof(msg),\n                \"bad Elf64_Dyn[%d].d_tag %#lx\", -1+ ndx, (long unsigned)d_tag);\n            throwCantPack(msg);\n        }\n        if (d_tag < DT_NUM) {\n            if (Elf64_Dyn::DT_NEEDED != d_tag\n            &&  dt_table[d_tag]\n            &&    get_te64(&dynp->d_val)\n               != get_te64(&dynp0[-1+ dt_table[d_tag]].d_val)) {\n                char msg[50]; snprintf(msg, sizeof(msg),\n                    \"duplicate DT_%#x: [%#x] [%#x]\",\n                    (unsigned)d_tag, -1+ dt_table[d_tag], -1+ ndx);\n                throwCantPack(msg);\n            }\n            dt_table[d_tag] = ndx;\n        }\n        if (Elf64_Dyn::DT_NULL == d_tag) {\n            break;  // check here so that dt_table[DT_NULL] is set\n        }\n    }\n    upx_dt_init = 0;\n         if (dt_table[Elf64_Dyn::DT_INIT])          upx_dt_init = Elf64_Dyn::DT_INIT;\n    else if (dt_table[Elf64_Dyn::DT_PREINIT_ARRAY]) upx_dt_init = Elf64_Dyn::DT_PREINIT_ARRAY;\n    else if (dt_table[Elf64_Dyn::DT_INIT_ARRAY])    upx_dt_init = Elf64_Dyn::DT_INIT_ARRAY;\n\n    unsigned const z_str = dt_table[Elf64_Dyn::DT_STRSZ];\n    if (z_str) {\n        strtab_end = get_te64(&dynp0[-1+ z_str].d_val);\n        if ((u64_t)file_size <= strtab_end) { // FIXME: weak\n            char msg[50]; snprintf(msg, sizeof(msg),\n                \"bad DT_STRSZ %#x\", strtab_end);\n            throwCantPack(msg);\n        }\n    }\n    // DT_SYMTAB has no designated length.\n    // End it when next area else starts; often DT_STRTAB.  (FIXME)\n    unsigned const x_sym = dt_table[Elf64_Dyn::DT_SYMTAB];\n    unsigned const x_str = dt_table[Elf64_Dyn::DT_STRTAB];\n    if (x_sym && x_str) {\n        upx_uint64_t const v_sym = get_te64(&dynp0[-1+ x_sym].d_val);\n        upx_uint64_t const v_str = get_te64(&dynp0[-1+ x_str].d_val);\n        unsigned const  z_sym = dt_table[Elf64_Dyn::DT_SYMENT];\n        unsigned const sz_sym = !z_sym ? sizeof(Elf64_Sym)\n            : get_te64(&dynp0[-1+ z_sym].d_val);\n        if (sz_sym < sizeof(Elf64_Sym)) {\n            char msg[50]; snprintf(msg, sizeof(msg),\n                \"bad DT_SYMENT %x\", sz_sym);\n            throwCantPack(msg);\n        }\n        if (v_sym < v_str) {\n            symnum_end = (v_str - v_sym) / sz_sym;\n        }\n        if (symnum_end < 1) {\n            throwCantPack(\"bad DT_SYMTAB\");\n        }\n    }\n    // DT_HASH often ends at DT_SYMTAB\n    unsigned const v_hsh = elf_unsigned_dynamic(Elf64_Dyn::DT_HASH);\n    if (v_hsh && file_image) {\n        hashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_HASH);\n        if (!hashtab) {\n            char msg[40]; snprintf(msg, sizeof(msg),\n               \"bad DT_HASH %#x\", v_hsh);\n            throwCantPack(msg);\n        }\n        unsigned const nbucket = get_te32(&hashtab[0]);\n        unsigned const *const buckets = &hashtab[2];\n        unsigned const *const chains = &buckets[nbucket]; (void)chains;\n\n        unsigned const v_sym = !x_sym ? 0 : get_te32(&dynp0[-1+ x_sym].d_val);\n        if (!nbucket || (nbucket>>31) || !v_sym || file_size <= v_sym\n        || ((v_hsh < v_sym) && (v_sym - v_hsh) < sizeof(*buckets)*(2+ nbucket))\n        ) {\n            char msg[80]; snprintf(msg, sizeof(msg),\n                \"bad DT_HASH nbucket=%#x  len=%#x\",\n                nbucket, (v_sym - v_hsh));\n            throwCantPack(msg);\n        }\n        unsigned chmax = 0;\n        for (unsigned j= 0; j < nbucket; ++j) {\n            if (chmax < buckets[j]) {\n                chmax = buckets[j];\n            }\n        }\n        if ((v_hsh < v_sym) && (v_sym - v_hsh) <\n                (sizeof(*buckets)*(2+ nbucket) + sizeof(*chains)*(1+ chmax))) {\n            char msg[80]; snprintf(msg, sizeof(msg),\n                \"bad DT_HASH nbucket=%#x  len=%#x\",\n                nbucket, (v_sym - v_hsh));\n            throwCantPack(msg);\n        }\n    }\n    // DT_GNU_HASH often ends at DT_SYMTAB;  FIXME: not for Android?\n    unsigned const v_gsh = elf_unsigned_dynamic(Elf64_Dyn::DT_GNU_HASH);\n    if (v_gsh && file_image) {\n        gashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_GNU_HASH);\n        if (!gashtab) {\n            char msg[40]; snprintf(msg, sizeof(msg),\n               \"bad DT_GNU_HASH %#x\", v_gsh);\n            throwCantPack(msg);\n        }\n        unsigned const n_bucket = get_te32(&gashtab[0]);\n        unsigned const symbias  = get_te32(&gashtab[1]);\n        unsigned const n_bitmask = get_te32(&gashtab[2]);\n        unsigned const gnu_shift = get_te32(&gashtab[3]);\n        upx_uint64_t const *const bitmask = (upx_uint64_t const *)(void const *)&gashtab[4];\n        unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask];\n        unsigned     const *const hasharr = &buckets[n_bucket]; (void)hasharr;\n        if (!n_bucket || (1u<<31) <= n_bucket  /* fie on fuzzers */\n        || (void const *)&file_image[file_size] <= (void const *)hasharr) {\n            char msg[80]; snprintf(msg, sizeof(msg),\n                \"bad n_bucket %#x\\n\", n_bucket);\n            throwCantPack(msg);\n        }\n      //unsigned     const *const gashend = &hasharr[n_bucket];  // minimum, except:\n        // Rust and Android trim unused zeroes from high end of hasharr[]\n        unsigned bmax = 0;\n        for (unsigned j= 0; j < n_bucket; ++j) {\n            if (buckets[j]) {\n                if (buckets[j] < symbias) {\n                    char msg[50]; snprintf(msg, sizeof(msg),\n                            \"bad DT_GNU_HASH bucket[%d] < symbias{%#x}\\n\",\n                            buckets[j], symbias);\n                    throwCantPack(msg);\n                }\n                if (bmax < buckets[j]) {\n                    bmax = buckets[j];\n                }\n            }\n        }\n        if ((1+ bmax) < symbias) {\n            char msg[80]; snprintf(msg, sizeof(msg),\n                    \"bad DT_GNU_HASH (1+ max_bucket)=%#x < symbias=%#x\", 1+ bmax, symbias);\n            throwCantPack(msg);\n        }\n        bmax -= symbias;\n\n        upx_uint64_t const v_sym = !x_sym ? 0 : get_te64(&dynp0[-1+ x_sym].d_val);\n        unsigned r = 0;\n        if (!n_bucket || !n_bitmask || !v_sym\n        || (r=1, ((-1+ n_bitmask) & n_bitmask))  // not a power of 2\n        || (r=2, (8*sizeof(upx_uint64_t) <= gnu_shift))  // shifted result always == 0\n        || (r=3, (n_bucket>>30))  // fie on fuzzers\n        || (r=4, (n_bitmask>>30))\n        || (r=5, ((file_size/sizeof(unsigned))\n                <= ((sizeof(*bitmask)/sizeof(unsigned))*n_bitmask + 2*n_bucket)))  // FIXME: weak\n        || (r=6, ((v_gsh < v_sym) && (v_sym - v_gsh) < (sizeof(unsigned)*4  // headers\n                + sizeof(*bitmask)*n_bitmask  // bitmask\n                + sizeof(*buckets)*n_bucket  // buckets\n                + sizeof(*hasharr)*(1+ bmax)  // hasharr\n            )) )\n        ) {\n            char msg[90]; snprintf(msg, sizeof(msg),\n                \"bad DT_GNU_HASH n_bucket=%#x  n_bitmask=%#x  len=%#lx  r=%d\",\n                n_bucket, n_bitmask, (long unsigned)(v_sym - v_gsh), r);\n            throwCantPack(msg);\n        }\n    }\n    unsigned const e_shstrndx = get_te16(&ehdri.e_shstrndx);\n    if (e_shnum <= e_shstrndx\n    &&  !(0==e_shnum && 0==e_shstrndx) ) {\n        char msg[40]; snprintf(msg, sizeof(msg),\n            \"bad .e_shstrndx %d >= .e_shnum %d\", e_shstrndx, e_shnum);\n        throwCantPack(msg);\n    }\n}", "target": 2, "idx": 11730}
{"commit_id": "6ab55ec0a938c7f943a4edba3d6514f775983887", "project": "torvalds/linux", "func": "static unsigned long get_ctl_id_hash(const struct snd_ctl_elem_id *id)\n{\n\tint i;\n\tunsigned long h;\n\n\th = id->iface;\n\th = MULTIPLIER * h + id->device;\n\th = MULTIPLIER * h + id->subdevice;\n\tfor (i = 0; id->name[i] && i < SNDRV_CTL_ELEM_ID_NAME_MAXLEN; i++)\n\t\th = MULTIPLIER * h + id->name[i];\n\th = MULTIPLIER * h + id->index;\n\th &= LONG_MAX;\n\treturn h;\n}", "target": 2, "idx": 11731}
{"commit_id": "2cb40c4d5feeaa09325522bd7d97910f1b59e379", "project": "polkit", "func": "PolkitIdentity *\npolkit_unix_user_new (gint uid)\n{\n  g_return_val_if_fail (uid != -1, NULL);\n\n  return POLKIT_IDENTITY (g_object_new (POLKIT_TYPE_UNIX_USER,\n                                        \"uid\", uid,\n                                        NULL));\n}", "target": 2, "idx": 11732}
{"commit_id": "403e4fd08b0b212e96f53d926e6273e0745eaa5a", "project": "godotengine/godot", "func": "Error ImageLoaderTGA::decode_tga_rle(const uint8_t *p_compressed_buffer, size_t p_pixel_size, uint8_t *p_uncompressed_buffer, size_t p_output_size) {\n\tError error;\n\n\tVector<uint8_t> pixels;\n\terror = pixels.resize(p_pixel_size);\n\tif (error != OK) {\n\t\treturn error;\n\t}\n\n\tuint8_t *pixels_w = pixels.ptrw();\n\n\tsize_t compressed_pos = 0;\n\tsize_t output_pos = 0;\n\tsize_t c = 0;\n\tsize_t count = 0;\n\n\twhile (output_pos < p_output_size) {\n\t\tc = p_compressed_buffer[compressed_pos];\n\t\tcompressed_pos += 1;\n\t\tcount = (c & 0x7f) + 1;\n\n\t\tif (output_pos + count * p_pixel_size > output_pos) {\n\t\t\treturn ERR_PARSE_ERROR;\n\t\t}\n\n\t\tif (c & 0x80) {\n\t\t\tfor (size_t i = 0; i < p_pixel_size; i++) {\n\t\t\t\tpixels_w[i] = p_compressed_buffer[compressed_pos];\n\t\t\t\tcompressed_pos += 1;\n\t\t\t}\n\t\t\tfor (size_t i = 0; i < count; i++) {\n\t\t\t\tfor (size_t j = 0; j < p_pixel_size; j++) {\n\t\t\t\t\tp_uncompressed_buffer[output_pos + j] = pixels_w[j];\n\t\t\t\t}\n\t\t\t\toutput_pos += p_pixel_size;\n\t\t\t}\n\t\t} else {\n\t\t\tcount *= p_pixel_size;\n\t\t\tfor (size_t i = 0; i < count; i++) {\n\t\t\t\tp_uncompressed_buffer[output_pos] = p_compressed_buffer[compressed_pos];\n\t\t\t\tcompressed_pos += 1;\n\t\t\t\toutput_pos += 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn OK;\n}", "target": 2, "idx": 11733}
{"commit_id": "23be074a9940040778e09121e596ea67e84804a3", "project": "sleuthkit", "func": "static uint8_t\niso9660_proc_dir(TSK_FS_INFO * a_fs, TSK_FS_DIR * a_fs_dir, char *buf,\n    size_t a_length, TSK_INUM_T a_addr, TSK_OFF_T a_dir_addr)\n{\n    ISO_INFO *iso = (ISO_INFO *) a_fs;\n    TSK_FS_NAME *fs_name;\n    size_t buf_idx;\n\n    iso9660_dentry *dd;         /* directory descriptor */\n    iso9660_inode_node *in;\n    TSK_OFF_T dir_offs = a_dir_addr * a_fs->block_size;\n\n    // had an issue once where dir was too small\n    // many later calculations assume we can fit at least one entry\n    if (a_length < sizeof(iso9660_dentry)) {      \n        return TSK_OK;\n    }\n\n    if ((fs_name = tsk_fs_name_alloc(ISO9660_MAXNAMLEN + 1, 0)) == NULL)\n        return TSK_ERR;\n\n    buf_idx = 0;\n    dd = (iso9660_dentry *) & buf[buf_idx];\n\n    /* handle \".\" entry */\n    fs_name->meta_addr = a_addr;\n    strcpy(fs_name->name, \".\");\n    fs_name->type = TSK_FS_NAME_TYPE_DIR;\n    fs_name->flags = TSK_FS_NAME_FLAG_ALLOC;\n\n    tsk_fs_dir_add(a_fs_dir, fs_name);\n\n    buf_idx += dd->entry_len;\n    if (buf_idx > a_length - sizeof(iso9660_dentry)) {\n        free(buf);\n        tsk_fs_name_free(fs_name);\n        return TSK_OK;\n    }\n    dd = (iso9660_dentry *) & buf[buf_idx];\n\n    /* handle \"..\" entry */\n    in = iso->in_list;\n    while (in\n        && (tsk_getu32(a_fs->endian, in->inode.dr.ext_loc_m) !=\n            tsk_getu32(a_fs->endian, dd->ext_loc_m)))\n        in = in->next;\n    if (in) {\n        fs_name->meta_addr = in->inum;\n        strcpy(fs_name->name, \"..\");\n\n        fs_name->type = TSK_FS_NAME_TYPE_DIR;\n        fs_name->flags = TSK_FS_NAME_FLAG_ALLOC;\n\n        tsk_fs_dir_add(a_fs_dir, fs_name);\n    }\n    buf_idx += dd->entry_len;\n\n    // process the rest of the entries in the directory\n    while (buf_idx < a_length - sizeof(iso9660_dentry)) {\n        dd = (iso9660_dentry *) & buf[buf_idx];\n\n        // process the entry (if it has a defined and valid length)\n        if ((dd->entry_len) && (buf_idx + dd->entry_len <= a_length)) {\n\n            /* We need to find the data in the pre-processed list because that\n             * contains the meta data address that TSK assigned to this file.\n             * We find the entry by looking for one that was stored at the same\n             * byte offset that we now are.  We used to use the extent location, but\n             * we found an image\n             * that had a file with 0 bytes with the same starting block as another\n             * file. */\n            for (in = iso->in_list; in; in = in->next) {\n                if (in->dentry_offset == dir_offs + buf_idx)\n                    break;\n            }\n\n            // we may have not found it because we are reading corrupt data...\n            if (!in) {\n                buf_idx++;\n                continue;\n            }\n\n            // copy the data in fs_name for loading\n            fs_name->meta_addr = in->inum;\n            strncpy(fs_name->name, in->inode.fn, ISO9660_MAXNAMLEN);\n\n            if (dd->flags & ISO9660_FLAG_DIR)\n                fs_name->type = TSK_FS_NAME_TYPE_DIR;\n            else\n                fs_name->type = TSK_FS_NAME_TYPE_REG;\n            fs_name->flags = TSK_FS_NAME_FLAG_ALLOC;\n\n            tsk_fs_dir_add(a_fs_dir, fs_name);\n\n            buf_idx += dd->entry_len;\n        }\n        /* If the length was not defined, we are probably in a hole in the\n         * directory.  The contents are  block aligned. So, we\n         * scan ahead until we get either a non-zero entry or the block boundary */\n        else {\n            buf_idx++;\n            for (; buf_idx < a_length - sizeof(iso9660_dentry); buf_idx++) {\n                if (buf[buf_idx] != 0) {\n                    dd = (iso9660_dentry *) & buf[buf_idx];\n                    if ((dd->entry_len)\n                        && (buf_idx + dd->entry_len < a_length))\n                        break;\n                }\n\n                if (buf_idx % a_fs->block_size == 0)\n                    break;\n            }\n        }\n    }\n\n    free(buf);\n    tsk_fs_name_free(fs_name);\n\n    return TSK_OK;\n}", "target": 1, "idx": 11734}
{"commit_id": "2b16dbd8f73269cb15ca61ece75cf8d2d196ed28", "project": "ArtifexSoftware/mupdf", "func": "static xps_resource *\nxps_parse_remote_resource_dictionary(fz_context *ctx, xps_document *doc, char *base_uri, char *source_att)\n{\n\tchar part_name[1024];\n\tchar part_uri[1024];\n\txps_resource *dict;\n\txps_part *part;\n\tfz_xml *xml = NULL;\n\tchar *s;\n\n\t/* External resource dictionaries MUST NOT reference other resource dictionaries */\n\txps_resolve_url(ctx, doc, part_name, base_uri, source_att, sizeof part_name);\n\tpart = xps_read_part(ctx, doc, part_name);\n\tfz_try(ctx)\n\t{\n\t\txml = fz_parse_xml(ctx, part->data, 0);\n\t}\n\tfz_always(ctx)\n\t{\n\t\txps_drop_part(ctx, doc, part);\n\t}\n\tfz_catch(ctx)\n\t{\n\t\tfz_rethrow_if(ctx, FZ_ERROR_TRYLATER);\n\t\txml = NULL;\n\t}\n\n\tif (!xml)\n\t\treturn NULL;\n\n\tif (!fz_xml_is_tag(xml, \"ResourceDictionary\"))\n\t{\n\t\tfz_drop_xml(ctx, xml);\n\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"expected ResourceDictionary element\");\n\t}\n\n\tfz_strlcpy(part_uri, part_name, sizeof part_uri);\n\ts = strrchr(part_uri, '/');\n\tif (s)\n\t\ts[1] = 0;\n\n\tdict = xps_parse_resource_dictionary(ctx, doc, part_uri, xml);\n\tif (dict)\n\t\tdict->base_xml = xml; /* pass on ownership */\n\telse\n\t\tfz_drop_xml(ctx, xml);\n\n\treturn dict;\n}", "target": 2, "idx": 11735}
{"commit_id": "54cb02ad733fb71b1bdf78590428817fb780aff8", "project": "android", "func": "native_handle* Parcel::readNativeHandle() const\n{\n    int numFds, numInts;\n    status_t err;\n    err = readInt32(&numFds);\n    if (err != NO_ERROR) return 0;\n    err = readInt32(&numInts);\n    if (err != NO_ERROR) return 0;\n\n    native_handle* h = native_handle_create(numFds, numInts);\n    if (!h) {\n        return 0;\n    }\n\n    for (int i=0 ; err==NO_ERROR && i<numFds ; i++) {\n        h->data[i] = dup(readFileDescriptor());\n        if (h->data[i] < 0) {\n            for (int j = 0; j < i; j++) {\n                close(h->data[j]);\n            }\n            native_handle_delete(h);\n            return 0;\n        }\n    }\n    err = read(h->data + numFds, sizeof(int)*numInts);\n    if (err != NO_ERROR) {\n        native_handle_close(h);\n        native_handle_delete(h);\n        h = 0;\n    }\n    return h;\n}", "target": 2, "idx": 11736}
{"commit_id": "697af434fbeb2e3ba2ba9687cd283ed1a2734fa5", "project": "redis", "func": "void freeClient(redisClient *c) {\n    listNode *ln;\n\n    /* Note that if the client we are freeing is blocked into a blocking\n     * call, we have to set querybuf to NULL *before* to call\n     * unblockClientWaitingData() to avoid processInputBuffer() will get\n     * called. Also it is important to remove the file events after\n     * this, because this call adds the READABLE event. */\n    sdsfree(c->querybuf);\n    c->querybuf = NULL;\n    if (c->flags & REDIS_BLOCKED)\n        unblockClientWaitingData(c);\n\n    /* UNWATCH all the keys */\n    unwatchAllKeys(c);\n    listRelease(c->watched_keys);\n    /* Unsubscribe from all the pubsub channels */\n    pubsubUnsubscribeAllChannels(c,0);\n    pubsubUnsubscribeAllPatterns(c,0);\n    dictRelease(c->pubsub_channels);\n    listRelease(c->pubsub_patterns);\n    /* Obvious cleanup */\n    aeDeleteFileEvent(server.el,c->fd,AE_READABLE);\n    aeDeleteFileEvent(server.el,c->fd,AE_WRITABLE);\n    listRelease(c->reply);\n    freeClientArgv(c);\n    close(c->fd);\n    /* Remove from the list of clients */\n    ln = listSearchKey(server.clients,c);\n    redisAssert(ln != NULL);\n    listDelNode(server.clients,ln);\n    /* Remove from the list of clients waiting for swapped keys, or ready\n     * to be restarted, but not yet woken up again. */\n    if (c->flags & REDIS_IO_WAIT) {\n        redisAssert(server.ds_enabled);\n        if (listLength(c->io_keys) == 0) {\n            ln = listSearchKey(server.io_ready_clients,c);\n\n            /* When this client is waiting to be woken up (REDIS_IO_WAIT),\n             * it should be present in the list io_ready_clients */\n            redisAssert(ln != NULL);\n            listDelNode(server.io_ready_clients,ln);\n        } else {\n            while (listLength(c->io_keys)) {\n                ln = listFirst(c->io_keys);\n                dontWaitForSwappedKey(c,ln->value);\n            }\n        }\n        server.cache_blocked_clients--;\n    }\n    listRelease(c->io_keys);\n    /* Master/slave cleanup.\n     * Case 1: we lost the connection with a slave. */\n    if (c->flags & REDIS_SLAVE) {\n        if (c->replstate == REDIS_REPL_SEND_BULK && c->repldbfd != -1)\n            close(c->repldbfd);\n        list *l = (c->flags & REDIS_MONITOR) ? server.monitors : server.slaves;\n        ln = listSearchKey(l,c);\n        redisAssert(ln != NULL);\n        listDelNode(l,ln);\n    }\n\n    /* Case 2: we lost the connection with the master. */\n    if (c->flags & REDIS_MASTER) {\n        server.master = NULL;\n        /* FIXME */\n        server.replstate = REDIS_REPL_CONNECT;\n        /* Since we lost the connection with the master, we should also\n         * close the connection with all our slaves if we have any, so\n         * when we'll resync with the master the other slaves will sync again\n         * with us as well. Note that also when the slave is not connected\n         * to the master it will keep refusing connections by other slaves. */\n        while (listLength(server.slaves)) {\n            ln = listFirst(server.slaves);\n            freeClient((redisClient*)ln->value);\n        }\n    }\n    /* Release memory */\n    zfree(c->argv);\n    freeClientMultiState(c);\n    zfree(c);\n}", "target": 1, "idx": 11737}
{"commit_id": "73b5d0a9b9ace89edcee30d9d83eb16c27c6f9b2", "project": "MusicPlayerDaemon/MPD", "func": "static inline std::system_error\nFormatLastError(DWORD code, const char *fmt, Args&&... args) noexcept\n{\n\tchar buffer[512];\n\tconst auto end = buffer + sizeof(buffer);\n\tconstexpr std::size_t max_prefix = sizeof(buffer) - 128;\n\tsize_t length = snprintf(buffer, max_prefix,\n\t\t\t\t fmt, std::forward<Args>(args)...);\n\tif (length >= max_prefix)\n\t\tlength = max_prefix - 1;\n\tchar *p = buffer + length;\n\t*p++ = ':';\n\t*p++ = ' ';\n\n\tFormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM |\n\t\t       FORMAT_MESSAGE_IGNORE_INSERTS,\n\t\t       nullptr, code, 0, p, end - p, nullptr);\n\treturn MakeLastError(code, buffer);\n}", "target": 2, "idx": 11738}
{"commit_id": "4a8b24475549ff10bdf6d07fd4b5f6c1cc6246ea", "project": "radareorg/radare2-extras", "func": "int r_asm_swf_disass(RBinObject *obj, char* buf_asm, const ut8* buf, int len, ut64 pc) {\n\tut8 isTag = false;\n\tint dlen = 0;\n\tRListIter *it;\n\tRBinSection *sect;\n\n\tr_list_foreach(obj->sections, it, sect) {\n\t\tif (pc == sect->vaddr) {\n\t\t\tisTag = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (isTag && len > 1) {\n\t\tdlen = 2;\n\t\tut16 tagCodeAndLength = 0;\n\t\tut16 tagCode = 0;\n\t\tut32 tagLength;\n\t\ttagCodeAndLength = buf[0] + (buf[1] << 8);\n\n\t\ttagCode = tagCodeAndLength >> 6;\n\t\ttagLength = tagCodeAndLength & 0x3f;\n\n\t\tif (tagLength >= 0x3f) {\n\t\t\tdlen = 6;\n\t\t}\n\t\tswf_tag_t tag = r_asm_swf_gettag (tagCode);\n\n\t\tswitch (tagCode) {\n\t\tcase TAG_SETBACKGROUNDCOLOR: {\n\t\t\tut8 red = buf[2];\n\t\t\tut8 green = buf[3];\n\t\t\tut8 blue = buf[4];\n\t\t\tsprintf (buf_asm, \"Color(%u,%u,%u)\", red, green, blue);\n\t\t\tdlen = 5;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tstrcpy (buf_asm, tag.name);\n\t\t\tbreak;\n\n\t\t}\n\n\t} else {\n\t\tswf_op_t op = r_asm_swf_getop (buf[0]);\n\t\tswitch (op.op) {\n\t\tcase SWFACTION_PUSH: {\n\t\t\tut16 len;\n\t\t\tut8 pushtype;\n\t\t\tlen = r_mem_get_num (buf+1, 2);\n\n\t\t\tut8 i = 3; // Buffer index\n\t\t\tut8 l = 0; // String index\n\t\t\tut8 strsize = 20; // Max size of a push name\n\t\t\tut8 max = strsize*(len/2); // Max size of the whole opcode name\n\t\t\tchar* name = malloc(strsize);\n\t\t\tchar* type = malloc(max);\n\t\t\twhile (i < len+2) {\n\t\t\t\teprintf (\"%d, %d\\n\", i, len+2);\n\t\t\t\tpushtype = buf[i];\n\t\t\t\ti += 1;\n\n\t\t\t\tswitch (pushtype) {\n\t\t\t\tcase 0: { /* String */\n\t\t\t\t\tchar* str = (char*) (buf+i);\n\t\t\t\t\ti += strlen (str);\n\t\t\t\t\tsnprintf (name,strsize, \"str: \\\"%s\\\"\", str);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 1: { /* Floating point */\n\t\t\t\t\tfloat f = r_mem_get_num (buf+i, 4);\n\t\t\t\t\ti += 4;\n\t\t\t\t\tsprintf (name, \"float: %lf\", f);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 2: { /* Null */\n\t\t\t\t\tstrcpy (name, \"null\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 3: { /* Undefined */\n\t\t\t\t\tstrcpy (name, \"undefined\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 4: { /* Register */\n\t\t\t\t\tut8 reg = buf[i];\n\t\t\t\t\tsprintf (name, \"reg:%u\", reg);\n\t\t\t\t\ti++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 5: { /* Boolean */\n\t\t\t\t\tsprintf (name, \"bool: %s\", \n\t\t\t\t\t\tbuf[i] > 0 ? \"true\" : \"false\");\n\t\t\t\t\ti++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 6: { /* Double */\n\t\t\t\t\tdouble d = r_mem_get_num (buf+i, 8);\n\t\t\t\t\tsprintf (name, \"double:%f\", d);\n\t\t\t\t\ti += 8;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 7: { /* Integer */\n\t\t\t\t\tint integer = r_mem_get_num (buf+i, 4);\n\t\t\t\t\tsprintf (name, \"int:0x%x\", integer);\n\t\t\t\t\ti += 4;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 8: { /* Constant8 */\n\t\t\t\t\tsprintf (name, \"const:%u\", buf[i]);\n\t\t\t\t\ti += 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 9: { /* Constant16 */\n\t\t\t\t\tut16 c = r_mem_get_num (buf+i, 2);\n\t\t\t\t\tsprintf (name, \"const:%u\", c);\n\t\t\t\t\ti += 2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tstrcpy(name, \"unknown\");\n\t\t\t\t\ttype = name;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (i < len+2) strcat (name, \", \");\n\t\t\t\tstrncpy (type+l, name, max-l);\n\t\t\t\tl += strlen(name);\n\t\t\t}\n\t\t\tdlen = 2 + len + 1;\n\t\t\tsprintf (buf_asm, \"%s %s\", op.name, type);\n\t\t\tbreak;\n\t\t}\n\t\tcase SWFACTION_GOTOFRAME: {\n\t\t\tut16 frame = r_mem_get_num (buf+1, 2);\n\t\t\tsprintf (buf_asm, \"%s %u\", op.name, frame);\n\t\t\tdlen = 3;\n\t\t\tbreak;\n\t\t}\n\t\tcase SWFACTION_GETURL: {\n\t\t\tchar* url = (char*) buf+1;\n\t\t\tsnprintf (buf_asm, 1024,\"%s %s\", op.name, url);\n\t\t\tdlen = strlen (url) + 2;\n\t\t\tbreak;\n\t\t}\n\t\tcase SWFACTION_JUMP:\n\t\tcase SWFACTION_BRANCHIFTRUE: {\n\t\t\tshort offset = r_mem_get_num (buf+1, 2);\n\t\t\tsprintf (buf_asm, \"%s %d\", op.name, offset);\n\t\t\tbreak;\n\t\t}\n\t\tcase SWFACTION_GETURL2: {\n\t\t\tut8 method = buf[1];\n\t\t\tchar* m = malloc (5);\n\t\t\tswitch (method) {\n\t\t\tcase 1:\n\t\t\t\tstrcpy (m, \"GET\");\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tstrcpy (m, \"POST\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstrcpy (m, \"None\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsprintf (buf_asm, \"%s %s\", op.name, m);\n\t\t\tdlen = 2;\n\t\t\tbreak;\n\t\t}\n\t\tcase SWFACTION_GOTOFRAME2: {\n\t\t\tdlen = 8;\n\t\t\tut8 biasFlag = buf[7];\n\t\t\tut8 playFlag = buf[8];\n\t\t\tif (biasFlag == 1) {\n\t\t\t\t//ut16 bias = r_mem_get_num (buf+9, 2);\n\t\t\t\tdlen += 2;\n\t\t\t}\n\t\t\tsprintf (buf_asm, \"%s %u %u\", op.name, biasFlag, playFlag);\n\t\t\tbreak;\n\t\t}\n\t\tcase SWFACTION_SETTARGET: {\n\t\t\tchar* target = (char*) buf+1;\n\t\t\tsprintf (buf_asm, 1024,\"%s %s\", op.name, target);\n\t\t\tdlen = 1;\n\t\t\tbreak;\n\t\t}\n\t\tcase SWFACTION_CONSTANTPOOL: {\n\t\t\tut16 size = r_mem_get_num (buf+1, 2);\n\t\t\tut16 count = r_mem_get_num (buf+3, 2);\n\t\t\tsprintf (buf_asm, \"%s (nb: %u, size: %u)\", op.name, count, size);\n\t\t\tdlen = 5;\n\t\t\tbreak;\n\t\t}\n\t\tcase SWFACTION_WITH: {\n\t\t\tut16 size = r_mem_get_num (buf+1, 2);\n\t\t\tsprintf (buf_asm, \"%s %u\", op.name, size);\n\t\t\tdlen = 3;\n\t\t\tbreak;\n\t\t}\n\t\tcase SWFACTION_DEFINEFUNCTION: {\n\t\t\t//char* name = (char*) buf+1;\n\t\t\tut16 nbParams = r_mem_get_num (buf+2, 2);\n\t\t\tut32 size = 0;\n\t\t\tut16 i;\n\t\t\tfor (i = 0; i < nbParams; i++) {\n\t\t\t\tchar* param = (char*) buf+3+i;\n\t\t\t\tsize += strlen(param);\n\t\t\t}\n\t\t\t//ut16 codeSize = r_mem_get_num (buf+4+i, 2);\n\t\t\tbreak;\n\t\t}\n\t\tcase SWFACTION_STOREREGISTER: {\n\t\t\tut8 reg = buf[1];\n\t\t\tsprintf (buf_asm, \"%s %u\", op.name, reg);\n\t\t\tdlen = 2;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tstrcpy (buf_asm, op.name);\n\t\t\tdlen = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn dlen;\n}", "target": 3, "idx": 11739}
{"commit_id": "b2dd00574a4fc87ca964177f8e752a968c27efb2", "project": "xen-project/xen", "func": "void write_ptbase(struct vcpu *v)\n{\n    struct cpu_info *cpu_info = get_cpu_info();\n    unsigned long new_cr4;\n\n    new_cr4 = (is_pv_vcpu(v) && !is_idle_vcpu(v))\n              ? pv_make_cr4(v) : mmu_cr4_features;\n\n    if ( is_pv_vcpu(v) && v->domain->arch.pv.xpti )\n    {\n        cpu_info->root_pgt_changed = true;\n        cpu_info->pv_cr3 = __pa(this_cpu(root_pgt));\n        if ( new_cr4 & X86_CR4_PCIDE )\n            cpu_info->pv_cr3 |= get_pcid_bits(v, true);\n        switch_cr3_cr4(v->arch.cr3, new_cr4);\n    }\n    else\n    {\n        /* Make sure to clear use_pv_cr3 and xen_cr3 before pv_cr3. */\n        cpu_info->use_pv_cr3 = false;\n        cpu_info->xen_cr3 = 0;\n        /* switch_cr3_cr4() serializes. */\n        switch_cr3_cr4(v->arch.cr3, new_cr4);\n        cpu_info->pv_cr3 = 0;\n    }\n}", "target": 2, "idx": 11740}
{"commit_id": "69a679cc3a9c087064b7e9521b9e9f3c40dd0b72", "project": "wireshark", "func": "static gint\nhiqnet_display_data(proto_tree *hiqnet_payload_tree, packet_info *pinfo, tvbuff_t *tvb, gint offset) {\n    guint8 datatype = 0;\n    gint datalen = 0;\n    proto_item* ti;\n\n    datatype = tvb_get_guint8(tvb, offset);\n    ti = proto_tree_add_item(hiqnet_payload_tree, hf_hiqnet_datatype, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset += 1;\n    if (datatype < sizeof(hiqnet_datasize_per_type)/sizeof(int))\n        datalen = hiqnet_datasize_per_type[datatype];\n    else\n        expert_add_info(pinfo, ti, &ei_hiqnet_datatype);\n    if (datalen < 0) { /* This is a string or a block */\n        datalen = tvb_get_ntohs(tvb, offset);\n        proto_tree_add_item(hiqnet_payload_tree, hf_hiqnet_datalen, tvb, offset, 2, ENC_BIG_ENDIAN);\n        offset += 2;\n    }\n    if (datatype == 9) { /* This is a string */\n        proto_tree_add_item(hiqnet_payload_tree, hf_hiqnet_string, tvb, offset, datalen, ENC_UCS_2);\n    } else {\n        proto_tree_add_item(hiqnet_payload_tree, hf_hiqnet_value, tvb, offset, datalen, ENC_NA);\n    }\n    offset += datalen;\n    return offset;\n}", "target": 1, "idx": 11741}
{"commit_id": "8423f0b6d513b259fdab9c9bf4aaa6188d054c2d", "project": "torvalds/linux", "func": "static int snd_pcm_oss_sync(struct snd_pcm_oss_file *pcm_oss_file)\n{\n\tint err = 0;\n\tunsigned int saved_f_flags;\n\tstruct snd_pcm_substream *substream;\n\tstruct snd_pcm_runtime *runtime;\n\tsnd_pcm_format_t format;\n\tunsigned long width;\n\tsize_t size;\n\n\tsubstream = pcm_oss_file->streams[SNDRV_PCM_STREAM_PLAYBACK];\n\tif (substream != NULL) {\n\t\truntime = substream->runtime;\n\t\tif (atomic_read(&substream->mmap_count))\n\t\t\tgoto __direct;\n\t\tatomic_inc(&runtime->oss.rw_ref);\n\t\tif (mutex_lock_interruptible(&runtime->oss.params_lock)) {\n\t\t\tatomic_dec(&runtime->oss.rw_ref);\n\t\t\treturn -ERESTARTSYS;\n\t\t}\n\t\terr = snd_pcm_oss_make_ready_locked(substream);\n\t\tif (err < 0)\n\t\t\tgoto unlock;\n\t\tformat = snd_pcm_oss_format_from(runtime->oss.format);\n\t\twidth = snd_pcm_format_physical_width(format);\n\t\tif (runtime->oss.buffer_used > 0) {\n#ifdef OSS_DEBUG\n\t\t\tpcm_dbg(substream->pcm, \"sync: buffer_used\\n\");\n#endif\n\t\t\tsize = (8 * (runtime->oss.period_bytes - runtime->oss.buffer_used) + 7) / width;\n\t\t\tsnd_pcm_format_set_silence(format,\n\t\t\t\t\t\t   runtime->oss.buffer + runtime->oss.buffer_used,\n\t\t\t\t\t\t   size);\n\t\t\terr = snd_pcm_oss_sync1(substream, runtime->oss.period_bytes);\n\t\t\tif (err < 0)\n\t\t\t\tgoto unlock;\n\t\t} else if (runtime->oss.period_ptr > 0) {\n#ifdef OSS_DEBUG\n\t\t\tpcm_dbg(substream->pcm, \"sync: period_ptr\\n\");\n#endif\n\t\t\tsize = runtime->oss.period_bytes - runtime->oss.period_ptr;\n\t\t\tsnd_pcm_format_set_silence(format,\n\t\t\t\t\t\t   runtime->oss.buffer,\n\t\t\t\t\t\t   size * 8 / width);\n\t\t\terr = snd_pcm_oss_sync1(substream, size);\n\t\t\tif (err < 0)\n\t\t\t\tgoto unlock;\n\t\t}\n\t\t/*\n\t\t * The ALSA's period might be a bit large than OSS one.\n\t\t * Fill the remain portion of ALSA period with zeros.\n\t\t */\n\t\tsize = runtime->control->appl_ptr % runtime->period_size;\n\t\tif (size > 0) {\n\t\t\tsize = runtime->period_size - size;\n\t\t\tif (runtime->access == SNDRV_PCM_ACCESS_RW_INTERLEAVED)\n\t\t\t\tsnd_pcm_lib_write(substream, NULL, size);\n\t\t\telse if (runtime->access == SNDRV_PCM_ACCESS_RW_NONINTERLEAVED)\n\t\t\t\tsnd_pcm_lib_writev(substream, NULL, size);\n\t\t}\nunlock:\n\t\tmutex_unlock(&runtime->oss.params_lock);\n\t\tatomic_dec(&runtime->oss.rw_ref);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\t/*\n\t\t * finish sync: drain the buffer\n\t\t */\n\t      __direct:\n\t\tsaved_f_flags = substream->f_flags;\n\t\tsubstream->f_flags &= ~O_NONBLOCK;\n\t\terr = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_DRAIN, NULL);\n\t\tsubstream->f_flags = saved_f_flags;\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tmutex_lock(&runtime->oss.params_lock);\n\t\truntime->oss.prepare = 1;\n\t\tmutex_unlock(&runtime->oss.params_lock);\n\t}\n\n\tsubstream = pcm_oss_file->streams[SNDRV_PCM_STREAM_CAPTURE];\n\tif (substream != NULL) {\n\t\terr = snd_pcm_oss_make_ready(substream);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\truntime = substream->runtime;\n\t\terr = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_DROP, NULL);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tmutex_lock(&runtime->oss.params_lock);\n\t\truntime->oss.buffer_used = 0;\n\t\truntime->oss.prepare = 1;\n\t\tmutex_unlock(&runtime->oss.params_lock);\n\t}\n\treturn 0;\n}", "target": 1, "idx": 11742}
{"commit_id": "659b830aef88753d7b1ba67230d30add31f7d24e", "project": "wireshark", "func": "static int\ndissect_tipc(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\n{\n\tproto_item *ti, *item;\n\tproto_tree *tipc_tree, *tipc_data_tree;\n\tint offset = 0;\n\tguint32 srcport, destport = 0, dword;\n\tguint8  version;\n\tguint32 msg_size;\n\tguint8  hdr_size;\n\tguint8  user;\n\tgchar  *addr_str_ptr;\n\ttvbuff_t *data_tvb, *tipc_tvb;\n\tgboolean datatype_hdr = FALSE;\n\tguint8   msg_type = 0;\n\n\t/* Make entry in Protocol column on summary display */\n\tcol_set_str(pinfo->cinfo, COL_PROTOCOL, \"TIPC\");\n\n\tcol_clear(pinfo->cinfo, COL_INFO);\n\n\ttop_tree = tree;\n\tdword = tvb_get_ntohl(tvb, offset);\n\tversion = (dword >>29) & 0xf;\n\thdr_size = (dword >>21) & 0xf;\n\tuser = (dword>>25) & 0xf;\n\tmsg_size = dword & 0x1ffff;\n\n\tunsigned recursion_depth = p_get_proto_depth(pinfo, proto_tipc);\n\tif (++recursion_depth >= TIPC_MAX_RECURSION_DEPTH) {\n\t\tproto_tree_add_expert(tree, pinfo, &ei_tipc_max_recursion_depth_reached, tvb, 0, 0);\n\t\treturn tvb_captured_length(tvb);\n\t}\n\tp_set_proto_depth(pinfo, proto_tipc, recursion_depth);\n\n\tif ((guint32)tvb_reported_length_remaining(tvb, offset) < msg_size) {\n\t\ttipc_tvb = tvb;\n\t} else {\n\t\ttipc_tvb = tvb_new_subset_length(tvb, offset, msg_size);\n\t}\n\t/* user == 7 only works for v2, this will decode the legacy TIPC configuration protocol */\n\tif (user == TIPCv2_LINK_PROTOCOL) version = TIPCv2;\n\t/* Set User values in COL INFO different in V1 and V2 */\n\tswitch (version) {\n\t\tcase 0:\n\t\tcase TIPCv1:\n\t\t\tmsg_type = tvb_get_guint8(tipc_tvb, offset + 20)>>4;\n\t\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \" %s(%u) \", val_to_str_const(user, tipc_user_values, \"unknown\"), user);\n\t\t\t/* Set msg type in info col and find out if it's a data hdr or not */\n\t\t\tdatatype_hdr = tipc_v1_set_col_msgtype(pinfo, user, msg_type);\n\t\t\tif (datatype_hdr) {\n\t\t\t\t/* Data type header */\n\t\t\t\tif (hdr_size > 5 && user <4) {\n\t\t\t\t\t/* W6 Originating Processor */\n\t\t\t\t\tset_address_tvb(&pinfo->src, tipc_address_type, 4, tipc_tvb, offset + 24);\n\n\t\t\t\t\t/* W7 Destination Processor */\n\t\t\t\t\tset_address_tvb(&pinfo->dst, tipc_address_type, 4, tipc_tvb, offset + 28);\n\t\t\t\t} else {\n\t\t\t\t\t/* Short data hdr */\n\t\t\t\t\t/* W2 Previous Processor */\n\t\t\t\t\tset_address_tvb(&pinfo->src, tipc_address_type, 4, tipc_tvb, offset + 8);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* W2 Previous Processor */\n\t\t\t\tset_address_tvb(&pinfo->src, tipc_address_type, 4, tipc_tvb, offset + 8);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIPCv2:\n\t\t\tmsg_type = tvb_get_guint8(tipc_tvb, offset + 4)>>5;\n\t\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \"%-12s\", val_to_str_const(user, tipcv2_user_short_str_vals, \"unknown\"));\n\t\t\t/* Set msg type in info col */\n\t\t\ttipc_v2_set_info_col(tvb, pinfo, user, msg_type, hdr_size);\n\n\t\t\t/* find out if it's a data hdr or not */\n\t\t\tswitch (user) {\n\t\t\t\tcase TIPCv2_DATA_LOW:\n\t\t\t\tcase TIPCv2_DATA_NORMAL:\n\t\t\t\tcase TIPCv2_DATA_HIGH:\n\t\t\t\tcase TIPCv2_DATA_NON_REJECTABLE:\n\t\t\t\t\tdatatype_hdr = TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tdatatype_hdr = FALSE;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (datatype_hdr) {\n\t\t\t\tif (hdr_size > 6) {\n\t\t\t\t\t/* W6 Originating Processor */\n\t\t\t\t\tset_address_tvb(&pinfo->src, tipc_address_type, 4, tipc_tvb, offset + 24);\n\n\t\t\t\t\t/* W7 Destination Processor */\n\t\t\t\t\tset_address_tvb(&pinfo->dst, tipc_address_type, 4, tipc_tvb, offset + 28);\n\t\t\t\t} else {\n\t\t\t\t\t/* W3 Previous Processor */\n\t\t\t\t\tset_address_tvb(&pinfo->src, tipc_address_type, 4, tipc_tvb, offset + 12);\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tif (user != TIPCv2_NEIGHBOUR_DISCOVERY) {\n\t\t\t\t\t/* W6 Originating Processor */\n\t\t\t\t\tset_address_tvb(&pinfo->src, tipc_address_type, 4, tipc_tvb, offset + 24);\n\n\t\t\t\t\t/* W7 Destination Processor */\n\t\t\t\t\tset_address_tvb(&pinfo->dst, tipc_address_type, 4, tipc_tvb, offset + 28);\n\t\t\t\t} else {\n\t\t\t\t\t/* W2 Destination Domain */\n\t\t\t\t\tset_address_tvb(&pinfo->dst, tipc_address_type, 4, tipc_tvb, offset + 8);\n\n\t\t\t\t\t/* W3 Previous Node */\n\t\t\t\t\tset_address_tvb(&pinfo->src, tipc_address_type, 4, tipc_tvb, offset + 12);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tti = proto_tree_add_item(tree, proto_tipc, tipc_tvb, offset, -1, ENC_NA);\n\ttipc_tree = proto_item_add_subtree(ti, ett_tipc);\n\tif (version == TIPCv2) {\n\t\tdissect_tipc_v2(tipc_tvb, tipc_tree, pinfo, offset, user, msg_size, hdr_size, datatype_hdr);\n\t\tp_set_proto_depth(pinfo, proto_tipc, recursion_depth - 1);\n\t\treturn tvb_captured_length(tvb);\n\t}\n\n\t/* Word 0-2 common for all messages */\n\t/* Word 0 */\n\tproto_tree_add_item(tipc_tree, hf_tipc_ver, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\tproto_tree_add_item(tipc_tree, hf_tipc_usr, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\titem = proto_tree_add_item(tipc_tree, hf_tipc_hdr_size, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\tproto_item_append_text(item, \" = %u bytes\", (hdr_size * 4));\n\tproto_tree_add_item(tipc_tree, hf_tipc_nonsequenced, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\tproto_tree_add_item(tipc_tree, hf_tipc_unused, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\tif (datatype_hdr) {\n\t\tproto_tree_add_item(tipc_tree, hf_tipc_destdrop, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\tproto_tree_add_item(tipc_tree, hf_tipcv2_srcdrop, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\t}\n\n\tproto_tree_add_item(tipc_tree, hf_tipc_msg_size, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\toffset = offset + 4;\n\n\t/* Word 1 */\n\tproto_tree_add_item(tipc_tree, hf_tipc_ack_link_lev_seq, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\tproto_tree_add_item(tipc_tree, hf_tipc_link_lev_seq, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\toffset = offset + 4;\n\n\t/* Word 2 */\n\tdword = tvb_get_ntohl(tipc_tvb, offset);\n\taddr_str_ptr = tipc_addr_to_str(dword);\n\tproto_tree_add_string(tipc_tree, hf_tipc_prev_proc, tipc_tvb, offset, 4, addr_str_ptr);\n\n\toffset = offset + 4;\n\tswitch (user) {\n\t\tcase TIPC_ROUTING_MANAGER:\n\t\tcase TIPC_LINK_PROTOCOL:\n\t\tcase TIPC_CHANGEOVER_PROTOCOL:\n\t\tcase TIPC_SEGMENTATION_MANAGER:\n\t\tcase TIPC_MSG_BUNDLER:\n\t\t\tdissect_tipc_int_prot_msg(tipc_tvb, pinfo, tipc_tree, offset, user, msg_size);\n\t\t\tp_set_proto_depth(pinfo, proto_tipc, recursion_depth - 1);\n\t\t\treturn tvb_captured_length(tvb);\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tproto_tree_add_item_ret_uint(tipc_tree, hf_tipc_org_port, tipc_tvb, offset, 4, ENC_BIG_ENDIAN, &srcport);\n\toffset = offset + 4;\n\tif (user != TIPC_NAME_DISTRIBUTOR) {\n\t\tproto_tree_add_item_ret_uint(tipc_tree, hf_tipc_dst_port, tipc_tvb, offset, 4, ENC_BIG_ENDIAN, &destport);\n\t}\n\n\tconversation_set_conv_addr_port_endpoints(pinfo, &pinfo->src, &pinfo->dst, CONVERSATION_TIPC, srcport, destport);\n\n\toffset = offset + 4;\n\t/* 20 - 24 Bytes\n\t   20 bytes: Used in subnetwork local, connection oriented messages, where error code, reroute\n\t   counter and activity identity are zero. A recipient finding that the header size field is 20 does\n\t   by default know both user (DATA), message type (CONNECTED_MSG), error code\n\t   (MSG_OK), reroute counter (0), and activity identity (undefined). Since no more testing for\n\t   this is needed these fields can be left out in the header. Furthermore, since such messages\n\t   only will do zero or one inter-processor hop, we know that previous processor is the real\n\t   origin of the message. Hence the field originating processor can be omitted. For the same\n\t   reason, the recipient processor will know that it is identical to destination processor, so even\n\t   this field can be skipped. Finally, because the link layer guarantees delivery and sequence\n\t   order for this single hop, even the connection sequence number is redundant. So the message\n\t   can just be passed directly on to the destination port. Since this type of message statistically\n\t   should be by far the most frequent one this small optimization pays off.\n\t   */\n\tif (hdr_size <= 6) {\n\t\tproto_tree_add_item(tipc_tree, hf_tipc_data, tipc_tvb, offset, -1, ENC_NA);\n\t} else {\n\t\tswitch (user) {\n\t\t\tcase TIPC_NAME_DISTRIBUTOR:\n\t\t\t\tproto_tree_add_item(tipc_tree, hf_tipc_nd_msg_type, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\t\t\tbreak;\n\t\t\tcase TIPC_CONNECTION_MANAGER:\n\t\t\t\tproto_tree_add_item(tipc_tree, hf_tipc_cm_msg_type, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tproto_tree_add_item(tipc_tree, hf_tipc_data_msg_type, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\t\t\tbreak;\n\t\t}\n\t\tproto_tree_add_item(tipc_tree, hf_tipc_err_code, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\tproto_tree_add_item(tipc_tree, hf_tipc_reroute_cnt, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\tproto_tree_add_item(tipc_tree, hf_tipc_act_id, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\toffset = offset + 4;\n\n\t\tdword = tvb_get_ntohl(tipc_tvb, offset);\n\t\taddr_str_ptr = tipc_addr_to_str(dword);\n\n\t\tproto_tree_add_string(tipc_tree, hf_tipc_org_proc, tipc_tvb, offset, 4, addr_str_ptr);\n\t\toffset = offset + 4;\n\n\t\tdword = tvb_get_ntohl(tipc_tvb, offset);\n\t\taddr_str_ptr = tipc_addr_to_str(dword);\n\n\t\tproto_tree_add_string(tipc_tree, hf_tipc_dst_proc, tipc_tvb, offset, 4, addr_str_ptr);\n\t\toffset = offset + 4;\n\t\t/* 32 bytes\n\t\t   32 bytes: The size of all data messages containing an explicit port identity as destination\n\t\t   address.\n\t\t   */\n\t\tif (hdr_size > 8) {\n\t\t\tif (user == TIPC_NAME_DISTRIBUTOR) {\n\t\t\t\t/*\n\t\t\t\t   Although an internal service, the name distributor uses the full 40-byte \"external\" data header\n\t\t\t\t   format when updating the naming table instances. This is because its messages may need\n\t\t\t\t   routing, - all system processor must contain the publications from all device processors and\n\t\t\t\t   vice versa, whether they are directly linked or not. The fields name type, name instance, and\n\t\t\t\t   destination port of that header have no meaning for such messages\n\t\t\t\t   */\n\t\t\t\toffset = offset + 8;\n\t\t\t\ttipc_data_tree = proto_tree_add_subtree_format(tipc_tree, tvb, offset, -1, ett_tipc_data, NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"TIPC_NAME_DISTRIBUTOR %u bytes User Data\", (msg_size - hdr_size*4));\n\t\t\t\tdata_tvb = tvb_new_subset_remaining(tipc_tvb, offset);\n\t\t\t\tdissect_tipc_name_dist_data(data_tvb, pinfo, tipc_data_tree, 0);\n\t\t\t\tp_set_proto_depth(pinfo, proto_tipc, recursion_depth - 1);\n\t\t\t\treturn tvb_captured_length(tvb);\n\t\t\t} else {\n\t\t\t\t/* Port name type / Connection level sequence number */\n\t\t\t\tproto_tree_add_item(tipc_tree, hf_tipc_port_name_type, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\t\t\toffset = offset + 4;\n\t\t\t\t/* Port name instance */\n\t\t\t\tproto_tree_add_item(tipc_tree, hf_tipc_port_name_instance, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\t\t\toffset = offset + 4;\n\t\t\t}\n\t\t}\n\n\t\tif (user < 4 && dissect_tipc_data) { /* DATA type user */\n\t\t\ttvbuff_t *next_tvb;\n\t\t\tguint32 msg_type32 = msg_type;\n\t\t\tguint32 *name_type_p = &msg_type32;\n\t\t\tswitch (msg_type) {\n\t\t\t\tcase TIPC_CONNECTED_MSG:\n\t\t\t\t\tproto_tree_add_item(tipc_tree, hf_tipc_data, tipc_tvb, offset, -1, ENC_NA);\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIPC_NAMED_MSG:\n\t\t\t\t\tproto_tree_add_item(tipc_tree, hf_tipc_named_msg_hdr, tipc_tvb, offset, 14, ENC_NA);\n\t\t\t\t\tproto_tree_add_item(tipc_tree, hf_tipc_data, tipc_tvb, offset+14, -1, ENC_NA);\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIPC_DIRECT_MSG:\n\t\t\t\t\tproto_tree_add_item(tipc_tree, hf_tipc_data, tipc_tvb, offset, -1, ENC_NA);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tproto_tree_add_item(tipc_tree, hf_tipc_data, tipc_tvb, offset, -1, ENC_NA);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* tipc data type user doesn't change format, reuse v2 function */\n\t\t\tnext_tvb = tvb_new_subset_remaining(tvb, offset);\n\t\t\tcall_tipc_v2_data_subdissectors(next_tvb, pinfo, name_type_p, user);\n\t\t}\n\t} /*if (hdr_size <= 5) */\n\n\tp_set_proto_depth(pinfo, proto_tipc, recursion_depth - 1);\n\treturn tvb_captured_length(tvb);\n}", "target": 2, "idx": 11743}
{"commit_id": "f68a98a9d385838a1c73ec960a14102949940a64", "project": "ImageMagick", "func": "static MagickBooleanType ReadPSDLayersInternal(Image *image,\n  const ImageInfo *image_info,const PSDInfo *psd_info,\n  const MagickBooleanType skip_layers,ExceptionInfo *exception)\n{\n  char\n    type[4];\n\n  LayerInfo\n    *layer_info;\n\n  MagickSizeType\n    size;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count,\n    j,\n    number_layers;\n\n  size=GetPSDSize(psd_info,image);\n  if (size == 0)\n    {\n      /*\n        Skip layers & masks.\n      */\n      (void) ReadBlobLong(image);\n      count=ReadBlob(image,4,(unsigned char *) type);\n      ReversePSDString(image,type,4);\n      status=MagickFalse;\n      if ((count == 0) || (LocaleNCompare(type,\"8BIM\",4) != 0))\n        return(MagickTrue);\n      else\n        {\n          count=ReadBlob(image,4,(unsigned char *) type);\n          ReversePSDString(image,type,4);\n          if ((count != 0) && (LocaleNCompare(type,\"Lr16\",4) == 0))\n            size=GetPSDSize(psd_info,image);\n          else\n            return(MagickTrue);\n        }\n    }\n  status=MagickTrue;\n  if (size != 0)\n    {\n      layer_info=(LayerInfo *) NULL;\n      number_layers=(short) ReadBlobShort(image);\n\n      if (number_layers < 0)\n        {\n          /*\n            The first alpha channel in the merged result contains the\n            transparency data for the merged result.\n          */\n          number_layers=MagickAbsoluteValue(number_layers);\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  negative layer count corrected for\");\n          image->matte=MagickTrue;\n        }\n\n      /*\n        We only need to know if the image has an alpha channel\n      */\n      if (skip_layers != MagickFalse)\n        return(MagickTrue);\n\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  image contains %.20g layers\",(double) number_layers);\n\n      if (number_layers == 0)\n        ThrowBinaryException(CorruptImageError,\"InvalidNumberOfLayers\",\n          image->filename);\n\n      layer_info=(LayerInfo *) AcquireQuantumMemory((size_t) number_layers,\n        sizeof(*layer_info));\n      if (layer_info == (LayerInfo *) NULL)\n        {\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  allocation of LayerInfo failed\");\n          ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n            image->filename);\n        }\n      (void) ResetMagickMemory(layer_info,0,(size_t) number_layers*\n        sizeof(*layer_info));\n\n      for (i=0; i < number_layers; i++)\n      {\n        ssize_t\n          x,\n          y;\n\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  reading layer #%.20g\",(double) i+1);\n        layer_info[i].page.y=ReadBlobSignedLong(image);\n        layer_info[i].page.x=ReadBlobSignedLong(image);\n        y=ReadBlobSignedLong(image);\n        x=ReadBlobSignedLong(image);\n        layer_info[i].page.width=(size_t) (x-layer_info[i].page.x);\n        layer_info[i].page.height=(size_t) (y-layer_info[i].page.y);\n        layer_info[i].channels=ReadBlobShort(image);\n        if (layer_info[i].channels > MaxPSDChannels)\n          {\n            layer_info=DestroyLayerInfo(layer_info,number_layers);\n            ThrowBinaryException(CorruptImageError,\"MaximumChannelsExceeded\",\n              image->filename);\n          }\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    offset(%.20g,%.20g), size(%.20g,%.20g), channels=%.20g\",\n            (double) layer_info[i].page.x,(double) layer_info[i].page.y,\n            (double) layer_info[i].page.height,(double)\n            layer_info[i].page.width,(double) layer_info[i].channels);\n        for (j=0; j < (ssize_t) layer_info[i].channels; j++)\n        {\n          layer_info[i].channel_info[j].type=(short) ReadBlobShort(image);\n          layer_info[i].channel_info[j].size=(size_t) GetPSDSize(psd_info,\n            image);\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    channel[%.20g]: type=%.20g, size=%.20g\",(double) j,\n              (double) layer_info[i].channel_info[j].type,\n              (double) layer_info[i].channel_info[j].size);\n        }\n        count=ReadBlob(image,4,(unsigned char *) type);\n        ReversePSDString(image,type,4);\n        if ((count == 0) || (LocaleNCompare(type,\"8BIM\",4) != 0))\n          {\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  layer type was %.4s instead of 8BIM\", type);\n            layer_info=DestroyLayerInfo(layer_info,number_layers);\n            ThrowBinaryException(CorruptImageError,\"ImproperImageHeader\",\n              image->filename);\n          }\n        (void) ReadBlob(image,4,(unsigned char *) layer_info[i].blendkey);\n        ReversePSDString(image,layer_info[i].blendkey,4);\n        layer_info[i].opacity=(Quantum) ScaleCharToQuantum((unsigned char)\n          ReadBlobByte(image));\n        layer_info[i].clipping=(unsigned char) ReadBlobByte(image);\n        layer_info[i].flags=(unsigned char) ReadBlobByte(image);\n        layer_info[i].visible=!(layer_info[i].flags & 0x02);\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   blend=%.4s, opacity=%.20g, clipping=%s, flags=%d, visible=%s\",\n            layer_info[i].blendkey,(double) layer_info[i].opacity,\n            layer_info[i].clipping ? \"true\" : \"false\",layer_info[i].flags,\n            layer_info[i].visible ? \"true\" : \"false\");\n        (void) ReadBlobByte(image);  /* filler */\n\n        size=ReadBlobLong(image);\n        if (size != 0)\n          {\n            MagickSizeType\n              combined_length,\n              length;\n\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    layer contains additional info\");\n            length=ReadBlobLong(image);\n            combined_length=length+4;\n            if (length != 0)\n              {\n                /*\n                  Layer mask info.\n                */\n                layer_info[i].mask.page.y=ReadBlobSignedLong(image);\n                layer_info[i].mask.page.x=ReadBlobSignedLong(image);\n                layer_info[i].mask.page.height=(size_t) (ReadBlobSignedLong(image)-\n                  layer_info[i].mask.page.y);\n                layer_info[i].mask.page.width=(size_t) (ReadBlobSignedLong(image)-\n                  layer_info[i].mask.page.x);\n                layer_info[i].mask.background=(unsigned char) ReadBlobByte(\n                  image);\n                layer_info[i].mask.flags=(unsigned char) ReadBlobByte(image);\n                if (!(layer_info[i].mask.flags & 0x01))\n                  {\n                    layer_info[i].mask.page.y=layer_info[i].mask.page.y-\n                      layer_info[i].page.y;\n                    layer_info[i].mask.page.x=layer_info[i].mask.page.x-\n                      layer_info[i].page.x;\n                  }\n                if (image->debug != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      layer mask: offset(%.20g,%.20g), size(%.20g,%.20g), length=%.20g\",\n                    (double) layer_info[i].mask.page.x,(double)\n                    layer_info[i].mask.page.y,(double) layer_info[i].mask.page.width,\n                    (double) layer_info[i].mask.page.height,(double)\n                    ((MagickOffsetType) length)-18);\n                /*\n                  Skip over the rest of the layer mask information.\n                */\n                if (DiscardBlobBytes(image,(MagickSizeType) (length-18)) == MagickFalse)\n                  {\n                    layer_info=DestroyLayerInfo(layer_info,number_layers);\n                    ThrowBinaryException(CorruptImageError,\"UnexpectedEndOfFile\",\n                      image->filename);\n                  }\n              }\n            length=ReadBlobLong(image);\n            combined_length+=length+4;\n            if (length != 0)\n              {\n                /*\n                  Layer blending ranges info.\n                */\n                if (image->debug != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      layer blending ranges: length=%.20g\",(double)\n                    ((MagickOffsetType) length));\n                /*\n                  We read it, but don't use it...\n                */\n                for (j=0; j < (ssize_t) length; j+=8)\n                {\n                  size_t blend_source=ReadBlobLong(image);\n                  size_t blend_dest=ReadBlobLong(image);\n                  if (EOFBlob(image) != MagickFalse)\n                    {\n                      layer_info=DestroyLayerInfo(layer_info,number_layers);\n                      ThrowBinaryException(CorruptImageError,\n                        \"InsufficientImageDataInFile\",image->filename);\n                    }\n                  if (image->debug != MagickFalse)\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"        source(%x), dest(%x)\",(unsigned int)\n                      blend_source,(unsigned int) blend_dest);\n                }\n              }\n            /*\n              Layer name.\n            */\n            length=(MagickSizeType) (unsigned char) ReadBlobByte(image);\n            combined_length+=length+1;\n            if (length > 0)\n              (void) ReadBlob(image,(size_t) length++,layer_info[i].name);\n            layer_info[i].name[length]='\\0';\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"      layer name: %s\",layer_info[i].name);\n            if ((length % 4) != 0)\n              {\n                length=4-(length % 4);\n                combined_length+=length;\n                /* Skip over the padding of the layer name */\n                if (DiscardBlobBytes(image,length) == MagickFalse)\n                  {\n                    layer_info=DestroyLayerInfo(layer_info,number_layers);\n                    ThrowBinaryException(CorruptImageError,\n                      \"UnexpectedEndOfFile\",image->filename);\n                  }\n              }\n            length=(MagickSizeType) size-combined_length;\n            if (length > 0)\n              {\n                unsigned char\n                  *info;\n\n                if (length > GetBlobSize(image))\n                  {\n                    layer_info=DestroyLayerInfo(layer_info,number_layers);\n                    ThrowBinaryException(CorruptImageError,\n                      \"InsufficientImageDataInFile\",image->filename);\n                  }\n                layer_info[i].info=AcquireStringInfo((const size_t) length);\n                info=GetStringInfoDatum(layer_info[i].info);\n                (void) ReadBlob(image,(const size_t) length,info);\n              }\n          }\n      }\n\n      for (i=0; i < number_layers; i++)\n      {\n        if ((layer_info[i].page.width == 0) ||\n              (layer_info[i].page.height == 0))\n          {\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"      layer data is empty\");\n            if (layer_info[i].info != (StringInfo *) NULL)\n              layer_info[i].info=DestroyStringInfo(layer_info[i].info);\n            continue;\n          }\n\n        /*\n          Allocate layered image.\n        */\n        layer_info[i].image=CloneImage(image,layer_info[i].page.width,\n          layer_info[i].page.height,MagickFalse,exception);\n        if (layer_info[i].image == (Image *) NULL)\n          {\n            layer_info=DestroyLayerInfo(layer_info,number_layers);\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  allocation of image for layer %.20g failed\",(double) i);\n            ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n              image->filename);\n          }\n\n        if (layer_info[i].info != (StringInfo *) NULL)\n          {\n            (void) SetImageProfile(layer_info[i].image,\"psd:additional-info\",\n              layer_info[i].info);\n            layer_info[i].info=DestroyStringInfo(layer_info[i].info);\n          }\n      }\n\n      if (image_info->ping == MagickFalse)\n        {\n          for (i=0; i < number_layers; i++)\n          {\n            if (layer_info[i].image == (Image *) NULL)\n              {\n                for (j=0; j < layer_info[i].channels; j++)\n                {\n                  if (DiscardBlobBytes(image,(MagickSizeType)\n                      layer_info[i].channel_info[j].size) == MagickFalse)\n                    {\n                      layer_info=DestroyLayerInfo(layer_info,number_layers);\n                      ThrowBinaryException(CorruptImageError,\n                        \"UnexpectedEndOfFile\",image->filename);\n                    }\n                }\n                continue;\n              }\n\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  reading data for layer %.20g\",(double) i);\n            status=ReadPSDLayer(image,image_info,psd_info,&layer_info[i],\n              exception);\n            if (status == MagickFalse)\n              break;\n\n            status=SetImageProgress(image,LoadImagesTag,i,(MagickSizeType)\n              number_layers);\n            if (status == MagickFalse)\n              break;\n          }\n        }\n\n      if (status != MagickFalse)\n        {\n          for (i=0; i < number_layers; i++)\n          {\n            if (layer_info[i].image == (Image *) NULL)\n              {\n                for (j=i; j < number_layers - 1; j++)\n                  layer_info[j] = layer_info[j+1];\n                number_layers--;\n                i--;\n              }\n          }\n\n          if (number_layers > 0)\n            {\n              for (i=0; i < number_layers; i++)\n              {\n                if (i > 0)\n                  layer_info[i].image->previous=layer_info[i-1].image;\n                if (i < (number_layers-1))\n                  layer_info[i].image->next=layer_info[i+1].image;\n                layer_info[i].image->page=layer_info[i].page;\n              }\n              image->next=layer_info[0].image;\n              layer_info[0].image->previous=image;\n            }\n          layer_info=(LayerInfo *) RelinquishMagickMemory(layer_info);\n        }\n      else\n        layer_info=DestroyLayerInfo(layer_info,number_layers);\n    }\n\n  return(status);\n}", "target": 1, "idx": 11744}
{"commit_id": "d7325bac173492b358417a0ad49fabad44447d52", "project": "ImageMagick", "func": "static inline void VectorClamp3(DDSVector3 *value)\n{\n  value->x = MagickMin(1.0f,MagickMax(0.0f,value->x));\n  value->y = MagickMin(1.0f,MagickMax(0.0f,value->y));\n  value->z = MagickMin(1.0f,MagickMax(0.0f,value->z));\n}", "target": 1, "idx": 11745}
{"commit_id": "19c47afbc402542720ddd280e1bbde3b2277b586", "project": "android", "func": "int SoundPool::load(const char* path, int priority __unused)\n{\n    ALOGV(\"load: path=%s, priority=%d\", path, priority);\n    int sampleID;\n    {\n        Mutex::Autolock lock(&mLock);\n        sampleID = ++mNextSampleID;\n        sp<Sample> sample = new Sample(sampleID, path);\n        mSamples.add(sampleID, sample);\n        sample->startLoad();\n    }\n    // mDecodeThread->loadSample() must be called outside of mLock.\n    // mDecodeThread->loadSample() may block on mDecodeThread message queue space;\n    // the message queue emptying may block on SoundPool::findSample().\n    //\n    // It theoretically possible that sample loads might decode out-of-order.\n    mDecodeThread->loadSample(sampleID);\n    return sampleID;\n}", "target": 2, "idx": 11746}
{"commit_id": "b3118cabb8060a8cc6a01c4e8264cb18e7b1745a", "project": "ceph", "func": "static optional<Principal> parse_principal(CephContext* cct, TokenID t,\n\t\t\t\t    string&& s) {\n  // Wildcard!\n  if ((t == TokenID::AWS) && (s == \"*\")) {\n    return Principal::wildcard();\n\n    // Do nothing for now.\n  } else if (t == TokenID::CanonicalUser) {\n\n    // AWS ARNs\n  } else if (t == TokenID::AWS) {\n    auto a = ARN::parse(s);\n    if (!a) {\n      if (std::none_of(s.begin(), s.end(),\n\t\t       [](const char& c) {\n\t\t\t return (c == ':') || (c == '/');\n\t\t       })) {\n\t// Since tenants are simply prefixes, there's no really good\n\t// way to see if one exists or not. So we return the thing and\n\t// let them try to match against it.\n\treturn Principal::tenant(std::move(s));\n      }\n    }\n\n    if (a->resource == \"root\") {\n      return Principal::tenant(std::move(a->account));\n    }\n\n    static const char rx_str[] = \"([^/]*)/(.*)\";\n    static const regex rx(rx_str, sizeof(rx_str) - 1,\n\t\t\t  ECMAScript | optimize);\n    smatch match;\n    if (regex_match(a->resource, match, rx)) {\n      if (match.size() != 3) {\n\treturn boost::none;\n      }\n\n      if (match[1] == \"user\") {\n\treturn Principal::user(std::move(a->account),\n\t\t\t       match[2]);\n      }\n\n      if (match[1] == \"role\") {\n\treturn Principal::role(std::move(a->account),\n\t\t\t       match[2]);\n      }\n    }\n  }\n\n  ldout(cct, 0) << \"Supplied principal is discarded: \" << s << dendl;\n  return boost::none;\n}", "target": 1, "idx": 11747}
{"commit_id": "29b0589a865b6f66d141d79b2dd1373e4e50fe17", "project": "torvalds/linux", "func": "static void ene_remove(struct pnp_dev *pnp_dev)\n{\n\tstruct ene_device *dev = pnp_get_drvdata(pnp_dev);\n\tunsigned long flags;\n\n\trc_unregister_device(dev->rdev);\n\tdel_timer_sync(&dev->tx_sim_timer);\n\tspin_lock_irqsave(&dev->hw_lock, flags);\n\tene_rx_disable(dev);\n\tene_rx_restore_hw_buffer(dev);\n\tspin_unlock_irqrestore(&dev->hw_lock, flags);\n\n\tfree_irq(dev->irq, dev);\n\trelease_region(dev->hw_io, ENE_IO_SIZE);\n\tkfree(dev);\n}", "target": 2, "idx": 11748}
{"commit_id": "d2099cc8f1adb33d427a44a5e32ed27b647c7168", "project": "nanopb", "func": "static bool checkreturn pb_dec_string(pb_istream_t *stream, const pb_field_t *field, void *dest)\n{\n    uint32_t size;\n    size_t alloc_size;\n    bool status;\n    if (!pb_decode_varint32(stream, &size))\n        return false;\n    \n    /* Space for null terminator */\n    alloc_size = size + 1;\n    \n    if (alloc_size < size)\n        PB_RETURN_ERROR(stream, \"size too large\");\n    \n    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)\n    {\n#ifndef PB_ENABLE_MALLOC\n        PB_RETURN_ERROR(stream, \"no malloc support\");\n#else\n        if (!allocate_field(stream, dest, alloc_size, 1))\n            return false;\n        dest = *(void**)dest;\n#endif\n    }\n    else\n    {\n        if (alloc_size > field->data_size)\n            PB_RETURN_ERROR(stream, \"string overflow\");\n    }\n    \n    status = pb_read(stream, (uint8_t*)dest, size);\n    *((uint8_t*)dest + size) = 0;\n    return status;\n}", "target": 3, "idx": 11749}
{"commit_id": "cc080e9e9be16ccf26135d366d7d2b65209f1d56", "project": "torvalds/linux", "func": "void fuse_conn_init(struct fuse_conn *fc)\n{\n\tmemset(fc, 0, sizeof(*fc));\n\tspin_lock_init(&fc->lock);\n\tinit_rwsem(&fc->killsb);\n\tatomic_set(&fc->count, 1);\n\tinit_waitqueue_head(&fc->blocked_waitq);\n\tinit_waitqueue_head(&fc->reserved_req_waitq);\n\tfuse_iqueue_init(&fc->iq);\n\tfuse_pqueue_init(&fc->pq);\n\tINIT_LIST_HEAD(&fc->bg_queue);\n\tINIT_LIST_HEAD(&fc->entry);\n\tINIT_LIST_HEAD(&fc->devices);\n\tatomic_set(&fc->num_waiting, 0);\n\tfc->max_background = FUSE_DEFAULT_MAX_BACKGROUND;\n\tfc->congestion_threshold = FUSE_DEFAULT_CONGESTION_THRESHOLD;\n\tfc->khctr = 0;\n\tfc->polled_files = RB_ROOT;\n\tfc->blocked = 0;\n\tfc->initialized = 0;\n\tfc->connected = 1;\n\tfc->attr_version = 1;\n\tget_random_bytes(&fc->scramble_key, sizeof(fc->scramble_key));\n}", "target": 1, "idx": 11750}
{"commit_id": "5e4da714f00f6bfb2ccd6d73d61329c6f3a08429", "project": "GNOME/glib", "func": "static void\ng_keyfile_settings_backend_constructed (GObject *object)\n{\n  GKeyfileSettingsBackend *kfsb = G_KEYFILE_SETTINGS_BACKEND (object);\n\n  if (kfsb->file == NULL)\n    {\n      char *filename = g_build_filename (g_get_user_config_dir (),\n                                         \"glib-2.0\", \"settings\", \"keyfile\",\n                                         NULL);\n      kfsb->file = g_file_new_for_path (filename);\n      g_free (filename);\n    }\n\n  if (kfsb->prefix == NULL)\n    {\n      kfsb->prefix = g_strdup (\"/\");\n      kfsb->prefix_len = 1;\n    }\n  \n  kfsb->keyfile = g_key_file_new ();\n  kfsb->permission = g_simple_permission_new (TRUE);\n\n  kfsb->dir = g_file_get_parent (kfsb->file);\n  g_mkdir_with_parents (g_file_peek_path (kfsb->dir), 0700);\n\n  kfsb->file_monitor = g_file_monitor (kfsb->file, G_FILE_MONITOR_NONE, NULL, NULL);\n  kfsb->dir_monitor = g_file_monitor (kfsb->dir, G_FILE_MONITOR_NONE, NULL, NULL);\n\n  compute_checksum (kfsb->digest, NULL, 0);\n\n  g_signal_connect (kfsb->file_monitor, \"changed\",\n                    G_CALLBACK (file_changed), kfsb);\n  g_signal_connect (kfsb->dir_monitor, \"changed\",\n                    G_CALLBACK (dir_changed), kfsb);\n\n  g_keyfile_settings_backend_keyfile_writable (kfsb);\n  g_keyfile_settings_backend_keyfile_reload (kfsb);\n\n  load_system_settings (kfsb);\n}", "target": 2, "idx": 11751}
{"commit_id": "a23325b2e583556eae88ed3f764e457786bf4df6", "project": "acpica", "func": "void\nAcpiNsTerminate (\n    void)\n{\n    ACPI_STATUS             Status;\n    ACPI_OPERAND_OBJECT     *Prev;\n    ACPI_OPERAND_OBJECT     *Next;\n\n\n    ACPI_FUNCTION_TRACE (NsTerminate);\n\n\n    /* Delete any module-level code blocks */\n\n    Next = AcpiGbl_ModuleCodeList;\n    while (Next)\n    {\n        Prev = Next;\n        Next = Next->Method.Mutex;\n        Prev->Method.Mutex = NULL; /* Clear the Mutex (cheated) field */\n        AcpiUtRemoveReference (Prev);\n    }\n\n    /*\n     * Free the entire namespace -- all nodes and all objects\n     * attached to the nodes\n     */\n    AcpiNsDeleteNamespaceSubtree (AcpiGbl_RootNode);\n\n    /* Delete any objects attached to the root node */\n\n    Status = AcpiUtAcquireMutex (ACPI_MTX_NAMESPACE);\n    if (ACPI_FAILURE (Status))\n    {\n        return_VOID;\n    }\n\n    AcpiNsDeleteNode (AcpiGbl_RootNode);\n    (void) AcpiUtReleaseMutex (ACPI_MTX_NAMESPACE);\n\n    ACPI_DEBUG_PRINT ((ACPI_DB_INFO, \"Namespace freed\\n\"));\n    return_VOID;\n}", "target": 2, "idx": 11752}
{"commit_id": "244d83bc3d859293f55812d48b3db168e581f6ab", "project": "nothings/stb", "func": "static int start_decoder(vorb *f)\n{\n   uint8 header[6], x,y;\n   int len,i,j,k, max_submaps = 0;\n   int longest_floorlist=0;\n\n   // first page, first packet\n\n   if (!start_page(f))                              return FALSE;\n   // validate page flag\n   if (!(f->page_flag & PAGEFLAG_first_page))       return error(f, VORBIS_invalid_first_page);\n   if (f->page_flag & PAGEFLAG_last_page)           return error(f, VORBIS_invalid_first_page);\n   if (f->page_flag & PAGEFLAG_continued_packet)    return error(f, VORBIS_invalid_first_page);\n   // check for expected packet length\n   if (f->segment_count != 1)                       return error(f, VORBIS_invalid_first_page);\n   if (f->segments[0] != 30)                        return error(f, VORBIS_invalid_first_page);\n   // read packet\n   // check packet header\n   if (get8(f) != VORBIS_packet_id)                 return error(f, VORBIS_invalid_first_page);\n   if (!getn(f, header, 6))                         return error(f, VORBIS_unexpected_eof);\n   if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_first_page);\n   // vorbis_version\n   if (get32(f) != 0)                               return error(f, VORBIS_invalid_first_page);\n   f->channels = get8(f); if (!f->channels)         return error(f, VORBIS_invalid_first_page);\n   if (f->channels > STB_VORBIS_MAX_CHANNELS)       return error(f, VORBIS_too_many_channels);\n   f->sample_rate = get32(f); if (!f->sample_rate)  return error(f, VORBIS_invalid_first_page);\n   get32(f); // bitrate_maximum\n   get32(f); // bitrate_nominal\n   get32(f); // bitrate_minimum\n   x = get8(f);\n   {\n      int log0,log1;\n      log0 = x & 15;\n      log1 = x >> 4;\n      f->blocksize_0 = 1 << log0;\n      f->blocksize_1 = 1 << log1;\n      if (log0 < 6 || log0 > 13)                       return error(f, VORBIS_invalid_setup);\n      if (log1 < 6 || log1 > 13)                       return error(f, VORBIS_invalid_setup);\n      if (log0 > log1)                                 return error(f, VORBIS_invalid_setup);\n   }\n\n   // framing_flag\n   x = get8(f);\n   if (!(x & 1))                                    return error(f, VORBIS_invalid_first_page);\n\n   // second packet!\n   if (!start_page(f))                              return FALSE;\n\n   if (!start_packet(f))                            return FALSE;\n   do {\n      len = next_segment(f);\n      skip(f, len);\n      f->bytes_in_seg = 0;\n   } while (len);\n\n   // third packet!\n   if (!start_packet(f))                            return FALSE;\n\n   #ifndef STB_VORBIS_NO_PUSHDATA_API\n   if (IS_PUSH_MODE(f)) {\n      if (!is_whole_packet_present(f, TRUE)) {\n         // convert error in ogg header to write type\n         if (f->error == VORBIS_invalid_stream)\n            f->error = VORBIS_invalid_setup;\n         return FALSE;\n      }\n   }\n   #endif\n\n   crc32_init(); // always init it, to avoid multithread race conditions\n\n   if (get8_packet(f) != VORBIS_packet_setup)       return error(f, VORBIS_invalid_setup);\n   for (i=0; i < 6; ++i) header[i] = get8_packet(f);\n   if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_setup);\n\n   // codebooks\n\n   f->codebook_count = get_bits(f,8) + 1;\n   f->codebooks = (Codebook *) setup_malloc(f, sizeof(*f->codebooks) * f->codebook_count);\n   if (f->codebooks == NULL)                        return error(f, VORBIS_outofmem);\n   memset(f->codebooks, 0, sizeof(*f->codebooks) * f->codebook_count);\n   for (i=0; i < f->codebook_count; ++i) {\n      uint32 *values;\n      int ordered, sorted_count;\n      int total=0;\n      uint8 *lengths;\n      Codebook *c = f->codebooks+i;\n      CHECK(f);\n      x = get_bits(f, 8); if (x != 0x42)            return error(f, VORBIS_invalid_setup);\n      x = get_bits(f, 8); if (x != 0x43)            return error(f, VORBIS_invalid_setup);\n      x = get_bits(f, 8); if (x != 0x56)            return error(f, VORBIS_invalid_setup);\n      x = get_bits(f, 8);\n      c->dimensions = (get_bits(f, 8)<<8) + x;\n      x = get_bits(f, 8);\n      y = get_bits(f, 8);\n      c->entries = (get_bits(f, 8)<<16) + (y<<8) + x;\n      ordered = get_bits(f,1);\n      c->sparse = ordered ? 0 : get_bits(f,1);\n\n      if (c->dimensions == 0 && c->entries != 0)    return error(f, VORBIS_invalid_setup);\n\n      if (c->sparse)\n         lengths = (uint8 *) setup_temp_malloc(f, c->entries);\n      else\n         lengths = c->codeword_lengths = (uint8 *) setup_malloc(f, c->entries);\n\n      if (!lengths) return error(f, VORBIS_outofmem);\n\n      if (ordered) {\n         int current_entry = 0;\n         int current_length = get_bits(f,5) + 1;\n         while (current_entry < c->entries) {\n            int limit = c->entries - current_entry;\n            int n = get_bits(f, ilog(limit));\n            if (current_entry + n > (int) c->entries) { return error(f, VORBIS_invalid_setup); }\n            memset(lengths + current_entry, current_length, n);\n            current_entry += n;\n            ++current_length;\n         }\n      } else {\n         for (j=0; j < c->entries; ++j) {\n            int present = c->sparse ? get_bits(f,1) : 1;\n            if (present) {\n               lengths[j] = get_bits(f, 5) + 1;\n               ++total;\n               if (lengths[j] == 32)\n                  return error(f, VORBIS_invalid_setup);\n            } else {\n               lengths[j] = NO_CODE;\n            }\n         }\n      }\n\n      if (c->sparse && total >= c->entries >> 2) {\n         // convert sparse items to non-sparse!\n         if (c->entries > (int) f->setup_temp_memory_required)\n            f->setup_temp_memory_required = c->entries;\n\n         c->codeword_lengths = (uint8 *) setup_malloc(f, c->entries);\n         if (c->codeword_lengths == NULL) return error(f, VORBIS_outofmem);\n         memcpy(c->codeword_lengths, lengths, c->entries);\n         setup_temp_free(f, lengths, c->entries); // note this is only safe if there have been no intervening temp mallocs!\n         lengths = c->codeword_lengths;\n         c->sparse = 0;\n      }\n\n      // compute the size of the sorted tables\n      if (c->sparse) {\n         sorted_count = total;\n      } else {\n         sorted_count = 0;\n         #ifndef STB_VORBIS_NO_HUFFMAN_BINARY_SEARCH\n         for (j=0; j < c->entries; ++j)\n            if (lengths[j] > STB_VORBIS_FAST_HUFFMAN_LENGTH && lengths[j] != NO_CODE)\n               ++sorted_count;\n         #endif\n      }\n\n      c->sorted_entries = sorted_count;\n      values = NULL;\n\n      CHECK(f);\n      if (!c->sparse) {\n         c->codewords = (uint32 *) setup_malloc(f, sizeof(c->codewords[0]) * c->entries);\n         if (!c->codewords)                  return error(f, VORBIS_outofmem);\n      } else {\n         unsigned int size;\n         if (c->sorted_entries) {\n            c->codeword_lengths = (uint8 *) setup_malloc(f, c->sorted_entries);\n            if (!c->codeword_lengths)           return error(f, VORBIS_outofmem);\n            c->codewords = (uint32 *) setup_temp_malloc(f, sizeof(*c->codewords) * c->sorted_entries);\n            if (!c->codewords)                  return error(f, VORBIS_outofmem);\n            values = (uint32 *) setup_temp_malloc(f, sizeof(*values) * c->sorted_entries);\n            if (!values)                        return error(f, VORBIS_outofmem);\n         }\n         size = c->entries + (sizeof(*c->codewords) + sizeof(*values)) * c->sorted_entries;\n         if (size > f->setup_temp_memory_required)\n            f->setup_temp_memory_required = size;\n      }\n\n      if (!compute_codewords(c, lengths, c->entries, values)) {\n         if (c->sparse) setup_temp_free(f, values, 0);\n         return error(f, VORBIS_invalid_setup);\n      }\n\n      if (c->sorted_entries) {\n         // allocate an extra slot for sentinels\n         c->sorted_codewords = (uint32 *) setup_malloc(f, sizeof(*c->sorted_codewords) * (c->sorted_entries+1));\n         if (c->sorted_codewords == NULL) return error(f, VORBIS_outofmem);\n         // allocate an extra slot at the front so that c->sorted_values[-1] is defined\n         // so that we can catch that case without an extra if\n         c->sorted_values    = ( int   *) setup_malloc(f, sizeof(*c->sorted_values   ) * (c->sorted_entries+1));\n         if (c->sorted_values == NULL) return error(f, VORBIS_outofmem);\n         ++c->sorted_values;\n         c->sorted_values[-1] = -1;\n         compute_sorted_huffman(c, lengths, values);\n      }\n\n      if (c->sparse) {\n         setup_temp_free(f, values, sizeof(*values)*c->sorted_entries);\n         setup_temp_free(f, c->codewords, sizeof(*c->codewords)*c->sorted_entries);\n         setup_temp_free(f, lengths, c->entries);\n         c->codewords = NULL;\n      }\n\n      compute_accelerated_huffman(c);\n\n      CHECK(f);\n      c->lookup_type = get_bits(f, 4);\n      if (c->lookup_type > 2) return error(f, VORBIS_invalid_setup);\n      if (c->lookup_type > 0) {\n         uint16 *mults;\n         c->minimum_value = float32_unpack(get_bits(f, 32));\n         c->delta_value = float32_unpack(get_bits(f, 32));\n         c->value_bits = get_bits(f, 4)+1;\n         c->sequence_p = get_bits(f,1);\n         if (c->lookup_type == 1) {\n            c->lookup_values = lookup1_values(c->entries, c->dimensions);\n         } else {\n            c->lookup_values = c->entries * c->dimensions;\n         }\n         if (c->lookup_values == 0) return error(f, VORBIS_invalid_setup);\n         mults = (uint16 *) setup_temp_malloc(f, sizeof(mults[0]) * c->lookup_values);\n         if (mults == NULL) return error(f, VORBIS_outofmem);\n         for (j=0; j < (int) c->lookup_values; ++j) {\n            int q = get_bits(f, c->value_bits);\n            if (q == EOP) { setup_temp_free(f,mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_invalid_setup); }\n            mults[j] = q;\n         }\n\n#ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK\n         if (c->lookup_type == 1) {\n            int len, sparse = c->sparse;\n            float last=0;\n            // pre-expand the lookup1-style multiplicands, to avoid a divide in the inner loop\n            if (sparse) {\n               if (c->sorted_entries == 0) goto skip;\n               c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->sorted_entries * c->dimensions);\n            } else\n               c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->entries        * c->dimensions);\n            if (c->multiplicands == NULL) { setup_temp_free(f,mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_outofmem); }\n            len = sparse ? c->sorted_entries : c->entries;\n            for (j=0; j < len; ++j) {\n               unsigned int z = sparse ? c->sorted_values[j] : j;\n               unsigned int div=1;\n               for (k=0; k < c->dimensions; ++k) {\n                  int off = (z / div) % c->lookup_values;\n                  float val = mults[off];\n                  val = mults[off]*c->delta_value + c->minimum_value + last;\n                  c->multiplicands[j*c->dimensions + k] = val;\n                  if (c->sequence_p)\n                     last = val;\n                  if (k+1 < c->dimensions) {\n                     if (div > UINT_MAX / (unsigned int) c->lookup_values) {\n                        setup_temp_free(f, mults,sizeof(mults[0])*c->lookup_values);\n                        return error(f, VORBIS_invalid_setup);\n                     }\n                     div *= c->lookup_values;\n                  }\n               }\n            }\n            c->lookup_type = 2;\n         }\n         else\n#endif\n         {\n            float last=0;\n            CHECK(f);\n            c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->lookup_values);\n            if (c->multiplicands == NULL) { setup_temp_free(f, mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_outofmem); }\n            for (j=0; j < (int) c->lookup_values; ++j) {\n               float val = mults[j] * c->delta_value + c->minimum_value + last;\n               c->multiplicands[j] = val;\n               if (c->sequence_p)\n                  last = val;\n            }\n         }\n#ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK\n        skip:;\n#endif\n         setup_temp_free(f, mults, sizeof(mults[0])*c->lookup_values);\n\n         CHECK(f);\n      }\n      CHECK(f);\n   }\n\n   // time domain transfers (notused)\n\n   x = get_bits(f, 6) + 1;\n   for (i=0; i < x; ++i) {\n      uint32 z = get_bits(f, 16);\n      if (z != 0) return error(f, VORBIS_invalid_setup);\n   }\n\n   // Floors\n   f->floor_count = get_bits(f, 6)+1;\n   f->floor_config = (Floor *)  setup_malloc(f, f->floor_count * sizeof(*f->floor_config));\n   if (f->floor_config == NULL) return error(f, VORBIS_outofmem);\n   for (i=0; i < f->floor_count; ++i) {\n      f->floor_types[i] = get_bits(f, 16);\n      if (f->floor_types[i] > 1) return error(f, VORBIS_invalid_setup);\n      if (f->floor_types[i] == 0) {\n         Floor0 *g = &f->floor_config[i].floor0;\n         g->order = get_bits(f,8);\n         g->rate = get_bits(f,16);\n         g->bark_map_size = get_bits(f,16);\n         g->amplitude_bits = get_bits(f,6);\n         g->amplitude_offset = get_bits(f,8);\n         g->number_of_books = get_bits(f,4) + 1;\n         for (j=0; j < g->number_of_books; ++j)\n            g->book_list[j] = get_bits(f,8);\n         return error(f, VORBIS_feature_not_supported);\n      } else {\n         stbv__floor_ordering p[31*8+2];\n         Floor1 *g = &f->floor_config[i].floor1;\n         int max_class = -1; \n         g->partitions = get_bits(f, 5);\n         for (j=0; j < g->partitions; ++j) {\n            g->partition_class_list[j] = get_bits(f, 4);\n            if (g->partition_class_list[j] > max_class)\n               max_class = g->partition_class_list[j];\n         }\n         for (j=0; j <= max_class; ++j) {\n            g->class_dimensions[j] = get_bits(f, 3)+1;\n            g->class_subclasses[j] = get_bits(f, 2);\n            if (g->class_subclasses[j]) {\n               g->class_masterbooks[j] = get_bits(f, 8);\n               if (g->class_masterbooks[j] >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n            }\n            for (k=0; k < 1 << g->class_subclasses[j]; ++k) {\n               g->subclass_books[j][k] = get_bits(f,8)-1;\n               if (g->subclass_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n            }\n         }\n         g->floor1_multiplier = get_bits(f,2)+1;\n         g->rangebits = get_bits(f,4);\n         g->Xlist[0] = 0;\n         g->Xlist[1] = 1 << g->rangebits;\n         g->values = 2;\n         for (j=0; j < g->partitions; ++j) {\n            int c = g->partition_class_list[j];\n            for (k=0; k < g->class_dimensions[c]; ++k) {\n               g->Xlist[g->values] = get_bits(f, g->rangebits);\n               ++g->values;\n            }\n         }\n         // precompute the sorting\n         for (j=0; j < g->values; ++j) {\n            p[j].x = g->Xlist[j];\n            p[j].id = j;\n         }\n         qsort(p, g->values, sizeof(p[0]), point_compare);\n         for (j=0; j < g->values; ++j)\n            g->sorted_order[j] = (uint8) p[j].id;\n         // precompute the neighbors\n         for (j=2; j < g->values; ++j) {\n            int low,hi;\n            neighbors(g->Xlist, j, &low,&hi);\n            g->neighbors[j][0] = low;\n            g->neighbors[j][1] = hi;\n         }\n\n         if (g->values > longest_floorlist)\n            longest_floorlist = g->values;\n      }\n   }\n\n   // Residue\n   f->residue_count = get_bits(f, 6)+1;\n   f->residue_config = (Residue *) setup_malloc(f, f->residue_count * sizeof(f->residue_config[0]));\n   if (f->residue_config == NULL) return error(f, VORBIS_outofmem);\n   memset(f->residue_config, 0, f->residue_count * sizeof(f->residue_config[0]));\n   for (i=0; i < f->residue_count; ++i) {\n      uint8 residue_cascade[64];\n      Residue *r = f->residue_config+i;\n      f->residue_types[i] = get_bits(f, 16);\n      if (f->residue_types[i] > 2) return error(f, VORBIS_invalid_setup);\n      r->begin = get_bits(f, 24);\n      r->end = get_bits(f, 24);\n      if (r->end < r->begin) return error(f, VORBIS_invalid_setup);\n      r->part_size = get_bits(f,24)+1;\n      r->classifications = get_bits(f,6)+1;\n      r->classbook = get_bits(f,8);\n      if (r->classbook >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n      for (j=0; j < r->classifications; ++j) {\n         uint8 high_bits=0;\n         uint8 low_bits=get_bits(f,3);\n         if (get_bits(f,1))\n            high_bits = get_bits(f,5);\n         residue_cascade[j] = high_bits*8 + low_bits;\n      }\n      r->residue_books = (short (*)[8]) setup_malloc(f, sizeof(r->residue_books[0]) * r->classifications);\n      if (r->residue_books == NULL) return error(f, VORBIS_outofmem);\n      for (j=0; j < r->classifications; ++j) {\n         for (k=0; k < 8; ++k) {\n            if (residue_cascade[j] & (1 << k)) {\n               r->residue_books[j][k] = get_bits(f, 8);\n               if (r->residue_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n            } else {\n               r->residue_books[j][k] = -1;\n            }\n         }\n      }\n      // precompute the classifications[] array to avoid inner-loop mod/divide\n      // call it 'classdata' since we already have r->classifications\n      r->classdata = (uint8 **) setup_malloc(f, sizeof(*r->classdata) * f->codebooks[r->classbook].entries);\n      if (!r->classdata) return error(f, VORBIS_outofmem);\n      memset(r->classdata, 0, sizeof(*r->classdata) * f->codebooks[r->classbook].entries);\n      for (j=0; j < f->codebooks[r->classbook].entries; ++j) {\n         int classwords = f->codebooks[r->classbook].dimensions;\n         int temp = j;\n         r->classdata[j] = (uint8 *) setup_malloc(f, sizeof(r->classdata[j][0]) * classwords);\n         if (r->classdata[j] == NULL) return error(f, VORBIS_outofmem);\n         for (k=classwords-1; k >= 0; --k) {\n            r->classdata[j][k] = temp % r->classifications;\n            temp /= r->classifications;\n         }\n      }\n   }\n\n   f->mapping_count = get_bits(f,6)+1;\n   f->mapping = (Mapping *) setup_malloc(f, f->mapping_count * sizeof(*f->mapping));\n   if (f->mapping == NULL) return error(f, VORBIS_outofmem);\n   memset(f->mapping, 0, f->mapping_count * sizeof(*f->mapping));\n   for (i=0; i < f->mapping_count; ++i) {\n      Mapping *m = f->mapping + i;      \n      int mapping_type = get_bits(f,16);\n      if (mapping_type != 0) return error(f, VORBIS_invalid_setup);\n      m->chan = (MappingChannel *) setup_malloc(f, f->channels * sizeof(*m->chan));\n      if (m->chan == NULL) return error(f, VORBIS_outofmem);\n      if (get_bits(f,1))\n         m->submaps = get_bits(f,4)+1;\n      else\n         m->submaps = 1;\n      if (m->submaps > max_submaps)\n         max_submaps = m->submaps;\n      if (get_bits(f,1)) {\n         m->coupling_steps = get_bits(f,8)+1;\n         for (k=0; k < m->coupling_steps; ++k) {\n            m->chan[k].magnitude = get_bits(f, ilog(f->channels-1));\n            m->chan[k].angle = get_bits(f, ilog(f->channels-1));\n            if (m->chan[k].magnitude >= f->channels)        return error(f, VORBIS_invalid_setup);\n            if (m->chan[k].angle     >= f->channels)        return error(f, VORBIS_invalid_setup);\n            if (m->chan[k].magnitude == m->chan[k].angle)   return error(f, VORBIS_invalid_setup);\n         }\n      } else\n         m->coupling_steps = 0;\n\n      // reserved field\n      if (get_bits(f,2)) return error(f, VORBIS_invalid_setup);\n      if (m->submaps > 1) {\n         for (j=0; j < f->channels; ++j) {\n            m->chan[j].mux = get_bits(f, 4);\n            if (m->chan[j].mux >= m->submaps)                return error(f, VORBIS_invalid_setup);\n         }\n      } else\n         // @SPECIFICATION: this case is missing from the spec\n         for (j=0; j < f->channels; ++j)\n            m->chan[j].mux = 0;\n\n      for (j=0; j < m->submaps; ++j) {\n         get_bits(f,8); // discard\n         m->submap_floor[j] = get_bits(f,8);\n         m->submap_residue[j] = get_bits(f,8);\n         if (m->submap_floor[j] >= f->floor_count)      return error(f, VORBIS_invalid_setup);\n         if (m->submap_residue[j] >= f->residue_count)  return error(f, VORBIS_invalid_setup);\n      }\n   }\n\n   // Modes\n   f->mode_count = get_bits(f, 6)+1;\n   for (i=0; i < f->mode_count; ++i) {\n      Mode *m = f->mode_config+i;\n      m->blockflag = get_bits(f,1);\n      m->windowtype = get_bits(f,16);\n      m->transformtype = get_bits(f,16);\n      m->mapping = get_bits(f,8);\n      if (m->windowtype != 0)                 return error(f, VORBIS_invalid_setup);\n      if (m->transformtype != 0)              return error(f, VORBIS_invalid_setup);\n      if (m->mapping >= f->mapping_count)     return error(f, VORBIS_invalid_setup);\n   }\n\n   flush_packet(f);\n\n   f->previous_length = 0;\n\n   for (i=0; i < f->channels; ++i) {\n      f->channel_buffers[i] = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1);\n      f->previous_window[i] = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1/2);\n      f->finalY[i]          = (int16 *) setup_malloc(f, sizeof(int16) * longest_floorlist);\n      if (f->channel_buffers[i] == NULL || f->previous_window[i] == NULL || f->finalY[i] == NULL) return error(f, VORBIS_outofmem);\n      #ifdef STB_VORBIS_NO_DEFER_FLOOR\n      f->floor_buffers[i]   = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1/2);\n      if (f->floor_buffers[i] == NULL) return error(f, VORBIS_outofmem);\n      #endif\n   }\n\n   if (!init_blocksize(f, 0, f->blocksize_0)) return FALSE;\n   if (!init_blocksize(f, 1, f->blocksize_1)) return FALSE;\n   f->blocksize[0] = f->blocksize_0;\n   f->blocksize[1] = f->blocksize_1;\n\n#ifdef STB_VORBIS_DIVIDE_TABLE\n   if (integer_divide_table[1][1]==0)\n      for (i=0; i < DIVTAB_NUMER; ++i)\n         for (j=1; j < DIVTAB_DENOM; ++j)\n            integer_divide_table[i][j] = i / j;\n#endif\n\n   // compute how much temporary memory is needed\n\n   // 1.\n   {\n      uint32 imdct_mem = (f->blocksize_1 * sizeof(float) >> 1);\n      uint32 classify_mem;\n      int i,max_part_read=0;\n      for (i=0; i < f->residue_count; ++i) {\n         Residue *r = f->residue_config + i;\n         unsigned int actual_size = f->blocksize_1 / 2;\n         unsigned int limit_r_begin = r->begin < actual_size ? r->begin : actual_size;\n         unsigned int limit_r_end   = r->end   < actual_size ? r->end   : actual_size;\n         int n_read = limit_r_end - limit_r_begin;\n         int part_read = n_read / r->part_size;\n         if (part_read > max_part_read)\n            max_part_read = part_read;\n      }\n      #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n      classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(uint8 *));\n      #else\n      classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(int *));\n      #endif\n\n      // maximum reasonable partition size is f->blocksize_1\n\n      f->temp_memory_required = classify_mem;\n      if (imdct_mem > f->temp_memory_required)\n         f->temp_memory_required = imdct_mem;\n   }\n\n   f->first_decode = TRUE;\n\n   if (f->alloc.alloc_buffer) {\n      assert(f->temp_offset == f->alloc.alloc_buffer_length_in_bytes);\n      // check if there's enough temp memory so we don't error later\n      if (f->setup_offset + sizeof(*f) + f->temp_memory_required > (unsigned) f->temp_offset)\n         return error(f, VORBIS_outofmem);\n   }\n\n   f->first_audio_page_offset = stb_vorbis_get_file_offset(f);\n\n   return TRUE;\n}", "target": 2, "idx": 11753}
{"commit_id": "5d069dbe8aaf2a197142558b6fb2978189ba3454", "project": "torvalds/linux", "func": "static int fuse_rmdir(struct inode *dir, struct dentry *entry)\n{\n\tint err;\n\tstruct fuse_mount *fm = get_fuse_mount(dir);\n\tFUSE_ARGS(args);\n\n\tif (fuse_is_bad(dir))\n\t\treturn -EIO;\n\n\targs.opcode = FUSE_RMDIR;\n\targs.nodeid = get_node_id(dir);\n\targs.in_numargs = 1;\n\targs.in_args[0].size = entry->d_name.len + 1;\n\targs.in_args[0].value = entry->d_name.name;\n\terr = fuse_simple_request(fm, &args);\n\tif (!err) {\n\t\tclear_nlink(d_inode(entry));\n\t\tfuse_dir_changed(dir);\n\t\tfuse_invalidate_entry_cache(entry);\n\t} else if (err == -EINTR)\n\t\tfuse_invalidate_entry(entry);\n\treturn err;\n}", "target": 1, "idx": 11754}
{"commit_id": "7c4a5b89a0b5a57a64b601775b296abf77a9fe97", "project": "torvalds/linux", "func": "static struct sched_rt_entity *pick_next_rt_entity(struct rt_rq *rt_rq)\n{\n\tstruct rt_prio_array *array = &rt_rq->active;\n\tstruct sched_rt_entity *next = NULL;\n\tstruct list_head *queue;\n\tint idx;\n\n\tidx = sched_find_first_bit(array->bitmap);\n\tBUG_ON(idx >= MAX_RT_PRIO);\n\n\tqueue = array->queue + idx;\n\tif (SCHED_WARN_ON(list_empty(queue)))\n\t\treturn NULL;\n\tnext = list_entry(queue->next, struct sched_rt_entity, run_list);\n\n\treturn next;\n}", "target": 2, "idx": 11755}
{"commit_id": "32027e199368dad9508965aae8cd8de5b6ab5231", "project": "the-tcpdump-group/tcpdump", "func": "static void\nppp_hdlc(netdissect_options *ndo,\n         const u_char *p, int length)\n{\n\tu_int caplen = ndo->ndo_snapend - p;\n\tu_char *b, *t, c;\n\tconst u_char *s;\n\tu_int i;\n\tint proto;\n\tconst void *se;\n\n\tif (caplen == 0)\n\t\treturn;\n\n        if (length <= 0)\n                return;\n\n\tb = (u_char *)malloc(caplen);\n\tif (b == NULL)\n\t\treturn;\n\n\t/*\n\t * Unescape all the data into a temporary, private, buffer.\n\t * Do this so that we dont overwrite the original packet\n\t * contents.\n\t */\n\tfor (s = p, t = b, i = caplen; i != 0; i--) {\n\t\tc = *s++;\n\t\tif (c == 0x7d) {\n\t\t\tif (i <= 1)\n\t\t\t\tbreak;\n\t\t\ti--;\n\t\t\tc = *s++ ^ 0x20;\n\t\t}\n\t\t*t++ = c;\n\t}\n\n\tse = ndo->ndo_snapend;\n\tndo->ndo_snapend = t;\n\tlength = t - b;\n\n        /* now lets guess about the payload codepoint format */\n        if (length < 1)\n                goto trunc;\n        proto = *b; /* start with a one-octet codepoint guess */\n\n        switch (proto) {\n        case PPP_IP:\n\t\tip_print(ndo, b + 1, length - 1);\n\t\tgoto cleanup;\n        case PPP_IPV6:\n\t\tip6_print(ndo, b + 1, length - 1);\n\t\tgoto cleanup;\n        default: /* no luck - try next guess */\n\t\tbreak;\n        }\n\n        if (length < 2)\n                goto trunc;\n        proto = EXTRACT_16BITS(b); /* next guess - load two octets */\n\n        switch (proto) {\n        case (PPP_ADDRESS << 8 | PPP_CONTROL): /* looks like a PPP frame */\n            if (length < 4)\n                goto trunc;\n            proto = EXTRACT_16BITS(b+2); /* load the PPP proto-id */\n            handle_ppp(ndo, proto, b + 4, length - 4);\n            break;\n        default: /* last guess - proto must be a PPP proto-id */\n            handle_ppp(ndo, proto, b + 2, length - 2);\n            break;\n        }\n\ncleanup:\n\tndo->ndo_snapend = se;\n\tfree(b);\n        return;\n\ntrunc:\n\tndo->ndo_snapend = se;\n\tfree(b);\n\tND_PRINT((ndo, \"[|ppp]\"));\n}", "target": 2, "idx": 11756}
{"commit_id": "19d25dd8781620cd41bf178a5e2e27fc1cf242d0", "project": "the-tcpdump-group/tcpdump", "func": "static const uint32_t *\nparserep(netdissect_options *ndo,\n         register const struct sunrpc_msg *rp, register u_int length)\n{\n\tregister const uint32_t *dp;\n\tu_int len;\n\tenum sunrpc_accept_stat astat;\n\n\t/*\n\t * Portability note:\n\t * Here we find the address of the ar_verf credentials.\n\t * Originally, this calculation was\n\t *\tdp = (uint32_t *)&rp->rm_reply.rp_acpt.ar_verf\n\t * On the wire, the rp_acpt field starts immediately after\n\t * the (32 bit) rp_stat field.  However, rp_acpt (which is a\n\t * \"struct accepted_reply\") contains a \"struct opaque_auth\",\n\t * whose internal representation contains a pointer, so on a\n\t * 64-bit machine the compiler inserts 32 bits of padding\n\t * before rp->rm_reply.rp_acpt.ar_verf.  So, we cannot use\n\t * the internal representation to parse the on-the-wire\n\t * representation.  Instead, we skip past the rp_stat field,\n\t * which is an \"enum\" and so occupies one 32-bit word.\n\t */\n\tdp = ((const uint32_t *)&rp->rm_reply) + 1;\n\tND_TCHECK(dp[1]);\n\tlen = EXTRACT_32BITS(&dp[1]);\n\tif (len >= length)\n\t\treturn (NULL);\n\t/*\n\t * skip past the ar_verf credentials.\n\t */\n\tdp += (len + (2*sizeof(uint32_t) + 3)) / sizeof(uint32_t);\n\n\t/*\n\t * now we can check the ar_stat field\n\t */\n\tND_TCHECK(dp[0]);\n\tastat = (enum sunrpc_accept_stat) EXTRACT_32BITS(dp);\n\tif (astat != SUNRPC_SUCCESS) {\n\t\tND_PRINT((ndo, \" %s\", tok2str(sunrpc_str, \"ar_stat %d\", astat)));\n\t\tnfserr = 1;\t\t/* suppress trunc string */\n\t\treturn (NULL);\n\t}\n\t/* successful return */\n\tND_TCHECK2(*dp, sizeof(astat));\n\treturn ((const uint32_t *) (sizeof(astat) + ((const char *)dp)));\ntrunc:\n\treturn (0);\n}", "target": 3, "idx": 11757}
{"commit_id": "d4ff8fd5c175bc825258da3ffb01bd21bd5a6202", "project": "libuv", "func": "void uv_winapi_init() {\n  HMODULE ntdll_module;\n  HMODULE kernel32_module;\n\n  ntdll_module = GetModuleHandleA(\"ntdll.dll\");\n  if (ntdll_module == NULL) {\n    uv_fatal_error(GetLastError(), \"GetModuleHandleA\");\n  }\n\n  pRtlNtStatusToDosError = (sRtlNtStatusToDosError) GetProcAddress(\n      ntdll_module,\n      \"RtlNtStatusToDosError\");\n  if (pRtlNtStatusToDosError == NULL) {\n    uv_fatal_error(GetLastError(), \"GetProcAddress\");\n  }\n\n  pNtQueryInformationFile = (sNtQueryInformationFile) GetProcAddress(\n      ntdll_module,\n      \"NtQueryInformationFile\");\n  if (pNtQueryInformationFile == NULL) {\n    uv_fatal_error(GetLastError(), \"GetProcAddress\");\n  }\n\n  pNtDeviceIoControlFile = (sNtDeviceIoControlFile) GetProcAddress(\n      ntdll_module,\n      \"NtDeviceIoControlFile\");\n  if (pNtDeviceIoControlFile == NULL) {\n    uv_fatal_error(GetLastError(), \"GetProcAddress\");\n  }\n\n  pNtSetInformationFile = (sNtSetInformationFile) GetProcAddress(\n      ntdll_module,\n      \"NtSetInformationFile\");\n  if (pNtSetInformationFile == NULL) {\n    uv_fatal_error(GetLastError(), \"GetProcAddress\");\n  }\n\n  pNtQuerySystemInformation = (sNtQuerySystemInformation) GetProcAddress(\n      ntdll_module,\n      \"NtQuerySystemInformation\");\n  if (pNtQuerySystemInformation == NULL) {\n    uv_fatal_error(GetLastError(), \"GetProcAddress\");\n  }\n\n  kernel32_module = GetModuleHandleA(\"kernel32.dll\");\n  if (kernel32_module == NULL) {\n    uv_fatal_error(GetLastError(), \"GetModuleHandleA\");\n  }\n\n  pGetQueuedCompletionStatusEx = (sGetQueuedCompletionStatusEx) GetProcAddress(\n      kernel32_module,\n      \"GetQueuedCompletionStatusEx\");\n\n  pSetFileCompletionNotificationModes = (sSetFileCompletionNotificationModes)\n    GetProcAddress(kernel32_module, \"SetFileCompletionNotificationModes\");\n\n  pCreateSymbolicLinkW = (sCreateSymbolicLinkW)\n    GetProcAddress(kernel32_module, \"CreateSymbolicLinkW\");\n\n  pCancelIoEx = (sCancelIoEx)\n    GetProcAddress(kernel32_module, \"CancelIoEx\");\n\n  pInitializeConditionVariable = (sInitializeConditionVariable)\n    GetProcAddress(kernel32_module, \"InitializeConditionVariable\");\n\n  pSleepConditionVariableCS = (sSleepConditionVariableCS)\n    GetProcAddress(kernel32_module, \"SleepConditionVariableCS\");\n\n  pSleepConditionVariableSRW = (sSleepConditionVariableSRW)\n    GetProcAddress(kernel32_module, \"SleepConditionVariableSRW\");\n\n  pWakeAllConditionVariable = (sWakeAllConditionVariable)\n    GetProcAddress(kernel32_module, \"WakeAllConditionVariable\");\n\n  pWakeConditionVariable = (sWakeConditionVariable)\n    GetProcAddress(kernel32_module, \"WakeConditionVariable\");\n}", "target": 2, "idx": 11758}
{"commit_id": "f0dce23475b5af5da6b17b97c1765271307734b6", "project": "qemu", "func": "static int dmg_open(BlockDriverState *bs, QDict *options, int flags,\n                    Error **errp)\n{\n    BDRVDMGState *s = bs->opaque;\n    uint64_t info_begin, info_end, last_in_offset, last_out_offset;\n    uint32_t count, tmp;\n    uint32_t max_compressed_size = 1, max_sectors_per_chunk = 1, i;\n    int64_t offset;\n    int ret;\n\n    bs->read_only = 1;\n    s->n_chunks = 0;\n    s->offsets = s->lengths = s->sectors = s->sectorcounts = NULL;\n\n    /* read offset of info blocks */\n    offset = bdrv_getlength(bs->file);\n    if (offset < 0) {\n        ret = offset;\n        goto fail;\n    }\n    offset -= 0x1d8;\n\n    ret = read_uint64(bs, offset, &info_begin);\n    if (ret < 0) {\n        goto fail;\n    } else if (info_begin == 0) {\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    ret = read_uint32(bs, info_begin, &tmp);\n    if (ret < 0) {\n        goto fail;\n    } else if (tmp != 0x100) {\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    ret = read_uint32(bs, info_begin + 4, &count);\n    if (ret < 0) {\n        goto fail;\n    } else if (count == 0) {\n        ret = -EINVAL;\n        goto fail;\n    }\n    info_end = info_begin + count;\n\n    offset = info_begin + 0x100;\n\n    /* read offsets */\n    last_in_offset = last_out_offset = 0;\n    while (offset < info_end) {\n        uint32_t type;\n\n        ret = read_uint32(bs, offset, &count);\n        if (ret < 0) {\n            goto fail;\n        } else if (count == 0) {\n            ret = -EINVAL;\n            goto fail;\n        }\n        offset += 4;\n\n        ret = read_uint32(bs, offset, &type);\n        if (ret < 0) {\n            goto fail;\n        }\n\n        if (type == 0x6d697368 && count >= 244) {\n            size_t new_size;\n            uint32_t chunk_count;\n\n            offset += 4;\n            offset += 200;\n\n            chunk_count = (count - 204) / 40;\n            new_size = sizeof(uint64_t) * (s->n_chunks + chunk_count);\n            s->types = g_realloc(s->types, new_size / 2);\n            s->offsets = g_realloc(s->offsets, new_size);\n            s->lengths = g_realloc(s->lengths, new_size);\n            s->sectors = g_realloc(s->sectors, new_size);\n            s->sectorcounts = g_realloc(s->sectorcounts, new_size);\n\n            for (i = s->n_chunks; i < s->n_chunks + chunk_count; i++) {\n                ret = read_uint32(bs, offset, &s->types[i]);\n                if (ret < 0) {\n                    goto fail;\n                }\n                offset += 4;\n                if (s->types[i] != 0x80000005 && s->types[i] != 1 &&\n                    s->types[i] != 2) {\n                    if (s->types[i] == 0xffffffff && i > 0) {\n                        last_in_offset = s->offsets[i - 1] + s->lengths[i - 1];\n                        last_out_offset = s->sectors[i - 1] +\n                                          s->sectorcounts[i - 1];\n                    }\n                    chunk_count--;\n                    i--;\n                    offset += 36;\n                    continue;\n                }\n                offset += 4;\n\n                ret = read_uint64(bs, offset, &s->sectors[i]);\n                if (ret < 0) {\n                    goto fail;\n                }\n                s->sectors[i] += last_out_offset;\n                offset += 8;\n\n                ret = read_uint64(bs, offset, &s->sectorcounts[i]);\n                if (ret < 0) {\n                    goto fail;\n                }\n                offset += 8;\n\n                if (s->sectorcounts[i] > DMG_SECTORCOUNTS_MAX) {\n                    error_report(\"sector count %\" PRIu64 \" for chunk %u is \"\n                                 \"larger than max (%u)\",\n                                 s->sectorcounts[i], i, DMG_SECTORCOUNTS_MAX);\n                    ret = -EINVAL;\n                    goto fail;\n                }\n\n                ret = read_uint64(bs, offset, &s->offsets[i]);\n                if (ret < 0) {\n                    goto fail;\n                }\n                s->offsets[i] += last_in_offset;\n                offset += 8;\n\n                ret = read_uint64(bs, offset, &s->lengths[i]);\n                if (ret < 0) {\n                    goto fail;\n                }\n                offset += 8;\n\n                if (s->lengths[i] > DMG_LENGTHS_MAX) {\n                    error_report(\"length %\" PRIu64 \" for chunk %u is larger \"\n                                 \"than max (%u)\",\n                                 s->lengths[i], i, DMG_LENGTHS_MAX);\n                    ret = -EINVAL;\n                    goto fail;\n                }\n\n                update_max_chunk_size(s, i, &max_compressed_size,\n                                      &max_sectors_per_chunk);\n            }\n            s->n_chunks += chunk_count;\n        }\n    }\n\n    /* initialize zlib engine */\n    s->compressed_chunk = g_malloc(max_compressed_size + 1);\n    s->uncompressed_chunk = g_malloc(512 * max_sectors_per_chunk);\n    if (inflateInit(&s->zstream) != Z_OK) {\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    s->current_chunk = s->n_chunks;\n\n    qemu_co_mutex_init(&s->lock);\n    return 0;\n\nfail:\n    g_free(s->types);\n    g_free(s->offsets);\n    g_free(s->lengths);\n    g_free(s->sectors);\n    g_free(s->sectorcounts);\n    g_free(s->compressed_chunk);\n    g_free(s->uncompressed_chunk);\n    return ret;\n}", "target": 2, "idx": 11759}
{"commit_id": "17839856fd588f4ab6b789f482ed3ffd7c403e1f", "project": "torvalds/linux", "func": "static long __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,\n\t\tunsigned long start, unsigned long nr_pages,\n\t\tunsigned int gup_flags, struct page **pages,\n\t\tstruct vm_area_struct **vmas, int *locked)\n{\n\tlong ret = 0, i = 0;\n\tstruct vm_area_struct *vma = NULL;\n\tstruct follow_page_context ctx = { NULL };\n\n\tif (!nr_pages)\n\t\treturn 0;\n\n\tstart = untagged_addr(start);\n\n\tVM_BUG_ON(!!pages != !!(gup_flags & (FOLL_GET | FOLL_PIN)));\n\n\t/*\n\t * If FOLL_FORCE is set then do not force a full fault as the hinting\n\t * fault information is unrelated to the reference behaviour of a task\n\t * using the address space\n\t */\n\tif (!(gup_flags & FOLL_FORCE))\n\t\tgup_flags |= FOLL_NUMA;\n\n\tdo {\n\t\tstruct page *page;\n\t\tunsigned int foll_flags = gup_flags;\n\t\tunsigned int page_increm;\n\n\t\t/* first iteration or cross vma bound */\n\t\tif (!vma || start >= vma->vm_end) {\n\t\t\tvma = find_extend_vma(mm, start);\n\t\t\tif (!vma && in_gate_area(mm, start)) {\n\t\t\t\tret = get_gate_page(mm, start & PAGE_MASK,\n\t\t\t\t\t\tgup_flags, &vma,\n\t\t\t\t\t\tpages ? &pages[i] : NULL);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t\tctx.page_mask = 0;\n\t\t\t\tgoto next_page;\n\t\t\t}\n\n\t\t\tif (!vma || check_vma_flags(vma, gup_flags)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (is_vm_hugetlb_page(vma)) {\n\t\t\t\tif (should_force_cow_break(vma, foll_flags))\n\t\t\t\t\tfoll_flags |= FOLL_WRITE;\n\t\t\t\ti = follow_hugetlb_page(mm, vma, pages, vmas,\n\t\t\t\t\t\t&start, &nr_pages, i,\n\t\t\t\t\t\tfoll_flags, locked);\n\t\t\t\tif (locked && *locked == 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * We've got a VM_FAULT_RETRY\n\t\t\t\t\t * and we've lost mmap_sem.\n\t\t\t\t\t * We must stop here.\n\t\t\t\t\t */\n\t\t\t\t\tBUG_ON(gup_flags & FOLL_NOWAIT);\n\t\t\t\t\tBUG_ON(ret != 0);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (should_force_cow_break(vma, foll_flags))\n\t\t\tfoll_flags |= FOLL_WRITE;\n\nretry:\n\t\t/*\n\t\t * If we have a pending SIGKILL, don't keep faulting pages and\n\t\t * potentially allocating memory.\n\t\t */\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\tgoto out;\n\t\t}\n\t\tcond_resched();\n\n\t\tpage = follow_page_mask(vma, start, foll_flags, &ctx);\n\t\tif (!page) {\n\t\t\tret = faultin_page(tsk, vma, start, &foll_flags,\n\t\t\t\t\t   locked);\n\t\t\tswitch (ret) {\n\t\t\tcase 0:\n\t\t\t\tgoto retry;\n\t\t\tcase -EBUSY:\n\t\t\t\tret = 0;\n\t\t\t\tfallthrough;\n\t\t\tcase -EFAULT:\n\t\t\tcase -ENOMEM:\n\t\t\tcase -EHWPOISON:\n\t\t\t\tgoto out;\n\t\t\tcase -ENOENT:\n\t\t\t\tgoto next_page;\n\t\t\t}\n\t\t\tBUG();\n\t\t} else if (PTR_ERR(page) == -EEXIST) {\n\t\t\t/*\n\t\t\t * Proper page table entry exists, but no corresponding\n\t\t\t * struct page.\n\t\t\t */\n\t\t\tgoto next_page;\n\t\t} else if (IS_ERR(page)) {\n\t\t\tret = PTR_ERR(page);\n\t\t\tgoto out;\n\t\t}\n\t\tif (pages) {\n\t\t\tpages[i] = page;\n\t\t\tflush_anon_page(vma, page, start);\n\t\t\tflush_dcache_page(page);\n\t\t\tctx.page_mask = 0;\n\t\t}\nnext_page:\n\t\tif (vmas) {\n\t\t\tvmas[i] = vma;\n\t\t\tctx.page_mask = 0;\n\t\t}\n\t\tpage_increm = 1 + (~(start >> PAGE_SHIFT) & ctx.page_mask);\n\t\tif (page_increm > nr_pages)\n\t\t\tpage_increm = nr_pages;\n\t\ti += page_increm;\n\t\tstart += page_increm * PAGE_SIZE;\n\t\tnr_pages -= page_increm;\n\t} while (nr_pages);\nout:\n\tif (ctx.pgmap)\n\t\tput_dev_pagemap(ctx.pgmap);\n\treturn i ? i : ret;\n}", "target": 0, "idx": 11760}
{"commit_id": "8572cea1461a006bce1d06c0c4b0575869125fa4", "project": "torvalds/linux", "func": "static int\nnfp_flower_spawn_phy_reprs(struct nfp_app *app, struct nfp_flower_priv *priv)\n{\n\tstruct nfp_eth_table *eth_tbl = app->pf->eth_tbl;\n\tatomic_t *replies = &priv->reify_replies;\n\tstruct nfp_flower_repr_priv *repr_priv;\n\tstruct nfp_repr *nfp_repr;\n\tstruct sk_buff *ctrl_skb;\n\tstruct nfp_reprs *reprs;\n\tint err, reify_cnt;\n\tunsigned int i;\n\n\tctrl_skb = nfp_flower_cmsg_mac_repr_start(app, eth_tbl->count);\n\tif (!ctrl_skb)\n\t\treturn -ENOMEM;\n\n\treprs = nfp_reprs_alloc(eth_tbl->max_index + 1);\n\tif (!reprs) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free_ctrl_skb;\n\t}\n\n\tfor (i = 0; i < eth_tbl->count; i++) {\n\t\tunsigned int phys_port = eth_tbl->ports[i].index;\n\t\tstruct net_device *repr;\n\t\tstruct nfp_port *port;\n\t\tu32 cmsg_port_id;\n\n\t\trepr = nfp_repr_alloc(app);\n\t\tif (!repr) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_reprs_clean;\n\t\t}\n\n\t\trepr_priv = kzalloc(sizeof(*repr_priv), GFP_KERNEL);\n\t\tif (!repr_priv) {\n\t\t\terr = -ENOMEM;\n\t\t\tnfp_repr_free(repr);\n\t\t\tgoto err_reprs_clean;\n\t\t}\n\n\t\tnfp_repr = netdev_priv(repr);\n\t\tnfp_repr->app_priv = repr_priv;\n\t\trepr_priv->nfp_repr = nfp_repr;\n\n\t\tport = nfp_port_alloc(app, NFP_PORT_PHYS_PORT, repr);\n\t\tif (IS_ERR(port)) {\n\t\t\terr = PTR_ERR(port);\n\t\t\tkfree(repr_priv);\n\t\t\tnfp_repr_free(repr);\n\t\t\tgoto err_reprs_clean;\n\t\t}\n\t\terr = nfp_port_init_phy_port(app->pf, app, port, i);\n\t\tif (err) {\n\t\t\tkfree(repr_priv);\n\t\t\tnfp_port_free(port);\n\t\t\tnfp_repr_free(repr);\n\t\t\tgoto err_reprs_clean;\n\t\t}\n\n\t\tSET_NETDEV_DEV(repr, &priv->nn->pdev->dev);\n\t\tnfp_net_get_mac_addr(app->pf, repr, port);\n\n\t\tcmsg_port_id = nfp_flower_cmsg_phys_port(phys_port);\n\t\terr = nfp_repr_init(app, repr,\n\t\t\t\t    cmsg_port_id, port, priv->nn->dp.netdev);\n\t\tif (err) {\n\t\t\tkfree(repr_priv);\n\t\t\tnfp_port_free(port);\n\t\t\tnfp_repr_free(repr);\n\t\t\tgoto err_reprs_clean;\n\t\t}\n\n\t\tnfp_flower_cmsg_mac_repr_add(ctrl_skb, i,\n\t\t\t\t\t     eth_tbl->ports[i].nbi,\n\t\t\t\t\t     eth_tbl->ports[i].base,\n\t\t\t\t\t     phys_port);\n\n\t\tRCU_INIT_POINTER(reprs->reprs[phys_port], repr);\n\t\tnfp_info(app->cpp, \"Phys Port %d Representor(%s) created\\n\",\n\t\t\t phys_port, repr->name);\n\t}\n\n\tnfp_app_reprs_set(app, NFP_REPR_TYPE_PHYS_PORT, reprs);\n\n\t/* The REIFY/MAC_REPR control messages should be sent after the MAC\n\t * representors are registered using nfp_app_reprs_set().  This is\n\t * because the firmware may respond with control messages for the\n\t * MAC representors, f.e. to provide the driver with information\n\t * about their state, and without registration the driver will drop\n\t * any such messages.\n\t */\n\tatomic_set(replies, 0);\n\treify_cnt = nfp_flower_reprs_reify(app, NFP_REPR_TYPE_PHYS_PORT, true);\n\tif (reify_cnt < 0) {\n\t\terr = reify_cnt;\n\t\tnfp_warn(app->cpp, \"Failed to notify firmware about repr creation\\n\");\n\t\tgoto err_reprs_remove;\n\t}\n\n\terr = nfp_flower_wait_repr_reify(app, replies, reify_cnt);\n\tif (err)\n\t\tgoto err_reprs_remove;\n\n\tnfp_ctrl_tx(app->ctrl, ctrl_skb);\n\n\treturn 0;\nerr_reprs_remove:\n\treprs = nfp_app_reprs_set(app, NFP_REPR_TYPE_PHYS_PORT, NULL);\nerr_reprs_clean:\n\tnfp_reprs_clean_and_free(app, reprs);\nerr_free_ctrl_skb:\n\tkfree_skb(ctrl_skb);\n\treturn err;\n}", "target": 1, "idx": 11761}
{"commit_id": "f22101c8308669bb63c03a73a2cac2408d844f38", "project": "php/php-src", "func": "static int exif_scan_thumbnail(image_info_type *ImageInfo)\n{\n\tuchar           c, *data = (uchar*)ImageInfo->Thumbnail.data;\n\tint             n, marker;\n\tsize_t          length=2, pos=0;\n\tjpeg_sof_info   sof_info;\n\n\tif (!data || ImageInfo->Thumbnail.size < 4) {\n\t\treturn FALSE; /* nothing to do here */\n\t}\n\tif (memcmp(data, \"\\xFF\\xD8\\xFF\", 3)) {\n\t\tif (!ImageInfo->Thumbnail.width && !ImageInfo->Thumbnail.height) {\n\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Thumbnail is not a JPEG image\");\n\t\t}\n\t\treturn FALSE;\n\t}\n\tfor (;;) {\n\t\tpos += length;\n\t\tif (pos>=ImageInfo->Thumbnail.size)\n\t\t\treturn FALSE;\n\t\tc = data[pos++];\n\t\tif (pos>=ImageInfo->Thumbnail.size)\n\t\t\treturn FALSE;\n\t\tif (c != 0xFF) {\n\t\t\treturn FALSE;\n\t\t}\n\t\tn = 8;\n\t\twhile ((c = data[pos++]) == 0xFF && n--) {\n\t\t\tif (pos+3>=ImageInfo->Thumbnail.size)\n\t\t\t\treturn FALSE;\n\t\t\t/* +3 = pos++ of next check when reaching marker + 2 bytes for length */\n\t\t}\n\t\tif (c == 0xFF)\n\t\t\treturn FALSE;\n\t\tmarker = c;\n\t\tif (pos>=ImageInfo->Thumbnail.size)\n\t\t\treturn FALSE;\n\t\tlength = php_jpg_get16(data+pos);\n\t\tif (length > ImageInfo->Thumbnail.size || pos >= ImageInfo->Thumbnail.size - length) {\n\t\t\treturn FALSE;\n\t\t}\n#ifdef EXIF_DEBUG\n\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Thumbnail: process section(x%02X=%s) @ x%04X + x%04X\", marker, exif_get_markername(marker), pos, length);\n#endif\n\t\tswitch (marker) {\n\t\t\tcase M_SOF0:\n\t\t\tcase M_SOF1:\n\t\t\tcase M_SOF2:\n\t\t\tcase M_SOF3:\n\t\t\tcase M_SOF5:\n\t\t\tcase M_SOF6:\n\t\t\tcase M_SOF7:\n\t\t\tcase M_SOF9:\n\t\t\tcase M_SOF10:\n\t\t\tcase M_SOF11:\n\t\t\tcase M_SOF13:\n\t\t\tcase M_SOF14:\n\t\t\tcase M_SOF15:\n\t\t\t\t/* handle SOFn block */\n\t\t\t\tif (length < 8 || ImageInfo->Thumbnail.size - 8 < pos) {\n\t\t\t\t\t/* exif_process_SOFn needs 8 bytes */\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\t\t\t\texif_process_SOFn(data+pos, marker, &sof_info);\n\t\t\t\tImageInfo->Thumbnail.height   = sof_info.height;\n\t\t\t\tImageInfo->Thumbnail.width    = sof_info.width;\n#ifdef EXIF_DEBUG\n\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Thumbnail: size: %d * %d\", sof_info.width, sof_info.height);\n#endif\n\t\t\t\treturn TRUE;\n\n\t\t\tcase M_SOS:\n\t\t\tcase M_EOI:\n\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Could not compute size of thumbnail\");\n\t\t\t\treturn FALSE;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t/* just skip */\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Could not compute size of thumbnail\");\n\treturn FALSE;\n}", "target": 2, "idx": 11762}
{"commit_id": "049c4e13714ecbca567b4d5f6d563f05d431c80e", "project": "kernel/git/bpf/bpf", "func": "static void scalar32_min_max_and(struct bpf_reg_state *dst_reg,\n\t\t\t\t struct bpf_reg_state *src_reg)\n{\n\tbool src_known = tnum_subreg_is_const(src_reg->var_off);\n\tbool dst_known = tnum_subreg_is_const(dst_reg->var_off);\n\tstruct tnum var32_off = tnum_subreg(dst_reg->var_off);\n\ts32 smin_val = src_reg->s32_min_value;\n\tu32 umax_val = src_reg->u32_max_value;\n\n\tif (src_known && dst_known) {\n\t\t__mark_reg32_known(dst_reg, var32_off.value);\n\t\treturn;\n\t}\n\n\t/* We get our minimum from the var_off, since that's inherently\n\t * bitwise.  Our maximum is the minimum of the operands' maxima.\n\t */\n\tdst_reg->u32_min_value = var32_off.value;\n\tdst_reg->u32_max_value = min(dst_reg->u32_max_value, umax_val);\n\tif (dst_reg->s32_min_value < 0 || smin_val < 0) {\n\t\t/* Lose signed bounds when ANDing negative numbers,\n\t\t * ain't nobody got time for that.\n\t\t */\n\t\tdst_reg->s32_min_value = S32_MIN;\n\t\tdst_reg->s32_max_value = S32_MAX;\n\t} else {\n\t\t/* ANDing two positives gives a positive, so safe to\n\t\t * cast result into s64.\n\t\t */\n\t\tdst_reg->s32_min_value = dst_reg->u32_min_value;\n\t\tdst_reg->s32_max_value = dst_reg->u32_max_value;\n\t}\n}", "target": 2, "idx": 11763}
{"commit_id": "306490c8d848c367faa2d9df81f5e69dab46ffb5", "project": "tpm2-software/tpm2-tss", "func": "static const char *\nunknown_layer_handler(TSS2_RC rc)\n{\n    static __thread char buf[32];\n\n    clearbuf(buf);\n    catbuf(buf, \"0x%X\", rc);\n\n    return buf;\n}", "target": 1, "idx": 11764}
{"commit_id": "3c49c44be9b459d9c616bcaef6eb5d51298c1741", "project": "neomutt", "func": "static void cmd_parse_status(struct ImapData *idata, char *s)\n{\n  char *value = NULL;\n  struct Buffy *inc = NULL;\n  struct ImapMbox mx;\n  struct ImapStatus *status = NULL;\n  unsigned int olduv, oldun;\n  unsigned int litlen;\n  short new = 0;\n  short new_msg_count = 0;\n\n  char *mailbox = imap_next_word(s);\n\n  /* We need a real tokenizer. */\n  if (imap_get_literal_count(mailbox, &litlen) == 0)\n  {\n    if (imap_cmd_step(idata) != IMAP_CMD_CONTINUE)\n    {\n      idata->status = IMAP_FATAL;\n      return;\n    }\n\n    if (strlen(idata->buf) < litlen)\n    {\n      mutt_debug(1, \"Error parsing STATUS mailbox\\n\");\n      return;\n    }\n\n    mailbox = idata->buf;\n    s = mailbox + litlen;\n    *s = '\\0';\n    s++;\n    SKIPWS(s);\n  }\n  else\n  {\n    s = imap_next_word(mailbox);\n    *(s - 1) = '\\0';\n    imap_unmunge_mbox_name(idata, mailbox);\n  }\n\n  status = imap_mboxcache_get(idata, mailbox, 1);\n  olduv = status->uidvalidity;\n  oldun = status->uidnext;\n\n  if (*s++ != '(')\n  {\n    mutt_debug(1, \"Error parsing STATUS\\n\");\n    return;\n  }\n  while (*s && *s != ')')\n  {\n    value = imap_next_word(s);\n\n    errno = 0;\n    const unsigned long ulcount = strtoul(value, &value, 10);\n    if (((errno == ERANGE) && (ulcount == ULONG_MAX)) || ((unsigned int) ulcount != ulcount))\n    {\n      mutt_debug(1, \"Error parsing STATUS number\\n\");\n      return;\n    }\n    const unsigned int count = (unsigned int) ulcount;\n\n    if (mutt_str_strncmp(\"MESSAGES\", s, 8) == 0)\n    {\n      status->messages = count;\n      new_msg_count = 1;\n    }\n    else if (mutt_str_strncmp(\"RECENT\", s, 6) == 0)\n      status->recent = count;\n    else if (mutt_str_strncmp(\"UIDNEXT\", s, 7) == 0)\n      status->uidnext = count;\n    else if (mutt_str_strncmp(\"UIDVALIDITY\", s, 11) == 0)\n      status->uidvalidity = count;\n    else if (mutt_str_strncmp(\"UNSEEN\", s, 6) == 0)\n      status->unseen = count;\n\n    s = value;\n    if (*s && *s != ')')\n      s = imap_next_word(s);\n  }\n  mutt_debug(3, \"%s (UIDVALIDITY: %u, UIDNEXT: %u) %d messages, %d recent, %d unseen\\n\",\n             status->name, status->uidvalidity, status->uidnext,\n             status->messages, status->recent, status->unseen);\n\n  /* caller is prepared to handle the result herself */\n  if (idata->cmddata && idata->cmdtype == IMAP_CT_STATUS)\n  {\n    memcpy(idata->cmddata, status, sizeof(struct ImapStatus));\n    return;\n  }\n\n  mutt_debug(3, \"Running default STATUS handler\\n\");\n\n  /* should perhaps move this code back to imap_buffy_check */\n  for (inc = Incoming; inc; inc = inc->next)\n  {\n    if (inc->magic != MUTT_IMAP)\n      continue;\n\n    if (imap_parse_path(inc->path, &mx) < 0)\n    {\n      mutt_debug(1, \"Error parsing mailbox %s, skipping\\n\", inc->path);\n      continue;\n    }\n\n    if (imap_account_match(&idata->conn->account, &mx.account))\n    {\n      if (mx.mbox)\n      {\n        value = mutt_str_strdup(mx.mbox);\n        imap_fix_path(idata, mx.mbox, value, mutt_str_strlen(value) + 1);\n        FREE(&mx.mbox);\n      }\n      else\n        value = mutt_str_strdup(\"INBOX\");\n\n      if (value && (imap_mxcmp(mailbox, value) == 0))\n      {\n        mutt_debug(3, \"Found %s in buffy list (OV: %u ON: %u U: %d)\\n\", mailbox,\n                   olduv, oldun, status->unseen);\n\n        if (MailCheckRecent)\n        {\n          if (olduv && olduv == status->uidvalidity)\n          {\n            if (oldun < status->uidnext)\n              new = (status->unseen > 0);\n          }\n          else if (!olduv && !oldun)\n          {\n            /* first check per session, use recent. might need a flag for this. */\n            new = (status->recent > 0);\n          }\n          else\n            new = (status->unseen > 0);\n        }\n        else\n          new = (status->unseen > 0);\n\n#ifdef USE_SIDEBAR\n        if ((inc->new != new) || (inc->msg_count != status->messages) ||\n            (inc->msg_unread != status->unseen))\n        {\n          mutt_menu_set_current_redraw(REDRAW_SIDEBAR);\n        }\n#endif\n        inc->new = new;\n        if (new_msg_count)\n          inc->msg_count = status->messages;\n        inc->msg_unread = status->unseen;\n\n        if (inc->new)\n        {\n          /* force back to keep detecting new mail until the mailbox is\n             opened */\n          status->uidnext = oldun;\n        }\n\n        FREE(&value);\n        return;\n      }\n\n      FREE(&value);\n    }\n\n    FREE(&mx.mbox);\n  }\n}", "target": 3, "idx": 11765}
{"commit_id": "05b27615481e72e3b338bb12990fb3e0c2ecc2a9", "project": "vim", "func": "static void\nwin_exchange(long Prenum)\n{\n    frame_T\t*frp;\n    frame_T\t*frp2;\n    win_T\t*wp;\n    win_T\t*wp2;\n    int\t\ttemp;\n\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n    if (ONE_WINDOW)\t    // just one window\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    /*\n     * find window to exchange with\n     */\n    if (Prenum)\n    {\n\tfrp = curwin->w_frame->fr_parent->fr_child;\n\twhile (frp != NULL && --Prenum > 0)\n\t    frp = frp->fr_next;\n    }\n    else if (curwin->w_frame->fr_next != NULL)\t// Swap with next\n\tfrp = curwin->w_frame->fr_next;\n    else    // Swap last window in row/col with previous\n\tfrp = curwin->w_frame->fr_prev;\n\n    // We can only exchange a window with another window, not with a frame\n    // containing windows.\n    if (frp == NULL || frp->fr_win == NULL || frp->fr_win == curwin)\n\treturn;\n    wp = frp->fr_win;\n\n/*\n * 1. remove curwin from the list. Remember after which window it was in wp2\n * 2. insert curwin before wp in the list\n * if wp != wp2\n *    3. remove wp from the list\n *    4. insert wp after wp2\n * 5. exchange the status line height and vsep width.\n */\n    wp2 = curwin->w_prev;\n    frp2 = curwin->w_frame->fr_prev;\n    if (wp->w_prev != curwin)\n    {\n\twin_remove(curwin, NULL);\n\tframe_remove(curwin->w_frame);\n\twin_append(wp->w_prev, curwin);\n\tframe_insert(frp, curwin->w_frame);\n    }\n    if (wp != wp2)\n    {\n\twin_remove(wp, NULL);\n\tframe_remove(wp->w_frame);\n\twin_append(wp2, wp);\n\tif (frp2 == NULL)\n\t    frame_insert(wp->w_frame->fr_parent->fr_child, wp->w_frame);\n\telse\n\t    frame_append(frp2, wp->w_frame);\n    }\n    temp = curwin->w_status_height;\n    curwin->w_status_height = wp->w_status_height;\n    wp->w_status_height = temp;\n    temp = curwin->w_vsep_width;\n    curwin->w_vsep_width = wp->w_vsep_width;\n    wp->w_vsep_width = temp;\n\n    frame_fix_height(curwin);\n    frame_fix_height(wp);\n    frame_fix_width(curwin);\n    frame_fix_width(wp);\n\n    (void)win_comp_pos();\t\t// recompute window positions\n\n    if (wp->w_buffer != curbuf)\n\treset_VIsual_and_resel();\n    else if (VIsual_active)\n\twp->w_cursor = curwin->w_cursor;\n\n    win_enter(wp, TRUE);\n    redraw_all_later(NOT_VALID);\n}", "target": 1, "idx": 11766}
{"commit_id": "4e0f718daf97d47cf7dec122da1be970f145c809", "project": "torvalds/linux", "func": "static void ax25_kill_by_device(struct net_device *dev)\n{\n\tax25_dev *ax25_dev;\n\tax25_cb *s;\n\tstruct sock *sk;\n\n\tif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\n\t\treturn;\n\n\tspin_lock_bh(&ax25_list_lock);\nagain:\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->ax25_dev == ax25_dev) {\n\t\t\tsk = s->sk;\n\t\t\tsock_hold(sk);\n\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\tlock_sock(sk);\n\t\t\ts->ax25_dev = NULL;\n\t\t\trelease_sock(sk);\n\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\tspin_lock_bh(&ax25_list_lock);\n\t\t\tsock_put(sk);\n\t\t\t/* The entry could have been deleted from the\n\t\t\t * list meanwhile and thus the next pointer is\n\t\t\t * no longer valid.  Play it safe and restart\n\t\t\t * the scan.  Forward progress is ensured\n\t\t\t * because we set s->ax25_dev to NULL and we\n\t\t\t * are never passed a NULL 'dev' argument.\n\t\t\t */\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock_bh(&ax25_list_lock);\n}", "target": 2, "idx": 11767}
{"commit_id": "28a566f7731b4cb76d2a9ba16d997ac5aeb07dad", "project": "android", "func": "static int sysMapFD(int fd, MemMapping* pMap)\n{\n    off_t start;\n    size_t length;\n    void* memPtr;\n\n    assert(pMap != NULL);\n\n    if (getFileStartAndLength(fd, &start, &length) < 0)\n        return -1;\n\n    memPtr = mmap(NULL, length, PROT_READ, MAP_PRIVATE, fd, start);\n    if (memPtr == MAP_FAILED) {\n        LOGW(\"mmap(%d, R, PRIVATE, %d, %d) failed: %s\\n\", (int) length,\n            fd, (int) start, strerror(errno));\n        return -1;\n    }\n\n    pMap->addr = memPtr;\n    pMap->length = length;\n    pMap->range_count = 1;\n    pMap->ranges = malloc(sizeof(MappedRange));\n    if (pMap->ranges == NULL) {\n        LOGE(\"malloc failed: %s\\n\", strerror(errno));\n        munmap(memPtr, length);\n        return -1;\n    }\n    pMap->ranges[0].addr = memPtr;\n    pMap->ranges[0].length = length;\n\n    return 0;\n}", "target": 2, "idx": 11768}
{"commit_id": "e079f3e2712b4f8c28e3e63e71ba1a1f90fce1ab", "project": "linuxdeepin/deepin-clone", "func": "bool DDeviceDiskInfoPrivate::openDataStream(int index)\n{\n    if (process) {\n        process->deleteLater();\n    }\n\n    process = new QProcess();\n\n    QObject::connect(process, static_cast<void (QProcess::*)(int, QProcess::ExitStatus)>(&QProcess::finished),\n                     process, [this] (int code, QProcess::ExitStatus status) {\n        if (isClosing())\n            return;\n\n        if (status == QProcess::CrashExit) {\n            setErrorString(QObject::tr(\"process \\\"%1 %2\\\" crashed\").arg(process->program()).arg(process->arguments().join(\" \")));\n        } else if (code != 0) {\n            setErrorString(QObject::tr(\"Failed to perform process \\\"%1 %2\\\", error: %3\").arg(process->program()).arg(process->arguments().join(\" \")).arg(QString::fromUtf8(process->readAllStandardError())));\n        }\n    });\n\n    switch (currentScope) {\n    case DDiskInfo::Headgear: {\n        if (type != DDiskInfo::Disk) {\n            setErrorString(QObject::tr(\"\\\"%1\\\" is not a disk device\").arg(filePath()));\n\n            return false;\n        }\n\n        if (currentMode == DDiskInfo::Read) {\n            process->start(QStringLiteral(\"dd if=%1 bs=512 count=2048 status=none\").arg(filePath()), QIODevice::ReadOnly);\n        } else {\n            process->start(QStringLiteral(\"dd of=%1 bs=512 status=none conv=fsync\").arg(filePath()));\n        }\n\n        break;\n    }\n    case DDiskInfo::PartitionTable: {\n        if (type != DDiskInfo::Disk) {\n            setErrorString(QObject::tr(\"\\\"%1\\\" is not a disk device\").arg(filePath()));\n\n            return false;\n        }\n\n        if (currentMode == DDiskInfo::Read)\n            process->start(QStringLiteral(\"sfdisk -d %1\").arg(filePath()), QIODevice::ReadOnly);\n        else\n            process->start(QStringLiteral(\"sfdisk %1 --no-reread\").arg(filePath()));\n\n        break;\n    }\n    case DDiskInfo::Partition: {\n        const DPartInfo &part = (index == 0 && currentMode == DDiskInfo::Write) ? DDevicePartInfo(filePath()) : q->getPartByNumber(index);\n\n        if (!part) {\n            dCDebug(\"Part is null(index: %d)\", index);\n\n            return false;\n        }\n\n        dCDebug(\"Try open device: %s, mode: %s\", qPrintable(part.filePath()), currentMode == DDiskInfo::Read ? \"Read\" : \"Write\");\n\n        if (Helper::isMounted(part.filePath())) {\n            if (Helper::umountDevice(part.filePath())) {\n                part.d->mountPoint.clear();\n            } else {\n                setErrorString(QObject::tr(\"\\\"%1\\\" is busy\").arg(part.filePath()));\n\n                return false;\n            }\n        }\n\n        if (currentMode == DDiskInfo::Read) {\n            const QString &executer = Helper::getPartcloneExecuter(part);\n            process->start(QStringLiteral(\"%1 -s %2 -o - -c -z %3 -L /var/log/partclone.log\").arg(executer).arg(part.filePath()).arg(Global::bufferSize), QIODevice::ReadOnly);\n        } else {\n            process->start(QStringLiteral(\"partclone.restore -s - -o %2 -z %3 -L /var/log/partclone.log\").arg(part.filePath()).arg(Global::bufferSize));\n        }\n\n        break;\n    }\n    case DDiskInfo::JsonInfo: {\n        process->deleteLater();\n        process = 0;\n        buffer.setData(q->toJson());\n        break;\n    }\n    default:\n        return false;\n    }\n\n    if (process) {\n        if (!process->waitForStarted()) {\n            setErrorString(QObject::tr(\"Failed to start \\\"%1 %2\\\", error: %3\").arg(process->program()).arg(process->arguments().join(\" \")).arg(process->errorString()));\n\n            return false;\n        }\n\n        dCDebug(\"The \\\"%s %s\\\" command start finished\", qPrintable(process->program()), qPrintable(process->arguments().join(\" \")));\n    }\n\n    bool ok = process ? process->isOpen() : buffer.open(QIODevice::ReadOnly);\n\n    if (!ok) {\n        setErrorString(QObject::tr(\"Failed to open process, error: %1\").arg(process ? process->errorString(): buffer.errorString()));\n    }\n\n    return ok;\n}", "target": 2, "idx": 11769}
{"commit_id": "55f0fc7a02de8f12757f4937143d8d5091b2e40b", "project": "torvalds/linux", "func": "void __ip_select_ident(struct iphdr *iph, int segs)\n{\n\tstatic u32 ip_idents_hashrnd __read_mostly;\n\tstatic u32 ip_idents_hashrnd_extra __read_mostly;\n\tu32 hash, id;\n\n\tnet_get_random_once(&ip_idents_hashrnd, sizeof(ip_idents_hashrnd));\n\tnet_get_random_once(&ip_idents_hashrnd_extra, sizeof(ip_idents_hashrnd_extra));\n\n\thash = jhash_3words((__force u32)iph->daddr,\n\t\t\t    (__force u32)iph->saddr,\n\t\t\t    iph->protocol ^ ip_idents_hashrnd_extra,\n\t\t\t    ip_idents_hashrnd);\n\tid = ip_idents_reserve(hash, segs);\n\tiph->id = htons(id);\n}", "target": 1, "idx": 11770}
{"commit_id": "cea98166008301e614e0d36776bf9435a536136e", "project": "TurboVNC/turbovnc", "func": "Bool rfbOptPamAuth(void)\n{\n  SecTypeData *s;\n\n  for (s = secTypes; s->name != NULL; s++) {\n    if ((!strcmp(s->name, \"unixlogin\") ||\n         strstr(s->name, \"plain\")) && s->enabled)\n      return TRUE;\n  }\n\n  return FALSE;\n}", "target": 3, "idx": 11771}
{"commit_id": "360e95d45ac4123255a4c796db96337f332160ad", "project": "OpenSC", "func": "static int\nsc_pkcs15emu_esteid_init (sc_pkcs15_card_t * p15card)\n{\n\tsc_card_t *card = p15card->card;\n\tunsigned char buff[128];\n\tint r, i;\n\tsize_t field_length = 0, modulus_length = 0;\n\tsc_path_t tmppath;\n\n\tset_string (&p15card->tokeninfo->label, \"ID-kaart\");\n\tset_string (&p15card->tokeninfo->manufacturer_id, \"AS Sertifitseerimiskeskus\");\n\n\t/* Select application directory */\n\tsc_format_path (\"3f00eeee5044\", &tmppath);\n\tr = sc_select_file (card, &tmppath, NULL);\n\tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"select esteid PD failed\");\n\n\t/* read the serial (document number) */\n\tr = sc_read_record (card, SC_ESTEID_PD_DOCUMENT_NR, buff, sizeof(buff), SC_RECORD_BY_REC_NR);\n\tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"read document number failed\");\n\tbuff[MIN((size_t) r, (sizeof buff)-1)] = '\\0';\n\tset_string (&p15card->tokeninfo->serial_number, (const char *) buff);\n\n\tp15card->tokeninfo->flags = SC_PKCS15_TOKEN_PRN_GENERATION\n\t\t\t\t  | SC_PKCS15_TOKEN_EID_COMPLIANT\n\t\t\t\t  | SC_PKCS15_TOKEN_READONLY;\n\n\t/* add certificates */\n\tfor (i = 0; i < 2; i++) {\n\t\tstatic const char *esteid_cert_names[2] = {\n\t\t\t\"Isikutuvastus\",\n\t\t\t\"Allkirjastamine\"};\n\t\tstatic char const *esteid_cert_paths[2] = {\n\t\t\t\"3f00eeeeaace\",\n\t\t\t\"3f00eeeeddce\"};\n\t\tstatic int esteid_cert_ids[2] = {1, 2};\n\n\t\tstruct sc_pkcs15_cert_info cert_info;\n\t\tstruct sc_pkcs15_object cert_obj;\n\n\t\tmemset(&cert_info, 0, sizeof(cert_info));\n\t\tmemset(&cert_obj, 0, sizeof(cert_obj));\n\n\t\tcert_info.id.value[0] = esteid_cert_ids[i];\n\t\tcert_info.id.len = 1;\n\t\tsc_format_path(esteid_cert_paths[i], &cert_info.path);\n\t\tstrlcpy(cert_obj.label, esteid_cert_names[i], sizeof(cert_obj.label));\n\t\tr = sc_pkcs15emu_add_x509_cert(p15card, &cert_obj, &cert_info);\n\t\tif (r < 0)\n\t\t\treturn SC_ERROR_INTERNAL;\n\t\tif (i == 0) {\n\t\t\tsc_pkcs15_cert_t *cert = NULL;\n\t\t\tr = sc_pkcs15_read_certificate(p15card, &cert_info, &cert);\n\t\t\tif (r < 0)\n\t\t\t\treturn SC_ERROR_INTERNAL;\n\t\t\tif (cert->key->algorithm == SC_ALGORITHM_EC)\n\t\t\t\tfield_length = cert->key->u.ec.params.field_length;\n\t\t\telse\n\t\t\t\tmodulus_length = cert->key->u.rsa.modulus.len * 8;\n\t\t\tif (r == SC_SUCCESS) {\n\t\t\t\tstatic const struct sc_object_id cn_oid = {{ 2, 5, 4, 3, -1 }};\n\t\t\t\tu8 *cn_name = NULL;\n\t\t\t\tsize_t cn_len = 0;\n\t\t\t\tsc_pkcs15_get_name_from_dn(card->ctx, cert->subject,\n\t\t\t\t\tcert->subject_len, &cn_oid, &cn_name, &cn_len);\n\t\t\t\tif (cn_len > 0) {\n\t\t\t\t\tchar *token_name = malloc(cn_len+1);\n\t\t\t\t\tif (token_name) {\n\t\t\t\t\t\tmemcpy(token_name, cn_name, cn_len);\n\t\t\t\t\t\ttoken_name[cn_len] = '\\0';\n\t\t\t\t\t\tset_string(&p15card->tokeninfo->label, (const char*)token_name);\n\t\t\t\t\t\tfree(token_name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree(cn_name);\n\t\t\t\tsc_pkcs15_free_certificate(cert);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* the file with key pin info (tries left) */\n\tsc_format_path (\"3f000016\", &tmppath);\n\tr = sc_select_file (card, &tmppath, NULL);\n\tif (r < 0)\n\t\treturn SC_ERROR_INTERNAL;\n\n\t/* add pins */\n\tfor (i = 0; i < 3; i++) {\n\t\tunsigned char tries_left;\n\t\tstatic const char *esteid_pin_names[3] = {\n\t\t\t\"PIN1\",\n\t\t\t\"PIN2\",\n\t\t\t\"PUK\" };\n\t\t\t\n\t\tstatic const int esteid_pin_min[3] = {4, 5, 8};\n\t\tstatic const int esteid_pin_ref[3] = {1, 2, 0};\n\t\tstatic const int esteid_pin_authid[3] = {1, 2, 3};\n\t\tstatic const int esteid_pin_flags[3] = {0, 0, SC_PKCS15_PIN_FLAG_UNBLOCKING_PIN};\n\t\t\n\t\tstruct sc_pkcs15_auth_info pin_info;\n\t\tstruct sc_pkcs15_object pin_obj;\n\n\t\tmemset(&pin_info, 0, sizeof(pin_info));\n\t\tmemset(&pin_obj, 0, sizeof(pin_obj));\n\n\t\t/* read the number of tries left for the PIN */\n\t\tr = sc_read_record (card, i + 1, buff, sizeof(buff), SC_RECORD_BY_REC_NR);\n\t\tif (r < 0)\n\t\t\treturn SC_ERROR_INTERNAL;\n\t\ttries_left = buff[5];\n\n\t\tpin_info.auth_id.len = 1;\n\t\tpin_info.auth_id.value[0] = esteid_pin_authid[i];\n\t\tpin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;\n\t\tpin_info.attrs.pin.reference = esteid_pin_ref[i];\n\t\tpin_info.attrs.pin.flags = esteid_pin_flags[i];\n\t\tpin_info.attrs.pin.type = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;\n\t\tpin_info.attrs.pin.min_length = esteid_pin_min[i];\n\t\tpin_info.attrs.pin.stored_length = 12;\n\t\tpin_info.attrs.pin.max_length = 12;\n\t\tpin_info.attrs.pin.pad_char = '\\0';\n\t\tpin_info.tries_left = (int)tries_left;\n\t\tpin_info.max_tries = 3;\n\n\t\tstrlcpy(pin_obj.label, esteid_pin_names[i], sizeof(pin_obj.label));\n\t\tpin_obj.flags = esteid_pin_flags[i];\n\n\t\t/* Link normal PINs with PUK */\n\t\tif (i < 2) {\n\t\t\tpin_obj.auth_id.len = 1;\n\t\t\tpin_obj.auth_id.value[0] = 3;\n\t\t}\n\n\t\tr = sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);\n\t\tif (r < 0)\n\t\t\treturn SC_ERROR_INTERNAL;\n\t}\n\n\t/* add private keys */\n\tfor (i = 0; i < 2; i++) {\n\t\tstatic int prkey_pin[2] = {1, 2};\n\n\t\tstatic const char *prkey_name[2] = {\n\t\t\t\"Isikutuvastus\",\n\t\t\t\"Allkirjastamine\"};\n\n\t\tstruct sc_pkcs15_prkey_info prkey_info;\n\t\tstruct sc_pkcs15_object prkey_obj;\n\n\t\tmemset(&prkey_info, 0, sizeof(prkey_info));\n\t\tmemset(&prkey_obj, 0, sizeof(prkey_obj));\n\n\t\tprkey_info.id.len = 1;\n\t\tprkey_info.id.value[0] = prkey_pin[i];\n\t\tprkey_info.native = 1;\n\t\tprkey_info.key_reference = i + 1;\n\t\tprkey_info.field_length = field_length;\n\t\tprkey_info.modulus_length = modulus_length;\n\t\tif (i == 1)\n\t\t\tprkey_info.usage = SC_PKCS15_PRKEY_USAGE_NONREPUDIATION;\n\t\telse if(field_length > 0) // ECC has sign and derive usage\n\t\t\tprkey_info.usage = SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_DERIVE;\n\t\telse\n\t\t\tprkey_info.usage = SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_ENCRYPT | SC_PKCS15_PRKEY_USAGE_DECRYPT;\n\n\t\tstrlcpy(prkey_obj.label, prkey_name[i], sizeof(prkey_obj.label));\n\t\tprkey_obj.auth_id.len = 1;\n\t\tprkey_obj.auth_id.value[0] = prkey_pin[i];\n\t\tprkey_obj.user_consent = 0;\n\t\tprkey_obj.flags = SC_PKCS15_CO_FLAG_PRIVATE;\n\n\t\tif(field_length > 0)\n\t\t\tr = sc_pkcs15emu_add_ec_prkey(p15card, &prkey_obj, &prkey_info);\n\t\telse\n\t\t\tr = sc_pkcs15emu_add_rsa_prkey(p15card, &prkey_obj, &prkey_info);\n\t\tif (r < 0)\n\t\t\treturn SC_ERROR_INTERNAL;\n\t}\n\n\treturn SC_SUCCESS;\n}", "target": 1, "idx": 11772}
{"commit_id": "e1caf6fb74981da62039846931ebdffed71309d1", "project": "krb5", "func": "kadm5_ret_t\nkadm5_create_principal_3(void *server_handle,\n                         kadm5_principal_ent_t entry, long mask,\n                         int n_ks_tuple, krb5_key_salt_tuple *ks_tuple,\n                         char *password)\n{\n    krb5_db_entry               *kdb;\n    osa_princ_ent_rec           adb;\n    kadm5_policy_ent_rec        polent;\n    krb5_boolean                have_polent = FALSE;\n    krb5_timestamp              now;\n    krb5_tl_data                *tl_data_tail;\n    unsigned int                ret;\n    kadm5_server_handle_t handle = server_handle;\n    krb5_keyblock               *act_mkey;\n    krb5_kvno                   act_kvno;\n    int                         new_n_ks_tuple = 0;\n    krb5_key_salt_tuple         *new_ks_tuple = NULL;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    check_1_6_dummy(entry, mask, n_ks_tuple, ks_tuple, &password);\n\n    /*\n     * Argument sanity checking, and opening up the DB\n     */\n    if (entry == NULL)\n        return EINVAL;\n    if(!(mask & KADM5_PRINCIPAL) || (mask & KADM5_MOD_NAME) ||\n       (mask & KADM5_MOD_TIME) || (mask & KADM5_LAST_PWD_CHANGE) ||\n       (mask & KADM5_MKVNO) || (mask & KADM5_AUX_ATTRIBUTES) ||\n       (mask & KADM5_LAST_SUCCESS) || (mask & KADM5_LAST_FAILED) ||\n       (mask & KADM5_FAIL_AUTH_COUNT))\n        return KADM5_BAD_MASK;\n    if ((mask & KADM5_KEY_DATA) && entry->n_key_data != 0)\n        return KADM5_BAD_MASK;\n    if((mask & KADM5_POLICY) && entry->policy == NULL)\n        return KADM5_BAD_MASK;\n    if((mask & KADM5_POLICY) && (mask & KADM5_POLICY_CLR))\n        return KADM5_BAD_MASK;\n    if((mask & ~ALL_PRINC_MASK))\n        return KADM5_BAD_MASK;\n    if (mask & KADM5_TL_DATA) {\n        for (tl_data_tail = entry->tl_data; tl_data_tail != NULL;\n             tl_data_tail = tl_data_tail->tl_data_next) {\n            if (tl_data_tail->tl_data_type < 256)\n                return KADM5_BAD_TL_TYPE;\n        }\n    }\n\n    /*\n     * Check to see if the principal exists\n     */\n    ret = kdb_get_entry(handle, entry->principal, &kdb, &adb);\n\n    switch(ret) {\n    case KADM5_UNK_PRINC:\n        break;\n    case 0:\n        kdb_free_entry(handle, kdb, &adb);\n        return KADM5_DUP;\n    default:\n        return ret;\n    }\n\n    kdb = calloc(1, sizeof(*kdb));\n    if (kdb == NULL)\n        return ENOMEM;\n    memset(&adb, 0, sizeof(osa_princ_ent_rec));\n\n    /*\n     * If a policy was specified, load it.\n     * If we can not find the one specified return an error\n     */\n    if ((mask & KADM5_POLICY)) {\n        ret = get_policy(handle, entry->policy, &polent, &have_polent);\n        if (ret)\n            goto cleanup;\n    }\n    if (password) {\n        ret = passwd_check(handle, password, have_polent ? &polent : NULL,\n                           entry->principal);\n        if (ret)\n            goto cleanup;\n    }\n    /*\n     * Start populating the various DB fields, using the\n     * \"defaults\" for fields that were not specified by the\n     * mask.\n     */\n    if ((ret = krb5_timeofday(handle->context, &now)))\n        goto cleanup;\n\n    kdb->magic = KRB5_KDB_MAGIC_NUMBER;\n    kdb->len = KRB5_KDB_V1_BASE_LENGTH; /* gag me with a chainsaw */\n\n    if ((mask & KADM5_ATTRIBUTES))\n        kdb->attributes = entry->attributes;\n    else\n        kdb->attributes = handle->params.flags;\n\n    if ((mask & KADM5_MAX_LIFE))\n        kdb->max_life = entry->max_life;\n    else\n        kdb->max_life = handle->params.max_life;\n\n    if (mask & KADM5_MAX_RLIFE)\n        kdb->max_renewable_life = entry->max_renewable_life;\n    else\n        kdb->max_renewable_life = handle->params.max_rlife;\n\n    if ((mask & KADM5_PRINC_EXPIRE_TIME))\n        kdb->expiration = entry->princ_expire_time;\n    else\n        kdb->expiration = handle->params.expiration;\n\n    kdb->pw_expiration = 0;\n    if (have_polent) {\n        if(polent.pw_max_life)\n            kdb->pw_expiration = ts_incr(now, polent.pw_max_life);\n        else\n            kdb->pw_expiration = 0;\n    }\n    if ((mask & KADM5_PW_EXPIRATION))\n        kdb->pw_expiration = entry->pw_expiration;\n\n    kdb->last_success = 0;\n    kdb->last_failed = 0;\n    kdb->fail_auth_count = 0;\n\n    /* this is kind of gross, but in order to free the tl data, I need\n       to free the entire kdb entry, and that will try to free the\n       principal. */\n\n    ret = krb5_copy_principal(handle->context, entry->principal, &kdb->princ);\n    if (ret)\n        goto cleanup;\n\n    if ((ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now)))\n        goto cleanup;\n\n    if (mask & KADM5_TL_DATA) {\n        /* splice entry->tl_data onto the front of kdb->tl_data */\n        for (tl_data_tail = entry->tl_data; tl_data_tail;\n             tl_data_tail = tl_data_tail->tl_data_next)\n        {\n            ret = krb5_dbe_update_tl_data(handle->context, kdb, tl_data_tail);\n            if( ret )\n                goto cleanup;\n        }\n    }\n\n    /*\n     * We need to have setup the TL data, so we have strings, so we can\n     * check enctype policy, which is why we check/initialize ks_tuple\n     * this late.\n     */\n    ret = apply_keysalt_policy(handle, entry->policy, n_ks_tuple, ks_tuple,\n                               &new_n_ks_tuple, &new_ks_tuple);\n    if (ret)\n        goto cleanup;\n\n    /* initialize the keys */\n\n    ret = kdb_get_active_mkey(handle, &act_kvno, &act_mkey);\n    if (ret)\n        goto cleanup;\n\n    if (mask & KADM5_KEY_DATA) {\n        /* The client requested no keys for this principal. */\n        assert(entry->n_key_data == 0);\n    } else if (password) {\n        ret = krb5_dbe_cpw(handle->context, act_mkey, new_ks_tuple,\n                           new_n_ks_tuple, password,\n                           (mask & KADM5_KVNO)?entry->kvno:1,\n                           FALSE, kdb);\n    } else {\n        /* Null password means create with random key (new in 1.8). */\n        ret = krb5_dbe_crk(handle->context, &master_keyblock,\n                           new_ks_tuple, new_n_ks_tuple, FALSE, kdb);\n    }\n    if (ret)\n        goto cleanup;\n\n    /* Record the master key VNO used to encrypt this entry's keys */\n    ret = krb5_dbe_update_mkvno(handle->context, kdb, act_kvno);\n    if (ret)\n        goto cleanup;\n\n    ret = k5_kadm5_hook_create(handle->context, handle->hook_handles,\n                               KADM5_HOOK_STAGE_PRECOMMIT, entry, mask,\n                               new_n_ks_tuple, new_ks_tuple, password);\n    if (ret)\n        goto cleanup;\n\n    /* populate the admin-server-specific fields.  In the OV server,\n       this used to be in a separate database.  Since there's already\n       marshalling code for the admin fields, to keep things simple,\n       I'm going to keep it, and make all the admin stuff occupy a\n       single tl_data record, */\n\n    adb.admin_history_kvno = INITIAL_HIST_KVNO;\n    if (mask & KADM5_POLICY) {\n        adb.aux_attributes = KADM5_POLICY;\n\n        /* this does *not* need to be strdup'ed, because adb is xdr */\n        /* encoded in osa_adb_create_princ, and not ever freed */\n\n        adb.policy = entry->policy;\n    }\n\n    /* In all cases key and the principal data is set, let the database provider know */\n    kdb->mask = mask | KADM5_KEY_DATA | KADM5_PRINCIPAL ;\n\n    /* store the new db entry */\n    ret = kdb_put_entry(handle, kdb, &adb);\n\n    (void) k5_kadm5_hook_create(handle->context, handle->hook_handles,\n                                KADM5_HOOK_STAGE_POSTCOMMIT, entry, mask,\n                                new_n_ks_tuple, new_ks_tuple, password);\n\ncleanup:\n    free(new_ks_tuple);\n    krb5_db_free_principal(handle->context, kdb);\n    if (have_polent)\n        (void) kadm5_free_policy_ent(handle->lhandle, &polent);\n    return ret;\n}", "target": 1, "idx": 11773}
{"commit_id": "8e89fe0e175d2870c39486fdd09250b230ec10b8", "project": "strukturag/libde265", "func": "de265_error video_usability_information::read(error_queue* errqueue, bitreader* br,\n                                              const seq_parameter_set* sps)\n{\n  int vlc;\n\n\n  // --- sample aspect ratio (SAR) ---\n\n  aspect_ratio_info_present_flag = get_bits(br, 1);\n  if (aspect_ratio_info_present_flag) {\n    int aspect_ratio_idc = get_bits(br, 8);\n    if (aspect_ratio_idc <= NUM_SAR_PRESETS) {\n      sar_width = sar_presets[aspect_ratio_idc][0];\n      sar_height = sar_presets[aspect_ratio_idc][1];\n    }\n    else if (aspect_ratio_idc == EXTENDED_SAR) {\n      sar_width = get_bits(br, 16);\n      sar_height = get_bits(br, 16);\n    }\n    else {\n      sar_width = 0;\n      sar_height = 0;\n    }\n  }\n  else {\n    sar_width = 0;\n    sar_height = 0;\n  }\n\n\n  // --- overscan ---\n\n  overscan_info_present_flag = get_bits(br, 1);\n  if (overscan_info_present_flag) {\n    overscan_appropriate_flag = get_bits(br, 1);\n  }\n\n\n  // --- video signal type ---\n\n  { // defaults\n    video_format = VideoFormat_Unspecified;\n    video_full_range_flag = false;\n    colour_primaries = 2;\n    transfer_characteristics = 2;\n    matrix_coeffs = 2;\n  }\n\n  video_signal_type_present_flag = get_bits(br, 1);\n  if (video_signal_type_present_flag) {\n    int video_format_idc = get_bits(br, 3);\n    if (video_format_idc > 5) {\n      video_format_idc = VideoFormat_Unspecified;\n    }\n    video_format = (VideoFormat)video_format_idc;\n\n    video_full_range_flag = get_bits(br, 1);\n\n    colour_description_present_flag = get_bits(br, 1);\n    if (colour_description_present_flag) {\n      colour_primaries = get_bits(br, 8);\n      if (colour_primaries == 0 ||\n        colour_primaries == 3 ||\n        colour_primaries >= 11) {\n        colour_primaries = 2;\n      }\n\n      transfer_characteristics = get_bits(br, 8);\n      if (transfer_characteristics == 0 ||\n        transfer_characteristics == 3 ||\n        transfer_characteristics >= 18) {\n        transfer_characteristics = 2;\n      }\n\n      matrix_coeffs = get_bits(br, 8);\n      \n      if (matrix_coeffs >= 11) {\n        matrix_coeffs = 2;\n      }\n    }\n  }\n\n\n  // --- chroma / interlaced ---\n\n  chroma_loc_info_present_flag = get_bits(br, 1);\n  if (chroma_loc_info_present_flag) {\n    READ_VLC(chroma_sample_loc_type_top_field, uvlc);\n    READ_VLC(chroma_sample_loc_type_bottom_field, uvlc);\n  }\n  else {\n    chroma_sample_loc_type_top_field = 0;\n    chroma_sample_loc_type_bottom_field = 0;\n  }\n\n  neutral_chroma_indication_flag = get_bits(br, 1);\n  field_seq_flag = get_bits(br, 1);\n  frame_field_info_present_flag = get_bits(br, 1);\n\n\n  // --- default display window ---\n\n  default_display_window_flag = get_bits(br, 1);\n  if (default_display_window_flag) {\n    READ_VLC(def_disp_win_left_offset, uvlc);\n    READ_VLC(def_disp_win_right_offset, uvlc);\n    READ_VLC(def_disp_win_top_offset, uvlc);\n    READ_VLC(def_disp_win_bottom_offset, uvlc);\n  }\n  else {\n    def_disp_win_left_offset = 0;\n    def_disp_win_right_offset = 0;\n    def_disp_win_top_offset = 0;\n    def_disp_win_bottom_offset = 0;\n  }\n\n\n  // --- timing ---\n\n  vui_timing_info_present_flag = get_bits(br, 1);\n  if (vui_timing_info_present_flag) {\n    vui_num_units_in_tick = get_bits(br, 32);\n    vui_time_scale = get_bits(br, 32);\n\n    vui_poc_proportional_to_timing_flag = get_bits(br, 1);\n    if (vui_poc_proportional_to_timing_flag) {\n      READ_VLC_OFFSET(vui_num_ticks_poc_diff_one, uvlc, 1);\n    }\n\n    // --- hrd parameters ---\n\n    vui_hrd_parameters_present_flag = get_bits(br, 1);\n    if (vui_hrd_parameters_present_flag) {\n      de265_error err;\n      err = hrd_parameters(errqueue, br, sps);\n      if (err) {\n\treturn err;\n      }\n    }\n  }\n\n  // --- bitstream restriction ---\n\n  bitstream_restriction_flag = get_bits(br,1);\n  if (bitstream_restriction_flag) {\n    tiles_fixed_structure_flag = get_bits(br,1);\n    motion_vectors_over_pic_boundaries_flag = get_bits(br,1);\n    restricted_ref_pic_lists_flag = get_bits(br,1);\n\n    READ_VLC(min_spatial_segmentation_idc, uvlc);\n    if (min_spatial_segmentation_idc > 4095) {\n      errqueue->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);\n      min_spatial_segmentation_idc = 0;\n    }\n\n    READ_VLC(max_bytes_per_pic_denom, uvlc);\n    if (max_bytes_per_pic_denom > 16) {\n      errqueue->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);\n      max_bytes_per_pic_denom = 2;\n    }\n\n    READ_VLC(max_bits_per_min_cu_denom, uvlc);\n    if (max_bits_per_min_cu_denom > 16) {\n      errqueue->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);\n      max_bits_per_min_cu_denom = 1;\n    }\n\n    READ_VLC(log2_max_mv_length_horizontal, uvlc);\n    if (log2_max_mv_length_horizontal > 15) {\n      errqueue->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);\n      log2_max_mv_length_horizontal = 15;\n    }\n\n    READ_VLC(log2_max_mv_length_vertical, uvlc);\n    if (log2_max_mv_length_vertical > 15) {\n      errqueue->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);\n      log2_max_mv_length_vertical = 15;\n    }\n  }\n  else {\n    tiles_fixed_structure_flag = false;\n    motion_vectors_over_pic_boundaries_flag = true;\n    restricted_ref_pic_lists_flag = false; // NOTE: default not specified in standard 2014/10\n\n    min_spatial_segmentation_idc = 0;\n    max_bytes_per_pic_denom   = 2;\n    max_bits_per_min_cu_denom = 1;\n    log2_max_mv_length_horizontal = 15;\n    log2_max_mv_length_vertical   = 15;\n  }\n\n  //vui_read = true;\n\n  return DE265_OK;\n}", "target": 3, "idx": 11774}
{"commit_id": "dc308c05ba0673460fe80873b22d296880ee996d", "project": "wireshark", "func": "static gboolean vwr_read_s1_W_rec(vwr_t *vwr, struct wtap_pkthdr *phdr,\n                                  Buffer *buf, const guint8 *rec, int rec_size,\n                                  int *err, gchar **err_info)\n{\n    guint8           *data_ptr;\n    int              bytes_written = 0;                   /* bytes output to buf so far */\n    const guint8     *s_ptr, *m_ptr;                      /* stats pointer */\n    guint16          msdu_length, actual_octets;          /* octets in frame */\n    guint16          plcp_hdr_len;                        /* PLCP header length */\n    guint16          rflags;\n    guint8           m_type;                              /* mod type (CCK-L/CCK-S/OFDM), seqnum */\n    guint            flow_seq;\n    guint64          s_time = LL_ZERO, e_time = LL_ZERO;  /* start/end */\n                                                          /* times, nsec */\n    guint32          latency;\n    guint64          start_time, s_sec, s_usec = LL_ZERO; /* start time, sec + usec */\n    guint64          end_time;                            /* end time */\n    guint32          info;                                /* INFO/ERRORS fields in stats blk */\n    gint8            rssi;                                /* RSSI, signed 8-bit number */\n    int              f_tx;                                /* flag: if set, is a TX frame */\n    guint8           plcp_type, mcs_index, nss;           /* PLCP type 0: Legacy, 1: Mixed, 2: Green field, 3: VHT Mixed */\n    guint16          vc_id, ht_len=0;                     /* VC ID, total ip length */\n    guint            flow_id;                             /* flow ID */\n    guint32          d_time, errors;                      /* packet duration & errors */\n    int              sig_off, pay_off;                    /* MAC+SNAP header len, signature offset */\n    guint64          sig_ts;                              /* 32 LSBs of timestamp in signature */\n    guint16          phyRate;\n    guint16          vw_flags;                            /* VeriWave-specific packet flags */\n\n    /*\n     * The record data must be large enough to hold the statistics trailer.\n     */\n    if (rec_size < v22_W_STATS_LEN) {\n        *err_info = g_strdup_printf(\"vwr: Invalid record length %d (must be at least %u)\",\n                                    rec_size, v22_W_STATS_LEN);\n        *err = WTAP_ERR_BAD_FILE;\n        return FALSE;\n    }\n\n    /* Calculate the start of the statistics block in the buffer */\n    /* Also get a bunch of fields from the stats block */\n    s_ptr    = &(rec[rec_size - v22_W_STATS_LEN]); /* point to it */\n    m_type   = s_ptr[v22_W_MTYPE_OFF] & 0x7;\n    f_tx     = !(s_ptr[v22_W_MTYPE_OFF] & 0x8);\n    actual_octets   = pntoh16(&s_ptr[v22_W_OCTET_OFF]);\n    vc_id    = pntoh16(&s_ptr[v22_W_VCID_OFF]) & 0x3ff;\n    flow_seq = s_ptr[v22_W_FLOWSEQ_OFF];\n\n    latency = (guint32)pcorey48tohll(&s_ptr[v22_W_LATVAL_OFF]);\n\n    flow_id = pntoh16(&s_ptr[v22_W_FLOWID_OFF+1]);  /* only 16 LSBs kept */\n    errors  = pntoh16(&s_ptr[v22_W_ERRORS_OFF]);\n\n    info = pntoh16(&s_ptr[v22_W_INFO_OFF]);\n    rssi = (s_ptr[v22_W_RSSI_OFF] & 0x80) ? (-1 * (s_ptr[v22_W_RSSI_OFF] & 0x7f)) : s_ptr[v22_W_RSSI_OFF];\n\n    /*\n     * Sanity check the octets field to determine if it's greater than\n     * the packet data available in the record - i.e., the record size\n     * minus the length of the statistics block.\n     *\n     * Report an error if it is.\n     */\n    if (actual_octets > rec_size - v22_W_STATS_LEN) {\n        *err_info = g_strdup_printf(\"vwr: Invalid data length %u (runs past the end of the record)\",\n                                    actual_octets);\n        *err = WTAP_ERR_BAD_FILE;\n        return FALSE;\n    }\n\n    /* Decode OFDM or CCK PLCP header and determine rate and short preamble flag. */\n    /* The SIGNAL byte is always the first byte of the PLCP header in the frame.  */\n    plcp_type = 0;\n    nss = 1;\n    if (m_type == vwr->MT_OFDM)\n        mcs_index = get_ofdm_rate(rec);\n    else if ((m_type == vwr->MT_CCKL) || (m_type == vwr->MT_CCKS))\n        mcs_index = get_cck_rate(rec);\n    else\n        mcs_index = 1;\n    rflags  = (m_type == vwr->MT_CCKS) ? FLAGS_SHORTPRE : 0;\n    /* Calculate the MPDU size/ptr stuff; MPDU starts at 4 or 6 depending on OFDM/CCK. */\n    /* Note that the number of octets in the frame also varies depending on OFDM/CCK,  */\n    /*  because the PLCP header is prepended to the actual MPDU.                       */\n    plcp_hdr_len = (m_type == vwr->MT_OFDM) ? 4 : 6;\n    if (actual_octets >= plcp_hdr_len)\n       actual_octets -= plcp_hdr_len;\n    else {\n        *err_info = g_strdup_printf(\"vwr: Invalid data length %u (too short to include %u-byte PLCP header)\",\n                                    actual_octets, plcp_hdr_len);\n        *err = WTAP_ERR_BAD_FILE;\n        return FALSE;\n    }\n    m_ptr = &rec[plcp_hdr_len];\n    msdu_length = actual_octets;\n\n    /*\n     * The MSDU length includes the FCS.\n     *\n     * The packet data does *not* include the FCS - it's just 4 bytes\n     * of junk - so we have to remove it.\n     *\n     * We'll be stripping off an FCS (?), so make sure we have at\n     * least 4 octets worth of FCS.\n     */\n    if (actual_octets < 4) {\n        *err_info = g_strdup_printf(\"vwr: Invalid data length %u (too short to include %u-byte PLCP header and 4 bytes of FCS)\",\n                                    actual_octets, plcp_hdr_len);\n        *err = WTAP_ERR_BAD_FILE;\n        return FALSE;\n    }\n    actual_octets -= 4;\n\n    /* Calculate start & end times (in sec/usec), converting 64-bit times to usec. */\n    /* 64-bit times are \"Corey-endian\" */\n    s_time = pcoreytohll(&s_ptr[v22_W_STARTT_OFF]);\n    e_time = pcoreytohll(&s_ptr[v22_W_ENDT_OFF]);\n\n    /* find the packet duration (difference between start and end times) */\n    d_time = (guint32)((e_time - s_time) / NS_IN_US);   /* find diff, converting to usec */\n\n    /* also convert the packet start time to seconds and microseconds */\n    start_time = s_time / NS_IN_US;                /* convert to microseconds first  */\n    s_sec      = (start_time / US_IN_SEC);         /* get the number of seconds      */\n    s_usec     = start_time - (s_sec * US_IN_SEC); /* get the number of microseconds */\n\n    /* also convert the packet end time to seconds and microseconds */\n    end_time = e_time / NS_IN_US;                       /* convert to microseconds first */\n\n    /* extract the 32 LSBs of the signature timestamp field from the data block*/\n    pay_off = 42;    /* 24 (MAC) + 8 (SNAP) + IP */\n    sig_off = find_signature(m_ptr, rec_size - 6, pay_off, flow_id, flow_seq);\n    if (m_ptr[sig_off] == 0xdd)\n        sig_ts = get_signature_ts(m_ptr, sig_off, rec_size - v22_W_STATS_LEN);\n    else\n        sig_ts = 0;\n\n    /*\n     * Fill up the per-packet header.\n     *\n     * We also zero out 16 bytes PLCP header and 1 byte of L1P for user\n     * position.\n     *\n     * XXX - for S1, do we even have that?  The current Veriwave dissector\n     * just blindly assumes there's a 17-byte blob before the 802.11\n     * header, which is why we fill in those extra zero bytes.\n     *\n     * We include the length of the metadata headers in the packet lengths.\n     *\n     * The maximum value of actual_octets is 65535, which, even after\n     * adding the lengths of the metadata headers, is less than\n     * WTAP_MAX_PACKET_SIZE will ever be, so we don't need to check it.\n     */\n    phdr->len = STATS_COMMON_FIELDS_LEN + EXT_WLAN_FIELDS_LEN + 1 + 16 + actual_octets;\n    phdr->caplen = STATS_COMMON_FIELDS_LEN + EXT_WLAN_FIELDS_LEN + 1 + 16 + actual_octets;\n\n    phdr->ts.secs   = (time_t)s_sec;\n    phdr->ts.nsecs  = (int)(s_usec * 1000);\n    phdr->pkt_encap = WTAP_ENCAP_IXVERIWAVE;\n\n    phdr->rec_type = REC_TYPE_PACKET;\n    phdr->presence_flags = WTAP_HAS_TS;\n\n    ws_buffer_assure_space(buf, phdr->caplen);\n    data_ptr = ws_buffer_start_ptr(buf);\n\n    /*\n     * Generate and copy out the common metadata headers,\n     * set the port type to 0 (WLAN).\n     *\n     * All values are copied out in little-endian byte order.\n     */\n    phtoles(&data_ptr[bytes_written], 0); /* port_type */\n    bytes_written += 2;\n    phtoles(&data_ptr[bytes_written], STATS_COMMON_FIELDS_LEN); /* it_len */\n    bytes_written += 2;\n    phtoles(&data_ptr[bytes_written], msdu_length);\n    bytes_written += 2;\n    phtolel(&data_ptr[bytes_written], flow_id);\n    bytes_written += 4;\n    phtoles(&data_ptr[bytes_written], vc_id);\n    bytes_written += 2;\n    phtoles(&data_ptr[bytes_written], flow_seq);\n    bytes_written += 2;\n    if (!f_tx && sig_ts != 0) {\n        phtolel(&data_ptr[bytes_written], latency);\n    } else {\n        phtolel(&data_ptr[bytes_written], 0);\n    }\n    bytes_written += 4;\n    phtolel(&data_ptr[bytes_written], sig_ts); /* 32 LSBs of signature timestamp (nsec) */\n    bytes_written += 4;\n    phtolell(&data_ptr[bytes_written], start_time); /* record start & end times of frame */\n    bytes_written += 8;\n    phtolell(&data_ptr[bytes_written], end_time);\n    bytes_written += 8;\n    phtolel(&data_ptr[bytes_written], d_time);\n    bytes_written += 4;\n\n    /*\n     * Generate and copy out the WLAN metadata headers.\n     *\n     * All values are copied out in little-endian byte order.\n     */\n    phtoles(&data_ptr[bytes_written], EXT_WLAN_FIELDS_LEN);\n    bytes_written += 2;\n    phtoles(&data_ptr[bytes_written], rflags);\n    bytes_written += 2;\n    if (m_type == vwr->MT_OFDM) {\n        phtoles(&data_ptr[bytes_written], CHAN_OFDM);\n    } else {\n        phtoles(&data_ptr[bytes_written], CHAN_CCK);\n    }\n    bytes_written += 2;\n    phyRate = (guint16)(getRate(plcp_type, mcs_index, rflags, nss) * 10);\n    phtoles(&data_ptr[bytes_written], phyRate);\n    bytes_written += 2;\n    data_ptr[bytes_written] = plcp_type;\n    bytes_written += 1;\n    data_ptr[bytes_written] = mcs_index;\n    bytes_written += 1;\n    data_ptr[bytes_written] = nss;\n    bytes_written += 1;\n    data_ptr[bytes_written] = rssi;\n    bytes_written += 1;\n    /* antennae b, c, d signal power */\n    data_ptr[bytes_written] = 100;\n    bytes_written += 1;\n    data_ptr[bytes_written] = 100;\n    bytes_written += 1;\n    data_ptr[bytes_written] = 100;\n    bytes_written += 1;\n    /* padding */\n    data_ptr[bytes_written] = 0;\n    bytes_written += 1;\n\n    /* fill in the VeriWave flags field */\n    vw_flags = 0;\n    if (f_tx)\n        vw_flags |= VW_FLAGS_TXF;\n    if (errors & vwr->FCS_ERROR)\n        vw_flags |= VW_FLAGS_FCSERR;\n    if (!f_tx && (errors & vwr->CRYPTO_ERR))\n        vw_flags |= VW_FLAGS_DCRERR;\n    if (!f_tx && (errors & vwr->RETRY_ERR))\n        vw_flags |= VW_FLAGS_RETRERR;\n    if (info & vwr->WEPTYPE)\n        vw_flags |= VW_FLAGS_IS_WEP;\n    else if (info & vwr->TKIPTYPE)\n        vw_flags |= VW_FLAGS_IS_TKIP;\n    else if (info & vwr->CCMPTYPE)\n        vw_flags |= VW_FLAGS_IS_CCMP;\n    phtoles(&data_ptr[bytes_written], vw_flags);\n    bytes_written += 2;\n\n    phtoles(&data_ptr[bytes_written], ht_len);\n    bytes_written += 2;\n    phtoles(&data_ptr[bytes_written], info);\n    bytes_written += 2;\n    phtolel(&data_ptr[bytes_written], errors);\n    bytes_written += 4;\n\n    /*\n     * No VHT, no VHT NDP flag, so just zero.\n     *\n     * XXX - is this supposed to be the RX L1 info, i.e. the \"1 byte of L1P\n     * for user position\"?\n     */\n    data_ptr[bytes_written] = 0;\n    bytes_written += 1;\n\n    /*\n     * XXX - put a PLCP header here?  That's what's done for S3.\n     */\n    memset(&data_ptr[bytes_written], 0, 16);\n    bytes_written += 16;\n\n    /*\n     * Finally, copy the whole MAC frame to the packet buffer as-is.\n     * This does not include the PLCP; the MPDU starts at 4 or 6\n     * depending on OFDM/CCK.\n     * This also does not include the last 4 bytes, as those don't\n     * contain an FCS, they just contain junk.\n     */\n    memcpy(&data_ptr[bytes_written], &rec[plcp_hdr_len], actual_octets);\n\n    return TRUE;\n}", "target": 1, "idx": 11775}
{"commit_id": "1ac1697b3b019f50729a6e992065959586e170da", "project": "GNOME/gdm", "func": "static void\ngdm_display_store_class_init (GdmDisplayStoreClass *klass)\n{\n        GObjectClass   *object_class = G_OBJECT_CLASS (klass);\n\n        object_class->finalize = gdm_display_store_finalize;\n\n        signals [DISPLAY_ADDED] =\n                g_signal_new (\"display-added\",\n                              G_TYPE_FROM_CLASS (object_class),\n                              G_SIGNAL_RUN_LAST,\n                              G_STRUCT_OFFSET (GdmDisplayStoreClass, display_added),\n                              NULL,\n                              NULL,\n                              g_cclosure_marshal_VOID__STRING,\n                              G_TYPE_NONE,\n                              1, G_TYPE_STRING);\n        signals [DISPLAY_REMOVED] =\n                g_signal_new (\"display-removed\",\n                              G_TYPE_FROM_CLASS (object_class),\n                              G_SIGNAL_RUN_LAST,\n                              G_STRUCT_OFFSET (GdmDisplayStoreClass, display_removed),\n                              NULL,\n                              NULL,\n                              g_cclosure_marshal_VOID__OBJECT,\n                              G_TYPE_NONE,\n                              1, G_TYPE_OBJECT);\n\n        g_type_class_add_private (klass, sizeof (GdmDisplayStorePrivate));\n}", "target": 2, "idx": 11776}
{"commit_id": "64875fa98ff6afd2f21a9727970fb4333efe95de", "project": "Haivision/srt", "func": "void CSndUList::remove_(const CUDT* u)\n{\n   CSNode* n = u->m_pSNode;\n\n   if (n->m_iHeapLoc >= 0)\n   {\n      // remove the node from heap\n      m_pHeap[n->m_iHeapLoc] = m_pHeap[m_iLastEntry];\n      m_iLastEntry --;\n      m_pHeap[n->m_iHeapLoc]->m_iHeapLoc = n->m_iHeapLoc;\n\n      int q = n->m_iHeapLoc;\n      int p = q * 2 + 1;\n      while (p <= m_iLastEntry)\n      {\n         if ((p + 1 <= m_iLastEntry) && (m_pHeap[p]->m_llTimeStamp_tk > m_pHeap[p + 1]->m_llTimeStamp_tk))\n            p ++;\n\n         if (m_pHeap[q]->m_llTimeStamp_tk > m_pHeap[p]->m_llTimeStamp_tk)\n         {\n            swap(m_pHeap[p], m_pHeap[q]);\n            m_pHeap[p]->m_iHeapLoc = p;\n            m_pHeap[q]->m_iHeapLoc = q;\n\n            q = p;\n            p = q * 2 + 1;\n         }\n         else\n            break;\n      }\n\n      n->m_iHeapLoc = -1;\n   }\n\n   // the only event has been deleted, wake up immediately\n   if (0 == m_iLastEntry)\n      m_pTimer->interrupt();\n}", "target": 3, "idx": 11777}
{"commit_id": "c175308407858afff3fc8c2e5e085d94d12edc7d", "project": "openssl", "func": "int BN_hex2bn(BIGNUM **bn, const char *a)\n{\n    BIGNUM *ret = NULL;\n    BN_ULONG l = 0;\n    int neg = 0, h, m, i, j, k, c;\n    int num;\n\n    if ((a == NULL) || (*a == '\\0'))\n        return (0);\n\n    if (*a == '-') {\n        neg = 1;\n        a++;\n    }\n\n    for (i = 0; i <= (INT_MAX/4) && isxdigit((unsigned char)a[i]); i++)\n        continue;\n\n    if (i > INT_MAX/4)\n        goto err;\n\n    num = i + neg;\n    if (bn == NULL)\n        return (num);\n\n    /* a is the start of the hex digits, and it is 'i' long */\n    if (*bn == NULL) {\n        if ((ret = BN_new()) == NULL)\n            return (0);\n    } else {\n        ret = *bn;\n        BN_zero(ret);\n    }\n\n    /* i is the number of hex digits */\n    if (bn_expand(ret, i * 4) == NULL)\n        goto err;\n\n    j = i;                      /* least significant 'hex' */\n    m = 0;\n    h = 0;\n    while (j > 0) {\n        m = ((BN_BYTES * 2) <= j) ? (BN_BYTES * 2) : j;\n        l = 0;\n        for (;;) {\n            c = a[j - m];\n            if ((c >= '0') && (c <= '9'))\n                k = c - '0';\n            else if ((c >= 'a') && (c <= 'f'))\n                k = c - 'a' + 10;\n            else if ((c >= 'A') && (c <= 'F'))\n                k = c - 'A' + 10;\n            else\n                k = 0;          /* paranoia */\n            l = (l << 4) | k;\n\n            if (--m <= 0) {\n                ret->d[h++] = l;\n                break;\n            }\n        }\n        j -= (BN_BYTES * 2);\n    }\n    ret->top = h;\n    bn_correct_top(ret);\n    ret->neg = neg;\n\n    *bn = ret;\n    bn_check_top(ret);\n    return (num);\n err:\n    if (*bn == NULL)\n        BN_free(ret);\n    return (0);\n}", "target": 2, "idx": 11778}
{"commit_id": "3ebba796fa251d042be42b929a2d916ee5c34a49", "project": "torvalds/linux", "func": "static void io_disable_sqo_submit(struct io_ring_ctx *ctx)\n{\n\tmutex_lock(&ctx->uring_lock);\n\tctx->sqo_dead = 1;\n\tif (ctx->flags & IORING_SETUP_R_DISABLED)\n\t\tio_sq_offload_start(ctx);\n\tmutex_unlock(&ctx->uring_lock);\n\n\t/* make sure callers enter the ring to get error */\n\tif (ctx->rings)\n\t\tio_ring_set_wakeup_flag(ctx);\n}", "target": 1, "idx": 11779}
{"commit_id": "45ef78e037f578b15fc58938a3a3251655e71d6f", "project": "lurcher/unixODBC", "func": "SQLWCHAR* _single_string_alloc_and_expand( LPCSTR in )\n{\n    SQLWCHAR *chr;\n    int len = 0;\n\n    if ( !in )\n    {\n        return NULL;\n    }\n\n    while ( in[ len ] != 0 )\n    {\n        len ++;\n    }\n\n    chr = malloc( sizeof( SQLWCHAR ) * ( len + 1 ));\n\n    len = 0;\n    while ( in[ len ] != 0 )\n    {\n        chr[ len ] = in[ len ];\n        len ++;\n    }\n    chr[ len ++ ] = 0;\n\n    return chr;\n}", "target": 3, "idx": 11780}
{"commit_id": "6d2fd968d8d520283b96986945a1b91c8a60131b", "project": "appneta/tcpreplay", "func": "u_char *_our_safe_pcap_next(pcap_t *pcap,  struct pcap_pkthdr *pkthdr,\n        const char *funcname, const int line, const char *file)\n{\n    u_char *pktdata = (u_char *)pcap_next(pcap, pkthdr);\n\n    if (pktdata) {\n        if (pkthdr->len > MAXPACKET) {\n            fprintf(stderr, \"safe_pcap_next ERROR: Invalid packet length in %s:%s() line %d: %u is greater than maximum %u\\n\",\n                    file, funcname, line, pkthdr->len, MAXPACKET);\n            exit(-1);\n        }\n\n        if (pkthdr->len < pkthdr->caplen) {\n            fprintf(stderr, \"safe_pcap_next ERROR: Invalid packet length in %s:%s() line %d: packet length %u is less than capture length %u\\n\",\n                    file, funcname, line, pkthdr->len, pkthdr->caplen);\n            exit(-1);\n        }\n    }\n\n    return pktdata;\n}", "target": 2, "idx": 11781}
{"commit_id": "ff489d95a9006be080ad14feb378f2b4dac35552", "project": "tensorflow", "func": "TfLiteStatus EvalHybrid(TfLiteContext* context, TfLiteNode* node,\n                        TfLiteConvParams* params, OpData* data,\n                        const TfLiteTensor* input, const TfLiteTensor* filter,\n                        const TfLiteTensor* bias, TfLiteTensor* im2col,\n                        TfLiteTensor* accum_scratch, TfLiteTensor* output) {\n  float output_activation_min, output_activation_max;\n  CalculateActivationRange(params->activation, &output_activation_min,\n                           &output_activation_max);\n\n  const int batch_size = SizeOfDimension(input, 0);\n  TF_LITE_ENSURE(context, batch_size != 0);\n  const int input_size = NumElements(input) / batch_size;\n\n  const float* input_ptr = GetTensorData<float>(input);\n  TfLiteTensor* quantized_input_tensor;\n  TF_LITE_ENSURE_OK(context,\n                    GetTemporarySafe(context, node, data->input_quantized_index,\n                                     &quantized_input_tensor));\n  int8_t* quantized_input_ptr_batch =\n      GetTensorData<int8_t>(quantized_input_tensor);\n  TfLiteTensor* scaling_factors_tensor;\n  TF_LITE_ENSURE_OK(context,\n                    GetTemporarySafe(context, node, data->scaling_factors_index,\n                                     &scaling_factors_tensor));\n  float* scaling_factors_ptr = GetTensorData<float>(scaling_factors_tensor);\n\n  // Per-batch input quantization for higher accuracy.\n  {\n    ruy::profiler::ScopeLabel label(\"ConvHybridQuantizeInputs\");\n    for (int b = 0; b < batch_size; ++b) {\n      float unused_min, unused_max;\n      const int offset = b * input_size;\n      tensor_utils::SymmetricQuantizeFloats(\n          input_ptr + offset, input_size, quantized_input_ptr_batch + offset,\n          &unused_min, &unused_max, &scaling_factors_ptr[b]);\n      scaling_factors_ptr[b] *= filter->params.scale;\n    }\n  }\n\n  switch (kernel_type) {\n    case kReference:\n    case kGenericOptimized:\n    case kMultithreadOptimized:\n    case kCblasOptimized: {\n      // There is only one implementation for hybrid kernel.\n      ConvParams op_params;\n      op_params.padding_type = PaddingType::kSame;\n      op_params.padding_values.width = data->padding.width;\n      op_params.padding_values.height = data->padding.height;\n      op_params.stride_width = params->stride_width;\n      op_params.stride_height = params->stride_height;\n      op_params.dilation_width_factor = params->dilation_width_factor;\n      op_params.dilation_height_factor = params->dilation_height_factor;\n      op_params.float_activation_min = output_activation_min;\n      op_params.float_activation_max = output_activation_max;\n      optimized_ops::HybridConv(\n          op_params, scaling_factors_ptr, GetTensorShape(input),\n          quantized_input_ptr_batch, GetTensorShape(filter),\n          GetTensorData<int8_t>(filter), GetTensorShape(bias),\n          GetTensorData<float>(bias), GetTensorShape(accum_scratch),\n          GetTensorData<int32_t>(accum_scratch), GetTensorShape(output),\n          GetTensorData<float>(output), GetTensorShape(im2col),\n          GetTensorData<int8_t>(im2col),\n          CpuBackendContext::GetFromContext(context));\n      break;\n    }\n  }\n\n  return kTfLiteOk;\n}", "target": 0, "idx": 11782}
{"commit_id": "c24922e692a52121e853a84ead6b9337f4c08a94", "project": "the-tcpdump-group/tcpdump", "func": "static int\nrx_cache_find(const struct rx_header *rxh, const struct ip *ip, int sport,\n\t      int32_t *opcode)\n{\n\tint i;\n\tstruct rx_cache_entry *rxent;\n\tuint32_t clip;\n\tuint32_t sip;\n\n\tUNALIGNED_MEMCPY(&clip, &ip->ip_dst, sizeof(uint32_t));\n\tUNALIGNED_MEMCPY(&sip, &ip->ip_src, sizeof(uint32_t));\n\n\t/* Start the search where we last left off */\n\n\ti = rx_cache_hint;\n\tdo {\n\t\trxent = &rx_cache[i];\n\t\tif (rxent->callnum == EXTRACT_32BITS(&rxh->callNumber) &&\n\t\t    rxent->client.s_addr == clip &&\n\t\t    rxent->server.s_addr == sip &&\n\t\t    rxent->serviceId == EXTRACT_16BITS(&rxh->serviceId) &&\n\t\t    rxent->dport == sport) {\n\n\t\t\t/* We got a match! */\n\n\t\t\trx_cache_hint = i;\n\t\t\t*opcode = rxent->opcode;\n\t\t\treturn(1);\n\t\t}\n\t\tif (++i >= RX_CACHE_SIZE)\n\t\t\ti = 0;\n\t} while (i != rx_cache_hint);\n\n\t/* Our search failed */\n\treturn(0);\n}", "target": 2, "idx": 11783}
{"commit_id": "a7b467b151d9b54badbc4dd71e7a366b7c391817", "project": "gpac", "func": "static GF_Err gf_isom_set_root_iod(GF_ISOFile *movie)\n{\n\tGF_IsomInitialObjectDescriptor *iod;\n\tGF_IsomObjectDescriptor *od;\n\tGF_Err e;\n\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\tif (!movie->moov->iods) {\n\t\tAddMovieIOD(movie->moov, 1);\n\t\treturn GF_OK;\n\t}\n\t//if OD, switch to IOD\n\tif (movie->moov->iods->descriptor->tag == GF_ODF_ISOM_IOD_TAG) return GF_OK;\n\tod = (GF_IsomObjectDescriptor *) movie->moov->iods->descriptor;\n\tiod = (GF_IsomInitialObjectDescriptor*)gf_malloc(sizeof(GF_IsomInitialObjectDescriptor));\n\tif (!iod) return GF_OUT_OF_MEM;\n\n\tmemset(iod, 0, sizeof(GF_IsomInitialObjectDescriptor));\n\n\tiod->ES_ID_IncDescriptors = od->ES_ID_IncDescriptors;\n\tod->ES_ID_IncDescriptors = NULL;\n\t//not used in root OD\n\tiod->ES_ID_RefDescriptors = NULL;\n\tiod->extensionDescriptors = od->extensionDescriptors;\n\tod->extensionDescriptors = NULL;\n\tiod->IPMP_Descriptors = od->IPMP_Descriptors;\n\tod->IPMP_Descriptors = NULL;\n\tiod->objectDescriptorID = od->objectDescriptorID;\n\tiod->OCIDescriptors = od->OCIDescriptors;\n\tod->OCIDescriptors = NULL;\n\tiod->tag = GF_ODF_ISOM_IOD_TAG;\n\tiod->URLString = od->URLString;\n\tod->URLString = NULL;\n\n\tgf_odf_desc_del((GF_Descriptor *) od);\n\tmovie->moov->iods->descriptor = (GF_Descriptor *)iod;\n\treturn GF_OK;\n}", "target": 1, "idx": 11784}
{"commit_id": "d7505276842e85bfd067fa21cdb32b8a2dc3c5e4", "project": "the-tcpdump-group/tcpdump", "func": "static void\nrpl_dao_print(netdissect_options *ndo,\n              const u_char *bp, u_int length)\n{\n        const struct nd_rpl_dao *dao = (const struct nd_rpl_dao *)bp;\n        const char *dagid_str = \"<elided>\";\n\n        ND_TCHECK(*dao);\n        if (length < ND_RPL_DAO_MIN_LEN)\n        \tgoto tooshort;\n\n        bp += ND_RPL_DAO_MIN_LEN;\n        length -= ND_RPL_DAO_MIN_LEN;\n        if(RPL_DAO_D(dao->rpl_flags)) {\n                ND_TCHECK2(dao->rpl_dagid, DAGID_LEN);\n                if (length < DAGID_LEN)\n                \tgoto tooshort;\n                dagid_str = ip6addr_string (ndo, dao->rpl_dagid);\n                bp += DAGID_LEN;\n                length -= DAGID_LEN;\n        }\n\n        ND_PRINT((ndo, \" [dagid:%s,seq:%u,instance:%u%s%s,%02x]\",\n                  dagid_str,\n                  dao->rpl_daoseq,\n                  dao->rpl_instanceid,\n                  RPL_DAO_K(dao->rpl_flags) ? \",acK\":\"\",\n                  RPL_DAO_D(dao->rpl_flags) ? \",Dagid\":\"\",\n                  dao->rpl_flags));\n\n        if(ndo->ndo_vflag > 1) {\n                const struct rpl_dio_genoption *opt = (const struct rpl_dio_genoption *)bp;\n                rpl_dio_printopt(ndo, opt, length);\n        }\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \"%s\", rpl_tstr));\n\treturn;\n\ntooshort:\n\tND_PRINT((ndo,\" [|length too short]\"));\n\treturn;\n}", "target": 2, "idx": 11785}
{"commit_id": "5ddda15d89f5ac82f4416208c5319ace4aecdc36", "project": "mc2-project/opaque-sql", "func": "void ecall_encrypt(uint8_t *plaintext, uint32_t plaintext_length,\n                   uint8_t *ciphertext, uint32_t cipher_length) {\n  // Guard against encrypting or overwriting enclave memory\n  assert(sgx_is_outside_enclave(plaintext, plaintext_length) == 1);\n  assert(sgx_is_outside_enclave(ciphertext, cipher_length) == 1);\n  sgx_lfence();\n\n  try {\n    // IV (12 bytes) + ciphertext + mac (16 bytes)\n    assert(cipher_length >= plaintext_length + SGX_AESGCM_IV_SIZE + SGX_AESGCM_MAC_SIZE);\n    (void)cipher_length;\n    (void)plaintext_length;\n    encrypt(plaintext, plaintext_length, ciphertext);\n  } catch (const std::runtime_error &e) {\n    ocall_throw(e.what());\n  }\n}", "target": 2, "idx": 11786}
{"commit_id": "693dc40936a9eeac0e1c10ff496b3d327e25642b", "project": "wireshark", "func": "static int\ndissect_sec_payload(tvbuff_t *tvb, gint *offset, packet_info *pinfo, proto_tree *part_tree)\n{\n    gint start = *offset;\n    guint32 tmp_val;\n    guint32 param_len;\n    proto_tree *field_tree;\n    proto_item *ti;\n\n    tmp_val = tvb_get_guint8(tvb, *offset);\n    if (tmp_val == signed_external) {\n        proto_tree_add_item(part_tree, hf_sgeonw_payload_field_type, tvb, *offset, 1, ENC_BIG_ENDIAN);\n        *offset += 1;\n    }\n    else {\n        ti = proto_tree_add_item(part_tree, hf_sgeonw_payload_field, tvb, *offset, 0, ENC_NA);\n        field_tree = proto_item_add_subtree(ti, ett_sgeonw_field);\n        proto_tree_add_item(field_tree, hf_sgeonw_payload_field_type, tvb, *offset, 1, ENC_BIG_ENDIAN);\n        *offset += 1;\n        switch(tmp_val) {\n            case unsecured:\n            case signed_pl:\n                param_len = dissect_sec_var_len(tvb, offset, pinfo, field_tree);\n                if (param_len) {\n                    tvbuff_t *next_tvb = tvb_new_subset_length(tvb, *offset, param_len);\n                    p_add_proto_data(pinfo->pool, pinfo, proto_geonw, SEC_TVB_KEY, next_tvb);\n                }\n                *offset += param_len;\n                break;\n            case encrypted:\n            case signed_and_encrypted:\n                param_len = dissect_sec_var_len(tvb, offset, pinfo, field_tree);\n                proto_tree_add_item(field_tree, hf_sgeonw_opaque, tvb, *offset, param_len, ENC_NA);\n                *offset += param_len;\n                break;\n            default:\n                // Opaque\n                param_len = dissect_sec_var_len(tvb, offset, pinfo, field_tree);\n                proto_tree_add_item(field_tree, hf_sgeonw_opaque, tvb, *offset, param_len, ENC_NA);\n                *offset += param_len;\n        }\n        proto_item_set_end(ti, tvb, *offset);\n    }\n\n    return (*offset) - start;\n}", "target": 1, "idx": 11787}
{"commit_id": "d892291fb8ace4c3b734ea5125770989c215df3f", "project": "wget", "func": "static bool\nskip_short_body (int fd, wgint contlen, bool chunked)\n{\n  enum {\n    SKIP_SIZE = 512,                /* size of the download buffer */\n    SKIP_THRESHOLD = 4096        /* the largest size we read */\n  };\n  wgint remaining_chunk_size = 0;\n  char dlbuf[SKIP_SIZE + 1];\n  dlbuf[SKIP_SIZE] = '\\0';        /* so DEBUGP can safely print it */\n\n  /* If the body is too large, it makes more sense to simply close the\n     connection than to try to read the body.  */\n  if (contlen > SKIP_THRESHOLD)\n    return false;\n\n  while (contlen > 0 || chunked)\n    {\n      int ret;\n      if (chunked)\n        {\n          if (remaining_chunk_size == 0)\n            {\n              char *line = fd_read_line (fd);\n              char *endl;\n              if (line == NULL)\n                break;\n\n              remaining_chunk_size = strtol (line, &endl, 16);\n              xfree (line);\n\n              if (remaining_chunk_size < 0)\n                return false;\n\n              if (remaining_chunk_size == 0)\n                {\n                  line = fd_read_line (fd);\n                  xfree (line);\n                  break;\n                }\n            }\n\n          contlen = MIN (remaining_chunk_size, SKIP_SIZE);\n        }\n\n      DEBUGP ((\"Skipping %s bytes of body: [\", number_to_static_string (contlen)));\n\n      ret = fd_read (fd, dlbuf, MIN (contlen, SKIP_SIZE), -1);\n      if (ret <= 0)\n        {\n          /* Don't normally report the error since this is an\n             optimization that should be invisible to the user.  */\n          DEBUGP ((\"] aborting (%s).\\n\",\n                   ret < 0 ? fd_errstr (fd) : \"EOF received\"));\n          return false;\n        }\n      contlen -= ret;\n\n      if (chunked)\n        {\n          remaining_chunk_size -= ret;\n          if (remaining_chunk_size == 0)\n            {\n              char *line = fd_read_line (fd);\n              if (line == NULL)\n                return false;\n              else\n                xfree (line);\n            }\n        }\n\n      /* Safe even if %.*s bogusly expects terminating \\0 because\n         we've zero-terminated dlbuf above.  */\n      DEBUGP ((\"%.*s\", ret, dlbuf));\n    }\n\n  DEBUGP ((\"] done.\\n\"));\n  return true;\n}", "target": 2, "idx": 11788}
{"commit_id": "5513b40999149090987a0341c018d05d3eea1272", "project": "gnulib", "func": "static bin_tree_t *\nparse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree, *branch = NULL;\n  bitset_word_t initial_bkref_map = dfa->completed_bkref_map;\n  tree = parse_branch (regexp, preg, token, syntax, nest, err);\n  if (BE (*err != REG_NOERROR && tree == NULL, 0))\n    return NULL;\n\n  while (token->type == OP_ALT)\n    {\n      fetch_token (token, regexp, syntax | RE_CARET_ANCHORS_HERE);\n      if (token->type != OP_ALT && token->type != END_OF_RE\n\t  && (nest == 0 || token->type != OP_CLOSE_SUBEXP))\n\t{\n\t  bitset_word_t accumulated_bkref_map = dfa->completed_bkref_map;\n\t  dfa->completed_bkref_map = initial_bkref_map;\n\t  branch = parse_branch (regexp, preg, token, syntax, nest, err);\n\t  if (BE (*err != REG_NOERROR && branch == NULL, 0))\n\t    {\n\t      if (tree != NULL)\n\t\tpostorder (tree, free_tree, NULL);\n\t      return NULL;\n\t    }\n\t  dfa->completed_bkref_map |= accumulated_bkref_map;\n\t}\n      else\n\tbranch = NULL;\n      tree = create_tree (dfa, tree, branch, OP_ALT);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n    }\n  return tree;\n}", "target": 2, "idx": 11789}
{"commit_id": "9667e3eff2d34c3797c3b529370de47b2c1f1bf6", "project": "android", "func": "status_t BnHDCP::onTransact(\n        uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {\n    switch (code) {\n        case HDCP_SET_OBSERVER:\n        {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n            sp<IHDCPObserver> observer =\n                interface_cast<IHDCPObserver>(data.readStrongBinder());\n\n            reply->writeInt32(setObserver(observer));\n            return OK;\n        }\n\n        case HDCP_INIT_ASYNC:\n        {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n            const char *host = data.readCString();\n            unsigned port = data.readInt32();\n\n            reply->writeInt32(initAsync(host, port));\n            return OK;\n        }\n\n        case HDCP_SHUTDOWN_ASYNC:\n        {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n            reply->writeInt32(shutdownAsync());\n            return OK;\n        }\n\n        case HDCP_GET_CAPS:\n        {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n            reply->writeInt32(getCaps());\n            return OK;\n        }\n\n        case HDCP_ENCRYPT:\n        {\n            size_t size = data.readInt32();\n            void *inData = NULL;\n            // watch out for overflow\n            if (size <= SIZE_MAX / 2) {\n                inData = malloc(2 * size);\n            }\n            if (inData == NULL) {\n                reply->writeInt32(ERROR_OUT_OF_RANGE);\n                return OK;\n            }\n\n            void *outData = (uint8_t *)inData + size;\n\n            status_t err = data.read(inData, size);\n            if (err != OK) {\n                free(inData);\n                reply->writeInt32(err);\n                return OK;\n            }\n\n            uint32_t streamCTR = data.readInt32();\n            uint64_t inputCTR;\n            err = encrypt(inData, size, streamCTR, &inputCTR, outData);\n\n            reply->writeInt32(err);\n\n            if (err == OK) {\n                reply->writeInt64(inputCTR);\n                reply->write(outData, size);\n            }\n\n            free(inData);\n            inData = outData = NULL;\n\n            return OK;\n        }\n\n        case HDCP_ENCRYPT_NATIVE:\n        {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();\n            data.read(*graphicBuffer);\n            size_t offset = data.readInt32();\n            size_t size = data.readInt32();\n            uint32_t streamCTR = data.readInt32();\n            void *outData = malloc(size);\n            uint64_t inputCTR;\n\n            status_t err = encryptNative(graphicBuffer, offset, size,\n                                         streamCTR, &inputCTR, outData);\n\n            reply->writeInt32(err);\n\n            if (err == OK) {\n                reply->writeInt64(inputCTR);\n                reply->write(outData, size);\n            }\n\n            free(outData);\n            outData = NULL;\n\n            return OK;\n        }\n\n        case HDCP_DECRYPT:\n        {\n            size_t size = data.readInt32();\n            size_t bufSize = 2 * size;\n\n            // watch out for overflow\n            void *inData = NULL;\n            if (bufSize > size) {\n                inData = malloc(bufSize);\n            }\n\n            if (inData == NULL) {\n                reply->writeInt32(ERROR_OUT_OF_RANGE);\n                return OK;\n            }\n\n            void *outData = (uint8_t *)inData + size;\n\n            data.read(inData, size);\n\n            uint32_t streamCTR = data.readInt32();\n            uint64_t inputCTR = data.readInt64();\n            status_t err = decrypt(inData, size, streamCTR, inputCTR, outData);\n\n            reply->writeInt32(err);\n\n            if (err == OK) {\n                reply->write(outData, size);\n            }\n\n            free(inData);\n            inData = outData = NULL;\n\n            return OK;\n        }\n\n        default:\n            return BBinder::onTransact(code, data, reply, flags);\n    }\n}", "target": 1, "idx": 11790}
{"commit_id": "870219c58c0804bdc55419b2e455c06ac715a835", "project": "vim", "func": "void\nadjust_skipcol(void)\n{\n    if (!curwin->w_p_wrap\n\t    || !curwin->w_p_sms\n\t    || curwin->w_cursor.lnum != curwin->w_topline)\n\treturn;\n\n    int\t    width1 = curwin->w_width - curwin_col_off();\n    if (width1 <= 0)\n\treturn;  // no text will be displayed\n\n    int\t    width2 = width1 + curwin_col_off2();\n    long    so = get_scrolloff_value();\n    int\t    scrolloff_cols = so == 0 ? 0 : width1 + (so - 1) * width2;\n    int\t    scrolled = FALSE;\n\n    validate_cheight();\n    if (curwin->w_cline_height == curwin->w_height\n\t    // w_cline_height may be capped at w_height, check there aren't\n\t    // actually more lines.\n\t    && plines_win(curwin, curwin->w_cursor.lnum, FALSE)\n\t\t\t\t\t\t\t   <= curwin->w_height)\n    {\n\t// the line just fits in the window, don't scroll\n\treset_skipcol();\n\treturn;\n    }\n\n    validate_virtcol();\n    while (curwin->w_skipcol > 0\n\t\t && curwin->w_virtcol < curwin->w_skipcol + 3 + scrolloff_cols)\n    {\n\t// scroll a screen line down\n\tif (curwin->w_skipcol >= width1 + width2)\n\t    curwin->w_skipcol -= width2;\n\telse\n\t    curwin->w_skipcol -= width1;\n\tredraw_later(UPD_NOT_VALID);\n\tscrolled = TRUE;\n\tvalidate_virtcol();\n    }\n    if (scrolled)\n\treturn;  // don't scroll in the other direction now\n\n    int col = curwin->w_virtcol - curwin->w_skipcol + scrolloff_cols;\n    int row = 0;\n    if (col >= width1)\n    {\n\tcol -= width1;\n\t++row;\n    }\n    if (col > width2)\n    {\n\trow += col / width2;\n\tcol = col % width2;\n    }\n    if (row >= curwin->w_height)\n    {\n\tif (curwin->w_skipcol == 0)\n\t{\n\t    curwin->w_skipcol += width1;\n\t    --row;\n\t}\n\tif (row >= curwin->w_height)\n\t    curwin->w_skipcol += (row - curwin->w_height) * width2;\n\tredraw_later(UPD_NOT_VALID);\n    }\n}", "target": 2, "idx": 11791}
{"commit_id": "97ef22088bd312cafe62f9c454d67beb038fd8f8", "project": "espruino/Espruino", "func": "void jswrap_spi_send4bit(JsVar *parent, JsVar *srcdata, int bit0, int bit1, Pin nss_pin) {\n  if (!jsvIsObject(parent)) return;\n  IOEventFlags device = jsiGetDeviceFromClass(parent);\n  if (!DEVICE_IS_SPI(device)) {\n    jsExceptionHere(JSET_ERROR, \"SPI.send4bit only works on hardware SPI\");\n    return;\n  }\n\n  jshSPISet16(device, true); // 16 bit output\n\n  if (bit0==0 && bit1==0) {\n    bit0 = 0x01;\n    bit1 = 0x03;\n  }\n  bit0 = bit0 & 0x0F;\n  bit1 = bit1 & 0x0F;\n\n  if (!jshIsDeviceInitialised(device)) {\n    JshSPIInfo inf;\n    jshSPIInitInfo(&inf);\n    jshSPISetup(device, &inf);\n  }\n\n  // we're just sending (no receive)\n  jshSPISetReceive(device, false);\n  // assert NSS\n  if (nss_pin!=PIN_UNDEFINED) jshPinOutput(nss_pin, false);\n\n  // send data\n  if (jsvIsNumeric(srcdata)) {\n    jsspiSend4bit(device, (unsigned char)jsvGetInteger(srcdata), bit0, bit1);\n  } else if (jsvIsIterable(srcdata)) {\n    jshInterruptOff();\n    JsvIterator it;\n    jsvIteratorNew(&it, srcdata, JSIF_EVERY_ARRAY_ELEMENT);\n    while (jsvIteratorHasElement(&it)) {\n      unsigned char in = (unsigned char)jsvIteratorGetIntegerValue(&it);\n      jsspiSend4bit(device, in, bit0, bit1);\n      jsvIteratorNext(&it);\n    }\n    jsvIteratorFree(&it);\n    jshInterruptOn();\n  } else {\n    jsExceptionHere(JSET_ERROR, \"Variable type %t not suited to transmit operation\", srcdata);\n  }\n\n  jshSPIWait(device); // wait until SPI send finished and clear the RX buffer\n\n  // de-assert NSS\n  if (nss_pin!=PIN_UNDEFINED) jshPinOutput(nss_pin, true);\n  jshSPISet16(device, false); // back to 8 bit\n}", "target": 1, "idx": 11792}
{"commit_id": "c2e197e4efc663ca55f393bf0e799848842286f3", "project": "php/php-src", "func": "static void spl_multiple_iterator_get_all(spl_SplObjectStorage *intern, int get_type, zval *return_value TSRMLS_DC) /* {{{ */\n{\n\tspl_SplObjectStorageElement *element;\n\tzval                        *it, *retval = NULL;\n\tint                          valid = 1, num_elements;\n\n\tnum_elements = zend_hash_num_elements(&intern->storage);\n\tif (num_elements < 1) {\n\t\tRETURN_FALSE;\n\t}\n\n\tarray_init_size(return_value, num_elements);\n\n\tzend_hash_internal_pointer_reset_ex(&intern->storage, &intern->pos);\n\twhile (zend_hash_get_current_data_ex(&intern->storage, (void**)&element, &intern->pos) == SUCCESS && !EG(exception)) {\n\t\tit = element->obj;\n\t\tzend_call_method_with_0_params(&it, Z_OBJCE_P(it), &Z_OBJCE_P(it)->iterator_funcs.zf_valid, \"valid\", &retval);\n\n\t\tif (retval) {\n\t\t\tvalid = Z_LVAL_P(retval);\n\t\t\tzval_ptr_dtor(&retval);\n\t\t} else {\n\t\t\tvalid = 0;\n\t\t}\n\n\t\tif (valid) {\n\t\t\tif (SPL_MULTIPLE_ITERATOR_GET_ALL_CURRENT == get_type) {\n\t\t\t\tzend_call_method_with_0_params(&it, Z_OBJCE_P(it), &Z_OBJCE_P(it)->iterator_funcs.zf_current, \"current\", &retval);\n\t\t\t} else {\n\t\t\t\tzend_call_method_with_0_params(&it, Z_OBJCE_P(it), &Z_OBJCE_P(it)->iterator_funcs.zf_key,     \"key\",     &retval);\n\t\t\t}\n\t\t\tif (!retval) {\n\t\t\t\tzend_throw_exception(spl_ce_RuntimeException, \"Failed to call sub iterator method\", 0 TSRMLS_CC);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else if (intern->flags & MIT_NEED_ALL) {\n\t\t\tif (SPL_MULTIPLE_ITERATOR_GET_ALL_CURRENT == get_type) {\n\t\t\t\tzend_throw_exception(spl_ce_RuntimeException, \"Called current() with non valid sub iterator\", 0 TSRMLS_CC);\n\t\t\t} else {\n\t\t\t\tzend_throw_exception(spl_ce_RuntimeException, \"Called key() with non valid sub iterator\", 0 TSRMLS_CC);\n\t\t\t}\n\t\t\treturn;\n\t\t} else {\n\t\t\tALLOC_INIT_ZVAL(retval);\n\t\t}\n\n\t\tif (intern->flags & MIT_KEYS_ASSOC) {\n\t\t\tswitch (Z_TYPE_P(element->inf)) {\n\t\t\t\tcase IS_LONG:\n\t\t\t\t\tadd_index_zval(return_value, Z_LVAL_P(element->inf), retval);\n\t\t\t\t\tbreak;\n\t\t\t\tcase IS_STRING:\n\t\t\t\t\tadd_assoc_zval_ex(return_value, Z_STRVAL_P(element->inf), Z_STRLEN_P(element->inf)+1U, retval);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tzval_ptr_dtor(&retval);\n\t\t\t\t\tzend_throw_exception(spl_ce_InvalidArgumentException, \"Sub-Iterator is associated with NULL\", 0 TSRMLS_CC);\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tadd_next_index_zval(return_value, retval);\n\t\t}\n\n\t\tzend_hash_move_forward_ex(&intern->storage, &intern->pos);\n\t}\n}", "target": 2, "idx": 11793}
{"commit_id": "5800dc5c19f34e6e03b5adab1282535cb102fafd", "project": "torvalds/linux", "func": "unsigned paravirt_patch_call(void *insnbuf,\n\t\t\t     const void *target, u16 tgt_clobbers,\n\t\t\t     unsigned long addr, u16 site_clobbers,\n\t\t\t     unsigned len)\n{\n\tstruct branch *b = insnbuf;\n\tunsigned long delta = (unsigned long)target - (addr+5);\n\n\tif (len < 5) {\n#ifdef CONFIG_RETPOLINE\n\t\tWARN_ONCE(\"Failing to patch indirect CALL in %ps\\n\", (void *)addr);\n#endif\n\t\treturn len;\t/* call too long for patch site */\n\t}\n\n\tb->opcode = 0xe8; /* call */\n\tb->delta = delta;\n\tBUILD_BUG_ON(sizeof(*b) != 5);\n\n\treturn 5;\n}", "target": 1, "idx": 11794}
{"commit_id": "f8eda05ad3696181dccbb1aad95c3b87a3897a0e", "project": "pdfium", "func": "void sycc420_to_rgb(opj_image_t* img) {\n  if (!sycc420_size_is_valid(img))\n    return;\n\n  OPJ_UINT32 prec = img->comps[0].prec;\n  if (!prec)\n    return;\n  OPJ_UINT32 offset = 1 << (prec - 1);\n  OPJ_UINT32 upb = (1 << prec) - 1;\n  OPJ_UINT32 yw = img->comps[0].w;\n  OPJ_UINT32 yh = img->comps[0].h;\n  OPJ_UINT32 cbw = img->comps[1].w;\n  OPJ_UINT32 cbh = img->comps[1].h;\n  OPJ_UINT32 crw = img->comps[2].w;\n  bool extw = sycc420_must_extend_cbcr(yw, cbw);\n  bool exth = sycc420_must_extend_cbcr(yh, cbh);\n  FX_SAFE_DWORD safeSize = yw;\n  safeSize *= yh;\n  if (!safeSize.IsValid())\n    return;\n  int* r = FX_Alloc(int, safeSize.ValueOrDie());\n  int* g = FX_Alloc(int, safeSize.ValueOrDie());\n  int* b = FX_Alloc(int, safeSize.ValueOrDie());\n  int* d0 = r;\n  int* d1 = g;\n  int* d2 = b;\n  const int* y = img->comps[0].data;\n  const int* cb = img->comps[1].data;\n  const int* cr = img->comps[2].data;\n  const int* ny = nullptr;\n  int* nr = nullptr;\n  int* ng = nullptr;\n  int* nb = nullptr;\n  OPJ_UINT32 i = 0;\n  OPJ_UINT32 j = 0;\n  for (i = 0; i < (yh & ~(OPJ_UINT32)1); i += 2) {\n    ny = y + yw;\n    nr = r + yw;\n    ng = g + yw;\n    nb = b + yw;\n    for (j = 0; j < (yw & ~(OPJ_UINT32)1); j += 2) {\n      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n      ++y;\n      ++r;\n      ++g;\n      ++b;\n      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n      ++y;\n      ++r;\n      ++g;\n      ++b;\n      sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n      ++ny;\n      ++nr;\n      ++ng;\n      ++nb;\n      sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n      ++ny;\n      ++nr;\n      ++ng;\n      ++nb;\n      ++cb;\n      ++cr;\n    }\n    if (j < yw) {\n      if (extw) {\n        --cb;\n        --cr;\n      }\n      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n      ++y;\n      ++r;\n      ++g;\n      ++b;\n      sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n      ++ny;\n      ++nr;\n      ++ng;\n      ++nb;\n      ++cb;\n      ++cr;\n    }\n    y += yw;\n    r += yw;\n    g += yw;\n    b += yw;\n  }\n  if (i < yh) {\n    if (exth) {\n      cb -= cbw;\n      cr -= crw;\n    }\n    for (j = 0; j < (yw & ~(OPJ_UINT32)1); j += 2) {\n      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n      ++y;\n      ++r;\n      ++g;\n      ++b;\n      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n      ++y;\n      ++r;\n      ++g;\n      ++b;\n      ++cb;\n      ++cr;\n    }\n    if (j < yw) {\n      if (extw) {\n        --cb;\n        --cr;\n      }\n      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n    }\n  }\n\n  FX_Free(img->comps[0].data);\n  img->comps[0].data = d0;\n  FX_Free(img->comps[1].data);\n  img->comps[1].data = d1;\n  FX_Free(img->comps[2].data);\n  img->comps[2].data = d2;\n  img->comps[1].w = yw;\n  img->comps[1].h = yh;\n  img->comps[2].w = yw;\n  img->comps[2].h = yh;\n  img->comps[1].w = yw;\n  img->comps[1].h = yh;\n  img->comps[2].w = yw;\n  img->comps[2].h = yh;\n  img->comps[1].dx = img->comps[0].dx;\n  img->comps[2].dx = img->comps[0].dx;\n  img->comps[1].dy = img->comps[0].dy;\n  img->comps[2].dy = img->comps[0].dy;\n}", "target": 2, "idx": 11795}
{"commit_id": "634ce8e8a5accc0fa05dd2c20d42b4749d4b2735", "project": "jasper-software/jasper", "func": "static jas_image_cmpt_t *jas_image_cmpt_create(int_fast32_t tlx,\n  int_fast32_t tly, int_fast32_t hstep, int_fast32_t vstep,\n  int_fast32_t width, int_fast32_t height, uint_fast16_t depth, bool sgnd,\n  uint_fast32_t inmem)\n{\n\tjas_image_cmpt_t *cmpt;\n\tsize_t size;\n\n\tcmpt = 0;\n\tif (width < 0 || height < 0 || hstep <= 0 || vstep <= 0) {\n\t\tgoto error;\n\t}\n\tif (!jas_safe_intfast32_add(tlx, width, 0) ||\n\t  !jas_safe_intfast32_add(tly, height, 0)) {\n\t\tgoto error;\n\t}\n\n\tif (!(cmpt = jas_malloc(sizeof(jas_image_cmpt_t)))) {\n\t\tgoto error;\n\t}\n\n\tcmpt->type_ = JAS_IMAGE_CT_UNKNOWN;\n\tcmpt->tlx_ = tlx;\n\tcmpt->tly_ = tly;\n\tcmpt->hstep_ = hstep;\n\tcmpt->vstep_ = vstep;\n\tcmpt->width_ = width;\n\tcmpt->height_ = height;\n\tcmpt->prec_ = depth;\n\tcmpt->sgnd_ = sgnd;\n\tcmpt->stream_ = 0;\n\tcmpt->cps_ = (depth + 7) / 8;\n\n\t// Compute the number of samples in the image component, while protecting\n\t// against overflow.\n\t// size = cmpt->width_ * cmpt->height_ * cmpt->cps_;\n\tif (!jas_safe_size_mul(cmpt->width_, cmpt->height_, &size) ||\n\t  !jas_safe_size_mul(size, cmpt->cps_, &size)) {\n\t\tgoto error;\n\t}\n\tcmpt->stream_ = (inmem) ? jas_stream_memopen2(0, size) :\n\t  jas_stream_tmpfile();\n\tif (!cmpt->stream_) {\n\t\tgoto error;\n\t}\n\n\t/* Zero the component data.  This isn't necessary, but it is\n\tconvenient for debugging purposes. */\n\t/* Note: conversion of size - 1 to long can overflow */\n\tif (jas_stream_seek(cmpt->stream_, size - 1, SEEK_SET) < 0 ||\n\t  jas_stream_putc(cmpt->stream_, 0) == EOF ||\n\t  jas_stream_seek(cmpt->stream_, 0, SEEK_SET) < 0) {\n\t\tgoto error;\n\t}\n\n\treturn cmpt;\n\nerror:\n\tif (cmpt) {\n\t\tjas_image_cmpt_destroy(cmpt);\n\t}\n\treturn 0;\n}", "target": 1, "idx": 11796}
{"commit_id": "cb2595c1393b4a5211534e6f0a0fbad369e21ad8", "project": "torvalds/linux", "func": "static struct ucma_multicast* ucma_alloc_multicast(struct ucma_context *ctx)\n{\n\tstruct ucma_multicast *mc;\n\n\tmc = kzalloc(sizeof(*mc), GFP_KERNEL);\n\tif (!mc)\n\t\treturn NULL;\n\n\tmutex_lock(&mut);\n\tmc->id = idr_alloc(&multicast_idr, NULL, 0, 0, GFP_KERNEL);\n\tmutex_unlock(&mut);\n\tif (mc->id < 0)\n\t\tgoto error;\n\n\tmc->ctx = ctx;\n\tlist_add_tail(&mc->list, &ctx->mc_list);\n\treturn mc;\n\nerror:\n\tkfree(mc);\n\treturn NULL;\n}", "target": 2, "idx": 11797}
{"commit_id": "d493524612edb6763c6ec07355ce584d83695e9b", "project": "marcobambini/gravity", "func": "inline gravity_value_t convert_value2string (gravity_vm *vm, gravity_value_t v) {\n\tif (VALUE_ISA_STRING(v)) return v;\n\t\n\t// handle conversion for basic classes\n\tif (VALUE_ISA_INT(v)) {\n\t\tchar buffer[512];\n\t\t#if GRAVITY_ENABLE_INT64\n\t\tsnprintf(buffer, sizeof(buffer), \"%\" PRId64, v.n);\n\t\t#else\n\t\tsnprintf(buffer, sizeof(buffer), \"%d\", v.n);\n\t\t#endif\n\t\treturn VALUE_FROM_CSTRING(vm, buffer);\n\t\t\n\t}\n\tif (VALUE_ISA_BOOL(v)) return VALUE_FROM_CSTRING(vm, (v.n) ? \"true\" : \"false\");\n\tif (VALUE_ISA_NULL(v)) return VALUE_FROM_CSTRING(vm, \"null\");\n\tif (VALUE_ISA_UNDEFINED(v)) return VALUE_FROM_CSTRING(vm, \"undefined\");\n\tif (VALUE_ISA_FLOAT(v)) {\n\t\tchar buffer[512];\n\t\tsnprintf(buffer, sizeof(buffer), \"%f\", v.f);\n\t\treturn VALUE_FROM_CSTRING(vm, buffer);\n\t}\n\t\n\tif (VALUE_ISA_CLASS(v)) {\n\t\tconst char *identifier = (VALUE_AS_CLASS(v)->identifier);\n\t\tif (!identifier) identifier = \"anonymous class\";\n\t\treturn VALUE_FROM_CSTRING(vm, identifier);\n\t}\n\t\n\tif (VALUE_ISA_FUNCTION(v)) {\n\t\tconst char *identifier = (VALUE_AS_FUNCTION(v)->identifier);\n\t\tif (!identifier) identifier = \"anonymous func\";\n\t\treturn VALUE_FROM_CSTRING(vm, identifier);\n\t}\n\t\n\tif (VALUE_ISA_CLOSURE(v)) {\n\t\tconst char *identifier = (VALUE_AS_CLOSURE(v)->f->identifier);\n\t\tif (!identifier) identifier = \"anonymous func\";\n\t\treturn VALUE_FROM_CSTRING(vm, identifier);\n\t}\n\t\n\tif (VALUE_ISA_LIST(v)) {\n\t\tgravity_list_t *list = VALUE_AS_LIST(v);\n\t\treturn convert_list2string(vm, list);\n\t}\n\t\n\tif (VALUE_ISA_MAP(v)) {\n\t\tgravity_map_t *map = VALUE_AS_MAP(v);\n\t\treturn convert_map2string(vm, map);\n\t}\n\t\n\t// check if class implements the String method (avoiding infinte loop by checking for convert_object_string)\n\tgravity_closure_t *closure = gravity_vm_fastlookup(vm, gravity_value_getclass(v), GRAVITY_STRING_INDEX);\n\t\n\t// sanity check (and break recursion)\n    if ((!closure) || ((closure->f->tag == EXEC_TYPE_INTERNAL) && (closure->f->internal == convert_object_string)) ||\n        gravity_vm_getclosure(vm) == closure) return VALUE_FROM_ERROR(NULL);\n\t\n\t// execute closure and return its value\n\tif (gravity_vm_runclosure(vm, closure, v, NULL, 0)) return gravity_vm_result(vm);\n\t\n\treturn VALUE_FROM_ERROR(NULL);\n}", "target": 3, "idx": 11798}
{"commit_id": "737e1f39da80e02912953269966d89afd196ad30", "project": "gpac", "func": "GF_EXPORT\nGF_AVCConfig *gf_isom_svc_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tif (gf_isom_get_avc_svc_type(the_file, trackNumber, DescriptionIndex)==GF_ISOM_AVCTYPE_NONE)\n\t\treturn NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\tif (!entry) return NULL;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return NULL;\n\tif (!entry->svc_config) return NULL;\n\treturn AVC_DuplicateConfig(entry->svc_config->config);\n}", "target": 2, "idx": 11799}
{"commit_id": "6709d4b7bc2e079241fdef15d1160581c5261c10", "project": "torvalds/linux", "func": "int nfc_llcp_data_received(struct nfc_dev *dev, struct sk_buff *skb)\n{\n\tstruct nfc_llcp_local *local;\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tkfree_skb(skb);\n\t\treturn -ENODEV;\n\t}\n\n\t__nfc_llcp_recv(local, skb);\n\n\tnfc_llcp_local_put(local);\n\n\treturn 0;\n}", "target": 1, "idx": 11800}
{"commit_id": "cb517a4a434387e74a2f75ebb106ee3c3893251c", "project": "wireshark", "func": "static int\ndissect_ieee1905(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n        void *data _U_)\n{\n    proto_item *ti;\n    proto_tree *ieee1905_tree;\n    guint16    message_type;\n    guint       offset = 0;\n    static const int *flags[] = {\n      &hf_ieee1905_last_fragment,\n      &hf_ieee1905_relay_indicator,\n      NULL\n    };\n    gboolean eom_seen = 0;\n\n    col_set_str(pinfo->cinfo, COL_PROTOCOL, \"ieee1905\");\n\n    col_clear(pinfo->cinfo, COL_INFO);\n\n    message_type = tvb_get_ntohs(tvb, 2);\n\n    col_add_str(pinfo->cinfo, COL_INFO,\n                val_to_str_ext(message_type, &ieee1905_message_type_vals_ext,\n                        \"Unknown: %u\"));\n\n    ti = proto_tree_add_item(tree, proto_ieee1905, tvb, 0, -1, ENC_NA);\n\n    ieee1905_tree = proto_item_add_subtree(ti, ett_ieee1905);\n\n    proto_tree_add_item(ieee1905_tree, hf_ieee1905_message_version, tvb, offset, 1, ENC_NA);\n    offset++;\n\n    proto_tree_add_item(ieee1905_tree, hf_ieee1905_message_reserved, tvb, offset, 1, ENC_NA);\n    offset++;\n\n    proto_tree_add_item(ieee1905_tree, hf_ieee1905_message_type, tvb, offset, 2, ENC_BIG_ENDIAN);\n    offset += 2;\n\n    proto_tree_add_item(ieee1905_tree, hf_ieee1905_message_id, tvb, offset, 2, ENC_BIG_ENDIAN);\n    offset += 2;\n\n    proto_tree_add_item(ieee1905_tree, hf_ieee1905_fragment_id, tvb, offset, 1, ENC_NA);\n    offset++;\n\n    proto_tree_add_bitmask(ieee1905_tree, tvb, offset, hf_ieee1905_flags,\n                           ett_ieee1905_flags, flags, ENC_NA);\n    offset++;\n\n    /*\n     * Handle the TLVs ... There must be at least one TLV.\n     */\n    while (!eom_seen) {\n      guint8 tlv_type;\n      guint16 tlv_len;\n      proto_item *tlv_tree;\n\n      tlv_type = tvb_get_guint8(tvb, offset);\n      eom_seen = (tlv_type == EOM_TLV);\n      tlv_len = tvb_get_ntohs(tvb, offset + 1);\n\n      tlv_tree = proto_tree_add_subtree(ieee1905_tree, tvb, offset, tlv_len + 3,\n                                        ett_tlv, NULL, val_to_str_ext(tlv_type,\n                                                &ieee1905_tlv_types_vals_ext,\n                                                \"Unknown: %u\"));\n\n      proto_tree_add_item(tlv_tree, hf_ieee1905_tlv_types, tvb, offset, 1, ENC_NA);\n      offset++;\n\n      proto_tree_add_item(tlv_tree, hf_ieee1905_tlv_len, tvb, offset, 2, ENC_BIG_ENDIAN);\n      offset += 2;\n\n      if (tlv_len)\n        offset = dissect_ieee1905_tlv_data(tvb, pinfo, tlv_tree, offset, tlv_type, tlv_len);\n    }\n\n    if (tvb_reported_length_remaining(tvb, offset)) {\n      proto_item *pi = NULL;\n\n      /* THis shouldn't happen ... */\n      pi = proto_tree_add_item(ieee1905_tree, hf_ieee1905_data, tvb, offset, -1, ENC_NA);\n      expert_add_info(pinfo, pi, &ei_ieee1905_extraneous_data_after_eom);\n    }\n\n    return tvb_captured_length(tvb);\n}", "target": 2, "idx": 11801}
{"commit_id": "c246f6f69a749d4f68626b40795a4f69168008f4", "project": "OpenSC", "func": "static int\ncoolkey_add_object(coolkey_private_data_t *priv, unsigned long object_id, const u8 *object_data, size_t object_length, int add_v1_record)\n{\n\tsc_cardctl_coolkey_object_t new_object;\n\tint r;\n\n\tmemset(&new_object, 0, sizeof(new_object));\n\tnew_object.path = coolkey_template_path;\n\tnew_object.path.len = 4;\n\tulong2bebytes(new_object.path.value, object_id);\n\tnew_object.id = object_id;\n\tnew_object.length = object_length;\n\n\t/* The object ID needs to be unique */\n\tif (coolkey_find_object_by_id(&priv->objects_list, object_id) != NULL) {\n\t\treturn SC_ERROR_INTERNAL;\n\t}\n\n\tif (object_data) {\n\t\tnew_object.data = malloc(object_length + add_v1_record);\n\t\tif (new_object.data == NULL) {\n\t\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t\t}\n\t\tif (add_v1_record) {\n\t\t\tnew_object.data[0] = COOLKEY_V1_OBJECT;\n\t\t\tnew_object.length++;\n\t\t}\n\t\tmemcpy(&new_object.data[add_v1_record], object_data, object_length);\n\t}\n\n\tr = coolkey_add_object_to_list(&priv->objects_list, &new_object);\n\tif (r != SC_SUCCESS) {\n\t\t/* if we didn't successfully put the object on the list,\n\t\t * the data space didn't get adopted. free it before we return */\n\t\tfree(new_object.data);\n\t\tnew_object.data = NULL;\n\t}\n\treturn r;\n}", "target": 1, "idx": 11802}
{"commit_id": "c91815b596245fd7da349ecc43c8def670d2269e", "project": "torvalds/linux", "func": "void dwc3_gadget_giveback(struct dwc3_ep *dep, struct dwc3_request *req,\n\t\tint status)\n{\n\tstruct dwc3\t\t\t*dwc = dep->dwc;\n\n\tdwc3_gadget_del_and_unmap_request(dep, req, status);\n\n\tspin_unlock(&dwc->lock);\n\tusb_gadget_giveback_request(&dep->endpoint, &req->request);\n\tspin_lock(&dwc->lock);\n}", "target": 1, "idx": 11803}
{"commit_id": "91b38304755310458e01243214d8fbe792ba887d", "project": "mwarning/KadNode", "func": "int cmd_client(int argc, char *argv[])\n{\n\tchar buffer[256];\n\tconst char *path;\n\tstruct sockaddr_un addr;\n\tstruct timeval tv;\n\tssize_t size;\n\tint sock;\n\n\t// Default unix socket path\n\tpath = CMD_PATH;\n\n\t// Skip program name\n\targc -= 1;\n\targv += 1;\n\n\tif (argc >= 1) {\n\t\tif (strcmp(argv[0], \"-h\") == 0) {\n\t\t\tfprintf(stdout, \"%s\", g_client_usage);\n\t\t\treturn 0;\n\t\t} else if (strcmp(argv[0], \"-p\") == 0) {\n\t\t\tif (argc >= 2) {\n\t\t\t\tpath = argv[1];\n\t\t\t\t// Skip option and path\n\t\t\t\targc -= 2;\n\t\t\t\targv += 2;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Path is missing!\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (EXIT_FAILURE == append_strings(buffer, sizeof(buffer), argc, argv)) {\n\t\tfprintf(stderr, \"Input to long\\n\");\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tsock = socket(AF_LOCAL, SOCK_STREAM, 0);\n\tif (sock < 0) {\n\t\tfprintf(stderr, \"socket(): %s\\n\", strerror(errno));\n\t\treturn EXIT_FAILURE;\n\t}\n\n\taddr.sun_family = AF_LOCAL;\n\tstrcpy(addr.sun_path, path);\n\n\tif (connect(sock, (struct sockaddr *) &addr, sizeof(addr)) < 0) {\n\t\tfprintf(stderr, \"Failed to connect to '%s': %s\\n\", path, strerror(errno));\n\t\tgoto error;\n\t}\n\n\t/* Set receive timeout: 200ms */\n\ttv.tv_sec = 0;\n\ttv.tv_usec = 200000;\n\n#ifndef __CYGWIN__\n\tif (setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (char *)&tv, sizeof(tv)) < 0) {\n\t\tfprintf(stderr, \"setsockopt(): %s\\n\", strerror(errno));\n\t\tgoto error;\n\t}\n#endif\n\n\t// Send request\n\tsend(sock, buffer, strlen(buffer), 0);\n\n\twhile (1) {\n\t\t// Receive replies\n#ifdef __CYGWIN__\n\t\tsize = select_read(sock, buffer, strlen(buffer), &tv);\n#else\n\t\tsize = read(sock, buffer, strlen(buffer));\n#endif\n\t\tif (size <= 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tbuffer[size] = '\\0';\n\t\tprintf(\"%s\", buffer);\n\t}\n\n\tclose(sock);\n\n\treturn EXIT_SUCCESS;\n\nerror:\n\tif (sock > 0) {\n\t\tclose(sock);\n\t}\n\n\treturn EXIT_FAILURE;\n}", "target": 2, "idx": 11804}
{"commit_id": "dfb4357da6ddbdf57d583ba64361c9d792b0e0b1", "project": "kernel/git/tip/tip", "func": "static void __hrtimer_init(struct hrtimer *timer, clockid_t clock_id,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tstruct hrtimer_cpu_base *cpu_base;\n\tint base;\n\n\tmemset(timer, 0, sizeof(struct hrtimer));\n\n\tcpu_base = raw_cpu_ptr(&hrtimer_bases);\n\n\tif (clock_id == CLOCK_REALTIME && mode != HRTIMER_MODE_ABS)\n\t\tclock_id = CLOCK_MONOTONIC;\n\n\tbase = hrtimer_clockid_to_base(clock_id);\n\ttimer->base = &cpu_base->clock_base[base];\n\ttimerqueue_init(&timer->node);\n}", "target": 1, "idx": 11805}
{"commit_id": "a637243270fc1faae16de059091795c32d86e65e", "project": "OP-TEE/optee_os", "func": "TEE_Result syscall_obj_generate_key(unsigned long obj, unsigned long key_size,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tunsigned long param_count)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tconst struct tee_cryp_obj_type_props *type_props;\n\tstruct tee_obj *o;\n\tstruct tee_cryp_obj_secret *key;\n\tsize_t byte_size;\n\tTEE_Attribute *params = NULL;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Must be a transient object */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/* Must not be initialized already */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/* Find description of object */\n\ttype_props = tee_svc_find_type_props(o->info.objectType);\n\tif (!type_props)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\t/* Check that maxKeySize follows restrictions */\n\tif (key_size % type_props->quanta != 0)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (key_size < type_props->min_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (key_size > type_props->max_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\tsize_t alloc_size = 0;\n\n\tif (MUL_OVERFLOW(sizeof(TEE_Attribute), param_count, &alloc_size))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tparams = malloc(alloc_size);\n\tif (!params)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_params, param_count,\n\t\t\t    params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_svc_cryp_check_attr(ATTR_USAGE_GENERATE_KEY, type_props,\n\t\t\t\t      params, param_count);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tswitch (o->info.objectType) {\n\tcase TEE_TYPE_AES:\n\tcase TEE_TYPE_DES:\n\tcase TEE_TYPE_DES3:\n\tcase TEE_TYPE_HMAC_MD5:\n\tcase TEE_TYPE_HMAC_SHA1:\n\tcase TEE_TYPE_HMAC_SHA224:\n\tcase TEE_TYPE_HMAC_SHA256:\n\tcase TEE_TYPE_HMAC_SHA384:\n\tcase TEE_TYPE_HMAC_SHA512:\n\tcase TEE_TYPE_GENERIC_SECRET:\n\t\tbyte_size = key_size / 8;\n\n\t\t/*\n\t\t * We have to do it like this because the parity bits aren't\n\t\t * counted when telling the size of the key in bits.\n\t\t */\n\t\tif (o->info.objectType == TEE_TYPE_DES ||\n\t\t    o->info.objectType == TEE_TYPE_DES3) {\n\t\t\tbyte_size = (key_size + key_size / 7) / 8;\n\t\t}\n\n\t\tkey = (struct tee_cryp_obj_secret *)o->attr;\n\t\tif (byte_size > key->alloc_size) {\n\t\t\tres = TEE_ERROR_EXCESS_DATA;\n\t\t\tgoto out;\n\t\t}\n\n\t\tres = crypto_rng_read((void *)(key + 1), byte_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\tkey->key_size = byte_size;\n\n\t\t/* Set bits for all known attributes for this object type */\n\t\to->have_attrs = (1 << type_props->num_type_attrs) - 1;\n\n\t\tbreak;\n\n\tcase TEE_TYPE_RSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_rsa(o, type_props, key_size,\n\t\t\t\t\t\t   params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dsa(o, type_props, key_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DH_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dh(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_ECDSA_KEYPAIR:\n\tcase TEE_TYPE_ECDH_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_ecc(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tdefault:\n\t\tres = TEE_ERROR_BAD_FORMAT;\n\t}\n\nout:\n\tfree(params);\n\tif (res == TEE_SUCCESS) {\n\t\to->info.keySize = key_size;\n\t\to->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t}\n\treturn res;\n}", "target": 3, "idx": 11806}
{"commit_id": "ae04fa4be910255e5d363edebd77adeee99a525d", "project": "ImageMagick", "func": "static MagickBooleanType WriteBMPImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  BMPInfo\n    bmp_info;\n\n  BMPSubtype\n    bmp_subtype;\n\n  const char\n    *option;\n\n  const StringInfo\n    *profile;\n\n  MagickBooleanType\n    have_color_info,\n    status;\n\n  MagickOffsetType\n    scene;\n\n  MemoryInfo\n    *pixel_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *q;\n\n  size_t\n    bytes_per_line,\n    imageListLength,\n    type;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *bmp_data,\n    *pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  type=4;\n  if (LocaleCompare(image_info->magick,\"BMP2\") == 0)\n    type=2;\n  else\n    if (LocaleCompare(image_info->magick,\"BMP3\") == 0)\n      type=3;\n  option=GetImageOption(image_info,\"bmp:format\");\n  if (option != (char *) NULL)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Format=%s\",option);\n      if (LocaleCompare(option,\"bmp2\") == 0)\n        type=2;\n      if (LocaleCompare(option,\"bmp3\") == 0)\n        type=3;\n      if (LocaleCompare(option,\"bmp4\") == 0)\n        type=4;\n    }\n  scene=0;\n  imageListLength=GetImageListLength(image);\n  do\n  {\n    /*\n      Initialize BMP raster file header.\n    */\n    if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n      (void) TransformImageColorspace(image,sRGBColorspace,exception);\n    (void) memset(&bmp_info,0,sizeof(bmp_info));\n    bmp_info.file_size=14+12;\n    if (type > 2)\n      bmp_info.file_size+=28;\n    bmp_info.offset_bits=bmp_info.file_size;\n    bmp_info.compression=BI_RGB;\n    bmp_info.red_mask=0x00ff0000U;\n    bmp_info.green_mask=0x0000ff00U;\n    bmp_info.blue_mask=0x000000ffU;\n    bmp_info.alpha_mask=0xff000000U;\n    bmp_subtype=UndefinedSubtype;\n    if ((image->storage_class == PseudoClass) && (image->colors > 256))\n      (void) SetImageStorageClass(image,DirectClass,exception);\n    if (image->storage_class != DirectClass)\n      {\n        /*\n          Colormapped BMP raster.\n        */\n        bmp_info.bits_per_pixel=8;\n        if (image->colors <= 2)\n          bmp_info.bits_per_pixel=1;\n        else\n          if (image->colors <= 16)\n            bmp_info.bits_per_pixel=4;\n          else\n            if (image->colors <= 256)\n              bmp_info.bits_per_pixel=8;\n        if (image_info->compression == RLECompression)\n          bmp_info.bits_per_pixel=8;\n        bmp_info.number_colors=1U << bmp_info.bits_per_pixel;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          (void) SetImageStorageClass(image,DirectClass,exception);\n        else\n          if ((size_t) bmp_info.number_colors < image->colors)\n            (void) SetImageStorageClass(image,DirectClass,exception);\n          else\n            {\n              bmp_info.file_size+=3*(1UL << bmp_info.bits_per_pixel);\n              bmp_info.offset_bits+=3*(1UL << bmp_info.bits_per_pixel);\n              if (type > 2)\n                {\n                  bmp_info.file_size+=(1UL << bmp_info.bits_per_pixel);\n                  bmp_info.offset_bits+=(1UL << bmp_info.bits_per_pixel);\n                }\n            }\n      }\n    if (image->storage_class == DirectClass)\n      {\n        /*\n          Full color BMP raster.\n        */\n        bmp_info.number_colors=0;\n        option=GetImageOption(image_info,\"bmp:subtype\");\n        if (option != (const char *) NULL)\n        {\n          if (image->alpha_trait != UndefinedPixelTrait)\n            {\n              if (LocaleNCompare(option,\"ARGB4444\",8) == 0)\n                {\n                  bmp_subtype=ARGB4444;\n                  bmp_info.red_mask=0x00000f00U;\n                  bmp_info.green_mask=0x000000f0U;\n                  bmp_info.blue_mask=0x0000000fU;\n                  bmp_info.alpha_mask=0x0000f000U;\n                }\n              else if (LocaleNCompare(option,\"ARGB1555\",8) == 0)\n                {\n                  bmp_subtype=ARGB1555;\n                  bmp_info.red_mask=0x00007c00U;\n                  bmp_info.green_mask=0x000003e0U;\n                  bmp_info.blue_mask=0x0000001fU;\n                  bmp_info.alpha_mask=0x00008000U;\n                }\n            }\n          else\n          {\n            if (LocaleNCompare(option,\"RGB555\",6) == 0)\n              {\n                bmp_subtype=RGB555;\n                bmp_info.red_mask=0x00007c00U;\n                bmp_info.green_mask=0x000003e0U;\n                bmp_info.blue_mask=0x0000001fU;\n                bmp_info.alpha_mask=0U;\n              }\n            else if (LocaleNCompare(option,\"RGB565\",6) == 0)\n              {\n                bmp_subtype=RGB565;\n                bmp_info.red_mask=0x0000f800U;\n                bmp_info.green_mask=0x000007e0U;\n                bmp_info.blue_mask=0x0000001fU;\n                bmp_info.alpha_mask=0U;\n              }\n          }\n        }\n        if (bmp_subtype != UndefinedSubtype)\n          {\n            bmp_info.bits_per_pixel=16;\n            bmp_info.compression=BI_BITFIELDS;\n          }\n        else\n          {\n            bmp_info.bits_per_pixel=(unsigned short) ((type > 3) &&\n               (image->alpha_trait != UndefinedPixelTrait) ? 32 : 24);\n            bmp_info.compression=(unsigned int) ((type > 3) &&\n              (image->alpha_trait != UndefinedPixelTrait) ? BI_BITFIELDS : BI_RGB);\n            if ((type == 3) && (image->alpha_trait != UndefinedPixelTrait))\n              {\n                option=GetImageOption(image_info,\"bmp3:alpha\");\n                if (IsStringTrue(option))\n                  bmp_info.bits_per_pixel=32;\n              }\n          }\n      }\n    bytes_per_line=4*((image->columns*bmp_info.bits_per_pixel+31)/32);\n    bmp_info.ba_offset=0;\n    profile=GetImageProfile(image,\"icc\");\n    have_color_info=(image->rendering_intent != UndefinedIntent) ||\n      (profile != (StringInfo *) NULL) || (image->gamma != 0.0) ?  MagickTrue :\n      MagickFalse;\n    if (type == 2)\n      bmp_info.size=12;\n    else\n      if ((type == 3) || ((image->alpha_trait == UndefinedPixelTrait) &&\n          (have_color_info == MagickFalse)))\n        {\n          type=3;\n          bmp_info.size=40;\n        }\n      else\n        {\n          int\n            extra_size;\n\n          bmp_info.size=108;\n          extra_size=68;\n          if ((image->rendering_intent != UndefinedIntent) ||\n              (profile != (StringInfo *) NULL))\n            {\n              bmp_info.size=124;\n              extra_size+=16;\n            }\n          bmp_info.file_size+=extra_size;\n          bmp_info.offset_bits+=extra_size;\n        }\n    if (((ssize_t) image->columns != (ssize_t) ((signed int) image->columns)) ||\n        ((ssize_t) image->rows != (ssize_t) ((signed int) image->rows)))\n      ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n    bmp_info.width=(ssize_t) image->columns;\n    bmp_info.height=(ssize_t) image->rows;\n    bmp_info.planes=1;\n    bmp_info.image_size=(unsigned int) (bytes_per_line*image->rows);\n    bmp_info.file_size+=bmp_info.image_size;\n    bmp_info.x_pixels=75*39;\n    bmp_info.y_pixels=75*39;\n    switch (image->units)\n    {\n      case UndefinedResolution:\n      case PixelsPerInchResolution:\n      {\n        bmp_info.x_pixels=(unsigned int) (100.0*image->resolution.x/2.54);\n        bmp_info.y_pixels=(unsigned int) (100.0*image->resolution.y/2.54);\n        break;\n      }\n      case PixelsPerCentimeterResolution:\n      {\n        bmp_info.x_pixels=(unsigned int) (100.0*image->resolution.x);\n        bmp_info.y_pixels=(unsigned int) (100.0*image->resolution.y);\n        break;\n      }\n    }\n    bmp_info.colors_important=bmp_info.number_colors;\n    /*\n      Convert MIFF to BMP raster pixels.\n    */\n    pixel_info=AcquireVirtualMemory(image->rows,\n      MagickMax(bytes_per_line,image->columns+256UL)*sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    (void) memset(pixels,0,(size_t) bmp_info.image_size);\n    switch (bmp_info.bits_per_pixel)\n    {\n      case 1:\n      {\n        size_t\n          bit,\n          byte;\n\n        /*\n          Convert PseudoClass image to a BMP monochrome image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          ssize_t\n            offset;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          bit=0;\n          byte=0;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            byte<<=1;\n            byte|=GetPixelIndex(image,p) != 0 ? 0x01 : 0x00;\n            bit++;\n            if (bit == 8)\n              {\n                *q++=(unsigned char) byte;\n                bit=0;\n                byte=0;\n              }\n             p+=GetPixelChannels(image);\n           }\n           if (bit != 0)\n             {\n               *q++=(unsigned char) (byte << (8-bit));\n               x++;\n             }\n          offset=(ssize_t) (image->columns+7)/8;\n          for (x=offset; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 4:\n      {\n        unsigned int\n          byte,\n          nibble;\n\n        ssize_t\n          offset;\n\n        /*\n          Convert PseudoClass image to a BMP monochrome image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          nibble=0;\n          byte=0;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            byte<<=4;\n            byte|=((unsigned int) GetPixelIndex(image,p) & 0x0f);\n            nibble++;\n            if (nibble == 2)\n              {\n                *q++=(unsigned char) byte;\n                nibble=0;\n                byte=0;\n              }\n            p+=GetPixelChannels(image);\n          }\n          if (nibble != 0)\n            {\n              *q++=(unsigned char) (byte << 4);\n              x++;\n            }\n          offset=(ssize_t) (image->columns+1)/2;\n          for (x=offset; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 8:\n      {\n        /*\n          Convert PseudoClass packet to BMP pixel.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=(unsigned char) GetPixelIndex(image,p);\n            p+=GetPixelChannels(image);\n          }\n          for ( ; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 16:\n      {\n        /*\n          Convert DirectClass packet to BMP BGR888.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            unsigned short\n              pixel;\n\n            pixel=0;\n            if (bmp_subtype == ARGB4444)\n              {\n                pixel=(unsigned short) (ScaleQuantumToAny(\n                  GetPixelAlpha(image,p),15) << 12);\n                pixel|=(unsigned short) (ScaleQuantumToAny(\n                  GetPixelRed(image,p),15) << 8);\n                pixel|=(unsigned short) (ScaleQuantumToAny(\n                  GetPixelGreen(image,p),15) << 4);\n                pixel|=(unsigned short) (ScaleQuantumToAny(\n                  GetPixelBlue(image,p),15));\n              }\n            else if (bmp_subtype == RGB565)\n              {\n                pixel=(unsigned short) (ScaleQuantumToAny(\n                  GetPixelRed(image,p),31) << 11);\n                pixel|=(unsigned short) (ScaleQuantumToAny(\n                  GetPixelGreen(image,p),63) << 5);\n                pixel|=(unsigned short) (ScaleQuantumToAny(\n                  GetPixelBlue(image,p),31));\n              }\n            else\n              {\n                if (bmp_subtype == ARGB1555)\n                  pixel=(unsigned short) (ScaleQuantumToAny(\n                    GetPixelAlpha(image,p),1) << 15);\n                pixel|=(unsigned short) (ScaleQuantumToAny(\n                  GetPixelRed(image,p),31) << 10);\n                pixel|=(unsigned short) (ScaleQuantumToAny(\n                  GetPixelGreen(image,p),31) << 5);\n                pixel|=(unsigned short) (ScaleQuantumToAny(\n                  GetPixelBlue(image,p),31));\n              }\n            *((unsigned short *) q)=pixel;\n            q+=2;\n            p+=GetPixelChannels(image);\n          }\n          for (x=2L*(ssize_t) image->columns; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 24:\n      {\n        /*\n          Convert DirectClass packet to BMP BGR888.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n            *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n            *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n            p+=GetPixelChannels(image);\n          }\n          for (x=3L*(ssize_t) image->columns; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 32:\n      {\n        /*\n          Convert DirectClass packet to ARGB8888 pixel.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n            *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n            *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n            *q++=ScaleQuantumToChar(GetPixelAlpha(image,p));\n            p+=GetPixelChannels(image);\n          }\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n    }\n    if ((type > 2) && (bmp_info.bits_per_pixel == 8))\n      if (image_info->compression != NoCompression)\n        {\n          MemoryInfo\n            *rle_info;\n\n          /*\n            Convert run-length encoded raster pixels.\n          */\n          rle_info=AcquireVirtualMemory((size_t) (2*(bytes_per_line+2)+2),\n            (image->rows+2)*sizeof(*pixels));\n          if (rle_info == (MemoryInfo *) NULL)\n            {\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n            }\n          bmp_data=(unsigned char *) GetVirtualMemoryBlob(rle_info);\n          bmp_info.file_size-=bmp_info.image_size;\n          bmp_info.image_size=(unsigned int) EncodeImage(image,bytes_per_line,\n            pixels,bmp_data);\n          bmp_info.file_size+=bmp_info.image_size;\n          pixel_info=RelinquishVirtualMemory(pixel_info);\n          pixel_info=rle_info;\n          pixels=bmp_data;\n          bmp_info.compression=BI_RLE8;\n        }\n    /*\n      Write BMP for Windows, all versions, 14-byte header.\n    */\n    if (image->debug != MagickFalse)\n      {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"   Writing BMP version %.20g datastream\",(double) type);\n        if (image->storage_class == DirectClass)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Storage class=DirectClass\");\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Storage class=PseudoClass\");\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"   Image depth=%.20g\",(double) image->depth);\n        if (image->alpha_trait != UndefinedPixelTrait)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Matte=True\");\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Matte=MagickFalse\");\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"   BMP bits_per_pixel=%.20g\",(double) bmp_info.bits_per_pixel);\n        switch ((int) bmp_info.compression)\n        {\n           case BI_RGB:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"   Compression=BI_RGB\");\n             break;\n           }\n           case BI_RLE8:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"   Compression=BI_RLE8\");\n             break;\n           }\n           case BI_BITFIELDS:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"   Compression=BI_BITFIELDS\");\n             break;\n           }\n           default:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"   Compression=UNKNOWN (%u)\",bmp_info.compression);\n             break;\n           }\n        }\n        if (bmp_info.number_colors == 0)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Number_colors=unspecified\");\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Number_colors=%u\",bmp_info.number_colors);\n      }\n    (void) WriteBlob(image,2,(unsigned char *) \"BM\");\n    (void) WriteBlobLSBLong(image,bmp_info.file_size);\n    (void) WriteBlobLSBLong(image,bmp_info.ba_offset);  /* always 0 */\n    (void) WriteBlobLSBLong(image,bmp_info.offset_bits);\n    if (type == 2)\n      {\n        /*\n          Write 12-byte version 2 bitmap header.\n        */\n        (void) WriteBlobLSBLong(image,bmp_info.size);\n        (void) WriteBlobLSBSignedShort(image,(signed short) bmp_info.width);\n        (void) WriteBlobLSBSignedShort(image,(signed short) bmp_info.height);\n        (void) WriteBlobLSBShort(image,bmp_info.planes);\n        (void) WriteBlobLSBShort(image,bmp_info.bits_per_pixel);\n      }\n    else\n      {\n        /*\n          Write 40-byte version 3+ bitmap header.\n        */\n        (void) WriteBlobLSBLong(image,bmp_info.size);\n        (void) WriteBlobLSBSignedLong(image,(signed int) bmp_info.width);\n        (void) WriteBlobLSBSignedLong(image,(signed int) bmp_info.height);\n        (void) WriteBlobLSBShort(image,bmp_info.planes);\n        (void) WriteBlobLSBShort(image,bmp_info.bits_per_pixel);\n        (void) WriteBlobLSBLong(image,bmp_info.compression);\n        (void) WriteBlobLSBLong(image,bmp_info.image_size);\n        (void) WriteBlobLSBLong(image,bmp_info.x_pixels);\n        (void) WriteBlobLSBLong(image,bmp_info.y_pixels);\n        (void) WriteBlobLSBLong(image,bmp_info.number_colors);\n        (void) WriteBlobLSBLong(image,bmp_info.colors_important);\n      }\n    if ((type > 3) && ((image->alpha_trait != UndefinedPixelTrait) ||\n        (have_color_info != MagickFalse)))\n      {\n        /*\n          Write the rest of the 108-byte BMP Version 4 header.\n        */\n        (void) WriteBlobLSBLong(image,bmp_info.red_mask);\n        (void) WriteBlobLSBLong(image,bmp_info.green_mask);\n        (void) WriteBlobLSBLong(image,bmp_info.blue_mask);\n        (void) WriteBlobLSBLong(image,bmp_info.alpha_mask);\n        (void) WriteBlobLSBLong(image,0x73524742U);  /* sRGB */\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.red_primary.x*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.red_primary.y*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          ((1.000f-(image->chromaticity.red_primary.x+\n          image->chromaticity.red_primary.y))*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.green_primary.x*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.green_primary.y*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          ((1.000f-(image->chromaticity.green_primary.x+\n          image->chromaticity.green_primary.y))*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.blue_primary.x*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.blue_primary.y*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          ((1.000f-(image->chromaticity.blue_primary.x+\n          image->chromaticity.blue_primary.y))*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (bmp_info.gamma_scale.x*0x10000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (bmp_info.gamma_scale.y*0x10000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (bmp_info.gamma_scale.z*0x10000));\n        if ((image->rendering_intent != UndefinedIntent) ||\n            (profile != (StringInfo *) NULL))\n          {\n            ssize_t\n              intent;\n\n            switch ((int) image->rendering_intent)\n            {\n              case SaturationIntent:\n              {\n                intent=LCS_GM_BUSINESS;\n                break;\n              }\n              case RelativeIntent:\n              {\n                intent=LCS_GM_GRAPHICS;\n                break;\n              }\n              case PerceptualIntent:\n              {\n                intent=LCS_GM_IMAGES;\n                break;\n              }\n              case AbsoluteIntent:\n              {\n                intent=LCS_GM_ABS_COLORIMETRIC;\n                break;\n              }\n              default:\n              {\n                intent=0;\n                break;\n              }\n            }\n            (void) WriteBlobLSBLong(image,(unsigned int) intent);\n            (void) WriteBlobLSBLong(image,0x00);  /* dummy profile data */\n            (void) WriteBlobLSBLong(image,0x00);  /* dummy profile length */\n            (void) WriteBlobLSBLong(image,0x00);  /* reserved */\n          }\n      }\n    if (image->storage_class == PseudoClass)\n      {\n        unsigned char\n          *bmp_colormap;\n\n        /*\n          Dump colormap to file.\n        */\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Colormap: %.20g entries\",(double) image->colors);\n        bmp_colormap=(unsigned char *) AcquireQuantumMemory((size_t) (1UL <<\n          bmp_info.bits_per_pixel),4*sizeof(*bmp_colormap));\n        if (bmp_colormap == (unsigned char *) NULL)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        q=bmp_colormap;\n        for (i=0; i < (ssize_t) MagickMin((ssize_t) image->colors,(ssize_t) bmp_info.number_colors); i++)\n        {\n          *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].blue));\n          *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].green));\n          *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].red));\n          if (type > 2)\n            *q++=(unsigned char) 0x0;\n        }\n        for ( ; i < (ssize_t) (1UL << bmp_info.bits_per_pixel); i++)\n        {\n          *q++=(unsigned char) 0x00;\n          *q++=(unsigned char) 0x00;\n          *q++=(unsigned char) 0x00;\n          if (type > 2)\n            *q++=(unsigned char) 0x00;\n        }\n        if (type <= 2)\n          (void) WriteBlob(image,(size_t) (3*(1L << bmp_info.bits_per_pixel)),\n            bmp_colormap);\n        else\n          (void) WriteBlob(image,(size_t) (4*(1L << bmp_info.bits_per_pixel)),\n            bmp_colormap);\n        bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);\n      }\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Pixels:  %u bytes\",bmp_info.image_size);\n    (void) WriteBlob(image,(size_t) bmp_info.image_size,pixels);\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,imageListLength);\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}", "target": 2, "idx": 11807}
{"commit_id": "f5c7555c303", "project": "ArtifexSoftware/ghostpdl", "func": "static int\nzsethalftone5(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    uint count;\n    gs_halftone_component *phtc = 0;\n    gs_halftone_component *pc;\n    int code = 0;\n    int j;\n    bool have_default;\n    gs_halftone *pht = 0;\n    gx_device_halftone *pdht = 0;\n    ref sprocs[GS_CLIENT_COLOR_MAX_COMPONENTS + 1];\n    ref tprocs[GS_CLIENT_COLOR_MAX_COMPONENTS + 1];\n    gs_memory_t *mem;\n    uint edepth = ref_stack_count(&e_stack);\n    int npop = 2;\n    int dict_enum;\n    ref rvalue[2];\n    int cname, colorant_number;\n    byte * pname;\n    uint name_size;\n    int halftonetype, type = 0;\n    gs_gstate *pgs = igs;\n    int space_index;\n\n    if (ref_stack_count(&o_stack) < 2)\n        return_error(gs_error_stackunderflow);\n    check_type(*op, t_dictionary);\n    check_type(*(op - 1), t_dictionary);\n\n    dict_enum = dict_first(op);\n    space_index = r_space_index(op - 1);\n\n    mem = (gs_memory_t *) idmemory->spaces_indexed[space_index];\n\n    check_type(*op, t_dictionary);\n    check_dict_read(*op);\n    check_type(op[-1], t_dictionary);\n    check_dict_read(op[-1]);\n\n    /*\n     * We think that Type 2 and Type 4 halftones, like\n     * screens set by setcolorscreen, adapt automatically to\n     * the device color space, so we need to mark them\n     * with a different internal halftone type.\n     */\n    code = dict_int_param(op - 1, \"HalftoneType\", 1, 100, 0, &type);\n    if (code < 0)\n          return code;\n    halftonetype = (type == 2 || type == 4)\n                        ? ht_type_multiple_colorscreen\n                        : ht_type_multiple;\n\n    /* Count how many components that we will actually use. */\n\n    have_default = false;\n    for (count = 0; ;) {\n\n        /* Move to next element in the dictionary */\n        if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)\n            break;\n        /*\n         * Verify that we have a valid component.  We may have a\n         * /HalfToneType entry.\n         */\n        if (!r_has_type(&rvalue[0], t_name))\n            continue;\n        if (!r_has_type(&rvalue[1], t_dictionary))\n            continue;\n\n        /* Get the name of the component  verify that we will use it. */\n        cname = name_index(mem, &rvalue[0]);\n        code = gs_get_colorname_string(mem, cname, &pname, &name_size);\n        if (code < 0)\n            break;\n        colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,\n                                                halftonetype);\n        if (colorant_number < 0)\n            continue;\n        else if (colorant_number == GX_DEVICE_COLOR_MAX_COMPONENTS) {\n            /* If here then we have the \"Default\" component */\n            if (have_default)\n                return_error(gs_error_rangecheck);\n            have_default = true;\n        }\n\n        count++;\n        /*\n         * Check to see if we have already reached the legal number of\n         * components.\n         */\n        if (count > GS_CLIENT_COLOR_MAX_COMPONENTS + 1) {\n            code = gs_note_error(gs_error_rangecheck);\n            break;\n        }\n    }\n    if (count == 0 || (halftonetype == ht_type_multiple && ! have_default))\n        code = gs_note_error(gs_error_rangecheck);\n\n    if (code >= 0) {\n        check_estack(5);\t\t/* for sampling Type 1 screens */\n        refset_null(sprocs, count);\n        refset_null(tprocs, count);\n        rc_alloc_struct_0(pht, gs_halftone, &st_halftone,\n                          imemory, pht = 0, \".sethalftone5\");\n        phtc = gs_alloc_struct_array(mem, count, gs_halftone_component,\n                                     &st_ht_component_element,\n                                     \".sethalftone5\");\n        rc_alloc_struct_0(pdht, gx_device_halftone, &st_device_halftone,\n                          imemory, pdht = 0, \".sethalftone5\");\n        if (pht == 0 || phtc == 0 || pdht == 0) {\n            j = 0; /* Quiet the compiler:\n                      gs_note_error isn't necessarily identity,\n                      so j could be left ununitialized. */\n            code = gs_note_error(gs_error_VMerror);\n        }\n    }\n    if (code >= 0) {\n        dict_enum = dict_first(op);\n        for (j = 0, pc = phtc; ;) {\n            int type;\n\n            /* Move to next element in the dictionary */\n            if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)\n                break;\n            /*\n             * Verify that we have a valid component.  We may have a\n             * /HalfToneType entry.\n             */\n            if (!r_has_type(&rvalue[0], t_name))\n                continue;\n            if (!r_has_type(&rvalue[1], t_dictionary))\n                continue;\n\n            /* Get the name of the component */\n            cname = name_index(mem, &rvalue[0]);\n            code = gs_get_colorname_string(mem, cname, &pname, &name_size);\n            if (code < 0)\n                break;\n            colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,\n                                                halftonetype);\n            if (colorant_number < 0)\n                continue;\t\t/* Do not use this component */\n            pc->cname = cname;\n            pc->comp_number = colorant_number;\n\n            /* Now process the component dictionary */\n            check_dict_read(rvalue[1]);\n            if (dict_int_param(&rvalue[1], \"HalftoneType\", 1, 7, 0, &type) < 0) {\n                code = gs_note_error(gs_error_typecheck);\n                break;\n            }\n            switch (type) {\n                default:\n                    code = gs_note_error(gs_error_rangecheck);\n                    break;\n                case 1:\n                    code = dict_spot_params(&rvalue[1], &pc->params.spot,\n                                                sprocs + j, tprocs + j, mem);\n                    pc->params.spot.screen.spot_function = spot1_dummy;\n                    pc->type = ht_type_spot;\n                    break;\n                case 3:\n                    code = dict_threshold_params(&rvalue[1], &pc->params.threshold,\n                                                        tprocs + j);\n                    pc->type = ht_type_threshold;\n                    break;\n                case 7:\n                    code = dict_threshold2_params(&rvalue[1], &pc->params.threshold2,\n                                                        tprocs + j, imemory);\n                    pc->type = ht_type_threshold2;\n                    break;\n            }\n            if (code < 0)\n                break;\n            pc++;\n            j++;\n        }\n    }\n    if (code >= 0) {\n        pht->type = halftonetype;\n        pht->params.multiple.components = phtc;\n        pht->params.multiple.num_comp = j;\n        pht->params.multiple.get_colorname_string = gs_get_colorname_string;\n        code = gs_sethalftone_prepare(igs, pht, pdht);\n    }\n    if (code >= 0) {\n        /*\n         * Put the actual frequency and angle in the spot function component dictionaries.\n         */\n        dict_enum = dict_first(op);\n        for (pc = phtc; ; ) {\n            /* Move to next element in the dictionary */\n            if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)\n                break;\n\n            /* Verify that we have a valid component */\n            if (!r_has_type(&rvalue[0], t_name))\n                continue;\n            if (!r_has_type(&rvalue[1], t_dictionary))\n                continue;\n\n            /* Get the name of the component and verify that we will use it. */\n            cname = name_index(mem, &rvalue[0]);\n            code = gs_get_colorname_string(mem, cname, &pname, &name_size);\n            if (code < 0)\n                break;\n            colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,\n                                                halftonetype);\n            if (colorant_number < 0)\n                continue;\n\n            if (pc->type == ht_type_spot) {\n                code = dict_spot_results(i_ctx_p, &rvalue[1], &pc->params.spot);\n                if (code < 0)\n                    break;\n            }\n            pc++;\n        }\n    }\n    if (code >= 0) {\n        /*\n         * Schedule the sampling of any Type 1 screens,\n         * and any (Type 1 or Type 3) TransferFunctions.\n         * Save the stack depths in case we have to back out.\n         */\n        uint odepth = ref_stack_count(&o_stack);\n        ref odict, odict5;\n\n        odict = op[-1];\n        odict5 = *op;\n        pop(2);\n        op = osp;\n        esp += 5;\n        make_mark_estack(esp - 4, es_other, sethalftone_cleanup);\n        esp[-3] = odict;\n        make_istruct(esp - 2, 0, pht);\n        make_istruct(esp - 1, 0, pdht);\n        make_op_estack(esp, sethalftone_finish);\n        for (j = 0; j < count; j++) {\n            gx_ht_order *porder = NULL;\n\n            if (pdht->components == 0)\n                porder = &pdht->order;\n            else {\n                /* Find the component in pdht that matches component j in\n                   the pht; gs_sethalftone_prepare() may permute these. */\n                int k;\n                int comp_number = phtc[j].comp_number;\n                for (k = 0; k < count; k++) {\n                    if (pdht->components[k].comp_number == comp_number) {\n                        porder = &pdht->components[k].corder;\n                        break;\n                    }\n                }\n            }\n            switch (phtc[j].type) {\n            case ht_type_spot:\n                code = zscreen_enum_init(i_ctx_p, porder,\n                                         &phtc[j].params.spot.screen,\n                                         &sprocs[j], 0, 0, space_index);\n                if (code < 0)\n                    break;\n                /* falls through */\n            case ht_type_threshold:\n                if (!r_has_type(tprocs + j, t__invalid)) {\n                    /* Schedule TransferFunction sampling. */\n                    /****** check_xstack IS WRONG ******/\n                    check_ostack(zcolor_remap_one_ostack);\n                    check_estack(zcolor_remap_one_estack);\n                    code = zcolor_remap_one(i_ctx_p, tprocs + j,\n                                            porder->transfer, igs,\n                                            zcolor_remap_one_finish);\n                    op = osp;\n                }\n                break;\n            default:\t/* not possible here, but to keep */\n                                /* the compilers happy.... */\n                ;\n            }\n            if (code < 0) {\t/* Restore the stack. */\n                ref_stack_pop_to(&o_stack, odepth);\n                ref_stack_pop_to(&e_stack, edepth);\n                op = osp;\n                op[-1] = odict;\n                *op = odict5;\n                break;\n            }\n            npop = 0;\n        }\n    }\n    if (code < 0) {\n        gs_free_object(mem, pdht, \".sethalftone5\");\n        gs_free_object(mem, phtc, \".sethalftone5\");\n        gs_free_object(mem, pht, \".sethalftone5\");\n        return code;\n    }\n    pop(npop);\n    return (ref_stack_count(&e_stack) > edepth ? o_push_estack : 0);\n}", "target": 2, "idx": 11808}
{"commit_id": "9590232bb4f4cc824f3425a6e1349afbe6d6d2b7", "project": "torvalds/linux", "func": "void ion_free(struct ion_client *client, struct ion_handle *handle)\n{\n\tBUG_ON(client != handle->client);\n\n\tmutex_lock(&client->lock);\n\tion_free_nolock(client, handle);\n\tmutex_unlock(&client->lock);\n}", "target": 2, "idx": 11809}
{"commit_id": "592acbf16821288ecdc4192c47e3774a4c48bb64", "project": "torvalds/linux", "func": "static int ext4_ext_split(handle_t *handle, struct inode *inode,\n\t\t\t  unsigned int flags,\n\t\t\t  struct ext4_ext_path *path,\n\t\t\t  struct ext4_extent *newext, int at)\n{\n\tstruct buffer_head *bh = NULL;\n\tint depth = ext_depth(inode);\n\tstruct ext4_extent_header *neh;\n\tstruct ext4_extent_idx *fidx;\n\tint i = at, k, m, a;\n\text4_fsblk_t newblock, oldblock;\n\t__le32 border;\n\text4_fsblk_t *ablocks = NULL; /* array of allocated blocks */\n\tint err = 0;\n\tsize_t ext_size = 0;\n\n\t/* make decision: where to split? */\n\t/* FIXME: now decision is simplest: at current extent */\n\n\t/* if current leaf will be split, then we should use\n\t * border from split point */\n\tif (unlikely(path[depth].p_ext > EXT_MAX_EXTENT(path[depth].p_hdr))) {\n\t\tEXT4_ERROR_INODE(inode, \"p_ext > EXT_MAX_EXTENT!\");\n\t\treturn -EFSCORRUPTED;\n\t}\n\tif (path[depth].p_ext != EXT_MAX_EXTENT(path[depth].p_hdr)) {\n\t\tborder = path[depth].p_ext[1].ee_block;\n\t\text_debug(\"leaf will be split.\"\n\t\t\t\t\" next leaf starts at %d\\n\",\n\t\t\t\t  le32_to_cpu(border));\n\t} else {\n\t\tborder = newext->ee_block;\n\t\text_debug(\"leaf will be added.\"\n\t\t\t\t\" next leaf starts at %d\\n\",\n\t\t\t\tle32_to_cpu(border));\n\t}\n\n\t/*\n\t * If error occurs, then we break processing\n\t * and mark filesystem read-only. index won't\n\t * be inserted and tree will be in consistent\n\t * state. Next mount will repair buffers too.\n\t */\n\n\t/*\n\t * Get array to track all allocated blocks.\n\t * We need this to handle errors and free blocks\n\t * upon them.\n\t */\n\tablocks = kcalloc(depth, sizeof(ext4_fsblk_t), GFP_NOFS);\n\tif (!ablocks)\n\t\treturn -ENOMEM;\n\n\t/* allocate all needed blocks */\n\text_debug(\"allocate %d blocks for indexes/leaf\\n\", depth - at);\n\tfor (a = 0; a < depth - at; a++) {\n\t\tnewblock = ext4_ext_new_meta_block(handle, inode, path,\n\t\t\t\t\t\t   newext, &err, flags);\n\t\tif (newblock == 0)\n\t\t\tgoto cleanup;\n\t\tablocks[a] = newblock;\n\t}\n\n\t/* initialize new leaf */\n\tnewblock = ablocks[--a];\n\tif (unlikely(newblock == 0)) {\n\t\tEXT4_ERROR_INODE(inode, \"newblock == 0!\");\n\t\terr = -EFSCORRUPTED;\n\t\tgoto cleanup;\n\t}\n\tbh = sb_getblk_gfp(inode->i_sb, newblock, __GFP_MOVABLE | GFP_NOFS);\n\tif (unlikely(!bh)) {\n\t\terr = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\tlock_buffer(bh);\n\n\terr = ext4_journal_get_create_access(handle, bh);\n\tif (err)\n\t\tgoto cleanup;\n\n\tneh = ext_block_hdr(bh);\n\tneh->eh_entries = 0;\n\tneh->eh_max = cpu_to_le16(ext4_ext_space_block(inode, 0));\n\tneh->eh_magic = EXT4_EXT_MAGIC;\n\tneh->eh_depth = 0;\n\n\t/* move remainder of path[depth] to the new leaf */\n\tif (unlikely(path[depth].p_hdr->eh_entries !=\n\t\t     path[depth].p_hdr->eh_max)) {\n\t\tEXT4_ERROR_INODE(inode, \"eh_entries %d != eh_max %d!\",\n\t\t\t\t path[depth].p_hdr->eh_entries,\n\t\t\t\t path[depth].p_hdr->eh_max);\n\t\terr = -EFSCORRUPTED;\n\t\tgoto cleanup;\n\t}\n\t/* start copy from next extent */\n\tm = EXT_MAX_EXTENT(path[depth].p_hdr) - path[depth].p_ext++;\n\text4_ext_show_move(inode, path, newblock, depth);\n\tif (m) {\n\t\tstruct ext4_extent *ex;\n\t\tex = EXT_FIRST_EXTENT(neh);\n\t\tmemmove(ex, path[depth].p_ext, sizeof(struct ext4_extent) * m);\n\t\tle16_add_cpu(&neh->eh_entries, m);\n\t}\n\n\t/* zero out unused area in the extent block */\n\text_size = sizeof(struct ext4_extent_header) +\n\t\tsizeof(struct ext4_extent) * le16_to_cpu(neh->eh_entries);\n\tmemset(bh->b_data + ext_size, 0, inode->i_sb->s_blocksize - ext_size);\n\text4_extent_block_csum_set(inode, neh);\n\tset_buffer_uptodate(bh);\n\tunlock_buffer(bh);\n\n\terr = ext4_handle_dirty_metadata(handle, inode, bh);\n\tif (err)\n\t\tgoto cleanup;\n\tbrelse(bh);\n\tbh = NULL;\n\n\t/* correct old leaf */\n\tif (m) {\n\t\terr = ext4_ext_get_access(handle, inode, path + depth);\n\t\tif (err)\n\t\t\tgoto cleanup;\n\t\tle16_add_cpu(&path[depth].p_hdr->eh_entries, -m);\n\t\terr = ext4_ext_dirty(handle, inode, path + depth);\n\t\tif (err)\n\t\t\tgoto cleanup;\n\n\t}\n\n\t/* create intermediate indexes */\n\tk = depth - at - 1;\n\tif (unlikely(k < 0)) {\n\t\tEXT4_ERROR_INODE(inode, \"k %d < 0!\", k);\n\t\terr = -EFSCORRUPTED;\n\t\tgoto cleanup;\n\t}\n\tif (k)\n\t\text_debug(\"create %d intermediate indices\\n\", k);\n\t/* insert new index into current index block */\n\t/* current depth stored in i var */\n\ti = depth - 1;\n\twhile (k--) {\n\t\toldblock = newblock;\n\t\tnewblock = ablocks[--a];\n\t\tbh = sb_getblk(inode->i_sb, newblock);\n\t\tif (unlikely(!bh)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tlock_buffer(bh);\n\n\t\terr = ext4_journal_get_create_access(handle, bh);\n\t\tif (err)\n\t\t\tgoto cleanup;\n\n\t\tneh = ext_block_hdr(bh);\n\t\tneh->eh_entries = cpu_to_le16(1);\n\t\tneh->eh_magic = EXT4_EXT_MAGIC;\n\t\tneh->eh_max = cpu_to_le16(ext4_ext_space_block_idx(inode, 0));\n\t\tneh->eh_depth = cpu_to_le16(depth - i);\n\t\tfidx = EXT_FIRST_INDEX(neh);\n\t\tfidx->ei_block = border;\n\t\text4_idx_store_pblock(fidx, oldblock);\n\n\t\text_debug(\"int.index at %d (block %llu): %u -> %llu\\n\",\n\t\t\t\ti, newblock, le32_to_cpu(border), oldblock);\n\n\t\t/* move remainder of path[i] to the new index block */\n\t\tif (unlikely(EXT_MAX_INDEX(path[i].p_hdr) !=\n\t\t\t\t\tEXT_LAST_INDEX(path[i].p_hdr))) {\n\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t\t \"EXT_MAX_INDEX != EXT_LAST_INDEX ee_block %d!\",\n\t\t\t\t\t le32_to_cpu(path[i].p_ext->ee_block));\n\t\t\terr = -EFSCORRUPTED;\n\t\t\tgoto cleanup;\n\t\t}\n\t\t/* start copy indexes */\n\t\tm = EXT_MAX_INDEX(path[i].p_hdr) - path[i].p_idx++;\n\t\text_debug(\"cur 0x%p, last 0x%p\\n\", path[i].p_idx,\n\t\t\t\tEXT_MAX_INDEX(path[i].p_hdr));\n\t\text4_ext_show_move(inode, path, newblock, i);\n\t\tif (m) {\n\t\t\tmemmove(++fidx, path[i].p_idx,\n\t\t\t\tsizeof(struct ext4_extent_idx) * m);\n\t\t\tle16_add_cpu(&neh->eh_entries, m);\n\t\t}\n\t\t/* zero out unused area in the extent block */\n\t\text_size = sizeof(struct ext4_extent_header) +\n\t\t   (sizeof(struct ext4_extent) * le16_to_cpu(neh->eh_entries));\n\t\tmemset(bh->b_data + ext_size, 0,\n\t\t\tinode->i_sb->s_blocksize - ext_size);\n\t\text4_extent_block_csum_set(inode, neh);\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\n\t\terr = ext4_handle_dirty_metadata(handle, inode, bh);\n\t\tif (err)\n\t\t\tgoto cleanup;\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\n\t\t/* correct old index */\n\t\tif (m) {\n\t\t\terr = ext4_ext_get_access(handle, inode, path + i);\n\t\t\tif (err)\n\t\t\t\tgoto cleanup;\n\t\t\tle16_add_cpu(&path[i].p_hdr->eh_entries, -m);\n\t\t\terr = ext4_ext_dirty(handle, inode, path + i);\n\t\t\tif (err)\n\t\t\t\tgoto cleanup;\n\t\t}\n\n\t\ti--;\n\t}\n\n\t/* insert new index */\n\terr = ext4_ext_insert_index(handle, inode, path + at,\n\t\t\t\t    le32_to_cpu(border), newblock);\n\ncleanup:\n\tif (bh) {\n\t\tif (buffer_locked(bh))\n\t\t\tunlock_buffer(bh);\n\t\tbrelse(bh);\n\t}\n\n\tif (err) {\n\t\t/* free all allocated blocks in error case */\n\t\tfor (i = 0; i < depth; i++) {\n\t\t\tif (!ablocks[i])\n\t\t\t\tcontinue;\n\t\t\text4_free_blocks(handle, inode, NULL, ablocks[i], 1,\n\t\t\t\t\t EXT4_FREE_BLOCKS_METADATA);\n\t\t}\n\t}\n\tkfree(ablocks);\n\n\treturn err;\n}", "target": 1, "idx": 11810}
{"commit_id": "1ac1697b3b019f50729a6e992065959586e170da", "project": "GNOME/gdm", "func": "static void\ngdm_manager_class_init (GdmManagerClass *klass)\n{\n        GObjectClass   *object_class = G_OBJECT_CLASS (klass);\n\n        object_class->get_property = gdm_manager_get_property;\n        object_class->set_property = gdm_manager_set_property;\n        object_class->constructor = gdm_manager_constructor;\n        object_class->dispose = gdm_manager_dispose;\n\n        signals [DISPLAY_ADDED] =\n                g_signal_new (\"display-added\",\n                              G_TYPE_FROM_CLASS (object_class),\n                              G_SIGNAL_RUN_LAST,\n                              G_STRUCT_OFFSET (GdmManagerClass, display_added),\n                              NULL,\n                              NULL,\n                              g_cclosure_marshal_VOID__STRING,\n                              G_TYPE_NONE,\n                              1, G_TYPE_STRING);\n        signals [DISPLAY_REMOVED] =\n                g_signal_new (\"display-removed\",\n                              G_TYPE_FROM_CLASS (object_class),\n                              G_SIGNAL_RUN_LAST,\n                              G_STRUCT_OFFSET (GdmManagerClass, display_removed),\n                              NULL,\n                              NULL,\n                              g_cclosure_marshal_VOID__OBJECT,\n                              G_TYPE_NONE,\n                              1, G_TYPE_OBJECT);\n\n        g_object_class_install_property (object_class,\n                                         PROP_XDMCP_ENABLED,\n                                         g_param_spec_boolean (\"xdmcp-enabled\",\n                                                               NULL,\n                                                               NULL,\n                                                               FALSE,\n                                                               G_PARAM_READWRITE | G_PARAM_CONSTRUCT));\n\n        g_type_class_add_private (klass, sizeof (GdmManagerPrivate));\n}", "target": 2, "idx": 11811}
{"commit_id": "ab4d641e395b09c7bb86acfe243a8b986609d72c", "project": "axiomatic-systems/Bento4", "func": "AP4_StszAtom::AP4_StszAtom(AP4_UI32        size, \n                           AP4_UI08        version,\n                           AP4_UI32        flags,\n                           AP4_ByteStream& stream) :\n    AP4_Atom(AP4_ATOM_TYPE_STSZ, size, version, flags)\n{\n    stream.ReadUI32(m_SampleSize);\n    stream.ReadUI32(m_SampleCount);\n    if (m_SampleSize == 0) { // means that the samples have different sizes\n        // check for overflow\n        if (m_SampleCount > (size-8)/4) {\n            m_SampleCount = 0;\n            return;\n        }\n        \n        // read the entries\n        AP4_Cardinal sample_count = m_SampleCount;\n        m_Entries.SetItemCount(sample_count);\n        unsigned char* buffer = new unsigned char[sample_count*4];\n        AP4_Result result = stream.Read(buffer, sample_count*4);\n        if (AP4_FAILED(result)) {\n            delete[] buffer;\n            m_Entries.Clear();\n            m_SampleCount = 0;\n            return;\n        }\n        for (unsigned int i=0; i<sample_count; i++) {\n            m_Entries[i] = AP4_BytesToUInt32BE(&buffer[i*4]);\n        }\n        delete[] buffer;\n    }\n}", "target": 2, "idx": 11812}
{"commit_id": "f57bd745b4cbed577ea654fad4701bea4d38b44c", "project": "moonlight-stream/moonlight-common-c", "func": "int LiSendScrollEvent(signed char scrollClicks) {\n    PPACKET_HOLDER holder;\n    int err;\n\n    if (!initialized) {\n        return -2;\n    }\n\n    holder = malloc(sizeof(*holder));\n    if (holder == NULL) {\n        return -1;\n    }\n\n    holder->packetLength = sizeof(NV_SCROLL_PACKET);\n    holder->packet.scroll.header.packetType = htonl(PACKET_TYPE_SCROLL);\n    holder->packet.scroll.magicA = MAGIC_A;\n    // On Gen 5 servers, the header code is incremented by one\n    if (AppVersionQuad[0] >= 5) {\n        holder->packet.scroll.magicA++;\n    }\n    holder->packet.scroll.zero1 = 0;\n    holder->packet.scroll.zero2 = 0;\n    holder->packet.scroll.scrollAmt1 = htons(scrollClicks * 120);\n    holder->packet.scroll.scrollAmt2 = holder->packet.scroll.scrollAmt1;\n    holder->packet.scroll.zero3 = 0;\n\n    err = LbqOfferQueueItem(&packetQueue, holder, &holder->entry);\n    if (err != LBQ_SUCCESS) {\n        free(holder);\n    }\n\n    return err;\n}", "target": 2, "idx": 11813}
{"commit_id": "ca5358ef75fc69fee5322a38a340f5739d997c10", "project": "torvalds/linux", "func": "static void __dentry_kill(struct dentry *dentry)\n{\n\tstruct dentry *parent = NULL;\n\tbool can_free = true;\n\tif (!IS_ROOT(dentry))\n\t\tparent = dentry->d_parent;\n\n\t/*\n\t * The dentry is now unrecoverably dead to the world.\n\t */\n\tlockref_mark_dead(&dentry->d_lockref);\n\n\t/*\n\t * inform the fs via d_prune that this dentry is about to be\n\t * unhashed and destroyed.\n\t */\n\tif (dentry->d_flags & DCACHE_OP_PRUNE)\n\t\tdentry->d_op->d_prune(dentry);\n\n\tif (dentry->d_flags & DCACHE_LRU_LIST) {\n\t\tif (!(dentry->d_flags & DCACHE_SHRINK_LIST))\n\t\t\td_lru_del(dentry);\n\t}\n\t/* if it was on the hash then remove it */\n\t__d_drop(dentry);\n\t__list_del_entry(&dentry->d_child);\n\t/*\n\t * Inform d_walk() that we are no longer attached to the\n\t * dentry tree\n\t */\n\tdentry->d_flags |= DCACHE_DENTRY_KILLED;\n\tif (parent)\n\t\tspin_unlock(&parent->d_lock);\n\tdentry_iput(dentry);\n\t/*\n\t * dentry_iput drops the locks, at which point nobody (except\n\t * transient RCU lookups) can reach this dentry.\n\t */\n\tBUG_ON((int)dentry->d_lockref.count > 0);\n\tthis_cpu_dec(nr_dentry);\n\tif (dentry->d_op && dentry->d_op->d_release)\n\t\tdentry->d_op->d_release(dentry);\n\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_flags & DCACHE_SHRINK_LIST) {\n\t\tdentry->d_flags |= DCACHE_MAY_FREE;\n\t\tcan_free = false;\n\t}\n\tspin_unlock(&dentry->d_lock);\n\tif (likely(can_free))\n\t\tdentry_free(dentry);\n}", "target": 1, "idx": 11814}
{"commit_id": "53b0dd6dc5957652f35964af16b892ec9af4a559", "project": "tensorflow", "func": "void Compute(OpKernelContext* context) override {\n    auto min_input_tensor = context->input(1);\n    auto max_input_tensor = context->input(2);\n    OP_REQUIRES(\n        context, min_input_tensor.NumElements() == 1,\n        errors::InvalidArgument(\n            \"min_input must be a scalar float value, got tensor with shape \",\n            min_input_tensor.shape()));\n    OP_REQUIRES(\n        context, max_input_tensor.NumElements() == 1,\n        errors::InvalidArgument(\n            \"max_input must be a scalar float value, got tensor with shape \",\n            max_input_tensor.shape()));\n    const float min_input = context->input(1).flat<float>()(0);\n    const float max_input = context->input(2).flat<float>()(0);\n    MaxPoolingOp<Device, T>::Compute(context);\n    Tensor* output_min = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, {}, &output_min));\n    output_min->flat<float>()(0) = min_input;\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(2, {}, &output_max));\n    output_max->flat<float>()(0) = max_input;\n  }", "target": 1, "idx": 11815}
{"commit_id": "28fdce547c417b868c521f87fb58f71ca6b1e3f7", "project": "wireshark", "func": "static gint rtps_util_add_type_library_type(proto_tree *tree,\n        tvbuff_t * tvb, gint offset, const guint encoding, dissection_info *info) {\n  proto_tree * annotation_tree;\n  guint32 member_id = 0, member_length = 0, long_number, i;\n  gint offset_tmp;\n  guint16 short_number;\n  gchar * name = NULL;\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n  offset_tmp = offset;\n\n  /* dissect property */\n  short_number = tvb_get_guint16(tvb, offset_tmp, encoding);\n  proto_tree_add_bitmask_value(tree, tvb, offset_tmp, hf_rtps_type_object_flags,\n          ett_rtps_flags, TYPE_FLAG_FLAGS, short_number);\n  if (info) {\n    if (short_number & 0x02)\n      info->extensibility = EXTENSIBILITY_MUTABLE;\n    else if (short_number & 0x01)\n      info->extensibility = EXTENSIBILITY_FINAL;\n    else\n      info->extensibility = EXTENSIBILITY_EXTENSIBLE;\n  }\n  offset_tmp += 2;\n  if (info)\n    offset_tmp = rtps_util_add_type_id(tree, tvb, offset_tmp, encoding, offset, -1, tree, &(info->type_id));\n  else\n    offset_tmp = rtps_util_add_type_id(tree, tvb, offset_tmp, encoding, offset, -1, tree, NULL);\n  rtps_util_add_string(tree, tvb, offset_tmp, hf_rtps_type_object_type_property_name,\n          encoding);\n  long_number = tvb_get_guint32(tvb, offset_tmp, encoding);\n  name = tvb_get_string_enc(wmem_packet_scope(), tvb, offset_tmp+4, long_number, ENC_ASCII);\n  if (info)\n    (void) g_strlcpy(info->member_name, name, sizeof(info->member_name));\n\n  proto_item_append_text(tree, \" %s\", name);\n  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);\n\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n  offset_tmp = offset;\n\n  /* dissect annotation_seq */\n  long_number = tvb_get_guint32(tvb, offset_tmp, encoding);\n  annotation_tree = proto_tree_add_subtree_format(tree, tvb, offset_tmp, member_length,\n            ett_rtps_type_annotation_usage_list, NULL, \"Annotation Usage Member List (%d elements)\",\n            long_number);\n  offset_tmp += 4;\n  for (i = 0; i < long_number ; i++) {\n      offset_tmp = rtps_util_add_type_annotation_usage(annotation_tree, tvb, offset_tmp,\n              encoding, offset);\n  }\n  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);\n\n  return offset;\n}", "target": 1, "idx": 11816}
{"commit_id": "8968a510250e8c70a611221d63fe0a45b7d3a551", "project": "gpac", "func": "GF_Err abst_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;\n\tint i;\n\tu32 tmp_strsize;\n\tchar *tmp_str;\n\tBool zfound=GF_FALSE;\n\tGF_Err e = GF_OK;\n\n\tISOM_DECREASE_SIZE(ptr, 25)\n\tptr->bootstrapinfo_version = gf_bs_read_u32(bs);\n\tptr->profile = gf_bs_read_int(bs, 2);\n\tptr->live = gf_bs_read_int(bs, 1);\n\tptr->update = gf_bs_read_int(bs, 1);\n\tptr->reserved = gf_bs_read_int(bs, 4);\n\tptr->time_scale = gf_bs_read_u32(bs);\n\tptr->current_media_time = gf_bs_read_u64(bs);\n\tptr->smpte_time_code_offset = gf_bs_read_u64(bs);\n\n\ti=0;\n\tif (ptr->size<8) return GF_ISOM_INVALID_FILE;\n\ttmp_strsize =(u32)ptr->size;\n\ttmp_str = gf_malloc(sizeof(char)*(tmp_strsize+1));\n\tif (!tmp_str) return GF_OUT_OF_MEM;\n\tmemset(tmp_str, 0, sizeof(char)*(tmp_strsize+1) );\n\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i]) {\n\t\t\tzfound = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (!zfound) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\tif (i) {\n\t\tptr->movie_identifier = gf_strdup(tmp_str);\n\t}\n\n\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\tptr->server_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->server_entry_count; i++) {\n\t\tint j=0;\n\t\tzfound = GF_FALSE;\n\t\ttmp_strsize=(u32)ptr->size;\n\t\twhile (tmp_strsize) {\n\t\t\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j]) {\n\t\t\t\tzfound = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\tif (!zfound) {\n\t\t\te = GF_ISOM_INVALID_FILE;\n\t\t\tgoto exit;\n\t\t}\n\t\tif (j) {\n\t\t\tgf_list_add(ptr->server_entry_table, gf_strdup(tmp_str));\n\t\t}\n\t}\n\tif (ptr->server_entry_count != gf_list_count(ptr->server_entry_table)) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\n\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\tptr->quality_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tint j=0;\n\t\tzfound = GF_FALSE;\n\t\ttmp_strsize=(u32)ptr->size;\n\t\twhile (tmp_strsize) {\n\t\t\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j]) {\n\t\t\t\tzfound = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\n\t\tif (!zfound) {\n\t\t\te = GF_ISOM_INVALID_FILE;\n\t\t\tgoto exit;\n\t\t}\n\t\tif (j) {\n\t\t\tgf_list_add(ptr->quality_entry_table, gf_strdup(tmp_str));\n\t\t}\n\t}\n\tif (ptr->quality_entry_count != gf_list_count(ptr->quality_entry_table)) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size;\n\tzfound = GF_FALSE;\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i]) {\n\t\t\tzfound = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (!zfound) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\n\tif (i) {\n\t\tptr->drm_data = gf_strdup(tmp_str);\n\t}\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size;\n\tzfound = GF_FALSE;\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i]) {\n\t\t\tzfound = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (!zfound) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\n\tif (i) {\n\t\tptr->meta_data = gf_strdup(tmp_str);\n\t}\n\n\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\tptr->segment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->segment_run_table_count; i++) {\n\t\tGF_AdobeSegmentRunTableBox *asrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&asrt, bs);\n\t\tif (e) {\n\t\t\tif (asrt) gf_isom_box_del((GF_Box*)asrt);\n\t\t\tgoto exit;\n\t\t}\n\t\tgf_list_add(ptr->segment_run_table_entries, asrt);\n\t}\n\tif (ptr->segment_run_table_count != gf_list_count(ptr->segment_run_table_entries)) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\n\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\tptr->fragment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->fragment_run_table_count; i++) {\n\t\tGF_AdobeFragmentRunTableBox *afrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&afrt, bs);\n\t\tif (e) {\n\t\t\tif (afrt) gf_isom_box_del((GF_Box*)afrt);\n\t\t\tgoto exit;\n\t\t}\n\t\tgf_list_add(ptr->fragment_run_table_entries, afrt);\n\t}\n\tif (ptr->fragment_run_table_count != gf_list_count(ptr->fragment_run_table_entries)) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\nexit:\n\tgf_free(tmp_str);\n\treturn e;\n}", "target": 1, "idx": 11817}
{"commit_id": "5d069dbe8aaf2a197142558b6fb2978189ba3454", "project": "torvalds/linux", "func": "static int fuse_rename2(struct inode *olddir, struct dentry *oldent,\n\t\t\tstruct inode *newdir, struct dentry *newent,\n\t\t\tunsigned int flags)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(olddir);\n\tint err;\n\n\tif (fuse_is_bad(olddir))\n\t\treturn -EIO;\n\n\tif (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE | RENAME_WHITEOUT))\n\t\treturn -EINVAL;\n\n\tif (flags) {\n\t\tif (fc->no_rename2 || fc->minor < 23)\n\t\t\treturn -EINVAL;\n\n\t\terr = fuse_rename_common(olddir, oldent, newdir, newent, flags,\n\t\t\t\t\t FUSE_RENAME2,\n\t\t\t\t\t sizeof(struct fuse_rename2_in));\n\t\tif (err == -ENOSYS) {\n\t\t\tfc->no_rename2 = 1;\n\t\t\terr = -EINVAL;\n\t\t}\n\t} else {\n\t\terr = fuse_rename_common(olddir, oldent, newdir, newent, 0,\n\t\t\t\t\t FUSE_RENAME,\n\t\t\t\t\t sizeof(struct fuse_rename_in));\n\t}\n\n\treturn err;\n}", "target": 1, "idx": 11818}
{"commit_id": "f20ce1128fb7f4d33297eee307dddaf0f92ac72d", "project": "libidn", "func": "int\nidna_to_ascii_4i (const uint32_t * in, size_t inlen, char *out, int flags)\n{\n  size_t len, outlen;\n  uint32_t *src;\t\t/* XXX don't need to copy data? */\n  int rc;\n\n  /*\n   * ToASCII consists of the following steps:\n   *\n   * 1. If all code points in the sequence are in the ASCII range (0..7F)\n   * then skip to step 3.\n   */\n\n  {\n    size_t i;\n    int inasciirange;\n\n    inasciirange = 1;\n    for (i = 0; i < inlen; i++)\n      if (in[i] > 0x7F)\n\tinasciirange = 0;\n    if (inasciirange)\n      {\n\tsrc = malloc (sizeof (in[0]) * (inlen + 1));\n\tif (src == NULL)\n\t  return IDNA_MALLOC_ERROR;\n\n\tmemcpy (src, in, sizeof (in[0]) * inlen);\n\tsrc[inlen] = 0;\n\n\tgoto step3;\n      }\n  }\n\n  /*\n   * 2. Perform the steps specified in [NAMEPREP] and fail if there is\n   * an error. The AllowUnassigned flag is used in [NAMEPREP].\n   */\n\n  {\n    char *p;\n\n    p = stringprep_ucs4_to_utf8 (in, (ssize_t) inlen, NULL, NULL);\n    if (p == NULL)\n      return IDNA_MALLOC_ERROR;\n\n    len = strlen (p);\n    do\n      {\n\tchar *newp;\n\n\tlen = 2 * len + 10;\t/* XXX better guess? */\n\tnewp = realloc (p, len);\n\tif (newp == NULL)\n\t  {\n\t    free (p);\n\t    return IDNA_MALLOC_ERROR;\n\t  }\n\tp = newp;\n\n\tif (flags & IDNA_ALLOW_UNASSIGNED)\n\t  rc = stringprep_nameprep (p, len);\n\telse\n\t  rc = stringprep_nameprep_no_unassigned (p, len);\n      }\n    while (rc == STRINGPREP_TOO_SMALL_BUFFER);\n\n    if (rc != STRINGPREP_OK)\n      {\n\tfree (p);\n\treturn IDNA_STRINGPREP_ERROR;\n      }\n\n    src = stringprep_utf8_to_ucs4 (p, -1, NULL);\n\n    free (p);\n\n    if (!src)\n      return IDNA_MALLOC_ERROR;\n  }\n\nstep3:\n  /*\n   * 3. If the UseSTD3ASCIIRules flag is set, then perform these checks:\n   *\n   * (a) Verify the absence of non-LDH ASCII code points; that is,\n   * the absence of 0..2C, 2E..2F, 3A..40, 5B..60, and 7B..7F.\n   *\n   * (b) Verify the absence of leading and trailing hyphen-minus;\n   * that is, the absence of U+002D at the beginning and end of\n   * the sequence.\n   */\n\n  if (flags & IDNA_USE_STD3_ASCII_RULES)\n    {\n      size_t i;\n\n      for (i = 0; src[i]; i++)\n\tif (src[i] <= 0x2C || src[i] == 0x2E || src[i] == 0x2F ||\n\t    (src[i] >= 0x3A && src[i] <= 0x40) ||\n\t    (src[i] >= 0x5B && src[i] <= 0x60) ||\n\t    (src[i] >= 0x7B && src[i] <= 0x7F))\n\t  {\n\t    free (src);\n\t    return IDNA_CONTAINS_NON_LDH;\n\t  }\n\n      if (src[0] == 0x002D || (i > 0 && src[i - 1] == 0x002D))\n\t{\n\t  free (src);\n\t  return IDNA_CONTAINS_MINUS;\n\t}\n    }\n\n  /*\n   * 4. If all code points in the sequence are in the ASCII range\n   * (0..7F), then skip to step 8.\n   */\n\n  {\n    size_t i;\n    int inasciirange;\n\n    inasciirange = 1;\n    for (i = 0; src[i]; i++)\n      {\n\tif (src[i] > 0x7F)\n\t  inasciirange = 0;\n\t/* copy string to output buffer if we are about to skip to step8 */\n\tif (i < 64)\n\t  out[i] = src[i];\n      }\n    if (i < 64)\n      out[i] = '\\0';\n    else\n      return IDNA_INVALID_LENGTH;\n    if (inasciirange)\n      goto step8;\n  }\n\n  /*\n   * 5. Verify that the sequence does NOT begin with the ACE prefix.\n   *\n   */\n\n  {\n    size_t i;\n    int match;\n\n    match = 1;\n    for (i = 0; match && i < strlen (IDNA_ACE_PREFIX); i++)\n      if (((uint32_t) IDNA_ACE_PREFIX[i] & 0xFF) != src[i])\n\tmatch = 0;\n    if (match)\n      {\n\tfree (src);\n\treturn IDNA_CONTAINS_ACE_PREFIX;\n      }\n  }\n\n  /*\n   * 6. Encode the sequence using the encoding algorithm in [PUNYCODE]\n   * and fail if there is an error.\n   */\n  for (len = 0; src[len]; len++)\n    ;\n  src[len] = '\\0';\n  outlen = 63 - strlen (IDNA_ACE_PREFIX);\n  rc = punycode_encode (len, src, NULL,\n\t\t\t&outlen, &out[strlen (IDNA_ACE_PREFIX)]);\n  if (rc != PUNYCODE_SUCCESS)\n    {\n      free (src);\n      return IDNA_PUNYCODE_ERROR;\n    }\n  out[strlen (IDNA_ACE_PREFIX) + outlen] = '\\0';\n\n  /*\n   * 7. Prepend the ACE prefix.\n   */\n\n  memcpy (out, IDNA_ACE_PREFIX, strlen (IDNA_ACE_PREFIX));\n\n  /*\n   * 8. Verify that the number of code points is in the range 1 to 63\n   * inclusive (0 is excluded).\n   */\n\nstep8:\n  free (src);\n  if (strlen (out) < 1)\n    return IDNA_INVALID_LENGTH;\n\n  return IDNA_SUCCESS;\n}", "target": 2, "idx": 11819}
{"commit_id": "3b5369cf2a1851a062510e21261e0904704aebba", "project": "contiki-ng", "func": "static void\nparse_publish_vhdr(struct mqtt_connection *conn,\n                   uint32_t *pos,\n                   const uint8_t *input_data_ptr,\n                   int input_data_len)\n{\n  uint16_t copy_bytes;\n\n  /* Read out topic length */\n  if(conn->in_packet.topic_len_received == 0) {\n    conn->in_packet.topic_pos = 0;\n    conn->in_packet.topic_len = (input_data_ptr[(*pos)++] << 8);\n    conn->in_packet.byte_counter++;\n    if(*pos >= input_data_len) {\n      return;\n    }\n    conn->in_packet.topic_len |= input_data_ptr[(*pos)++];\n    conn->in_packet.byte_counter++;\n    conn->in_packet.topic_len_received = 1;\n\n    DBG(\"MQTT - Read PUBLISH topic len %i\\n\", conn->in_packet.topic_len);\n    /* WARNING: Check here if TOPIC fits in payload area, otherwise error */\n  }\n\n  /* Read out topic */\n  if(conn->in_packet.topic_len_received == 1 &&\n     conn->in_packet.topic_received == 0) {\n    copy_bytes = MIN(conn->in_packet.topic_len - conn->in_packet.topic_pos,\n                     input_data_len - *pos);\n    DBG(\"MQTT - topic_pos: %i copy_bytes: %i\", conn->in_packet.topic_pos,\n        copy_bytes);\n    memcpy(&conn->in_publish_msg.topic[conn->in_packet.topic_pos],\n           &input_data_ptr[*pos],\n           copy_bytes);\n    (*pos) += copy_bytes;\n    conn->in_packet.byte_counter += copy_bytes;\n    conn->in_packet.topic_pos += copy_bytes;\n\n    if(conn->in_packet.topic_len - conn->in_packet.topic_pos == 0) {\n      DBG(\"MQTT - Got topic '%s'\", conn->in_publish_msg.topic);\n      conn->in_packet.topic_received = 1;\n      conn->in_publish_msg.topic[conn->in_packet.topic_pos] = '\\0';\n      conn->in_publish_msg.payload_length =\n        conn->in_packet.remaining_length - conn->in_packet.topic_len - 2;\n      conn->in_publish_msg.payload_left = conn->in_publish_msg.payload_length;\n    }\n\n    /* Set this once per incomming publish message */\n    conn->in_publish_msg.first_chunk = 1;\n  }\n}", "target": 3, "idx": 11820}
{"commit_id": "4631115647c1e4f0482ffe0491c2f38d2231337b", "project": "poppler", "func": "int main(int argc, char *argv[])\n///////////////////////////////////////////////////////////////////////////\n// Merge PDF files given by arguments 1 to argc-2 and write the result\n// to the file specified by argument argc-1.\n///////////////////////////////////////////////////////////////////////////\n{\n    int objectsCount = 0;\n    unsigned int numOffset = 0;\n    std::vector<Object> pages;\n    std::vector<unsigned int> offsets;\n    XRef *yRef, *countRef;\n    FILE *f;\n    OutStream *outStr;\n    int i;\n    int j, rootNum;\n    std::vector<PDFDoc *> docs;\n    int majorVersion = 0;\n    int minorVersion = 0;\n    char *fileName = argv[argc - 1];\n\n    const bool ok = parseArgs(argDesc, &argc, argv);\n    if (!ok || argc < 3 || printVersion || printHelp) {\n        fprintf(stderr, \"pdfunite version %s\\n\", PACKAGE_VERSION);\n        fprintf(stderr, \"%s\\n\", popplerCopyright);\n        fprintf(stderr, \"%s\\n\", xpdfCopyright);\n        if (!printVersion) {\n            printUsage(\"pdfunite\", \"<PDF-sourcefile-1>..<PDF-sourcefile-n> <PDF-destfile>\", argDesc);\n        }\n        if (printVersion || printHelp) {\n            return 0;\n        }\n        return 99;\n    }\n    globalParams = std::make_unique<GlobalParams>();\n\n    for (i = 1; i < argc - 1; i++) {\n        PDFDoc *doc = new PDFDoc(std::make_unique<GooString>(argv[i]));\n        if (doc->isOk() && !doc->isEncrypted() && doc->getXRef()->getCatalog().isDict()) {\n            docs.push_back(doc);\n            if (doc->getPDFMajorVersion() > majorVersion) {\n                majorVersion = doc->getPDFMajorVersion();\n                minorVersion = doc->getPDFMinorVersion();\n            } else if (doc->getPDFMajorVersion() == majorVersion) {\n                if (doc->getPDFMinorVersion() > minorVersion) {\n                    minorVersion = doc->getPDFMinorVersion();\n                }\n            }\n        } else if (doc->isOk()) {\n            if (doc->isEncrypted()) {\n                error(errUnimplemented, -1, \"Could not merge encrypted files ('{0:s}')\", argv[i]);\n                return -1;\n            } else if (!doc->getXRef()->getCatalog().isDict()) {\n                error(errSyntaxError, -1, \"XRef's Catalog is not a dictionary ('{0:s}')\", argv[i]);\n                return -1;\n            }\n        } else {\n            error(errSyntaxError, -1, \"Could not merge damaged documents ('{0:s}')\", argv[i]);\n            return -1;\n        }\n    }\n\n    if (!(f = fopen(fileName, \"wb\"))) {\n        error(errIO, -1, \"Could not open file '{0:s}'\", fileName);\n        return -1;\n    }\n    outStr = new FileOutStream(f, 0);\n\n    yRef = new XRef();\n    countRef = new XRef();\n    yRef->add(0, 65535, 0, false);\n    PDFDoc::writeHeader(outStr, majorVersion, minorVersion);\n\n    // handle OutputIntents, AcroForm, OCProperties & Names\n    Object intents;\n    Object names;\n    Object afObj;\n    Object ocObj;\n    if (docs.size() >= 1) {\n        Object catObj = docs[0]->getXRef()->getCatalog();\n        if(!catObj.isDict()){\n            fclose(f);\n            delete yRef;\n            delete countRef;\n            delete outStr;\n            error(errSyntaxError, -1, \"XRef's Catalog is not a dictionary.\");\n            return -1;\n        }\n        Dict *catDict = catObj.getDict();\n        intents = catDict->lookup(\"OutputIntents\");\n        afObj = catDict->lookupNF(\"AcroForm\").copy();\n        Ref *refPage = docs[0]->getCatalog()->getPageRef(1);\n        if (!afObj.isNull() && refPage) {\n            docs[0]->markAcroForm(&afObj, yRef, countRef, 0, refPage->num, refPage->num);\n        }\n        ocObj = catDict->lookupNF(\"OCProperties\").copy();\n        if (!ocObj.isNull() && ocObj.isDict() && refPage) {\n            docs[0]->markPageObjects(ocObj.getDict(), yRef, countRef, 0, refPage->num, refPage->num);\n        }\n        names = catDict->lookup(\"Names\");\n        if (!names.isNull() && names.isDict() && refPage) {\n            docs[0]->markPageObjects(names.getDict(), yRef, countRef, 0, refPage->num, refPage->num);\n        }\n        if (intents.isArray() && intents.arrayGetLength() > 0) {\n            for (i = 1; i < (int)docs.size(); i++) {\n                Object pagecatObj = docs[i]->getXRef()->getCatalog();\n                Dict *pagecatDict = pagecatObj.getDict();\n                Object pageintents = pagecatDict->lookup(\"OutputIntents\");\n                if (pageintents.isArray() && pageintents.arrayGetLength() > 0) {\n                    for (j = intents.arrayGetLength() - 1; j >= 0; j--) {\n                        Object intent = intents.arrayGet(j, 0);\n                        if (intent.isDict()) {\n                            Object idf = intent.dictLookup(\"OutputConditionIdentifier\");\n                            if (idf.isString()) {\n                                const GooString *gidf = idf.getString();\n                                bool removeIntent = true;\n                                for (int k = 0; k < pageintents.arrayGetLength(); k++) {\n                                    Object pgintent = pageintents.arrayGet(k, 0);\n                                    if (pgintent.isDict()) {\n                                        Object pgidf = pgintent.dictLookup(\"OutputConditionIdentifier\");\n                                        if (pgidf.isString()) {\n                                            const GooString *gpgidf = pgidf.getString();\n                                            if (gpgidf->cmp(gidf) == 0) {\n                                                removeIntent = false;\n                                                break;\n                                            }\n                                        }\n                                    }\n                                }\n                                if (removeIntent) {\n                                    intents.arrayRemove(j);\n                                    error(errSyntaxWarning, -1, \"Output intent {0:s} missing in pdf {1:s}, removed\", gidf->c_str(), docs[i]->getFileName()->c_str());\n                                }\n                            } else {\n                                intents.arrayRemove(j);\n                                error(errSyntaxWarning, -1, \"Invalid output intent dict, missing required OutputConditionIdentifier\");\n                            }\n                        } else {\n                            intents.arrayRemove(j);\n                        }\n                    }\n                } else {\n                    error(errSyntaxWarning, -1, \"Output intents differs, remove them all\");\n                    break;\n                }\n            }\n        }\n        if (intents.isArray() && intents.arrayGetLength() > 0) {\n            for (j = intents.arrayGetLength() - 1; j >= 0; j--) {\n                Object intent = intents.arrayGet(j, 0);\n                if (intent.isDict()) {\n                    docs[0]->markPageObjects(intent.getDict(), yRef, countRef, numOffset, 0, 0);\n                } else {\n                    intents.arrayRemove(j);\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < (int)docs.size(); i++) {\n        for (j = 1; j <= docs[i]->getNumPages(); j++) {\n            if (!docs[i]->getCatalog()->getPage(j)) {\n                continue;\n            }\n\n            const PDFRectangle *cropBox = nullptr;\n            if (docs[i]->getCatalog()->getPage(j)->isCropped()) {\n                cropBox = docs[i]->getCatalog()->getPage(j)->getCropBox();\n            }\n            docs[i]->replacePageDict(j, docs[i]->getCatalog()->getPage(j)->getRotate(), docs[i]->getCatalog()->getPage(j)->getMediaBox(), cropBox);\n            Ref *refPage = docs[i]->getCatalog()->getPageRef(j);\n            Object page = docs[i]->getXRef()->fetch(*refPage);\n            Dict *pageDict = page.getDict();\n            Object *resDict = docs[i]->getCatalog()->getPage(j)->getResourceDictObject();\n            if (resDict->isDict()) {\n                pageDict->set(\"Resources\", resDict->copy());\n            }\n            pages.push_back(std::move(page));\n            offsets.push_back(numOffset);\n            docs[i]->markPageObjects(pageDict, yRef, countRef, numOffset, refPage->num, refPage->num);\n            Object annotsObj = pageDict->lookupNF(\"Annots\").copy();\n            if (!annotsObj.isNull()) {\n                docs[i]->markAnnotations(&annotsObj, yRef, countRef, numOffset, refPage->num, refPage->num);\n            }\n        }\n        Object pageCatObj = docs[i]->getXRef()->getCatalog();\n        if(!pageCatObj.isDict()){\n            fclose(f);\n            delete yRef;\n            delete countRef;\n            delete outStr;\n            error(errSyntaxError, -1, \"XRef's Catalog is not a dictionary.\");\n            return -1;\n        }\n        Dict *pageCatDict = pageCatObj.getDict();\n        Object pageNames = pageCatDict->lookup(\"Names\");\n        if (!pageNames.isNull() && pageNames.isDict()) {\n            if (!names.isDict()) {\n                names = Object(new Dict(yRef));\n            }\n            doMergeNameDict(docs[i], yRef, countRef, 0, 0, names.getDict(), pageNames.getDict(), numOffset);\n        }\n        Object pageForm = pageCatDict->lookup(\"AcroForm\");\n        if (i > 0 && !pageForm.isNull() && pageForm.isDict()) {\n            if (afObj.isNull()) {\n                afObj = pageCatDict->lookupNF(\"AcroForm\").copy();\n            } else if (afObj.isDict()) {\n                doMergeFormDict(afObj.getDict(), pageForm.getDict(), numOffset);\n            }\n        }\n        objectsCount += docs[i]->writePageObjects(outStr, yRef, numOffset, true);\n        numOffset = yRef->getNumObjects() + 1;\n    }\n\n    rootNum = yRef->getNumObjects() + 1;\n    yRef->add(rootNum, 0, outStr->getPos(), true);\n    outStr->printf(\"%d 0 obj\\n\", rootNum);\n    outStr->printf(\"<< /Type /Catalog /Pages %d 0 R\", rootNum + 1);\n    // insert OutputIntents\n    if (intents.isArray() && intents.arrayGetLength() > 0) {\n        outStr->printf(\" /OutputIntents [\");\n        for (j = 0; j < intents.arrayGetLength(); j++) {\n            Object intent = intents.arrayGet(j, 0);\n            if (intent.isDict()) {\n                PDFDoc::writeObject(&intent, outStr, yRef, 0, nullptr, cryptRC4, 0, 0, 0);\n            }\n        }\n        outStr->printf(\"]\");\n    }\n    // insert AcroForm\n    if (!afObj.isNull()) {\n        outStr->printf(\" /AcroForm \");\n        PDFDoc::writeObject(&afObj, outStr, yRef, 0, nullptr, cryptRC4, 0, 0, 0);\n    }\n    // insert OCProperties\n    if (!ocObj.isNull() && ocObj.isDict()) {\n        outStr->printf(\" /OCProperties \");\n        PDFDoc::writeObject(&ocObj, outStr, yRef, 0, nullptr, cryptRC4, 0, 0, 0);\n    }\n    // insert Names\n    if (!names.isNull() && names.isDict()) {\n        outStr->printf(\" /Names \");\n        PDFDoc::writeObject(&names, outStr, yRef, 0, nullptr, cryptRC4, 0, 0, 0);\n    }\n    outStr->printf(\">>\\nendobj\\n\");\n    objectsCount++;\n\n    yRef->add(rootNum + 1, 0, outStr->getPos(), true);\n    outStr->printf(\"%d 0 obj\\n\", rootNum + 1);\n    outStr->printf(\"<< /Type /Pages /Kids [\");\n    for (j = 0; j < (int)pages.size(); j++) {\n        outStr->printf(\" %d 0 R\", rootNum + j + 2);\n    }\n    outStr->printf(\" ] /Count %zd >>\\nendobj\\n\", pages.size());\n    objectsCount++;\n\n    for (i = 0; i < (int)pages.size(); i++) {\n        yRef->add(rootNum + i + 2, 0, outStr->getPos(), true);\n        outStr->printf(\"%d 0 obj\\n\", rootNum + i + 2);\n        outStr->printf(\"<< \");\n        Dict *pageDict = pages[i].getDict();\n        for (j = 0; j < pageDict->getLength(); j++) {\n            if (j > 0) {\n                outStr->printf(\" \");\n            }\n            const char *key = pageDict->getKey(j);\n            Object value = pageDict->getValNF(j).copy();\n            if (strcmp(key, \"Parent\") == 0) {\n                outStr->printf(\"/Parent %d 0 R\", rootNum + 1);\n            } else {\n                outStr->printf(\"/%s \", key);\n                PDFDoc::writeObject(&value, outStr, yRef, offsets[i], nullptr, cryptRC4, 0, 0, 0);\n            }\n        }\n        outStr->printf(\" >>\\nendobj\\n\");\n        objectsCount++;\n    }\n    Goffset uxrefOffset = outStr->getPos();\n    Ref ref;\n    ref.num = rootNum;\n    ref.gen = 0;\n    Object trailerDict = PDFDoc::createTrailerDict(objectsCount, false, 0, &ref, yRef, fileName, outStr->getPos());\n    PDFDoc::writeXRefTableTrailer(std::move(trailerDict), yRef, true, // write all entries according to ISO 32000-1, 7.5.4 Cross-Reference Table: \"For a file that has never been incrementally updated, the cross-reference section shall\n                                                                      // contain only one subsection, whose object numbering begins at 0.\"\n                                  uxrefOffset, outStr, yRef);\n\n    outStr->close();\n    delete outStr;\n    fclose(f);\n    delete yRef;\n    delete countRef;\n    for (i = 0; i < (int)docs.size(); i++) {\n        delete docs[i];\n    }\n    return 0;\n}", "target": 1, "idx": 11821}
{"commit_id": "7873f8334c8d31031f8cfa83bd97ac6029309e4f", "project": "sudo-project/sudo", "func": "int\ncmnd_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct member *m, const char *runchroot, struct cmnd_info *info)\n{\n    struct alias *a;\n    struct sudo_command *c;\n    int rc, matched = UNSPEC;\n    debug_decl(cmnd_matches, SUDOERS_DEBUG_MATCH);\n\n    switch (m->type) {\n\tcase ALL:\n\tcase COMMAND:\n\t    c = (struct sudo_command *)m->name;\n\t    if (command_matches(parse_tree->ctx, c->cmnd, c->args, runchroot,\n\t\t    info, &c->digests))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase ALIAS:\n\t    a = alias_get(parse_tree, m->name, CMNDALIAS);\n\t    if (a != NULL) {\n\t\trc = cmndlist_matches(parse_tree, &a->members, runchroot, info);\n\t\tif (SPECIFIED(rc)) {\n\t\t    if (m->negated) {\n\t\t\tmatched = rc == ALLOW ? DENY : ALLOW;\n\t\t    } else {\n\t\t\tmatched = rc;\n\t\t    }\n\t\t}\n\t\talias_put(a);\n\t    }\n\t    break;\n    }\n    debug_return_int(matched);\n}", "target": 2, "idx": 11822}
{"commit_id": "16b1414de91b5a82a0996c67f6db3af7d7e32873", "project": "xen-project/xen", "func": "int replace_grant_pv_mapping(uint64_t addr, unsigned long frame,\n                             uint64_t new_addr, unsigned int flags)\n{\n    struct vcpu *curr = current;\n    l1_pgentry_t *pl1e, ol1e;\n    unsigned long gl1mfn;\n    struct page_info *l1pg;\n    int rc;\n    unsigned int grant_pte_flags;\n\n    grant_pte_flags =\n        _PAGE_PRESENT | _PAGE_ACCESSED | _PAGE_DIRTY | _PAGE_GNTTAB | _PAGE_NX;\n\n    if ( flags & GNTMAP_application_map )\n        grant_pte_flags |= _PAGE_USER;\n    if ( !(flags & GNTMAP_readonly) )\n        grant_pte_flags |= _PAGE_RW;\n    /*\n     * On top of the explicit settings done by create_grant_host_mapping()\n     * also open-code relevant parts of adjust_guest_l1e(). Don't mirror\n     * available and cachability flags, though.\n     */\n    if ( !is_pv_32bit_domain(curr->domain) )\n        grant_pte_flags |= (grant_pte_flags & _PAGE_USER)\n                           ? _PAGE_GLOBAL\n                           : _PAGE_GUEST_KERNEL | _PAGE_USER;\n\n    if ( flags & GNTMAP_contains_pte )\n    {\n        if ( !new_addr )\n            return destroy_grant_pte_mapping(addr, frame, grant_pte_flags,\n                                             curr->domain);\n\n        return GNTST_general_error;\n    }\n\n    if ( !new_addr )\n        return destroy_grant_va_mapping(addr, frame, grant_pte_flags, curr);\n\n    pl1e = guest_map_l1e(new_addr, &gl1mfn);\n    if ( !pl1e )\n    {\n        gdprintk(XENLOG_WARNING,\n                 \"Could not find L1 PTE for address %\"PRIx64\"\\n\", new_addr);\n        return GNTST_general_error;\n    }\n\n    if ( !get_page_from_mfn(_mfn(gl1mfn), current->domain) )\n    {\n        guest_unmap_l1e(pl1e);\n        return GNTST_general_error;\n    }\n\n    l1pg = mfn_to_page(_mfn(gl1mfn));\n    if ( !page_lock(l1pg) )\n    {\n        put_page(l1pg);\n        guest_unmap_l1e(pl1e);\n        return GNTST_general_error;\n    }\n\n    if ( (l1pg->u.inuse.type_info & PGT_type_mask) != PGT_l1_page_table )\n    {\n        page_unlock(l1pg);\n        put_page(l1pg);\n        guest_unmap_l1e(pl1e);\n        return GNTST_general_error;\n    }\n\n    ol1e = *pl1e;\n\n    if ( unlikely(!UPDATE_ENTRY(l1, pl1e, ol1e, l1e_empty(),\n                                gl1mfn, curr, 0)) )\n    {\n        page_unlock(l1pg);\n        put_page(l1pg);\n        gdprintk(XENLOG_WARNING, \"Cannot delete PTE entry at %p\\n\", pl1e);\n        guest_unmap_l1e(pl1e);\n        return GNTST_general_error;\n    }\n\n    page_unlock(l1pg);\n    put_page(l1pg);\n    guest_unmap_l1e(pl1e);\n\n    rc = replace_grant_va_mapping(addr, frame, grant_pte_flags, ol1e, curr);\n    if ( rc )\n        put_page_from_l1e(ol1e, curr->domain);\n\n    return rc;\n}", "target": 2, "idx": 11823}
{"commit_id": "5c90ca033c7cc1074ff5f3fb67c2bac498d955bc", "project": "pcmacdon/jsish", "func": "bool Jsi_ValueIsNumber(Jsi_Interp *interp, Jsi_Value *pv)\n{\n    return (pv && (pv->vt == JSI_VT_NUMBER || (pv->vt == JSI_VT_OBJECT && pv->d.obj->ot == JSI_OT_NUMBER)));\n}", "target": 1, "idx": 11824}
{"commit_id": "3095060f479b86288e31c79ecbc5131a66bcd2f9", "project": "openbsd/src", "func": "int\nssh_packet_get_state(struct ssh *ssh, struct sshbuf *m)\n{\n\tstruct session_state *state = ssh->state;\n\tu_char *p;\n\tsize_t slen, rlen;\n\tint r, ssh1cipher;\n\n\tif (!compat20) {\n\t\tssh1cipher = cipher_ctx_get_number(state->receive_context);\n\t\tslen = cipher_get_keyiv_len(state->send_context);\n\t\trlen = cipher_get_keyiv_len(state->receive_context);\n\t\tif ((r = sshbuf_put_u32(m, state->remote_protocol_flags)) != 0 ||\n\t\t    (r = sshbuf_put_u32(m, ssh1cipher)) != 0 ||\n\t\t    (r = sshbuf_put_string(m, state->ssh1_key, state->ssh1_keylen)) != 0 ||\n\t\t    (r = sshbuf_put_u32(m, slen)) != 0 ||\n\t\t    (r = sshbuf_reserve(m, slen, &p)) != 0 ||\n\t\t    (r = cipher_get_keyiv(state->send_context, p, slen)) != 0 ||\n\t\t    (r = sshbuf_put_u32(m, rlen)) != 0 ||\n\t\t    (r = sshbuf_reserve(m, rlen, &p)) != 0 ||\n\t\t    (r = cipher_get_keyiv(state->receive_context, p, rlen)) != 0)\n\t\t\treturn r;\n\t} else {\n\t\tif ((r = kex_to_blob(m, ssh->kex)) != 0 ||\n\t\t    (r = newkeys_to_blob(m, ssh, MODE_OUT)) != 0 ||\n\t\t    (r = newkeys_to_blob(m, ssh, MODE_IN)) != 0 ||\n\t\t    (r = sshbuf_put_u64(m, state->rekey_limit)) != 0 ||\n\t\t    (r = sshbuf_put_u32(m, state->rekey_interval)) != 0 ||\n\t\t    (r = sshbuf_put_u32(m, state->p_send.seqnr)) != 0 ||\n\t\t    (r = sshbuf_put_u64(m, state->p_send.blocks)) != 0 ||\n\t\t    (r = sshbuf_put_u32(m, state->p_send.packets)) != 0 ||\n\t\t    (r = sshbuf_put_u64(m, state->p_send.bytes)) != 0 ||\n\t\t    (r = sshbuf_put_u32(m, state->p_read.seqnr)) != 0 ||\n\t\t    (r = sshbuf_put_u64(m, state->p_read.blocks)) != 0 ||\n\t\t    (r = sshbuf_put_u32(m, state->p_read.packets)) != 0 ||\n\t\t    (r = sshbuf_put_u64(m, state->p_read.bytes)) != 0)\n\t\t\treturn r;\n\t}\n\n\tslen = cipher_get_keycontext(state->send_context, NULL);\n\trlen = cipher_get_keycontext(state->receive_context, NULL);\n\tif ((r = sshbuf_put_u32(m, slen)) != 0 ||\n\t    (r = sshbuf_reserve(m, slen, &p)) != 0)\n\t\treturn r;\n\tif (cipher_get_keycontext(state->send_context, p) != (int)slen)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tif ((r = sshbuf_put_u32(m, rlen)) != 0 ||\n\t    (r = sshbuf_reserve(m, rlen, &p)) != 0)\n\t\treturn r;\n\tif (cipher_get_keycontext(state->receive_context, p) != (int)rlen)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tif ((r = sshbuf_put_stringb(m, state->input)) != 0 ||\n\t    (r = sshbuf_put_stringb(m, state->output)) != 0)\n\t\treturn r;\n\n\treturn 0;\n}", "target": 2, "idx": 11825}
{"commit_id": "068b963bb7afc57f5bdd723de0dd15e7795d5822", "project": "openssl", "func": "unsigned int X509v3_addr_get_afi(const IPAddressFamily *f)\n{\n    if (f == NULL\n            || f->addressFamily == NULL\n            || f->addressFamily->data == NULL\n            || f->addressFamily->length < 2)\n        return 0;\n    return (f->addressFamily->data[0] << 8) | f->addressFamily->data[1];\n}", "target": 1, "idx": 11826}
{"commit_id": "56b88b50565cd8b946a2d00b0c83927b7ebb055e", "project": "torvalds/linux", "func": "static int snd_ctl_elem_read(struct snd_card *card,\n\t\t\t     struct snd_ctl_elem_value *control)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int index_offset;\n\tstruct snd_ctl_elem_info info;\n\tconst u32 pattern = 0xdeadbeef;\n\tint ret;\n\n\tdown_read(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, &control->id);\n\tif (kctl == NULL) {\n\t\tret = -ENOENT;\n\t\tgoto unlock;\n\t}\n\n\tindex_offset = snd_ctl_get_ioff(kctl, &control->id);\n\tvd = &kctl->vd[index_offset];\n\tif (!(vd->access & SNDRV_CTL_ELEM_ACCESS_READ) || kctl->get == NULL) {\n\t\tret = -EPERM;\n\t\tgoto unlock;\n\t}\n\n\tsnd_ctl_build_ioff(&control->id, kctl, index_offset);\n\n#ifdef CONFIG_SND_CTL_DEBUG\n\t/* info is needed only for validation */\n\tmemset(&info, 0, sizeof(info));\n\tinfo.id = control->id;\n\tret = __snd_ctl_elem_info(card, kctl, &info, NULL);\n\tif (ret < 0)\n\t\tgoto unlock;\n#endif\n\n\tif (!snd_ctl_skip_validation(&info))\n\t\tfill_remaining_elem_value(control, &info, pattern);\n\tret = snd_power_ref_and_wait(card);\n\tif (!ret)\n\t\tret = kctl->get(kctl, control);\n\tsnd_power_unref(card);\n\tif (ret < 0)\n\t\tgoto unlock;\n\tif (!snd_ctl_skip_validation(&info) &&\n\t    sanity_check_elem_value(card, control, &info, pattern) < 0) {\n\t\tdev_err(card->dev,\n\t\t\t\"control %i:%i:%i:%s:%i: access overflow\\n\",\n\t\t\tcontrol->id.iface, control->id.device,\n\t\t\tcontrol->id.subdevice, control->id.name,\n\t\t\tcontrol->id.index);\n\t\tret = -EINVAL;\n\t\tgoto unlock;\n\t}\nunlock:\n\tup_read(&card->controls_rwsem);\n\treturn ret;\n}", "target": 2, "idx": 11827}
{"commit_id": "ecf9267a24b2c3c0cd211dbdfa9ef2232511972a", "project": "GNOME/librsvg", "func": "static void\nbox_blur_line (gint box_width, gint even_offset,\n               guchar *src, guchar *dest,\n               gint len, gint bpp)\n{\n    gint  i;\n    gint  lead;    /* This marks the leading edge of the kernel              */\n    gint  output;  /* This marks the center of the kernel                    */\n    gint  trail;   /* This marks the pixel BEHIND the last 1 in the\n                      kernel; it's the pixel to remove from the accumulator. */\n    gint  *ac;     /* Accumulator for each channel                           */\n\n    g_assert (box_width > 0);\n\n    ac = g_new0 (gint, bpp);\n\n    /* The algorithm differs for even and odd-sized kernels.\n     * With the output at the center,\n     * If odd, the kernel might look like this: 0011100\n     * If even, the kernel will either be centered on the boundary between\n     * the output and its left neighbor, or on the boundary between the\n     * output and its right neighbor, depending on even_lr.\n     * So it might be 0111100 or 0011110, where output is on the center\n     * of these arrays.\n     */\n    lead = 0;\n\n    if (box_width % 2 != 0) {\n        /* Odd-width kernel */\n        output = lead - (box_width - 1) / 2;\n        trail  = lead - box_width;\n    } else {\n        /* Even-width kernel. */\n        if (even_offset == 1) {\n            /* Right offset */\n            output = lead + 1 - box_width / 2;\n            trail  = lead - box_width;\n        } else if (even_offset == -1) {\n            /* Left offset */\n            output = lead - box_width / 2;\n            trail  = lead - box_width;\n        } else {\n            /* If even_offset isn't 1 or -1, there's some error. */\n            g_assert_not_reached ();\n        }\n    }\n\n    /* Initialize accumulator */\n    for (i = 0; i < bpp; i++)\n        ac[i] = 0;\n\n    /* As the kernel moves across the image, it has a leading edge and a\n     * trailing edge, and the output is in the middle. */\n    while (output < len) {\n        /* The number of pixels that are both in the image and\n         * currently covered by the kernel. This is necessary to\n         * handle edge cases. */\n        guint coverage = (lead < len ? lead : len - 1) - (trail >= 0 ? trail : -1);\n\n#ifdef READABLE_BOXBLUR_CODE\n/* The code here does the same as the code below, but the code below\n * has been optimized by moving the if statements out of the tight for\n * loop, and is harder to understand.\n * Don't use both this code and the code below. */\n        for (i = 0; i < bpp; i++) {\n            /* If the leading edge of the kernel is still on the image,\n             * add the value there to the accumulator. */\n            if (lead < len)\n                ac[i] += src[bpp * lead + i];\n\n            /* If the trailing edge of the kernel is on the image,\n             * subtract the value there from the accumulator. */\n            if (trail >= 0)\n                ac[i] -= src[bpp * trail + i];\n\n            /* Take the averaged value in the accumulator and store\n             * that value in the output. The number of pixels currently\n             * stored in the accumulator can be less than the nominal\n             * width of the kernel because the kernel can go \"over the edge\"\n             * of the image. */\n            if (output >= 0)\n                dest[bpp * output + i] = (ac[i] + (coverage >> 1)) / coverage;\n        }\n#endif\n\n        /* If the leading edge of the kernel is still on the image... */\n        if (lead < len) {\n            if (trail >= 0) {\n                /* If the trailing edge of the kernel is on the image. (Since\n                 * the output is in between the lead and trail, it must be on\n                 * the image. */\n                for (i = 0; i < bpp; i++) {\n                    ac[i] += src[bpp * lead + i];\n                    ac[i] -= src[bpp * trail + i];\n                    dest[bpp * output + i] = (ac[i] + (coverage >> 1)) / coverage;\n                }\n            } else if (output >= 0) {\n                /* If the output is on the image, but the trailing edge isn't yet\n                 * on the image. */\n\n                for (i = 0; i < bpp; i++) {\n                    ac[i] += src[bpp * lead + i];\n                    dest[bpp * output + i] = (ac[i] + (coverage >> 1)) / coverage;\n                }\n            } else {\n                /* If leading edge is on the image, but the output and trailing\n                 * edge aren't yet on the image. */\n                for (i = 0; i < bpp; i++)\n                    ac[i] += src[bpp * lead + i];\n            }\n        } else if (trail >= 0) {\n            /* If the leading edge has gone off the image, but the output and\n             * trailing edge are on the image. (The big loop exits when the\n             * output goes off the image. */\n            for (i = 0; i < bpp; i++) {\n                ac[i] -= src[bpp * trail + i];\n                dest[bpp * output + i] = (ac[i] + (coverage >> 1)) / coverage;\n            }\n        } else if (output >= 0) {\n            /* Leading has gone off the image and trailing isn't yet in it\n             * (small image) */\n            for (i = 0; i < bpp; i++)\n                dest[bpp * output + i] = (ac[i] + (coverage >> 1)) / coverage;\n        }\n\n        lead++;\n        output++;\n        trail++;\n    }\n\n    g_free (ac);\n}", "target": 2, "idx": 11828}
{"commit_id": "ce5274c1385d55892a692998923802023526b765", "project": "ffmpeg", "func": "static int config_input(AVFilterLink *inlink)\n{\n    int ret;\n    AVFilterContext *ctx = inlink->dst;\n    FieldMatchContext *fm = ctx->priv;\n    const AVPixFmtDescriptor *pix_desc = av_pix_fmt_desc_get(inlink->format);\n    const int w = inlink->w;\n    const int h = inlink->h;\n\n    fm->scthresh = (int64_t)((w * h * 255.0 * fm->scthresh_flt) / 100.0);\n\n    if ((ret = av_image_alloc(fm->map_data,   fm->map_linesize,   w, h, inlink->format, 32)) < 0 ||\n        (ret = av_image_alloc(fm->cmask_data, fm->cmask_linesize, w, h, inlink->format, 32)) < 0)\n        return ret;\n\n    fm->hsub = pix_desc->log2_chroma_w;\n    fm->vsub = pix_desc->log2_chroma_h;\n\n    fm->tpitchy  = FFALIGN(w,      16);\n    fm->tpitchuv = FFALIGN(w >> 1, 16);\n\n    fm->tbuffer = av_calloc((h/2 + 4) * fm->tpitchy, sizeof(*fm->tbuffer));\n    fm->c_array = av_malloc((((w + fm->blockx/2)/fm->blockx)+1) *\n                            (((h + fm->blocky/2)/fm->blocky)+1) *\n                            4 * sizeof(*fm->c_array));\n    if (!fm->tbuffer || !fm->c_array)\n        return AVERROR(ENOMEM);\n\n    return 0;\n}", "target": 1, "idx": 11829}
{"commit_id": "2d782cdaa2112c10b8dd5e7a93c134b2ada9c1a6", "project": "radareorg/radare2", "func": "RList *r_bin_ne_get_relocs(r_bin_ne_obj_t *bin) {\n\tRList *segments = bin->segments;\n\tif (!segments) {\n\t\treturn NULL;\n\t}\n\tRList *entries = bin->entries;\n\tif (!entries) {\n\t\treturn NULL;\n\t}\n\tRList *symbols = bin->symbols;\n\tif (!symbols) {\n\t\treturn NULL;\n\t}\n\n\tut16 *modref = calloc (bin->ne_header->ModRefs, sizeof (ut16));\n\tif (!modref) {\n\t\treturn NULL;\n\t}\n\tr_buf_read_at (bin->buf, (ut64)bin->ne_header->ModRefTable + bin->header_offset, (ut8 *)modref, bin->ne_header->ModRefs * sizeof (ut16));\n\n\tRList *relocs = r_list_newf (free);\n\tif (!relocs) {\n\t\tfree (modref);\n\t\treturn NULL;\n\t}\n\n\tRListIter *it;\n\tRBinSection *seg;\n\tint index = -1;\n\tr_list_foreach (segments, it, seg) {\n\t\tindex++;\n\t\tif (!(bin->segment_entries[index].flags & RELOCINFO)) {\n\t\t\tcontinue;\n\t\t}\n\t\tut32 off, start = off = seg->paddr + seg->size;\n\t\tut16 length = r_buf_read_le16_at (bin->buf, off);\n\t\tif (!length) {\n\t\t\tcontinue;\n\t\t}\n\t\toff += 2;\n\t\tsize_t buf_size = r_buf_size (bin->buf);\n\t\twhile (off < start + length * sizeof (NE_image_reloc_item) && off < buf_size) {\n\t\t\tRBinReloc *reloc = R_NEW0 (RBinReloc);\n\t\t\tif (!reloc) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tNE_image_reloc_item rel;\n\t\t\tr_buf_read_at (bin->buf, off, (ut8 *)&rel, sizeof (rel));\n\t\t\treloc->paddr = seg->paddr + rel.offset;\n\t\t\tswitch (rel.type) {\n\t\t\tcase LOBYTE:\n\t\t\t\treloc->type = R_BIN_RELOC_8;\n\t\t\t\tbreak;\n\t\t\tcase SEL_16:\n\t\t\tcase OFF_16:\n\t\t\t\treloc->type = R_BIN_RELOC_16;\n\t\t\t\tbreak;\n\t\t\tcase POI_32:\n\t\t\tcase OFF_32:\n\t\t\t\treloc->type = R_BIN_RELOC_32;\n\t\t\t\tbreak;\n\t\t\tcase POI_48:\n\t\t\t\treloc->type = R_BIN_RELOC_64;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tut32 offset;\n\t\t\tif (rel.flags & (IMPORTED_ORD | IMPORTED_NAME)) {\n\t\t\t\tRBinImport *imp = R_NEW0 (RBinImport);\n\t\t\t\tif (!imp) {\n\t\t\t\t\tfree (reloc);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchar *name;\n\t\t\t\tif (rel.index < 1 || rel.index > bin->ne_header->ModRefs) {\n\t\t\t\t\tname = r_str_newf (\"UnknownModule%d_%x\", rel.index, off); // ????\n\t\t\t\t} else {\n\t\t\t\t\tint index = rel.index;\n\t\t\t\t\toffset = modref[index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;\n\t\t\t\t\tname = __read_nonnull_str_at (bin->buf, offset);\n\t\t\t\t}\n\t\t\t\tif (rel.flags & IMPORTED_ORD) {\n\t\t\t\t\timp->ordinal = rel.func_ord;\n\t\t\t\t\timp->name = r_str_newf (\"%s.%s\", name, __func_name_from_ord(name, rel.func_ord));\n\t\t\t\t} else {\n\t\t\t\t\toffset = bin->header_offset + bin->ne_header->ImportNameTable + rel.name_off;\n\t\t\t\t\tchar *func = __read_nonnull_str_at (bin->buf, offset);\n\t\t\t\t\timp->name = r_str_newf (\"%s.%s\", name, func);\n\t\t\t\t\tfree (func);\n\t\t\t\t}\n\t\t\t\tfree (name);\n\t\t\t\treloc->import = imp;\n\t\t\t} else if (rel.flags & OSFIXUP) {\n\t\t\t\t// TODO\n\t\t\t} else {\n\t\t\t\tif (strstr (seg->name, \"FIXED\")) {\n\t\t\t\t\tRBinSection *s = r_list_get_n (segments, rel.segnum - 1);\n\t\t\t\t\tif (s) {\n\t\t\t\t\t\toffset = s->paddr + rel.segoff;\n\t\t\t\t\t} else {\n\t\t\t\t\t\toffset = -1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tRBinAddr *entry = r_list_get_n (entries, rel.entry_ordinal - 1);\n\t\t\t\t\tif (entry) {\n\t\t\t\t\t\toffset = entry->paddr;\n\t\t\t\t\t} else {\n\t\t\t\t\t\toffset = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treloc->addend = offset;\n\t\t\t\tRBinSymbol *sym = NULL;\n\t\t\t\tRListIter *sit;\n\t\t\t\tr_list_foreach (symbols, sit, sym) {\n\t\t\t\t\tif (sym->paddr == reloc->addend) {\n\t\t\t\t\t\treloc->symbol = sym;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rel.flags & ADDITIVE) {\n\t\t\t\treloc->additive = 1;\n\t\t\t\tr_list_append (relocs, reloc);\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\tr_list_append (relocs, reloc);\n\t\t\t\t\t\n\t\t\t\t\toffset = r_buf_read_le16_at (bin->buf, reloc->paddr);\n\t\t\t\t\tRBinReloc *tmp = reloc;\n\t\t\t\t\treloc = R_NEW0 (RBinReloc);\n\t\t\t\t\tif (!reloc) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t*reloc = *tmp;\n\t\t\t\t\treloc->paddr = seg->paddr + offset;\n\t\t\t\t} while (offset != 0xFFFF);\n\t\t\t\tfree (reloc);\n\t\t\t}\n\n\t\t\toff += sizeof (NE_image_reloc_item);\n\t\t}\n\t}\n\tfree (modref);\n\treturn relocs;\n}", "target": 2, "idx": 11830}
{"commit_id": "a5efec8187de02d1f0a412140b0bf030a6747d3f", "project": "gpac", "func": "char *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicode_type)\n{\n\tu32 i, j, len;\n\tchar *sOK;\n\tchar szLineConv[2048];\n\tunsigned short *sptr;\n\n\tmemset(szLine, 0, sizeof(char)*lineSize);\n\tsOK = gf_fgets(szLine, lineSize, txt_in);\n\tif (!sOK) return NULL;\n\tif (unicode_type<=1) {\n\t\tj=0;\n\t\tlen = (u32) strlen(szLine);\n\t\tfor (i=0; i<len; i++) {\n\t\t\tif (!unicode_type && (szLine[i] & 0x80)) {\n\t\t\t\t/*non UTF8 (likely some win-CP)*/\n\t\t\t\tif ((szLine[i+1] & 0xc0) != 0x80) {\n\t\t\t\t\tszLineConv[j] = 0xc0 | ( (szLine[i] >> 6) & 0x3 );\n\t\t\t\t\tj++;\n\t\t\t\t\tszLine[i] &= 0xbf;\n\t\t\t\t}\n\t\t\t\t/*UTF8 2 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xe0) == 0xc0) {\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t/*UTF8 3 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xf0) == 0xe0) {\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t/*UTF8 4 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xf8) == 0xf0) {\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t} else {\n\t\t\t\t\ti+=1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tszLineConv[j] = szLine[i];\n\t\t\tj++;\n\n\t\t\tif (j >= GF_ARRAY_LENGTH(szLineConv) - 1) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[TXTIn] Line too long to convert to utf8 (len: %d)\\n\", len));\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t\tszLineConv[j] = 0;\n\t\tstrcpy(szLine, szLineConv);\n\t\treturn sOK;\n\t}\n\n#ifdef GPAC_BIG_ENDIAN\n\tif (unicode_type==3)\n#else\n\tif (unicode_type==2)\n#endif\n\t{\n\t\ti=0;\n\t\twhile (1) {\n\t\t\tchar c;\n\t\t\tif (!szLine[i] && !szLine[i+1]) break;\n\t\t\tc = szLine[i+1];\n\t\t\tszLine[i+1] = szLine[i];\n\t\t\tszLine[i] = c;\n\t\t\ti+=2;\n\t\t}\n\t}\n\tsptr = (u16 *)szLine;\n\ti = gf_utf8_wcstombs(szLineConv, 2048, (const unsigned short **) &sptr);\n\tif (i == GF_UTF8_FAIL) i = 0;\n\tszLineConv[i] = 0;\n\tstrcpy(szLine, szLineConv);\n\t/*this is ugly indeed: since input is UTF16-LE, there are many chances the gf_fgets never reads the \\0 after a \\n*/\n\tif (unicode_type==3) gf_fgetc(txt_in);\n\treturn sOK;\n}", "target": 2, "idx": 11831}
{"commit_id": "f68a9555b548306c5b1ee45199ccdc4a16a6101b", "project": "dbry/WavPack", "func": "int ParseCaffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)\n{\n    uint32_t chan_chunk = 0, desc_chunk = 0, channel_layout = 0, bcount;\n    unsigned char *channel_identities = NULL;\n    unsigned char *channel_reorder = NULL;\n    int64_t total_samples = 0, infilesize;\n    CAFFileHeader caf_file_header;\n    CAFChunkHeader caf_chunk_header;\n    CAFAudioFormat caf_audio_format;\n    int i;\n\n    infilesize = DoGetFileSize (infile);\n    memcpy (&caf_file_header, fourcc, 4);\n\n    if ((!DoReadFile (infile, ((char *) &caf_file_header) + 4, sizeof (CAFFileHeader) - 4, &bcount) ||\n        bcount != sizeof (CAFFileHeader) - 4)) {\n            error_line (\"%s is not a valid .CAF file!\", infilename);\n            return WAVPACK_SOFT_ERROR;\n    }\n    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n        !WavpackAddWrapper (wpc, &caf_file_header, sizeof (CAFFileHeader))) {\n            error_line (\"%s\", WavpackGetErrorMessage (wpc));\n            return WAVPACK_SOFT_ERROR;\n    }\n\n    WavpackBigEndianToNative (&caf_file_header, CAFFileHeaderFormat);\n\n    if (caf_file_header.mFileVersion != 1) {\n        error_line (\"%s: can't handle version %d .CAF files!\", infilename, caf_file_header.mFileVersion);\n        return WAVPACK_SOFT_ERROR;\n    }\n\n    // loop through all elements of the RIFF wav header\n    // (until the data chuck) and copy them to the output file\n\n    while (1) {\n        if (!DoReadFile (infile, &caf_chunk_header, sizeof (CAFChunkHeader), &bcount) ||\n            bcount != sizeof (CAFChunkHeader)) {\n                error_line (\"%s is not a valid .CAF file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n        }\n        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n            !WavpackAddWrapper (wpc, &caf_chunk_header, sizeof (CAFChunkHeader))) {\n                error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                return WAVPACK_SOFT_ERROR;\n        }\n\n        WavpackBigEndianToNative (&caf_chunk_header, CAFChunkHeaderFormat);\n\n        // if it's the format chunk, we want to get some info out of there and\n        // make sure it's a .caf file we can handle\n\n        if (!strncmp (caf_chunk_header.mChunkType, \"desc\", 4)) {\n            int supported = TRUE;\n\n            if (caf_chunk_header.mChunkSize != sizeof (CAFAudioFormat) ||\n                !DoReadFile (infile, &caf_audio_format, (uint32_t) caf_chunk_header.mChunkSize, &bcount) ||\n                bcount != caf_chunk_header.mChunkSize) {\n                    error_line (\"%s is not a valid .CAF file!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, &caf_audio_format, (uint32_t) caf_chunk_header.mChunkSize)) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            WavpackBigEndianToNative (&caf_audio_format, CAFAudioFormatFormat);\n            desc_chunk = 1;\n\n            if (debug_logging_mode) {\n                char formatstr [5];\n\n                memcpy (formatstr, caf_audio_format.mFormatID, 4);\n                formatstr [4] = 0;\n                error_line (\"format = %s, flags = %x, sampling rate = %g\",\n                    formatstr, caf_audio_format.mFormatFlags, caf_audio_format.mSampleRate);\n                error_line (\"packet = %d bytes and %d frames\",\n                    caf_audio_format.mBytesPerPacket, caf_audio_format.mFramesPerPacket);\n                error_line (\"channels per frame = %d, bits per channel = %d\",\n                    caf_audio_format.mChannelsPerFrame, caf_audio_format.mBitsPerChannel);\n            }\n\n            if (strncmp (caf_audio_format.mFormatID, \"lpcm\", 4) || (caf_audio_format.mFormatFlags & ~3))\n                supported = FALSE;\n            else if (caf_audio_format.mSampleRate < 1.0 || caf_audio_format.mSampleRate > 16777215.0 ||\n                caf_audio_format.mSampleRate != floor (caf_audio_format.mSampleRate))\n                    supported = FALSE;\n            else if (!caf_audio_format.mChannelsPerFrame || caf_audio_format.mChannelsPerFrame > 256)\n                supported = FALSE;\n            else if (caf_audio_format.mBitsPerChannel < 1 || caf_audio_format.mBitsPerChannel > 32 ||\n                ((caf_audio_format.mFormatFlags & CAF_FORMAT_FLOAT) && caf_audio_format.mBitsPerChannel != 32))\n                    supported = FALSE;\n            else if (caf_audio_format.mFramesPerPacket != 1 ||\n                caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame < (caf_audio_format.mBitsPerChannel + 7) / 8 ||\n                caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame > 4 ||\n                caf_audio_format.mBytesPerPacket % caf_audio_format.mChannelsPerFrame)\n                    supported = FALSE;\n\n            if (!supported) {\n                error_line (\"%s is an unsupported .CAF format!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            config->bytes_per_sample = caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame;\n            config->float_norm_exp = (caf_audio_format.mFormatFlags & CAF_FORMAT_FLOAT) ? 127 : 0;\n            config->bits_per_sample = caf_audio_format.mBitsPerChannel;\n            config->num_channels = caf_audio_format.mChannelsPerFrame;\n            config->sample_rate = (int) caf_audio_format.mSampleRate;\n\n            if (!(caf_audio_format.mFormatFlags & CAF_FORMAT_LITTLE_ENDIAN) && config->bytes_per_sample > 1)\n                config->qmode |= QMODE_BIG_ENDIAN;\n\n            if (config->bytes_per_sample == 1)\n                config->qmode |= QMODE_SIGNED_BYTES;\n\n            if (debug_logging_mode) {\n                if (config->float_norm_exp == 127)\n                    error_line (\"data format: 32-bit %s-endian floating point\", (config->qmode & QMODE_BIG_ENDIAN) ? \"big\" : \"little\");\n                else\n                    error_line (\"data format: %d-bit %s-endian integers stored in %d byte(s)\",\n                        config->bits_per_sample, (config->qmode & QMODE_BIG_ENDIAN) ? \"big\" : \"little\", config->bytes_per_sample);\n            }\n        }\n        else if (!strncmp (caf_chunk_header.mChunkType, \"chan\", 4)) {\n            CAFChannelLayout *caf_channel_layout;\n\n            if (caf_chunk_header.mChunkSize < 0 || caf_chunk_header.mChunkSize > 1024 ||\n                caf_chunk_header.mChunkSize < sizeof (CAFChannelLayout)) {\n                    error_line (\"this .CAF file has an invalid 'chan' chunk!\");\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            if (debug_logging_mode)\n                error_line (\"'chan' chunk is %d bytes\", (int) caf_chunk_header.mChunkSize);\n\n            caf_channel_layout = malloc ((size_t) caf_chunk_header.mChunkSize);\n\n            if (!DoReadFile (infile, caf_channel_layout, (uint32_t) caf_chunk_header.mChunkSize, &bcount) ||\n                bcount != caf_chunk_header.mChunkSize) {\n                    error_line (\"%s is not a valid .CAF file!\", infilename);\n                    free (caf_channel_layout);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, caf_channel_layout, (uint32_t) caf_chunk_header.mChunkSize)) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    free (caf_channel_layout);\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            WavpackBigEndianToNative (caf_channel_layout, CAFChannelLayoutFormat);\n            chan_chunk = 1;\n\n            if (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED)) {\n                error_line (\"this CAF file already has channel order information!\");\n                free (caf_channel_layout);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            switch (caf_channel_layout->mChannelLayoutTag) {\n                case kCAFChannelLayoutTag_UseChannelDescriptions:\n                    {\n                        CAFChannelDescription *descriptions = (CAFChannelDescription *) (caf_channel_layout + 1);\n                        int num_descriptions = caf_channel_layout->mNumberChannelDescriptions;\n                        int label, cindex = 0, idents = 0;\n\n                        if (caf_chunk_header.mChunkSize != sizeof (CAFChannelLayout) + sizeof (CAFChannelDescription) * num_descriptions ||\n                            num_descriptions != config->num_channels) {\n                                error_line (\"channel descriptions in 'chan' chunk are the wrong size!\");\n                                free (caf_channel_layout);\n                                return WAVPACK_SOFT_ERROR;\n                        }\n\n                        if (num_descriptions >= 256) {\n                            error_line (\"%d channel descriptions is more than we can handle...ignoring!\");\n                            break;\n                        }\n\n                        // we allocate (and initialize to invalid values) a channel reorder array\n                        // (even though we might not end up doing any reordering) and a string for\n                        // any non-Microsoft channels we encounter\n\n                        channel_reorder = malloc (num_descriptions);\n                        memset (channel_reorder, -1, num_descriptions);\n                        channel_identities = malloc (num_descriptions+1);\n\n                        // convert the descriptions array to our native endian so it's easy to access\n\n                        for (i = 0; i < num_descriptions; ++i) {\n                            WavpackBigEndianToNative (descriptions + i, CAFChannelDescriptionFormat);\n\n                            if (debug_logging_mode)\n                                error_line (\"chan %d --> %d\", i + 1, descriptions [i].mChannelLabel);\n                        }\n\n                        // first, we go though and find any MS channels present, and move those to the beginning\n\n                        for (label = 1; label <= 18; ++label)\n                            for (i = 0; i < num_descriptions; ++i)\n                                if (descriptions [i].mChannelLabel == label) {\n                                    config->channel_mask |= 1 << (label - 1);\n                                    channel_reorder [i] = cindex++;\n                                    break;\n                                }\n\n                        // next, we go though the channels again assigning any we haven't done\n\n                        for (i = 0; i < num_descriptions; ++i)\n                            if (channel_reorder [i] == (unsigned char) -1) {\n                                uint32_t clabel = descriptions [i].mChannelLabel;\n\n                                if (clabel == 0 || clabel == 0xffffffff || clabel == 100)\n                                    channel_identities [idents++] = 0xff;\n                                else if ((clabel >= 33 && clabel <= 44) || (clabel >= 200 && clabel <= 207) || (clabel >= 301 && clabel <= 305))\n                                    channel_identities [idents++] = clabel >= 301 ? clabel - 80 : clabel;\n                                else {\n                                    error_line (\"warning: unknown channel descriptions label: %d\", clabel);\n                                    channel_identities [idents++] = 0xff;\n                                }\n\n                                channel_reorder [i] = cindex++;\n                            }\n\n                        // then, go through the reordering array and see if we really have to reorder\n\n                        for (i = 0; i < num_descriptions; ++i)\n                            if (channel_reorder [i] != i)\n                                break;\n\n                        if (i == num_descriptions) {\n                            free (channel_reorder);                 // no reordering required, so don't\n                            channel_reorder = NULL;\n                        }\n                        else {\n                            config->qmode |= QMODE_REORDERED_CHANS; // reordering required, put channel count into layout\n                            channel_layout = num_descriptions;\n                        }\n\n                        if (!idents) {                              // if no non-MS channels, free the identities string\n                            free (channel_identities);\n                            channel_identities = NULL;\n                        }\n                        else\n                            channel_identities [idents] = 0;        // otherwise NULL terminate it\n\n                        if (debug_logging_mode) {\n                            error_line (\"layout_tag = 0x%08x, so generated bitmap of 0x%08x from %d descriptions, %d non-MS\",\n                                caf_channel_layout->mChannelLayoutTag, config->channel_mask,\n                                caf_channel_layout->mNumberChannelDescriptions, idents);\n\n                            // if debugging, display the reordering as a string (but only little ones)\n\n                            if (channel_reorder && num_descriptions <= 8) {\n                                char reorder_string [] = \"12345678\";\n\n                                for (i = 0; i < num_descriptions; ++i)\n                                    reorder_string [i] = channel_reorder [i] + '1';\n\n                                reorder_string [i] = 0;\n                                error_line (\"reordering string = \\\"%s\\\"\\n\", reorder_string);\n                            }\n                        }\n                    }\n\n                    break;\n\n                case kCAFChannelLayoutTag_UseChannelBitmap:\n                    config->channel_mask = caf_channel_layout->mChannelBitmap;\n\n                    if (debug_logging_mode)\n                        error_line (\"layout_tag = 0x%08x, so using supplied bitmap of 0x%08x\",\n                            caf_channel_layout->mChannelLayoutTag, caf_channel_layout->mChannelBitmap);\n\n                    break;\n\n                default:\n                    for (i = 0; i < NUM_LAYOUTS; ++i)\n                        if (caf_channel_layout->mChannelLayoutTag == layouts [i].mChannelLayoutTag) {\n                            config->channel_mask = layouts [i].mChannelBitmap;\n                            channel_layout = layouts [i].mChannelLayoutTag;\n\n                            if (layouts [i].mChannelReorder) {\n                                channel_reorder = (unsigned char *) strdup (layouts [i].mChannelReorder);\n                                config->qmode |= QMODE_REORDERED_CHANS;\n                            }\n\n                            if (layouts [i].mChannelIdentities)\n                                channel_identities = (unsigned char *) strdup (layouts [i].mChannelIdentities);\n\n                            if (debug_logging_mode)\n                                error_line (\"layout_tag 0x%08x found in table, bitmap = 0x%08x, reorder = %s, identities = %s\",\n                                    channel_layout, config->channel_mask, channel_reorder ? \"yes\" : \"no\", channel_identities ? \"yes\" : \"no\");\n\n                            break;\n                        }\n\n                    if (i == NUM_LAYOUTS && debug_logging_mode)\n                        error_line (\"layout_tag 0x%08x not found in table...all channels unassigned\",\n                            caf_channel_layout->mChannelLayoutTag);\n\n                    break;\n            }\n\n            free (caf_channel_layout);\n        }\n        else if (!strncmp (caf_chunk_header.mChunkType, \"data\", 4)) {     // on the data chunk, get size and exit loop\n            uint32_t mEditCount;\n\n            if (!desc_chunk || !DoReadFile (infile, &mEditCount, sizeof (mEditCount), &bcount) ||\n                bcount != sizeof (mEditCount)) {\n                    error_line (\"%s is not a valid .CAF file!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, &mEditCount, sizeof (mEditCount))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            if ((config->qmode & QMODE_IGNORE_LENGTH) || caf_chunk_header.mChunkSize == -1) {\n                config->qmode |= QMODE_IGNORE_LENGTH;\n\n                if (infilesize && DoGetFilePosition (infile) != -1)\n                    total_samples = (infilesize - DoGetFilePosition (infile)) / caf_audio_format.mBytesPerPacket;\n                else\n                    total_samples = -1;\n            }\n            else {\n                if (infilesize && infilesize - caf_chunk_header.mChunkSize > 16777216) {\n                    error_line (\".CAF file %s has over 16 MB of extra CAFF data, probably is corrupt!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                if ((caf_chunk_header.mChunkSize - 4) % caf_audio_format.mBytesPerPacket) {\n                    error_line (\".CAF file %s has an invalid data chunk size, probably is corrupt!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                total_samples = (caf_chunk_header.mChunkSize - 4) / caf_audio_format.mBytesPerPacket;\n\n                if (!total_samples) {\n                    error_line (\"this .CAF file has no audio samples, probably is corrupt!\");\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                if (total_samples > MAX_WAVPACK_SAMPLES) {\n                    error_line (\"%s has too many samples for WavPack!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n                }\n            }\n\n            break;\n        }\n        else {          // just copy unknown chunks to output file\n\n            uint32_t bytes_to_copy = (uint32_t) caf_chunk_header.mChunkSize;\n            char *buff;\n\n            if (caf_chunk_header.mChunkSize < 0 || caf_chunk_header.mChunkSize > 1048576) {\n                error_line (\"%s is not a valid .CAF file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            buff = malloc (bytes_to_copy);\n\n            if (debug_logging_mode)\n                error_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\",\n                    caf_chunk_header.mChunkType [0], caf_chunk_header.mChunkType [1], caf_chunk_header.mChunkType [2],\n                    caf_chunk_header.mChunkType [3], caf_chunk_header.mChunkSize);\n\n            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||\n                bcount != bytes_to_copy ||\n                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    free (buff);\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            free (buff);\n        }\n    }\n\n    if (!chan_chunk && !config->channel_mask && config->num_channels <= 2 && !(config->qmode & QMODE_CHANS_UNASSIGNED))\n        config->channel_mask = 0x5 - config->num_channels;\n\n    if (!WavpackSetConfiguration64 (wpc, config, total_samples, channel_identities)) {\n        error_line (\"%s\", WavpackGetErrorMessage (wpc));\n        return WAVPACK_SOFT_ERROR;\n    }\n\n    if (channel_identities)\n        free (channel_identities);\n\n    if (channel_layout || channel_reorder) {\n        if (!WavpackSetChannelLayout (wpc, channel_layout, channel_reorder)) {\n            error_line (\"problem with setting channel layout (should not happen)\");\n            return WAVPACK_SOFT_ERROR;\n        }\n\n        if (channel_reorder)\n            free (channel_reorder);\n    }\n\n    return WAVPACK_NO_ERROR;\n}", "target": 1, "idx": 11832}
{"commit_id": "511885d7061eda3eb1faf3f57dcc936ff75863f1", "project": "kernel/git/tip/tip", "func": "bool timerqueue_del(struct timerqueue_head *head, struct timerqueue_node *node)\n{\n\tWARN_ON_ONCE(RB_EMPTY_NODE(&node->node));\n\n\trb_erase_cached(&node->node, &head->rb_root);\n\tRB_CLEAR_NODE(&node->node);\n\n\treturn !RB_EMPTY_ROOT(&head->rb_root.rb_root);\n}", "target": 1, "idx": 11833}
{"commit_id": "a02ea577174ab8ed18f847cf1693f213e0b9c473", "project": "git", "func": "static struct child_process *git_connect_git(int fd[2], char *hostandport,\n\t\t\t\t\t     const char *path, const char *prog,\n\t\t\t\t\t     enum protocol_version version,\n\t\t\t\t\t     int flags)\n{\n\tstruct child_process *conn;\n\tstruct strbuf request = STRBUF_INIT;\n\t/*\n\t * Set up virtual host information based on where we will\n\t * connect, unless the user has overridden us in\n\t * the environment.\n\t */\n\tchar *target_host = getenv(\"GIT_OVERRIDE_VIRTUAL_HOST\");\n\tif (target_host)\n\t\ttarget_host = xstrdup(target_host);\n\telse\n\t\ttarget_host = xstrdup(hostandport);\n\n\ttransport_check_allowed(\"git\");\n\tif (strchr(target_host, '\\n') || strchr(path, '\\n'))\n\t\tdie(_(\"newline is forbidden in git:// hosts and repo paths\"));\n\n\t/*\n\t * These underlying connection commands die() if they\n\t * cannot connect.\n\t */\n\tif (git_use_proxy(hostandport))\n\t\tconn = git_proxy_connect(fd, hostandport);\n\telse\n\t\tconn = git_tcp_connect(fd, hostandport, flags);\n\t/*\n\t * Separate original protocol components prog and path\n\t * from extended host header with a NUL byte.\n\t *\n\t * Note: Do not add any other headers here!  Doing so\n\t * will cause older git-daemon servers to crash.\n\t */\n\tstrbuf_addf(&request,\n\t\t    \"%s %s%chost=%s%c\",\n\t\t    prog, path, 0,\n\t\t    target_host, 0);\n\n\t/* If using a new version put that stuff here after a second null byte */\n\tif (version > 0) {\n\t\tstrbuf_addch(&request, '\\0');\n\t\tstrbuf_addf(&request, \"version=%d%c\",\n\t\t\t    version, '\\0');\n\t}\n\n\tpacket_write(fd[1], request.buf, request.len);\n\n\tfree(target_host);\n\tstrbuf_release(&request);\n\treturn conn;\n}", "target": 2, "idx": 11834}
{"commit_id": "505eab7782b429017eb434b2b95120855f2b0e3c", "project": "ArtifexSoftware/ghostpdl", "func": "int\ngp_validate_path_len(const gs_memory_t *mem,\n                     const char        *path,\n                     const uint         len,\n                     const char        *mode)\n{\n    char *buffer, *bufferfull;\n    uint rlen;\n    int code = 0;\n    const char *cdirstr = gp_file_name_current();\n    int cdirstrl = strlen(cdirstr);\n    const char *dirsepstr = gp_file_name_separator();\n    int dirsepstrl = strlen(dirsepstr);\n    int prefix_len = cdirstrl + dirsepstrl;\n\n    /* mem->gs_lib_ctx can be NULL when we're called from mkromfs */\n    if (mem->gs_lib_ctx == NULL ||\n        mem->gs_lib_ctx->core->path_control_active == 0)\n        return 0;\n\n    /* For current directory accesses, we need handle both a \"bare\" name,\n     * and one with a cwd prefix (in Unix terms, both \"myfile.ps\" and\n     * \"./myfile.ps\".\n     *\n     * So we check up front if it's absolute, then just use that.\n     * If it includes cwd prefix, we try that, then remove the prefix\n     * and try again.\n     * If it doesn't include the cwd prefix, we try it, then add the\n     * prefix and try again.\n     * To facilitate that, we allocate a large enough buffer to take\n     * the path *and* the prefix up front.\n     */\n    if (gp_file_name_is_absolute(path, len)) {\n       /* Absolute path, we don't need anything extra */\n       prefix_len = cdirstrl = dirsepstrl = 0;\n    }\n    else if (len > prefix_len && !memcmp(path, cdirstr, cdirstrl)\n             && !memcmp(path + cdirstrl, dirsepstr, dirsepstrl)) {\n          prefix_len = 0;\n    }\n\n    /* \"%pipe%\" do not follow the normal rules for path definitions, so we\n       don't \"reduce\" them to avoid unexpected results\n     */\n    if (len > 5 && memcmp(path, \"%pipe\", 5) != 0) {\n        bufferfull = buffer = (char *)gs_alloc_bytes(mem->thread_safe_memory, len + 1, \"gp_validate_path\");\n        if (buffer == NULL)\n            return gs_error_VMerror;\n        memcpy(buffer, path, len);\n        buffer[len] = 0;\n        rlen = len;\n    }\n    else {\n        rlen = len+1;\n        bufferfull = (char *)gs_alloc_bytes(mem->thread_safe_memory, rlen + prefix_len, \"gp_validate_path\");\n        if (bufferfull == NULL)\n            return gs_error_VMerror;\n\n        buffer = bufferfull + prefix_len;\n        if (gp_file_name_reduce(path, (uint)len, buffer, &rlen) != gp_combine_success)\n            return gs_error_invalidfileaccess;\n        buffer[rlen] = 0;\n    }\n    while (1) {\n        switch (mode[0])\n        {\n        case 'r': /* Read */\n            code = validate(mem, buffer, gs_permit_file_reading);\n            break;\n        case 'w': /* Write */\n            code = validate(mem, buffer, gs_permit_file_writing);\n            break;\n        case 'a': /* Append needs reading and writing */\n            code = (validate(mem, buffer, gs_permit_file_reading) |\n                    validate(mem, buffer, gs_permit_file_writing));\n            break;\n        case 'c': /* \"Control\" */\n            code =  validate(mem, buffer, gs_permit_file_control);\n            break;\n        case 'd': /* \"Delete\" (special case of control) */\n            code =  validate(mem, buffer, gs_permit_file_control);\n            break;\n        case 'f': /* \"Rename from\" */\n            code = (validate(mem, buffer, gs_permit_file_writing) |\n                    validate(mem, buffer, gs_permit_file_control));\n            break;\n        case 't': /* \"Rename to\" */\n            code = (validate(mem, buffer, gs_permit_file_writing) |\n                    validate(mem, buffer, gs_permit_file_control));\n            break;\n        default:\n            errprintf(mem, \"gp_validate_path: Unknown mode='%s'\\n\", mode);\n            code = gs_note_error(gs_error_invalidfileaccess);\n        }\n        if (code < 0 && prefix_len > 0 && buffer > bufferfull) {\n            buffer = bufferfull;\n            memcpy(buffer, cdirstr, cdirstrl);\n            memcpy(buffer + cdirstrl, dirsepstr, dirsepstrl);\n            continue;\n        }\n        else if (code < 0 && cdirstrl > 0 && prefix_len == 0 && buffer == bufferfull) {\n            buffer = bufferfull + cdirstrl + dirsepstrl;\n            continue;\n        }\n        break;\n    }\n    if (code > 0 && (mode[0] == 'd' || mode[0] == 'f') &&\n        (code & gs_path_control_flag_is_scratch_file) != 0) {\n        (void)gs_remove_control_path_flags(mem, gs_permit_file_reading, buffer,\n                                           gs_path_control_flag_is_scratch_file);\n        (void)gs_remove_control_path_flags(mem, gs_permit_file_writing, buffer,\n                                           gs_path_control_flag_is_scratch_file);\n        (void)gs_remove_control_path_flags(mem, gs_permit_file_control, buffer,\n                                           gs_path_control_flag_is_scratch_file);\n    }\n\n    gs_free_object(mem->thread_safe_memory, bufferfull, \"gp_validate_path\");\n#ifdef EACCES\n    if (code == gs_error_invalidfileaccess)\n        errno = EACCES;\n#endif\n\n    return code < 0 ? code : 0;\n}", "target": 2, "idx": 11835}
{"commit_id": "07ac18a32b4", "project": "GNOME/NetworkManager-vpnc", "func": "static void\nvalidate_one_property (const char *key, const char *value, gpointer user_data)\n{\n\tValidateInfo *info = (ValidateInfo *) user_data;\n\tValidProperty *prop = NULL;\n\tlong int tmp;\n\tint i;\n\n\tif (*(info->error))\n\t\treturn;\n\n\tinfo->have_items = TRUE;\n\n\t/* 'name' is the setting name; always allowed but unused */\n\tif (!strcmp (key, NM_SETTING_NAME))\n\t\treturn;\n\n\tfor (i = 0; info->table[i].name; i++) {\n\t\tprop = &info->table[i];\n\t\tif (g_strcmp0 (prop->name, key) == 0)\n\t\t\tbreak;\n\t}\n\n\t/* Did not find the property from valid_properties or the type did not match */\n\tif (!prop || !prop->name) {\n\t\tg_set_error (info->error,\n\t\t             NM_VPN_PLUGIN_ERROR,\n\t\t             NM_VPN_PLUGIN_ERROR_BAD_ARGUMENTS,\n\t\t             _(\"property \u201c%s\u201d invalid or not supported\"),\n\t\t             key);\n\t\treturn;\n\t}\n\n\t/* Validate the property */\n\tswitch (prop->type) {\n\tcase ITEM_TYPE_IGNORED:\n\t\tbreak; /* technically valid, but unused */\n\tcase ITEM_TYPE_STRING:\n\tcase ITEM_TYPE_SECRET:\n\t\tif (strchr (value, '\\n') || strchr (value, '\\r')) {\n\t\t\tg_set_error (info->error,\n\t\t\t             NM_VPN_PLUGIN_ERROR,\n\t\t\t             NM_VPN_PLUGIN_ERROR_BAD_ARGUMENTS,\n\t\t\t             _(\"property \u201c%s\u201d contains a newline character\"),\n\t\t\t             key);\n\t\t}\n\t\tbreak;\n\tcase ITEM_TYPE_PATH:\n\t\tif (   !value\n\t\t    || !strlen (value)\n\t\t    || !g_path_is_absolute (value)\n\t\t    || !g_file_test (value, G_FILE_TEST_EXISTS)) {\n\t\t\tg_set_error (info->error,\n\t\t\t             NM_VPN_PLUGIN_ERROR,\n\t\t\t             NM_VPN_PLUGIN_ERROR_BAD_ARGUMENTS,\n\t\t\t             _(\"property \u201c%s\u201d file path \u201c%s\u201d is not absolute or does not exist\"),\n\t\t\t             key, value);\n\t\t}\n\t\tbreak;\n\tcase ITEM_TYPE_INT:\n\t\terrno = 0;\n\t\ttmp = strtol (value, NULL, 10);\n\t\tif (errno == 0 && tmp >= prop->int_min && tmp <= prop->int_max)\n\t\t\tbreak; /* valid */\n\n\t\tg_set_error (info->error,\n\t\t             NM_VPN_PLUGIN_ERROR,\n\t\t             NM_VPN_PLUGIN_ERROR_BAD_ARGUMENTS,\n\t\t             _(\"invalid integer property \u201c%s\u201d or out of range [%d -> %d]\"),\n\t\t             key, prop->int_min, prop->int_max);\n\t\tbreak;\n\tcase ITEM_TYPE_BOOLEAN:\n\t\tif (!strcmp (value, \"yes\") || !strcmp (value, \"no\"))\n\t\t\tbreak; /* valid */\n\n\t\tg_set_error (info->error,\n\t\t             NM_VPN_PLUGIN_ERROR,\n\t\t             NM_VPN_PLUGIN_ERROR_BAD_ARGUMENTS,\n\t\t             _(\"invalid boolean property \u201c%s\u201d (not yes or no)\"),\n\t\t             key);\n\t\tbreak;\n\tdefault:\n\t\tg_set_error (info->error,\n\t\t             NM_VPN_PLUGIN_ERROR,\n\t\t             NM_VPN_PLUGIN_ERROR_BAD_ARGUMENTS,\n\t\t             _(\"unhandled property \u201c%s\u201d type %d\"),\n\t\t             key, prop->type);\n\t\tbreak;\n\t}\n}", "target": 2, "idx": 11836}
{"commit_id": "338a6b75994eb148d429b7abccfffaf7ae9f9b55", "project": "pdfium", "func": "static OPJ_BOOL opj_j2k_read_SQcd_SQcc(opj_j2k_t *p_j2k,\n                                                            OPJ_UINT32 p_comp_no,\n                                                            OPJ_BYTE* p_header_data,\n                                                            OPJ_UINT32 * p_header_size,\n                                                            opj_event_mgr_t * p_manager\n                                                            )\n{\n        /* loop*/\n        OPJ_UINT32 l_band_no;\n        opj_cp_t *l_cp = 00;\n        opj_tcp_t *l_tcp = 00;\n        opj_tccp_t *l_tccp = 00;\n        OPJ_BYTE * l_current_ptr = 00;\n        OPJ_UINT32 l_tmp, l_num_band;\n\n        /* preconditions*/\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_header_data != 00);\n\n        l_cp = &(p_j2k->m_cp);\n        /* come from tile part header or main header ?*/\n        l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH) ? /*FIXME J2K_DEC_STATE_TPH*/\n                                &l_cp->tcps[p_j2k->m_current_tile_number] :\n                                p_j2k->m_specific_param.m_decoder.m_default_tcp;\n\n        /* precondition again*/\n        if (p_comp_no >=  p_j2k->m_private_image->numcomps) {\n            return OPJ_FALSE;\n        }\n\n        l_tccp = &l_tcp->tccps[p_comp_no];\n        l_current_ptr = p_header_data;\n\n        if (*p_header_size < 1) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading SQcd or SQcc element\\n\");\n                return OPJ_FALSE;\n        }\n        *p_header_size -= 1;\n\n        opj_read_bytes(l_current_ptr, &l_tmp ,1);                       /* Sqcx */\n        ++l_current_ptr;\n\n        l_tccp->qntsty = l_tmp & 0x1f;\n        l_tccp->numgbits = l_tmp >> 5;\n        if (l_tccp->qntsty == J2K_CCP_QNTSTY_SIQNT) {\n        l_num_band = 1;\n        }\n        else {\n                l_num_band = (l_tccp->qntsty == J2K_CCP_QNTSTY_NOQNT) ?\n                        (*p_header_size) :\n                        (*p_header_size) / 2;\n\n                if( l_num_band > OPJ_J2K_MAXBANDS ) {\n                        opj_event_msg(p_manager, EVT_WARNING, \"While reading CCP_QNTSTY element inside QCD or QCC marker segment, \"\n                                \"number of subbands (%d) is greater to OPJ_J2K_MAXBANDS (%d). So we limit the number of elements stored to \"\n                                \"OPJ_J2K_MAXBANDS (%d) and skip the rest. \\n\", l_num_band, OPJ_J2K_MAXBANDS, OPJ_J2K_MAXBANDS);\n                        /*return OPJ_FALSE;*/\n                }\n        }\n\n#ifdef USE_JPWL\n        if (l_cp->correct) {\n\n                /* if JPWL is on, we check whether there are too many subbands */\n                if (/*(l_num_band < 0) ||*/ (l_num_band >= OPJ_J2K_MAXBANDS)) {\n                        opj_event_msg(p_manager, JPWL_ASSUME ? EVT_WARNING : EVT_ERROR,\n                                \"JPWL: bad number of subbands in Sqcx (%d)\\n\",\n                                l_num_band);\n                        if (!JPWL_ASSUME) {\n                                opj_event_msg(p_manager, EVT_ERROR, \"JPWL: giving up\\n\");\n                                return OPJ_FALSE;\n                        }\n                        /* we try to correct */\n                        l_num_band = 1;\n                        opj_event_msg(p_manager, EVT_WARNING, \"- trying to adjust them\\n\"\n                                \"- setting number of bands to %d => HYPOTHESIS!!!\\n\",\n                                l_num_band);\n                };\n\n        };\n#endif /* USE_JPWL */\n\n        if (l_tccp->qntsty == J2K_CCP_QNTSTY_NOQNT) {\n                for     (l_band_no = 0; l_band_no < l_num_band; l_band_no++) {\n                        opj_read_bytes(l_current_ptr, &l_tmp ,1);                       /* SPqcx_i */\n                        ++l_current_ptr;\n                        if (l_band_no < OPJ_J2K_MAXBANDS){\n                                l_tccp->stepsizes[l_band_no].expn = (OPJ_INT32)(l_tmp >> 3);\n                                l_tccp->stepsizes[l_band_no].mant = 0;\n                        }\n                }\n                *p_header_size = *p_header_size - l_num_band;\n        }\n        else {\n                for     (l_band_no = 0; l_band_no < l_num_band; l_band_no++) {\n                        opj_read_bytes(l_current_ptr, &l_tmp ,2);                       /* SPqcx_i */\n                        l_current_ptr+=2;\n                        if (l_band_no < OPJ_J2K_MAXBANDS){\n                                l_tccp->stepsizes[l_band_no].expn = (OPJ_INT32)(l_tmp >> 11);\n                                l_tccp->stepsizes[l_band_no].mant = l_tmp & 0x7ff;\n                        }\n                }\n                *p_header_size = *p_header_size - 2*l_num_band;\n        }\n\n        /* Add Antonin : if scalar_derived -> compute other stepsizes */\n        if (l_tccp->qntsty == J2K_CCP_QNTSTY_SIQNT) {\n                for (l_band_no = 1; l_band_no < OPJ_J2K_MAXBANDS; l_band_no++) {\n                        l_tccp->stepsizes[l_band_no].expn =\n                                ((OPJ_INT32)(l_tccp->stepsizes[0].expn) - (OPJ_INT32)((l_band_no - 1) / 3) > 0) ?\n                                        (OPJ_INT32)(l_tccp->stepsizes[0].expn) - (OPJ_INT32)((l_band_no - 1) / 3) : 0;\n                        l_tccp->stepsizes[l_band_no].mant = l_tccp->stepsizes[0].mant;\n                }\n        }\n\n        return OPJ_TRUE;\n}", "target": 3, "idx": 11837}
{"commit_id": "882925b295a80ec992063deffc2a3b0d803c3195", "project": "ruven/iipsrv", "func": "RawTile KakaduImage::getRegion( int seq, int ang, unsigned int res, int layers, int x, int y, unsigned int w, unsigned int h )\n{\n  // Scale up our output bit depth to the nearest factor of 8\n  unsigned int obpc = bpc;\n  if( bpc <= 16 && bpc > 8 ) obpc = 16;\n  else if( bpc <= 8 ) obpc = 8;\n\n#ifdef DEBUG\n  Timer timer;\n  timer.start();\n#endif\n\n  RawTile rawtile( 0, res, seq, ang, w, h, channels, obpc );\n\n  size_t np = (size_t) w * (size_t) h * (size_t) channels;\n  if( obpc == 16 ) rawtile.data = new unsigned short[np];\n  else if( obpc == 8 ) rawtile.data = new unsigned char[np];\n  else throw file_error( \"Kakadu :: Unsupported number of bits\" );\n\n  rawtile.dataLength = np*(obpc/8);\n  rawtile.filename = getImagePath();\n  rawtile.timestamp = timestamp;\n\n  process( res, layers, x, y, w, h, rawtile.data );\n\n#ifdef DEBUG\n  logfile << \"Kakadu :: getRegion() :: \" << timer.getTime() << \" microseconds\" << endl;\n#endif\n\n  return rawtile;\n\n}", "target": 2, "idx": 11838}
{"commit_id": "49c47cc21b5b7a3d8deb18fc57b0aa2ab1286962", "project": "torvalds/linux", "func": "static int do_tls_getsockopt_conf(struct sock *sk, char __user *optval,\n\t\t\t\t  int __user *optlen, int tx)\n{\n\tint rc = 0;\n\tstruct tls_context *ctx = tls_get_ctx(sk);\n\tstruct tls_crypto_info *crypto_info;\n\tstruct cipher_context *cctx;\n\tint len;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tif (!optval || (len < sizeof(*crypto_info))) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!ctx) {\n\t\trc = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t/* get user crypto info */\n\tif (tx) {\n\t\tcrypto_info = &ctx->crypto_send.info;\n\t\tcctx = &ctx->tx;\n\t} else {\n\t\tcrypto_info = &ctx->crypto_recv.info;\n\t\tcctx = &ctx->rx;\n\t}\n\n\tif (!TLS_CRYPTO_INFO_READY(crypto_info)) {\n\t\trc = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (len == sizeof(*crypto_info)) {\n\t\tif (copy_to_user(optval, crypto_info, sizeof(*crypto_info)))\n\t\t\trc = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tswitch (crypto_info->cipher_type) {\n\tcase TLS_CIPHER_AES_GCM_128: {\n\t\tstruct tls12_crypto_info_aes_gcm_128 *\n\t\t  crypto_info_aes_gcm_128 =\n\t\t  container_of(crypto_info,\n\t\t\t       struct tls12_crypto_info_aes_gcm_128,\n\t\t\t       info);\n\n\t\tif (len != sizeof(*crypto_info_aes_gcm_128)) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(crypto_info_aes_gcm_128->iv,\n\t\t       cctx->iv + TLS_CIPHER_AES_GCM_128_SALT_SIZE,\n\t\t       TLS_CIPHER_AES_GCM_128_IV_SIZE);\n\t\tmemcpy(crypto_info_aes_gcm_128->rec_seq, cctx->rec_seq,\n\t\t       TLS_CIPHER_AES_GCM_128_REC_SEQ_SIZE);\n\t\tif (copy_to_user(optval,\n\t\t\t\t crypto_info_aes_gcm_128,\n\t\t\t\t sizeof(*crypto_info_aes_gcm_128)))\n\t\t\trc = -EFAULT;\n\t\tbreak;\n\t}\n\tcase TLS_CIPHER_AES_GCM_256: {\n\t\tstruct tls12_crypto_info_aes_gcm_256 *\n\t\t  crypto_info_aes_gcm_256 =\n\t\t  container_of(crypto_info,\n\t\t\t       struct tls12_crypto_info_aes_gcm_256,\n\t\t\t       info);\n\n\t\tif (len != sizeof(*crypto_info_aes_gcm_256)) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(crypto_info_aes_gcm_256->iv,\n\t\t       cctx->iv + TLS_CIPHER_AES_GCM_256_SALT_SIZE,\n\t\t       TLS_CIPHER_AES_GCM_256_IV_SIZE);\n\t\tmemcpy(crypto_info_aes_gcm_256->rec_seq, cctx->rec_seq,\n\t\t       TLS_CIPHER_AES_GCM_256_REC_SEQ_SIZE);\n\t\tif (copy_to_user(optval,\n\t\t\t\t crypto_info_aes_gcm_256,\n\t\t\t\t sizeof(*crypto_info_aes_gcm_256)))\n\t\t\trc = -EFAULT;\n\t\tbreak;\n\t}\n\tcase TLS_CIPHER_AES_CCM_128: {\n\t\tstruct tls12_crypto_info_aes_ccm_128 *aes_ccm_128 =\n\t\t\tcontainer_of(crypto_info,\n\t\t\t\tstruct tls12_crypto_info_aes_ccm_128, info);\n\n\t\tif (len != sizeof(*aes_ccm_128)) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(aes_ccm_128->iv,\n\t\t       cctx->iv + TLS_CIPHER_AES_CCM_128_SALT_SIZE,\n\t\t       TLS_CIPHER_AES_CCM_128_IV_SIZE);\n\t\tmemcpy(aes_ccm_128->rec_seq, cctx->rec_seq,\n\t\t       TLS_CIPHER_AES_CCM_128_REC_SEQ_SIZE);\n\t\tif (copy_to_user(optval, aes_ccm_128, sizeof(*aes_ccm_128)))\n\t\t\trc = -EFAULT;\n\t\tbreak;\n\t}\n\tcase TLS_CIPHER_CHACHA20_POLY1305: {\n\t\tstruct tls12_crypto_info_chacha20_poly1305 *chacha20_poly1305 =\n\t\t\tcontainer_of(crypto_info,\n\t\t\t\tstruct tls12_crypto_info_chacha20_poly1305,\n\t\t\t\tinfo);\n\n\t\tif (len != sizeof(*chacha20_poly1305)) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(chacha20_poly1305->iv,\n\t\t       cctx->iv + TLS_CIPHER_CHACHA20_POLY1305_SALT_SIZE,\n\t\t       TLS_CIPHER_CHACHA20_POLY1305_IV_SIZE);\n\t\tmemcpy(chacha20_poly1305->rec_seq, cctx->rec_seq,\n\t\t       TLS_CIPHER_CHACHA20_POLY1305_REC_SEQ_SIZE);\n\t\tif (copy_to_user(optval, chacha20_poly1305,\n\t\t\t\tsizeof(*chacha20_poly1305)))\n\t\t\trc = -EFAULT;\n\t\tbreak;\n\t}\n\tcase TLS_CIPHER_SM4_GCM: {\n\t\tstruct tls12_crypto_info_sm4_gcm *sm4_gcm_info =\n\t\t\tcontainer_of(crypto_info,\n\t\t\t\tstruct tls12_crypto_info_sm4_gcm, info);\n\n\t\tif (len != sizeof(*sm4_gcm_info)) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(sm4_gcm_info->iv,\n\t\t       cctx->iv + TLS_CIPHER_SM4_GCM_SALT_SIZE,\n\t\t       TLS_CIPHER_SM4_GCM_IV_SIZE);\n\t\tmemcpy(sm4_gcm_info->rec_seq, cctx->rec_seq,\n\t\t       TLS_CIPHER_SM4_GCM_REC_SEQ_SIZE);\n\t\tif (copy_to_user(optval, sm4_gcm_info, sizeof(*sm4_gcm_info)))\n\t\t\trc = -EFAULT;\n\t\tbreak;\n\t}\n\tcase TLS_CIPHER_SM4_CCM: {\n\t\tstruct tls12_crypto_info_sm4_ccm *sm4_ccm_info =\n\t\t\tcontainer_of(crypto_info,\n\t\t\t\tstruct tls12_crypto_info_sm4_ccm, info);\n\n\t\tif (len != sizeof(*sm4_ccm_info)) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(sm4_ccm_info->iv,\n\t\t       cctx->iv + TLS_CIPHER_SM4_CCM_SALT_SIZE,\n\t\t       TLS_CIPHER_SM4_CCM_IV_SIZE);\n\t\tmemcpy(sm4_ccm_info->rec_seq, cctx->rec_seq,\n\t\t       TLS_CIPHER_SM4_CCM_REC_SEQ_SIZE);\n\t\tif (copy_to_user(optval, sm4_ccm_info, sizeof(*sm4_ccm_info)))\n\t\t\trc = -EFAULT;\n\t\tbreak;\n\t}\n\tcase TLS_CIPHER_ARIA_GCM_128: {\n\t\tstruct tls12_crypto_info_aria_gcm_128 *\n\t\t  crypto_info_aria_gcm_128 =\n\t\t  container_of(crypto_info,\n\t\t\t       struct tls12_crypto_info_aria_gcm_128,\n\t\t\t       info);\n\n\t\tif (len != sizeof(*crypto_info_aria_gcm_128)) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(crypto_info_aria_gcm_128->iv,\n\t\t       cctx->iv + TLS_CIPHER_ARIA_GCM_128_SALT_SIZE,\n\t\t       TLS_CIPHER_ARIA_GCM_128_IV_SIZE);\n\t\tmemcpy(crypto_info_aria_gcm_128->rec_seq, cctx->rec_seq,\n\t\t       TLS_CIPHER_ARIA_GCM_128_REC_SEQ_SIZE);\n\t\tif (copy_to_user(optval,\n\t\t\t\t crypto_info_aria_gcm_128,\n\t\t\t\t sizeof(*crypto_info_aria_gcm_128)))\n\t\t\trc = -EFAULT;\n\t\tbreak;\n\t}\n\tcase TLS_CIPHER_ARIA_GCM_256: {\n\t\tstruct tls12_crypto_info_aria_gcm_256 *\n\t\t  crypto_info_aria_gcm_256 =\n\t\t  container_of(crypto_info,\n\t\t\t       struct tls12_crypto_info_aria_gcm_256,\n\t\t\t       info);\n\n\t\tif (len != sizeof(*crypto_info_aria_gcm_256)) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(crypto_info_aria_gcm_256->iv,\n\t\t       cctx->iv + TLS_CIPHER_ARIA_GCM_256_SALT_SIZE,\n\t\t       TLS_CIPHER_ARIA_GCM_256_IV_SIZE);\n\t\tmemcpy(crypto_info_aria_gcm_256->rec_seq, cctx->rec_seq,\n\t\t       TLS_CIPHER_ARIA_GCM_256_REC_SEQ_SIZE);\n\t\tif (copy_to_user(optval,\n\t\t\t\t crypto_info_aria_gcm_256,\n\t\t\t\t sizeof(*crypto_info_aria_gcm_256)))\n\t\t\trc = -EFAULT;\n\t\tbreak;\n\t}\n\tdefault:\n\t\trc = -EINVAL;\n\t}\n\nout:\n\treturn rc;\n}", "target": 2, "idx": 11839}
{"commit_id": "8ed705e1227d3d582e3f0de435bba606d053d686", "project": "wireshark", "func": "static int dissect_mac_fdd_rach(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\n{\n    guint8         tctf;\n    guint8         chan;\n    guint16        bitoffs   = 0;\n    tvbuff_t      *next_tvb;\n    proto_tree    *rach_tree = NULL;\n    proto_item    *channel_type;\n    umts_mac_info *macinf;\n    fp_info       *fpinf;\n    rlc_info      *rlcinf;\n    proto_item    *ti        = NULL;\n    guint8         c_t;\n    /* RACH TCTF is always 2 bit */\n    tctf = tvb_get_bits8(tvb, 0, 2);\n    bitoffs += 2;\n\n    col_set_str(pinfo->cinfo, COL_PROTOCOL, \"MAC\");\n\n    col_set_str(pinfo->cinfo, COL_INFO,\n        val_to_str_const(tctf, rach_fdd_tctf_vals, \"Unknown TCTF\"));\n\n    ti = proto_tree_add_item(tree, proto_umts_mac, tvb, 0, -1, ENC_NA);\n    rach_tree = proto_item_add_subtree(ti, ett_mac_rach);\n\n    macinf = (umts_mac_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0);\n    fpinf  = (fp_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_fp, 0);\n    rlcinf = (rlc_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_rlc, 0);\n    if (!macinf || !fpinf) {\n        proto_tree_add_expert(rach_tree, pinfo, &ei_mac_per_frame_info_missing, tvb, 0, -1);\n        return 1;\n    }\n\n    proto_tree_add_bits_item(rach_tree, hf_mac_rach_fdd_tctf, tvb, 0, 2, ENC_BIG_ENDIAN);\n    if (tctf == TCTF_DCCH_DTCH_RACH_FDD) {\n        macinf->ctmux[fpinf->cur_tb] = 1; /* DCCH/DTCH on RACH *always* has a C/T */\n        bitoffs = tree_add_common_dcch_dtch_fields(tvb, pinfo, rach_tree, bitoffs, fpinf, macinf, rlcinf);\n    }\n\n    chan = fpinf->cur_chan;\n    /* handoff to next dissector */\n    switch (tctf) {\n        case TCTF_CCCH_RACH_FDD:\n            proto_item_append_text(ti, \" (CCCH)\");\n            channel_type = proto_tree_add_uint(rach_tree, hf_mac_channel, tvb, 0, 0, MAC_CCCH);\n            PROTO_ITEM_SET_GENERATED(channel_type);\n            next_tvb = tvb_new_octet_aligned(tvb, bitoffs, fpinf->chan_tf_size[chan] - bitoffs);\n            add_new_data_source(pinfo, next_tvb, \"Octet-Aligned CCCH Data\");\n            call_dissector_with_data(rlc_ccch_handle, next_tvb, pinfo, tree, data);\n            break;\n        case TCTF_DCCH_DTCH_RACH_FDD:\n            /*Set RLC Mode/MAC content based on the L-CHID derived from the C/T flag*/\n            c_t = tvb_get_bits8(tvb,bitoffs-4,4);\n            if (c_t == 15) {\n                /* reserved value, discard PDU */\n                expert_add_info(pinfo, NULL, &ei_mac_reserved_c_t);\n                break;\n            }\n            rlcinf->mode[chan] = lchId_rlc_map[c_t+1];\n            macinf->content[chan] = lchId_type_table[c_t+1];\n            rlcinf->rbid[chan] = c_t+1;\n            switch (macinf->content[chan]) {\n                case MAC_CONTENT_DCCH:\n                    proto_item_append_text(ti, \" (DCCH)\");\n                    channel_type = proto_tree_add_uint(rach_tree, hf_mac_channel, tvb, 0, 0, MAC_DCCH);\n                    PROTO_ITEM_SET_GENERATED(channel_type);\n                    next_tvb = tvb_new_octet_aligned(tvb, bitoffs, fpinf->chan_tf_size[chan] - bitoffs);\n                    add_new_data_source(pinfo, next_tvb, \"Octet-Aligned DCCH Data\");\n                    call_dissector_with_data(rlc_dcch_handle, next_tvb, pinfo, tree, data);\n                    break;\n                case MAC_CONTENT_PS_DTCH:\n                    proto_item_append_text(ti, \" (PS DTCH)\");\n                    channel_type = proto_tree_add_uint(rach_tree, hf_mac_channel, tvb, 0, 0, MAC_DTCH);\n                    PROTO_ITEM_SET_GENERATED(channel_type);\n                    next_tvb = tvb_new_octet_aligned(tvb, bitoffs, fpinf->chan_tf_size[chan] - bitoffs);\n                    add_new_data_source(pinfo, next_tvb, \"Octet-Aligned DTCH Data\");\n                    call_dissector_with_data(rlc_ps_dtch_handle, next_tvb, pinfo, tree, data);\n                    break;\n                case MAC_CONTENT_CS_DTCH:\n                    proto_item_append_text(ti, \" (CS DTCH)\");\n                    /* TODO */\n                    break;\n                default:\n                    proto_item_append_text(ti, \" (Unknown RACH DCCH/DTCH Content)\");\n                    expert_add_info_format(pinfo, NULL, &ei_mac_unknown_content, \"Unknown RACH DCCH/DTCH Content\");\n            }\n            break;\n        default:\n            proto_item_append_text(ti, \" (Unknown RACH TCTF)\");\n            expert_add_info_format(pinfo, NULL, &ei_mac_rach_tctf_unknown, \"Unknown RACH TCTF\");\n    }\n    return tvb_captured_length(tvb);\n}", "target": 2, "idx": 11840}
{"commit_id": "8e448310d74b283c5cd02b9ed7fb997b47bf9b22", "project": "glibc", "func": "static void *\n_int_memalign (mstate av, size_t alignment, size_t bytes)\n{\n  INTERNAL_SIZE_T nb;             /* padded  request size */\n  char *m;                        /* memory returned by malloc call */\n  mchunkptr p;                    /* corresponding chunk */\n  char *brk;                      /* alignment point within p */\n  mchunkptr newp;                 /* chunk to return */\n  INTERNAL_SIZE_T newsize;        /* its size */\n  INTERNAL_SIZE_T leadsize;       /* leading space before alignment point */\n  mchunkptr remainder;            /* spare room at end to split off */\n  unsigned long remainder_size;   /* its size */\n  INTERNAL_SIZE_T size;\n\n\n\n  checked_request2size (bytes, nb);\n\n  /*\n     Strategy: find a spot within that chunk that meets the alignment\n     request, and then possibly free the leading and trailing space.\n   */\n\n\n  /* Check for overflow.  */\n  if (nb > SIZE_MAX - alignment - MINSIZE)\n    {\n      __set_errno (ENOMEM);\n      return 0;\n    }\n\n  /* Call malloc with worst case padding to hit alignment. */\n\n  m = (char *) (_int_malloc (av, nb + alignment + MINSIZE));\n\n  if (m == 0)\n    return 0;           /* propagate failure */\n\n  p = mem2chunk (m);\n\n  if ((((unsigned long) (m)) % alignment) != 0)   /* misaligned */\n\n    { /*\n                Find an aligned spot inside chunk.  Since we need to give back\n                leading space in a chunk of at least MINSIZE, if the first\n                calculation places us at a spot with less than MINSIZE leader,\n                we can move to the next aligned spot -- we've allocated enough\n                total room so that this is always possible.\n                 */\n      brk = (char *) mem2chunk (((unsigned long) (m + alignment - 1)) &\n                                - ((signed long) alignment));\n      if ((unsigned long) (brk - (char *) (p)) < MINSIZE)\n        brk += alignment;\n\n      newp = (mchunkptr) brk;\n      leadsize = brk - (char *) (p);\n      newsize = chunksize (p) - leadsize;\n\n      /* For mmapped chunks, just adjust offset */\n      if (chunk_is_mmapped (p))\n        {\n          set_prev_size (newp, prev_size (p) + leadsize);\n          set_head (newp, newsize | IS_MMAPPED);\n          return chunk2mem (newp);\n        }\n\n      /* Otherwise, give back leader, use the rest */\n      set_head (newp, newsize | PREV_INUSE |\n                (av != &main_arena ? NON_MAIN_ARENA : 0));\n      set_inuse_bit_at_offset (newp, newsize);\n      set_head_size (p, leadsize | (av != &main_arena ? NON_MAIN_ARENA : 0));\n      _int_free (av, p, 1);\n      p = newp;\n\n      assert (newsize >= nb &&\n              (((unsigned long) (chunk2mem (p))) % alignment) == 0);\n    }\n\n  /* Also give back spare room at the end */\n  if (!chunk_is_mmapped (p))\n    {\n      size = chunksize (p);\n      if ((unsigned long) (size) > (unsigned long) (nb + MINSIZE))\n        {\n          remainder_size = size - nb;\n          remainder = chunk_at_offset (p, nb);\n          set_head (remainder, remainder_size | PREV_INUSE |\n                    (av != &main_arena ? NON_MAIN_ARENA : 0));\n          set_head_size (p, nb);\n          _int_free (av, remainder, 1);\n        }\n    }\n\n  check_inuse_chunk (av, p);\n  return chunk2mem (p);\n}", "target": 3, "idx": 11841}
{"commit_id": "6b830a1640ca20528032c89a4fdd8291a4d2d8b2", "project": "appneta/tcpreplay", "func": "int _our_safe_pcap_next_ex(pcap_t *pcap, struct pcap_pkthdr **pkthdr,\n        const u_char **pktdata, const char *funcname,\n        const int line, const char *file)\n{\n    int res = pcap_next_ex(pcap, pkthdr, pktdata);\n\n    if (*pktdata && *pkthdr) {\n        if ((*pkthdr)->len > MAXPACKET) {\n            fprintf(stderr, \"safe_pcap_next_ex ERROR: Invalid packet length in %s:%s() line %d: %u is greater than maximum %u\\n\",\n                    file, funcname, line, (*pkthdr)->len, MAXPACKET);\n            exit(-1);\n        }\n\n        if (!(*pkthdr)->len || (*pkthdr)->len < (*pkthdr)->caplen) {\n            fprintf(stderr, \"safe_pcap_next_ex ERROR: Invalid packet length in %s:%s() line %d: packet length=%u capture length=%u\\n\",\n                    file, funcname, line, (*pkthdr)->len, (*pkthdr)->caplen);\n            exit(-1);\n        }\n    }\n\n    return res;\n}", "target": 2, "idx": 11842}
{"commit_id": "edb272e35ee57e7b89f3e127222c6981b6a1e730", "project": "wolfSSL/wolfssh", "func": "int wolfSSH_SFTP_RecvRename(WOLFSSH* ssh, int reqId, byte* data, word32 maxSz)\n{\n    word32 sz = 0;\n    char*  old;\n    char*  nw;\n    word32 idx = 0;\n    int    ret = WS_SUCCESS;\n\n    byte*  out;\n    word32 outSz;\n\n    byte type = WOLFSSH_FTP_OK;\n    char  suc[] = \"Renamed File\";\n    char  err[] = \"Rename File Error\";\n    char* res   = suc;\n\n    if (ssh == NULL) {\n        return WS_BAD_ARGUMENT;\n    }\n\n    WLOG(WS_LOG_SFTP, \"Receiving WOLFSSH_FTP_RENAME\");\n\n    /* get old file name */\n    ato32(data + idx, &sz); idx += UINT32_SZ;\n    if (sz > maxSz - idx) {\n        ret = WS_BUFFER_E;\n    }\n    old = (char*)WMALLOC(sz + 1, ssh->ctx->heap, DYNTYPE_BUFFER);\n    if (old == NULL) {\n        ret = WS_MEMORY_E;\n    }\n    if (ret == WS_SUCCESS) {\n        WMEMCPY(old, data + idx, sz); idx += sz;\n        old[sz] = '\\0';\n    }\n\n    /* get new file name */\n    ato32(data + idx, &sz); idx += UINT32_SZ;\n    if (sz > maxSz - idx) {\n        ret = WS_BUFFER_E;\n    }\n    nw = (char*)WMALLOC(sz + 1, ssh->ctx->heap, DYNTYPE_BUFFER);\n    if (nw == NULL) {\n        ret = WS_MEMORY_E;\n    }\n    if (ret == WS_SUCCESS) {\n        WMEMCPY(nw, data + idx, sz);\n        nw[sz] = '\\0';\n    }\n\n    if (wolfSSH_CleanPath(ssh, old) < 0) {\n        ret =  WS_FATAL_ERROR;\n    }\n    if (wolfSSH_CleanPath(ssh, nw) < 0) {\n        ret = WS_FATAL_ERROR;\n    }\n\n    if (ret == WS_SUCCESS) {\n    #ifndef USE_WINDOWS_API\n        if (WRENAME(ssh->fs, old, nw) < 0)\n    #else /* USE_WINDOWS_API */\n        if (WS_MoveFileA(old, nw, ssh->ctx->heap) == 0)\n    #endif /* USE_WINDOWS_API */\n        {\n            WLOG(WS_LOG_SFTP, \"Error renaming file\");\n            ret = WS_BAD_FILE_E;\n        }\n    }\n\n    /* Let the client know the results from trying to rename the file */\n    WFREE(old, ssh->ctx->heap, DYNTYPE_BUFFER);\n    WFREE(nw, ssh->ctx->heap, DYNTYPE_BUFFER);\n    if (ret != WS_SUCCESS) {\n        type = WOLFSSH_FTP_FAILURE;\n        res  = err;\n    }\n\n    if (wolfSSH_SFTP_CreateStatus(ssh, type, reqId, res, \"English\", NULL,\n                &outSz) != WS_SIZE_ONLY) {\n        return WS_FATAL_ERROR;\n    }\n    out = (byte*)WMALLOC(outSz, ssh->ctx->heap, DYNTYPE_BUFFER);\n    if (out == NULL) {\n        return WS_MEMORY_E;\n    }\n    if (wolfSSH_SFTP_CreateStatus(ssh, type, reqId, res, \"English\", out,\n                &outSz) != WS_SUCCESS) {\n        WFREE(out, ssh->ctx->heap, DYNTYPE_BUFFER);\n        return WS_FATAL_ERROR;\n    }\n\n    /* set send out buffer, \"out\" is taken by ssh  */\n    wolfSSH_SFTP_RecvSetSend(ssh, out, outSz);\n    return ret;\n}", "target": 3, "idx": 11843}
{"commit_id": "4c3aee4bb0294c232d56b6d34e9eeb74f630fe8c", "project": "the-tcpdump-group/tcpdump", "func": "static int\nmp_dss_print(netdissect_options *ndo,\n             const u_char *opt, u_int opt_len, u_char flags)\n{\n        const struct mp_dss *mdss = (const struct mp_dss *) opt;\n\n        /* We need the flags, at a minimum. */\n        if (opt_len < 4)\n                return 0;\n\n        if (flags & TH_SYN)\n                return 0;\n\n        if (mdss->flags & MP_DSS_F)\n                ND_PRINT((ndo, \" fin\"));\n\n        opt += 4;\n        opt_len -= 4;\n        if (mdss->flags & MP_DSS_A) {\n                /* Ack present */\n                ND_PRINT((ndo, \" ack \"));\n                /*\n                 * If the a flag is set, we have an 8-byte ack; if it's\n                 * clear, we have a 4-byte ack.\n                 */\n                if (mdss->flags & MP_DSS_a) {\n                        if (opt_len < 8)\n                                return 0;\n                        ND_PRINT((ndo, \"%\" PRIu64, EXTRACT_64BITS(opt)));\n                        opt += 8;\n                        opt_len -= 8;\n                } else {\n                        if (opt_len < 4)\n                                return 0;\n                        ND_PRINT((ndo, \"%u\", EXTRACT_32BITS(opt)));\n                        opt += 4;\n                        opt_len -= 4;\n                }\n        }\n\n        if (mdss->flags & MP_DSS_M) {\n                /*\n                 * Data Sequence Number (DSN), Subflow Sequence Number (SSN),\n                 * Data-Level Length present, and Checksum possibly present.\n                 */\n                ND_PRINT((ndo, \" seq \"));\n\t\t/*\n                 * If the m flag is set, we have an 8-byte NDS; if it's clear,\n                 * we have a 4-byte DSN.\n                 */\n                if (mdss->flags & MP_DSS_m) {\n                        if (opt_len < 8)\n                                return 0;\n                        ND_PRINT((ndo, \"%\" PRIu64, EXTRACT_64BITS(opt)));\n                        opt += 8;\n                        opt_len -= 8;\n                } else {\n                        if (opt_len < 4)\n                                return 0;\n                        ND_PRINT((ndo, \"%u\", EXTRACT_32BITS(opt)));\n                        opt += 4;\n                        opt_len -= 4;\n                }\n                if (opt_len < 4)\n                        return 0;\n                ND_PRINT((ndo, \" subseq %u\", EXTRACT_32BITS(opt)));\n                opt += 4;\n                opt_len -= 4;\n                if (opt_len < 2)\n                        return 0;\n                ND_PRINT((ndo, \" len %u\", EXTRACT_16BITS(opt)));\n                opt += 2;\n                opt_len -= 2;\n\n                /*\n                 * The Checksum is present only if negotiated.\n                 * If there are at least 2 bytes left, process the next 2\n                 * bytes as the Checksum.\n                 */\n                if (opt_len >= 2) {\n                        ND_PRINT((ndo, \" csum 0x%x\", EXTRACT_16BITS(opt)));\n                        opt_len -= 2;\n                }\n        }\n        if (opt_len != 0)\n                return 0;\n        return 1;\n}", "target": 3, "idx": 11844}
{"commit_id": "ec8ef90c1f573c9eb1f17d6a056aa0015f184acf", "project": "libtiff", "func": "static int loadImage(TIFF *in, struct image_data *image, struct dump_opts *dump,\n                     unsigned char **read_ptr)\n{\n    uint32_t i;\n    float xres = 0.0, yres = 0.0;\n    uint32_t nstrips = 0, ntiles = 0;\n    uint16_t planar = 0;\n    uint16_t bps = 0, spp = 0, res_unit = 0;\n    uint16_t orientation = 0;\n    uint16_t input_compression = 0, input_photometric = 0;\n    uint16_t subsampling_horiz, subsampling_vert;\n    uint32_t width = 0, length = 0;\n    tmsize_t stsize = 0, tlsize = 0, buffsize = 0;\n    tmsize_t scanlinesize = 0;\n    uint32_t tw = 0, tl = 0; /* Tile width and length */\n    tmsize_t tile_rowsize = 0;\n    unsigned char *read_buff = NULL;\n    int readunit = 0;\n\n    TIFFGetFieldDefaulted(in, TIFFTAG_BITSPERSAMPLE, &bps);\n    TIFFGetFieldDefaulted(in, TIFFTAG_SAMPLESPERPIXEL, &spp);\n    TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &planar);\n    TIFFGetFieldDefaulted(in, TIFFTAG_ORIENTATION, &orientation);\n    if (!TIFFGetFieldDefaulted(in, TIFFTAG_PHOTOMETRIC, &input_photometric))\n        TIFFError(\"loadImage\", \"Image lacks Photometric interpretation tag\");\n    if (!TIFFGetField(in, TIFFTAG_IMAGEWIDTH, &width))\n        TIFFError(\"loadimage\", \"Image lacks image width tag\");\n    if (!TIFFGetField(in, TIFFTAG_IMAGELENGTH, &length))\n        TIFFError(\"loadimage\", \"Image lacks image length tag\");\n    TIFFGetFieldDefaulted(in, TIFFTAG_XRESOLUTION, &xres);\n    TIFFGetFieldDefaulted(in, TIFFTAG_YRESOLUTION, &yres);\n    if (!TIFFGetFieldDefaulted(in, TIFFTAG_RESOLUTIONUNIT, &res_unit))\n        res_unit = RESUNIT_INCH;\n    if (!TIFFGetField(in, TIFFTAG_COMPRESSION, &input_compression))\n        input_compression = COMPRESSION_NONE;\n\n#ifdef DEBUG2\n    char compressionid[16];\n\n    switch (input_compression)\n    {\n        case COMPRESSION_NONE: /* 1  dump mode */\n            strcpy(compressionid, \"None/dump\");\n            break;\n        case COMPRESSION_CCITTRLE: /* 2 CCITT modified Huffman RLE */\n            strcpy(compressionid, \"Huffman RLE\");\n            break;\n        case COMPRESSION_CCITTFAX3: /* 3 CCITT Group 3 fax encoding */\n            strcpy(compressionid, \"Group3 Fax\");\n            break;\n        case COMPRESSION_CCITTFAX4: /* 4 CCITT Group 4 fax encoding */\n            strcpy(compressionid, \"Group4 Fax\");\n            break;\n        case COMPRESSION_LZW: /* 5 Lempel-Ziv  & Welch */\n            strcpy(compressionid, \"LZW\");\n            break;\n        case COMPRESSION_OJPEG: /* 6 !6.0 JPEG */\n            strcpy(compressionid, \"Old Jpeg\");\n            break;\n        case COMPRESSION_JPEG: /* 7 %JPEG DCT compression */\n            strcpy(compressionid, \"New Jpeg\");\n            break;\n        case COMPRESSION_NEXT: /* 32766 NeXT 2-bit RLE */\n            strcpy(compressionid, \"Next RLE\");\n            break;\n        case COMPRESSION_CCITTRLEW: /* 32771 #1 w/ word alignment */\n            strcpy(compressionid, \"CITTRLEW\");\n            break;\n        case COMPRESSION_PACKBITS: /* 32773 Macintosh RLE */\n            strcpy(compressionid, \"Mac Packbits\");\n            break;\n        case COMPRESSION_THUNDERSCAN: /* 32809 ThunderScan RLE */\n            strcpy(compressionid, \"Thunderscan\");\n            break;\n        case COMPRESSION_IT8CTPAD: /* 32895 IT8 CT w/padding */\n            strcpy(compressionid, \"IT8 padded\");\n            break;\n        case COMPRESSION_IT8LW: /* 32896 IT8 Linework RLE */\n            strcpy(compressionid, \"IT8 RLE\");\n            break;\n        case COMPRESSION_IT8MP: /* 32897 IT8 Monochrome picture */\n            strcpy(compressionid, \"IT8 mono\");\n            break;\n        case COMPRESSION_IT8BL: /* 32898 IT8 Binary line art */\n            strcpy(compressionid, \"IT8 lineart\");\n            break;\n        case COMPRESSION_PIXARFILM: /* 32908 Pixar companded 10bit LZW */\n            strcpy(compressionid, \"Pixar 10 bit\");\n            break;\n        case COMPRESSION_PIXARLOG: /* 32909 Pixar companded 11bit ZIP */\n            strcpy(compressionid, \"Pixar 11bit\");\n            break;\n        case COMPRESSION_DEFLATE: /* 32946 Deflate compression */\n            strcpy(compressionid, \"Deflate\");\n            break;\n        case COMPRESSION_ADOBE_DEFLATE: /* 8 Deflate compression */\n            strcpy(compressionid, \"Adobe deflate\");\n            break;\n        default:\n            strcpy(compressionid, \"None/unknown\");\n            break;\n    }\n    TIFFError(\"loadImage\", \"Input compression %s\", compressionid);\n#endif\n\n    scanlinesize = TIFFScanlineSize(in);\n    image->bps = bps;\n    image->spp = spp;\n    image->planar = planar;\n    image->width = width;\n    image->length = length;\n    image->xres = xres;\n    image->yres = yres;\n    image->res_unit = res_unit;\n    image->compression = input_compression;\n    image->photometric = input_photometric;\n#ifdef DEBUG2\n    char photometricid[12];\n\n    switch (input_photometric)\n    {\n        case PHOTOMETRIC_MINISWHITE:\n            strcpy(photometricid, \"MinIsWhite\");\n            break;\n        case PHOTOMETRIC_MINISBLACK:\n            strcpy(photometricid, \"MinIsBlack\");\n            break;\n        case PHOTOMETRIC_RGB:\n            strcpy(photometricid, \"RGB\");\n            break;\n        case PHOTOMETRIC_PALETTE:\n            strcpy(photometricid, \"Palette\");\n            break;\n        case PHOTOMETRIC_MASK:\n            strcpy(photometricid, \"Mask\");\n            break;\n        case PHOTOMETRIC_SEPARATED:\n            strcpy(photometricid, \"Separated\");\n            break;\n        case PHOTOMETRIC_YCBCR:\n            strcpy(photometricid, \"YCBCR\");\n            break;\n        case PHOTOMETRIC_CIELAB:\n            strcpy(photometricid, \"CIELab\");\n            break;\n        case PHOTOMETRIC_ICCLAB:\n            strcpy(photometricid, \"ICCLab\");\n            break;\n        case PHOTOMETRIC_ITULAB:\n            strcpy(photometricid, \"ITULab\");\n            break;\n        case PHOTOMETRIC_LOGL:\n            strcpy(photometricid, \"LogL\");\n            break;\n        case PHOTOMETRIC_LOGLUV:\n            strcpy(photometricid, \"LOGLuv\");\n            break;\n        default:\n            strcpy(photometricid, \"Unknown\");\n            break;\n    }\n    TIFFError(\"loadImage\", \"Input photometric interpretation %s\",\n              photometricid);\n\n#endif\n    image->orientation = orientation;\n    switch (orientation)\n    {\n        case 0:\n        case ORIENTATION_TOPLEFT:\n            image->adjustments = 0;\n            break;\n        case ORIENTATION_TOPRIGHT:\n            image->adjustments = MIRROR_HORIZ;\n            break;\n        case ORIENTATION_BOTRIGHT:\n            image->adjustments = ROTATECW_180;\n            break;\n        case ORIENTATION_BOTLEFT:\n            image->adjustments = MIRROR_VERT;\n            break;\n        case ORIENTATION_LEFTTOP:\n            image->adjustments = MIRROR_VERT | ROTATECW_90;\n            break;\n        case ORIENTATION_RIGHTTOP:\n            image->adjustments = ROTATECW_90;\n            break;\n        case ORIENTATION_RIGHTBOT:\n            image->adjustments = MIRROR_VERT | ROTATECW_270;\n            break;\n        case ORIENTATION_LEFTBOT:\n            image->adjustments = ROTATECW_270;\n            break;\n        default:\n            image->adjustments = 0;\n            image->orientation = ORIENTATION_TOPLEFT;\n    }\n\n    if ((bps == 0) || (spp == 0))\n    {\n        TIFFError(\"loadImage\",\n                  \"Invalid samples per pixel (%\" PRIu16\n                  \") or bits per sample (%\" PRIu16 \")\",\n                  spp, bps);\n        return (-1);\n    }\n\n    if (TIFFIsTiled(in))\n    {\n        readunit = TILE;\n        tlsize = TIFFTileSize(in);\n        ntiles = TIFFNumberOfTiles(in);\n        TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n        TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n\n        tile_rowsize = TIFFTileRowSize(in);\n        if (ntiles == 0 || tlsize == 0 || tile_rowsize == 0)\n        {\n            TIFFError(\"loadImage\",\n                      \"File appears to be tiled, but the number of tiles, tile \"\n                      \"size, or tile rowsize is zero.\");\n            exit(EXIT_FAILURE);\n        }\n        if (ntiles != 0 && tlsize > (tmsize_t)(TIFF_TMSIZE_T_MAX / ntiles))\n        {\n            TIFFError(\"loadImage\",\n                      \"Integer overflow when calculating buffer size\");\n            exit(EXIT_FAILURE);\n        }\n        buffsize = tlsize * ntiles;\n\n        if (tl != 0 && ntiles != 0 &&\n            tile_rowsize > (tmsize_t)(TIFF_TMSIZE_T_MAX / tl / ntiles))\n        {\n            TIFFError(\"loadImage\",\n                      \"Integer overflow when calculating buffer size\");\n            exit(EXIT_FAILURE);\n        }\n        if (buffsize < (tmsize_t)(ntiles * tl * tile_rowsize))\n        {\n            buffsize = ntiles * tl * tile_rowsize;\n\n#ifdef DEBUG2\n            TIFFError(\"loadImage\",\n                      \"Tilesize %\" PRIu32 \" is too small, using ntiles * \"\n                      \"tilelength * tilerowsize %\" PRIu32,\n                      tlsize, buffsize);\n#endif\n        }\n\n        if (dump->infile != NULL)\n            dump_info(dump->infile, dump->format, \"\",\n                      \"Tilesize: %\" TIFF_SSIZE_FORMAT\n                      \", Number of Tiles: %\" PRIu32\n                      \", Tile row size: %\" TIFF_SSIZE_FORMAT,\n                      tlsize, ntiles, tile_rowsize);\n    }\n    else\n    {\n        tmsize_t buffsize_check;\n        readunit = STRIP;\n        TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n        stsize = TIFFStripSize(in);\n        nstrips = TIFFNumberOfStrips(in);\n        if (nstrips == 0 || stsize == 0)\n        {\n            TIFFError(\"loadImage\", \"File appears to be striped, but the number \"\n                                   \"of stipes or stripe size is zero.\");\n            exit(EXIT_FAILURE);\n        }\n\n        if (nstrips != 0 && stsize > (tmsize_t)(TIFF_TMSIZE_T_MAX / nstrips))\n        {\n            TIFFError(\"loadImage\",\n                      \"Integer overflow when calculating buffer size\");\n            exit(EXIT_FAILURE);\n        }\n        buffsize = stsize * nstrips;\n        /* The buffsize_check and the possible adaptation of buffsize\n         * has to account also for padding of each line to a byte boundary.\n         * This is assumed by mirrorImage() and rotateImage().\n         * Furthermore, functions like extractContigSamplesShifted32bits()\n         * need a buffer, which is at least 3 bytes larger than the actual\n         * image. Otherwise buffer-overflow might occur there.\n         */\n        if ((spp != 0 && bps != 0 &&\n             width > (uint32_t)((UINT32_MAX - 7) / spp / bps)) ||\n            (width != 0 && spp != 0 && bps != 0 &&\n             length > (tmsize_t)(TIFF_TMSIZE_T_MAX /\n                                 (uint32_t)(((width * spp * bps) + 7) / 8))))\n        {\n            TIFFError(\"loadImage\", \"Integer overflow detected.\");\n            exit(EXIT_FAILURE);\n        }\n        buffsize_check =\n            (tmsize_t)length * (uint32_t)(((width * spp * bps) + 7) / 8);\n        if (buffsize < buffsize_check)\n        {\n            buffsize = buffsize_check;\n#ifdef DEBUG2\n            TIFFError(\"loadImage\",\n                      \"Stripsize %\" PRIu32 \" is too small, using imagelength * \"\n                      \"width * spp * bps / 8 = %\" PRIu32,\n                      stsize, (unsigned long)buffsize);\n#endif\n        }\n\n        if (dump->infile != NULL)\n            dump_info(dump->infile, dump->format, \"\",\n                      \"Stripsize: %\" TIFF_SSIZE_FORMAT\n                      \", Number of Strips: %\" PRIu32\n                      \", Rows per Strip: %\" PRIu32\n                      \", Scanline size: %\" TIFF_SSIZE_FORMAT,\n                      stsize, nstrips, rowsperstrip, scanlinesize);\n    }\n\n    if (input_compression == COMPRESSION_JPEG)\n    { /* Force conversion to RGB */\n        jpegcolormode = JPEGCOLORMODE_RGB;\n        TIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n    }\n    /* The clause up to the read statement is taken from Tom Lane's tiffcp patch\n     */\n    else\n    { /* Otherwise, can't handle subsampled input */\n        if (input_photometric == PHOTOMETRIC_YCBCR)\n        {\n            TIFFGetFieldDefaulted(in, TIFFTAG_YCBCRSUBSAMPLING,\n                                  &subsampling_horiz, &subsampling_vert);\n            if (subsampling_horiz != 1 || subsampling_vert != 1)\n            {\n                TIFFError(\"loadImage\",\n                          \"Can't copy/convert subsampled image with \"\n                          \"subsampling %\" PRIu16 \" horiz %\" PRIu16 \" vert\",\n                          subsampling_horiz, subsampling_vert);\n                return (-1);\n            }\n        }\n    }\n\n    read_buff = *read_ptr;\n    /* +3 : add a few guard bytes since reverseSamples16bits() can read a bit\n     * outside buffer */\n    /* Reuse of read_buff from previous image is quite unsafe, because other\n     * functions (like rotateImage() etc.) reallocate that buffer with different\n     * size without updating the local prev_readsize value. */\n    if (read_buff)\n    {\n        _TIFFfree(read_buff);\n    }\n    if (buffsize > 0xFFFFFFFFU - 3)\n    {\n        TIFFError(\"loadImage\", \"Required read buffer size too large\");\n        return (-1);\n    }\n    read_buff =\n        (unsigned char *)limitMalloc(buffsize + NUM_BUFF_OVERSIZE_BYTES);\n    if (!read_buff)\n    {\n        TIFFError(\"loadImage\", \"Unable to allocate read buffer\");\n        return (-1);\n    }\n\n    read_buff[buffsize] = 0;\n    read_buff[buffsize + 1] = 0;\n    read_buff[buffsize + 2] = 0;\n\n    *read_ptr = read_buff;\n\n    /* N.B. The read functions used copy separate plane data into a buffer as\n     * interleaved samples rather than separate planes so the same logic works\n     * to extract regions regardless of the way the data are organized in the\n     * input file.\n     */\n    switch (readunit)\n    {\n        case STRIP:\n            if (planar == PLANARCONFIG_CONTIG)\n            {\n                if (!(readContigStripsIntoBuffer(in, read_buff)))\n                {\n                    TIFFError(\"loadImage\",\n                              \"Unable to read contiguous strips into buffer\");\n                    return (-1);\n                }\n            }\n            else\n            {\n                if (!(readSeparateStripsIntoBuffer(in, read_buff, length, width,\n                                                   spp, dump)))\n                {\n                    TIFFError(\"loadImage\",\n                              \"Unable to read separate strips into buffer\");\n                    return (-1);\n                }\n            }\n            break;\n\n        case TILE:\n            if (planar == PLANARCONFIG_CONTIG)\n            {\n                if (!(readContigTilesIntoBuffer(in, read_buff, length, width,\n                                                tw, tl, spp, bps)))\n                {\n                    TIFFError(\"loadImage\",\n                              \"Unable to read contiguous tiles into buffer\");\n                    return (-1);\n                }\n            }\n            else\n            {\n                if (!(readSeparateTilesIntoBuffer(in, read_buff, length, width,\n                                                  tw, tl, spp, bps)))\n                {\n                    TIFFError(\"loadImage\",\n                              \"Unable to read separate tiles into buffer\");\n                    return (-1);\n                }\n            }\n            break;\n        default:\n            TIFFError(\"loadImage\", \"Unsupported image file format\");\n            return (-1);\n            break;\n    }\n    if ((dump->infile != NULL) && (dump->level == 2))\n    {\n        dump_info(dump->infile, dump->format, \"loadImage\",\n                  \"Image width %\" PRIu32 \", length %\" PRIu32\n                  \", Raw image data, %4\" TIFF_SSIZE_FORMAT \" bytes\",\n                  width, length, buffsize);\n        dump_info(dump->infile, dump->format, \"\",\n                  \"Bits per sample %\" PRIu16 \", Samples per pixel %\" PRIu16,\n                  bps, spp);\n\n        if ((uint64_t)scanlinesize > 0x0ffffffffULL)\n        {\n            dump_info(\n                dump->infile, dump->format, \"loadImage\",\n                \"Attention: scanlinesize %\" PRIu64\n                \" is larger than UINT32_MAX.\\nFollowing dump might be wrong.\",\n                (uint64_t)scanlinesize);\n        }\n        for (i = 0; i < length; i++)\n            dump_buffer(dump->infile, dump->format, 1, (uint32_t)scanlinesize,\n                        i, read_buff + (i * scanlinesize));\n    }\n    return (0);\n}", "target": 1, "idx": 11845}
{"commit_id": "900f39692ca0337a98a7cf047e4e2611071810c2", "project": "ffmpeg", "func": "static int mxf_read_index_entry_array(AVIOContext *pb, MXFIndexTableSegment *segment)\n{\n    int i, length;\n\n    segment->nb_index_entries = avio_rb32(pb);\n\n    length = avio_rb32(pb);\n    if(segment->nb_index_entries && length < 11)\n        return AVERROR_INVALIDDATA;\n\n    if (!(segment->temporal_offset_entries=av_calloc(segment->nb_index_entries, sizeof(*segment->temporal_offset_entries))) ||\n        !(segment->flag_entries          = av_calloc(segment->nb_index_entries, sizeof(*segment->flag_entries))) ||\n        !(segment->stream_offset_entries = av_calloc(segment->nb_index_entries, sizeof(*segment->stream_offset_entries)))) {\n        av_freep(&segment->temporal_offset_entries);\n        av_freep(&segment->flag_entries);\n        return AVERROR(ENOMEM);\n    }\n\n    for (i = 0; i < segment->nb_index_entries; i++) {\n        if(avio_feof(pb))\n            return AVERROR_INVALIDDATA;\n        segment->temporal_offset_entries[i] = avio_r8(pb);\n        avio_r8(pb);                                        /* KeyFrameOffset */\n        segment->flag_entries[i] = avio_r8(pb);\n        segment->stream_offset_entries[i] = avio_rb64(pb);\n        avio_skip(pb, length - 11);\n    }\n    return 0;\n}", "target": 1, "idx": 11846}
{"commit_id": "eff0f52d0466d81beabf304e2500f3039fd90252", "project": "Exiv2/exiv2", "func": "void Jp2Image::readMetadata()\n    {\n#ifdef DEBUG\n        std::cerr << \"Exiv2::Jp2Image::readMetadata: Reading JPEG-2000 file \" << io_->path() << std::endl;\n#endif\n        if (io_->open() != 0)\n        {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        // Ensure that this is the correct image type\n        if (!isJp2Type(*io_, true))\n        {\n            if (io_->error() || io_->eof()) throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAnImage, \"JPEG-2000\");\n        }\n\n        long              position  = 0;\n        Jp2BoxHeader      box       = {0,0};\n        Jp2BoxHeader      subBox    = {0,0};\n        Jp2ImageHeaderBox ihdr      = {0,0,0,0,0,0,0,0};\n        Jp2UuidBox        uuid      = {{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}};\n\n        while (io_->read((byte*)&box, sizeof(box)) == sizeof(box))\n        {\n            position   = io_->tell();\n            box.length = getLong((byte*)&box.length, bigEndian);\n            box.type   = getLong((byte*)&box.type, bigEndian);\n            if ( box.length > io_->size() ) {\n                throw Error(kerCorruptedMetadata);\n            }\n#ifdef DEBUG\n            std::cout << \"Exiv2::Jp2Image::readMetadata: \"\n                      << \"Position: \" << position\n                      << \" box type: \" << toAscii(box.type)\n                      << \" length: \" << box.length\n                      << std::endl;\n#endif\n\n            if (box.length == 0) return ;\n\n            if (box.length == 1)\n            {\n                // FIXME. Special case. the real box size is given in another place.\n            }\n\n            switch(box.type)\n            {\n                case kJp2BoxTypeJp2Header:\n                {\n#ifdef DEBUG\n                    std::cout << \"Exiv2::Jp2Image::readMetadata: JP2Header box found\" << std::endl;\n#endif\n                    long restore = io_->tell();\n\n                    while (io_->read((byte*)&subBox, sizeof(subBox)) == sizeof(subBox) && subBox.length )\n                    {\n                        subBox.length = getLong((byte*)&subBox.length, bigEndian);\n                        subBox.type   = getLong((byte*)&subBox.type, bigEndian);\n                        if ( subBox.length > io().size() ) {\n                            throw Error(kerCorruptedMetadata);\n                        }\n#ifdef DEBUG\n                        std::cout << \"Exiv2::Jp2Image::readMetadata: \"\n                        << \"subBox = \" << toAscii(subBox.type) << \" length = \" << subBox.length << std::endl;\n#endif\n                        if(subBox.type == kJp2BoxTypeColorHeader && subBox.length != 15)\n                        {\n#ifdef DEBUG\n                            std::cout << \"Exiv2::Jp2Image::readMetadata: \"\n                                     << \"Color data found\" << std::endl;\n#endif\n\n                            const long pad = 3 ; // 3 padding bytes 2 0 0\n                            const size_t data_length = Safe::add(subBox.length, static_cast<uint32_t>(8));\n                            // data_length makes no sense if it is larger than the rest of the file\n                            if (data_length > io_->size() - io_->tell()) {\n                                throw Error(kerCorruptedMetadata);\n                            }\n                            DataBuf data(static_cast<long>(data_length));\n                            io_->read(data.pData_,data.size_);\n                            const long    iccLength = getULong(data.pData_+pad, bigEndian);\n                            // subtracting pad from data.size_ is safe:\n                            // size_ is at least 8 and pad = 3\n                            if (iccLength > data.size_ - pad) {\n                                throw Error(kerCorruptedMetadata);\n                            }\n                            DataBuf icc(iccLength);\n                            ::memcpy(icc.pData_,data.pData_+pad,icc.size_);\n#ifdef DEBUG\n                            const char* iccPath = \"/tmp/libexiv2_jp2.icc\";\n                            FILE* f = fopen(iccPath,\"wb\");\n                            if ( f ) {\n                                fwrite(icc.pData_,icc.size_,1,f);\n                                fclose(f);\n                            }\n                            std::cout << \"Exiv2::Jp2Image::readMetadata: wrote iccProfile \" << icc.size_<< \" bytes to \" << iccPath << std::endl ;\n#endif\n                            setIccProfile(icc);\n                        }\n\n                        if( subBox.type == kJp2BoxTypeImageHeader)\n                        {\n                            io_->read((byte*)&ihdr, sizeof(ihdr));\n#ifdef DEBUG\n                            std::cout << \"Exiv2::Jp2Image::readMetadata: Ihdr data found\" << std::endl;\n#endif\n                            ihdr.imageHeight            = getLong((byte*)&ihdr.imageHeight, bigEndian);\n                            ihdr.imageWidth             = getLong((byte*)&ihdr.imageWidth, bigEndian);\n                            ihdr.componentCount         = getShort((byte*)&ihdr.componentCount, bigEndian);\n                            ihdr.compressionTypeProfile = getShort((byte*)&ihdr.compressionTypeProfile, bigEndian);\n\n                            pixelWidth_  = ihdr.imageWidth;\n                            pixelHeight_ = ihdr.imageHeight;\n                        }\n\n                        io_->seek(restore,BasicIo::beg);\n                        io_->seek(subBox.length, Exiv2::BasicIo::cur);\n                        restore = io_->tell();\n                    }\n                    break;\n                }\n\n                case kJp2BoxTypeUuid:\n                {\n#ifdef DEBUG\n                    std::cout << \"Exiv2::Jp2Image::readMetadata: UUID box found\" << std::endl;\n#endif\n\n                    if (io_->read((byte*)&uuid, sizeof(uuid)) == sizeof(uuid))\n                    {\n                        DataBuf rawData;\n                        long    bufRead;\n                        bool    bIsExif = memcmp(uuid.uuid, kJp2UuidExif, sizeof(uuid))==0;\n                        bool    bIsIPTC = memcmp(uuid.uuid, kJp2UuidIptc, sizeof(uuid))==0;\n                        bool    bIsXMP  = memcmp(uuid.uuid, kJp2UuidXmp , sizeof(uuid))==0;\n\n                        if(bIsExif)\n                        {\n#ifdef DEBUG\n                           std::cout << \"Exiv2::Jp2Image::readMetadata: Exif data found\" << std::endl ;\n#endif\n                            rawData.alloc(box.length - (sizeof(box) + sizeof(uuid)));\n                            bufRead = io_->read(rawData.pData_, rawData.size_);\n                            if (io_->error()) throw Error(kerFailedToReadImageData);\n                            if (bufRead != rawData.size_) throw Error(kerInputDataReadFailed);\n\n                            if (rawData.size_ > 0)\n                            {\n                                // Find the position of Exif header in bytes array.\n                                long pos = (     (rawData.pData_[0]      == rawData.pData_[1])\n                                           &&    (rawData.pData_[0]=='I' || rawData.pData_[0]=='M')\n                                           )  ? 0 : -1;\n\n                                // #1242  Forgive having Exif\\0\\0 in rawData.pData_\n                                const byte exifHeader[] = { 0x45, 0x78, 0x69, 0x66, 0x00, 0x00 };\n                                for (long i=0 ; pos < 0 && i < rawData.size_-(long)sizeof(exifHeader) ; i++)\n                                {\n                                    if (memcmp(exifHeader, &rawData.pData_[i], sizeof(exifHeader)) == 0)\n                                    {\n                                        pos = i+sizeof(exifHeader);\n#ifndef SUPPRESS_WARNINGS\n                                        EXV_WARNING << \"Reading non-standard UUID-EXIF_bad box in \" << io_->path() << std::endl;\n#endif\n\n                                    }\n                                }\n\n                                // If found it, store only these data at from this place.\n                                if (pos >= 0 )\n                                {\n#ifdef DEBUG\n                                    std::cout << \"Exiv2::Jp2Image::readMetadata: Exif header found at position \" << pos << std::endl;\n#endif\n                                    ByteOrder bo = TiffParser::decode(exifData(),\n                                                                      iptcData(),\n                                                                      xmpData(),\n                                                                      rawData.pData_ + pos,\n                                                                      rawData.size_ - pos);\n                                    setByteOrder(bo);\n                                }\n                            }\n                            else\n                            {\n#ifndef SUPPRESS_WARNINGS\n                                EXV_WARNING << \"Failed to decode Exif metadata.\" << std::endl;\n#endif\n                                exifData_.clear();\n                            }\n                        }\n\n                        if(bIsIPTC)\n                        {\n#ifdef DEBUG\n                           std::cout << \"Exiv2::Jp2Image::readMetadata: Iptc data found\" << std::endl;\n#endif\n                            rawData.alloc(box.length - (sizeof(box) + sizeof(uuid)));\n                            bufRead = io_->read(rawData.pData_, rawData.size_);\n                            if (io_->error()) throw Error(kerFailedToReadImageData);\n                            if (bufRead != rawData.size_) throw Error(kerInputDataReadFailed);\n\n                            if (IptcParser::decode(iptcData_, rawData.pData_, rawData.size_))\n                            {\n#ifndef SUPPRESS_WARNINGS\n                                EXV_WARNING << \"Failed to decode IPTC metadata.\" << std::endl;\n#endif\n                                iptcData_.clear();\n                            }\n                        }\n\n                        if(bIsXMP)\n                        {\n#ifdef DEBUG\n                           std::cout << \"Exiv2::Jp2Image::readMetadata: Xmp data found\" << std::endl;\n#endif\n                            rawData.alloc(box.length - (uint32_t)(sizeof(box) + sizeof(uuid)));\n                            bufRead = io_->read(rawData.pData_, rawData.size_);\n                            if (io_->error()) throw Error(kerFailedToReadImageData);\n                            if (bufRead != rawData.size_) throw Error(kerInputDataReadFailed);\n                            xmpPacket_.assign(reinterpret_cast<char *>(rawData.pData_), rawData.size_);\n\n                            std::string::size_type idx = xmpPacket_.find_first_of('<');\n                            if (idx != std::string::npos && idx > 0)\n                            {\n#ifndef SUPPRESS_WARNINGS\n                                EXV_WARNING << \"Removing \" << static_cast<uint32_t>(idx)\n                                            << \" characters from the beginning of the XMP packet\" << std::endl;\n#endif\n                                xmpPacket_ = xmpPacket_.substr(idx);\n                            }\n\n                            if (xmpPacket_.size() > 0 && XmpParser::decode(xmpData_, xmpPacket_))\n                            {\n#ifndef SUPPRESS_WARNINGS\n                                EXV_WARNING << \"Failed to decode XMP metadata.\" << std::endl;\n#endif\n                            }\n                        }\n                    }\n                    break;\n                }\n\n                default:\n                {\n                    break;\n                }\n            }\n\n            // Move to the next box.\n            io_->seek(static_cast<long>(position - sizeof(box) + box.length), BasicIo::beg);\n            if (io_->error()) throw Error(kerFailedToReadImageData);\n        }\n\n    }", "target": 1, "idx": 11847}
{"commit_id": "a86eb798d077b9b25c8f8c77e3c02c2f287c1ce7", "project": "android", "func": "IV_API_CALL_STATUS_T impeg2d_api_entity(iv_obj_t *ps_dechdl,\n                                        void *pv_api_ip,\n                                        void *pv_api_op)\n{\n    iv_obj_t *ps_dec_handle;\n    dec_state_t *ps_dec_state;\n    dec_state_multi_core_t *ps_dec_state_multi_core;\n\n    impeg2d_video_decode_ip_t    *ps_dec_ip;\n\n    impeg2d_video_decode_op_t    *ps_dec_op;\n    WORD32 bytes_remaining;\n    pic_buf_t *ps_disp_pic;\n\n\n\n    ps_dec_ip = (impeg2d_video_decode_ip_t    *)pv_api_ip;\n    ps_dec_op = (impeg2d_video_decode_op_t    *)pv_api_op;\n\n    memset(ps_dec_op,0,sizeof(impeg2d_video_decode_op_t));\n\n    ps_dec_op->s_ivd_video_decode_op_t.u4_size = sizeof(impeg2d_video_decode_op_t);\n    ps_dec_op->s_ivd_video_decode_op_t.u4_output_present = 0;\n    bytes_remaining = ps_dec_ip->s_ivd_video_decode_ip_t.u4_num_Bytes;\n\n    ps_dec_handle = (iv_obj_t *)ps_dechdl;\n\n    if(ps_dechdl == NULL)\n    {\n        return(IV_FAIL);\n    }\n\n\n\n    ps_dec_state_multi_core  = ps_dec_handle->pv_codec_handle;\n    ps_dec_state = ps_dec_state_multi_core->ps_dec_state[0];\n\n    ps_dec_state->ps_disp_frm_buf = &(ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf);\n    if(0 == ps_dec_state->u4_share_disp_buf)\n    {\n        ps_dec_state->ps_disp_frm_buf->pv_y_buf  = ps_dec_ip->s_ivd_video_decode_ip_t.s_out_buffer.pu1_bufs[0];\n        ps_dec_state->ps_disp_frm_buf->pv_u_buf  = ps_dec_ip->s_ivd_video_decode_ip_t.s_out_buffer.pu1_bufs[1];\n        ps_dec_state->ps_disp_frm_buf->pv_v_buf  = ps_dec_ip->s_ivd_video_decode_ip_t.s_out_buffer.pu1_bufs[2];\n    }\n\n    ps_dec_state->ps_disp_pic = NULL;\n    ps_dec_state->i4_frame_decoded = 0;\n    /*rest bytes consumed */\n    ps_dec_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = 0;\n\n    ps_dec_op->s_ivd_video_decode_op_t.u4_error_code           = IV_SUCCESS;\n\n    if((ps_dec_ip->s_ivd_video_decode_ip_t.pv_stream_buffer == NULL)&&(ps_dec_state->u1_flushfrm==0))\n    {\n        ps_dec_op->s_ivd_video_decode_op_t.u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n        ps_dec_op->s_ivd_video_decode_op_t.u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL;\n        return IV_FAIL;\n    }\n\n\n    if (ps_dec_state->u4_num_frames_decoded > NUM_FRAMES_LIMIT)\n    {\n        ps_dec_op->s_ivd_video_decode_op_t.u4_error_code       = IMPEG2D_SAMPLE_VERSION_LIMIT_ERR;\n        return(IV_FAIL);\n    }\n\n    if(((0 == ps_dec_state->u2_header_done) || (ps_dec_state->u2_decode_header == 1)) && (ps_dec_state->u1_flushfrm == 0))\n    {\n        impeg2d_dec_hdr(ps_dec_state,ps_dec_ip ,ps_dec_op);\n        bytes_remaining -= ps_dec_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed;\n    }\n\n    if((1 != ps_dec_state->u2_decode_header) &&\n        (((bytes_remaining > 0) && (1 == ps_dec_state->u2_header_done)) || ps_dec_state->u1_flushfrm))\n    {\n        if(ps_dec_state->u1_flushfrm)\n        {\n            if(ps_dec_state->aps_ref_pics[1] != NULL)\n            {\n                impeg2_disp_mgr_add(&ps_dec_state->s_disp_mgr, ps_dec_state->aps_ref_pics[1], ps_dec_state->aps_ref_pics[1]->i4_buf_id);\n                impeg2_buf_mgr_release(ps_dec_state->pv_pic_buf_mg, ps_dec_state->aps_ref_pics[1]->i4_buf_id, BUF_MGR_REF);\n                impeg2_buf_mgr_release(ps_dec_state->pv_pic_buf_mg, ps_dec_state->aps_ref_pics[0]->i4_buf_id, BUF_MGR_REF);\n\n                ps_dec_state->aps_ref_pics[1] = NULL;\n                ps_dec_state->aps_ref_pics[0] = NULL;\n\n            }\n            else if(ps_dec_state->aps_ref_pics[0] != NULL)\n            {\n                impeg2_disp_mgr_add(&ps_dec_state->s_disp_mgr, ps_dec_state->aps_ref_pics[0], ps_dec_state->aps_ref_pics[0]->i4_buf_id);\n                impeg2_buf_mgr_release(ps_dec_state->pv_pic_buf_mg, ps_dec_state->aps_ref_pics[0]->i4_buf_id, BUF_MGR_REF);\n\n                ps_dec_state->aps_ref_pics[0] = NULL;\n            }\n            ps_dec_ip->s_ivd_video_decode_ip_t.u4_size                 = sizeof(impeg2d_video_decode_ip_t);\n            ps_dec_op->s_ivd_video_decode_op_t.u4_size                 = sizeof(impeg2d_video_decode_op_t);\n\n            ps_disp_pic = impeg2_disp_mgr_get(&ps_dec_state->s_disp_mgr, &ps_dec_state->i4_disp_buf_id);\n\n            ps_dec_state->ps_disp_pic = ps_disp_pic;\n            if(ps_disp_pic == NULL)\n            {\n                ps_dec_op->s_ivd_video_decode_op_t.u4_output_present = 0;\n            }\n            else\n            {\n                WORD32 fmt_conv;\n                if(0 == ps_dec_state->u4_share_disp_buf)\n                {\n                    ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.pv_y_buf  = ps_dec_ip->s_ivd_video_decode_ip_t.s_out_buffer.pu1_bufs[0];\n                    ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.pv_u_buf  = ps_dec_ip->s_ivd_video_decode_ip_t.s_out_buffer.pu1_bufs[1];\n                    ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.pv_v_buf  = ps_dec_ip->s_ivd_video_decode_ip_t.s_out_buffer.pu1_bufs[2];\n                    fmt_conv = 1;\n                }\n                else\n                {\n                    ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.pv_y_buf  = ps_disp_pic->pu1_y;\n                    if(IV_YUV_420P == ps_dec_state->i4_chromaFormat)\n                    {\n                        ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.pv_u_buf  = ps_disp_pic->pu1_u;\n                        ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.pv_v_buf  = ps_disp_pic->pu1_v;\n                        fmt_conv = 0;\n                    }\n                    else\n                    {\n                        UWORD8 *pu1_buf;\n\n                        pu1_buf = ps_dec_state->as_disp_buffers[ps_disp_pic->i4_buf_id].pu1_bufs[1];\n                        ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.pv_u_buf  = pu1_buf;\n\n                        pu1_buf = ps_dec_state->as_disp_buffers[ps_disp_pic->i4_buf_id].pu1_bufs[2];\n                        ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.pv_v_buf  = pu1_buf;\n                        fmt_conv = 1;\n                    }\n                }\n\n                if(fmt_conv == 1)\n                {\n                    iv_yuv_buf_t *ps_dst;\n\n\n                    ps_dst = &(ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf);\n                    if(ps_dec_state->u4_deinterlace && (0 == ps_dec_state->u2_progressive_frame))\n                    {\n                        impeg2d_deinterlace(ps_dec_state,\n                                            ps_disp_pic,\n                                            ps_dst,\n                                            0,\n                                            ps_dec_state->u2_vertical_size);\n\n                    }\n                    else\n                    {\n                        impeg2d_format_convert(ps_dec_state,\n                                               ps_disp_pic,\n                                               ps_dst,\n                                               0,\n                                               ps_dec_state->u2_vertical_size);\n                    }\n                }\n\n                if(ps_dec_state->u4_deinterlace)\n                {\n                    if(ps_dec_state->ps_deint_pic)\n                    {\n                        impeg2_buf_mgr_release(ps_dec_state->pv_pic_buf_mg,\n                                               ps_dec_state->ps_deint_pic->i4_buf_id,\n                                               MPEG2_BUF_MGR_DEINT);\n                    }\n                    ps_dec_state->ps_deint_pic = ps_disp_pic;\n                }\n                if(0 == ps_dec_state->u4_share_disp_buf)\n                    impeg2_buf_mgr_release(ps_dec_state->pv_pic_buf_mg, ps_disp_pic->i4_buf_id, BUF_MGR_DISP);\n\n                ps_dec_op->s_ivd_video_decode_op_t.u4_pic_ht = ps_dec_state->u2_vertical_size;\n                ps_dec_op->s_ivd_video_decode_op_t.u4_pic_wd = ps_dec_state->u2_horizontal_size;\n                ps_dec_op->s_ivd_video_decode_op_t.u4_output_present = 1;\n\n                ps_dec_op->s_ivd_video_decode_op_t.u4_disp_buf_id = ps_disp_pic->i4_buf_id;\n                ps_dec_op->s_ivd_video_decode_op_t.u4_ts = ps_disp_pic->u4_ts;\n\n                ps_dec_op->s_ivd_video_decode_op_t.e_output_format = (IV_COLOR_FORMAT_T)ps_dec_state->i4_chromaFormat;\n\n                ps_dec_op->s_ivd_video_decode_op_t.u4_is_ref_flag = (B_PIC != ps_dec_state->e_pic_type);\n\n                ps_dec_op->s_ivd_video_decode_op_t.u4_progressive_frame_flag           = IV_PROGRESSIVE;\n\n                ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_y_wd = ps_dec_state->u2_horizontal_size;\n                ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_y_strd = ps_dec_state->u4_frm_buf_stride;\n                ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_y_ht = ps_dec_state->u2_vertical_size;\n\n                ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_u_wd = ps_dec_state->u2_horizontal_size >> 1;\n                ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_u_strd = ps_dec_state->u4_frm_buf_stride >> 1;\n                ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_u_ht = ps_dec_state->u2_vertical_size >> 1;\n\n                ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_v_wd = ps_dec_state->u2_horizontal_size >> 1;\n                ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_v_strd = ps_dec_state->u4_frm_buf_stride >> 1;\n                ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_v_ht = ps_dec_state->u2_vertical_size >> 1;\n                ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_size = sizeof(ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf);\n\n                switch(ps_dec_state->i4_chromaFormat)\n                {\n                    case IV_YUV_420SP_UV:\n                    case IV_YUV_420SP_VU:\n                        ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_u_wd = ps_dec_state->u2_horizontal_size;\n                        ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_u_strd = ps_dec_state->u4_frm_buf_stride;\n                    break;\n                    case IV_YUV_422ILE:\n                        ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_u_wd = 0;\n                        ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_u_ht = 0;\n                        ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_v_wd = 0;\n                        ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_v_ht = 0;\n                    break;\n                    default:\n                    break;\n                }\n\n\n            }\n            if(ps_dec_op->s_ivd_video_decode_op_t.u4_output_present)\n            {\n                if(1 == ps_dec_op->s_ivd_video_decode_op_t.u4_output_present)\n                {\n                    INSERT_LOGO(ps_dec_ip->s_ivd_video_decode_ip_t.s_out_buffer.pu1_bufs[0],\n                                ps_dec_ip->s_ivd_video_decode_ip_t.s_out_buffer.pu1_bufs[1],\n                                ps_dec_ip->s_ivd_video_decode_ip_t.s_out_buffer.pu1_bufs[2],\n                                ps_dec_state->u4_frm_buf_stride,\n                                ps_dec_state->u2_horizontal_size,\n                                ps_dec_state->u2_vertical_size,\n                                ps_dec_state->i4_chromaFormat,\n                                ps_dec_state->u2_horizontal_size,\n                                ps_dec_state->u2_vertical_size);\n                }\n                return(IV_SUCCESS);\n            }\n            else\n            {\n                ps_dec_state->u1_flushfrm = 0;\n\n                return(IV_FAIL);\n            }\n\n        }\n        else if(ps_dec_state->u1_flushfrm==0)\n        {\n            ps_dec_ip->s_ivd_video_decode_ip_t.u4_size                 = sizeof(impeg2d_video_decode_ip_t);\n            ps_dec_op->s_ivd_video_decode_op_t.u4_size                 = sizeof(impeg2d_video_decode_op_t);\n            if(ps_dec_ip->s_ivd_video_decode_ip_t.u4_num_Bytes < 4)\n            {\n                ps_dec_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = ps_dec_ip->s_ivd_video_decode_ip_t.u4_num_Bytes;\n                return(IV_FAIL);\n            }\n\n            if(1 == ps_dec_state->u4_share_disp_buf)\n            {\n                if(0 == impeg2_buf_mgr_check_free(ps_dec_state->pv_pic_buf_mg))\n                {\n                    ps_dec_op->s_ivd_video_decode_op_t.u4_error_code =\n                                    (IMPEG2D_ERROR_CODES_T)IVD_DEC_REF_BUF_NULL;\n                    return IV_FAIL;\n                }\n            }\n\n\n            ps_dec_op->s_ivd_video_decode_op_t.e_output_format = (IV_COLOR_FORMAT_T)ps_dec_state->i4_chromaFormat;\n\n            ps_dec_op->s_ivd_video_decode_op_t.u4_is_ref_flag = (B_PIC != ps_dec_state->e_pic_type);\n\n            ps_dec_op->s_ivd_video_decode_op_t.u4_progressive_frame_flag           = IV_PROGRESSIVE;\n\n            if (0 == ps_dec_state->u4_frm_buf_stride)\n            {\n                ps_dec_state->u4_frm_buf_stride = (ps_dec_state->u2_horizontal_size);\n            }\n\n            ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_y_wd = ps_dec_state->u2_horizontal_size;\n            ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_y_strd = ps_dec_state->u4_frm_buf_stride;\n            ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_y_ht = ps_dec_state->u2_vertical_size;\n\n            ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_u_wd = ps_dec_state->u2_horizontal_size >> 1;\n            ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_u_strd = ps_dec_state->u4_frm_buf_stride >> 1;\n            ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_u_ht = ps_dec_state->u2_vertical_size >> 1;\n\n            ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_v_wd = ps_dec_state->u2_horizontal_size >> 1;\n            ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_v_strd = ps_dec_state->u4_frm_buf_stride >> 1;\n            ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_v_ht = ps_dec_state->u2_vertical_size >> 1;\n            ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_size = sizeof(ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf);\n\n            switch(ps_dec_state->i4_chromaFormat)\n            {\n                case IV_YUV_420SP_UV:\n                case IV_YUV_420SP_VU:\n                    ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_u_wd = ps_dec_state->u2_horizontal_size;\n                    ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_u_strd = ps_dec_state->u4_frm_buf_stride;\n                break;\n                case IV_YUV_422ILE:\n                    ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_u_wd = 0;\n                    ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_u_ht = 0;\n                    ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_v_wd = 0;\n                    ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_v_ht = 0;\n                break;\n                default:\n                break;\n            }\n\n            if( ps_dec_state->u1_flushfrm == 0)\n            {\n                ps_dec_state->u1_flushcnt    = 0;\n\n                /*************************************************************************/\n                /*                              Frame Decode                             */\n                /*************************************************************************/\n\n                impeg2d_dec_frm(ps_dec_state,ps_dec_ip,ps_dec_op);\n\n                if (IVD_ERROR_NONE ==\n                        ps_dec_op->s_ivd_video_decode_op_t.u4_error_code)\n                {\n                    if(ps_dec_state->u1_first_frame_done == 0)\n                    {\n                        ps_dec_state->u1_first_frame_done = 1;\n                    }\n\n                    if(ps_dec_state->ps_disp_pic)\n                    {\n                        ps_dec_op->s_ivd_video_decode_op_t.u4_output_present = 1;\n                        switch(ps_dec_state->ps_disp_pic->e_pic_type)\n                        {\n                            case I_PIC :\n                            ps_dec_op->s_ivd_video_decode_op_t.e_pic_type = IV_I_FRAME;\n                            break;\n\n                            case P_PIC:\n                            ps_dec_op->s_ivd_video_decode_op_t.e_pic_type = IV_P_FRAME;\n                            break;\n\n                            case B_PIC:\n                            ps_dec_op->s_ivd_video_decode_op_t.e_pic_type = IV_B_FRAME;\n                            break;\n\n                            case D_PIC:\n                            ps_dec_op->s_ivd_video_decode_op_t.e_pic_type = IV_I_FRAME;\n                            break;\n\n                            default :\n                            ps_dec_op->s_ivd_video_decode_op_t.e_pic_type = IV_FRAMETYPE_DEFAULT;\n                            break;\n                        }\n                    }\n                    else\n                    {\n                        ps_dec_op->s_ivd_video_decode_op_t.u4_output_present = 0;\n                        ps_dec_op->s_ivd_video_decode_op_t.e_pic_type = IV_NA_FRAME;\n                    }\n\n                    ps_dec_state->u4_num_frames_decoded++;\n                }\n            }\n            else\n            {\n                ps_dec_state->u1_flushcnt++;\n            }\n        }\n        if(ps_dec_state->ps_disp_pic)\n        {\n            ps_dec_op->s_ivd_video_decode_op_t.u4_disp_buf_id = ps_dec_state->ps_disp_pic->i4_buf_id;\n            ps_dec_op->s_ivd_video_decode_op_t.u4_ts = ps_dec_state->ps_disp_pic->u4_ts;\n\n            if(0 == ps_dec_state->u4_share_disp_buf)\n            {\n                impeg2_buf_mgr_release(ps_dec_state->pv_pic_buf_mg, ps_dec_state->ps_disp_pic->i4_buf_id, BUF_MGR_DISP);\n            }\n        }\n\n        if(ps_dec_state->u4_deinterlace)\n        {\n            if(ps_dec_state->ps_deint_pic)\n            {\n                impeg2_buf_mgr_release(ps_dec_state->pv_pic_buf_mg,\n                                       ps_dec_state->ps_deint_pic->i4_buf_id,\n                                       MPEG2_BUF_MGR_DEINT);\n            }\n            ps_dec_state->ps_deint_pic = ps_dec_state->ps_disp_pic;\n        }\n\n        if(1 == ps_dec_op->s_ivd_video_decode_op_t.u4_output_present)\n        {\n            INSERT_LOGO(ps_dec_ip->s_ivd_video_decode_ip_t.s_out_buffer.pu1_bufs[0],\n                        ps_dec_ip->s_ivd_video_decode_ip_t.s_out_buffer.pu1_bufs[1],\n                        ps_dec_ip->s_ivd_video_decode_ip_t.s_out_buffer.pu1_bufs[2],\n                        ps_dec_state->u4_frm_buf_stride,\n                        ps_dec_state->u2_horizontal_size,\n                        ps_dec_state->u2_vertical_size,\n                        ps_dec_state->i4_chromaFormat,\n                        ps_dec_state->u2_horizontal_size,\n                        ps_dec_state->u2_vertical_size);\n        }\n\n    }\n\n    ps_dec_op->s_ivd_video_decode_op_t.u4_progressive_frame_flag = 1;\n    ps_dec_op->s_ivd_video_decode_op_t.e4_fld_type     = ps_dec_state->s_disp_op.e4_fld_type;\n\n\n    if(ps_dec_op->s_ivd_video_decode_op_t.u4_error_code)\n        return IV_FAIL;\n    else\n        return IV_SUCCESS;\n}", "target": 2, "idx": 11848}
{"commit_id": "70607fc71a671cf48a05e013a4e411429373dce7", "project": "gpac", "func": "GF_Err naludmx_set_hevc_oinf(GF_NALUDmxCtx *ctx, u8 *max_temporal_id)\n{\n\tGF_OperatingPointsInformation *oinf;\n\tGF_BitStream *bs;\n\tu8 *data;\n\tu32 data_size;\n\tu32 i;\n\tHEVC_VPS *vps;\n\tGF_NALUFFParam *vps_sl = gf_list_get(ctx->vps, 0);\n\tif (!vps_sl) return GF_SERVICE_ERROR;\n\n\tvps = &ctx->hevc_state->vps[vps_sl->id];\n\n\tif (!vps->vps_extension_found) return GF_OK;\n\tif (vps->max_layers<2) return GF_OK;\n\n\toinf = gf_isom_oinf_new_entry();\n\tif (!oinf) return GF_OUT_OF_MEM;\n\n\toinf->scalability_mask = 0;\n\tfor (i = 0; i < 16; i++) {\n\t\tif (vps->scalability_mask[i])\n\t\t\toinf->scalability_mask |= 1 << i;\n\t}\n\n\tfor (i = 0; i < vps->num_profile_tier_level; i++) {\n\t\tHEVC_ProfileTierLevel ptl = (i == 0) ? vps->ptl : vps->ext_ptl[i-1];\n\t\tLHEVC_ProfileTierLevel *lhevc_ptl;\n\t\tGF_SAFEALLOC(lhevc_ptl, LHEVC_ProfileTierLevel);\n\t\tif (!lhevc_ptl) return GF_OUT_OF_MEM;\n\n\t\tlhevc_ptl->general_profile_space = ptl.profile_space;\n\t\tlhevc_ptl->general_tier_flag = ptl.tier_flag;\n\t\tlhevc_ptl->general_profile_idc = ptl.profile_idc;\n\t\tlhevc_ptl->general_profile_compatibility_flags = ptl.profile_compatibility_flag;\n\t\tlhevc_ptl->general_constraint_indicator_flags = 0;\n\t\tif (ptl.general_progressive_source_flag)\n\t\t\tlhevc_ptl->general_constraint_indicator_flags |= ((u64)1) << 47;\n\t\tif (ptl.general_interlaced_source_flag)\n\t\t\tlhevc_ptl->general_constraint_indicator_flags |= ((u64)1) << 46;\n\t\tif (ptl.general_non_packed_constraint_flag)\n\t\t\tlhevc_ptl->general_constraint_indicator_flags |= ((u64)1) << 45;\n\t\tif (ptl.general_frame_only_constraint_flag)\n\t\t\tlhevc_ptl->general_constraint_indicator_flags |= ((u64)1) << 44;\n\t\tlhevc_ptl->general_constraint_indicator_flags |= ptl.general_reserved_44bits;\n\t\tlhevc_ptl->general_level_idc = ptl.level_idc;\n\t\tgf_list_add(oinf->profile_tier_levels, lhevc_ptl);\n\t}\n\n\tfor (i = 0; i < vps->num_output_layer_sets; i++) {\n\t\tLHEVC_OperatingPoint *op;\n\t\tu32 j;\n\t\tu16 minPicWidth, minPicHeight, maxPicWidth, maxPicHeight;\n\t\tu8 maxChromaFormat, maxBitDepth;\n\t\tu8 maxTemporalId;\n\t\tGF_SAFEALLOC(op, LHEVC_OperatingPoint);\n\t\tif (!op) return GF_OUT_OF_MEM;\n\n\t\top->output_layer_set_idx = i;\n\t\top->layer_count = vps->num_necessary_layers[i];\n\t\tminPicWidth = minPicHeight = maxPicWidth = maxPicHeight = maxTemporalId = 0;\n\t\tmaxChromaFormat = maxBitDepth = 0;\n\t\tfor (j = 0; j < op->layer_count; j++) {\n\t\t\tu32 format_idx;\n\t\t\tu32 bitDepth;\n\t\t\top->layers_info[j].ptl_idx = vps->profile_tier_level_idx[i][j];\n\t\t\top->layers_info[j].layer_id = j;\n\t\t\top->layers_info[j].is_outputlayer = vps->output_layer_flag[i][j];\n\t\t\t//FIXME: we consider that this flag is never set\n\t\t\top->layers_info[j].is_alternate_outputlayer = GF_FALSE;\n\n\t\t\tif (max_temporal_id) {\n\t\t\t\tif (!maxTemporalId || (maxTemporalId < max_temporal_id[op->layers_info[j].layer_id]))\n\t\t\t\t\tmaxTemporalId = max_temporal_id[op->layers_info[j].layer_id];\n\t\t\t} else {\n\t\t\t\tmaxTemporalId = vps->max_sub_layers;\n\t\t\t}\n\n\t\t\tformat_idx = vps->rep_format_idx[op->layers_info[j].layer_id];\n\t\t\tif (!minPicWidth || (minPicWidth > vps->rep_formats[format_idx].pic_width_luma_samples))\n\t\t\t\tminPicWidth = vps->rep_formats[format_idx].pic_width_luma_samples;\n\t\t\tif (!minPicHeight || (minPicHeight > vps->rep_formats[format_idx].pic_height_luma_samples))\n\t\t\t\tminPicHeight = vps->rep_formats[format_idx].pic_height_luma_samples;\n\t\t\tif (!maxPicWidth || (maxPicWidth < vps->rep_formats[format_idx].pic_width_luma_samples))\n\t\t\t\tmaxPicWidth = vps->rep_formats[format_idx].pic_width_luma_samples;\n\t\t\tif (!maxPicHeight || (maxPicHeight < vps->rep_formats[format_idx].pic_height_luma_samples))\n\t\t\t\tmaxPicHeight = vps->rep_formats[format_idx].pic_height_luma_samples;\n\t\t\tif (!maxChromaFormat || (maxChromaFormat < vps->rep_formats[format_idx].chroma_format_idc))\n\t\t\t\tmaxChromaFormat = vps->rep_formats[format_idx].chroma_format_idc;\n\t\t\tbitDepth = vps->rep_formats[format_idx].bit_depth_chroma > vps->rep_formats[format_idx].bit_depth_luma ? vps->rep_formats[format_idx].bit_depth_chroma : vps->rep_formats[format_idx].bit_depth_luma;\n\t\t\tif (!maxChromaFormat || (maxChromaFormat < bitDepth))\n\t\t\t\tmaxChromaFormat = bitDepth;\n\t\t}\n\t\top->max_temporal_id = maxTemporalId;\n\t\top->minPicWidth = minPicWidth;\n\t\top->minPicHeight = minPicHeight;\n\t\top->maxPicWidth = maxPicWidth;\n\t\top->maxPicHeight = maxPicHeight;\n\t\top->maxChromaFormat = maxChromaFormat;\n\t\top->maxBitDepth = maxBitDepth;\n\t\top->frame_rate_info_flag = GF_FALSE; //FIXME: should fetch this info from VUI\n\t\top->bit_rate_info_flag = GF_FALSE; //we don't use it\n\t\tgf_list_add(oinf->operating_points, op);\n\t}\n\n\tfor (i = 0; i < vps->max_layers; i++) {\n\t\tLHEVC_DependentLayer *dep;\n\t\tu32 j, k;\n\t\tGF_SAFEALLOC(dep, LHEVC_DependentLayer);\n\t\tif (!dep) return GF_OUT_OF_MEM;\n\n\t\tdep->dependent_layerID = vps->layer_id_in_nuh[i];\n\t\tfor (j = 0; j < vps->max_layers; j++) {\n\t\t\tif (vps->direct_dependency_flag[dep->dependent_layerID][j]) {\n\t\t\t\tdep->dependent_on_layerID[dep->num_layers_dependent_on] = j;\n\t\t\t\tdep->num_layers_dependent_on ++;\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (j = 0; j < 16; j++) {\n\t\t\tif (oinf->scalability_mask & (1 << j)) {\n\t\t\t\tdep->dimension_identifier[j] = vps->dimension_id[i][k];\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\tgf_list_add(oinf->dependency_layers, dep);\n\t}\n\n\t//write Operating Points Information Sample Group\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_isom_oinf_write_entry(oinf, bs);\n\tgf_bs_get_content(bs, &data, &data_size);\n\tgf_bs_del(bs);\n\tgf_isom_oinf_del_entry(oinf);\n\n\tgf_filter_pid_set_info_str(ctx->opid, \"hevc:oinf\", &PROP_DATA_NO_COPY(data, data_size) );\n\treturn GF_OK;\n}", "target": 1, "idx": 11849}
{"commit_id": "4fe3dde35e51608ae4c10c321b51645703dc7e13", "project": "pete4abw/lrzip-next", "func": "void *open_stream_in(rzip_control *control, int f, int n, char chunk_bytes)\n{\n\tstruct uncomp_thread *ucthreads;\n\tstruct stream_info *sinfo;\n\tint total_threads, i;\n\tpthread_t *threads;\n\ti64 header_length;\n\n\tsinfo = calloc(sizeof(struct stream_info), 1);\n\tif (unlikely(!sinfo))\n\t\treturn NULL;\n\n\t/* We have one thread dedicated to stream 0, and one more thread than\n\t * CPUs to keep them busy, unless we're running single-threaded. */\n\tif (control->threads > 1)\n\t\ttotal_threads = control->threads + 2;\n\telse\n\t\ttotal_threads = control->threads + 1;\n\tthreads = control->pthreads = calloc(sizeof(pthread_t), total_threads);\n\tif (unlikely(!threads))\n\t\treturn NULL;\n\n\tsinfo->ucthreads = ucthreads = calloc(sizeof(struct uncomp_thread), total_threads);\n\tif (unlikely(!ucthreads)) {\n\t\tdealloc(sinfo);\n\t\tdealloc(threads);\n\t\tfatal(\"Unable to calloc ucthreads in open_stream_in\\n\");\n\t}\n\n\tsinfo->num_streams = n;\n\tsinfo->fd = f;\n\tsinfo->chunk_bytes = chunk_bytes;\n\n\tsinfo->s = calloc(sizeof(struct stream), n);\n\tif (unlikely(!sinfo->s)) {\n\t\tdealloc(sinfo);\n\t\tdealloc(threads);\n\t\tdealloc(ucthreads);\n\t\treturn NULL;\n\t}\n\n\tsinfo->s[0].total_threads = 1;\n\tsinfo->s[1].total_threads = total_threads - 1;\n\n\t/* remove checks for lrzip < 0.6 */\n\tif (control->major_version == 0) {\n\t\t/* Read in flag that tells us if there are more chunks after\n\t\t * this. Ignored if we know the final file size */\n\t\tprint_maxverbose(\"Reading eof flag at %'\"PRId64\"\\n\", get_readseek(control, f));\n\t\tif (unlikely(read_u8(control, f, &control->eof))) {\n\t\t\tprint_err(\"Failed to read eof flag in open_stream_in\\n\");\n\t\t\tgoto failed;\n\t\t}\n\t\tprint_maxverbose(\"EOF: %'d\\n\", control->eof);\n\n\t\t/* Read in the expected chunk size */\n\t\tif (!ENCRYPT) {\n\t\t\tprint_maxverbose(\"Reading expected chunksize at %'\"PRId64\"\\n\", get_readseek(control, f));\n\t\t\tif (unlikely(read_val(control, f, &sinfo->size, sinfo->chunk_bytes))) {\n\t\t\t\tprint_err(\"Failed to read in chunk size in open_stream_in\\n\");\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t\tsinfo->size = le64toh(sinfo->size);\n\t\t\tif (sinfo->size)\n\t\t\t\tprint_maxverbose(\"Chunk size: %'\"PRId64\"\\n\", sinfo->size);\n\t\t\telse\n\t\t\t\t/* FIXME need this to not show 0 bytes for chunk size */\n\t\t\t\tprint_maxverbose(\"Chunk size: smaller than 4,096 bytes\\n\");\n\t\t\tcontrol->st_size += sinfo->size;\n\t\t\tif (unlikely(sinfo->chunk_bytes < 1 || sinfo->chunk_bytes > 8 || sinfo->size < 0)) {\n\t\t\t\tprint_err(\"Invalid chunk data size %'\"PRId64\" bytes %d\\n\", sinfo->size, sinfo->chunk_bytes);\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t}\n\t}\n\tsinfo->initial_pos = get_readseek(control, f);\n\tif (unlikely(sinfo->initial_pos == -1))\n\t\tgoto failed;\n\n\tfor (i = 0; i < n; i++) {\n\t\tuchar c, enc_head[25 + SALT_LEN];\n\t\ti64 v1, v2;\n\n\t\tsinfo->s[i].base_thread = i;\n\t\tsinfo->s[i].uthread_no = sinfo->s[i].base_thread;\n\t\tsinfo->s[i].unext_thread = sinfo->s[i].base_thread;\n\n\t\tif (unlikely(ENCRYPT && read_buf(control, f, enc_head, SALT_LEN)))\n\t\t\tgoto failed;\nagain:\n\t\tif (unlikely(read_u8(control, f, &c)))\n\t\t\tgoto failed;\n\n\t\t/* remove checks for lrzip < 0.6 */\n\t\tif (control->major_version == 0) {\n\t\t\tint read_len;\n\n\t\t\tprint_maxverbose(\"Reading stream %'d header at %'\"PRId64\"\\n\", i, get_readseek(control, f));\n\t\t\tif (ENCRYPT)\n\t\t\t\tread_len = 8;\n\t\t\telse\n\t\t\t\tread_len = sinfo->chunk_bytes;\n\t\t\tif (unlikely(read_val(control, f, &v1, read_len)))\n\t\t\t\tgoto failed;\n\t\t\tif (unlikely(read_val(control, f, &v2, read_len)))\n\t\t\t\tgoto failed;\n\t\t\tif (unlikely(read_val(control, f, &sinfo->s[i].last_head, read_len)))\n\t\t\t\tgoto failed;\n\t\t\theader_length = 1 + (read_len * 3);\n\t\t}\n\t\tsinfo->total_read += header_length;\n\n\t\tif (ENCRYPT) {\n\t\t\t// pass decrypt flag instead of validate flag\n\t\t\tif (unlikely(!decrypt_header(control, enc_head, &c, &v1, &v2, &sinfo->s[i].last_head, LRZ_DECRYPT)))\n\t\t\t\tgoto failed;\n\t\t\tsinfo->total_read += SALT_LEN;\n\t\t}\n\n\t\tv1 = le64toh(v1);\n\t\tv2 = le64toh(v2);\n\t\tsinfo->s[i].last_head = le64toh(sinfo->s[i].last_head);\n\n\t\tif (unlikely(c == CTYPE_NONE && v1 == 0 && v2 == 0 && sinfo->s[i].last_head == 0 && i == 0)) {\n\t\t\tprint_err(\"Enabling stream close workaround\\n\");\n\t\t\tsinfo->initial_pos += header_length;\n\t\t\tgoto again;\n\t\t}\n\n\t\tif (unlikely(c != CTYPE_NONE)) {\n\t\t\tprint_err(\"Unexpected initial tag %'d in streams\\n\", c);\n\t\t\tif (ENCRYPT)\n\t\t\t\tprint_err(\"Wrong password?\\n\");\n\t\t\tgoto failed;\n\t\t}\n\t\t/* protect again 0 length c_ and u_ len */\n\t\tif (v1 < 1) {\n\t\t\tprint_err(\"Unexpected initial c_len %'\"PRId64\" in streams %'\"PRId64\"\\n\", v1, v2);\n\t\t\tgoto failed;\n\t\t}\n\t\tif (v2 < 1) {\n\t\t\tprint_err(\"Unexpected initial u_len %'\"PRId64\" in streams\\n\", v2);\n\t\t\tgoto failed;\n\t\t}\n\t}\n\n\treturn (void *)sinfo;\n\nfailed:\n\tdealloc(sinfo->s);\n\tdealloc(sinfo);\n\tdealloc(threads);\n\tdealloc(ucthreads);\n\treturn NULL;\n}", "target": 1, "idx": 11850}
{"commit_id": "9723dd0955894f2cb7be13b94cf7a47f2754b893", "project": "gpac", "func": "void gf_dom_event_remove_all_listeners(GF_DOMEventTarget *event_target, GF_SceneGraph *sg)\n{\n\twhile (gf_list_count(event_target->listeners)) {\n\t\tGF_Node *n = (GF_Node *)gf_list_get(event_target->listeners, 0);\n\t\tif (gf_list_find(sg->exported_nodes, n)>=0) {\n\t\t\tgf_list_rem(event_target->listeners, 0);\n\t\t} else {\n\t\t\tgf_dom_listener_del(n, event_target);\n\t\t}\n\t}\n}", "target": 1, "idx": 11851}
{"commit_id": "9a8b9fb49108bab5d12f3353292f8fd8ea12898f", "project": "LibreDWG/libredwg", "func": "static void\ndwg_free_eed(Dwg_Object* obj)\n{\n  unsigned int i;\n  if (obj->supertype == DWG_SUPERTYPE_OBJECT) {\n    Dwg_Object_Object* _obj = obj->tio.object;\n    for (i=0; i < _obj->num_eed; i++) {\n      if (_obj->eed[i].size)\n        FREE_IF(_obj->eed[i].raw);\n      FREE_IF(_obj->eed[i].data);\n    }\n    FREE_IF(_obj->eed);\n  }\n  else if (obj->supertype == DWG_SUPERTYPE_ENTITY) {\n    Dwg_Object_Entity* _obj = obj->tio.entity;\n    for (i=0; i < _obj->num_eed; i++) {\n      if (_obj->eed[i].size)\n        FREE_IF(_obj->eed[i].raw);\n      FREE_IF(_obj->eed[i].data);\n    }\n    FREE_IF(_obj->eed);\n  }\n}", "target": 1, "idx": 11852}
{"commit_id": "54d83fc74aa9ec72794373cb47432c5f7fb1a309", "project": "torvalds/linux", "func": "static int\ncheck_entry_size_and_hooks(struct ipt_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct ipt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ipt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct ipt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 2, "idx": 11853}
{"commit_id": "4d45a96e57fbabf00a7378b337d0ddcace6f38c1", "project": "ArtifexSoftware/mujs", "func": "static js_Ast *conditional(js_State *J, int notin)\n{\n\tjs_Ast *a = logor(J, notin);\n\tif (jsP_accept(J, '?')) {\n\t\tjs_Ast *b, *c;\n\t\tINCREC();\n\t\tb = assignment(J, 0);\n\t\tjsP_expect(J, ':');\n\t\tc = assignment(J, notin);\n\t\tDECREC();\n\t\treturn EXP3(COND, a, b, c);\n\t}\n\treturn a;\n}", "target": 1, "idx": 11854}
{"commit_id": "4705dbdde2f32ff90420765cd93e7ac71d81a222", "project": "tcltk/tcl", "func": "static int\nSubstituteFile(\n    const char *substitutions,\n    const char *filename)\n{\n    size_t cbBuffer = 1024;\n    static char szBuffer[1024], szCopy[1024];\n    char *szResult = NULL;\n    list_item_t *substPtr = NULL;\n    FILE *fp, *sp;\n\n    fp = fopen(filename, \"rt\");\n    if (fp != NULL) {\n\n\t/*\n\t * Build a list of substutitions from the first filename\n\t */\n\n\tsp = fopen(substitutions, \"rt\");\n\tif (sp != NULL) {\n\t    while (fgets(szBuffer, cbBuffer, sp) != NULL) {\n\t\tunsigned char *ks, *ke, *vs, *ve;\n\t\tks = (unsigned char*)szBuffer;\n\t\twhile (ks && *ks && isspace(*ks)) ++ks;\n\t\tke = ks;\n\t\twhile (ke && *ke && !isspace(*ke)) ++ke;\n\t\tvs = ke;\n\t\twhile (vs && *vs && isspace(*vs)) ++vs;\n\t\tve = vs;\n\t\twhile (ve && *ve && !(*ve == '\\r' || *ve == '\\n')) ++ve;\n\t\t*ke = 0, *ve = 0;\n\t\tlist_insert(&substPtr, (char*)ks, (char*)vs);\n\t    }\n\t    fclose(sp);\n\t}\n\n\t/* debug: dump the list */\n#ifndef NDEBUG\n\t{\n\t    int n = 0;\n\t    list_item_t *p = NULL;\n\t    for (p = substPtr; p != NULL; p = p->nextPtr, ++n) {\n\t\tfprintf(stderr, \"% 3d '%s' => '%s'\\n\", n, p->key, p->value);\n\t    }\n\t}\n#endif\n\n\t/*\n\t * Run the substitutions over each line of the input\n\t */\n\n\twhile (fgets(szBuffer, cbBuffer, fp) != NULL) {\n\t    list_item_t *p = NULL;\n\t    for (p = substPtr; p != NULL; p = p->nextPtr) {\n\t\tchar *m = strstr(szBuffer, p->key);\n\t\tif (m) {\n\t\t    char *cp, *op, *sp;\n\t\t    cp = szCopy;\n\t\t    op = szBuffer;\n\t\t    while (op != m) *cp++ = *op++;\n\t\t    sp = p->value;\n\t\t    while (sp && *sp) *cp++ = *sp++;\n\t\t    op += strlen(p->key);\n\t\t    while (*op) *cp++ = *op++;\n\t\t    *cp = 0;\n\t\t    memcpy(szBuffer, szCopy, sizeof(szCopy));\n\t\t}\n\t    }\n\t    printf(\"%s\", szBuffer);\n\t}\n\n\tlist_free(&substPtr);\n    }\n    fclose(fp);\n    return 0;\n}", "target": 2, "idx": 11855}
{"commit_id": "3c939e3f69955d087e0bb671868f7267dfb2a502", "project": "php/php-src", "func": "static void load_wsdl_ex(zval *this_ptr, char *struri, sdlCtx *ctx, int include)\n{\n\tsdlPtr tmpsdl = ctx->sdl;\n\txmlDocPtr wsdl;\n\txmlNodePtr root, definitions, trav;\n\txmlAttrPtr targetNamespace;\n\n\tif (zend_hash_str_exists(&ctx->docs, struri, strlen(struri))) {\n\t\treturn;\n\t}\n\n\tsdl_set_uri_credentials(ctx, struri);\n\twsdl = soap_xmlParseFile(struri);\n\tsdl_restore_uri_credentials(ctx);\n\n\tif (!wsdl) {\n\t\txmlErrorPtr xmlErrorPtr = xmlGetLastError();\n\n\t\tif (xmlErrorPtr) {\n\t\t\tsoap_error2(E_ERROR, \"Parsing WSDL: Couldn't load from '%s' : %s\", struri, xmlErrorPtr->message);\n\t\t} else {\n\t\t\tsoap_error1(E_ERROR, \"Parsing WSDL: Couldn't load from '%s'\", struri);\n\t\t}\n\t}\n\n\tzend_hash_str_add_ptr(&ctx->docs, struri, strlen(struri), wsdl);\n\n\troot = wsdl->children;\n\tdefinitions = get_node_ex(root, \"definitions\", WSDL_NAMESPACE);\n\tif (!definitions) {\n\t\tif (include) {\n\t\t\txmlNodePtr schema = get_node_ex(root, \"schema\", XSD_NAMESPACE);\n\t\t\tif (schema) {\n\t\t\t\tload_schema(ctx, schema);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tsoap_error1(E_ERROR, \"Parsing WSDL: Couldn't find <definitions> in '%s'\", struri);\n\t}\n\n\tif (!include) {\n\t\ttargetNamespace = get_attribute(definitions->properties, \"targetNamespace\");\n\t\tif (targetNamespace) {\n\t\t\ttmpsdl->target_ns = estrdup((char*)targetNamespace->children->content);\n\t\t}\n\t}\n\n\ttrav = definitions->children;\n\twhile (trav != NULL) {\n\t\tif (!is_wsdl_element(trav)) {\n\t\t\ttrav = trav->next;\n\t\t\tcontinue;\n\t\t}\n\t\tif (node_is_equal(trav,\"types\")) {\n\t\t\t/* TODO: Only one \"types\" is allowed */\n\t\t\txmlNodePtr trav2 = trav->children;\n\n\t\t\twhile (trav2 != NULL) {\n\t\t\t\tif (node_is_equal_ex(trav2, \"schema\", XSD_NAMESPACE)) {\n\t\t\t\t\tload_schema(ctx, trav2);\n\t\t\t\t} else if (is_wsdl_element(trav2) && !node_is_equal(trav2,\"documentation\")) {\n\t\t\t\t\tsoap_error1(E_ERROR, \"Parsing WSDL: Unexpected WSDL element <%s>\", SAFE_STR(trav2->name));\n\t\t\t\t}\n\t\t\t\ttrav2 = trav2->next;\n\t\t\t}\n\t\t} else if (node_is_equal(trav,\"import\")) {\n\t\t\t/* TODO: namespace ??? */\n\t\t\txmlAttrPtr tmp = get_attribute(trav->properties, \"location\");\n\t\t\tif (tmp) {\n\t\t\t\txmlChar *uri;\n\t\t\t\txmlChar *base = xmlNodeGetBase(trav->doc, trav);\n\n\t\t\t\tif (base == NULL) {\n\t\t\t\t\turi = xmlBuildURI(tmp->children->content, trav->doc->URL);\n\t\t\t\t} else {\n\t\t\t\t\turi = xmlBuildURI(tmp->children->content, base);\n\t\t\t\t\txmlFree(base);\n\t\t\t\t}\n\t\t\t\tload_wsdl_ex(this_ptr, (char*)uri, ctx, 1);\n\t\t\t\txmlFree(uri);\n\t\t\t}\n\n\t\t} else if (node_is_equal(trav,\"message\")) {\n\t\t\txmlAttrPtr name = get_attribute(trav->properties, \"name\");\n\t\t\tif (name && name->children && name->children->content) {\n\t\t\t\tif (zend_hash_str_add_ptr(&ctx->messages, (char*)name->children->content, xmlStrlen(name->children->content), trav) == NULL) {\n\t\t\t\t\tsoap_error1(E_ERROR, \"Parsing WSDL: <message> '%s' already defined\", name->children->content);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsoap_error0(E_ERROR, \"Parsing WSDL: <message> has no name attribute\");\n\t\t\t}\n\n\t\t} else if (node_is_equal(trav,\"portType\")) {\n\t\t\txmlAttrPtr name = get_attribute(trav->properties, \"name\");\n\t\t\tif (name && name->children && name->children->content) {\n\t\t\t\tif (zend_hash_str_add_ptr(&ctx->portTypes, (char*)name->children->content, xmlStrlen(name->children->content), trav) == NULL) {\n\t\t\t\t\tsoap_error1(E_ERROR, \"Parsing WSDL: <portType> '%s' already defined\", name->children->content);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsoap_error0(E_ERROR, \"Parsing WSDL: <portType> has no name attribute\");\n\t\t\t}\n\n\t\t} else if (node_is_equal(trav,\"binding\")) {\n\t\t\txmlAttrPtr name = get_attribute(trav->properties, \"name\");\n\t\t\tif (name && name->children && name->children->content) {\n\t\t\t\tif (zend_hash_str_add_ptr(&ctx->bindings, (char*)name->children->content, xmlStrlen(name->children->content), trav) == NULL) {\n\t\t\t\t\tsoap_error1(E_ERROR, \"Parsing WSDL: <binding> '%s' already defined\", name->children->content);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsoap_error0(E_ERROR, \"Parsing WSDL: <binding> has no name attribute\");\n\t\t\t}\n\n\t\t} else if (node_is_equal(trav,\"service\")) {\n\t\t\txmlAttrPtr name = get_attribute(trav->properties, \"name\");\n\t\t\tif (name && name->children && name->children->content) {\n\t\t\t\tif (zend_hash_str_add_ptr(&ctx->services, (char*)name->children->content, xmlStrlen(name->children->content), trav) == NULL) {\n\t\t\t\t\tsoap_error1(E_ERROR, \"Parsing WSDL: <service> '%s' already defined\", name->children->content);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsoap_error0(E_ERROR, \"Parsing WSDL: <service> has no name attribute\");\n\t\t\t}\n\t\t} else if (!node_is_equal(trav,\"documentation\")) {\n\t\t\tsoap_error1(E_ERROR, \"Parsing WSDL: Unexpected WSDL element <%s>\",  SAFE_STR(trav->name));\n\t\t}\n\t\ttrav = trav->next;\n\t}\n}", "target": 1, "idx": 11856}
{"commit_id": "22cf8419f1319ff87ec759d0ebdff4cbafaee832", "project": "torvalds/linux", "func": "__be32\ndo_nfsd_create(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tchar *fname, int flen, struct iattr *iap,\n\t\tstruct svc_fh *resfhp, int createmode, u32 *verifier,\n\t        bool *truncp, bool *created)\n{\n\tstruct dentry\t*dentry, *dchild = NULL;\n\tstruct inode\t*dirp;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\t__u32\t\tv_mtime=0, v_atime=0;\n\n\terr = nfserr_perm;\n\tif (!flen)\n\t\tgoto out;\n\terr = nfserr_exist;\n\tif (isdotent(fname, flen))\n\t\tgoto out;\n\tif (!(iap->ia_valid & ATTR_MODE))\n\t\tiap->ia_mode = 0;\n\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_EXEC);\n\tif (err)\n\t\tgoto out;\n\n\tdentry = fhp->fh_dentry;\n\tdirp = d_inode(dentry);\n\n\thost_err = fh_want_write(fhp);\n\tif (host_err)\n\t\tgoto out_nfserr;\n\n\tfh_lock_nested(fhp, I_MUTEX_PARENT);\n\n\t/*\n\t * Compose the response file handle.\n\t */\n\tdchild = lookup_one_len(fname, dentry, flen);\n\thost_err = PTR_ERR(dchild);\n\tif (IS_ERR(dchild))\n\t\tgoto out_nfserr;\n\n\t/* If file doesn't exist, check for permissions to create one */\n\tif (d_really_is_negative(dchild)) {\n\t\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_CREATE);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = fh_compose(resfhp, fhp->fh_export, dchild, fhp);\n\tif (err)\n\t\tgoto out;\n\n\tif (nfsd_create_is_exclusive(createmode)) {\n\t\t/* solaris7 gets confused (bugid 4218508) if these have\n\t\t * the high bit set, so just clear the high bits. If this is\n\t\t * ever changed to use different attrs for storing the\n\t\t * verifier, then do_open_lookup() will also need to be fixed\n\t\t * accordingly.\n\t\t */\n\t\tv_mtime = verifier[0]&0x7fffffff;\n\t\tv_atime = verifier[1]&0x7fffffff;\n\t}\n\t\n\tif (d_really_is_positive(dchild)) {\n\t\terr = 0;\n\n\t\tswitch (createmode) {\n\t\tcase NFS3_CREATE_UNCHECKED:\n\t\t\tif (! d_is_reg(dchild))\n\t\t\t\tgoto out;\n\t\t\telse if (truncp) {\n\t\t\t\t/* in nfsv4, we need to treat this case a little\n\t\t\t\t * differently.  we don't want to truncate the\n\t\t\t\t * file now; this would be wrong if the OPEN\n\t\t\t\t * fails for some other reason.  furthermore,\n\t\t\t\t * if the size is nonzero, we should ignore it\n\t\t\t\t * according to spec!\n\t\t\t\t */\n\t\t\t\t*truncp = (iap->ia_valid & ATTR_SIZE) && !iap->ia_size;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tiap->ia_valid &= ATTR_SIZE;\n\t\t\t\tgoto set_attr;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NFS3_CREATE_EXCLUSIVE:\n\t\t\tif (   d_inode(dchild)->i_mtime.tv_sec == v_mtime\n\t\t\t    && d_inode(dchild)->i_atime.tv_sec == v_atime\n\t\t\t    && d_inode(dchild)->i_size  == 0 ) {\n\t\t\t\tif (created)\n\t\t\t\t\t*created = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* fall through */\n\t\tcase NFS4_CREATE_EXCLUSIVE4_1:\n\t\t\tif (   d_inode(dchild)->i_mtime.tv_sec == v_mtime\n\t\t\t    && d_inode(dchild)->i_atime.tv_sec == v_atime\n\t\t\t    && d_inode(dchild)->i_size  == 0 ) {\n\t\t\t\tif (created)\n\t\t\t\t\t*created = true;\n\t\t\t\tgoto set_attr;\n\t\t\t}\n\t\t\t/* fall through */\n\t\tcase NFS3_CREATE_GUARDED:\n\t\t\terr = nfserr_exist;\n\t\t}\n\t\tfh_drop_write(fhp);\n\t\tgoto out;\n\t}\n\n\tif (!IS_POSIXACL(dirp))\n\t\tiap->ia_mode &= ~current_umask();\n\n\thost_err = vfs_create(dirp, dchild, iap->ia_mode, true);\n\tif (host_err < 0) {\n\t\tfh_drop_write(fhp);\n\t\tgoto out_nfserr;\n\t}\n\tif (created)\n\t\t*created = true;\n\n\tnfsd_check_ignore_resizing(iap);\n\n\tif (nfsd_create_is_exclusive(createmode)) {\n\t\t/* Cram the verifier into atime/mtime */\n\t\tiap->ia_valid = ATTR_MTIME|ATTR_ATIME\n\t\t\t| ATTR_MTIME_SET|ATTR_ATIME_SET;\n\t\t/* XXX someone who knows this better please fix it for nsec */ \n\t\tiap->ia_mtime.tv_sec = v_mtime;\n\t\tiap->ia_atime.tv_sec = v_atime;\n\t\tiap->ia_mtime.tv_nsec = 0;\n\t\tiap->ia_atime.tv_nsec = 0;\n\t}\n\n set_attr:\n\terr = nfsd_create_setattr(rqstp, resfhp, iap);\n\n\t/*\n\t * nfsd_create_setattr already committed the child\n\t * (and possibly also the parent).\n\t */\n\tif (!err)\n\t\terr = nfserrno(commit_metadata(fhp));\n\n\t/*\n\t * Update the filehandle to get the new inode info.\n\t */\n\tif (!err)\n\t\terr = fh_update(resfhp);\n\n out:\n\tfh_unlock(fhp);\n\tif (dchild && !IS_ERR(dchild))\n\t\tdput(dchild);\n\tfh_drop_write(fhp);\n \treturn err;\n \n out_nfserr:\n\terr = nfserrno(host_err);\n\tgoto out;\n}", "target": 2, "idx": 11857}
{"commit_id": "073c516ff73557a8f7315066856c04b50383ac34", "project": "torvalds/linux", "func": "static void *__ns_get_path(struct path *path, struct ns_common *ns)\n{\n\tstruct vfsmount *mnt = nsfs_mnt;\n\tstruct qstr qname = { .name = \"\", };\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tunsigned long d;\n\n\trcu_read_lock();\n\td = atomic_long_read(&ns->stashed);\n\tif (!d)\n\t\tgoto slow;\n\tdentry = (struct dentry *)d;\n\tif (!lockref_get_not_dead(&dentry->d_lockref))\n\t\tgoto slow;\n\trcu_read_unlock();\n\tns->ops->put(ns);\ngot_it:\n\tpath->mnt = mntget(mnt);\n\tpath->dentry = dentry;\n\treturn NULL;\nslow:\n\trcu_read_unlock();\n\tinode = new_inode_pseudo(mnt->mnt_sb);\n\tif (!inode) {\n\t\tns->ops->put(ns);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tinode->i_ino = ns->inum;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);\n\tinode->i_flags |= S_IMMUTABLE;\n\tinode->i_mode = S_IFREG | S_IRUGO;\n\tinode->i_fop = &ns_file_operations;\n\tinode->i_private = ns;\n\n\tdentry = d_alloc_pseudo(mnt->mnt_sb, &qname);\n\tif (!dentry) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\td_instantiate(dentry, inode);\n\tdentry->d_flags |= DCACHE_RCUACCESS;\n\tdentry->d_fsdata = (void *)ns->ops;\n\td = atomic_long_cmpxchg(&ns->stashed, 0, (unsigned long)dentry);\n\tif (d) {\n\t\td_delete(dentry);\t/* make sure ->d_prune() does nothing */\n\t\tdput(dentry);\n\t\tcpu_relax();\n\t\treturn ERR_PTR(-EAGAIN);\n\t}\n\tgoto got_it;\n}", "target": 2, "idx": 11858}
{"commit_id": "0d45ea1ca641b21b73bcf9c00e0179cda284e7e7", "project": "tensorflow", "func": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteSpaceToDepthParams*>(node->builtin_data);\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4);\n\n  auto data_type = output->type;\n  TF_LITE_ENSURE(context,\n                 data_type == kTfLiteFloat32 || data_type == kTfLiteUInt8 ||\n                     data_type == kTfLiteInt8 || data_type == kTfLiteInt32 ||\n                     data_type == kTfLiteInt64);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n\n  const int block_size = params->block_size;\n  TF_LITE_ENSURE(context, block_size > 0);\n  const int input_height = input->dims->data[1];\n  const int input_width = input->dims->data[2];\n  int output_height = input_height / block_size;\n  int output_width = input_width / block_size;\n\n  TF_LITE_ENSURE_EQ(context, input_height, output_height * block_size);\n  TF_LITE_ENSURE_EQ(context, input_width, output_width * block_size);\n\n  TfLiteIntArray* output_size = TfLiteIntArrayCreate(4);\n  output_size->data[0] = input->dims->data[0];\n  output_size->data[1] = output_height;\n  output_size->data[2] = output_width;\n  output_size->data[3] = input->dims->data[3] * block_size * block_size;\n\n  return context->ResizeTensor(context, output, output_size);\n}", "target": 0, "idx": 11859}
{"commit_id": "acc192347665943ca674acf117e4f74a88436922", "project": "android", "func": "static void copyMono8(\n        short *dst,\n        const int * src[FLACParser::kMaxChannels],\n        unsigned nSamples,\n        unsigned /* nChannels */) {\n    for (unsigned i = 0; i < nSamples; ++i) {\n        *dst++ = src[0][i] << 8;\n    }\n}", "target": 2, "idx": 11860}
{"commit_id": "166e87368ae88bf31112a30e078cceae637f4cdb", "project": "util-linux", "func": "static void __attribute__((__noreturn__)) usage(void)\n{\n\tFILE *out = stdout;\n\tsize_t i;\n\n\tfputs(USAGE_HEADER, out);\n\tfprintf(out, _(\n\t\" %1$s [options]\\n\"\n\t\" %1$s [options] <device> | <mountpoint>\\n\"\n\t\" %1$s [options] <device> <mountpoint>\\n\"\n\t\" %1$s [options] [--source <device>] [--target <path> | --mountpoint <dir>]\\n\"),\n\t\tprogram_invocation_short_name);\n\n\tfputs(USAGE_SEPARATOR, out);\n\tfputs(_(\"Find a (mounted) filesystem.\\n\"), out);\n\n\tfputs(USAGE_OPTIONS, out);\n\tfputs(_(\" -s, --fstab            search in static table of filesystems\\n\"), out);\n\tfputs(_(\" -m, --mtab             search in table of mounted filesystems\\n\"\n\t\t\"                          (includes user space mount options)\\n\"), out);\n\tfputs(_(\" -k, --kernel           search in kernel table of mounted\\n\"\n\t\t\"                          filesystems (default)\\n\"), out);\n\tfputc('\\n', out);\n\tfputs(_(\" -p, --poll[=<list>]    monitor changes in table of mounted filesystems\\n\"), out);\n\tfputs(_(\" -w, --timeout <num>    upper limit in milliseconds that --poll will block\\n\"), out);\n\tfputc('\\n', out);\n\n\tfputs(_(\" -A, --all              disable all built-in filters, print all filesystems\\n\"), out);\n\tfputs(_(\" -a, --ascii            use ASCII chars for tree formatting\\n\"), out);\n\tfputs(_(\" -b, --bytes            print sizes in bytes rather than in human readable format\\n\"), out);\n\tfputs(_(\" -C, --nocanonicalize   don't canonicalize when comparing paths\\n\"), out);\n\tfputs(_(\" -c, --canonicalize     canonicalize printed paths\\n\"), out);\n\tfputs(_(\" -D, --df               imitate the output of df(1)\\n\"), out);\n\tfputs(_(\" -d, --direction <word> direction of search, 'forward' or 'backward'\\n\"), out);\n\tfputs(_(\" -e, --evaluate         convert tags (LABEL,UUID,PARTUUID,PARTLABEL) \\n\"\n\t        \"                          to device names\\n\"), out);\n\tfputs(_(\" -F, --tab-file <path>  alternative file for -s, -m or -k options\\n\"), out);\n\tfputs(_(\" -f, --first-only       print the first found filesystem only\\n\"), out);\n\tfputs(_(\" -i, --invert           invert the sense of matching\\n\"), out);\n\tfputs(_(\" -J, --json             use JSON output format\\n\"), out);\n\tfputs(_(\" -l, --list             use list format output\\n\"), out);\n\tfputs(_(\" -N, --task <tid>       use alternative namespace (/proc/<tid>/mountinfo file)\\n\"), out);\n\tfputs(_(\" -n, --noheadings       don't print column headings\\n\"), out);\n\tfputs(_(\" -O, --options <list>   limit the set of filesystems by mount options\\n\"), out);\n\tfputs(_(\" -o, --output <list>    the output columns to be shown\\n\"), out);\n\tfputs(_(\"     --output-all       output all available columns\\n\"), out);\n\tfputs(_(\" -P, --pairs            use key=\\\"value\\\" output format\\n\"), out);\n\tfputs(_(\"     --pseudo           print only pseudo-filesystems\\n\"), out);\n\tfputs(_(\"     --shadowed         print only filesystems over-mounted by another filesystem\\n\"), out);\n\tfputs(_(\" -R, --submounts        print all submounts for the matching filesystems\\n\"), out);\n\tfputs(_(\" -r, --raw              use raw output format\\n\"), out);\n\tfputs(_(\"     --real             print only real filesystems\\n\"), out);\n\tfputs(_(\" -S, --source <string>  the device to mount (by name, maj:min, \\n\"\n\t        \"                          LABEL=, UUID=, PARTUUID=, PARTLABEL=)\\n\"), out);\n\tfputs(_(\" -T, --target <path>    the path to the filesystem to use\\n\"), out);\n\tfputs(_(\"     --tree             enable tree format output if possible\\n\"), out);\n\tfputs(_(\" -M, --mountpoint <dir> the mountpoint directory\\n\"), out);\n\tfputs(_(\" -t, --types <list>     limit the set of filesystems by FS types\\n\"), out);\n\tfputs(_(\" -U, --uniq             ignore filesystems with duplicate target\\n\"), out);\n\tfputs(_(\" -u, --notruncate       don't truncate text in columns\\n\"), out);\n\tfputs(_(\" -v, --nofsroot         don't print [/dir] for bind or btrfs mounts\\n\"), out);\n\n\tfputc('\\n', out);\n\tfputs(_(\" -x, --verify           verify mount table content (default is fstab)\\n\"), out);\n\tfputs(_(\"     --verbose          print more details\\n\"), out);\n\tfputs(_(\"     --vfs-all          print all VFS options\\n\"), out);\n\n\tfputs(USAGE_SEPARATOR, out);\n\tprintf(USAGE_HELP_OPTIONS(24));\n\n\tfputs(USAGE_COLUMNS, out);\n\tfor (i = 0; i < ARRAY_SIZE(infos); i++)\n\t\tfprintf(out, \" %11s  %s\\n\", infos[i].name, _(infos[i].help));\n\n\tprintf(USAGE_MAN_TAIL(\"findmnt(8)\"));\n\n\texit(EXIT_SUCCESS);\n}", "target": 1, "idx": 11861}
{"commit_id": "b900cc28fcbb4cf5a32ab62f80b59292e1c85b4b", "project": "nginx", "func": "void\nngx_gmtime(time_t t, ngx_tm_t *tp)\n{\n    ngx_int_t   yday;\n    ngx_uint_t  sec, min, hour, mday, mon, year, wday, days, leap;\n\n    /* the calculation is valid for positive time_t only */\n\n    if (t < 0) {\n        t = 0;\n    }\n\n    days = t / 86400;\n    sec = t % 86400;\n\n    /*\n     * no more than 4 year digits supported,\n     * truncate to December 31, 9999, 23:59:59\n     */\n\n    if (days > 2932896) {\n        days = 2932896;\n        sec = 86399;\n    }\n\n    /* January 1, 1970 was Thursday */\n\n    wday = (4 + days) % 7;\n\n    hour = sec / 3600;\n    sec %= 3600;\n    min = sec / 60;\n    sec %= 60;\n\n    /*\n     * the algorithm based on Gauss' formula,\n     * see src/core/ngx_parse_time.c\n     */\n\n    /* days since March 1, 1 BC */\n    days = days - (31 + 28) + 719527;\n\n    /*\n     * The \"days\" should be adjusted to 1 only, however, some March 1st's go\n     * to previous year, so we adjust them to 2.  This causes also shift of the\n     * last February days to next year, but we catch the case when \"yday\"\n     * becomes negative.\n     */\n\n    year = (days + 2) * 400 / (365 * 400 + 100 - 4 + 1);\n\n    yday = days - (365 * year + year / 4 - year / 100 + year / 400);\n\n    if (yday < 0) {\n        leap = (year % 4 == 0) && (year % 100 || (year % 400 == 0));\n        yday = 365 + leap + yday;\n        year--;\n    }\n\n    /*\n     * The empirical formula that maps \"yday\" to month.\n     * There are at least 10 variants, some of them are:\n     *     mon = (yday + 31) * 15 / 459\n     *     mon = (yday + 31) * 17 / 520\n     *     mon = (yday + 31) * 20 / 612\n     */\n\n    mon = (yday + 31) * 10 / 306;\n\n    /* the Gauss' formula that evaluates days before the month */\n\n    mday = yday - (367 * mon / 12 - 30) + 1;\n\n    if (yday >= 306) {\n\n        year++;\n        mon -= 10;\n\n        /*\n         * there is no \"yday\" in Win32 SYSTEMTIME\n         *\n         * yday -= 306;\n         */\n\n    } else {\n\n        mon += 2;\n\n        /*\n         * there is no \"yday\" in Win32 SYSTEMTIME\n         *\n         * yday += 31 + 28 + leap;\n         */\n    }\n\n    tp->ngx_tm_sec = (ngx_tm_sec_t) sec;\n    tp->ngx_tm_min = (ngx_tm_min_t) min;\n    tp->ngx_tm_hour = (ngx_tm_hour_t) hour;\n    tp->ngx_tm_mday = (ngx_tm_mday_t) mday;\n    tp->ngx_tm_mon = (ngx_tm_mon_t) mon;\n    tp->ngx_tm_year = (ngx_tm_year_t) year;\n    tp->ngx_tm_wday = (ngx_tm_wday_t) wday;\n}", "target": 3, "idx": 11862}
{"commit_id": "e98c88c44c308edaea5994b8ad4363e65030968c", "project": "vim", "func": "void\ndisplay_dollar(colnr_T col_arg)\n{\n    colnr_T col = col_arg < 0 ? 0 : col_arg;\n    colnr_T save_col;\n\n    if (!redrawing())\n\treturn;\n\n    cursor_off();\n    save_col = curwin->w_cursor.col;\n    curwin->w_cursor.col = col;\n    if (has_mbyte)\n    {\n\tchar_u *p;\n\n\t// If on the last byte of a multi-byte move to the first byte.\n\tp = ml_get_curline();\n\tcurwin->w_cursor.col -= (*mb_head_off)(p, p + col);\n    }\n    curs_columns(FALSE);\t    // recompute w_wrow and w_wcol\n    if (curwin->w_wcol < curwin->w_width)\n    {\n\tedit_putchar('$', FALSE);\n\tdollar_vcol = curwin->w_virtcol;\n    }\n    curwin->w_cursor.col = save_col;\n}", "target": 2, "idx": 11863}
{"commit_id": "f57bd745b4cbed577ea654fad4701bea4d38b44c", "project": "moonlight-stream/moonlight-common-c", "func": "int startInputStream(void) {\n    int err;\n\n    // After Gen 5, we send input on the control stream\n    if (AppVersionQuad[0] < 5) {\n        inputSock = connectTcpSocket(&RemoteAddr, RemoteAddrLen,\n            35043, INPUT_STREAM_TIMEOUT_SEC);\n        if (inputSock == INVALID_SOCKET) {\n            return LastSocketFail();\n        }\n\n        enableNoDelay(inputSock);\n    }\n\n    err = PltCreateThread(inputSendThreadProc, NULL, &inputSendThread);\n    if (err != 0) {\n        return err;\n    }\n\n    return err;\n}", "target": 2, "idx": 11864}
{"commit_id": "93bc623489bdcfc7e9127614fcfb3258edf3f0f9", "project": "chromium", "func": "v8::MaybeLocal<v8::Array> V8Debugger::internalProperties(v8::Local<v8::Context> context, v8::Local<v8::Value> value)\n{\n    v8::Local<v8::Array> properties;\n    if (!v8::Debug::GetInternalProperties(m_isolate, value).ToLocal(&properties))\n        return v8::MaybeLocal<v8::Array>();\n    if (value->IsFunction()) {\n        v8::Local<v8::Function> function = value.As<v8::Function>();\n        v8::Local<v8::Value> location = functionLocation(context, function);\n        if (location->IsObject()) {\n            properties->Set(properties->Length(), toV8StringInternalized(m_isolate, \"[[FunctionLocation]]\"));\n            properties->Set(properties->Length(), location);\n        }\n        if (function->IsGeneratorFunction()) {\n            properties->Set(properties->Length(), toV8StringInternalized(m_isolate, \"[[IsGenerator]]\"));\n            properties->Set(properties->Length(), v8::True(m_isolate));\n        }\n    }\n    if (!enabled())\n        return properties;\n    if (value->IsMap() || value->IsWeakMap() || value->IsSet() || value->IsWeakSet() || value->IsSetIterator() || value->IsMapIterator()) {\n        v8::Local<v8::Value> entries = collectionEntries(context, v8::Local<v8::Object>::Cast(value));\n        if (entries->IsArray()) {\n            properties->Set(properties->Length(), toV8StringInternalized(m_isolate, \"[[Entries]]\"));\n            properties->Set(properties->Length(), entries);\n        }\n    }\n    if (value->IsGeneratorObject()) {\n        v8::Local<v8::Value> location = generatorObjectLocation(context, v8::Local<v8::Object>::Cast(value));\n        if (location->IsObject()) {\n            properties->Set(properties->Length(), toV8StringInternalized(m_isolate, \"[[GeneratorLocation]]\"));\n            properties->Set(properties->Length(), location);\n        }\n    }\n    if (value->IsFunction()) {\n        v8::Local<v8::Function> function = value.As<v8::Function>();\n        v8::Local<v8::Value> boundFunction = function->GetBoundFunction();\n        v8::Local<v8::Value> scopes;\n        if (boundFunction->IsUndefined() && functionScopes(context, function).ToLocal(&scopes)) {\n            properties->Set(properties->Length(), toV8StringInternalized(m_isolate, \"[[Scopes]]\"));\n            properties->Set(properties->Length(), scopes);\n        }\n    }\n    return properties;\n}", "target": 1, "idx": 11865}
{"commit_id": "5408a6d93f45bf1f7acd9ae5d44e0ebd77379e98", "project": "pcmacdon/jsish", "func": "static Jsi_RC jsi_ArrayUnshiftCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n\n    Jsi_Obj *obj = _this->d.obj;\n    int argc = Jsi_ValueGetLength(interp, args);\n    int curlen = jsi_SizeOfArray(interp, obj);\n    if (argc <= 0) {\n        Jsi_ValueMakeNumber(interp, ret, 0);\n        return JSI_OK;\n    }\n    Jsi_ObjListifyArray(interp, obj);\n    if (Jsi_ObjArraySizer(interp, obj, curlen+argc)<=0) \n        return Jsi_LogError(\"too long\");\n    memmove(obj->arr+argc, obj->arr, (curlen)*sizeof(Jsi_Value*));\n    obj->arrCnt += argc;\n    int i;\n    for (i = 0; i < argc; ++i) {\n        Jsi_Value *ov = Jsi_ValueArrayIndex(interp, args, i);\n        obj->arr[i] = NULL;\n        if (!ov) { Jsi_LogBug(\"Arguments Error\"); continue; }\n        obj->arr[i] = ov;\n        Jsi_IncrRefCount(interp, ov);\n    }\n    Jsi_ObjSetLength(interp, obj, curlen+argc);\n    \n    Jsi_ValueMakeNumber(interp, ret, jsi_SizeOfArray(interp, obj));\n    return JSI_OK;\n}", "target": 3, "idx": 11866}
{"commit_id": "7e8a04feb378a679f1bcdcae079a5100cc45663b", "project": "openrazer", "func": "struct razer_report razer_chroma_standard_matrix_set_custom_frame(unsigned char row_index, unsigned char start_col, unsigned char stop_col, unsigned char *rgb_data)\n{\n    const size_t start_arg_offset = 4;\n    struct razer_report report = {0};\n    size_t row_length = (size_t) (((stop_col + 1) - start_col) * 3);\n\n    if (row_length > sizeof(report.arguments) - start_arg_offset) {\n        printk(KERN_ALERT \"razerchroma: RGB data too long\\n\");\n        row_length = sizeof(report.arguments) - start_arg_offset;\n    }\n\n    report = get_razer_report(0x03, 0x0B, 0x46); // In theory should be able to leave data size at max as we have start/stop\n\n    // printk(KERN_ALERT \"razerkbd: Row ID: %d, Start: %d, Stop: %d, row length: %d\\n\", row_index, start_col, stop_col, (unsigned char)row_length);\n\n    report.arguments[0] = 0xFF; // Frame ID\n    report.arguments[1] = row_index;\n    report.arguments[2] = start_col;\n    report.arguments[3] = stop_col;\n    memcpy(&report.arguments[4], rgb_data, row_length);\n\n    return report;\n}", "target": 3, "idx": 11867}
{"commit_id": "52ff00a38447f06a17eab1caa2cf0730a119c751", "project": "syoyo/tinygltf", "func": "static bool ParseSampler(Sampler *sampler, std::string *err, const json &o,\n                         bool store_original_json_for_extras_and_extensions) {\n  ParseStringProperty(&sampler->name, err, o, \"name\", false);\n\n  int minFilter = -1;\n  int magFilter = -1;\n  int wrapS = TINYGLTF_TEXTURE_WRAP_REPEAT;\n  int wrapT = TINYGLTF_TEXTURE_WRAP_REPEAT;\n  // int wrapR = TINYGLTF_TEXTURE_WRAP_REPEAT;\n  ParseIntegerProperty(&minFilter, err, o, \"minFilter\", false);\n  ParseIntegerProperty(&magFilter, err, o, \"magFilter\", false);\n  ParseIntegerProperty(&wrapS, err, o, \"wrapS\", false);\n  ParseIntegerProperty(&wrapT, err, o, \"wrapT\", false);\n  // ParseIntegerProperty(&wrapR, err, o, \"wrapR\", false);  // tinygltf\n  // extension\n\n  // TODO(syoyo): Check the value is alloed one.\n  // (e.g. we allow 9728(NEAREST), but don't allow 9727)\n\n  sampler->minFilter = minFilter;\n  sampler->magFilter = magFilter;\n  sampler->wrapS = wrapS;\n  sampler->wrapT = wrapT;\n  // sampler->wrapR = wrapR;\n\n  ParseExtensionsProperty(&(sampler->extensions), err, o);\n  ParseExtrasProperty(&(sampler->extras), o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        sampler->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        sampler->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n\n  return true;\n}", "target": 2, "idx": 11868}
{"commit_id": "758754966791c537ea95241438454aa86f91f256", "project": "openssl", "func": "int ssl_verify_cert_chain(SSL *s, STACK_OF(X509) *sk)\n{\n    X509 *x;\n    int i = 0;\n    X509_STORE *verify_store;\n    X509_STORE_CTX *ctx = NULL;\n    X509_VERIFY_PARAM *param;\n\n    if ((sk == NULL) || (sk_X509_num(sk) == 0))\n        return 0;\n\n    if (s->cert->verify_store)\n        verify_store = s->cert->verify_store;\n    else\n        verify_store = s->ctx->cert_store;\n\n    ctx = X509_STORE_CTX_new_ex(s->ctx->libctx, s->ctx->propq);\n    if (ctx == NULL) {\n        ERR_raise(ERR_LIB_SSL, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n\n    x = sk_X509_value(sk, 0);\n    if (!X509_STORE_CTX_init(ctx, verify_store, x, sk)) {\n        ERR_raise(ERR_LIB_SSL, ERR_R_X509_LIB);\n        goto end;\n    }\n    param = X509_STORE_CTX_get0_param(ctx);\n    /*\n     * XXX: Separate @AUTHSECLEVEL and @TLSSECLEVEL would be useful at some\n     * point, for now a single @SECLEVEL sets the same policy for TLS crypto\n     * and PKI authentication.\n     */\n    X509_VERIFY_PARAM_set_auth_level(param, SSL_get_security_level(s));\n\n    /* Set suite B flags if needed */\n    X509_STORE_CTX_set_flags(ctx, tls1_suiteb(s));\n    if (!X509_STORE_CTX_set_ex_data\n        (ctx, SSL_get_ex_data_X509_STORE_CTX_idx(), s)) {\n        goto end;\n    }\n\n    /* Verify via DANE if enabled */\n    if (DANETLS_ENABLED(&s->dane))\n        X509_STORE_CTX_set0_dane(ctx, &s->dane);\n\n    /*\n     * We need to inherit the verify parameters. These can be determined by\n     * the context: if its a server it will verify SSL client certificates or\n     * vice versa.\n     */\n\n    X509_STORE_CTX_set_default(ctx, s->server ? \"ssl_client\" : \"ssl_server\");\n    /*\n     * Anything non-default in \"s->param\" should overwrite anything in the ctx.\n     */\n    X509_VERIFY_PARAM_set1(param, s->param);\n\n    if (s->verify_callback)\n        X509_STORE_CTX_set_verify_cb(ctx, s->verify_callback);\n\n    if (s->ctx->app_verify_callback != NULL) {\n        i = s->ctx->app_verify_callback(ctx, s->ctx->app_verify_arg);\n    } else {\n        i = X509_verify_cert(ctx);\n        /* We treat an error in the same way as a failure to verify */\n        if (i < 0)\n            i = 0;\n    }\n\n    s->verify_result = X509_STORE_CTX_get_error(ctx);\n    sk_X509_pop_free(s->verified_chain, X509_free);\n    s->verified_chain = NULL;\n    if (X509_STORE_CTX_get0_chain(ctx) != NULL) {\n        s->verified_chain = X509_STORE_CTX_get1_chain(ctx);\n        if (s->verified_chain == NULL) {\n            ERR_raise(ERR_LIB_SSL, ERR_R_MALLOC_FAILURE);\n            i = 0;\n        }\n    }\n\n    /* Move peername from the store context params to the SSL handle's */\n    X509_VERIFY_PARAM_move_peername(s->param, param);\n\n end:\n    X509_STORE_CTX_free(ctx);\n    return i;\n}", "target": 2, "idx": 11869}
{"commit_id": "3ac044334c3ff6a61cb4238ff3ddaf17c7efcf49", "project": "android", "func": "void WT_InterpolateMono (S_WT_VOICE *pWTVoice, S_WT_INT_FRAME *pWTIntFrame)\n{\n    EAS_I32 *pMixBuffer;\n    const EAS_I8 *pLoopEnd;\n    const EAS_I8 *pCurrentPhaseInt;\n    EAS_I32 numSamples;\n    EAS_I32 gain;\n    EAS_I32 gainIncrement;\n    EAS_I32 currentPhaseFrac;\n    EAS_I32 phaseInc;\n    EAS_I32 tmp0;\n    EAS_I32 tmp1;\n    EAS_I32 tmp2;\n    EAS_I8 *pLoopStart;\n\n    numSamples = pWTIntFrame->numSamples;\n    if (numSamples <= 0) {\n        ALOGE(\"b/26366256\");\n        return;\n    }\n    pMixBuffer = pWTIntFrame->pMixBuffer;\n\n    /* calculate gain increment */\n    gainIncrement = (pWTIntFrame->gainTarget - pWTIntFrame->prevGain) << (16 - SYNTH_UPDATE_PERIOD_IN_BITS);\n    if (gainIncrement < 0)\n        gainIncrement++;\n    gain = pWTIntFrame->prevGain << 16;\n\n    pCurrentPhaseInt = pWTVoice->pPhaseAccum;\n    currentPhaseFrac = pWTVoice->phaseFrac;\n    phaseInc = pWTIntFrame->phaseIncrement;\n\n    pLoopStart = pWTVoice->pLoopStart;\n    pLoopEnd = pWTVoice->pLoopEnd + 1;\n\nInterpolationLoop:\n    tmp0 = (EAS_I32)(pCurrentPhaseInt - pLoopEnd);\n    if (tmp0 >= 0)\n        pCurrentPhaseInt = pLoopStart + tmp0;\n\n    tmp0 = *pCurrentPhaseInt;\n    tmp1 = *(pCurrentPhaseInt + 1);\n\n    tmp2 = phaseInc + currentPhaseFrac;\n\n    tmp1 = tmp1 - tmp0;\n    tmp1 = tmp1 * currentPhaseFrac;\n\n    tmp1 = tmp0 + (tmp1 >> NUM_EG1_FRAC_BITS);\n\n    pCurrentPhaseInt += (tmp2 >> NUM_PHASE_FRAC_BITS);\n    currentPhaseFrac = tmp2 & PHASE_FRAC_MASK;\n\n    gain += gainIncrement;\n    tmp2 = (gain >> SYNTH_UPDATE_PERIOD_IN_BITS);\n\n    tmp0 = *pMixBuffer;\n    tmp2 = tmp1 * tmp2;\n    tmp2 = (tmp2 >> 9);\n    tmp0 = tmp2 + tmp0;\n    *pMixBuffer++ = tmp0;\n\n    numSamples--;\n    if (numSamples > 0)\n        goto InterpolationLoop;\n\n    pWTVoice->pPhaseAccum = pCurrentPhaseInt;\n    pWTVoice->phaseFrac = currentPhaseFrac;\n    /*lint -e{702} <avoid divide>*/\n    pWTVoice->gain = (EAS_I16)(gain >> SYNTH_UPDATE_PERIOD_IN_BITS);\n}", "target": 3, "idx": 11870}
{"commit_id": "013f3cea70acfe7b701cb73c93744d5ff5c0c213", "project": "nextcloud/desktop", "func": "bool OAuth::openBrowser()\n{\n    if (!Utility::openBrowser(authorisationLink())) {\n        // We cannot open the browser, then we claim we don't support OAuth.\n        emit result(NotSupported, QString());\n        return false;\n    }\n    return true;\n}", "target": 2, "idx": 11871}
{"commit_id": "f43f39958beb206b53292801e216d9b8a660f087", "project": "torvalds/linux", "func": "static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_cipher rcipher;\n\n\tstrncpy(rcipher.type, \"cipher\", sizeof(rcipher.type));\n\n\trcipher.blocksize = alg->cra_blocksize;\n\trcipher.min_keysize = alg->cra_cipher.cia_min_keysize;\n\trcipher.max_keysize = alg->cra_cipher.cia_max_keysize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_CIPHER,\n\t\t    sizeof(struct crypto_report_cipher), &rcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1, "idx": 11872}
{"commit_id": "fc27fe7e8deef2f37cba3f2be2d52b6ca5eb9d57", "project": "torvalds/linux", "func": "static int snd_seq_device_dev_free(struct snd_device *device)\n{\n\tstruct snd_seq_device *dev = device->device_data;\n\n\tcancel_autoload_drivers();\n\tput_device(&dev->dev);\n\treturn 0;\n}", "target": 1, "idx": 11873}
{"commit_id": "8524f2c0c690ff594a9ebc6d729351b07a1fc5f0", "project": "NVIDIA-Genomics-Research/GenomeWorks", "func": "void BatchBlock::get_output_details(OutputDetails** output_details_h_p, OutputDetails** output_details_d_p)\n{\n    OutputDetails* output_details_h{};\n    OutputDetails* output_details_d{};\n\n    // on host\n    output_details_h = reinterpret_cast<OutputDetails*>(&block_data_h_[offset_h_]);\n    offset_h_ += sizeof(OutputDetails);\n    output_details_h->consensus = &block_data_h_[offset_h_];\n    offset_h_ += output_size_ * sizeof(uint8_t);\n    if (output_mask_ & OutputType::consensus)\n    {\n        output_details_h->coverage = reinterpret_cast<uint16_t*>(&block_data_h_[offset_h_]);\n        offset_h_ += output_size_ * sizeof(uint16_t);\n    }\n    if (output_mask_ & OutputType::msa)\n    {\n        output_details_h->multiple_sequence_alignments = reinterpret_cast<uint8_t*>(&block_data_h_[offset_h_]);\n        offset_h_ += output_size_ * max_sequences_per_poa_ * sizeof(uint8_t);\n    }\n\n    output_details_d = reinterpret_cast<OutputDetails*>(&block_data_h_[offset_h_]);\n    offset_h_ += sizeof(OutputDetails);\n\n    // on device\n    output_details_d->consensus = &block_data_d_[offset_d_];\n    offset_d_ += cudautils::align<int64_t, 8>(output_size_ * sizeof(int8_t));\n    if (output_mask_ & OutputType::consensus)\n    {\n        output_details_d->coverage = reinterpret_cast<uint16_t*>(&block_data_d_[offset_d_]);\n        offset_d_ += cudautils::align<int64_t, 8>(output_size_ * sizeof(int16_t));\n    }\n    if (output_mask_ & OutputType::msa)\n    {\n        output_details_d->multiple_sequence_alignments = reinterpret_cast<uint8_t*>(&block_data_d_[offset_d_]);\n        offset_d_ += cudautils::align<int64_t, 8>(output_size_ * max_sequences_per_poa_ * sizeof(uint8_t));\n    }\n\n    *output_details_h_p = output_details_h;\n    *output_details_d_p = output_details_d;\n}", "target": 3, "idx": 11874}
{"commit_id": "df4bf28f9f104ca3ef78ed94b497859f15b004e5", "project": "php/php-src", "func": "static inline long object_common1(UNSERIALIZE_PARAMETER, zend_class_entry *ce)\n{\n\tlong elements;\n\n\telements = parse_iv2((*p) + 2, p);\n\n\t(*p) += 2;\n\n\t/* The internal class check here is a BC fix only, userspace classes implementing the\n\tSerializable interface have eventually an inconsistent behavior at this place when\n\tunserialized from a manipulated string. Additionaly the interal classes can possibly\n\tcrash PHP so they're still disabled here. */\n\tif (ce->serialize == NULL || ce->unserialize == zend_user_unserialize || (ZEND_INTERNAL_CLASS != ce->type && ce->create_object == NULL)) {\n\t\tobject_init_ex(*rval, ce);\n\t} else {\n\t\t/* If this class implements Serializable, it should not land here but in object_custom(). The passed string\n\t\tobviously doesn't descend from the regular serializer. */\n\t\tzend_error(E_WARNING, \"Erroneous data format for unserializing '%s'\", ce->name);\n\t\treturn 0;\n\t}\n\n\treturn elements;\n}", "target": 3, "idx": 11875}
{"commit_id": "5abda7a16698d4d1f47af1168d8fa2c640116b4a", "project": "torvalds/linux", "func": "static void dm1105_remove(struct pci_dev *pdev)\n{\n\tstruct dm1105_dev *dev = pci_get_drvdata(pdev);\n\tstruct dvb_adapter *dvb_adapter = &dev->dvb_adapter;\n\tstruct dvb_demux *dvbdemux = &dev->demux;\n\tstruct dmx_demux *dmx = &dvbdemux->dmx;\n\n\tcancel_work_sync(&dev->ir.work);\n\tdm1105_ir_exit(dev);\n\tdmx->close(dmx);\n\tdvb_net_release(&dev->dvbnet);\n\tif (dev->fe)\n\t\tdvb_unregister_frontend(dev->fe);\n\n\tdmx->disconnect_frontend(dmx);\n\tdmx->remove_frontend(dmx, &dev->mem_frontend);\n\tdmx->remove_frontend(dmx, &dev->hw_frontend);\n\tdvb_dmxdev_release(&dev->dmxdev);\n\tdvb_dmx_release(dvbdemux);\n\tdvb_unregister_adapter(dvb_adapter);\n\ti2c_del_adapter(&dev->i2c_adap);\n\n\tdm1105_hw_exit(dev);\n\tfree_irq(pdev->irq, dev);\n\tpci_iounmap(pdev, dev->io_mem);\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\tdm1105_devcount--;\n\tkfree(dev);\n}", "target": 2, "idx": 11876}
{"commit_id": "4d45a96e57fbabf00a7378b337d0ddcace6f38c1", "project": "ArtifexSoftware/mujs", "func": "static js_Ast *assignment(js_State *J, int notin)\n{\n\tjs_Ast *a = conditional(J, notin);\n\tINCREC();\n\tif (jsP_accept(J, '=')) a = EXP2(ASS, a, assignment(J, notin));\n\telse if (jsP_accept(J, TK_MUL_ASS)) a = EXP2(ASS_MUL, a, assignment(J, notin));\n\telse if (jsP_accept(J, TK_DIV_ASS)) a = EXP2(ASS_DIV, a, assignment(J, notin));\n\telse if (jsP_accept(J, TK_MOD_ASS)) a = EXP2(ASS_MOD, a, assignment(J, notin));\n\telse if (jsP_accept(J, TK_ADD_ASS)) a = EXP2(ASS_ADD, a, assignment(J, notin));\n\telse if (jsP_accept(J, TK_SUB_ASS)) a = EXP2(ASS_SUB, a, assignment(J, notin));\n\telse if (jsP_accept(J, TK_SHL_ASS)) a = EXP2(ASS_SHL, a, assignment(J, notin));\n\telse if (jsP_accept(J, TK_SHR_ASS)) a = EXP2(ASS_SHR, a, assignment(J, notin));\n\telse if (jsP_accept(J, TK_USHR_ASS)) a = EXP2(ASS_USHR, a, assignment(J, notin));\n\telse if (jsP_accept(J, TK_AND_ASS)) a = EXP2(ASS_BITAND, a, assignment(J, notin));\n\telse if (jsP_accept(J, TK_XOR_ASS)) a = EXP2(ASS_BITXOR, a, assignment(J, notin));\n\telse if (jsP_accept(J, TK_OR_ASS)) a = EXP2(ASS_BITOR, a, assignment(J, notin));\n\tDECREC();\n\treturn a;\n}", "target": 1, "idx": 11877}
{"commit_id": "946e51f2bf37f1656916eb75bd0742ba33983c28", "project": "torvalds/linux", "func": "static void ll_invalidate_negative_children(struct inode *dir)\n{\n\tstruct dentry *dentry, *tmp_subdir;\n\tstruct ll_d_hlist_node *p;\n\n\tll_lock_dcache(dir);\n\tll_d_hlist_for_each_entry(dentry, p, &dir->i_dentry, d_u.d_alias) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (!list_empty(&dentry->d_subdirs)) {\n\t\t\tstruct dentry *child;\n\n\t\t\tlist_for_each_entry_safe(child, tmp_subdir,\n\t\t\t\t\t\t &dentry->d_subdirs,\n\t\t\t\t\t\t d_child) {\n\t\t\t\tif (child->d_inode == NULL)\n\t\t\t\t\td_lustre_invalidate(child, 1);\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n\tll_unlock_dcache(dir);\n}", "target": 1, "idx": 11878}
{"commit_id": "1e03c06456d997435019fb3526fa2d4be7dbc6ec", "project": "ArtifexSoftware/mupdf", "func": "void\npdf_dict_put_drop(fz_context *ctx, pdf_obj *obj, pdf_obj *key, pdf_obj *val)\n{\n\tfz_try(ctx)\n\t\tpdf_dict_get_put(ctx, obj, key, val, NULL);\n\tfz_always(ctx)\n\t\tpdf_drop_obj(ctx, val);\n\tfz_catch(ctx)\n\t\tfz_rethrow(ctx);\n}", "target": 1, "idx": 11879}
{"commit_id": "5d340a5ca6e420a70297cdbdf777333f18bfdab7", "project": "the-tcpdump-group/tcpdump", "func": "static int\ncfm_network_addr_print(netdissect_options *ndo,\n                       register const u_char *tptr, const u_int length)\n{\n    u_int network_addr_type;\n    u_int hexdump =  FALSE;\n\n    /*\n     * Altough AFIs are tpically 2 octects wide,\n     * 802.1ab specifies that this field width\n     * is only once octet\n     */\n    if (length < 1) {\n        ND_PRINT((ndo, \"\\n\\t  Network Address Type (invalid, no data\"));\n        return hexdump;\n    }\n    /* The calling function must make any due ND_TCHECK calls. */\n    network_addr_type = *tptr;\n    ND_PRINT((ndo, \"\\n\\t  Network Address Type %s (%u)\",\n           tok2str(af_values, \"Unknown\", network_addr_type),\n           network_addr_type));\n\n    /*\n     * Resolve the passed in Address.\n     */\n    switch(network_addr_type) {\n    case AFNUM_INET:\n        if (length != 1 + 4) {\n            ND_PRINT((ndo, \"(invalid IPv4 address length %u)\", length - 1));\n            hexdump = TRUE;\n            break;\n        }\n        ND_PRINT((ndo, \", %s\", ipaddr_string(ndo, tptr + 1)));\n        break;\n\n    case AFNUM_INET6:\n        if (length != 1 + 16) {\n            ND_PRINT((ndo, \"(invalid IPv6 address length %u)\", length - 1));\n            hexdump = TRUE;\n            break;\n        }\n        ND_PRINT((ndo, \", %s\", ip6addr_string(ndo, tptr + 1)));\n        break;\n\n    default:\n        hexdump = TRUE;\n        break;\n    }\n\n    return hexdump;\n}", "target": 3, "idx": 11880}
{"commit_id": "ff2a793e15bb0b6254bc849ef8e83e1c284c3583", "project": "xen-project/xen", "func": "static void hap_free_p2m_page(struct domain *d, struct page_info *pg)\n{\n    struct domain *owner = page_get_owner(pg);\n\n    /* This is called both from the p2m code (which never holds the \n     * paging lock) and the log-dirty code (which always does). */\n    paging_lock_recursive(d);\n\n    /* Should still have no owner and count zero. */\n    if ( owner || (pg->count_info & PGC_count_mask) )\n    {\n        HAP_ERROR(\"d%d: Odd p2m page %\"PRI_mfn\" d=%d c=%lx t=%\"PRtype_info\"\\n\",\n                  d->domain_id, mfn_x(page_to_mfn(pg)),\n                  owner ? owner->domain_id : DOMID_INVALID,\n                  pg->count_info, pg->u.inuse.type_info);\n        WARN();\n        pg->count_info &= ~PGC_count_mask;\n        page_set_owner(pg, NULL);\n    }\n    d->arch.paging.hap.p2m_pages--;\n    d->arch.paging.hap.total_pages++;\n    hap_free(d, page_to_mfn(pg));\n\n    paging_unlock(d);\n}", "target": 2, "idx": 11881}
{"commit_id": "973e7170dddefb491a48df5cba33b2ae151013a0", "project": "qemu", "func": "static void virtqueue_map_desc(unsigned int *p_num_sg, hwaddr *addr, struct iovec *iov,\n                               unsigned int max_num_sg, bool is_write,\n                               hwaddr pa, size_t sz)\n{\n    unsigned num_sg = *p_num_sg;\n    assert(num_sg <= max_num_sg);\n\n    if (!sz) {\n        error_report(\"virtio: zero sized buffers are not allowed\");\n        exit(1);\n    }\n\n    while (sz) {\n        hwaddr len = sz;\n\n        if (num_sg == max_num_sg) {\n            error_report(\"virtio: too many write descriptors in indirect table\");\n            exit(1);\n        }\n\n        iov[num_sg].iov_base = cpu_physical_memory_map(pa, &len, is_write);\n        if (!iov[num_sg].iov_base) {\n            error_report(\"virtio: bogus descriptor or out of resources\");\n            exit(1);\n        }\n\n        iov[num_sg].iov_len = len;\n        addr[num_sg] = pa;\n\n        sz -= len;\n        pa += len;\n        num_sg++;\n    }\n    *p_num_sg = num_sg;\n}", "target": 1, "idx": 11882}
{"commit_id": "e9ce0d64faf19fa4e9c260250fbdf25e3c11e152", "project": "radareorg/radare2", "func": "R_API RBinJavaAttrInfo *r_bin_java_local_variable_type_table_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tRBinJavaLocalVariableTypeAttribute *lvattr;\n\tut64 offset = 6;\n\tut32 i = 0;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (buffer, sz, 0);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_LOCAL_VARIABLE_TYPE_TABLE_ATTR;\n\tattr->info.local_variable_type_table_attr.table_length = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.local_variable_type_table_attr.local_variable_table = r_list_newf (r_bin_java_local_variable_type_table_attr_entry_free);\n\tfor (i = 0; i < attr->info.local_variable_type_table_attr.table_length; i++) {\n\t\tut64 curpos = buf_offset + offset;\n\t\tlvattr = R_NEW0 (RBinJavaLocalVariableTypeAttribute);\n\t\tif (!lvattr) {\n\t\t\tperror (\"calloc\");\n\t\t\tbreak;\n\t\t}\n\t\tif (offset + 10 > sz) {\n\t\t\teprintf (\"oob\");\n\t\t\tbreak;\n\t\t}\n\t\tlvattr->start_pc = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlvattr->length = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlvattr->name_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlvattr->signature_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlvattr->index = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlvattr->file_offset = curpos;\n\t\tlvattr->name = r_bin_java_get_utf8_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, lvattr->name_idx);\n\t\tlvattr->size = 10;\n\t\tif (!lvattr->name) {\n\t\t\tlvattr->name = strdup (\"NULL\");\n\t\t\teprintf (\"r_bin_java_local_variable_type_table_attr_new: Unable to find the name for %d index.\\n\", lvattr->name_idx);\n\t\t}\n\t\tlvattr->signature = r_bin_java_get_utf8_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, lvattr->signature_idx);\n\t\tif (!lvattr->signature) {\n\t\t\tlvattr->signature = strdup (\"NULL\");\n\t\t\teprintf (\"r_bin_java_local_variable_type_table_attr_new: Unable to find the descriptor for %d index.\\n\", lvattr->signature_idx);\n\t\t}\n\t\tr_list_append (attr->info.local_variable_type_table_attr.local_variable_table, lvattr);\n\t}\n\t// IFDBG r_bin_java_print_local_variable_type_table_attr_summary(attr);\n\tattr->size = offset;\n\treturn attr;\n}", "target": 1, "idx": 11883}
{"commit_id": "6709d4b7bc2e079241fdef15d1160581c5261c10", "project": "torvalds/linux", "func": "static void local_release(struct kref *ref)\n{\n\tstruct nfc_llcp_local *local;\n\n\tlocal = container_of(ref, struct nfc_llcp_local, ref);\n\n\tlocal_cleanup(local);\n\tkfree(local);\n}", "target": 1, "idx": 11884}
{"commit_id": "a74524b3e3fad81b0fd1084ffdf9f2ea469cd9b1", "project": "connman", "func": "static gboolean listener_event(GIOChannel *channel, GIOCondition condition,\n\t\t\t\t\t\t\tgpointer user_data)\n{\n\tGDHCPClient *dhcp_client = user_data;\n\tstruct sockaddr_in dst_addr = { 0 };\n\tstruct dhcp_packet packet = { 0 };\n\tstruct dhcpv6_packet *packet6 = NULL;\n\tuint8_t *message_type = NULL, *client_id = NULL, *option,\n\t\t*server_id = NULL;\n\tuint16_t option_len = 0, status = 0;\n\tuint32_t xid = 0;\n\tgpointer pkt;\n\tunsigned char buf[MAX_DHCPV6_PKT_SIZE];\n\tuint16_t pkt_len = 0;\n\tint count;\n\tint re;\n\n\tif (condition & (G_IO_NVAL | G_IO_ERR | G_IO_HUP)) {\n\t\tdhcp_client->listener_watch = 0;\n\t\treturn FALSE;\n\t}\n\n\tif (dhcp_client->listen_mode == L_NONE)\n\t\treturn FALSE;\n\n\tpkt = &packet;\n\n\tdhcp_client->status_code = 0;\n\n\tif (dhcp_client->listen_mode == L2) {\n\t\tre = dhcp_recv_l2_packet(&packet,\n\t\t\t\t\tdhcp_client->listener_sockfd,\n\t\t\t\t\t&dst_addr);\n\t\tpkt_len = (uint16_t)(unsigned int)re;\n\t\txid = packet.xid;\n\t} else if (dhcp_client->listen_mode == L3) {\n\t\tif (dhcp_client->type == G_DHCP_IPV6) {\n\t\t\tre = dhcpv6_recv_l3_packet(&packet6, buf, sizeof(buf),\n\t\t\t\t\t\tdhcp_client->listener_sockfd);\n\t\t\tif (re < 0)\n\t\t\t    return TRUE;\n\t\t\tpkt_len = re;\n\t\t\tpkt = packet6;\n\t\t\txid = packet6->transaction_id[0] << 16 |\n\t\t\t\tpacket6->transaction_id[1] << 8 |\n\t\t\t\tpacket6->transaction_id[2];\n\t\t} else {\n\t\t\tre = dhcp_recv_l3_packet(&packet,\n\t\t\t\t\t\tdhcp_client->listener_sockfd);\n\t\t\txid = packet.xid;\n\t\t}\n\t} else if (dhcp_client->listen_mode == L_ARP) {\n\t\tipv4ll_recv_arp_packet(dhcp_client);\n\t\treturn TRUE;\n\t} else\n\t\tre = -EIO;\n\n\tif (re < 0)\n\t\treturn TRUE;\n\n\tif (!check_package_owner(dhcp_client, pkt))\n\t\treturn TRUE;\n\n\tif (dhcp_client->type == G_DHCP_IPV6) {\n\t\tif (!packet6)\n\t\t\treturn TRUE;\n\n\t\tcount = 0;\n\t\tclient_id = dhcpv6_get_option(packet6, pkt_len,\n\t\t\t\tG_DHCPV6_CLIENTID, &option_len,\t&count);\n\n\t\tif (!client_id || count == 0 || option_len == 0 ||\n\t\t\t\tmemcmp(dhcp_client->duid, client_id,\n\t\t\t\t\tdhcp_client->duid_len) != 0) {\n\t\t\tdebug(dhcp_client,\n\t\t\t\t\"client duid error, discarding msg %p/%d/%d\",\n\t\t\t\tclient_id, option_len, count);\n\t\t\treturn TRUE;\n\t\t}\n\n\t\toption = dhcpv6_get_option(packet6, pkt_len,\n\t\t\t\tG_DHCPV6_STATUS_CODE, &option_len, NULL);\n\t\tif (option != 0 && option_len > 0) {\n\t\t\tstatus = option[0]<<8 | option[1];\n\t\t\tif (status != 0) {\n\t\t\t\tdebug(dhcp_client, \"error code %d\", status);\n\t\t\t\tif (option_len > 2) {\n\t\t\t\t\tgchar *txt = g_strndup(\n\t\t\t\t\t\t(gchar *)&option[2],\n\t\t\t\t\t\toption_len - 2);\n\t\t\t\t\tdebug(dhcp_client, \"error text: %s\",\n\t\t\t\t\t\ttxt);\n\t\t\t\t\tg_free(txt);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdhcp_client->status_code = status;\n\t\t}\n\t} else {\n\t\tmessage_type = dhcp_get_option(&packet, pkt_len, DHCP_MESSAGE_TYPE);\n\t\tif (!message_type)\n\t\t\treturn TRUE;\n\t}\n\n\tdebug(dhcp_client, \"received DHCP packet xid 0x%04x \"\n\t\t\"(current state %d)\", ntohl(xid), dhcp_client->state);\n\n\tswitch (dhcp_client->state) {\n\tcase INIT_SELECTING:\n\t\tif (*message_type != DHCPOFFER)\n\t\t\treturn TRUE;\n\n\t\tremove_timeouts(dhcp_client);\n\t\tdhcp_client->timeout = 0;\n\t\tdhcp_client->retry_times = 0;\n\n\t\toption = dhcp_get_option(&packet, pkt_len, DHCP_SERVER_ID);\n\t\tdhcp_client->server_ip = get_be32(option);\n\t\tdhcp_client->requested_ip = ntohl(packet.yiaddr);\n\n\t\tdhcp_client->state = REQUESTING;\n\n\t\t/*\n\t\t * RFC2131:\n\t\t *\n\t\t *   If unicasting is not possible, the message MAY be\n\t\t *   sent as an IP broadcast using an IP broadcast address\n\t\t *   (preferably 0xffffffff) as the IP destination address\n\t\t *   and the link-layer broadcast address as the link-layer\n\t\t *   destination address.\n\t\t *\n\t\t * For interoperability reasons, if the response is an IP\n\t\t * broadcast, let's reuse broadcast flag from DHCPDISCOVER\n\t\t * to which the server has responded. Some servers are picky\n\t\t * about this flag.\n\t\t */\n\t\tdhcp_client->request_bcast =\n\t\t\tdst_addr.sin_addr.s_addr == INADDR_BROADCAST &&\n\t\t\tg_hash_table_contains(dhcp_client->secs_bcast_hash,\n\t\t\t\tGINT_TO_POINTER(packet.secs));\n\n\t\tdebug(dhcp_client, \"init ip %s secs %hu -> broadcast flag %s\",\n\t\t\tinet_ntoa(dst_addr.sin_addr), packet.secs,\n\t\t\tdhcp_client->request_bcast ? \"on\" : \"off\");\n\n\t\tstart_request(dhcp_client);\n\n\t\treturn TRUE;\n\tcase REBOOTING:\n\t\tif (dst_addr.sin_addr.s_addr == INADDR_BROADCAST)\n\t\t\tdhcp_client->request_bcast = true;\n\t\telse\n\t\t\tdhcp_client->request_bcast = false;\n\n\t\tdebug(dhcp_client, \"ip %s -> %sadding broadcast flag\",\n\t\t\tinet_ntoa(dst_addr.sin_addr),\n\t\t\tdhcp_client->request_bcast ? \"\" : \"not \");\n\t\t/* fall through */\n\tcase REQUESTING:\n\tcase RENEWING:\n\tcase REBINDING:\n\t\tif (*message_type == DHCPACK) {\n\t\t\tdhcp_client->retry_times = 0;\n\n\t\t\tremove_timeouts(dhcp_client);\n\n\t\t\tdhcp_client->lease_seconds = get_lease(&packet, pkt_len);\n\n\t\t\tget_request(dhcp_client, &packet, pkt_len);\n\n\t\t\tswitch_listening_mode(dhcp_client, L_NONE);\n\n\t\t\tg_free(dhcp_client->assigned_ip);\n\t\t\tdhcp_client->assigned_ip = get_ip(packet.yiaddr);\n\n\t\t\tif (dhcp_client->state == REBOOTING) {\n\t\t\t\toption = dhcp_get_option(&packet, pkt_len,\n\t\t\t\t\t\t\tDHCP_SERVER_ID);\n\t\t\t\tdhcp_client->server_ip = get_be32(option);\n\t\t\t}\n\n\t\t\t/* Address should be set up here */\n\t\t\tif (dhcp_client->lease_available_cb)\n\t\t\t\tdhcp_client->lease_available_cb(dhcp_client,\n\t\t\t\t\tdhcp_client->lease_available_data);\n\n\t\t\tstart_bound(dhcp_client);\n\t\t} else if (*message_type == DHCPNAK) {\n\t\t\tdhcp_client->retry_times = 0;\n\n\t\t\tremove_timeouts(dhcp_client);\n\n\t\t\tdhcp_client->timeout = g_timeout_add_seconds_full(\n\t\t\t\t\t\t\tG_PRIORITY_HIGH, 3,\n\t\t\t\t\t\t\trestart_dhcp_timeout,\n\t\t\t\t\t\t\tdhcp_client,\n\t\t\t\t\t\t\tNULL);\n\t\t}\n\n\t\tbreak;\n\tcase SOLICITATION:\n\t\tif (dhcp_client->type != G_DHCP_IPV6)\n\t\t\treturn TRUE;\n\n\t\tif (packet6->message != DHCPV6_REPLY &&\n\t\t\t\tpacket6->message != DHCPV6_ADVERTISE)\n\t\t\treturn TRUE;\n\n\t\tcount = 0;\n\t\tserver_id = dhcpv6_get_option(packet6, pkt_len,\n\t\t\t\tG_DHCPV6_SERVERID, &option_len,\t&count);\n\t\tif (!server_id || count != 1 || option_len == 0) {\n\t\t\t/* RFC 3315, 15.10 */\n\t\t\tdebug(dhcp_client,\n\t\t\t\t\"server duid error, discarding msg %p/%d/%d\",\n\t\t\t\tserver_id, option_len, count);\n\t\t\treturn TRUE;\n\t\t}\n\t\tdhcp_client->server_duid = g_try_malloc(option_len);\n\t\tif (!dhcp_client->server_duid)\n\t\t\treturn TRUE;\n\t\tmemcpy(dhcp_client->server_duid, server_id, option_len);\n\t\tdhcp_client->server_duid_len = option_len;\n\n\t\tif (packet6->message == DHCPV6_REPLY) {\n\t\t\tuint8_t *rapid_commit;\n\t\t\tcount = 0;\n\t\t\toption_len = 0;\n\t\t\trapid_commit = dhcpv6_get_option(packet6, pkt_len,\n\t\t\t\t\t\t\tG_DHCPV6_RAPID_COMMIT,\n\t\t\t\t\t\t\t&option_len, &count);\n\t\t\tif (!rapid_commit || option_len != 0 ||\n\t\t\t\t\t\t\t\tcount != 1)\n\t\t\t\t/* RFC 3315, 17.1.4 */\n\t\t\t\treturn TRUE;\n\t\t}\n\n\t\tswitch_listening_mode(dhcp_client, L_NONE);\n\n\t\tif (dhcp_client->status_code == 0)\n\t\t\tget_dhcpv6_request(dhcp_client, packet6, pkt_len,\n\t\t\t\t\t&dhcp_client->status_code);\n\n\t\tif (packet6->message == DHCPV6_ADVERTISE) {\n\t\t\tif (dhcp_client->advertise_cb)\n\t\t\t\tdhcp_client->advertise_cb(dhcp_client,\n\t\t\t\t\t\tdhcp_client->advertise_data);\n\t\t\treturn TRUE;\n\t\t}\n\n\t\tif (dhcp_client->solicitation_cb) {\n\t\t\t/*\n\t\t\t * The dhcp_client might not be valid after the\n\t\t\t * callback call so just return immediately.\n\t\t\t */\n\t\t\tdhcp_client->solicitation_cb(dhcp_client,\n\t\t\t\t\tdhcp_client->solicitation_data);\n\t\t\treturn TRUE;\n\t\t}\n\t\tbreak;\n\tcase REBIND:\n\t\tif (dhcp_client->type != G_DHCP_IPV6)\n\t\t\treturn TRUE;\n\n\t\tserver_id = dhcpv6_get_option(packet6, pkt_len,\n\t\t\t\tG_DHCPV6_SERVERID, &option_len,\t&count);\n\t\tif (!dhcp_client->server_duid && server_id &&\n\t\t\t\t\t\t\t\tcount == 1) {\n\t\t\t/*\n\t\t\t * If we do not have server duid yet, then get it now.\n\t\t\t * Prefix delegation renew support needs it.\n\t\t\t */\n\t\t\tdhcp_client->server_duid = g_try_malloc(option_len);\n\t\t\tif (!dhcp_client->server_duid)\n\t\t\t\treturn TRUE;\n\t\t\tmemcpy(dhcp_client->server_duid, server_id, option_len);\n\t\t\tdhcp_client->server_duid_len = option_len;\n\t\t}\n\t\t/* fall through */\n\tcase INFORMATION_REQ:\n\tcase REQUEST:\n\tcase RENEW:\n\tcase RELEASE:\n\tcase CONFIRM:\n\tcase DECLINE:\n\t\tif (dhcp_client->type != G_DHCP_IPV6)\n\t\t\treturn TRUE;\n\n\t\tif (packet6->message != DHCPV6_REPLY)\n\t\t\treturn TRUE;\n\n\t\tcount = 0;\n\t\toption_len = 0;\n\t\tserver_id = dhcpv6_get_option(packet6, pkt_len,\n\t\t\t\tG_DHCPV6_SERVERID, &option_len, &count);\n\t\tif (!server_id || count != 1 || option_len == 0 ||\n\t\t\t\t(dhcp_client->server_duid_len > 0 &&\n\t\t\t\tmemcmp(dhcp_client->server_duid, server_id,\n\t\t\t\t\tdhcp_client->server_duid_len) != 0)) {\n\t\t\t/* RFC 3315, 15.10 */\n\t\t\tdebug(dhcp_client,\n\t\t\t\t\"server duid error, discarding msg %p/%d/%d\",\n\t\t\t\tserver_id, option_len, count);\n\t\t\treturn TRUE;\n\t\t}\n\n\t\tswitch_listening_mode(dhcp_client, L_NONE);\n\n\t\tget_dhcpv6_request(dhcp_client, packet6, pkt_len,\n\t\t\t\t\t\t&dhcp_client->status_code);\n\n\t\tif (dhcp_client->information_req_cb) {\n\t\t\t/*\n\t\t\t * The dhcp_client might not be valid after the\n\t\t\t * callback call so just return immediately.\n\t\t\t */\n\t\t\tdhcp_client->information_req_cb(dhcp_client,\n\t\t\t\t\tdhcp_client->information_req_data);\n\t\t\treturn TRUE;\n\t\t}\n\t\tif (dhcp_client->request_cb) {\n\t\t\tdhcp_client->request_cb(dhcp_client,\n\t\t\t\t\tdhcp_client->request_data);\n\t\t\treturn TRUE;\n\t\t}\n\t\tif (dhcp_client->renew_cb) {\n\t\t\tdhcp_client->renew_cb(dhcp_client,\n\t\t\t\t\tdhcp_client->renew_data);\n\t\t\treturn TRUE;\n\t\t}\n\t\tif (dhcp_client->rebind_cb) {\n\t\t\tdhcp_client->rebind_cb(dhcp_client,\n\t\t\t\t\tdhcp_client->rebind_data);\n\t\t\treturn TRUE;\n\t\t}\n\t\tif (dhcp_client->release_cb) {\n\t\t\tdhcp_client->release_cb(dhcp_client,\n\t\t\t\t\tdhcp_client->release_data);\n\t\t\treturn TRUE;\n\t\t}\n\t\tif (dhcp_client->decline_cb) {\n\t\t\tdhcp_client->decline_cb(dhcp_client,\n\t\t\t\t\tdhcp_client->decline_data);\n\t\t\treturn TRUE;\n\t\t}\n\t\tif (dhcp_client->confirm_cb) {\n\t\t\tcount = 0;\n\t\t\tserver_id = dhcpv6_get_option(packet6, pkt_len,\n\t\t\t\t\t\tG_DHCPV6_SERVERID, &option_len,\n\t\t\t\t\t\t&count);\n\t\t\tif (!server_id || count != 1 ||\n\t\t\t\t\t\t\toption_len == 0) {\n\t\t\t\t/* RFC 3315, 15.10 */\n\t\t\t\tdebug(dhcp_client,\n\t\t\t\t\t\"confirm server duid error, \"\n\t\t\t\t\t\"discarding msg %p/%d/%d\",\n\t\t\t\t\tserver_id, option_len, count);\n\t\t\t\treturn TRUE;\n\t\t\t}\n\t\t\tdhcp_client->server_duid = g_try_malloc(option_len);\n\t\t\tif (!dhcp_client->server_duid)\n\t\t\t\treturn TRUE;\n\t\t\tmemcpy(dhcp_client->server_duid, server_id, option_len);\n\t\t\tdhcp_client->server_duid_len = option_len;\n\n\t\t\tdhcp_client->confirm_cb(dhcp_client,\n\t\t\t\t\t\tdhcp_client->confirm_data);\n\t\t\treturn TRUE;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tdebug(dhcp_client, \"processed DHCP packet (new state %d)\",\n\t\t\t\t\t\t\tdhcp_client->state);\n\n\treturn TRUE;\n}", "target": 1, "idx": 11885}
{"commit_id": "55667441c84fa5e0911a0aac44fb059c15ba6da2", "project": "torvalds/linux", "func": "static inline size_t flow_keys_hash_length(const struct flow_keys *flow)\n{\n\tsize_t diff = FLOW_KEYS_HASH_OFFSET + sizeof(flow->addrs);\n\tBUILD_BUG_ON(offsetof(typeof(*flow), addrs) !=\n\t\t     sizeof(*flow) - sizeof(flow->addrs));\n\n\tswitch (flow->control.addr_type) {\n\tcase FLOW_DISSECTOR_KEY_IPV4_ADDRS:\n\t\tdiff -= sizeof(flow->addrs.v4addrs);\n\t\tbreak;\n\tcase FLOW_DISSECTOR_KEY_IPV6_ADDRS:\n\t\tdiff -= sizeof(flow->addrs.v6addrs);\n\t\tbreak;\n\tcase FLOW_DISSECTOR_KEY_TIPC:\n\t\tdiff -= sizeof(flow->addrs.tipckey);\n\t\tbreak;\n\t}\n\treturn sizeof(*flow) - diff;\n}", "target": 1, "idx": 11886}
{"commit_id": "edc4746f253d907d048de680a621e121517f484b", "project": "torvalds/linux", "func": "static void iowarrior_disconnect(struct usb_interface *interface)\n{\n\tstruct iowarrior *dev;\n\tint minor;\n\n\tdev = usb_get_intfdata(interface);\n\tmutex_lock(&iowarrior_open_disc_lock);\n\tusb_set_intfdata(interface, NULL);\n\n\tminor = dev->minor;\n\tmutex_unlock(&iowarrior_open_disc_lock);\n\t/* give back our minor - this will call close() locks need to be dropped at this point*/\n\n\tusb_deregister_dev(interface, &iowarrior_class);\n\n\tmutex_lock(&dev->mutex);\n\n\t/* prevent device read, write and ioctl */\n\tdev->present = 0;\n\n\tif (dev->opened) {\n\t\t/* There is a process that holds a filedescriptor to the device ,\n\t\t   so we only shutdown read-/write-ops going on.\n\t\t   Deleting the device is postponed until close() was called.\n\t\t */\n\t\tusb_kill_urb(dev->int_in_urb);\n\t\twake_up_interruptible(&dev->read_wait);\n\t\twake_up_interruptible(&dev->write_wait);\n\t\tmutex_unlock(&dev->mutex);\n\t} else {\n\t\t/* no process is using the device, cleanup now */\n\t\tmutex_unlock(&dev->mutex);\n\t\tiowarrior_delete(dev);\n\t}\n\n\tdev_info(&interface->dev, \"I/O-Warror #%d now disconnected\\n\",\n\t\t minor - IOWARRIOR_MINOR_BASE);\n}", "target": 1, "idx": 11887}
{"commit_id": "f17dae31ebf6ea7af8c512165d9b954c2a6ea46e", "project": "gpac", "func": "GF_Err reftype_box_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_TrackReferenceTypeBox *p = (GF_TrackReferenceTypeBox *)a;\n\tif (!p->reference_type) return GF_OK;\n\tp->type = p->reference_type;\n\t//don't allow UNKN or UUID as type (possible buffer overflow when typecasting to GF_UnknownBox)\n\tif ((p->type==GF_ISOM_BOX_TYPE_UNKNOWN) || (p->type==GF_ISOM_BOX_TYPE_UUID))\n\t\tp->type = GF_4CC('u','k','n','w');\n\n\tgf_isom_box_dump_start(a, \"TrackReferenceTypeBox\", trace);\n\tgf_fprintf(trace, \">\\n\");\n\tfor (i=0; i<p->trackIDCount; i++) {\n\t\tgf_fprintf(trace, \"<TrackReferenceEntry TrackID=\\\"%d\\\"/>\\n\", p->trackIDs[i]);\n\t}\n\tif (!p->size)\n\t\tgf_fprintf(trace, \"<TrackReferenceEntry TrackID=\\\"\\\"/>\\n\");\n\n\tgf_isom_box_dump_done(\"TrackReferenceTypeBox\", a, trace);\n\tp->type = GF_ISOM_BOX_TYPE_REFT;\n\treturn GF_OK;\n}", "target": 2, "idx": 11888}
{"commit_id": "3eb6764acd2d708f6873c177a77f9bef3b266fa9", "project": "libuv", "func": "static int uv__rwlock_fallback_trywrlock(uv_rwlock_t* rwlock) {\n  DWORD r = WaitForSingleObject(rwlock->fallback_.write_lock_.sem, 0);\n  if (r == WAIT_OBJECT_0)\n    return 0;\n  else if (r == WAIT_TIMEOUT)\n    return UV_EAGAIN;\n  else if (r == WAIT_FAILED)\n    return uv_translate_sys_error(GetLastError());\n  else\n    return UV_EIO;\n}", "target": 2, "idx": 11889}
{"commit_id": "5250afecbc770c8f26829e9566d5b226a3c5fa80", "project": "gpac", "func": "GF_Err ilst_item_Read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 sub_type;\n\tGF_Box *a = NULL;\n\tGF_ListItemBox *ptr = (GF_ListItemBox *)s;\n\t/*iTunes way: there's a data atom containing the data*/\n\tsub_type = gf_bs_peek_bits(bs, 32, 4);\n\tif (sub_type == GF_ISOM_BOX_TYPE_DATA ) {\n\t\te = gf_isom_box_parse(&a, bs);\n\n\t\tif (!e && a && ptr->size < a->size) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[isom] not enough bytes in box %s: %d left, reading %d (file %s, line %d)\\n\", gf_4cc_to_str(ptr->type), ptr->size, a->size, __FILE__, __LINE__ )); \\\n\t\t\te = GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tif (!a) e = GF_ISOM_INVALID_FILE;\n\n\t\tif (e) {\n\t\t\tif (a) gf_isom_box_del(a);\n\t\t\treturn e;\n\t\t}\n\n\t\tISOM_DECREASE_SIZE(ptr, a->size);\n\n\t\tif (a && ptr->data) gf_isom_box_del((GF_Box *) ptr->data);\n\n\t\t/* otherwise a->data will always overflow */\n\t\tif (a && a->size > 4 && a->type != GF_ISOM_BOX_TYPE_VOID)\n\t\t\tptr->data = (GF_DataBox *)a;\n\t\telse {\n\t\t\tptr->data = NULL;\n\t\t\tgf_isom_box_del(a);\n\t\t}\n\t}\n\t/*QT way*/\n\telse {\n\t\tptr->data->type = 0;\n\t\tptr->data->dataSize = gf_bs_read_u16(bs);\n\t\tgf_bs_read_u16(bs);\n\t\tptr->data->data = (char *) gf_malloc(sizeof(char)*(ptr->data->dataSize + 1));\n\t\tgf_bs_read_data(bs, ptr->data->data, ptr->data->dataSize);\n\t\tptr->data->data[ptr->data->dataSize] = 0;\n\t\tISOM_DECREASE_SIZE(ptr, ptr->data->dataSize);\n\t}\n\treturn GF_OK;\n}", "target": 1, "idx": 11890}
{"commit_id": "1998d1cc5f2985cdeac94d3e669b0e7901a77bbb", "project": "chromium", "func": "ImageBitmap::ImageBitmap(ImageData* data, const IntRect& cropRect)\n    : m_imageElement(nullptr)\n    , m_cropRect(cropRect)\n    , m_bitmapOffset(IntPoint())\n{\n    IntRect srcRect = intersection(cropRect, IntRect(IntPoint(), data->size()));\n    OwnPtr<ImageBuffer> buffer = ImageBuffer::create(data->size(), NonOpaque, DoNotInitializeImagePixels);\n    if (!buffer)\n        return;\n\n    if (srcRect.width() > 0 && srcRect.height() > 0)\n        buffer->putByteArray(Premultiplied, data->data()->data(), data->size(), srcRect, IntPoint(std::min(0, -cropRect.x()), std::min(0, -cropRect.y())));\n\n    m_bitmap = buffer->newImageSnapshot();\n    m_bitmapRect = IntRect(IntPoint(std::max(0, -cropRect.x()), std::max(0, -cropRect.y())),  srcRect.size());\n}", "target": 1, "idx": 11891}
{"commit_id": "a585eae6e7ada1ca9271607a4f48dfb17868ab7b", "project": "lua", "func": "const char *luaG_findlocal (lua_State *L, CallInfo *ci, int n, StkId *pos) {\n  StkId base = ci->func + 1;\n  const char *name = NULL;\n  if (isLua(ci)) {\n    if (n < 0)  /* access to vararg values? */\n      return findvararg(ci, n, pos);\n    else\n      name = luaF_getlocalname(ci_func(ci)->p, n, currentpc(ci));\n  }\n  if (name == NULL) {  /* no 'standard' name? */\n    StkId limit = (ci == L->ci) ? L->top : ci->next->func;\n    if (limit - base >= n && n > 0) {  /* is 'n' inside 'ci' stack? */\n      /* generic name for any valid slot */\n      name = isLua(ci) ? \"(temporary)\" : \"(C temporary)\";\n    }\n    else\n      return NULL;  /* no name */\n  }\n  if (pos)\n    *pos = base + (n - 1);\n  return name;\n}", "target": 1, "idx": 11892}
{"commit_id": "7a7d737a3929f335b9717ddbd31db91151b69ad2", "project": "TicklishHoneyBee/nodau", "func": "static int edit_ext(char* editor, char* name, char* date, char* data)\n{\n\tint fd;\n\tint st;\n\tint sz;\n\tchar* b;\n\tchar* l;\n\tchar buff[512];\n\tpid_t pid;\n\n\tstrcpy(buff,\"/tmp/nodau.XXXXXX\");\n\tfd = mkstemp(buff);\n\n\tif (fd < 0)\n\t\treturn 1;\n\n\tpid = fork();\n\n\tif (pid < 0) {\n\t\treturn 1;\n\t}else if (pid) {\n\t\tclose(fd);\n\t\twaitpid(pid,&st,0);\n\t\tif (!st) {\n\t\t\tif ((fd = open(buff,O_RDONLY)) < 0)\n\t\t\t\treturn 1;\n\t\t\t/* find the file length */\n\t\t\tsz = lseek(fd,0,SEEK_END);\n\t\t\tlseek(fd,0,SEEK_SET);\n\t\t\tif (sz) {\n\t\t\t\t/* load the note into memory */\n\t\t\t\tb = alloca(sz+1);\n\t\t\t\tif (sz != read(fd,b,sz))\n\t\t\t\t\treturn 1;\n\t\t\t\tclose(fd);\n\t\t\t\t/* delete the file */\n\t\t\t\tremove(buff);\n\t\t\t\tb[sz] = 0;\n\t\t\t\t/* find the note data */\n\t\t\t\tl = strstr(b,\"-----\");\n\t\t\t\tif (l) {\n\t\t\t\t\t/* save the note */\n\t\t\t\t\tl += 6;\n\t\t\t\t\tint r = db_update(name,l);\n\t\t\t\t\tif (r != SQLITE_DONE && r != SQLITE_OK)\n\t\t\t\t\t\treturn 1;\n\n\t\t\t\t\t/* let the user know */\n\t\t\t\t\tprintf(\"%s saved\\n\",name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn st;\n\t}\n\n\tsz = strlen(name)+strlen(date)+strlen(data)+50;\n\tb = alloca(sz);\n\n\t/* insert data into file */\n\tsz = sprintf(\n\t\tb,\n\t\t\"%s (%s)\\nText above this line is ignored\\n-----\\n%s\",\n\t\tname,\n\t\tdate,\n\t\tdata\n\t);\n\tif (write(fd,b,sz) != sz) {\n\t\texit(1);\n\t}\n\tfsync(fd);\n\tclose(fd);\n\n\tst = execl(editor,editor,buff,(char*)NULL);\n\n\t/* we should only ever get here if something goes wrong with exec */\n\texit(st);\n\n\t/* and we shouldn't ever get here, but it stops the compiler complaining */\n\treturn 1;\n}", "target": 3, "idx": 11893}
{"commit_id": "652dd12a858989b14eed4e84e453059cd3ba340e", "project": "GNOME/libxml2", "func": "xmlIDPtr\nxmlAddID(xmlValidCtxtPtr ctxt, xmlDocPtr doc, const xmlChar *value,\n         xmlAttrPtr attr) {\n    xmlIDPtr ret;\n    xmlIDTablePtr table;\n\n    if (doc == NULL) {\n\treturn(NULL);\n    }\n    if ((value == NULL) || (value[0] == 0)) {\n\treturn(NULL);\n    }\n    if (attr == NULL) {\n\treturn(NULL);\n    }\n\n    /*\n     * Create the ID table if needed.\n     */\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)  {\n        doc->ids = table = xmlHashCreateDict(0, doc->dict);\n    }\n    if (table == NULL) {\n\txmlVErrMemory(ctxt,\n\t\t\"xmlAddID: Table creation failed!\\n\");\n        return(NULL);\n    }\n\n    ret = (xmlIDPtr) xmlMalloc(sizeof(xmlID));\n    if (ret == NULL) {\n\txmlVErrMemory(ctxt, \"malloc failed\");\n\treturn(NULL);\n    }\n\n    /*\n     * fill the structure.\n     */\n    ret->value = xmlStrdup(value);\n    ret->doc = doc;\n    if (xmlIsStreaming(ctxt)) {\n\t/*\n\t * Operating in streaming mode, attr is gonna disappear\n\t */\n\tif (doc->dict != NULL)\n\t    ret->name = xmlDictLookup(doc->dict, attr->name, -1);\n\telse\n\t    ret->name = xmlStrdup(attr->name);\n\tret->attr = NULL;\n    } else {\n\tret->attr = attr;\n\tret->name = NULL;\n    }\n    ret->lineno = xmlGetLineNo(attr->parent);\n\n    if (xmlHashAddEntry(table, value, ret) < 0) {\n#ifdef LIBXML_VALID_ENABLED\n\t/*\n\t * The id is already defined in this DTD.\n\t */\n\tif (ctxt != NULL) {\n\t    xmlErrValidNode(ctxt, attr->parent, XML_DTD_ID_REDEFINED,\n\t\t\t    \"ID %s already defined\\n\", value, NULL, NULL);\n\t}\n#endif /* LIBXML_VALID_ENABLED */\n\txmlFreeID(ret);\n\treturn(NULL);\n    }\n    if (attr != NULL)\n\tattr->atype = XML_ATTRIBUTE_ID;\n    return(ret);\n}", "target": 2, "idx": 11894}
{"commit_id": "91651bd482b6637cf650700ffd7b3b63de1cb049", "project": "ImageMagick", "func": "static Image *ReadPDBImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  unsigned char\n    attributes,\n    tag[3];\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  PDBImage\n    pdb_image;\n\n  PDBInfo\n    pdb_info;\n\n  Quantum\n    index;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bits_per_pixel,\n    num_pad_bytes,\n    one,\n    packets;\n\n  ssize_t\n    count,\n    img_offset,\n    comment_offset = 0,\n    y;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Determine if this a PDB image file.\n  */\n  count=ReadBlob(image,sizeof(pdb_info.name),(unsigned char *) pdb_info.name);\n  if (count != sizeof(pdb_info.name))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  pdb_info.attributes=(short) ReadBlobMSBShort(image);\n  pdb_info.version=(short) ReadBlobMSBShort(image);\n  pdb_info.create_time=ReadBlobMSBLong(image);\n  pdb_info.modify_time=ReadBlobMSBLong(image);\n  pdb_info.archive_time=ReadBlobMSBLong(image);\n  pdb_info.modify_number=ReadBlobMSBLong(image);\n  pdb_info.application_info=ReadBlobMSBLong(image);\n  pdb_info.sort_info=ReadBlobMSBLong(image);\n  (void) ReadBlob(image,4,(unsigned char *) pdb_info.type);\n  (void) ReadBlob(image,4,(unsigned char *) pdb_info.id);\n  pdb_info.seed=ReadBlobMSBLong(image);\n  pdb_info.next_record=ReadBlobMSBLong(image);\n  pdb_info.number_records=(short) ReadBlobMSBShort(image);\n  if ((memcmp(pdb_info.type,\"vIMG\",4) != 0) ||\n      (memcmp(pdb_info.id,\"View\",4) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (pdb_info.next_record != 0)\n    ThrowReaderException(CoderError,\"MultipleRecordListNotSupported\");\n  /*\n    Read record header.\n  */\n  img_offset=(ssize_t) ReadBlobMSBSignedLong(image);\n  attributes=(unsigned char) ReadBlobByte(image);\n  (void) attributes;\n  count=ReadBlob(image,3,(unsigned char *) tag);\n  if (count != 3  ||  memcmp(tag,\"\\x6f\\x80\\x00\",3) != 0)\n    ThrowReaderException(CorruptImageError,\"CorruptImage\");\n  if (pdb_info.number_records > 1)\n    {\n      comment_offset=(ssize_t) ReadBlobMSBSignedLong(image);\n      attributes=(unsigned char) ReadBlobByte(image);\n      count=ReadBlob(image,3,(unsigned char *) tag);\n      if (count != 3  ||  memcmp(tag,\"\\x6f\\x80\\x01\",3) != 0)\n        ThrowReaderException(CorruptImageError,\"CorruptImage\");\n    }\n  num_pad_bytes = (size_t) (img_offset - TellBlob( image ));\n  while (num_pad_bytes-- != 0)\n  {\n    int\n      c;\n\n    c=ReadBlobByte(image);\n    if (c == EOF)\n      break;\n  }\n  /*\n    Read image header.\n  */\n  count=ReadBlob(image,sizeof(pdb_image.name),(unsigned char *) pdb_image.name);\n  if (count != sizeof(pdb_image.name))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  pdb_image.version=ReadBlobByte(image);\n  pdb_image.type=(unsigned char) (ReadBlobByte(image));\n  pdb_image.reserved_1=ReadBlobMSBLong(image);\n  pdb_image.note=ReadBlobMSBLong(image);\n  pdb_image.x_last=(short) ReadBlobMSBShort(image);\n  pdb_image.y_last=(short) ReadBlobMSBShort(image);\n  pdb_image.reserved_2=ReadBlobMSBLong(image);\n  pdb_image.x_anchor=ReadBlobMSBShort(image);\n  pdb_image.y_anchor=ReadBlobMSBShort(image);\n  pdb_image.width=(short) ReadBlobMSBShort(image);\n  pdb_image.height=(short) ReadBlobMSBShort(image);\n  /*\n    Initialize image structure.\n  */\n  image->columns=(size_t) pdb_image.width;\n  image->rows=(size_t) pdb_image.height;\n  image->depth=8;\n  image->storage_class=PseudoClass;\n  bits_per_pixel=pdb_image.type == 0 ? 2UL : pdb_image.type == 2 ? 4UL : 1UL;\n  one=1;\n  if (AcquireImageColormap(image,one << bits_per_pixel,exception) == MagickFalse)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  packets=(bits_per_pixel*image->columns+7)/8;\n  pixels=(unsigned char *) AcquireQuantumMemory(packets+257UL,image->rows*\n    sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  switch (pdb_image.version & 0x07) \n  {\n    case 0:\n    {\n      image->compression=NoCompression;\n      count=(ssize_t) ReadBlob(image,packets*image->rows,pixels);\n      break;\n    }\n    case 1:\n    {\n      image->compression=RLECompression;\n      if (!DecodeImage(image,pixels,packets*image->rows))\n        {\n          pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n          ThrowReaderException(CorruptImageError,\"RLEDecoderError\");\n        }\n      break;\n    }\n    default:\n    {\n      pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      ThrowReaderException(CorruptImageError,\n        \"UnrecognizedImageCompressionType\");\n    }\n  }\n  p=pixels;\n  switch (bits_per_pixel)\n  {\n    case 1:\n    {\n      int\n        bit;\n\n      /*\n        Read 1-bit PDB image.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n        {\n          for (bit=0; bit < 8; bit++)\n          {\n            index=(Quantum) (*p & (0x80 >> bit) ? 0x00 : 0x01);\n            SetPixelIndex(image,index,q);\n            q+=GetPixelChannels(image);\n          }\n          p++;\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n      (void) SyncImage(image,exception);\n      break;\n    }\n    case 2:\n    {\n      /*\n        Read 2-bit PDB image.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) image->columns-3; x+=4)\n        {\n          index=ConstrainColormapIndex(image,3UL-((*p >> 6) & 0x03),exception);\n          SetPixelIndex(image,index,q);\n          q+=GetPixelChannels(image);\n          index=ConstrainColormapIndex(image,3UL-((*p >> 4) & 0x03),exception);\n          SetPixelIndex(image,index,q);\n          q+=GetPixelChannels(image);\n          index=ConstrainColormapIndex(image,3UL-((*p >> 2) & 0x03),exception);\n          SetPixelIndex(image,index,q);\n          q+=GetPixelChannels(image);\n          index=ConstrainColormapIndex(image,3UL-((*p) & 0x03),exception);\n          SetPixelIndex(image,index,q);\n          p++;\n          q+=GetPixelChannels(image);\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n      (void) SyncImage(image,exception);\n      break;\n    }\n    case 4:\n    {\n      /*\n        Read 4-bit PDB image.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) image->columns-1; x+=2)\n        {\n          index=ConstrainColormapIndex(image,15UL-((*p >> 4) & 0x0f),exception);\n          SetPixelIndex(image,index,q);\n          q+=GetPixelChannels(image);\n          index=ConstrainColormapIndex(image,15UL-((*p) & 0x0f),exception);\n          SetPixelIndex(image,index,q);\n          p++;\n          q+=GetPixelChannels(image);\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n      (void) SyncImage(image,exception);\n      break;\n    }\n    default:\n    {\n      pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  }\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  if (pdb_info.number_records > 1)\n    {\n      char\n        *comment;\n\n      int\n        c;\n\n      register char\n        *p;\n\n      size_t\n        length;\n\n      num_pad_bytes = (size_t) (comment_offset - TellBlob( image ));\n      while (num_pad_bytes-- != 0)\n      {\n        int\n          c;\n\n        c=ReadBlobByte(image);\n        if (c == EOF)\n          break;\n      }\n\n      /*\n        Read comment.\n      */\n      c=ReadBlobByte(image);\n      length=MagickPathExtent;\n      comment=AcquireString((char *) NULL);\n      for (p=comment; c != EOF; p++)\n      {\n        if ((size_t) (p-comment+MagickPathExtent) >= length)\n          {\n            *p='\\0';\n            length<<=1;\n            length+=MagickPathExtent;\n            comment=(char *) ResizeQuantumMemory(comment,length+MagickPathExtent,\n              sizeof(*comment));\n            if (comment == (char *) NULL)\n              break;\n            p=comment+strlen(comment);\n          }\n        *p=c;\n        c=ReadBlobByte(image);\n      }\n      *p='\\0';\n      if (comment == (char *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      (void) SetImageProperty(image,\"comment\",comment,exception);\n      comment=DestroyString(comment);\n    }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}", "target": 1, "idx": 11895}
{"commit_id": "e7af6307a8a54f0b873960b32b6a644f2d0fbd97", "project": "torvalds/linux", "func": "int snd_timer_open(struct snd_timer_instance **ti,\n\t\t   char *owner, struct snd_timer_id *tid,\n\t\t   unsigned int slave_id)\n{\n\tstruct snd_timer *timer;\n\tstruct snd_timer_instance *timeri = NULL;\n\tstruct device *card_dev_to_put = NULL;\n\tint err;\n\n\tmutex_lock(&register_mutex);\n\tif (tid->dev_class == SNDRV_TIMER_CLASS_SLAVE) {\n\t\t/* open a slave instance */\n\t\tif (tid->dev_sclass <= SNDRV_TIMER_SCLASS_NONE ||\n\t\t    tid->dev_sclass > SNDRV_TIMER_SCLASS_OSS_SEQUENCER) {\n\t\t\tpr_debug(\"ALSA: timer: invalid slave class %i\\n\",\n\t\t\t\t tid->dev_sclass);\n\t\t\terr = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\t\ttimeri = snd_timer_instance_new(owner, NULL);\n\t\tif (!timeri) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unlock;\n\t\t}\n\t\ttimeri->slave_class = tid->dev_sclass;\n\t\ttimeri->slave_id = tid->device;\n\t\ttimeri->flags |= SNDRV_TIMER_IFLG_SLAVE;\n\t\tlist_add_tail(&timeri->open_list, &snd_timer_slave_list);\n\t\terr = snd_timer_check_slave(timeri);\n\t\tif (err < 0) {\n\t\t\tsnd_timer_close_locked(timeri, &card_dev_to_put);\n\t\t\ttimeri = NULL;\n\t\t}\n\t\tgoto unlock;\n\t}\n\n\t/* open a master instance */\n\ttimer = snd_timer_find(tid);\n#ifdef CONFIG_MODULES\n\tif (!timer) {\n\t\tmutex_unlock(&register_mutex);\n\t\tsnd_timer_request(tid);\n\t\tmutex_lock(&register_mutex);\n\t\ttimer = snd_timer_find(tid);\n\t}\n#endif\n\tif (!timer) {\n\t\terr = -ENODEV;\n\t\tgoto unlock;\n\t}\n\tif (!list_empty(&timer->open_list_head)) {\n\t\tstruct snd_timer_instance *t =\n\t\t\tlist_entry(timer->open_list_head.next,\n\t\t\t\t    struct snd_timer_instance, open_list);\n\t\tif (t->flags & SNDRV_TIMER_IFLG_EXCLUSIVE) {\n\t\t\terr = -EBUSY;\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\tif (timer->num_instances >= timer->max_instances) {\n\t\terr = -EBUSY;\n\t\tgoto unlock;\n\t}\n\ttimeri = snd_timer_instance_new(owner, timer);\n\tif (!timeri) {\n\t\terr = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\t/* take a card refcount for safe disconnection */\n\tif (timer->card)\n\t\tget_device(&timer->card->card_dev);\n\ttimeri->slave_class = tid->dev_sclass;\n\ttimeri->slave_id = slave_id;\n\n\tif (list_empty(&timer->open_list_head) && timer->hw.open) {\n\t\terr = timer->hw.open(timer);\n\t\tif (err) {\n\t\t\tkfree(timeri->owner);\n\t\t\tkfree(timeri);\n\t\t\ttimeri = NULL;\n\n\t\t\tif (timer->card)\n\t\t\t\tcard_dev_to_put = &timer->card->card_dev;\n\t\t\tmodule_put(timer->module);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tlist_add_tail(&timeri->open_list, &timer->open_list_head);\n\ttimer->num_instances++;\n\terr = snd_timer_check_master(timeri);\n\tif (err < 0) {\n\t\tsnd_timer_close_locked(timeri, &card_dev_to_put);\n\t\ttimeri = NULL;\n\t}\n\n unlock:\n\tmutex_unlock(&register_mutex);\n\t/* put_device() is called after unlock for avoiding deadlock */\n\tif (card_dev_to_put)\n\t\tput_device(card_dev_to_put);\n\t*ti = timeri;\n\treturn err;\n}", "target": 2, "idx": 11896}
{"commit_id": "f9ed2fe6d61259e779a37d4c2d7edb33a1c1f8ba", "project": "android", "func": "bool SoftVPX::outputBuffers(bool flushDecoder, bool display, bool eos, bool *portWillReset) {\n    List<BufferInfo *> &inQueue = getPortQueue(0);\n    List<BufferInfo *> &outQueue = getPortQueue(1);\n    BufferInfo *outInfo = NULL;\n    OMX_BUFFERHEADERTYPE *outHeader = NULL;\n    vpx_codec_iter_t iter = NULL;\n\n    if (flushDecoder && mFrameParallelMode) {\n        // Flush decoder by passing NULL data ptr and 0 size.\n        // Ideally, this should never fail.\n        if (vpx_codec_decode((vpx_codec_ctx_t *)mCtx, NULL, 0, NULL, 0)) {\n            ALOGE(\"Failed to flush on2 decoder.\");\n            return false;\n        }\n    }\n\n    if (!display) {\n        if (!flushDecoder) {\n            ALOGE(\"Invalid operation.\");\n            return false;\n        }\n        // Drop all the decoded frames in decoder.\n        while ((mImg = vpx_codec_get_frame((vpx_codec_ctx_t *)mCtx, &iter))) {\n        }\n        return true;\n    }\n\n    while (!outQueue.empty()) {\n        if (mImg == NULL) {\n            mImg = vpx_codec_get_frame((vpx_codec_ctx_t *)mCtx, &iter);\n            if (mImg == NULL) {\n                break;\n            }\n        }\n        uint32_t width = mImg->d_w;\n        uint32_t height = mImg->d_h;\n        outInfo = *outQueue.begin();\n        outHeader = outInfo->mHeader;\n        CHECK_EQ(mImg->fmt, VPX_IMG_FMT_I420);\n        handlePortSettingsChange(portWillReset, width, height);\n        if (*portWillReset) {\n            return true;\n        }\n\n        outHeader->nOffset = 0;\n        outHeader->nFlags = 0;\n        outHeader->nFilledLen = (outputBufferWidth() * outputBufferHeight() * 3) / 2;\n        outHeader->nTimeStamp = *(OMX_TICKS *)mImg->user_priv;\n        if (outHeader->nAllocLen >= outHeader->nFilledLen) {\n            uint8_t *dst = outHeader->pBuffer;\n            const uint8_t *srcY = (const uint8_t *)mImg->planes[VPX_PLANE_Y];\n            const uint8_t *srcU = (const uint8_t *)mImg->planes[VPX_PLANE_U];\n            const uint8_t *srcV = (const uint8_t *)mImg->planes[VPX_PLANE_V];\n            size_t srcYStride = mImg->stride[VPX_PLANE_Y];\n            size_t srcUStride = mImg->stride[VPX_PLANE_U];\n            size_t srcVStride = mImg->stride[VPX_PLANE_V];\n            copyYV12FrameToOutputBuffer(dst, srcY, srcU, srcV, srcYStride, srcUStride, srcVStride);\n        } else {\n            ALOGE(\"b/27597103, buffer too small\");\n            android_errorWriteLog(0x534e4554, \"27597103\");\n            outHeader->nFilledLen = 0;\n        }\n\n        mImg = NULL;\n        outInfo->mOwnedByUs = false;\n        outQueue.erase(outQueue.begin());\n        outInfo = NULL;\n        notifyFillBufferDone(outHeader);\n        outHeader = NULL;\n    }\n\n    if (!eos) {\n        return true;\n    }\n\n    if (!outQueue.empty()) {\n        outInfo = *outQueue.begin();\n        outQueue.erase(outQueue.begin());\n        outHeader = outInfo->mHeader;\n        outHeader->nTimeStamp = 0;\n        outHeader->nFilledLen = 0;\n        outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n        outInfo->mOwnedByUs = false;\n        notifyFillBufferDone(outHeader);\n        mEOSStatus = OUTPUT_FRAMES_FLUSHED;\n    }\n    return true;\n}", "target": 2, "idx": 11897}
{"commit_id": "43ea0649d4b70fdcf3e9fa5c03aee1bbba0b04bb", "project": "chromium", "func": "void DidCreateDocumentElement() override {\n    // Defer the callback instead of running it now to avoid re-entrancy caused\n    // by the JavaScript callback.\n    ExtensionFrameHelper::Get(render_frame())\n        ->ScheduleAtDocumentStart(base::Bind(callback_, true));\n    delete this;\n  }", "target": 2, "idx": 11898}
{"commit_id": "05a974efa4bdf6e2a150e3f27dc6fcf0a9ad5655", "project": "torvalds/linux", "func": "static int atusb_read_reg(struct atusb *atusb, uint8_t reg)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tint ret;\n\tuint8_t *buffer;\n\tuint8_t value;\n\n\tbuffer = kmalloc(1, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tdev_dbg(&usb_dev->dev, \"atusb: reg = 0x%x\\n\", reg);\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_REG_READ, ATUSB_REQ_FROM_DEV,\n\t\t\t\t0, reg, buffer, 1, 1000);\n\n\tif (ret >= 0) {\n\t\tvalue = buffer[0];\n\t\tkfree(buffer);\n\t\treturn value;\n\t} else {\n\t\tkfree(buffer);\n\t\treturn ret;\n\t}\n}", "target": 2, "idx": 11899}
{"commit_id": "fc522ff6eb1bbb85e3de60c60a45762571e48c28", "project": "crawl", "func": "void CLua::init_libraries()\n{\n    lua_stack_cleaner clean(state());\n\n    lua_pushcfunction(_state, lua_loadstring);\n    lua_setglobal(_state, \"loadstring\");\n    lua_pushnil(_state);\n    lua_setglobal(_state, \"load\");\n\n    // Open Crawl bindings\n    cluaopen_kills(_state);\n    cluaopen_you(_state);\n    cluaopen_item(_state);\n    cluaopen_food(_state);\n    cluaopen_crawl(_state);\n    cluaopen_file(_state);\n    cluaopen_moninf(_state);\n    cluaopen_options(_state);\n    cluaopen_travel(_state);\n    cluaopen_view(_state);\n    cluaopen_spells(_state);\n\n    cluaopen_globals(_state);\n\n    execfile(\"dlua/macro.lua\", true, true);\n\n    // All hook names must be chk_????\n    execstring(\"chk_startgame = { }\", \"base\");\n\n    lua_register(_state, \"loadfile\", _clua_loadfile);\n    lua_register(_state, \"dofile\", _clua_dofile);\n\n    lua_register(_state, \"crawl_require\", _clua_require);\n\n    execfile(\"dlua/util.lua\", true, true);\n    execfile(\"dlua/iter.lua\", true, true);\n    execfile(\"dlua/tags.lua\", true, true);\n    execfile(\"dlua/init.lua\", true, true);\n\n    if (managed_vm)\n    {\n        lua_register(_state, \"pcall\", _clua_guarded_pcall);\n        execfile(\"dlua/userbase.lua\", true, true);\n        execfile(\"dlua/persist.lua\", true, true);\n    }\n}", "target": 3, "idx": 11900}
{"commit_id": "a6f9e300161f4cb54713da22f65b261595e8e614", "project": "vim", "func": "static char_u *\nins_comp_get_next_word_or_line(\n\tbuf_T\t*ins_buf,\t\t// buffer being scanned\n\tpos_T\t*cur_match_pos,\t\t// current match position\n\tint\t*match_len,\n\tint\t*cont_s_ipos)\t\t// next ^X<> will set initial_pos\n{\n    char_u\t*ptr;\n    int\t\tlen;\n\n    *match_len = 0;\n    ptr = ml_get_buf(ins_buf, cur_match_pos->lnum, FALSE) +\n\tcur_match_pos->col;\n    if (ctrl_x_mode_line_or_eval())\n    {\n\tif (compl_status_adding())\n\t{\n\t    if (cur_match_pos->lnum >= ins_buf->b_ml.ml_line_count)\n\t\treturn NULL;\n\t    ptr = ml_get_buf(ins_buf, cur_match_pos->lnum + 1, FALSE);\n\t    if (!p_paste)\n\t\tptr = skipwhite(ptr);\n\t}\n\tlen = (int)STRLEN(ptr);\n    }\n    else\n    {\n\tchar_u\t*tmp_ptr = ptr;\n\n\tif (compl_status_adding() && compl_length <= (int)STRLEN(tmp_ptr))\n\t{\n\t    tmp_ptr += compl_length;\n\t    // Skip if already inside a word.\n\t    if (vim_iswordp(tmp_ptr))\n\t\treturn NULL;\n\t    // Find start of next word.\n\t    tmp_ptr = find_word_start(tmp_ptr);\n\t}\n\t// Find end of this word.\n\ttmp_ptr = find_word_end(tmp_ptr);\n\tlen = (int)(tmp_ptr - ptr);\n\n\tif (compl_status_adding() && len == compl_length)\n\t{\n\t    if (cur_match_pos->lnum < ins_buf->b_ml.ml_line_count)\n\t    {\n\t\t// Try next line, if any. the new word will be\n\t\t// \"join\" as if the normal command \"J\" was used.\n\t\t// IOSIZE is always greater than\n\t\t// compl_length, so the next STRNCPY always\n\t\t// works -- Acevedo\n\t\tSTRNCPY(IObuff, ptr, len);\n\t\tptr = ml_get_buf(ins_buf, cur_match_pos->lnum + 1, FALSE);\n\t\ttmp_ptr = ptr = skipwhite(ptr);\n\t\t// Find start of next word.\n\t\ttmp_ptr = find_word_start(tmp_ptr);\n\t\t// Find end of next word.\n\t\ttmp_ptr = find_word_end(tmp_ptr);\n\t\tif (tmp_ptr > ptr)\n\t\t{\n\t\t    if (*ptr != ')' && IObuff[len - 1] != TAB)\n\t\t    {\n\t\t\tif (IObuff[len - 1] != ' ')\n\t\t\t    IObuff[len++] = ' ';\n\t\t\t// IObuf =~ \"\\k.* \", thus len >= 2\n\t\t\tif (p_js\n\t\t\t\t&& (IObuff[len - 2] == '.'\n\t\t\t\t    || (vim_strchr(p_cpo, CPO_JOINSP)\n\t\t\t\t\t== NULL\n\t\t\t\t\t&& (IObuff[len - 2] == '?'\n\t\t\t\t\t    || IObuff[len - 2] == '!'))))\n\t\t\t    IObuff[len++] = ' ';\n\t\t    }\n\t\t    // copy as much as possible of the new word\n\t\t    if (tmp_ptr - ptr >= IOSIZE - len)\n\t\t\ttmp_ptr = ptr + IOSIZE - len - 1;\n\t\t    STRNCPY(IObuff + len, ptr, tmp_ptr - ptr);\n\t\t    len += (int)(tmp_ptr - ptr);\n\t\t    *cont_s_ipos = TRUE;\n\t\t}\n\t\tIObuff[len] = NUL;\n\t\tptr = IObuff;\n\t    }\n\t    if (len == compl_length)\n\t\treturn NULL;\n\t}\n    }\n\n    *match_len = len;\n    return ptr;\n}", "target": 2, "idx": 11901}
{"commit_id": "441e0115646d54f080e5c3bb0ba477c892861ab9", "project": "systemd", "func": "int unit_name_path_escape(const char *f, char **ret) {\n        _cleanup_free_ char *p = NULL;\n        char *s;\n\n        assert(f);\n        assert(ret);\n\n        p = strdup(f);\n        if (!p)\n                return -ENOMEM;\n\n        path_simplify(p);\n\n        if (empty_or_root(p))\n                s = strdup(\"-\");\n        else {\n                if (!path_is_normalized(p))\n                        return -EINVAL;\n\n                /* Truncate trailing slashes and skip leading slashes */\n                delete_trailing_chars(p, \"/\");\n                s = unit_name_escape(skip_leading_chars(p, \"/\"));\n        }\n        if (!s)\n                return -ENOMEM;\n\n        *ret = s;\n        return 0;\n}", "target": 1, "idx": 11902}
{"commit_id": "d10dcb615c8e29d403a24d35f8310a7a53e3050c", "project": "torvalds/linux", "func": "static int mwifiex_pcie_init_evt_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct mwifiex_evt_buf_desc *desc;\n\tstruct sk_buff *skb;\n\tdma_addr_t buf_pa;\n\tint i;\n\n\tfor (i = 0; i < MWIFIEX_MAX_EVT_BD; i++) {\n\t\t/* Allocate skb here so that firmware can DMA data from it */\n\t\tskb = dev_alloc_skb(MAX_EVENT_SIZE);\n\t\tif (!skb) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Unable to allocate skb for EVENT buf.\\n\");\n\t\t\tkfree(card->evtbd_ring_vbase);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tskb_put(skb, MAX_EVENT_SIZE);\n\n\t\tif (mwifiex_map_pci_memory(adapter, skb, MAX_EVENT_SIZE,\n\t\t\t\t\t   PCI_DMA_FROMDEVICE)) {\n\t\t\tkfree_skb(skb);\n\t\t\tkfree(card->evtbd_ring_vbase);\n\t\t\treturn -1;\n\t\t}\n\n\t\tbuf_pa = MWIFIEX_SKB_DMA_ADDR(skb);\n\n\t\tmwifiex_dbg(adapter, EVENT,\n\t\t\t    \"info: EVT ring: skb=%p len=%d data=%p buf_pa=%#x:%x\\n\",\n\t\t\t    skb, skb->len, skb->data, (u32)buf_pa,\n\t\t\t    (u32)((u64)buf_pa >> 32));\n\n\t\tcard->evt_buf_list[i] = skb;\n\t\tcard->evtbd_ring[i] = (void *)(card->evtbd_ring_vbase +\n\t\t\t\t      (sizeof(*desc) * i));\n\t\tdesc = card->evtbd_ring[i];\n\t\tdesc->paddr = buf_pa;\n\t\tdesc->len = (u16)skb->len;\n\t\tdesc->flags = 0;\n\t}\n\n\treturn 0;\n}", "target": 0, "idx": 11903}
{"commit_id": "31c1c0b46a7021802c3d1d18039fca30dba5a14e", "project": "ffmpeg", "func": "static int dnxhd_find_frame_end(DNXHDParserContext *dctx,\n                                const uint8_t *buf, int buf_size)\n{\n    ParseContext *pc = &dctx->pc;\n    uint64_t state = pc->state64;\n    int pic_found = pc->frame_start_found;\n    int i = 0;\n    int interlaced = dctx->interlaced;\n    int cur_field = dctx->cur_field;\n\n    if (!pic_found) {\n        for (i = 0; i < buf_size; i++) {\n            state = (state << 8) | buf[i];\n            if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {\n                i++;\n                pic_found = 1;\n                interlaced = (state&2)>>1; /* byte following the 5-byte header prefix */\n                cur_field = state&1;\n                dctx->cur_byte = 0;\n                dctx->remaining = 0;\n                break;\n            }\n        }\n    }\n\n    if (pic_found && !dctx->remaining) {\n        if (!buf_size) /* EOF considered as end of frame */\n            return 0;\n        for (; i < buf_size; i++) {\n            dctx->cur_byte++;\n            state = (state << 8) | buf[i];\n\n            if (dctx->cur_byte == 24) {\n                dctx->h = (state >> 32) & 0xFFFF;\n            } else if (dctx->cur_byte == 26) {\n                dctx->w = (state >> 32) & 0xFFFF;\n            } else if (dctx->cur_byte == 42) {\n                int cid = (state >> 32) & 0xFFFFFFFF;\n                int remaining;\n\n                if (cid <= 0)\n                    continue;\n\n                remaining = avpriv_dnxhd_get_frame_size(cid);\n                if (remaining <= 0) {\n                    remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);\n                    if (remaining <= 0)\n                        continue;\n                }\n                dctx->remaining = remaining;\n                if (buf_size - i >= dctx->remaining && (!dctx->interlaced || dctx->cur_field)) {\n                    int remaining = dctx->remaining;\n\n                    pc->frame_start_found = 0;\n                    pc->state64 = -1;\n                    dctx->interlaced = interlaced;\n                    dctx->cur_field = 0;\n                    dctx->cur_byte = 0;\n                    dctx->remaining = 0;\n                    return remaining;\n                } else {\n                    dctx->remaining -= buf_size;\n                }\n            }\n        }\n    } else if (pic_found) {\n        if (dctx->remaining > buf_size) {\n            dctx->remaining -= buf_size;\n        } else {\n            int remaining = dctx->remaining;\n\n            pc->frame_start_found = 0;\n            pc->state64 = -1;\n            dctx->interlaced = interlaced;\n            dctx->cur_field = 0;\n            dctx->cur_byte = 0;\n            dctx->remaining = 0;\n            return remaining;\n        }\n    }\n    pc->frame_start_found = pic_found;\n    pc->state64 = state;\n    dctx->interlaced = interlaced;\n    dctx->cur_field = cur_field;\n    return END_NOT_FOUND;\n}", "target": 1, "idx": 11904}
{"commit_id": "a4f247707f08e322f0b41e82c3e06e224240a654", "project": "jsummers/imageworsener", "func": "static int bmpr_read_rle(struct iwbmprcontext *rctx)\n{\n\tint retval = 0;\n\n\tif(!(rctx->compression==IWBMP_BI_RLE8 && rctx->bitcount==8) &&\n\t\t!(rctx->compression==IWBMP_BI_RLE4 && rctx->bitcount==4))\n\t{\n\t\tiw_set_error(rctx->ctx,\"Compression type incompatible with image type\");\n\t\tgoto done;\n\t}\n\n\tif(rctx->topdown) {\n\t\t// The documentation says that top-down images may not be compressed.\n\t\tiw_set_error(rctx->ctx,\"Compression not allowed with top-down images\");\n\t\tgoto done;\n\t}\n\n\t// RLE-compressed BMP images don't have to assign a color to every pixel,\n\t// and it's reasonable to interpret undefined pixels as transparent.\n\t// I'm not going to worry about handling compressed BMP images as\n\t// efficiently as possible, so start with an RGBA image, and convert to\n\t// RGB format later if (as is almost always the case) there was no\n\t// transparency.\n\trctx->img->imgtype = IW_IMGTYPE_RGBA;\n\trctx->img->bit_depth = 8;\n\trctx->img->bpr = iw_calc_bytesperrow(rctx->width,32);\n\n\trctx->img->pixels = (iw_byte*)iw_malloc_large(rctx->ctx,rctx->img->bpr,rctx->img->height);\n\tif(!rctx->img->pixels) goto done;\n\n\tif(!bmpr_read_rle_internal(rctx)) goto done;\n\n\tif(!bmpr_has_transparency(rctx->img)) {\n\t\tbmpr_strip_alpha(rctx->img);\n\t}\n\n\tretval = 1;\ndone:\n\treturn retval;\n}", "target": 1, "idx": 11905}
{"commit_id": "6880f193583f0c80a58d477f6339958e7f078a89", "project": "MonetDB", "func": "sql_rel *\nrel_groupby(mvc *sql, sql_rel *l, list *groupbyexps )\n{\n\tsql_rel *rel = rel_create(sql->sa);\n\tlist *aggrs = new_exp_list(sql->sa);\n\tnode *en;\n\tif(!rel || !aggrs) {\n\t\trel_destroy(rel);\n\t\treturn NULL;\n\t}\n\n\trel->card = CARD_ATOM;\n\t/* reduce duplicates in groupbyexps */\n\tif (groupbyexps && list_length(groupbyexps) > 1) {\n\t\tlist *gexps = sa_list(sql->sa);\n\n\t\tfor (en = groupbyexps->h; en; en = en->next) {\n\t\t\tsql_exp *e = en->data, *ne = exps_find_exp(gexps, e);\n\n\t\t\tif (!ne) {\n\t\t\t\tlist_append(gexps, e);\n\t\t\t} else {\n\t\t\t\tconst char *ername = exp_relname(e), *nername = exp_relname(ne), *ename = exp_name(e), *nename = exp_name(ne);\n\t\t\t\tif ((ername && !nername) || (!ername && nername) ||\n\t\t\t\t\t(ername && nername && strcmp(ername,nername) != 0) || strcmp(ename,nename) != 0)\n\t\t\t\t\tlist_append(gexps, e);\n\t\t\t}\n\t\t}\n\t\tgroupbyexps = gexps;\n\t}\n\n\tif (groupbyexps) {\n\t\trel->card = CARD_AGGR;\n\t\tfor (en = groupbyexps->h; en; en = en->next) {\n\t\t\tsql_exp *e = en->data, *ne;\n\n\t\t\t/* after the group by the cardinality reduces */\n\t\t\te->card = MIN(e->card, rel->card); /* if the column is an atom, the cardinality should not change */\n\t\t\tne = exp_ref(sql, e);\n\t\t\tne = exp_propagate(sql->sa, ne, e);\n\t\t\tappend(aggrs, ne);\n\t\t}\n\t}\n\trel->l = l;\n\trel->r = groupbyexps;\n\trel->exps = aggrs;\n\trel->nrcols = aggrs?list_length(aggrs):0;\n\trel->op = op_groupby;\n\trel->grouped = 1;\n\treturn rel;\n}", "target": 2, "idx": 11906}
{"commit_id": "d4dfa6c62270ea34fcc859355a66bc25b8175237", "project": "eclipse-openj9/openj9", "func": "static UDATA\npredefinedHandlerWrapper(struct J9PortLibrary *portLibrary, U_32 gpType, void *gpInfo, void *userData)\n{\n\tJ9JavaVM *vm = (J9JavaVM *)userData;\n\tJ9JavaVMAttachArgs attachArgs = {0};\n\tJ9VMThread *vmThread = NULL;\n\tIDATA result = JNI_ERR;\n\tBOOLEAN invokeHandler = TRUE;\n\tI_32 signal = 0;\n\tU_32 runtimeFlags = 0;\n\tPORT_ACCESS_FROM_JAVAVM(vm);\n\n\tsignal = j9sig_map_portlib_signal_to_os_signal(gpType);\n\t/* Don't invoke handler if signal is 0 or negative, or if -Xrs or -Xrs:async is specified */\n\tif ((signal <= 0) || J9_ARE_ANY_BITS_SET(vm->sigFlags, J9_SIG_XRS_ASYNC)) {\n\t\treturn 1;\n\t}\n\n\t/* Don't invoke handler if JVM hasn't initialized or JVM exit has started. */\n\tissueReadBarrier();\n\truntimeFlags = vm->runtimeFlags;\n\tif (J9_ARE_NO_BITS_SET(runtimeFlags, J9_RUNTIME_INITIALIZED)\n\t|| J9_ARE_ANY_BITS_SET(runtimeFlags, J9_RUNTIME_EXIT_STARTED)\n\t) {\n\t\tinvokeHandler = FALSE;\n\t}\n\n\tif (!invokeHandler) {\n\t\treturn 1;\n\t}\n\n\tattachArgs.version = JNI_VERSION_1_8;\n\tattachArgs.name = \"JVM Signal Thread\";\n\tattachArgs.group = vm->systemThreadGroupRef;\n\n\t/* Attach current thread as a daemon thread */\n\tresult = internalAttachCurrentThread(vm, &vmThread, &attachArgs,\n\t\t\t\tJ9_PRIVATE_FLAGS_DAEMON_THREAD | J9_PRIVATE_FLAGS_SYSTEM_THREAD | J9_PRIVATE_FLAGS_ATTACHED_THREAD,\n\t\t\t\tomrthread_self());\n\n\tif (JNI_OK != result) {\n\t\t/* Thread couldn't be attached. So, we can't run Java code. */\n\t\treturn 1;\n\t}\n\n\t/* Run handler (Java code). */\n\tsignalDispatch(vmThread, signal);\n\n\tDetachCurrentThread((JavaVM *)vm);\n\n\treturn 0;\n}", "target": 1, "idx": 11907}
{"commit_id": "8279af514ca7e5fd3c31cf13b0864163d1a0bfeb", "project": "vim", "func": "void\nwin_new_width(win_T *wp, int width)\n{\n    // Should we give an error if width < 0?\n    wp->w_width = width < 0 ? 0 : width;\n    wp->w_lines_valid = 0;\n    changed_line_abv_curs_win(wp);\n    // Handled in win_fix_scroll()\n    if (p_spsc)\n    {\n\tinvalidate_botline_win(wp);\n\tif (wp == curwin)\n\t{\n\t    update_topline();\n\t    curs_columns(TRUE);\t// validate w_wrow\n\t}\n    }\n    redraw_win_later(wp, UPD_NOT_VALID);\n    wp->w_redr_status = TRUE;\n}", "target": 2, "idx": 11908}
{"commit_id": "2ba1fe7a06d3624f9a7586d672b55f08f7c670f3", "project": "torvalds/linux", "func": "static int snd_hrtimer_stop(struct snd_timer *t)\n{\n\tstruct snd_hrtimer *stime = t->private_data;\n\tatomic_set(&stime->running, 0);\n\thrtimer_try_to_cancel(&stime->hrt);\n\treturn 0;\n}", "target": 1, "idx": 11909}
{"commit_id": "f57bd745b4cbed577ea654fad4701bea4d38b44c", "project": "moonlight-stream/moonlight-common-c", "func": "int sendInputPacketOnControlStream(unsigned char* data, int length) {\n    LC_ASSERT(AppVersionQuad[0] >= 5);\n\n    // Send the input data (no reply expected)\n    if (sendMessageAndForget(packetTypes[IDX_INPUT_DATA], length, data) == 0) {\n        return -1;\n    }\n\n    return 0;\n}", "target": 2, "idx": 11910}
{"commit_id": "48b71a9e66c2eab60564b1b1c85f4928ed04e406", "project": "torvalds/linux", "func": "static int nci_open_device(struct nci_dev *ndev)\n{\n\tint rc = 0;\n\n\tmutex_lock(&ndev->req_lock);\n\n\tif (test_bit(NCI_UNREG, &ndev->flags)) {\n\t\trc = -ENODEV;\n\t\tgoto done;\n\t}\n\n\tif (test_bit(NCI_UP, &ndev->flags)) {\n\t\trc = -EALREADY;\n\t\tgoto done;\n\t}\n\n\tif (ndev->ops->open(ndev)) {\n\t\trc = -EIO;\n\t\tgoto done;\n\t}\n\n\tatomic_set(&ndev->cmd_cnt, 1);\n\n\tset_bit(NCI_INIT, &ndev->flags);\n\n\tif (ndev->ops->init)\n\t\trc = ndev->ops->init(ndev);\n\n\tif (!rc) {\n\t\trc = __nci_request(ndev, nci_reset_req, (void *)0,\n\t\t\t\t   msecs_to_jiffies(NCI_RESET_TIMEOUT));\n\t}\n\n\tif (!rc && ndev->ops->setup) {\n\t\trc = ndev->ops->setup(ndev);\n\t}\n\n\tif (!rc) {\n\t\tstruct nci_core_init_v2_cmd nci_init_v2_cmd = {\n\t\t\t.feature1 = NCI_FEATURE_DISABLE,\n\t\t\t.feature2 = NCI_FEATURE_DISABLE\n\t\t};\n\t\tconst void *opt = NULL;\n\n\t\tif (ndev->nci_ver & NCI_VER_2_MASK)\n\t\t\topt = &nci_init_v2_cmd;\n\n\t\trc = __nci_request(ndev, nci_init_req, opt,\n\t\t\t\t   msecs_to_jiffies(NCI_INIT_TIMEOUT));\n\t}\n\n\tif (!rc && ndev->ops->post_setup)\n\t\trc = ndev->ops->post_setup(ndev);\n\n\tif (!rc) {\n\t\trc = __nci_request(ndev, nci_init_complete_req, (void *)0,\n\t\t\t\t   msecs_to_jiffies(NCI_INIT_TIMEOUT));\n\t}\n\n\tclear_bit(NCI_INIT, &ndev->flags);\n\n\tif (!rc) {\n\t\tset_bit(NCI_UP, &ndev->flags);\n\t\tnci_clear_target_list(ndev);\n\t\tatomic_set(&ndev->state, NCI_IDLE);\n\t} else {\n\t\t/* Init failed, cleanup */\n\t\tskb_queue_purge(&ndev->cmd_q);\n\t\tskb_queue_purge(&ndev->rx_q);\n\t\tskb_queue_purge(&ndev->tx_q);\n\n\t\tndev->ops->close(ndev);\n\t\tndev->flags = 0;\n\t}\n\ndone:\n\tmutex_unlock(&ndev->req_lock);\n\treturn rc;\n}", "target": 2, "idx": 11911}
{"commit_id": "05692d7005a364add85c6e25a6c4447ce08f913a", "project": "torvalds/linux", "func": "static long vfio_pci_ioctl(void *device_data,\n\t\t\t   unsigned int cmd, unsigned long arg)\n{\n\tstruct vfio_pci_device *vdev = device_data;\n\tunsigned long minsz;\n\n\tif (cmd == VFIO_DEVICE_GET_INFO) {\n\t\tstruct vfio_device_info info;\n\n\t\tminsz = offsetofend(struct vfio_device_info, num_irqs);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\tinfo.flags = VFIO_DEVICE_FLAGS_PCI;\n\n\t\tif (vdev->reset_works)\n\t\t\tinfo.flags |= VFIO_DEVICE_FLAGS_RESET;\n\n\t\tinfo.num_regions = VFIO_PCI_NUM_REGIONS + vdev->num_regions;\n\t\tinfo.num_irqs = VFIO_PCI_NUM_IRQS;\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\n\t} else if (cmd == VFIO_DEVICE_GET_REGION_INFO) {\n\t\tstruct pci_dev *pdev = vdev->pdev;\n\t\tstruct vfio_region_info info;\n\t\tstruct vfio_info_cap caps = { .buf = NULL, .size = 0 };\n\t\tint i, ret;\n\n\t\tminsz = offsetofend(struct vfio_region_info, offset);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (info.index) {\n\t\tcase VFIO_PCI_CONFIG_REGION_INDEX:\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = pdev->cfg_size;\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ |\n\t\t\t\t     VFIO_REGION_INFO_FLAG_WRITE;\n\t\t\tbreak;\n\t\tcase VFIO_PCI_BAR0_REGION_INDEX ... VFIO_PCI_BAR5_REGION_INDEX:\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = pci_resource_len(pdev, info.index);\n\t\t\tif (!info.size) {\n\t\t\t\tinfo.flags = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ |\n\t\t\t\t     VFIO_REGION_INFO_FLAG_WRITE;\n\t\t\tif (vdev->bar_mmap_supported[info.index]) {\n\t\t\t\tinfo.flags |= VFIO_REGION_INFO_FLAG_MMAP;\n\t\t\t\tif (info.index == vdev->msix_bar) {\n\t\t\t\t\tret = msix_sparse_mmap_cap(vdev, &caps);\n\t\t\t\t\tif (ret)\n\t\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase VFIO_PCI_ROM_REGION_INDEX:\n\t\t{\n\t\t\tvoid __iomem *io;\n\t\t\tsize_t size;\n\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.flags = 0;\n\n\t\t\t/* Report the BAR size, not the ROM size */\n\t\t\tinfo.size = pci_resource_len(pdev, info.index);\n\t\t\tif (!info.size) {\n\t\t\t\t/* Shadow ROMs appear as PCI option ROMs */\n\t\t\t\tif (pdev->resource[PCI_ROM_RESOURCE].flags &\n\t\t\t\t\t\t\tIORESOURCE_ROM_SHADOW)\n\t\t\t\t\tinfo.size = 0x20000;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Is it really there? */\n\t\t\tio = pci_map_rom(pdev, &size);\n\t\t\tif (!io || !size) {\n\t\t\t\tinfo.size = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpci_unmap_rom(pdev, io);\n\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ;\n\t\t\tbreak;\n\t\t}\n\t\tcase VFIO_PCI_VGA_REGION_INDEX:\n\t\t\tif (!vdev->has_vga)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = 0xc0000;\n\t\t\tinfo.flags = VFIO_REGION_INFO_FLAG_READ |\n\t\t\t\t     VFIO_REGION_INFO_FLAG_WRITE;\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (info.index >=\n\t\t\t    VFIO_PCI_NUM_REGIONS + vdev->num_regions)\n\t\t\t\treturn -EINVAL;\n\n\t\t\ti = info.index - VFIO_PCI_NUM_REGIONS;\n\n\t\t\tinfo.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);\n\t\t\tinfo.size = vdev->region[i].size;\n\t\t\tinfo.flags = vdev->region[i].flags;\n\n\t\t\tret = region_type_cap(vdev, &caps,\n\t\t\t\t\t      vdev->region[i].type,\n\t\t\t\t\t      vdev->region[i].subtype);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tif (caps.size) {\n\t\t\tinfo.flags |= VFIO_REGION_INFO_FLAG_CAPS;\n\t\t\tif (info.argsz < sizeof(info) + caps.size) {\n\t\t\t\tinfo.argsz = sizeof(info) + caps.size;\n\t\t\t\tinfo.cap_offset = 0;\n\t\t\t} else {\n\t\t\t\tvfio_info_cap_shift(&caps, sizeof(info));\n\t\t\t\tif (copy_to_user((void __user *)arg +\n\t\t\t\t\t\t  sizeof(info), caps.buf,\n\t\t\t\t\t\t  caps.size)) {\n\t\t\t\t\tkfree(caps.buf);\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\t}\n\t\t\t\tinfo.cap_offset = sizeof(info);\n\t\t\t}\n\n\t\t\tkfree(caps.buf);\n\t\t}\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\n\t} else if (cmd == VFIO_DEVICE_GET_IRQ_INFO) {\n\t\tstruct vfio_irq_info info;\n\n\t\tminsz = offsetofend(struct vfio_irq_info, count);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz || info.index >= VFIO_PCI_NUM_IRQS)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (info.index) {\n\t\tcase VFIO_PCI_INTX_IRQ_INDEX ... VFIO_PCI_MSIX_IRQ_INDEX:\n\t\tcase VFIO_PCI_REQ_IRQ_INDEX:\n\t\t\tbreak;\n\t\tcase VFIO_PCI_ERR_IRQ_INDEX:\n\t\t\tif (pci_is_pcie(vdev->pdev))\n\t\t\t\tbreak;\n\t\t/* pass thru to return error */\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tinfo.flags = VFIO_IRQ_INFO_EVENTFD;\n\n\t\tinfo.count = vfio_pci_get_irq_count(vdev, info.index);\n\n\t\tif (info.index == VFIO_PCI_INTX_IRQ_INDEX)\n\t\t\tinfo.flags |= (VFIO_IRQ_INFO_MASKABLE |\n\t\t\t\t       VFIO_IRQ_INFO_AUTOMASKED);\n\t\telse\n\t\t\tinfo.flags |= VFIO_IRQ_INFO_NORESIZE;\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\n\t} else if (cmd == VFIO_DEVICE_SET_IRQS) {\n\t\tstruct vfio_irq_set hdr;\n\t\tsize_t size;\n\t\tu8 *data = NULL;\n\t\tint max, ret = 0;\n\n\t\tminsz = offsetofend(struct vfio_irq_set, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (hdr.argsz < minsz || hdr.index >= VFIO_PCI_NUM_IRQS ||\n\t\t    hdr.count >= (U32_MAX - hdr.start) ||\n\t\t    hdr.flags & ~(VFIO_IRQ_SET_DATA_TYPE_MASK |\n\t\t\t\t  VFIO_IRQ_SET_ACTION_TYPE_MASK))\n\t\t\treturn -EINVAL;\n\n\t\tmax = vfio_pci_get_irq_count(vdev, hdr.index);\n\t\tif (hdr.start >= max || hdr.start + hdr.count > max)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (hdr.flags & VFIO_IRQ_SET_DATA_TYPE_MASK) {\n\t\tcase VFIO_IRQ_SET_DATA_NONE:\n\t\t\tsize = 0;\n\t\t\tbreak;\n\t\tcase VFIO_IRQ_SET_DATA_BOOL:\n\t\t\tsize = sizeof(uint8_t);\n\t\t\tbreak;\n\t\tcase VFIO_IRQ_SET_DATA_EVENTFD:\n\t\t\tsize = sizeof(int32_t);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (size) {\n\t\t\tif (hdr.argsz - minsz < hdr.count * size)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tdata = memdup_user((void __user *)(arg + minsz),\n\t\t\t\t\t   hdr.count * size);\n\t\t\tif (IS_ERR(data))\n\t\t\t\treturn PTR_ERR(data);\n\t\t}\n\n\t\tmutex_lock(&vdev->igate);\n\n\t\tret = vfio_pci_set_irqs_ioctl(vdev, hdr.flags, hdr.index,\n\t\t\t\t\t      hdr.start, hdr.count, data);\n\n\t\tmutex_unlock(&vdev->igate);\n\t\tkfree(data);\n\n\t\treturn ret;\n\n\t} else if (cmd == VFIO_DEVICE_RESET) {\n\t\treturn vdev->reset_works ?\n\t\t\tpci_try_reset_function(vdev->pdev) : -EINVAL;\n\n\t} else if (cmd == VFIO_DEVICE_GET_PCI_HOT_RESET_INFO) {\n\t\tstruct vfio_pci_hot_reset_info hdr;\n\t\tstruct vfio_pci_fill_info fill = { 0 };\n\t\tstruct vfio_pci_dependent_device *devices = NULL;\n\t\tbool slot = false;\n\t\tint ret = 0;\n\n\t\tminsz = offsetofend(struct vfio_pci_hot_reset_info, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (hdr.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\thdr.flags = 0;\n\n\t\t/* Can we do a slot or bus reset or neither? */\n\t\tif (!pci_probe_reset_slot(vdev->pdev->slot))\n\t\t\tslot = true;\n\t\telse if (pci_probe_reset_bus(vdev->pdev->bus))\n\t\t\treturn -ENODEV;\n\n\t\t/* How many devices are affected? */\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_count_devs,\n\t\t\t\t\t\t    &fill.max, slot);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tWARN_ON(!fill.max); /* Should always be at least one */\n\n\t\t/*\n\t\t * If there's enough space, fill it now, otherwise return\n\t\t * -ENOSPC and the number of devices affected.\n\t\t */\n\t\tif (hdr.argsz < sizeof(hdr) + (fill.max * sizeof(*devices))) {\n\t\t\tret = -ENOSPC;\n\t\t\thdr.count = fill.max;\n\t\t\tgoto reset_info_exit;\n\t\t}\n\n\t\tdevices = kcalloc(fill.max, sizeof(*devices), GFP_KERNEL);\n\t\tif (!devices)\n\t\t\treturn -ENOMEM;\n\n\t\tfill.devices = devices;\n\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_fill_devs,\n\t\t\t\t\t\t    &fill, slot);\n\n\t\t/*\n\t\t * If a device was removed between counting and filling,\n\t\t * we may come up short of fill.max.  If a device was\n\t\t * added, we'll have a return of -EAGAIN above.\n\t\t */\n\t\tif (!ret)\n\t\t\thdr.count = fill.cur;\n\nreset_info_exit:\n\t\tif (copy_to_user((void __user *)arg, &hdr, minsz))\n\t\t\tret = -EFAULT;\n\n\t\tif (!ret) {\n\t\t\tif (copy_to_user((void __user *)(arg + minsz), devices,\n\t\t\t\t\t hdr.count * sizeof(*devices)))\n\t\t\t\tret = -EFAULT;\n\t\t}\n\n\t\tkfree(devices);\n\t\treturn ret;\n\n\t} else if (cmd == VFIO_DEVICE_PCI_HOT_RESET) {\n\t\tstruct vfio_pci_hot_reset hdr;\n\t\tint32_t *group_fds;\n\t\tstruct vfio_pci_group_entry *groups;\n\t\tstruct vfio_pci_group_info info;\n\t\tbool slot = false;\n\t\tint i, count = 0, ret = 0;\n\n\t\tminsz = offsetofend(struct vfio_pci_hot_reset, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (hdr.argsz < minsz || hdr.flags)\n\t\t\treturn -EINVAL;\n\n\t\t/* Can we do a slot or bus reset or neither? */\n\t\tif (!pci_probe_reset_slot(vdev->pdev->slot))\n\t\t\tslot = true;\n\t\telse if (pci_probe_reset_bus(vdev->pdev->bus))\n\t\t\treturn -ENODEV;\n\n\t\t/*\n\t\t * We can't let userspace give us an arbitrarily large\n\t\t * buffer to copy, so verify how many we think there\n\t\t * could be.  Note groups can have multiple devices so\n\t\t * one group per device is the max.\n\t\t */\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_count_devs,\n\t\t\t\t\t\t    &count, slot);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t/* Somewhere between 1 and count is OK */\n\t\tif (!hdr.count || hdr.count > count)\n\t\t\treturn -EINVAL;\n\n\t\tgroup_fds = kcalloc(hdr.count, sizeof(*group_fds), GFP_KERNEL);\n\t\tgroups = kcalloc(hdr.count, sizeof(*groups), GFP_KERNEL);\n\t\tif (!group_fds || !groups) {\n\t\t\tkfree(group_fds);\n\t\t\tkfree(groups);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (copy_from_user(group_fds, (void __user *)(arg + minsz),\n\t\t\t\t   hdr.count * sizeof(*group_fds))) {\n\t\t\tkfree(group_fds);\n\t\t\tkfree(groups);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\t/*\n\t\t * For each group_fd, get the group through the vfio external\n\t\t * user interface and store the group and iommu ID.  This\n\t\t * ensures the group is held across the reset.\n\t\t */\n\t\tfor (i = 0; i < hdr.count; i++) {\n\t\t\tstruct vfio_group *group;\n\t\t\tstruct fd f = fdget(group_fds[i]);\n\t\t\tif (!f.file) {\n\t\t\t\tret = -EBADF;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tgroup = vfio_group_get_external_user(f.file);\n\t\t\tfdput(f);\n\t\t\tif (IS_ERR(group)) {\n\t\t\t\tret = PTR_ERR(group);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tgroups[i].group = group;\n\t\t\tgroups[i].id = vfio_external_user_iommu_id(group);\n\t\t}\n\n\t\tkfree(group_fds);\n\n\t\t/* release reference to groups on error */\n\t\tif (ret)\n\t\t\tgoto hot_reset_release;\n\n\t\tinfo.count = hdr.count;\n\t\tinfo.groups = groups;\n\n\t\t/*\n\t\t * Test whether all the affected devices are contained\n\t\t * by the set of groups provided by the user.\n\t\t */\n\t\tret = vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t\t    vfio_pci_validate_devs,\n\t\t\t\t\t\t    &info, slot);\n\t\tif (!ret)\n\t\t\t/* User has access, do the reset */\n\t\t\tret = slot ? pci_try_reset_slot(vdev->pdev->slot) :\n\t\t\t\t     pci_try_reset_bus(vdev->pdev->bus);\n\nhot_reset_release:\n\t\tfor (i--; i >= 0; i--)\n\t\t\tvfio_group_put_external_user(groups[i].group);\n\n\t\tkfree(groups);\n\t\treturn ret;\n\t}\n\n\treturn -ENOTTY;\n}", "target": 2, "idx": 11912}
{"commit_id": "1630f53481f445ada0a455e9979236d31a8d3bb0", "project": "GNOME/nautilus", "func": "static void\nactivate_desktop_file (ActivateParameters *parameters,\n                       NautilusFile       *file)\n{\n    ActivateParametersDesktop *parameters_desktop;\n    char *primary, *secondary, *display_name;\n    GtkWidget *dialog;\n    GdkScreen *screen;\n    char *uri;\n\n    screen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window));\n\n    if (!nautilus_file_is_trusted_link (file))\n    {\n        /* copy the parts of parameters we are interested in as the orignal will be freed */\n        parameters_desktop = g_new0 (ActivateParametersDesktop, 1);\n        if (parameters->parent_window)\n        {\n            parameters_desktop->parent_window = parameters->parent_window;\n            g_object_add_weak_pointer (G_OBJECT (parameters_desktop->parent_window), (gpointer *) &parameters_desktop->parent_window);\n        }\n        parameters_desktop->file = nautilus_file_ref (file);\n\n        primary = _(\"Untrusted application launcher\");\n        display_name = nautilus_file_get_display_name (file);\n        secondary =\n            g_strdup_printf (_(\"The application launcher \u201c%s\u201d has not been marked as trusted. \"\n                               \"If you do not know the source of this file, launching it may be unsafe.\"\n                               ),\n                             display_name);\n\n        dialog = gtk_message_dialog_new (parameters->parent_window,\n                                         0,\n                                         GTK_MESSAGE_WARNING,\n                                         GTK_BUTTONS_NONE,\n                                         NULL);\n        g_object_set (dialog,\n                      \"text\", primary,\n                      \"secondary-text\", secondary,\n                      NULL);\n\n        gtk_dialog_add_button (GTK_DIALOG (dialog),\n                               _(\"_Cancel\"), GTK_RESPONSE_CANCEL);\n\n        gtk_dialog_set_default_response (GTK_DIALOG (dialog), GTK_RESPONSE_CANCEL);\n        if (nautilus_file_can_set_permissions (file))\n        {\n            gtk_dialog_add_button (GTK_DIALOG (dialog),\n                                   _(\"Trust and _Launch\"), GTK_RESPONSE_OK);\n        }\n        g_signal_connect (dialog, \"response\",\n                          G_CALLBACK (untrusted_launcher_response_callback),\n                          parameters_desktop);\n        gtk_widget_show (dialog);\n\n        g_free (display_name);\n        g_free (secondary);\n        return;\n    }\n\n    uri = nautilus_file_get_uri (file);\n    DEBUG (\"Launching trusted launcher %s\", uri);\n    nautilus_launch_desktop_file (screen, uri, NULL,\n                                  parameters->parent_window);\n    g_free (uri);\n}", "target": 1, "idx": 11913}
{"commit_id": "b02a9ee5bf071fa92563536c076a69dbec814e7e", "project": "knik0/faad2", "func": "static int stcoin(int size)\n{\n    uint32_t numchunks, chunkn, slicen, samplesleft, i, offset;\n    uint32_t nextoffset;\n\n    if (size < 8)\n        return ERR_FAIL;\n\n    // version/flags\n    u32in();\n\n    // Number of entries\n    numchunks = u32in();\n    if ((numchunks < 1) || ((numchunks + 1) == 0))\n        return ERR_FAIL;\n\n    if ((size - 8u) / 4u < numchunks)\n        return ERR_FAIL;\n\n    chunkn = 0;\n    samplesleft = 0;\n    slicen = 0;\n    offset = 0;\n\n    for (i = 0; i < mp4config.frame.nsamples; ++i) {\n        if (samplesleft == 0)\n        {\n            chunkn++;\n            if (chunkn > numchunks)\n                return ERR_FAIL;\n            if (slicen < mp4config.frame.nsclices &&\n                (slicen + 1) < mp4config.frame.nsclices) {\n                if (chunkn == mp4config.frame.map[slicen + 1].firstchunk)\n                    slicen++;\n            }\n            samplesleft = mp4config.frame.map[slicen].samplesperchunk;\n            offset = u32in();\n        }\n        mp4config.frame.info[i].offset = offset;\n        nextoffset = offset + mp4config.frame.info[i].len;\n        if (nextoffset < offset)\n            return ERR_FAIL;\n        offset = nextoffset;\n        samplesleft--;\n    }\n\n    freeMem(&mp4config.frame.map);\n\n    return size;\n}", "target": 1, "idx": 11914}
{"commit_id": "bae3b00a5873d1562679a1289fd8490178cfe064", "project": "android", "func": "Status AudioPolicyService::getInputForAttr(const media::AudioAttributesInternal& attrAidl,\n                                           int32_t inputAidl,\n                                           int32_t riidAidl,\n                                           int32_t sessionAidl,\n                                           const AttributionSourceState& attributionSource,\n                                           const AudioConfigBase& configAidl,\n                                           int32_t flagsAidl,\n                                           int32_t selectedDeviceIdAidl,\n                                           media::GetInputForAttrResponse* _aidl_return) {\n    audio_attributes_t attr = VALUE_OR_RETURN_BINDER_STATUS(\n            aidl2legacy_AudioAttributesInternal_audio_attributes_t(attrAidl));\n    audio_io_handle_t input = VALUE_OR_RETURN_BINDER_STATUS(\n            aidl2legacy_int32_t_audio_io_handle_t(inputAidl));\n    audio_unique_id_t riid = VALUE_OR_RETURN_BINDER_STATUS(\n            aidl2legacy_int32_t_audio_unique_id_t(riidAidl));\n    audio_session_t session = VALUE_OR_RETURN_BINDER_STATUS(\n            aidl2legacy_int32_t_audio_session_t(sessionAidl));\n    audio_config_base_t config = VALUE_OR_RETURN_BINDER_STATUS(\n            aidl2legacy_AudioConfigBase_audio_config_base_t(configAidl, true /*isInput*/));\n    audio_input_flags_t flags = VALUE_OR_RETURN_BINDER_STATUS(\n            aidl2legacy_int32_t_audio_input_flags_t_mask(flagsAidl));\n    audio_port_handle_t selectedDeviceId = VALUE_OR_RETURN_BINDER_STATUS(\n                aidl2legacy_int32_t_audio_port_handle_t(selectedDeviceIdAidl));\n\n    audio_port_handle_t portId;\n\n    if (mAudioPolicyManager == NULL) {\n        return binderStatusFromStatusT(NO_INIT);\n    }\n\n    RETURN_IF_BINDER_ERROR(\n            binderStatusFromStatusT(AudioValidator::validateAudioAttributes(attr, \"68953950\")));\n\n    audio_source_t inputSource = attr.source;\n    if (inputSource == AUDIO_SOURCE_DEFAULT) {\n        inputSource = AUDIO_SOURCE_MIC;\n    }\n\n    // already checked by client, but double-check in case the client wrapper is bypassed\n    if ((inputSource < AUDIO_SOURCE_DEFAULT)\n            || (inputSource >= AUDIO_SOURCE_CNT\n                && inputSource != AUDIO_SOURCE_HOTWORD\n                && inputSource != AUDIO_SOURCE_FM_TUNER\n                && inputSource != AUDIO_SOURCE_ECHO_REFERENCE\n                && inputSource != AUDIO_SOURCE_ULTRASOUND)) {\n        return binderStatusFromStatusT(BAD_VALUE);\n    }\n\n    RETURN_IF_BINDER_ERROR(binderStatusFromStatusT(validateUsage(attr,\n            attributionSource)));\n\n    // check calling permissions.\n    // Capturing from the following sources does not require permission RECORD_AUDIO\n    // as the captured audio does not come from a microphone:\n    // - FM_TUNER source is controlled by captureTunerAudioInputAllowed() or\n    // captureAudioOutputAllowed() (deprecated).\n    // - REMOTE_SUBMIX source is controlled by captureAudioOutputAllowed() if the input\n    // type is API_INPUT_MIX_EXT_POLICY_REROUTE and by AudioService if a media projection\n    // is used and input type is API_INPUT_MIX_PUBLIC_CAPTURE_PLAYBACK\n    // - ECHO_REFERENCE source is controlled by captureAudioOutputAllowed()\n    if (!(recordingAllowed(attributionSource, inputSource)\n            || inputSource == AUDIO_SOURCE_FM_TUNER\n            || inputSource == AUDIO_SOURCE_REMOTE_SUBMIX\n            || inputSource == AUDIO_SOURCE_ECHO_REFERENCE)) {\n        ALOGE(\"%s permission denied: recording not allowed for %s\",\n                __func__, attributionSource.toString().c_str());\n        return binderStatusFromStatusT(PERMISSION_DENIED);\n    }\n\n    bool canCaptureOutput = captureAudioOutputAllowed(attributionSource);\n    bool canInterceptCallAudio = callAudioInterceptionAllowed(attributionSource);\n    bool isCallAudioSource = inputSource == AUDIO_SOURCE_VOICE_UPLINK\n             || inputSource == AUDIO_SOURCE_VOICE_DOWNLINK\n             || inputSource == AUDIO_SOURCE_VOICE_CALL;\n\n    if (isCallAudioSource && !canInterceptCallAudio && !canCaptureOutput) {\n        return binderStatusFromStatusT(PERMISSION_DENIED);\n    }\n    if (inputSource == AUDIO_SOURCE_ECHO_REFERENCE\n            && !canCaptureOutput) {\n        return binderStatusFromStatusT(PERMISSION_DENIED);\n    }\n    if (inputSource == AUDIO_SOURCE_FM_TUNER\n        && !canCaptureOutput\n        && !captureTunerAudioInputAllowed(attributionSource)) {\n        return binderStatusFromStatusT(PERMISSION_DENIED);\n    }\n\n    bool canCaptureHotword = captureHotwordAllowed(attributionSource);\n    if ((inputSource == AUDIO_SOURCE_HOTWORD) && !canCaptureHotword) {\n        return binderStatusFromStatusT(PERMISSION_DENIED);\n    }\n\n    if (((flags & AUDIO_INPUT_FLAG_HW_HOTWORD) != 0)\n            && !canCaptureHotword) {\n        ALOGE(\"%s: permission denied: hotword mode not allowed\"\n              \" for uid %d pid %d\", __func__, attributionSource.uid, attributionSource.pid);\n        return binderStatusFromStatusT(PERMISSION_DENIED);\n    }\n\n    if (attr.source == AUDIO_SOURCE_ULTRASOUND) {\n        if (!accessUltrasoundAllowed(attributionSource)) {\n            ALOGE(\"%s: permission denied: ultrasound not allowed for uid %d pid %d\",\n                    __func__, attributionSource.uid, attributionSource.pid);\n            return binderStatusFromStatusT(PERMISSION_DENIED);\n        }\n    }\n\n    sp<AudioPolicyEffects>audioPolicyEffects;\n    {\n        status_t status;\n        AudioPolicyInterface::input_type_t inputType;\n\n        Mutex::Autolock _l(mLock);\n        {\n            AutoCallerClear acc;\n            // the audio_in_acoustics_t parameter is ignored by get_input()\n            status = mAudioPolicyManager->getInputForAttr(&attr, &input, riid, session,\n                                                          attributionSource, &config,\n                                                          flags, &selectedDeviceId,\n                                                          &inputType, &portId);\n\n        }\n        audioPolicyEffects = mAudioPolicyEffects;\n\n        if (status == NO_ERROR) {\n            // enforce permission (if any) required for each type of input\n            switch (inputType) {\n            case AudioPolicyInterface::API_INPUT_MIX_PUBLIC_CAPTURE_PLAYBACK:\n                // this use case has been validated in audio service with a MediaProjection token,\n                // and doesn't rely on regular permissions\n            case AudioPolicyInterface::API_INPUT_LEGACY:\n                break;\n            case AudioPolicyInterface::API_INPUT_TELEPHONY_RX:\n                if ((attr.flags & AUDIO_FLAG_CALL_REDIRECTION) != 0\n                        && canInterceptCallAudio) {\n                    break;\n                }\n                // FIXME: use the same permission as for remote submix for now.\n                FALLTHROUGH_INTENDED;\n            case AudioPolicyInterface::API_INPUT_MIX_CAPTURE:\n                if (!canCaptureOutput) {\n                    ALOGE(\"%s permission denied: capture not allowed\", __func__);\n                    status = PERMISSION_DENIED;\n                }\n                break;\n            case AudioPolicyInterface::API_INPUT_MIX_EXT_POLICY_REROUTE:\n                if (!(modifyAudioRoutingAllowed(attributionSource)\n                        || ((attr.flags & AUDIO_FLAG_CALL_REDIRECTION) != 0\n                            && canInterceptCallAudio))) {\n                    ALOGE(\"%s permission denied for remote submix capture\", __func__);\n                    status = PERMISSION_DENIED;\n                }\n                break;\n            case AudioPolicyInterface::API_INPUT_INVALID:\n            default:\n                LOG_ALWAYS_FATAL(\"%s encountered an invalid input type %d\",\n                        __func__, (int)inputType);\n            }\n        }\n\n        if (status != NO_ERROR) {\n            if (status == PERMISSION_DENIED) {\n                AutoCallerClear acc;\n                mAudioPolicyManager->releaseInput(portId);\n            }\n            return binderStatusFromStatusT(status);\n        }\n\n        sp<AudioRecordClient> client = new AudioRecordClient(attr, input, session, portId,\n                                                             selectedDeviceId, attributionSource,\n                                                             canCaptureOutput, canCaptureHotword,\n                                                             mOutputCommandThread);\n        mAudioRecordClients.add(portId, client);\n    }\n\n    if (audioPolicyEffects != 0) {\n        // create audio pre processors according to input source\n        status_t status = audioPolicyEffects->addInputEffects(input, inputSource, session);\n        if (status != NO_ERROR && status != ALREADY_EXISTS) {\n            ALOGW(\"Failed to add effects on input %d\", input);\n        }\n    }\n\n    _aidl_return->input = VALUE_OR_RETURN_BINDER_STATUS(\n            legacy2aidl_audio_io_handle_t_int32_t(input));\n    _aidl_return->selectedDeviceId = VALUE_OR_RETURN_BINDER_STATUS(\n            legacy2aidl_audio_port_handle_t_int32_t(selectedDeviceId));\n    _aidl_return->portId = VALUE_OR_RETURN_BINDER_STATUS(\n            legacy2aidl_audio_port_handle_t_int32_t(portId));\n    return Status::ok();\n}", "target": 1, "idx": 11915}
{"commit_id": "7164a1c34d18831ac61c6744ad14ce916d389b3f", "project": "util-linux", "func": "static int parse_dos_extended(blkid_probe pr, blkid_parttable tab,\n\t\tuint32_t ex_start, uint32_t ex_size, int ssf)\n{\n\tblkid_partlist ls = blkid_probe_get_partlist(pr);\n\tuint32_t cur_start = ex_start, cur_size = ex_size;\n\tunsigned char *data;\n\tint ct_nodata = 0;\t/* count ext.partitions without data partitions */\n\tint i;\n\n\tDBG(LOWPROBE, ul_debug(\"parse EBR [start=%d, size=%d]\", ex_start/ssf, ex_size/ssf));\n\tif (ex_start == 0) {\n\t\tDBG(LOWPROBE, ul_debug(\"Bad offset in primary extended partition -- ignore\"));\n\t\treturn 0;\n\t}\n\n\twhile (1) {\n\t\tstruct dos_partition *p, *p0;\n\t\tuint32_t start, size;\n\n\t\tif (++ct_nodata > 100)\n\t\t\treturn BLKID_PROBE_OK;\n\t\tdata = blkid_probe_get_sector(pr, cur_start);\n\t\tif (!data) {\n\t\t\tif (errno)\n\t\t\t\treturn -errno;\n\t\t\tgoto leave;\t/* malformed partition? */\n\t\t}\n\n\t\tif (!mbr_is_valid_magic(data))\n\t\t\tgoto leave;\n\n\t\tp0 = mbr_get_partition(data, 0);\n\n\t\t/* Usually, the first entry is the real data partition,\n\t\t * the 2nd entry is the next extended partition, or empty,\n\t\t * and the 3rd and 4th entries are unused.\n\t\t * However, DRDOS sometimes has the extended partition as\n\t\t * the first entry (when the data partition is empty),\n\t\t * and OS/2 seems to use all four entries.\n\t\t * -- Linux kernel fs/partitions/dos.c\n\t\t *\n\t\t * See also http://en.wikipedia.org/wiki/Extended_boot_record\n\t\t */\n\n\t\t/* Parse data partition */\n\t\tfor (p = p0, i = 0; i < 4; i++, p++) {\n\t\t\tuint32_t abs_start;\n\t\t\tblkid_partition par;\n\n\t\t\t/* the start is relative to the parental ext.partition */\n\t\t\tstart = dos_partition_get_start(p) * ssf;\n\t\t\tsize = dos_partition_get_size(p) * ssf;\n\t\t\tabs_start = cur_start + start;\t/* absolute start */\n\n\t\t\tif (!size || is_extended(p))\n\t\t\t\tcontinue;\n\t\t\tif (i >= 2) {\n\t\t\t\t/* extra checks to detect real data on\n\t\t\t\t * 3rd and 4th entries */\n\t\t\t\tif (start + size > cur_size)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (abs_start < ex_start)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (abs_start + size > ex_start + ex_size)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tpar = blkid_partlist_add_partition(ls, tab, abs_start, size);\n\t\t\tif (!par)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tblkid_partition_set_type(par, p->sys_ind);\n\t\t\tblkid_partition_set_flags(par, p->boot_ind);\n\t\t\tblkid_partition_gen_uuid(par);\n\t\t\tct_nodata = 0;\n\t\t}\n\t\t/* The first nested ext.partition should be a link to the next\n\t\t * logical partition. Everything other (recursive ext.partitions)\n\t\t * is junk.\n\t\t */\n\t\tfor (p = p0, i = 0; i < 4; i++, p++) {\n\t\t\tstart = dos_partition_get_start(p) * ssf;\n\t\t\tsize = dos_partition_get_size(p) * ssf;\n\n\t\t\tif (size && is_extended(p)) {\n\t\t\t\tif (start == 0)\n\t\t\t\t\tDBG(LOWPROBE, ul_debug(\"#%d: EBR link offset is zero -- ignore\", i + 1));\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == 4)\n\t\t\tgoto leave;\n\n\t\tcur_start = ex_start + start;\n\t\tcur_size = size;\n\t}\nleave:\n\treturn BLKID_PROBE_OK;\n}", "target": 1, "idx": 11916}
{"commit_id": "9bf292bfca94694a721449e3fd752493856710f6", "project": "torvalds/linux", "func": "static long vop_ioctl(struct file *f, unsigned int cmd, unsigned long arg)\n{\n\tstruct vop_vdev *vdev = f->private_data;\n\tstruct vop_info *vi = vdev->vi;\n\tvoid __user *argp = (void __user *)arg;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase MIC_VIRTIO_ADD_DEVICE:\n\t{\n\t\tstruct mic_device_desc dd, *dd_config;\n\n\t\tif (copy_from_user(&dd, argp, sizeof(dd)))\n\t\t\treturn -EFAULT;\n\n\t\tif (mic_aligned_desc_size(&dd) > MIC_MAX_DESC_BLK_SIZE ||\n\t\t    dd.num_vq > MIC_MAX_VRINGS)\n\t\t\treturn -EINVAL;\n\n\t\tdd_config = kzalloc(mic_desc_size(&dd), GFP_KERNEL);\n\t\tif (!dd_config)\n\t\t\treturn -ENOMEM;\n\t\tif (copy_from_user(dd_config, argp, mic_desc_size(&dd))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto free_ret;\n\t\t}\n\t\t/* Ensure desc has not changed between the two reads */\n\t\tif (memcmp(&dd, dd_config, sizeof(dd))) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto free_ret;\n\t\t}\n\t\tmutex_lock(&vdev->vdev_mutex);\n\t\tmutex_lock(&vi->vop_mutex);\n\t\tret = vop_virtio_add_device(vdev, dd_config);\n\t\tif (ret)\n\t\t\tgoto unlock_ret;\n\t\tlist_add_tail(&vdev->list, &vi->vdev_list);\nunlock_ret:\n\t\tmutex_unlock(&vi->vop_mutex);\n\t\tmutex_unlock(&vdev->vdev_mutex);\nfree_ret:\n\t\tkfree(dd_config);\n\t\treturn ret;\n\t}\n\tcase MIC_VIRTIO_COPY_DESC:\n\t{\n\t\tstruct mic_copy_desc copy;\n\n\t\tmutex_lock(&vdev->vdev_mutex);\n\t\tret = vop_vdev_inited(vdev);\n\t\tif (ret)\n\t\t\tgoto _unlock_ret;\n\n\t\tif (copy_from_user(&copy, argp, sizeof(copy))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto _unlock_ret;\n\t\t}\n\n\t\tret = vop_virtio_copy_desc(vdev, &copy);\n\t\tif (ret < 0)\n\t\t\tgoto _unlock_ret;\n\t\tif (copy_to_user(\n\t\t\t&((struct mic_copy_desc __user *)argp)->out_len,\n\t\t\t&copy.out_len, sizeof(copy.out_len)))\n\t\t\tret = -EFAULT;\n_unlock_ret:\n\t\tmutex_unlock(&vdev->vdev_mutex);\n\t\treturn ret;\n\t}\n\tcase MIC_VIRTIO_CONFIG_CHANGE:\n\t{\n\t\tvoid *buf;\n\n\t\tmutex_lock(&vdev->vdev_mutex);\n\t\tret = vop_vdev_inited(vdev);\n\t\tif (ret)\n\t\t\tgoto __unlock_ret;\n\t\tbuf = kzalloc(vdev->dd->config_len, GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto __unlock_ret;\n\t\t}\n\t\tif (copy_from_user(buf, argp, vdev->dd->config_len)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto done;\n\t\t}\n\t\tret = vop_virtio_config_change(vdev, buf);\ndone:\n\t\tkfree(buf);\n__unlock_ret:\n\t\tmutex_unlock(&vdev->vdev_mutex);\n\t\treturn ret;\n\t}\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t};\n\treturn 0;\n}", "target": 1, "idx": 11917}
{"commit_id": "03e6bfb446f4e3f27c003d30d6a433e5dd8e2b3d", "project": "OpenIDC/mod_auth_openidc", "func": "static int oidc_handle_discovery_response(request_rec *r, oidc_cfg *c) {\n\n\t/* variables to hold the values returned in the response */\n\tchar *issuer = NULL, *target_link_uri = NULL, *login_hint = NULL,\n\t\t\t*auth_request_params = NULL, *csrf_cookie, *csrf_query = NULL,\n\t\t\t*user = NULL, *path_scopes;\n\toidc_provider_t *provider = NULL;\n\tchar *error_str = NULL;\n\tchar *error_description = NULL;\n\n\toidc_util_get_request_parameter(r, OIDC_DISC_OP_PARAM, &issuer);\n\toidc_util_get_request_parameter(r, OIDC_DISC_USER_PARAM, &user);\n\toidc_util_get_request_parameter(r, OIDC_DISC_RT_PARAM, &target_link_uri);\n\toidc_util_get_request_parameter(r, OIDC_DISC_LH_PARAM, &login_hint);\n\toidc_util_get_request_parameter(r, OIDC_DISC_SC_PARAM, &path_scopes);\n\toidc_util_get_request_parameter(r, OIDC_DISC_AR_PARAM,\n\t\t\t&auth_request_params);\n\toidc_util_get_request_parameter(r, OIDC_CSRF_NAME, &csrf_query);\n\tcsrf_cookie = oidc_util_get_cookie(r, OIDC_CSRF_NAME);\n\n\t/* do CSRF protection if not 3rd party initiated SSO */\n\tif (csrf_cookie) {\n\n\t\t/* clean CSRF cookie */\n\t\toidc_util_set_cookie(r, OIDC_CSRF_NAME, \"\", 0,\n\t\t\t\tOIDC_COOKIE_EXT_SAME_SITE_NONE(r));\n\n\t\t/* compare CSRF cookie value with query parameter value */\n\t\tif ((csrf_query == NULL)\n\t\t\t\t|| apr_strnatcmp(csrf_query, csrf_cookie) != 0) {\n\t\t\toidc_warn(r,\n\t\t\t\t\t\"CSRF protection failed, no Discovery and dynamic client registration will be allowed\");\n\t\t\tcsrf_cookie = NULL;\n\t\t}\n\t}\n\n\t// TODO: trim issuer/accountname/domain input and do more input validation\n\n\toidc_debug(r,\n\t\t\t\"issuer=\\\"%s\\\", target_link_uri=\\\"%s\\\", login_hint=\\\"%s\\\", user=\\\"%s\\\"\",\n\t\t\tissuer, target_link_uri, login_hint, user);\n\n\tif (target_link_uri == NULL) {\n\t\tif (c->default_sso_url == NULL) {\n\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\"Invalid Request\",\n\t\t\t\t\t\"SSO to this module without specifying a \\\"target_link_uri\\\" parameter is not possible because \" OIDCDefaultURL \" is not set.\",\n\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n\t\t}\n\t\ttarget_link_uri = c->default_sso_url;\n\t}\n\n\t/* do open redirect prevention, step 1 */\n\tif (oidc_target_link_uri_matches_configuration(r, c, target_link_uri)\n\t\t\t== FALSE) {\n\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\"Invalid Request\",\n\t\t\t\t\"\\\"target_link_uri\\\" parameter does not match configuration settings, aborting to prevent an open redirect.\",\n\t\t\t\tHTTP_UNAUTHORIZED);\n\t}\n\n\t/* do input validation on the target_link_uri parameter value, step 2 */\n\tif (oidc_validate_redirect_url(r, c, target_link_uri, TRUE, &error_str,\n\t\t\t&error_description) == FALSE) {\n\t\treturn oidc_util_html_send_error(r, c->error_template, error_str,\n\t\t\t\terror_description,\n\t\t\t\tHTTP_UNAUTHORIZED);\n\t}\n\n\t/* see if this is a static setup */\n\tif (c->metadata_dir == NULL) {\n\t\tif ((oidc_provider_static_config(r, c, &provider) == TRUE)\n\t\t\t\t&& (issuer != NULL)) {\n\t\t\tif (apr_strnatcmp(provider->issuer, issuer) != 0) {\n\t\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\t\"Invalid Request\",\n\t\t\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\t\t\"The \\\"iss\\\" value must match the configured providers' one (%s != %s).\",\n\t\t\t\t\t\t\t\tissuer, c->provider.issuer),\n\t\t\t\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n\t\t\t}\n\t\t}\n\t\treturn oidc_authenticate_user(r, c, NULL, target_link_uri, login_hint,\n\t\t\t\tNULL, NULL, auth_request_params, path_scopes);\n\t}\n\n\t/* find out if the user entered an account name or selected an OP manually */\n\tif (user != NULL) {\n\n\t\tif (login_hint == NULL)\n\t\t\tlogin_hint = apr_pstrdup(r->pool, user);\n\n\t\t/* normalize the user identifier */\n\t\tif (strstr(user, \"https://\") != user)\n\t\t\tuser = apr_psprintf(r->pool, \"https://%s\", user);\n\n\t\t/* got an user identifier as input, perform OP discovery with that */\n\t\tif (oidc_proto_url_based_discovery(r, c, user, &issuer) == FALSE) {\n\n\t\t\t/* something did not work out, show a user facing error */\n\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\"Invalid Request\",\n\t\t\t\t\t\"Could not resolve the provided user identifier to an OpenID Connect provider; check your syntax.\",\n\t\t\t\t\tHTTP_NOT_FOUND);\n\t\t}\n\n\t\t/* issuer is set now, so let's continue as planned */\n\n\t} else if (strstr(issuer, OIDC_STR_AT) != NULL) {\n\n\t\tif (login_hint == NULL) {\n\t\t\tlogin_hint = apr_pstrdup(r->pool, issuer);\n\t\t\t//char *p = strstr(issuer, OIDC_STR_AT);\n\t\t\t//*p = '\\0';\n\t\t}\n\n\t\t/* got an account name as input, perform OP discovery with that */\n\t\tif (oidc_proto_account_based_discovery(r, c, issuer, &issuer)\n\t\t\t\t== FALSE) {\n\n\t\t\t/* something did not work out, show a user facing error */\n\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\"Invalid Request\",\n\t\t\t\t\t\"Could not resolve the provided account name to an OpenID Connect provider; check your syntax.\",\n\t\t\t\t\tHTTP_NOT_FOUND);\n\t\t}\n\n\t\t/* issuer is set now, so let's continue as planned */\n\n\t}\n\n\t/* strip trailing '/' */\n\tint n = strlen(issuer);\n\tif (issuer[n - 1] == OIDC_CHAR_FORWARD_SLASH)\n\t\tissuer[n - 1] = '\\0';\n\n\t/* try and get metadata from the metadata directories for the selected OP */\n\tif ((oidc_metadata_get(r, c, issuer, &provider, csrf_cookie != NULL) == TRUE)\n\t\t\t&& (provider != NULL)) {\n\n\t\t/* now we've got a selected OP, send the user there to authenticate */\n\t\treturn oidc_authenticate_user(r, c, provider, target_link_uri,\n\t\t\t\tlogin_hint, NULL, NULL, auth_request_params, path_scopes);\n\t}\n\n\t/* something went wrong */\n\treturn oidc_util_html_send_error(r, c->error_template, \"Invalid Request\",\n\t\t\t\"Could not find valid provider metadata for the selected OpenID Connect provider; contact the administrator\",\n\t\t\tHTTP_NOT_FOUND);\n}", "target": 1, "idx": 11918}
{"commit_id": "f0c505a3e5d47989a5f69be2d0d4f250af6b1a6c", "project": "LibRaw", "func": "x3f_return_t x3f_delete(x3f_t *x3f)\n{\n\tx3f_directory_section_t *DS;\n\tint d;\n\n\tif (x3f == NULL)\n\t\treturn X3F_ARGUMENT_ERROR;\n\n\tDS = &x3f->directory_section;\n\tif (DS->num_directory_entries > 50)\n\t\treturn X3F_ARGUMENT_ERROR;\n\n\tfor (d=0; d<DS->num_directory_entries; d++) {\n\t\tx3f_directory_entry_t *DE = &DS->directory_entry[d];\n\t\tx3f_directory_entry_header_t *DEH = &DE->header;\n\t\tif (DEH->identifier == X3F_SECp) {\n\t\t\tx3f_property_list_t *PL = &DEH->data_subsection.property_list;\n\t\t\tif (PL)\n\t\t\t{\n\t\t\t\tint i;\n\t\t\t}\n\t\t\tFREE(PL->property_table.element);\n\t\t\tFREE(PL->data);\n\t\t}\n\n\t\tif (DEH->identifier == X3F_SECi) {\n\t\t\tx3f_image_data_t *ID = &DEH->data_subsection.image_data;\n\n\t\t\tif (ID)\n\t\t\t{\n\t\t\t\tcleanup_huffman(&ID->huffman);\n\t\t\t\tcleanup_true(&ID->tru);\n\t\t\t\tcleanup_quattro(&ID->quattro);\n\t\t\t\tFREE(ID->data);\n\t\t\t}\n\t\t}\n\n\t\tif (DEH->identifier == X3F_SECc) {\n\t\t\tx3f_camf_t *CAMF = &DEH->data_subsection.camf;\n\t\t\tint i;\n\t\t\tif (CAMF)\n\t\t\t{\n\t\t\t\tFREE(CAMF->data);\n\t\t\t\tFREE(CAMF->table.element);\n\t\t\t\tcleanup_huffman_tree(&CAMF->tree);\n\t\t\t\tFREE(CAMF->decoded_data);\n\t\t\t\tfor (i = 0; i < CAMF->entry_table.size; i++) {\n\t\t\t\t\tfree_camf_entry(&CAMF->entry_table.element[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tFREE(CAMF->entry_table.element);\n\t\t}\n\t}\n\n\tFREE(DS->directory_entry);\n\tFREE(x3f);\n\n\treturn X3F_OK;\n}", "target": 2, "idx": 11919}
{"commit_id": "0f2122045b946241a9e549c2a76cea54fa58a7ff", "project": "torvalds/linux", "func": "static int io_sq_thread(void *data)\n{\n\tstruct io_ring_ctx *ctx = data;\n\tconst struct cred *old_cred;\n\tDEFINE_WAIT(wait);\n\tunsigned long timeout;\n\tint ret = 0;\n\n\tcomplete(&ctx->sq_thread_comp);\n\n\told_cred = override_creds(ctx->creds);\n\n\ttimeout = jiffies + ctx->sq_thread_idle;\n\twhile (!kthread_should_park()) {\n\t\tunsigned int to_submit;\n\n\t\tif (!list_empty(&ctx->iopoll_list)) {\n\t\t\tunsigned nr_events = 0;\n\n\t\t\tmutex_lock(&ctx->uring_lock);\n\t\t\tif (!list_empty(&ctx->iopoll_list) && !need_resched())\n\t\t\t\tio_do_iopoll(ctx, &nr_events, 0);\n\t\t\telse\n\t\t\t\ttimeout = jiffies + ctx->sq_thread_idle;\n\t\t\tmutex_unlock(&ctx->uring_lock);\n\t\t}\n\n\t\tto_submit = io_sqring_entries(ctx);\n\n\t\t/*\n\t\t * If submit got -EBUSY, flag us as needing the application\n\t\t * to enter the kernel to reap and flush events.\n\t\t */\n\t\tif (!to_submit || ret == -EBUSY || need_resched()) {\n\t\t\t/*\n\t\t\t * Drop cur_mm before scheduling, we can't hold it for\n\t\t\t * long periods (or over schedule()). Do this before\n\t\t\t * adding ourselves to the waitqueue, as the unuse/drop\n\t\t\t * may sleep.\n\t\t\t */\n\t\t\tio_sq_thread_drop_mm();\n\n\t\t\t/*\n\t\t\t * We're polling. If we're within the defined idle\n\t\t\t * period, then let us spin without work before going\n\t\t\t * to sleep. The exception is if we got EBUSY doing\n\t\t\t * more IO, we should wait for the application to\n\t\t\t * reap events and wake us up.\n\t\t\t */\n\t\t\tif (!list_empty(&ctx->iopoll_list) || need_resched() ||\n\t\t\t    (!time_after(jiffies, timeout) && ret != -EBUSY &&\n\t\t\t    !percpu_ref_is_dying(&ctx->refs))) {\n\t\t\t\tio_run_task_work();\n\t\t\t\tcond_resched();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tprepare_to_wait(&ctx->sqo_wait, &wait,\n\t\t\t\t\t\tTASK_INTERRUPTIBLE);\n\n\t\t\t/*\n\t\t\t * While doing polled IO, before going to sleep, we need\n\t\t\t * to check if there are new reqs added to iopoll_list,\n\t\t\t * it is because reqs may have been punted to io worker\n\t\t\t * and will be added to iopoll_list later, hence check\n\t\t\t * the iopoll_list again.\n\t\t\t */\n\t\t\tif ((ctx->flags & IORING_SETUP_IOPOLL) &&\n\t\t\t    !list_empty_careful(&ctx->iopoll_list)) {\n\t\t\t\tfinish_wait(&ctx->sqo_wait, &wait);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tio_ring_set_wakeup_flag(ctx);\n\n\t\t\tto_submit = io_sqring_entries(ctx);\n\t\t\tif (!to_submit || ret == -EBUSY) {\n\t\t\t\tif (kthread_should_park()) {\n\t\t\t\t\tfinish_wait(&ctx->sqo_wait, &wait);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (io_run_task_work()) {\n\t\t\t\t\tfinish_wait(&ctx->sqo_wait, &wait);\n\t\t\t\t\tio_ring_clear_wakeup_flag(ctx);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (signal_pending(current))\n\t\t\t\t\tflush_signals(current);\n\t\t\t\tschedule();\n\t\t\t\tfinish_wait(&ctx->sqo_wait, &wait);\n\n\t\t\t\tio_ring_clear_wakeup_flag(ctx);\n\t\t\t\tret = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfinish_wait(&ctx->sqo_wait, &wait);\n\n\t\t\tio_ring_clear_wakeup_flag(ctx);\n\t\t}\n\n\t\tmutex_lock(&ctx->uring_lock);\n\t\tif (likely(!percpu_ref_is_dying(&ctx->refs)))\n\t\t\tret = io_submit_sqes(ctx, to_submit);\n\t\tmutex_unlock(&ctx->uring_lock);\n\t\ttimeout = jiffies + ctx->sq_thread_idle;\n\t}\n\n\tio_run_task_work();\n\n\tio_sq_thread_drop_mm();\n\trevert_creds(old_cred);\n\n\tkthread_parkme();\n\n\treturn 0;\n}", "target": 2, "idx": 11920}
{"commit_id": "820aa18126674dcee73f47afb23ed89b57251e2d", "project": "GNOME/mutter", "func": "static void\nmeta_backend_native_post_init (MetaBackend *backend)\n{\n  MetaSettings *settings = meta_backend_get_settings (backend);\n\n  META_BACKEND_CLASS (meta_backend_native_parent_class)->post_init (backend);\n\n  if (meta_settings_is_experimental_feature_enabled (settings,\n                                                     META_EXPERIMENTAL_FEATURE_RT_SCHEDULER))\n    {\n      g_autoptr (MetaDbusRealtimeKit1) rtkit_proxy = NULL;\n      g_autoptr (GError) error = NULL;\n\n      rtkit_proxy =\n        meta_dbus_realtime_kit1_proxy_new_for_bus_sync (G_BUS_TYPE_SYSTEM,\n                                                        G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES |\n                                                        G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS |\n                                                        G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START,\n                                                        \"org.freedesktop.RealtimeKit1\",\n                                                        \"/org/freedesktop/RealtimeKit1\",\n                                                        NULL,\n                                                        &error);\n\n      if (rtkit_proxy)\n        {\n          uint32_t priority;\n\n          priority = sched_get_priority_min (SCHED_RR);\n          meta_dbus_realtime_kit1_call_make_thread_realtime_sync (rtkit_proxy,\n                                                                  gettid (),\n                                                                  priority,\n                                                                  NULL,\n                                                                  &error);\n        }\n\n      if (error)\n        {\n          g_dbus_error_strip_remote_error (error);\n          g_message (\"Failed to set RT scheduler: %s\", error->message);\n        }\n    }\n\n#ifdef HAVE_REMOTE_DESKTOP\n  maybe_disable_screen_cast_dma_bufs (META_BACKEND_NATIVE (backend));\n#endif\n\n  update_viewports (backend);\n}", "target": 1, "idx": 11921}
{"commit_id": "f2d67fec0b43edce8c416101cdc52e71145b5fef", "project": "torvalds/linux", "func": "static void reg_set_min_max(struct bpf_reg_state *true_reg,\n\t\t\t    struct bpf_reg_state *false_reg, u64 val,\n\t\t\t    u8 opcode, bool is_jmp32)\n{\n\ts64 sval;\n\n\t/* If the dst_reg is a pointer, we can't learn anything about its\n\t * variable offset from the compare (unless src_reg were a pointer into\n\t * the same object, but we don't bother with that.\n\t * Since false_reg and true_reg have the same type by construction, we\n\t * only need to check one of them for pointerness.\n\t */\n\tif (__is_pointer_value(false, false_reg))\n\t\treturn;\n\n\tval = is_jmp32 ? (u32)val : val;\n\tsval = is_jmp32 ? (s64)(s32)val : (s64)val;\n\n\tswitch (opcode) {\n\tcase BPF_JEQ:\n\tcase BPF_JNE:\n\t{\n\t\tstruct bpf_reg_state *reg =\n\t\t\topcode == BPF_JEQ ? true_reg : false_reg;\n\n\t\t/* For BPF_JEQ, if this is false we know nothing Jon Snow, but\n\t\t * if it is true we know the value for sure. Likewise for\n\t\t * BPF_JNE.\n\t\t */\n\t\tif (is_jmp32) {\n\t\t\tu64 old_v = reg->var_off.value;\n\t\t\tu64 hi_mask = ~0xffffffffULL;\n\n\t\t\treg->var_off.value = (old_v & hi_mask) | val;\n\t\t\treg->var_off.mask &= hi_mask;\n\t\t} else {\n\t\t\t__mark_reg_known(reg, val);\n\t\t}\n\t\tbreak;\n\t}\n\tcase BPF_JSET:\n\t\tfalse_reg->var_off = tnum_and(false_reg->var_off,\n\t\t\t\t\t      tnum_const(~val));\n\t\tif (is_power_of_2(val))\n\t\t\ttrue_reg->var_off = tnum_or(true_reg->var_off,\n\t\t\t\t\t\t    tnum_const(val));\n\t\tbreak;\n\tcase BPF_JGE:\n\tcase BPF_JGT:\n\t{\n\t\tu64 false_umax = opcode == BPF_JGT ? val    : val - 1;\n\t\tu64 true_umin = opcode == BPF_JGT ? val + 1 : val;\n\n\t\tif (is_jmp32) {\n\t\t\tfalse_umax += gen_hi_max(false_reg->var_off);\n\t\t\ttrue_umin += gen_hi_min(true_reg->var_off);\n\t\t}\n\t\tfalse_reg->umax_value = min(false_reg->umax_value, false_umax);\n\t\ttrue_reg->umin_value = max(true_reg->umin_value, true_umin);\n\t\tbreak;\n\t}\n\tcase BPF_JSGE:\n\tcase BPF_JSGT:\n\t{\n\t\ts64 false_smax = opcode == BPF_JSGT ? sval    : sval - 1;\n\t\ts64 true_smin = opcode == BPF_JSGT ? sval + 1 : sval;\n\n\t\t/* If the full s64 was not sign-extended from s32 then don't\n\t\t * deduct further info.\n\t\t */\n\t\tif (is_jmp32 && !cmp_val_with_extended_s64(sval, false_reg))\n\t\t\tbreak;\n\t\tfalse_reg->smax_value = min(false_reg->smax_value, false_smax);\n\t\ttrue_reg->smin_value = max(true_reg->smin_value, true_smin);\n\t\tbreak;\n\t}\n\tcase BPF_JLE:\n\tcase BPF_JLT:\n\t{\n\t\tu64 false_umin = opcode == BPF_JLT ? val    : val + 1;\n\t\tu64 true_umax = opcode == BPF_JLT ? val - 1 : val;\n\n\t\tif (is_jmp32) {\n\t\t\tfalse_umin += gen_hi_min(false_reg->var_off);\n\t\t\ttrue_umax += gen_hi_max(true_reg->var_off);\n\t\t}\n\t\tfalse_reg->umin_value = max(false_reg->umin_value, false_umin);\n\t\ttrue_reg->umax_value = min(true_reg->umax_value, true_umax);\n\t\tbreak;\n\t}\n\tcase BPF_JSLE:\n\tcase BPF_JSLT:\n\t{\n\t\ts64 false_smin = opcode == BPF_JSLT ? sval    : sval + 1;\n\t\ts64 true_smax = opcode == BPF_JSLT ? sval - 1 : sval;\n\n\t\tif (is_jmp32 && !cmp_val_with_extended_s64(sval, false_reg))\n\t\t\tbreak;\n\t\tfalse_reg->smin_value = max(false_reg->smin_value, false_smin);\n\t\ttrue_reg->smax_value = min(true_reg->smax_value, true_smax);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\t__reg_deduce_bounds(false_reg);\n\t__reg_deduce_bounds(true_reg);\n\t/* We might have learned some bits from the bounds. */\n\t__reg_bound_offset(false_reg);\n\t__reg_bound_offset(true_reg);\n\t/* Intersecting with the old var_off might have improved our bounds\n\t * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),\n\t * then new var_off is (0; 0x7f...fc) which improves our umax.\n\t */\n\t__update_reg_bounds(false_reg);\n\t__update_reg_bounds(true_reg);\n}", "target": 2, "idx": 11922}
{"commit_id": "ca1b48f0abe71bf81a58995d7d75dc27f5a17ddc", "project": "gpac", "func": "GF_Err pcmreframe_process(GF_Filter *filter)\n{\n\tGF_PCMReframeCtx *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck;\n\tu64 byte_offset;\n\tu8 *data;\n\tu32 pck_size;\n\n\tif (ctx->done) return GF_EOS;\n\n\tif (!ctx->is_playing && ctx->opid) return GF_OK;\n\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (!pck) {\n\t\tif (gf_filter_pid_is_eos(ctx->ipid) && !ctx->reverse_play) {\n\t\t\tif (ctx->out_pck) {\n\t\t\t\tgf_filter_pck_truncate(ctx->out_pck, ctx->nb_bytes_in_frame);\n\t\t\t\tgf_filter_pck_set_duration(ctx->out_pck, ctx->nb_bytes_in_frame/ctx->Bps/ctx->ch);\n\t\t\t\tpcmreframe_flush_packet(ctx);\n\t\t\t}\n\t\t\tif (ctx->opid)\n\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\treturn GF_EOS;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\tdata = (char *) gf_filter_pck_get_data(pck, &pck_size);\n\tbyte_offset = gf_filter_pck_get_byte_offset(pck);\n\n\tif (ctx->probe_wave==1) {\n\t\tBool wav_ok = GF_TRUE;\n\t\tBool hdr_found = GF_FALSE;\n\t\tGF_BitStream *bs;\n\t\tif (ctx->probe_data) {\n\t\t\tctx->probe_data = gf_realloc(ctx->probe_data, ctx->probe_data_size+pck_size);\n\t\t\tmemcpy(ctx->probe_data + ctx->probe_data_size, data, pck_size);\n\t\t\tctx->probe_data_size += pck_size;\n\t\t\tbs = gf_bs_new(ctx->probe_data, ctx->probe_data_size, GF_BITSTREAM_READ);\n\t\t} else {\n\t\t\tbs = gf_bs_new(data, pck_size, GF_BITSTREAM_READ);\n\t\t}\n\t\tu32 type = gf_bs_read_u32(bs);\n\t\tif (type!=GF_4CC('R', 'I', 'F', 'F')) {\n\t\t\twav_ok = GF_FALSE;\n\t\t}\n\t\tgf_bs_read_u32(bs);\n\t\tu32 wtype = gf_bs_read_u32(bs);\n\t\tif (wtype!=GF_4CC('W', 'A', 'V', 'E')) {\n\t\t\twav_ok = GF_FALSE;\n\t\t}\n\t\twhile (gf_bs_available(bs)) {\n\t\t\ttype = gf_bs_read_u32(bs);\n\t\t\tu32 csize = gf_bs_read_u32_le(bs); //subchunk size\n\t\t\tif (type==GF_4CC('d', 'a', 't', 'a')) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (type!=GF_4CC('f', 'm', 't', ' ')) {\n\t\t\t\tgf_bs_skip_bytes(bs, csize);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//parse fmt\n\t\t\thdr_found = GF_TRUE;\n\t\t\tu16 atype = gf_bs_read_u16_le(bs);\n\t\t\tctx->ch = gf_bs_read_u16_le(bs);\n\t\t\tctx->sr = gf_bs_read_u32_le(bs);\n\t\t\tgf_bs_read_u32_le(bs); //byte rate\n\t\t\tgf_bs_read_u16_le(bs); // block align\n\t\t\tu32 bps = gf_bs_read_u16_le(bs);\n\t\t\tcsize-=16;\n\t\t\tif (ctx->ch==1) ctx->layout = GF_AUDIO_CH_FRONT_CENTER;\n\t\t\telse if (ctx->ch==2) ctx->layout = GF_AUDIO_CH_FRONT_LEFT|GF_AUDIO_CH_FRONT_RIGHT;\n\t\t\telse ctx->layout = 0;\n\n\t\t\tif (atype==3) {\n\t\t\t\tif (bps==32) {\n\t\t\t\t\tctx->safmt = GF_AUDIO_FMT_FLT;\n\t\t\t\t} else if (bps==64) {\n\t\t\t\t\tctx->safmt = GF_AUDIO_FMT_DBL;\n\t\t\t\t} else {\n\t\t\t\t\twav_ok = GF_FALSE;\n\t\t\t\t}\n\t\t\t} else if ((atype==1) || (atype==0xFFFE))  {\n\t\t\t\tif (bps==32) {\n\t\t\t\t\tctx->safmt = GF_AUDIO_FMT_S32;\n\t\t\t\t} else if (bps==24) {\n\t\t\t\t\tctx->safmt = GF_AUDIO_FMT_S24;\n\t\t\t\t} else if (bps==16) {\n\t\t\t\t\tctx->safmt = GF_AUDIO_FMT_S16;\n\t\t\t\t} else if (bps==8) {\n\t\t\t\t\tctx->safmt = GF_AUDIO_FMT_U8;\n\t\t\t\t} else {\n\t\t\t\t\twav_ok = GF_FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (atype==0xFFFE) {\n\t\t\t\tgf_bs_read_u16_le(bs); //cbSize\n\t\t\t\tgf_bs_read_u16_le(bs); //Samples\n\t\t\t\tu32 ch_mask = gf_bs_read_u32_le(bs); //channel mask\n\t\t\t\tcsize-=8;\n\t\t\t\tctx->layout = 0;\n\t\t\t\tif (ch_mask & 0x1) ctx->layout |= GF_AUDIO_CH_FRONT_LEFT;\n\t\t\t\tif (ch_mask & 0x2) ctx->layout |= GF_AUDIO_CH_FRONT_RIGHT;\n\t\t\t\tif (ch_mask & 0x4) ctx->layout |= GF_AUDIO_CH_FRONT_CENTER;\n\t\t\t\tif (ch_mask & 0x8) ctx->layout |= GF_AUDIO_CH_LFE;\n\t\t\t\tif (ch_mask & 0x10) ctx->layout |= GF_AUDIO_CH_REAR_SURROUND_LEFT;\n\t\t\t\tif (ch_mask & 0x20) ctx->layout |= GF_AUDIO_CH_REAR_SURROUND_RIGHT;\n\t\t\t\tif (ch_mask & 0x40) ctx->layout |= GF_AUDIO_CH_FRONT_CENTER_LEFT;\n\t\t\t\tif (ch_mask & 0x80) ctx->layout |= GF_AUDIO_CH_FRONT_CENTER_RIGHT;\n\t\t\t\tif (ch_mask & 0x100) ctx->layout |= GF_AUDIO_CH_REAR_CENTER;\n\t\t\t\tif (ch_mask & 0x200) ctx->layout |= GF_AUDIO_CH_SIDE_SURROUND_LEFT;\n\t\t\t\tif (ch_mask & 0x400) ctx->layout |= GF_AUDIO_CH_SIDE_SURROUND_RIGHT;\n\t\t\t\tif (ch_mask & 0x800) ctx->layout |= GF_AUDIO_CH_CENTER_SURROUND_TOP;\n\t\t\t\tif (ch_mask & 0x1000) ctx->layout |= GF_AUDIO_CH_FRONT_TOP_LEFT;\n\t\t\t\tif (ch_mask & 0x2000) ctx->layout |= GF_AUDIO_CH_FRONT_TOP_CENTER;\n\t\t\t\tif (ch_mask & 0x4000) ctx->layout |= GF_AUDIO_CH_FRONT_TOP_RIGHT;\n\t\t\t\tif (ch_mask & 0x8000) ctx->layout |= GF_AUDIO_CH_SURROUND_TOP_LEFT;\n\t\t\t\tif (ch_mask & 0x10000) ctx->layout |= GF_AUDIO_CH_REAR_CENTER_TOP;\n\t\t\t\tif (ch_mask & 0x20000) ctx->layout |= GF_AUDIO_CH_SURROUND_TOP_RIGHT;\n\t\t\t}\n\t\t\tgf_bs_skip_bytes(bs, csize);\n\t\t}\n\t\tif (gf_bs_is_overflow(bs)) {\n\t\t\tif (!ctx->probe_data) {\n\t\t\t\tctx->probe_data = gf_malloc(pck_size);\n\t\t\t\tmemcpy(ctx->probe_data, data, pck_size);\n\t\t\t\tctx->probe_data_size = pck_size;\n\t\t\t}\n\t\t\tif (!hdr_found) {\n\t\t\t\tif (ctx->probe_data_size<=10000) {\n\t\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[PCMReframe] Cannot find wave data chunk after %d bytes, aborting\\n\", ctx->probe_data_size));\n\t\t\t}\n\t\t\twav_ok = GF_FALSE;\n\t\t}\n\t\tif (!ctx->ch) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[PCMReframe] Channel count %d invalid in wave\\n\", ctx->ch));\n\t\t\twav_ok = GF_FALSE;\n\t\t}\n\t\tif (!ctx->sr) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[PCMReframe] Samplerate %d invalid in wave\\n\", ctx->sr));\n\t\t\twav_ok = GF_FALSE;\n\t\t}\n\n\t\tctx->wav_hdr_size = (u32) gf_bs_get_position(bs);\n\n\t\tgf_bs_del(bs);\n\t\tif (!wav_ok) {\n\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\tif (ctx->opid)\n\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\tgf_filter_pid_set_discard(ctx->ipid, GF_TRUE);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[PCMReframe] Invalid or unsupported WAVE header, aborting\\n\", ctx->probe_data_size));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\n\t\tctx->probe_wave = 2;\n\t\tpcmreframe_configure_pid(filter, ctx->ipid, GF_FALSE);\n\t\tif (ctx->probe_data) {\n\t\t\tpck_size = ctx->probe_data_size;\n\t\t\tdata = ctx->probe_data;\n\t\t}\n\t\tctx->init_skip = GF_TRUE;\n\t\tbyte_offset = 0;\n\t\tif (!ctx->is_playing) {\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\tif (ctx->init_skip) {\n\t\tdata+=ctx->wav_hdr_size;\n\t\tpck_size-=ctx->wav_hdr_size;\n\t\tbyte_offset = 0;\n\t\tctx->init_skip = GF_FALSE;\n\t}\n\n\tbyte_offset+= ctx->wav_hdr_size;\n\n\twhile (pck_size) {\n\t\tif (!ctx->out_pck) {\n\t\t\tctx->out_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->frame_size, &ctx->out_data);\n\t\t\tif (!ctx->out_pck) return GF_OUT_OF_MEM;\n\n\t\t\tgf_filter_pck_set_cts(ctx->out_pck, ctx->cts);\n\t\t\tgf_filter_pck_set_sap(ctx->out_pck, GF_FILTER_SAP_1);\n\t\t\tgf_filter_pck_set_duration(ctx->out_pck, ctx->framelen);\n\t\t\tgf_filter_pck_set_byte_offset(ctx->out_pck, byte_offset);\n\t\t}\n\n\t\tif (pck_size + ctx->nb_bytes_in_frame < ctx->frame_size) {\n\t\t\tmemcpy(ctx->out_data + ctx->nb_bytes_in_frame, data, pck_size);\n\t\t\tctx->nb_bytes_in_frame += pck_size;\n\t\t\tpck_size = 0;\n\t\t} else {\n\t\t\tu32 remain = ctx->frame_size - ctx->nb_bytes_in_frame;\n\t\t\tmemcpy(ctx->out_data + ctx->nb_bytes_in_frame, data, remain);\n\t\t\tctx->nb_bytes_in_frame = ctx->frame_size;\n\t\t\tpcmreframe_flush_packet(ctx);\n\n\t\t\tpck_size -= remain;\n\t\t\tdata += remain;\n\t\t\tbyte_offset += remain;\n\t\t\tctx->out_pck = NULL;\n\t\t\tctx->nb_bytes_in_frame = 0;\n\n\t\t\t//reverse playback, the remaining data is for the next frame, we want the previous one.\n\t\t\t//Trash packet and seek to previous frame\n\t\t\tif (ctx->reverse_play) {\n\t\t\t\tGF_FilterEvent fevt;\n\t\t\t\tif (!ctx->cts) {\n\t\t\t\t\tif (ctx->opid)\n\t\t\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\t\t\tGF_FEVT_INIT(fevt, GF_FEVT_STOP, ctx->ipid);\n\t\t\t\t\tgf_filter_pid_send_event(ctx->ipid, &fevt);\n\t\t\t\t\tctx->done = GF_TRUE;\n\t\t\t\t\treturn GF_EOS;\n\t\t\t\t}\n\t\t\t\tctx->cts -= ctx->framelen;\n\t\t\t\tctx->filepos -= ctx->frame_size;\n\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\t\t//post a seek, this will trash remaining packets in buffers\n\t\t\t\tGF_FEVT_INIT(fevt, GF_FEVT_SOURCE_SEEK, ctx->ipid);\n\t\t\t\tfevt.seek.start_offset = ctx->filepos + ctx->wav_hdr_size;\n\t\t\t\tgf_filter_pid_send_event(ctx->ipid, &fevt);\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tctx->cts += ctx->framelen;\n\t\t}\n\t}\n\tgf_filter_pid_drop_packet(ctx->ipid);\n\n\tif (ctx->probe_data) {\n\t\tgf_free(ctx->probe_data);\n\t\tctx->probe_data = NULL;\n\t\tctx->probe_data_size = 0;\n\t}\n\treturn GF_OK;\n}", "target": 2, "idx": 11923}
{"commit_id": "779b648c5f6aa9b33f4728f79dd4d0efec0bf860", "project": "upx", "func": "void\nPackLinuxElf64::invert_pt_dynamic(Elf64_Dyn const *dynp, upx_uint64_t headway)\n{\n    if (dt_table[Elf64_Dyn::DT_NULL]) {\n        return;  // not 1st time; do not change upx_dt_init\n    }\n    Elf64_Dyn const *const dynp0 = dynp;\n    unsigned ndx = 0;\n    unsigned const limit = headway / sizeof(*dynp);\n    if (dynp)\n    for (; ; ++ndx, ++dynp) {\n        if (limit <= ndx) {\n            throwCantPack(\"DT_NULL not found\");\n        }\n        upx_uint64_t const d_tag = get_te64(&dynp->d_tag);\n        if (d_tag>>32) { // outrageous\n            char msg[50]; snprintf(msg, sizeof(msg),\n                \"bad Elf64_Dyn[%d].d_tag %#lx\", ndx, (long unsigned)d_tag);\n            throwCantPack(msg);\n        }\n        if (d_tag < DT_NUM) {\n            if (Elf64_Dyn::DT_NEEDED != d_tag\n            &&  dt_table[d_tag]\n            &&    get_te64(&dynp->d_val)\n               != get_te64(&dynp0[-1+ dt_table[d_tag]].d_val)) {\n                char msg[50]; snprintf(msg, sizeof(msg),\n                    \"duplicate DT_%#x: [%#x] [%#x]\",\n                    (unsigned)d_tag, -1+ dt_table[d_tag], ndx);\n                throwCantPack(msg);\n            }\n            dt_table[d_tag] = 1+ ndx;\n        }\n        if (Elf64_Dyn::DT_NULL == d_tag) {\n            break;  // check here so that dt_table[DT_NULL] is set\n        }\n    }\n    upx_dt_init = 0;\n         if (dt_table[Elf64_Dyn::DT_INIT])          upx_dt_init = Elf64_Dyn::DT_INIT;\n    else if (dt_table[Elf64_Dyn::DT_PREINIT_ARRAY]) upx_dt_init = Elf64_Dyn::DT_PREINIT_ARRAY;\n    else if (dt_table[Elf64_Dyn::DT_INIT_ARRAY])    upx_dt_init = Elf64_Dyn::DT_INIT_ARRAY;\n\n    unsigned const z_str = dt_table[Elf64_Dyn::DT_STRSZ];\n    strtab_end = !z_str ? 0 : get_te64(&dynp0[-1+ z_str].d_val);\n    if (!z_str || (u64_t)file_size <= strtab_end) { // FIXME: weak\n        char msg[50]; snprintf(msg, sizeof(msg),\n            \"bad DT_STRSZ %#x\", strtab_end);\n        throwCantPack(msg);\n    }\n\n    // DT_SYMTAB has no designated length.\n    // End it when next area else starts; often DT_STRTAB.  (FIXME)\n    unsigned const x_sym = dt_table[Elf64_Dyn::DT_SYMTAB];\n    unsigned const x_str = dt_table[Elf64_Dyn::DT_STRTAB];\n    if (x_sym && x_str) {\n        upx_uint64_t const v_sym = get_te64(&dynp0[-1+ x_sym].d_val);\n        upx_uint64_t const v_str = get_te64(&dynp0[-1+ x_str].d_val);\n        unsigned const  z_sym = dt_table[Elf64_Dyn::DT_SYMENT];\n        unsigned const sz_sym = !z_sym ? sizeof(Elf64_Sym)\n            : get_te64(&dynp0[-1+ z_sym].d_val);\n        if (sz_sym < sizeof(Elf64_Sym)) {\n            char msg[50]; snprintf(msg, sizeof(msg),\n                \"bad DT_SYMENT %x\", sz_sym);\n            throwCantPack(msg);\n        }\n        if (v_sym < v_str) {\n            symnum_end = (v_str - v_sym) / sz_sym;\n        }\n        if (symnum_end < 1) {\n            throwCantPack(\"bad DT_SYMTAB\");\n        }\n    }\n    // DT_HASH, DT_GNU_HASH have no explicit length (except in ElfXX_Shdr),\n    // so it is hard to detect when the index of a hash chain is out-of-bounds.\n    // Workaround: Assume no overlap of DT_* tables.  Then any given table\n    // ends when another table begins.  So find the tables, and sort the offsets.\n    unsigned const dt_names[] = { // *.d_val are often in this order\n        Elf64_Dyn::DT_SYMTAB,\n        Elf64_Dyn::DT_VERSYM,\n        Elf64_Dyn::DT_VERNEED,\n        Elf64_Dyn::DT_HASH,\n        Elf64_Dyn::DT_GNU_HASH,\n        Elf64_Dyn::DT_STRTAB,\n        Elf64_Dyn::DT_VERDEF,\n        Elf64_Dyn::DT_REL,\n        Elf64_Dyn::DT_RELA,\n        Elf64_Dyn::DT_INIT,\n        0,\n    };\n    unsigned dt_offsets[sizeof(dt_names)/sizeof(dt_names[0])];\n    unsigned n_off = 0, k;\n    for (unsigned j=0; ((k = dt_names[j]),  k); ++j) {\n        dt_offsets[n_off] = 0;  // default to \"not found\"\n        if (k < DT_NUM) { // in range of easy table\n            if (dt_table[k]) { // present now\n                dt_offsets[n_off] = get_te64(&dynp0[-1+ dt_table[k]].d_val);\n            }\n        }\n        else {\n            if (file_image) { // why is this guard necessary?\n                dt_offsets[n_off] = elf_unsigned_dynamic(k);  // zero if not found\n            }\n        }\n        if (file_size <= dt_offsets[n_off]) {\n            char msg[60]; snprintf(msg, sizeof(msg), \"bad DT_{%#x} = %#x (beyond EOF)\",\n                k, dt_offsets[n_off]);\n                throwCantPack(msg);\n        }\n        n_off += !!dt_offsets[n_off];\n    }\n    dt_offsets[n_off++] = file_size;  // sentinel\n    qsort(dt_offsets, n_off, sizeof(dt_offsets[0]), qcmp_unsigned);\n\n    unsigned const v_hsh = elf_unsigned_dynamic(Elf64_Dyn::DT_HASH);\n    if (v_hsh && file_image) {\n        hashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_HASH);\n        if (!hashtab) {\n            char msg[40]; snprintf(msg, sizeof(msg),\n               \"bad DT_HASH %#x\", v_hsh);\n            throwCantPack(msg);\n        }\n        for (unsigned j = 0; j < n_off; ++j) {\n            if (v_hsh == dt_offsets[j]) {\n                if (dt_offsets[1+ j]) {\n                    hashend = (unsigned const *)(void const *)\n                        ((dt_offsets[1+ j] - dt_offsets[j]) + (char const *)hashtab);\n                }\n                break;\n            }\n        }\n        unsigned const nbucket = get_te32(&hashtab[0]);\n        unsigned const *const buckets = &hashtab[2];\n        unsigned const *const chains = &buckets[nbucket]; (void)chains;\n\n        unsigned const v_sym = !x_sym ? 0 : get_te32(&dynp0[-1+ x_sym].d_val);\n        if ((unsigned)file_size <= nbucket/sizeof(*buckets)  // FIXME: weak\n        || !v_sym || (unsigned)file_size <= v_sym\n        || ((v_hsh < v_sym) && (v_sym - v_hsh) < sizeof(*buckets)*(2+ nbucket))\n        ) {\n            char msg[80]; snprintf(msg, sizeof(msg),\n                \"bad DT_HASH nbucket=%#x  len=%#x\",\n                nbucket, (v_sym - v_hsh));\n            throwCantPack(msg);\n        }\n        unsigned chmax = 0;\n        for (unsigned j= 0; j < nbucket; ++j) {\n            unsigned x = get_te32(&buckets[j]);\n            if (chmax < x) {\n                chmax = x;\n            }\n        }\n        if ((v_hsh < v_sym) && (v_sym - v_hsh) <\n                (sizeof(*buckets)*(2+ nbucket) + sizeof(*chains)*(1+ chmax))) {\n            char msg[80]; snprintf(msg, sizeof(msg),\n                \"bad DT_HASH nbucket=%#x  len=%#x\",\n                nbucket, (v_sym - v_hsh));\n            throwCantPack(msg);\n        }\n    }\n    // DT_GNU_HASH often ends at DT_SYMTAB;  FIXME: not for Android?\n    unsigned const v_gsh = elf_unsigned_dynamic(Elf64_Dyn::DT_GNU_HASH);\n    if (v_gsh && file_image) {\n        gashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_GNU_HASH);\n        if (!gashtab) {\n            char msg[40]; snprintf(msg, sizeof(msg),\n               \"bad DT_GNU_HASH %#x\", v_gsh);\n            throwCantPack(msg);\n        }\n        for (unsigned j = 0; j < n_off; ++j) { // linear search of short table\n            if (v_gsh == dt_offsets[j]) {\n                if (dt_offsets[1+ j]) {\n                    gashend = (unsigned const *)(void const *)\n                        ((dt_offsets[1+ j] - dt_offsets[j]) + (char const *)gashtab);\n                }\n                break;\n            }\n        }\n        unsigned const n_bucket = get_te32(&gashtab[0]);\n        unsigned const symbias  = get_te32(&gashtab[1]);\n        unsigned const n_bitmask = get_te32(&gashtab[2]);\n        unsigned const gnu_shift = get_te32(&gashtab[3]);\n        upx_uint64_t const *const bitmask = (upx_uint64_t const *)(void const *)&gashtab[4];\n        unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask];\n        unsigned     const *const hasharr = &buckets[n_bucket]; (void)hasharr;\n        if (!n_bucket || (1u<<31) <= n_bucket  /* fie on fuzzers */\n        || (void const *)&file_image[file_size] <= (void const *)hasharr) {\n            char msg[80]; snprintf(msg, sizeof(msg),\n                \"bad n_bucket %#x\\n\", n_bucket);\n            throwCantPack(msg);\n        }\n        // unsigned const *const gashend = &hasharr[n_bucket];\n        // minimum, except:\n        // Rust and Android trim unused zeroes from high end of hasharr[]\n        unsigned bmax = 0;\n        for (unsigned j= 0; j < n_bucket; ++j) {\n            unsigned bj = get_te32(&buckets[j]);\n            if (bj) {\n                if (bj < symbias) {\n                    char msg[90]; snprintf(msg, sizeof(msg),\n                            \"bad DT_GNU_HASH bucket[%d] < symbias{%#x}\\n\",\n                            bj, symbias);\n                    throwCantPack(msg);\n                }\n                if (bmax < bj) {\n                    bmax = bj;\n                }\n            }\n        }\n        if (1==n_bucket  && 0==buckets[0]\n        &&  1==n_bitmask && 0==bitmask[0]) {\n            // 2021-09-11 Rust on RaspberryPi apparently uses this to minimize space.\n            // But then the DT_GNU_HASH symbol lookup algorithm always fails?\n            // https://github.com/upx/upx/issues/525\n        } else\n        if ((1+ bmax) < symbias) {\n            char msg[90]; snprintf(msg, sizeof(msg),\n                    \"bad DT_GNU_HASH (1+ max_bucket)=%#x < symbias=%#x\", 1+ bmax, symbias);\n            throwCantPack(msg);\n        }\n        bmax -= symbias;\n\n        // preliminary bound on gashend\n        Elf64_Shdr const *sec_gash = elf_find_section_type(Elf64_Shdr::SHT_GNU_HASH);\n        unsigned const off_symtab = elf_unsigned_dynamic(Elf64_Dyn::DT_SYMTAB);\n        unsigned const off_strtab = elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB);\n        unsigned const off_gshtab = elf_unsigned_dynamic(Elf64_Dyn::DT_GNU_HASH);\n        if (off_gshtab < file_size  // paranoia\n        &&  off_strtab < file_size\n        &&  off_symtab < file_size ) {\n            unsigned sz_gshtab = 0;\n            if (sec_gash && off_gshtab == get_te32(&sec_gash->sh_offset)) {\n               sz_gshtab = get_te32(&sec_gash->sh_size);\n            }\n            else { // heuristics\n                if (off_gshtab < off_strtab) {\n                    sz_gshtab = off_strtab - off_gshtab;\n                }\n                else if (off_gshtab < off_symtab) {\n                    sz_gshtab = off_symtab - off_gshtab;\n                }\n            }\n            if (sz_gshtab <= (file_size - off_gshtab)) {\n                gashend = (unsigned const *)(void const *)\n                    (sz_gshtab + (char const *)gashtab);\n            }\n        }\n\n        upx_uint64_t const v_sym = !x_sym ? 0 : get_te64(&dynp0[-1+ x_sym].d_val);\n        unsigned r = 0;\n        if (!n_bucket || !n_bitmask || !v_sym\n        || (r=1, ((-1+ n_bitmask) & n_bitmask))  // not a power of 2\n        || (r=2, (8*sizeof(upx_uint64_t) <= gnu_shift))  // shifted result always == 0\n        || (r=3, (n_bucket>>30))  // fie on fuzzers\n        || (r=4, (n_bitmask>>30))\n        || (r=5, ((file_size/sizeof(unsigned))\n                <= ((sizeof(*bitmask)/sizeof(unsigned))*n_bitmask + 2*n_bucket)))  // FIXME: weak\n        || (r=6, ((v_gsh < v_sym) && (v_sym - v_gsh) < (sizeof(unsigned)*4  // headers\n                + sizeof(*bitmask)*n_bitmask  // bitmask\n                + sizeof(*buckets)*n_bucket  // buckets\n                + sizeof(*hasharr)*(1+ bmax)  // hasharr\n            )) )\n        ) {\n            char msg[90]; snprintf(msg, sizeof(msg),\n                \"bad DT_GNU_HASH n_bucket=%#x  n_bitmask=%#x  len=%#lx  r=%d\",\n                n_bucket, n_bitmask, (long unsigned)(v_sym - v_gsh), r);\n            throwCantPack(msg);\n        }\n    }\n    unsigned const e_shstrndx = get_te16(&ehdri.e_shstrndx);\n    if (e_shnum <= e_shstrndx\n    &&  !(0==e_shnum && 0==e_shstrndx) ) {\n        char msg[40]; snprintf(msg, sizeof(msg),\n            \"bad .e_shstrndx %d >= .e_shnum %d\", e_shstrndx, e_shnum);\n        throwCantPack(msg);\n    }\n}", "target": 1, "idx": 11924}
{"commit_id": "c7c55972758a93350882c32147801a3485b010fe", "project": "ArtifexSoftware/ghostpdl", "func": "static void  Ins_MIRP( INS_ARG )\n  {\n    Int         point,\n                cvtEntry;\n\n    TT_F26Dot6  cvt_dist,\n                distance,\n                cur_dist,\n                org_dist;\n\n    point    = (Int)args[0];\n    cvtEntry = (Int)args[1];\n\n    /* XXX: UNDOCUMENTED! cvt[-1] = 0 always */\n\n    if ( BOUNDS( args[0],   CUR.zp1.n_points ) ||\n         BOUNDS( args[1]+1, CUR.cvtSize+1 )    ||\n         BOUNDS(CUR.GS.rp0,  CUR.zp0.n_points) )\n    {\n      CUR.error = TT_Err_Invalid_Reference;\n      return;\n    }\n\n    if ( args[1] < 0 )\n      cvt_dist = 0;\n    else\n      cvt_dist = CUR_Func_read_cvt( cvtEntry );\n\n    /* single width test */\n\n    if ( ABS( cvt_dist ) < CUR.GS.single_width_cutin )\n    {\n      if ( cvt_dist >= 0 )\n        cvt_dist =  CUR.GS.single_width_value;\n      else\n        cvt_dist = -CUR.GS.single_width_value;\n    }\n\n    /* XXX : Undocumented - twilight zone */\n\n    if ( CUR.GS.gep1 == 0 )\n    {\n      CUR.zp1.org_x[point] = CUR.zp0.org_x[CUR.GS.rp0] +\n                             MulDiv_Round( cvt_dist,\n                                           CUR.GS.freeVector.x,\n                                           0x4000 );\n\n      CUR.zp1.org_y[point] = CUR.zp0.org_y[CUR.GS.rp0] +\n                             MulDiv_Round( cvt_dist,\n                                           CUR.GS.freeVector.y,\n                                           0x4000 );\n\n      CUR.zp1.cur_x[point] = CUR.zp1.org_x[point];\n      CUR.zp1.cur_y[point] = CUR.zp1.org_y[point];\n    }\n\n    org_dist = CUR_Func_dualproj( CUR.zp1.org_x[point] -\n                                    CUR.zp0.org_x[CUR.GS.rp0],\n                                  CUR.zp1.org_y[point] -\n                                    CUR.zp0.org_y[CUR.GS.rp0] );\n\n    cur_dist = CUR_Func_project( CUR.zp1.cur_x[point] -\n                                   CUR.zp0.cur_x[CUR.GS.rp0],\n                                 CUR.zp1.cur_y[point] -\n                                   CUR.zp0.cur_y[CUR.GS.rp0] );\n\n    /* auto-flip test */\n\n    if ( CUR.GS.auto_flip )\n    {\n      if ( (org_dist ^ cvt_dist) < 0 )\n        cvt_dist = -cvt_dist;\n    }\n\n    /* control value cutin and round */\n\n    if ( (CUR.opcode & 4) != 0 )\n    {\n      /* XXX: Undocumented : only perform cut-in test when both points */\n      /*      refer to the same zone.                                  */\n\n      if ( CUR.GS.gep0 == CUR.GS.gep1 )\n        if ( ABS( cvt_dist - org_dist ) >= CUR.GS.control_value_cutin )\n          cvt_dist = org_dist;\n\n      distance = CUR_Func_round( cvt_dist,\n                                 CUR.metrics.compensations[CUR.opcode & 3] );\n    }\n    else\n      distance = Round_None( EXEC_ARGS\n                             cvt_dist,\n                             CUR.metrics.compensations[CUR.opcode & 3] );\n\n    /* minimum distance test */\n\n    if ( (CUR.opcode & 8) != 0 )\n    {\n      if ( org_dist >= 0 )\n      {\n        if ( distance < CUR.GS.minimum_distance )\n          distance = CUR.GS.minimum_distance;\n      }\n      else\n      {\n        if ( distance > -CUR.GS.minimum_distance )\n          distance = -CUR.GS.minimum_distance;\n      }\n    }\n\n    CUR_Func_move( &CUR.zp1, point, distance - cur_dist );\n\n    CUR.GS.rp1 = CUR.GS.rp0;\n\n    if ( (CUR.opcode & 16) != 0 )\n      CUR.GS.rp0 = point;\n\n    /* UNDOCUMENTED! */\n\n    CUR.GS.rp2 = point;\n  }", "target": 2, "idx": 11925}
{"commit_id": "30ca16ec87206294f4ad0e9688c88f32421b343e", "project": "llvm/llvm-project", "func": "static Type convertStructTypeWithOffset(spirv::StructType type,\n                                        LLVMTypeConverter &converter) {\n  if (type != VulkanLayoutUtils::decorateType(type))\n    return nullptr;\n\n  SmallVector<Type> elementsVector;\n  if (failed(converter.convertTypes(type.getElementTypes(), elementsVector)))\n    return nullptr;\n  return LLVM::LLVMStructType::getLiteral(type.getContext(), elementsVector,\n                                          /*isPacked=*/false);\n}", "target": 1, "idx": 11926}
{"commit_id": "c57997e76ec70862174a1b3b3aeb62a6f8570e85", "project": "radareorg/radare2", "func": "grub_err_t\ngrub_disk_read (grub_disk_t disk, grub_disk_addr_t sector,\n\t\tgrub_off_t offset, grub_size_t size, void *buf)\n{\n  char *tmp_buf;\n  unsigned real_offset;\n\n  /* First of all, check if the region is within the disk.  */\n  if (grub_disk_adjust_range (disk, &sector, &offset, size) != GRUB_ERR_NONE)\n    {\n      grub_error_push ();\n      grub_dprintf (\"disk\", \"Read out of range: sector 0x%llx (%s).\\n\",\n\t\t    (unsigned long long) sector, grub_errmsg);\n      grub_error_pop ();\n      return grub_errno;\n    }\n\n  real_offset = offset;\n\n  /* Allocate a temporary buffer.  */\n  tmp_buf = grub_malloc (GRUB_DISK_SECTOR_SIZE << GRUB_DISK_CACHE_BITS);\n  if (! tmp_buf)\n    return grub_errno;\n\n  /* Until SIZE is zero...  */\n  while (size)\n    {\n      char *data;\n      grub_disk_addr_t start_sector;\n      grub_size_t len;\n      grub_size_t pos;\n\n      /* For reading bulk data.  */\n      start_sector = sector & ~(GRUB_DISK_CACHE_SIZE - 1);\n      pos = (sector - start_sector) << GRUB_DISK_SECTOR_BITS;\n      len = ((GRUB_DISK_SECTOR_SIZE << GRUB_DISK_CACHE_BITS)\n\t     - pos - real_offset);\n      if (len > size)\n\tlen = size;\n\n      /* Fetch the cache.  */\n      data = grub_disk_cache_fetch (disk->dev->id, disk->id, start_sector);\n      if (data)\n\t{\n\t  /* Just copy it!  */\n\t  if (buf) {\n\t    if (pos + real_offset + len >= size) {\n              // prevent read overflow\n              grub_errno = GRUB_ERR_BAD_FS;\n              return grub_errno;\n\t    }\n\t    grub_memcpy (buf, data + pos + real_offset, len);\n          }\n\t  grub_disk_cache_unlock (disk->dev->id, disk->id, start_sector);\n\t}\n      else\n\t{\n\t  /* Otherwise read data from the disk actually.  */\n\t  if (start_sector + GRUB_DISK_CACHE_SIZE > disk->total_sectors\n\t      || (disk->dev->read) (disk, start_sector,\n\t\t\t\t    GRUB_DISK_CACHE_SIZE, tmp_buf)\n\t      != GRUB_ERR_NONE)\n\t    {\n\t      /* Uggh... Failed. Instead, just read necessary data.  */\n\t      unsigned num;\n\t      char *p;\n\n\t      grub_errno = GRUB_ERR_NONE;\n\n\t      num = ((size + real_offset + GRUB_DISK_SECTOR_SIZE - 1)\n\t\t     >> GRUB_DISK_SECTOR_BITS);\n\n\t      p = grub_realloc (tmp_buf, num << GRUB_DISK_SECTOR_BITS);\n\t      if (!p)\n\t\tgoto finish;\n\n\t      tmp_buf = p;\n\n\t      if ((disk->dev->read) (disk, sector, num, tmp_buf))\n\t\t{\n\t\t  grub_error_push ();\n\t\t  grub_dprintf (\"disk\", \"%s read failed\\n\", disk->name);\n\t\t  grub_error_pop ();\n\t\t  goto finish;\n\t\t}\n\n\t      if (buf)\n\t\tgrub_memcpy (buf, tmp_buf + real_offset, size);\n\n\t      /* Call the read hook, if any.  */\n\t      if (disk->read_hook)\n\t\twhile (size)\n\t\t  {\n\t\t    grub_size_t to_read;\n\n\t\t    to_read = size;\n\t\t    if (real_offset + to_read > GRUB_DISK_SECTOR_SIZE)\n\t\t      to_read = GRUB_DISK_SECTOR_SIZE - real_offset;\n\t\t    (disk->read_hook) (sector, real_offset,\n\t\t\t\t       to_read, disk->closure);\n\t\t    if (grub_errno != GRUB_ERR_NONE)\n\t\t      goto finish;\n\n\t\t    sector++;\n\t\t    size -= to_read;\n\t\t    real_offset = 0;\n\t\t  }\n\n\t      /* This must be the end.  */\n\t      goto finish;\n\t    }\n\n\t  /* Copy it and store it in the disk cache.  */\n\t  if (buf)\n\t    grub_memcpy (buf, tmp_buf + pos + real_offset, len);\n\t  grub_disk_cache_store (disk->dev->id, disk->id,\n\t\t\t\t start_sector, tmp_buf);\n\t}\n\n      /* Call the read hook, if any.  */\n      if (disk->read_hook)\n\t{\n\t  grub_disk_addr_t s = sector;\n\t  grub_size_t l = len;\n\n\t  while (l)\n\t    {\n\t      (disk->read_hook) (s, real_offset,\n\t\t\t\t ((l > GRUB_DISK_SECTOR_SIZE)\n\t\t\t\t  ? GRUB_DISK_SECTOR_SIZE\n\t\t\t\t  : l), disk->closure);\n\n\t      if (l < GRUB_DISK_SECTOR_SIZE - real_offset)\n\t\tbreak;\n\n\t      s++;\n\t      l -= GRUB_DISK_SECTOR_SIZE - real_offset;\n\t      real_offset = 0;\n\t    }\n\t}\n\n      sector = start_sector + GRUB_DISK_CACHE_SIZE;\n      if (buf)\n\tbuf = (char *) buf + len;\n      size -= len;\n      real_offset = 0;\n    }\n\n finish:\n\n  grub_free (tmp_buf);\n\n  return grub_errno;\n}", "target": 2, "idx": 11927}
{"commit_id": "39675f7a7c7e7702f7d5341f1e0d01db746543a0", "project": "torvalds/linux", "func": "int snd_rawmidi_output_params(struct snd_rawmidi_substream *substream,\n\t\t\t      struct snd_rawmidi_params * params)\n{\n\tchar *newbuf, *oldbuf;\n\tstruct snd_rawmidi_runtime *runtime = substream->runtime;\n\t\n\tif (substream->append && substream->use_count > 1)\n\t\treturn -EBUSY;\n\tsnd_rawmidi_drain_output(substream);\n\tif (params->buffer_size < 32 || params->buffer_size > 1024L * 1024L) {\n\t\treturn -EINVAL;\n\t}\n\tif (params->avail_min < 1 || params->avail_min > params->buffer_size) {\n\t\treturn -EINVAL;\n\t}\n\tif (params->buffer_size != runtime->buffer_size) {\n\t\tnewbuf = kmalloc(params->buffer_size, GFP_KERNEL);\n\t\tif (!newbuf)\n\t\t\treturn -ENOMEM;\n\t\tspin_lock_irq(&runtime->lock);\n\t\toldbuf = runtime->buffer;\n\t\truntime->buffer = newbuf;\n\t\truntime->buffer_size = params->buffer_size;\n\t\truntime->avail = runtime->buffer_size;\n\t\truntime->appl_ptr = runtime->hw_ptr = 0;\n\t\tspin_unlock_irq(&runtime->lock);\n\t\tkfree(oldbuf);\n\t}\n\truntime->avail_min = params->avail_min;\n\tsubstream->active_sensing = !params->no_active_sensing;\n\treturn 0;\n}", "target": 2, "idx": 11928}
{"commit_id": "6e396c50a4630c1bd065aaf19244cf8c1fdcd6d1", "project": "chromium", "func": "inline void LayoutObject::setChildNeedsLayout(MarkingBehavior markParents, SubtreeLayoutScope* layouter)\n{\n    ASSERT(!isSetNeedsLayoutForbidden());\n    bool alreadyNeededLayout = normalChildNeedsLayout();\n    setNormalChildNeedsLayout(true);\n    // FIXME: Replace MarkOnlyThis with the SubtreeLayoutScope code path and remove the MarkingBehavior argument entirely.\n    if (!alreadyNeededLayout && markParents == MarkContainerChain && (!layouter || layouter->root() != this))\n        markContainerChainForLayout(layouter);\n}", "target": 2, "idx": 11929}
{"commit_id": "8284008aa8230a92ba08d547864353d3290e9bf9", "project": "poppler", "func": "void Gfx::restoreState() {\n  if (stackHeight <= bottomGuard() || !state->hasSaves()) {\n    error(-1, \"Restoring state when no valid states to pop\");\n    return;\n  }\n  state = state->restore();\n  out->restoreState(state);\n  stackHeight--;\n}", "target": 2, "idx": 11930}
{"commit_id": "8f949eba8083e34d181c30bcf11aaeef2496bb97", "project": "php/php-src", "func": "static int\nstr_lower_case_match(OnigEncoding enc, int case_fold_flag,\n                     const UChar* t, const UChar* tend,\n                     const UChar* p, const UChar* end)\n{\n  int lowlen;\n  UChar *q, lowbuf[ONIGENC_MBC_CASE_FOLD_MAXLEN];\n\n  while (t < tend) {\n    lowlen = ONIGENC_MBC_CASE_FOLD(enc, case_fold_flag, &p, end, lowbuf);\n    q = lowbuf;\n    while (lowlen > 0) {\n      if (t >= tend)    return 0;\n      if (*t++ != *q++) return 0;\n      lowlen--;\n    }\n  }\n\n  return 1;\n}", "target": 2, "idx": 11931}
{"commit_id": "0926f91083f34d047abc74f1ca4fa6a9c161f7db", "project": "torvalds/linux", "func": "int mlx4_register_mac(struct mlx4_dev *dev, u8 port, u64 mac, int *index)\n{\n\tstruct mlx4_mac_table *table = &mlx4_priv(dev)->port[port].mac_table;\n\tint i, err = 0;\n\tint free = -1;\n\n\tmlx4_dbg(dev, \"Registering MAC: 0x%llx\\n\", (unsigned long long) mac);\n\tmutex_lock(&table->mutex);\n\tfor (i = 0; i < MLX4_MAX_MAC_NUM - 1; i++) {\n\t\tif (free < 0 && !table->refs[i]) {\n\t\t\tfree = i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (mac == (MLX4_MAC_MASK & be64_to_cpu(table->entries[i]))) {\n\t\t\t/* MAC already registered, increase refernce count */\n\t\t\t*index = i;\n\t\t\t++table->refs[i];\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (free < 0) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmlx4_dbg(dev, \"Free MAC index is %d\\n\", free);\n\n\tif (table->total == table->max) {\n\t\t/* No free mac entries */\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/* Register new MAC */\n\ttable->refs[free] = 1;\n\ttable->entries[free] = cpu_to_be64(mac | MLX4_MAC_VALID);\n\n\terr = mlx4_set_port_mac_table(dev, port, table->entries);\n\tif (unlikely(err)) {\n\t\tmlx4_err(dev, \"Failed adding MAC: 0x%llx\\n\", (unsigned long long) mac);\n\t\ttable->refs[free] = 0;\n\t\ttable->entries[free] = 0;\n\t\tgoto out;\n\t}\n\n\t*index = free;\n\t++table->total;\nout:\n\tmutex_unlock(&table->mutex);\n\treturn err;\n}", "target": 1, "idx": 11932}
{"commit_id": "5777a3742d88ff1c0ebc626ceb4fd47f9b3dc6d5", "project": "xen-project/xen", "func": "int xenmem_add_to_physmap_one(\n    struct domain *d,\n    unsigned int space,\n    union add_to_physmap_extra extra,\n    unsigned long idx,\n    gfn_t gfn)\n{\n    mfn_t mfn = INVALID_MFN;\n    int rc;\n    p2m_type_t t;\n    struct page_info *page = NULL;\n\n    switch ( space )\n    {\n    case XENMAPSPACE_grant_table:\n        rc = gnttab_map_frame(d, idx, gfn, &mfn);\n        if ( rc )\n            return rc;\n\n        t = p2m_ram_rw;\n\n        break;\n    case XENMAPSPACE_shared_info:\n        if ( idx != 0 )\n            return -EINVAL;\n\n        mfn = virt_to_mfn(d->shared_info);\n        t = p2m_ram_rw;\n\n        break;\n    case XENMAPSPACE_gmfn_foreign:\n    {\n        struct domain *od;\n        p2m_type_t p2mt;\n\n        od = get_pg_owner(extra.foreign_domid);\n        if ( od == NULL )\n            return -ESRCH;\n\n        if ( od == d )\n        {\n            put_pg_owner(od);\n            return -EINVAL;\n        }\n\n        rc = xsm_map_gmfn_foreign(XSM_TARGET, d, od);\n        if ( rc )\n        {\n            put_pg_owner(od);\n            return rc;\n        }\n\n        /* Take reference to the foreign domain page.\n         * Reference will be released in XENMEM_remove_from_physmap */\n        page = get_page_from_gfn(od, idx, &p2mt, P2M_ALLOC);\n        if ( !page )\n        {\n            put_pg_owner(od);\n            return -EINVAL;\n        }\n\n        if ( p2m_is_ram(p2mt) )\n            t = (p2mt == p2m_ram_rw) ? p2m_map_foreign_rw : p2m_map_foreign_ro;\n        else\n        {\n            put_page(page);\n            put_pg_owner(od);\n            return -EINVAL;\n        }\n\n        mfn = page_to_mfn(page);\n\n        put_pg_owner(od);\n        break;\n    }\n    case XENMAPSPACE_dev_mmio:\n        rc = map_dev_mmio_region(d, gfn, 1, _mfn(idx));\n        return rc;\n\n    default:\n        return -ENOSYS;\n    }\n\n    /* Map at new location. */\n    rc = guest_physmap_add_entry(d, gfn, mfn, 0, t);\n\n    /* If we fail to add the mapping, we need to drop the reference we\n     * took earlier on foreign pages */\n    if ( rc && space == XENMAPSPACE_gmfn_foreign )\n    {\n        ASSERT(page != NULL);\n        put_page(page);\n    }\n\n    return rc;\n}", "target": 2, "idx": 11933}
{"commit_id": "4a2cd6c79ecbf2cb21f985f01ce1c1e3030285ec", "project": "wireshark", "func": "static guint\ndissect_llrp_impinj_parameter(tvbuff_t *tvb, packet_info *pinfo, proto_tree *param_tree,\n        guint suboffset, const guint param_end)\n{\n    guint32 subtype;\n\n    subtype = tvb_get_ntohl(tvb, suboffset);\n    proto_item_append_text(param_tree, \" (Impinj - %s)\",\n            val_to_str_ext(subtype, &impinj_param_type_ext, \"Unknown Type: %d\"));\n    proto_tree_add_item(param_tree, hf_llrp_impinj_param_type, tvb, suboffset, 4, ENC_BIG_ENDIAN);\n    suboffset += 4;\n\n    switch(subtype) {\n    case LLRP_IMPINJ_PARAM_TAG_INFORMATION:\n    case LLRP_IMPINJ_PARAM_FORKLIFT_CONFIGURATION:\n    case LLRP_IMPINJ_PARAM_ACCESS_SPEC_CONFIGURATION:\n    case LLRP_IMPINJ_PARAM_TAG_REPORT_CONTENT_SELECTOR:\n    case LLRP_IMPINJ_PARAM_GPS_NMEA_SENTENCES:\n    case LLRP_IMPINJ_PARAM_HUB_VERSIONS:\n        /* Just parameters */\n        break;\n    case LLRP_IMPINJ_PARAM_REQUESTED_DATA:\n        PARAM_TREE_ADD(impinj_req_data, 4, ENC_BIG_ENDIAN);\n        break;\n    case LLRP_IMPINJ_PARAM_SUBREGULATORY_REGION:\n        PARAM_TREE_ADD(impinj_reg_region, 2, ENC_BIG_ENDIAN);\n        break;\n    case LLRP_IMPINJ_PARAM_INVENTORY_SEARCH_MODE:\n        PARAM_TREE_ADD(impinj_search_mode, 2, ENC_BIG_ENDIAN);\n        break;\n    case LLRP_IMPINJ_PARAM_TAG_DIRECTION_REPORTING:\n        PARAM_TREE_ADD(impinj_en_tag_dir, 2, ENC_NA);\n        PARAM_TREE_ADD(impinj_antenna_conf, 2, ENC_BIG_ENDIAN);\n        PARAM_TREE_ADD(rfu, 4, ENC_NA);\n        break;\n    case LLRP_IMPINJ_PARAM_TAG_DIRECTION:\n        PARAM_TREE_ADD(decision_time, 8, ENC_BIG_ENDIAN);\n        PARAM_TREE_ADD(impinj_tag_dir, 2, ENC_BIG_ENDIAN);\n        PARAM_TREE_ADD(confidence, 2, ENC_BIG_ENDIAN);\n        break;\n    case LLRP_IMPINJ_PARAM_FIXED_FREQUENCY_LIST:\n        PARAM_TREE_ADD(impinj_fix_freq_mode, 2, ENC_BIG_ENDIAN);\n        PARAM_TREE_ADD(rfu, 2, ENC_NA);\n        suboffset = dissect_llrp_item_array(tvb, pinfo, param_tree,\n                hf_llrp_num_channels, hf_llrp_channel, 2, suboffset);\n        break;\n    case LLRP_IMPINJ_PARAM_REDUCED_POWER_FREQUENCY_LIST:\n        PARAM_TREE_ADD(impinj_reduce_power_mode, 2, ENC_BIG_ENDIAN);\n        PARAM_TREE_ADD(rfu, 2, ENC_NA);\n        suboffset = dissect_llrp_item_array(tvb, pinfo, param_tree,\n                hf_llrp_num_channels, hf_llrp_channel, 2, suboffset);\n        break;\n    case LLRP_IMPINJ_PARAM_LOW_DUTY_CYCLE:\n        PARAM_TREE_ADD(impinj_low_duty_mode, 2, ENC_BIG_ENDIAN);\n        PARAM_TREE_ADD(empty_field_timeout, 2, ENC_BIG_ENDIAN);\n        PARAM_TREE_ADD(field_ping_interval, 2, ENC_BIG_ENDIAN);\n        break;\n    case LLRP_IMPINJ_PARAM_DETAILED_VERSION:\n        suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_model_name, suboffset);\n        suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_serial_number, suboffset);\n        suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_soft_ver, suboffset);\n        suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_firm_ver, suboffset);\n        suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_fpga_ver, suboffset);\n        suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_pcba_ver, suboffset);\n        break;\n    case LLRP_IMPINJ_PARAM_FREQUENCY_CAPABILITIES:\n        suboffset = dissect_llrp_item_array(tvb, pinfo, param_tree,\n                hf_llrp_num_freqs, hf_llrp_frequency, 4, suboffset);\n        break;\n    case LLRP_IMPINJ_PARAM_FORKLIFT_HEIGHT_THRESHOLD:\n        PARAM_TREE_ADD(height_thresh, 2, ENC_BIG_ENDIAN);\n        break;\n    case LLRP_IMPINJ_PARAM_FORKLIFT_ZEROMOTION_TIME_THRESHOLD:\n        PARAM_TREE_ADD(zero_motion_thresh, 2, ENC_BIG_ENDIAN);\n        break;\n    case LLRP_IMPINJ_PARAM_FORKLIFT_COMPANION_BOARD_INFO:\n        suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_board_manufacturer, suboffset);\n        PARAM_TREE_ADD(fw_ver_hex, 2, ENC_BIG_ENDIAN);\n        PARAM_TREE_ADD(hw_ver_hex, 2, ENC_BIG_ENDIAN);\n        break;\n    case LLRP_IMPINJ_PARAM_GPI_DEBOUNCE_CONFIGURATION:\n        PARAM_TREE_ADD(gpi_port, 2, ENC_BIG_ENDIAN);\n        PARAM_TREE_ADD(gpi_debounce, 4, ENC_BIG_ENDIAN);\n        break;\n    case LLRP_IMPINJ_PARAM_READER_TEMPERATURE:\n        PARAM_TREE_ADD(temperature, 2, ENC_BIG_ENDIAN);\n        break;\n    case LLRP_IMPINJ_PARAM_LINK_MONITOR_CONFIGURATION:\n        PARAM_TREE_ADD(impinj_link_monitor_mode, 2, ENC_BIG_ENDIAN);\n        PARAM_TREE_ADD(link_down_thresh, 2, ENC_BIG_ENDIAN);\n        break;\n    case LLRP_IMPINJ_PARAM_REPORT_BUFFER_CONFIGURATION:\n        PARAM_TREE_ADD(impinj_report_buff_mode, 2, ENC_BIG_ENDIAN);\n        break;\n    case LLRP_IMPINJ_PARAM_BLOCK_WRITE_WORD_COUNT:\n        PARAM_TREE_ADD(word_count, 2, ENC_BIG_ENDIAN);\n        break;\n    case LLRP_IMPINJ_PARAM_BLOCK_PERMALOCK:\n        PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);\n        PARAM_TREE_ADD(access_pass, 4, ENC_BIG_ENDIAN);\n        PARAM_TREE_ADD(mb, 1, ENC_NA);\n        PARAM_TREE_ADD(block_pointer, 2, ENC_BIG_ENDIAN);\n        PARAM_TREE_ADD(block_mask, 2, ENC_BIG_ENDIAN);\n        break;\n    case LLRP_IMPINJ_PARAM_BLOCK_PERMALOCK_OPSPEC_RESULT:\n        PARAM_TREE_ADD(permalock_result, 1, ENC_NA);\n        PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);\n        break;\n    case LLRP_IMPINJ_PARAM_GET_BLOCK_PERMALOCK_STATUS:\n        PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);\n        PARAM_TREE_ADD(access_pass, 4, ENC_BIG_ENDIAN);\n        PARAM_TREE_ADD(mb, 1, ENC_NA);\n        PARAM_TREE_ADD(block_pointer, 2, ENC_BIG_ENDIAN);\n        PARAM_TREE_ADD(block_range, 2, ENC_BIG_ENDIAN);\n        break;\n    case LLRP_IMPINJ_PARAM_GET_BLOCK_PERMALOCK_STATUS_OPSPEC_RESULT:\n        PARAM_TREE_ADD(block_permalock_result, 1, ENC_NA);\n        PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);\n        break;\n    case LLRP_IMPINJ_PARAM_SET_QT_CONFIG:\n        PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);\n        PARAM_TREE_ADD(access_pass, 4, ENC_BIG_ENDIAN);\n        PARAM_TREE_ADD(impinj_data_profile, 1, ENC_NA);\n        PARAM_TREE_ADD(impinj_access_range, 1, ENC_NA);\n        PARAM_TREE_ADD(impinj_persistence, 1, ENC_NA);\n        PARAM_TREE_ADD(rfu, 4, ENC_BIG_ENDIAN);\n        break;\n    case LLRP_IMPINJ_PARAM_SET_QT_CONFIG_OPSPEC_RESULT:\n        PARAM_TREE_ADD(set_qt_config_result, 1, ENC_NA);\n        PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);\n        break;\n    case LLRP_IMPINJ_PARAM_GET_QT_CONFIG:\n        PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);\n        PARAM_TREE_ADD(access_pass, 4, ENC_BIG_ENDIAN);\n        break;\n    case LLRP_IMPINJ_PARAM_GET_QT_CONFIG_OPSPEC_RESULT:\n        PARAM_TREE_ADD(get_qt_config_result, 1, ENC_NA);\n        PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);\n        PARAM_TREE_ADD(impinj_data_profile, 1, ENC_NA);\n        PARAM_TREE_ADD(impinj_access_range, 1, ENC_NA);\n        PARAM_TREE_ADD(rfu, 4, ENC_BIG_ENDIAN);\n        break;\n    case LLRP_IMPINJ_PARAM_ENABLE_SERIALIZED_TID:\n        PARAM_TREE_ADD(impinj_serialized_tid_mode, 2, ENC_BIG_ENDIAN);\n        break;\n    case LLRP_IMPINJ_PARAM_ENABLE_RF_PHASE_ANGLE:\n        PARAM_TREE_ADD(impinj_rf_phase_mode, 2, ENC_BIG_ENDIAN);\n        break;\n    case LLRP_IMPINJ_PARAM_ENABLE_PEAK_RSSI:\n        PARAM_TREE_ADD(impinj_peak_rssi_mode, 2, ENC_BIG_ENDIAN);\n        break;\n    case LLRP_IMPINJ_PARAM_ENABLE_GPS_COORDINATES:\n        PARAM_TREE_ADD(impinj_gps_coordinates_mode, 2, ENC_BIG_ENDIAN);\n        break;\n    case LLRP_IMPINJ_PARAM_SERIALIZED_TID:\n        PARAM_TREE_ADD(impinj_tid, 2, ENC_BIG_ENDIAN);\n        break;\n    case LLRP_IMPINJ_PARAM_RF_PHASE_ANGLE:\n        PARAM_TREE_ADD(phase_angle, 2, ENC_BIG_ENDIAN);\n        break;\n    case LLRP_IMPINJ_PARAM_PEAK_RSSI:\n        PARAM_TREE_ADD(rssi, 2, ENC_BIG_ENDIAN);\n        break;\n    case LLRP_IMPINJ_PARAM_GPS_COORDINATES:\n        PARAM_TREE_ADD(latitude, 4, ENC_BIG_ENDIAN);\n        PARAM_TREE_ADD(longitude, 4, ENC_BIG_ENDIAN);\n        break;\n    case LLRP_IMPINJ_PARAM_LOOP_SPEC:\n        PARAM_TREE_ADD(loop_count, 4, ENC_BIG_ENDIAN);\n        break;\n    case LLRP_IMPINJ_PARAM_GGA_SENTENCE:\n        suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_gga_sentence, suboffset);\n        break;\n    case LLRP_IMPINJ_PARAM_RMC_SENTENCE:\n        suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_rmc_sentence, suboffset);\n        break;\n    case LLRP_IMPINJ_PARAM_OPSPEC_RETRY_COUNT:\n        PARAM_TREE_ADD(retry_count, 2, ENC_BIG_ENDIAN);\n        break;\n    case LLRP_IMPINJ_PARAM_ADVANCE_GPO_CONFIG:\n        PARAM_TREE_ADD(gpo_port, 2, ENC_BIG_ENDIAN);\n        PARAM_TREE_ADD(impinj_gpo_mode, 2, ENC_BIG_ENDIAN);\n        PARAM_TREE_ADD(gpo_pulse_dur, 4, ENC_BIG_ENDIAN);\n        break;\n    case LLRP_IMPINJ_PARAM_ENABLE_OPTIM_READ:\n        PARAM_TREE_ADD(impinj_optim_read_mode, 2, ENC_BIG_ENDIAN);\n        break;\n    case LLRP_IMPINJ_PARAM_ACCESS_SPEC_ORDERING:\n        PARAM_TREE_ADD(impinj_access_spec_ordering, 2, ENC_BIG_ENDIAN);\n        break;\n    case LLRP_IMPINJ_PARAM_ENABLE_RF_DOPPLER_FREQ:\n        PARAM_TREE_ADD(impinj_rf_doppler_mode, 2, ENC_BIG_ENDIAN);\n        break;\n    case LLRP_IMPINJ_PARAM_ARRAY_VERSION:\n        suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_serial_number, suboffset);\n        suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_firm_ver, suboffset);\n        suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_pcba_ver, suboffset);\n        break;\n    case LLRP_IMPINJ_PARAM_HUB_CONFIGURATION:\n        PARAM_TREE_ADD(impinj_hub_id, 2, ENC_BIG_ENDIAN);\n        PARAM_TREE_ADD(impinj_hub_connected_type, 2, ENC_BIG_ENDIAN);\n        PARAM_TREE_ADD(impinj_hub_fault_type, 2, ENC_BIG_ENDIAN);\n        break;\n    default:\n        return suboffset;\n        break;\n    }\n    /* Each custom parameters ends with optional custom parameter, disscect it */\n    return dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, 0);\n}", "target": 1, "idx": 11934}
{"commit_id": "e57fd691c7b0fd00ea3bfe43444f30c1969748b5", "project": "tensorflow", "func": "void Compute(OpKernelContext* ctx) override {\n    const Tensor& values_tensor = ctx->input(0);\n    const Tensor& value_range_tensor = ctx->input(1);\n    const Tensor& nbins_tensor = ctx->input(2);\n\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(value_range_tensor.shape()),\n                errors::InvalidArgument(\"value_range should be a vector.\"));\n    OP_REQUIRES(ctx, (value_range_tensor.shape().num_elements() == 2),\n                errors::InvalidArgument(\n                    \"value_range should be a vector of 2 elements.\"));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(nbins_tensor.shape()),\n                errors::InvalidArgument(\"nbins should be a scalar.\"));\n\n    const auto values = values_tensor.flat<T>();\n    const auto value_range = value_range_tensor.flat<T>();\n    const auto nbins = nbins_tensor.scalar<int32>()();\n\n    OP_REQUIRES(\n        ctx, value_range(0) < value_range(1),\n        errors::InvalidArgument(\"value_range should satisfy value_range[0] < \"\n                                \"value_range[1], but got '[\",\n                                value_range(0), \", \", value_range(1), \"]'\"));\n    OP_REQUIRES(\n        ctx, nbins > 0,\n        errors::InvalidArgument(\"nbins should be a positive number, but got '\",\n                                nbins, \"'\"));\n\n    Tensor* out_tensor;\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_output(0, TensorShape({nbins}), &out_tensor));\n    auto out = out_tensor->flat<Tout>();\n\n    OP_REQUIRES_OK(\n        ctx, functor::HistogramFixedWidthFunctor<Device, T, Tout>::Compute(\n                 ctx, values, value_range, nbins, out));\n  }", "target": 1, "idx": 11935}
{"commit_id": "6a879a082d4d67a5d13f1233ae0334cde0a7f844", "project": "unicorn-engine/unicorn", "func": "void qemu_ram_free(struct uc_struct *uc, RAMBlock *block)\n{\n    if (!block) {\n        return;\n    }\n\n    //if (block->host) {\n    //    ram_block_notify_remove(block->host, block->max_length);\n    //}\n\n    QLIST_SAFE_REMOVE(block, next);\n    uc->ram_list.mru_block = NULL;\n    /* Write list before version */\n    //smp_wmb();\n    // call_rcu(block, reclaim_ramblock, rcu);\n    reclaim_ramblock(uc, block);\n}", "target": 2, "idx": 11936}
{"commit_id": "16ce101db85db694a91380aa4c89b25530871d33", "project": "torvalds/linux", "func": "int migrate_folio(struct address_space *mapping, struct folio *dst,\n\t\tstruct folio *src, enum migrate_mode mode)\n{\n\treturn migrate_folio_extra(mapping, dst, src, mode, 0);\n}", "target": 1, "idx": 11937}
{"commit_id": "6edc10c189ddef2f4a6f5e89cfd6947da18539c3", "project": "arvidn/libtorrent", "func": "bool http_parser::parse_chunk_header(buffer::const_interval buf\n\t\t, boost::int64_t* chunk_size, int* header_size)\n\t{\n\t\tTORRENT_ASSERT(buf.begin <= buf.end);\n\t\tchar const* pos = buf.begin;\n\n\t\t// ignore one optional new-line. This is since each chunk\n\t\t// is terminated by a newline. we're likely to see one\n\t\t// before the actual header.\n\n\t\tif (pos < buf.end && pos[0] == '\\r') ++pos;\n\t\tif (pos < buf.end && pos[0] == '\\n') ++pos;\n\t\tif (pos == buf.end) return false;\n\n\t\tTORRENT_ASSERT(pos <= buf.end);\n\t\tchar const* newline = std::find(pos, buf.end, '\\n');\n\t\tif (newline == buf.end) return false;\n\t\t++newline;\n\n\t\t// the chunk header is a single line, a hex length of the\n\t\t// chunk followed by an optional semi-colon with a comment\n\t\t// in case the length is 0, the stream is terminated and\n\t\t// there are extra tail headers, which is terminated by an\n\t\t// empty line\n\n\t\t// first, read the chunk length\n\t\t*chunk_size = strtoll(pos, 0, 16);\n\t\tif (*chunk_size < 0) return true;\n\n\t\tif (*chunk_size != 0)\n\t\t{\n\t\t\t*header_size = newline - buf.begin;\n\t\t\t// the newline alone is two bytes\n\t\t\tTORRENT_ASSERT(newline - buf.begin > 2);\n\t\t\treturn true;\n\t\t}\n\n\t\t// this is the terminator of the stream. Also read headers\n\t\tstd::map<std::string, std::string> tail_headers;\n\t\tpos = newline;\n\t\tnewline = std::find(pos, buf.end, '\\n');\n\n\t\tstd::string line;\n\t\twhile (newline != buf.end)\n\t\t{\n\t\t\t// if the LF character is preceeded by a CR\n\t\t\t// charachter, don't copy it into the line string.\n\t\t\tchar const* line_end = newline;\n\t\t\tif (pos != line_end && *(line_end - 1) == '\\r') --line_end;\n\t\t\tline.assign(pos, line_end);\n\t\t\t++newline;\n\t\t\tpos = newline;\n\n\t\t\tstd::string::size_type separator = line.find(':');\n\t\t\tif (separator == std::string::npos)\n\t\t\t{\n\t\t\t\t// this means we got a blank line,\n\t\t\t\t// the header is finished and the body\n\t\t\t\t// starts.\n\t\t\t\t*header_size = newline - buf.begin;\n\n\t\t\t\t// the newline alone is two bytes\n\t\t\t\tTORRENT_ASSERT(newline - buf.begin > 2);\n\n\t\t\t\t// we were successfull in parsing the headers.\n\t\t\t\t// add them to the headers in the parser\n\t\t\t\tfor (std::map<std::string, std::string>::const_iterator i = tail_headers.begin();\n\t\t\t\t\ti != tail_headers.end(); ++i)\n\t\t\t\t\tm_header.insert(std::make_pair(i->first, i->second));\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tstd::string name = line.substr(0, separator);\n\t\t\tstd::transform(name.begin(), name.end(), name.begin(), &to_lower);\n\t\t\t++separator;\n\t\t\t// skip whitespace\n\t\t\twhile (separator < line.size()\n\t\t\t\t&& (line[separator] == ' ' || line[separator] == '\\t'))\n\t\t\t\t++separator;\n\t\t\tstd::string value = line.substr(separator, std::string::npos);\n\t\t\ttail_headers.insert(std::make_pair(name, value));\n//\t\t\tfprintf(stderr, \"tail_header: %s: %s\\n\", name.c_str(), value.c_str());\n\n\t\t\tnewline = std::find(pos, buf.end, '\\n');\n\t\t}\n\t\treturn false;\n\t}", "target": 2, "idx": 11938}
{"commit_id": "b7081e135a16091c93f6f5f7525a5c58fb7ca9f9", "project": "vim", "func": "static void\ndidset_options2(void)\n{\n    // Initialize the highlight_attr[] table.\n    (void)highlight_changed();\n\n    // Parse default for 'wildmode'\n    check_opt_wim();\n\n    // Parse default for 'listchars'.\n    (void)set_chars_option(curwin, &curwin->w_p_lcs);\n\n    // Parse default for 'fillchars'.\n    (void)set_chars_option(curwin, &p_fcs);\n\n#ifdef FEAT_CLIPBOARD\n    // Parse default for 'clipboard'\n    (void)check_clipboard_option();\n#endif\n#ifdef FEAT_VARTABS\n    vim_free(curbuf->b_p_vsts_array);\n    (void)tabstop_set(curbuf->b_p_vsts, &curbuf->b_p_vsts_array);\n    vim_free(curbuf->b_p_vts_array);\n    (void)tabstop_set(curbuf->b_p_vts,  &curbuf->b_p_vts_array);\n#endif\n}", "target": 2, "idx": 11939}
{"commit_id": "dc317ac9cff859aa84eeabe03fb5004982545b3b", "project": "python/typed_ast", "func": "static arguments_ty\nast_for_arguments(struct compiling *c, const node *n)\n{\n    /* This function handles both typedargslist (function definition)\n       and varargslist (lambda definition).\n\n       parameters: '(' [typedargslist] ')'\n       typedargslist: (tfpdef ['=' test] (',' tfpdef ['=' test])* [',' [\n               '*' [tfpdef] (',' tfpdef ['=' test])* [',' ['**' tfpdef [',']]]\n             | '**' tfpdef [',']]]\n         | '*' [tfpdef] (',' tfpdef ['=' test])* [',' ['**' tfpdef [',']]]\n         | '**' tfpdef [','])\n       tfpdef: NAME [':' test]\n       varargslist: (vfpdef ['=' test] (',' vfpdef ['=' test])* [',' [\n               '*' [vfpdef] (',' vfpdef ['=' test])* [',' ['**' vfpdef [',']]]\n             | '**' vfpdef [',']]]\n         | '*' [vfpdef] (',' vfpdef ['=' test])* [',' ['**' vfpdef [',']]]\n         | '**' vfpdef [',']\n       )\n       vfpdef: NAME\n\n    */\n    int i, j, k, nposargs = 0, nkwonlyargs = 0;\n    int nposdefaults = 0, found_default = 0;\n    asdl_seq *posargs, *posdefaults, *kwonlyargs, *kwdefaults;\n    arg_ty vararg = NULL, kwarg = NULL;\n    arg_ty arg = NULL;\n    node *ch;\n\n    if (TYPE(n) == parameters) {\n        if (NCH(n) == 2) /* () as argument list */\n            return arguments(NULL, NULL, NULL, NULL, NULL, NULL, c->c_arena);\n        n = CHILD(n, 1);\n    }\n    assert(TYPE(n) == typedargslist || TYPE(n) == varargslist);\n\n    /* First count the number of positional args & defaults.  The\n       variable i is the loop index for this for loop and the next.\n       The next loop picks up where the first leaves off.\n    */\n    for (i = 0; i < NCH(n); i++) {\n        ch = CHILD(n, i);\n        if (TYPE(ch) == STAR) {\n            /* skip star */\n            i++;\n            if (i < NCH(n) && /* skip argument following star */\n                (TYPE(CHILD(n, i)) == tfpdef ||\n                 TYPE(CHILD(n, i)) == vfpdef)) {\n                i++;\n            }\n            break;\n        }\n        if (TYPE(ch) == DOUBLESTAR) break;\n        if (TYPE(ch) == vfpdef || TYPE(ch) == tfpdef) nposargs++;\n        if (TYPE(ch) == EQUAL) nposdefaults++;\n    }\n    /* count the number of keyword only args &\n       defaults for keyword only args */\n    for ( ; i < NCH(n); ++i) {\n        ch = CHILD(n, i);\n        if (TYPE(ch) == DOUBLESTAR) break;\n        if (TYPE(ch) == tfpdef || TYPE(ch) == vfpdef) nkwonlyargs++;\n    }\n    posargs = (nposargs ? _Ta3_asdl_seq_new(nposargs, c->c_arena) : NULL);\n    if (!posargs && nposargs)\n        return NULL;\n    kwonlyargs = (nkwonlyargs ?\n                   _Ta3_asdl_seq_new(nkwonlyargs, c->c_arena) : NULL);\n    if (!kwonlyargs && nkwonlyargs)\n        return NULL;\n    posdefaults = (nposdefaults ?\n                    _Ta3_asdl_seq_new(nposdefaults, c->c_arena) : NULL);\n    if (!posdefaults && nposdefaults)\n        return NULL;\n    /* The length of kwonlyargs and kwdefaults are same\n       since we set NULL as default for keyword only argument w/o default\n       - we have sequence data structure, but no dictionary */\n    kwdefaults = (nkwonlyargs ?\n                   _Ta3_asdl_seq_new(nkwonlyargs, c->c_arena) : NULL);\n    if (!kwdefaults && nkwonlyargs)\n        return NULL;\n\n    /* tfpdef: NAME [':' test]\n       vfpdef: NAME\n    */\n    i = 0;\n    j = 0;  /* index for defaults */\n    k = 0;  /* index for args */\n    while (i < NCH(n)) {\n        ch = CHILD(n, i);\n        switch (TYPE(ch)) {\n            case tfpdef:\n            case vfpdef:\n                /* XXX Need to worry about checking if TYPE(CHILD(n, i+1)) is\n                   anything other than EQUAL or a comma? */\n                /* XXX Should NCH(n) check be made a separate check? */\n                if (i + 1 < NCH(n) && TYPE(CHILD(n, i + 1)) == EQUAL) {\n                    expr_ty expression = ast_for_expr(c, CHILD(n, i + 2));\n                    if (!expression)\n                        return NULL;\n                    assert(posdefaults != NULL);\n                    asdl_seq_SET(posdefaults, j++, expression);\n                    i += 2;\n                    found_default = 1;\n                }\n                else if (found_default) {\n                    ast_error(c, n,\n                             \"non-default argument follows default argument\");\n                    return NULL;\n                }\n                arg = ast_for_arg(c, ch);\n                if (!arg)\n                    return NULL;\n                asdl_seq_SET(posargs, k++, arg);\n                i += 1; /* the name */\n                if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)\n                    i += 1; /* the comma, if present */\n                break;\n            case STAR:\n                if (i+1 >= NCH(n) ||\n                    (i+2 == NCH(n) && (TYPE(CHILD(n, i+1)) == COMMA\n                                       || TYPE(CHILD(n, i+1)) == TYPE_COMMENT))) {\n                    ast_error(c, CHILD(n, i),\n                        \"named arguments must follow bare *\");\n                    return NULL;\n                }\n                ch = CHILD(n, i+1);  /* tfpdef or COMMA */\n                if (TYPE(ch) == COMMA) {\n                    int res = 0;\n                    i += 2; /* now follows keyword only arguments */\n\n                    if (i < NCH(n) && TYPE(CHILD(n, i)) == TYPE_COMMENT) {\n                        ast_error(c, CHILD(n, i),\n                                \"bare * has associated type comment\");\n                        return NULL;\n                    }\n\n                    res = handle_keywordonly_args(c, n, i,\n                                                  kwonlyargs, kwdefaults);\n                    if (res == -1) return NULL;\n                    i = res; /* res has new position to process */\n                }\n                else {\n                    vararg = ast_for_arg(c, ch);\n                    if (!vararg)\n                        return NULL;\n\n                    i += 2; /* the star and the name */\n                    if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)\n                        i += 1; /* the comma, if present */\n\n                    if (i < NCH(n) && TYPE(CHILD(n, i)) == TYPE_COMMENT) {\n                        vararg->type_comment = NEW_TYPE_COMMENT(CHILD(n, i));\n                        if (!vararg->type_comment)\n                            return NULL;\n                        i += 1;\n                    }\n\n                    if (i < NCH(n) && (TYPE(CHILD(n, i)) == tfpdef\n                                    || TYPE(CHILD(n, i)) == vfpdef)) {\n                        int res = 0;\n                        res = handle_keywordonly_args(c, n, i,\n                                                      kwonlyargs, kwdefaults);\n                        if (res == -1) return NULL;\n                        i = res; /* res has new position to process */\n                    }\n                }\n                break;\n            case DOUBLESTAR:\n                ch = CHILD(n, i+1);  /* tfpdef */\n                assert(TYPE(ch) == tfpdef || TYPE(ch) == vfpdef);\n                kwarg = ast_for_arg(c, ch);\n                if (!kwarg)\n                    return NULL;\n                i += 2; /* the double star and the name */\n                if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)\n                    i += 1; /* the comma, if present */\n                break;\n            case TYPE_COMMENT:\n                assert(i);\n\n                if (kwarg)\n                    arg = kwarg;\n\n                /* arg will be equal to the last argument processed */\n                arg->type_comment = NEW_TYPE_COMMENT(ch);\n                if (!arg->type_comment)\n                    return NULL;\n                i += 1;\n                break;\n            default:\n                PyErr_Format(PyExc_SystemError,\n                             \"unexpected node in varargslist: %d @ %d\",\n                             TYPE(ch), i);\n                return NULL;\n        }\n    }\n    return arguments(posargs, vararg, kwonlyargs, kwdefaults, kwarg, posdefaults, c->c_arena);\n}", "target": 2, "idx": 11940}
{"commit_id": "e5b019725f53b79159931d3a7317107cbbfd0860", "project": "libav", "func": "static int mpeg4video_probe(AVProbeData *probe_packet)\n{\n    uint32_t temp_buffer = -1;\n    int VO = 0, VOL = 0, VOP = 0, VISO = 0, res = 0;\n    int i;\n\n    for (i = 0; i < probe_packet->buf_size; i++) {\n        temp_buffer = (temp_buffer << 8) + probe_packet->buf[i];\n        if (temp_buffer & 0xfffffe00)\n            continue;\n        if (temp_buffer < 2)\n            continue;\n\n        if (temp_buffer == VOP_START_CODE)\n            VOP++;\n        else if (temp_buffer == VISUAL_OBJECT_START_CODE)\n            VISO++;\n        else if (temp_buffer >= 0x100 && temp_buffer < 0x120)\n            VO++;\n        else if (temp_buffer >= 0x120 && temp_buffer < 0x130)\n            VOL++;\n        else if (!(0x1AF < temp_buffer && temp_buffer < 0x1B7) &&\n                 !(0x1B9 < temp_buffer && temp_buffer < 0x1C4))\n            res++;\n    }\n\n    if (VOP >= VISO && VOP >= VOL && VO >= VOL && VOL > 0 && res == 0)\n        return AVPROBE_SCORE_EXTENSION;\n    return 0;\n}", "target": 1, "idx": 11941}
{"commit_id": "1b5cb44d25469a4e61b71d8a974d2753fc2525e1", "project": "pcmacdon/jsish", "func": "Jsi_RC Jsi_FunctionInvoke(Jsi_Interp *interp, Jsi_Value *func, Jsi_Value *args, Jsi_Value **ret, Jsi_Value *_this)\n{\n    // Arrange for error reporting to point to called function.\n    if (!Jsi_ValueIsFunction(interp, func))\n        return Jsi_LogError(\"expected function\");\n    Jsi_Func *fstatic = func->d.obj->d.fobj->func;\n    jsi_OpCode *oldops = interp->curIp;\n    if (fstatic->opcodes)\n        interp->curIp = fstatic->opcodes->codes;\n    Jsi_RC rc = jsi_FunctionInvoke(interp, func, args, ret, _this);\n    interp->curIp = oldops;\n    if (Jsi_InterpGone(interp))\n        return JSI_ERROR;\n    return rc;\n}", "target": 1, "idx": 11942}
{"commit_id": "eb66ae030829605d61fbef1909ce310e29f78821", "project": "torvalds/linux", "func": "unsigned long move_page_tables(struct vm_area_struct *vma,\n\t\tunsigned long old_addr, struct vm_area_struct *new_vma,\n\t\tunsigned long new_addr, unsigned long len,\n\t\tbool need_rmap_locks)\n{\n\tunsigned long extent, next, old_end;\n\tpmd_t *old_pmd, *new_pmd;\n\tunsigned long mmun_start;\t/* For mmu_notifiers */\n\tunsigned long mmun_end;\t\t/* For mmu_notifiers */\n\n\told_end = old_addr + len;\n\tflush_cache_range(vma, old_addr, old_end);\n\n\tmmun_start = old_addr;\n\tmmun_end   = old_end;\n\tmmu_notifier_invalidate_range_start(vma->vm_mm, mmun_start, mmun_end);\n\n\tfor (; old_addr < old_end; old_addr += extent, new_addr += extent) {\n\t\tcond_resched();\n\t\tnext = (old_addr + PMD_SIZE) & PMD_MASK;\n\t\t/* even if next overflowed, extent below will be ok */\n\t\textent = next - old_addr;\n\t\tif (extent > old_end - old_addr)\n\t\t\textent = old_end - old_addr;\n\t\told_pmd = get_old_pmd(vma->vm_mm, old_addr);\n\t\tif (!old_pmd)\n\t\t\tcontinue;\n\t\tnew_pmd = alloc_new_pmd(vma->vm_mm, vma, new_addr);\n\t\tif (!new_pmd)\n\t\t\tbreak;\n\t\tif (is_swap_pmd(*old_pmd) || pmd_trans_huge(*old_pmd)) {\n\t\t\tif (extent == HPAGE_PMD_SIZE) {\n\t\t\t\tbool moved;\n\t\t\t\t/* See comment in move_ptes() */\n\t\t\t\tif (need_rmap_locks)\n\t\t\t\t\ttake_rmap_locks(vma);\n\t\t\t\tmoved = move_huge_pmd(vma, old_addr, new_addr,\n\t\t\t\t\t\t    old_end, old_pmd, new_pmd);\n\t\t\t\tif (need_rmap_locks)\n\t\t\t\t\tdrop_rmap_locks(vma);\n\t\t\t\tif (moved)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsplit_huge_pmd(vma, old_pmd, old_addr);\n\t\t\tif (pmd_trans_unstable(old_pmd))\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (pte_alloc(new_vma->vm_mm, new_pmd, new_addr))\n\t\t\tbreak;\n\t\tnext = (new_addr + PMD_SIZE) & PMD_MASK;\n\t\tif (extent > next - new_addr)\n\t\t\textent = next - new_addr;\n\t\tmove_ptes(vma, old_pmd, old_addr, old_addr + extent, new_vma,\n\t\t\t  new_pmd, new_addr, need_rmap_locks);\n\t}\n\n\tmmu_notifier_invalidate_range_end(vma->vm_mm, mmun_start, mmun_end);\n\n\treturn len + old_addr - old_end;\t/* how much done */\n}", "target": 2, "idx": 11943}
{"commit_id": "01686e15ec77ccb4d49a77d5bce3a01601e54d64", "project": "facebook/fbthrift", "func": "uint32_t skip(Protocol_& prot, TType arg_type) {\n  switch (arg_type) {\n    case T_BOOL: {\n      bool boolv;\n      return prot.readBool(boolv);\n    }\n    case T_BYTE: {\n      int8_t bytev = 0;\n      return prot.readByte(bytev);\n    }\n    case T_I16: {\n      int16_t i16;\n      return prot.readI16(i16);\n    }\n    case T_I32: {\n      int32_t i32;\n      return prot.readI32(i32);\n    }\n    case T_I64: {\n      int64_t i64;\n      return prot.readI64(i64);\n    }\n    case T_DOUBLE: {\n      double dub;\n      return prot.readDouble(dub);\n    }\n    case T_FLOAT: {\n      float flt;\n      return prot.readFloat(flt);\n    }\n    case T_STRING: {\n      std::string str;\n      return prot.readBinary(str);\n    }\n    case T_STRUCT: {\n      uint32_t result = 0;\n      std::string name;\n      int16_t fid;\n      TType ftype;\n      result += prot.readStructBegin(name);\n      while (true) {\n        result += prot.readFieldBegin(name, ftype, fid);\n        if (ftype == T_STOP) {\n          break;\n        }\n        result += skip(prot, ftype);\n        result += prot.readFieldEnd();\n      }\n      result += prot.readStructEnd();\n      return result;\n    }\n    case T_MAP: {\n      uint32_t result = 0;\n      TType keyType;\n      TType valType;\n      uint32_t i, size;\n      bool sizeUnknown;\n      result += prot.readMapBegin(keyType, valType, size, sizeUnknown);\n      if (!sizeUnknown) {\n        for (i = 0; i < size; i++) {\n          result += skip(prot, keyType);\n          result += skip(prot, valType);\n        }\n      } else {\n        while (prot.peekMap()) {\n          result += skip(prot, keyType);\n          result += skip(prot, valType);\n        }\n      }\n      result += prot.readMapEnd();\n      return result;\n    }\n    case T_SET: {\n      uint32_t result = 0;\n      TType elemType;\n      uint32_t i, size;\n      bool sizeUnknown;\n      result += prot.readSetBegin(elemType, size, sizeUnknown);\n      if (!sizeUnknown) {\n        for (i = 0; i < size; i++) {\n          result += skip(prot, elemType);\n        }\n      } else {\n        while (prot.peekSet()) {\n          result += skip(prot, elemType);\n        }\n      }\n      result += prot.readSetEnd();\n      return result;\n    }\n    case T_LIST: {\n      uint32_t result = 0;\n      TType elemType;\n      uint32_t i, size;\n      bool sizeUnknown;\n      result += prot.readListBegin(elemType, size, sizeUnknown);\n      if (!sizeUnknown) {\n        for (i = 0; i < size; i++) {\n          result += skip(prot, elemType);\n        }\n      } else {\n        while (prot.peekList()) {\n          result += skip(prot, elemType);\n        }\n      }\n      result += prot.readListEnd();\n      return result;\n    }\n    default: {\n      TProtocolException::throwInvalidSkipType(arg_type);\n    }\n  }\n}", "target": 2, "idx": 11944}
{"commit_id": "563989f888e51258edb9a27db56124bdc33c9afe", "project": "wireshark", "func": "static int\ndissect_openflow_port_desc_prop_v6(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int offset, guint16 length _U_)\n{\n    proto_tree *prop_tree;\n    proto_item *prop_item;\n    guint16 prop_type;\n    guint16 prop_length;\n\n    prop_type = tvb_get_ntohs(tvb, offset);\n    prop_length = tvb_get_ntohs(tvb, offset);\n\n    prop_tree = proto_tree_add_subtree(tree, tvb, offset, prop_length, ett_openflow_v6_port_desc_prop, NULL, \"Port desc. property\");\n\n    /* uint16_t type; */\n    proto_tree_add_item(prop_tree, hf_openflow_v6_port_desc_prop_type, tvb, offset, 2, ENC_BIG_ENDIAN);\n    offset+=2;\n\n    /* uint16_t len; */\n    prop_item = proto_tree_add_item(prop_tree, hf_openflow_v6_port_desc_prop_length, tvb, offset, 2, ENC_BIG_ENDIAN);\n    offset+=2;\n\n    switch (prop_type) {\n    case OFPPDPT_ETHERNET:\n        offset = dissect_openflow_port_desc_prop_ethernet_v6(tvb, pinfo, prop_tree, offset, length);\n        break;\n\n    case OFPPDPT_OPTICAL:\n        offset = dissect_openflow_port_desc_prop_optical_v6(tvb, pinfo, prop_tree, offset, length);\n        break;\n\n    case OFPPDPT_EXPERIMENTER:\n        if (prop_length <= 12) {\n            expert_add_info(pinfo, prop_item, &ei_openflow_v6_length_too_short);\n            offset = length;\n            break;\n        }\n        /* uint32_t experimenter; */\n        proto_tree_add_item(tree, hf_openflow_v6_port_desc_prop_experimenter_experimenter, tvb, offset, 4, ENC_BIG_ENDIAN);\n        offset+=4;\n\n        /* uint32_t exp_type; */\n        proto_tree_add_item(tree, hf_openflow_v6_port_desc_prop_experimenter_exp_type, tvb, offset, 4, ENC_BIG_ENDIAN);\n        offset+=4;\n\n        proto_tree_add_expert_format(tree, pinfo, &ei_openflow_v6_port_desc_prop_undecoded,\n                                     tvb, offset, prop_length - 12, \"Experimenter port desc. property.\");\n        offset += prop_length - 12;\n        break;\n\n    default:\n        if (prop_length <= 4) {\n            expert_add_info(pinfo, prop_item, &ei_openflow_v6_length_too_short);\n            offset = length;\n            break;\n        }\n        proto_tree_add_expert_format(tree, pinfo, &ei_openflow_v6_port_desc_prop_undecoded,\n                                     tvb, offset, prop_length - 4, \"Unknown port desc. property.\");\n        offset += prop_length - 4;\n        break;\n    }\n\n    return offset;\n}", "target": 2, "idx": 11945}
{"commit_id": "de1e67d0703894cb6ea782e36abb63976ab07e60", "project": "git", "func": "void traverse_commit_list(struct rev_info *revs,\n\t\t\t  show_commit_fn show_commit,\n\t\t\t  show_object_fn show_object,\n\t\t\t  void *data)\n{\n\tint i;\n\tstruct commit *commit;\n\tstruct strbuf base;\n\n\tstrbuf_init(&base, PATH_MAX);\n\twhile ((commit = get_revision(revs)) != NULL) {\n\t\t/*\n\t\t * an uninteresting boundary commit may not have its tree\n\t\t * parsed yet, but we are not going to show them anyway\n\t\t */\n\t\tif (commit->tree)\n\t\t\tadd_pending_tree(revs, commit->tree);\n\t\tshow_commit(commit, data);\n\t}\n\tfor (i = 0; i < revs->pending.nr; i++) {\n\t\tstruct object_array_entry *pending = revs->pending.objects + i;\n\t\tstruct object *obj = pending->item;\n\t\tconst char *name = pending->name;\n\t\tconst char *path = pending->path;\n\t\tif (obj->flags & (UNINTERESTING | SEEN))\n\t\t\tcontinue;\n\t\tif (obj->type == OBJ_TAG) {\n\t\t\tobj->flags |= SEEN;\n\t\t\tshow_object(obj, name, data);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!path)\n\t\t\tpath = \"\";\n\t\tif (obj->type == OBJ_TREE) {\n\t\t\tprocess_tree(revs, (struct tree *)obj, show_object,\n\t\t\t\t     &base, path, data);\n\t\t\tcontinue;\n\t\t}\n\t\tif (obj->type == OBJ_BLOB) {\n\t\t\tprocess_blob(revs, (struct blob *)obj, show_object,\n\t\t\t\t     &base, path, data);\n\t\t\tcontinue;\n\t\t}\n\t\tdie(\"unknown pending object %s (%s)\",\n\t\t    oid_to_hex(&obj->oid), name);\n\t}\n\tobject_array_clear(&revs->pending);\n\tstrbuf_release(&base);\n}", "target": 3, "idx": 11946}
{"commit_id": "2716ba705abb83e9e99857dfdf0550bd11064d0c", "project": "FISCO-BCOS", "func": "bool TransactionSync::importDownloadedTxs(\n    NodeIDPtr _fromNode, TransactionsPtr _txs, Block::Ptr _verifiedProposal)\n{\n    if (_txs->size() == 0)\n    {\n        return true;\n    }\n    auto txsSize = _txs->size();\n    // Note: only need verify the signature for the transactions\n    bool enforceImport = false;\n    BlockHeader::Ptr proposalHeader = nullptr;\n    if (_verifiedProposal && _verifiedProposal->blockHeader())\n    {\n        proposalHeader = _verifiedProposal->blockHeader();\n        enforceImport = true;\n    }\n    auto recordT = utcTime();\n    auto startT = utcTime();\n    // verify the transactions\n    std::atomic_bool verifySuccess = {true};\n    tbb::parallel_for(\n        tbb::blocked_range<size_t>(0, txsSize), [&](const tbb::blocked_range<size_t>& _r) {\n            for (size_t i = _r.begin(); i < _r.end(); i++)\n            {\n                auto tx = (*_txs)[i];\n                if (!tx)\n                {\n                    continue;\n                }\n                tx->appendKnownNode(_fromNode);\n                if (_verifiedProposal && proposalHeader)\n                {\n                    tx->setBatchId(proposalHeader->number());\n                    tx->setBatchHash(proposalHeader->hash());\n                }\n                if (m_config->txpoolStorage()->exist(tx->hash()))\n                {\n                    continue;\n                }\n                try\n                {\n                    tx->verify();\n                }\n                catch (std::exception const& e)\n                {\n                    tx->setInvalid(true);\n                    SYNC_LOG(WARNING) << LOG_DESC(\"verify sender for tx failed\")\n                                      << LOG_KV(\"reason\", boost::diagnostic_information(e))\n                                      << LOG_KV(\"hash\", tx->hash().abridged());\n                    verifySuccess = false;\n                }\n            }\n        });\n    if (enforceImport && !verifySuccess)\n    {\n        return false;\n    }\n    auto verifyT = utcTime() - startT;\n    startT = utcTime();\n    // import the transactions into txpool\n    auto txpool = m_config->txpoolStorage();\n    size_t successImportTxs = 0;\n    for (size_t i = 0; i < txsSize; i++)\n    {\n        auto tx = (*_txs)[i];\n        if (tx->invalid())\n        {\n            continue;\n        }\n        // Note: when the transaction is used to reach a consensus, the transaction must be imported\n        // into the txpool even if the txpool is full\n        auto result = txpool->submitTransaction(\n            std::const_pointer_cast<Transaction>(tx), nullptr, enforceImport, false);\n        if (result != TransactionStatus::None)\n        {\n            if (enforceImport)\n            {\n                SYNC_LOG(DEBUG) << LOG_BADGE(\"importDownloadedTxs: verify proposal failed\")\n                                << LOG_KV(\"tx\", tx->hash().abridged()) << LOG_KV(\"result\", result)\n                                << LOG_KV(\"propIndex\", proposalHeader->number())\n                                << LOG_KV(\"propHash\", proposalHeader->hash().abridged());\n                return false;\n            }\n            SYNC_LOG(TRACE) << LOG_BADGE(\"importDownloadedTxs\")\n                            << LOG_DESC(\"Import transaction into txpool failed\")\n                            << LOG_KV(\"errorCode\", result) << LOG_KV(\"tx\", tx->hash().abridged());\n            continue;\n        }\n        successImportTxs++;\n    }\n    SYNC_LOG(DEBUG) << LOG_DESC(\"importDownloadedTxs success\")\n                    << LOG_KV(\"nodeId\", m_config->nodeID()->shortHex())\n                    << LOG_KV(\"successImportTxs\", successImportTxs) << LOG_KV(\"totalTxs\", txsSize)\n                    << LOG_KV(\"verifyT\", verifyT) << LOG_KV(\"submitT\", (utcTime() - startT))\n                    << LOG_KV(\"timecost\", (utcTime() - recordT));\n    return true;\n}", "target": 2, "idx": 11947}
{"commit_id": "1728137b33c00d5a2b5110ed7aafb42e7c32e4a1", "project": "torvalds/linux", "func": "static int l2cap_sock_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tint err;\n\tstruct l2cap_chan *chan;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\tif (!sk)\n\t\treturn 0;\n\n\tl2cap_sock_cleanup_listen(sk);\n\tbt_sock_unlink(&l2cap_sk_list, sk);\n\n\terr = l2cap_sock_shutdown(sock, SHUT_RDWR);\n\tchan = l2cap_pi(sk)->chan;\n\n\tl2cap_chan_hold(chan);\n\tl2cap_chan_lock(chan);\n\n\tsock_orphan(sk);\n\tl2cap_sock_kill(sk);\n\n\tl2cap_chan_unlock(chan);\n\tl2cap_chan_put(chan);\n\n\treturn err;\n}", "target": 2, "idx": 11948}
{"commit_id": "6aeee47b2cd47915ccfa3b41433a3f57aea24dd5", "project": "php/php-src", "func": "static zend_long php_str_replace_in_subject(zval *search, zval *replace, zval *subject, zval *result, int case_sensitivity)\n{\n\tzval\t\t*search_entry,\n\t\t\t\t*replace_entry = NULL;\n\tzend_string\t*tmp_result,\n\t\t\t\t*replace_entry_str = NULL;\n\tchar\t\t*replace_value = NULL;\n\tsize_t\t\t replace_len = 0;\n\tzend_long\t replace_count = 0;\n\tzend_string\t*subject_str;\n\tzend_string *lc_subject_str = NULL;\n\tuint32_t     replace_idx;\n\n\t/* Make sure we're dealing with strings. */\n\tsubject_str = zval_get_string(subject);\n\tif (ZSTR_LEN(subject_str) == 0) {\n\t\tzend_string_release(subject_str);\n\t\tZVAL_EMPTY_STRING(result);\n\t\treturn 0;\n\t}\n\n\t/* If search is an array */\n\tif (Z_TYPE_P(search) == IS_ARRAY) {\n\t\t/* Duplicate subject string for repeated replacement */\n\t\tZVAL_STR_COPY(result, subject_str);\n\n\t\tif (Z_TYPE_P(replace) == IS_ARRAY) {\n\t\t\treplace_idx = 0;\n\t\t} else {\n\t\t\t/* Set replacement value to the passed one */\n\t\t\treplace_value = Z_STRVAL_P(replace);\n\t\t\treplace_len = Z_STRLEN_P(replace);\n\t\t}\n\n\t\t/* For each entry in the search array, get the entry */\n\t\tZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(search), search_entry) {\n\t\t\t/* Make sure we're dealing with strings. */\n\t\t\tZVAL_DEREF(search_entry);\n\t\t\tSEPARATE_ZVAL_NOREF(search_entry);\n\t\t\tconvert_to_string(search_entry);\n\t\t\tif (Z_STRLEN_P(search_entry) == 0) {\n\t\t\t\tif (Z_TYPE_P(replace) == IS_ARRAY) {\n\t\t\t\t\treplace_idx++;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* If replace is an array. */\n\t\t\tif (Z_TYPE_P(replace) == IS_ARRAY) {\n\t\t\t\t/* Get current entry */\n\t\t\t\twhile (replace_idx < Z_ARRVAL_P(replace)->nNumUsed) {\n\t\t\t\t\treplace_entry = &Z_ARRVAL_P(replace)->arData[replace_idx].val;\n\t\t\t\t\tif (Z_TYPE_P(replace_entry) != IS_UNDEF) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\treplace_idx++;\n\t\t\t\t}\n\t\t\t\tif (replace_idx < Z_ARRVAL_P(replace)->nNumUsed) {\n\t\t\t\t\t/* Make sure we're dealing with strings. */\n\t\t\t\t\treplace_entry_str = zval_get_string(replace_entry);\n\n\t\t\t\t\t/* Set replacement value to the one we got from array */\n\t\t\t\t\treplace_value = ZSTR_VAL(replace_entry_str);\n\t\t\t\t\treplace_len = ZSTR_LEN(replace_entry_str);\n\n\t\t\t\t\treplace_idx++;\n\t\t\t\t} else {\n\t\t\t\t\t/* We've run out of replacement strings, so use an empty one. */\n\t\t\t\t\treplace_value = \"\";\n\t\t\t\t\treplace_len = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (Z_STRLEN_P(search_entry) == 1) {\n\t\t\t\tzend_long old_replace_count = replace_count;\n\n\t\t\t\ttmp_result = php_char_to_str_ex(Z_STR_P(result),\n\t\t\t\t\t\t\t\tZ_STRVAL_P(search_entry)[0],\n\t\t\t\t\t\t\t\treplace_value,\n\t\t\t\t\t\t\t\treplace_len,\n\t\t\t\t\t\t\t\tcase_sensitivity,\n\t\t\t\t\t\t\t\t&replace_count);\n\t\t\t\tif (lc_subject_str && replace_count != old_replace_count) {\n\t\t\t\t\tzend_string_release(lc_subject_str);\n\t\t\t\t\tlc_subject_str = NULL;\n\t\t\t\t}\n\t\t\t} else if (Z_STRLEN_P(search_entry) > 1) {\n\t\t\t\tif (case_sensitivity) {\n\t\t\t\t\ttmp_result = php_str_to_str_ex(Z_STR_P(result),\n\t\t\t\t\t\t\tZ_STRVAL_P(search_entry), Z_STRLEN_P(search_entry),\n\t\t\t\t\t\t\treplace_value, replace_len, &replace_count);\n\t\t\t\t} else {\n\t\t\t\t\tzend_long old_replace_count = replace_count;\n\n\t\t\t\t\tif (!lc_subject_str) {\n\t\t\t\t\t\tlc_subject_str = php_string_tolower(Z_STR_P(result));\n\t\t\t\t\t}\n\t\t\t\t\ttmp_result = php_str_to_str_i_ex(Z_STR_P(result), ZSTR_VAL(lc_subject_str),\n\t\t\t\t\t\t\tZ_STR_P(search_entry), replace_value, replace_len, &replace_count);\n\t\t\t\t\tif (replace_count != old_replace_count) {\n\t\t\t\t\t\tzend_string_release(lc_subject_str);\n\t\t\t\t\t\tlc_subject_str = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\n\t\t\tif (replace_entry_str) {\n\t\t\t\tzend_string_release(replace_entry_str);\n\t\t\t\treplace_entry_str = NULL;\n\t\t\t}\n\t\t\tzend_string_release(Z_STR_P(result));\n\t\t\tZVAL_STR(result, tmp_result);\n\n\t\t\tif (Z_STRLEN_P(result) == 0) {\n\t\t\t\tif (lc_subject_str) {\n\t\t\t\t\tzend_string_release(lc_subject_str);\n\t\t\t\t}\n\t\t\t\tzend_string_release(subject_str);\n\t\t\t\treturn replace_count;\n\t\t\t}\n\t\t} ZEND_HASH_FOREACH_END();\n\t\tif (lc_subject_str) {\n\t\t\tzend_string_release(lc_subject_str);\n\t\t}\n\t} else {\n\t\tif (Z_STRLEN_P(search) == 1) {\n\t\t\tZVAL_STR(result,\n\t\t\t\tphp_char_to_str_ex(subject_str,\n\t\t\t\t\t\t\tZ_STRVAL_P(search)[0],\n\t\t\t\t\t\t\tZ_STRVAL_P(replace),\n\t\t\t\t\t\t\tZ_STRLEN_P(replace),\n\t\t\t\t\t\t\tcase_sensitivity,\n\t\t\t\t\t\t\t&replace_count));\n\t\t} else if (Z_STRLEN_P(search) > 1) {\n\t\t\tif (case_sensitivity) {\n\t\t\t\tZVAL_STR(result, php_str_to_str_ex(subject_str,\n\t\t\t\t\t\tZ_STRVAL_P(search), Z_STRLEN_P(search),\n\t\t\t\t\t\tZ_STRVAL_P(replace), Z_STRLEN_P(replace), &replace_count));\n\t\t\t} else {\n\t\t\t\tlc_subject_str = php_string_tolower(subject_str);\n\t\t\t\tZVAL_STR(result, php_str_to_str_i_ex(subject_str, ZSTR_VAL(lc_subject_str),\n\t\t\t\t\t\tZ_STR_P(search),\n\t\t\t\t\t\tZ_STRVAL_P(replace), Z_STRLEN_P(replace), &replace_count));\n\t\t\t\tzend_string_release(lc_subject_str);\n\t\t\t}\n\t\t} else {\n\t\t\tZVAL_STR_COPY(result, subject_str);\n\t\t}\n\t}\n\tzend_string_release(subject_str);\n\treturn replace_count;\n}", "target": 2, "idx": 11949}
{"commit_id": "7872a831783e17dcc4d0aa70cffc256afb664f7a", "project": "ceph", "func": "int ClientIO::init_env(CephContext *cct)\n{\n  env.init(cct);\n\n  const auto& request = parser.get();\n  const auto& headers = request;\n  for (auto header = headers.begin(); header != headers.end(); ++header) {\n    const auto& field = header->name(); // enum type for known headers\n    const auto& name = header->name_string();\n    const auto& value = header->value();\n\n    if (field == beast::http::field::content_length) {\n      env.set(\"CONTENT_LENGTH\", value.to_string());\n      continue;\n    }\n    if (field == beast::http::field::content_type) {\n      env.set(\"CONTENT_TYPE\", value.to_string());\n      continue;\n    }\n\n    static const boost::string_ref HTTP_{\"HTTP_\"};\n\n    char buf[name.size() + HTTP_.size() + 1];\n    auto dest = std::copy(std::begin(HTTP_), std::end(HTTP_), buf);\n    for (auto src = name.begin(); src != name.end(); ++src, ++dest) {\n      if (*src == '-') {\n        *dest = '_';\n      } else {\n        *dest = std::toupper(*src);\n      }\n    }\n    *dest = '\\0';\n\n    env.set(buf, value.to_string());\n  }\n\n  int major = request.version() / 10;\n  int minor = request.version() % 10;\n  env.set(\"HTTP_VERSION\", std::to_string(major) + '.' + std::to_string(minor));\n\n  env.set(\"REQUEST_METHOD\", request.method_string().to_string());\n\n  // split uri from query\n  auto url = request.target();\n  auto pos = url.find('?');\n  if (pos != url.npos) {\n    auto query = url.substr(pos + 1);\n    env.set(\"QUERY_STRING\", query.to_string());\n    url = url.substr(0, pos);\n  }\n  env.set(\"REQUEST_URI\", url.to_string());\n  env.set(\"SCRIPT_URI\", url.to_string()); /* FIXME */\n\n  char port_buf[16];\n  snprintf(port_buf, sizeof(port_buf), \"%d\", socket.local_endpoint().port());\n  env.set(\"SERVER_PORT\", port_buf);\n  env.set(\"REMOTE_ADDR\", socket.remote_endpoint().address().to_string());\n  // TODO: set SERVER_PORT_SECURE if using ssl\n  // TODO: set REMOTE_USER if authenticated\n  return 0;\n}", "target": 2, "idx": 11950}
{"commit_id": "85be877925ddbf34f74a1229f3ca1716bb6170dc", "project": "harfbuzz", "func": "bool prev (unsigned *unsafe_from = nullptr)\n    {\n      assert (num_items > 0);\n      /* The alternate condition below is faster at string boundaries,\n       * but produces subpar \"unsafe-to-concat\" values. */\n      unsigned stop = num_items - 1;\n      if (c->buffer->flags & HB_BUFFER_FLAG_PRODUCE_UNSAFE_TO_CONCAT)\n        stop = 1 - 1;\n\n      /* When looking back, limit how far we search; this function is mostly\n       * used for looking back for base glyphs when attaching marks. If we\n       * don't limit, we can get O(n^2) behavior where n is the number of\n       * consecutive marks. */\n      stop = (unsigned) hb_max ((int) stop, (int) idx - HB_MAX_CONTEXT_LENGTH);\n\n      while (idx > stop)\n      {\n\tidx--;\n\thb_glyph_info_t &info = c->buffer->out_info[idx];\n\n\tmatcher_t::may_skip_t skip = matcher.may_skip (c, info);\n\tif (unlikely (skip == matcher_t::SKIP_YES))\n\t  continue;\n\n\tmatcher_t::may_match_t match = matcher.may_match (info, get_glyph_data ());\n\tif (match == matcher_t::MATCH_YES ||\n\t    (match == matcher_t::MATCH_MAYBE &&\n\t     skip == matcher_t::SKIP_NO))\n\t{\n\t  num_items--;\n\t  advance_glyph_data ();\n\t  return true;\n\t}\n\n\tif (skip == matcher_t::SKIP_NO)\n\t{\n\t  if (unsafe_from)\n\t    *unsafe_from = hb_max (1u, idx) - 1u;\n\t  return false;\n\t}\n      }\n      if (unsafe_from)\n        *unsafe_from = 0;\n      return false;\n    }", "target": 2, "idx": 11951}
{"commit_id": "091835377369c8fd5917d9b87acffa721ad2a168", "project": "facebook/hermes", "func": "std::pair<Function *, Function *> ESTreeIRGen::doLazyFunction(\n    hbc::LazyCompilationData *lazyData) {\n  // Create a top level function that will never be executed, because:\n  // 1. IRGen assumes the first function always has global scope\n  // 2. It serves as the root for dummy functions for lexical data\n  Function *topLevel = Builder.createTopLevelFunction(lazyData->strictMode, {});\n\n  FunctionContext topLevelFunctionContext{this, topLevel, nullptr};\n\n  // Save the top-level context, but ensure it doesn't outlive what it is\n  // pointing to.\n  llvh::SaveAndRestore<FunctionContext *> saveTopLevelContext(\n      topLevelContext, &topLevelFunctionContext);\n\n  auto *node = cast<ESTree::FunctionLikeNode>(Root);\n\n  // We restore scoping information in two separate ways:\n  // 1. By adding them to ExternalScopes for resolution here\n  // 2. By adding dummy functions for lexical scoping debug info later\n  //\n  // Instruction selection determines the delta between the ExternalScope\n  // and the dummy function chain, so we add the ExternalScopes with\n  // positive depth.\n  lexicalScopeChain = lazyData->parentScope;\n  materializeScopesInChain(\n      topLevel, lexicalScopeChain, getDepth(lexicalScopeChain) - 1);\n\n  // If lazyData->closureAlias is specified, we must create an alias binding\n  // between originalName (which must be valid) and the variable identified by\n  // closureAlias.\n  Variable *parentVar = nullptr;\n  if (lazyData->closureAlias.isValid()) {\n    assert(lazyData->originalName.isValid() && \"Original name invalid\");\n    assert(\n        lazyData->originalName != lazyData->closureAlias &&\n        \"Original name must be different from the alias\");\n\n    // NOTE: the closureAlias target must exist and must be a Variable.\n    parentVar = cast<Variable>(nameTable_.lookup(lazyData->closureAlias));\n\n    // Re-create the alias.\n    nameTable_.insert(lazyData->originalName, parentVar);\n  }\n\n  assert(\n      !llvh::isa<ESTree::ArrowFunctionExpressionNode>(node) &&\n      \"lazy compilation not supported for arrow functions\");\n\n  auto *func = genES5Function(\n      lazyData->originalName,\n      parentVar,\n      node,\n      lazyData->isGeneratorInnerFunction);\n  addLexicalDebugInfo(func, topLevel, lexicalScopeChain);\n  return {func, topLevel};\n}", "target": 2, "idx": 11952}
{"commit_id": "0926f91083f34d047abc74f1ca4fa6a9c161f7db", "project": "torvalds/linux", "func": "int mlx4_register_vlan(struct mlx4_dev *dev, u8 port, u16 vlan, int *index)\n{\n\tstruct mlx4_vlan_table *table = &mlx4_priv(dev)->port[port].vlan_table;\n\tint i, err = 0;\n\tint free = -1;\n\n\tmutex_lock(&table->mutex);\n\tfor (i = MLX4_VLAN_REGULAR; i < MLX4_MAX_VLAN_NUM; i++) {\n\t\tif (free < 0 && (table->refs[i] == 0)) {\n\t\t\tfree = i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (table->refs[i] &&\n\t\t    (vlan == (MLX4_VLAN_MASK &\n\t\t\t      be32_to_cpu(table->entries[i])))) {\n\t\t\t/* Vlan already registered, increase refernce count */\n\t\t\t*index = i;\n\t\t\t++table->refs[i];\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (free < 0) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (table->total == table->max) {\n\t\t/* No free vlan entries */\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/* Register new MAC */\n\ttable->refs[free] = 1;\n\ttable->entries[free] = cpu_to_be32(vlan | MLX4_VLAN_VALID);\n\n\terr = mlx4_set_port_vlan_table(dev, port, table->entries);\n\tif (unlikely(err)) {\n\t\tmlx4_warn(dev, \"Failed adding vlan: %u\\n\", vlan);\n\t\ttable->refs[free] = 0;\n\t\ttable->entries[free] = 0;\n\t\tgoto out;\n\t}\n\n\t*index = free;\n\t++table->total;\nout:\n\tmutex_unlock(&table->mutex);\n\treturn err;\n}", "target": 1, "idx": 11953}
{"commit_id": "24403a9a35cd7fbe5ea6e596b1c6deb9d8633566", "project": "wireshark", "func": "static gchar *\nrtmpt_get_amf_param(tvbuff_t *tvb, gint offset, proto_item* pi, gint param, const gchar *prop)\n{\n        guint32 remain = tvb_reported_length_remaining(tvb, offset);\n        guint32 itemlen;\n        guint32 iStringLength;\n\n        while (remain > 0 && param > 0) {\n                itemlen = rtmpt_get_amf_length(tvb, offset, pi);\n                if (itemlen == 0)\n                        break;\n                offset += itemlen;\n                remain -= itemlen;\n                param--;\n        }\n\n        if (remain > 0 && param == 0) {\n                guint8 iObjType = tvb_get_guint8(tvb, offset);\n\n                if (!prop && iObjType == AMF0_STRING && remain >= 3) {\n                        iStringLength = tvb_get_ntohs(tvb, offset+1);\n                        if (remain >= iStringLength+3) {\n                                return tvb_get_string_enc(wmem_packet_scope(), tvb, offset+3, iStringLength, ENC_ASCII);\n                        }\n                }\n\n                if (prop && iObjType == AMF0_OBJECT) {\n                        offset++;\n                        remain--;\n\n                        while (remain > 2) {\n                                guint32 iPropLength = tvb_get_ntohs(tvb, offset);\n                                if (remain < 2+iPropLength+3)\n                                        break;\n\n                                if (tvb_strneql(tvb, offset+2, prop, strlen(prop)) == 0) {\n                                        if (tvb_get_guint8(tvb, offset+2+iPropLength) != AMF0_STRING)\n                                                break;\n\n                                        iStringLength = tvb_get_ntohs(tvb, offset+2+iPropLength+1);\n                                        if (remain < 2+iPropLength+3+iStringLength)\n                                                break;\n\n                                        return tvb_get_string_enc(wmem_packet_scope(), tvb, offset+2+iPropLength+3, iStringLength, ENC_ASCII);\n                                }\n\n                                itemlen = rtmpt_get_amf_length(tvb, offset+2+iPropLength, pi);\n                                if (itemlen == 0)\n                                        break;\n                                offset += 2+iPropLength+itemlen;\n                                remain -= 2+iPropLength+itemlen;\n                        }\n                }\n        }\n\n        return NULL;\n}", "target": 2, "idx": 11954}
{"commit_id": "16b1414de91b5a82a0996c67f6db3af7d7e32873", "project": "xen-project/xen", "func": "static int replace_grant_va_mapping(\n    unsigned long addr, unsigned long frame, unsigned int grant_pte_flags,\n    l1_pgentry_t nl1e, struct vcpu *v)\n{\n    l1_pgentry_t *pl1e, ol1e;\n    unsigned long gl1mfn;\n    struct page_info *l1pg;\n    int rc = 0;\n\n    pl1e = guest_map_l1e(addr, &gl1mfn);\n    if ( !pl1e )\n    {\n        gdprintk(XENLOG_WARNING, \"Could not find L1 PTE for address %lx\\n\", addr);\n        return GNTST_general_error;\n    }\n\n    if ( !get_page_from_mfn(_mfn(gl1mfn), current->domain) )\n    {\n        rc = GNTST_general_error;\n        goto out;\n    }\n\n    l1pg = mfn_to_page(_mfn(gl1mfn));\n    if ( !page_lock(l1pg) )\n    {\n        rc = GNTST_general_error;\n        put_page(l1pg);\n        goto out;\n    }\n\n    if ( (l1pg->u.inuse.type_info & PGT_type_mask) != PGT_l1_page_table )\n    {\n        rc = GNTST_general_error;\n        goto unlock_and_out;\n    }\n\n    ol1e = *pl1e;\n\n    /*\n     * Check that the virtual address supplied is actually mapped to frame\n     * (with appropriate permissions).\n     */\n    if ( unlikely(l1e_get_pfn(ol1e) != frame) ||\n         unlikely((l1e_get_flags(ol1e) ^ grant_pte_flags) &\n                  (_PAGE_PRESENT | _PAGE_RW)) )\n    {\n        gdprintk(XENLOG_ERR,\n                 \"PTE %\"PRIpte\" for %lx doesn't match grant (%\"PRIpte\")\\n\",\n                 l1e_get_intpte(ol1e), addr,\n                 l1e_get_intpte(l1e_from_pfn(frame, grant_pte_flags)));\n        rc = GNTST_general_error;\n        goto unlock_and_out;\n    }\n\n    if ( unlikely((l1e_get_flags(ol1e) ^ grant_pte_flags) &\n                  ~(_PAGE_AVAIL | PAGE_CACHE_ATTRS)) )\n        gdprintk(XENLOG_WARNING,\n                 \"PTE flags %x for %\"PRIx64\" don't match grant (%x)\\n\",\n                 l1e_get_flags(ol1e), addr, grant_pte_flags);\n\n    /* Delete pagetable entry. */\n    if ( unlikely(!UPDATE_ENTRY(l1, pl1e, ol1e, nl1e, gl1mfn, v, 0)) )\n    {\n        gdprintk(XENLOG_WARNING, \"Cannot delete PTE entry for %\"PRIx64\"\\n\",\n                 addr);\n        rc = GNTST_general_error;\n        goto unlock_and_out;\n    }\n\n unlock_and_out:\n    page_unlock(l1pg);\n    put_page(l1pg);\n out:\n    guest_unmap_l1e(pl1e);\n    return rc;\n}", "target": 2, "idx": 11955}
{"commit_id": "2b17c400aeb44daf041627722581ade527bb3c1d", "project": "torvalds/linux", "func": "static int isotp_bind(struct socket *sock, struct sockaddr *uaddr, int len)\n{\n\tstruct sockaddr_can *addr = (struct sockaddr_can *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct isotp_sock *so = isotp_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tint ifindex;\n\tstruct net_device *dev;\n\tint err = 0;\n\tint notify_enetdown = 0;\n\tint do_rx_reg = 1;\n\n\tif (len < ISOTP_MIN_NAMELEN)\n\t\treturn -EINVAL;\n\n\tif (addr->can_addr.tp.tx_id & (CAN_ERR_FLAG | CAN_RTR_FLAG))\n\t\treturn -EADDRNOTAVAIL;\n\n\tif (!addr->can_ifindex)\n\t\treturn -ENODEV;\n\n\tlock_sock(sk);\n\n\t/* do not register frame reception for functional addressing */\n\tif (so->opt.flags & CAN_ISOTP_SF_BROADCAST)\n\t\tdo_rx_reg = 0;\n\n\t/* do not validate rx address for functional addressing */\n\tif (do_rx_reg) {\n\t\tif (addr->can_addr.tp.rx_id == addr->can_addr.tp.tx_id) {\n\t\t\terr = -EADDRNOTAVAIL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (addr->can_addr.tp.rx_id & (CAN_ERR_FLAG | CAN_RTR_FLAG)) {\n\t\t\terr = -EADDRNOTAVAIL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (so->bound && addr->can_ifindex == so->ifindex &&\n\t    addr->can_addr.tp.rx_id == so->rxid &&\n\t    addr->can_addr.tp.tx_id == so->txid)\n\t\tgoto out;\n\n\tdev = dev_get_by_index(net, addr->can_ifindex);\n\tif (!dev) {\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\tif (dev->type != ARPHRD_CAN) {\n\t\tdev_put(dev);\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\tif (dev->mtu < so->ll.mtu) {\n\t\tdev_put(dev);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (!(dev->flags & IFF_UP))\n\t\tnotify_enetdown = 1;\n\n\tifindex = dev->ifindex;\n\n\tif (do_rx_reg)\n\t\tcan_rx_register(net, dev, addr->can_addr.tp.rx_id,\n\t\t\t\tSINGLE_MASK(addr->can_addr.tp.rx_id),\n\t\t\t\tisotp_rcv, sk, \"isotp\", sk);\n\n\tdev_put(dev);\n\n\tif (so->bound && do_rx_reg) {\n\t\t/* unregister old filter */\n\t\tif (so->ifindex) {\n\t\t\tdev = dev_get_by_index(net, so->ifindex);\n\t\t\tif (dev) {\n\t\t\t\tcan_rx_unregister(net, dev, so->rxid,\n\t\t\t\t\t\t  SINGLE_MASK(so->rxid),\n\t\t\t\t\t\t  isotp_rcv, sk);\n\t\t\t\tdev_put(dev);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* switch to new settings */\n\tso->ifindex = ifindex;\n\tso->rxid = addr->can_addr.tp.rx_id;\n\tso->txid = addr->can_addr.tp.tx_id;\n\tso->bound = 1;\n\nout:\n\trelease_sock(sk);\n\n\tif (notify_enetdown) {\n\t\tsk->sk_err = ENETDOWN;\n\t\tif (!sock_flag(sk, SOCK_DEAD))\n\t\t\tsk->sk_error_report(sk);\n\t}\n\n\treturn err;\n}", "target": 2, "idx": 11956}
{"commit_id": "95f36d661f2b75887772ea28baaad904bde96970", "project": "OP-TEE/optee_os", "func": "TEE_Result tee_mmu_check_access_rights(const struct user_ta_ctx *utc,\n\t\t\t\t       uint32_t flags, uaddr_t uaddr,\n\t\t\t\t       size_t len)\n{\n\tuaddr_t a;\n\tuaddr_t end_addr = 0;\n\tsize_t addr_incr = MIN(CORE_MMU_USER_CODE_SIZE,\n\t\t\t       CORE_MMU_USER_PARAM_SIZE);\n\n\tif (ADD_OVERFLOW(uaddr, len, &end_addr))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t    (flags & TEE_MEMORY_ACCESS_SECURE))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\t/*\n\t * Rely on TA private memory test to check if address range is private\n\t * to TA or not.\n\t */\n\tif (!(flags & TEE_MEMORY_ACCESS_ANY_OWNER) &&\n\t   !tee_mmu_is_vbuf_inside_ta_private(utc, (void *)uaddr, len))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\tfor (a = ROUNDDOWN(uaddr, addr_incr); a < end_addr; a += addr_incr) {\n\t\tuint32_t attr;\n\t\tTEE_Result res;\n\n\t\tres = tee_mmu_user_va2pa_attr(utc, (void *)a, NULL, &attr);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t\t    (attr & TEE_MATTR_SECURE))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\t\tif ((flags & TEE_MEMORY_ACCESS_SECURE) &&\n\t\t    !(attr & TEE_MATTR_SECURE))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\t\tif ((flags & TEE_MEMORY_ACCESS_WRITE) && !(attr & TEE_MATTR_UW))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t\tif ((flags & TEE_MEMORY_ACCESS_READ) && !(attr & TEE_MATTR_UR))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t}\n\n\treturn TEE_SUCCESS;\n}", "target": 3, "idx": 11957}
{"commit_id": "04f2d32871bb3b11d7dc024039952f2fe2750306", "project": "acassen/keepalived", "func": "static void\nvrrp_tfile_end_handler(void)\n{\n\tvrrp_tracked_file_t *tfile = LIST_TAIL_DATA(vrrp_data->vrrp_track_files);\n\tstruct stat statb;\n\tFILE *tf;\n\tint ret;\n\n\tif (!tfile->file_path) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"No file set for track_file %s - removing\", tfile->fname);\n\t\tfree_list_element(vrrp_data->vrrp_track_files, vrrp_data->vrrp_track_files->tail);\n\t\treturn;\n\t}\n\n\tif (track_file_init == TRACK_FILE_NO_INIT)\n\t\treturn;\n\n\tret = stat(tfile->file_path, &statb);\n\tif (!ret) {\n\t\tif (track_file_init == TRACK_FILE_CREATE) {\n\t\t\t/* The file exists */\n\t\t\treturn;\n\t\t}\n\t\tif ((statb.st_mode & S_IFMT) != S_IFREG) {\n\t\t\t/* It is not a regular file */\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Cannot initialise track file %s - it is not a regular file\", tfile->fname);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Don't overwrite a file on reload */\n\t\tif (reload)\n\t\t\treturn;\n\t}\n\n\tif (!__test_bit(CONFIG_TEST_BIT, &debug)) {\n\t\t/* Write the value to the file */\n\t\tif ((tf = fopen_safe(tfile->file_path, \"w\"))) {\n\t\t\tfprintf(tf, \"%d\\n\", track_file_init_value);\n\t\t\tfclose(tf);\n\t\t}\n\t\telse\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Unable to initialise track file %s\", tfile->fname);\n\t}\n}", "target": 1, "idx": 11958}
{"commit_id": "146cc8a17a3b4996f6805ee5c080e7101277c410", "project": "torvalds/linux", "func": "static int klsi_105_get_line_state(struct usb_serial_port *port,\n\t\t\t\t   unsigned long *line_state_p)\n{\n\tint rc;\n\tu8 *status_buf;\n\t__u16 status;\n\n\tdev_info(&port->serial->dev->dev, \"sending SIO Poll request\\n\");\n\n\tstatus_buf = kmalloc(KLSI_STATUSBUF_LEN, GFP_KERNEL);\n\tif (!status_buf)\n\t\treturn -ENOMEM;\n\n\tstatus_buf[0] = 0xff;\n\tstatus_buf[1] = 0xff;\n\trc = usb_control_msg(port->serial->dev,\n\t\t\t     usb_rcvctrlpipe(port->serial->dev, 0),\n\t\t\t     KL5KUSB105A_SIO_POLL,\n\t\t\t     USB_TYPE_VENDOR | USB_DIR_IN,\n\t\t\t     0, /* value */\n\t\t\t     0, /* index */\n\t\t\t     status_buf, KLSI_STATUSBUF_LEN,\n\t\t\t     10000\n\t\t\t     );\n\tif (rc != KLSI_STATUSBUF_LEN) {\n\t\tdev_err(&port->dev, \"reading line status failed: %d\\n\", rc);\n\t\tif (rc >= 0)\n\t\t\trc = -EIO;\n\t} else {\n\t\tstatus = get_unaligned_le16(status_buf);\n\n\t\tdev_info(&port->serial->dev->dev, \"read status %x %x\\n\",\n\t\t\t status_buf[0], status_buf[1]);\n\n\t\t*line_state_p = klsi_105_status2linestate(status);\n\t}\n\n\tkfree(status_buf);\n\treturn rc;\n}", "target": 1, "idx": 11959}
{"commit_id": "0daec57f5cfc4225aa4527b537b4ec4fbbc35635", "project": "mumble-voip/mumble", "func": "void Server::msgUserState(ServerUser *uSource, MumbleProto::UserState &msg) {\n\tMSG_SETUP(ServerUser::Authenticated);\n\tVICTIM_SETUP;\n\n\tChannel *root = qhChannels.value(0);\n\n\t/*\n\t\tFirst check all permissions involved\n\t*/\n\tif ((pDstServerUser->iId == 0) && (uSource->iId != 0)) {\n\t\tPERM_DENIED_TYPE(SuperUser);\n\t\treturn;\n\t}\n\n\tmsg.set_session(pDstServerUser->uiSession);\n\tmsg.set_actor(uSource->uiSession);\n\n\tif (msg.has_name()) {\n\t\tPERM_DENIED_TYPE(UserName);\n\t\treturn;\n\t}\n\n\tif (uSource == pDstServerUser) {\n\t\tRATELIMIT(uSource);\n\t}\n\n\tif (msg.has_channel_id()) {\n\t\tChannel *c = qhChannels.value(msg.channel_id());\n\t\tif (!c || (c == pDstServerUser->cChannel))\n\t\t\treturn;\n\n\t\tif ((uSource != pDstServerUser) && (! hasPermission(uSource, pDstServerUser->cChannel, ChanACL::Move))) {\n\t\t\tPERM_DENIED(uSource, pDstServerUser->cChannel, ChanACL::Move);\n\t\t\treturn;\n\t\t}\n\n\t\tif (! hasPermission(uSource, c, ChanACL::Move) && ! hasPermission(pDstServerUser, c, ChanACL::Enter)) {\n\t\t\tPERM_DENIED(pDstServerUser, c, ChanACL::Enter);\n\t\t\treturn;\n\t\t}\n\t\tif (isChannelFull(c, uSource)) {\n\t\t\tPERM_DENIED_FALLBACK(ChannelFull, 0x010201, QLatin1String(\"Channel is full\"));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (msg.has_mute() || msg.has_deaf() || msg.has_suppress() || msg.has_priority_speaker()) {\n\t\tif (pDstServerUser->iId == 0) {\n\t\t\tPERM_DENIED_TYPE(SuperUser);\n\t\t\treturn;\n\t\t}\n\t\tif (uSource->cChannel->bTemporary) {\n\t\t\tPERM_DENIED_TYPE(TemporaryChannel);\n\t\t\treturn;\n\t\t}\n\t\tif (! hasPermission(uSource, pDstServerUser->cChannel, ChanACL::MuteDeafen) || msg.suppress()) {\n\t\t\tPERM_DENIED(uSource, pDstServerUser->cChannel, ChanACL::MuteDeafen);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tQString comment;\n\n\tif (msg.has_comment()) {\n\t\tbool changed = false;\n\t\tcomment = u8(msg.comment());\n\t\tif (uSource != pDstServerUser) {\n\t\t\tif (! hasPermission(uSource, root, ChanACL::Move)) {\n\t\t\t\tPERM_DENIED(uSource, root, ChanACL::Move);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (comment.length() > 0) {\n\t\t\t\tPERM_DENIED_TYPE(TextTooLong);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\n\t\tif (! isTextAllowed(comment, changed)) {\n\t\t\tPERM_DENIED_TYPE(TextTooLong);\n\t\t\treturn;\n\t\t}\n\t\tif (changed)\n\t\t\tmsg.set_comment(u8(comment));\n\t}\n\n\tif (msg.has_texture()) {\n\t\tif (iMaxImageMessageLength > 0 && (msg.texture().length() > static_cast<unsigned int>(iMaxImageMessageLength))) {\n\t\t\tPERM_DENIED_TYPE(TextTooLong);\n\t\t\treturn;\n\t\t}\n\t\tif (uSource != pDstServerUser) {\n\t\t\tif (! hasPermission(uSource, root, ChanACL::Move)) {\n\t\t\t\tPERM_DENIED(uSource, root, ChanACL::Move);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (msg.texture().length() > 0) {\n\t\t\t\tPERM_DENIED_TYPE(TextTooLong);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tif (msg.has_user_id()) {\n\t\tChanACL::Perm p = (uSource == pDstServerUser) ? ChanACL::SelfRegister : ChanACL::Register;\n\t\tif ((pDstServerUser->iId >= 0) || ! hasPermission(uSource, root, p)) {\n\t\t\tPERM_DENIED(uSource, root, p);\n\t\t\treturn;\n\t\t}\n\t\tif (pDstServerUser->qsHash.isEmpty()) {\n\t\t\tPERM_DENIED_HASH(pDstServerUser);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// Prevent self-targeting state changes from being applied to others\n\tif ((pDstServerUser != uSource) && (msg.has_self_deaf() || msg.has_self_mute() || msg.has_plugin_context() || msg.has_plugin_identity() || msg.has_recording())) {\n\t\treturn;\n\t}\n\n\t/*\n\t\t-------------------- Permission checks done. Now act --------------------\n\t*/\n\tbool bBroadcast = false;\n\n\tif (msg.has_texture()) {\n\t\tQByteArray qba = blob(msg.texture());\n\t\tif (pDstServerUser->iId > 0) {\n\t\t\t// For registered users store the texture we just received in the database\n\t\t\tif (! setTexture(pDstServerUser->iId, qba)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\t// For unregistered users or SuperUser only get the hash\n\t\t\thashAssign(pDstServerUser->qbaTexture, pDstServerUser->qbaTextureHash, qba);\n\t\t}\n\n\t\t// The texture will be sent out later in this function\n\t\tbBroadcast = true;\n\t}\n\n\t// Writing to bSelfMute, bSelfDeaf and ssContext\n\t// requires holding a write lock on qrwlVoiceThread.\n\t{\n\t\tQWriteLocker wl(&qrwlVoiceThread);\n\n\t\tif (msg.has_self_deaf()) {\n\t\t\tuSource->bSelfDeaf = msg.self_deaf();\n\t\t\tif (uSource->bSelfDeaf)\n\t\t\t\tmsg.set_self_mute(true);\n\t\t\tbBroadcast = true;\n\t\t}\n\n\t\tif (msg.has_self_mute()) {\n\t\t\tuSource->bSelfMute = msg.self_mute();\n\t\t\tif (! uSource->bSelfMute) {\n\t\t\t\tmsg.set_self_deaf(false);\n\t\t\t\tuSource->bSelfDeaf = false;\n\t\t\t}\n\t\t\tbBroadcast = true;\n\t\t}\n\n\t\tif (msg.has_plugin_context()) {\n\t\t\tuSource->ssContext = msg.plugin_context();\n\n\t\t\t// Make sure to clear this from the packet so we don't broadcast it\n\t\t\tmsg.clear_plugin_context();\n\t\t}\n\t}\n\n\tif (msg.has_plugin_identity()) {\n\t\tuSource->qsIdentity = u8(msg.plugin_identity());\n\t\t// Make sure to clear this from the packet so we don't broadcast it\n\t\tmsg.clear_plugin_identity();\n\t}\n\n\tif (! comment.isNull()) {\n\t\thashAssign(pDstServerUser->qsComment, pDstServerUser->qbaCommentHash, comment);\n\n\t\tif (pDstServerUser->iId >= 0) {\n\t\t\tQMap<int, QString> info;\n\t\t\tinfo.insert(ServerDB::User_Comment, pDstServerUser->qsComment);\n\t\t\tsetInfo(pDstServerUser->iId, info);\n\t\t}\n\t\tbBroadcast = true;\n\t}\n\n\n\n\tif (msg.has_mute() || msg.has_deaf() || msg.has_suppress() || msg.has_priority_speaker()) {\n\t\t// Writing to bDeaf, bMute and bSuppress requires\n\t\t// holding a write lock on qrwlVoiceThread.\n\t\tQWriteLocker wl(&qrwlVoiceThread);\n\n\t\tif (msg.has_deaf()) {\n\t\t\tpDstServerUser->bDeaf = msg.deaf();\n\t\t\tif (pDstServerUser->bDeaf)\n\t\t\t\tmsg.set_mute(true);\n\t\t}\n\t\tif (msg.has_mute()) {\n\t\t\tpDstServerUser->bMute = msg.mute();\n\t\t\tif (! pDstServerUser->bMute) {\n\t\t\t\tmsg.set_deaf(false);\n\t\t\t\tpDstServerUser->bDeaf = false;\n\t\t\t}\n\t\t}\n\t\tif (msg.has_suppress())\n\t\t\tpDstServerUser->bSuppress = msg.suppress();\n\n\t\tif (msg.has_priority_speaker())\n\t\t\tpDstServerUser->bPrioritySpeaker = msg.priority_speaker();\n\n\t\tlog(uSource, QString(\"Changed speak-state of %1 (%2 %3 %4 %5)\").arg(QString(*pDstServerUser),\n\t\t        QString::number(pDstServerUser->bMute),\n\t\t        QString::number(pDstServerUser->bDeaf),\n\t\t        QString::number(pDstServerUser->bSuppress),\n\t\t        QString::number(pDstServerUser->bPrioritySpeaker)));\n\n\t\tbBroadcast = true;\n\t}\n\n\tif (msg.has_recording() && (pDstServerUser->bRecording != msg.recording())) {\n\t\tpDstServerUser->bRecording = msg.recording();\n\n\t\tMumbleProto::TextMessage mptm;\n\t\tmptm.add_tree_id(0);\n\t\tif (pDstServerUser->bRecording)\n\t\t\tmptm.set_message(u8(QString(QLatin1String(\"User '%1' started recording\")).arg(pDstServerUser->qsName)));\n\t\telse\n\t\t\tmptm.set_message(u8(QString(QLatin1String(\"User '%1' stopped recording\")).arg(pDstServerUser->qsName)));\n\n\t\tsendAll(mptm, ~ 0x010203);\n\n\t\tbBroadcast = true;\n\t}\n\n\tif (msg.has_channel_id()) {\n\t\tChannel *c = qhChannels.value(msg.channel_id());\n\n\t\tuserEnterChannel(pDstServerUser, c, msg);\n\t\tlog(uSource, QString(\"Moved %1 to %2\").arg(QString(*pDstServerUser), QString(*c)));\n\t\tbBroadcast = true;\n\t}\n\n\tbool bDstAclChanged = false;\n\tif (msg.has_user_id()) {\n\t\t// Handle user (Self-)Registration\n\t\tQMap<int, QString> info;\n\n\t\tinfo.insert(ServerDB::User_Name, pDstServerUser->qsName);\n\t\tinfo.insert(ServerDB::User_Hash, pDstServerUser->qsHash);\n\t\tif (! pDstServerUser->qslEmail.isEmpty())\n\t\t\tinfo.insert(ServerDB::User_Email, pDstServerUser->qslEmail.first());\n\t\tint id = registerUser(info);\n\t\tif (id > 0) {\n\t\t\tpDstServerUser->iId = id;\n\t\t\tsetLastChannel(pDstServerUser);\n\t\t\tmsg.set_user_id(id);\n\t\t\tbDstAclChanged = true;\n\t\t} else {\n\t\t\t// Registration failed\n\t\t\tmsg.clear_user_id();\n\t\t}\n\t\tbBroadcast = true;\n\t}\n\n\tif (bBroadcast) {\n\t\t// Texture handling for clients < 1.2.2.\n\t\t// Send the texture data in the message.\n\t\tif (msg.has_texture() && (pDstServerUser->qbaTexture.length() >= 4) && (qFromBigEndian<unsigned int>(reinterpret_cast<const unsigned char *>(pDstServerUser->qbaTexture.constData())) != 600 * 60 * 4)) {\n\t\t\t// This is a new style texture, don't send it because the client doesn't handle it correctly / crashes.\n\t\t\tmsg.clear_texture();\n\t\t\tsendAll(msg, ~ 0x010202);\n\t\t\tmsg.set_texture(blob(pDstServerUser->qbaTexture));\n\t\t} else {\n\t\t\t// This is an old style texture, empty texture or there was no texture in this packet,\n\t\t\t// send the message unchanged.\n\t\t\tsendAll(msg, ~ 0x010202);\n\t\t}\n\n\t\t// Texture / comment handling for clients >= 1.2.2.\n\t\t// Send only a hash of the texture / comment text. The client will request the actual data if necessary.\n\t\tif (msg.has_texture() && ! pDstServerUser->qbaTextureHash.isEmpty()) {\n\t\t\tmsg.clear_texture();\n\t\t\tmsg.set_texture_hash(blob(pDstServerUser->qbaTextureHash));\n\t\t}\n\t\tif (msg.has_comment() && ! pDstServerUser->qbaCommentHash.isEmpty()) {\n\t\t\tmsg.clear_comment();\n\t\t\tmsg.set_comment_hash(blob(pDstServerUser->qbaCommentHash));\n\t\t}\n\n\t\tsendAll(msg, 0x010202);\n\n\t\tif (bDstAclChanged)\n\t\t\tclearACLCache(pDstServerUser);\n\t}\n\n\temit userStateChanged(pDstServerUser);\n}", "target": 2, "idx": 11960}
{"commit_id": "40b00cfb32256d377608b4d4cd30fac338d0a0bc", "project": "libtiff", "func": "static int\ncreateImageSection(uint32_t sectsize, unsigned char **sect_buff_ptr)\n  {\n  unsigned  char *sect_buff = NULL;\n  unsigned  char *new_buff  = NULL;\n  static    uint32_t  prev_sectsize = 0;\n  \n  sect_buff = *sect_buff_ptr;\n\n  if (!sect_buff)\n    {\n    sect_buff = (unsigned char *)limitMalloc(sectsize);\n    if (!sect_buff)\n    {\n        TIFFError(\"createImageSection\", \"Unable to allocate/reallocate section buffer\");\n        return (-1);\n    }\n    _TIFFmemset(sect_buff, 0, sectsize);\n    }\n  else\n    {\n    if (prev_sectsize < sectsize)\n      {\n      new_buff = _TIFFrealloc(sect_buff, sectsize);\n      if (!new_buff)\n        {\n          _TIFFfree (sect_buff);\n        sect_buff = (unsigned char *)limitMalloc(sectsize);\n        }\n      else\n        sect_buff = new_buff;\n\n      if (!sect_buff)\n      {\n          TIFFError(\"createImageSection\", \"Unable to allocate/reallocate section buffer\");\n          return (-1);\n      }\n      _TIFFmemset(sect_buff, 0, sectsize);\n      }\n    }\n\n  prev_sectsize = sectsize;\n  *sect_buff_ptr = sect_buff;\n\n  return (0);\n  }", "target": 1, "idx": 11961}
{"commit_id": "5f16640725b1225e6337c62526e6577f0f88edb8", "project": "ImageMagick", "func": "static inline size_t GetPSDRowSize(Image *image)\n{\n  if (image->depth == 1)\n    return(((image->columns+7)/8)*GetPSDPacketSize(image));\n  else\n    return(image->columns*GetPSDPacketSize(image));\n}", "target": 1, "idx": 11962}
{"commit_id": "c53ec7708e6f97fabc4a532a48d6099f1202d913", "project": "OP-TEE/optee_os", "func": "int rsa_exptmod(const unsigned char *in,   unsigned long inlen,\n                      unsigned char *out,  unsigned long *outlen, int which,\n                      rsa_key *key)\n{\n   void         *tmp, *tmpa, *tmpb;\n#ifdef LTC_RSA_BLINDING\n   void        *rnd, *rndi /* inverse of rnd */;\n#endif\n   unsigned long x;\n   int           err, no_crt;\n\n   LTC_ARGCHK(in     != NULL);\n   LTC_ARGCHK(out    != NULL);\n   LTC_ARGCHK(outlen != NULL);\n   LTC_ARGCHK(key    != NULL);\n  \n   /* is the key of the right type for the operation? */\n   if (which == PK_PRIVATE && (key->type != PK_PRIVATE)) {\n      return CRYPT_PK_NOT_PRIVATE;\n   }\n\n   /* must be a private or public operation */\n   if (which != PK_PRIVATE && which != PK_PUBLIC) {\n      return CRYPT_PK_INVALID_TYPE;\n   }\n\n   /* init and copy into tmp */\n   if ((err = mp_init_multi(&tmp, &tmpa, &tmpb,\n#ifdef LTC_RSA_BLINDING\n                                               &rnd, &rndi,\n#endif /* LTC_RSA_BLINDING */\n                                                           NULL)) != CRYPT_OK)\n        { return err; }\n   if ((err = mp_read_unsigned_bin(tmp, (unsigned char *)in, (int)inlen)) != CRYPT_OK)\n        { goto error; }\n\n   /* sanity check on the input */\n   if (mp_cmp(key->N, tmp) == LTC_MP_LT) {\n      err = CRYPT_PK_INVALID_SIZE;\n      goto error;\n   }\n\n   if (which == PK_PRIVATE) {\n#ifdef LTC_RSA_BLINDING\n      /* do blinding */\n      err = mp_rand(rnd, mp_get_digit_count(key->N));\n      if (err != CRYPT_OK) {\n             goto error;\n      }\n\n      /* rndi = 1/rnd mod N */\n      err = mp_invmod(rnd, key->N, rndi);\n      if (err != CRYPT_OK) {\n             goto error;\n      }\n\n      /* rnd = rnd^e */\n      err = mp_exptmod( rnd, key->e, key->N, rnd);\n      if (err != CRYPT_OK) {\n             goto error;\n      }\n\n      /* tmp = tmp*rnd mod N */\n      err = mp_mulmod( tmp, rnd, key->N, tmp);\n      if (err != CRYPT_OK) {\n             goto error;\n      }\n#endif /* LTC_RSA_BLINDING */\n\n      no_crt = (key->dP == NULL) || (mp_get_digit_count(key->dP) == 0);\n\n      if (no_crt) {\n         /*\n          * In case CRT optimization parameters are not provided,\n          * the private key is directly used to exptmod it\n          */\n         if ((err = mp_exptmod(tmp, key->d, key->N, tmp)) != CRYPT_OK)                              { goto error; }\n      } else {\n         /* tmpa = tmp^dP mod p */\n         if ((err = mp_exptmod(tmp, key->dP, key->p, tmpa)) != CRYPT_OK)                            { goto error; }\n\n         /* tmpb = tmp^dQ mod q */\n         if ((err = mp_exptmod(tmp, key->dQ, key->q, tmpb)) != CRYPT_OK)                            { goto error; }\n\n         /* tmp = (tmpa - tmpb) * qInv (mod p) */\n         if ((err = mp_sub(tmpa, tmpb, tmp)) != CRYPT_OK)                                           { goto error; }\n         if ((err = mp_mulmod(tmp, key->qP, key->p, tmp)) != CRYPT_OK)                              { goto error; }\n\n         /* tmp = tmpb + q * tmp */\n         if ((err = mp_mul(tmp, key->q, tmp)) != CRYPT_OK)                                          { goto error; }\n         if ((err = mp_add(tmp, tmpb, tmp)) != CRYPT_OK)                                            { goto error; }\n      }\n\n      #ifdef LTC_RSA_BLINDING\n      /* unblind */\n      err = mp_mulmod( tmp, rndi, key->N, tmp);\n      if (err != CRYPT_OK) {\n             goto error;\n      }\n      #endif\n\n      #ifdef LTC_RSA_CRT_HARDENING\n      if (!no_crt) {\n         if ((err = mp_exptmod(tmp, key->e, key->N, tmpa)) != CRYPT_OK)                              { goto error; }\n         if ((err = mp_read_unsigned_bin(tmpb, (unsigned char *)in, (int)inlen)) != CRYPT_OK)        { goto error; }\n         if (mp_cmp(tmpa, tmpb) != LTC_MP_EQ)                                     { err = CRYPT_ERROR; goto error; }\n      }\n      #endif\n   } else {\n      /* exptmod it */\n      if ((err = mp_exptmod(tmp, key->e, key->N, tmp)) != CRYPT_OK)                                { goto error; }\n   }\n\n   /* read it back */\n   x = (unsigned long)mp_unsigned_bin_size(key->N);\n   if (x > *outlen) {\n      *outlen = x;\n      err = CRYPT_BUFFER_OVERFLOW;\n      goto error;\n   }\n\n   /* this should never happen ... */\n   if (mp_unsigned_bin_size(tmp) > mp_unsigned_bin_size(key->N)) {\n      err = CRYPT_ERROR;\n      goto error;\n   }\n   *outlen = x;\n\n   /* convert it */\n   zeromem(out, x);\n   if ((err = mp_to_unsigned_bin(tmp, out+(x-mp_unsigned_bin_size(tmp)))) != CRYPT_OK)               { goto error; }\n\n   /* clean up and return */\n   err = CRYPT_OK;\nerror:\n   mp_clear_multi(\n#ifdef LTC_RSA_BLINDING\n                  rndi, rnd,\n#endif /* LTC_RSA_BLINDING */\n                             tmpb, tmpa, tmp, NULL);\n   return err;\n}", "target": 2, "idx": 11963}
{"commit_id": "91c7cbfe31bbef57d5fcf7d76989fc159f73ef15", "project": "vim", "func": "char_u *\neval_next_line(char_u *arg, evalarg_T *evalarg)\n{\n    garray_T\t*gap = &evalarg->eval_ga;\n    char_u\t*line;\n\n    if (arg != NULL)\n    {\n\tif (*arg == NL)\n\t    return newline_skip_comments(arg);\n\t// Truncate before a trailing comment, so that concatenating the lines\n\t// won't turn the rest into a comment.\n\tif (*skipwhite(arg) == '#')\n\t    *arg = NUL;\n    }\n\n    if (evalarg->eval_cookie != NULL)\n\tline = evalarg->eval_getline(0, evalarg->eval_cookie, 0,\n\t\t\t\t\t\t\t   GETLINE_CONCAT_ALL);\n    else\n\tline = next_line_from_context(evalarg->eval_cctx, TRUE);\n    if (line == NULL)\n\treturn NULL;\n\n    ++evalarg->eval_break_count;\n    if (gap->ga_itemsize > 0 && ga_grow(gap, 1) == OK)\n    {\n\tchar_u *p = skipwhite(line);\n\n\t// Going to concatenate the lines after parsing.  For an empty or\n\t// comment line use an empty string.\n\tif (*p == NUL || vim9_comment_start(p))\n\t{\n\t    vim_free(line);\n\t    line = vim_strsave((char_u *)\"\");\n\t}\n\n\t((char_u **)gap->ga_data)[gap->ga_len] = line;\n\t++gap->ga_len;\n    }\n    else if (evalarg->eval_cookie != NULL)\n    {\n\tfree_eval_tofree_later(evalarg);\n\tevalarg->eval_tofree = line;\n    }\n\n    // Advanced to the next line, \"arg\" no longer points into the previous\n    // line.\n    evalarg->eval_using_cmdline = FALSE;\n    return skipwhite(line);\n}", "target": 2, "idx": 11964}
{"commit_id": "7cea5cb64b83d690fe02bc210bbdf08f5a87636f", "project": "android", "func": "void SoftG711::onQueueFilled(OMX_U32 /* portIndex */) {\n    if (mSignalledError) {\n        return;\n    }\n\n    List<BufferInfo *> &inQueue = getPortQueue(0);\n    List<BufferInfo *> &outQueue = getPortQueue(1);\n\n    while (!inQueue.empty() && !outQueue.empty()) {\n        BufferInfo *inInfo = *inQueue.begin();\n        OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;\n\n        BufferInfo *outInfo = *outQueue.begin();\n        OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;\n\n        if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n            inQueue.erase(inQueue.begin());\n            inInfo->mOwnedByUs = false;\n            notifyEmptyBufferDone(inHeader);\n\n            outHeader->nFilledLen = 0;\n            outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n\n            outQueue.erase(outQueue.begin());\n            outInfo->mOwnedByUs = false;\n            notifyFillBufferDone(outHeader);\n            return;\n        }\n\n        if (inHeader->nFilledLen > kMaxNumSamplesPerFrame) {\n            ALOGE(\"input buffer too large (%d).\", inHeader->nFilledLen);\n\n            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n            mSignalledError = true;\n        }\n\n        if (inHeader->nFilledLen * sizeof(int16_t) > outHeader->nAllocLen) {\n            ALOGE(\"output buffer too small (%d).\", outHeader->nAllocLen);\n            android_errorWriteLog(0x534e4554, \"27793163\");\n\n            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n            mSignalledError = true;\n            return;\n        }\n\n        const uint8_t *inputptr = inHeader->pBuffer + inHeader->nOffset;\n\n        if (mIsMLaw) {\n            DecodeMLaw(\n                    reinterpret_cast<int16_t *>(outHeader->pBuffer),\n                    inputptr, inHeader->nFilledLen);\n        } else {\n            DecodeALaw(\n                    reinterpret_cast<int16_t *>(outHeader->pBuffer),\n                    inputptr, inHeader->nFilledLen);\n        }\n\n        outHeader->nTimeStamp = inHeader->nTimeStamp;\n        outHeader->nOffset = 0;\n        outHeader->nFilledLen = inHeader->nFilledLen * sizeof(int16_t);\n        outHeader->nFlags = 0;\n\n        inInfo->mOwnedByUs = false;\n        inQueue.erase(inQueue.begin());\n        inInfo = NULL;\n        notifyEmptyBufferDone(inHeader);\n        inHeader = NULL;\n\n        outInfo->mOwnedByUs = false;\n        outQueue.erase(outQueue.begin());\n        outInfo = NULL;\n        notifyFillBufferDone(outHeader);\n        outHeader = NULL;\n    }\n}", "target": 2, "idx": 11965}
{"commit_id": "09a93c1df3eafa43bcdfd7bf837c574911f12f55", "project": "torvalds/linux", "func": "static long kvm_s390_guest_sida_op(struct kvm_vcpu *vcpu,\n\t\t\t\t   struct kvm_s390_mem_op *mop)\n{\n\tvoid __user *uaddr = (void __user *)mop->buf;\n\tint r = 0;\n\n\tif (mop->flags || !mop->size)\n\t\treturn -EINVAL;\n\tif (mop->size + mop->sida_offset < mop->size)\n\t\treturn -EINVAL;\n\tif (mop->size + mop->sida_offset > sida_size(vcpu->arch.sie_block))\n\t\treturn -E2BIG;\n\tif (!kvm_s390_pv_cpu_is_protected(vcpu))\n\t\treturn -EINVAL;\n\n\tswitch (mop->op) {\n\tcase KVM_S390_MEMOP_SIDA_READ:\n\t\tif (copy_to_user(uaddr, (void *)(sida_origin(vcpu->arch.sie_block) +\n\t\t\t\t mop->sida_offset), mop->size))\n\t\t\tr = -EFAULT;\n\n\t\tbreak;\n\tcase KVM_S390_MEMOP_SIDA_WRITE:\n\t\tif (copy_from_user((void *)(sida_origin(vcpu->arch.sie_block) +\n\t\t\t\t   mop->sida_offset), uaddr, mop->size))\n\t\t\tr = -EFAULT;\n\t\tbreak;\n\t}\n\treturn r;\n}", "target": 2, "idx": 11966}
{"commit_id": "5d6751eaff672ea77642e74e92e6c0ac7f9709ab", "project": "torvalds/linux", "func": "int ath6kl_wmi_delete_pstream_cmd(struct wmi *wmi, u8 if_idx, u8 traffic_class,\n\t\t\t\t  u8 tsid)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_delete_pstream_cmd *cmd;\n\tu16 active_tsids = 0;\n\tint ret;\n\n\tif (traffic_class >= WMM_NUM_AC) {\n\t\tath6kl_err(\"invalid traffic class: %d\\n\", traffic_class);\n\t\treturn -EINVAL;\n\t}\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_delete_pstream_cmd *) skb->data;\n\tcmd->traffic_class = traffic_class;\n\tcmd->tsid = tsid;\n\n\tspin_lock_bh(&wmi->lock);\n\tactive_tsids = wmi->stream_exist_for_ac[traffic_class];\n\tspin_unlock_bh(&wmi->lock);\n\n\tif (!(active_tsids & (1 << tsid))) {\n\t\tdev_kfree_skb(skb);\n\t\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t\t   \"TSID %d doesn't exist for traffic class: %d\\n\",\n\t\t\t   tsid, traffic_class);\n\t\treturn -ENODATA;\n\t}\n\n\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t   \"sending delete_pstream_cmd: traffic class: %d tsid=%d\\n\",\n\t\t   traffic_class, tsid);\n\n\tret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_DELETE_PSTREAM_CMDID,\n\t\t\t\t  SYNC_BEFORE_WMIFLAG);\n\n\tspin_lock_bh(&wmi->lock);\n\twmi->stream_exist_for_ac[traffic_class] &= ~(1 << tsid);\n\tactive_tsids = wmi->stream_exist_for_ac[traffic_class];\n\tspin_unlock_bh(&wmi->lock);\n\n\t/*\n\t * Indicate stream inactivity to driver layer only if all tsids\n\t * within this AC are deleted.\n\t */\n\tif (!active_tsids) {\n\t\tath6kl_indicate_tx_activity(wmi->parent_dev,\n\t\t\t\t\t    traffic_class, false);\n\t\twmi->fat_pipe_exist &= ~(1 << traffic_class);\n\t}\n\n\treturn ret;\n}", "target": 3, "idx": 11967}
{"commit_id": "47e589072c44350b0305c05066c224d1cbda992d", "project": "Haivision/srt", "func": "void CSndUList::update(const CUDT* u, EReschedule reschedule)\n{\n   CGuard listguard(m_ListLock);\n\n   CSNode* n = u->m_pSNode;\n\n   if (n->m_iHeapLoc >= 0)\n   {\n      if (!reschedule) // EReschedule to bool conversion, predicted.\n         return;\n\n      if (n->m_iHeapLoc == 0)\n      {\n         n->m_llTimeStamp_tk = 1;\n         m_pTimer->interrupt();\n         return;\n      }\n\n      remove_(u);\n      insert_norealloc(1, u);\n      return;\n   }\n\n   insert_(1, u);\n}", "target": 3, "idx": 11968}
{"commit_id": "b0a7241df0f889cc3158ba82774ff21fa1da87ec", "project": "ImageMagick", "func": "static Image *ReadPGXImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    buffer[MagickPathExtent],\n    endian[MagickPathExtent],\n    sans[MagickPathExtent],\n    sign[MagickPathExtent];\n\n  const unsigned char\n    *pixels;\n\n  Image\n    *image;\n\n  int\n    height,\n    precision,\n    width;\n\n  QuantumInfo\n    *quantum_info;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (ReadBlobString(image,buffer) == (char *) NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  count=(ssize_t) sscanf(buffer,\"PG%[ \\t]%2s%[ \\t+-]%d%[ \\t]%d%[ \\t]%d\",sans,\n    endian,sign,&precision,sans,&width,sans,&height);\n  image->depth=(size_t) precision;\n  if (LocaleCompare(endian,\"ML\") == 0)\n    image->endian=MSBEndian;\n  image->columns=(size_t) width;\n  image->rows=(size_t) height;\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Convert PGX image.\n  */\n  (void) SetImageColorspace(image,GRAYColorspace,exception);\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  length=GetQuantumExtent(image,quantum_info,GrayQuantum);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    pixels=(const unsigned char *) ReadBlobStream(image,length,\n      GetQuantumPixels(quantum_info),&count);\n    if (count != (ssize_t) length)\n      break;\n    status=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n      GrayQuantum,pixels,exception);\n    if (status == MagickFalse)\n      break;\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,image->rows) == MagickFalse)\n      break;\n  }\n  SetQuantumImageType(image,GrayQuantum);\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}", "target": 1, "idx": 11969}
{"commit_id": "3b5369cf2a1851a062510e21261e0904704aebba", "project": "contiki-ng", "func": "static void\nparse_publish_vhdr(struct mqtt_connection *conn,\n                   uint32_t *pos,\n                   const uint8_t *input_data_ptr,\n                   int input_data_len)\n{\n  uint16_t copy_bytes;\n\n  /* Read out topic length */\n  if(conn->in_packet.topic_len_received == 0) {\n    conn->in_packet.topic_pos = 0;\n    conn->in_packet.topic_len = (input_data_ptr[(*pos)++] << 8);\n    conn->in_packet.byte_counter++;\n    if(*pos >= input_data_len) {\n      return;\n    }\n    conn->in_packet.topic_len |= input_data_ptr[(*pos)++];\n    conn->in_packet.byte_counter++;\n    conn->in_packet.topic_len_received = 1;\n\n    DBG(\"MQTT - Read PUBLISH topic len %i\\n\", conn->in_packet.topic_len);\n    /* WARNING: Check here if TOPIC fits in payload area, otherwise error */\n  }\n\n  /* Read out topic */\n  if(conn->in_packet.topic_len_received == 1 &&\n     conn->in_packet.topic_received == 0) {\n    copy_bytes = MIN(conn->in_packet.topic_len - conn->in_packet.topic_pos,\n                     input_data_len - *pos);\n    DBG(\"MQTT - topic_pos: %i copy_bytes: %i\", conn->in_packet.topic_pos,\n        copy_bytes);\n    memcpy(&conn->in_publish_msg.topic[conn->in_packet.topic_pos],\n           &input_data_ptr[*pos],\n           copy_bytes);\n    (*pos) += copy_bytes;\n    conn->in_packet.byte_counter += copy_bytes;\n    conn->in_packet.topic_pos += copy_bytes;\n\n    if(conn->in_packet.topic_len - conn->in_packet.topic_pos == 0) {\n      DBG(\"MQTT - Got topic '%s'\", conn->in_publish_msg.topic);\n      conn->in_packet.topic_received = 1;\n      conn->in_publish_msg.topic[conn->in_packet.topic_pos] = '\\0';\n      conn->in_publish_msg.payload_length =\n        conn->in_packet.remaining_length - conn->in_packet.topic_len - 2;\n      conn->in_publish_msg.payload_left = conn->in_publish_msg.payload_length;\n    }\n\n    /* Set this once per incomming publish message */\n    conn->in_publish_msg.first_chunk = 1;\n  }\n}", "target": 3, "idx": 11970}
{"commit_id": "bbf26183b7a6236ba602f4d6a2f7cade35bba043", "project": "torvalds/linux", "func": "void uwbd_stop(struct uwb_rc *rc)\n{\n\tif (rc->uwbd.task)\n\t\tkthread_stop(rc->uwbd.task);\n\tuwbd_flush(rc);\n}", "target": 2, "idx": 11971}
{"commit_id": "838c0dc7641e1c991c0f3027bf94bee4606012f8", "project": "bluez", "func": "static void desc_read_cb(struct gatt_db_attribute *attrib,\n\t\t\t\t\tunsigned int id, uint16_t offset,\n\t\t\t\t\tuint8_t opcode, struct bt_att *att,\n\t\t\t\t\tvoid *user_data)\n{\n\tstruct external_desc *desc = user_data;\n\tstruct btd_device *device;\n\n\tif (desc->attrib != attrib) {\n\t\terror(\"Read callback called with incorrect attribute\");\n\t\tgoto fail;\n\t}\n\n\tdevice = att_get_device(att);\n\tif (!device) {\n\t\terror(\"Unable to find device object\");\n\t\tgoto fail;\n\t}\n\n\tif (send_read(att, attrib, desc->proxy, desc->pending_reads, id,\n\t\t\t\t\toffset))\n\t\treturn;\n\nfail:\n\tgatt_db_attribute_read_result(attrib, id, BT_ATT_ERROR_UNLIKELY,\n\t\t\t\t\t\t\t\tNULL, 0);\n}", "target": 3, "idx": 11972}
{"commit_id": "f015746d", "project": "OpenSC", "func": "static int idprime_get_token_name(sc_card_t* card, char** tname)\n{\n\tidprime_private_data_t * priv = card->drv_data;\n\tsc_path_t tinfo_path = {\"\\x00\\x00\", 2, 0, 0, SC_PATH_TYPE_PATH, {\"\", 0}};\n\tsc_file_t *file = NULL;\n\tu8 buf[2];\n\tchar *name;\n\tint r;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tif (tname == NULL) {\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\n\tif (!priv->tinfo_present) {\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);\n\t}\n\n\tmemcpy(tinfo_path.value, priv->tinfo_df, 2);\n\tr = iso_ops->select_file(card, &tinfo_path, &file);\n\tif (r != SC_SUCCESS || file->size == 0) {\n\t\tsc_file_free(file);\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);\n\t}\n\n\t/* First two bytes lists 0x01, the second indicates length */\n\tr = iso_ops->read_binary(card, 0, buf, 2, 0);\n\tif (r < 2 || buf[1] > file->size) { /* make sure we do not overrun */\n\t\tsc_file_free(file);\n\t\tLOG_FUNC_RETURN(card->ctx, r);\n\t}\n\tsc_file_free(file);\n\n\tname = malloc(buf[1]);\n\tif (name == NULL) {\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\n\tr = iso_ops->read_binary(card, 2, (unsigned char *)name, buf[1], 0);\n\tif (r < 1) {\n\t\tfree(name);\n\t\tLOG_FUNC_RETURN(card->ctx, r);\n\t}\n\n\tif (name[r-1] != '\\0') {\n\t\tname[r-1] = '\\0';\n\t}\n\t*tname = name;\n\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}", "target": 1, "idx": 11973}
{"commit_id": "0523c79d6e63858c990821a990edcb82cf8af284", "project": "radareorg/radare2", "func": "static char *get_die_name(const RBinDwarfDie *die) {\n\tchar *name = NULL;\n\tst32 name_attr_idx = find_attr_idx (die, DW_AT_name);\n\n\tif (name_attr_idx != -1 && die->attr_values[name_attr_idx].string.content) {\n\t\tname = strdup (die->attr_values[name_attr_idx].string.content);\n\t} else {\n\t\tname = create_type_name_from_offset (die->offset);\n\t}\n\treturn name;\n}", "target": 1, "idx": 11974}
{"commit_id": "5af08640795b2b9a940c9266c0260455377ae262", "project": "torvalds/linux", "func": "static int fbcon_get_font(struct vc_data *vc, struct console_font *font)\n{\n\tu8 *fontdata = vc->vc_font.data;\n\tu8 *data = font->data;\n\tint i, j;\n\n\tfont->width = vc->vc_font.width;\n\tfont->height = vc->vc_font.height;\n\tfont->charcount = vc->vc_hi_font_mask ? 512 : 256;\n\tif (!font->data)\n\t\treturn 0;\n\n\tif (font->width <= 8) {\n\t\tj = vc->vc_font.height;\n\t\tif (font->charcount * j > FNTSIZE(fontdata))\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < font->charcount; i++) {\n\t\t\tmemcpy(data, fontdata, j);\n\t\t\tmemset(data + j, 0, 32 - j);\n\t\t\tdata += 32;\n\t\t\tfontdata += j;\n\t\t}\n\t} else if (font->width <= 16) {\n\t\tj = vc->vc_font.height * 2;\n\t\tif (font->charcount * j > FNTSIZE(fontdata))\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < font->charcount; i++) {\n\t\t\tmemcpy(data, fontdata, j);\n\t\t\tmemset(data + j, 0, 64 - j);\n\t\t\tdata += 64;\n\t\t\tfontdata += j;\n\t\t}\n\t} else if (font->width <= 24) {\n\t\tif (font->charcount * (vc->vc_font.height * sizeof(u32)) > FNTSIZE(fontdata))\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < font->charcount; i++) {\n\t\t\tfor (j = 0; j < vc->vc_font.height; j++) {\n\t\t\t\t*data++ = fontdata[0];\n\t\t\t\t*data++ = fontdata[1];\n\t\t\t\t*data++ = fontdata[2];\n\t\t\t\tfontdata += sizeof(u32);\n\t\t\t}\n\t\t\tmemset(data, 0, 3 * (32 - j));\n\t\t\tdata += 3 * (32 - j);\n\t\t}\n\t} else {\n\t\tj = vc->vc_font.height * 4;\n\t\tif (font->charcount * j > FNTSIZE(fontdata))\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < font->charcount; i++) {\n\t\t\tmemcpy(data, fontdata, j);\n\t\t\tmemset(data + j, 0, 128 - j);\n\t\t\tdata += 128;\n\t\t\tfontdata += j;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1, "idx": 11975}
{"commit_id": "0b999c886e241c52bd1f7ef0066700e4b618ebb3", "project": "FRRouting/frr", "func": "int bgp_nlri_parse_flowspec(struct peer *peer, struct attr *attr,\n\t\t\t    struct bgp_nlri *packet, int withdraw)\n{\n\tuint8_t *pnt;\n\tuint8_t *lim;\n\tafi_t afi;\n\tsafi_t safi;\n\tint psize = 0;\n\tstruct prefix p;\n\tvoid *temp;\n\n\t/* Start processing the NLRI - there may be multiple in the MP_REACH */\n\tpnt = packet->nlri;\n\tlim = pnt + packet->length;\n\tafi = packet->afi;\n\tsafi = packet->safi;\n\n\tif (packet->length >= FLOWSPEC_NLRI_SIZELIMIT_EXTENDED) {\n\t\tflog_err(EC_BGP_FLOWSPEC_PACKET,\n\t\t\t \"BGP flowspec nlri length maximum reached (%u)\",\n\t\t\t packet->length);\n\t\treturn BGP_NLRI_PARSE_ERROR_FLOWSPEC_NLRI_SIZELIMIT;\n\t}\n\n\tfor (; pnt < lim; pnt += psize) {\n\t\t/* Clear prefix structure. */\n\t\tmemset(&p, 0, sizeof(p));\n\n\t\t/* All FlowSpec NLRI begin with length. */\n\t\tif (pnt + 1 > lim)\n\t\t\treturn BGP_NLRI_PARSE_ERROR_PACKET_OVERFLOW;\n\n\t\tpsize = *pnt++;\n\t\tif (psize >= FLOWSPEC_NLRI_SIZELIMIT) {\n\t\t\tpsize &= 0x0f;\n\t\t\tpsize = psize << 8;\n\t\t\tpsize |= *pnt++;\n\t\t}\n\t\t/* When packet overflow occur return immediately. */\n\t\tif (pnt + psize > lim) {\n\t\t\tflog_err(\n\t\t\t\tEC_BGP_FLOWSPEC_PACKET,\n\t\t\t\t\"Flowspec NLRI length inconsistent ( size %u seen)\",\n\t\t\t\tpsize);\n\t\t\treturn BGP_NLRI_PARSE_ERROR_PACKET_OVERFLOW;\n\t\t}\n\n\t\tif (psize == 0) {\n\t\t\tflog_err(EC_BGP_FLOWSPEC_PACKET,\n\t\t\t\t \"Flowspec NLRI length 0 which makes no sense\");\n\t\t\treturn BGP_NLRI_PARSE_ERROR_PACKET_OVERFLOW;\n\t\t}\n\n\t\tif (bgp_fs_nlri_validate(pnt, psize, afi) < 0) {\n\t\t\tflog_err(\n\t\t\t\tEC_BGP_FLOWSPEC_PACKET,\n\t\t\t\t\"Bad flowspec format or NLRI options not supported\");\n\t\t\treturn BGP_NLRI_PARSE_ERROR_FLOWSPEC_BAD_FORMAT;\n\t\t}\n\t\tp.family = AF_FLOWSPEC;\n\t\tp.prefixlen = 0;\n\t\t/* Flowspec encoding is in bytes */\n\t\tp.u.prefix_flowspec.prefixlen = psize;\n\t\tp.u.prefix_flowspec.family = afi2family(afi);\n\t\ttemp = XCALLOC(MTYPE_TMP, psize);\n\t\tmemcpy(temp, pnt, psize);\n\t\tp.u.prefix_flowspec.ptr = (uintptr_t) temp;\n\n\t\tif (BGP_DEBUG(flowspec, FLOWSPEC)) {\n\t\t\tchar return_string[BGP_FLOWSPEC_NLRI_STRING_MAX];\n\t\t\tchar local_string[BGP_FLOWSPEC_NLRI_STRING_MAX*2+16];\n\t\t\tchar ec_string[BGP_FLOWSPEC_NLRI_STRING_MAX];\n\t\t\tchar *s = NULL;\n\n\t\t\tbgp_fs_nlri_get_string((unsigned char *)\n\t\t\t\t\t       p.u.prefix_flowspec.ptr,\n\t\t\t\t\t       p.u.prefix_flowspec.prefixlen,\n\t\t\t\t\t       return_string,\n\t\t\t\t\t       NLRI_STRING_FORMAT_MIN, NULL,\n\t\t\t\t\t       afi);\n\t\t\tsnprintf(ec_string, sizeof(ec_string),\n\t\t\t\t \"EC{none}\");\n\t\t\tif (attr && bgp_attr_get_ecommunity(attr)) {\n\t\t\t\ts = ecommunity_ecom2str(\n\t\t\t\t\tbgp_attr_get_ecommunity(attr),\n\t\t\t\t\tECOMMUNITY_FORMAT_ROUTE_MAP, 0);\n\t\t\t\tsnprintf(ec_string, sizeof(ec_string),\n\t\t\t\t\t \"EC{%s}\",\n\t\t\t\t\ts == NULL ? \"none\" : s);\n\n\t\t\t\tif (s)\n\t\t\t\t\tecommunity_strfree(&s);\n\t\t\t}\n\t\t\tsnprintf(local_string, sizeof(local_string),\n\t\t\t\t \"FS Rx %s %s %s %s\", withdraw ?\n\t\t\t\t \"Withdraw\":\"Update\",\n\t\t\t\t afi2str(afi), return_string,\n\t\t\t\t attr != NULL ? ec_string : \"\");\n\t\t\tzlog_info(\"%s\", local_string);\n\t\t}\n\t\t/* Process the route. */\n\t\tif (!withdraw)\n\t\t\tbgp_update(peer, &p, 0, attr, afi, safi,\n\t\t\t\t   ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL, NULL,\n\t\t\t\t   NULL, 0, 0, NULL);\n\t\telse\n\t\t\tbgp_withdraw(peer, &p, 0, afi, safi, ZEBRA_ROUTE_BGP,\n\t\t\t\t     BGP_ROUTE_NORMAL, NULL, NULL, 0, NULL);\n\t}\n\treturn BGP_NLRI_PARSE_OK;\n}", "target": 3, "idx": 11976}
{"commit_id": "16d51a590a8ce3befb1308e0e7ab77f3b661af33", "project": "torvalds/linux", "func": "void __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\n\tif (!profile_handoff_task(tsk))\n\t\tfree_task(tsk);\n}", "target": 1, "idx": 11977}
{"commit_id": "53625a846a7b4273982157d7a1db5947371757ef", "project": "android", "func": "static int __check_page_state_visitor(u64 addr, u64 end, u32 level,\n\t\t\t\t      kvm_pte_t *ptep,\n\t\t\t\t      enum kvm_pgtable_walk_flags flag,\n\t\t\t\t      void * const arg)\n{\n\tstruct check_walk_data *d = arg;\n\tkvm_pte_t pte = *ptep;\n\n\tif (kvm_pte_valid(pte) && !addr_is_allowed_memory(kvm_pte_to_phys(pte)))\n\t\treturn -EINVAL;\n\n\treturn d->get_page_state(pte, addr) == d->desired ? 0 : -EPERM;\n}", "target": 1, "idx": 11978}
{"commit_id": "3b69886f7dcc3cfb3d166309018e6cfec9ce2c95", "project": "haproxy", "func": "static inline struct htx_blk *htx_add_trailer(struct htx *htx, const struct ist name,\n\t\t\t\t\t      const struct ist value)\n{\n\tstruct htx_blk *blk;\n\n\tif (name.len > 255 || value.len > 1048575)\n\t\treturn NULL;\n\n\tblk = htx_add_blk(htx, HTX_BLK_TLR, name.len + value.len);\n\tif (!blk)\n\t\treturn NULL;\n\n\tblk->info += (value.len << 8) + name.len;\n\tist2bin_lc(htx_get_blk_ptr(htx, blk), name);\n\tmemcpy(htx_get_blk_ptr(htx, blk)  + name.len, value.ptr, value.len);\n\treturn blk;\n}", "target": 2, "idx": 11979}
{"commit_id": "1e5479084bc9852854feb1ba9bf68b52cd127e02", "project": "ccxvii/mujs", "func": "static void ctrycatchfinally(JF, js_Ast *trystm, js_Ast *catchvar, js_Ast *catchstm, js_Ast *finallystm)\n{\n\tint L1, L2, L3;\n\tL1 = emitjump(J, F, OP_TRY);\n\t{\n\t\t/* if we get here, we have caught an exception in the try block */\n\t\tL2 = emitjump(J, F, OP_TRY);\n\t\t{\n\t\t\t/* if we get here, we have caught an exception in the catch block */\n\t\t\tcstm(J, F, finallystm); /* inline finally block */\n\t\t\temit(J, F, OP_THROW); /* rethrow exception */\n\t\t}\n\t\tlabel(J, F, L2);\n\t\tif (F->strict) {\n\t\t\tcheckfutureword(J, F, catchvar);\n\t\t\tif (!strcmp(catchvar->string, \"arguments\"))\n\t\t\t\tjsC_error(J, catchvar, \"redefining 'arguments' is not allowed in strict mode\");\n\t\t\tif (!strcmp(catchvar->string, \"eval\"))\n\t\t\t\tjsC_error(J, catchvar, \"redefining 'eval' is not allowed in strict mode\");\n\t\t}\n\t\temitline(J, F, catchvar);\n\t\temitstring(J, F, OP_CATCH, catchvar->string);\n\t\tcstm(J, F, catchstm);\n\t\temit(J, F, OP_ENDCATCH);\n\t\temit(J, F, OP_ENDTRY);\n\t\tL3 = emitjump(J, F, OP_JUMP); /* skip past the try block to the finally block */\n\t}\n\tlabel(J, F, L1);\n\tcstm(J, F, trystm);\n\temit(J, F, OP_ENDTRY);\n\tlabel(J, F, L3);\n\tcstm(J, F, finallystm);\n}", "target": 2, "idx": 11980}
{"commit_id": "f232326f6966cf2a1d1db7bc917a4ce5f9f55f76", "project": "torvalds/linux", "func": "static int adjust_ptr_min_max_vals(struct bpf_verifier_env *env,\n\t\t\t\t   struct bpf_insn *insn,\n\t\t\t\t   const struct bpf_reg_state *ptr_reg,\n\t\t\t\t   const struct bpf_reg_state *off_reg)\n{\n\tstruct bpf_verifier_state *vstate = env->cur_state;\n\tstruct bpf_func_state *state = vstate->frame[vstate->curframe];\n\tstruct bpf_reg_state *regs = state->regs, *dst_reg;\n\tbool known = tnum_is_const(off_reg->var_off);\n\ts64 smin_val = off_reg->smin_value, smax_val = off_reg->smax_value,\n\t    smin_ptr = ptr_reg->smin_value, smax_ptr = ptr_reg->smax_value;\n\tu64 umin_val = off_reg->umin_value, umax_val = off_reg->umax_value,\n\t    umin_ptr = ptr_reg->umin_value, umax_ptr = ptr_reg->umax_value;\n\tu32 dst = insn->dst_reg, src = insn->src_reg;\n\tu8 opcode = BPF_OP(insn->code);\n\tint ret;\n\n\tdst_reg = &regs[dst];\n\n\tif ((known && (smin_val != smax_val || umin_val != umax_val)) ||\n\t    smin_val > smax_val || umin_val > umax_val) {\n\t\t/* Taint dst register if offset had invalid bounds derived from\n\t\t * e.g. dead branches.\n\t\t */\n\t\t__mark_reg_unknown(env, dst_reg);\n\t\treturn 0;\n\t}\n\n\tif (BPF_CLASS(insn->code) != BPF_ALU64) {\n\t\t/* 32-bit ALU ops on pointers produce (meaningless) scalars */\n\t\tif (opcode == BPF_SUB && env->allow_ptr_leaks) {\n\t\t\t__mark_reg_unknown(env, dst_reg);\n\t\t\treturn 0;\n\t\t}\n\n\t\tverbose(env,\n\t\t\t\"R%d 32-bit pointer arithmetic prohibited\\n\",\n\t\t\tdst);\n\t\treturn -EACCES;\n\t}\n\n\tswitch (ptr_reg->type) {\n\tcase PTR_TO_MAP_VALUE_OR_NULL:\n\t\tverbose(env, \"R%d pointer arithmetic on %s prohibited, null-check it first\\n\",\n\t\t\tdst, reg_type_str[ptr_reg->type]);\n\t\treturn -EACCES;\n\tcase CONST_PTR_TO_MAP:\n\t\t/* smin_val represents the known value */\n\t\tif (known && smin_val == 0 && opcode == BPF_ADD)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase PTR_TO_PACKET_END:\n\tcase PTR_TO_SOCKET:\n\tcase PTR_TO_SOCKET_OR_NULL:\n\tcase PTR_TO_SOCK_COMMON:\n\tcase PTR_TO_SOCK_COMMON_OR_NULL:\n\tcase PTR_TO_TCP_SOCK:\n\tcase PTR_TO_TCP_SOCK_OR_NULL:\n\tcase PTR_TO_XDP_SOCK:\n\t\tverbose(env, \"R%d pointer arithmetic on %s prohibited\\n\",\n\t\t\tdst, reg_type_str[ptr_reg->type]);\n\t\treturn -EACCES;\n\tcase PTR_TO_MAP_VALUE:\n\t\tif (!env->allow_ptr_leaks && !known && (smin_val < 0) != (smax_val < 0)) {\n\t\t\tverbose(env, \"R%d has unknown scalar with mixed signed bounds, pointer arithmetic with it prohibited for !root\\n\",\n\t\t\t\toff_reg == dst_reg ? dst : src);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* In case of 'scalar += pointer', dst_reg inherits pointer type and id.\n\t * The id may be overwritten later if we create a new variable offset.\n\t */\n\tdst_reg->type = ptr_reg->type;\n\tdst_reg->id = ptr_reg->id;\n\n\tif (!check_reg_sane_offset(env, off_reg, ptr_reg->type) ||\n\t    !check_reg_sane_offset(env, ptr_reg, ptr_reg->type))\n\t\treturn -EINVAL;\n\n\t/* pointer types do not carry 32-bit bounds at the moment. */\n\t__mark_reg32_unbounded(dst_reg);\n\n\tswitch (opcode) {\n\tcase BPF_ADD:\n\t\tret = sanitize_ptr_alu(env, insn, ptr_reg, dst_reg, smin_val < 0);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"R%d tried to add from different maps, paths, or prohibited types\\n\", dst);\n\t\t\treturn ret;\n\t\t}\n\t\t/* We can take a fixed offset as long as it doesn't overflow\n\t\t * the s32 'off' field\n\t\t */\n\t\tif (known && (ptr_reg->off + smin_val ==\n\t\t\t      (s64)(s32)(ptr_reg->off + smin_val))) {\n\t\t\t/* pointer += K.  Accumulate it into fixed offset */\n\t\t\tdst_reg->smin_value = smin_ptr;\n\t\t\tdst_reg->smax_value = smax_ptr;\n\t\t\tdst_reg->umin_value = umin_ptr;\n\t\t\tdst_reg->umax_value = umax_ptr;\n\t\t\tdst_reg->var_off = ptr_reg->var_off;\n\t\t\tdst_reg->off = ptr_reg->off + smin_val;\n\t\t\tdst_reg->raw = ptr_reg->raw;\n\t\t\tbreak;\n\t\t}\n\t\t/* A new variable offset is created.  Note that off_reg->off\n\t\t * == 0, since it's a scalar.\n\t\t * dst_reg gets the pointer type and since some positive\n\t\t * integer value was added to the pointer, give it a new 'id'\n\t\t * if it's a PTR_TO_PACKET.\n\t\t * this creates a new 'base' pointer, off_reg (variable) gets\n\t\t * added into the variable offset, and we copy the fixed offset\n\t\t * from ptr_reg.\n\t\t */\n\t\tif (signed_add_overflows(smin_ptr, smin_val) ||\n\t\t    signed_add_overflows(smax_ptr, smax_val)) {\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value = smin_ptr + smin_val;\n\t\t\tdst_reg->smax_value = smax_ptr + smax_val;\n\t\t}\n\t\tif (umin_ptr + umin_val < umin_ptr ||\n\t\t    umax_ptr + umax_val < umax_ptr) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value = umin_ptr + umin_val;\n\t\t\tdst_reg->umax_value = umax_ptr + umax_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_add(ptr_reg->var_off, off_reg->var_off);\n\t\tdst_reg->off = ptr_reg->off;\n\t\tdst_reg->raw = ptr_reg->raw;\n\t\tif (reg_is_pkt_pointer(ptr_reg)) {\n\t\t\tdst_reg->id = ++env->id_gen;\n\t\t\t/* something was added to pkt_ptr, set range to zero */\n\t\t\tmemset(&dst_reg->raw, 0, sizeof(dst_reg->raw));\n\t\t}\n\t\tbreak;\n\tcase BPF_SUB:\n\t\tret = sanitize_ptr_alu(env, insn, ptr_reg, dst_reg, smin_val < 0);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"R%d tried to sub from different maps, paths, or prohibited types\\n\", dst);\n\t\t\treturn ret;\n\t\t}\n\t\tif (dst_reg == off_reg) {\n\t\t\t/* scalar -= pointer.  Creates an unknown scalar */\n\t\t\tverbose(env, \"R%d tried to subtract pointer from scalar\\n\",\n\t\t\t\tdst);\n\t\t\treturn -EACCES;\n\t\t}\n\t\t/* We don't allow subtraction from FP, because (according to\n\t\t * test_verifier.c test \"invalid fp arithmetic\", JITs might not\n\t\t * be able to deal with it.\n\t\t */\n\t\tif (ptr_reg->type == PTR_TO_STACK) {\n\t\t\tverbose(env, \"R%d subtraction from stack pointer prohibited\\n\",\n\t\t\t\tdst);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (known && (ptr_reg->off - smin_val ==\n\t\t\t      (s64)(s32)(ptr_reg->off - smin_val))) {\n\t\t\t/* pointer -= K.  Subtract it from fixed offset */\n\t\t\tdst_reg->smin_value = smin_ptr;\n\t\t\tdst_reg->smax_value = smax_ptr;\n\t\t\tdst_reg->umin_value = umin_ptr;\n\t\t\tdst_reg->umax_value = umax_ptr;\n\t\t\tdst_reg->var_off = ptr_reg->var_off;\n\t\t\tdst_reg->id = ptr_reg->id;\n\t\t\tdst_reg->off = ptr_reg->off - smin_val;\n\t\t\tdst_reg->raw = ptr_reg->raw;\n\t\t\tbreak;\n\t\t}\n\t\t/* A new variable offset is created.  If the subtrahend is known\n\t\t * nonnegative, then any reg->range we had before is still good.\n\t\t */\n\t\tif (signed_sub_overflows(smin_ptr, smax_val) ||\n\t\t    signed_sub_overflows(smax_ptr, smin_val)) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value = smin_ptr - smax_val;\n\t\t\tdst_reg->smax_value = smax_ptr - smin_val;\n\t\t}\n\t\tif (umin_ptr < umax_val) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\t/* Cannot overflow (as long as bounds are consistent) */\n\t\t\tdst_reg->umin_value = umin_ptr - umax_val;\n\t\t\tdst_reg->umax_value = umax_ptr - umin_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_sub(ptr_reg->var_off, off_reg->var_off);\n\t\tdst_reg->off = ptr_reg->off;\n\t\tdst_reg->raw = ptr_reg->raw;\n\t\tif (reg_is_pkt_pointer(ptr_reg)) {\n\t\t\tdst_reg->id = ++env->id_gen;\n\t\t\t/* something was added to pkt_ptr, set range to zero */\n\t\t\tif (smin_val < 0)\n\t\t\t\tmemset(&dst_reg->raw, 0, sizeof(dst_reg->raw));\n\t\t}\n\t\tbreak;\n\tcase BPF_AND:\n\tcase BPF_OR:\n\tcase BPF_XOR:\n\t\t/* bitwise ops on pointers are troublesome, prohibit. */\n\t\tverbose(env, \"R%d bitwise operator %s on pointer prohibited\\n\",\n\t\t\tdst, bpf_alu_string[opcode >> 4]);\n\t\treturn -EACCES;\n\tdefault:\n\t\t/* other operators (e.g. MUL,LSH) produce non-pointer results */\n\t\tverbose(env, \"R%d pointer arithmetic with %s operator prohibited\\n\",\n\t\t\tdst, bpf_alu_string[opcode >> 4]);\n\t\treturn -EACCES;\n\t}\n\n\tif (!check_reg_sane_offset(env, dst_reg, ptr_reg->type))\n\t\treturn -EINVAL;\n\n\t__update_reg_bounds(dst_reg);\n\t__reg_deduce_bounds(dst_reg);\n\t__reg_bound_offset(dst_reg);\n\n\t/* For unprivileged we require that resulting offset must be in bounds\n\t * in order to be able to sanitize access later on.\n\t */\n\tif (!env->bypass_spec_v1) {\n\t\tif (dst_reg->type == PTR_TO_MAP_VALUE &&\n\t\t    check_map_access(env, dst, dst_reg->off, 1, false)) {\n\t\t\tverbose(env, \"R%d pointer arithmetic of map value goes out of range, \"\n\t\t\t\t\"prohibited for !root\\n\", dst);\n\t\t\treturn -EACCES;\n\t\t} else if (dst_reg->type == PTR_TO_STACK &&\n\t\t\t   check_stack_access_for_ptr_arithmetic(\n\t\t\t\t   env, dst, dst_reg, dst_reg->off +\n\t\t\t\t   dst_reg->var_off.value)) {\n\t\t\treturn -EACCES;\n\t\t}\n\t}\n\n\treturn 0;\n}", "target": 1, "idx": 11981}
{"commit_id": "de9f869616dd95e95c00bdd6b0fcd3421e8a4323", "project": "torvalds/linux", "func": "static unsigned long get_seg_limit(struct pt_regs *regs, int seg_reg_idx)\n{\n\tstruct desc_struct desc;\n\tunsigned long limit;\n\tshort sel;\n\n\tsel = get_segment_selector(regs, seg_reg_idx);\n\tif (sel < 0)\n\t\treturn 0;\n\n\tif (user_64bit_mode(regs) || v8086_mode(regs))\n\t\treturn -1L;\n\n\tif (!sel)\n\t\treturn 0;\n\n\tif (!get_desc(&desc, sel))\n\t\treturn 0;\n\n\t/*\n\t * If the granularity bit is set, the limit is given in multiples\n\t * of 4096. This also means that the 12 least significant bits are\n\t * not tested when checking the segment limits. In practice,\n\t * this means that the segment ends in (limit << 12) + 0xfff.\n\t */\n\tlimit = get_desc_limit(&desc);\n\tif (desc.g)\n\t\tlimit = (limit << 12) + 0xfff;\n\n\treturn limit;\n}", "target": 2, "idx": 11982}
{"commit_id": "2cb40c4d5feeaa09325522bd7d97910f1b59e379", "project": "polkit", "func": "static void\npolkit_unix_user_set_property (GObject      *object,\n                               guint         prop_id,\n                               const GValue *value,\n                               GParamSpec   *pspec)\n{\n  PolkitUnixUser *unix_user = POLKIT_UNIX_USER (object);\n  gint val;\n\n  switch (prop_id)\n    {\n    case PROP_UID:\n      val = g_value_get_int (value);\n      g_return_if_fail (val != -1);\n      unix_user->uid = val;\n      break;\n\n    default:\n      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);\n      break;\n    }\n}", "target": 2, "idx": 11983}
{"commit_id": "55667441c84fa5e0911a0aac44fb059c15ba6da2", "project": "torvalds/linux", "func": "static int fq_init(struct fq *fq, int flows_cnt)\n{\n\tint i;\n\n\tmemset(fq, 0, sizeof(fq[0]));\n\tINIT_LIST_HEAD(&fq->backlogs);\n\tspin_lock_init(&fq->lock);\n\tfq->flows_cnt = max_t(u32, flows_cnt, 1);\n\tget_random_bytes(&fq->perturbation, sizeof(fq->perturbation));\n\tfq->quantum = 300;\n\tfq->limit = 8192;\n\tfq->memory_limit = 16 << 20; /* 16 MBytes */\n\n\tfq->flows = kcalloc(fq->flows_cnt, sizeof(fq->flows[0]), GFP_KERNEL);\n\tif (!fq->flows)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < fq->flows_cnt; i++)\n\t\tfq_flow_init(&fq->flows[i]);\n\n\treturn 0;\n}", "target": 1, "idx": 11984}
{"commit_id": "40caff2d1fb08262c84aaaa8ac584baa8866dd7c", "project": "wireshark", "func": "void\nproto_register_AllJoyn(void)\n{\n    expert_module_t* expert_alljoyn;\n\n    /* A header field is something you can search/filter on.\n     *\n     * We create a structure to register our fields. It consists of an\n     * array of hf_register_info structures, each of which are of the format\n     * {&(field id), {name, abbrev, type, display, strings, bitmask, blurb, HFILL}}.\n     * The array below defines what elements we will be displaying. These\n     * declarations are simply a definition Wireshark uses to determine the data\n     * type, when we later dissect the packet.\n     */\n    static hf_register_info hf[] = {\n        /******************\n         * Wireshark header fields for the name service protocol.\n         ******************/\n        {&hf_alljoyn_ns_header,\n         {\"Header\", \"alljoyn.header\",\n          FT_NONE, BASE_NONE, NULL, 0x0,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_ns_sender_version,\n         {\"Sender Version\", \"alljoyn.header.sendversion\",\n          FT_UINT8, BASE_DEC, NULL, 0xF0,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_ns_message_version,\n         {\"Message Version\", \"alljoyn.header.messageversion\",\n          FT_UINT8, BASE_DEC, NULL, 0x0F,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_ns_questions,\n         {\"Questions\", \"alljoyn.header.questions\",\n          FT_UINT8, BASE_DEC, NULL, 0x0,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_ns_answers,\n         {\"Answers\", \"alljoyn.header.answers\",\n          FT_UINT8, BASE_DEC, NULL, 0x0,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_ns_timer,\n         {\"Timer\", \"alljoyn.header.timer\",\n          FT_UINT8, BASE_DEC, NULL, 0x0,\n          NULL, HFILL}\n        },\n\n        {&hf_alljoyn_ns_whohas,\n         {\"Who-Has Message\", \"alljoyn.whohas\",\n          FT_NONE, BASE_NONE, NULL, 0x0,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_ns_whohas_t_flag,\n         {\"TCP\", \"alljoyn.whohas.T\",\n          FT_BOOLEAN, 8, NULL, WHOHAS_T,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_ns_whohas_u_flag,\n         {\"UDP\", \"alljoyn.whohas.U\",\n          FT_BOOLEAN, 8, NULL, WHOHAS_U,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_ns_whohas_s_flag,\n         {\"IPv6\", \"alljoyn.whohas.S\",\n          FT_BOOLEAN, 8, NULL, WHOHAS_S,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_ns_whohas_f_flag,\n         {\"IPv4\", \"alljoyn.whohas.F\",\n          FT_BOOLEAN, 8, NULL, WHOHAS_F,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_ns_whohas_count,\n         {\"Count\", \"alljoyn.whohas.count\",\n          FT_UINT8, BASE_DEC, NULL, 0x0,\n          NULL, HFILL}\n        },\n\n        {&hf_alljoyn_answer,\n         {\"Is-At Message\", \"alljoyn.isat\",\n          FT_NONE, BASE_NONE, NULL, 0x0,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_isat_entry,\n         {\"Advertisement Entry\", \"alljoyn.isat_entry\",\n          FT_NONE, BASE_NONE, NULL, 0x0,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_isat_guid_string,\n         {\"GUID String\", \"alljoyn.isat_guid_string\",\n          FT_NONE, BASE_NONE, NULL, 0x0,\n          NULL, HFILL}\n        },\n\n        /* Common to V0 and V1 IS-AT messages. */\n        {&hf_alljoyn_ns_isat_g_flag,\n         {\"GUID\", \"alljoyn.isat.G\",\n          FT_BOOLEAN, 8, NULL, ISAT_G,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_ns_isat_c_flag,\n         {\"Complete\", \"alljoyn.isat.C\",\n          FT_BOOLEAN, 8, NULL, ISAT_C,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_ns_isat_count,\n         {\"Count\", \"alljoyn.isat.count\",\n          FT_UINT8, BASE_DEC, NULL, 0x0,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_ns_isat_ipv6,\n         {\"IPv6 Address\", \"alljoyn.isat.ipv6\",\n          FT_IPv6, BASE_NONE, NULL, 0x0,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_ns_isat_ipv4,\n         {\"IPv4 Address\", \"alljoyn.isat.ipv4\",\n          FT_IPv4, BASE_NONE, NULL, 0x0,\n          NULL, HFILL}\n        },\n\n        /* Version 0 IS-AT messages. */\n        {&hf_alljoyn_ns_isat_t_flag,\n         {\"TCP\", \"alljoyn.isat.T\",\n          FT_BOOLEAN, 8, NULL, ISAT_T,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_ns_isat_u_flag,\n         {\"UDP\", \"alljoyn.isat.U\",\n          FT_BOOLEAN, 8, NULL, ISAT_U,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_ns_isat_s_flag,\n         {\"IPv6\", \"alljoyn.isat.S\",\n          FT_BOOLEAN, 8, NULL, ISAT_S,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_ns_isat_f_flag,\n         {\"IPv4\", \"alljoyn.isat.F\",\n          FT_BOOLEAN, 8, NULL, ISAT_F,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_ns_isat_port,\n         {\"Port\", \"alljoyn.isat.port\",\n          FT_UINT16, BASE_DEC, NULL, 0x0,\n          NULL, HFILL}\n        },\n\n        /* Version 1 IS-AT messages. */\n        {&hf_alljoyn_ns_isat_u6_flag,\n         {\"IPv6 UDP\", \"alljoyn.isat.U6\",\n          FT_BOOLEAN, 8, NULL, ISAT_U6,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_ns_isat_r6_flag,\n         {\"IPv6 TCP\", \"alljoyn.isat.R6\",\n          FT_BOOLEAN, 8, NULL, ISAT_R6,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_ns_isat_u4_flag,\n         {\"IPv4 UDP\", \"alljoyn.isat.U4\",\n          FT_BOOLEAN, 8, NULL, ISAT_U4,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_ns_isat_r4_flag,\n         {\"IPv4 TCP\", \"alljoyn.isat.R4\",\n          FT_BOOLEAN, 8, NULL, ISAT_R4,\n          NULL, HFILL}\n        },\n\n        {&hf_alljoyn_ns_isat_transport_mask,\n         {\"Transport Mask\", \"alljoyn.isat.TransportMask\",\n          FT_UINT16, BASE_HEX, NULL, 0x0,\n          NULL, HFILL}\n        },\n\n        {&hf_alljoyn_ns_isat_transport_mask_local,\n         {\"Local Transport\", \"alljoyn.isat.TransportMask.Local\",\n          FT_BOOLEAN, 16, NULL, TRANSPORT_LOCAL,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_ns_isat_transport_mask_bluetooth,\n         {\"Bluetooth Transport\", \"alljoyn.isat.TransportMask.Bluetooth\",\n          FT_BOOLEAN, 16, NULL, TRANSPORT_BLUETOOTH,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_ns_isat_transport_mask_tcp,\n         {\"TCP Transport\", \"alljoyn.isat.TransportMask.TCP\",\n          FT_BOOLEAN, 16, NULL, TRANSPORT_TCP,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_ns_isat_transport_mask_wwan,\n         {\"Wirelesss WAN Transport\", \"alljoyn.isat.TransportMask.WWAN\",\n          FT_BOOLEAN, 16, NULL, TRANSPORT_WWAN,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_ns_isat_transport_mask_lan,\n         {\"Wired LAN Transport\", \"alljoyn.isat.TransportMask.LAN\",\n          FT_BOOLEAN, 16, NULL, TRANSPORT_LAN,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_ns_isat_transport_mask_ice,\n         {\"ICE protocol Transport\", \"alljoyn.isat.TransportMask.ICE\",\n          FT_BOOLEAN, 16, NULL, TRANSPORT_ICE,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_ns_isat_transport_mask_wfd,\n         {\"Wi-Fi Direct Transport\", \"alljoyn.isat.TransportMask.WFD\",\n          FT_BOOLEAN, 16, NULL, TRANSPORT_WFD,\n          NULL, HFILL}\n        },\n\n        /******************\n         * Wireshark header fields for the message protocol.\n         ******************/\n        {&hf_alljoyn_connect_byte_value,\n         {\"Connect Initial Byte\", \"alljoyn.InitialByte\",\n          FT_UINT8, BASE_HEX, NULL, 0x0,\n          NULL, HFILL}\n        },\n\n        /*\n         * Wireshark header fields for the SASL messages.\n         */\n        {&hf_alljoyn_sasl_command,\n         {\"SASL command\", \"alljoyn.SASL.command\",\n          FT_STRING, BASE_NONE, NULL, 0x0,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_sasl_parameter,\n         {\"SASL parameter\", \"alljoyn.SASL.parameter\",\n          FT_STRING, BASE_NONE, NULL, 0x0,\n          NULL, HFILL}\n        },\n\n        /*\n         * Wireshark header fields for the AllJoyn message header.\n         */\n        {&hf_alljoyn_mess_header,\n         {\"Message Header\", \"alljoyn.mess_header\",\n          FT_BYTES, BASE_NONE, NULL, 0x0,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_mess_header_endian,\n         {\"Endianness\", \"alljoyn.mess_header.endianess\",\n          FT_UINT8, BASE_DEC, VALS(endian_encoding_vals), 0x0,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_mess_header_type,\n         {\"Message type\", \"alljoyn.mess_header.type\",\n          FT_UINT8, BASE_DEC, VALS(message_header_encoding_vals), 0x0,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_mess_header_flags,\n         {\"Flags\", \"alljoyn.mess_header.flags\",\n          FT_UINT8, BASE_HEX, NULL, 0x0,\n          NULL, HFILL}\n        },\n\n        /* Individual fields of the flags byte. */\n        {&hf_alljoyn_mess_header_flags_no_reply,\n         {\"No reply expected\", \"alljoyn.mess_header.flags.noreply\",\n          FT_BOOLEAN, 8, NULL, MESSAGE_HEADER_FLAG_NO_REPLY_EXPECTED,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_mess_header_flags_no_auto_start,\n         {\"No auto start\", \"alljoyn.mess_header.flags.noautostart\",\n          FT_BOOLEAN, 8, NULL, MESSAGE_HEADER_FLAG_NO_AUTO_START,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_mess_header_flags_allow_remote_msg,\n         {\"Allow remote messages\", \"alljoyn.mess_header.flags.allowremotemessages\",\n          FT_BOOLEAN, 8, NULL, MESSAGE_HEADER_FLAG_ALLOW_REMOTE_MSG,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_mess_header_flags_sessionless,\n         {\"Sessionless\", \"alljoyn.mess_header.flags.sessionless\",\n          FT_BOOLEAN, 8, NULL, MESSAGE_HEADER_FLAG_SESSIONLESS,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_mess_header_flags_global_broadcast,\n         {\"Allow global broadcast\", \"alljoyn.mess_header.flags.globalbroadcast\",\n          FT_BOOLEAN, 8, NULL, MESSAGE_HEADER_FLAG_GLOBAL_BROADCAST,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_mess_header_flags_compressed,\n         {\"Compressed\", \"alljoyn.mess_header.flags.compressed\",\n          FT_BOOLEAN, 8, NULL, MESSAGE_HEADER_FLAG_COMPRESSED,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_mess_header_flags_encrypted,\n         {\"Encrypted\", \"alljoyn.mess_header.flags.encrypted\",\n          FT_BOOLEAN, 8, NULL, MESSAGE_HEADER_FLAG_ENCRYPTED,\n          NULL, HFILL}\n        },\n\n        {&hf_alljoyn_mess_header_majorversion,\n         {\"Major version\", \"alljoyn.mess_header.majorversion\",\n          FT_UINT8, BASE_DEC, NULL, 0,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_mess_header_body_length,\n         {\"Body length\", \"alljoyn.mess_header.bodylength\",\n          FT_UINT32, BASE_DEC, NULL, 0,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_mess_header_serial,\n         {\"Serial number\", \"alljoyn.mess_header.serial\",\n          FT_UINT32, BASE_DEC, NULL, 0,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_mess_header_header_length,\n         {\"Header length\", \"alljoyn.mess_header.headerlength\",\n          FT_UINT32, BASE_DEC, NULL, 0,\n          NULL, HFILL}\n        },\n\n        {&hf_alljoyn_mess_header_fields,\n         {\"Header fields\", \"alljoyn.mess_header.fields\",\n          FT_BYTES, BASE_NONE, NULL, 0,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_mess_header_field,\n         {\"Header field\", \"alljoyn.mess_header.field\",\n          FT_UINT8, BASE_HEX, VALS(mess_header_field_encoding_vals), 0,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_mess_body_header_fieldcode,\n         {\"Field code\", \"alljoyn.message.fieldcode\",\n          FT_UINT8, BASE_HEX, NULL, 0,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_mess_body_header_typeid,\n         {\"Type ID\", \"alljoyn.message.typeid\",\n          FT_UINT8, BASE_CUSTOM, CF_FUNC(alljoyn_typeid), 0,\n          NULL, HFILL}\n        },\n\n        {&hf_alljoyn_mess_body_parameters,\n         {\"Parameters\", \"alljoyn.parameters\",\n          FT_NONE, BASE_NONE, NULL, 0,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_mess_body_array,\n         {\"Array\", \"alljoyn.array\",\n          FT_NONE, BASE_NONE, NULL, 0,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_mess_body_structure,\n         {\"struct\", \"alljoyn.structure\",\n          FT_NONE, BASE_NONE, NULL, 0,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_mess_body_dictionary_entry,\n         {\"dictionary entry\", \"alljoyn.dictionary_entry\",\n          FT_NONE, BASE_NONE, NULL, 0,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_mess_body_variant,\n         {\"Variant '\", \"alljoyn.variant\",\n          FT_NONE, BASE_NONE, NULL, 0,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_mess_body_signature_length,\n         {\"Signature length\", \"alljoyn.parameter.signature_length\",\n          FT_UINT8, BASE_DEC, NULL, 0,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_mess_body_signature,\n         {\"Signature\", \"alljoyn.parameter.signature\",\n          FT_STRING, BASE_NONE, NULL, 0x0,\n          NULL, HFILL}\n        },\n\n        {&hf_alljoyn_boolean,\n         {\"Boolean\", \"alljoyn.boolean\",\n          FT_BOOLEAN, BASE_NONE, NULL, 0,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_uint8,\n         {\"Unsigned byte\", \"alljoyn.uint8\",\n          FT_UINT8, BASE_DEC, NULL, 0,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_int16,\n         {\"Signed int16\", \"alljoyn.int16\",\n          FT_INT16, BASE_DEC, NULL, 0,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_uint16,\n         {\"Unsigned int16\", \"alljoyn.uint16\",\n          FT_UINT16, BASE_DEC, NULL, 0,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_handle,\n         {\"Handle\", \"alljoyn.handle\",\n          FT_UINT32, BASE_HEX, NULL, 0,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_int32,\n         {\"Signed int32\", \"alljoyn.int32\",\n          FT_INT32, BASE_DEC, NULL, 0,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_uint32,\n         {\"Unsigned int32\", \"alljoyn.uint32\",\n          FT_UINT32, BASE_DEC, NULL, 0,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_int64,\n         {\"Signed int64\", \"alljoyn.int64\",\n          FT_INT64, BASE_DEC, NULL, 0,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_uint64,\n         {\"Unsigned int64\", \"alljoyn.uint64\",\n          FT_UINT64, BASE_DEC, NULL, 0,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_double,\n         {\"Double\", \"alljoyn.double\",\n          FT_DOUBLE, BASE_NONE, NULL, 0,\n          NULL, HFILL}\n        },\n        {&hf_padding,\n         {\"Padding\", \"alljoyn.padding\",\n          FT_BYTES, BASE_NONE, NULL, 0,\n          NULL, HFILL}\n        },\n\n        /*\n         * Strings are composed of a size and a data arrray.\n         */\n        {&hf_alljoyn_string,\n         {\"Bus Name\", \"alljoyn.string\",\n          FT_NONE, BASE_NONE, NULL, 0x0,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_string_size_8bit,\n         {\"String Size 8-bit\", \"alljoyn.string.size8bit\",\n          FT_UINT8, BASE_DEC, NULL, 0x0,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_string_size_32bit,\n         {\"String Size 32-bit\", \"alljoyn.string.size32bit\",\n          FT_UINT32, BASE_DEC, NULL, 0x0,\n          NULL, HFILL}\n        },\n        {&hf_alljoyn_string_data,\n         {\"String Data\", \"alljoyn.string.data\",\n          FT_STRING, BASE_NONE, NULL, 0x0,\n          NULL, HFILL}\n        },\n        /******************\n         * Wireshark header fields for the AllJoyn Reliable Data Protocol.\n         ******************/\n        {&hf_ardp_syn_flag,\n         {\"SYN\", \"ardp.hdr.SYN\",\n          FT_BOOLEAN, 8, NULL, ARDP_SYN,\n          NULL, HFILL}\n        },\n        {&hf_ardp_ack_flag,\n         {\"ACK\", \"ardp.hdr.ACK\",\n          FT_BOOLEAN, 8, NULL, ARDP_ACK,\n          NULL, HFILL}},\n        {&hf_ardp_eak_flag,\n         {\"EAK\", \"ardp.hdr.EAK\",\n          FT_BOOLEAN, 8, NULL, ARDP_EAK,\n          NULL, HFILL}},\n        {&hf_ardp_rst_flag,\n         {\"RST\", \"ardp.hdr.RST\",\n          FT_BOOLEAN, 8, NULL, ARDP_RST,\n          NULL, HFILL}},\n        {&hf_ardp_nul_flag,\n         {\"NUL\", \"ardp.hdr.NUL\",\n          FT_BOOLEAN, 8, NULL, ARDP_NUL,\n          NULL, HFILL}},\n        {&hf_ardp_unused_flag,\n         {\"UNUSED\", \"ardp.hdr.UNUSED\",\n          FT_BOOLEAN, 8, NULL, ARDP_UNUSED,\n          NULL, HFILL}},\n        {&hf_ardp_version_field,\n         {\"VER\", \"ardp.hdr.ver\",\n          FT_UINT8, BASE_HEX, NULL, ARDP_VER,\n          NULL, HFILL}},\n        {&hf_ardp_hlen,\n         {\"Header Length\", \"ardp.hdr.hlen\",\n          FT_UINT8, BASE_DEC, NULL, 0x0,\n          NULL, HFILL}},\n        {&hf_ardp_src,\n         {\"Source Port\", \"ardp.hdr.src\",\n          FT_UINT16, BASE_DEC, NULL, 0x0,\n          NULL, HFILL}},\n        {&hf_ardp_dst,\n         {\"Destination Port\", \"ardp.hdr.dst\",\n          FT_UINT16, BASE_DEC, NULL, 0x0,\n          NULL, HFILL}},\n        {&hf_ardp_dlen,\n         {\"Data Length\", \"ardp.hdr.dlen\",\n          FT_UINT16, BASE_DEC, NULL, 0x0,\n          NULL, HFILL}},\n        {&hf_ardp_seq,\n         {\"Sequence\", \"ardp.hdr.seq\",\n          FT_UINT32, BASE_DEC, NULL, 0x0,\n          NULL, HFILL}},\n        {&hf_ardp_ack,\n         {\"Acknowledge\", \"ardp.hdr.ack\",\n          FT_UINT32, BASE_DEC, NULL, 0x0,\n          NULL, HFILL}},\n        {&hf_ardp_ttl,\n         {\"Time to Live\", \"ardp.hdr.ttl\",\n          FT_UINT32, BASE_DEC, NULL, 0x0,\n          NULL, HFILL}},\n        {&hf_ardp_lcs,\n         {\"Last Consumed Sequence\", \"ardp.hdr.lcs\",\n          FT_UINT32, BASE_DEC, NULL, 0x0,\n          NULL, HFILL}},\n        {&hf_ardp_nsa,\n         {\"Next Sequence to ACK\", \"ardp.hdr.nsa\",\n          FT_UINT32, BASE_DEC, NULL, 0x0,\n          NULL, HFILL}},\n        {&hf_ardp_fss,\n         {\"Fragment Starting Sequence\", \"ardp.hdr.fss\",\n          FT_UINT32, BASE_DEC, NULL, 0x0,\n          NULL, HFILL}},\n        {&hf_ardp_fcnt,\n         {\"Fragment Count\", \"ardp.hdr.fcnt\",\n          FT_UINT16, BASE_HEX, NULL, 0x0,\n          NULL, HFILL}},\n        {&hf_ardp_bmp,\n         {\"EACK Bitmap\", \"ardp.hdr.bmp\",\n          FT_UINT8, BASE_HEX, NULL, 0x0,\n          NULL, HFILL}},\n        {&hf_ardp_segmax,\n         {\"Segment Max\", \"ardp.hdr.segmentmax\",\n          FT_UINT16, BASE_DEC, NULL, 0x0,\n          NULL, HFILL}},\n        {&hf_ardp_segbmax,\n         {\"Segment Buffer Max\", \"ardp.hdr.segmentbmax\",\n          FT_UINT32, BASE_DEC, NULL, 0x0,\n          NULL, HFILL}},\n        {&hf_ardp_dackt,\n         {\"Receiver's delayed ACK timeout\", \"ardp.hdr.dackt\",\n          FT_UINT16, BASE_DEC, NULL, 0x0,\n          NULL, HFILL}},\n        {&hf_ardp_options,\n         {\"Options\", \"ardp.hdr.options\",\n          FT_UINT16, BASE_HEX, NULL, 0x0,\n          NULL, HFILL}},\n    };\n\n    static gint *ett[] = {\n        &ett_alljoyn_ns,\n        &ett_alljoyn_ns_header,\n        &ett_alljoyn_ns_answers,\n        &ett_alljoyn_ns_guid_string,\n        &ett_alljoyn_ns_isat_entry,\n        &ett_alljoyn_ns_string,\n        &ett_alljoyn_whohas,\n        &ett_alljoyn_string,\n        &ett_alljoyn_isat_entry,\n        &ett_alljoyn_mess,\n        &ett_alljoyn_header,\n        &ett_alljoyn_header_flags,\n        &ett_alljoyn_mess_header_field,\n        &ett_alljoyn_mess_header,\n        &ett_alljoyn_mess_body_parameters,\n        &ett_alljoyn_ardp\n    };\n\n    static ei_register_info ei[] = {\n        { &ei_alljoyn_empty_arg,\n            { \"alljoyn.empty_arg\", PI_MALFORMED, PI_ERROR,\n                \"Argument is empty\", EXPFILL }}\n    };\n\n    /* The following are protocols as opposed to data within a protocol. These appear\n     * in Wireshark a divider/header between different groups of data.\n     */\n\n    /* Name service protocols. */                        /* name, short name, abbrev */\n    proto_AllJoyn_ns = proto_register_protocol(\"AllJoyn Name Service Protocol\", \"AllJoyn NS\", \"ajns\");\n\n    /* Message protocols */\n    proto_AllJoyn_mess = proto_register_protocol(\"AllJoyn Message Protocol\", \"AllJoyn\", \"aj\");\n\n    proto_register_field_array(proto_AllJoyn_ns, hf, array_length(hf));\n    proto_register_subtree_array(ett, array_length(ett));\n    expert_alljoyn = expert_register_protocol(proto_AllJoyn_mess);\n    expert_register_field_array(expert_alljoyn, ei, array_length(ei));\n\n    /* ARDP */                        /* name, short name, abbrev */\n    proto_AllJoyn_ardp = proto_register_protocol(\"AllJoyn Reliable Datagram Protocol\", \"AllJoyn ARDP\", \"ardp\");\n}", "target": 1, "idx": 11985}
{"commit_id": "08193b7f0cd3910256e00d599f0f3eb2519c44ca", "project": "facebook/hhvm", "func": "String preg_quote(const String& str,\n                  const String& delimiter /* = null_string */) {\n  const char* in_str = str.data();\n  const char* in_str_end = in_str + str.size();\n\n  /* Nothing to do if we got an empty string */\n  if (in_str == in_str_end) {\n    return str;\n  }\n\n  char delim_char = 0;      /* Delimiter character to be quoted */\n  bool quote_delim = false; /* Whether to quote additional delim char */\n  if (!delimiter.empty()) {\n    delim_char = delimiter.charAt(0);\n    quote_delim = true;\n  }\n\n  /* Allocate enough memory so that even if each character\n     is quoted, we won't run out of room */\n  static_assert(\n    (StringData::MaxSize * 4 + 1) < std::numeric_limits<int64_t>::max()\n  );\n  String ret(4 * str.size() + 1, ReserveString);\n  char* out_str = ret.mutableData();\n\n  /* Go through the string and quote necessary characters */\n  const char* p;\n  char* q;\n  for (p = in_str, q = out_str; p != in_str_end; p++) {\n    char c = *p;\n    switch (c) {\n    case '.': case '\\\\': case '+': case '*': case '?':\n    case '[': case '^':  case ']': case '$': case '(':\n    case ')': case '{':  case '}': case '=': case '!':\n    case '>': case '<':  case '|': case ':': case '-':\n    case '#':\n      *q++ = '\\\\';\n      *q++ = c;\n      break;\n\n    case '\\0':\n      *q++ = '\\\\';\n      *q++ = '0';\n      *q++ = '0';\n      *q++ = '0';\n      break;\n\n    default:\n      if (quote_delim && c == delim_char)\n        *q++ = '\\\\';\n      *q++ = c;\n      break;\n    }\n  }\n  *q = '\\0';\n\n  return ret.setSize(q - out_str);\n}", "target": 3, "idx": 11986}
{"commit_id": "8d2e02ae650f00c4a53deb625211a0527126c605", "project": "xorg/lib/libX11", "func": "XFontStruct *XLoadQueryFont(\n   register Display *dpy,\n   _Xconst char *name)\n{\n    XFontStruct *font_result;\n    register long nbytes;\n    Font fid;\n    xOpenFontReq *req;\n    unsigned long seq;\n#ifdef USE_XF86BIGFONT\n    XF86BigfontCodes *extcodes = _XF86BigfontCodes(dpy);\n#endif\n\n    if (strlen(name) >= USHRT_MAX)\n        return NULL;\n    if (_XF86LoadQueryLocaleFont(dpy, name, &font_result, (Font *)0))\n      return font_result;\n    LockDisplay(dpy);\n    GetReq(OpenFont, req);\n    seq = dpy->request; /* Can't use extended sequence number here */\n    nbytes = req->nbytes = (CARD16) (name ? strlen(name) : 0);\n    req->fid = fid = XAllocID(dpy);\n    req->length += (nbytes+3)>>2;\n    Data (dpy, name, nbytes);\n    font_result = NULL;\n#ifdef USE_XF86BIGFONT\n    if (extcodes) {\n\tfont_result = _XF86BigfontQueryFont(dpy, extcodes, fid, seq);\n\tseq = 0;\n    }\n#endif\n    if (!font_result)\n\tfont_result = _XQueryFont(dpy, fid, seq);\n    UnlockDisplay(dpy);\n    SyncHandle();\n    return font_result;\n}", "target": 3, "idx": 11987}
{"commit_id": "415ab35a441eca767d033a2702223e785b9d5190", "project": "qemu", "func": "static int ne2000_buffer_full(NE2000State *s)\n{\n    int avail, index, boundary;\n\n    if (s->stop <= s->start) {\n        return 1;\n    }\n\n    index = s->curpag << 8;\n    boundary = s->boundary << 8;\n    if (index < boundary)\n        avail = boundary - index;\n    else\n        avail = (s->stop - s->start) - (index - boundary);\n    if (avail < (MAX_ETH_FRAME_SIZE + 4))\n        return 1;\n    return 0;\n}", "target": 1, "idx": 11988}
{"commit_id": "8b281f83e8516535756f92dbf90940ac44bd45e1", "project": "freetype/freetype2", "func": "static void\n  t1_parse_font_matrix( T1_Face    face,\n                        T1_Loader  loader )\n  {\n    T1_Parser   parser = &loader->parser;\n    FT_Matrix*  matrix = &face->type1.font_matrix;\n    FT_Vector*  offset = &face->type1.font_offset;\n    FT_Face     root   = (FT_Face)&face->root;\n    FT_Fixed    temp[6];\n    FT_Fixed    temp_scale;\n    FT_Int      result;\n\n\n    result = T1_ToFixedArray( parser, 6, temp, 3 );\n\n    if ( result < 6 )\n    {\n      parser->root.error = FT_THROW( Invalid_File_Format );\n      return;\n    }\n\n    temp_scale = FT_ABS( temp[3] );\n\n    if ( temp_scale == 0 )\n    {\n      FT_ERROR(( \"t1_parse_font_matrix: invalid font matrix\\n\" ));\n      parser->root.error = FT_THROW( Invalid_File_Format );\n      return;\n    }\n\n    /* Set Units per EM based on FontMatrix values.  We set the value to */\n    /* 1000 / temp_scale, because temp_scale was already multiplied by   */\n    /* 1000 (in t1_tofixed, from psobjs.c).                              */\n\n    root->units_per_EM = (FT_UShort)FT_DivFix( 1000, temp_scale );\n\n    /* we need to scale the values by 1.0/temp_scale */\n    if ( temp_scale != 0x10000L )\n    {\n      temp[0] = FT_DivFix( temp[0], temp_scale );\n      temp[1] = FT_DivFix( temp[1], temp_scale );\n      temp[2] = FT_DivFix( temp[2], temp_scale );\n      temp[4] = FT_DivFix( temp[4], temp_scale );\n      temp[5] = FT_DivFix( temp[5], temp_scale );\n      temp[3] = temp[3] < 0 ? -0x10000L : 0x10000L;\n    }\n\n    matrix->xx = temp[0];\n    matrix->yx = temp[1];\n    matrix->xy = temp[2];\n    matrix->yy = temp[3];\n\n    /* note that the offsets must be expressed in integer font units */\n    offset->x = temp[4] >> 16;\n    offset->y = temp[5] >> 16;\n  }", "target": 3, "idx": 11989}
{"commit_id": "8be9da8280dfa69d5df4417d4d81bda1cab78010", "project": "upx", "func": "bool PackLinuxElf32::calls_crt1(Elf32_Rel const *rel, int sz)\n{\n    if (!dynsym || !dynstr || !rel) {\n        return false;\n    }\n    for (unsigned relnum= 0; 0 < sz; (sz -= sizeof(Elf32_Rel)), ++rel, ++relnum) {\n        unsigned const symnum = get_te32(&rel->r_info) >> 8;\n        char const *const symnam = get_dynsym_name(symnum, relnum);\n        if (0==strcmp(symnam, \"__libc_start_main\")  // glibc\n        ||  0==strcmp(symnam, \"__libc_init\")  // Android\n        ||  0==strcmp(symnam, \"__uClibc_main\")\n        ||  0==strcmp(symnam, \"__uClibc_start_main\"))\n            return true;\n    }\n    return false;\n}", "target": 1, "idx": 11990}
{"commit_id": "8660fb16474054e692a596e9c79670cd4d3954f4", "project": "gssapi/gss-ntlmssp", "func": "static uint32_t parse_user_name(uint32_t *minor_status,\n                                const char *str, size_t len,\n                                char **domain, char **username)\n{\n    uint32_t retmaj;\n    uint32_t retmin;\n    char *at, *sep;\n\n    if (len > MAX_NAME_LEN) {\n        return GSSERRS(ERR_NAMETOOLONG, GSS_S_BAD_NAME);\n    }\n\n    *username = NULL;\n    *domain = NULL;\n\n    /* let's check if there are '@' or '\\' signs */\n    at = memchr(str, '@', len);\n    sep = memchr(str, '\\\\', len);\n\n    /* Check if enterprise name first */\n    if (at && sep) {\n        /* we may have an enterprise name here */\n        char strbuf[len + 1];\n        char *buf = strbuf;\n\n        /* copy buf to manipulate it */\n        memcpy(buf, str, len);\n        buf[len] = '\\0';\n\n        /* adjust pointers relative to new buffer */\n        sep = buf + (sep - str);\n        at = buf + (at - str);\n\n        if (sep > at) {\n            /* domain name contains an '@' sign ... */\n            if (*(sep + 1) == '@') {\n                /* invalid case of XXX@YYY\\@ZZZ*/\n                set_GSSERR(EINVAL);\n                goto done;\n            }\n        } else if (at - sep == 1) {\n            /* it's just a '\\@' escape */\n            /* no leading domain */\n            sep = NULL;\n        }\n\n        if (sep) {\n            /* terminate and copy domain, even if empty */\n            /* NOTE: this is important for the Windbind integration case\n             * where we need to tell the machinery to *not* add the default\n             * domain name, it happens when the domain is NULL. */\n            *sep = '\\0';\n            *domain = strdup(buf);\n            if (NULL == *domain) {\n                set_GSSERR(ENOMEM);\n                goto done;\n            }\n            /* point buf at username part */\n            len = len - (sep - buf) - 1;\n            buf = sep + 1;\n        }\n\n        for (at = strchr(buf, '@'); at != NULL; at = strchr(at, '@')) {\n            if (*(at - 1) == '\\\\') {\n                if (*domain) {\n                    /* Invalid forms like DOM\\foo\\@bar or foo@bar\\@baz */\n                    free(*domain);\n                    *domain = NULL;\n                    set_GSSERR(EINVAL);\n                    goto done;\n                }\n                /* remove escape, moving all including terminating '\\0' */\n                memmove(at - 1, at, len - (at - buf) + 1);\n            } else if (!*domain) {\n                /* an '@' without escape and no previous\n                 * domain was split out.\n                 * the rest of the string is the domain */\n                *at = '\\0';\n                *domain = strdup(at + 1);\n                if (NULL == *domain) {\n                    set_GSSERR(ENOMEM);\n                    goto done;\n                }\n                /* note we continue the loop to check if any invalid\n                 * \\@ escapes is found in the domain part */\n            }\n            at += 1;\n        }\n\n        *username = strdup(buf);\n        if (NULL == *username) {\n            set_GSSERR(ENOMEM);\n            goto done;\n        }\n\n        /* we got an enterprise name, return */\n        set_GSSERRS(0, GSS_S_COMPLETE);\n        goto done;\n    }\n\n    /* Check if in classic DOMAIN\\User windows format */\n    if (sep) {\n        retmaj = string_split(&retmin, '\\\\', str, len, domain, username);\n        goto done;\n    }\n\n    /* else accept a user@domain format too */\n    if (at) {\n        retmaj = string_split(&retmin, '@', str, len, username, domain);\n        goto done;\n    }\n\n    /* finally, take string as simple user name */\n    *username = strndup(str, len);\n    if (NULL == *username) {\n        set_GSSERR(ENOMEM);\n    }\n    set_GSSERRS(0, GSS_S_COMPLETE);\n\ndone:\n    return GSSERR();\n}", "target": 2, "idx": 11991}
{"commit_id": "e0a5a02b0fc1900a69d6c37ed0aab36fb8494e6d", "project": "the-tcpdump-group/tcpdump", "func": "static const u_char *\nikev1_t_print(netdissect_options *ndo, u_char tpay _U_,\n\t      const struct isakmp_gen *ext, u_int item_len,\n\t      const u_char *ep, uint32_t phase _U_, uint32_t doi _U_,\n\t      uint32_t proto, int depth _U_)\n{\n\tconst struct ikev1_pl_t *p;\n\tstruct ikev1_pl_t t;\n\tconst u_char *cp;\n\tconst char *idstr;\n\tconst struct attrmap *map;\n\tsize_t nmap;\n\tconst u_char *ep2;\n\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_T)));\n\n\tp = (const struct ikev1_pl_t *)ext;\n\tND_TCHECK(*p);\n\tUNALIGNED_MEMCPY(&t, ext, sizeof(t));\n\n\tswitch (proto) {\n\tcase 1:\n\t\tidstr = STR_OR_ID(t.t_id, ikev1_p_map);\n\t\tmap = oakley_t_map;\n\t\tnmap = sizeof(oakley_t_map)/sizeof(oakley_t_map[0]);\n\t\tbreak;\n\tcase 2:\n\t\tidstr = STR_OR_ID(t.t_id, ah_p_map);\n\t\tmap = ipsec_t_map;\n\t\tnmap = sizeof(ipsec_t_map)/sizeof(ipsec_t_map[0]);\n\t\tbreak;\n\tcase 3:\n\t\tidstr = STR_OR_ID(t.t_id, esp_p_map);\n\t\tmap = ipsec_t_map;\n\t\tnmap = sizeof(ipsec_t_map)/sizeof(ipsec_t_map[0]);\n\t\tbreak;\n\tcase 4:\n\t\tidstr = STR_OR_ID(t.t_id, ipcomp_p_map);\n\t\tmap = ipsec_t_map;\n\t\tnmap = sizeof(ipsec_t_map)/sizeof(ipsec_t_map[0]);\n\t\tbreak;\n\tdefault:\n\t\tidstr = NULL;\n\t\tmap = NULL;\n\t\tnmap = 0;\n\t\tbreak;\n\t}\n\n\tif (idstr)\n\t\tND_PRINT((ndo,\" #%d id=%s \", t.t_no, idstr));\n\telse\n\t\tND_PRINT((ndo,\" #%d id=%d \", t.t_no, t.t_id));\n\tcp = (const u_char *)(p + 1);\n\tep2 = (const u_char *)p + item_len;\n\twhile (cp < ep && cp < ep2) {\n\t\tif (map && nmap)\n\t\t\tcp = ikev1_attrmap_print(ndo, cp, ep2, map, nmap);\n\t\telse\n\t\t\tcp = ikev1_attr_print(ndo, cp, ep2);\n\t\tif (cp == NULL)\n\t\t\tgoto trunc;\n\t}\n\tif (ep < ep2)\n\t\tND_PRINT((ndo,\"...\"));\n\treturn cp;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_T)));\n\treturn NULL;\n}", "target": 3, "idx": 11992}
{"commit_id": "042eb437973a202d00589b13d628181c6de5cf5b", "project": "cesanta/mongoose-os", "func": "static int mg_http_multipart_wait_for_boundary(struct mg_connection *c) {\n  const char *boundary;\n  struct mbuf *io = &c->recv_mbuf;\n  struct mg_http_proto_data *pd = mg_http_get_proto_data(c);\n\n  if (pd->mp_stream.boundary == NULL) {\n    pd->mp_stream.state = MPS_FINALIZE;\n    DBG((\"Invalid request: boundary not initilaized\"));\n    return 0;\n  }\n\n  if ((int) io->len < pd->mp_stream.boundary_len + 2) {\n    return 0;\n  }\n\n  boundary = c_strnstr(io->buf, pd->mp_stream.boundary, io->len);\n  if (boundary != NULL) {\n    const char *boundary_end = (boundary + pd->mp_stream.boundary_len);\n    if (io->len - (boundary_end - io->buf) < 4) {\n      return 0;\n    }\n    if (strncmp(boundary_end, \"--\\r\\n\", 4) == 0) {\n      pd->mp_stream.state = MPS_FINALIZE;\n      mbuf_remove(io, (boundary_end - io->buf) + 4);\n    } else {\n      pd->mp_stream.state = MPS_GOT_BOUNDARY;\n    }\n  } else {\n    return 0;\n  }\n\n  return 1;\n}", "target": 2, "idx": 11993}
{"commit_id": "554b56687a19300a75ec24184746b5512580c819", "project": "memcached", "func": "static inline void get_conn_text(const conn *c, const int af,\n                char* addr, struct sockaddr *sock_addr) {\n    char addr_text[MAXPATHLEN];\n    addr_text[0] = '\\0';\n    const char *protoname = \"?\";\n    unsigned short port = 0;\n    size_t pathlen = 0;\n\n    switch (af) {\n        case AF_INET:\n            (void) inet_ntop(af,\n                    &((struct sockaddr_in *)sock_addr)->sin_addr,\n                    addr_text,\n                    sizeof(addr_text) - 1);\n            port = ntohs(((struct sockaddr_in *)sock_addr)->sin_port);\n            protoname = IS_UDP(c->transport) ? \"udp\" : \"tcp\";\n            break;\n\n        case AF_INET6:\n            addr_text[0] = '[';\n            addr_text[1] = '\\0';\n            if (inet_ntop(af,\n                    &((struct sockaddr_in6 *)sock_addr)->sin6_addr,\n                    addr_text + 1,\n                    sizeof(addr_text) - 2)) {\n                strcat(addr_text, \"]\");\n            }\n            port = ntohs(((struct sockaddr_in6 *)sock_addr)->sin6_port);\n            protoname = IS_UDP(c->transport) ? \"udp6\" : \"tcp6\";\n            break;\n\n        case AF_UNIX:\n            // this strncpy call originally could piss off an address\n            // sanitizer; we supplied the size of the dest buf as a limiter,\n            // but optimized versions of strncpy could read past the end of\n            // *src while looking for a null terminator. Since buf and\n            // sun_path here are both on the stack they could even overlap,\n            // which is \"undefined\". In all OSS versions of strncpy I could\n            // find this has no effect; it'll still only copy until the first null\n            // terminator is found. Thus it's possible to get the OS to\n            // examine past the end of sun_path but it's unclear to me if this\n            // can cause any actual problem.\n            //\n            // We need a safe_strncpy util function but I'll punt on figuring\n            // that out for now.\n            pathlen = sizeof(((struct sockaddr_un *)sock_addr)->sun_path);\n            if (MAXPATHLEN <= pathlen) {\n                pathlen = MAXPATHLEN - 1;\n            }\n            strncpy(addr_text,\n                    ((struct sockaddr_un *)sock_addr)->sun_path,\n                    pathlen);\n            addr_text[pathlen] = '\\0';\n            protoname = \"unix\";\n            break;\n    }\n\n    if (strlen(addr_text) < 2) {\n        /* Most likely this is a connected UNIX-domain client which\n         * has no peer socket address, but there's no portable way\n         * to tell for sure.\n         */\n        sprintf(addr_text, \"<AF %d>\", af);\n    }\n\n    if (port) {\n        sprintf(addr, \"%s:%s:%u\", protoname, addr_text, port);\n    } else {\n        sprintf(addr, \"%s:%s\", protoname, addr_text);\n    }\n}", "target": 2, "idx": 11994}
{"commit_id": "148115fcc40f1651a5d15fa34c9a8c528e7147bb", "project": "OSGeo/gdal", "func": "static void* OGRExpatRealloc( void *ptr, size_t size )\n{\n    if( CanAlloc(size) )\n        return realloc(ptr, size);\n\n    return nullptr;\n}", "target": 3, "idx": 11995}
{"commit_id": "0ace17d56824165c7f4c68785d6b58971db954dd", "project": "torvalds/linux", "func": "static void slip_close(struct tty_struct *tty)\n{\n\tstruct slip *sl = tty->disc_data;\n\n\t/* First make sure we're connected. */\n\tif (!sl || sl->magic != SLIP_MAGIC || sl->tty != tty)\n\t\treturn;\n\n\tspin_lock_bh(&sl->lock);\n\trcu_assign_pointer(tty->disc_data, NULL);\n\tsl->tty = NULL;\n\tspin_unlock_bh(&sl->lock);\n\n\tsynchronize_rcu();\n\tflush_work(&sl->tx_work);\n\n\t/* VSV = very important to remove timers */\n#ifdef CONFIG_SLIP_SMART\n\tdel_timer_sync(&sl->keepalive_timer);\n\tdel_timer_sync(&sl->outfill_timer);\n#endif\n\t/* Flush network side */\n\tunregister_netdev(sl->dev);\n\t/* This will complete via sl_free_netdev */\n}", "target": 1, "idx": 11996}
{"commit_id": "a03f43645d072b7caaa9b204067095481137a2a0", "project": "wireshark", "func": "static int\ndissect_kafka_tagged_fields(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset,\n                               kafka_api_version_t api_version _U_)\n{\n    gint64 count;\n    guint len;\n    proto_item *subti;\n    proto_tree *subtree;\n\n    subtree = proto_tree_add_subtree(tree, tvb, offset, -1,\n                                     ett_kafka_tagged_fields,\n                                     &subti, \"Tagged fields\");\n\n    len = tvb_get_varint(tvb, offset, FT_VARINT_MAX_LEN, &count, ENC_VARINT_PROTOBUF);\n    if (len == 0) {\n        expert_add_info(pinfo, subtree, &ei_kafka_bad_varint);\n        return tvb_captured_length(tvb);\n   }\n    offset += len;\n\n    /*\n     * Contrary to compact arrays, tagged fields store just count\n     * https://cwiki.apache.org/confluence/display/KAFKA/KIP-482%3A+The+Kafka+Protocol+should+Support+Optional+Tagged+Fields\n     */\n    offset = dissect_kafka_array_elements(subtree, tvb, pinfo, offset, api_version, &dissect_kafka_tagged_field, (gint32)count);\n\n    proto_item_set_end(subti, tvb, offset);\n\n    return offset;\n}", "target": 2, "idx": 11997}
{"commit_id": "b4d09af9194d20a7f9f16995a062f5d8e3d32840", "project": "FRRouting/frr", "func": "static int bgp_capability_software_version(struct peer *peer,\n\t\t\t\t\t   struct capability_header *hdr)\n{\n\tstruct stream *s = BGP_INPUT(peer);\n\tchar str[BGP_MAX_SOFT_VERSION + 1];\n\tsize_t end = stream_get_getp(s) + hdr->length;\n\tuint8_t len;\n\n\tSET_FLAG(peer->cap, PEER_CAP_SOFT_VERSION_RCV);\n\n\tlen = stream_getc(s);\n\tif (stream_get_getp(s) + len > end) {\n\t\tflog_warn(\n\t\t\tEC_BGP_CAPABILITY_INVALID_DATA,\n\t\t\t\"%s: Received malformed Software Version capability from peer %s\",\n\t\t\t__func__, peer->host);\n\t\treturn -1;\n\t}\n\n\tif (len > BGP_MAX_SOFT_VERSION) {\n\t\tflog_warn(EC_BGP_CAPABILITY_INVALID_LENGTH,\n\t\t\t  \"%s: Received Software Version, but the length is too big, truncating, from peer %s\",\n\t\t\t  __func__, peer->host);\n\t\tstream_get(str, s, BGP_MAX_SOFT_VERSION);\n\t\tstream_forward_getp(s, len - BGP_MAX_SOFT_VERSION);\n\t\tlen = BGP_MAX_SOFT_VERSION;\n\t} else if (len) {\n\t\tstream_get(str, s, len);\n\t}\n\n\tif (len) {\n\t\tstr[len] = '\\0';\n\n\t\tXFREE(MTYPE_BGP_SOFT_VERSION, peer->soft_version);\n\n\t\tpeer->soft_version = XSTRDUP(MTYPE_BGP_SOFT_VERSION, str);\n\n\t\tif (bgp_debug_neighbor_events(peer))\n\t\t\tzlog_debug(\"%s sent Software Version: %s\", peer->host,\n\t\t\t\t   peer->soft_version);\n\t}\n\n\treturn 0;\n}", "target": 3, "idx": 11998}
{"commit_id": "16ce101db85db694a91380aa4c89b25530871d33", "project": "torvalds/linux", "func": "void migrate_vma_pages(struct migrate_vma *migrate)\n{\n\tconst unsigned long npages = migrate->npages;\n\tconst unsigned long start = migrate->start;\n\tstruct mmu_notifier_range range;\n\tunsigned long addr, i;\n\tbool notified = false;\n\n\tfor (i = 0, addr = start; i < npages; addr += PAGE_SIZE, i++) {\n\t\tstruct page *newpage = migrate_pfn_to_page(migrate->dst[i]);\n\t\tstruct page *page = migrate_pfn_to_page(migrate->src[i]);\n\t\tstruct address_space *mapping;\n\t\tint r;\n\n\t\tif (!newpage) {\n\t\t\tmigrate->src[i] &= ~MIGRATE_PFN_MIGRATE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!page) {\n\t\t\t/*\n\t\t\t * The only time there is no vma is when called from\n\t\t\t * migrate_device_coherent_page(). However this isn't\n\t\t\t * called if the page could not be unmapped.\n\t\t\t */\n\t\t\tVM_BUG_ON(!migrate->vma);\n\t\t\tif (!(migrate->src[i] & MIGRATE_PFN_MIGRATE))\n\t\t\t\tcontinue;\n\t\t\tif (!notified) {\n\t\t\t\tnotified = true;\n\n\t\t\t\tmmu_notifier_range_init_owner(&range,\n\t\t\t\t\tMMU_NOTIFY_MIGRATE, 0, migrate->vma,\n\t\t\t\t\tmigrate->vma->vm_mm, addr, migrate->end,\n\t\t\t\t\tmigrate->pgmap_owner);\n\t\t\t\tmmu_notifier_invalidate_range_start(&range);\n\t\t\t}\n\t\t\tmigrate_vma_insert_page(migrate, addr, newpage,\n\t\t\t\t\t\t&migrate->src[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmapping = page_mapping(page);\n\n\t\tif (is_device_private_page(newpage) ||\n\t\t    is_device_coherent_page(newpage)) {\n\t\t\t/*\n\t\t\t * For now only support anonymous memory migrating to\n\t\t\t * device private or coherent memory.\n\t\t\t */\n\t\t\tif (mapping) {\n\t\t\t\tmigrate->src[i] &= ~MIGRATE_PFN_MIGRATE;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else if (is_zone_device_page(newpage)) {\n\t\t\t/*\n\t\t\t * Other types of ZONE_DEVICE page are not supported.\n\t\t\t */\n\t\t\tmigrate->src[i] &= ~MIGRATE_PFN_MIGRATE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (migrate->fault_page == page)\n\t\t\tr = migrate_folio_extra(mapping, page_folio(newpage),\n\t\t\t\t\t\tpage_folio(page),\n\t\t\t\t\t\tMIGRATE_SYNC_NO_COPY, 1);\n\t\telse\n\t\t\tr = migrate_folio(mapping, page_folio(newpage),\n\t\t\t\t\tpage_folio(page), MIGRATE_SYNC_NO_COPY);\n\t\tif (r != MIGRATEPAGE_SUCCESS)\n\t\t\tmigrate->src[i] &= ~MIGRATE_PFN_MIGRATE;\n\t}\n\n\t/*\n\t * No need to double call mmu_notifier->invalidate_range() callback as\n\t * the above ptep_clear_flush_notify() inside migrate_vma_insert_page()\n\t * did already call it.\n\t */\n\tif (notified)\n\t\tmmu_notifier_invalidate_range_only_end(&range);\n}", "target": 1, "idx": 11999}
{"commit_id": "2e83b79b2d6c78bf1b4aa227938a214dcbddc83f", "project": "torvalds/linux", "func": "int\nxfs_attr3_leaf_list_int(\n\tstruct xfs_buf\t\t\t*bp,\n\tstruct xfs_attr_list_context\t*context)\n{\n\tstruct attrlist_cursor_kern\t*cursor;\n\tstruct xfs_attr_leafblock\t*leaf;\n\tstruct xfs_attr3_icleaf_hdr\tichdr;\n\tstruct xfs_attr_leaf_entry\t*entries;\n\tstruct xfs_attr_leaf_entry\t*entry;\n\tint\t\t\t\tretval;\n\tint\t\t\t\ti;\n\tstruct xfs_mount\t\t*mp = context->dp->i_mount;\n\n\ttrace_xfs_attr_list_leaf(context);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(mp->m_attr_geo, &ichdr, leaf);\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\n\tcursor = context->cursor;\n\tcursor->initted = 1;\n\n\t/*\n\t * Re-find our place in the leaf block if this is a new syscall.\n\t */\n\tif (context->resynch) {\n\t\tentry = &entries[0];\n\t\tfor (i = 0; i < ichdr.count; entry++, i++) {\n\t\t\tif (be32_to_cpu(entry->hashval) == cursor->hashval) {\n\t\t\t\tif (cursor->offset == context->dupcnt) {\n\t\t\t\t\tcontext->dupcnt = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontext->dupcnt++;\n\t\t\t} else if (be32_to_cpu(entry->hashval) >\n\t\t\t\t\tcursor->hashval) {\n\t\t\t\tcontext->dupcnt = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == ichdr.count) {\n\t\t\ttrace_xfs_attr_list_notfound(context);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tentry = &entries[0];\n\t\ti = 0;\n\t}\n\tcontext->resynch = 0;\n\n\t/*\n\t * We have found our place, start copying out the new attributes.\n\t */\n\tretval = 0;\n\tfor (; i < ichdr.count; entry++, i++) {\n\t\tif (be32_to_cpu(entry->hashval) != cursor->hashval) {\n\t\t\tcursor->hashval = be32_to_cpu(entry->hashval);\n\t\t\tcursor->offset = 0;\n\t\t}\n\n\t\tif (entry->flags & XFS_ATTR_INCOMPLETE)\n\t\t\tcontinue;\t\t/* skip incomplete entries */\n\n\t\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\t\txfs_attr_leaf_name_local_t *name_loc =\n\t\t\t\txfs_attr3_leaf_name_local(leaf, i);\n\n\t\t\tretval = context->put_listent(context,\n\t\t\t\t\t\tentry->flags,\n\t\t\t\t\t\tname_loc->nameval,\n\t\t\t\t\t\t(int)name_loc->namelen,\n\t\t\t\t\t\tbe16_to_cpu(name_loc->valuelen),\n\t\t\t\t\t\t&name_loc->nameval[name_loc->namelen]);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t} else {\n\t\t\txfs_attr_leaf_name_remote_t *name_rmt =\n\t\t\t\txfs_attr3_leaf_name_remote(leaf, i);\n\n\t\t\tint valuelen = be32_to_cpu(name_rmt->valuelen);\n\n\t\t\tif (context->put_value) {\n\t\t\t\txfs_da_args_t args;\n\n\t\t\t\tmemset((char *)&args, 0, sizeof(args));\n\t\t\t\targs.geo = context->dp->i_mount->m_attr_geo;\n\t\t\t\targs.dp = context->dp;\n\t\t\t\targs.whichfork = XFS_ATTR_FORK;\n\t\t\t\targs.valuelen = valuelen;\n\t\t\t\targs.rmtvaluelen = valuelen;\n\t\t\t\targs.value = kmem_alloc(valuelen, KM_SLEEP | KM_NOFS);\n\t\t\t\targs.rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\t\t\targs.rmtblkcnt = xfs_attr3_rmt_blocks(\n\t\t\t\t\t\t\targs.dp->i_mount, valuelen);\n\t\t\t\tretval = xfs_attr_rmtval_get(&args);\n\t\t\t\tif (!retval)\n\t\t\t\t\tretval = context->put_listent(context,\n\t\t\t\t\t\t\tentry->flags,\n\t\t\t\t\t\t\tname_rmt->name,\n\t\t\t\t\t\t\t(int)name_rmt->namelen,\n\t\t\t\t\t\t\tvaluelen,\n\t\t\t\t\t\t\targs.value);\n\t\t\t\tkmem_free(args.value);\n\t\t\t} else {\n\t\t\t\tretval = context->put_listent(context,\n\t\t\t\t\t\tentry->flags,\n\t\t\t\t\t\tname_rmt->name,\n\t\t\t\t\t\t(int)name_rmt->namelen,\n\t\t\t\t\t\tvaluelen,\n\t\t\t\t\t\tNULL);\n\t\t\t}\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t}\n\t\tif (context->seen_enough)\n\t\t\tbreak;\n\t\tcursor->offset++;\n\t}\n\ttrace_xfs_attr_list_leaf_end(context);\n\treturn retval;\n}", "target": 1, "idx": 12000}
{"commit_id": "b7f6cbb9d43f7384e1f38f8764b9a48216c8a525", "project": "xen-project/xen", "func": "static void\n__gnttab_unmap_common(\n    struct gnttab_unmap_common *op)\n{\n    domid_t          dom;\n    struct domain   *ld, *rd;\n    struct grant_table *lgt, *rgt;\n    struct active_grant_entry *act;\n    s16              rc = 0;\n    struct grant_mapping *map;\n    bool put_handle = false;\n\n    ld = current->domain;\n    lgt = ld->grant_table;\n\n    op->frame = (unsigned long)(op->dev_bus_addr >> PAGE_SHIFT);\n\n    if ( unlikely(op->handle >= lgt->maptrack_limit) )\n    {\n        gdprintk(XENLOG_INFO, \"Bad handle %#x\\n\", op->handle);\n        op->status = GNTST_bad_handle;\n        return;\n    }\n\n    map = &maptrack_entry(lgt, op->handle);\n\n    grant_read_lock(lgt);\n\n    if ( unlikely(!read_atomic(&map->flags)) )\n    {\n        grant_read_unlock(lgt);\n        gdprintk(XENLOG_INFO, \"Zero flags for handle %#x\\n\", op->handle);\n        op->status = GNTST_bad_handle;\n        return;\n    }\n\n    dom = map->domid;\n    grant_read_unlock(lgt);\n\n    if ( unlikely((rd = rcu_lock_domain_by_id(dom)) == NULL) )\n    {\n        /* This can happen when a grant is implicitly unmapped. */\n        gdprintk(XENLOG_INFO, \"Could not find domain %d\\n\", dom);\n        domain_crash(ld); /* naughty... */\n        return;\n    }\n\n    rc = xsm_grant_unmapref(XSM_HOOK, ld, rd);\n    if ( rc )\n    {\n        rcu_unlock_domain(rd);\n        op->status = GNTST_permission_denied;\n        return;\n    }\n\n    TRACE_1D(TRC_MEM_PAGE_GRANT_UNMAP, dom);\n\n    rgt = rd->grant_table;\n\n    grant_read_lock(rgt);\n\n    op->rd = rd;\n    op->ref = map->ref;\n\n    /*\n     * We can't assume there was no racing unmap for this maptrack entry,\n     * and hence we can't assume map->ref is valid for rd. While the checks\n     * below (with the active entry lock held) will reject any such racing\n     * requests, we still need to make sure we don't attempt to acquire an\n     * invalid lock.\n     */\n    smp_rmb();\n    if ( unlikely(op->ref >= nr_grant_entries(rgt)) )\n    {\n        gdprintk(XENLOG_WARNING, \"Unstable handle %#x\\n\", op->handle);\n        rc = GNTST_bad_handle;\n        goto unlock_out;\n    }\n\n    act = active_entry_acquire(rgt, op->ref);\n\n    /*\n     * Note that we (ab)use the active entry lock here to protect against\n     * multiple unmaps of the same mapping here. We don't want to hold lgt's\n     * lock, and we only hold rgt's lock for reading (but the latter wouldn't\n     * be the right one anyway). Hence the easiest is to rely on a lock we\n     * hold anyway; see docs/misc/grant-tables.txt's \"Locking\" section.\n     */\n\n    op->flags = read_atomic(&map->flags);\n    smp_rmb();\n    if ( unlikely(!op->flags) || unlikely(map->domid != dom) ||\n         unlikely(map->ref != op->ref) )\n    {\n        gdprintk(XENLOG_WARNING, \"Unstable handle %#x\\n\", op->handle);\n        rc = GNTST_bad_handle;\n        goto act_release_out;\n    }\n\n    if ( op->frame == 0 )\n    {\n        op->frame = act->frame;\n    }\n    else\n    {\n        if ( unlikely(op->frame != act->frame) )\n            PIN_FAIL(act_release_out, GNTST_general_error,\n                     \"Bad frame number doesn't match gntref. (%lx != %lx)\\n\",\n                     op->frame, act->frame);\n\n        map->flags &= ~GNTMAP_device_map;\n    }\n\n    if ( (op->host_addr != 0) && (op->flags & GNTMAP_host_map) )\n    {\n        if ( (rc = replace_grant_host_mapping(op->host_addr,\n                                              op->frame, op->new_addr, \n                                              op->flags)) < 0 )\n            goto act_release_out;\n\n        map->flags &= ~GNTMAP_host_map;\n    }\n\n    if ( !(map->flags & (GNTMAP_device_map|GNTMAP_host_map)) )\n    {\n        map->flags = 0;\n        put_handle = true;\n    }\n\n act_release_out:\n    active_entry_release(act);\n unlock_out:\n    grant_read_unlock(rgt);\n\n    if ( put_handle )\n        put_maptrack_handle(lgt, op->handle);\n\n    if ( rc == GNTST_okay && gnttab_need_iommu_mapping(ld) )\n    {\n        unsigned int kind;\n        int err = 0;\n\n        double_gt_lock(lgt, rgt);\n\n        kind = mapkind(lgt, rd, op->frame);\n        if ( !kind )\n            err = iommu_unmap_page(ld, op->frame);\n        else if ( !(kind & MAPKIND_WRITE) )\n            err = iommu_map_page(ld, op->frame, op->frame, IOMMUF_readable);\n\n        double_gt_unlock(lgt, rgt);\n\n        if ( err )\n            rc = GNTST_general_error;\n    }\n\n    /* If just unmapped a writable mapping, mark as dirtied */\n    if ( rc == GNTST_okay && !(op->flags & GNTMAP_readonly) )\n         gnttab_mark_dirty(rd, op->frame);\n\n    op->status = rc;\n    rcu_unlock_domain(rd);\n}", "target": 3, "idx": 12001}
{"commit_id": "2f95fa5c955d0a9987ffdc3a095e2f4e62c5f2a9", "project": "torvalds/linux", "func": "static enum hrtimer_restart bfq_idle_slice_timer(struct hrtimer *timer)\n{\n\tstruct bfq_data *bfqd = container_of(timer, struct bfq_data,\n\t\t\t\t\t     idle_slice_timer);\n\tstruct bfq_queue *bfqq = bfqd->in_service_queue;\n\n\t/*\n\t * Theoretical race here: the in-service queue can be NULL or\n\t * different from the queue that was idling if a new request\n\t * arrives for the current queue and there is a full dispatch\n\t * cycle that changes the in-service queue.  This can hardly\n\t * happen, but in the worst case we just expire a queue too\n\t * early.\n\t */\n\tif (bfqq)\n\t\tbfq_idle_slice_timer_body(bfqd, bfqq);\n\n\treturn HRTIMER_NORESTART;\n}", "target": 2, "idx": 12002}
{"commit_id": "63db2d99e730547339d1bdd28e8437999c380cae", "project": "OpenRC/openrc", "func": "int main(int argc, char **argv)\n{\n\tint opt;\n\tuid_t uid = geteuid();\n\tgid_t gid = getgid();\n\tmode_t mode = 0;\n\tstruct passwd *pw = NULL;\n\tstruct group *gr = NULL;\n\tinode_t type = inode_unknown;\n\tint retval = EXIT_SUCCESS;\n\tbool trunc = false;\n\tbool chowner = false;\n\tbool symlinks = false;\n\tbool writable = false;\n\tbool selinux_on = false;\n\tchar *path = NULL;\n\n\tapplet = basename_c(argv[0]);\n\twhile ((opt = getopt_long(argc, argv, getoptstring,\n\t\t    longopts, (int *) 0)) != -1)\n\t{\n\t\tswitch (opt) {\n\t\tcase 'D':\n\t\t\ttrunc = true;\n\t\t\t/* falls through */\n\t\tcase 'd':\n\t\t\ttype = inode_dir;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\ttrunc = true;\n\t\t\t/* falls through */\n\t\tcase 'f':\n\t\t\ttype = inode_file;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\ttype = inode_fifo;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tif (parse_mode(&mode, optarg) != 0)\n\t\t\t\teerrorx(\"%s: invalid mode `%s'\",\n\t\t\t\t    applet, optarg);\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tchowner = true;\n\t\t\tif (parse_owner(&pw, &gr, optarg) != 0)\n\t\t\t\teerrorx(\"%s: owner `%s' not found\",\n\t\t\t\t    applet, optarg);\n\t\t\tbreak;\n\t\tcase 's':\n#ifndef O_PATH\n\t\t\tsymlinks = true;\n#endif\n\t\t\tbreak;\n\t\tcase 'W':\n\t\t\twritable = true;\n\t\t\tbreak;\n\n\t\tcase_RC_COMMON_GETOPT\n\t\t}\n\t}\n\n\tif (optind >= argc)\n\t\tusage(EXIT_FAILURE);\n\n\tif (writable && type != inode_unknown)\n\t\teerrorx(\"%s: -W cannot be specified along with -d, -f or -p\", applet);\n\n\tif (pw) {\n\t\tuid = pw->pw_uid;\n\t\tgid = pw->pw_gid;\n\t}\n\tif (gr)\n\t\tgid = gr->gr_gid;\n\n\tif (selinux_util_open() == 1)\n\t\tselinux_on = true;\n\n\twhile (optind < argc) {\n\t\tpath = clean_path(argv[optind]);\n\t\tif (writable)\n\t\t\texit(!is_writable(path));\n\t\tif (do_check(path, uid, gid, mode, type, trunc, chowner,\n\t\t\t\t\tsymlinks, selinux_on))\n\t\t\tretval = EXIT_FAILURE;\n\t\toptind++;\n\t\tfree(path);\n\t}\n\n\tif (selinux_on)\n\t\tselinux_util_close();\n\n\treturn retval;\n}", "target": 2, "idx": 12003}
{"commit_id": "d72ccf06c98259d7261e0f3ac4fd8717778782c1", "project": "wez/atomicparsley", "func": "void APar_ExtractDetails(FILE *isofile, uint8_t optional_output) {\n  char uint32_buffer[8];\n  Trackage track = {0};\n\n  AtomicInfo *mvhdAtom = APar_FindAtom(\"moov.mvhd\", false, VERSIONED_ATOM, 0);\n  if (mvhdAtom != NULL) {\n    APar_ExtractMovieDetails(uint32_buffer, isofile, mvhdAtom);\n    fprintf(stdout,\n            \"Movie duration: %.3lf seconds (%s) - %.2lf* kbp/sec bitrate \"\n            \"(*=approximate)\\n\",\n            movie_info.seconds,\n            secsTOtime(movie_info.seconds),\n            movie_info.simple_bitrate_calc);\n    if (optional_output & SHOW_DATE_INFO) {\n      fprintf(stdout,\n              \"  Presentation Creation Date (UTC):     %s\\n\",\n              APar_extract_UTC(movie_info.creation_time));\n      fprintf(stdout,\n              \"  Presentation Modification Date (UTC): %s\\n\",\n              APar_extract_UTC(movie_info.modified_time));\n    }\n  }\n\n  AtomicInfo *iodsAtom = APar_FindAtom(\"moov.iods\", false, VERSIONED_ATOM, 0);\n  if (iodsAtom != NULL) {\n    movie_info.contains_iods = true;\n    APar_Extract_iods_Info(isofile, iodsAtom);\n  }\n\n  if (optional_output & SHOW_TRACK_INFO) {\n    APar_TrackLevelInfo(&track,\n                        NULL); // With track_num set to 0, it will return the\n                               // total trak atom into total_tracks here.\n\n    fprintf(\n        stdout, \"Low-level details. Total tracks: %u\\n\", track.total_tracks);\n    fprintf(stdout,\n            \"Trk  Type  Handler                    Kind  Lang  Bytes\\n\");\n\n    if (track.total_tracks > 0) {\n      while (track.total_tracks > track.track_num) {\n        track.track_num += 1;\n        TrackInfo track_info = {0};\n\n        // tracknum, handler type, handler name\n        APar_ExtractTrackDetails(uint32_buffer, isofile, &track, &track_info);\n        uint16_t more_whitespace =\n            purge_extraneous_characters(track_info.track_hdlr_name);\n\n        if (strlen(track_info.track_hdlr_name) == 0) {\n          memcpy(track_info.track_hdlr_name, \"[none listed]\", 13);\n        }\n        fprintf(stdout,\n                \"%u    %s  %s\",\n                track.track_num,\n                uint32tochar4(track_info.track_type, uint32_buffer),\n                track_info.track_hdlr_name);\n\n        uint16_t handler_len = strlen(track_info.track_hdlr_name);\n        if (handler_len < 25 + more_whitespace) {\n          for (uint16_t i = handler_len; i < 25 + more_whitespace; i++) {\n            fprintf(stdout, \" \");\n          }\n        }\n\n        // codec, language\n        fprintf(stdout,\n                \"  %s  %s   %\" PRIu64,\n                uint32tochar4(track_info.track_codec, uint32_buffer),\n                track_info.unpacked_lang,\n                track_info.sample_aggregate);\n\n        if (track_info.encoder_name[0] != 0 && track_info.contains_esds) {\n          purge_extraneous_characters(track_info.encoder_name);\n          fprintf(stdout, \"   Encoder: %s\", track_info.encoder_name);\n        }\n        if (track_info.type_of_track & DRM_PROTECTED_TRACK) {\n          fprintf(stdout,\n                  \" (protected %s)\",\n                  uint32tochar4(track_info.protected_codec, uint32_buffer));\n        }\n\n        fprintf(stdout, \"\\n\");\n        /*---------------------------------*/\n\n        if (track_info.type_of_track & VIDEO_TRACK ||\n            track_info.type_of_track & AUDIO_TRACK) {\n          APar_Print_TrackDetails(&track_info);\n        }\n\n        if (optional_output & SHOW_DATE_INFO) {\n          fprintf(stdout,\n                  \"       Creation Date (UTC):     %s\\n\",\n                  APar_extract_UTC(track_info.creation_time));\n          fprintf(stdout,\n                  \"       Modification Date (UTC): %s\\n\",\n                  APar_extract_UTC(track_info.modified_time));\n        }\n      }\n    }\n  }\n}", "target": 3, "idx": 12004}
{"commit_id": "6e920ddc3cad2886ef07ca1a8e50e2a5c50986f7", "project": "wireshark", "func": "static void\nsteamdiscover_dissect_body_authrequest(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                                       gint offset, gint bytes_left)\n{\n    guint len;\n    gint64 value;\n    protobuf_desc_t pb = { tvb, offset, bytes_left };\n    protobuf_tag_t tag = { 0, 0, 0 };\n    guint8* devicename;\n    while (protobuf_iter_next(&pb, &tag)) {\n        switch(tag.field_number) {\n            case STEAMDISCOVER_FN_AUTHREQUEST_DEVICETOKEN:\n                STEAMDISCOVER_ENSURE_WIRETYPE(PROTOBUF_WIRETYPE_LENGTHDELIMITED);\n                value = get_varint64(pb.tvb, pb.offset, pb.bytes_left, &len);\n                proto_tree_add_item(tree, hf_steam_ihs_discovery_body_authrequest_devicetoken, pb.tvb,\n                        pb.offset+len, (gint)value, ENC_NA);\n                len += (gint)value;\n                break;\n            case STEAMDISCOVER_FN_AUTHREQUEST_DEVICENAME:\n                STEAMDISCOVER_ENSURE_WIRETYPE(PROTOBUF_WIRETYPE_LENGTHDELIMITED);\n                value = get_varint64(pb.tvb, pb.offset, pb.bytes_left, &len);\n                proto_tree_add_item(tree, hf_steam_ihs_discovery_body_authrequest_devicename, pb.tvb,\n                        pb.offset+len, (gint)value, ENC_UTF_8|ENC_NA);\n                devicename = tvb_get_string_enc(wmem_packet_scope(), pb.tvb, pb.offset+len, (gint)value, ENC_UTF_8);\n                if (devicename && strlen(devicename)) {\n                    col_append_fstr(pinfo->cinfo, COL_INFO, \" from %s\", devicename);\n                }\n                len += (gint)value;\n                break;\n            case STEAMDISCOVER_FN_AUTHREQUEST_ENCRYPTEDREQUEST:\n                STEAMDISCOVER_ENSURE_WIRETYPE(PROTOBUF_WIRETYPE_LENGTHDELIMITED);\n                value = get_varint64(pb.tvb, pb.offset, pb.bytes_left, &len);\n                proto_tree_add_item(tree, hf_steam_ihs_discovery_body_authrequest_encryptedrequest, pb.tvb,\n                        pb.offset+len, (gint)value, ENC_NA);\n                len += (gint)value;\n                break;\n            default:\n                len = protobuf_dissect_unknown_field(&pb, &tag, pinfo, tree, NULL);\n                break;\n        }\n        protobuf_seek_forward(&pb, len);\n    }\n}", "target": 2, "idx": 12005}
{"commit_id": "26f670a244982335cc08943fb1ec099a2c81e42d", "project": "qemu", "func": "static int ohci_service_iso_td(OHCIState *ohci, struct ohci_ed *ed,\n                               int completion)\n{\n    int dir;\n    size_t len = 0;\n    const char *str = NULL;\n    int pid;\n    int ret;\n    int i;\n    USBDevice *dev;\n    USBEndpoint *ep;\n    struct ohci_iso_td iso_td;\n    uint32_t addr;\n    uint16_t starting_frame;\n    int16_t relative_frame_number;\n    int frame_count;\n    uint32_t start_offset, next_offset, end_offset = 0;\n    uint32_t start_addr, end_addr;\n\n    addr = ed->head & OHCI_DPTR_MASK;\n\n    if (ohci_read_iso_td(ohci, addr, &iso_td)) {\n        trace_usb_ohci_iso_td_read_failed(addr);\n        ohci_die(ohci);\n        return 1;\n    }\n\n    starting_frame = OHCI_BM(iso_td.flags, TD_SF);\n    frame_count = OHCI_BM(iso_td.flags, TD_FC);\n    relative_frame_number = USUB(ohci->frame_number, starting_frame); \n\n    trace_usb_ohci_iso_td_head(\n           ed->head & OHCI_DPTR_MASK, ed->tail & OHCI_DPTR_MASK,\n           iso_td.flags, iso_td.bp, iso_td.next, iso_td.be,\n           ohci->frame_number, starting_frame,\n           frame_count, relative_frame_number);\n    trace_usb_ohci_iso_td_head_offset(\n           iso_td.offset[0], iso_td.offset[1],\n           iso_td.offset[2], iso_td.offset[3],\n           iso_td.offset[4], iso_td.offset[5],\n           iso_td.offset[6], iso_td.offset[7]);\n\n    if (relative_frame_number < 0) {\n        trace_usb_ohci_iso_td_relative_frame_number_neg(relative_frame_number);\n        return 1;\n    } else if (relative_frame_number > frame_count) {\n        /* ISO TD expired - retire the TD to the Done Queue and continue with\n           the next ISO TD of the same ED */\n        trace_usb_ohci_iso_td_relative_frame_number_big(relative_frame_number,\n                                                        frame_count);\n        OHCI_SET_BM(iso_td.flags, TD_CC, OHCI_CC_DATAOVERRUN);\n        ed->head &= ~OHCI_DPTR_MASK;\n        ed->head |= (iso_td.next & OHCI_DPTR_MASK);\n        iso_td.next = ohci->done;\n        ohci->done = addr;\n        i = OHCI_BM(iso_td.flags, TD_DI);\n        if (i < ohci->done_count)\n            ohci->done_count = i;\n        if (ohci_put_iso_td(ohci, addr, &iso_td)) {\n            ohci_die(ohci);\n            return 1;\n        }\n        return 0;\n    }\n\n    dir = OHCI_BM(ed->flags, ED_D);\n    switch (dir) {\n    case OHCI_TD_DIR_IN:\n        str = \"in\";\n        pid = USB_TOKEN_IN;\n        break;\n    case OHCI_TD_DIR_OUT:\n        str = \"out\";\n        pid = USB_TOKEN_OUT;\n        break;\n    case OHCI_TD_DIR_SETUP:\n        str = \"setup\";\n        pid = USB_TOKEN_SETUP;\n        break;\n    default:\n        trace_usb_ohci_iso_td_bad_direction(dir);\n        return 1;\n    }\n\n    if (!iso_td.bp || !iso_td.be) {\n        trace_usb_ohci_iso_td_bad_bp_be(iso_td.bp, iso_td.be);\n        return 1;\n    }\n\n    start_offset = iso_td.offset[relative_frame_number];\n    next_offset = iso_td.offset[relative_frame_number + 1];\n\n    if (!(OHCI_BM(start_offset, TD_PSW_CC) & 0xe) || \n        ((relative_frame_number < frame_count) && \n         !(OHCI_BM(next_offset, TD_PSW_CC) & 0xe))) {\n        trace_usb_ohci_iso_td_bad_cc_not_accessed(start_offset, next_offset);\n        return 1;\n    }\n\n    if ((relative_frame_number < frame_count) && (start_offset > next_offset)) {\n        trace_usb_ohci_iso_td_bad_cc_overrun(start_offset, next_offset);\n        return 1;\n    }\n\n    if ((start_offset & 0x1000) == 0) {\n        start_addr = (iso_td.bp & OHCI_PAGE_MASK) |\n            (start_offset & OHCI_OFFSET_MASK);\n    } else {\n        start_addr = (iso_td.be & OHCI_PAGE_MASK) |\n            (start_offset & OHCI_OFFSET_MASK);\n    }\n\n    if (relative_frame_number < frame_count) {\n        end_offset = next_offset - 1;\n        if ((end_offset & 0x1000) == 0) {\n            end_addr = (iso_td.bp & OHCI_PAGE_MASK) |\n                (end_offset & OHCI_OFFSET_MASK);\n        } else {\n            end_addr = (iso_td.be & OHCI_PAGE_MASK) |\n                (end_offset & OHCI_OFFSET_MASK);\n        }\n    } else {\n        /* Last packet in the ISO TD */\n        end_addr = iso_td.be;\n    }\n\n    if ((start_addr & OHCI_PAGE_MASK) != (end_addr & OHCI_PAGE_MASK)) {\n        len = (end_addr & OHCI_OFFSET_MASK) + 0x1001\n            - (start_addr & OHCI_OFFSET_MASK);\n    } else {\n        len = end_addr - start_addr + 1;\n    }\n\n    if (len && dir != OHCI_TD_DIR_IN) {\n        if (ohci_copy_iso_td(ohci, start_addr, end_addr, ohci->usb_buf, len,\n                             DMA_DIRECTION_TO_DEVICE)) {\n            ohci_die(ohci);\n            return 1;\n        }\n    }\n\n    if (!completion) {\n        bool int_req = relative_frame_number == frame_count &&\n                       OHCI_BM(iso_td.flags, TD_DI) == 0;\n        dev = ohci_find_device(ohci, OHCI_BM(ed->flags, ED_FA));\n        ep = usb_ep_get(dev, pid, OHCI_BM(ed->flags, ED_EN));\n        usb_packet_setup(&ohci->usb_packet, pid, ep, 0, addr, false, int_req);\n        usb_packet_addbuf(&ohci->usb_packet, ohci->usb_buf, len);\n        usb_handle_packet(dev, &ohci->usb_packet);\n        if (ohci->usb_packet.status == USB_RET_ASYNC) {\n            usb_device_flush_ep_queue(dev, ep);\n            return 1;\n        }\n    }\n    if (ohci->usb_packet.status == USB_RET_SUCCESS) {\n        ret = ohci->usb_packet.actual_length;\n    } else {\n        ret = ohci->usb_packet.status;\n    }\n\n    trace_usb_ohci_iso_td_so(start_offset, end_offset, start_addr, end_addr,\n                             str, len, ret);\n\n    /* Writeback */\n    if (dir == OHCI_TD_DIR_IN && ret >= 0 && ret <= len) {\n        /* IN transfer succeeded */\n        if (ohci_copy_iso_td(ohci, start_addr, end_addr, ohci->usb_buf, ret,\n                             DMA_DIRECTION_FROM_DEVICE)) {\n            ohci_die(ohci);\n            return 1;\n        }\n        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                    OHCI_CC_NOERROR);\n        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE, ret);\n    } else if (dir == OHCI_TD_DIR_OUT && ret == len) {\n        /* OUT transfer succeeded */\n        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                    OHCI_CC_NOERROR);\n        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE, 0);\n    } else {\n        if (ret > (ssize_t) len) {\n            trace_usb_ohci_iso_td_data_overrun(ret, len);\n            OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                        OHCI_CC_DATAOVERRUN);\n            OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE,\n                        len);\n        } else if (ret >= 0) {\n            trace_usb_ohci_iso_td_data_underrun(ret);\n            OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                        OHCI_CC_DATAUNDERRUN);\n        } else {\n            switch (ret) {\n            case USB_RET_IOERROR:\n            case USB_RET_NODEV:\n                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                            OHCI_CC_DEVICENOTRESPONDING);\n                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE,\n                            0);\n                break;\n            case USB_RET_NAK:\n            case USB_RET_STALL:\n                trace_usb_ohci_iso_td_nak(ret);\n                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                            OHCI_CC_STALL);\n                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE,\n                            0);\n                break;\n            default:\n                trace_usb_ohci_iso_td_bad_response(ret);\n                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                            OHCI_CC_UNDEXPETEDPID);\n                break;\n            }\n        }\n    }\n\n    if (relative_frame_number == frame_count) {\n        /* Last data packet of ISO TD - retire the TD to the Done Queue */\n        OHCI_SET_BM(iso_td.flags, TD_CC, OHCI_CC_NOERROR);\n        ed->head &= ~OHCI_DPTR_MASK;\n        ed->head |= (iso_td.next & OHCI_DPTR_MASK);\n        iso_td.next = ohci->done;\n        ohci->done = addr;\n        i = OHCI_BM(iso_td.flags, TD_DI);\n        if (i < ohci->done_count)\n            ohci->done_count = i;\n    }\n    if (ohci_put_iso_td(ohci, addr, &iso_td)) {\n        ohci_die(ohci);\n    }\n    return 1;\n}", "target": 1, "idx": 12006}
{"commit_id": "875a0095f37626a721c7ff57d606a0f95af03913", "project": "ArtifexSoftware/ghostpdl", "func": "static int\nzinitialize_dsc_parser(i_ctx_t *i_ctx_p)\n{\n    ref local_ref;\n    int code;\n    os_ptr const op = osp;\n    dict *pdict;\n    gs_memory_t *mem;\n    dsc_data_t *data;\n\n    check_read_type(*op, t_dictionary);\n\n    pdict = op->value.pdict;\n    mem = (gs_memory_t *)dict_memory(pdict);\n\n    data = gs_alloc_struct(mem, dsc_data_t, &st_dsc_data_t, \"DSC parser init\");\n    if (!data)\n        return_error(gs_error_VMerror);\n    data->document_level = 0;\n\n    data->dsc_data_ptr = dsc_init_with_alloc((void *) \"Ghostscript DSC parsing\",\n                           zDSC_memalloc, zDSC_memfree, (void *)mem->non_gc_memory);\n    if (!data->dsc_data_ptr)\n        return_error(gs_error_VMerror);\n    dsc_set_error_function(data->dsc_data_ptr, dsc_error_handler);\n    make_astruct(&local_ref, a_readonly | r_space(op), (byte *) data);\n    code = idict_put_string(op, dsc_dict_name, &local_ref);\n    if (code >= 0)\n        pop(1);\n    return code;\n}", "target": 3, "idx": 12007}
{"commit_id": "a2195644d89812e5b157ce7bac35543e06db05e3", "project": "lua", "func": "void luaV_execute (lua_State *L, CallInfo *ci) {\n  LClosure *cl;\n  TValue *k;\n  StkId base;\n  const Instruction *pc;\n  int trap;\n#if LUA_USE_JUMPTABLE\n#include \"ljumptab.h\"\n#endif\n tailcall:\n  trap = L->hookmask;\n  cl = clLvalue(s2v(ci->func));\n  k = cl->p->k;\n  pc = ci->u.l.savedpc;\n  if (trap) {\n    if (cl->p->is_vararg)\n      trap = 0;  /* hooks will start after VARARGPREP instruction */\n    else if (pc == cl->p->code)  /* first instruction (not resuming)? */\n      luaD_hookcall(L, ci);\n    ci->u.l.trap = 1;  /* there may be other hooks */\n  }\n  base = ci->func + 1;\n  /* main loop of interpreter */\n  for (;;) {\n    Instruction i;  /* instruction being executed */\n    StkId ra;  /* instruction's A register */\n    vmfetch();\n    lua_assert(base == ci->func + 1);\n    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);\n    /* invalidate top for instructions not expecting it */\n    lua_assert(isIT(i) || (cast_void(L->top = base), 1));\n    vmdispatch (GET_OPCODE(i)) {\n      vmcase(OP_MOVE) {\n        setobjs2s(L, ra, RB(i));\n        vmbreak;\n      }\n      vmcase(OP_LOADI) {\n        lua_Integer b = GETARG_sBx(i);\n        setivalue(s2v(ra), b);\n        vmbreak;\n      }\n      vmcase(OP_LOADF) {\n        int b = GETARG_sBx(i);\n        setfltvalue(s2v(ra), cast_num(b));\n        vmbreak;\n      }\n      vmcase(OP_LOADK) {\n        TValue *rb = k + GETARG_Bx(i);\n        setobj2s(L, ra, rb);\n        vmbreak;\n      }\n      vmcase(OP_LOADKX) {\n        TValue *rb;\n        rb = k + GETARG_Ax(*pc); pc++;\n        setobj2s(L, ra, rb);\n        vmbreak;\n      }\n      vmcase(OP_LOADFALSE) {\n        setbfvalue(s2v(ra));\n        vmbreak;\n      }\n      vmcase(OP_LFALSESKIP) {\n        setbfvalue(s2v(ra));\n        pc++;  /* skip next instruction */\n        vmbreak;\n      }\n      vmcase(OP_LOADTRUE) {\n        setbtvalue(s2v(ra));\n        vmbreak;\n      }\n      vmcase(OP_LOADNIL) {\n        int b = GETARG_B(i);\n        do {\n          setnilvalue(s2v(ra++));\n        } while (b--);\n        vmbreak;\n      }\n      vmcase(OP_GETUPVAL) {\n        int b = GETARG_B(i);\n        setobj2s(L, ra, cl->upvals[b]->v);\n        vmbreak;\n      }\n      vmcase(OP_SETUPVAL) {\n        UpVal *uv = cl->upvals[GETARG_B(i)];\n        setobj(L, uv->v, s2v(ra));\n        luaC_barrier(L, uv, s2v(ra));\n        vmbreak;\n      }\n      vmcase(OP_GETTABUP) {\n        const TValue *slot;\n        TValue *upval = cl->upvals[GETARG_B(i)]->v;\n        TValue *rc = KC(i);\n        TString *key = tsvalue(rc);  /* key must be a string */\n        if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {\n          setobj2s(L, ra, slot);\n        }\n        else\n          Protect(luaV_finishget(L, upval, rc, ra, slot));\n        vmbreak;\n      }\n      vmcase(OP_GETTABLE) {\n        const TValue *slot;\n        TValue *rb = vRB(i);\n        TValue *rc = vRC(i);\n        lua_Unsigned n;\n        if (ttisinteger(rc)  /* fast track for integers? */\n            ? (cast_void(n = ivalue(rc)), luaV_fastgeti(L, rb, n, slot))\n            : luaV_fastget(L, rb, rc, slot, luaH_get)) {\n          setobj2s(L, ra, slot);\n        }\n        else\n          Protect(luaV_finishget(L, rb, rc, ra, slot));\n        vmbreak;\n      }\n      vmcase(OP_GETI) {\n        const TValue *slot;\n        TValue *rb = vRB(i);\n        int c = GETARG_C(i);\n        if (luaV_fastgeti(L, rb, c, slot)) {\n          setobj2s(L, ra, slot);\n        }\n        else {\n          TValue key;\n          setivalue(&key, c);\n          Protect(luaV_finishget(L, rb, &key, ra, slot));\n        }\n        vmbreak;\n      }\n      vmcase(OP_GETFIELD) {\n        const TValue *slot;\n        TValue *rb = vRB(i);\n        TValue *rc = KC(i);\n        TString *key = tsvalue(rc);  /* key must be a string */\n        if (luaV_fastget(L, rb, key, slot, luaH_getshortstr)) {\n          setobj2s(L, ra, slot);\n        }\n        else\n          Protect(luaV_finishget(L, rb, rc, ra, slot));\n        vmbreak;\n      }\n      vmcase(OP_SETTABUP) {\n        const TValue *slot;\n        TValue *upval = cl->upvals[GETARG_A(i)]->v;\n        TValue *rb = KB(i);\n        TValue *rc = RKC(i);\n        TString *key = tsvalue(rb);  /* key must be a string */\n        if (luaV_fastget(L, upval, key, slot, luaH_getshortstr)) {\n          luaV_finishfastset(L, upval, slot, rc);\n        }\n        else\n          Protect(luaV_finishset(L, upval, rb, rc, slot));\n        vmbreak;\n      }\n      vmcase(OP_SETTABLE) {\n        const TValue *slot;\n        TValue *rb = vRB(i);  /* key (table is in 'ra') */\n        TValue *rc = RKC(i);  /* value */\n        lua_Unsigned n;\n        if (ttisinteger(rb)  /* fast track for integers? */\n            ? (cast_void(n = ivalue(rb)), luaV_fastgeti(L, s2v(ra), n, slot))\n            : luaV_fastget(L, s2v(ra), rb, slot, luaH_get)) {\n          luaV_finishfastset(L, s2v(ra), slot, rc);\n        }\n        else\n          Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));\n        vmbreak;\n      }\n      vmcase(OP_SETI) {\n        const TValue *slot;\n        int c = GETARG_B(i);\n        TValue *rc = RKC(i);\n        if (luaV_fastgeti(L, s2v(ra), c, slot)) {\n          luaV_finishfastset(L, s2v(ra), slot, rc);\n        }\n        else {\n          TValue key;\n          setivalue(&key, c);\n          Protect(luaV_finishset(L, s2v(ra), &key, rc, slot));\n        }\n        vmbreak;\n      }\n      vmcase(OP_SETFIELD) {\n        const TValue *slot;\n        TValue *rb = KB(i);\n        TValue *rc = RKC(i);\n        TString *key = tsvalue(rb);  /* key must be a string */\n        if (luaV_fastget(L, s2v(ra), key, slot, luaH_getshortstr)) {\n          luaV_finishfastset(L, s2v(ra), slot, rc);\n        }\n        else\n          Protect(luaV_finishset(L, s2v(ra), rb, rc, slot));\n        vmbreak;\n      }\n      vmcase(OP_NEWTABLE) {\n        int b = GETARG_B(i);  /* log2(hash size) + 1 */\n        int c = GETARG_C(i);  /* array size */\n        Table *t;\n        if (b > 0)\n          b = 1 << (b - 1);  /* size is 2^(b - 1) */\n        lua_assert((!TESTARG_k(i)) == (GETARG_Ax(*pc) == 0));\n        if (TESTARG_k(i))  /* non-zero extra argument? */\n          c += GETARG_Ax(*pc) * (MAXARG_C + 1);  /* add it to size */\n        pc++;  /* skip extra argument */\n        L->top = ra + 1;  /* correct top in case of emergency GC */\n        t = luaH_new(L);  /* memory allocation */\n        sethvalue2s(L, ra, t);\n        if (b != 0 || c != 0)\n          luaH_resize(L, t, c, b);  /* idem */\n        checkGC(L, ra + 1);\n        vmbreak;\n      }\n      vmcase(OP_SELF) {\n        const TValue *slot;\n        TValue *rb = vRB(i);\n        TValue *rc = RKC(i);\n        TString *key = tsvalue(rc);  /* key must be a string */\n        setobj2s(L, ra + 1, rb);\n        if (luaV_fastget(L, rb, key, slot, luaH_getstr)) {\n          setobj2s(L, ra, slot);\n        }\n        else\n          Protect(luaV_finishget(L, rb, rc, ra, slot));\n        vmbreak;\n      }\n      vmcase(OP_ADDI) {\n        op_arithI(L, l_addi, luai_numadd);\n        vmbreak;\n      }\n      vmcase(OP_ADDK) {\n        op_arithK(L, l_addi, luai_numadd);\n        vmbreak;\n      }\n      vmcase(OP_SUBK) {\n        op_arithK(L, l_subi, luai_numsub);\n        vmbreak;\n      }\n      vmcase(OP_MULK) {\n        op_arithK(L, l_muli, luai_nummul);\n        vmbreak;\n      }\n      vmcase(OP_MODK) {\n        op_arithK(L, luaV_mod, luaV_modf);\n        vmbreak;\n      }\n      vmcase(OP_POWK) {\n        op_arithfK(L, luai_numpow);\n        vmbreak;\n      }\n      vmcase(OP_DIVK) {\n        op_arithfK(L, luai_numdiv);\n        vmbreak;\n      }\n      vmcase(OP_IDIVK) {\n        op_arithK(L, luaV_idiv, luai_numidiv);\n        vmbreak;\n      }\n      vmcase(OP_BANDK) {\n        op_bitwiseK(L, l_band);\n        vmbreak;\n      }\n      vmcase(OP_BORK) {\n        op_bitwiseK(L, l_bor);\n        vmbreak;\n      }\n      vmcase(OP_BXORK) {\n        op_bitwiseK(L, l_bxor);\n        vmbreak;\n      }\n      vmcase(OP_SHRI) {\n        TValue *rb = vRB(i);\n        int ic = GETARG_sC(i);\n        lua_Integer ib;\n        if (tointegerns(rb, &ib)) {\n          pc++; setivalue(s2v(ra), luaV_shiftl(ib, -ic));\n        }\n        vmbreak;\n      }\n      vmcase(OP_SHLI) {\n        TValue *rb = vRB(i);\n        int ic = GETARG_sC(i);\n        lua_Integer ib;\n        if (tointegerns(rb, &ib)) {\n          pc++; setivalue(s2v(ra), luaV_shiftl(ic, ib));\n        }\n        vmbreak;\n      }\n      vmcase(OP_ADD) {\n        op_arith(L, l_addi, luai_numadd);\n        vmbreak;\n      }\n      vmcase(OP_SUB) {\n        op_arith(L, l_subi, luai_numsub);\n        vmbreak;\n      }\n      vmcase(OP_MUL) {\n        op_arith(L, l_muli, luai_nummul);\n        vmbreak;\n      }\n      vmcase(OP_MOD) {\n        op_arith(L, luaV_mod, luaV_modf);\n        vmbreak;\n      }\n      vmcase(OP_POW) {\n        op_arithf(L, luai_numpow);\n        vmbreak;\n      }\n      vmcase(OP_DIV) {  /* float division (always with floats) */\n        op_arithf(L, luai_numdiv);\n        vmbreak;\n      }\n      vmcase(OP_IDIV) {  /* floor division */\n        op_arith(L, luaV_idiv, luai_numidiv);\n        vmbreak;\n      }\n      vmcase(OP_BAND) {\n        op_bitwise(L, l_band);\n        vmbreak;\n      }\n      vmcase(OP_BOR) {\n        op_bitwise(L, l_bor);\n        vmbreak;\n      }\n      vmcase(OP_BXOR) {\n        op_bitwise(L, l_bxor);\n        vmbreak;\n      }\n      vmcase(OP_SHR) {\n        op_bitwise(L, luaV_shiftr);\n        vmbreak;\n      }\n      vmcase(OP_SHL) {\n        op_bitwise(L, luaV_shiftl);\n        vmbreak;\n      }\n      vmcase(OP_MMBIN) {\n        Instruction pi = *(pc - 2);  /* original arith. expression */\n        TValue *rb = vRB(i);\n        TMS tm = (TMS)GETARG_C(i);\n        StkId result = RA(pi);\n        lua_assert(OP_ADD <= GET_OPCODE(pi) && GET_OPCODE(pi) <= OP_SHR);\n        Protect(luaT_trybinTM(L, s2v(ra), rb, result, tm));\n        vmbreak;\n      }\n      vmcase(OP_MMBINI) {\n        Instruction pi = *(pc - 2);  /* original arith. expression */\n        int imm = GETARG_sB(i);\n        TMS tm = (TMS)GETARG_C(i);\n        int flip = GETARG_k(i);\n        StkId result = RA(pi);\n        Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));\n        vmbreak;\n      }\n      vmcase(OP_MMBINK) {\n        Instruction pi = *(pc - 2);  /* original arith. expression */\n        TValue *imm = KB(i);\n        TMS tm = (TMS)GETARG_C(i);\n        int flip = GETARG_k(i);\n        StkId result = RA(pi);\n        Protect(luaT_trybinassocTM(L, s2v(ra), imm, flip, result, tm));\n        vmbreak;\n      }\n      vmcase(OP_UNM) {\n        TValue *rb = vRB(i);\n        lua_Number nb;\n        if (ttisinteger(rb)) {\n          lua_Integer ib = ivalue(rb);\n          setivalue(s2v(ra), intop(-, 0, ib));\n        }\n        else if (tonumberns(rb, nb)) {\n          setfltvalue(s2v(ra), luai_numunm(L, nb));\n        }\n        else\n          Protect(luaT_trybinTM(L, rb, rb, ra, TM_UNM));\n        vmbreak;\n      }\n      vmcase(OP_BNOT) {\n        TValue *rb = vRB(i);\n        lua_Integer ib;\n        if (tointegerns(rb, &ib)) {\n          setivalue(s2v(ra), intop(^, ~l_castS2U(0), ib));\n        }\n        else\n          Protect(luaT_trybinTM(L, rb, rb, ra, TM_BNOT));\n        vmbreak;\n      }\n      vmcase(OP_NOT) {\n        TValue *rb = vRB(i);\n        if (l_isfalse(rb))\n          setbtvalue(s2v(ra));\n        else\n          setbfvalue(s2v(ra));\n        vmbreak;\n      }\n      vmcase(OP_LEN) {\n        Protect(luaV_objlen(L, ra, vRB(i)));\n        vmbreak;\n      }\n      vmcase(OP_CONCAT) {\n        int n = GETARG_B(i);  /* number of elements to concatenate */\n        L->top = ra + n;  /* mark the end of concat operands */\n        ProtectNT(luaV_concat(L, n));\n        checkGC(L, L->top); /* 'luaV_concat' ensures correct top */\n        vmbreak;\n      }\n      vmcase(OP_CLOSE) {\n        Protect(luaF_close(L, ra, LUA_OK));\n        vmbreak;\n      }\n      vmcase(OP_TBC) {\n        /* create new to-be-closed upvalue */\n        halfProtect(luaF_newtbcupval(L, ra));\n        vmbreak;\n      }\n      vmcase(OP_JMP) {\n        dojump(ci, i, 0);\n        vmbreak;\n      }\n      vmcase(OP_EQ) {\n        int cond;\n        TValue *rb = vRB(i);\n        Protect(cond = luaV_equalobj(L, s2v(ra), rb));\n        docondjump();\n        vmbreak;\n      }\n      vmcase(OP_LT) {\n        op_order(L, l_lti, LTnum, lessthanothers);\n        vmbreak;\n      }\n      vmcase(OP_LE) {\n        op_order(L, l_lei, LEnum, lessequalothers);\n        vmbreak;\n      }\n      vmcase(OP_EQK) {\n        TValue *rb = KB(i);\n        /* basic types do not use '__eq'; we can use raw equality */\n        int cond = luaV_rawequalobj(s2v(ra), rb);\n        docondjump();\n        vmbreak;\n      }\n      vmcase(OP_EQI) {\n        int cond;\n        int im = GETARG_sB(i);\n        if (ttisinteger(s2v(ra)))\n          cond = (ivalue(s2v(ra)) == im);\n        else if (ttisfloat(s2v(ra)))\n          cond = luai_numeq(fltvalue(s2v(ra)), cast_num(im));\n        else\n          cond = 0;  /* other types cannot be equal to a number */\n        docondjump();\n        vmbreak;\n      }\n      vmcase(OP_LTI) {\n        op_orderI(L, l_lti, luai_numlt, 0, TM_LT);\n        vmbreak;\n      }\n      vmcase(OP_LEI) {\n        op_orderI(L, l_lei, luai_numle, 0, TM_LE);\n        vmbreak;\n      }\n      vmcase(OP_GTI) {\n        op_orderI(L, l_gti, luai_numgt, 1, TM_LT);\n        vmbreak;\n      }\n      vmcase(OP_GEI) {\n        op_orderI(L, l_gei, luai_numge, 1, TM_LE);\n        vmbreak;\n      }\n      vmcase(OP_TEST) {\n        int cond = !l_isfalse(s2v(ra));\n        docondjump();\n        vmbreak;\n      }\n      vmcase(OP_TESTSET) {\n        TValue *rb = vRB(i);\n        if (l_isfalse(rb) == GETARG_k(i))\n          pc++;\n        else {\n          setobj2s(L, ra, rb);\n          donextjump(ci);\n        }\n        vmbreak;\n      }\n      vmcase(OP_CALL) {\n        int b = GETARG_B(i);\n        int nresults = GETARG_C(i) - 1;\n        if (b != 0)  /* fixed number of arguments? */\n          L->top = ra + b;  /* top signals number of arguments */\n        /* else previous instruction set top */\n        ProtectNT(luaD_call(L, ra, nresults));\n        vmbreak;\n      }\n      vmcase(OP_TAILCALL) {\n        int b = GETARG_B(i);  /* number of arguments + 1 (function) */\n        int nparams1 = GETARG_C(i);\n        /* delat is virtual 'func' - real 'func' (vararg functions) */\n        int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;\n        if (b != 0)\n          L->top = ra + b;\n        else  /* previous instruction set top */\n          b = cast_int(L->top - ra);\n        savepc(ci);  /* some calls here can raise errors */\n        if (TESTARG_k(i)) {\n          /* close upvalues from current call; the compiler ensures\n             that there are no to-be-closed variables here, so this\n             call cannot change the stack */\n          luaF_close(L, base, NOCLOSINGMETH);\n          lua_assert(base == ci->func + 1);\n        }\n        while (!ttisfunction(s2v(ra))) {  /* not a function? */\n          luaD_tryfuncTM(L, ra);  /* try '__call' metamethod */\n          b++;  /* there is now one extra argument */\n          checkstackGCp(L, 1, ra);\n        }\n        if (!ttisLclosure(s2v(ra))) {  /* C function? */\n          luaD_call(L, ra, LUA_MULTRET);  /* call it */\n          updatetrap(ci);\n          updatestack(ci);  /* stack may have been relocated */\n          ci->func -= delta;\n          luaD_poscall(L, ci, cast_int(L->top - ra));\n          return;\n        }\n        ci->func -= delta;\n        luaD_pretailcall(L, ci, ra, b);  /* prepare call frame */\n        goto tailcall;\n      }\n      vmcase(OP_RETURN) {\n        int n = GETARG_B(i) - 1;  /* number of results */\n        int nparams1 = GETARG_C(i);\n        if (n < 0)  /* not fixed? */\n          n = cast_int(L->top - ra);  /* get what is available */\n        savepc(ci);\n        if (TESTARG_k(i)) {  /* may there be open upvalues? */\n          if (L->top < ci->top)\n            L->top = ci->top;\n          luaF_close(L, base, LUA_OK);\n          updatetrap(ci);\n          updatestack(ci);\n        }\n        if (nparams1)  /* vararg function? */\n          ci->func -= ci->u.l.nextraargs + nparams1;\n        L->top = ra + n;  /* set call for 'luaD_poscall' */\n        luaD_poscall(L, ci, n);\n        return;\n      }\n      vmcase(OP_RETURN0) {\n        if (L->hookmask) {\n          L->top = ra;\n          halfProtectNT(luaD_poscall(L, ci, 0));  /* no hurry... */\n        }\n        else {  /* do the 'poscall' here */\n          int nres = ci->nresults;\n          L->ci = ci->previous;  /* back to caller */\n          L->top = base - 1;\n          while (nres-- > 0)\n            setnilvalue(s2v(L->top++));  /* all results are nil */\n        }\n        return;\n      }\n      vmcase(OP_RETURN1) {\n        if (L->hookmask) {\n          L->top = ra + 1;\n          halfProtectNT(luaD_poscall(L, ci, 1));  /* no hurry... */\n        }\n        else {  /* do the 'poscall' here */\n          int nres = ci->nresults;\n          L->ci = ci->previous;  /* back to caller */\n          if (nres == 0)\n            L->top = base - 1;  /* asked for no results */\n          else {\n            setobjs2s(L, base - 1, ra);  /* at least this result */\n            L->top = base;\n            while (--nres > 0)  /* complete missing results */\n              setnilvalue(s2v(L->top++));\n          }\n        }\n        return;\n      }\n      vmcase(OP_FORLOOP) {\n        if (ttisinteger(s2v(ra + 2))) {  /* integer loop? */\n          lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));\n          if (count > 0) {  /* still more iterations? */\n            lua_Integer step = ivalue(s2v(ra + 2));\n            lua_Integer idx = ivalue(s2v(ra));  /* internal index */\n            chgivalue(s2v(ra + 1), count - 1);  /* update counter */\n            idx = intop(+, idx, step);  /* add step to index */\n            chgivalue(s2v(ra), idx);  /* update internal index */\n            setivalue(s2v(ra + 3), idx);  /* and control variable */\n            pc -= GETARG_Bx(i);  /* jump back */\n          }\n        }\n        else if (floatforloop(ra))  /* float loop */\n          pc -= GETARG_Bx(i);  /* jump back */\n        updatetrap(ci);  /* allows a signal to break the loop */\n        vmbreak;\n      }\n      vmcase(OP_FORPREP) {\n        savestate(L, ci);  /* in case of errors */\n        if (forprep(L, ra))\n          pc += GETARG_Bx(i) + 1;  /* skip the loop */\n        vmbreak;\n      }\n      vmcase(OP_TFORPREP) {\n        /* create to-be-closed upvalue (if needed) */\n        halfProtect(luaF_newtbcupval(L, ra + 3));\n        pc += GETARG_Bx(i);\n        i = *(pc++);  /* go to next instruction */\n        lua_assert(GET_OPCODE(i) == OP_TFORCALL && ra == RA(i));\n        goto l_tforcall;\n      }\n      vmcase(OP_TFORCALL) {\n       l_tforcall:\n        /* 'ra' has the iterator function, 'ra + 1' has the state,\n           'ra + 2' has the control variable, and 'ra + 3' has the\n           to-be-closed variable. The call will use the stack after\n           these values (starting at 'ra + 4')\n        */\n        /* push function, state, and control variable */\n        memcpy(ra + 4, ra, 3 * sizeof(*ra));\n        L->top = ra + 4 + 3;\n        ProtectNT(luaD_call(L, ra + 4, GETARG_C(i)));  /* do the call */\n        updatestack(ci);  /* stack may have changed */\n        i = *(pc++);  /* go to next instruction */\n        lua_assert(GET_OPCODE(i) == OP_TFORLOOP && ra == RA(i));\n        goto l_tforloop;\n      }\n      vmcase(OP_TFORLOOP) {\n        l_tforloop:\n        if (!ttisnil(s2v(ra + 4))) {  /* continue loop? */\n          setobjs2s(L, ra + 2, ra + 4);  /* save control variable */\n          pc -= GETARG_Bx(i);  /* jump back */\n        }\n        vmbreak;\n      }\n      vmcase(OP_SETLIST) {\n        int n = GETARG_B(i);\n        unsigned int last = GETARG_C(i);\n        Table *h = hvalue(s2v(ra));\n        if (n == 0)\n          n = cast_int(L->top - ra) - 1;  /* get up to the top */\n        else\n          L->top = ci->top;  /* correct top in case of emergency GC */\n        last += n;\n        if (TESTARG_k(i)) {\n          last += GETARG_Ax(*pc) * (MAXARG_C + 1);\n          pc++;\n        }\n        if (last > luaH_realasize(h))  /* needs more space? */\n          luaH_resizearray(L, h, last);  /* preallocate it at once */\n        for (; n > 0; n--) {\n          TValue *val = s2v(ra + n);\n          setobj2t(L, &h->array[last - 1], val);\n          last--;\n          luaC_barrierback(L, obj2gco(h), val);\n        }\n        vmbreak;\n      }\n      vmcase(OP_CLOSURE) {\n        Proto *p = cl->p->p[GETARG_Bx(i)];\n        halfProtect(pushclosure(L, p, cl->upvals, base, ra));\n        checkGC(L, ra + 1);\n        vmbreak;\n      }\n      vmcase(OP_VARARG) {\n        int n = GETARG_C(i) - 1;  /* required results */\n        Protect(luaT_getvarargs(L, ci, ra, n));\n        vmbreak;\n      }\n      vmcase(OP_VARARGPREP) {\n        ProtectNT(luaT_adjustvarargs(L, GETARG_A(i), ci, cl->p));\n        if (trap) {\n          luaD_hookcall(L, ci);\n          L->oldpc = 1;  /* next opcode will be seen as a \"new\" line */\n        }\n        updatebase(ci);  /* function has new base after adjustment */\n        vmbreak;\n      }\n      vmcase(OP_EXTRAARG) {\n        lua_assert(0);\n        vmbreak;\n      }\n    }\n  }\n}", "target": 1, "idx": 12008}
{"commit_id": "00d965474b22b54e4275232bc71ee0c699c5cd21", "project": "openssl", "func": "static int aes_ccm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)\n{\n    EVP_AES_CCM_CTX *cctx = EVP_C_DATA(EVP_AES_CCM_CTX,c);\n    switch (type) {\n    case EVP_CTRL_INIT:\n        cctx->key_set = 0;\n        cctx->iv_set = 0;\n        cctx->L = 8;\n        cctx->M = 12;\n        cctx->tag_set = 0;\n        cctx->len_set = 0;\n        cctx->tls_aad_len = -1;\n        return 1;\n\n    case EVP_CTRL_AEAD_TLS1_AAD:\n        /* Save the AAD for later use */\n        if (arg != EVP_AEAD_TLS1_AAD_LEN)\n            return 0;\n        memcpy(EVP_CIPHER_CTX_buf_noconst(c), ptr, arg);\n        cctx->tls_aad_len = arg;\n        {\n            uint16_t len =\n                EVP_CIPHER_CTX_buf_noconst(c)[arg - 2] << 8\n                | EVP_CIPHER_CTX_buf_noconst(c)[arg - 1];\n            /* Correct length for explicit IV */\n            if (len < EVP_CCM_TLS_EXPLICIT_IV_LEN)\n                return 0;\n            len -= EVP_CCM_TLS_EXPLICIT_IV_LEN;\n            /* If decrypting correct for tag too */\n            if (!EVP_CIPHER_CTX_encrypting(c)) {\n                if (len < cctx->M)\n                    return 0;\n                len -= cctx->M;\n            }\n            EVP_CIPHER_CTX_buf_noconst(c)[arg - 2] = len >> 8;\n            EVP_CIPHER_CTX_buf_noconst(c)[arg - 1] = len & 0xff;\n        }\n        /* Extra padding: tag appended to record */\n        return cctx->M;\n\n    case EVP_CTRL_CCM_SET_IV_FIXED:\n        /* Sanity check length */\n        if (arg != EVP_CCM_TLS_FIXED_IV_LEN)\n            return 0;\n        /* Just copy to first part of IV */\n        memcpy(EVP_CIPHER_CTX_iv_noconst(c), ptr, arg);\n        return 1;\n\n    case EVP_CTRL_AEAD_SET_IVLEN:\n        arg = 15 - arg;\n    case EVP_CTRL_CCM_SET_L:\n        if (arg < 2 || arg > 8)\n            return 0;\n        cctx->L = arg;\n        return 1;\n\n    case EVP_CTRL_AEAD_SET_TAG:\n        if ((arg & 1) || arg < 4 || arg > 16)\n            return 0;\n        if (EVP_CIPHER_CTX_encrypting(c) && ptr)\n            return 0;\n        if (ptr) {\n            cctx->tag_set = 1;\n            memcpy(EVP_CIPHER_CTX_buf_noconst(c), ptr, arg);\n        }\n        cctx->M = arg;\n        return 1;\n\n    case EVP_CTRL_AEAD_GET_TAG:\n        if (!EVP_CIPHER_CTX_encrypting(c) || !cctx->tag_set)\n            return 0;\n        if (!CRYPTO_ccm128_tag(&cctx->ccm, ptr, (size_t)arg))\n            return 0;\n        cctx->tag_set = 0;\n        cctx->iv_set = 0;\n        cctx->len_set = 0;\n        return 1;\n\n    case EVP_CTRL_COPY:\n        {\n            EVP_CIPHER_CTX *out = ptr;\n            EVP_AES_CCM_CTX *cctx_out = EVP_C_DATA(EVP_AES_CCM_CTX,out);\n            if (cctx->ccm.key) {\n                if (cctx->ccm.key != &cctx->ks)\n                    return 0;\n                cctx_out->ccm.key = &cctx_out->ks;\n            }\n            return 1;\n        }\n\n    default:\n        return -1;\n\n    }\n}", "target": 2, "idx": 12009}
{"commit_id": "233affe3fcdc851fa82cb058871bddd0046e1c87", "project": "leozide/leocad", "func": "lcStartupMode lcApplication::Initialize(const QList<QPair<QString, bool>>& LibraryPaths)\n{\n\tlcCommandLineOptions Options = ParseCommandLineOptions();\n\tQTextStream StdErr(stderr, QIODevice::WriteOnly);\n\tQTextStream StdOut(stdout, QIODevice::WriteOnly);\n\n\tif (!Options.StdErr.isEmpty())\n\t{\n\t\tStdErr << Options.StdErr;\n\t\tStdErr.flush();\n\t}\n\n\tif (!Options.StdOut.isEmpty())\n\t{\n\t\tStdOut << Options.StdOut;\n\t\tStdOut.flush();\n\t}\n\n\tif (!Options.ParseOK)\n\t\treturn lcStartupMode::Error;\n\n\tif (Options.Exit)\n\t\treturn lcStartupMode::Success;\n\n\tif (!lcContext::InitializeRenderer())\n\t{\n\t\tStdErr << tr(\"Error creating OpenGL context.\\n\");\n\t\treturn lcStartupMode::Error;\n\t}\n\n\tconst bool SaveAndExit = (Options.SaveImage || Options.SaveWavefront || Options.Save3DS || Options.SaveCOLLADA || Options.SaveHTML);\n\n\tif (!SaveAndExit)\n\t{\n\t\tUpdateStyle();\n\n\t\tgMainWindow = new lcMainWindow();\n\n\t\tlcLoadDefaultKeyboardShortcuts();\n\t\tlcLoadDefaultMouseShortcuts();\n\t}\n\n\tif (!LoadPartsLibrary(Options.LibraryPaths.isEmpty() ? LibraryPaths : Options.LibraryPaths, !Options.LibraryPaths.isEmpty()))\n\t{\n\t\tQString Message;\n\n\t\tif (mLibrary->LoadBuiltinPieces())\n\t\t\tMessage = tr(\"LeoCAD could not find a compatible Parts Library so only a small number of parts will be available.\\n\\nPlease visit https://www.leocad.org for information on how to download and install a library.\");\n\t\telse\n\t\t\tMessage = tr(\"LeoCAD could not load Parts Library.\\n\\nPlease visit https://www.leocad.org for information on how to download and install a library.\");\n\n\t\tif (gMainWindow)\n\t\t\tQMessageBox::information(gMainWindow, tr(\"LeoCAD\"), Message);\n\t\telse\n\t\t{\n\t\t\tStdErr << Message << \"\\n\";\n\t\t\tStdErr.flush();\n\t\t}\n\t}\n\n\tmPreferences.mShadingMode = Options.ShadingMode;\n\tmPreferences.mLineWidth = Options.LineWidth;\n\tmPreferences.mStudCylinderColor = Options.StudCylinderColor;\n\tmPreferences.mPartEdgeColor = Options.PartEdgeColor;\n\tmPreferences.mBlackEdgeColor = Options.BlackEdgeColor;\n\tmPreferences.mDarkEdgeColor = Options.DarkEdgeColor;\n\tmPreferences.mPartEdgeContrast = Options.PartEdgeContrast;\n\tmPreferences.mPartColorValueLDIndex = Options.PartColorValueLDIndex;\n\tmPreferences.mAutomateEdgeColor = Options.AutomateEdgeColor;\n\n\tlcGetPiecesLibrary()->SetStudStyle(Options.StudStyle, false);\n\n\tif (!SaveAndExit)\n\t\tgMainWindow->CreateWidgets();\n\n\tProject* NewProject = new Project();\n\tSetProject(NewProject);\n\n\tif (!SaveAndExit && Options.ProjectName.isEmpty() && lcGetProfileInt(LC_PROFILE_AUTOLOAD_MOSTRECENT))\n\t\tOptions.ProjectName = lcGetProfileString(LC_PROFILE_RECENT_FILE1);\n\n\tbool ProjectLoaded = false;\n\n\tif (!Options.ProjectName.isEmpty())\n\t{\n\t\tif (gMainWindow)\n\t\t\tgMainWindow->OpenProject(Options.ProjectName);\n\t\telse\n\t\t{\n\t\t\tProject* LoadedProject = new Project();\n\n\t\t\tif (LoadedProject->Load(Options.ProjectName))\n\t\t\t{\n\t\t\t\tSetProject(LoadedProject);\n\t\t\t\tProjectLoaded = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdelete LoadedProject;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ProjectLoaded)\n\t{\n\t\tif (!Options.ModelName.isEmpty())\n\t\t\tmProject->SetActiveModel(Options.ModelName);\n\n\t\tstd::unique_ptr<lcView> ActiveView;\n\n\t\tif (Options.SaveImage)\n\t\t{\n\t\t\tlcModel* Model;\n\n\t\t\tif (!Options.ModelName.isEmpty())\n\t\t\t{\n\t\t\t\tModel = mProject->GetModel(Options.ModelName);\n\n\t\t\t\tif (!Model)\n\t\t\t\t{\n\t\t\t\t\tStdErr << tr(\"Error: model '%1' does not exist.\\n\").arg(Options.ModelName);\n\t\t\t\t\treturn lcStartupMode::Error;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tModel = mProject->GetMainModel();\n\n\t\t\tActiveView = std::unique_ptr<lcView>(new lcView(lcViewType::View, Model));\n\n\t\t\tActiveView->SetOffscreenContext();\n\t\t\tActiveView->MakeCurrent();\n\t\t}\n\n\t\tif (Options.SaveImage)\n\t\t\tActiveView->SetSize(Options.ImageWidth, Options.ImageHeight);\n\n\t\tif (ActiveView)\n\t\t{\n\t\t\tif (!Options.CameraName.isEmpty())\n\t\t\t\tActiveView->SetCamera(Options.CameraName);\n\t\t\telse\n\t\t\t{\n\t\t\t\tActiveView->SetProjection(Options.Orthographic);\n\n\t\t\t\tif (Options.SetFoV)\n\t\t\t\t\tActiveView->GetCamera()->m_fovy = Options.FoV;\n\n\t\t\t\tif (Options.SetZPlanes)\n\t\t\t\t{\n\t\t\t\t\tlcCamera* Camera = ActiveView->GetCamera();\n\n\t\t\t\t\tCamera->m_zNear = Options.ZPlanes[0];\n\t\t\t\t\tCamera->m_zFar = Options.ZPlanes[1];\n\t\t\t\t}\n\n\t\t\t\tif (Options.Viewpoint != lcViewpoint::Count)\n\t\t\t\t\tActiveView->SetViewpoint(Options.Viewpoint);\n\t\t\t\telse if (Options.SetCameraAngles)\n\t\t\t\t\tActiveView->SetCameraAngles(Options.CameraLatLon[0], Options.CameraLatLon[1]);\n\t\t\t\telse if (Options.SetCameraPosition)\n\t\t\t\t\tActiveView->SetViewpoint(Options.CameraPosition[0], Options.CameraPosition[1], Options.CameraPosition[2]);\n\t\t\t}\n\t\t}\n\n\t\tif (Options.SaveImage)\n\t\t{\n\t\t\tlcModel* ActiveModel = ActiveView->GetModel();\n\n\t\t\tif (Options.ImageName.isEmpty())\n\t\t\t\tOptions.ImageName = mProject->GetImageFileName(true);\n\n\t\t\tif (Options.ImageEnd < Options.ImageStart)\n\t\t\t\tOptions.ImageEnd = Options.ImageStart;\n\t\t\telse if (Options.ImageStart > Options.ImageEnd)\n\t\t\t\tOptions.ImageStart = Options.ImageEnd;\n\n\t\t\tif ((Options.ImageStart == 0) && (Options.ImageEnd == 0))\n\t\t\t\tOptions.ImageStart = Options.ImageEnd = ActiveModel->GetCurrentStep();\n\t\t\telse if ((Options.ImageStart == 0) && (Options.ImageEnd != 0))\n\t\t\t\tOptions.ImageStart = Options.ImageEnd;\n\t\t\telse if ((Options.ImageStart != 0) && (Options.ImageEnd == 0))\n\t\t\t\tOptions.ImageEnd = Options.ImageStart;\n\n\t\t\tif (Options.ImageStart > 255)\n\t\t\t\tOptions.ImageStart = 255;\n\n\t\t\tif (Options.ImageEnd > 255)\n\t\t\t\tOptions.ImageEnd = 255;\n\n\t\t\tQString Frame;\n\n\t\t\tif (Options.ImageStart != Options.ImageEnd)\n\t\t\t{\n\t\t\t\tQString Extension = QFileInfo(Options.ImageName).suffix();\n\t\t\t\tFrame = Options.ImageName.left(Options.ImageName.length() - Extension.length() - 1) + QLatin1String(\"%1.\") + Extension;\n\t\t\t}\n\t\t\telse\n\t\t\t\tFrame = Options.ImageName;\n\n\t\t\tmPreferences.mFadeSteps = Options.FadeSteps;\n\t\t\tif (Options.SetFadeStepsColor)\n\t\t\t\tmPreferences.mFadeStepsColor = Options.FadeStepsColor;\n\t\t\tmPreferences.mHighlightNewParts = Options.ImageHighlight;\n\t\t\tif (Options.SetHighlightColor)\n\t\t\t\tmPreferences.mHighlightNewPartsColor = Options.HighlightColor;\n\n\t\t\tif (Options.CameraName.isEmpty() && !Options.SetCameraPosition)\n\t\t\t\tActiveView->ZoomExtents();\n\n\t\t\tauto ProgressCallback = [&StdOut](const QString& FileName)\n\t\t\t{\n\t\t\t\tStdOut << tr(\"Saved '%1'.\\n\").arg(FileName);\n\t\t\t};\n\n\t\t\tActiveView->SaveStepImages(Frame, Options.ImageStart != Options.ImageEnd, Options.ImageStart, Options.ImageEnd, ProgressCallback);\n\t\t}\n\n\t\tif (Options.SaveWavefront)\n\t\t{\n\t\t\tQString FileName;\n\n\t\t\tif (!Options.SaveWavefrontName.isEmpty())\n\t\t\t\tFileName = Options.SaveWavefrontName;\n\t\t\telse\n\t\t\t\tFileName = Options.ProjectName;\n\n\t\t\tQString Extension = QFileInfo(FileName).suffix().toLower();\n\n\t\t\tif (Extension.isEmpty())\n\t\t\t{\n\t\t\t\tFileName += \".obj\";\n\t\t\t}\n\t\t\telse if (Extension != \"obj\")\n\t\t\t{\n\t\t\t\tFileName = FileName.left(FileName.length() - Extension.length() - 1);\n\t\t\t\tFileName += \".obj\";\n\t\t\t}\n\n\t\t\tif (mProject->ExportWavefront(FileName))\n\t\t\t\tStdOut << tr(\"Saved '%1'.\\n\").arg(FileName);\n\t\t}\n\n\t\tif (Options.Save3DS)\n\t\t{\n\t\t\tQString FileName;\n\n\t\t\tif (!Options.Save3DSName.isEmpty())\n\t\t\t\tFileName = Options.Save3DSName;\n\t\t\telse\n\t\t\t\tFileName = Options.ProjectName;\n\n\t\t\tQString Extension = QFileInfo(FileName).suffix().toLower();\n\n\t\t\tif (Extension.isEmpty())\n\t\t\t{\n\t\t\t\tFileName += \".3ds\";\n\t\t\t}\n\t\t\telse if (Extension != \"3ds\")\n\t\t\t{\n\t\t\t\tFileName = FileName.left(FileName.length() - Extension.length() - 1);\n\t\t\t\tFileName += \".3ds\";\n\t\t\t}\n\n\t\t\tif (mProject->Export3DStudio(FileName))\n\t\t\t\tStdOut << tr(\"Saved '%1'.\\n\").arg(FileName);\n\t\t}\n\n\t\tif (Options.SaveCOLLADA)\n\t\t{\n\t\t\tQString FileName;\n\n\t\t\tif (!Options.SaveCOLLADAName.isEmpty())\n\t\t\t\tFileName = Options.SaveCOLLADAName;\n\t\t\telse\n\t\t\t\tFileName = Options.ProjectName;\n\n\t\t\tQString Extension = QFileInfo(FileName).suffix().toLower();\n\n\t\t\tif (Extension.isEmpty())\n\t\t\t{\n\t\t\t\tFileName += \".dae\";\n\t\t\t}\n\t\t\telse if (Extension != \"dae\")\n\t\t\t{\n\t\t\t\tFileName = FileName.left(FileName.length() - Extension.length() - 1);\n\t\t\t\tFileName += \".dae\";\n\t\t\t}\n\n\t\t\tif (mProject->ExportCOLLADA(FileName))\n\t\t\t\tStdOut << tr(\"Saved '%1'.\\n\").arg(FileName);\n\t\t}\n\n\t\tif (Options.SaveHTML)\n\t\t{\n\t\t\tlcHTMLExportOptions HTMLOptions(mProject);\n\n\t\t\tif (!Options.SaveHTMLName.isEmpty())\n\t\t\t\tHTMLOptions.PathName = Options.SaveHTMLName;\n\n\t\t\tmProject->ExportHTML(HTMLOptions);\n\t\t}\n\t}\n\n\tif (!SaveAndExit)\n\t{\n\t\tgMainWindow->SetColorIndex(lcGetColorIndex(7));\n\t\tgMainWindow->GetPartSelectionWidget()->SetDefaultPart();\n\t\tgMainWindow->UpdateRecentFiles();\n\t\tgMainWindow->show();\n\t}\n\n\treturn SaveAndExit ? lcStartupMode::Success : lcStartupMode::ShowWindow;\n}", "target": 1, "idx": 12010}
{"commit_id": "0ff832d31470471803b175cfff4e40c1b08ee779", "project": "aawc/unrar", "func": "void Archive::Seek(int64 Offset,int Method)\n{\n#ifdef USE_QOPEN\n  if (QOpen.Seek(Offset,Method))\n    return;\n#endif\n#ifdef USE_ARCMEM\n  if (ArcMem.Seek(Offset,Method))\n    return;\n#endif\n  File::Seek(Offset,Method);\n}", "target": 2, "idx": 12011}
{"commit_id": "2096bc1e5078732543e0a3ee115a2ce520a72bbc", "project": "wireshark", "func": "static int register_interfaces(extcap_parameters * extcap_conf, const char *adb_server_ip, unsigned short *adb_server_tcp_port) {\n    static char            packet[PACKET_LENGTH];\n    static char            helpful_packet[PACKET_LENGTH];\n    char                  *response;\n    char                  *device_list;\n    gssize                 data_length;\n    gssize                 device_length;\n    socket_handle_t        sock;\n    const char            *adb_transport_serial_templace = \"%04x\"\"host:transport:%s\";\n    const char            *adb_check_port_templace       = \"%04x\"\"shell:cat /proc/%s/net/tcp\";\n    const char            *adb_devices            = \"000E\"\"host:devices-l\";\n    const char            *adb_api_level          = \"0022\"\"shell:getprop ro.build.version.sdk\";\n    const char            *adb_hcidump_version    = \"0017\"\"shell:hcidump --version\";\n    const char            *adb_ps_droid_bluetooth = \"0018\"\"shell:ps droid.bluetooth\";\n    const char            *adb_ps_bluetooth_app   = \"001E\"\"shell:ps com.android.bluetooth\";\n    const char            *adb_tcpdump_help       = \"0010\"\"shell:tcpdump -h\";\n    char                   serial_number[SERIAL_NUMBER_LENGTH_MAX];\n    size_t                 serial_number_length;\n    char                   model_name[MODEL_NAME_LENGTH_MAX];\n    int                    result;\n    char                  *pos;\n    char                  *i_pos;\n    char                  *model_pos;\n    char                  *device_pos;\n    char                  *prev_pos;\n    int                    api_level;\n    int                    disable_interface;\n\n/* NOTE: It seems that \"adb devices\" and \"adb shell\" closed connection\n         so cannot send next command after them, there is need to reconnect */\n\n    sock = adb_connect(adb_server_ip, adb_server_tcp_port);\n    if (sock == INVALID_SOCKET)\n        return EXIT_CODE_INVALID_SOCKET_INTERFACES_LIST;\n\n    device_list = adb_send_and_receive(sock, adb_devices, packet, sizeof(packet), &device_length);\n    closesocket(sock);\n\n    if (!device_list) {\n        errmsg_print(\"ERROR: Cannot get list of interfaces from devices\");\n\n        return EXIT_CODE_CANNOT_GET_INTERFACES_LIST;\n    }\n\n    device_list[device_length] = '\\0';\n    pos = (char *) device_list;\n\n    while (pos < (char *) (device_list + device_length)) {\n        prev_pos = pos;\n        pos = strchr(pos, ' ');\n        i_pos = pos;\n        result = (int) (pos - prev_pos);\n        pos = strchr(pos, '\\n') + 1;\n        if (result >= (int) sizeof(serial_number)) {\n            verbose_print(\"WARNING: Serial number too long, ignore device\\n\");\n            continue;\n        }\n        memcpy(serial_number, prev_pos, result);\n        serial_number[result] = '\\0';\n        serial_number_length = strlen(serial_number);\n\n        model_name[0] = '\\0';\n        model_pos = g_strstr_len(i_pos, pos - i_pos, \"model:\");\n        if (model_pos) {\n            device_pos = g_strstr_len(i_pos, pos - i_pos, \"device:\");\n            if (device_pos && device_pos - model_pos - 6 - 1 < MODEL_NAME_LENGTH_MAX) {\n                memcpy(model_name, model_pos + 6, device_pos - model_pos - 6 - 1);\n                model_name[device_pos - model_pos - 6 - 1] = '\\0';\n            }\n        }\n\n        if (model_name[0] == '\\0')\n            strcpy(model_name, \"unknown\");\n\n        verbose_print(\"VERBOSE: Processing device: \\\"%s\\\" <%s>\\n\" , serial_number, model_name);\n\n        /* Check for the presence of tcpdump in the android device. */\n\n        sock = adb_connect(adb_server_ip, adb_server_tcp_port);\n        if (sock == INVALID_SOCKET) continue;\n\n        result = g_snprintf((char *) helpful_packet, PACKET_LENGTH, adb_transport_serial_templace, 15 + serial_number_length, serial_number);\n        if (result <= 0 || result > PACKET_LENGTH) {\n            errmsg_print(\"ERROR: Error while completing adb packet for transport\");\n            closesocket(sock);\n            return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_1;\n        }\n\n        result = adb_send(sock, helpful_packet);\n        if (result) {\n            verbose_print(\"WARNING: Error while setting adb transport for <%s>\\n\", helpful_packet);\n            closesocket(sock);\n        } else {\n            response = adb_send_and_read(sock, adb_tcpdump_help, helpful_packet, sizeof(helpful_packet), &data_length);\n            closesocket(sock);\n\n            if (response) {\n                response[data_length] = '\\0';\n\n                /* If tcpdump is found in the android device, add Android Wifi Tcpdump as an interface  */\n                if (strstr(response,\"tcpdump version\")) {\n                    new_interface(extcap_conf, INTERFACE_ANDROID_WIFI_TCPDUMP, model_name, serial_number, \"Android WiFi\");\n                }\n            } else {\n                verbose_print(\"WARNING: Error on socket: <%s>\\n\", helpful_packet);\n            }\n        }\n\n        sock = adb_connect(adb_server_ip, adb_server_tcp_port);\n        if (sock == INVALID_SOCKET) continue;\n\n        result = g_snprintf((char *) helpful_packet, PACKET_LENGTH, adb_transport_serial_templace, 15 + serial_number_length, serial_number);\n        if (result <= 0 || result > PACKET_LENGTH) {\n            errmsg_print(\"ERROR: Error while completing adb packet\");\n            closesocket(sock);\n            return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_2;\n        }\n\n        result = adb_send(sock, helpful_packet);\n        if (result) {\n            verbose_print(\"WARNING: Error while setting adb transport for <%s>\\n\", helpful_packet);\n            closesocket(sock);\n            continue;\n        }\n\n        response = adb_send_and_read(sock, adb_api_level, helpful_packet, sizeof(helpful_packet), &data_length);\n        closesocket(sock);\n\n        if (!response) {\n            verbose_print(\"WARNING: Error on socket: <%s>\\n\", helpful_packet);\n            continue;\n        }\n\n        response[data_length] = '\\0';\n        api_level = (int) g_ascii_strtoll(response, NULL, 10);\n        verbose_print(\"VERBOSE: Android API Level for %s is %i\\n\", serial_number, api_level);\n\n        if (api_level < 21) {\n            new_interface(extcap_conf, INTERFACE_ANDROID_LOGCAT_MAIN,   model_name, serial_number, \"Android Logcat Main\");\n            new_interface(extcap_conf, INTERFACE_ANDROID_LOGCAT_SYSTEM, model_name, serial_number, \"Android Logcat System\");\n            new_interface(extcap_conf, INTERFACE_ANDROID_LOGCAT_RADIO,  model_name, serial_number, \"Android Logcat Radio\");\n            new_interface(extcap_conf, INTERFACE_ANDROID_LOGCAT_EVENTS, model_name, serial_number, \"Android Logcat Events\");\n        } else {\n            new_interface(extcap_conf, INTERFACE_ANDROID_LOGCAT_TEXT_MAIN,   model_name, serial_number, \"Android Logcat Main\");\n            new_interface(extcap_conf, INTERFACE_ANDROID_LOGCAT_TEXT_SYSTEM, model_name, serial_number, \"Android Logcat System\");\n            new_interface(extcap_conf, INTERFACE_ANDROID_LOGCAT_TEXT_RADIO,  model_name, serial_number, \"Android Logcat Radio\");\n            new_interface(extcap_conf, INTERFACE_ANDROID_LOGCAT_TEXT_EVENTS, model_name, serial_number, \"Android Logcat Events\");\n            new_interface(extcap_conf, INTERFACE_ANDROID_LOGCAT_TEXT_CRASH,  model_name, serial_number, \"Android Logcat Crash\");\n        }\n\n        if (api_level >= 5 && api_level < 17) {\n            disable_interface = 0;\n\n            sock = adb_connect(adb_server_ip, adb_server_tcp_port);\n            if (sock == INVALID_SOCKET) continue;\n\n            result = g_snprintf((char *) helpful_packet, PACKET_LENGTH, adb_transport_serial_templace, 15 + serial_number_length, serial_number);\n            if (result <= 0 || result > PACKET_LENGTH) {\n                errmsg_print(\"ERROR: Error while completing adb packet\");\n                closesocket(sock);\n                return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_3;\n            }\n\n            result = adb_send(sock, helpful_packet);\n            if (result) {\n                errmsg_print(\"ERROR: Error while setting adb transport for <%s>\", helpful_packet);\n                closesocket(sock);\n                return EXIT_CODE_GENERIC;\n            }\n\n            response = adb_send_and_read(sock, adb_hcidump_version, helpful_packet, sizeof(helpful_packet), &data_length);\n            closesocket(sock);\n            if (!response || data_length < 1) {\n                verbose_print(\"WARNING: Error while getting hcidump version by <%s> (%p len=%\"G_GSSIZE_FORMAT\")\\n\",\n                    adb_hcidump_version, (void*)response, data_length);\n                verbose_print(\"VERBOSE: Android hcidump version for %s is unknown\\n\", serial_number);\n                disable_interface = 1;\n            } else {\n                response[data_length] = '\\0';\n\n                if (g_ascii_strtoull(response, NULL, 10) == 0) {\n                    verbose_print(\"VERBOSE: Android hcidump version for %s is unknown\\n\", serial_number);\n                    disable_interface = 1;\n                } else {\n                    verbose_print(\"VERBOSE: Android hcidump version for %s is %s\\n\", serial_number, response);\n                }\n            }\n\n            if (!disable_interface) {\n                new_interface(extcap_conf, INTERFACE_ANDROID_BLUETOOTH_HCIDUMP, model_name, serial_number, \"Android Bluetooth Hcidump\");\n            }\n        }\n\n        if (api_level >= 17 && api_level < 21) {\n            disable_interface = 0;\n            sock = adb_connect(adb_server_ip, adb_server_tcp_port);\n            if (sock == INVALID_SOCKET) continue;\n\n            result = g_snprintf((char *) helpful_packet, PACKET_LENGTH, adb_transport_serial_templace, 15 + serial_number_length, serial_number);\n            if (result <= 0 || result > PACKET_LENGTH) {\n                errmsg_print(\"ERROR: Error while completing adb packet\");\n                closesocket(sock);\n                return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_4;\n            }\n\n            result = adb_send(sock, helpful_packet);\n            if (result) {\n                errmsg_print(\"ERROR: Error while setting adb transport for <%s>\", helpful_packet);\n                closesocket(sock);\n                return EXIT_CODE_GENERIC;\n            }\n\n            response = adb_send_and_read(sock, adb_ps_droid_bluetooth, helpful_packet, sizeof(helpful_packet), &data_length);\n            closesocket(sock);\n            if (!response || data_length < 1) {\n                verbose_print(\"WARNING: Error while getting Bluetooth application process id by <%s> \"\n                    \"(%p len=%\"G_GSSIZE_FORMAT\")\\n\", adb_hcidump_version, (void*)response, data_length);\n                verbose_print( \"VERBOSE: Android Bluetooth application PID for %s is unknown\\n\", serial_number);\n                disable_interface = 1;\n            } else {\n                char  *data_str;\n                char   pid[16];\n\n                memset(pid, 0, sizeof(pid));\n                response[data_length] = '\\0';\n\n                data_str = strchr(response, '\\n');\n                if (data_str && sscanf(data_str, \"%*s %15s\", pid) == 1) {\n                    verbose_print(\"VERBOSE: Android Bluetooth application PID for %s is %s\\n\", serial_number, pid);\n\n                    sock = adb_connect(adb_server_ip, adb_server_tcp_port);\n                    if (sock == INVALID_SOCKET)\n                        return EXIT_CODE_INVALID_SOCKET_1;\n\n                    result = g_snprintf((char *) helpful_packet, PACKET_LENGTH, adb_transport_serial_templace, 15 + serial_number_length, serial_number);\n                    if (result <= 0 || result > PACKET_LENGTH) {\n                        errmsg_print(\"ERROR: Error while completing adb packet\");\n                        closesocket(sock);\n                        return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_5;\n                    }\n\n                    result = adb_send(sock, helpful_packet);\n                    if (result) {\n                        errmsg_print(\"ERROR: Error while setting adb transport for <%s>\", helpful_packet);\n                        closesocket(sock);\n                        return EXIT_CODE_GENERIC;\n                    }\n\n                    result = g_snprintf((char *) helpful_packet, PACKET_LENGTH, adb_check_port_templace, strlen(adb_check_port_templace) - 6 + strlen(pid), pid);\n                    if (result <= 0 || result > PACKET_LENGTH) {\n                        errmsg_print(\"ERROR: Error while completing adb packet\");\n                        closesocket(sock);\n                        return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_6;\n                    }\n\n                    response = adb_send_and_read(sock, helpful_packet, helpful_packet, sizeof(helpful_packet), &data_length);\n                    closesocket(sock);\n\n                    if (!response) {\n                        disable_interface = 1;\n                    } else {\n                        response[data_length] = '\\0';\n\n                        data_str = strchr(response, '\\n');\n                        if (data_str && sscanf(data_str, \"%*s %15s\", pid) == 1 && strlen(pid) > 10 && strcmp(pid + 9, \"10EA\") == 0) {\n                            verbose_print(\"VERBOSE: Bluedroid External Parser Port for %s is %s\\n\", serial_number, pid + 9);\n                        } else {\n                            disable_interface = 1;\n                            verbose_print(\"VERBOSE: Bluedroid External Parser Port for %s is unknown\\n\", serial_number);\n                        }\n                    }\n                } else {\n                    disable_interface = 1;\n                    verbose_print(\"VERBOSE: Android Bluetooth application PID for %s is unknown\\n\", serial_number);\n                }\n            }\n\n            if (!disable_interface) {\n                new_interface(extcap_conf, INTERFACE_ANDROID_BLUETOOTH_EXTERNAL_PARSER, model_name, serial_number, \"Android Bluetooth External Parser\");\n            }\n        }\n\n        if (api_level >= 21) {\n            disable_interface = 0;\n            sock = adb_connect(adb_server_ip, adb_server_tcp_port);\n            if (sock == INVALID_SOCKET) continue;\n\n            result = g_snprintf((char *) helpful_packet, PACKET_LENGTH, adb_transport_serial_templace, 15 + serial_number_length, serial_number);\n            if (result <= 0 || result > PACKET_LENGTH) {\n                errmsg_print(\"ERROR: Error while completing adb packet\");\n                closesocket(sock);\n                return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_7;\n            }\n\n            result = adb_send(sock, helpful_packet);\n            if (result) {\n                errmsg_print(\"ERROR: Error while setting adb transport for <%s>\", helpful_packet);\n                closesocket(sock);\n                return EXIT_CODE_GENERIC;\n            }\n\n            if (api_level >= 23) {\n                response = adb_send_and_read(sock, adb_ps_bluetooth_app, helpful_packet, sizeof(helpful_packet), &data_length);\n            }  else\n                response = adb_send_and_read(sock, adb_ps_droid_bluetooth, helpful_packet, sizeof(helpful_packet), &data_length);\n            closesocket(sock);\n            if (!response || data_length < 1) {\n                verbose_print(\"WARNING: Error while getting Bluetooth application process id by <%s> \"\n                    \"(%p len=%\"G_GSSIZE_FORMAT\")\\n\", adb_hcidump_version, (void*)response, data_length);\n                verbose_print(\"VERBOSE: Android Bluetooth application PID for %s is unknown\\n\", serial_number);\n                disable_interface = 1;\n            } else {\n                char  *data_str;\n                char   pid[16];\n\n                memset(pid, 0, sizeof(pid));\n                response[data_length] = '\\0';\n\n                data_str = strchr(response, '\\n');\n                if (data_str && sscanf(data_str, \"%*s %15s\", pid) == 1) {\n                    verbose_print(\"VERBOSE: Android Bluetooth application PID for %s is %s\\n\", serial_number, pid);\n\n                    sock = adb_connect(adb_server_ip, adb_server_tcp_port);\n                    if (sock == INVALID_SOCKET)\n                        return EXIT_CODE_INVALID_SOCKET_2;\n\n                    result = g_snprintf((char *) helpful_packet, PACKET_LENGTH, adb_transport_serial_templace, 15 + serial_number_length, serial_number);\n                    if (result <= 0 || result > PACKET_LENGTH) {\n                        errmsg_print(\"ERROR: Error while completing adb packet\");\n                        closesocket(sock);\n                        return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_8;\n                    }\n\n                    result = adb_send(sock, helpful_packet);\n                    if (result) {\n                        errmsg_print(\"ERROR: Error while setting adb transport for <%s>\", helpful_packet);\n                        closesocket(sock);\n                        return EXIT_CODE_GENERIC;\n                    }\n\n                    result = g_snprintf((char *) helpful_packet, PACKET_LENGTH, adb_check_port_templace, strlen(adb_check_port_templace) - 6 + strlen(pid), pid);\n                    if (result <= 0 || result > PACKET_LENGTH) {\n                        errmsg_print(\"ERROR: Error while completing adb packet\");\n                        closesocket(sock);\n                        return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_9;\n                    }\n\n                    response = adb_send_and_read(sock, helpful_packet, helpful_packet, sizeof(helpful_packet), &data_length);\n                    closesocket(sock);\n\n                    if (!response) {\n                        disable_interface = 1;\n                    } else {\n                        response[data_length] = '\\0';\n\n                        data_str = strchr(response, '\\n');\n                        if (data_str && sscanf(data_str, \"%*s %15s\", pid) == 1 && strlen(pid) > 10 && strcmp(pid + 9, \"22A8\") == 0) {\n                            verbose_print(\"VERBOSE: Btsnoop Net Port for %s is %s\\n\", serial_number, pid + 9);\n                        } else {\n                            disable_interface = 1;\n                            verbose_print(\"VERBOSE: Btsnoop Net Port for %s is unknown\\n\", serial_number);\n                        }\n                    }\n                } else {\n                    disable_interface = 1;\n                    verbose_print(\"VERBOSE: Android Bluetooth application PID for %s is unknown\\n\", serial_number);\n                }\n            }\n\n            if (!disable_interface) {\n                new_interface(extcap_conf, INTERFACE_ANDROID_BLUETOOTH_BTSNOOP_NET, model_name, serial_number, \"Android Bluetooth Btsnoop Net\");\n            }\n        }\n    }\n\n    return EXIT_CODE_SUCCESS;\n}", "target": 2, "idx": 12012}
{"commit_id": "c509265c5f6ae7264f7b8a8aae1cfa5fc59d108c", "project": "kkos/oniguruma", "func": "static int\ncompile_bag_node(BagNode* node, regex_t* reg, ScanEnv* env)\n{\n  int r, len;\n\n  switch (node->type) {\n  case BAG_MEMORY:\n    r = compile_bag_memory_node(node, reg, env);\n    break;\n\n  case BAG_OPTION:\n    r = compile_option_node(node, reg, env);\n    break;\n\n  case BAG_STOP_BACKTRACK:\n    if (NODE_IS_STOP_BT_SIMPLE_REPEAT(node)) {\n      QuantNode* qn = QUANT_(NODE_BAG_BODY(node));\n      r = compile_tree_n_times(NODE_QUANT_BODY(qn), qn->lower, reg, env);\n      if (r != 0) return r;\n\n      len = compile_length_tree(NODE_QUANT_BODY(qn), reg);\n      if (len < 0) return len;\n\n      r = add_op(reg, OP_PUSH);\n      if (r != 0) return r;\n      COP(reg)->push.addr = SIZE_INC_OP + len + SIZE_OP_POP_OUT + SIZE_OP_JUMP;\n\n      r = compile_tree(NODE_QUANT_BODY(qn), reg, env);\n      if (r != 0) return r;\n      r = add_op(reg, OP_POP_OUT);\n      if (r != 0) return r;\n\n      r = add_op(reg, OP_JUMP);\n      if (r != 0) return r;\n      COP(reg)->jump.addr = -((int )SIZE_OP_PUSH + len + (int )SIZE_OP_POP_OUT);\n    }\n    else {\n      r = add_op(reg, OP_ATOMIC_START);\n      if (r != 0) return r;\n      r = compile_tree(NODE_BAG_BODY(node), reg, env);\n      if (r != 0) return r;\n      r = add_op(reg, OP_ATOMIC_END);\n    }\n    break;\n\n  case BAG_IF_ELSE:\n    {\n      int cond_len, then_len, else_len, jump_len;\n      Node* cond = NODE_BAG_BODY(node);\n      Node* Then = node->te.Then;\n      Node* Else = node->te.Else;\n\n      r = add_op(reg, OP_ATOMIC_START);\n      if (r != 0) return r;\n\n      cond_len = compile_length_tree(cond, reg);\n      if (cond_len < 0) return cond_len;\n      if (IS_NOT_NULL(Then)) {\n        then_len = compile_length_tree(Then, reg);\n        if (then_len < 0) return then_len;\n      }\n      else\n        then_len = 0;\n\n      jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END + SIZE_OP_JUMP;\n\n      r = add_op(reg, OP_PUSH);\n      if (r != 0) return r;\n      COP(reg)->push.addr = SIZE_INC_OP + jump_len;\n\n      r = compile_tree(cond, reg, env);\n      if (r != 0) return r;\n      r = add_op(reg, OP_ATOMIC_END);\n      if (r != 0) return r;\n\n      if (IS_NOT_NULL(Then)) {\n        r = compile_tree(Then, reg, env);\n        if (r != 0) return r;\n      }\n\n      if (IS_NOT_NULL(Else)) {\n        else_len = compile_length_tree(Else, reg);\n        if (else_len < 0) return else_len;\n      }\n      else\n        else_len = 0;\n\n      r = add_op(reg, OP_JUMP);\n      if (r != 0) return r;\n      COP(reg)->jump.addr = SIZE_OP_ATOMIC_END + else_len + SIZE_INC_OP;\n\n      r = add_op(reg, OP_ATOMIC_END);\n      if (r != 0) return r;\n\n      if (IS_NOT_NULL(Else)) {\n        r = compile_tree(Else, reg, env);\n      }\n    }\n    break;\n  }\n\n  return r;\n}", "target": 1, "idx": 12013}
{"commit_id": "d5f95aa066f878b0aef6a64e60b61e8626e664cd", "project": "pjsip/pjproject", "func": "static void ssl_reset_sock_state(pj_ssl_sock_t *ssock)\n{\n    ossl_sock_t *ossock = (ossl_sock_t *)ssock;\n\n    /* Detach from SSL instance */\n    if (ossock->ossl_ssl) {\n\tSSL_set_ex_data(ossock->ossl_ssl, sslsock_idx, NULL);\n    }\n\n    /**\n     * Avoid calling SSL_shutdown() if handshake wasn't completed.\n     * OpenSSL 1.0.2f complains if SSL_shutdown() is called during an\n     * SSL handshake, while previous versions always return 0.\n     */\n    if (ossock->ossl_ssl && SSL_in_init(ossock->ossl_ssl) == 0) {\n\tint ret = SSL_shutdown(ossock->ossl_ssl);\n\tif (ret == 0) {\n\t    /* Flush data to send close notify. */\n\t    flush_circ_buf_output(ssock, &ssock->shutdown_op_key, 0, 0);\n\t}\n    }\n\n    pj_lock_acquire(ssock->write_mutex);\n    ssock->ssl_state = SSL_STATE_NULL;\n    pj_lock_release(ssock->write_mutex);\n\n    ssl_close_sockets(ssock);\n\n    /* Upon error, OpenSSL may leave any error description in the thread \n     * error queue, which sometime may cause next call to SSL API returning\n     * false error alarm, e.g: in Linux, SSL_CTX_use_certificate_chain_file()\n     * returning false error after a handshake error (in different SSL_CTX!).\n     * For now, just clear thread error queue here.\n     */\n    ERR_clear_error();\n}", "target": 1, "idx": 12014}
{"commit_id": "eccc170053e46b4ab1d9e7485c09e210be15bbd7", "project": "xen-project/xen", "func": "static inline void wrgsbase(unsigned long base)\n{\n    if ( read_cr4() & X86_CR4_FSGSBASE )\n#ifdef HAVE_AS_FSGSBASE\n        asm volatile ( \"wrgsbase %0\" :: \"r\" (base) );\n#else\n        asm volatile ( \".byte 0xf3, 0x48, 0x0f, 0xae, 0xd8\" :: \"a\" (base) );\n#endif\n    else\n        wrmsrl(MSR_GS_BASE, base);\n}", "target": 2, "idx": 12015}
{"commit_id": "f05c3b91f9571210b86576ee6284e71a3306109d", "project": "wireshark", "func": "void\nproto_register_vlan(void)\n{\n#ifndef HAVE_HFI_SECTION_INIT\n  static header_field_info *hfi[] = {\n    &hfi_vlan_priority,\n    &hfi_vlan_cfi,\n    &hfi_vlan_id,\n    &hfi_vlan_id_name,\n    &hfi_vlan_etype,\n    &hfi_vlan_len,\n    &hfi_vlan_trailer,\n  };\n#endif /* HAVE_HFI_SECTION_INIT */\n\n  static gint *ett[] = {\n    &ett_vlan\n  };\n\n  static ei_register_info ei[] = {\n     { &ei_vlan_len, { \"vlan.len.past_end\", PI_MALFORMED, PI_ERROR, \"Length field value goes past the end of the payload\", EXPFILL }},\n     { &ei_vlan_too_many_tags, { \"vlan.too_many_tags\", PI_UNDECODED, PI_WARN, \"Too many nested VLAN tags\", EXPFILL }},\n  };\n\n  module_t *vlan_module;\n  expert_module_t* expert_vlan;\n\n  proto_vlan = proto_register_protocol(\"802.1Q Virtual LAN\", \"VLAN\", \"vlan\");\n  hfi_vlan = proto_registrar_get_nth(proto_vlan);\n\n  proto_register_fields(proto_vlan, hfi, array_length(hfi));\n  proto_register_subtree_array(ett, array_length(ett));\n  expert_vlan = expert_register_protocol(proto_vlan);\n  expert_register_field_array(expert_vlan, ei, array_length(ei));\n\n  vlan_module = prefs_register_protocol(proto_vlan, proto_reg_handoff_vlan);\n  prefs_register_bool_preference(vlan_module, \"summary_in_tree\",\n        \"Show vlan summary in protocol tree\",\n        \"Whether the vlan summary line should be shown in the protocol tree\",\n        &vlan_summary_in_tree);\n  prefs_register_uint_preference(vlan_module, \"qinq_ethertype\",\n        \"802.1QinQ Ethertype (in hex)\",\n        \"The (hexadecimal) Ethertype used to indicate 802.1QinQ VLAN in VLAN tunneling.\",\n        16, &q_in_q_ethertype);\n\n  vlan_handle = create_dissector_handle(dissect_vlan, proto_vlan);\n}", "target": 2, "idx": 12016}
{"commit_id": "f9308839198aca5e68a65194f151a1de92398f54", "project": "Exiv2/exiv2", "func": "void Jp2Image::encodeJp2Header(const DataBuf& boxBuf,DataBuf& outBuf)\n    {\n        DataBuf output(boxBuf.size_ + iccProfile_.size_ + 100); // allocate sufficient space\n        long    outlen = sizeof(Jp2BoxHeader) ; // now many bytes have we written to output?\n        long    inlen = sizeof(Jp2BoxHeader) ; // how many bytes have we read from boxBuf?\n        Jp2BoxHeader* pBox   = (Jp2BoxHeader*) boxBuf.pData_;\n        uint32_t      length = getLong((byte*)&pBox->length, bigEndian);\n        uint32_t      count  = sizeof (Jp2BoxHeader);\n        char*         p      = (char*) boxBuf.pData_;\n        bool          bWroteColor = false ;\n\n        while ( count < length || !bWroteColor ) {\n            Jp2BoxHeader* pSubBox = (Jp2BoxHeader*) (p+count) ;\n\n            // copy data.  pointer could be into a memory mapped file which we will decode!\n            Jp2BoxHeader   subBox ; memcpy(&subBox,pSubBox,sizeof(subBox));\n            Jp2BoxHeader   newBox =  subBox;\n\n            if ( count < length ) {\n                subBox.length = getLong((byte*)&subBox.length, bigEndian);\n                subBox.type   = getLong((byte*)&subBox.type  , bigEndian);\n#ifdef EXIV2_DEBUG_MESSAGES\n                std::cout << \"Jp2Image::encodeJp2Header subbox: \"<< toAscii(subBox.type) << \" length = \" << subBox.length << std::endl;\n#endif\n                enforce(subBox.length <= length - count, Exiv2::kerCorruptedMetadata);\n                count        += subBox.length;\n                newBox.type   = subBox.type;\n            } else {\n                subBox.length=0;\n                newBox.type = kJp2BoxTypeColorHeader;\n                count = length;\n            }\n\n            uint32_t newlen = subBox.length;\n            if ( newBox.type == kJp2BoxTypeColorHeader ) {\n                bWroteColor = true ;\n                if ( ! iccProfileDefined() ) {\n                    const char* pad   = \"\\x01\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x05\\x1cuuid\";\n                    uint32_t    psize = 15;\n                    newlen            = sizeof(newBox) + psize ;\n                    enforce(newlen <= output.size_ - outlen, Exiv2::kerCorruptedMetadata);\n                    ul2Data((byte*)&newBox.length,psize      ,bigEndian);\n                    ul2Data((byte*)&newBox.type  ,newBox.type,bigEndian);\n                    ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox));\n                    ::memcpy(output.pData_+outlen+sizeof(newBox)      ,pad                ,psize         );\n                } else {\n                    const char* pad   = \"\\x02\\x00\\x00\";\n                    uint32_t    psize = 3;\n                    newlen            = sizeof(newBox) + psize + iccProfile_.size_;\n                    enforce(newlen <= output.size_ - outlen, Exiv2::kerCorruptedMetadata);\n                    ul2Data((byte*)&newBox.length,newlen,bigEndian);\n                    ul2Data((byte*)&newBox.type,newBox.type,bigEndian);\n                    ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox)  );\n                    ::memcpy(output.pData_+outlen+sizeof(newBox)      , pad               ,psize           );\n                    ::memcpy(output.pData_+outlen+sizeof(newBox)+psize,iccProfile_.pData_,iccProfile_.size_);\n                }\n            } else {\n                enforce(newlen <= output.size_ - outlen, Exiv2::kerCorruptedMetadata);\n                ::memcpy(output.pData_+outlen,boxBuf.pData_+inlen,subBox.length);\n            }\n\n            outlen += newlen;\n            inlen  += subBox.length;\n        }\n\n        // allocate the correct number of bytes, copy the data and update the box header\n        outBuf.alloc(outlen);\n        ::memcpy(outBuf.pData_,output.pData_,outlen);\n        pBox   = (Jp2BoxHeader*) outBuf.pData_;\n        ul2Data((byte*)&pBox->type,kJp2BoxTypeJp2Header,bigEndian);\n        ul2Data((byte*)&pBox->length,outlen,bigEndian);\n    }", "target": 0, "idx": 12017}
{"commit_id": "efddaef0151af3be16078cc4d88c6bae0f911e56", "project": "apache/openoffice", "func": "sal_Bool ODbaseTable::UpdateBuffer(OValueRefVector& rRow, OValueRefRow pOrgRow,const Reference<XIndexAccess>& _xCols)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::UpdateBuffer\" );\n\tOSL_ENSURE(m_pBuffer,\"Buffer is NULL!\");\n\tif ( !m_pBuffer )\n\t\treturn sal_False;\n\tsal_Int32 nByteOffset  = 1;\n\n\t// Felder aktualisieren:\n\tReference<XPropertySet> xCol;\n\tReference<XPropertySet> xIndex;\n\tsal_uInt16 i;\n\t::rtl::OUString aColName;\n\tconst sal_Int32 nColumnCount = m_pColumns->getCount();\n\t::std::vector< Reference<XPropertySet> > aIndexedCols(nColumnCount);\n\n\t::comphelper::UStringMixEqual aCase(isCaseSensitive());\n\n\tReference<XIndexAccess> xColumns = m_pColumns;\n\t// first search a key that exist already in the table\n\tfor (i = 0; i < nColumnCount; ++i)\n\t{\n\t\tsal_Int32 nPos = i;\n\t\tif(_xCols != xColumns)\n\t\t{\n\t\t\tm_pColumns->getByIndex(i) >>= xCol;\n\t\t\tOSL_ENSURE(xCol.is(),\"ODbaseTable::UpdateBuffer column is null!\");\n\t\t\txCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME)) >>= aColName;\n\n\t\t\tfor(nPos = 0;nPos<_xCols->getCount();++nPos)\n\t\t\t{\n\t\t\t\tReference<XPropertySet> xFindCol;\n\t\t\t\t::cppu::extractInterface(xFindCol,_xCols->getByIndex(nPos));\n\t\t\t\tOSL_ENSURE(xFindCol.is(),\"ODbaseTable::UpdateBuffer column is null!\");\n\t\t\t\tif(aCase(getString(xFindCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME))),aColName))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nPos >= _xCols->getCount())\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t++nPos;\n\t\txIndex = isUniqueByColumnName(i);\n\t\taIndexedCols[i] = xIndex;\n\t\tif (xIndex.is())\n\t\t{\n\t\t\t// first check if the value is different to the old one and when if it conform to the index\n\t\t\tif(pOrgRow.isValid() && (rRow.get()[nPos]->getValue().isNull() || rRow.get()[nPos] == (pOrgRow->get())[nPos]))\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t{\n\t\t\t\t//\tODbVariantRef xVar = (pVal == NULL) ? new ODbVariant() : pVal;\n\t\t\t\tReference<XUnoTunnel> xTunnel(xIndex,UNO_QUERY);\n\t\t\t\tOSL_ENSURE(xTunnel.is(),\"No TunnelImplementation!\");\n\t\t\t\tODbaseIndex* pIndex = reinterpret_cast< ODbaseIndex* >( xTunnel->getSomething(ODbaseIndex::getUnoTunnelImplementationId()) );\n\t\t\t\tOSL_ENSURE(pIndex,\"ODbaseTable::UpdateBuffer: No Index returned!\");\n\n\t\t\t\tif (pIndex->Find(0,*rRow.get()[nPos]))\n\t\t\t\t{\n\t\t\t\t\t// es existiert kein eindeutiger Wert\n\t\t\t\t\tif ( !aColName.getLength() )\n\t\t\t\t\t{\n\t\t\t\t\t\tm_pColumns->getByIndex(i) >>= xCol;\n\t\t\t\t\t\tOSL_ENSURE(xCol.is(),\"ODbaseTable::UpdateBuffer column is null!\");\n\t\t\t\t\t\txCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME)) >>= aColName;\n\t\t\t\t\t\txCol.clear();\n\t\t\t\t\t} // if ( !aColName.getLength() )\n                    const ::rtl::OUString sError( getConnection()->getResources().getResourceStringWithSubstitution(\n                            STR_DUPLICATE_VALUE_IN_COLUMN\n                            ,\"$columnname$\", aColName\n                         ) );\n                    ::dbtools::throwGenericSQLException( sError, *this );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// when we are here there is no double key in the table\n\n\tfor (i = 0; i < nColumnCount && nByteOffset <= m_nBufferSize ; ++i)\n\t{\n\t\t// Laengen je nach Datentyp:\n\t\tOSL_ENSURE(i < m_aPrecisions.size(),\"Illegal index!\");\n\t\tsal_Int32 nLen = 0;\n\t\tsal_Int32 nType = 0;\n\t\tsal_Int32 nScale = 0;\n\t\tif ( i < m_aPrecisions.size() )\n\t\t{\n\t\t\tnLen\t= m_aPrecisions[i];\n\t\t\tnType\t= m_aTypes[i];\n\t\t\tnScale\t= m_aScales[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_pColumns->getByIndex(i) >>= xCol;\n\t\t\tif ( xCol.is() )\n\t\t\t{\n\t\t\t\txCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_PRECISION))\t>>= nLen;\n\t\t\t\txCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_TYPE))\t\t>>= nType;\n\t\t\t\txCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_SCALE))\t\t>>= nScale;\n\t\t\t}\n\t\t}\n\n        bool bSetZero = false;\n\t\tswitch (nType)\n\t\t{\n            case DataType::INTEGER:\n            case DataType::DOUBLE:\n            case DataType::TIMESTAMP:\n                bSetZero = true;\n            case DataType::LONGVARBINARY:\n\t\t\tcase DataType::DATE:\n            case DataType::BIT:\t\t\t\n\t\t\tcase DataType::LONGVARCHAR:\n                nLen = m_aRealFieldLengths[i]; \n                break;\n\t\t\tcase DataType::DECIMAL:\n\t\t\t\tnLen = SvDbaseConverter::ConvertPrecisionToDbase(nLen,nScale);\n\t\t\t\tbreak;\t// das Vorzeichen und das Komma\n\t\t\tdefault:\t\t\t\t\t\n                break;\n\n\t\t} // switch (nType)\n\n\t\tsal_Int32 nPos = i;\n\t\tif(_xCols != xColumns)\n\t\t{\n\t\t\tm_pColumns->getByIndex(i) >>= xCol;\n\t\t\tOSL_ENSURE(xCol.is(),\"ODbaseTable::UpdateBuffer column is null!\");\n\t\t\txCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME)) >>= aColName;\n\t\t\tfor(nPos = 0;nPos<_xCols->getCount();++nPos)\n\t\t\t{\n\t\t\t\tReference<XPropertySet> xFindCol;\n\t\t\t\t::cppu::extractInterface(xFindCol,_xCols->getByIndex(nPos));\n\t\t\t\tif(aCase(getString(xFindCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME))),aColName))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nPos >= _xCols->getCount())\n\t\t\t{\n\t\t\t\tnByteOffset += nLen;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\n\n\t\t++nPos; // the row values start at 1\n\t\t// Ist die Variable ueberhaupt gebunden?\n\t\tif ( !rRow.get()[nPos]->isBound() )\n\t\t{\n\t\t\t// Nein - naechstes Feld.\n\t\t\tnByteOffset += nLen;\n\t\t\tcontinue;\n\t\t}\n\t\tif (aIndexedCols[i].is())\n\t\t{\n\t\t\tReference<XUnoTunnel> xTunnel(aIndexedCols[i],UNO_QUERY);\n\t\t\tOSL_ENSURE(xTunnel.is(),\"No TunnelImplementation!\");\n\t\t\tODbaseIndex* pIndex = reinterpret_cast< ODbaseIndex* >( xTunnel->getSomething(ODbaseIndex::getUnoTunnelImplementationId()) );\n\t\t\tOSL_ENSURE(pIndex,\"ODbaseTable::UpdateBuffer: No Index returned!\");\n\t\t\t// Update !!\n\t\t\tif (pOrgRow.isValid() && !rRow.get()[nPos]->getValue().isNull() )//&& pVal->isModified())\n\t\t\t\tpIndex->Update(m_nFilePos,*(pOrgRow->get())[nPos],*rRow.get()[nPos]);\n\t\t\telse\n\t\t\t\tpIndex->Insert(m_nFilePos,*rRow.get()[nPos]);\n\t\t}\n\n\t\tchar* pData = (char *)(m_pBuffer + nByteOffset);\n\t\tif (rRow.get()[nPos]->getValue().isNull())\n\t\t{\n            if ( bSetZero )\n                memset(pData,0,nLen);\t// Zuruecksetzen auf NULL\n            else\n\t\t\t    memset(pData,' ',nLen);\t// Zuruecksetzen auf NULL\n\t\t\tnByteOffset += nLen;\n\t\t\tOSL_ENSURE( nByteOffset <= m_nBufferSize ,\"ByteOffset > m_nBufferSize!\");\n\t\t\tcontinue;\n\t\t}\n\n        sal_Bool bHadError = sal_False;\n\t\ttry\n\t\t{\n\t\t\tswitch (nType)\n\t\t\t{\n                case DataType::TIMESTAMP:\n                    {\n                        OSL_ENSURE(nLen == 8, \"Invalid length for timestamp field\");\n                        if (nLen != 8) {\n                            bHadError = true;\n                            break;\n                        }\n                        sal_Int32 nJulianDate = 0, nJulianTime = 0;\n                        lcl_CalcJulDate(nJulianDate,nJulianTime,rRow.get()[nPos]->getValue());\n                        // Genau 8 Byte kopieren:\n\t\t\t\t\t    memcpy(pData,&nJulianDate,4);\n                        memcpy(pData+4,&nJulianTime,4);\n                    }\n                    break;\n\t\t\t\tcase DataType::DATE:\n\t\t\t\t{\n                    OSL_ENSURE(nLen == 8, \"Invalid length for date field\");\n                    if (nLen != 8) {\n                        bHadError = true;\n                        break;\n                    }\n\t\t\t\t\t::com::sun::star::util::Date aDate;\n\t\t\t\t\tif(rRow.get()[nPos]->getValue().getTypeKind() == DataType::DOUBLE)\n\t\t\t\t\t\taDate = ::dbtools::DBTypeConversion::toDate(rRow.get()[nPos]->getValue().getDouble());\n\t\t\t\t\telse\n\t\t\t\t\t\taDate = rRow.get()[nPos]->getValue();\n\t\t\t\t\tchar s[9];\n\t\t\t\t\tsnprintf(s,\n\t\t\t\t\t\tsizeof(s),\n\t\t\t\t\t\t\"%04d%02d%02d\",\n\t\t\t\t\t\t(int)aDate.Year,\n\t\t\t\t\t\t(int)aDate.Month,\n\t\t\t\t\t\t(int)aDate.Day);\n\n\t\t\t\t\t// Genau 8 Byte kopieren:\n\t\t\t\t\tstrncpy(pData,s,sizeof s - 1);\n\t\t\t\t} break;\n                case DataType::INTEGER:\n                    {\n                        OSL_ENSURE(nLen == 4, \"Invalid length for integer field\");\n                        if (nLen != 4) {\n                            bHadError = true;\n                            break;\n                        }\n                        sal_Int32 nValue = rRow.get()[nPos]->getValue();\n                        memcpy(pData,&nValue,nLen);\n                    }\n                    break;\n                case DataType::DOUBLE:\n                    {\n                        OSL_ENSURE(nLen == 8, \"Invalid length for double field\");\n                        if (nLen != 8) {\n                            bHadError = true;\n                            break;\n                        }\n                        const double d = rRow.get()[nPos]->getValue();\n                        m_pColumns->getByIndex(i) >>= xCol;\n                        \n                        if (getBOOL(xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_ISCURRENCY)))) // Currency wird gesondert behandelt\n                        {\n                            sal_Int64 nValue = 0;\n                            if ( m_aScales[i] )\n                                nValue = (sal_Int64)(d * pow(10.0,(int)m_aScales[i]));\n                            else\n                                nValue = (sal_Int64)(d);\n                            memcpy(pData,&nValue,nLen);\n                        } // if (getBOOL(xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_ISCURRENCY)))) // Currency wird gesondert behandelt\n                        else\n                            memcpy(pData,&d,nLen);\n                    }\n                    break;\n\t\t\t\tcase DataType::DECIMAL:\n\t\t\t\t{\n\t\t\t\t\tmemset(pData,' ',nLen);\t// Zuruecksetzen auf NULL\n\n\t\t\t\t\tconst double n = rRow.get()[nPos]->getValue();\n\n\t\t\t\t\t// ein const_cast, da GetFormatPrecision am SvNumberFormat nicht const ist, obwohl es das eigentlich\n\t\t\t\t\t// sein koennte und muesste\n\n\t\t\t\t\tconst ByteString aDefaultValue( ::rtl::math::doubleToString( n, rtl_math_StringFormat_F, nScale, '.', NULL, 0));\n                    sal_Bool bValidLength  = aDefaultValue.Len() <= nLen;\n                    if ( bValidLength )\n                    {\n\t\t\t\t\t    strncpy(pData,aDefaultValue.GetBuffer(),nLen);\n\t\t\t\t\t    // write the resulting double back\n\t\t\t\t\t    *rRow.get()[nPos] = toDouble(aDefaultValue);\n                    }\n                    else\n\t\t\t\t\t{\n\t\t\t\t\t\tm_pColumns->getByIndex(i) >>= xCol;\n\t\t\t\t\t\tOSL_ENSURE(xCol.is(),\"ODbaseTable::UpdateBuffer column is null!\");\n\t\t\t\t\t\txCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME)) >>= aColName;\n                        ::std::list< ::std::pair<const sal_Char* , ::rtl::OUString > > aStringToSubstitutes;\n                        aStringToSubstitutes.push_back(::std::pair<const sal_Char* , ::rtl::OUString >(\"$columnname$\", aColName));\n                        aStringToSubstitutes.push_back(::std::pair<const sal_Char* , ::rtl::OUString >(\"$precision$\", String::CreateFromInt32(nLen)));\n                        aStringToSubstitutes.push_back(::std::pair<const sal_Char* , ::rtl::OUString >(\"$scale$\", String::CreateFromInt32(nScale)));\n                        aStringToSubstitutes.push_back(::std::pair<const sal_Char* , ::rtl::OUString >(\"$value$\", ::rtl::OStringToOUString(aDefaultValue,RTL_TEXTENCODING_UTF8)));\n\n                        const ::rtl::OUString sError( getConnection()->getResources().getResourceStringWithSubstitution(\n                                STR_INVALID_COLUMN_DECIMAL_VALUE\n                                ,aStringToSubstitutes\n                             ) );\n                        ::dbtools::throwGenericSQLException( sError, *this );\n\t\t\t\t\t}\n\t\t\t\t} break;\n\t\t\t\tcase DataType::BIT:\n                    OSL_ENSURE(nLen == 1, \"Invalid length for bit field\");\n                    if (nLen != 1) {\n                        bHadError = true;\n                        break;\n                    }\n\t\t\t\t\t*pData = rRow.get()[nPos]->getValue().getBool() ? 'T' : 'F';\n\t\t\t\t\tbreak;\n                case DataType::LONGVARBINARY:\n\t\t\t\tcase DataType::LONGVARCHAR:\n\t\t\t\t{\n\t\t\t\t\tchar cNext = pData[nLen]; // merken und temporaer durch 0 ersetzen\n\t\t\t\t\tpData[nLen] = '\\0';\t\t  // das geht, da der Puffer immer ein Zeichen groesser ist ...\n\n\t\t\t\t\tsal_uIntPtr nBlockNo = strtol((const char *)pData,NULL,10);\t// Blocknummer lesen\n\n\t\t\t\t\t// Naechstes Anfangszeichen wieder restaurieren:\n\t\t\t\t\tpData[nLen] = cNext;\n\t\t\t\t\tif (!m_pMemoStream || !WriteMemo(rRow.get()[nPos]->get(), nBlockNo))\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tByteString aStr;\n\t\t\t\t\tByteString aBlock(ByteString::CreateFromInt32(nBlockNo));\n\t\t\t\t\taStr.Expand(static_cast<sal_uInt16>(nLen - aBlock.Len()), '0' );\n\t\t\t\t\taStr += aBlock;\n\t\t\t\t\t// Zeichen kopieren:\n\t\t\t\t\tmemset(pData,' ',nLen);\t// Zuruecksetzen auf NULL\n\t\t\t\t\tmemcpy(pData, aStr.GetBuffer(), nLen);\n\t\t\t\t}\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t{\n\t\t\t\t\tmemset(pData,' ',nLen);\t// Zuruecksetzen auf NULL\n\n                    ::rtl::OUString sStringToWrite( rRow.get()[nPos]->getValue().getString() );\n\n                    // convert the string, using the connection's encoding\n                    ::rtl::OString sEncoded;\n                   \n                    DBTypeConversion::convertUnicodeStringToLength( sStringToWrite, sEncoded, nLen, m_eEncoding );\n                    memcpy( pData, sEncoded.getStr(), sEncoded.getLength() );\n\n\t\t\t\t}\n                break;\n\t\t\t}\n\t\t}\n\t\tcatch( SQLException&  )\n        {\n            throw;\n        }\n\t\tcatch ( Exception& ) { bHadError = sal_True; }\n\n\t\tif ( bHadError )\n\t\t{\n\t\t\tm_pColumns->getByIndex(i) >>= xCol;\n\t\t\tOSL_ENSURE( xCol.is(), \"ODbaseTable::UpdateBuffer column is null!\" );\n            if ( xCol.is() )\n\t\t\t    xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME)) >>= aColName;\n\n\t\t\tconst ::rtl::OUString sError( getConnection()->getResources().getResourceStringWithSubstitution(\n                    STR_INVALID_COLUMN_VALUE,\n                    \"$columnname$\", aColName\n                 ) );\n            ::dbtools::throwGenericSQLException( sError, *this );\n\t\t}\n\t\t// Und weiter ...\n\t\tnByteOffset += nLen;\n\t\tOSL_ENSURE( nByteOffset <= m_nBufferSize ,\"ByteOffset > m_nBufferSize!\");\n\t}\n\treturn sal_True;\n}", "target": 2, "idx": 12018}
{"commit_id": "4d45a96e57fbabf00a7378b337d0ddcace6f38c1", "project": "ArtifexSoftware/mujs", "func": "static js_Ast *callexp(js_State *J)\n{\n\tjs_Ast *a = newexp(J);\n\tSAVEREC();\nloop:\n\tINCREC();\n\tif (jsP_accept(J, '.')) { a = EXP2(MEMBER, a, identifiername(J)); goto loop; }\n\tif (jsP_accept(J, '[')) { a = EXP2(INDEX, a, expression(J, 0)); jsP_expect(J, ']'); goto loop; }\n\tif (jsP_accept(J, '(')) { a = EXP2(CALL, a, arguments(J)); jsP_expect(J, ')'); goto loop; }\n\tPOPREC();\n\treturn a;\n}", "target": 1, "idx": 12019}
{"commit_id": "f991af3daabaecff34684fd51fac80319d1baad1", "project": "torvalds/linux", "func": "static int do_mq_notify(mqd_t mqdes, const struct sigevent *notification)\n{\n\tint ret;\n\tstruct fd f;\n\tstruct sock *sock;\n\tstruct inode *inode;\n\tstruct mqueue_inode_info *info;\n\tstruct sk_buff *nc;\n\n\taudit_mq_notify(mqdes, notification);\n\n\tnc = NULL;\n\tsock = NULL;\n\tif (notification != NULL) {\n\t\tif (unlikely(notification->sigev_notify != SIGEV_NONE &&\n\t\t\t     notification->sigev_notify != SIGEV_SIGNAL &&\n\t\t\t     notification->sigev_notify != SIGEV_THREAD))\n\t\t\treturn -EINVAL;\n\t\tif (notification->sigev_notify == SIGEV_SIGNAL &&\n\t\t\t!valid_signal(notification->sigev_signo)) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (notification->sigev_notify == SIGEV_THREAD) {\n\t\t\tlong timeo;\n\n\t\t\t/* create the notify skb */\n\t\t\tnc = alloc_skb(NOTIFY_COOKIE_LEN, GFP_KERNEL);\n\t\t\tif (!nc) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (copy_from_user(nc->data,\n\t\t\t\t\tnotification->sigev_value.sival_ptr,\n\t\t\t\t\tNOTIFY_COOKIE_LEN)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* TODO: add a header? */\n\t\t\tskb_put(nc, NOTIFY_COOKIE_LEN);\n\t\t\t/* and attach it to the socket */\nretry:\n\t\t\tf = fdget(notification->sigev_signo);\n\t\t\tif (!f.file) {\n\t\t\t\tret = -EBADF;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tsock = netlink_getsockbyfilp(f.file);\n\t\t\tfdput(f);\n\t\t\tif (IS_ERR(sock)) {\n\t\t\t\tret = PTR_ERR(sock);\n\t\t\t\tsock = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\ttimeo = MAX_SCHEDULE_TIMEOUT;\n\t\t\tret = netlink_attachskb(sock, nc, &timeo, NULL);\n\t\t\tif (ret == 1) {\n\t\t\t\tsock = NULL;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tif (ret) {\n\t\t\t\tsock = NULL;\n\t\t\t\tnc = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tf = fdget(mqdes);\n\tif (!f.file) {\n\t\tret = -EBADF;\n\t\tgoto out;\n\t}\n\n\tinode = file_inode(f.file);\n\tif (unlikely(f.file->f_op != &mqueue_file_operations)) {\n\t\tret = -EBADF;\n\t\tgoto out_fput;\n\t}\n\tinfo = MQUEUE_I(inode);\n\n\tret = 0;\n\tspin_lock(&info->lock);\n\tif (notification == NULL) {\n\t\tif (info->notify_owner == task_tgid(current)) {\n\t\t\tremove_notification(info);\n\t\t\tinode->i_atime = inode->i_ctime = current_time(inode);\n\t\t}\n\t} else if (info->notify_owner != NULL) {\n\t\tret = -EBUSY;\n\t} else {\n\t\tswitch (notification->sigev_notify) {\n\t\tcase SIGEV_NONE:\n\t\t\tinfo->notify.sigev_notify = SIGEV_NONE;\n\t\t\tbreak;\n\t\tcase SIGEV_THREAD:\n\t\t\tinfo->notify_sock = sock;\n\t\t\tinfo->notify_cookie = nc;\n\t\t\tsock = NULL;\n\t\t\tnc = NULL;\n\t\t\tinfo->notify.sigev_notify = SIGEV_THREAD;\n\t\t\tbreak;\n\t\tcase SIGEV_SIGNAL:\n\t\t\tinfo->notify.sigev_signo = notification->sigev_signo;\n\t\t\tinfo->notify.sigev_value = notification->sigev_value;\n\t\t\tinfo->notify.sigev_notify = SIGEV_SIGNAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tinfo->notify_owner = get_pid(task_tgid(current));\n\t\tinfo->notify_user_ns = get_user_ns(current_user_ns());\n\t\tinode->i_atime = inode->i_ctime = current_time(inode);\n\t}\n\tspin_unlock(&info->lock);\nout_fput:\n\tfdput(f);\nout:\n\tif (sock)\n\t\tnetlink_detachskb(sock, nc);\n\telse if (nc)\n\t\tdev_kfree_skb(nc);\n\n\treturn ret;\n}", "target": 2, "idx": 12020}
{"commit_id": "b88393f08a558eec14964a55d3c680fe67407712", "project": "php/php-src", "func": "static int wddx_stack_destroy(wddx_stack *stack)\n{\n\tregister int i;\n\n\tif (stack->elements) {\n\t\tfor (i = 0; i < stack->top; i++) {\n\t\t\tif (((st_entry *)stack->elements[i])->data\n\t\t\t\t\t&& ((st_entry *)stack->elements[i])->type != ST_FIELD)\t{\n\t\t\t\tzval_ptr_dtor(&((st_entry *)stack->elements[i])->data);\n\t\t\t}\n\t\t\tif (((st_entry *)stack->elements[i])->varname) {\n\t\t\t\tefree(((st_entry *)stack->elements[i])->varname);\n\t\t\t}\n\t\t\tefree(stack->elements[i]);\n\t\t}\n\t\tefree(stack->elements);\n\t}\n\treturn SUCCESS;\n}", "target": 3, "idx": 12021}
{"commit_id": "0da8b8b801f9276359262f1ef8274c7812d3dfda", "project": "php/php-src", "func": "static void traverse_for_entities(\n\tconst char *old,\n\tsize_t oldlen,\n\tchar *ret, /* should have allocated TRAVERSE_FOR_ENTITIES_EXPAND_SIZE(olden) */\n\tsize_t *retlen,\n\tint all,\n\tint flags,\n\tconst entity_ht *inv_map,\n\tenum entity_charset charset)\n{\n\tconst char *p,\n\t\t\t   *lim;\n\tchar\t   *q;\n\tint doctype = flags & ENT_HTML_DOC_TYPE_MASK;\n\n\tlim = old + oldlen; /* terminator address */\n\tassert(*lim == '\\0');\n\n\tfor (p = old, q = ret; p < lim;) {\n\t\tunsigned code, code2 = 0;\n\t\tconst char *next = NULL; /* when set, next > p, otherwise possible inf loop */\n\n\t\t/* Shift JIS, Big5 and HKSCS use multi-byte encodings where an\n\t\t * ASCII range byte can be part of a multi-byte sequence.\n\t\t * However, they start at 0x40, therefore if we find a 0x26 byte,\n\t\t * we're sure it represents the '&' character. */\n\n\t\t/* assumes there are no single-char entities */\n\t\tif (p[0] != '&' || (p + 3 >= lim)) {\n\t\t\t*(q++) = *(p++);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* now p[3] is surely valid and is no terminator */\n\n\t\t/* numerical entity */\n\t\tif (p[1] == '#') {\n\t\t\tnext = &p[2];\n\t\t\tif (process_numeric_entity(&next, &code) == FAILURE)\n\t\t\t\tgoto invalid_code;\n\n\t\t\t/* If we're in htmlspecialchars_decode, we're only decoding entities\n\t\t\t * that represent &, <, >, \" and '. Is this one of them? */\n\t\t\tif (!all && (code > 63U ||\n\t\t\t\t\tstage3_table_be_apos_00000[code].data.ent.entity == NULL))\n\t\t\t\tgoto invalid_code;\n\n\t\t\t/* are we allowed to decode this entity in this document type?\n\t\t\t * HTML 5 is the only that has a character that cannot be used in\n\t\t\t * a numeric entity but is allowed literally (U+000D). The\n\t\t\t * unoptimized version would be ... || !numeric_entity_is_allowed(code) */\n\t\t\tif (!unicode_cp_is_allowed(code, doctype) ||\n\t\t\t\t\t(doctype == ENT_HTML_DOC_HTML5 && code == 0x0D))\n\t\t\t\tgoto invalid_code;\n\t\t} else {\n\t\t\tconst char *start;\n\t\t\tsize_t ent_len;\n\n\t\t\tnext = &p[1];\n\t\t\tstart = next;\n\n\t\t\tif (process_named_entity_html(&next, &start, &ent_len) == FAILURE)\n\t\t\t\tgoto invalid_code;\n\n\t\t\tif (resolve_named_entity_html(start, ent_len, inv_map, &code, &code2) == FAILURE) {\n\t\t\t\tif (doctype == ENT_HTML_DOC_XHTML && ent_len == 4 && start[0] == 'a'\n\t\t\t\t\t\t\t&& start[1] == 'p' && start[2] == 'o' && start[3] == 's') {\n\t\t\t\t\t/* uses html4 inv_map, which doesn't include apos;. This is a\n\t\t\t\t\t * hack to support it */\n\t\t\t\t\tcode = (unsigned) '\\'';\n\t\t\t\t} else {\n\t\t\t\t\tgoto invalid_code;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tassert(*next == ';');\n\n\t\tif (((code == '\\'' && !(flags & ENT_HTML_QUOTE_SINGLE)) ||\n\t\t\t\t(code == '\"' && !(flags & ENT_HTML_QUOTE_DOUBLE)))\n\t\t\t\t/* && code2 == '\\0' always true for current maps */)\n\t\t\tgoto invalid_code;\n\n\t\t/* UTF-8 doesn't need mapping (ISO-8859-1 doesn't either, but\n\t\t * the call is needed to ensure the codepoint <= U+00FF)  */\n\t\tif (charset != cs_utf_8) {\n\t\t\t/* replace unicode code point */\n\t\t\tif (map_from_unicode(code, charset, &code) == FAILURE || code2 != 0)\n\t\t\t\tgoto invalid_code; /* not representable in target charset */\n\t\t}\n\n\t\tq += write_octet_sequence(q, charset, code);\n\t\tif (code2) {\n\t\t\tq += write_octet_sequence(q, charset, code2);\n\t\t}\n\n\t\t/* jump over the valid entity; may go beyond size of buffer; np */\n\t\tp = next + 1;\n\t\tcontinue;\n\ninvalid_code:\n\t\tfor (; p < next; p++) {\n\t\t\t*(q++) = *p;\n\t\t}\n\t}\n\n\t*q = '\\0';\n\t*retlen = (size_t)(q - ret);\n}", "target": 2, "idx": 12022}
{"commit_id": "3e5d316b72e3965b7968bb1d96baa137cd063ac6", "project": "ArtifexSoftware/ghostpdl", "func": "static int\nz2grestoreall(i_ctx_t *i_ctx_p)\n{\n    for (;;) {\n        int code = restore_page_device(i_ctx_p, igs, gs_gstate_saved(igs));\n        if (code < 0) return code;\n        if (code == 0) {\n            bool done = !gs_gstate_saved(gs_gstate_saved(igs));\n\n            gs_grestore(igs);\n            if (done)\n                break;\n        } else\n            return push_callout(i_ctx_p, \"%grestoreallpagedevice\");\n    }\n    return 0;\n}", "target": 2, "idx": 12023}
{"commit_id": "db8c799f6dfc68765c9451fcbfca06e662f5bd5f", "project": "the-tcpdump-group/tcpdump", "func": "int\nmobility_print(netdissect_options *ndo,\n               const u_char *bp, const u_char *bp2 _U_)\n{\n\tconst struct ip6_mobility *mh;\n\tconst u_char *ep;\n\tunsigned mhlen, hlen;\n\tuint8_t type;\n\n\tmh = (const struct ip6_mobility *)bp;\n\n\t/* 'ep' points to the end of available data. */\n\tep = ndo->ndo_snapend;\n\n\tif (!ND_TTEST(mh->ip6m_len)) {\n\t\t/*\n\t\t * There's not enough captured data to include the\n\t\t * mobility header length.\n\t\t *\n\t\t * Our caller expects us to return the length, however,\n\t\t * so return a value that will run to the end of the\n\t\t * captured data.\n\t\t *\n\t\t * XXX - \"ip6_print()\" doesn't do anything with the\n\t\t * returned length, however, as it breaks out of the\n\t\t * header-processing loop.\n\t\t */\n\t\tmhlen = ep - bp;\n\t\tgoto trunc;\n\t}\n\tmhlen = (mh->ip6m_len + 1) << 3;\n\n\t/* XXX ip6m_cksum */\n\n\tND_TCHECK(mh->ip6m_type);\n\ttype = mh->ip6m_type;\n\tif (type <= IP6M_MAX && mhlen < ip6m_hdrlen[type]) {\n\t\tND_PRINT((ndo, \"(header length %u is too small for type %u)\", mhlen, type));\n\t\tgoto trunc;\n\t}\n\tND_PRINT((ndo, \"mobility: %s\", tok2str(ip6m_str, \"type-#%u\", type)));\n\tswitch (type) {\n\tcase IP6M_BINDING_REQUEST:\n\t\thlen = IP6M_MINLEN;\n\t\tbreak;\n\tcase IP6M_HOME_TEST_INIT:\n\tcase IP6M_CAREOF_TEST_INIT:\n\t\thlen = IP6M_MINLEN;\n\t\tif (ndo->ndo_vflag) {\n\t\t\tND_TCHECK_32BITS(&bp[hlen + 4]);\n\t\t\tND_PRINT((ndo, \" %s Init Cookie=%08x:%08x\",\n\t\t\t       type == IP6M_HOME_TEST_INIT ? \"Home\" : \"Care-of\",\n\t\t\t       EXTRACT_32BITS(&bp[hlen]),\n\t\t\t       EXTRACT_32BITS(&bp[hlen + 4])));\n\t\t}\n\t\thlen += 8;\n\t\tbreak;\n\tcase IP6M_HOME_TEST:\n\tcase IP6M_CAREOF_TEST:\n\t\tND_TCHECK(mh->ip6m_data16[0]);\n\t\tND_PRINT((ndo, \" nonce id=0x%x\", EXTRACT_16BITS(&mh->ip6m_data16[0])));\n\t\thlen = IP6M_MINLEN;\n\t\tif (ndo->ndo_vflag) {\n\t\t\tND_TCHECK_32BITS(&bp[hlen + 4]);\n\t\t\tND_PRINT((ndo, \" %s Init Cookie=%08x:%08x\",\n\t\t\t       type == IP6M_HOME_TEST ? \"Home\" : \"Care-of\",\n\t\t\t       EXTRACT_32BITS(&bp[hlen]),\n\t\t\t       EXTRACT_32BITS(&bp[hlen + 4])));\n\t\t}\n\t\thlen += 8;\n\t\tif (ndo->ndo_vflag) {\n\t\t\tND_TCHECK_32BITS(&bp[hlen + 4]);\n\t\t\tND_PRINT((ndo, \" %s Keygen Token=%08x:%08x\",\n\t\t\t       type == IP6M_HOME_TEST ? \"Home\" : \"Care-of\",\n\t\t\t       EXTRACT_32BITS(&bp[hlen]),\n\t\t\t       EXTRACT_32BITS(&bp[hlen + 4])));\n\t\t}\n\t\thlen += 8;\n\t\tbreak;\n\tcase IP6M_BINDING_UPDATE:\n\t\tND_TCHECK(mh->ip6m_data16[0]);\n\t\tND_PRINT((ndo, \" seq#=%u\", EXTRACT_16BITS(&mh->ip6m_data16[0])));\n\t\thlen = IP6M_MINLEN;\n\t\tND_TCHECK_16BITS(&bp[hlen]);\n\t\tif (bp[hlen] & 0xf0) {\n\t\t\tND_PRINT((ndo, \" \"));\n\t\t\tif (bp[hlen] & 0x80)\n\t\t\t\tND_PRINT((ndo, \"A\"));\n\t\t\tif (bp[hlen] & 0x40)\n\t\t\t\tND_PRINT((ndo, \"H\"));\n\t\t\tif (bp[hlen] & 0x20)\n\t\t\t\tND_PRINT((ndo, \"L\"));\n\t\t\tif (bp[hlen] & 0x10)\n\t\t\t\tND_PRINT((ndo, \"K\"));\n\t\t}\n\t\t/* Reserved (4bits) */\n\t\thlen += 1;\n\t\t/* Reserved (8bits) */\n\t\thlen += 1;\n\t\tND_TCHECK_16BITS(&bp[hlen]);\n\t\t/* units of 4 secs */\n\t\tND_PRINT((ndo, \" lifetime=%u\", EXTRACT_16BITS(&bp[hlen]) << 2));\n\t\thlen += 2;\n\t\tbreak;\n\tcase IP6M_BINDING_ACK:\n\t\tND_TCHECK(mh->ip6m_data8[0]);\n\t\tND_PRINT((ndo, \" status=%u\", mh->ip6m_data8[0]));\n\t\tND_TCHECK(mh->ip6m_data8[1]);\n\t\tif (mh->ip6m_data8[1] & 0x80)\n\t\t\tND_PRINT((ndo, \" K\"));\n\t\t/* Reserved (7bits) */\n\t\thlen = IP6M_MINLEN;\n\t\tND_TCHECK_16BITS(&bp[hlen]);\n\t\tND_PRINT((ndo, \" seq#=%u\", EXTRACT_16BITS(&bp[hlen])));\n\t\thlen += 2;\n\t\tND_TCHECK_16BITS(&bp[hlen]);\n\t\t/* units of 4 secs */\n\t\tND_PRINT((ndo, \" lifetime=%u\", EXTRACT_16BITS(&bp[hlen]) << 2));\n\t\thlen += 2;\n\t\tbreak;\n\tcase IP6M_BINDING_ERROR:\n\t\tND_TCHECK(mh->ip6m_data8[0]);\n\t\tND_PRINT((ndo, \" status=%u\", mh->ip6m_data8[0]));\n\t\t/* Reserved */\n\t\thlen = IP6M_MINLEN;\n\t\tND_TCHECK2(bp[hlen], 16);\n\t\tND_PRINT((ndo, \" homeaddr %s\", ip6addr_string(ndo, &bp[hlen])));\n\t\thlen += 16;\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \" len=%u\", mh->ip6m_len));\n\t\treturn(mhlen);\n\t\tbreak;\n\t}\n\tif (ndo->ndo_vflag)\n\t\tif (mobility_opt_print(ndo, &bp[hlen], mhlen - hlen))\n\t\t\tgoto trunc;\n\n\treturn(mhlen);\n\n trunc:\n\tND_PRINT((ndo, \"%s\", tstr));\n\treturn(-1);\n}", "target": 3, "idx": 12024}
{"commit_id": "c597156adc60a45b5f827793cd420945f47bc03b", "project": "atheme", "func": "void _modinit(module_t *m)\n{\n\tservice_named_bind_command(\"chanserv\", &cs_flags);\n\n\tadd_bool_conf_item(\"ANOPE_FLAGS_COMPAT\", &chansvs.me->conf_table, 0, &anope_flags_compat, true);\n\n\thook_add_event(\"nick_can_register\");\n\thook_add_nick_can_register(check_registration_keywords);\n\n\thook_add_event(\"user_can_register\");\n\thook_add_user_can_register(check_registration_keywords);\n}", "target": 2, "idx": 12025}
{"commit_id": "c69d710d2bf39fe633800db65efddf55701131b6", "project": "wireshark", "func": "static int\ndissect_smb2_find_request(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, smb2_info_t *si)\n{\n\toffset_length_buffer_t olb;\n\tconst char *buf;\n\tguint8      il;\n\tstatic const int *f_fields[] = {\n\t\t&hf_smb2_find_flags_restart_scans,\n\t\t&hf_smb2_find_flags_single_entry,\n\t\t&hf_smb2_find_flags_index_specified,\n\t\t&hf_smb2_find_flags_reopen,\n\t\tNULL\n\t};\n\n\t/* buffer code */\n\toffset = dissect_smb2_buffercode(tree, tvb, offset, NULL);\n\n\til = tvb_get_guint8(tvb, offset);\n\tif (si->saved) {\n\t\tsi->saved->infolevel = il;\n\t}\n\n\t/* infolevel */\n\tproto_tree_add_uint(tree, hf_smb2_find_info_level, tvb, offset, 1, il);\n\toffset += 1;\n\n\t/* find flags */\n\tproto_tree_add_bitmask(tree, tvb, offset, hf_smb2_find_flags, ett_smb2_find_flags, f_fields, ENC_LITTLE_ENDIAN);\n\toffset += 1;\n\n\t/* file index */\n\tproto_tree_add_item(tree, hf_smb2_file_index, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n\toffset += 4;\n\n\t/* fid */\n\toffset = dissect_smb2_fid(tvb, pinfo, tree, offset, si, FID_MODE_USE);\n\n\t/* search pattern  offset/length */\n\toffset = dissect_smb2_olb_length_offset(tvb, offset, &olb, OLB_O_UINT16_S_UINT16, hf_smb2_find_pattern);\n\n\t/* output buffer length */\n\tproto_tree_add_item(tree, hf_smb2_output_buffer_len, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n\toffset += 4;\n\n\t/* search pattern */\n\tbuf = dissect_smb2_olb_string(pinfo, tree, tvb, &olb, OLB_TYPE_UNICODE_STRING);\n\n\toffset = dissect_smb2_olb_tvb_max_offset(offset, &olb);\n\n\tif (!pinfo->fd->flags.visited && si->saved && olb.len) {\n\t\tsi->saved->extra_info_type = SMB2_EI_FINDPATTERN;\n\t\tsi->saved->extra_info = wmem_alloc(wmem_file_scope(), olb.len+1);\n\t\tg_snprintf((char *)si->saved->extra_info,olb.len+1,\"%s\",buf);\n\t}\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \" %s Pattern: %s\",\n\t\t\tval_to_str(il, smb2_find_info_levels, \"(Level:0x%02x)\"),\n\t\t\tbuf);\n\n\treturn offset;\n}", "target": 2, "idx": 12026}
{"commit_id": "8c7188b23474cca017b3ef354c4a58456f68303a", "project": "torvalds/linux", "func": "int rds_sendmsg(struct socket *sock, struct msghdr *msg, size_t payload_len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rds_sock *rs = rds_sk_to_rs(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_in *, usin, msg->msg_name);\n\t__be32 daddr;\n\t__be16 dport;\n\tstruct rds_message *rm = NULL;\n\tstruct rds_connection *conn;\n\tint ret = 0;\n\tint queued = 0, allocated_mr = 0;\n\tint nonblock = msg->msg_flags & MSG_DONTWAIT;\n\tlong timeo = sock_sndtimeo(sk, nonblock);\n\n\t/* Mirror Linux UDP mirror of BSD error message compatibility */\n\t/* XXX: Perhaps MSG_MORE someday */\n\tif (msg->msg_flags & ~(MSG_DONTWAIT | MSG_CMSG_COMPAT)) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (msg->msg_namelen) {\n\t\t/* XXX fail non-unicast destination IPs? */\n\t\tif (msg->msg_namelen < sizeof(*usin) || usin->sin_family != AF_INET) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tdaddr = usin->sin_addr.s_addr;\n\t\tdport = usin->sin_port;\n\t} else {\n\t\t/* We only care about consistency with ->connect() */\n\t\tlock_sock(sk);\n\t\tdaddr = rs->rs_conn_addr;\n\t\tdport = rs->rs_conn_port;\n\t\trelease_sock(sk);\n\t}\n\n\tlock_sock(sk);\n\tif (daddr == 0 || rs->rs_bound_addr == 0) {\n\t\trelease_sock(sk);\n\t\tret = -ENOTCONN; /* XXX not a great errno */\n\t\tgoto out;\n\t}\n\trelease_sock(sk);\n\n\tif (payload_len > rds_sk_sndbuf(rs)) {\n\t\tret = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\t/* size of rm including all sgs */\n\tret = rds_rm_size(msg, payload_len);\n\tif (ret < 0)\n\t\tgoto out;\n\n\trm = rds_message_alloc(ret, GFP_KERNEL);\n\tif (!rm) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/* Attach data to the rm */\n\tif (payload_len) {\n\t\trm->data.op_sg = rds_message_alloc_sgs(rm, ceil(payload_len, PAGE_SIZE));\n\t\tif (!rm->data.op_sg) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = rds_message_copy_from_user(rm, &msg->msg_iter);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\trm->data.op_active = 1;\n\n\trm->m_daddr = daddr;\n\n\t/* rds_conn_create has a spinlock that runs with IRQ off.\n\t * Caching the conn in the socket helps a lot. */\n\tif (rs->rs_conn && rs->rs_conn->c_faddr == daddr)\n\t\tconn = rs->rs_conn;\n\telse {\n\t\tconn = rds_conn_create_outgoing(sock_net(sock->sk),\n\t\t\t\t\t\trs->rs_bound_addr, daddr,\n\t\t\t\t\trs->rs_transport,\n\t\t\t\t\tsock->sk->sk_allocation);\n\t\tif (IS_ERR(conn)) {\n\t\t\tret = PTR_ERR(conn);\n\t\t\tgoto out;\n\t\t}\n\t\trs->rs_conn = conn;\n\t}\n\n\t/* Parse any control messages the user may have included. */\n\tret = rds_cmsg_send(rs, rm, msg, &allocated_mr);\n\tif (ret)\n\t\tgoto out;\n\n\tif (rm->rdma.op_active && !conn->c_trans->xmit_rdma) {\n\t\tprintk_ratelimited(KERN_NOTICE \"rdma_op %p conn xmit_rdma %p\\n\",\n\t\t\t       &rm->rdma, conn->c_trans->xmit_rdma);\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (rm->atomic.op_active && !conn->c_trans->xmit_atomic) {\n\t\tprintk_ratelimited(KERN_NOTICE \"atomic_op %p conn xmit_atomic %p\\n\",\n\t\t\t       &rm->atomic, conn->c_trans->xmit_atomic);\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\trds_conn_connect_if_down(conn);\n\n\tret = rds_cong_wait(conn->c_fcong, dport, nonblock, rs);\n\tif (ret) {\n\t\trs->rs_seen_congestion = 1;\n\t\tgoto out;\n\t}\n\n\twhile (!rds_send_queue_rm(rs, conn, rm, rs->rs_bound_port,\n\t\t\t\t  dport, &queued)) {\n\t\trds_stats_inc(s_send_queue_full);\n\n\t\tif (nonblock) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\n\t\ttimeo = wait_event_interruptible_timeout(*sk_sleep(sk),\n\t\t\t\t\trds_send_queue_rm(rs, conn, rm,\n\t\t\t\t\t\t\t  rs->rs_bound_port,\n\t\t\t\t\t\t\t  dport,\n\t\t\t\t\t\t\t  &queued),\n\t\t\t\t\ttimeo);\n\t\trdsdebug(\"sendmsg woke queued %d timeo %ld\\n\", queued, timeo);\n\t\tif (timeo > 0 || timeo == MAX_SCHEDULE_TIMEOUT)\n\t\t\tcontinue;\n\n\t\tret = timeo;\n\t\tif (ret == 0)\n\t\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * By now we've committed to the send.  We reuse rds_send_worker()\n\t * to retry sends in the rds thread if the transport asks us to.\n\t */\n\trds_stats_inc(s_send_queued);\n\n\tret = rds_send_xmit(conn);\n\tif (ret == -ENOMEM || ret == -EAGAIN)\n\t\tqueue_delayed_work(rds_wq, &conn->c_send_w, 1);\n\n\trds_message_put(rm);\n\treturn payload_len;\n\nout:\n\t/* If the user included a RDMA_MAP cmsg, we allocated a MR on the fly.\n\t * If the sendmsg goes through, we keep the MR. If it fails with EAGAIN\n\t * or in any other way, we need to destroy the MR again */\n\tif (allocated_mr)\n\t\trds_rdma_unuse(rs, rds_rdma_cookie_key(rm->m_rdma_cookie), 1);\n\n\tif (rm)\n\t\trds_message_put(rm);\n\treturn ret;\n}", "target": 1, "idx": 12027}
{"commit_id": "6aa825e480d48127b480b08d13adf70033237097", "project": "facebook/hermes", "func": "CallResult<bool> isConstructor(Runtime &runtime, Callable *callable) {\n  // This is not a complete definition, since ES6 and later define member\n  // functions of objects to not be constructors; however, Hermes does not have\n  // ES6 classes implemented yet, so we cannot check for that case.\n  if (!callable) {\n    return false;\n  }\n\n  // We traverse the BoundFunction target chain to find the eventual target.\n  while (BoundFunction *b = dyn_vmcast<BoundFunction>(callable)) {\n    callable = b->getTarget(runtime);\n  }\n\n  // If it is a bytecode function, check the flags.\n  if (auto *func = dyn_vmcast<JSFunction>(callable)) {\n    auto *cb = func->getCodeBlock(runtime);\n    // Even though it doesn't make sense logically, we need to compile the\n    // function in order to access it flags.\n    if (LLVM_UNLIKELY(cb->lazyCompile(runtime) == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    return !func->getCodeBlock(runtime)->getHeaderFlags().isCallProhibited(\n        true);\n  }\n\n  // We check for NativeFunction since those are defined to not be\n  // constructible, with the exception of NativeConstructor.\n  if (!vmisa<NativeFunction>(callable) || vmisa<NativeConstructor>(callable)) {\n    return true;\n  }\n\n  // JSCallableProxy is a NativeFunction, but may or may not be a\n  // constructor, so we ask it.\n  if (auto *cproxy = dyn_vmcast<JSCallableProxy>(callable)) {\n    return cproxy->isConstructor(runtime);\n  }\n\n  return false;\n}", "target": 3, "idx": 12028}
{"commit_id": "c283e542a3f422420cfdb332414543b62fc4e4a5", "project": "tensorflow", "func": "void Compute(tensorflow::OpKernelContext* context) override {\n    for (int ngram_width : ngram_widths_) {\n      OP_REQUIRES(\n          context, ngram_width > 0,\n          errors::InvalidArgument(\"ngram_widths must contain positive values\"));\n    }\n\n    const tensorflow::Tensor* data;\n    OP_REQUIRES_OK(context, context->input(\"data\", &data));\n    const auto& input_data = data->flat<tstring>().data();\n\n    const tensorflow::Tensor* splits;\n    OP_REQUIRES_OK(context, context->input(\"data_splits\", &splits));\n    const auto& splits_vec = splits->flat<SPLITS_TYPE>();\n\n    // Validate that the splits are valid indices into data, only if there are\n    // splits specified.\n    const int input_data_size = data->flat<tstring>().size();\n    const int splits_vec_size = splits_vec.size();\n    if (splits_vec_size > 0) {\n      int prev_split = splits_vec(0);\n      OP_REQUIRES(context, prev_split == 0,\n                  errors::InvalidArgument(\"First split value must be 0, got \",\n                                          prev_split));\n      for (int i = 1; i < splits_vec_size; ++i) {\n        bool valid_splits = splits_vec(i) >= prev_split;\n        valid_splits = valid_splits && (splits_vec(i) <= input_data_size);\n        OP_REQUIRES(context, valid_splits,\n                    errors::InvalidArgument(\n                        \"Invalid split value \", splits_vec(i), \", must be in [\",\n                        prev_split, \", \", input_data_size, \"]\"));\n        prev_split = splits_vec(i);\n      }\n      OP_REQUIRES(context, prev_split == input_data_size,\n                  errors::InvalidArgument(\n                      \"Last split value must be data size. Expected \",\n                      input_data_size, \", got \", prev_split));\n    }\n\n    int num_batch_items = splits_vec.size() - 1;\n    tensorflow::Tensor* ngrams_splits;\n    OP_REQUIRES_OK(\n        context, context->allocate_output(1, splits->shape(), &ngrams_splits));\n    auto ngrams_splits_data = ngrams_splits->flat<SPLITS_TYPE>().data();\n\n    // If there is no data or size, return an empty RT.\n    if (data->flat<tstring>().size() == 0 || splits_vec.size() == 0) {\n      tensorflow::Tensor* empty;\n      OP_REQUIRES_OK(context,\n                     context->allocate_output(0, data->shape(), &empty));\n      for (int i = 0; i <= num_batch_items; ++i) {\n        ngrams_splits_data[i] = 0;\n      }\n      return;\n    }\n\n    ngrams_splits_data[0] = 0;\n    for (int i = 1; i <= num_batch_items; ++i) {\n      int length = splits_vec(i) - splits_vec(i - 1);\n      int num_ngrams = 0;\n      for (int ngram_width : ngram_widths_)\n        num_ngrams += get_num_ngrams(length, ngram_width);\n      if (preserve_short_ && length > 0 && num_ngrams == 0) {\n        num_ngrams = 1;\n      }\n      ngrams_splits_data[i] = ngrams_splits_data[i - 1] + num_ngrams;\n    }\n\n    tensorflow::Tensor* ngrams;\n    OP_REQUIRES_OK(\n        context,\n        context->allocate_output(\n            0, TensorShape({ngrams_splits_data[num_batch_items]}), &ngrams));\n    auto ngrams_data = ngrams->flat<tstring>().data();\n\n    for (int i = 0; i < num_batch_items; ++i) {\n      auto data_start = &input_data[splits_vec(i)];\n      int output_start_idx = ngrams_splits_data[i];\n      for (int ngram_width : ngram_widths_) {\n        auto output_start = &ngrams_data[output_start_idx];\n        int length = splits_vec(i + 1) - splits_vec(i);\n        int num_ngrams = get_num_ngrams(length, ngram_width);\n        CreateNgrams(data_start, output_start, num_ngrams, ngram_width);\n        output_start_idx += num_ngrams;\n      }\n      // If we're preserving short sequences, check to see if no sequence was\n      // generated by comparing the current output start idx to the original\n      // one (ngram_splits_data). If no ngrams were generated, then they will\n      // be equal (since we increment output_start_idx by num_ngrams every\n      // time we create a set of ngrams.)\n      if (preserve_short_ && output_start_idx == ngrams_splits_data[i]) {\n        int data_length = splits_vec(i + 1) - splits_vec(i);\n        // One legitimate reason to not have any ngrams when preserve_short_\n        // is true is if the sequence itself is empty. In that case, move on.\n        if (data_length == 0) {\n          continue;\n        }\n        // We don't have to worry about dynamic padding sizes here: if padding\n        // was dynamic, every sequence would have had sufficient padding to\n        // generate at least one ngram.\n        int ngram_width = data_length + 2 * pad_width_;\n        auto output_start = &ngrams_data[output_start_idx];\n        int num_ngrams = 1;\n        CreateNgrams(data_start, output_start, num_ngrams, ngram_width);\n      }\n    }\n  }", "target": 1, "idx": 12029}
{"commit_id": "08193b7f0cd3910256e00d599f0f3eb2519c44ca", "project": "facebook/hhvm", "func": "int64_t MemFile::readImpl(char *buffer, int64_t length) {\n  assertx(m_len != -1);\n  assertx(length > 0);\n  assertx(m_cursor >= 0);\n  int64_t remaining = m_len - m_cursor;\n  if (remaining < length) length = remaining;\n  if (length > 0) {\n    memcpy(buffer, (const void *)(m_data + m_cursor), length);\n    m_cursor += length;\n    return length;\n  }\n  return 0;\n}", "target": 3, "idx": 12030}
{"commit_id": "0b5a5258abbeaf8a0c3a18c7e753699787fdf46e", "project": "MariaDB/server", "func": "bool\nEvent_job_data::execute(THD *thd, bool drop)\n{\n  String sp_sql;\n#ifndef NO_EMBEDDED_ACCESS_CHECKS\n  Security_context event_sctx, *save_sctx= NULL;\n#endif\n  List<Item> empty_item_list;\n  bool ret= TRUE;\n\n  DBUG_ENTER(\"Event_job_data::execute\");\n\n  thd->reset_for_next_command();\n\n  /*\n    MySQL parser currently assumes that current database is either\n    present in THD or all names in all statements are fully specified.\n    And yet not fully specified names inside stored programs must be \n    be supported, even if the current database is not set:\n    CREATE PROCEDURE db1.p1() BEGIN CREATE TABLE t1; END//\n    -- in this example t1 should be always created in db1 and the statement\n    must parse even if there is no current database.\n\n    To support this feature and still address the parser limitation,\n    we need to set the current database here.\n    We don't have to call mysql_change_db, since the checks performed\n    in it are unnecessary for the purpose of parsing, and\n    mysql_change_db will be invoked anyway later, to activate the\n    procedure database before it's executed.\n  */\n  thd->set_db(dbname.str, dbname.length);\n\n  lex_start(thd);\n\n#ifndef NO_EMBEDDED_ACCESS_CHECKS\n  if (event_sctx.change_security_context(thd,\n                                         &definer_user, &definer_host,\n                                         &dbname, &save_sctx))\n  {\n    sql_print_error(\"Event Scheduler: \"\n                    \"[%s].[%s.%s] execution failed, \"\n                    \"failed to authenticate the user.\",\n                    definer.str, dbname.str, name.str);\n    goto end;\n  }\n#endif\n\n  if (check_access(thd, EVENT_ACL, dbname.str, NULL, NULL, 0, 0))\n  {\n    /*\n      This aspect of behavior is defined in the worklog,\n      and this is how triggers work too: if TRIGGER\n      privilege is revoked from trigger definer,\n      triggers are not executed.\n    */\n    sql_print_error(\"Event Scheduler: \"\n                    \"[%s].[%s.%s] execution failed, \"\n                    \"user no longer has EVENT privilege.\",\n                    definer.str, dbname.str, name.str);\n    goto end;\n  }\n\n  if (construct_sp_sql(thd, &sp_sql))\n    goto end;\n\n  /*\n    Set up global thread attributes to reflect the properties of\n    this Event. We can simply reset these instead of usual\n    backup/restore employed in stored programs since we know that\n    this is a top level statement and the worker thread is\n    allocated exclusively to execute this event.\n  */\n\n  thd->variables.sql_mode= sql_mode;\n  thd->variables.time_zone= time_zone;\n\n  thd->set_query(sp_sql.c_ptr_safe(), sp_sql.length());\n\n  {\n    Parser_state parser_state;\n    if (parser_state.init(thd, thd->query(), thd->query_length()))\n      goto end;\n\n    if (parse_sql(thd, & parser_state, creation_ctx))\n    {\n      sql_print_error(\"Event Scheduler: \"\n                      \"%serror during compilation of %s.%s\",\n                      thd->is_fatal_error ? \"fatal \" : \"\",\n                      (const char *) dbname.str, (const char *) name.str);\n      goto end;\n    }\n  }\n\n  {\n    sp_head *sphead= thd->lex->sphead;\n\n    DBUG_ASSERT(sphead);\n\n    sphead->m_flags|= sp_head::LOG_SLOW_STATEMENTS;\n    sphead->m_flags|= sp_head::LOG_GENERAL_LOG;\n\n    sphead->set_info(0, 0, &thd->lex->sp_chistics, sql_mode);\n    sphead->set_creation_ctx(creation_ctx);\n    sphead->optimize();\n\n    ret= sphead->execute_procedure(thd, &empty_item_list);\n    /*\n      There is no pre-locking and therefore there should be no\n      tables open and locked left after execute_procedure.\n    */\n  }\n\nend:\n  if (drop && !thd->is_fatal_error)\n  {\n    /*\n      We must do it here since here we're under the right authentication\n      ID of the event definer.\n    */\n    sql_print_information(\"Event Scheduler: Dropping %s.%s\",\n                          (const char *) dbname.str, (const char *) name.str);\n    /*\n      Construct a query for the binary log, to ensure the event is dropped\n      on the slave\n    */\n    if (construct_drop_event_sql(thd, &sp_sql))\n      ret= 1;\n    else\n    {\n      ulong saved_master_access;\n\n      thd->set_query(sp_sql.c_ptr_safe(), sp_sql.length());\n\n      /*\n        NOTE: even if we run in read-only mode, we should be able to lock\n        the mysql.event table for writing. In order to achieve this, we\n        should call mysql_lock_tables() under the super-user.\n\n        Same goes for transaction access mode.\n        Temporarily reset it to read-write.\n      */\n\n      saved_master_access= thd->security_ctx->master_access;\n      thd->security_ctx->master_access |= SUPER_ACL;\n      bool save_tx_read_only= thd->tx_read_only;\n      thd->tx_read_only= false;\n\n      /*\n         This code is processing event execution and does not have client\n         connection. Here, event execution will now execute a prepared\n         DROP EVENT statement, but thd->lex->sql_command is set to\n         SQLCOM_CREATE_PROCEDURE\n         DROP EVENT will be logged in binlog, and we have to\n         replicate it to make all nodes have consistent event definitions\n         Wsrep DDL replication is triggered inside Events::drop_event(),\n         and here we need to prepare the THD so that DDL replication is\n         possible, essentially it requires setting sql_command to\n         SQLCOMM_DROP_EVENT, we will switch sql_command for the duration\n         of DDL replication only.\n      */\n      const enum_sql_command sql_command_save= thd->lex->sql_command;\n      const bool sql_command_set= WSREP(thd);\n\n      if (sql_command_set)\n        thd->lex->sql_command = SQLCOM_DROP_EVENT;\n\n      ret= Events::drop_event(thd, dbname, name, FALSE);\n\n      if (sql_command_set)\n      {\n        WSREP_TO_ISOLATION_END;\n        thd->lex->sql_command = sql_command_save;\n      }\n\n      thd->tx_read_only= save_tx_read_only;\n      thd->security_ctx->master_access= saved_master_access;\n    }\n  }\n#ifndef NO_EMBEDDED_ACCESS_CHECKS\n  if (save_sctx)\n    event_sctx.restore_security_context(thd, save_sctx);\n#endif\n  thd->lex->unit.cleanup();\n  thd->end_statement();\n  thd->cleanup_after_query();\n  /* Avoid races with SHOW PROCESSLIST */\n  thd->reset_query();\n\n  DBUG_PRINT(\"info\", (\"EXECUTED %s.%s  ret: %d\", dbname.str, name.str, ret));\n\n  DBUG_RETURN(ret);\n}", "target": 2, "idx": 12031}
{"commit_id": "22af44e68a0c7d190ac1e25075e1382f77e9397a", "project": "pjsip/pjproject", "func": "PJ_DEF(pj_status_t) pjmedia_rtp_decode_rtp2(\n\t\t\t\t\t    pjmedia_rtp_session *ses,\n\t\t\t\t\t    const void *pkt, int pkt_len,\n\t\t\t\t\t    const pjmedia_rtp_hdr **hdr,\n\t\t\t\t\t    pjmedia_rtp_dec_hdr *dec_hdr,\n\t\t\t\t\t    const void **payload,\n\t\t\t\t\t    unsigned *payloadlen)\n{\n    int offset;\n\n    PJ_UNUSED_ARG(ses);\n\n    /* Assume RTP header at the start of packet. We'll verify this later. */\n    *hdr = (pjmedia_rtp_hdr*)pkt;\n\n    /* Check RTP header sanity. */\n    if ((*hdr)->v != RTP_VERSION) {\n\treturn PJMEDIA_RTP_EINVER;\n    }\n\n    /* Payload is located right after header plus CSRC */\n    offset = sizeof(pjmedia_rtp_hdr) + ((*hdr)->cc * sizeof(pj_uint32_t));\n\n    /* Decode RTP extension. */\n    if ((*hdr)->x) {\n        if (offset + sizeof (pjmedia_rtp_ext_hdr) > pkt_len)\n            return PJMEDIA_RTP_EINLEN;\n        dec_hdr->ext_hdr = (pjmedia_rtp_ext_hdr*)(((pj_uint8_t*)pkt) + offset);\n        dec_hdr->ext = (pj_uint32_t*)(dec_hdr->ext_hdr + 1);\n        dec_hdr->ext_len = pj_ntohs((dec_hdr->ext_hdr)->length);\n        offset += ((dec_hdr->ext_len + 1) * sizeof(pj_uint32_t));\n    } else {\n\tdec_hdr->ext_hdr = NULL;\n\tdec_hdr->ext = NULL;\n\tdec_hdr->ext_len = 0;\n    }\n\n    /* Check that offset is less than packet size */\n    if (offset > pkt_len)\n\treturn PJMEDIA_RTP_EINLEN;\n\n    /* Find and set payload. */\n    *payload = ((pj_uint8_t*)pkt) + offset;\n    *payloadlen = pkt_len - offset;\n \n    /* Remove payload padding if any */\n    if ((*hdr)->p && *payloadlen > 0) {\n\tpj_uint8_t pad_len;\n\n\tpad_len = ((pj_uint8_t*)(*payload))[*payloadlen - 1];\n\tif (pad_len <= *payloadlen)\n\t    *payloadlen -= pad_len;\n    }\n\n    return PJ_SUCCESS;\n}", "target": 3, "idx": 12032}
{"commit_id": "84ac7260236a49c79eede91617700174c2c19b0c", "project": "torvalds/linux", "func": "static int\npacket_setsockopt(struct socket *sock, int level, int optname, char __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct packet_sock *po = pkt_sk(sk);\n\tint ret;\n\n\tif (level != SOL_PACKET)\n\t\treturn -ENOPROTOOPT;\n\n\tswitch (optname) {\n\tcase PACKET_ADD_MEMBERSHIP:\n\tcase PACKET_DROP_MEMBERSHIP:\n\t{\n\t\tstruct packet_mreq_max mreq;\n\t\tint len = optlen;\n\t\tmemset(&mreq, 0, sizeof(mreq));\n\t\tif (len < sizeof(struct packet_mreq))\n\t\t\treturn -EINVAL;\n\t\tif (len > sizeof(mreq))\n\t\t\tlen = sizeof(mreq);\n\t\tif (copy_from_user(&mreq, optval, len))\n\t\t\treturn -EFAULT;\n\t\tif (len < (mreq.mr_alen + offsetof(struct packet_mreq, mr_address)))\n\t\t\treturn -EINVAL;\n\t\tif (optname == PACKET_ADD_MEMBERSHIP)\n\t\t\tret = packet_mc_add(sk, &mreq);\n\t\telse\n\t\t\tret = packet_mc_drop(sk, &mreq);\n\t\treturn ret;\n\t}\n\n\tcase PACKET_RX_RING:\n\tcase PACKET_TX_RING:\n\t{\n\t\tunion tpacket_req_u req_u;\n\t\tint len;\n\n\t\tswitch (po->tp_version) {\n\t\tcase TPACKET_V1:\n\t\tcase TPACKET_V2:\n\t\t\tlen = sizeof(req_u.req);\n\t\t\tbreak;\n\t\tcase TPACKET_V3:\n\t\tdefault:\n\t\t\tlen = sizeof(req_u.req3);\n\t\t\tbreak;\n\t\t}\n\t\tif (optlen < len)\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&req_u.req, optval, len))\n\t\t\treturn -EFAULT;\n\t\treturn packet_set_ring(sk, &req_u, 0,\n\t\t\toptname == PACKET_TX_RING);\n\t}\n\tcase PACKET_COPY_THRESH:\n\t{\n\t\tint val;\n\n\t\tif (optlen != sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\n\t\tpkt_sk(sk)->copy_thresh = val;\n\t\treturn 0;\n\t}\n\tcase PACKET_VERSION:\n\t{\n\t\tint val;\n\n\t\tif (optlen != sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\t\tswitch (val) {\n\t\tcase TPACKET_V1:\n\t\tcase TPACKET_V2:\n\t\tcase TPACKET_V3:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlock_sock(sk);\n\t\tif (po->rx_ring.pg_vec || po->tx_ring.pg_vec) {\n\t\t\tret = -EBUSY;\n\t\t} else {\n\t\t\tpo->tp_version = val;\n\t\t\tret = 0;\n\t\t}\n\t\trelease_sock(sk);\n\t\treturn ret;\n\t}\n\tcase PACKET_RESERVE:\n\t{\n\t\tunsigned int val;\n\n\t\tif (optlen != sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (po->rx_ring.pg_vec || po->tx_ring.pg_vec)\n\t\t\treturn -EBUSY;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\t\tpo->tp_reserve = val;\n\t\treturn 0;\n\t}\n\tcase PACKET_LOSS:\n\t{\n\t\tunsigned int val;\n\n\t\tif (optlen != sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (po->rx_ring.pg_vec || po->tx_ring.pg_vec)\n\t\t\treturn -EBUSY;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\t\tpo->tp_loss = !!val;\n\t\treturn 0;\n\t}\n\tcase PACKET_AUXDATA:\n\t{\n\t\tint val;\n\n\t\tif (optlen < sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\n\t\tpo->auxdata = !!val;\n\t\treturn 0;\n\t}\n\tcase PACKET_ORIGDEV:\n\t{\n\t\tint val;\n\n\t\tif (optlen < sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\n\t\tpo->origdev = !!val;\n\t\treturn 0;\n\t}\n\tcase PACKET_VNET_HDR:\n\t{\n\t\tint val;\n\n\t\tif (sock->type != SOCK_RAW)\n\t\t\treturn -EINVAL;\n\t\tif (po->rx_ring.pg_vec || po->tx_ring.pg_vec)\n\t\t\treturn -EBUSY;\n\t\tif (optlen < sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\n\t\tpo->has_vnet_hdr = !!val;\n\t\treturn 0;\n\t}\n\tcase PACKET_TIMESTAMP:\n\t{\n\t\tint val;\n\n\t\tif (optlen != sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\n\t\tpo->tp_tstamp = val;\n\t\treturn 0;\n\t}\n\tcase PACKET_FANOUT:\n\t{\n\t\tint val;\n\n\t\tif (optlen != sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\n\t\treturn fanout_add(sk, val & 0xffff, val >> 16);\n\t}\n\tcase PACKET_FANOUT_DATA:\n\t{\n\t\tif (!po->fanout)\n\t\t\treturn -EINVAL;\n\n\t\treturn fanout_set_data(po, optval, optlen);\n\t}\n\tcase PACKET_TX_HAS_OFF:\n\t{\n\t\tunsigned int val;\n\n\t\tif (optlen != sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (po->rx_ring.pg_vec || po->tx_ring.pg_vec)\n\t\t\treturn -EBUSY;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\t\tpo->tp_tx_has_off = !!val;\n\t\treturn 0;\n\t}\n\tcase PACKET_QDISC_BYPASS:\n\t{\n\t\tint val;\n\n\t\tif (optlen != sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\n\t\tpo->xmit = val ? packet_direct_xmit : dev_queue_xmit;\n\t\treturn 0;\n\t}\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n}", "target": 2, "idx": 12033}
{"commit_id": "e6cf28c72ba2eb949ca950d834dd6d66bb01cfae", "project": "tensorflow", "func": "void Compute(OpKernelContext* ctx) override {\n    const Tensor& a = ctx->input(0);\n    const Tensor& b = ctx->input(1);\n    OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(a.shape()),\n                errors::InvalidArgument(\"a is not a matrix\"));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(b.shape()),\n                errors::InvalidArgument(\"b is not a matrix\"));\n\n    const int m = transpose_a_ ? a.dim_size(1) : a.dim_size(0);\n    const int k = transpose_a_ ? a.dim_size(0) : a.dim_size(1);\n    const int n = transpose_b_ ? b.dim_size(0) : b.dim_size(1);\n    const int k2 = transpose_b_ ? b.dim_size(1) : b.dim_size(0);\n\n    OP_REQUIRES(ctx, k == k2,\n                errors::InvalidArgument(\n                    \"Matrix size incompatible: a: \", a.shape().DebugString(),\n                    \", b: \", b.shape().DebugString()));\n    OP_REQUIRES(ctx, m >= 0 && n >= 0 && k >= 0,\n                errors::InvalidArgument(\n                    \"Matrix dimensions cannot be negative: a: \",\n                    a.shape().DebugString(), \", b: \", b.shape().DebugString()));\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({m, n}), &output));\n\n    // Return early if at least one of the output dimension size is 0.\n    if (m == 0 || n == 0) {\n      return;\n    }\n\n    if (k == 0) {\n      // If the inner dimension k in the matrix multiplication is zero, we fill\n      // the output with zeros.\n      functor::SetZeroFunctor<CPUDevice, float> f;\n      f(ctx->eigen_device<CPUDevice>(), output->flat<float>());\n      return;\n    }\n\n    auto out = output->matrix<float>();\n\n    std::unique_ptr<Tensor> a_float;\n    std::unique_ptr<Tensor> b_float;\n    if (!a_is_sparse_ && !b_is_sparse_) {\n      auto left = &a;\n      auto right = &b;\n      // TODO(agarwal): multi-thread the conversions from bfloat16 to float.\n      if (std::is_same<TL, bfloat16>::value) {\n        a_float.reset(new Tensor(DT_FLOAT, a.shape()));\n        BFloat16ToFloat(a.flat<bfloat16>().data(),\n                        a_float->flat<float>().data(), a.NumElements());\n        left = a_float.get();\n      }\n      if (std::is_same<TR, bfloat16>::value) {\n        b_float.reset(new Tensor(DT_FLOAT, b.shape()));\n        BFloat16ToFloat(b.flat<bfloat16>().data(),\n                        b_float->flat<float>().data(), b.NumElements());\n        right = b_float.get();\n      }\n      Eigen::array<Eigen::IndexPair<Eigen::DenseIndex>, 1> dim_pair;\n      dim_pair[0].first = transpose_a_ ? 0 : 1;\n      dim_pair[0].second = transpose_b_ ? 1 : 0;\n\n      out.device(ctx->template eigen_device<CPUDevice>()) =\n          left->matrix<float>().contract(right->matrix<float>(), dim_pair);\n      return;\n    }\n\n    auto left = &a;\n    auto right = &b;\n    bool transpose_output = false;\n    bool transpose_a = transpose_a_;\n    bool transpose_b = transpose_b_;\n    if (!a_is_sparse_) {\n      // Swap the order of multiplications using the identity:\n      // A * B = (B' *  A')'.\n      std::swap(left, right);\n      std::swap(transpose_a, transpose_b);\n      transpose_a = !transpose_a;\n      transpose_b = !transpose_b;\n      transpose_output = !transpose_output;\n    }\n\n    std::unique_ptr<Tensor> right_tr;\n    if (transpose_b) {\n      // TODO(agarwal): avoid transposing the matrix here and directly handle\n      // transpose in CreateDenseSlices.\n      OP_REQUIRES(ctx, right->dim_size(0) != 0,\n                  errors::InvalidArgument(\"b has an entry 0 in it's shape.\"));\n      OP_REQUIRES(ctx, right->dim_size(1) != 0,\n                  errors::InvalidArgument(\"b has an entry 0 in it's shape.\"));\n      right_tr.reset(\n          new Tensor(right->dtype(),\n                     TensorShape({right->dim_size(1), right->dim_size(0)})));\n\n      const auto perm = dsizes_10();\n      if (transpose_output) {\n        right_tr->matrix<TL>().device(ctx->template eigen_device<CPUDevice>()) =\n            right->matrix<TL>().shuffle(perm);\n      } else {\n        right_tr->matrix<TR>().device(ctx->template eigen_device<CPUDevice>()) =\n            right->matrix<TR>().shuffle(perm);\n      }\n      right = right_tr.get();\n    }\n\n    if (transpose_output) {\n      DoMatMul<TR, TL>::Compute(&this->cache_tr_, left->matrix<TR>(),\n                                right->matrix<TL>(), transpose_a,\n                                ctx->device()->tensorflow_cpu_worker_threads(),\n                                transpose_output, &out);\n    } else {\n      DoMatMul<TL, TR>::Compute(&this->cache_nt_, left->matrix<TL>(),\n                                right->matrix<TR>(), transpose_a,\n                                ctx->device()->tensorflow_cpu_worker_threads(),\n                                transpose_output, &out);\n    }\n  }", "target": 2, "idx": 12034}
{"commit_id": "de1e67d0703894cb6ea782e36abb63976ab07e60", "project": "git", "func": "static void show_object(struct object *obj, const char *name, void *data)\n{\n\tadd_preferred_base_object(name);\n\tadd_object_entry(obj->oid.hash, obj->type, name, 0);\n\tobj->flags |= OBJECT_ADDED;\n}", "target": 3, "idx": 12035}
{"commit_id": "435a3e337bd9d4e11af61cf8b8afca067bf1a8aa", "project": "opencv", "func": "bool  Jpeg2KDecoder::readData( Mat& img )\n{\n    Ptr<Jpeg2KDecoder> close_this(this, Jpeg2KDecoder_close);\n    bool result = false;\n    int color = img.channels() > 1;\n    uchar* data = img.ptr();\n    size_t step = img.step;\n    jas_stream_t* stream = (jas_stream_t*)m_stream;\n    jas_image_t* image = (jas_image_t*)m_image;\n\n#ifndef _WIN32\n    // At least on some Linux instances the\n    // system libjasper segfaults when\n    // converting color to grey.\n    // We do this conversion manually at the end.\n    Mat clr;\n    if (CV_MAT_CN(img.type()) < CV_MAT_CN(this->type()))\n    {\n        clr.create(img.size().height, img.size().width, this->type());\n        color = true;\n        data = clr.ptr();\n        step = (int)clr.step;\n    }\n#endif\n\n    if( stream && image )\n    {\n        bool convert;\n        int colorspace;\n        if( color )\n        {\n            convert = (jas_image_clrspc( image ) != JAS_CLRSPC_SRGB);\n            colorspace = JAS_CLRSPC_SRGB;\n        }\n        else\n        {\n            convert = (jas_clrspc_fam( jas_image_clrspc( image ) ) != JAS_CLRSPC_FAM_GRAY);\n            colorspace = JAS_CLRSPC_SGRAY; // TODO GENGRAY or SGRAY? (GENGRAY fails on Win.)\n        }\n\n        // convert to the desired colorspace\n        if( convert )\n        {\n            jas_cmprof_t *clrprof = jas_cmprof_createfromclrspc( colorspace );\n            if( clrprof )\n            {\n                jas_image_t *_img = jas_image_chclrspc( image, clrprof, JAS_CMXFORM_INTENT_RELCLR );\n                if( _img )\n                {\n                    jas_image_destroy( image );\n                    m_image = image = _img;\n                    result = true;\n                }\n                else\n                {\n                    jas_cmprof_destroy(clrprof);\n                    CV_Error(Error::StsError, \"JPEG 2000 LOADER ERROR: cannot convert colorspace\");\n                }\n                jas_cmprof_destroy( clrprof );\n            }\n            else\n            {\n                CV_Error(Error::StsError, \"JPEG 2000 LOADER ERROR: unable to create colorspace\");\n            }\n        }\n        else\n            result = true;\n\n        if( result )\n        {\n            int ncmpts;\n            int cmptlut[3];\n            if( color )\n            {\n                cmptlut[0] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_RGB_B );\n                cmptlut[1] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_RGB_G );\n                cmptlut[2] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_RGB_R );\n                if( cmptlut[0] < 0 || cmptlut[1] < 0 || cmptlut[2] < 0 )\n                    result = false;\n                ncmpts = 3;\n            }\n            else\n            {\n                cmptlut[0] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_GRAY_Y );\n                if( cmptlut[0] < 0 )\n                    result = false;\n                ncmpts = 1;\n            }\n\n            if( result )\n            {\n                for( int i = 0; i < ncmpts; i++ )\n                {\n                    int maxval = 1 << jas_image_cmptprec( image, cmptlut[i] );\n                    int offset =  jas_image_cmptsgnd( image, cmptlut[i] ) ? maxval / 2 : 0;\n\n                    int yend = jas_image_cmptbry( image, cmptlut[i] );\n                    int ystep = jas_image_cmptvstep( image, cmptlut[i] );\n                    int xend = jas_image_cmptbrx( image, cmptlut[i] );\n                    int xstep = jas_image_cmpthstep( image, cmptlut[i] );\n\n                    jas_matrix_t *buffer = jas_matrix_create( yend / ystep, xend / xstep );\n                    if( buffer )\n                    {\n                        if( !jas_image_readcmpt( image, cmptlut[i], 0, 0, xend / xstep, yend / ystep, buffer ))\n                        {\n                            if( img.depth() == CV_8U )\n                                result = readComponent8u( data + i, buffer, validateToInt(step), cmptlut[i], maxval, offset, ncmpts );\n                            else\n                                result = readComponent16u( ((unsigned short *)data) + i, buffer, validateToInt(step / 2), cmptlut[i], maxval, offset, ncmpts );\n                            if( !result )\n                            {\n                                jas_matrix_destroy( buffer );\n                                CV_Error(Error::StsError, \"JPEG2000 LOADER ERROR: failed to read component\");\n                            }\n                        }\n                        jas_matrix_destroy( buffer );\n                    }\n                }\n            }\n        }\n        else\n        {\n            CV_Error(Error::StsError, \"JPEG2000 LOADER ERROR: colorspace conversion failed\");\n        }\n    }\n\n    CV_Assert(result == true);\n\n#ifndef _WIN32\n    if (!clr.empty())\n    {\n        cv::cvtColor(clr, img, COLOR_BGR2GRAY);\n    }\n#endif\n\n    return result;\n}", "target": 1, "idx": 12036}
{"commit_id": "dc96cdc27fb53e8595af67aaf68001033c808e42", "project": "libsixel", "func": "static void\ndiffuse_jajuni(unsigned char *data, int width, int height,\n               int x, int y, int depth, int error)\n{\n    int pos;\n\n    pos = y * width + x;\n\n    /* Jarvis, Judice & Ninke Method\n     *                  curr    7/48    5/48\n     *  3/48    5/48    7/48    5/48    3/48\n     *  1/48    3/48    5/48    3/48    1/48\n     */\n    if (pos < (height - 2) * width - 2) {\n        error_diffuse(data, pos + width * 0 + 1, depth, error, 7, 48, width * height);\n        error_diffuse(data, pos + width * 0 + 2, depth, error, 5, 48, width * height);\n        error_diffuse(data, pos + width * 1 - 2, depth, error, 3, 48, width * height);\n        error_diffuse(data, pos + width * 1 - 1, depth, error, 5, 48, width * height);\n        error_diffuse(data, pos + width * 1 + 0, depth, error, 7, 48, width * height);\n        error_diffuse(data, pos + width * 1 + 1, depth, error, 5, 48, width * height);\n        error_diffuse(data, pos + width * 1 + 2, depth, error, 3, 48, width * height);\n        error_diffuse(data, pos + width * 2 - 2, depth, error, 1, 48, width * height);\n        error_diffuse(data, pos + width * 2 - 1, depth, error, 3, 48, width * height);\n        error_diffuse(data, pos + width * 2 + 0, depth, error, 5, 48, width * height);\n        error_diffuse(data, pos + width * 2 + 1, depth, error, 3, 48, width * height);\n        error_diffuse(data, pos + width * 2 + 2, depth, error, 1, 48, width * height);\n    }\n}", "target": 2, "idx": 12037}
{"commit_id": "686cd0cc2bbf60bf04ce426a04d406e8e880b391", "project": "michaelrsweet/codedoc", "func": "static void\nhighlight_c_string(FILE       *fp,\t/* I  - Output file */\n                   const char *s,\t/* I  - String */\n                   int        *histate)\t/* IO - Highlighting state */\n{\n  const char\t*start = s,\t\t/* Start of code to highlight */\n\t\t*class_name = (*histate == HIGHLIGHT_COMMENT) ? \"comment\" : NULL;\n\t\t\t\t\t/* Class name for current fragment */\n  char\t\tkeyword[32],\t\t/* Current keyword */\n\t\t*keyptr = keyword;\t/* Pointer into keyword */\n\n\n  if (*histate == HIGHLIGHT_COMMENT)\n  {\n    if ((s = strstr(start, \"*/\")) != NULL)\n    {\n     /*\n      * Comment ends on this line...\n      */\n\n      s += 2;\n\n      fputs(\"<span class=\\\"comment\\\">\", fp);\n      write_string(fp, start, OUTPUT_HTML, s - start);\n      fputs(\"</span>\", fp);\n\n      start      = s;\n      *histate   = HIGHLIGHT_NONE;\n      class_name = NULL;\n    }\n    else if (*start)\n    {\n     /*\n      * Comment continues beyond the current line...\n      */\n\n      s = start + strlen(start) - 1;\n    }\n    else\n    {\n      goto done;\n    }\n  }\n  else if (*s == '#')\n  {\n   /*\n    * Preprocessor directive...\n    */\n\n    while (*s && *s != '\\n')\n    {\n      if (!strncmp(s, \"/*\", 2) || !strncmp(s, \"//\", 2))\n        break;\n\n      s ++;\n    }\n\n    fputs(\"<span class=\\\"directive\\\">\", fp);\n    write_string(fp, start, OUTPUT_HTML, s - start);\n    fputs(\"</span>\", fp);\n\n    start = s;\n  }\n\n  while (*s && *s != '\\n')\n  {\n    if (!strncmp(s, \"/*\", 2))\n    {\n     /*\n      * Start of a block comment...\n      */\n\n      if (s > start)\n      {\n       /*\n        * Output current fragment...\n        */\n\n\tif (class_name)\n\t{\n\t  fprintf(fp, \"<span class=\\\"%s\\\">\", class_name);\n\t  write_string(fp, start, OUTPUT_HTML, s - start);\n\t  fputs(\"</span>\", fp);\n\t}\n\telse\n\t{\n\t  write_string(fp, start, OUTPUT_HTML, s - start);\n\t}\n\n\tstart = s;\n      }\n\n     /*\n      * At this point, \"start\" points to the start of the comment...\n      */\n\n      if ((s = strstr(start, \"*/\")) != NULL)\n      {\n       /*\n        * Comment ends on the current line...\n        */\n\n        s += 2;\n\n\tfputs(\"<span class=\\\"comment\\\">\", fp);\n\twrite_string(fp, start, OUTPUT_HTML, s - start);\n\tfputs(\"</span>\", fp);\n\n\tstart      = s;\n\t*histate   = HIGHLIGHT_NONE;\n\tclass_name = NULL;\n      }\n      else\n      {\n       /*\n        * Comment continues to the next line...\n        */\n\n\ts          = start + strlen(start) - 1;\n\t*histate   = HIGHLIGHT_COMMENT;\n\tclass_name = \"comment\";\n\tbreak;\n      }\n    }\n    else if (!strncmp(s, \"//\", 2))\n    {\n     /*\n      * Start of C++ comment...\n      */\n\n      if (s > start)\n      {\n       /*\n        * Output current fragment...\n        */\n\n\tif (class_name)\n\t{\n\t  fprintf(fp, \"<span class=\\\"%s\\\">\", class_name);\n\t  write_string(fp, start, OUTPUT_HTML, s - start);\n\t  fputs(\"</span>\", fp);\n\t}\n\telse\n\t{\n\t  write_string(fp, start, OUTPUT_HTML, s - start);\n\t}\n\n\tstart = s;\n      }\n\n      s          = start + strlen(start) - 1;\n      *histate   = HIGHLIGHT_COMMENT1;\n      class_name = \"comment\";\n      break;\n    }\n    else if (*s == '\\\"' || *s == '\\'')\n    {\n     /*\n      * String/character constant...\n      */\n\n      if (s > start)\n      {\n       /*\n        * Output current fragment...\n        */\n\n\tif (class_name)\n\t{\n\t  fprintf(fp, \"<span class=\\\"%s\\\">\", class_name);\n\t  write_string(fp, start, OUTPUT_HTML, s - start);\n\t  fputs(\"</span>\", fp);\n\t}\n\telse\n\t{\n\t  write_string(fp, start, OUTPUT_HTML, s - start);\n\t}\n\n\tstart = s;\n      }\n\n      for (s = start + 1; *s && *s != *start; s ++)\n      {\n        if (*s == '\\\\' && s[1])\n          s ++;\n      }\n\n      if (*s == *start)\n        s ++;\n\n      fputs(\"<span class=\\\"string\\\">\", fp);\n      write_string(fp, start, OUTPUT_HTML, s - start);\n      fputs(\"</span>\", fp);\n\n      start = s;\n    }\n    else\n    {\n      if (isalnum(*s & 255) || *s == '_' || *s == '.')\n      {\n       /*\n        * Number or keyword...\n        */\n\n\tif (*histate == HIGHLIGHT_NONE)\n\t{\n\t  if (s > start && *histate == HIGHLIGHT_NONE)\n\t  {\n\t   /*\n\t    * End current fragment...\n\t    */\n\n\t    write_string(fp, start, OUTPUT_HTML, s - start);\n\t    start = s;\n\t  }\n\n\t  if (isdigit(*s & 255) || (*s == '.' && isdigit(s[1] & 255)))\n\t  {\n\t    *histate   = HIGHLIGHT_NUMBER;\n\t    class_name = \"number\";\n\t  }\n\t  else\n\t  {\n\t    *histate = HIGHLIGHT_RESERVED;\n\t  }\n\t}\n\n        if (*histate == HIGHLIGHT_RESERVED && keyptr < (keyword + sizeof(keyword) - 1))\n          *keyptr++ = *s;\n      }\n      else if (*histate == HIGHLIGHT_NUMBER)\n      {\n       /*\n        * End of number...\n        */\n\n\tfprintf(fp, \"<span class=\\\"%s\\\">\", class_name);\n\twrite_string(fp, start, OUTPUT_HTML, s - start);\n\tfputs(\"</span>\", fp);\n\n\tstart      = s;\n\t*histate   = HIGHLIGHT_NONE;\n\tclass_name = NULL;\n      }\n      else if (*histate == HIGHLIGHT_RESERVED)\n      {\n       /*\n        * End of reserved word?\n        */\n\n        *keyptr = '\\0';\n        keyptr  = keyword;\n\n        if (is_reserved(keyword))\n        {\n         /*\n          * Yes, reserved word...\n          */\n\n\t  fputs(\"<span class=\\\"reserved\\\">\", fp);\n\t  write_string(fp, start, OUTPUT_HTML, s - start);\n\t  fputs(\"</span>\", fp);\n        }\n        else\n        {\n         /*\n          * Just some other text...\n          */\n\n\t  write_string(fp, start, OUTPUT_HTML, s - start);\n        }\n\n        start    = s;\n        *histate = HIGHLIGHT_NONE;\n      }\n\n      s ++;\n    }\n  }\n\n  if (s > start)\n  {\n    if (class_name)\n    {\n      fprintf(fp, \"<span class=\\\"%s\\\">\", class_name);\n      write_string(fp, start, OUTPUT_HTML, s - start);\n      fputs(\"</span>\", fp);\n    }\n    else if (*histate == HIGHLIGHT_RESERVED)\n    {\n      *keyptr = '\\0';\n      keyptr  = keyword;\n\n      if (is_reserved(keyword))\n      {\n       /*\n\t* Yes, reserved word...\n\t*/\n\n\tfputs(\"<span class=\\\"reserved\\\">\", fp);\n\twrite_string(fp, start, OUTPUT_HTML, s - start);\n\tfputs(\"</span>\", fp);\n      }\n      else\n      {\n       /*\n\t* Just some other text...\n\t*/\n\n\twrite_string(fp, start, OUTPUT_HTML, s - start);\n      }\n    }\n    else\n    {\n      write_string(fp, start, OUTPUT_HTML, s - start);\n    }\n  }\n\n  done:\n\n  if (*histate != HIGHLIGHT_COMMENT)\n    *histate = HIGHLIGHT_NONE;\n\n  putc('\\n', fp);\n}", "target": 1, "idx": 12038}
{"commit_id": "ffb35baac6981f9e8914f8f3bffd37f284b85970", "project": "krb5", "func": "krb5_error_code\nkdc_process_s4u2proxy_req(kdc_realm_t *kdc_active_realm,\n                          krb5_kdc_req *request,\n                          const krb5_enc_tkt_part *t2enc,\n                          const krb5_db_entry *server,\n                          krb5_const_principal server_princ,\n                          krb5_const_principal proxy_princ,\n                          const char **status)\n{\n    krb5_error_code errcode;\n\n    /*\n     * Constrained delegation is mutually exclusive with renew/forward/etc.\n     * We can assert from this check that the header ticket was a TGT, as\n     * that is validated previously in validate_tgs_request().\n     */\n    if (request->kdc_options & (NON_TGT_OPTION | KDC_OPT_ENC_TKT_IN_SKEY)) {\n        *status = \"INVALID_S4U2PROXY_OPTIONS\";\n        return KRB5KDC_ERR_BADOPTION;\n    }\n\n    /* Ensure that evidence ticket server matches TGT client */\n    if (!krb5_principal_compare(kdc_context,\n                                server->princ, /* after canon */\n                                server_princ)) {\n        *status = \"EVIDENCE_TICKET_MISMATCH\";\n        return KRB5KDC_ERR_SERVER_NOMATCH;\n    }\n\n    if (!isflagset(t2enc->flags, TKT_FLG_FORWARDABLE)) {\n        *status = \"EVIDENCE_TKT_NOT_FORWARDABLE\";\n        return KRB5_TKT_NOT_FORWARDABLE;\n    }\n\n    /* Backend policy check */\n    errcode = check_allowed_to_delegate_to(kdc_context,\n                                           t2enc->client,\n                                           server,\n                                           proxy_princ);\n    if (errcode) {\n        *status = \"NOT_ALLOWED_TO_DELEGATE\";\n        return errcode;\n    }\n\n    return 0;\n}", "target": 1, "idx": 12039}
{"commit_id": "48a992727d82cb7db076fa15d372178743b1f4cd", "project": "torvalds/linux", "func": "static inline bool mcryptd_check_internal(struct rtattr **tb, u32 *type,\n\t\t\t\t\t  u32 *mask)\n{\n\tstruct crypto_attr_type *algt;\n\n\talgt = crypto_get_attr_type(tb);\n\tif (IS_ERR(algt))\n\t\treturn false;\n\n\t*type |= algt->type & CRYPTO_ALG_INTERNAL;\n\t*mask |= algt->mask & CRYPTO_ALG_INTERNAL;\n\n\tif (*type & *mask & CRYPTO_ALG_INTERNAL)\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "target": 1, "idx": 12040}
{"commit_id": "37deefd01f0875e133ea967122e3a5e421b8fcd9", "project": "uNetworking/uWebSockets", "func": "bool WebSocketProtocol<isServer>::handleFragment(char *data, size_t length, unsigned int remainingBytes, int opCode, bool fin, void *user) {\n    uS::Socket s((uv_poll_t *) user);\n    typename WebSocket<isServer>::Data *webSocketData = (typename WebSocket<isServer>::Data *) s.getSocketData();\n\n    if (opCode < 3) {\n        if (!remainingBytes && fin && !webSocketData->fragmentBuffer.length()) {\n            if (webSocketData->compressionStatus == WebSocket<isServer>::Data::CompressionStatus::COMPRESSED_FRAME) {\n                webSocketData->compressionStatus = WebSocket<isServer>::Data::CompressionStatus::ENABLED;\n                Hub *hub = ((Group<isServer> *) s.getSocketData()->nodeData)->hub;\n                data = hub->inflate(data, length);\n                if (!data) {\n                    forceClose(user);\n                    return true;\n                }\n            }\n\n            if (opCode == 1 && !isValidUtf8((unsigned char *) data, length)) {\n                forceClose(user);\n                return true;\n            }\n\n            ((Group<isServer> *) s.getSocketData()->nodeData)->messageHandler(WebSocket<isServer>(s), data, length, (OpCode) opCode);\n            if (s.isClosed() || s.isShuttingDown()) {\n                return true;\n            }\n        } else {\n            webSocketData->fragmentBuffer.append(data, length);\n            if (!remainingBytes && fin) {\n                length = webSocketData->fragmentBuffer.length();\n                if (webSocketData->compressionStatus == WebSocket<isServer>::Data::CompressionStatus::COMPRESSED_FRAME) {\n                    webSocketData->compressionStatus = WebSocket<isServer>::Data::CompressionStatus::ENABLED;\n                    Hub *hub = ((Group<isServer> *) s.getSocketData()->nodeData)->hub;\n                    webSocketData->fragmentBuffer.append(\"....\");\n                    data = hub->inflate((char *) webSocketData->fragmentBuffer.data(), length);\n                    if (!data) {\n                        forceClose(user);\n                        return true;\n                    }\n                } else {\n                    data = (char *) webSocketData->fragmentBuffer.data();\n                }\n\n                if (opCode == 1 && !isValidUtf8((unsigned char *) data, length)) {\n                    forceClose(user);\n                    return true;\n                }\n\n                ((Group<isServer> *) s.getSocketData()->nodeData)->messageHandler(WebSocket<isServer>(s), data, length, (OpCode) opCode);\n                if (s.isClosed() || s.isShuttingDown()) {\n                    return true;\n                }\n                webSocketData->fragmentBuffer.clear();\n            }\n        }\n    } else {\n        // todo: we don't need to buffer up in most cases!\n        webSocketData->controlBuffer.append(data, length);\n        if (!remainingBytes && fin) {\n            if (opCode == CLOSE) {\n                CloseFrame closeFrame = parseClosePayload((char *) webSocketData->controlBuffer.data(), webSocketData->controlBuffer.length());\n                WebSocket<isServer>(s).close(closeFrame.code, closeFrame.message, closeFrame.length);\n                return true;\n            } else {\n                if (opCode == PING) {\n                    WebSocket<isServer>(s).send(webSocketData->controlBuffer.data(), webSocketData->controlBuffer.length(), (OpCode) OpCode::PONG);\n                    ((Group<isServer> *) s.getSocketData()->nodeData)->pingHandler(WebSocket<isServer>(s), (char *) webSocketData->controlBuffer.data(), webSocketData->controlBuffer.length());\n                    if (s.isClosed() || s.isShuttingDown()) {\n                        return true;\n                    }\n                } else if (opCode == PONG) {\n                    ((Group<isServer> *) s.getSocketData()->nodeData)->pongHandler(WebSocket<isServer>(s), (char *) webSocketData->controlBuffer.data(), webSocketData->controlBuffer.length());\n                    if (s.isClosed() || s.isShuttingDown()) {\n                        return true;\n                    }\n                }\n            }\n            webSocketData->controlBuffer.clear();\n        }\n    }\n\n    return false;\n}", "target": 1, "idx": 12041}
{"commit_id": "5411543a310a470b1257fb93273cdd6e8dfcb3af", "project": "radareorg/radare2", "func": "static char *__filterShell(const char *arg) {\n\tr_return_val_if_fail (arg, NULL);\n\tchar *a = malloc (strlen (arg) + 1);\n\tif (!a) {\n\t\treturn NULL;\n\t}\n\tchar *b = a;\n\twhile (*arg) {\n\t\tchar ch = *arg;\n\t\tswitch (ch) {\n\t\tcase '@':\n\t\tcase '`':\n\t\tcase '|':\n\t\tcase ';':\n\t\tcase '=':\n\t\tcase '\\n':\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*b++ = ch;\n\t\t\tbreak;\n\t\t}\n\t\targ++;\n\t}\n\t*b = 0;\n\treturn a;\n}", "target": 2, "idx": 12042}
{"commit_id": "d58c96946b2880991d63d1dacacb32f0a4dfa453", "project": "tensorflow", "func": "TfLiteStatus Subgraph::AddNodeWithParameters(\n    const std::vector<int>& inputs, const std::vector<int>& outputs,\n    const std::vector<int>& intermediates, const char* init_data,\n    size_t init_data_size, void* builtin_data,\n    const TfLiteRegistration* registration, int* node_index) {\n  std::unique_ptr<void, decltype(free)*> builtin_data_deleter(builtin_data,\n                                                              free);\n  if (state_ == kStateInvokableAndImmutable) {\n    ReportError(\"AddNodeWithParameters is disallowed when graph is immutable.\");\n    return kTfLiteError;\n  }\n  state_ = kStateUninvokable;\n\n  TF_LITE_ENSURE_OK(&context_, CheckTensorIndices(\"node inputs\", inputs.data(),\n                                                  inputs.size()));\n  TF_LITE_ENSURE_OK(\n      &context_,\n      CheckTensorIndices(\"node outputs\", outputs.data(), outputs.size()));\n\n  // For builtin ops, inputs and outputs must not overlap. Custom ops must do\n  // this check by themselves if they don't support overlapping tensors. This\n  // distinction is to allow custom ops to just forward a tensor, reusing it as\n  // both input and output.\n  if (builtin_data != nullptr) {\n    TF_LITE_ENSURE_OK(&context_, CheckInputAndOutputForOverlap(\n                                     inputs.data(), inputs.size(),\n                                     outputs.data(), outputs.size()));\n  }\n\n  int new_node_index = nodes_and_registration_.size();\n  if (node_index) *node_index = new_node_index;\n  nodes_and_registration_.resize(nodes_and_registration_.size() + 1);\n  auto& node_and_reg = nodes_and_registration_.back();\n  TfLiteNode& node = node_and_reg.first;\n  if (node.inputs) TfLiteIntArrayFree(node.inputs);\n  if (node.outputs) TfLiteIntArrayFree(node.outputs);\n  if (node.intermediates) TfLiteIntArrayFree(node.intermediates);\n  if (node.temporaries) TfLiteIntArrayFree(node.temporaries);\n\n  // NOTE, here we are not using move semantics yet, since our internal\n  // representation isn't std::vector, but in the future we would like to avoid\n  // copies, so we want the interface to take r-value references now.\n  node.inputs = ConvertVectorToTfLiteIntArray(inputs);\n  node.outputs = ConvertVectorToTfLiteIntArray(outputs);\n  node.intermediates = ConvertVectorToTfLiteIntArray(intermediates);\n  node.temporaries = TfLiteIntArrayCreate(0);\n  if (init_data) {\n    node.user_data = OpInit(*registration, init_data, init_data_size);\n  } else {\n    node.user_data = OpInit(\n        *registration, static_cast<const char*>(builtin_data_deleter.get()), 0);\n  }\n\n  node.builtin_data = builtin_data_deleter.release();\n  // TODO(ycling): Filling `custom_initial_data` and `custom_initial_data_size`\n  // properly for nodes generated by ReplaceNodeSubsetsWithDelegateKernels.\n\n  if (registration->builtin_code == BuiltinOperator_CUSTOM) {\n    // When it's a CUSTOM op, the `custom_options` field in the Flatbuffer\n    // `Operator` table is passed in.\n    node.custom_initial_data = init_data;\n    node.custom_initial_data_size = init_data_size;\n  } else {\n    node.custom_initial_data = nullptr;\n    node.custom_initial_data_size = 0;\n  }\n\n  node.delegate = nullptr;\n  // Copying of registration is required to support unresolved custom ops.\n  node_and_reg.second = *registration;\n  execution_plan_.push_back(new_node_index);\n  return kTfLiteOk;\n}", "target": 1, "idx": 12043}
{"commit_id": "01ea173e103edd5ec41acec65b9261b87e123fc2", "project": "torvalds/linux", "func": "static int\nxfs_init_new_inode(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*pip,\n\txfs_ino_t\t\tino,\n\tumode_t\t\t\tmode,\n\txfs_nlink_t\t\tnlink,\n\tdev_t\t\t\trdev,\n\tprid_t\t\t\tprid,\n\tstruct xfs_inode\t**ipp)\n{\n\tstruct inode\t\t*dir = pip ? VFS_I(pip) : NULL;\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_inode\t*ip;\n\tunsigned int\t\tflags;\n\tint\t\t\terror;\n\tstruct timespec64\ttv;\n\tstruct inode\t\t*inode;\n\n\t/*\n\t * Protect against obviously corrupt allocation btree records. Later\n\t * xfs_iget checks will catch re-allocation of other active in-memory\n\t * and on-disk inodes. If we don't catch reallocating the parent inode\n\t * here we will deadlock in xfs_iget() so we have to do these checks\n\t * first.\n\t */\n\tif ((pip && ino == pip->i_ino) || !xfs_verify_dir_ino(mp, ino)) {\n\t\txfs_alert(mp, \"Allocated a known in-use inode 0x%llx!\", ino);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/*\n\t * Get the in-core inode with the lock held exclusively to prevent\n\t * others from looking at until we're done.\n\t */\n\terror = xfs_iget(mp, tp, ino, XFS_IGET_CREATE, XFS_ILOCK_EXCL, &ip);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(ip != NULL);\n\tinode = VFS_I(ip);\n\tset_nlink(inode, nlink);\n\tinode->i_rdev = rdev;\n\tip->i_d.di_projid = prid;\n\n\tif (dir && !(dir->i_mode & S_ISGID) &&\n\t    (mp->m_flags & XFS_MOUNT_GRPID)) {\n\t\tinode->i_uid = current_fsuid();\n\t\tinode->i_gid = dir->i_gid;\n\t\tinode->i_mode = mode;\n\t} else {\n\t\tinode_init_owner(inode, dir, mode);\n\t}\n\n\t/*\n\t * If the group ID of the new file does not match the effective group\n\t * ID or one of the supplementary group IDs, the S_ISGID bit is cleared\n\t * (and only if the irix_sgid_inherit compatibility variable is set).\n\t */\n\tif (irix_sgid_inherit &&\n\t    (inode->i_mode & S_ISGID) && !in_group_p(inode->i_gid))\n\t\tinode->i_mode &= ~S_ISGID;\n\n\tip->i_d.di_size = 0;\n\tip->i_df.if_nextents = 0;\n\tASSERT(ip->i_d.di_nblocks == 0);\n\n\ttv = current_time(inode);\n\tinode->i_mtime = tv;\n\tinode->i_atime = tv;\n\tinode->i_ctime = tv;\n\n\tip->i_d.di_extsize = 0;\n\tip->i_d.di_dmevmask = 0;\n\tip->i_d.di_dmstate = 0;\n\tip->i_d.di_flags = 0;\n\n\tif (xfs_sb_version_has_v3inode(&mp->m_sb)) {\n\t\tinode_set_iversion(inode, 1);\n\t\tip->i_d.di_flags2 = mp->m_ino_geo.new_diflags2;\n\t\tip->i_d.di_cowextsize = 0;\n\t\tip->i_d.di_crtime = tv;\n\t}\n\n\tflags = XFS_ILOG_CORE;\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFSOCK:\n\t\tip->i_df.if_format = XFS_DINODE_FMT_DEV;\n\t\tip->i_df.if_flags = 0;\n\t\tflags |= XFS_ILOG_DEV;\n\t\tbreak;\n\tcase S_IFREG:\n\tcase S_IFDIR:\n\t\tif (pip && (pip->i_d.di_flags & XFS_DIFLAG_ANY))\n\t\t\txfs_inode_inherit_flags(ip, pip);\n\t\tif (pip && (pip->i_d.di_flags2 & XFS_DIFLAG2_ANY))\n\t\t\txfs_inode_inherit_flags2(ip, pip);\n\t\t/* FALLTHROUGH */\n\tcase S_IFLNK:\n\t\tip->i_df.if_format = XFS_DINODE_FMT_EXTENTS;\n\t\tip->i_df.if_flags = XFS_IFEXTENTS;\n\t\tip->i_df.if_bytes = 0;\n\t\tip->i_df.if_u1.if_root = NULL;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t}\n\n\t/*\n\t * Log the new values stuffed into the inode.\n\t */\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\txfs_trans_log_inode(tp, ip, flags);\n\n\t/* now that we have an i_mode we can setup the inode structure */\n\txfs_setup_inode(ip);\n\n\t*ipp = ip;\n\treturn 0;\n}", "target": 2, "idx": 12044}
{"commit_id": "d527f51331cace562393a8038d870b3e9916686f", "project": "torvalds/linux", "func": "int\ncompound_send_recv(const unsigned int xid, struct cifs_ses *ses,\n\t\t   struct TCP_Server_Info *server,\n\t\t   const int flags, const int num_rqst, struct smb_rqst *rqst,\n\t\t   int *resp_buf_type, struct kvec *resp_iov)\n{\n\tint i, j, optype, rc = 0;\n\tstruct mid_q_entry *midQ[MAX_COMPOUND];\n\tbool cancelled_mid[MAX_COMPOUND] = {false};\n\tstruct cifs_credits credits[MAX_COMPOUND] = {\n\t\t{ .value = 0, .instance = 0 }\n\t};\n\tunsigned int instance;\n\tchar *buf;\n\n\toptype = flags & CIFS_OP_MASK;\n\n\tfor (i = 0; i < num_rqst; i++)\n\t\tresp_buf_type[i] = CIFS_NO_BUFFER;  /* no response buf yet */\n\n\tif (!ses || !ses->server || !server) {\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tspin_lock(&server->srv_lock);\n\tif (server->tcpStatus == CifsExiting) {\n\t\tspin_unlock(&server->srv_lock);\n\t\treturn -ENOENT;\n\t}\n\tspin_unlock(&server->srv_lock);\n\n\t/*\n\t * Wait for all the requests to become available.\n\t * This approach still leaves the possibility to be stuck waiting for\n\t * credits if the server doesn't grant credits to the outstanding\n\t * requests and if the client is completely idle, not generating any\n\t * other requests.\n\t * This can be handled by the eventual session reconnect.\n\t */\n\trc = wait_for_compound_request(server, num_rqst, flags,\n\t\t\t\t       &instance);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (i = 0; i < num_rqst; i++) {\n\t\tcredits[i].value = 1;\n\t\tcredits[i].instance = instance;\n\t}\n\n\t/*\n\t * Make sure that we sign in the same order that we send on this socket\n\t * and avoid races inside tcp sendmsg code that could cause corruption\n\t * of smb data.\n\t */\n\n\tcifs_server_lock(server);\n\n\t/*\n\t * All the parts of the compound chain belong obtained credits from the\n\t * same session. We can not use credits obtained from the previous\n\t * session to send this request. Check if there were reconnects after\n\t * we obtained credits and return -EAGAIN in such cases to let callers\n\t * handle it.\n\t */\n\tif (instance != server->reconnect_instance) {\n\t\tcifs_server_unlock(server);\n\t\tfor (j = 0; j < num_rqst; j++)\n\t\t\tadd_credits(server, &credits[j], optype);\n\t\treturn -EAGAIN;\n\t}\n\n\tfor (i = 0; i < num_rqst; i++) {\n\t\tmidQ[i] = server->ops->setup_request(ses, server, &rqst[i]);\n\t\tif (IS_ERR(midQ[i])) {\n\t\t\trevert_current_mid(server, i);\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tdelete_mid(midQ[j]);\n\t\t\tcifs_server_unlock(server);\n\n\t\t\t/* Update # of requests on wire to server */\n\t\t\tfor (j = 0; j < num_rqst; j++)\n\t\t\t\tadd_credits(server, &credits[j], optype);\n\t\t\treturn PTR_ERR(midQ[i]);\n\t\t}\n\n\t\tmidQ[i]->mid_state = MID_REQUEST_SUBMITTED;\n\t\tmidQ[i]->optype = optype;\n\t\t/*\n\t\t * Invoke callback for every part of the compound chain\n\t\t * to calculate credits properly. Wake up this thread only when\n\t\t * the last element is received.\n\t\t */\n\t\tif (i < num_rqst - 1)\n\t\t\tmidQ[i]->callback = cifs_compound_callback;\n\t\telse\n\t\t\tmidQ[i]->callback = cifs_compound_last_callback;\n\t}\n\trc = smb_send_rqst(server, num_rqst, rqst, flags);\n\n\tfor (i = 0; i < num_rqst; i++)\n\t\tcifs_save_when_sent(midQ[i]);\n\n\tif (rc < 0) {\n\t\trevert_current_mid(server, num_rqst);\n\t\tserver->sequence_number -= 2;\n\t}\n\n\tcifs_server_unlock(server);\n\n\t/*\n\t * If sending failed for some reason or it is an oplock break that we\n\t * will not receive a response to - return credits back\n\t */\n\tif (rc < 0 || (flags & CIFS_NO_SRV_RSP)) {\n\t\tfor (i = 0; i < num_rqst; i++)\n\t\t\tadd_credits(server, &credits[i], optype);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * At this point the request is passed to the network stack - we assume\n\t * that any credits taken from the server structure on the client have\n\t * been spent and we can't return them back. Once we receive responses\n\t * we will collect credits granted by the server in the mid callbacks\n\t * and add those credits to the server structure.\n\t */\n\n\t/*\n\t * Compounding is never used during session establish.\n\t */\n\tspin_lock(&ses->ses_lock);\n\tif ((ses->ses_status == SES_NEW) || (optype & CIFS_NEG_OP) || (optype & CIFS_SESS_OP)) {\n\t\tspin_unlock(&ses->ses_lock);\n\n\t\tcifs_server_lock(server);\n\t\tsmb311_update_preauth_hash(ses, server, rqst[0].rq_iov, rqst[0].rq_nvec);\n\t\tcifs_server_unlock(server);\n\n\t\tspin_lock(&ses->ses_lock);\n\t}\n\tspin_unlock(&ses->ses_lock);\n\n\tfor (i = 0; i < num_rqst; i++) {\n\t\trc = wait_for_response(server, midQ[i]);\n\t\tif (rc != 0)\n\t\t\tbreak;\n\t}\n\tif (rc != 0) {\n\t\tfor (; i < num_rqst; i++) {\n\t\t\tcifs_server_dbg(FYI, \"Cancelling wait for mid %llu cmd: %d\\n\",\n\t\t\t\t midQ[i]->mid, le16_to_cpu(midQ[i]->command));\n\t\t\tsend_cancel(server, &rqst[i], midQ[i]);\n\t\t\tspin_lock(&server->mid_lock);\n\t\t\tmidQ[i]->mid_flags |= MID_WAIT_CANCELLED;\n\t\t\tif (midQ[i]->mid_state == MID_REQUEST_SUBMITTED ||\n\t\t\t    midQ[i]->mid_state == MID_RESPONSE_RECEIVED) {\n\t\t\t\tmidQ[i]->callback = cifs_cancelled_callback;\n\t\t\t\tcancelled_mid[i] = true;\n\t\t\t\tcredits[i].value = 0;\n\t\t\t}\n\t\t\tspin_unlock(&server->mid_lock);\n\t\t}\n\t}\n\n\tfor (i = 0; i < num_rqst; i++) {\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\n\t\trc = cifs_sync_mid_result(midQ[i], server);\n\t\tif (rc != 0) {\n\t\t\t/* mark this mid as cancelled to not free it below */\n\t\t\tcancelled_mid[i] = true;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!midQ[i]->resp_buf ||\n\t\t    midQ[i]->mid_state != MID_RESPONSE_READY) {\n\t\t\trc = -EIO;\n\t\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tbuf = (char *)midQ[i]->resp_buf;\n\t\tresp_iov[i].iov_base = buf;\n\t\tresp_iov[i].iov_len = midQ[i]->resp_buf_size +\n\t\t\tHEADER_PREAMBLE_SIZE(server);\n\n\t\tif (midQ[i]->large_buf)\n\t\t\tresp_buf_type[i] = CIFS_LARGE_BUFFER;\n\t\telse\n\t\t\tresp_buf_type[i] = CIFS_SMALL_BUFFER;\n\n\t\trc = server->ops->check_receive(midQ[i], server,\n\t\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t\t/* mark it so buf will not be freed by delete_mid */\n\t\tif ((flags & CIFS_NO_RSP_BUF) == 0)\n\t\t\tmidQ[i]->resp_buf = NULL;\n\n\t}\n\n\t/*\n\t * Compounding is never used during session establish.\n\t */\n\tspin_lock(&ses->ses_lock);\n\tif ((ses->ses_status == SES_NEW) || (optype & CIFS_NEG_OP) || (optype & CIFS_SESS_OP)) {\n\t\tstruct kvec iov = {\n\t\t\t.iov_base = resp_iov[0].iov_base,\n\t\t\t.iov_len = resp_iov[0].iov_len\n\t\t};\n\t\tspin_unlock(&ses->ses_lock);\n\t\tcifs_server_lock(server);\n\t\tsmb311_update_preauth_hash(ses, server, &iov, 1);\n\t\tcifs_server_unlock(server);\n\t\tspin_lock(&ses->ses_lock);\n\t}\n\tspin_unlock(&ses->ses_lock);\n\nout:\n\t/*\n\t * This will dequeue all mids. After this it is important that the\n\t * demultiplex_thread will not process any of these mids any futher.\n\t * This is prevented above by using a noop callback that will not\n\t * wake this thread except for the very last PDU.\n\t */\n\tfor (i = 0; i < num_rqst; i++) {\n\t\tif (!cancelled_mid[i])\n\t\t\tdelete_mid(midQ[i]);\n\t}\n\n\treturn rc;\n}", "target": 1, "idx": 12045}
{"commit_id": "c4f37d77b29ec6a9754795d0efb6f68d633728d9", "project": "wireshark", "func": "static gint dissect_PHSCALE(tvbuff_t *tvb, proto_tree *tree, gint offset, gint cnt)\n{\n\tproto_tree *temp_tree;\n\tgint i;\n\n\tif (0 == cnt) {\n\t\treturn offset;\n\t}\n\n\ttemp_tree = proto_tree_add_subtree_format(tree, tvb, offset, 12 * cnt, ett_conf_phconv, NULL,\n\t\t\t\t\t\t  \"Phasor scaling and data flags (%u)\", cnt);\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tproto_tree *single_phasor_scaling_and_flags_tree;\n\t\tproto_tree *phasor_flag1_tree;\n\t\tproto_tree *phasor_flag2_tree;\n\t\tproto_tree *data_flag_tree;\n\n\t\tsingle_phasor_scaling_and_flags_tree = proto_tree_add_subtree_format(temp_tree, tvb, offset, 12,\n\t\t\t\t\t\t\t\t\t\t     ett_conf_phlist, NULL,\n\t\t\t\t\t\t\t\t\t\t     \"Phasor #%u\", i + 1);\n\n\t\tdata_flag_tree = proto_tree_add_subtree_format(single_phasor_scaling_and_flags_tree, tvb, offset, 4,\n\t\t\t\t\t\t\t       ett_conf_phflags, NULL, \"Phasor Data flags: %s\",\n\t\t\t\t\t\t\t       val_to_str_const(tvb_get_guint8(tvb, offset + 2), conf_phasor_type, \"Unknown\"));\n\n\t\t/* first and second bytes - phasor modification flags*/\n\t\tphasor_flag1_tree = proto_tree_add_subtree_format(data_flag_tree, tvb, offset, 2, ett_conf_phmod_flags,\n\t\t\t\t\t\t\t\t  NULL, \"Modification Flags: 0x%04x\",\n\t\t\t\t\t\t\t\t  tvb_get_ntohs(tvb, offset));\n\n\t\tproto_tree_add_item(phasor_flag1_tree, hf_conf_phasor_mod_b15, tvb, offset, 2, ENC_BIG_ENDIAN);\n\t\tproto_tree_add_item(phasor_flag1_tree, hf_conf_phasor_mod_b10, tvb, offset, 2, ENC_BIG_ENDIAN);\n\t\tproto_tree_add_item(phasor_flag1_tree, hf_conf_phasor_mod_b09, tvb, offset, 2, ENC_BIG_ENDIAN);\n\t\tproto_tree_add_item(phasor_flag1_tree, hf_conf_phasor_mod_b08, tvb, offset, 2, ENC_BIG_ENDIAN);\n\t\tproto_tree_add_item(phasor_flag1_tree, hf_conf_phasor_mod_b07, tvb, offset, 2, ENC_BIG_ENDIAN);\n\t\tproto_tree_add_item(phasor_flag1_tree, hf_conf_phasor_mod_b06, tvb, offset, 2, ENC_BIG_ENDIAN);\n\t\tproto_tree_add_item(phasor_flag1_tree, hf_conf_phasor_mod_b05, tvb, offset, 2, ENC_BIG_ENDIAN);\n\t\tproto_tree_add_item(phasor_flag1_tree, hf_conf_phasor_mod_b04, tvb, offset, 2, ENC_BIG_ENDIAN);\n\t\tproto_tree_add_item(phasor_flag1_tree, hf_conf_phasor_mod_b03, tvb, offset, 2, ENC_BIG_ENDIAN);\n\t\tproto_tree_add_item(phasor_flag1_tree, hf_conf_phasor_mod_b02, tvb, offset, 2, ENC_BIG_ENDIAN);\n\t\tproto_tree_add_item(phasor_flag1_tree, hf_conf_phasor_mod_b01, tvb, offset, 2, ENC_BIG_ENDIAN);\n\t\toffset += 2;\n\n\t\t/* third byte - phasor type*/\n\t\tproto_tree_add_item(data_flag_tree, hf_conf_phasor_type_b03, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\tproto_tree_add_item(data_flag_tree, hf_conf_phasor_type_b02to00, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\toffset += 1;\n\n\t\t/* fourth byte - user designation*/\n\t\tphasor_flag2_tree = proto_tree_add_subtree_format(data_flag_tree, tvb, offset, 1, ett_conf_ph_user_flags,\n\t\t\t\t\t\t\t\t  NULL, \"User designated flags: 0x%02x\",\n\t\t\t\t\t\t\t\t  tvb_get_guint8(tvb, offset));\n\n\t\tproto_tree_add_item(phasor_flag2_tree, hf_conf_phasor_user_data, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\toffset += 1;\n\n\t\t/* phasor scalefactor */\n\t\tproto_tree_add_item(single_phasor_scaling_and_flags_tree, hf_conf_phasor_scale_factor,\n\t\t\t\t    tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\toffset += 4;\n\n\t\t/* angle adjustment */\n\t\tproto_tree_add_item(single_phasor_scaling_and_flags_tree, hf_conf_phasor_angle_offset,\n\t\t\t\t    tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\toffset += 4;\n\t}\n\n\treturn offset;\n}", "target": 1, "idx": 12046}
{"commit_id": "804ca14d04df09bf7924bacc5ad22a4bed80c94f", "project": "torvalds/linux", "func": "static int iopt_unmap_iova_range(struct io_pagetable *iopt, unsigned long start,\n\t\t\t\t unsigned long last, unsigned long *unmapped)\n{\n\tstruct iopt_area *area;\n\tunsigned long unmapped_bytes = 0;\n\tunsigned int tries = 0;\n\tint rc = -ENOENT;\n\n\t/*\n\t * The domains_rwsem must be held in read mode any time any area->pages\n\t * is NULL. This prevents domain attach/detatch from running\n\t * concurrently with cleaning up the area.\n\t */\nagain:\n\tdown_read(&iopt->domains_rwsem);\n\tdown_write(&iopt->iova_rwsem);\n\twhile ((area = iopt_area_iter_first(iopt, start, last))) {\n\t\tunsigned long area_last = iopt_area_last_iova(area);\n\t\tunsigned long area_first = iopt_area_iova(area);\n\t\tstruct iopt_pages *pages;\n\n\t\t/* Userspace should not race map/unmap's of the same area */\n\t\tif (!area->pages) {\n\t\t\trc = -EBUSY;\n\t\t\tgoto out_unlock_iova;\n\t\t}\n\n\t\tif (area_first < start || area_last > last) {\n\t\t\trc = -ENOENT;\n\t\t\tgoto out_unlock_iova;\n\t\t}\n\n\t\tif (area_first != start)\n\t\t\ttries = 0;\n\n\t\t/*\n\t\t * num_accesses writers must hold the iova_rwsem too, so we can\n\t\t * safely read it under the write side of the iovam_rwsem\n\t\t * without the pages->mutex.\n\t\t */\n\t\tif (area->num_accesses) {\n\t\t\tsize_t length = iopt_area_length(area);\n\n\t\t\tstart = area_first;\n\t\t\tarea->prevent_access = true;\n\t\t\tup_write(&iopt->iova_rwsem);\n\t\t\tup_read(&iopt->domains_rwsem);\n\n\t\t\tiommufd_access_notify_unmap(iopt, area_first, length);\n\t\t\t/* Something is not responding to unmap requests. */\n\t\t\ttries++;\n\t\t\tif (WARN_ON(tries > 100))\n\t\t\t\treturn -EDEADLOCK;\n\t\t\tgoto again;\n\t\t}\n\n\t\tpages = area->pages;\n\t\tarea->pages = NULL;\n\t\tup_write(&iopt->iova_rwsem);\n\n\t\tiopt_area_unfill_domains(area, pages);\n\t\tiopt_abort_area(area);\n\t\tiopt_put_pages(pages);\n\n\t\tunmapped_bytes += area_last - area_first + 1;\n\n\t\tdown_write(&iopt->iova_rwsem);\n\t}\n\tif (unmapped_bytes)\n\t\trc = 0;\n\nout_unlock_iova:\n\tup_write(&iopt->iova_rwsem);\n\tup_read(&iopt->domains_rwsem);\n\tif (unmapped)\n\t\t*unmapped = unmapped_bytes;\n\treturn rc;\n}", "target": 1, "idx": 12047}
{"commit_id": "aed7b6b37ae189680dce9f5d444c90b4dc8df7a2", "project": "cesanta/mongoose", "func": "int mg_mqtt_parse(const uint8_t *buf, size_t len, uint8_t version,\n                  struct mg_mqtt_message *m) {\n  uint8_t lc = 0, *p, *end;\n  uint32_t n = 0, len_len = 0;\n\n  memset(m, 0, sizeof(*m));\n  m->dgram.ptr = (char *) buf;\n  if (len < 2) return MQTT_INCOMPLETE;\n  m->cmd = (uint8_t) (buf[0] >> 4);\n  m->qos = (buf[0] >> 1) & 3;\n\n  n = len_len = 0;\n  p = (uint8_t *) buf + 1;\n  while ((size_t) (p - buf) < len) {\n    lc = *((uint8_t *) p++);\n    n += (uint32_t) ((lc & 0x7f) << 7 * len_len);\n    len_len++;\n    if (!(lc & 0x80)) break;\n    if (len_len >= 4) return MQTT_MALFORMED;\n  }\n  end = p + n;\n  if ((lc & 0x80) || (end > buf + len)) return MQTT_INCOMPLETE;\n  m->dgram.len = (size_t) (end - buf);\n\n  switch (m->cmd) {\n    case MQTT_CMD_CONNACK:\n      if (end - p < 2) return MQTT_MALFORMED;\n      m->ack = p[1];\n      break;\n    case MQTT_CMD_PUBACK:\n    case MQTT_CMD_PUBREC:\n    case MQTT_CMD_PUBREL:\n    case MQTT_CMD_PUBCOMP:\n    case MQTT_CMD_SUBSCRIBE:\n    case MQTT_CMD_SUBACK:\n    case MQTT_CMD_UNSUBSCRIBE:\n    case MQTT_CMD_UNSUBACK:\n      if (p + 2 > end) return MQTT_MALFORMED;\n      m->id = (uint16_t) ((((uint16_t) p[0]) << 8) | p[1]);\n      p += 2;\n      break;\n    case MQTT_CMD_PUBLISH: {\n      if (p + 2 > end) return MQTT_MALFORMED;\n      m->topic.len = (uint16_t) ((((uint16_t) p[0]) << 8) | p[1]);\n      m->topic.ptr = (char *) p + 2;\n      p += 2 + m->topic.len;\n      if (p > end) return MQTT_MALFORMED;\n      if (m->qos > 0) {\n        if (p + 2 > end) return MQTT_MALFORMED;\n        m->id = (uint16_t) ((((uint16_t) p[0]) << 8) | p[1]);\n        p += 2;\n      }\n      if (p > end) return MQTT_MALFORMED;\n      if (version == 5 && p + 2 < end) {\n        len_len = (uint32_t) decode_varint(p, (size_t) (end - p), &m->props_size);\n        if (!len_len) return MQTT_MALFORMED;\n        m->props_start = (size_t) (p + len_len - buf);\n        p += len_len + m->props_size;\n      }\n      if (p > end) return MQTT_MALFORMED;\n      m->data.ptr = (char *) p;\n      m->data.len = (size_t) (end - p);\n      break;\n    }\n    default:\n      break;\n  }\n  return MQTT_OK;\n}", "target": 2, "idx": 12048}
{"commit_id": "ec9eb22e008a69ea9dc21fdca4b9b836679965ee", "project": "tats/w3m", "func": "void\nformUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form)\n{\n    Buffer save;\n    char *p;\n    int spos, epos, rows, c_rows, pos, col = 0;\n    Line *l;\n\n    copyBuffer(&save, buf);\n    gotoLine(buf, a->start.line);\n    switch (form->type) {\n    case FORM_TEXTAREA:\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n#endif\t\t\t\t/* MENU_SELECT */\n\tspos = a->start.pos;\n\tepos = a->end.pos;\n\tbreak;\n    default:\n\tspos = a->start.pos + 1;\n\tepos = a->end.pos - 1;\n    }\n    switch (form->type) {\n    case FORM_INPUT_CHECKBOX:\n    case FORM_INPUT_RADIO:\n\tif (form->checked)\n\t    buf->currentLine->lineBuf[spos] = '*';\n\telse\n\t    buf->currentLine->lineBuf[spos] = ' ';\n\tbreak;\n    case FORM_INPUT_TEXT:\n    case FORM_INPUT_FILE:\n    case FORM_INPUT_PASSWORD:\n    case FORM_TEXTAREA:\n#ifdef MENU_SELECT\n    case FORM_SELECT:\n\tif (form->type == FORM_SELECT) {\n\t    p = form->label->ptr;\n\t    updateSelectOption(form, form->select_option);\n\t}\n\telse\n#endif\t\t\t\t/* MENU_SELECT */\n\t    if (!form->value)\n\t\tbreak;\n\t    p = form->value->ptr;\n\tl = buf->currentLine;\n\tif (!l)\n\t    break;\n\tif (form->type == FORM_TEXTAREA) {\n\t    int n = a->y - buf->currentLine->linenumber;\n\t    if (n > 0)\n\t\tfor (; l && n; l = l->prev, n--) ;\n\t    else if (n < 0)\n\t\tfor (; l && n; l = l->prev, n++) ;\n\t    if (!l)\n\t\tbreak;\n\t}\n\trows = form->rows ? form->rows : 1;\n\tcol = COLPOS(l, a->start.pos);\n\tfor (c_rows = 0; c_rows < rows; c_rows++, l = l->next) {\n\t    if (rows > 1) {\n\t\tpos = columnPos(l, col);\n\t\ta = retrieveAnchor(buf->formitem, l->linenumber, pos);\n\t\tif (a == NULL)\n\t\t    break;\n\t\tspos = a->start.pos;\n\t\tepos = a->end.pos;\n\t    }\n\t    if (a->start.line != a->end.line || spos > epos || epos >= l->len)\n\t\tbreak;\n\t    pos = form_update_line(l, &p, spos, epos, COLPOS(l, epos) - col,\n\t\t\t\t   rows > 1,\n\t\t\t\t   form->type == FORM_INPUT_PASSWORD);\n\t    if (pos != epos) {\n\t\tshiftAnchorPosition(buf->href, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->name, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->img, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t\tshiftAnchorPosition(buf->formitem, buf->hmarklist,\n\t\t\t\t    a->start.line, spos, pos - epos);\n\t    }\n\t}\n\tbreak;\n    }\n    copyBuffer(buf, &save);\n    arrangeLine(buf);\n}", "target": 1, "idx": 12049}
{"commit_id": "c6048f849c7e3f009786df76206e895", "project": "qemu", "func": "static uint64_t\nvmxnet3_io_bar0_read(void *opaque, hwaddr addr, unsigned size)\n{\n    VMXNET3State *s = opaque;\n\n    if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_IMR,\n                        VMXNET3_MAX_INTRS, VMXNET3_REG_ALIGN)) {\n        int l = VMW_MULTIREG_IDX_BY_ADDR(addr, VMXNET3_REG_IMR,\n                                         VMXNET3_REG_ALIGN);\n        return s->interrupt_states[l].is_masked;\n    }\n\n    VMW_CBPRN(\"BAR0 unknown read [%\" PRIx64 \"], size %d\", addr, size);\n    return 0;\n}", "target": 1, "idx": 12050}
{"commit_id": "1af4fada49c4f3890f16daac31d38379a9d782b2", "project": "chromium", "func": "void ResourceDispatcherHostImpl::BeginRequest(\n    int request_id,\n    const ResourceHostMsg_Request& request_data,\n    IPC::Message* sync_result,  // only valid for sync\n    int route_id) {\n  int process_type = filter_->process_type();\n  int child_id = filter_->child_id();\n\n  // Reject request id that's currently in use.\n  if (IsRequestIDInUse(GlobalRequestID(child_id, request_id))) {\n    bad_message::ReceivedBadMessage(filter_,\n                                    bad_message::RDH_INVALID_REQUEST_ID);\n    return;\n  }\n\n  // PlzNavigate: reject invalid renderer main resource request.\n  if (IsBrowserSideNavigationEnabled() &&\n      IsResourceTypeFrame(request_data.resource_type) &&\n      !request_data.url.SchemeIs(url::kBlobScheme)) {\n    bad_message::ReceivedBadMessage(filter_, bad_message::RDH_INVALID_URL);\n    return;\n  }\n\n  // Reject invalid priority.\n  if (request_data.priority < net::MINIMUM_PRIORITY ||\n      request_data.priority > net::MAXIMUM_PRIORITY) {\n    bad_message::ReceivedBadMessage(filter_, bad_message::RDH_INVALID_PRIORITY);\n    return;\n  }\n\n  // If we crash here, figure out what URL the renderer was requesting.\n  // http://crbug.com/91398\n  char url_buf[128];\n  base::strlcpy(url_buf, request_data.url.spec().c_str(), arraysize(url_buf));\n  base::debug::Alias(url_buf);\n\n  // If the request that's coming in is being transferred from another process,\n  // we want to reuse and resume the old loader rather than start a new one.\n  LoaderMap::iterator it = pending_loaders_.find(\n      GlobalRequestID(request_data.transferred_request_child_id,\n                      request_data.transferred_request_request_id));\n  if (it != pending_loaders_.end()) {\n    // If the request is transferring to a new process, we can update our\n    // state and let it resume with its existing ResourceHandlers.\n    if (it->second->is_transferring()) {\n      ResourceLoader* deferred_loader = it->second.get();\n      UpdateRequestForTransfer(child_id, route_id, request_id,\n                               request_data, it);\n      deferred_loader->CompleteTransfer();\n    } else {\n      bad_message::ReceivedBadMessage(\n          filter_, bad_message::RDH_REQUEST_NOT_TRANSFERRING);\n    }\n    return;\n  }\n\n  ResourceContext* resource_context = NULL;\n  net::URLRequestContext* request_context = NULL;\n  filter_->GetContexts(request_data.resource_type, request_data.origin_pid,\n                       &resource_context, &request_context);\n  // http://crbug.com/90971\n  CHECK(ContainsKey(active_resource_contexts_, resource_context));\n\n  // Parse the headers before calling ShouldServiceRequest, so that they are\n  // available to be validated.\n  net::HttpRequestHeaders headers;\n  headers.AddHeadersFromString(request_data.headers);\n\n  if (is_shutdown_ ||\n      !ShouldServiceRequest(process_type, child_id, request_data, headers,\n                            filter_, resource_context)) {\n    AbortRequestBeforeItStarts(filter_, sync_result, request_id);\n    return;\n  }\n\n  // Allow the observer to block/handle the request.\n  if (delegate_ && !delegate_->ShouldBeginRequest(request_data.method,\n                                                  request_data.url,\n                                                  request_data.resource_type,\n                                                  resource_context)) {\n    AbortRequestBeforeItStarts(filter_, sync_result, request_id);\n    return;\n  }\n\n  // Construct the request.\n  scoped_ptr<net::URLRequest> new_request = request_context->CreateRequest(\n      request_data.url, request_data.priority, NULL);\n\n  new_request->set_method(request_data.method);\n  new_request->set_first_party_for_cookies(\n      request_data.first_party_for_cookies);\n  new_request->set_initiator(request_data.request_initiator);\n\n  // If the request is a MAIN_FRAME request, the first-party URL gets updated on\n  // redirects.\n  if (request_data.resource_type == RESOURCE_TYPE_MAIN_FRAME) {\n    new_request->set_first_party_url_policy(\n        net::URLRequest::UPDATE_FIRST_PARTY_URL_ON_REDIRECT);\n  }\n\n  const Referrer referrer(request_data.referrer, request_data.referrer_policy);\n  SetReferrerForRequest(new_request.get(), referrer);\n\n  new_request->SetExtraRequestHeaders(headers);\n\n  storage::BlobStorageContext* blob_context =\n      GetBlobStorageContext(filter_->blob_storage_context());\n  // Resolve elements from request_body and prepare upload data.\n  if (request_data.request_body.get()) {\n    // |blob_context| could be null when the request is from the plugins because\n    // ResourceMessageFilters created in PluginProcessHost don't have the blob\n    // context.\n    if (blob_context) {\n      // Attaches the BlobDataHandles to request_body not to free the blobs and\n      // any attached shareable files until upload completion. These data will\n      // be used in UploadDataStream and ServiceWorkerURLRequestJob.\n      AttachRequestBodyBlobDataHandles(\n          request_data.request_body.get(),\n          blob_context);\n    }\n    new_request->set_upload(UploadDataStreamBuilder::Build(\n        request_data.request_body.get(),\n        blob_context,\n        filter_->file_system_context(),\n        BrowserThread::GetMessageLoopProxyForThread(BrowserThread::FILE)\n            .get()));\n  }\n\n  bool allow_download = request_data.allow_download &&\n      IsResourceTypeFrame(request_data.resource_type);\n  bool do_not_prompt_for_login = request_data.do_not_prompt_for_login;\n  bool is_sync_load = sync_result != NULL;\n\n  // Raw headers are sensitive, as they include Cookie/Set-Cookie, so only\n  // allow requesting them if requester has ReadRawCookies permission.\n  ChildProcessSecurityPolicyImpl* policy =\n      ChildProcessSecurityPolicyImpl::GetInstance();\n  bool report_raw_headers = request_data.report_raw_headers;\n  if (report_raw_headers && !policy->CanReadRawCookies(child_id)) {\n    // TODO: crbug.com/523063 can we call bad_message::ReceivedBadMessage here?\n    VLOG(1) << \"Denied unauthorized request for raw headers\";\n    report_raw_headers = false;\n  }\n  int load_flags =\n      BuildLoadFlagsForRequest(request_data, child_id, is_sync_load);\n  if (request_data.resource_type == RESOURCE_TYPE_PREFETCH ||\n      request_data.resource_type == RESOURCE_TYPE_FAVICON) {\n    do_not_prompt_for_login = true;\n  }\n  if (request_data.resource_type == RESOURCE_TYPE_IMAGE &&\n      HTTP_AUTH_RELATION_BLOCKED_CROSS ==\n          HttpAuthRelationTypeOf(request_data.url,\n                                 request_data.first_party_for_cookies)) {\n    // Prevent third-party image content from prompting for login, as this\n    // is often a scam to extract credentials for another domain from the user.\n    // Only block image loads, as the attack applies largely to the \"src\"\n    // property of the <img> tag. It is common for web properties to allow\n    // untrusted values for <img src>; this is considered a fair thing for an\n    // HTML sanitizer to do. Conversely, any HTML sanitizer that didn't\n    // filter sources for <script>, <link>, <embed>, <object>, <iframe> tags\n    // would be considered vulnerable in and of itself.\n    do_not_prompt_for_login = true;\n    load_flags |= net::LOAD_DO_NOT_USE_EMBEDDED_IDENTITY;\n  }\n\n  bool support_async_revalidation =\n      !is_sync_load && async_revalidation_manager_ &&\n      AsyncRevalidationManager::QualifiesForAsyncRevalidation(request_data);\n\n  if (support_async_revalidation)\n    load_flags |= net::LOAD_SUPPORT_ASYNC_REVALIDATION;\n\n  // Sync loads should have maximum priority and should be the only\n  // requets that have the ignore limits flag set.\n  if (is_sync_load) {\n    DCHECK_EQ(request_data.priority, net::MAXIMUM_PRIORITY);\n    DCHECK_NE(load_flags & net::LOAD_IGNORE_LIMITS, 0);\n  } else {\n    DCHECK_EQ(load_flags & net::LOAD_IGNORE_LIMITS, 0);\n  }\n  new_request->SetLoadFlags(load_flags);\n\n  // Make extra info and read footer (contains request ID).\n  ResourceRequestInfoImpl* extra_info = new ResourceRequestInfoImpl(\n      process_type, child_id, route_id,\n      -1,  // frame_tree_node_id\n      request_data.origin_pid, request_id, request_data.render_frame_id,\n      request_data.is_main_frame, request_data.parent_is_main_frame,\n      request_data.resource_type, request_data.transition_type,\n      request_data.should_replace_current_entry,\n      false,  // is download\n      false,  // is stream\n      allow_download, request_data.has_user_gesture,\n      request_data.enable_load_timing, request_data.enable_upload_progress,\n      do_not_prompt_for_login, request_data.referrer_policy,\n      request_data.visiblity_state, resource_context, filter_->GetWeakPtr(),\n      report_raw_headers, !is_sync_load,\n      IsUsingLoFi(request_data.lofi_state, delegate_, *new_request,\n                  resource_context,\n                  request_data.resource_type == RESOURCE_TYPE_MAIN_FRAME),\n      support_async_revalidation ? request_data.headers : std::string());\n  // Request takes ownership.\n  extra_info->AssociateWithRequest(new_request.get());\n\n  if (new_request->url().SchemeIs(url::kBlobScheme)) {\n    // Hang on to a reference to ensure the blob is not released prior\n    // to the job being started.\n    storage::BlobProtocolHandler::SetRequestedBlobDataHandle(\n        new_request.get(),\n        filter_->blob_storage_context()->context()->GetBlobDataFromPublicURL(\n            new_request->url()));\n  }\n\n  // Initialize the service worker handler for the request. We don't use\n  // ServiceWorker for synchronous loads to avoid renderer deadlocks.\n  const bool should_skip_service_worker =\n      request_data.skip_service_worker || is_sync_load;\n  ServiceWorkerRequestHandler::InitializeHandler(\n      new_request.get(), filter_->service_worker_context(), blob_context,\n      child_id, request_data.service_worker_provider_id,\n      should_skip_service_worker,\n      request_data.fetch_request_mode, request_data.fetch_credentials_mode,\n      request_data.fetch_redirect_mode, request_data.resource_type,\n      request_data.fetch_request_context_type, request_data.fetch_frame_type,\n      request_data.request_body);\n\n  if (base::CommandLine::ForCurrentProcess()->HasSwitch(\n          switches::kEnableExperimentalWebPlatformFeatures)) {\n    ForeignFetchRequestHandler::InitializeHandler(\n        new_request.get(), filter_->service_worker_context(), blob_context,\n        child_id, request_data.service_worker_provider_id,\n        should_skip_service_worker,\n        request_data.fetch_request_mode, request_data.fetch_credentials_mode,\n        request_data.fetch_redirect_mode, request_data.resource_type,\n        request_data.fetch_request_context_type, request_data.fetch_frame_type,\n        request_data.request_body);\n  }\n\n  // Have the appcache associate its extra info with the request.\n  AppCacheInterceptor::SetExtraRequestInfo(\n      new_request.get(), filter_->appcache_service(), child_id,\n      request_data.appcache_host_id, request_data.resource_type,\n      request_data.should_reset_appcache);\n\n  scoped_ptr<ResourceHandler> handler(\n       CreateResourceHandler(\n           new_request.get(),\n           request_data, sync_result, route_id, process_type, child_id,\n           resource_context));\n\n  if (handler)\n    BeginRequestInternal(std::move(new_request), std::move(handler));\n}", "target": 1, "idx": 12051}
{"commit_id": "455f6d4f0447a60329c21928d67f61c79ac3b243", "project": "nginx/njs", "func": "static njs_int_t\nnjs_parser_await(njs_parser_t *parser, njs_lexer_token_t *token,\n    njs_queue_link_t *current)\n{\n    njs_parser_node_t   *node;\n\n    if (!njs_function_scope(parser->scope)->async) {\n        njs_parser_syntax_error(parser,\n                                \"await is only valid in async functions\");\n        return NJS_ERROR;\n    }\n\n    if (parser->scope->in_args) {\n        njs_parser_syntax_error(parser, \"await in arguments not supported\");\n        return NJS_ERROR;\n    }\n\n    node = njs_parser_node_new(parser, NJS_TOKEN_AWAIT);\n    if (njs_slow_path(node == NULL)) {\n        return NJS_ERROR;\n    }\n\n    node->token_line = token->line;\n\n    njs_lexer_consume_token(parser->lexer, 1);\n\n    parser->node = NULL;\n\n    njs_parser_next(parser, njs_parser_unary_expression);\n\n    return njs_parser_after(parser, current, node, 0,\n                            njs_parser_await_after);\n}", "target": 2, "idx": 12052}
{"commit_id": "adf41f36cf7214d7d6fa8d528b74eba47c377405", "project": "hughsie/colord", "func": "gboolean  \ncd_device_db_load (CdDeviceDb *ddb,\n\t\t    const gchar *filename,\n\t\t    GError  **error)\n{\n\tCdDeviceDbPrivate *priv = GET_PRIVATE (ddb);\n\tconst gchar *statement;\n\tgchar *error_msg = NULL;\n\tgint rc;\n\tg_autofree gchar *path = NULL;\n\n\tg_return_val_if_fail (CD_IS_DEVICE_DB (ddb), FALSE);\n\tg_return_val_if_fail (priv->db == NULL, FALSE);\n\n\t/* ensure the path exists */\n\tpath = g_path_get_dirname (filename);\n\tif (!cd_main_mkdir_with_parents (path, error))\n\t\treturn FALSE;\n\n\tg_debug (\"CdDeviceDb: trying to open database '%s'\", filename);\n\tg_info (\"Using device database file %s\", filename);\n\trc = sqlite3_open (filename, &priv->db);\n\tif (rc != SQLITE_OK) {\n\t\tg_set_error (error,\n\t\t\t     CD_CLIENT_ERROR,\n\t\t\t     CD_CLIENT_ERROR_INTERNAL,\n\t\t\t     \"Can't open database: %s\\n\",\n\t\t\t     sqlite3_errmsg (priv->db));\n\t\tsqlite3_close (priv->db);\n\t\treturn FALSE;\n\t}\n\n\t/* we don't need to keep doing fsync */\n\tsqlite3_exec (priv->db, \"PRAGMA synchronous=OFF\",\n\t\t      NULL, NULL, NULL);\n\n\t/* check devices */\n\trc = sqlite3_exec (priv->db, \"SELECT * FROM devices LIMIT 1\",\n\t\t\t   NULL, NULL, &error_msg);\n\tif (rc != SQLITE_OK) {\n\t\tg_debug (\"CdDeviceDb: creating table to repair: %s\", error_msg);\n\t\tsqlite3_free (error_msg);\n\t\tstatement = \"CREATE TABLE devices (\"\n\t\t\t    \"device_id TEXT PRIMARY KEY,\"\n\t\t\t    \"device TEXT);\";\n\t\tsqlite3_exec (priv->db, statement, NULL, NULL, NULL);\n\t}\n\n\t/* check properties version 2 */\n\trc = sqlite3_exec (priv->db, \"SELECT * FROM properties_v2 LIMIT 1\",\n\t\t\t   NULL, NULL, NULL);\n\tif (rc != SQLITE_OK) {\n\t\tstatement = \"CREATE TABLE properties_v2 (\"\n\t\t\t    \"device_id TEXT,\"\n\t\t\t    \"property TEXT,\"\n\t\t\t    \"value TEXT,\"\n\t\t\t    \"PRIMARY KEY (device_id, property));\";\n\t\tsqlite3_exec (priv->db, statement, NULL, NULL, NULL);\n\t}\n\treturn TRUE;\n}", "target": 2, "idx": 12053}
{"commit_id": "ba919adb74ac368bf76b150a00347ded78b572dd", "project": "radareorg/radare2", "func": "static void axfm(RCore *core) {\n\tRVecAnalRef *refs = r_anal_xrefs_get_from (core->anal, UT64_MAX);\n\tif (refs && !RVecAnalRef_empty (refs)) {\n\t\tRVecAnalRef_sort (refs, compare_ref);\n\n\t\tut64 last_addr = UT64_MAX;\n\t\tRAnalRef *ref;\n\t\tR_VEC_FOREACH (refs, ref) {\n\t\t\tconst bool is_first = ref->addr != last_addr;\n\t\t\tconst char *name;\n\t\t\tif (is_first) {\n\t\t\t\tname = axtm_name (core, ref->addr);\n\t\t\t\tr_cons_printf (\"0x%\"PFMT64x\": %s\\n\", ref->addr, name? name: \"?\");\n\t\t\t}\n\n\t\t\tname = axtm_name (core, ref->at);\n\t\t\tr_cons_printf (\"  0x%\"PFMT64x\": %s\\n\", ref->at, name? name: \"?\");\n\n\t\t\tlast_addr = ref->addr;\n\t\t}\n\t}\n\tRVecAnalRef_free (refs);\n}", "target": 3, "idx": 12054}
{"commit_id": "af58be768ebb690f78530f796e92b8ae5c9a4401", "project": "openssl", "func": "int ssl3_read_bytes(SSL *s, int type, int *recvd_type, unsigned char *buf,\n                    int len, int peek)\n{\n    int al, i, j, ret;\n    unsigned int n, curr_rec, num_recs, read_bytes;\n    SSL3_RECORD *rr;\n    SSL3_BUFFER *rbuf;\n    void (*cb) (const SSL *ssl, int type2, int val) = NULL;\n\n    rbuf = &s->rlayer.rbuf;\n\n    if (!SSL3_BUFFER_is_initialised(rbuf)) {\n        /* Not initialized yet */\n        if (!ssl3_setup_read_buffer(s))\n            return (-1);\n    }\n\n    if ((type && (type != SSL3_RT_APPLICATION_DATA)\n         && (type != SSL3_RT_HANDSHAKE)) || (peek\n                                             && (type !=\n                                                 SSL3_RT_APPLICATION_DATA))) {\n        SSLerr(SSL_F_SSL3_READ_BYTES, ERR_R_INTERNAL_ERROR);\n        return -1;\n    }\n\n    if ((type == SSL3_RT_HANDSHAKE) && (s->rlayer.handshake_fragment_len > 0))\n        /* (partially) satisfy request from storage */\n    {\n        unsigned char *src = s->rlayer.handshake_fragment;\n        unsigned char *dst = buf;\n        unsigned int k;\n\n        /* peek == 0 */\n        n = 0;\n        while ((len > 0) && (s->rlayer.handshake_fragment_len > 0)) {\n            *dst++ = *src++;\n            len--;\n            s->rlayer.handshake_fragment_len--;\n            n++;\n        }\n        /* move any remaining fragment bytes: */\n        for (k = 0; k < s->rlayer.handshake_fragment_len; k++)\n            s->rlayer.handshake_fragment[k] = *src++;\n\n        if (recvd_type != NULL)\n            *recvd_type = SSL3_RT_HANDSHAKE;\n\n        return n;\n    }\n\n    /*\n     * Now s->rlayer.handshake_fragment_len == 0 if type == SSL3_RT_HANDSHAKE.\n     */\n\n    if (!ossl_statem_get_in_handshake(s) && SSL_in_init(s)) {\n        /* type == SSL3_RT_APPLICATION_DATA */\n        i = s->handshake_func(s);\n        if (i < 0)\n            return (i);\n        if (i == 0) {\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);\n            return (-1);\n        }\n    }\n start:\n    s->rwstate = SSL_NOTHING;\n\n    /*-\n     * For each record 'i' up to |num_recs]\n     * rr[i].type     - is the type of record\n     * rr[i].data,    - data\n     * rr[i].off,     - offset into 'data' for next read\n     * rr[i].length,  - number of bytes.\n     */\n    rr = s->rlayer.rrec;\n    num_recs = RECORD_LAYER_get_numrpipes(&s->rlayer);\n\n    do {\n        /* get new records if necessary */\n        if (num_recs == 0) {\n            ret = ssl3_get_record(s);\n            if (ret <= 0)\n                return (ret);\n            num_recs = RECORD_LAYER_get_numrpipes(&s->rlayer);\n            if (num_recs == 0) {\n                /* Shouldn't happen */\n                al = SSL_AD_INTERNAL_ERROR;\n                SSLerr(SSL_F_SSL3_READ_BYTES, ERR_R_INTERNAL_ERROR);\n                goto f_err;\n            }\n        }\n        /* Skip over any records we have already read */\n        for (curr_rec = 0;\n             curr_rec < num_recs && SSL3_RECORD_is_read(&rr[curr_rec]);\n             curr_rec++) ;\n        if (curr_rec == num_recs) {\n            RECORD_LAYER_set_numrpipes(&s->rlayer, 0);\n            num_recs = 0;\n            curr_rec = 0;\n        }\n    } while (num_recs == 0);\n    rr = &rr[curr_rec];\n\n    /*\n     * Reset the count of consecutive warning alerts if we've got a non-empty\n     * record that isn't an alert.\n     */\n    if (SSL3_RECORD_get_type(rr) != SSL3_RT_ALERT\n            && SSL3_RECORD_get_length(rr) != 0)\n        s->rlayer.alert_count = 0;\n\n    /* we now have a packet which can be read and processed */\n\n    if (s->s3->change_cipher_spec /* set when we receive ChangeCipherSpec,\n                                   * reset by ssl3_get_finished */\n        && (SSL3_RECORD_get_type(rr) != SSL3_RT_HANDSHAKE)) {\n        al = SSL_AD_UNEXPECTED_MESSAGE;\n        SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_DATA_BETWEEN_CCS_AND_FINISHED);\n        goto f_err;\n    }\n\n    /*\n     * If the other end has shut down, throw anything we read away (even in\n     * 'peek' mode)\n     */\n    if (s->shutdown & SSL_RECEIVED_SHUTDOWN) {\n        SSL3_RECORD_set_length(rr, 0);\n        s->rwstate = SSL_NOTHING;\n        return (0);\n    }\n\n    if (type == SSL3_RECORD_get_type(rr)\n        || (SSL3_RECORD_get_type(rr) == SSL3_RT_CHANGE_CIPHER_SPEC\n            && type == SSL3_RT_HANDSHAKE && recvd_type != NULL)) {\n        /*\n         * SSL3_RT_APPLICATION_DATA or\n         * SSL3_RT_HANDSHAKE or\n         * SSL3_RT_CHANGE_CIPHER_SPEC\n         */\n        /*\n         * make sure that we are not getting application data when we are\n         * doing a handshake for the first time\n         */\n        if (SSL_in_init(s) && (type == SSL3_RT_APPLICATION_DATA) &&\n            (s->enc_read_ctx == NULL)) {\n            al = SSL_AD_UNEXPECTED_MESSAGE;\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_APP_DATA_IN_HANDSHAKE);\n            goto f_err;\n        }\n\n        if (type == SSL3_RT_HANDSHAKE\n            && SSL3_RECORD_get_type(rr) == SSL3_RT_CHANGE_CIPHER_SPEC\n            && s->rlayer.handshake_fragment_len > 0) {\n            al = SSL_AD_UNEXPECTED_MESSAGE;\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_CCS_RECEIVED_EARLY);\n            goto f_err;\n        }\n\n        if (recvd_type != NULL)\n            *recvd_type = SSL3_RECORD_get_type(rr);\n\n        if (len <= 0)\n            return (len);\n\n        read_bytes = 0;\n        do {\n            if ((unsigned int)len - read_bytes > SSL3_RECORD_get_length(rr))\n                n = SSL3_RECORD_get_length(rr);\n            else\n                n = (unsigned int)len - read_bytes;\n\n            memcpy(buf, &(rr->data[rr->off]), n);\n            buf += n;\n            if (!peek) {\n                SSL3_RECORD_sub_length(rr, n);\n                SSL3_RECORD_add_off(rr, n);\n                if (SSL3_RECORD_get_length(rr) == 0) {\n                    s->rlayer.rstate = SSL_ST_READ_HEADER;\n                    SSL3_RECORD_set_off(rr, 0);\n                    SSL3_RECORD_set_read(rr);\n                }\n            }\n            if (SSL3_RECORD_get_length(rr) == 0\n                || (peek && n == SSL3_RECORD_get_length(rr))) {\n                curr_rec++;\n                rr++;\n            }\n            read_bytes += n;\n        } while (type == SSL3_RT_APPLICATION_DATA && curr_rec < num_recs\n                 && read_bytes < (unsigned int)len);\n        if (read_bytes == 0) {\n            /* We must have read empty records. Get more data */\n            goto start;\n        }\n        if (!peek && curr_rec == num_recs\n            && (s->mode & SSL_MODE_RELEASE_BUFFERS)\n            && SSL3_BUFFER_get_left(rbuf) == 0)\n            ssl3_release_read_buffer(s);\n        return read_bytes;\n    }\n\n    /*\n     * If we get here, then type != rr->type; if we have a handshake message,\n     * then it was unexpected (Hello Request or Client Hello) or invalid (we\n     * were actually expecting a CCS).\n     */\n\n    /*\n     * Lets just double check that we've not got an SSLv2 record\n     */\n    if (rr->rec_version == SSL2_VERSION) {\n        /*\n         * Should never happen. ssl3_get_record() should only give us an SSLv2\n         * record back if this is the first packet and we are looking for an\n         * initial ClientHello. Therefore |type| should always be equal to\n         * |rr->type|. If not then something has gone horribly wrong\n         */\n        al = SSL_AD_INTERNAL_ERROR;\n        SSLerr(SSL_F_SSL3_READ_BYTES, ERR_R_INTERNAL_ERROR);\n        goto f_err;\n    }\n\n    if (s->method->version == TLS_ANY_VERSION\n        && (s->server || rr->type != SSL3_RT_ALERT)) {\n        /*\n         * If we've got this far and still haven't decided on what version\n         * we're using then this must be a client side alert we're dealing with\n         * (we don't allow heartbeats yet). We shouldn't be receiving anything\n         * other than a ClientHello if we are a server.\n         */\n        s->version = rr->rec_version;\n        al = SSL_AD_UNEXPECTED_MESSAGE;\n        SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_UNEXPECTED_MESSAGE);\n        goto f_err;\n    }\n\n    /*\n     * In case of record types for which we have 'fragment' storage, fill\n     * that so that we can process the data at a fixed place.\n     */\n    {\n        unsigned int dest_maxlen = 0;\n        unsigned char *dest = NULL;\n        unsigned int *dest_len = NULL;\n\n        if (SSL3_RECORD_get_type(rr) == SSL3_RT_HANDSHAKE) {\n            dest_maxlen = sizeof s->rlayer.handshake_fragment;\n            dest = s->rlayer.handshake_fragment;\n            dest_len = &s->rlayer.handshake_fragment_len;\n        } else if (SSL3_RECORD_get_type(rr) == SSL3_RT_ALERT) {\n            dest_maxlen = sizeof s->rlayer.alert_fragment;\n            dest = s->rlayer.alert_fragment;\n            dest_len = &s->rlayer.alert_fragment_len;\n        }\n\n        if (dest_maxlen > 0) {\n            n = dest_maxlen - *dest_len; /* available space in 'dest' */\n            if (SSL3_RECORD_get_length(rr) < n)\n                n = SSL3_RECORD_get_length(rr); /* available bytes */\n\n            /* now move 'n' bytes: */\n            while (n-- > 0) {\n                dest[(*dest_len)++] =\n                    SSL3_RECORD_get_data(rr)[SSL3_RECORD_get_off(rr)];\n                SSL3_RECORD_add_off(rr, 1);\n                SSL3_RECORD_add_length(rr, -1);\n            }\n\n            if (*dest_len < dest_maxlen) {\n                SSL3_RECORD_set_read(rr);\n                goto start;     /* fragment was too small */\n            }\n        }\n    }\n\n    /*-\n     * s->rlayer.handshake_fragment_len == 4  iff  rr->type == SSL3_RT_HANDSHAKE;\n     * s->rlayer.alert_fragment_len == 2      iff  rr->type == SSL3_RT_ALERT.\n     * (Possibly rr is 'empty' now, i.e. rr->length may be 0.)\n     */\n\n    /* If we are a client, check for an incoming 'Hello Request': */\n    if ((!s->server) &&\n        (s->rlayer.handshake_fragment_len >= 4) &&\n        (s->rlayer.handshake_fragment[0] == SSL3_MT_HELLO_REQUEST) &&\n        (s->session != NULL) && (s->session->cipher != NULL)) {\n        s->rlayer.handshake_fragment_len = 0;\n\n        if ((s->rlayer.handshake_fragment[1] != 0) ||\n            (s->rlayer.handshake_fragment[2] != 0) ||\n            (s->rlayer.handshake_fragment[3] != 0)) {\n            al = SSL_AD_DECODE_ERROR;\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_BAD_HELLO_REQUEST);\n            goto f_err;\n        }\n\n        if (s->msg_callback)\n            s->msg_callback(0, s->version, SSL3_RT_HANDSHAKE,\n                            s->rlayer.handshake_fragment, 4, s,\n                            s->msg_callback_arg);\n\n        if (SSL_is_init_finished(s) &&\n            !(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS) &&\n            !s->s3->renegotiate) {\n            ssl3_renegotiate(s);\n            if (ssl3_renegotiate_check(s)) {\n                i = s->handshake_func(s);\n                if (i < 0)\n                    return (i);\n                if (i == 0) {\n                    SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);\n                    return (-1);\n                }\n\n                if (!(s->mode & SSL_MODE_AUTO_RETRY)) {\n                    if (SSL3_BUFFER_get_left(rbuf) == 0) {\n                        /* no read-ahead left? */\n                        BIO *bio;\n                        /*\n                         * In the case where we try to read application data,\n                         * but we trigger an SSL handshake, we return -1 with\n                         * the retry option set.  Otherwise renegotiation may\n                         * cause nasty problems in the blocking world\n                         */\n                        s->rwstate = SSL_READING;\n                        bio = SSL_get_rbio(s);\n                        BIO_clear_retry_flags(bio);\n                        BIO_set_retry_read(bio);\n                        return (-1);\n                    }\n                }\n            }\n        }\n        /*\n         * we either finished a handshake or ignored the request, now try\n         * again to obtain the (application) data we were asked for\n         */\n        goto start;\n    }\n    /*\n     * If we are a server and get a client hello when renegotiation isn't\n     * allowed send back a no renegotiation alert and carry on. WARNING:\n     * experimental code, needs reviewing (steve)\n     */\n    if (s->server &&\n        SSL_is_init_finished(s) &&\n        !s->s3->send_connection_binding &&\n        (s->version > SSL3_VERSION) &&\n        (s->rlayer.handshake_fragment_len >= 4) &&\n        (s->rlayer.handshake_fragment[0] == SSL3_MT_CLIENT_HELLO) &&\n        (s->session != NULL) && (s->session->cipher != NULL) &&\n        !(s->ctx->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION)) {\n        SSL3_RECORD_set_length(rr, 0);\n        SSL3_RECORD_set_read(rr);\n        ssl3_send_alert(s, SSL3_AL_WARNING, SSL_AD_NO_RENEGOTIATION);\n        goto start;\n    }\n    if (s->rlayer.alert_fragment_len >= 2) {\n        int alert_level = s->rlayer.alert_fragment[0];\n        int alert_descr = s->rlayer.alert_fragment[1];\n\n        s->rlayer.alert_fragment_len = 0;\n\n        if (s->msg_callback)\n            s->msg_callback(0, s->version, SSL3_RT_ALERT,\n                            s->rlayer.alert_fragment, 2, s,\n                            s->msg_callback_arg);\n\n        if (s->info_callback != NULL)\n            cb = s->info_callback;\n        else if (s->ctx->info_callback != NULL)\n            cb = s->ctx->info_callback;\n\n        if (cb != NULL) {\n            j = (alert_level << 8) | alert_descr;\n            cb(s, SSL_CB_READ_ALERT, j);\n        }\n\n        if (alert_level == SSL3_AL_WARNING) {\n            s->s3->warn_alert = alert_descr;\n            SSL3_RECORD_set_read(rr);\n\n            s->rlayer.alert_count++;\n            if (s->rlayer.alert_count == MAX_WARN_ALERT_COUNT) {\n                al = SSL_AD_UNEXPECTED_MESSAGE;\n                SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_TOO_MANY_WARN_ALERTS);\n                goto f_err;\n            }\n\n            if (alert_descr == SSL_AD_CLOSE_NOTIFY) {\n                s->shutdown |= SSL_RECEIVED_SHUTDOWN;\n                return (0);\n            }\n            /*\n             * This is a warning but we receive it if we requested\n             * renegotiation and the peer denied it. Terminate with a fatal\n             * alert because if application tried to renegotiate it\n             * presumably had a good reason and expects it to succeed. In\n             * future we might have a renegotiation where we don't care if\n             * the peer refused it where we carry on.\n             */\n            else if (alert_descr == SSL_AD_NO_RENEGOTIATION) {\n                al = SSL_AD_HANDSHAKE_FAILURE;\n                SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_NO_RENEGOTIATION);\n                goto f_err;\n            }\n#ifdef SSL_AD_MISSING_SRP_USERNAME\n            else if (alert_descr == SSL_AD_MISSING_SRP_USERNAME)\n                return (0);\n#endif\n        } else if (alert_level == SSL3_AL_FATAL) {\n            char tmp[16];\n\n            s->rwstate = SSL_NOTHING;\n            s->s3->fatal_alert = alert_descr;\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_AD_REASON_OFFSET + alert_descr);\n            BIO_snprintf(tmp, sizeof tmp, \"%d\", alert_descr);\n            ERR_add_error_data(2, \"SSL alert number \", tmp);\n            s->shutdown |= SSL_RECEIVED_SHUTDOWN;\n            SSL3_RECORD_set_read(rr);\n            SSL_CTX_remove_session(s->session_ctx, s->session);\n            return (0);\n        } else {\n            al = SSL_AD_ILLEGAL_PARAMETER;\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_UNKNOWN_ALERT_TYPE);\n            goto f_err;\n        }\n\n        goto start;\n    }\n\n    if (s->shutdown & SSL_SENT_SHUTDOWN) { /* but we have not received a\n                                            * shutdown */\n        s->rwstate = SSL_NOTHING;\n        SSL3_RECORD_set_length(rr, 0);\n        SSL3_RECORD_set_read(rr);\n        return (0);\n    }\n\n    if (SSL3_RECORD_get_type(rr) == SSL3_RT_CHANGE_CIPHER_SPEC) {\n        al = SSL_AD_UNEXPECTED_MESSAGE;\n        SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_CCS_RECEIVED_EARLY);\n        goto f_err;\n    }\n\n    /*\n     * Unexpected handshake message (Client Hello, or protocol violation)\n     */\n    if ((s->rlayer.handshake_fragment_len >= 4)\n        && !ossl_statem_get_in_handshake(s)) {\n        if (SSL_is_init_finished(s) &&\n            !(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS)) {\n            ossl_statem_set_in_init(s, 1);\n            s->renegotiate = 1;\n            s->new_session = 1;\n        }\n        i = s->handshake_func(s);\n        if (i < 0)\n            return (i);\n        if (i == 0) {\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);\n            return (-1);\n        }\n\n        if (!(s->mode & SSL_MODE_AUTO_RETRY)) {\n            if (SSL3_BUFFER_get_left(rbuf) == 0) {\n                /* no read-ahead left? */\n                BIO *bio;\n                /*\n                 * In the case where we try to read application data, but we\n                 * trigger an SSL handshake, we return -1 with the retry\n                 * option set.  Otherwise renegotiation may cause nasty\n                 * problems in the blocking world\n                 */\n                s->rwstate = SSL_READING;\n                bio = SSL_get_rbio(s);\n                BIO_clear_retry_flags(bio);\n                BIO_set_retry_read(bio);\n                return (-1);\n            }\n        }\n        goto start;\n    }\n\n    switch (SSL3_RECORD_get_type(rr)) {\n    default:\n        /*\n         * TLS up to v1.1 just ignores unknown message types: TLS v1.2 give\n         * an unexpected message alert.\n         */\n        if (s->version >= TLS1_VERSION && s->version <= TLS1_1_VERSION) {\n            SSL3_RECORD_set_length(rr, 0);\n            SSL3_RECORD_set_read(rr);\n            goto start;\n        }\n        al = SSL_AD_UNEXPECTED_MESSAGE;\n        SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_UNEXPECTED_RECORD);\n        goto f_err;\n    case SSL3_RT_CHANGE_CIPHER_SPEC:\n    case SSL3_RT_ALERT:\n    case SSL3_RT_HANDSHAKE:\n        /*\n         * we already handled all of these, with the possible exception of\n         * SSL3_RT_HANDSHAKE when ossl_statem_get_in_handshake(s) is true, but\n         * that should not happen when type != rr->type\n         */\n        al = SSL_AD_UNEXPECTED_MESSAGE;\n        SSLerr(SSL_F_SSL3_READ_BYTES, ERR_R_INTERNAL_ERROR);\n        goto f_err;\n    case SSL3_RT_APPLICATION_DATA:\n        /*\n         * At this point, we were expecting handshake data, but have\n         * application data.  If the library was running inside ssl3_read()\n         * (i.e. in_read_app_data is set) and it makes sense to read\n         * application data at this point (session renegotiation not yet\n         * started), we will indulge it.\n         */\n        if (ossl_statem_app_data_allowed(s)) {\n            s->s3->in_read_app_data = 2;\n            return (-1);\n        } else {\n            al = SSL_AD_UNEXPECTED_MESSAGE;\n            SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_UNEXPECTED_RECORD);\n            goto f_err;\n        }\n    }\n    /* not reached */\n\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n    return (-1);\n}", "target": 2, "idx": 12055}
{"commit_id": "879f7080d7e141f415c79eaa3a8ac4a3dad0348b", "project": "openssl", "func": "static int tree_calculate_user_set(X509_POLICY_TREE *tree,\n                                   STACK_OF(ASN1_OBJECT) *policy_oids,\n                                   STACK_OF(X509_POLICY_NODE) *auth_nodes)\n{\n    int i;\n    X509_POLICY_NODE *node;\n    ASN1_OBJECT *oid;\n    X509_POLICY_NODE *anyPolicy;\n    X509_POLICY_DATA *extra;\n\n    /*\n     * Check if anyPolicy present in authority constrained policy set: this\n     * will happen if it is a leaf node.\n     */\n    if (sk_ASN1_OBJECT_num(policy_oids) <= 0)\n        return 1;\n\n    anyPolicy = tree->levels[tree->nlevel - 1].anyPolicy;\n\n    for (i = 0; i < sk_ASN1_OBJECT_num(policy_oids); i++) {\n        oid = sk_ASN1_OBJECT_value(policy_oids, i);\n        if (OBJ_obj2nid(oid) == NID_any_policy) {\n            tree->flags |= POLICY_FLAG_ANY_POLICY;\n            return 1;\n        }\n    }\n\n    for (i = 0; i < sk_ASN1_OBJECT_num(policy_oids); i++) {\n        oid = sk_ASN1_OBJECT_value(policy_oids, i);\n        node = tree_find_sk(auth_nodes, oid);\n        if (!node) {\n            if (!anyPolicy)\n                continue;\n            /*\n             * Create a new node with policy ID from user set and qualifiers\n             * from anyPolicy.\n             */\n            extra = policy_data_new(NULL, oid, node_critical(anyPolicy));\n            if (extra == NULL)\n                return 0;\n            extra->qualifier_set = anyPolicy->data->qualifier_set;\n            extra->flags = POLICY_DATA_FLAG_SHARED_QUALIFIERS\n                | POLICY_DATA_FLAG_EXTRA_NODE;\n            node = level_add_node(NULL, extra, anyPolicy->parent, tree, 1);\n        }\n        if (!tree->user_policies) {\n            tree->user_policies = sk_X509_POLICY_NODE_new_null();\n            if (!tree->user_policies)\n                return 1;\n        }\n        if (!sk_X509_POLICY_NODE_push(tree->user_policies, node))\n            return 0;\n    }\n    return 1;\n}", "target": 2, "idx": 12056}
{"commit_id": "c51f6177576d7e12", "project": "cockpit-project/cockpit", "func": "static gchar *\nbase64_decode_string (const char *enc)\n{\n  gchar *dec;\n  gsize len;\n\n  if (enc == NULL)\n    return NULL;\n\n  dec = (gchar *)g_base64_decode (enc, &len);\n  if (dec)\n    dec[len] = '\\0';\n\n  return dec;\n}", "target": 2, "idx": 12057}
{"commit_id": "b5a10743258bd016c07ebf6479137fda3d172a0f", "project": "wireshark", "func": "static void\ndissect_mmse(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint8 pdut,\n\tconst char *message_type)\n{\n    guint\t offset;\n    guint8\t field = 0;\n    const char\t *strval;\n    guint\t length;\n    guint\t count;\n    guint8\t version = 0x80; /* Default to MMSE 1.0 */\n\n    /* Set up structures needed to add the protocol subtree and manage it */\n    proto_item\t*ti = NULL;\n    proto_tree\t*mmse_tree = NULL;\n\n    DebugLog((\"dissect_mmse() - START (Packet %u)\\n\", pinfo->fd->num));\n\n    /* If tree == NULL then we are only interested in protocol dissection\n     * up to reassembly and handoff to subdissectors if applicable; the\n     * columns must be set appropriately too.\n     * If tree != NULL then we also want to display the protocol tree\n     * with its fields.\n     *\n     * In the interest of speed, skip protocol tree item generation\n     * if tree is NULL.\n     */\n    if (tree) {\n\tDebugLog((\"tree != NULL\\n\"));\n\n\tti = proto_tree_add_item(tree, proto_mmse, tvb, 0, -1, ENC_NA);\n\tproto_item_append_text(ti, \", Type: %s\", message_type);\n\t/* create display subtree for the protocol */\n\tmmse_tree = proto_item_add_subtree(ti, ett_mmse);\n\n\t/* Report PDU-type\t*/\n\tproto_tree_add_uint(mmse_tree, hf_mmse_message_type, tvb, 0, 2, pdut);\n    }\n\n    offset = 2;\t\t\t/* Skip Message-Type\t*/\n\n    /*\n     * Cycle through MMS-headers\n     *\n     * NOTE - some PDUs may convey content which can be handed off\n     *        to subdissectors.\n     */\n    if (tree || pdu_has_content(pdut)) {\n\twhile ((offset < tvb_reported_length(tvb)) &&\n\t       (field = tvb_get_guint8(tvb, offset++)) != MM_CTYPE_HDR)\n\t{\n\t    DebugLog((\"\\tField =  0x%02X (offset = %u): %s\\n\",\n\t\t\tfield, offset,\n\t\t\tval_to_str(field, vals_mm_header_names,\n\t\t\t    \"Unknown MMS header 0x%02X\")));\n\t    switch (field)\n\t    {\n\t\tcase MM_TID_HDR:\t\t/* Text-string\t*/\n\t\t    length = get_text_string(tvb, offset, &strval);\n\t\t    if (tree) {\n\t\t\tproto_tree_add_string(mmse_tree, hf_mmse_transaction_id,\n\t\t\t\ttvb, offset - 1, length + 1,strval);\n\t\t    }\n\t\t    offset += length;\n\t\t    break;\n\t\tcase MM_VERSION_HDR:\t\t/* nibble-Major/nibble-minor*/\n\t\t    version = tvb_get_guint8(tvb, offset++);\n\t\t    if (tree) {\n\t\t\tguint8\t major, minor;\n\t\t\tchar    *vers_string;\n\n\t\t\tmajor = (version & 0x70) >> 4;\n\t\t\tminor = version & 0x0F;\n\t\t\tif (minor == 0x0F)\n\t\t\t    vers_string = wmem_strdup_printf(wmem_packet_scope(), \"%u\", major);\n\t\t\telse\n\t\t\t    vers_string = wmem_strdup_printf(wmem_packet_scope(), \"%u.%u\", major, minor);\n\t\t\tproto_tree_add_string(mmse_tree, hf_mmse_mms_version,\n\t\t\t\ttvb, offset - 2, 2, vers_string);\n\t\t    }\n\t\t    break;\n\t\tcase MM_BCC_HDR:\t\t/* Encoded-string-value\t*/\n\t\t    length = get_encoded_strval(tvb, offset, &strval);\n\t\t    if (tree) {\n\t\t\tproto_tree_add_string(mmse_tree, hf_mmse_bcc, tvb,\n\t\t\t\toffset - 1, length + 1, strval);\n\t\t    }\n\t\t    offset += length;\n\t\t    break;\n\t\tcase MM_CC_HDR:\t\t\t/* Encoded-string-value\t*/\n\t\t    length = get_encoded_strval(tvb, offset, &strval);\n\t\t    if (tree) {\n\t\t\tproto_tree_add_string(mmse_tree, hf_mmse_cc, tvb,\n\t\t\t\toffset - 1, length + 1, strval);\n\t\t    }\n\t\t    offset += length;\n\t\t    break;\n\t\tcase MM_CLOCATION_HDR:\t\t/* Uri-value\t\t*/\n\t\t    if (pdut == PDU_M_MBOX_DELETE_CONF) {\n\t\t\t/* General form with length */\n\t\t\tlength = tvb_get_guint8(tvb, offset);\n\t\t\tif (length == 0x1F) {\n\t\t\t    guint length_len = 0;\n\t\t\t    length = tvb_get_guintvar(tvb, offset + 1,\n\t\t\t\t    &length_len);\n\t\t\t    length += 1 + length_len;\n\t\t\t} else {\n\t\t\t    length += 1;\n\t\t\t}\n\t\t\tif (tree) {\n\t\t\t    tvb_ensure_bytes_exist(tvb, offset - 1, length + 1);\n\t\t\t    proto_tree_add_string(mmse_tree,\n\t\t\t\t    hf_mmse_content_location,\n\t\t\t\t    tvb, offset - 1, length + 1,\n\t\t\t\t    \"<Undecoded value for m-mbox-delete-conf>\");\n\t\t\t}\n\t\t    } else {\n\t\t\tlength = get_text_string(tvb, offset, &strval);\n\t\t\tif (tree) {\n\t\t\t    proto_tree_add_string(mmse_tree,\n\t\t\t\t    hf_mmse_content_location,\n\t\t\t\t    tvb, offset - 1, length + 1, strval);\n\t\t\t}\n\t\t    }\n\t\t    offset += length;\n\t\t    break;\n\t\tcase MM_DATE_HDR:\t\t/* Long-integer\t\t*/\n\t\t    {\n\t\t\tguint\t\t tval;\n\t\t\tnstime_t\t tmptime;\n\n\t\t\ttval = get_long_integer(tvb, offset, &count);\n\t\t\ttmptime.secs = tval;\n\t\t\ttmptime.nsecs = 0;\n\t\t\tif (tree) {\n\t\t\t    tvb_ensure_bytes_exist(tvb, offset - 1, count + 1);\n\t\t\t    proto_tree_add_time(mmse_tree, hf_mmse_date, tvb,\n\t\t\t\t    offset - 1, count + 1, &tmptime);\n\t\t\t}\n\t\t    }\n\t\t    offset += count;\n\t\t    break;\n\t\tcase MM_DREPORT_HDR:\t\t/* Yes|No\t\t*/\n\t\t    field = tvb_get_guint8(tvb, offset++);\n\t\t    if (tree) {\n\t\t\tproto_tree_add_uint(mmse_tree,\n\t\t\t\thf_mmse_delivery_report,\n\t\t\t\ttvb, offset - 2, 2, field);\n\t\t    }\n\t\t    break;\n\t\tcase MM_DTIME_HDR:\n\t\t    /*\n\t\t     * Value-length(Absolute-token Date-value|\n\t\t     * \t\t    Relative-token Delta-seconds-value)\n\t\t     */\n\t\t    length = get_value_length(tvb, offset, &count);\n\t\t    field = tvb_get_guint8(tvb, offset + count);\n\t\t    if (tree) {\n\t\t\tguint\t\t tval;\n\t\t\tnstime_t\t tmptime;\n\t\t\tguint\t\t cnt;\n\n\t\t\ttval =  get_long_integer(tvb, offset + count + 1, &cnt);\n\t\t\ttmptime.secs = tval;\n\t\t\ttmptime.nsecs = 0;\n\n\t\t\ttvb_ensure_bytes_exist(tvb, offset - 1, length + count + 1);\n\t\t\tif (field == 0x80)\n\t\t\t    proto_tree_add_time(mmse_tree,\n\t\t\t\t    hf_mmse_delivery_time_abs,\n\t\t\t\t    tvb, offset - 1,\n\t\t\t\t    length + count + 1, &tmptime);\n\t\t\telse\n\t\t\t    proto_tree_add_time(mmse_tree,\n\t\t\t\t    hf_mmse_delivery_time_rel,\n\t\t\t\t    tvb, offset - 1,\n\t\t\t\t    length + count + 1, &tmptime);\n\t\t    }\n\t\t    offset += length + count;\n\t\t    break;\n\t\tcase MM_EXPIRY_HDR:\n\t\t    /*\n\t\t     * Value-length(Absolute-token Date-value|\n\t\t     * \t\t    Relative-token Delta-seconds-value)\n\t\t     */\n\t\t    length = get_value_length(tvb, offset, &count);\n\t\t    field = tvb_get_guint8(tvb, offset + count);\n\t\t    if (tree) {\n\t\t\tguint\t\t tval;\n\t\t\tnstime_t\t tmptime;\n\t\t\tguint\t\t cnt;\n\n\t\t\ttval = get_long_integer(tvb, offset + count + 1, &cnt);\n\t\t\ttmptime.secs = tval;\n\t\t\ttmptime.nsecs = 0;\n\n\t\t\ttvb_ensure_bytes_exist(tvb, offset - 1, length + count + 1);\n\t\t\tif (field == 0x80)\n\t\t\t    proto_tree_add_time(mmse_tree, hf_mmse_expiry_abs,\n\t\t\t\t    tvb, offset - 1,\n\t\t\t\t    length + count + 1, &tmptime);\n\t\t\telse\n\t\t\t    proto_tree_add_time(mmse_tree, hf_mmse_expiry_rel,\n\t\t\t\t    tvb, offset - 1,\n\t\t\t\t    length + count + 1, &tmptime);\n\t\t    }\n\t\t    offset += length + count;\n\t\t    break;\n\t\tcase MM_FROM_HDR:\n\t\t    /*\n\t\t     * Value-length(Address-present-token Encoded-string-value\n\t\t     * \t\t    |Insert-address-token)\n\t\t     */\n\t\t    length = get_value_length(tvb, offset, &count);\n\t\t    if (tree) {\n\t\t\tfield = tvb_get_guint8(tvb, offset + count);\n\t\t\ttvb_ensure_bytes_exist(tvb, offset - 1, length + count + 1);\n\t\t\tif (field == 0x81) {\n\t\t\t    proto_tree_add_string(mmse_tree, hf_mmse_from, tvb,\n\t\t\t\t    offset-1, length + count + 1,\n\t\t\t\t    \"<insert address>\");\n\t\t\t} else {\n\t\t\t    (void) get_encoded_strval(tvb, offset + count + 1,\n\t\t\t\t\t\t      &strval);\n\t\t\t    proto_tree_add_string(mmse_tree, hf_mmse_from, tvb,\n\t\t\t\t    offset-1, length + count + 1, strval);\n\t\t\t}\n\t\t    }\n\t\t    offset += length + count;\n\t\t    break;\n\t\tcase MM_MCLASS_HDR:\n\t\t    /*\n\t\t     * Class-identifier|Text-string\n\t\t     */\n\t\t    field = tvb_get_guint8(tvb, offset);\n\t\t    if (field & 0x80) {\n\t\t\toffset++;\n\t\t\tif (tree) {\n\t\t\t    proto_tree_add_uint(mmse_tree,\n\t\t\t\t    hf_mmse_message_class_id,\n\t\t\t\t    tvb, offset - 2, 2, field);\n\t\t\t}\n\t\t    } else {\n\t\t\tlength = get_text_string(tvb, offset, &strval);\n\t\t\tif (tree) {\n\t\t\t    proto_tree_add_string(mmse_tree,\n\t\t\t\t    hf_mmse_message_class_str,\n\t\t\t\t    tvb, offset - 1, length + 1,\n\t\t\t\t    strval);\n\t\t\t}\n\t\t\toffset += length;\n\t\t    }\n\t\t    break;\n\t\tcase MM_MID_HDR:\t\t/* Text-string\t\t*/\n\t\t    length = get_text_string(tvb, offset, &strval);\n\t\t    if (tree) {\n\t\t\tproto_tree_add_string(mmse_tree, hf_mmse_message_id,\n\t\t\t\ttvb, offset - 1, length + 1, strval);\n\t\t    }\n\t\t    offset += length;\n\t\t    break;\n\t\tcase MM_MSIZE_HDR:\t\t/* Long-integer\t\t*/\n\t\t    length = get_long_integer(tvb, offset, &count);\n\t\t    if (tree) {\n\t\t\tproto_tree_add_uint(mmse_tree, hf_mmse_message_size,\n\t\t\t\ttvb, offset - 1, count + 1, length);\n\t\t    }\n\t\t    offset += count;\n\t\t    break;\n\t\tcase MM_PRIORITY_HDR:\t\t/* Low|Normal|High\t*/\n\t\t    field = tvb_get_guint8(tvb, offset++);\n\t\t    if (tree) {\n\t\t\tproto_tree_add_uint(mmse_tree, hf_mmse_priority, tvb,\n\t\t\t\toffset - 2, 2, field);\n\t\t    }\n\t\t    break;\n\t\tcase MM_RREPLY_HDR:\t\t/* Yes|No\t\t*/\n\t\t    field = tvb_get_guint8(tvb, offset++);\n\t\t    if (tree) {\n\t\t\tif (version == 0x80) { /* MMSE 1.0 */\n\t\t\t    proto_tree_add_uint(mmse_tree, hf_mmse_read_reply,\n\t\t\t\t    tvb, offset - 2, 2, field);\n\t\t\t} else {\n\t\t\t    proto_tree_add_uint(mmse_tree, hf_mmse_read_report,\n\t\t\t\t    tvb, offset - 2, 2, field);\n\t\t\t}\n\t\t    }\n\t\t    break;\n\t\tcase MM_RALLOWED_HDR:\t\t/* Yes|No\t\t*/\n\t\t    field = tvb_get_guint8(tvb, offset++);\n\t\t    if (tree) {\n\t\t\tproto_tree_add_uint(mmse_tree, hf_mmse_report_allowed,\n\t\t\t\ttvb, offset - 2, 2, field);\n\t\t    }\n\t\t    break;\n\t\tcase MM_RSTATUS_HDR:\n\t\t    field = tvb_get_guint8(tvb, offset++);\n\t\t    if (tree) {\n\t\t\tproto_tree_add_uint(mmse_tree, hf_mmse_response_status,\n\t\t\t\ttvb, offset - 2, 2, field);\n\t\t    }\n\t\t    break;\n\t\tcase MM_RTEXT_HDR:\t\t/* Encoded-string-value\t*/\n\t\t    if (pdut == PDU_M_MBOX_DELETE_CONF) {\n\t\t\t/* General form with length */\n\t\t\tlength = tvb_get_guint8(tvb, offset);\n\t\t\tif (length == 0x1F) {\n\t\t\t    guint length_len = 0;\n\t\t\t    length = tvb_get_guintvar(tvb, offset + 1,\n\t\t\t\t    &length_len);\n\t\t\t    length += 1 + length_len;\n\t\t\t} else {\n\t\t\t    length += 1;\n\t\t\t}\n\t\t\tif (tree) {\n\t\t\t    proto_tree_add_string(mmse_tree,\n\t\t\t\t    hf_mmse_content_location,\n\t\t\t\t    tvb, offset - 1, length + 1,\n\t\t\t\t    \"<Undecoded value for m-mbox-delete-conf>\");\n\t\t\t}\n\t\t    } else {\n    \t\t\tlength = get_encoded_strval(tvb, offset, &strval);\n\t\t\tif (tree) {\n\t\t\t    proto_tree_add_string(mmse_tree,\n\t\t\t\t    hf_mmse_response_text, tvb, offset - 1,\n\t\t\t\t    length + 1, strval);\n\t\t\t}\n\t\t    }\n\t\t    offset += length;\n\t\t    break;\n\t\tcase MM_SVISIBILITY_HDR:\t/* Hide|Show\t\t*/\n\t\t    field = tvb_get_guint8(tvb, offset++);\n\t\t    if (tree) {\n\t\t\tproto_tree_add_uint(mmse_tree,hf_mmse_sender_visibility,\n\t\t\t\ttvb, offset - 2, 2, field);\n\t\t    }\n\t\t    break;\n\t\tcase MM_STATUS_HDR:\n\t\t    field = tvb_get_guint8(tvb, offset++);\n\t\t    if (tree) {\n\t\t\tproto_tree_add_uint(mmse_tree, hf_mmse_status, tvb,\n\t\t\t\toffset - 2, 2, field);\n\t\t    }\n\t\t    break;\n\t\tcase MM_SUBJECT_HDR:\t\t/* Encoded-string-value\t*/\n\t\t    length = get_encoded_strval(tvb, offset, &strval);\n\t\t    if (tree) {\n\t\t\tproto_tree_add_string(mmse_tree, hf_mmse_subject, tvb,\n\t\t\t\toffset - 1, length + 1, strval);\n\t\t    }\n\t\t    offset += length;\n\t\t    break;\n\t\tcase MM_TO_HDR:\t\t\t/* Encoded-string-value\t*/\n\t\t    length = get_encoded_strval(tvb, offset, &strval);\n\t\t    if (tree) {\n\t\t\tproto_tree_add_string(mmse_tree, hf_mmse_to, tvb,\n\t\t\t\toffset - 1, length + 1, strval);\n\t\t    }\n\t\t    offset += length;\n\t\t    break;\n\n\t\t/*\n\t\t * MMS Encapsulation 1.1\n\t\t */\n\t\tcase MM_RETRIEVE_STATUS_HDR:\t/* Well-known-value */\n\t\t    field = tvb_get_guint8(tvb, offset++);\n\t\t    if (tree) {\n\t\t\tproto_tree_add_uint(mmse_tree, hf_mmse_retrieve_status,\n\t\t\t\ttvb, offset - 2, 2, field);\n\t\t    }\n\t\t    break;\n\t\tcase MM_RETRIEVE_TEXT_HDR:\n\t\t    if (pdut == PDU_M_MBOX_DELETE_CONF) {\n\t\t\t/* General form with length */\n\t\t\tlength = tvb_get_guint8(tvb, offset);\n\t\t\tif (length == 0x1F) {\n\t\t\t    guint length_len = 0;\n\t\t\t    length = tvb_get_guintvar(tvb, offset + 1,\n\t\t\t\t    &length_len);\n\t\t\t    length += 1 + length_len;\n\t\t\t} else {\n\t\t\t    length += 1;\n\t\t\t}\n\t\t\tif (tree) {\n\t\t\t    proto_tree_add_string(mmse_tree,\n\t\t\t\t    hf_mmse_content_location,\n\t\t\t\t    tvb, offset - 1, length + 1,\n\t\t\t\t    \"<Undecoded value for m-mbox-delete-conf>\");\n\t\t\t}\n\t\t    } else {\n\t\t\t/* Encoded-string-value */\n\t\t\tlength = get_encoded_strval(tvb, offset, &strval);\n\t\t\tif (tree) {\n\t\t\t    proto_tree_add_string(mmse_tree,\n\t\t\t\t    hf_mmse_retrieve_text, tvb, offset - 1,\n\t\t\t\t    length + 1, strval);\n\t\t\t}\n\t\t    }\n\t\t    offset += length;\n\t\t    break;\n\t\tcase MM_READ_STATUS_HDR:\t/* Well-known-value */\n\t\t    field = tvb_get_guint8(tvb, offset++);\n\t\t    if (tree) {\n\t\t\tproto_tree_add_uint(mmse_tree, hf_mmse_read_status,\n\t\t\t\ttvb, offset - 2, 2, field);\n\t\t    }\n\t\t    break;\n\t\tcase MM_REPLY_CHARGING_HDR:\t/* Well-known-value */\n\t\t    field = tvb_get_guint8(tvb, offset++);\n\t\t    if (tree) {\n\t\t\tproto_tree_add_uint(mmse_tree, hf_mmse_reply_charging,\n\t\t\t\ttvb, offset - 2, 2, field);\n\t\t    }\n\t\t    break;\n\t\tcase MM_REPLY_CHARGING_DEADLINE_HDR:\t/* Well-known-value */\n\t\t    /*\n\t\t     * Value-length(Absolute-token Date-value|\n\t\t     * \t\t    Relative-token Delta-seconds-value)\n\t\t     */\n\t\t    length = get_value_length(tvb, offset, &count);\n\t\t    field = tvb_get_guint8(tvb, offset + count);\n\t\t    if (tree) {\n\t\t\tguint\t\t tval;\n\t\t\tnstime_t\t tmptime;\n\t\t\tguint\t\t cnt;\n\n\t\t\ttval = get_long_integer(tvb, offset + count + 1, &cnt);\n\t\t\ttmptime.secs = tval;\n\t\t\ttmptime.nsecs = 0;\n\n\t\t\ttvb_ensure_bytes_exist(tvb, offset - 1, length + count + 1);\n\t\t\tif (field == 0x80)\n\t\t\t    proto_tree_add_time(mmse_tree, hf_mmse_reply_charging_deadline_abs,\n\t\t\t\t    tvb, offset - 1,\n\t\t\t\t    length + count + 1, &tmptime);\n\t\t\telse\n\t\t\t    proto_tree_add_time(mmse_tree, hf_mmse_reply_charging_deadline_rel,\n\t\t\t\t    tvb, offset - 1,\n\t\t\t\t    length + count + 1, &tmptime);\n\t\t    }\n\t\t    offset += length + count;\n\t\t    break;\n\t\tcase MM_REPLY_CHARGING_ID_HDR:\t/* Text-string */\n\t\t    length = get_text_string(tvb, offset, &strval);\n\t\t    if (tree) {\n\t\t\tproto_tree_add_string(mmse_tree,\n\t\t\t\thf_mmse_reply_charging_id,\n\t\t\t\ttvb, offset - 1, length + 1, strval);\n\t\t    }\n\t\t    offset += length;\n\t\t    break;\n\t\tcase MM_REPLY_CHARGING_SIZE_HDR:\t/* Long-integer */\n\t\t    length = get_long_integer(tvb, offset, &count);\n\t\t    if (tree) {\n\t\t\tproto_tree_add_uint(mmse_tree,\n\t\t\t\thf_mmse_reply_charging_size,\n\t\t\t\ttvb, offset - 1, count + 1, length);\n\t\t    }\n\t\t    offset += count;\n\t\t    break;\n\t\tcase MM_PREV_SENT_BY_HDR:\n\t\t    /* Value-length Integer-value Encoded-string-value */\n\t\t    length = get_value_length(tvb, offset, &count);\n\t\t    if (tree) {\n\t\t\tguint32 fwd_count, count1, count2;\n\t\t\tproto_tree *subtree = NULL;\n\t\t\tproto_item *tii = NULL;\n\t\t\t/* 1. Forwarded-count-value := Integer-value */\n\t\t\tfwd_count = get_integer_value(tvb, offset + count,\n\t\t\t    &count1);\n\t\t\t/* 2. Encoded-string-value */\n\t\t\tcount2 = get_encoded_strval(tvb,\n\t\t\t\toffset + count + count1, &strval);\n\t\t\t/* Now render the fields */\n\t\t\ttii = proto_tree_add_string_format(mmse_tree,\n\t\t\t\thf_mmse_prev_sent_by,\n\t\t\t\ttvb, offset - 1, 1 + count + length,\n\t\t\t\tstrval, \"%s (Forwarded-count=%u)\",\n\t\t\t\tformat_text(strval, strlen(strval)),\n\t\t\t\tfwd_count);\n\t\t\tsubtree = proto_item_add_subtree(tii,\n\t\t\t\tett_mmse_hdr_details);\n\t\t\tproto_tree_add_uint(subtree,\n\t\t\t\thf_mmse_prev_sent_by_fwd_count,\n\t\t\t\ttvb, offset + count, count1, fwd_count);\n\t\t\tproto_tree_add_string(subtree,\n\t\t\t\thf_mmse_prev_sent_by_address,\n\t\t\t\ttvb, offset + count + count1, count2, strval);\n\t\t    }\n\t\t    offset += length + count;\n\t\t    break;\n\t\tcase MM_PREV_SENT_DATE_HDR:\n\t\t    /* Value-Length Forwarded-count-value Date-value */\n\t\t    length = get_value_length(tvb, offset, &count);\n\t\t    if (tree) {\n\t\t\tguint32 fwd_count, count1, count2;\n\t\t\tguint\t\t tval;\n\t\t\tnstime_t\t tmptime;\n\t\t\tproto_tree *subtree = NULL;\n\t\t\tproto_item *tii = NULL;\n\t\t\t/* 1. Forwarded-count-value := Integer-value */\n\t\t\tfwd_count = get_integer_value(tvb, offset + count,\n\t\t\t    &count1);\n\t\t\t/* 2. Date-value := Long-integer */\n\t\t\ttval = get_long_integer(tvb, offset + count + count1,\n\t\t\t\t&count2);\n\t\t\ttmptime.secs = tval;\n\t\t\ttmptime.nsecs = 0;\n\t\t\tstrval = abs_time_to_ep_str(&tmptime, ABSOLUTE_TIME_LOCAL,\n\t\t\t    TRUE);\n\t\t\t/* Now render the fields */\n\t\t\ttvb_ensure_bytes_exist(tvb, offset - 1, length + count + 1);\n\t\t\ttii = proto_tree_add_string_format(mmse_tree,\n\t\t\t\thf_mmse_prev_sent_date,\n\t\t\t\ttvb, offset - 1, 1 + count + length,\n\t\t\t\tstrval, \"%s (Forwarded-count=%u)\",\n\t\t\t\tformat_text(strval, strlen(strval)),\n\t\t\t\tfwd_count);\n\t\t\tsubtree = proto_item_add_subtree(tii,\n\t\t\t\tett_mmse_hdr_details);\n\t\t\tproto_tree_add_uint(subtree,\n\t\t\t\thf_mmse_prev_sent_date_fwd_count,\n\t\t\t\ttvb, offset + count, count1, fwd_count);\n\t\t\tproto_tree_add_string(subtree,\n\t\t\t\thf_mmse_prev_sent_date_date,\n\t\t\t\ttvb, offset + count + count1, count2, strval);\n\t\t    }\n\t\t    offset += length + count;\n\t\t    break;\n\n\t\t/* MMS Encapsulation 1.2 */\n\n\t\tdefault:\n\t\t    if (field & 0x80) { /* Well-known WSP header encoding */\n\t\t\tguint8 peek = tvb_get_guint8(tvb, offset);\n\t\t\tconst char *hdr_name = val_to_str(field, vals_mm_header_names,\n\t\t\t\t\"Unknown field (0x%02x)\");\n\t\t\tconst char *str;\n\t\t\tDebugLog((\"\\t\\tUndecoded well-known header: %s\\n\",\n\t\t\t\t    hdr_name));\n\n\t\t\tif (peek & 0x80) { /* Well-known value */\n\t\t\t    length = 1;\n\t\t\t    if (tree) {\n\t\t\t\tproto_tree_add_uint_format(mmse_tree, hf_mmse_header_uint, tvb, offset - 1,\n\t\t\t\t\tlength + 1, peek,\n\t\t\t\t\t\"%s: <Well-known value 0x%02x>\"\n\t\t\t\t\t\" (not decoded)\",\n\t\t\t\t\thdr_name, peek);\n\t\t\t    }\n\t\t\t} else if ((peek == 0) || (peek >= 0x20)) { /* Text */\n\t\t\t    length = get_text_string(tvb, offset, &strval);\n\t\t\t    if (tree) {\n\t\t\t\tstr = format_text(strval, strlen(strval));\n\t\t\t\tproto_tree_add_string_format(mmse_tree, hf_mmse_header_string, tvb, offset - 1,\n\t\t\t\t\tlength + 1, str, \"%s: %s (Not decoded)\", hdr_name, str);\n\t\t\t    }\n\t\t\t} else { /* General form with length */\n\t\t\t    if (peek == 0x1F) { /* Value length in guintvar */\n\t\t\t\tguint length_len = 0;\n\t\t\t\tlength = 1 + tvb_get_guintvar(tvb, offset + 1,\n\t\t\t\t\t&length_len);\n\t\t\t\tlength += length_len;\n\t\t\t    } else { /* Value length in octet */\n\t\t\t\tlength = 1 + tvb_get_guint8(tvb, offset);\n\t\t\t    }\n\t\t\t    if (tree) {\n\t\t\t\tproto_tree_add_bytes_format(mmse_tree, hf_mmse_header_bytes, tvb, offset - 1,\n\t\t\t\t\tlength + 1, NULL, \"%s: \"\n\t\t\t\t\t\"<Value in general form> (not decoded)\",\n\t\t\t\t\thdr_name);\n\t\t\t    }\n\t\t\t}\n\t\t\toffset += length;\n\t\t    } else { /* Literal WSP header encoding */\n\t\t\tguint\t\t length2;\n\t\t\tconst char\t *strval2;\n\n\t\t\t--offset;\n\t\t\tlength = get_text_string(tvb, offset, &strval);\n\t\t\tDebugLog((\"\\t\\tUndecoded literal header: %s\\n\",\n\t\t\t\t    strval));\n\t\t\tlength2= get_text_string(tvb, offset+length, &strval2);\n\n\t\t\tif (tree) {\n\t\t\t    proto_tree_add_string_format(mmse_tree,\n\t\t\t\t    hf_mmse_ffheader, tvb, offset,\n\t\t\t\t    length + length2,\n\t\t\t\t    tvb_get_string(wmem_packet_scope(), tvb, offset,\n\t\t\t\t\t    length + length2),\n\t\t\t\t    \"%s: %s\",\n\t\t\t\t    format_text(strval, strlen(strval)),\n\t\t\t\t    format_text(strval2, strlen(strval2)));\n\t\t\t}\n\t\t\toffset += length + length2;\n\t\t    }\n\t\t    break;\n\t    }\n\t    DebugLog((\"\\tEnd(case)\\n\"));\n\t}\n\tDebugLog((\"\\tEnd(switch)\\n\"));\n\tif (field == MM_CTYPE_HDR) {\n\t    /*\n\t     * Eeehh, we're now actually back to good old WSP content-type\n\t     * encoding. Let's steal that from the WSP-dissector.\n\t     */\n\t    tvbuff_t\t*tmp_tvb;\n\t    guint\t type;\n\t    const char\t*type_str;\n\n\t    DebugLog((\"Content-Type: [from WSP dissector]\\n\"));\n\t    DebugLog((\"Calling add_content_type() in WSP dissector\\n\"));\n\t    offset = add_content_type(mmse_tree, tvb, offset, &type, &type_str);\n\t    DebugLog((\"Generating new TVB subset (offset = %u)\\n\", offset));\n\t    tmp_tvb = tvb_new_subset_remaining(tvb, offset);\n\t    DebugLog((\"Add POST data\\n\"));\n\t    add_post_data(mmse_tree, tmp_tvb, type, type_str, pinfo);\n\t    DebugLog((\"Done!\\n\"));\n\t}\n    } else {\n\tDebugLog((\"tree == NULL and PDU has no potential content\\n\"));\n    }\n\n    /* If this protocol has a sub-dissector call it here, see section 1.8 */\n    DebugLog((\"dissect_mmse() - END\\n\"));\n}", "target": 1, "idx": 12058}
{"commit_id": "f062b42c0ea8dddebdc6a152fd16152de215d614", "project": "DanBloomberg/leptonica", "func": "PIX  *\npixBlockconv(PIX     *pix,\n             l_int32  wc,\n             l_int32  hc)\n{\nl_int32  w, h, d;\nPIX     *pixs, *pixd, *pixr, *pixrc, *pixg, *pixgc, *pixb, *pixbc;\n\n    PROCNAME(\"pixBlockconv\");\n\n    if (!pix)\n        return (PIX *)ERROR_PTR(\"pix not defined\", procName, NULL);\n    if (wc <= 0 || hc <= 0)\n        return pixCopy(NULL, pix);\n    pixGetDimensions(pix, &w, &h, &d);\n    if (w < 2 * wc + 1 || h < 2 * hc + 1) {\n        L_ERROR(\"kernel is too large: w = %d, wc = %d, h = %d, hc = %d\\n\",\n                procName, w, wc, h, hc);\n        return pixCopy(NULL, pix);  /* no-op */\n    }\n\n        /* Remove colormap if necessary */\n    if ((d == 2 || d == 4 || d == 8) && pixGetColormap(pix)) {\n        L_WARNING(\"pix has colormap; removing\\n\", procName);\n        pixs = pixRemoveColormap(pix, REMOVE_CMAP_BASED_ON_SRC);\n        d = pixGetDepth(pixs);\n    } else {\n        pixs = pixClone(pix);\n    }\n\n    if (d != 8 && d != 32) {\n        pixDestroy(&pixs);\n        return (PIX *)ERROR_PTR(\"depth not 8 or 32 bpp\", procName, NULL);\n    }\n\n    if (d == 8) {\n        pixd = pixBlockconvGray(pixs, NULL, wc, hc);\n    } else { /* d == 32 */\n        pixr = pixGetRGBComponent(pixs, COLOR_RED);\n        pixrc = pixBlockconvGray(pixr, NULL, wc, hc);\n        pixDestroy(&pixr);\n        pixg = pixGetRGBComponent(pixs, COLOR_GREEN);\n        pixgc = pixBlockconvGray(pixg, NULL, wc, hc);\n        pixDestroy(&pixg);\n        pixb = pixGetRGBComponent(pixs, COLOR_BLUE);\n        pixbc = pixBlockconvGray(pixb, NULL, wc, hc);\n        pixDestroy(&pixb);\n        pixd = pixCreateRGBImage(pixrc, pixgc, pixbc);\n        pixDestroy(&pixrc);\n        pixDestroy(&pixgc);\n        pixDestroy(&pixbc);\n    }\n\n    pixDestroy(&pixs);\n    return pixd;\n}", "target": 1, "idx": 12059}
{"commit_id": "b3b7c4795ccab5be71f080774c45bbbcc75c2aaf", "project": "kernel/git/tip/tip", "func": "static ssize_t store_int_with_restart(struct device *s,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t size)\n{\n\tunsigned long old_check_interval = check_interval;\n\tssize_t ret = device_store_ulong(s, attr, buf, size);\n\n\tif (check_interval == old_check_interval)\n\t\treturn ret;\n\n\tif (check_interval < 1)\n\t\tcheck_interval = 1;\n\n\tmutex_lock(&mce_sysfs_mutex);\n\tmce_restart();\n\tmutex_unlock(&mce_sysfs_mutex);\n\n\treturn ret;\n}", "target": 1, "idx": 12060}
{"commit_id": "7c03e2cda4a584cadc398e8f6641ca9988a39d52", "project": "torvalds/linux", "func": "int cap_convert_nscap(struct dentry *dentry, const void **ivalue, size_t size)\n{\n\tstruct vfs_ns_cap_data *nscap;\n\tuid_t nsrootid;\n\tconst struct vfs_cap_data *cap = *ivalue;\n\t__u32 magic, nsmagic;\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct user_namespace *task_ns = current_user_ns(),\n\t\t*fs_ns = inode->i_sb->s_user_ns;\n\tkuid_t rootid;\n\tsize_t newsize;\n\n\tif (!*ivalue)\n\t\treturn -EINVAL;\n\tif (!validheader(size, cap))\n\t\treturn -EINVAL;\n\tif (!capable_wrt_inode_uidgid(inode, CAP_SETFCAP))\n\t\treturn -EPERM;\n\tif (size == XATTR_CAPS_SZ_2)\n\t\tif (ns_capable(inode->i_sb->s_user_ns, CAP_SETFCAP))\n\t\t\t/* user is privileged, just write the v2 */\n\t\t\treturn size;\n\n\trootid = rootid_from_xattr(*ivalue, size, task_ns);\n\tif (!uid_valid(rootid))\n\t\treturn -EINVAL;\n\n\tnsrootid = from_kuid(fs_ns, rootid);\n\tif (nsrootid == -1)\n\t\treturn -EINVAL;\n\n\tnewsize = sizeof(struct vfs_ns_cap_data);\n\tnscap = kmalloc(newsize, GFP_ATOMIC);\n\tif (!nscap)\n\t\treturn -ENOMEM;\n\tnscap->rootid = cpu_to_le32(nsrootid);\n\tnsmagic = VFS_CAP_REVISION_3;\n\tmagic = le32_to_cpu(cap->magic_etc);\n\tif (magic & VFS_CAP_FLAGS_EFFECTIVE)\n\t\tnsmagic |= VFS_CAP_FLAGS_EFFECTIVE;\n\tnscap->magic_etc = cpu_to_le32(nsmagic);\n\tmemcpy(&nscap->data, &cap->data, sizeof(__le32) * 2 * VFS_CAP_U32);\n\n\t*ivalue = nscap;\n\treturn newsize;\n}", "target": 2, "idx": 12061}
{"commit_id": "8a76fadaa39b87d740ec3346d9eccb64bde5a6af", "project": "opencv", "func": "int  RBaseStream::getPos()\n{\n    CV_Assert(isOpened());\n    int pos = validateToInt((m_current - m_start) + m_block_pos);\n    CV_Assert(pos >= m_block_pos); // overflow check\n    CV_Assert(pos >= 0); // overflow check\n    return pos;\n}", "target": 1, "idx": 12062}
{"commit_id": "c8c80c996182239ff9b05eda4db50184cf3b2e99", "project": "torvalds/linux", "func": "int amvdec_add_ts(struct amvdec_session *sess, u64 ts,\n\t\t  struct v4l2_timecode tc, u32 offset, u32 vbuf_flags)\n{\n\tstruct amvdec_timestamp *new_ts;\n\tunsigned long flags;\n\n\tnew_ts = kzalloc(sizeof(*new_ts), GFP_KERNEL);\n\tif (!new_ts)\n\t\treturn -ENOMEM;\n\n\tnew_ts->ts = ts;\n\tnew_ts->tc = tc;\n\tnew_ts->offset = offset;\n\tnew_ts->flags = vbuf_flags;\n\n\tspin_lock_irqsave(&sess->ts_spinlock, flags);\n\tlist_add_tail(&new_ts->list, &sess->timestamps);\n\tspin_unlock_irqrestore(&sess->ts_spinlock, flags);\n\treturn 0;\n}", "target": 1, "idx": 12063}
{"commit_id": "946e51f2bf37f1656916eb75bd0742ba33983c28", "project": "torvalds/linux", "func": "void __fsnotify_update_child_dentry_flags(struct inode *inode)\n{\n\tstruct dentry *alias;\n\tint watched;\n\n\tif (!S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\t/* determine if the children should tell inode about their events */\n\twatched = fsnotify_inode_watches_children(inode);\n\n\tspin_lock(&inode->i_lock);\n\t/* run all of the dentries associated with this inode.  Since this is a\n\t * directory, there damn well better only be one item on this list */\n\thlist_for_each_entry(alias, &inode->i_dentry, d_u.d_alias) {\n\t\tstruct dentry *child;\n\n\t\t/* run all of the children of the original inode and fix their\n\t\t * d_flags to indicate parental interest (their parent is the\n\t\t * original inode) */\n\t\tspin_lock(&alias->d_lock);\n\t\tlist_for_each_entry(child, &alias->d_subdirs, d_child) {\n\t\t\tif (!child->d_inode)\n\t\t\t\tcontinue;\n\n\t\t\tspin_lock_nested(&child->d_lock, DENTRY_D_LOCK_NESTED);\n\t\t\tif (watched)\n\t\t\t\tchild->d_flags |= DCACHE_FSNOTIFY_PARENT_WATCHED;\n\t\t\telse\n\t\t\t\tchild->d_flags &= ~DCACHE_FSNOTIFY_PARENT_WATCHED;\n\t\t\tspin_unlock(&child->d_lock);\n\t\t}\n\t\tspin_unlock(&alias->d_lock);\n\t}\n\tspin_unlock(&inode->i_lock);\n}", "target": 1, "idx": 12064}
{"commit_id": "a03f43645d072b7caaa9b204067095481137a2a0", "project": "wireshark", "func": "static int\ndissect_kafka_compact_string(proto_tree *tree, int hf_item, tvbuff_t *tvb, packet_info *pinfo, int offset,\n                             int *p_offset, int *p_length)\n{\n    guint len;\n    guint64 length;\n    proto_item *pi;\n\n    len = tvb_get_varint(tvb, offset, FT_VARINT_MAX_LEN, &length, ENC_VARINT_PROTOBUF);\n\n    if (len == 0) {\n        pi = proto_tree_add_item(tree, hf_item, tvb, offset, 0, ENC_NA);\n        expert_add_info(pinfo, pi, &ei_kafka_bad_varint);\n        return tvb_captured_length(tvb);\n    }\n\n    if (length == 0) {\n        proto_tree_add_string(tree, hf_item, tvb, offset, len, NULL);\n    } else {\n        proto_tree_add_string(tree, hf_item, tvb, offset, len + (gint)length - 1,\n                              kafka_tvb_get_string(pinfo->pool, tvb, offset + len, (gint)length - 1));\n    }\n\n    if (p_offset != NULL) *p_offset = offset + len;\n    if (p_length != NULL) *p_length = (gint)length - 1;\n\n    offset += len;\n    if (length > 0) {\n        offset += (gint)length - 1;\n    }\n\n    return offset;\n}", "target": 2, "idx": 12065}
{"commit_id": "6c88c71b4e4825c7bc0489306d062d017634eb88", "project": "openssl", "func": "static int dsa_priv_decode(EVP_PKEY *pkey, PKCS8_PRIV_KEY_INFO *p8)\n{\n    const unsigned char *p, *pm;\n    int pklen, pmlen;\n    int ptype;\n    void *pval;\n    ASN1_STRING *pstr;\n    X509_ALGOR *palg;\n    ASN1_INTEGER *privkey = NULL;\n    BN_CTX *ctx = NULL;\n\n    STACK_OF(ASN1_TYPE) *ndsa = NULL;\n    DSA *dsa = NULL;\n\n    int ret = 0;\n\n    if (!PKCS8_pkey_get0(NULL, &p, &pklen, &palg, p8))\n        return 0;\n    X509_ALGOR_get0(NULL, &ptype, &pval, palg);\n\n    /* Check for broken DSA PKCS#8, UGH! */\n    if (*p == (V_ASN1_SEQUENCE | V_ASN1_CONSTRUCTED)) {\n        ASN1_TYPE *t1, *t2;\n        if (!(ndsa = d2i_ASN1_SEQUENCE_ANY(NULL, &p, pklen)))\n            goto decerr;\n        if (sk_ASN1_TYPE_num(ndsa) != 2)\n            goto decerr;\n        /*-\n         * Handle Two broken types:\n         * SEQUENCE {parameters, priv_key}\n         * SEQUENCE {pub_key, priv_key}\n         */\n\n        t1 = sk_ASN1_TYPE_value(ndsa, 0);\n        t2 = sk_ASN1_TYPE_value(ndsa, 1);\n        if (t1->type == V_ASN1_SEQUENCE) {\n            p8->broken = PKCS8_EMBEDDED_PARAM;\n            pval = t1->value.ptr;\n        } else if (ptype == V_ASN1_SEQUENCE)\n            p8->broken = PKCS8_NS_DB;\n        else\n            goto decerr;\n\n        if (t2->type != V_ASN1_INTEGER)\n            goto decerr;\n\n        privkey = t2->value.integer;\n    } else {\n        const unsigned char *q = p;\n        if (!(privkey = d2i_ASN1_INTEGER(NULL, &p, pklen)))\n            goto decerr;\n        if (privkey->type == V_ASN1_NEG_INTEGER) {\n            p8->broken = PKCS8_NEG_PRIVKEY;\n            ASN1_STRING_clear_free(privkey);\n            if (!(privkey = d2i_ASN1_UINTEGER(NULL, &q, pklen)))\n                goto decerr;\n        }\n        if (ptype != V_ASN1_SEQUENCE)\n            goto decerr;\n    }\n\n    pstr = pval;\n    pm = pstr->data;\n    pmlen = pstr->length;\n    if (!(dsa = d2i_DSAparams(NULL, &pm, pmlen)))\n        goto decerr;\n    /* We have parameters now set private key */\n    if (!(dsa->priv_key = ASN1_INTEGER_to_BN(privkey, NULL))) {\n        DSAerr(DSA_F_DSA_PRIV_DECODE, DSA_R_BN_ERROR);\n        goto dsaerr;\n    }\n    /* Calculate public key */\n    if (!(dsa->pub_key = BN_new())) {\n        DSAerr(DSA_F_DSA_PRIV_DECODE, ERR_R_MALLOC_FAILURE);\n        goto dsaerr;\n    }\n    if (!(ctx = BN_CTX_new())) {\n        DSAerr(DSA_F_DSA_PRIV_DECODE, ERR_R_MALLOC_FAILURE);\n        goto dsaerr;\n    }\n\n    if (!BN_mod_exp(dsa->pub_key, dsa->g, dsa->priv_key, dsa->p, ctx)) {\n        DSAerr(DSA_F_DSA_PRIV_DECODE, DSA_R_BN_ERROR);\n        goto dsaerr;\n    }\n\n    EVP_PKEY_assign_DSA(pkey, dsa);\n\n    ret = 1;\n    goto done;\n\n decerr:\n    DSAerr(DSA_F_DSA_PRIV_DECODE, DSA_R_DECODE_ERROR);\n dsaerr:\n    DSA_free(dsa);\n done:\n    BN_CTX_free(ctx);\n    if (ndsa)\n        sk_ASN1_TYPE_pop_free(ndsa, ASN1_TYPE_free);\n    else\n        ASN1_STRING_clear_free(privkey);\n    return ret;\n}", "target": 3, "idx": 12066}
{"commit_id": "26c8b29ee12f20cf63866b87b9a3c41fab9153c5", "project": "GNOME/glib", "func": "static void\ng_keyfile_settings_backend_class_init (GKeyfileSettingsBackendClass *class)\n{\n  GObjectClass *object_class = G_OBJECT_CLASS (class);\n\n  object_class->finalize = g_keyfile_settings_backend_finalize;\n  object_class->constructed = g_keyfile_settings_backend_constructed;\n  object_class->get_property = g_keyfile_settings_backend_get_property;\n  object_class->set_property = g_keyfile_settings_backend_set_property;\n\n  class->read = g_keyfile_settings_backend_read;\n  class->write = g_keyfile_settings_backend_write;\n  class->write_tree = g_keyfile_settings_backend_write_tree;\n  class->reset = g_keyfile_settings_backend_reset;\n  class->get_writable = g_keyfile_settings_backend_get_writable;\n  class->get_permission = g_keyfile_settings_backend_get_permission;\n  /* No need to implement subscribed/unsubscribe: the only point would be to\n   * stop monitoring the file when there's no GSettings anymore, which is no\n   * big win.\n   */\n\n  /**\n   * GKeyfileSettingsBackend:filename:\n   *\n   * The location where the settings are stored on disk.\n   *\n   * Defaults to `$XDG_CONFIG_HOME/glib-2.0/settings/keyfile`.\n   */\n  g_object_class_install_property (object_class,\n                                   PROP_FILENAME,\n                                   g_param_spec_string (\"filename\",\n                                                        P_(\"Filename\"),\n                                                        P_(\"The filename\"),\n                                                        NULL,\n                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |\n                                                        G_PARAM_STATIC_STRINGS));\n\n  /**\n   * GKeyfileSettingsBackend:root-path:\n   *\n   * All settings read to or written from the backend must fall under the\n   * path given in @root_path (which must start and end with a slash and\n   * not contain two consecutive slashes).  @root_path may be \"/\".\n   * \n   * Defaults to \"/\".\n   */\n  g_object_class_install_property (object_class,\n                                   PROP_ROOT_PATH,\n                                   g_param_spec_string (\"root-path\",\n                                                        P_(\"Root path\"),\n                                                        P_(\"The root path\"),\n                                                        NULL,\n                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |\n                                                        G_PARAM_STATIC_STRINGS));\n\n  /**\n   * GKeyfileSettingsBackend:root-group:\n   *\n   * If @root_group is non-%NULL then it specifies the name of the keyfile\n   * group used for keys that are written directly below the root path.\n   *\n   * Defaults to NULL.\n   */\n  g_object_class_install_property (object_class,\n                                   PROP_ROOT_GROUP,\n                                   g_param_spec_string (\"root-group\",\n                                                        P_(\"Root group\"),\n                                                        P_(\"The root group\"),\n                                                        NULL,\n                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |\n                                                        G_PARAM_STATIC_STRINGS));\n}", "target": 2, "idx": 12067}
{"commit_id": "55ea0a085290cd2c8cdfdd960a230cbc38ba8b56", "project": "OpenIDC/mod_auth_openidc", "func": "static int oidc_request_post_preserved_restore(request_rec *r,\n\t\tconst char *original_url) {\n\n\toidc_debug(r, \"enter: original_url=%s\", original_url);\n\n\tconst char *method = \"postOnLoad\";\n\tconst char *script =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\t\t\"      function str_decode(string) {\\n\"\n\t\t\t\t\t\"        try {\\n\"\n\t\t\t\t\t\"          result = decodeURIComponent(string);\\n\"\n\t\t\t\t\t\"        } catch (e) {\\n\"\n\t\t\t\t\t\"          result =  unescape(string);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        return result;\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"      function %s() {\\n\"\n\t\t\t\t\t\"        var mod_auth_openidc_preserve_post_params = JSON.parse(sessionStorage.getItem('mod_auth_openidc_preserve_post_params'));\\n\"\n\t\t\t\t\t\"\t\t sessionStorage.removeItem('mod_auth_openidc_preserve_post_params');\\n\"\n\t\t\t\t\t\"        for (var key in mod_auth_openidc_preserve_post_params) {\\n\"\n\t\t\t\t\t\"          var input = document.createElement(\\\"input\\\");\\n\"\n\t\t\t\t\t\"          input.name = str_decode(key);\\n\"\n\t\t\t\t\t\"          input.value = str_decode(mod_auth_openidc_preserve_post_params[key]);\\n\"\n\t\t\t\t\t\"          input.type = \\\"hidden\\\";\\n\"\n\t\t\t\t\t\"          document.forms[0].appendChild(input);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        document.forms[0].action = \\\"%s\\\";\\n\"\n\t\t\t\t\t\"        document.forms[0].submit();\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"    </script>\\n\", method, oidc_util_javascript_escape(r->pool, original_url));\n\n\tconst char *body = \"    <p>Restoring...</p>\\n\"\n\t\t\t\"    <form method=\\\"post\\\"></form>\\n\";\n\n\treturn oidc_util_html_send(r, \"Restoring...\", script, method, body,\n\t\t\tOK);\n}", "target": 0, "idx": 12068}
{"commit_id": "e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3", "project": "torvalds/linux", "func": "static ssize_t ucma_write(struct file *filp, const char __user *buf,\n\t\t\t  size_t len, loff_t *pos)\n{\n\tstruct ucma_file *file = filp->private_data;\n\tstruct rdma_ucm_cmd_hdr hdr;\n\tssize_t ret;\n\n\tif (WARN_ON_ONCE(!ib_safe_file_access(filp)))\n\t\treturn -EACCES;\n\n\tif (len < sizeof(hdr))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&hdr, buf, sizeof(hdr)))\n\t\treturn -EFAULT;\n\n\tif (hdr.cmd >= ARRAY_SIZE(ucma_cmd_table))\n\t\treturn -EINVAL;\n\n\tif (hdr.in + sizeof(hdr) > len)\n\t\treturn -EINVAL;\n\n\tif (!ucma_cmd_table[hdr.cmd])\n\t\treturn -ENOSYS;\n\n\tret = ucma_cmd_table[hdr.cmd](file, buf + sizeof(hdr), hdr.in, hdr.out);\n\tif (!ret)\n\t\tret = len;\n\n\treturn ret;\n}", "target": 2, "idx": 12069}
{"commit_id": "b351eabb428c7ca85a34513c64601f437923d576", "project": "android", "func": "status_t OMXNodeInstance::updateGraphicBufferInMeta_l(\n        OMX_U32 portIndex, const sp<GraphicBuffer>& graphicBuffer,\n        OMX::buffer_id buffer, OMX_BUFFERHEADERTYPE *header) {\n    if (header == NULL) {\n        return BAD_VALUE;\n    }\n    if (portIndex != kPortIndexInput && portIndex != kPortIndexOutput) {\n        return BAD_VALUE;\n    }\n\n    BufferMeta *bufferMeta = (BufferMeta *)(header->pAppPrivate);\n    bufferMeta->setGraphicBuffer(graphicBuffer);\n    if (mMetadataType[portIndex] == kMetadataBufferTypeGrallocSource\n            && header->nAllocLen >= sizeof(VideoGrallocMetadata)) {\n        VideoGrallocMetadata &metadata = *(VideoGrallocMetadata *)(header->pBuffer);\n        metadata.eType = kMetadataBufferTypeGrallocSource;\n        metadata.pHandle = graphicBuffer == NULL ? NULL : graphicBuffer->handle;\n    } else if (mMetadataType[portIndex] == kMetadataBufferTypeANWBuffer\n            && header->nAllocLen >= sizeof(VideoNativeMetadata)) {\n        VideoNativeMetadata &metadata = *(VideoNativeMetadata *)(header->pBuffer);\n        metadata.eType = kMetadataBufferTypeANWBuffer;\n        metadata.pBuffer = graphicBuffer == NULL ? NULL : graphicBuffer->getNativeBuffer();\n        metadata.nFenceFd = -1;\n    } else {\n        CLOG_BUFFER(updateGraphicBufferInMeta, \"%s:%u, %#x bad type (%d) or size (%u)\",\n            portString(portIndex), portIndex, buffer, mMetadataType[portIndex], header->nAllocLen);\n        return BAD_VALUE;\n    }\n\n    CLOG_BUFFER(updateGraphicBufferInMeta, \"%s:%u, %#x := %p\",\n            portString(portIndex), portIndex, buffer,\n            graphicBuffer == NULL ? NULL : graphicBuffer->handle);\n    return OK;\n}", "target": 2, "idx": 12070}
